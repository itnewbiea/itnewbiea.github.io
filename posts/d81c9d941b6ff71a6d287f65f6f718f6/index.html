<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[深入学习C#]LINQ查询表达式详解(1)——基本语法、使用扩展方法和Lambda表达式简化LINQ查询 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[深入学习C#]LINQ查询表达式详解(1)——基本语法、使用扩展方法和Lambda表达式简化LINQ查询" />
<meta property="og:description" content="简介 在Git上下载源码 在工程中我们少不了要定义类或者结构去储存数据，这些数据将被临时地储存在内存中，现在我们想要对其完成一些类似于查找、过滤等等常见的任务的时候，我们该如何去做呢？ 我们可以自己写代码去对集合中的每个对象进行遍历，检查变量的每个字段看其是否满足条件。这样的故事已经发生太多次了，微软怎么可能容忍在C#里发生如此弱智的事情呢？于是，C#的设计者决定在C#中集成查询的语法，以最大限度地减少程序员书写类似代码的情况。 这也就是我们说的LINQ(Language Intergated Query)也就是语言集成查询，我们可以使用同样的语法访问不同的数据源。
为什么要使用LINQ？ 几乎所有的应用程序都需要对数据进行处理，大部分的程序都通过自定义的逻辑来完成这些操作。这样做的弊端之意就是，代码逻辑将会跟它处理的数据的结构紧密耦合在一起，如果数据结构发生了改变，也许将会带来海量的代码改动。 为了解决这个问题，C#将这些处理数据的代码都抽象出来，提供给了广大开发者。这就是LINQ。 LINQ的语法类似于关系和分层查询语言(SQL和XQuery)，我们可以在不更改查询代码的情况下对数据结构进行更改。LINQ比之SQL要更加灵活，可以处理更广泛的逻辑数据结构。当然，这些数据结构都需要实现了IEnumerable或者IEnumerable&lt; T &gt;接口，才可以进行LINQ查询。
LINQ查询表达式语法详解 表达式基础语法 LINQ查询表达式以from子句开始，以select或者group子句结束。在这两个子句之间可以跟零个或者多个from、let、where、join或者orderby子句。 每个from子句都是一个生成器，该生成器将引入一个包括序列(Sequence)的元素的范围变量(range variable)。每个let子句都会引入一个范围变量，以表示通过前一个范围变量计算的值。每个where子句都是一个筛选器，用于从结果中排除项。每个join子句都将指定的源序列键与其他序列的键进行比较，以产生匹配对。每个orderby子句都会根据指定的条件对各项进行重新排序。而最后的select或者group子句根据范围变量来指定结果的表现形式。最后可以使用into子句来连接查询，将某一查询结果的视为后续查询的生成器。
标准查询操作符 在了解LINQ查询表达式之前，怎么能不了解下它的查询操作符呢？下面列表列出了LINQ定义的标准查询操作符。 表1:LINQ标准查询操作符 标准查询操作符说明where OfType&lt;TResult&gt;筛选操作符定义了返回元素的条件。在Where查询操作符中，可以使用谓词，例如Lambda表达式定义的谓词，来返回布尔值。OfType&lt;TResult&gt;根据类型筛选元素，只返回TResult的类型元素Select 和SelectMany投射操作符用于把对象转换为另一个类型的新对象。Select和SelectMany定义了根据选择器函数选择结果值的投射。OrderBy、ThenBy 、OrderByDescending 、ThenByDescending 、Reverse排序操作符改变所返回的元素的顺序。OrderBy按升序排列，OrderByDescending按降序排列。如果第一次排序结果很类似，就可以使用ThenBy和ThenByDescending操作符进行第二次排序。Reverse反转集合中的元素顺序。GroupBy、ToLookUp组合运算符把数据放在组里面。GroupBy操作符组合有公共键的元素。ToLookUp通过创建一个一对多的字典，来组合元素。Join、GroupJoin链接运算符用于合并不直接相关的集合。使用Join操作符，可以根绝键选择器函数连接两个集合，这类似于SQL中的Join。GroupJoin操作符连接两个集合，组合其结果。Any、All、Contains如果元素序列满足指定的条件，两次操作符就返回布尔值。Any、ALll和Contains都是限定符操作符。Any确定集合中是否有确定满足谓词函数的元素。ALll确定集合中的所有元素是否都满足谓词函数。Contains检查某个元素是否在集合中。这些操作符都返回一个布尔值。Take、Skip、TakeWhile、SkipWhile分区操作符返回集合的一个子集，Take、Skip、TakeWhile、SkipWhile都是分区操作符。使用它们可以得到部分结果，使用Take必须指定要从集合中提取的元素个数；Skip跳过指定个数的元素，提取其它元素；TakeWhile提取条件为真的元素。Distinct、Union、Intersect、Except、ZipSet操作符返回一个集合。Distinct从集合中删除重复的元素，除了Distinct之外，其它的Set操作符都需要两个集合。Union返回出现在其中一个集合中的唯一元素。Intersect返回两个集合中都有的元素。Except返回值出现在一个集合中的元素。Zip是.NET 4新增的，它把两个集合合并为一个。First、FirstOrDefault、Last、LastOrDefault、ElementAt、ElementAtOrDefault、Single、SingleOrDefault这些元素操作符仅返回一个元素。First返回第一个满足条件的元素。FirstOrDefault类似于First，单如果没有找到满足条件的元素，就返回类型的默认值。Last返回最后一个满足条件的元素。ElementAt指定了要返回的元素的位置。Single只返回一个满足条件的元素。如果有多个元素都满足条件，就抛出一个异常。Count、Sum、Min、Max、Average、Aggregate聚合操作符计算集合的一个值。利用这些聚合操作符，可以计算所有值的总和、所有元素的个数、值最大和最小的元素，以及平均值等等。ToArray、ToEnumerable、ToList、ToDictionary、Cast&lt;TRsult&gt;这些转换操作符将集合转换为数组：IEnumerable、IList、IDictionary等。Empty、Range、Repeat这些生成操作符返回一个心机和。使用Empty时集合是空的；Range返回一系列数字；Repeat返回一个始终重复一个值的集合。 设置案例背景 假设我们有4个类，Customer，Order，Detail，Product，它们的定义如下：
Customer类字段字段类型CustomerIDintCountrystringNamestringCitystringOrdersList&lt;Order&gt; Order类字段字段类型OrderIDintCustomerIDintTotalintOrderDateDateTimeDetailsList&lt;Detail&gt; Detail类字段字段类型DetailIDintOrderIDintUnitPricedoubleQuantitydoubleProductIDint Product类字段字段类型ProductIDintProductNamestring 假设现在它们各自有一个List集合，分别为Customers，Orders，Details，Products。我们在这基础之上来一步步阐述LINQ查询表达式。 customers数据：
CustomerIDCityCountryNameOrders0北京中国小米orders.FindAll(c =&gt; c.CustomerID == 0)1首尔韩国三星orders.FindAll(c =&gt; c.CustomerID == 1)2加州美国苹果orders.FindAll(c =&gt; c.CustomerID == 2)3台北中国HTCorders.FindAll(c =&gt; c.CustomerID == 3)4珠海中国魅族orders.FindAll(c =&gt; c.CustomerID == 4)5北京中国华为orders.FindAll(c =&gt; c.CustomerID == 5)6上海中国索尼orders.FindAll(c =&gt; c.CustomerID == 6)7北京中国联想orders.FindAll(c =&gt; c.CustomerID == 7)8上海中国诺基亚orders.FindAll(c =&gt; c." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d81c9d941b6ff71a6d287f65f6f718f6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-06-12T15:56:47+08:00" />
<meta property="article:modified_time" content="2015-06-12T15:56:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[深入学习C#]LINQ查询表达式详解(1)——基本语法、使用扩展方法和Lambda表达式简化LINQ查询</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="简介"><font color="darkblue">简介</font></h3> 
<p>　　<a href="https://github.com/honantic/LINQ-Query">在Git上下载源码</a> <br> 　　在工程中我们少不了要定义类或者结构去储存数据，这些数据将被临时地储存在内存中，现在我们想要对其完成一些类似于查找、过滤等等常见的任务的时候，我们该如何去做呢？ <br> 　　我们可以自己写代码去对集合中的每个对象进行遍历，检查变量的每个字段看其是否满足条件。这样的故事已经发生太多次了，微软怎么可能容忍在C#里发生如此弱智的事情呢？于是，C#的设计者决定在C#中集成查询的语法，以最大限度地减少程序员书写类似代码的情况。 <br> 　　这也就是我们说的<font color="blue">LINQ(Language Intergated Query)也就是语言集成查询</font>，我们可以使用同样的语法访问不同的数据源。</p> 
<h3 id="为什么要使用linq"><font color="darkblue">为什么要使用LINQ？</font></h3> 
<p>　　几乎所有的应用程序都需要对数据进行处理，大部分的程序都通过自定义的逻辑来完成这些操作。这样做的弊端之意就是，代码逻辑将会跟它处理的数据的结构紧密耦合在一起，如果数据结构发生了改变，也许将会带来海量的代码改动。 <br> 　　为了解决这个问题，C#将这些处理数据的代码都抽象出来，提供给了广大开发者。这就是LINQ。 <br> 　　LINQ的语法类似于关系和分层查询语言(SQL和XQuery)，我们可以在不更改查询代码的情况下对数据结构进行更改。LINQ比之SQL要更加灵活，可以处理更广泛的逻辑数据结构。<font color="blue">当然，这些数据结构都需要实现了<em>IEnumerable</em>或者<em>IEnumerable&lt; T &gt;</em>接口，才可以进行LINQ查询。</font></p> 
<h3 id="linq查询表达式语法详解"><font color="darkblue">LINQ查询表达式语法详解</font></h3> 
<h4 id="表达式基础语法"><font color="salmon">表达式基础语法</font></h4> 
<p>　　<font color="blue">LINQ查询表达式以from子句开始，以select或者group子句结束。在这两个子句之间可以跟零个或者多个from、let、where、join或者orderby子句。</font> <br> 　　每个<font color="blue">from</font>子句都是一个生成器，该生成器将引入一个包括序列(Sequence)的元素的范围变量(range variable)。每个<font color="blue">let</font>子句都会引入一个范围变量，以表示通过前一个范围变量计算的值。每个<font color="blue">where</font>子句都是一个筛选器，用于从结果中排除项。每个<font color="blue">join</font>子句都将指定的源序列键与其他序列的键进行比较，以产生匹配对。每个<font color="blue">orderby</font>子句都会根据指定的条件对各项进行重新排序。而最后的<font color="blue">select</font>或者<font color="blue">group</font>子句根据范围变量来指定结果的表现形式。最后可以使用<font color="blue">into</font>子句来连接查询，将某一查询结果的视为后续查询的生成器。</p> 
<h4 id="标准查询操作符"><font color="salmon">标准查询操作符</font></h4> 
<p>　　在了解LINQ查询表达式之前，怎么能不了解下它的查询操作符呢？下面列表<font color="blue">列出了LINQ定义的标准查询操作符。</font> <br> </p> 
<center> 
 <strong>表1:LINQ标准查询操作符</strong> 
</center> 
<p></p> 
<table><thead><tr><th>标准查询操作符</th><th>说明</th></tr></thead><tbody><tr><td>where OfType<code>&lt;</code>TResult<code>&gt;</code></td><td>筛选操作符定义了返回元素的条件。在Where查询操作符中，可以使用谓词，例如Lambda表达式定义的谓词，来返回布尔值。OfType<code>&lt;</code>TResult<code>&gt;</code>根据类型筛选元素，只返回TResult的类型元素</td></tr><tr><td>Select 和SelectMany</td><td>投射操作符用于把对象转换为另一个类型的新对象。Select和SelectMany定义了根据选择器函数选择结果值的投射。</td></tr><tr><td>OrderBy、ThenBy 、OrderByDescending 、ThenByDescending 、Reverse</td><td>排序操作符改变所返回的元素的顺序。OrderBy按升序排列，OrderByDescending按降序排列。如果第一次排序结果很类似，就可以使用ThenBy和ThenByDescending操作符进行第二次排序。Reverse反转集合中的元素顺序。</td></tr><tr><td>GroupBy、ToLookUp</td><td>组合运算符把数据放在组里面。GroupBy操作符组合有公共键的元素。ToLookUp通过创建一个一对多的字典，来组合元素。</td></tr><tr><td>Join、GroupJoin</td><td>链接运算符用于合并不直接相关的集合。使用Join操作符，可以根绝键选择器函数连接两个集合，这类似于SQL中的Join。GroupJoin操作符连接两个集合，组合其结果。</td></tr><tr><td>Any、All、Contains</td><td>如果元素序列满足指定的条件，两次操作符就返回布尔值。Any、ALll和Contains都是限定符操作符。Any确定集合中是否有确定满足谓词函数的元素。ALll确定集合中的所有元素是否都满足谓词函数。Contains检查某个元素是否在集合中。这些操作符都返回一个布尔值。</td></tr><tr><td>Take、Skip、TakeWhile、SkipWhile</td><td>分区操作符返回集合的一个子集，Take、Skip、TakeWhile、SkipWhile都是分区操作符。使用它们可以得到部分结果，使用Take必须指定要从集合中提取的元素个数；Skip跳过指定个数的元素，提取其它元素；TakeWhile提取条件为真的元素。</td></tr><tr><td>Distinct、Union、Intersect、Except、Zip</td><td>Set操作符返回一个集合。Distinct从集合中删除重复的元素，除了Distinct之外，其它的Set操作符都需要两个集合。Union返回出现在其中一个集合中的唯一元素。Intersect返回两个集合中都有的元素。Except返回值出现在一个集合中的元素。Zip是.NET 4新增的，它把两个集合合并为一个。</td></tr><tr><td>First、FirstOrDefault、Last、LastOrDefault、ElementAt、ElementAtOrDefault、Single、SingleOrDefault</td><td>这些元素操作符仅返回一个元素。First返回第一个满足条件的元素。FirstOrDefault类似于First，单如果没有找到满足条件的元素，就返回类型的默认值。Last返回最后一个满足条件的元素。ElementAt指定了要返回的元素的位置。Single只返回一个满足条件的元素。如果有多个元素都满足条件，就抛出一个异常。</td></tr><tr><td>Count、Sum、Min、Max、Average、Aggregate</td><td>聚合操作符计算集合的一个值。利用这些聚合操作符，可以计算所有值的总和、所有元素的个数、值最大和最小的元素，以及平均值等等。</td></tr><tr><td>ToArray、ToEnumerable、ToList、ToDictionary、Cast<code>&lt;</code>TRsult<code>&gt;</code></td><td>这些转换操作符将集合转换为数组：IEnumerable、IList、IDictionary等。</td></tr><tr><td>Empty、Range、Repeat</td><td>这些生成操作符返回一个心机和。使用Empty时集合是空的；Range返回一系列数字；Repeat返回一个始终重复一个值的集合。</td></tr></tbody></table> 
<h4 id="设置案例背景"><font color="salmon">设置案例背景</font></h4> 
<p>　　假设我们有4个类，Customer，Order，Detail，Product，它们的定义如下：</p> 
<table><thead><tr><th>Customer类字段</th><th>字段类型</th></tr></thead><tbody><tr><td>CustomerID</td><td>int</td></tr><tr><td>Country</td><td>string</td></tr><tr><td>Name</td><td>string</td></tr><tr><td>City</td><td>string</td></tr><tr><td>Orders</td><td>List<code>&lt;</code>Order<code>&gt;</code></td></tr></tbody></table> 
<table><thead><tr><th>Order类字段</th><th>字段类型</th></tr></thead><tbody><tr><td>OrderID</td><td>int</td></tr><tr><td>CustomerID</td><td>int</td></tr><tr><td>Total</td><td>int</td></tr><tr><td>OrderDate</td><td>DateTime</td></tr><tr><td>Details</td><td>List<code>&lt;</code>Detail<code>&gt;</code></td></tr></tbody></table> 
<table><thead><tr><th>Detail类字段</th><th>字段类型</th></tr></thead><tbody><tr><td>DetailID</td><td>int</td></tr><tr><td>OrderID</td><td>int</td></tr><tr><td>UnitPrice</td><td>double</td></tr><tr><td>Quantity</td><td>double</td></tr><tr><td>ProductID</td><td>int</td></tr></tbody></table> 
<table><thead><tr><th>Product类字段</th><th>字段类型</th></tr></thead><tbody><tr><td>ProductID</td><td>int</td></tr><tr><td>ProductName</td><td>string</td></tr></tbody></table> 
<p>　　假设现在它们各自有一个List集合，分别为Customers，Orders，Details，Products。我们在这基础之上来一步步阐述LINQ查询表达式。 <br> 　　<strong>customers数据：</strong></p> 
<table><thead><tr><th>CustomerID</th><th>City</th><th>Country</th><th>Name</th><th>Orders</th></tr></thead><tbody><tr><td>0</td><td>北京</td><td>中国</td><td>小米</td><td>orders.FindAll(c =&gt; c.CustomerID == 0)</td></tr><tr><td>1</td><td>首尔</td><td>韩国</td><td>三星</td><td>orders.FindAll(c =&gt; c.CustomerID == 1)</td></tr><tr><td>2</td><td>加州</td><td>美国</td><td>苹果</td><td>orders.FindAll(c =&gt; c.CustomerID == 2)</td></tr><tr><td>3</td><td>台北</td><td>中国</td><td>HTC</td><td>orders.FindAll(c =&gt; c.CustomerID == 3)</td></tr><tr><td>4</td><td>珠海</td><td>中国</td><td>魅族</td><td>orders.FindAll(c =&gt; c.CustomerID == 4)</td></tr><tr><td>5</td><td>北京</td><td>中国</td><td>华为</td><td>orders.FindAll(c =&gt; c.CustomerID == 5)</td></tr><tr><td>6</td><td>上海</td><td>中国</td><td>索尼</td><td>orders.FindAll(c =&gt; c.CustomerID == 6)</td></tr><tr><td>7</td><td>北京</td><td>中国</td><td>联想</td><td>orders.FindAll(c =&gt; c.CustomerID == 7)</td></tr><tr><td>8</td><td>上海</td><td>中国</td><td>诺基亚</td><td>orders.FindAll(c =&gt; c.CustomerID == 8)</td></tr></tbody></table> 
<p>　　 <br> 　　<strong>orders数据：</strong></p> 
<table><thead><tr><th>OrderID</th><th>CustomerID</th><th>OrderDate</th><th>Details</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>DateTime.Now</td><td>details.FindAll(d =&gt; d.OrderID == 0)</td></tr><tr><td>1</td><td>0</td><td>DateTime.Now</td><td>details.FindAll(d =&gt; d.OrderID == 1)</td></tr><tr><td>2</td><td>1</td><td>DateTime.Now</td><td>details.FindAll(d =&gt; d.OrderID == 2)</td></tr><tr><td>3</td><td>1</td><td>DateTime.Now</td><td>details.FindAll(d =&gt; d.OrderID == 3)</td></tr><tr><td>4</td><td>2</td><td>DateTime.Now</td><td>details.FindAll(d =&gt; d.OrderID == 4)</td></tr><tr><td>5</td><td>2</td><td>DateTime.Now</td><td>details.FindAll(d =&gt; d.OrderID == 5)</td></tr><tr><td>6</td><td>3</td><td>DateTime.Now</td><td>details.FindAll(d =&gt; d.OrderID == 6)</td></tr><tr><td>7</td><td>3</td><td>DateTime.Now</td><td>details.FindAll(d =&gt; d.OrderID == 7)</td></tr><tr><td>8</td><td>4</td><td>DateTime.Now</td><td>details.FindAll(d =&gt; d.OrderID == 8)</td></tr><tr><td>9</td><td>5</td><td>DateTime.Now</td><td>details.FindAll(d =&gt; d.OrderID == 9)</td></tr><tr><td>10</td><td>6</td><td>DateTime.Now</td><td>details.FindAll(d =&gt; d.OrderID == 10)</td></tr><tr><td>11</td><td>6</td><td>DateTime.Now</td><td>details.FindAll(d =&gt; d.OrderID == 11)</td></tr><tr><td>12</td><td>7</td><td>DateTime.Now</td><td>details.FindAll(d =&gt; d.OrderID == 12)</td></tr><tr><td>13</td><td>7</td><td>DateTime.Now</td><td>details.FindAll(d =&gt; d.OrderID == 13)</td></tr><tr><td>14</td><td>8</td><td>DateTime.Now</td><td>details.FindAll(d =&gt; d.OrderID == 14)</td></tr><tr><td>15</td><td>8</td><td>DateTime.Now</td><td>details.FindAll(d =&gt; d.OrderID == 15)</td></tr><tr><td>16</td><td>8</td><td>DateTime.Now</td><td>details.FindAll(d =&gt; d.OrderID == 16)</td></tr></tbody></table> 
<p>　　 <br> 　　<strong>details数据：</strong></p> 
<table><thead><tr><th>DetailID</th><th>OrderID</th><th>ProductID</th><th>Quantity</th><th>UnitPrice</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>1000</td><td>10</td></tr><tr><td>1</td><td>1</td><td>1</td><td>2134</td><td>8</td></tr><tr><td>2</td><td>2</td><td>1</td><td>1236</td><td>9</td></tr><tr><td>3</td><td>3</td><td>0</td><td>754</td><td>7</td></tr><tr><td>4</td><td>4</td><td>2</td><td>2354</td><td>12</td></tr><tr><td>5</td><td>5</td><td>0</td><td>6985</td><td>13</td></tr><tr><td>6</td><td>6</td><td>2</td><td>4213</td><td>10</td></tr><tr><td>7</td><td>7</td><td>3</td><td>1977</td><td>10</td></tr><tr><td>8</td><td>8</td><td>2</td><td>287</td><td>6</td></tr><tr><td>9</td><td>9</td><td>5</td><td>9778</td><td>12</td></tr><tr><td>10</td><td>10</td><td>4</td><td>854</td><td>11</td></tr><tr><td>11</td><td>11</td><td>2</td><td>756</td><td>10</td></tr><tr><td>12</td><td>12</td><td>3</td><td>1000</td><td>9</td></tr><tr><td>13</td><td>13</td><td>1</td><td>786</td><td>8</td></tr><tr><td>14</td><td>14</td><td>3</td><td>346</td><td>7</td></tr><tr><td>15</td><td>15</td><td>2</td><td>576</td><td>6</td></tr><tr><td>16</td><td>16</td><td>0</td><td>782</td><td>10</td></tr></tbody></table> 
<p>　　 <br> 　　<strong>products数据：</strong></p> 
<table><thead><tr><th>ProductID</th><th>ProductName</th></tr></thead><tbody><tr><td>0</td><td>samsung</td></tr><tr><td>1</td><td>nokia</td></tr><tr><td>2</td><td>apple</td></tr><tr><td>3</td><td>xiaomi</td></tr><tr><td>4</td><td>huawei</td></tr><tr><td>5</td><td>lenovo</td></tr></tbody></table> 
<h4 id="demo查询表达式"><font color="salmon">Demo查询表达式</font></h4> 
<h5 id="条件筛选"><font color="green">条件筛选</font></h5> 
<p>　　使用where子句，可以按照一个或者多个条件筛选集合，where子句的表达式的结果类型应该是布尔类型。 <br> 　　<font color="blue">筛选在北京且名称以‘小’开头的顾客。</font></p> 
<pre class="prettyprint"><code class="language-C# hljs avrasm">var query = from c <span class="hljs-keyword">in</span> customers
            where c<span class="hljs-preprocessor">.City</span> == <span class="hljs-string">"北京"</span> &amp;&amp; c<span class="hljs-preprocessor">.Name</span><span class="hljs-preprocessor">.StartsWith</span>(<span class="hljs-string">"小"</span>)
            select c<span class="hljs-comment">;</span>
foreach (Customer item <span class="hljs-keyword">in</span> query)
{
    Console<span class="hljs-preprocessor">.WriteLine</span>(item<span class="hljs-preprocessor">.Name</span> + <span class="hljs-string">"\t\t"</span> + item<span class="hljs-preprocessor">.City</span>)<span class="hljs-comment">;</span>
}
Console<span class="hljs-preprocessor">.ReadKey</span>()<span class="hljs-comment">;</span></code></pre> 
<p>　　该LINQ查询会返回在北京而且名字以“小”开头的Customer集合。 <br> 　　输出结果： <br> 　　<img src="https://images2.imgbox.com/62/e6/wJ40qRmu_o.png" alt="这里写图片描述" title=""> <br> 　　</p> 
<h5 id="复合from子句筛选"><font color="green">复合from子句筛选</font></h5> 
<p>　　当需要根绝对象的一个成员进行筛选，而该成员本身是一个集合或者列表，就可以使用复合的from子句。 <br> 　　<font color="blue">筛选订单数量大于800的信息。</font></p> 
<pre class="prettyprint"><code class="language-C# hljs avrasm">var query = from c <span class="hljs-keyword">in</span> customers
            from o <span class="hljs-keyword">in</span> c<span class="hljs-preprocessor">.Orders</span>
            from d <span class="hljs-keyword">in</span> o<span class="hljs-preprocessor">.Details</span>
            where d<span class="hljs-preprocessor">.Quantity</span> &gt; <span class="hljs-number">800</span>
            select new { Name = c<span class="hljs-preprocessor">.Name</span>, Total = d<span class="hljs-preprocessor">.UnitPrice</span> * d<span class="hljs-preprocessor">.Quantity</span> }<span class="hljs-comment">;</span>

foreach (var item <span class="hljs-keyword">in</span> query)
{
    Console<span class="hljs-preprocessor">.WriteLine</span>(item<span class="hljs-preprocessor">.Name</span> + <span class="hljs-string">"\t\t"</span> + item<span class="hljs-preprocessor">.Total</span>)<span class="hljs-comment">;</span>
}
Console<span class="hljs-preprocessor">.ReadKey</span>()<span class="hljs-comment">;</span></code></pre> 
<p>　　输出结果： <br> 　　<img src="https://images2.imgbox.com/36/e9/A4O4WTUc_o.png" alt="这里写图片描述" title=""> <br> 　　</p> 
<h5 id="排序"><font color="green">排序</font></h5> 
<p>　　要对序列排序，需要使用orderby子句。 <br> 　　<font color="blue">按照城市、顾客ID进行排序。</font>　</p> 
<pre class="prettyprint"><code class="language-C# hljs avrasm">var query = from c <span class="hljs-keyword">in</span> customers
            from o <span class="hljs-keyword">in</span> c<span class="hljs-preprocessor">.Orders</span>
            orderby c<span class="hljs-preprocessor">.City</span>, o<span class="hljs-preprocessor">.CustomerID</span>
            select new { Name = c<span class="hljs-preprocessor">.Name</span>, City = c<span class="hljs-preprocessor">.City</span>, OrderID = o<span class="hljs-preprocessor">.OrderID</span> }<span class="hljs-comment">;</span>

foreach (var item <span class="hljs-keyword">in</span> query)
{
    Console<span class="hljs-preprocessor">.WriteLine</span>(item<span class="hljs-preprocessor">.Name</span> + <span class="hljs-string">"\t\t"</span> + item<span class="hljs-preprocessor">.City</span> + <span class="hljs-string">"\t\t"</span> + item<span class="hljs-preprocessor">.OrderID</span>)<span class="hljs-comment">;</span>
}
Console<span class="hljs-preprocessor">.ReadKey</span>()<span class="hljs-comment">;</span></code></pre> 
<p>　　输出结果： <br> 　　<img src="https://images2.imgbox.com/a7/d4/gNz2hokS_o.png" alt="这里写图片描述" title=""> <br> 　　　　</p> 
<h5 id="分组"><font color="green">分组</font></h5> 
<p>　　要根木一个关键值对查询结果分组，可以使用group子句。 <br> 　　<font color="blue">统计各个产品的订单数量。</font>　　</p> 
<pre class="prettyprint"><code class="language-C# hljs avrasm">var query = from d <span class="hljs-keyword">in</span> details
            group d by d<span class="hljs-preprocessor">.ProductID</span> into g
            orderby g<span class="hljs-preprocessor">.Count</span>(), g<span class="hljs-preprocessor">.Key</span>
            select new { Name = g<span class="hljs-preprocessor">.Key</span>, Count = g<span class="hljs-preprocessor">.Count</span>() }<span class="hljs-comment">;</span>
Console<span class="hljs-preprocessor">.WriteLine</span>(<span class="hljs-string">"ProductID"</span>+ <span class="hljs-string">"\t"</span> + <span class="hljs-string">"Count"</span>)<span class="hljs-comment">;</span>
foreach (var item <span class="hljs-keyword">in</span> query)
{
    Console<span class="hljs-preprocessor">.WriteLine</span>(item<span class="hljs-preprocessor">.Name</span> + <span class="hljs-string">"\t\t"</span> + item<span class="hljs-preprocessor">.Count</span>)<span class="hljs-comment">;</span>
}
Console<span class="hljs-preprocessor">.ReadKey</span>()<span class="hljs-comment">;</span></code></pre> 
<p>　　输出结果： <br> 　　<img src="https://images2.imgbox.com/23/74/eSvnFwTB_o.png" alt="这里写图片描述" title=""> <br> 　　</p> 
<h5 id="对嵌套的对象分组"><font color="green">对嵌套的对象分组</font></h5> 
<p>　　如果分组的对象包含嵌套的序列，则各个改变select子句创建的匿名类型。 <br> 　　<font color="blue">统计各个产品的订单数量，并输出各个订单的订货数量。</font></p> 
<pre class="prettyprint"><code class=" hljs avrasm">var query = from d <span class="hljs-keyword">in</span> details
            group d by d<span class="hljs-preprocessor">.ProductID</span> into g
            orderby g<span class="hljs-preprocessor">.Count</span>(), g<span class="hljs-preprocessor">.Key</span>
            select new
            {
                Name = g<span class="hljs-preprocessor">.Key</span>,
                Count = g<span class="hljs-preprocessor">.Count</span>(),
                Quantity =  from d <span class="hljs-keyword">in</span> g
                            orderby d<span class="hljs-preprocessor">.Quantity</span>
                            select d<span class="hljs-preprocessor">.Quantity</span>
            }<span class="hljs-comment">;</span>

Console<span class="hljs-preprocessor">.WriteLine</span>(<span class="hljs-string">"ProductID"</span>+<span class="hljs-string">"\t"</span>+<span class="hljs-string">"Count"</span>+<span class="hljs-string">"\t"</span>+<span class="hljs-string">"Quantity"</span>)<span class="hljs-comment">;</span>
foreach (var item <span class="hljs-keyword">in</span> query)
{
    Console<span class="hljs-preprocessor">.Write</span>(item<span class="hljs-preprocessor">.Name</span> + <span class="hljs-string">"\t\t"</span> + item<span class="hljs-preprocessor">.Count</span>+<span class="hljs-string">"\t"</span>)<span class="hljs-comment">;</span>
    foreach (var quantity <span class="hljs-keyword">in</span> item<span class="hljs-preprocessor">.Quantity</span>)
    {
        Console<span class="hljs-preprocessor">.Write</span>(<span class="hljs-string">"{0};"</span>, quantity)<span class="hljs-comment">;</span>
    }
    Console<span class="hljs-preprocessor">.WriteLine</span>()<span class="hljs-comment">;</span>
}
Console<span class="hljs-preprocessor">.ReadKey</span>()<span class="hljs-comment">;</span></code></pre> 
<p>　　输出结果： <br> 　　<img src="https://images2.imgbox.com/e6/79/vJCUV83h_o.png" alt="这里写图片描述" title=""> <br> 　　</p> 
<h5 id="连接"><font color="green">连接</font></h5> 
<p>　　使用join子句可以根据特定的条件合并两个数据源，但之前要获得两个要连接的列表。 <br> 　　<font color="blue">统计各个顾客和其订单的信息。</font></p> 
<pre class="prettyprint"><code class="language-C# hljs avrasm">var query = from r <span class="hljs-keyword">in</span>
                from c <span class="hljs-keyword">in</span> customers
                from o <span class="hljs-keyword">in</span> c<span class="hljs-preprocessor">.Orders</span>
                from d <span class="hljs-keyword">in</span> o<span class="hljs-preprocessor">.Details</span>
                select new { Name = c<span class="hljs-preprocessor">.Name</span>, City = c<span class="hljs-preprocessor">.City</span>, Money = d<span class="hljs-preprocessor">.Quantity</span> * d<span class="hljs-preprocessor">.UnitPrice</span>, ProductID = d<span class="hljs-preprocessor">.ProductID</span> }
            join t <span class="hljs-keyword">in</span>
                from p <span class="hljs-keyword">in</span> products
                select p
            on r<span class="hljs-preprocessor">.ProductID</span> equals t<span class="hljs-preprocessor">.ProductID</span>
            select new { Name = r<span class="hljs-preprocessor">.Name</span>, City = r<span class="hljs-preprocessor">.City</span>, Money = r<span class="hljs-preprocessor">.Money</span>, ProductName = t<span class="hljs-preprocessor">.ProductName</span> }<span class="hljs-comment">;</span>
Console<span class="hljs-preprocessor">.WriteLine</span>(<span class="hljs-string">"Name"</span> + <span class="hljs-string">"\t"</span> + <span class="hljs-string">"City"</span> + <span class="hljs-string">"\t"</span> + <span class="hljs-string">"Money"</span> + <span class="hljs-string">"\t"</span> + <span class="hljs-string">"ProductName"</span>)<span class="hljs-comment">;</span>
foreach (var item <span class="hljs-keyword">in</span> query)
{
    Console<span class="hljs-preprocessor">.WriteLine</span>(item<span class="hljs-preprocessor">.Name</span> + <span class="hljs-string">"\t"</span> + item<span class="hljs-preprocessor">.City</span> + <span class="hljs-string">"\t"</span> + item<span class="hljs-preprocessor">.Money</span> + <span class="hljs-string">"\t"</span> + item<span class="hljs-preprocessor">.ProductName</span>)<span class="hljs-comment">;</span>
}
Console<span class="hljs-preprocessor">.ReadKey</span>()<span class="hljs-comment">;</span></code></pre> 
<p>　　输出结果： <br> 　　<img src="https://images2.imgbox.com/64/e5/SjOXC2hB_o.png" alt="这里写图片描述" title=""> <br> 　　　　</p> 
<h5 id="聚合操作符"><font color="green">聚合操作符</font></h5> 
<p>　　聚合操作符（包括Count()、Sum()、Min()、Max()、Average()和Aggregate()）它们不返回一个序列，而是返回一个值。 <br> 　　Count()方法返回集合中的项数；Sum()方法汇总序列中所有数字，返回这些数字的和；Min()方法返回集合中的最小值；Max()方法返回集合中的最大值；Average()方法计算集合中的平均值；Aggregate()方法，可以传递一个Lambda表达式，该表达式对所有的值进行聚合。 <br> 　　这些方法的使用方式类似，都是直接对序列或者集合进行操作。下面用Sum()做一个示例： <br> 　　<font color="blue">统计各个顾客总共订单的订货数量。</font></p> 
<pre class="prettyprint"><code class="language-C# hljs cs"><span class="hljs-keyword">var</span> query = <span class="hljs-keyword">from</span> r <span class="hljs-keyword">in</span>
                <span class="hljs-keyword">from</span> c <span class="hljs-keyword">in</span> customers
                <span class="hljs-keyword">select</span> <span class="hljs-keyword">new</span>
                {
                    Name = c.Name,
                    OrderCount = (  <span class="hljs-keyword">from</span> o <span class="hljs-keyword">in</span> c.Orders
                                    <span class="hljs-keyword">from</span> d <span class="hljs-keyword">in</span> o.Details
                                    <span class="hljs-keyword">select</span> d.Quantity).Sum()
                }
            <span class="hljs-keyword">orderby</span> r.OrderCount
            <span class="hljs-keyword">select</span> r;</code></pre> 
<p>　　输出结果： <br> 　　<img src="https://images2.imgbox.com/a8/42/mD5Z3B3q_o.png" alt="这里写图片描述" title=""></p> 
<h3 id="使用扩展方法和lambda表达式简化linq查询"><font color="darkblue">使用扩展方法和Lambda表达式简化LINQ查询</font></h3> 
<h4 id="什么是扩展方法"><font color="salmon">什么是扩展方法</font></h4> 
<p>　　<font color="blue">当方法的第一个形参包含this修饰符的时候，该方法称为扩展方法。</font>扩展方法只能在非泛型、非嵌套的静态类中声明，扩展方法的第一个形参不能带有除this之外的其他任何修饰符，而且形参类型不能是指针类型。 <br> 　　下面的程序是一个扩展方法的示例：</p> 
<pre class="prettyprint"><code class="language-C# hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> Extensions
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HelloWorld</span>(<span class="hljs-keyword">this</span> <span class="hljs-keyword">string</span> str)
    {
        Console.WriteLine(<span class="hljs-string">"{0} 调用了：HellWorld"</span>,str);
    }
}</code></pre> 
<p>　　现在就可以调用该方法了:</p> 
<pre class="prettyprint"><code class="language-C# hljs rust">string <span class="hljs-keyword">str</span>=<span class="hljs-string">"Jay"</span>;
<span class="hljs-keyword">str</span>.HelloWorld();</code></pre> 
<p>　　我们可以看到，控制台中输出了“Jay 调用了：HelloWorld”。 <br> 　　之所以这样，是因为HelloWorld第一个参数类型为string类型，因此该方法就是string类型的扩展方法，所有的string类型变量都可以调用，而变量的内容就是传递给HelloWorld的参数。 <br> 　　上面的程序和下面的代码结果一样：</p> 
<pre class="prettyprint"><code class="language-C# hljs rust">string <span class="hljs-keyword">str</span> = <span class="hljs-string">"Jay"</span>;
Extensions.HelloWorld(<span class="hljs-keyword">str</span>);</code></pre> 
<h4 id="linq扩展方法"><font color="salmon">LINQ扩展方法</font></h4> 
<p>　　LINQ为IEnumerable<code>&lt;</code>T<code>&gt;</code>接口提供了各种扩展方法，以便用户在实现了该接口的任意集合上使用LINQ查询。表1中列出的LINQ查询操作符，都有相应的扩展方法实现。 <br> 　　使用扩展方法可以和使用LINQ查询表达式获得十分类似甚至是相同的结果，当扩展方法和Lambda表达式结合的时候，会大大简化LINQ查询。 <br> 　　</p> 
<h4 id="简化linq查询"><font color="salmon">简化LINQ查询</font></h4> 
<p>　　前面一节的<font color="blue">条件筛选LINQ表达式</font>可以简化为：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">var query = customers<span class="hljs-preprocessor">.Where</span>(c =&gt; c<span class="hljs-preprocessor">.City</span> == <span class="hljs-string">"北京"</span> &amp;&amp; c<span class="hljs-preprocessor">.Name</span><span class="hljs-preprocessor">.StartsWith</span>(<span class="hljs-string">"小"</span>))<span class="hljs-preprocessor">.Select</span>(c =&gt; c)<span class="hljs-comment">;</span></code></pre> 
<p>　　 <br> 　　前面一节的<font color="blue">条件复合from子句筛选LINQ表达式</font>可以简化为：</p> 
<pre class="prettyprint"><code class=" hljs coffeescript"><span class="hljs-reserved">var</span> query = customers.SelectMany<span class="hljs-function"><span class="hljs-params">(c =&gt; c.Orders, (c, o) =&gt; <span class="hljs-keyword">new</span> { _customer = c, _order = o, _detail = o.Details })</span>.<span class="hljs-title">SelectMany</span><span class="hljs-params">(a =&gt; a._detail, (a, b) =&gt; <span class="hljs-keyword">new</span> { _var = a, Total = b.Quantity * b.UnitPrice, Quantity = b.Quantity })</span>.<span class="hljs-title">Where</span><span class="hljs-params">(_nameless =&gt; _nameless.Quantity &gt; <span class="hljs-number">800</span>)</span>.<span class="hljs-title">Select</span><span class="hljs-params">(_annonymous =&gt; <span class="hljs-keyword">new</span> { Name = _annonymous._var._customer.Name, Total = _annonymous.Total })</span>;</span></code></pre> 
<p>　　 <br> 　　前面一节的<font color="blue">排序LINQ表达式</font>可以简化为：</p> 
<pre class="prettyprint"><code class="language-C# hljs coffeescript"><span class="hljs-reserved">var</span> query = customers.SelectMany<span class="hljs-function"><span class="hljs-params">(c =&gt; c.Orders, (c, o) =&gt; <span class="hljs-keyword">new</span> { _customer = c, _order = o })</span>.<span class="hljs-title">OrderBy</span><span class="hljs-params">(_var =&gt; _var._customer.City)</span>.<span class="hljs-title">ThenBy</span><span class="hljs-params">(_var =&gt; _var._order.CustomerID)</span>.<span class="hljs-title">Select</span><span class="hljs-params">(_annonymous =&gt; <span class="hljs-keyword">new</span> { Name = _annonymous._customer.Name, City = _annonymous._customer.City, OrderID = _annonymous._order.OrderID })</span>;</span></code></pre> 
<p>　　 <br> 　　前面一节的<font color="blue">分组LINQ表达式</font>可以简化为：</p> 
<pre class="prettyprint"><code class="language-C# hljs avrasm">var query = details<span class="hljs-preprocessor">.GroupBy</span>(d =&gt; d<span class="hljs-preprocessor">.ProductID</span>)<span class="hljs-preprocessor">.OrderBy</span>(g =&gt; g<span class="hljs-preprocessor">.Count</span>())<span class="hljs-preprocessor">.ThenBy</span>(g =&gt; g<span class="hljs-preprocessor">.Key</span>)<span class="hljs-preprocessor">.Select</span>(g =&gt; new { Name = g<span class="hljs-preprocessor">.Key</span>, Count = g<span class="hljs-preprocessor">.Count</span>() })<span class="hljs-comment">;</span></code></pre> 
<p>　　 <br> 　　前面一节的<font color="blue">对嵌套的对象分组LINQ表达式</font>可以简化为：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">var query = details<span class="hljs-preprocessor">.GroupBy</span>(d =&gt; d<span class="hljs-preprocessor">.ProductID</span>)<span class="hljs-preprocessor">.OrderBy</span>(g =&gt; g<span class="hljs-preprocessor">.Count</span>())<span class="hljs-preprocessor">.ThenBy</span>(g =&gt; g<span class="hljs-preprocessor">.Key</span>)<span class="hljs-preprocessor">.Select</span>(_var =&gt; new { Name = _var<span class="hljs-preprocessor">.Key</span>, Count = _var<span class="hljs-preprocessor">.Count</span>(), Quantity = _var<span class="hljs-preprocessor">.OrderBy</span>(d =&gt; d<span class="hljs-preprocessor">.Quantity</span>)<span class="hljs-preprocessor">.Select</span>(d =&gt; d<span class="hljs-preprocessor">.Quantity</span>) })<span class="hljs-comment">;</span></code></pre> 
<p>　　前面一节的<font color="blue">连接LINQ表达式</font>可以简化为：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">var query = customers<span class="hljs-preprocessor">.SelectMany</span>(c =&gt; c<span class="hljs-preprocessor">.Orders</span>, (c, o) =&gt; new { Name = c<span class="hljs-preprocessor">.Name</span>, City = c<span class="hljs-preprocessor">.City</span>, Details = o<span class="hljs-preprocessor">.Details</span> })<span class="hljs-preprocessor">.SelectMany</span>(_var =&gt; _var<span class="hljs-preprocessor">.Details</span>, (_var, _detail) =&gt; new { Name = _var<span class="hljs-preprocessor">.Name</span>, City = _var<span class="hljs-preprocessor">.City</span>, Money = _detail<span class="hljs-preprocessor">.Quantity</span> * _detail<span class="hljs-preprocessor">.UnitPrice</span>, ProductID = _detail<span class="hljs-preprocessor">.ProductID</span> })<span class="hljs-preprocessor">.Join</span>(products, a =&gt; a<span class="hljs-preprocessor">.ProductID</span>, b =&gt; b<span class="hljs-preprocessor">.ProductID</span>, (a, b) =&gt; new { Name = a<span class="hljs-preprocessor">.Name</span>, City = a<span class="hljs-preprocessor">.City</span>, Money = a<span class="hljs-preprocessor">.Money</span>, ProductName = b<span class="hljs-preprocessor">.ProductName</span> })<span class="hljs-comment">;</span></code></pre> 
<p>　　 <br> 　　前面一节的<font color="blue">聚合操作LINQ表达式</font>可以简化为：</p> 
<pre class="prettyprint"><code class=" hljs coffeescript"><span class="hljs-reserved">var</span> query = customers.Select<span class="hljs-function"><span class="hljs-params">(c =&gt; <span class="hljs-keyword">new</span> { Name = c.Name, OrderCount = c.Orders.SelectMany(o =&gt; o.Details, (o, d) =&gt; <span class="hljs-keyword">new</span> { _Quantity = d.Quantity }).Select(_var =&gt; _var._Quantity).Sum() })</span>.<span class="hljs-title">OrderBy</span><span class="hljs-params">(_var =&gt; _var.OrderCount)</span>;</span></code></pre> 
<p>　　以上利用扩展方法和Lambda表达式的简化后的LINQ查询代码的查询结果，与LINQ查询表达式结果完全一样，证明这样是完全可行的。 <br> 　　唯一的问题就是代码看起来比较费解了。</p> 
<h3 id="linq查询表达式简化转换原则"><font color="darkblue">LINQ查询表达式简化转换原则</font></h3> 
<p>　　看到这里我们可能要奇怪，为什么我们能用这样的方式来简化LINQ查询表达式呢？ <br> 　　关于这个问题，我们将在下一篇文章进行详细讲解。 <br> 　　欢迎大家点击阅读。 <br> 　　<strong><em>本人还是菜鸟，写的不对的地方还请各位不吝赐教！</em></strong></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aaf355378d57f55f57cab9760579a3aa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IOS已解决 在构建版本上传后, 一直处于处理状态</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0a0a7a3385bfaa6a5383b193ebeccd4f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">POJ2395 -- Prim算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>