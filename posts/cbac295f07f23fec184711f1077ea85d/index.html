<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux 图形栈一览：基于 DRM 和 Wayland - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux 图形栈一览：基于 DRM 和 Wayland" />
<meta property="og:description" content="Chen Jie 创作于 2019/11/13
by Chen Jie of TinyLab.org 2019/10/07
本文图示了基于 DRM 还有 Wayland 的 Linux 图形栈。在这个图形栈中，App 将画好的 surface，通过 Wayland 协议提交给 Compositor。Compositor 将来自各个应用的 surface(s) 合成为一帧，通过 DRM 接口最终画在 Frame Buffer，如下图所示：
图 1：Linux 图形栈概览：Wayland 协议, Compositor 和 DRM 子系统
本文接下来自下而上，先介绍 Linux Kernel 的 DRM 子系统，而后步入 Userspace 来介绍：代入两个代表性的 GUI App，情景分析其渲染过程。
通常，GUI App 是通过图形控件库来布局和放置控件。对这类普通 GUI App 渲染过程分析，是为情景分析的第一章节。
随后分析了多媒体 App：它是进一步细分的一个情景，即 App 界面一部分内容，是多媒体。
伴随情景的细分，渲染过程会经由特定的一些软件栈，故而“花开两朵，各表一枝”。
1 背景：DRM —— buffer management、Frame Buffer / plane、Kernel Mode Setting Linux DRM 子系统，主要提供了以下功能：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/cbac295f07f23fec184711f1077ea85d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-16T19:48:21+08:00" />
<meta property="article:modified_time" content="2022-03-16T19:48:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux 图形栈一览：基于 DRM 和 Wayland</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a href="http://tinylab.org/linux-graphics-stack-overview#author-footer" rel="nofollow" id="author" title="Chen Jie">Chen Jie</a> 创作于 2019/11/13</p> 
<blockquote> 
 <p>by Chen Jie of <a href="http://tinylab.org/" rel="nofollow" title="TinyLab.org">TinyLab.org</a> 2019/10/07</p> 
</blockquote> 
<p>本文图示了基于 DRM 还有 Wayland 的 Linux 图形栈。在这个图形栈中，App 将画好的 surface，通过 Wayland 协议提交给 Compositor。Compositor 将来自各个应用的 surface(s) 合成为一帧，通过 DRM 接口最终画在 <a href="https://so.csdn.net/so/search?q=Frame&amp;spm=1001.2101.3001.7020" title="Frame">Frame</a> Buffer，如下图所示：</p> 
<p><img alt="image" src="https://images2.imgbox.com/46/1a/JJE66gkW_o.png"></p> 
<p>图 1：Linux 图形栈概览：Wayland 协议, Compositor 和 DRM 子系统</p> 
<p>本文接下来自下而上，先介绍 Linux Kernel 的 DRM 子系统，而后步入 Userspace 来介绍：代入两个代表性的 GUI App，情景分析其渲染过程。</p> 
<p>通常，GUI App 是通过图形控件库来布局和放置控件。对这类普通 GUI App 渲染过程分析，是为情景分析的第一章节。</p> 
<p>随后分析了多媒体 App：它是进一步细分的一个情景，即 App 界面一部分内容，是多媒体。</p> 
<p>伴随情景的细分，渲染过程会经由特定的一些软件栈，故而“花开两朵，各表一枝”。</p> 
<h3 id="背景drm--buffer-managementframe-buffer--planekernel-mode-setting"><a name="t0"></a>1 背景：DRM —— <a href="https://so.csdn.net/so/search?q=buffer&amp;spm=1001.2101.3001.7020" title="buffer">buffer</a> management、Frame Buffer / plane、Kernel Mode Setting</h3> 
<p>Linux DRM 子系统，主要提供了以下功能：</p> 
<ul><li>操作 Frame Buffer / Plane 接口</li><li>Buffer 管理</li><li>模式设定（分辨率、色深、刷新率等）</li></ul> 
<p><img alt="image" src="https://images2.imgbox.com/b9/61/mohtzfyJ_o.png"></p> 
<p>图 2：Linux DRM 中的概念：Frame Buffer，Plane，CRTC，Encoder 以及 Connector</p> 
<blockquote> 
 <p>简单地理解， DRM 功能上相当于 HW Composer + gralloc，只不过 “接口” 是 Linux Kernel 导出的，而不是 HAL。</p> 
 <p>换句话说，HW Composer 和 gralloc 可以映射到 DRM 实现。事实上，一些平台的 Android BSP 正是这样做的。</p> 
 <p>下图对比了两者：</p> 
 <p><img alt="image" src="https://images2.imgbox.com/c8/34/AJxANWdw_o.png"></p> 
</blockquote> 
<p>其中 Compositor 负责将合成后的帧，写入 Frame Buffer。下面聚焦在 Compositor 及其以上。</p> 
<h3 id="linux-图形栈一览"><a name="t1"></a>2 Linux 图形栈：一览</h3> 
<p>下图是一个 Linux 发行版图形栈的示意。其中，会话服务中：</p> 
<ul><li>Mutter 是 GNOME 下的 Compositor，实现了 Wayland 协议。它主要用到了源自 Linux DRM 子系统的功能。</li><li>而图示中 <a href="https://pipewire.org/" rel="nofollow" title="PipeWire">PipeWire</a> 出现，相当时髦。PipeWire 将替代 PulseAudio（故而用到了 Linux ALSA 子系统），但它更主要目的，是作为一个 Audio / Video IO 的守护，后文还将作进一步介绍。</li></ul> 
<p><img alt="image" src="https://images2.imgbox.com/8a/25/X5ud7koP_o.png"></p> 
<p>图 3：Linux 图形栈一览，相关的 Kernel 子系统，用户会话中的服务，以及典型应用。</p> 
<p>上图中，展示了两类典型应用，普通 GUI 应用，还有多媒体应用。下文就此分别展开描述。</p> 
<h4 id="普通-gui-app渲染过程"><a name="t2"></a>2.1 普通 GUI App：渲染过程</h4> 
<p><img alt="image" src="https://images2.imgbox.com/63/b9/TG2nkoLB_o.png"></p> 
<p>图 4：由 Graphics Widgets 所撑起的普通 GUI 应用，其工作流程</p> 
<p>在普通 GUI 应用中，界面是由 Graphics Widgets （例如 <a href="https://www.gtk.org/" rel="nofollow" title="Gtk+">Gtk+</a>、<a href="https://www.qt.io/" rel="nofollow" title="Qt">Qt</a>）布局，进而生成 Scene Graph（SG），通过遍历 SG 渲染在 surface。最后，这个 surface （或曰 buffer），提交给 Mutter 来进行合成。</p> 
<p>这里展开两个细节，其一，遍历 SG 进行渲染时，通常是通过 <a href="https://www.cairographics.org/" rel="nofollow" title="Cario">Cario</a> 或 <a href="https://skia.org/" rel="nofollow" title="Skia">Skia</a> 等绘图工具：</p> 
<ul><li>绘图工具常有多实现后端。其中 GPU 加速后端，常见基于 OpenGL ES（或其后继者 Vukan，此处暂且不提）</li><li>OpenGL ES 是个 API 的 SPEC，基于开源的 <em>实现方案</em> 常由 Mesa 提供。相关 buffer 分配，最终落实在「通过 DRM 接口，分配 GEM Buffer Object」</li></ul> 
<blockquote> 
 <p>以 intel i915 芯片为例，背后的 GEM BO 分配如下述伪调用栈所示：</p> 
 <pre><code> </code></pre> 
 <ol><li><code>/* 代码摘录 Mesa：dri2/platform_wayland.c */</code></li><li><code>get_back_bo()</code></li><li><code>|-&gt; gbm_bo_create() /* Wrapper 函数，主要调用 gbm_dri_bo_create */</code></li><li><code>|-&gt; intelImageExtension.createImage /* 函数指针：指向 intel_create_image() */</code></li><li><code>|-&gt; drm_intel_bo_alloc_tiled() /* libdrm */</code></li><li><code>|-&gt; bo_alloc_tiled /* 函数指针：指向 drm_intel_gem_bo_alloc_tiled */</code></li><li><code>|-&gt; drm_intel_gem_bo_alloc_internal()</code></li><li><code>|-&gt; drmIoctl(drm_fd, DRM_IOCTL_I915_GEM_CREATE, &amp;create)</code></li></ol> 
</blockquote> 
<p>展开细节其二：App 提交 buffer 到最终显示在屏幕的过程，一喻以蔽之，可以比喻成网购：</p> 
<ul><li>在当天 <em>截止时间</em> 之前下单的，当天发货</li><li>错过了，则明天发货</li></ul> 
<p><img alt="image" src="https://images2.imgbox.com/ae/79/YrADNrKv_o.png"></p> 
<p>图 5：Weston 周期性更新 Frame Buffer 示意（Weston 是 Wayland Server 的参考实现）</p> 
<blockquote> 
 <p>在一些操作系统上，例如 Fuchsia，还有一种统一渲染的思路，即 App 通过 <em>另一协议</em>，直接更新远程的 Scene Graph。</p> 
 <p>这样，最终渲染动作统一在一进程，如下图：</p> 
 <p><img alt="image" src="https://images2.imgbox.com/75/0c/dNtsxRtV_o.png"></p> 
 <p>相应的好处，比如有：</p> 
 <ol><li>更平滑的动画效果。动画是若干个状态间的渐变插值，由于 SG 统一在一进程，故而对其 Node(s) 进行渐变插值，效果更为平滑。</li><li>可以将多个应用 UI 的局部，组合起来，看起来像一个应用。</li></ol> 
 <p>统一渲染看似回归了 XServer 时代的 indirect rendering，但是围绕 SG 来展开的。从 MVC 视角来说，SG 是 View 范畴的。统一渲染将各应用 View 范畴的一部分，归总在一个进程处理。</p> 
 <p>更进一步想，可以将各应用 Model 范畴的一部分，归总在某个进程处理（例如，验证输入参数的一致性）。换言之，输入处理的一部分，统一在某处，从而平滑一部分的交互过程。对这个脑洞感兴趣的朋友，可参见本站「<a href="http://tinylab.org/quantized-UI/" rel="nofollow" title="量子化的 UI">量子化的 UI</a>」一文。</p> 
 <p>另一方面，UI 中输入参数一致性的约束逻辑，不仅图形 UI 中用到，在<a href="http://tinylab.org/brain-wide-open-hole-doing-a-ratio-table-screen-big-than-phone-portable-mobile-devices/#%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E9%A3%8E%E6%A0%BC%E7%9A%84%E4%BA%A4%E4%BA%92%E7%95%8C%E9%9D%A2" rel="nofollow" title="以语音等对话为主的新兴 UI">以语音等对话为主的新兴 UI</a> 中，也能用到。</p> 
</blockquote> 
<h4 id="多媒体-app渲染过程"><a name="t3"></a>2.2 多媒体 App：渲染过程</h4> 
<p><img alt="image" src="https://images2.imgbox.com/7a/27/0A2vaQLZ_o.png"></p> 
<p>图 6：多媒体应用中，相关的会话服务 PipeWire、Mutter 以及各间的数据流</p> 
<p>上图中，（相机）多媒体应用从 PipeWire 获得 Camera 的输入帧，经由应用内的多媒体管线处理，最后提交到 Compositor（Mutter），显示于屏幕。</p> 
<p>上图中的 PipeWire 作为 Audio / Video IO 守护，其主要功能有：</p> 
<ul><li>Audio record / playback 
  <ul><li>基于 ALSA 子系统</li><li>其中 playback 包含了多个音频流的混音（Mixing）逻辑</li><li>作为 PulseAudio 的替代</li></ul></li><li>Video capture：通过 V4L2 子系统，获得 Camera 的输入画面</li><li>Screen capture：通过 Mutter 的 plugin，获得截屏</li><li>其他</li></ul> 
<p>作为 Audio / Video IO 守护，PipeWire 还可以进行：</p> 
<ul><li>策略化的访问控制</li><li>简化 buffer 共享，避免不必要的拷贝</li><li>对流经数据进行处理，特别是利用硬件（例如 DSP）进行处理 
  <ul><li>处理数据的 Processing Graph 可由 Client 来构建</li></ul></li></ul> 
<p>下图示意了 PipeWire 的内部数据流，<a href="https://archive.fosdem.org/2019/schedule/event/pipewire/attachments/slides/2826/export/events/attachments/pipewire/slides/2826/PipeWire.pdf" rel="nofollow" title="取自 FOSDEM 2019 上，PipeWire 作者 Wim 的幻灯">取自 FOSDEM 2019 上，PipeWire 作者 Wim 的幻灯</a></p> 
<p><img alt="image" src="https://images2.imgbox.com/51/96/mTujyMsT_o.png"></p> 
<p>图 7：PipeWire 的内部数据流一览</p> 
<h3 id="附录"><a name="t4"></a>3 附录</h3> 
<p>在现代的移动设备上，通常借由 OpenGL ES（及其后继者 Vulkan，此处暂且不提）来进行图形渲染。而 OpenGL ES 和 Platform OS 上的 Window System 的交互，是通过 EGL 来隔开的。</p> 
<p>在本文讨论的开源图形栈中 EGL 的实现：</p> 
<ul><li>对于 App：EGL 基于 Wayland （以及 libgbm）来实现接口</li><li>对于 Compositor，EGL 基于 DRM（以及 DRM 进一步封装，如 libgbm） 来实现接口</li></ul> 
<p>下表列举 OpenGL ES 和 EGL 相关的一些扩展：</p> 
<table><thead><tr><th>OpenGL ES 扩展</th><th>相关函数</th></tr></thead><tbody><tr><td><a href="https://www.khronos.org/registry/OpenGL/extensions/OES/OES_EGL_image_external.txt" rel="nofollow" title="GL_OES_EGL_image_external">GL_OES_EGL_image_external</a></td><td>glEGLImageTargetTexture2DOES()</td></tr><tr><td><a href="https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_format_BGRA8888.txt" rel="nofollow" title="GL_EXT_texture_format_BGRA8888">GL_EXT_texture_format_BGRA8888</a></td><td></td></tr><tr><td><a href="https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_read_format_bgra.txt" rel="nofollow" title="GL_EXT_read_format_bgra">GL_EXT_read_format_bgra</a></td><td></td></tr><tr><td><a href="https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_unpack_subimage.txt" rel="nofollow" title="GL_EXT_unpack_subimage">GL_EXT_unpack_subimage</a></td><td></td></tr></tbody></table> 
<table><thead><tr><th>EGL 扩展</th><th>相关函数</th></tr></thead><tbody><tr><td></td><td>eglCreateImageKHR()<br> eglDestroyImageKHR()</td></tr><tr><td><a href="https://cgit.freedesktop.org/mesa/mesa/tree/docs/specs/WL_bind_wayland_display.spec" rel="nofollow" title="EGL_WL_bind_wayland_display">EGL_WL_bind_wayland_display</a></td><td>eglBindWaylandDisplayWL()<br> eglUnbindWaylandDisplayWL()<br> eglQueryWaylandBufferWL()</td></tr><tr><td><a href="https://www.khronos.org/registry/EGL/extensions/EXT/EGL_EXT_buffer_age.txt" rel="nofollow" title="EGL_EXT_buffer_age">EGL_EXT_buffer_age</a></td><td></td></tr><tr><td><a href="https://www.khronos.org/registry/EGL/extensions/EXT/EGL_EXT_swap_buffers_with_damage.txt" rel="nofollow" title="EGL_EXT_swap_buffers_with_damage">EGL_EXT_swap_buffers_with_damage</a></td><td>eglSwapBuffersWithDamageEXT()</td></tr><tr><td><a href="https://www.khronos.org/registry/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import.txt" rel="nofollow" title="EGL_EXT_image_dma_buf_import">EGL_EXT_image_dma_buf_import</a></td><td></td></tr><tr><td><a href="https://www.khronos.org/registry/EGL/extensions/EXT/EGL_EXT_platform_base.txt" rel="nofollow" title="EGL_EXT_platform_base">EGL_EXT_platform_base</a></td><td>eglCreatePlatformWindowSurfaceEXT()</td></tr></tbody></table> 
<p>以及更底层的 Wayland、DRM 中相关特性：</p> 
<p><img alt="image" src="https://images2.imgbox.com/11/11/18DDQQBe_o.png"></p> 
<p>下面就正文提及场景，补充一些代码级的流程示意</p> 
<h4 id="wayland-client-和-server-如何提交-buffer"><a name="t5"></a>3.1 Wayland Client 和 Server 如何提交 buffer?</h4> 
<p>Client 通过 <code>eglSwapBuffersWithDamageEXT()</code> 将画好的 buffer，提交给 Compositor。</p> 
<p>Server 通过同一 API 将合成好的一帧，写入 Frame Buffer。其中，Client 和 Compositor 加载了不同的 EGL 实现，如下图所示：</p> 
<p><img alt="image" src="https://images2.imgbox.com/ad/54/6mQ73TTy_o.png"></p> 
<h4 id="wayland-client-和-server-各有哪些初始化步骤"><a name="t6"></a>3.2 Wayland Client 和 Server 各有哪些初始化步骤？</h4> 
<p>（同上，Wayland Server 端，以其参考实现 Weston 来说明）</p> 
<ul><li>获取 Display，初始化并进行配置</li></ul> 
<p><img alt="image" src="https://images2.imgbox.com/e3/21/hqiqIbMm_o.png"></p> 
<p></p> 
<ul><li>获取 Surface，并将 Display，Surface 以及 Context 绑定在当前的渲染线程上。</li></ul> 
<p><img alt="image" src="https://images2.imgbox.com/0d/00/WW6QqEXR_o.png"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9d590812f81d3e88deb4a3c0699da23a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Nginx基础</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7345f98b527344fb238331851070b5c2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">OA系统--login</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>