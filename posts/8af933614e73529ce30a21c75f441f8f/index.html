<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL数据库中的事务隔离与其他并发事务的讲解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySQL数据库中的事务隔离与其他并发事务的讲解" />
<meta property="og:description" content="在MySQL中，事务隔离级别定义了事务与其他并发事务互相看见对方改变的数据的情况。SQL标准规定了四种隔离级别，具体如下：
序列化（SERIALIZABLE）：事务串行执行，即每个事务必须等待上一个事务结束后才能开始执行。这确保了事务之间不会互相干扰，但是也导致了并发性能的降低。可重复读（REPEATABLE READ）：在同一个事务内，多次读取同样数据时，结果都是一致的，无论其他事务是否已经修改过这些数据。但是，在事务提交之后，其他事务可以改变数据，这时本事务看到的是修改前的数据。提交读（READ COMMITTED）：只能看见已经提交的其他事务所做的修改。换句话说，一个事务开始时，只能看见开始之前已经提交的所有事务所做的修改。本事务内所做的修改在其他事务提交之前是不可见的。未提交读（READ UNCOMMITTED）：能看见其他事务做出的未提交的修改。这意味着本事务可能读取到脏数据，即尚未提交的数据。 脏读(dirty read): 当一个事务读取另一个事务尚未提交的修改时，产生脏读；
不可重复读(nonrepeatable read): 同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生不可重复读；
幻读(phanton read): 同一查询在统一事务中多次进行，有无其他提交事务所做的插入操作，每次返回不同的结果集，此时发生幻读。
四种隔离级别 隔离级别脏读不可重复读幻读加锁读Read uncommitted 读未提交√√√不加锁Read committed 读已提交×√√不加锁Repeatable read 可重复读 ×××加锁Serializable 可串行化×××加锁 #四种隔离别 -- Read uncommitted 读未提交 脏读 不可重复读 幻读 加锁读 -- Read committed 读已提交 不可重复读 幻读 不加锁 -- Repeatable read 可重复读	不加锁 -- Serializable 可串行化	加锁 -- 查看当前会话隔离级别 SELECT @@tx_isolation -- 查看系统当前隔离级别 SELECT @@global.tx_isolation -- 设置当前会话隔离级别 SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; -- 设置系统当前隔离级别 -- set session transaction isolation level [隔离级别名] 具体实例演示：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8af933614e73529ce30a21c75f441f8f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-12T19:04:32+08:00" />
<meta property="article:modified_time" content="2023-11-12T19:04:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL数据库中的事务隔离与其他并发事务的讲解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在MySQL中，事务隔离级别定义了事务与其他并发事务互相看见对方改变的数据的情况。SQL标准规定了<strong>四种隔离级别</strong>，具体如下：</p> 
<ul><li>序列化（SERIALIZABLE）：事务串行执行，即每个事务必须等待上一个事务结束后才能开始执行。这确保了事务之间不会互相干扰，但是也导致了并发性能的降低。</li><li>可重复读（REPEATABLE READ）：在同一个事务内，多次读取同样数据时，结果都是一致的，无论其他事务是否已经修改过这些数据。但是，在事务提交之后，其他事务可以改变数据，这时本事务看到的是修改前的数据。</li><li>提交读（READ COMMITTED）：只能看见已经提交的其他事务所做的修改。换句话说，一个事务开始时，只能看见开始之前已经提交的所有事务所做的修改。本事务内所做的修改在其他事务提交之前是不可见的。</li><li>未提交读（READ UNCOMMITTED）：能看见其他事务做出的未提交的修改。这意味着本事务可能读取到脏数据，即尚未提交的数据。</li></ul> 
<p><strong> 脏读(dirty read)</strong>: 当一个事务读取另一个事务尚<strong>未提交</strong>的修改时，产生脏读；</p> 
<p><strong>不可重复读(nonrepeatable read)</strong>: 同一查询在同一事务中多次进行，由于其他<strong>提交</strong>事务所做的<strong>修改或删除</strong>，每次返回不同的结果集，此时发生不可重复读；</p> 
<p><strong>幻读(phanton read)</strong>: 同一查询在统一事务中多次进行，有无其他<strong>提交</strong>事务所做的<strong>插入</strong>操作，每次返回不同的结果集，此时发生幻读。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>
   四种隔离级别 
 </caption><tbody><tr><td>隔离级别</td><td>脏读</td><td>不可重复读</td><td>幻读</td><td>加锁读</td></tr><tr><td>Read uncommitted 读未提交</td><td>√</td><td>√</td><td>√</td><td>不加锁</td></tr><tr><td>Read committed   读已提交</td><td>×</td><td>√</td><td>√</td><td>不加锁</td></tr><tr><td>Repeatable read  可重复读    </td><td>×</td><td>×</td><td>×</td><td>加锁</td></tr><tr><td>Serializable     可串行化</td><td>×</td><td>×</td><td>×</td><td>加锁</td></tr></tbody></table> 
<p></p> 
<pre><code class="language-sql">
#四种隔离别
-- Read uncommitted 读未提交 脏读 不可重复读 幻读 加锁读
-- Read committed   读已提交 	  不可重复读 幻读 不加锁
-- Repeatable read  可重复读			  不加锁
-- Serializable     可串行化			   加锁

-- 查看当前会话隔离级别
SELECT @@tx_isolation
-- 查看系统当前隔离级别
SELECT @@global.tx_isolation
-- 设置当前会话隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
-- 设置系统当前隔离级别
-- set session transaction isolation level [隔离级别名]</code></pre> 
<p>具体实例演示：</p> 
<pre><code class="language-sql">-- 演示MySQL的事务隔离级别
-- 1.开了两个控制台
-- 2.查看当前MySQL的隔离级别
SELECT @@tx_isolation;

# mysql&gt; SELECT @@tx_isolation;
-- +-----------------+
-- | @@tx_isolation  |
-- +-----------------+
-- | REPEATABLE-READ |
-- +-----------------+

-- 3.把其中一个控制台的隔离级别设置成 Read uncommitted</code></pre> 
<p>注意事项：将两表同时开启事务 start trancaction；</p> 
<p>如果在A未提交时，B控制台读到，A控制台未提交时的数据，证明脏读；</p> 
<p>如果在A提交后，B控制台读到，A控制台修改删除的数据，证明不可重复读；</p> 
<p>如果在A提交后，B控制台读到，A控制台插入的数据，证明幻读；</p> 
<p>ps：正常情况下，B控制台应该读取的是，当时B控制台开启时的数据，并不是实时更新的数据！</p> 
<h5>1.证明 Read uncommitted 读未提交的脏读、不可重复读、幻读</h5> 
<p><img alt="041e89f3a10d42438995ed390c9b6f34.png" src="https://images2.imgbox.com/a3/65/sa7yFdiH_o.png"><img alt="3d477495936d4877b274df1761f4d408.png" height="145" src="https://images2.imgbox.com/c0/b9/nhYrV4xM_o.png" width="300"></p> 
<p><img alt="3e9a6fef32434dbb8a0243935664a81a.png" height="206" src="https://images2.imgbox.com/85/d2/IzudJoLs_o.png" width="307"><img alt="ca4679869fd44a9f9885f95b0b764a58.png" height="204" src="https://images2.imgbox.com/b8/1c/rrZy22lt_o.png" width="348"></p> 
<p> </p> 
<p class="img-center"><img alt="7017fb09f3e24bf8bd67965a86862aa6.png" src="https://images2.imgbox.com/1c/0c/BN6BEdSv_o.png"></p> 
<p>这是另一个控制台，也可以同步查到数据 </p> 
<p><img alt="e13266be94f24cadb8422952400f0e8c.png" height="340" src="https://images2.imgbox.com/b9/ad/HH9BdgTp_o.png" width="261"></p> 
<p><img alt="c09631546ad34b19b099fd5ef9897903.png" src="https://images2.imgbox.com/de/7d/MclqsXOy_o.png"><img alt="fd3d89109d8644349be25b2d84627a73.png" src="https://images2.imgbox.com/da/c9/OXjDJO5x_o.png"></p> 
<p> 在A控制未提交时，以及提交后，B控制台都能查询到相关的数据改变，则证明以上；</p> 
<p></p> 
<h5>2.证明 Read committed 不可重复读、幻读</h5> 
<p>把B控制台改为read committed；</p> 
<p><img alt="a2cd22fc118a4c118d4443f4b12bad4a.png" src="https://images2.imgbox.com/4f/fa/VstjkEhp_o.png"></p> 
<p><img alt="d458ddb1c54e4351b4e4be66148977c5.png" src="https://images2.imgbox.com/22/a3/BWPeZ4kn_o.png"> <img alt="0095a4ba31bc4ecab3c8ffedb56cbc38.png" src="https://images2.imgbox.com/8e/cb/F5m92qxZ_o.png"></p> 
<p> 当A控制台再次插入数据且未提交时，B控制台查不到数据；脏读无；</p> 
<p><img alt="710525e10383436ba1dcdc1b727d8af3.png" src="https://images2.imgbox.com/ab/9b/Drtllsqx_o.png"><img alt="1bfa6e43a1f14a608ef6402bcf6e8319.png" src="https://images2.imgbox.com/1d/0a/Yxw21K9G_o.png"></p> 
<p> 当提交后B控制台查到数据，此时为不可重复读和幻读；</p> 
<h5>3.证明 Repeatable read 不存在 脏读、不可重复读、幻读</h5> 
<p>初始状态：</p> 
<p><img alt="" height="211" src="https://images2.imgbox.com/a2/b9/N084DQDd_o.png" width="307"><img alt="" height="298" src="https://images2.imgbox.com/d4/cc/mTpnrxCe_o.png" width="242"></p> 
<p>现在进行更改数据：</p> 
<p> <img alt="" height="227" src="https://images2.imgbox.com/6a/2b/fZrMlwv5_o.png" width="370"><img alt="" height="228" src="https://images2.imgbox.com/02/ec/3xu1PvFF_o.png" width="298"></p> 
<p> 当A控制台未提交时，B控制台查不到数据变化</p> 
<p><img alt="" height="63" src="https://images2.imgbox.com/6a/b9/BdCwuoAq_o.png" width="366"><img alt="" height="205" src="https://images2.imgbox.com/9a/7a/Nacvz7gh_o.png" width="243"></p> 
<p> 当A控制台提交后，B控制台依旧查不到数据变化，说明，脏读、不可重复度、幻读都不存在；</p> 
<h5>4.证明 Serializable 不存在 脏读、不可重复读、幻读，且是加锁的</h5> 
<p><img alt="" height="204" src="https://images2.imgbox.com/8f/7c/VG7ppXE5_o.png" width="227"><img alt="" height="207" src="https://images2.imgbox.com/5e/00/grkMz3Vd_o.png" width="382"></p> 
<p> 同时开启两个事务，将B控制台设置为serializable;</p> 
<p><img alt="" height="243" src="https://images2.imgbox.com/2a/11/gJ4IIl6q_o.png" width="361"><img alt="" height="127" src="https://images2.imgbox.com/b8/9d/SixDjJH4_o.png" width="301"></p> 
<p> 在A控制台进行数据操作，输入数据以及更改数据，在B控制台进行查询时，光标一直在闪烁中。此处就体现了锁，因为A事务正在占用该表，B控制台不能对其进行查看以及相关操作。</p> 
<p> 在B控制台进行了一会的等待后，出现了相关的语句，意思时，锁等待超时，尝试重启事务。</p> 
<p class="img-center"><img alt="" height="82" src="https://images2.imgbox.com/36/f9/350epxwh_o.png" width="592"></p> 
<p> 在A控制台，提交事务后，B控制台才能对该表进行相关的操作。</p> 
<p> <img alt="" height="97" src="https://images2.imgbox.com/72/48/rz6a6myF_o.png" width="374"><img alt="" height="194" src="https://images2.imgbox.com/cd/d5/z23HqGyA_o.png" width="234"></p> 
<p> 此处也可以证明了，Serializable，不存在脏读、不可重复度、幻读，且是加锁。</p> 
<p><strong>小结：</strong></p> 
<ol><li><strong>正常情况下，当时开启一个事务时，两个事务不可以相互访问。</strong>因为，此时事务<strong>还未提交</strong>，操作者，可能对数据进行修改，如果B事务访问正在修改的A事务，读到临时数据，此时为<strong><span style="color:#956fe7;">脏读</span>。</strong></li><li>当A、B事务同时开启时，A事务<strong>修改，删除 提交</strong>后，B事务依旧不能访问A事务对该表进行的操作。因为，正常情况下，A、B事务相互独立，不应该收到对方的影响。此时，为<span style="color:#956fe7;"><strong>不可重复度</strong></span>。</li><li>当A、B事务同时开启时，A事务<strong>插入操作 提交</strong>后，B事务依旧不能访问A事务对该表进行的操作。因为，正常情况下，A、B事务相互独立，不应该收到对方的影响。此时，为<strong><span style="color:#956fe7;">幻读</span></strong>。</li></ol>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ab2ef6c438cad3aab53137864b7b9f45/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android学习笔记（六）：常用布局--LinearLayout线性布局、RelativeLayout相对布局、GridLayout网格布局、ScrollView滚动视图</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/daac787e3c0fcd294507abfd8ddc2860/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Scrapy_settings配置文件设置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>