<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>char数组与char指针 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="char数组与char指针" />
<meta property="og:description" content="转载来源：
https://www.cnblogs.com/nzbbody/p/3553222.html
https://blog.csdn.net/jack_20/article/details/78913202
一、‘\0’的添加 存在的C语言方法，如strlen(s)，计算字符串的长度，其中s指针。
strlen要计算字符串长度，必须知道哪里是结尾，因此使用\0表示结尾。
只有字符数组才有\0的概念，其它类型(int)的数组没有这个概念。
二、内存分配 数组可以在栈上分配，也可以在堆上分配，但必须指定大小。
char a1[100]; //在栈上分配 char* pa = new char[100]; // 在堆上分配，返回首元素的地址 三、初始化 char str[10] = &#34;Hello&#34;; char str[10] = {&#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;\0&#39;}; char str[10] = {&#39;H&#39;}; char str[10] = {0}; char str[10] = &#34;Hello, world.\n&#34;; char str[] = &#34;Hello, world.\n&#34;; 第一种情况：初始化数据小于数组长度
如前面两个初始化的例子，这两个例子的效果一样，前五个字符为Hello,剩余的用’\0’填充
第三行与第四行，都只指定了第一个字符，剩余的全部用’\0’填充。第四个例子相当将整个数组初始化为’\0’
第二种情况：初始化数据等于或超过数据长度
这种情况下，超出的部分将被丢弃，所以最五个例子的最后一个字符为’l’.
此时使用一些字符串函数时要特别注意,因为该数组不含有’\0’，会造成不可预期的结果
第三种情况：不指定数组长度
这种情况下，数组部分如果不含有明确指定的’\0’，那么编译时会被自动添加一个’\0’;
在数组不含有明确的’\0’时，sizeof=strlen&#43;1
四、结果输出 char a1[] = “abc”; 下面的结果分别是什么？
输出相同，都是数组元素的第一个地址。
cout &lt;&lt; &amp;a1[0] &lt;&lt; endl; cout &lt;&lt; a1 &lt;&lt; endl; char* pa = “abc”; 下面的结果分别是什么？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e0c77f02daf01403ef1e22e4e9afc322/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-02-04T16:32:02+08:00" />
<meta property="article:modified_time" content="2019-02-04T16:32:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">char数组与char指针</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>转载来源：<br> <a href="https://www.cnblogs.com/nzbbody/p/3553222.html" rel="nofollow">https://www.cnblogs.com/nzbbody/p/3553222.html</a><br> <a href="https://blog.csdn.net/jack_20/article/details/78913202">https://blog.csdn.net/jack_20/article/details/78913202</a></p> 
<h3><a id="0_4"></a><strong>一、‘\0’的添加</strong></h3> 
<p>存在的C语言方法，如strlen(s)，计算字符串的长度，其中s指针。<br> strlen要计算字符串长度，必须知道哪里是结尾，因此使用\0表示结尾。<br> 只有字符数组才有\0的概念，其它类型(int)的数组没有这个概念。</p> 
<h3><a id="_10"></a><strong>二、内存分配</strong></h3> 
<p>数组可以在栈上分配，也可以在堆上分配，但必须指定大小。</p> 
<pre><code>char a1[100];                   //在栈上分配
char* pa = new char[100];       // 在堆上分配，返回首元素的地址
</code></pre> 
<h3><a id="_16"></a><strong>三、初始化</strong></h3> 
<pre><code>char str[10] = "Hello";
char str[10] = {'H','e','l','l','o','\0'};
char str[10] = {'H'};
char str[10] = {0};
char str[10] = "Hello, world.\n";
char str[] = "Hello, world.\n";
</code></pre> 
<p>第一种情况：初始化数据小于数组长度<br> 如前面两个初始化的例子，这两个例子的效果一样，前五个字符为Hello,剩余的用’\0’填充<br> 第三行与第四行，都只指定了第一个字符，剩余的全部用’\0’填充。第四个例子相当将整个数组初始化为’\0’</p> 
<p>第二种情况：初始化数据等于或超过数据长度<br> 这种情况下，超出的部分将被丢弃，所以最五个例子的最后一个字符为’l’.<br> 此时使用一些字符串函数时要特别注意,因为该数组不含有’\0’，会造成不可预期的结果</p> 
<p>第三种情况：不指定数组长度<br> 这种情况下，数组部分如果不含有明确指定的’\0’，那么编译时会被自动添加一个’\0’;<br> 在数组不含有明确的’\0’时，sizeof=strlen+1</p> 
<h3><a id="_37"></a><strong>四、结果输出</strong></h3> 
<p>char a1[] = “abc”; 下面的结果分别是什么？<br> 输出相同，都是数组元素的第一个地址。</p> 
<pre><code>cout &lt;&lt; &amp;a1[0] &lt;&lt; endl;
cout &lt;&lt; a1 &lt;&lt; endl;
</code></pre> 
<p>char* pa = “abc”; 下面的结果分别是什么？<br> 第一行输出pa在栈上的地址，第二行和第三行输出相同，都是首地址。<br> pa是指针，就是指向首个元素的地址。</p> 
<pre><code>cout &lt;&lt; &amp;pa &lt;&lt; endl;
cout &lt;&lt; &amp;pa[0] &lt;&lt; endl;
cout &lt;&lt; pa &lt;&lt; endl;
</code></pre> 
<p>下面的结果，违反直觉，按道理第4行，第5行应该输出地址。但是却输出指向的字符串。这有一定的合理性，我们打印char指针，往往是要看指向的内容，而不是要看地址是多少。而且cout很容易做到，只要遇到\0就结束。那么问题来了，我想看地址怎么办？使用int强制转化为地址。</p> 
<pre><code>char a1[] = "abc";
char* pa = "def";
cout &lt;&lt; a1 &lt;&lt; endl;          // 输出abc
cout &lt;&lt; pa &lt;&lt; endl;          // 输出def
cout &lt;&lt; (int)a1 &lt;&lt; endl;     // 输出a1地址
cout &lt;&lt; (int)pa &lt;&lt; endl;     // 输出pa地址
</code></pre> 
<p>除此之外，还可以用“ * ”来获取单个字符</p> 
<pre><code>char* pa = abcde;
cout &lt;&lt; *pa &lt;&lt; endl;          //输出a
cout &lt;&lt; *(pa+2) &lt;&lt;endl;       //输出c
</code></pre> 
<h3><a id="_69"></a><strong>五、获取长度</strong></h3> 
<pre><code>char p[] = "abcde";
char* p2 = "abcde";

cout &lt;&lt; sizeof(p) &lt;&lt; endl; //数组大小为6
cout &lt;&lt; sizeof(p2) &lt;&lt; endl; // 指针大小为4

cout &lt;&lt; strlen(p) &lt;&lt; endl; // 长度为5
cout &lt;&lt; strlen(p2) &lt;&lt; endl; // 长度为5
</code></pre> 
<h3><a id="_81"></a><strong>六、常用函数</strong></h3> 
<pre><code>#incldue &lt;string.h&gt;

//将已开辟内存空间 s 的首 n 个字节的值设为值 c。
void *memset(void *s,int c,size_t n);

//统计给定字符串的长度
size_t strlen(const char *s);

//拷贝src前n个字节到dest上
//当内存发生局部重叠的时候，memmove保证拷贝的结果是正确的，memcpy不保证。
void *memcpy(void *dest,const void *src,size_t n);
void *memmove(void *dest,const void *src,size_t n);

//拷贝src字符串到dest上(会复制结束符)
//strcpy只用于字符串拷贝，而memcpy可用于各种类型
char *strcpy(char *dest, const char *src);
char *strncpy(char *dest, const char *src,size_t n);

//把src所指字符串(前n个字节)添加到dest结尾处。
char *strcat(char *dest,const char *src);
char *strncat(char *desk,const char *src,size_t n);

//比较前n个字符大小，大小写敏感
//strcmp检查到'\0'则终止比较
//memcmp对特殊情况处理更好，效率更高
int memcmp(const void *s1,const void *s2,size_t n);
int strcmp(const char *s1,const char *s2);
int strncmp(const char *s1,const char *s2,size_t n);

//比较前n个字符大小，大小写不敏感
int strcasecmp(const char *s1,const char *s2);
int strncasecmp(const char *s1,const char *s2,size_t n);

//strchr找出str字符串中第一次出现c的地址，返回该地址
//strrchr找出str字符串中最后一次出现c的地址，返回该地址
//strstr找出在haystack字符串中第一次出现needle字符串的位置
char *strchr(const char *s,int c);
char *strrchr(const char *s,int c);
char *strstr(const char *haystack,const char *needle);

//strtok在str中有delim字符的位置处分割字符串
//strtok_r是linux下分割字符的安全函数，将剩余字符串保存在saveptr中
char *strtok(char *str,const char *delim);
char *strtok_r(char *str,const char *delim,char **saveptr);
</code></pre> 
<h3><a id="_128"></a><strong>七、相互转换</strong></h3> 
<p>请参考：C++中string、char *、char[]相互转换<br> <a href="https://blog.csdn.net/qq_30534935/article/details/82459448">https://blog.csdn.net/qq_30534935/article/details/82459448</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2f811df401e2a5fe525c0511b725eaa2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">算法训练 2的次幂表示(java)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/82ae50fa5bdff2091a52d5afec782abd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java趣味编程案例21----最小公倍数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>