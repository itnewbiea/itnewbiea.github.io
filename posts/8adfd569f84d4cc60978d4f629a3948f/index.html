<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>图像相关算法整理 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="图像相关算法整理" />
<meta property="og:description" content="图像相关算法整理 1.HE算法（灰度直方图均衡算法） 原理：将原始图像的灰度直方图从比较集中地某个灰度区间变成全部灰度范围内的均匀分布步骤：
- （1）遍历每一帧图像中的所有像素，记录每个灰度值出现的像素个数
- （2）统计每个灰度值占总像素的百分比，即每个灰度值出现的概率
- （3）建立一个映射表，对原图像的灰度值一一进行映射，修改成新的灰度值，映射关系为：
新灰度值 = （最大灰度值（255） - 最小灰度值（0））*累计概率缺点：对处理的数据不加选择，他可能会增加背景噪声的对比度并且降低有用信号的对比度。 2.AHE算法（自适应直方图均衡算法） 原理：在HE算法的基础上，将图像划为几块分别处理，每一块统计一个各自专属的分布函数。优点：相对于HE算法而言，算法的时间复杂度提高不少，降低了图像处理效率。缺点：AHE算法在对每个像素块独立进行处理映射，块与块之间没有过渡处理，这样就导致图像呈现出来的效果像被切成了几个块。 3.CLAHE（限制对比度自适应直方图均衡算法） 原理：在AHE算法的基础上，加上阈值，来限制对比度，达到削弱噪声放大问题的效果，并使用线性插值/双线性插值的方法来优化块与块之间的过渡问题。
对于当前块中的像素灰度值，是由其相邻块共同决定的；
如果直方图中统计的灰度值与我们设定的阈值进行对比，超出阈值的部分将其均匀的分布在每一个不同的灰度值下面。 4.BBHE（图像双直方图均衡算法） 原理：基于图像均值来分割输入图像，得到两幅子图，一副是像素值小于或者等于均值的样本集，另一个是像素值大于均值的样本集，分别独立的进行直方图均衡化步骤：
- （1）统计所有出现的灰度值的次数
- （2）将次数进行归一化，得到归一化直方图
- （3）计算累计直方图
- （4）将累计直方图进行区间转换
*区间转换公式：结果 = 最小值 &#43; 累计直方图的值 （最大值 - 最小值）
注：累计直方图：每一个概率值代表小于等于此灰度值的概率 5.DES加密算法 几个定义：
密匙：密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。对称加密：通信双方同时掌握一个密钥，加密解密都是由一个密钥完成的（即加密密钥等于解密密钥，加解密密钥可以相互推倒出来）。双方通信前共同拟定一个密钥，不对第三方公开。分组加密：分组密码是将明文分成固定长度的组，每一组都采用同一密钥和算法进行加密，输出也是固定长度的密文。 5.1 密匙产生 对于一个64位的密匙而言，其中只有56位是有用的，剩下的8位是用作奇偶验证的。
步骤：（1）将64位密匙通过下图所示的密匙置换表一去掉8个验证位，得到一个56位数据k’；
（2）将k’分成左右两块，前28位为C0,后28位为D0;
（3）根据轮数分别按照下图所示的表将上一次的两块分别循环左移1位或者2位，得到Ci,Di;
(4)将Ci,Di合并得到56位数据，再通过下图所示压缩置换表得到子密匙Ki。
5.2 S盒（代换选择） S盒是整个变换中唯一的非线性运算过程。
步骤：（1）48位数据划分成8个盒，每个盒输入为6位数据；
（2）通过6位数据中的第1,6组成二进制数作为行数，中间4位组成的二进制数作为列数；
（3）将对应的行列的数在下图中找到对应的十进制数，再按照四位二进制输出
5.3加密步骤 （1）64位明文使用下图所示初始置换表进行置换得到新数据（表中的数据表示第多少位的数据放到该位置）
（2）分成左右两块，L0（前32位）R0(后32位)
（3）i&lt;=16时,对于Li而言，等于R(i-1),对于Ri而言，先要让R（i-1）进行扩充置换操作得到48位数据，置换表如下第一个图所示，在与K(i-1)进行异或操作，得到新的48位数据，再对该数据通过S盒得到32位数据，下一步通过置换表得到一个新的32位数据，最后与L(i-1)进行异或操作得到Ri。
（4）经过十六轮之后，将L16和R16合并作为输入块，通过下图所示的逆置换表进行逆置换操作，得到最后的密文并输出。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8adfd569f84d4cc60978d4f629a3948f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-18T19:45:33+08:00" />
<meta property="article:modified_time" content="2021-11-18T19:45:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">图像相关算法整理</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>图像相关算法整理</h3> 
<h4><a id="1HE_1"></a>1.HE算法（灰度直方图均衡算法）</h4> 
<ul><li><strong>原理</strong>：将原始图像的灰度直方图从比较集中地某个灰度区间变成全部灰度范围内的均匀分布</li><li><strong>步骤</strong>：<br> - （1）遍历每一帧图像中的所有像素，记录每个灰度值出现的像素个数<br> - （2）统计每个灰度值占总像素的百分比，即每个灰度值出现的概率<br> - （3）建立一个映射表，对原图像的灰度值一一进行映射，修改成新的灰度值，映射关系为：<br> 新灰度值 = （最大灰度值（255） - 最小灰度值（0））*累计概率</li><li><strong>缺点</strong>：对处理的数据不加选择，他可能会增加背景噪声的对比度并且降低有用信号的对比度。</li></ul> 
<h4><a id="2AHE_9"></a>2.AHE算法（自适应直方图均衡算法）</h4> 
<ul><li><strong>原理</strong>：在HE算法的基础上，将图像划为几块分别处理，每一块统计一个各自专属的分布函数。</li><li><strong>优点</strong>：相对于HE算法而言，算法的时间复杂度提高不少，降低了图像处理效率。</li><li><strong>缺点</strong>：AHE算法在对每个像素块独立进行处理映射，块与块之间没有过渡处理，这样就导致图像呈现出来的效果像被切成了几个块。</li></ul> 
<h4><a id="3CLAHE_13"></a>3.CLAHE（限制对比度自适应直方图均衡算法）</h4> 
<ul><li><strong>原理</strong>：在AHE算法的基础上，加上阈值，来限制对比度，达到削弱噪声放大问题的效果，并使用线性插值/双线性插值的方法来优化块与块之间的过渡问题。<br> 对于当前块中的像素灰度值，是由其相邻块共同决定的；<br> 如果直方图中统计的灰度值与我们设定的阈值进行对比，超出阈值的部分将其均匀的分布在每一个不同的灰度值下面。</li></ul> 
<h4><a id="4BBHE_17"></a>4.BBHE（图像双直方图均衡算法）</h4> 
<ul><li><strong>原理</strong>：基于图像均值来分割输入图像，得到两幅子图，一副是像素值小于或者等于均值的样本集，另一个是像素值大于均值的样本集，分别独立的进行直方图均衡化</li><li><strong>步骤</strong>：<br> - （1）统计所有出现的灰度值的次数<br> - （2）将次数进行归一化，得到归一化直方图<br> - （3）计算累计直方图<br> - （4）将累计直方图进行区间转换<br> *<em>区间转换公式：结果 = 最小值 + 累计直方图的值 <em>（最大值 - 最小值）<br> 注：累计直方图：每一个概率值代表小于等于此灰度值的概率</em></em></li></ul> 
<h4><a id="5DES_26"></a>5.DES加密算法</h4> 
<p><strong>几个定义：</strong></p> 
<ul><li>密匙：密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。</li><li>对称加密：通信双方同时掌握一个密钥，加密解密都是由一个密钥完成的（即加密密钥等于解密密钥，加解密密钥可以相互推倒出来）。双方通信前共同拟定一个密钥，不对第三方公开。</li><li>分组加密：分组密码是将明文分成固定长度的组，每一组都采用同一密钥和算法进行加密，输出也是固定长度的密文。</li></ul> 
<h5><a id="51__31"></a>5.1 密匙产生</h5> 
<p>对于一个64位的密匙而言，其中只有56位是有用的，剩下的8位是用作奇偶验证的。<br> 步骤：（1）将64位密匙通过下图所示的密匙置换表一去掉8个验证位，得到一个56位数据k’；<br> <img src="https://images2.imgbox.com/0b/ed/gziurAYC_o.png" alt="在这里插入图片描述"><br> （2）将k’分成左右两块，前28位为C0,后28位为D0;<br> （3）根据轮数分别按照下图所示的表将上一次的两块分别循环左移1位或者2位，得到Ci,Di;<br> <img src="https://images2.imgbox.com/84/99/W5zgbaCz_o.png" alt="在这里插入图片描述"><br> (4)将Ci,Di合并得到56位数据，再通过下图所示压缩置换表得到子密匙Ki。<br> <img src="https://images2.imgbox.com/08/b9/6oERpF8l_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="52_S_40"></a>5.2 S盒（代换选择）</h5> 
<p>S盒是整个变换中唯一的非线性运算过程。<br> 步骤：（1）48位数据划分成8个盒，每个盒输入为6位数据；<br> （2）通过6位数据中的第1,6组成二进制数作为行数，中间4位组成的二进制数作为列数；<br> （3）将对应的行列的数在下图中找到对应的十进制数，再按照四位二进制输出<br> <img src="https://images2.imgbox.com/f5/b2/gQeiO9VX_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="53_46"></a>5.3加密步骤</h5> 
<p><img src="https://images2.imgbox.com/e7/67/6CREy9gh_o.png" alt="在这里插入图片描述"><br> （1）64位明文使用下图所示初始置换表进行置换得到新数据（表中的数据表示第多少位的数据放到该位置）<br> <img src="https://images2.imgbox.com/75/fa/k2puJxaG_o.png" alt="在这里插入图片描述"><br> （2）分成左右两块，L0（前32位）R0(后32位)<br> （3）i&lt;=16时,对于Li而言，等于R(i-1),对于Ri而言，先要让R（i-1）进行扩充置换操作得到48位数据，置换表如下第一个图所示，在与K(i-1)进行异或操作，得到新的48位数据，再对该数据通过S盒得到32位数据，下一步通过置换表得到一个新的32位数据，最后与L(i-1)进行异或操作得到Ri。<br> <img src="https://images2.imgbox.com/db/b6/wgQMLt0Z_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d9/34/20M2JQZl_o.png" alt="在这里插入图片描述"><br> （4）经过十六轮之后，将L16和R16合并作为输入块，通过下图所示的逆置换表进行逆置换操作，得到最后的密文并输出。<br> <img src="https://images2.imgbox.com/91/cc/t3GTgIsq_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/99802af5050856faf404489b40cadd93/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue 复制 粘贴div标签内容</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fcd3ac9cde0c03843a09f063e4302edf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Webpack 中常用的loader和plugin已经webpack如何配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>