<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux设备树分析2-创建device_node树 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux设备树分析2-创建device_node树" />
<meta property="og:description" content="二进制格式dtb设备树文件需要先转化成设备节点device_node结构，然后再将device_node转换成平台设备platform_device。
device_node在文件 include/linux/of.h中：
struct device_node { const char *name; /*保存节点名称属性*/ const char *type; /*节点类型*/ phandle phandle; /*节点句柄，该成员可以用于节点引用*/ const char *full_name; /*节点名称*/ struct fwnode_handle fwnode; /*暂时还不明白其作用*/ struct	property *properties; /*节点属性*/ struct	property *deadprops;	/*暂时还不明白其作用*/ struct	device_node *parent; /*父节点*/ struct	device_node *child; /*第一个子节点*/ struct	device_node *sibling; /*第一个兄弟节点*/ struct	kobject kobj; /*节点kobj对象*/ unsigned long _flags; /*节点标识*/ void	*data; /*节点特殊数据*/ #if defined(CONFIG_SPARC) /*暂不讨论*/ const char *path_component_name; unsigned int unique_id; struct of_irq_controller *irq_trans; #endif }; 从结构体parent，child，sibling三个成员可以看出device_node是以树状结构进行组织的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/9c16ef75b28fa3e8f381adc4bd3e3a66/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-03T14:22:39+08:00" />
<meta property="article:modified_time" content="2021-09-03T14:22:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux设备树分析2-创建device_node树</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:.0001pt;text-align:justify;">二进制格式dtb设备树文件需要先转化成设备节点device_node结构，然后再将device_node转换成平台设备platform_device。</p> 
<p style="margin-left:.0001pt;text-align:justify;">device_node在文件 include/linux/of.h中：</p> 
<pre><code class="language-cpp">struct device_node {
	const char *name; /*保存节点名称属性*/
	const char *type; /*节点类型*/
	phandle phandle; /*节点句柄，该成员可以用于节点引用*/
	const char *full_name;  /*节点名称*/
	struct fwnode_handle fwnode; /*暂时还不明白其作用*/

	struct	property *properties; /*节点属性*/
	struct	property *deadprops;	/*暂时还不明白其作用*/
	struct	device_node *parent; /*父节点*/
	struct	device_node *child; /*第一个子节点*/
	struct	device_node *sibling; /*第一个兄弟节点*/
	struct	kobject kobj; /*节点kobj对象*/
	unsigned long _flags; /*节点标识*/
	void	*data; /*节点特殊数据*/
#if defined(CONFIG_SPARC)  /*暂不讨论*/
	const char *path_component_name;
	unsigned int unique_id;
	struct of_irq_controller *irq_trans;
#endif
};
</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">从结构体parent，child，sibling三个成员可以看出device_node是以树状结构进行组织的。</p> 
<p style="margin-left:.0001pt;text-align:justify;">下面我们就来分析这颗设备树是如何长出来的。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">dtb解析过程调用的函数顺序如下：其中setup_arch 在文件arch/arm64/kernel/setup.c中定义：</p> 
<p style="margin-left:.0001pt;text-align:justify;">setup_arch-&gt;unflatten_device_tree-&gt;__unflatten_device_tree-&gt;unflatten_dt_node</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p>unflatten_device_tree 在文件drivers/of/fdt.c中定义：</p> 
<pre><code class="language-cpp">void __init unflatten_device_tree(void)
{
	__unflatten_device_tree(initial_boot_params, &amp;of_root,
				early_init_dt_alloc_memory_arch);

	/* Get pointer to "/chosen" and "/aliases" nodes for use everywhere */
	of_alias_scan(early_init_dt_alloc_memory_arch);
}
</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">__unflatten_device_tree在文件drivers/of/fdt.c中定义：</p> 
<pre><code class="language-cpp">static void __unflatten_device_tree(const void *blob,
			     struct device_node **mynodes,
			     void * (*dt_alloc)(u64 size, u64 align))
{
	unsigned long size;
	int start;
	void *mem;

	pr_debug(" -&gt; unflatten_device_tree()\n");

	if (!blob) {
		pr_debug("No device tree pointer\n");
		return;
	}

	pr_debug("Unflattening device tree:\n");
	pr_debug("magic: %08x\n", fdt_magic(blob));
	pr_debug("size: %08x\n", fdt_totalsize(blob));
	pr_debug("version: %08x\n", fdt_version(blob));
	
    /*通过检测dtb文件头的魔幻数和版本来判断dtb文件头信息是否正确*/
	if (fdt_check_header(blob)) {
		pr_err("Invalid device tree blob header\n");
		return;
	}

	/* First pass, scan for size */
	/*就是这个函数将dtb解析成device_node树，这里是第一次调用该接口函数，获取整个device_node树所需空间大小*/
	start = 0;
	size = (unsigned long)unflatten_dt_node(blob, NULL, &amp;start, NULL, NULL, 0, true);
	size = ALIGN(size, 4);

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	/*根据device_node所需空间大小申请内存空间*/
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);
	/*内存空间结尾标识，ps：标识既然叫“deadbeef”*/
	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	/*第二次调用，这次才正式将dtb解析成device_node树*/
	start = 0;
	unflatten_dt_node(blob, mem, &amp;start, NULL, mynodes, 0, false);
	if (be32_to_cpup(mem + size) != 0xdeadbeef)
		pr_warning("End of tree marker overwritten: %08x\n",
			   be32_to_cpup(mem + size));

	pr_debug(" &lt;- unflatten_device_tree()\n");
}

</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">下面就来详细分析下这个被2次调用的函数，unflatten_dt_node在文件drivers/of/fdt.c中定义，第一次调用时参数dryrun为true，这个标志表示不会将dtb解析成树，只是计算需要的内存空间大小，第二次调用时将解析dtb文件后生成的device_node树存入之前申请的空间。</p> 
<p style="margin-left:.0001pt;text-align:justify;">为了便于理解我们队这个函数分析两次，第一次调用时：</p> 
<pre><code class="language-cpp">static void * unflatten_dt_node(const void *blob,
				void *mem,
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
	const __be32 *p;
	struct device_node *np;
	struct property *pp, **prev_pp = NULL;
	const char *pathp;
	unsigned int l, allocl;
	static int depth;
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	/*获取节点名称，l用于返回名称长度*/
	pathp = fdt_get_name(blob, *poffset, &amp;l);
	if (!pathp)
		return mem;
	/*节点名称所占空间长度为节点名称长度加1（节点名称以0x0结束）*/
	allocl = ++l;

	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	/*16版本之前名称是以’/’起始的全路径名称，0x10以后版本节点名称没有采用全路径的方式了，而是只包含当前节点名称，根节点名称为0x00000000，fpsize记录节点名称全路径长度*/
	if ((*pathp) != '/') {
		/*dtb格式新版本标记*/
new_format = 1;
		if (fpsize == 0) {
			/* root node: special case. fpsize accounts for path
			 * plus terminating zero. root node only has '/', so
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
/*对于根节点名称全路径长度为1，需要申请的空间长度为2，名称长度设为1
路径指针指向空字符串”” */
			fpsize = 1;
			allocl = 2;
			l = 1;
			pathp = "";
		} else {
			/* account for '/' and path size minus terminal 0
			 * already in 'l'
			 */
			/*其他节点，全路径长度为上一个节点长度加上当前节点名称长度，
申请的名称空间长度为当前节点全路径长度*/
			fpsize += l;
			allocl = fpsize;
		}
	}
	/*计算节点所需内存空间大小，将所需内存大小存入mem中，申请的内存空间大小为device_node结构所占空间加上节点名称所占空间大小，申请的空间大小需要按device_node空间大小对齐，第一次调用暂时不管返回值np*/
	np = unflatten_dt_alloc(&amp;mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np-&gt;full_name = fn = ((char *)np) + sizeof(*np);
		if (new_format) {
			/* rebuild full path for new format */
			if (dad &amp;&amp; dad-&gt;parent) {
				strcpy(fn, dad-&gt;full_name);
#ifdef DEBUG
				if ((strlen(fn) + l + 1) != allocl) {
					pr_debug("%s: p: %d, l: %d, a: %d\n",
						pathp, (int)strlen(fn),
						l, allocl);
				}
#endif
				fn += strlen(fn);
			}
			*(fn++) = '/';
		}
		memcpy(fn, pathp, l);

		prev_pp = &amp;np-&gt;properties;
		if (dad != NULL) {
			np-&gt;parent = dad;
			np-&gt;sibling = dad-&gt;child;
			dad-&gt;child = np;
		}
	}
	/* process properties */
	/*依次遍历节点中所有属性*/
	for (offset = fdt_first_property_offset(blob, *poffset);
	     (offset &gt;= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
		const char *pname;
		u32 sz;
		/*获取属性名称和属性长度*/
		if (!(p = fdt_getprop_by_offset(blob, offset, &amp;pname, &amp;sz))) {
			offset = -FDT_ERR_INTERNAL;
			break;
		}

		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		/*属性名称为“name”*/
		if (strcmp(pname, "name") == 0)
			has_name = 1;
		/*申请属性存储空间*/
		pp = unflatten_dt_alloc(&amp;mem, sizeof(struct property),
					__alignof__(struct property));
		if (!dryrun) {
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
			    (strcmp(pname, "linux,phandle") == 0)) {
				if (np-&gt;phandle == 0)
					np-&gt;phandle = be32_to_cpup(p);
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
				np-&gt;phandle = be32_to_cpup(p);
			pp-&gt;name = (char *)pname;
			pp-&gt;length = sz;
			pp-&gt;value = (__be32 *)p;
			*prev_pp = pp;
			prev_pp = &amp;pp-&gt;next;
		}
	}
	/* with version 0x10 we may not have the name property, recreate
	 * it here from the unit name if absent
	 */

	/*如果节点无name属性，将节点名称解析成name属性，name属性值为“/”到“@”符号直接的字符串，如果节点名称中无“/”和“@”，name属性值为整个节点名称，例如节点
Sample@0x12345678{
	….
};
name 属性值为” Sample”
例如节点
Sample{
	….
};
name 属性值也为” Sample”
*/

if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
			if ((*p1) == '@')
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa &lt; ps)
			pa = p1;
		sz = (pa - ps) + 1;
		pp = unflatten_dt_alloc(&amp;mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
			pp-&gt;name = "name";
			pp-&gt;length = sz;
			pp-&gt;value = pp + 1;
			*prev_pp = pp;
			prev_pp = &amp;pp-&gt;next;
			memcpy(pp-&gt;value, ps, sz - 1);
			((char *)pp-&gt;value)[sz - 1] = 0;
			pr_debug("fixed up name for %s -&gt; %s\n", pathp,
				(char *)pp-&gt;value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
		np-&gt;name = of_get_property(np, "name", NULL);
		np-&gt;type = of_get_property(np, "device_type", NULL);

		if (!np-&gt;name)
			np-&gt;name = "&lt;NULL&gt;";
		if (!np-&gt;type)
			np-&gt;type = "&lt;NULL&gt;";
	}

	old_depth = depth;
	/*查找下一个节点偏移*/
	*poffset = fdt_next_node(blob, *poffset, &amp;depth);
	if (depth &lt; 0)
		depth = 0;

	/*递归解析所有节点*/
	while (*poffset &gt; 0 &amp;&amp; depth &gt; old_depth)
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
					fpsize, dryrun);

	if (*poffset &lt; 0 &amp;&amp; *poffset != -FDT_ERR_NOTFOUND)
		pr_err("unflatten: error %d processing FDT\n", *poffset);

	/*
	 * Reverse the child list. Some drivers assumes node order matches .dts
	 * node order
	 */
	if (!dryrun &amp;&amp; np-&gt;child) {
		struct device_node *child = np-&gt;child;
		np-&gt;child = NULL;
		while (child) {
			struct device_node *next = child-&gt;sibling;
			child-&gt;sibling = np-&gt;child;
			np-&gt;child = child;
			child = next;
		}
	}
    
	/*nodepp指向根节点*/
	if (nodepp)
		*nodepp = np;

	return mem;
}
</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">到此通过第一次调用unflatten_dt_node函数计算出了解析整个device_node所需内存空间大小，第二次调用该函数参数如下：</p> 
<p style="margin-left:.0001pt;text-align:justify;">unflatten_dt_node(blob, mem, &amp;start, NULL, mynodes, 0, false);</p> 
<p style="margin-left:.0001pt;text-align:justify;">其中dryrun参数变成了false，这次调用正式将dtb设备树文件解析成device_node，并将解析后的device_node树存入第一次调用函数申请的内存空间中，mem为第一次调用后申请的存储device_node的空间首地址，mynodes用于存储解析后的device_node树首地址。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">下面分析第二次调用过程：</p> 
<pre><code class="language-cpp">static void * unflatten_dt_node(const void *blob,
				void *mem,
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
	const __be32 *p;
	struct device_node *np;
	struct property *pp, **prev_pp = NULL;
	const char *pathp;
	unsigned int l, allocl;
	static int depth;
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	/*获取节点名称，l用于返回名称长度*/
	pathp = fdt_get_name(blob, *poffset, &amp;l);
	if (!pathp)
		return mem;
	/*节点名称所占空间长度为节点名称长度加1（节点名称以0x0结束）*/
	allocl = ++l;

	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	/*16版本之前名称是以’/’起始的全路径名称，0x10以后版本节点名称没有采用全路径的方式了，而是只包含当前节点名称，根节点名称为0x00000000，fpsize记录节点名称全路径长度*/
	if ((*pathp) != '/') {
		/*dtb格式新版本标记*/
new_format = 1;
		if (fpsize == 0) {
			/* root node: special case. fpsize accounts for path
			 * plus terminating zero. root node only has '/', so
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
/*对于根节点名称全路径长度为1，需要申请的空间长度为2，名称长度设为1
路径指针指向空字符串”” */
			fpsize = 1;
			allocl = 2;
			l = 1;
			pathp = "";
		} else {
			/* account for '/' and path size minus terminal 0
			 * already in 'l'
			 */
			/*其他节点，全路径长度为上一个节点长度加上当前节点名称长度，
申请的名称空间长度为当前节点全路径长度*/
			fpsize += l;
			allocl = fpsize;
		}
	}
	/*通过前面分析我们知道通过调用该接口计算存储所有device_node所占空间大小 ，并将所需空间大小存在mem变量中。本次调用用了一个小技巧：利用当前device_node所占空间大小也就是下一个新device_node的起始地址相对于首地址的偏移这个概念。本次调用前mem存储的是当前device_node在整个空间中的偏移位置，np返回的就是调用前的mem，调用后mem指向当前device_node的结尾，也是下一个新device_node的起始地址*/
	np = unflatten_dt_alloc(&amp;mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));

/*本次调用不会“干跑了”，下面就来分析下实际怎么跑的吧*/
	if (!dryrun) {
		char *fn;
		/*初始化device_node*/
		of_node_init(np);
		/*指向节点名称*/
		np-&gt;full_name = fn = ((char *)np) + sizeof(*np);
		if (new_format) {
			/* rebuild full path for new format */
			/*通过父节获取父节点全路径名称，只有2级子节点才需要获取父节点全路径名称*/
			if (dad &amp;&amp; dad-&gt;parent) {
				strcpy(fn, dad-&gt;full_name);
#ifdef DEBUG
				if ((strlen(fn) + l + 1) != allocl) {
					pr_debug("%s: p: %d, l: %d, a: %d\n",
						pathp, (int)strlen(fn),
						l, allocl);
				}
#endif
				fn += strlen(fn);
			}
			*(fn++) = '/';
		}
		/*将本节点名称追加到父节点全路径名称的后面*/
		memcpy(fn, pathp, l);

		/* prev_pp 指向节点的第一个属性*/
		prev_pp = &amp;np-&gt;properties;
		/*如果有父节点，当前节点的parent指向父节点，当前节点的sibling指向父节点的第一个孩子，父节点的第一个孩子指向当前节点，这里需要说明下：父节点第一个孩子指向的是新添加的节点，而不是最老的节点*/
		if (dad != NULL) {
			np-&gt;parent = dad;
			np-&gt;sibling = dad-&gt;child;
			dad-&gt;child = np;
		}
	}
	/* process properties */
	/*依次遍历节点中所有属性*/
	for (offset = fdt_first_property_offset(blob, *poffset);
	     (offset &gt;= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
		const char *pname;
		u32 sz;
		/*获取属性名称和属性长度*/
		if (!(p = fdt_getprop_by_offset(blob, offset, &amp;pname, &amp;sz))) {
			offset = -FDT_ERR_INTERNAL;
			break;
		}

		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		/*属性名称为“name”*/
		if (strcmp(pname, "name") == 0)
			has_name = 1;
		/*申请属性存储空间*/
		pp = unflatten_dt_alloc(&amp;mem, sizeof(struct property),
					__alignof__(struct property));
		if (!dryrun) {
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			/*获取phandle 属性*/
			if ((strcmp(pname, "phandle") == 0) ||
			    (strcmp(pname, "linux,phandle") == 0)) {
				if (np-&gt;phandle == 0)
					np-&gt;phandle = be32_to_cpup(p);
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
				np-&gt;phandle = be32_to_cpup(p);
			pp-&gt;name = (char *)pname;
			pp-&gt;length = sz;
			pp-&gt;value = (__be32 *)p;
			/*将属性挂载到节点的属性链表*/
			*prev_pp = pp;
			prev_pp = &amp;pp-&gt;next;
		}
	}
	/* with version 0x10 we may not have the name property, recreate
	 * it here from the unit name if absent
	 */

	/*如果节点无name属性，将节点名称解析成name属性，name属性值为“/”到“@”符号直接的字符串，如果节点名称中无“/”和“@”，name属性值为整个节点名称，例如节点
Sample@0x12345678{
	….
};
name 属性值为” Sample”
例如节点
Sample{
	….
};
name 属性值也为” Sample”
*/

if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
			if ((*p1) == '@')
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa &lt; ps)
			pa = p1;
		sz = (pa - ps) + 1;
		pp = unflatten_dt_alloc(&amp;mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
			pp-&gt;name = "name";
			pp-&gt;length = sz;
			pp-&gt;value = pp + 1;
			*prev_pp = pp;
			prev_pp = &amp;pp-&gt;next;
			memcpy(pp-&gt;value, ps, sz - 1);
			((char *)pp-&gt;value)[sz - 1] = 0;
			pr_debug("fixed up name for %s -&gt; %s\n", pathp,
				(char *)pp-&gt;value);
		}
	}
	if (!dryrun) {
		/*查找节点中名称为name和device_type的属性*/
		*prev_pp = NULL;
		np-&gt;name = of_get_property(np, "name", NULL);
		np-&gt;type = of_get_property(np, "device_type", NULL);

		if (!np-&gt;name)
			np-&gt;name = "&lt;NULL&gt;";
		if (!np-&gt;type)
			np-&gt;type = "&lt;NULL&gt;";
	}

	old_depth = depth;
	/*查找下一个节点偏移*/
	*poffset = fdt_next_node(blob, *poffset, &amp;depth);
	if (depth &lt; 0)
		depth = 0;

	/*递归解析所有节点*/
	while (*poffset &gt; 0 &amp;&amp; depth &gt; old_depth)
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
					fpsize, dryrun);

	if (*poffset &lt; 0 &amp;&amp; *poffset != -FDT_ERR_NOTFOUND)
		pr_err("unflatten: error %d processing FDT\n", *poffset);

	/*
	 * Reverse the child list. Some drivers assumes node order matches .dts
	 * node order
	 */
	/*上面解析的时候我们说过节点的child指向的是最新解析的子节点，并不是第一个解析的最老的子节点，这里讲第一个子节点和子节点的兄弟节点进行反序存储，反序后节点的第一个子节点就指向了最老的子节点，这样便于顺序遍历子节点*/
	if (!dryrun &amp;&amp; np-&gt;child) {
		struct device_node *child = np-&gt;child;
		np-&gt;child = NULL;
		while (child) {
			struct device_node *next = child-&gt;sibling;
			child-&gt;sibling = np-&gt;child;
			np-&gt;child = child;
			child = next;
		}
	}
    
	/*nodepp指向根节点*/
	if (nodepp)
		*nodepp = np;

	return mem;
}
</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">到这里device_node树就解析完了，现在可以根据device_node生成platform_device平台设备,平台设备生成入口：在arch/arm64/kernel/setup.c文件中，入口函数为：</p> 
<p style="margin-left:.0001pt;text-align:justify;">arm64_device_init-&gt;of_platform_populate</p> 
<p>of_platform_populate在drivers/of/platform.c中定义，下次分析。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/57502a4924bc689613d36dd4e9b75a69/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">阿里云elasticsearch实践（最大限度提高写入速度）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4ed81aee3afc103943f18e844dc18815/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PhpSpreadSheet使用GD绘图将图片导出表格，图片不显示</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>