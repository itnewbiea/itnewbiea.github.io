<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>详谈numpy.max,torch.max,argmax... - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="详谈numpy.max,torch.max,argmax..." />
<meta property="og:description" content="在编写或使用机器学习算法的过程中经常需要对numpy数组、tensor张量进行各种聚合操作，比如max，但是初次接触这块的东西，可能难以理解其中具体的聚合逻辑。
一。先上个简单的例子 给一个3行4列的numpy数组，按第0维取最大值。
import numpy as np import numpy.random np.random.seed(0) a = np.random.randint(0, 100, (3, 4), dtype=np.int32) print(f&#39;a:\r\n{a}&#39;) a_max_x = a.max(axis=0) print(f&#39;a_max_x:\r\n{a_max_x}&#39;) 按第0维，即指定axis=0。这到底是啥意思呢，直接来个简单的图，就是竖着计算啦，所以就是第0列取个最大值，第1列取个最大值，第2列最个最大值，第3列取个最大值。最终得到的是一行4列的结果。
那我要是按第1维呢，即改成axis=1，那就是横着取啦，第0行取个最大值，第1行。。。，第2行。。。
也就是说按第0维就是竖着取，按第1维就是横着取。好像蛮奇怪的哦，但是也好记，死背！
等等，先别划走，我要是这么说就完了，那就不叫详谈了！
二。再来个难点的例子 二维的数组确实能硬背，但来个三维的呢？现在是2行3列4垂（我瞎起个维度的名字）
import numpy as np import numpy.random np.random.seed(0) a = np.random.randint(0, 100, (2, 3, 4), dtype=np.int32) print(f&#39;a:\r\n{a}&#39;) a_max_x = a.max(axis=0) print(f&#39;a_max_x:\r\n{a_max_x}&#39;) 这箭头怎么画？箭头是不太好画了，因为有3个维度，但现在用平面来展示数据，没法在这其中画出1个维度的箭头了，但是下面的红线两连的一组组数据，就是做聚合的一组组数据。
2行3列4垂，现在按第0维聚合，所以是两两聚合（听不懂没关系，下面有更容易懂的）
如果上面的弄明白了，那直接跳跃一下，argmax的结果又是什么情况？
import numpy as np import numpy.random np.random.seed(0) a = np.random.randint(0, 100, (2, 3, 4), dtype=np.int32) print(f&#39;a:\r\n{a}&#39;) a_max_x = a." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/55ebecf128d23be06260b5dc197a9597/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-01T21:24:20+08:00" />
<meta property="article:modified_time" content="2023-09-01T21:24:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">详谈numpy.max,torch.max,argmax...</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在编写或使用机器学习算法的过程中经常需要对numpy数组、tensor张量进行各种聚合操作，比如max，但是初次接触这块的东西，可能难以理解其中具体的聚合逻辑。</p> 
<h2>一。先上个简单的例子</h2> 
<p>给一个3行4列的numpy数组，按第0维取最大值。</p> 
<p><img alt="e6eca3736aee498ca717e26eb37153a6.png" src="https://images2.imgbox.com/f4/7f/onbeVNJw_o.png"></p> 
<pre><code class="language-python">import numpy as np
import numpy.random

np.random.seed(0)
a = np.random.randint(0, 100, (3, 4), dtype=np.int32)
print(f'a:\r\n{a}')
a_max_x = a.max(axis=0)
print(f'a_max_x:\r\n{a_max_x}')</code></pre> 
<p>按第0维，即指定axis=0。这到底是啥意思呢，直接来个简单的图，就是竖着计算啦，所以就是第0列取个最大值，第1列取个最大值，第2列最个最大值，第3列取个最大值。最终得到的是一行4列的结果。</p> 
<p><img alt="1beb50e639e04800aec9b239e380a029.png" src="https://images2.imgbox.com/6d/30/AYAJadSR_o.png"></p> 
<p>那我要是按第1维呢，即改成axis=1，那就是横着取啦，第0行取个最大值，第1行。。。，第2行。。。</p> 
<p><img alt="a6388f6f82b44310b3ab5b1288e8c5e2.png" src="https://images2.imgbox.com/78/ab/bbaOuQvT_o.png"></p> 
<p>也就是说按第0维就是竖着取，按第1维就是横着取。好像蛮奇怪的哦，但是也好记，死背！</p> 
<p>等等，先别划走，我要是这么说就完了，那就不叫详谈了！</p> 
<h2>二。再来个难点的例子</h2> 
<p>二维的数组确实能硬背，但来个三维的呢？现在是2行3列4垂（我瞎起个维度的名字）</p> 
<pre><code class="language-python">import numpy as np
import numpy.random

np.random.seed(0)
a = np.random.randint(0, 100, (2, 3, 4), dtype=np.int32)
print(f'a:\r\n{a}')
a_max_x = a.max(axis=0)
print(f'a_max_x:\r\n{a_max_x}')</code></pre> 
<p><img alt="57712342892d45d8bd7eef64ac1a665d.png" src="https://images2.imgbox.com/51/90/gzrHpE3Q_o.png"></p> 
<p>这箭头怎么画？箭头是不太好画了，因为有3个维度，但现在用平面来展示数据，没法在这其中画出1个维度的箭头了，但是下面的红线两连的一组组数据，就是做聚合的一组组数据。</p> 
<p>2行3列4垂，现在按第0维聚合，所以是两两聚合（听不懂没关系，下面有更容易懂的）</p> 
<p><img alt="cb18b6f06bbb4866aab21e454f7e1240.png" src="https://images2.imgbox.com/85/c8/EDu5rVXT_o.png"></p> 
<p>如果上面的弄明白了，那直接跳跃一下，argmax的结果又是什么情况？</p> 
<pre><code class="language-python">import numpy as np
import numpy.random

np.random.seed(0)
a = np.random.randint(0, 100, (2, 3, 4), dtype=np.int32)
print(f'a:\r\n{a}')
a_max_x = a.max(axis=0)
print(f'a_max_x:\r\n{a_max_x}')
a_max_x_arg = a.argmax(axis=0)
print(f'a_max_x_arg:\r\n{a_max_x_arg}')</code></pre> 
<p><img alt="e9b6db98578046af91fe0a6099c0e0cf.png" src="https://images2.imgbox.com/d4/cc/51putRVF_o.png"></p> 
<p>红框里的是个啥玩意儿？这东西有什么用？莫急，其实如果真弄明白了聚合逻辑，就会知道这东西是什么，怎么用了。</p> 
<h2>三。具体的聚合逻辑</h2> 
<h3>1.二维数组聚合</h3> 
<p>还是先从简单的3行4列入数，具体来讲讲它的聚合逻辑。按第0维聚合，其实就是沿着第0维把多个数聚合成1个，注意，这是有条件的，即第0维度的下标可变，其它维度下标不变，得到多个值，把这多个值聚合成一个值。</p> 
<p>设第0维的坐标叫x，第1维的坐标叫y。那就是在</p> 
<p>y固定为0时，取x为0，1，2得到3个值，求最大值</p> 
<p>y固定为1时，取x为0，1，2得到3个值，求最大值</p> 
<p>y固定为2时，取x为0，1，2得到3个值，求最大值</p> 
<p>y固定为3时，取x为0，1，2得到3个值，求最大值</p> 
<p>如下图 。</p> 
<p><img alt="7df5809f11f64f1fafbd1a9e7a00b8df.png" src="https://images2.imgbox.com/21/83/YAP81NOO_o.png"></p> 
<p>如果让你写两层循环来实现聚合，y应该是外循环变量，x是内循环变量。最终得到的是1行4列的4个值（其实最后已经没有行这个维度了，因为它聚合成一个值了，二维的东西会聚合成一维，三维的东西会聚合成二维）</p> 
<p>同理如果是延第1维聚合，就是如下图：</p> 
<p><img alt="03612c6b80f84030887cda10ae27e803.png" src="https://images2.imgbox.com/29/b7/6bWw8j2W_o.png"></p> 
<p>最终得到三行一列的3个值（其实已经没有列这个维度了）</p> 
<p>这里插一句，如果我仍然想保留列这个维度呢？只要把keepdims指定为True就行了（默认是False）</p> 
<p><img alt="8db12e7f75b14168b004d2c033d11313.png" src="https://images2.imgbox.com/97/b1/f7Qdwp45_o.png"></p> 
<p>可以看到结果仍然是二维的</p> 
<p><img alt="b01b7de6ba7a45d7bcb6ad7f665e2a35.png" src="https://images2.imgbox.com/76/ef/QXX4OcWz_o.png"></p> 
<h3>2.那argmax的结果又是啥呢？</h3> 
<p>还是3行4列，按第0维聚合，现在看argmax的结果，再贴一下代码，现在主要看的是a_max_x_arg = a.argmax(axis=0)</p> 
<pre><code class="language-python">import numpy as np
import numpy.random

np.random.seed(0)
a = np.random.randint(0, 100, (3, 4), dtype=np.int32)
print(f'a:\r\n{a}')
a_max_x = a.max(axis=0)
print(f'a_max_x:\r\n{a_max_x}')
a_max_x_arg = a.argmax(axis=0)
print(f'a_max_x_arg:\r\n{a_max_x_arg}')</code></pre> 
<p>其结果就是如下图，每次聚合的时候，到底最大的那个值的x值（即第0维的坐标）是多少（而max是直接求出最大的元素值，而非坐标值）</p> 
<p><img alt="3e73b4dbc37a46fa9687543f4c36fe50.png" src="https://images2.imgbox.com/2d/82/220ADvYH_o.png"></p> 
<p><img alt="8948871439104a2aa60a949ab4baf6f0.png" src="https://images2.imgbox.com/e3/15/aEVJ9cyQ_o.png"></p> 
<p>注意这里x值是从0开始算的。</p> 
<p>这个结果有什么用呢？这个结果可以作用在原数组上，求出聚合值。</p> 
<h4>(1)先来个最最简单的，原数组就是1维的</h4> 
<pre><code class="language-python">import numpy as np
import numpy.random

np.random.seed(0)
a = np.random.randint(0, 100, (3,), dtype=np.int32)
print(f'a:\r\n{a}')
a_max_x = a.max(axis=0)
print(f'a_max_x:\r\n{a_max_x}')
a_max_x_arg = a.argmax(axis=0)
print(f'a_max_x_arg:\r\n{a_max_x_arg}')
another_a_max_x = a[a_max_x_arg]
print(f'有点绕的a_max_x:\r\n{another_a_max_x}')</code></pre> 
<p><img alt="343350ad215541f0bd1df18700b0f6c6.png" src="https://images2.imgbox.com/a8/8c/F5Wjhrj7_o.png"></p> 
<p>由于是一维的，这里求出的最大值下标(a_max_x_arg)就是一个标量，因为只有一个值。那直接用a[a_max_x_arg]就能求出最大值啦，如上图，红框的两个值是一样的，只是后者多绕了一步。</p> 
<p><em>你可能会问，我既然能直接求出最大值，我干麻还先求个下标，再用它去取最大值？</em></p> 
<p><em>因为有的时候你会有多个数组，比如一个是成绩数组，一个是学号数组或者学生名字数组（numpy数组的类型也可以是字符串哦），我不但要求出最高的成绩，我还想知道它对应的学号或者名字，这个时候你就得先求下标，再求成绩和学号。</em></p> 
<h4>(2)二维的</h4> 
<pre><code class="language-python">import numpy as np
import numpy.random

np.random.seed(0)
a = np.random.randint(0, 100, (3, 4), dtype=np.int32)
print(f'a:\r\n{a}')
a_max_x = a.max(axis=0)
print(f'a_max_x:\r\n{a_max_x}')
a_max_x_arg = a.argmax(axis=0)
print(f'a_max_x_arg:\r\n{a_max_x_arg}')
another_a_max_x = a[a_max_x_arg, range(4)]
print(f'有点绕的a_max_x:\r\n{another_a_max_x}')
</code></pre> 
<p><img alt="ecb64b48b3eb4cc2987e796d2ff8b10b.png" src="https://images2.imgbox.com/dd/33/qcHy4fmx_o.png"></p> 
<p>如上图，红框就是直接求出的最大值与间接求出的最大值，绿框就是4个最大值的下标x，它们分别对应的y是几呢，肯定是0、1、2、3啊，还记得吗，y是外层循环啊，每个y值都会遍历一遍。所以argmax的结果没必要再给你返回y，毫无悬念的多余信息不会返回给你！</p> 
<p>4个x与4个y的对应关系如下图。</p> 
<p><img alt="71b1c89ff4844022b64fdedab79980a8.png" src="https://images2.imgbox.com/bd/a1/Zasnbqqe_o.png"></p> 
<p>所以在原数组上取最大值的时候，自然就是用a[a_max_x_arg, range(4)]这种形式来取，0维、1维分别是一个序列，它的意思就是在原数组上分别取出(x=1,y=0),(x=2,y=1),(x=1,y=2),(x=2,y=3)的4个值。</p> 
<h4>(3)三维的</h4> 
<p>先等下，三维的最大值是怎么取的还没讲呢</p> 
<h3>3.三维数组的聚合逻辑</h3> 
<pre><code class="language-python">import numpy as np
import numpy.random

np.random.seed(0)
a = np.random.randint(0, 100, (2, 3, 4), dtype=np.int32)
print(f'a:\r\n{a}')
a_max_x = a.max(axis=0)
print(f'a_max_x:\r\n{a_max_x}')</code></pre> 
<p>其实如果二维数组的聚合逻辑理解了，更多维度的也就理解了，还是那句话，固定其它维度，在单一维度上做聚合。所以如果是三维数组，在第0维(x轴)聚合，那就是每次都固定1维(y轴)、2维(z轴)，取x轴上的多个值，求最大值。</p> 
<p>此时如果用代码循环来求结果，需要3层循环，外面两层是y轴、z轴（谁先谁后无所谓），最内层是x轴。</p> 
<p><img alt="ce2022e3de05458584e0c48a3e052b01.png" src="https://images2.imgbox.com/22/06/mf9fgxng_o.png"></p> 
<p>图1</p> 
<p>示例如上图。最终聚合出来的就是保留y、z两个维度的二维数组了。</p> 
<p>如果是按第1维聚合，那就是每次固定0维(x)，2维(z)，取第1维(y)的多个值做聚合。</p> 
<h3>4.三维的argmax结果怎么用呢？</h3> 
<p><img alt="e93ba2af621944c08a6b08ba2253b734.png" src="https://images2.imgbox.com/c9/41/DDwk63c4_o.png"></p> 
<p>图2</p> 
<p>如图2是2行3列4垂的三维数组按第0维聚合得到的argmax结果，如果二维的argmax想明白了，三维的聚合逻辑也想明白了，那就会知道，这里的argmax结果中指的全是第0维的坐标值（即x值），那它们对应的y、z是多少？其实y就是这个二维数组的第0维的下标、z就是这个二维数组的第1维的下标。如果觉得有点绕，把三维数组聚合逻辑中的图1再看看。</p> 
<p>接下来怎么用这个结果去原数组上取出聚合结果呢？</p> 
<p>a[a_max_x_arg, range(3), range(4)] 这样行不行？</p> 
<p>肯定不行，因为这3个东西的形状不一样啊。如果3个都是1维序列（假设长度为都是3），那可以，含义就是我要从3维数组里取3个值，我分别告诉你这3个值的x、y、z下标是多少。</p> 
<pre><code class="language-python">import numpy as np
import numpy.random

np.random.seed(0)
a = np.random.randint(0, 100, (2, 3, 4), dtype=np.int32)
print(f'a:\r\n{a}')
print(a[[0, 0, 0], range(3), range(3)])
</code></pre> 
<p>比如如上代码，取的就是下图中红框中的值</p> 
<p><img alt="" height="231" src="https://images2.imgbox.com/2c/26/d9loOfsd_o.png" width="233"></p> 
<p>现在回到之前的场景，argmax给我返回的是在所有的y、z上聚合出的结果的x值，即a_max_x_arg，它是一个二维的数组，你用它去索引原数组的时候，那对应的y、z也得是同样的形状才行啊，即是相同形状的二维数组，并且其中的每个值都是与x相对应的。y、z的值如下。结合上面的聚合逻辑想一想，是不是这样。</p> 
<p><img alt="" height="210" src="https://images2.imgbox.com/01/a4/2q8KEKR0_o.png" width="204"></p> 
<p>代码中怎么用呢，直接用a[a_max_x_arg, np.arange(3)[:, None], np.arange(4)]就行啦，这里是利用了广播机制，它们两广播后就会变成上面的样子。</p> 
<pre><code class="language-python">import numpy as np
import numpy.random

np.random.seed(0)
a = np.random.randint(0, 100, (2, 3, 4), dtype=np.int32)
print(f'a:\r\n{a}')
a_max_x = a.max(axis=0)
print(f'a_max_x:\r\n{a_max_x}')
a_max_x_arg = a.argmax(axis=0)
print(f'a_max_x_arg:\r\n{a_max_x_arg}')

another_a_max_x = a[a_max_x_arg, np.arange(3)[:, None], np.arange(4)]
print(f'有点绕的a_max_x:\r\n{another_a_max_x}')</code></pre> 
<p>完整代码如上。</p> 
<p><img alt="" height="510" src="https://images2.imgbox.com/61/6a/wqw8Krh5_o.png" width="206"></p> 
<p>索引后取到的最大值与直接计算的最大值是一样的吧！</p> 
<h2>四。举个生动点的例子</h2> 
<p>接下来举一个更实际的例子，可以自已检验一下到底理解了没有，空讲x、y、z三个维度太抽象啦，还是2行3列4垂，但是给它赋予具体的含义。</p> 
<p>现在有2个班级，每个班级有3组，每组有4个学生（小班化教学~~），现在有一个三维数组，存的就是这些学生的考试成绩，所以就是2行3列4垂的数组了。</p> 
<p>现在要淘汰学生，按某维度聚合，只保留成绩最高的学生。</p> 
<h3>问题1：如果按第0维聚合，最终得到的是什么结果？有几个班级？几个组？每组几个学生？</h3> 
<p>结果就是只有一个班级啦（其实班级维度已经没了，还记得吗，除非加上keepdims=True），仍然是3组，每组4个学生。想一想，具体是怎么两两淘汰的，印象会更深刻哦。</p> 
<h3>问题2：如果现在的淘汰要求是，每班只留下成绩最高的学生，其余的全淘汰！应该按哪个维度聚合？</h3> 
<p>给你挖了个坑哈哈，延单一维度无法聚合出这个结果啊，因为你需要把第1维（y）、第2维（z）全聚合了才行。具体做法可以有多种啦，比如分两次聚合，或者先把数组reshape成2行12列，然后按第1维聚合。</p> 
<h2>五。torch的max</h2> 
<p>上面讲的都是numpy，那pytorch呢？其实是一样的啊，顶多是函数名、参数啥的有点区别，比如pytorch的维度参数名不叫axis，叫dim。至于聚合时保留原维度，同样也叫keepdims。</p> 
<p>直接上一个示例</p> 
<pre><code class="language-python">import torch
torch.random.manual_seed(0)
a = torch.randint(0, 100, (3, 4), dtype=torch.int32)
a_max_x, a_max_x_arg = a.max(dim=0)
print(f'a:\r\n{a}')
print(f'a_max_x:\r\n{a_max_x}')
print(f'a_max_x_arg:\r\n{a_max_x_arg}')
another_a_max_x = a[a_max_x_arg, range(4)]
print(f'有点绕的a_max_x:\r\n{another_a_max_x}')</code></pre> 
<p><img alt="59fdbb04b05b41c8b672f84428421270.png" src="https://images2.imgbox.com/33/52/IEbmvLwe_o.png"></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/60d3356c5f7f477096094a0433e16153/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android 给广播接收器增加权限（permission）或signature签名权限</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/13d00d7b75f57f0870a9629664903b58/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端LayUI框架快速上手详解(二)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>