<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>干货篇 | 当CPU使用率达到100%该怎么办？ - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="干货篇 | 当CPU使用率达到100%该怎么办？" />
<meta property="og:description" content="不知道大家有没有遇到过服务器的CPU使用率达到了100%的情况，在实际生产环境中如果遇到了这种情况我们该怎么办？
接下来我就跟大家探讨一下：当CPU的使用率达到了100%的时候我们该如何排查、定位、找出问题根源。
CPU使用率 Linux作为一个多任务操作系统，将每个CPU的时间划分为很短的时间片，然后在通过调度器轮流分配给各个任务使用，因此造成多任务同时进行的错觉。
CPU使用率：就是CPU处在非空闲状态的时间占总CPU时间的百分比
而CPU使用率中也有很多相关的重要指标，我们可以通过 top 命令简单列举出来
user（缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。nice（缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低system（缩写为 sys），代表内核态 CPU 时间。idle（缩写为 id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。iowait（缩写为 wa），代表等待 I/O 的 CPU 时间。irq（缩写为 hi），代表处理硬中断的 CPU 时间。softirq（缩写为 si），代表处理软中断的 CPU 时间。steal（缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。 如何查看CPU使用率 在介绍查看CPU使用率的工具之前，我们先来想一个问题：这些性能工具是怎么计算CPU使用率的？
事实上，为了计算CPU使用率，大多数性能工具一般都会取间隔一段时间（比如3秒）的两次值作差后，再计算出这段时间内的平均CPU使用率
这个公式，就是大多数性能工具所看到的CPU使用率的实际计算方法。所以，在使用这些工具的时候我们要注意间隔时间的设置
top 工具和 ps 工具
top 和 ps 是最常用的性能分析工具，其中：
top 显示系统总体的CPU和内存使用情况，以及各个进程的资源使用情况
ps 显示每个进程的资源使用情况
sysstat 工具
除了上面这两个最常用的工具之外，我们还可以使用 sysstat 工具中的 pidstat 命令来查看进程的CPU使用率" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/08bf813009ab1b941ee0c5b3ecf1da0b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-08T16:16:50+08:00" />
<meta property="article:modified_time" content="2021-07-08T16:16:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">干货篇 | 当CPU使用率达到100%该怎么办？</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>不知道大家有没有遇到过服务器的CPU使用率达到了100%的情况，在实际生产环境中如果遇到了这种情况我们该怎么办？</p> 
<p>接下来我就跟大家探讨一下：当CPU的使用率达到了100%的时候我们该如何排查、定位、找出问题根源。</p> 
<h2><a id="CPU_4"></a>CPU使用率</h2> 
<p>Linux作为一个多任务操作系统，将每个CPU的时间划分为很短的时间片，然后在通过调度器轮流分配给各个任务使用，因此造成多任务同时进行的错觉。</p> 
<p>CPU使用率：就是CPU处在非空闲状态的时间占总CPU时间的百分比</p> 
<p>而CPU使用率中也有很多相关的重要指标，我们可以通过 top 命令简单列举出来</p> 
<ul><li>user（缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。</li><li>nice（缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低</li><li>system（缩写为 sys），代表内核态 CPU 时间。</li><li>idle（缩写为 id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。</li><li>iowait（缩写为 wa），代表等待 I/O 的 CPU 时间。</li><li>irq（缩写为 hi），代表处理硬中断的 CPU 时间。</li><li>softirq（缩写为 si），代表处理软中断的 CPU 时间。</li><li>steal（缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。</li></ul> 
<h2><a id="CPU_20"></a>如何查看CPU使用率</h2> 
<p>在介绍查看CPU使用率的工具之前，我们先来想一个问题：这些性能工具是怎么计算CPU使用率的？</p> 
<p>事实上，为了计算CPU使用率，大多数性能工具一般都会取间隔一段时间（比如3秒）的两次值作差后，再计算出这段时间内的平均CPU使用率</p> 
<p>这个公式，就是大多数性能工具所看到的CPU使用率的实际计算方法。所以，在使用这些工具的时候我们要注意间隔时间的设置</p> 
<p><strong>top 工具和 ps 工具</strong></p> 
<p>top 和 ps 是最常用的性能分析工具，其中：</p> 
<p>top 显示系统总体的CPU和内存使用情况，以及各个进程的资源使用情况</p> 
<p>ps 显示每个进程的资源使用情况</p> 
<p><strong>sysstat 工具</strong></p> 
<p>除了上面这两个最常用的工具之外，我们还可以使用 sysstat 工具中的 pidstat 命令来查看进程的CPU使用率</p> 
<pre><code class="prism language-bash">格式：

pidstat <span class="token punctuation">[</span> 选项 <span class="token punctuation">]</span> <span class="token punctuation">[</span> <span class="token operator">&lt;</span>时间间隔<span class="token operator">&gt;</span> <span class="token punctuation">]</span> <span class="token punctuation">[</span> <span class="token operator">&lt;</span>次数<span class="token operator">&gt;</span> <span class="token punctuation">]</span>
​
<span class="token comment"># 常用选项</span>
-u：默认的参数，显示各个进程的cpu使用统计
-r：显示各个进程的内存使用统计
-d：显示各个进程的IO使用情况
-p：指定进程号
-w：显示每个进程的上下文切换情况
-t：显示选择任务的线程的统计信息外的额外信息
</code></pre> 
<p>上面这些工具你可以轻松找出哪个CPU使用率较高的进程，但是找到进程还不够，我们还想找出是哪个具体进程或者具体函数占用了如此高的CPU时间，这样才能进行更好的优化、</p> 
<p>这里我推荐一个可以在第一时间分析进程的CPU问题的工具——perf</p> 
<p><strong>perf top</strong></p> 
<p>perf 是一种 Linux 内置的性能分析工具。它以性能事件采样为基础，不仅可以分析系统的各种事件和内核进程，还可以用来分析指定应用程序的性能问题</p> 
<p>perf top 类似于 top ，它能够实时显示占用CPU时钟最多的函数或者指令，因此可以查找出热点函数</p> 
<pre><code class="prism language-bash">$ perf <span class="token function">top</span>
Samples: <span class="token number">833</span>  of event <span class="token string">'cpu-clock'</span>, Event count <span class="token punctuation">(</span>approx.<span class="token punctuation">)</span>: <span class="token number">97742399</span>
Overhead  Shared Object       Symbol
   <span class="token number">7.28</span>%  perf                <span class="token punctuation">[</span>.<span class="token punctuation">]</span> 0x00000000001f78a4
   <span class="token number">4.72</span>%  <span class="token punctuation">[</span>kernel<span class="token punctuation">]</span>            <span class="token punctuation">[</span>k<span class="token punctuation">]</span> vsnprintf
   <span class="token number">4.32</span>%  <span class="token punctuation">[</span>kernel<span class="token punctuation">]</span>            <span class="token punctuation">[</span>k<span class="token punctuation">]</span> module_get_kallsym
   <span class="token number">3.65</span>%  <span class="token punctuation">[</span>kernel<span class="token punctuation">]</span>            <span class="token punctuation">[</span>k<span class="token punctuation">]</span> _raw_spin_unlock_irqrestore
</code></pre> 
<p>从输出结果我们可以看出：</p> 
<p>第一行包含三个数据：采样数（Samples）、事件类型（event）和事件总数量（Event count）。这个例子中 perf 总共采集了833个CPU时钟时间，而总事件数为97742399</p> 
<p>接着我们从列的角度来看：</p> 
<ul><li> <p>第一列：Overhead ，是该符号的性能事件在所有采样中的比例，用百分比来表示</p> </li><li> <p>第二列：：Shared ，是该函数或指令所在的动态共享对象（Dynamic Shared<br> Object），如内核、进程名、动态链接库名、内核模块名等。</p> </li><li> <p>第三列 ：Object 是动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间。</p> </li><li> <p>第四列：Symbol 是符号名，也就是函数名。当函数名未知时，用十六进制的地址来表示。</p> </li></ul> 
<p><strong>perf record 、perf report</strong></p> 
<p>perf top 虽然实时展示了系统的性能信息，但是它并不能保存数据，就意味着无法用于离线或者后续的分析</p> 
<p>而perf record 则提供了保存数据的功能，保存后的数据，需要你用 perf report 解析展示。</p> 
<pre><code class="prism language-bash">$ perf record <span class="token comment"># 按Ctrl+C终止采样</span>
<span class="token punctuation">[</span> perf record: Woken up <span class="token number">1</span> <span class="token builtin class-name">times</span> to <span class="token function">write</span> data <span class="token punctuation">]</span>
<span class="token punctuation">[</span> perf record: Captured and wrote <span class="token number">0.452</span> MB perf.data <span class="token punctuation">(</span><span class="token number">6093</span> samples<span class="token punctuation">)</span> <span class="token punctuation">]</span>
​
$ perf report <span class="token comment"># 展示类似于perf top的报告。有时候还会加上-g参数来开启调用关系的采样</span>
</code></pre> 
<h2><a id="_110"></a>案例</h2> 
<p>下面我将用极客时间里的一个例子，来展现当我们发现CPU使用率过高的问题后，要怎么使用各种性能工具找出异常的进程，又要怎么利用各种工具找出引发性能问题的函数</p> 
<p>这次案例里面，我们预先安装了 sysstat、perf、ab 等工具</p> 
<p>左边这台用作 Web 服务器，来模拟性能问题；右边用作客户端，来给 Web 服务器增加压力请求</p> 
<p>首先运行我们的 web 服务器，运行之后验证一下 Nginx 是否正常开启</p> 
<pre><code class="prism language-bash"><span class="token variable">$curl</span> <span class="token number">192.168</span>.1.1:80
​
It works<span class="token operator">!</span>
</code></pre> 
<p>接下来我们在客户端测试一下 web 服务器的性能</p> 
<pre><code class="prism language-bash"><span class="token comment"># 并发10个请求测试Nginx性能，总共测试100个请求</span>
$ ab -c <span class="token number">10</span> -n <span class="token number">100</span> http://192.168.1.1:80
This is ApacheBench, Version <span class="token number">2.3</span> <span class="token operator">&lt;</span><span class="token variable">$Revision</span><span class="token builtin class-name">:</span> <span class="token number">1706008</span> $<span class="token operator">&gt;</span>
Copyright <span class="token number">1996</span> Adam Twiss, Zeus Technology Ltd, 
<span class="token punctuation">..</span>.
Requests per second:    <span class="token number">11.63</span> <span class="token punctuation">[</span><span class="token comment">#/sec] (mean)</span>
Time per request:       <span class="token number">859.942</span> <span class="token punctuation">[</span>ms<span class="token punctuation">]</span> <span class="token punctuation">(</span>mean<span class="token punctuation">)</span>
<span class="token punctuation">..</span>.
</code></pre> 
<p>从ab的输出可以看到，Nginx能承受的每秒平均请求数只有11.63。这个结果说明Nginx 目前的性能不尽人意，我们先用top和pidstat看一下到底是哪里出了问题</p> 
<p>运行ab命令，持续给Nginx压力，方便我们使用性能分析工具</p> 
<pre><code class="prism language-bash"><span class="token comment">#并发10个请求，总共10000个请求</span>
$ ab -c <span class="token number">10</span> -n <span class="token number">10000</span> http://192.168.1.1:80
</code></pre> 
<p>运行 top 命令，按下数字1，切换到每个CPU使用情况（单核系统不需要按）</p> 
<pre><code class="prism language-bash">$ <span class="token function">top</span>
<span class="token punctuation">..</span>.
%Cpu0  <span class="token builtin class-name">:</span> <span class="token number">98.7</span> us,  <span class="token number">1.3</span> sy,  <span class="token number">0.0</span> ni,  <span class="token number">0.0</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st
%Cpu1  <span class="token builtin class-name">:</span> <span class="token number">99.3</span> us,  <span class="token number">0.7</span> sy,  <span class="token number">0.0</span> ni,  <span class="token number">0.0</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st
<span class="token punctuation">..</span>.
  PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
<span class="token number">21514</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">16384</span>   <span class="token number">8712</span> R  <span class="token number">41.9</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:06.00 php-fpm
<span class="token number">21513</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">13244</span>   <span class="token number">5572</span> R  <span class="token number">40.2</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:06.08 php-fpm
<span class="token number">21515</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">16384</span>   <span class="token number">8712</span> R  <span class="token number">40.2</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:05.67 php-fpm
<span class="token number">21512</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">13244</span>   <span class="token number">5572</span> R  <span class="token number">39.9</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:05.87 php-fpm
<span class="token number">21516</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">16384</span>   <span class="token number">8712</span> R  <span class="token number">35.9</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:05.61 php-fpm
</code></pre> 
<p>这里我们可以看到：</p> 
<p>系统中这几个php-fpm进程的CPU使用率加起来将近200%；而每个CPU的用户态使用率（us）也已经超过了98%</p> 
<p>所以我们可以得出结论：用户空间的php-fpm进程，导致了CPU使用率骤升</p> 
<p>接下来我们需要找出 php-fpm 进程里面哪个函数导致了CPU使用率的升高</p> 
<p>首先运行我们的 perf top 命令，实时分析进程的CPU问题</p> 
<pre><code class="prism language-bash"><span class="token comment"># -g参数开启调用关系分析，-p指定php-fpm的进程号21515</span>
$ perf <span class="token function">top</span> -g -p <span class="token number">21515</span>
</code></pre> 
<p>按方向键切换到php-fpm，再按下回车键开php-fpm的调用关系，你会发现，调用关系最终到了sqrt 和add_ function函数。</p> 
<p>找出了函数后我们再查看源码并修改优化</p> 
<p>优化后我们再测试一下</p> 
<pre><code class="prism language-bash">$ ab -c <span class="token number">10</span> -n <span class="token number">10000</span> http://192.168.1.1:80
<span class="token punctuation">..</span>.
Complete requests:      <span class="token number">10000</span>
Failed requests:        <span class="token number">0</span>
Total transferred:      <span class="token number">1720000</span> bytes
HTML transferred:       <span class="token number">90000</span> bytes
Requests per second:    <span class="token number">2237.04</span> <span class="token punctuation">[</span><span class="token comment">#/sec] (mean)</span>
Time per request:       <span class="token number">4.470</span> <span class="token punctuation">[</span>ms<span class="token punctuation">]</span> <span class="token punctuation">(</span>mean<span class="token punctuation">)</span>
Time per request:       <span class="token number">0.447</span> <span class="token punctuation">[</span>ms<span class="token punctuation">]</span> <span class="token punctuation">(</span>mean, across all concurrent requests<span class="token punctuation">)</span>
Transfer rate:          <span class="token number">375.75</span> <span class="token punctuation">[</span>Kbytes/sec<span class="token punctuation">]</span> received
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/058fae41ef1f8347c7361994ec536dfb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机科学与未解决的难题,NP（未解难题）_百度百科</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c8d4bea49ee2bcb0a7b1d2e0f8ba8df1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CRC32查表法的原理及汇编实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>