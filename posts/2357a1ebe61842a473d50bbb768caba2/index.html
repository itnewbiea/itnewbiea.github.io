<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringBoot&#43;druid&#43;aop动态数据源切换实现-修改中 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringBoot&#43;druid&#43;aop动态数据源切换实现-修改中" />
<meta property="og:description" content="目录
一、核心类AbstractRoutingDataSource
二、具体代码实现过程
1、自定义数据源类DynamicDataSource 2、切换操作类DynamicDataSourceHolder
3、配置动态数据源DynamicDataSourceConfig
4、定义注解DataSource
5、数据源切换切面DataSourceAspect
6、修改启动类-&gt;排除自动配置
三、附录相关配置文件
一、核心类AbstractRoutingDataSource Spring boot提供了AbstractRoutingDataSource 根据用户定义的规则选择当前的数据源，这样我们可以在执行查询之前，设置使用的数据源。
实现可动态路由的数据源，在每次数据库查询操作前执行。它的抽象方法 determineCurrentLookupKey() 决定使用哪个数据源。 org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource ：
对于该抽象类，关注两组变量和一个方法：
Map&lt;Object, Object&gt; targetDataSources和Object defaultTargetDataSourceMap&lt;Object, DataSource&gt; resolvedDataSources和DataSource resolvedDefaultDataSourceprotected abstract Object determineCurrentLookupKey(); 其中两组变量是相互对应的，在熟悉多实例数据源切换代码时不难发现，当有多个数据源的时候，一定要指定一个作为默认的数据源，在这里也同理，当同时初始化多个数据源的时候，需要显示的调用setDefaultTargetDataSource方法指定一个作为默认数据源； 我们需要关注的是
Map&lt;Object, Object&gt; targetDataSources和Map&lt;Object, DataSource&gt; resolvedDataSources，
targetDataSources是暴露给外部程序用来赋值的，用来添加多个数据源实例（DataSource），而resolvedDataSources是程序内部执行时把targetDataSources赋值到resolvedDataSources，因此会有一个赋值的操作，如下图所示：
根据这段源码可以看出，每次执行时，都会遍历targetDataSources内的所有元素并赋值给resolvedDataSources；这样如果我们在外部程序新增一个新的数据源，都会添加到内部使用，从而实现数据源的动态加载。
继承该抽象类的时候，必须实现一个抽象方法：
protected abstract Object determineCurrentLookupKey()
该方法用于指定到底需要使用哪一个数据源。
到此基本上清楚了该抽象类的使用方法，接下来贴下具体的实现代码
二、具体代码实现过程 1、自定义数据源类DynamicDataSource 自定义数据源DataSource类：
import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource; /** * @Description 自定义动态数据源类 */ public class DynamicDataSource extends AbstractRoutingDataSource { @Override protected Object determineCurrentLookupKey() { return DynamicDataSourceHolder.getDataSourceType(); } } 2、切换操作类DynamicDataSourceHolder 通过ThreadLocal维护一个全局唯一的map来实现数据源的动态切换" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2357a1ebe61842a473d50bbb768caba2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-19T22:44:50+08:00" />
<meta property="article:modified_time" content="2022-06-19T22:44:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringBoot&#43;druid&#43;aop动态数据源切换实现-修改中</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="main-toc-toc" style="margin-left:0px;"><a href="#main-toc" rel="nofollow">一、核心类AbstractRoutingDataSource</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B" rel="nofollow">二、具体代码实现过程</a></p> 
<p id="%E4%BA%8C%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E6%BA%90%E7%B1%BBDynamicDataSource%C2%A0-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E6%BA%90%E7%B1%BBDynamicDataSource%C2%A0" rel="nofollow">1、自定义数据源类DynamicDataSource </a></p> 
<p id="%E4%B8%89%E3%80%81%E5%88%87%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%B1%BBDynamicDataSourceHolder-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E5%88%87%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%B1%BBDynamicDataSourceHolder" rel="nofollow">2、切换操作类DynamicDataSourceHolder</a></p> 
<p id="%E5%9B%9B%E3%80%81%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90DynamicDataSourceConfig-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90DynamicDataSourceConfig" rel="nofollow">3、配置动态数据源DynamicDataSourceConfig</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3DataSource-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3DataSource" rel="nofollow">4、定义注解DataSource</a></p> 
<p id="%E5%85%AD%E3%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E5%88%87%E9%9D%A2DataSourceAspect-toc" style="margin-left:40px;"><a href="#%E5%85%AD%E3%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E5%88%87%E9%9D%A2DataSourceAspect" rel="nofollow">5、数据源切换切面DataSourceAspect</a></p> 
<p id="%C2%A0%E4%B8%83%E3%80%81%E4%BF%AE%E6%94%B9%E5%90%AF%E5%8A%A8%E7%B1%BB-%3E%E6%8E%92%E9%99%A4%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%B8%83%E3%80%81%E4%BF%AE%E6%94%B9%E5%90%AF%E5%8A%A8%E7%B1%BB-%3E%E6%8E%92%E9%99%A4%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE" rel="nofollow">6、修改启动类-&gt;排除自动配置</a></p> 
<p id="%E5%85%AB%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-toc" style="margin-left:0px;"><a href="#%E5%85%AB%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" rel="nofollow">三、附录相关配置文件</a></p> 
<hr id="hr-toc"> 
<h2><strong>一、核心类</strong><em>AbstractRoutingDataSource</em></h2> 
<p>Spring boot提供了<span style="color:#fe2c24;"><em><span style="background-color:#fef2f0;">AbstractRoutingDataSource</span></em><span style="background-color:#fef2f0;"> </span></span>根据用户定义的规则选择当前的数据源，这样我们可以在执行查询之前，设置使用的数据源。</p> 
<p>实现可动态路由的数据源，在每次数据库查询操作前执行。它的抽象方法 <span style="color:#fe2c24;"><em><span style="background-color:#fef2f0;">determineCurrentLookupKey() </span></em></span>决定使用哪个数据源。 </p> 
<p><em>org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource </em>：</p> 
<p class="img-center"><img alt="" height="246" src="https://images2.imgbox.com/87/97/V8YNMlMo_o.png" width="600"></p> 
<p>对于该抽象类，关注两组变量和一个方法：</p> 
<ol><li><em>Map&lt;Object, Object&gt; targetDataSources</em>和<em>Object defaultTargetDataSource</em></li><li><em>Map&lt;Object, DataSource&gt; resolvedDataSources</em>和<em>DataSource resolvedDefaultDataSource</em></li><li><em>protected abstract Object determineCurrentLookupKey();</em></li></ol> 
<p>其中两组变量是相互对应的，在熟悉多实例数据源切换代码时不难发现，当有多个数据源的时候，一定要指定一个作为默认的数据源，在这里也同理，当同时初始化多个数据源的时候，需要显示的调用setDefaultTargetDataSource方法指定一个作为默认数据源； </p> 
<p>我们需要关注的是</p> 
<p><span style="color:#fe2c24;"><em><span style="background-color:#fef2f0;">Map&lt;Object, Object&gt; targetDataSources</span></em></span>和<em><span style="color:#fe2c24;"><span style="background-color:#fef2f0;">Map&lt;Object, DataSource&gt; resolvedDataSources</span></span></em>，</p> 
<p>targetDataSources是暴露给外部程序用来赋值的，用来添加多个数据源实例（DataSource），而resolvedDataSources是程序内部执行时把targetDataSources赋值到resolvedDataSources，因此会有一个赋值的操作，如下图所示：</p> 
<p><img alt="" height="214" src="https://images2.imgbox.com/d9/42/B7DTJEnh_o.png" width="700"></p> 
<p>根据这段源码可以看出，每次执行时，<strong>都会遍历<span style="color:#fe2c24;"><em><span style="background-color:#fef2f0;">targetDataSources</span></em></span>内的所有元素并赋值给<span style="color:#fe2c24;"><em><span style="background-color:#fef2f0;">resolvedDataSources</span></em></span></strong>；这样如果我们在外部程序新增一个新的数据源，都会添加到内部使用，从而实现数据源的动态加载。</p> 
<p><strong>继承该抽象类的时候，必须实现一个抽象方法：</strong></p> 
<p><span style="color:#fe2c24;"><em><code><span style="background-color:#fef2f0;">protected abstract Object <strong>determineCurrentLookupKey()</strong></span></code></em></span></p> 
<p>该方法用于指定到底需要使用哪一个数据源。</p> 
<p>到此基本上清楚了该抽象类的使用方法，接下来贴下具体的实现代码</p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B">二、具体代码实现过程</h2> 
<h3 id="%E4%BA%8C%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E6%BA%90%E7%B1%BBDynamicDataSource%C2%A0">1、自定义数据源类<em><span style="background-color:#fbd4d0;">DynamicDataSource </span></em></h3> 
<p>自定义数据源DataSource类：</p> 
<pre><code>import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;

/**
 * @Description 自定义动态数据源类
 */
public class DynamicDataSource extends AbstractRoutingDataSource {
    @Override
    protected Object determineCurrentLookupKey() {
        return DynamicDataSourceHolder.getDataSourceType();
    }
}</code></pre> 
<h3 id="%E4%B8%89%E3%80%81%E5%88%87%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%B1%BBDynamicDataSourceHolder">2、切换操作类<em><span style="background-color:#fbd4d0;">DynamicDataSourceHolder</span></em></h3> 
<p>通过ThreadLocal维护一个全局唯一的map来实现数据源的动态切换</p> 
<pre><code>public class DynamicDataSourceHolder {

    private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;();

    public static void setDataSourceType(String dataSourceType) {
        contextHolder.set(dataSourceType);
    }

    public static String getDataSourceType() {
        return contextHolder.get();
    }

    public static void clearDataSourceType() {
        contextHolder.remove();
    }
}</code></pre> 
<h3 id="%E5%9B%9B%E3%80%81%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90DynamicDataSourceConfig">3、配置动态数据源<em><span style="background-color:#fbd4d0;">DynamicDataSourceConfig</span></em></h3> 
<p>Druid数据源加载过程图示</p> 
<p><img alt="" height="249" src="https://images2.imgbox.com/f3/a3/MRfMktBt_o.png" width="700">对自定义数据源进行配置，在<em><span style="background-color:#fbd4d0;">dynamicDataSource()</span></em>方法上加<em><span style="background-color:#fbd4d0;">@Primary</span></em>注解，优先使用我们自定义的数据源</p> 
<pre><code>import com.alibaba.druid.pool.DruidDataSource;
import com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

/**
 * @Description 动态数据源配置类
 */
@Configuration // 配置类
public class DynamicDataSourceConfig {

    private static final Logger log = LoggerFactory.getLogger(DynamicDataSourceConfig.class);

    @Bean//(initMethod = "init") // 初始化加载
    @ConfigurationProperties(prefix = "spring.datasource.master")
    public DruidDataSource masterDataSource(){
        return DruidDataSourceBuilder.create().build();
    }

    @Bean//(initMethod = "init") // 初始化加载
    @ConfigurationProperties(prefix = "spring.datasource.slave")
    public DruidDataSource slaveDataSource(){
        return DruidDataSourceBuilder.create().build();
    }

    @Primary//被注解为@Primary的Bean将作为首选者
    @Bean
    public DataSource dynamicDataSource(DataSource masterDataSource ,DataSource slaveDataSource){
        Map&lt;Object,Object&gt; targetDataSource = new HashMap&lt;&gt;();
        targetDataSource.put("master",masterDataSource);
        targetDataSource.put("slave",slaveDataSource);

        DynamicDataSource dynamicDataSource = new DynamicDataSource();
        dynamicDataSource.setTargetDataSources(targetDataSource); // 目标数据源列表
        dynamicDataSource.setDefaultTargetDataSource(masterDataSource); // 默认数据源
        // 数据源刷入
        // super.afterPropertiesSet();
        return dynamicDataSource;
    }

    /**
     * 将动态数据源添加到事务管理器中，并生成新的bean——&gt;待完善
     * @return the platform transaction manager
     */
//    @Bean
//    public PlatformTransactionManager transactionManager() {
//        return new DataSourceTransactionManager(dynamicDataSource(masterDataSource(),slaveDataSource()));
//    }
}</code></pre> 
<h3 id="%E4%BA%94%E3%80%81%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3DataSource">4、定义注解<span style="color:#0d0016;"><em><span style="background-color:#fbd4d0;">DataSource</span></em></span></h3> 
<p>设置动态路由的数据源注解</p> 
<pre><code>@Documented
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface DataSource {
    String value() default "master";
}</code></pre> 
<h3 id="%E5%85%AD%E3%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E5%88%87%E9%9D%A2DataSourceAspect">5、数据源切换切面<em><span style="background-color:#fbd4d0;">DataSourceAspect</span></em></h3> 
<p>使用注解来实现可动态路由的数据源，在每次数据库查询操作前执行</p> 
<pre><code>@Aspect
@Component
@Order(-1) // aop顺序,该切面应当先于 @Transactional 执行
public class DataSourceAspect {

    @Pointcut("@annotation(com.swadian.spring.dynamicDataSource.DataSource)")
    public void dataSourcePointCut(){
        // do nothing
    }

    @Around("dataSourcePointCut()")
    public Object around(ProceedingJoinPoint point) throws Throwable {
        MethodSignature signature = (MethodSignature) point.getSignature();
        Method method = signature.getMethod();
        DataSource annotation = method.getAnnotation(DataSource.class);
        if(annotation.value() != null){
            DynamicDataSourceHolder.setDataSourceType(annotation.value());
        }else{
            DynamicDataSourceHolder.setDataSourceType("master");
        }
        try {
            return point.proceed();
        } finally {
            // 清除本次key
            DynamicDataSourceHolder.clearDataSourceType();
        }
    }
}</code></pre> 
<h3 id="%C2%A0%E4%B8%83%E3%80%81%E4%BF%AE%E6%94%B9%E5%90%AF%E5%8A%A8%E7%B1%BB-%3E%E6%8E%92%E9%99%A4%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE">6、修改启动类-&gt;排除自动配置</h3> 
<p>启动类添加 <em><span style="background-color:#fbd4d0;">exclude = {DataSourceAutoConfiguration.class}</span></em>， 以禁用数据源默认自动配置。</p> 
<p>数据源默认自动配置会读取 <em><span style="background-color:#fbd4d0;">spring.datasource.* </span></em>的属性创建数据源，所以要禁用以进行定制。</p> 
<pre><code>@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
public class MyApplication {
    public static void main(String[] args) {
        Logger logger = LoggerFactory.getLogger(MyApplication.class);
        try {
            SpringApplication.run(MyApplication.class);
            logger.info("springBoot启动成功...");
        } catch (Exception e) {
            logger.info("SpringBoot启动失败...");
        }
    }
}</code></pre> 
<h2 id="%E5%85%AB%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">三、附录相关配置文件</h2> 
<p><strong>application.properties配置文件示例：</strong></p> 
<pre><code>#数据源1
spring.datasource.master.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.master.url=jdbc:mysql://localhost:3306/springbootdemo?useSSL=false
spring.datasource.master.username=root
spring.datasource.master.password=root
#数据源2
spring.datasource.slave.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.slave.url=jdbc:mysql://localhost:3306/seckill?useSSL=false
spring.datasource.slave.username=root
spring.datasource.slave.password=root

#映射器，Mapper包下所有的xml文件
mybatis.mapper-locations=classpath:mapper/*.xml
#开启驼峰模式
mybatis.configuration.map-underscore-to-camel-case=true</code></pre> 
<p><strong>pom.xml相关依赖示例：</strong></p> 
<pre><code>&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.3.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!-- MySQL 连接驱动依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.39&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--切面AOP--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--数据库连接池--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.1.18&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</code></pre> 
<p>参考资料：</p> 
<ul><li><a href="https://www.cnblogs.com/xifengxiaoma/p/11040336.html" rel="nofollow" id="cb_post_title_url" title="Spring Boot：实现MyBatis动态数据源">Spring Boot：实现MyBatis动态数据源</a></li><li><a href="https://www.cnblogs.com/xifengxiaoma/p/11040336.html" rel="nofollow" title="Spring Boot：实现MyBatis动态数据源 - 朝雨忆轻尘 - 博客园">Spring Boot：实现MyBatis动态数据源 - 朝雨忆轻尘 - 博客园</a></li><li> 
  <hr><p><a href="https://www.cnblogs.com/xiaotian1001/p/13098936.html" rel="nofollow" title="AbstractRoutingDataSource - 动态数据源">AbstractRoutingDataSource - 动态数据源</a></p> </li><li><a href="https://www.cnblogs.com/xiaotian1001/p/13098936.html" rel="nofollow" title="AbstractRoutingDataSource - 动态数据源 - xiaotian1021 - 博客园">AbstractRoutingDataSource - 动态数据源 - xiaotian1021 - 博客园</a></li><li> 
  <hr><p>基于Spring Boot实现Mybatis的多数据源切换和动态数据源加载</p> </li><li><a href="https://blog.csdn.net/YHYR_YCY/article/details/78894940" title="基于Spring Boot实现Mybatis的多数据源切换和动态数据源加载_【逸辰杳】的博客-CSDN博客_mybatis动态加载数据源">基于Spring Boot实现Mybatis的多数据源切换和动态数据源加载_【逸辰杳】的博客-CSDN博客_mybatis动态加载数据源</a></li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b76636427853ffecf794557a0cc9c97f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JS-BOM相关</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9a2899d32f97b46c765c4492eb01c463/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ONNXRUNTIME_EXCEPTION : Non-zero status code returned while running Where node. Name:‘Where‘</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>