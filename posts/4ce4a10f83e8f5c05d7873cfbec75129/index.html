<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>hash hashcode变化_面试官问我：hashcode 是什么？和equals是兄弟吗？ - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="hash hashcode变化_面试官问我：hashcode 是什么？和equals是兄弟吗？" />
<meta property="og:description" content="秋招的时候还记得面试官问过我hashcode是什么，对于int、long、string类型的hashcode有什么区别，和equals一起是怎么使用的，为什么重写hashcode的同时也要重写equals.八股文背多了，也只是会表面，有空的时候还是整理一下，顺便写了几个例子加深下印象。
hashcode 是什么？ hash 一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。hash 是一个函数，该函数中的实现就是一种算法，就是通过一系列的算法来得到一个 hash 值。每个对象都有 hashcode，对象的 hashcode 怎么得来的呢？
首先一个对象肯定有物理地址，对象的物理地址跟这个 hashcode 地址不一样，hashcode 代表对象的地址说的是对象在 hash 表中的位置，通过对象的内部地址(也就是物理地址)转换成一个整数，然后该整数通过 hash 函数的算法就得到了 hashcode。所以，hashcode 就是在 hash 表中对应的位置。
所有散列函数都有如下一个基本特性：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。
两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞。
常见的 Hash 函数有以下几个：
直接定址法：直接以关键字 k 或者 k 加上某个常数（k&#43;c）作为哈希地址。
数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。
除留余数法：用关键字 k 除以某个不大于哈希表长度 m 的数 p，将所得余数作为哈希表地址。
分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。
平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。
伪随机数法：采用一个伪随机数当作哈希函数。
定义 以下是关于 HashCode 的官方文档定义：
hashcode 方法返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。
hashCode 的常规协定是：在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。
如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。
以下情况不是必需的：
如果根据 equals(java.lang.Object)方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能
实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。） 当 equals 方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4ce4a10f83e8f5c05d7873cfbec75129/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-19T12:39:44+08:00" />
<meta property="article:modified_time" content="2020-12-19T12:39:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">hash hashcode变化_面试官问我：hashcode 是什么？和equals是兄弟吗？</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/4b/f9/icGCJwZ8_o.png" alt="94448baa109825367c980da7859b1db3.png"> 
 </div> 
 <p>秋招的时候还记得面试官问过我hashcode是什么，对于int、long、string类型的hashcode有什么区别，和equals一起是怎么使用的，为什么重写hashcode的同时也要重写equals.八股文背多了，也只是会表面，有空的时候还是整理一下，顺便写了几个例子加深下印象。</p> 
 <h3><b>hashcode 是什么？</b> </h3> 
 <p><b>hash</b> 一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。hash 是一个函数，该函数中的实现就是一种算法，就是通过一系列的算法来得到一个 hash 值。每个对象都有 hashcode，对象的 hashcode 怎么得来的呢？</p> 
 <p>首先一个对象肯定有物理地址，对象的物理地址跟这个 hashcode 地址不一样，hashcode 代表对象的地址说的是对象在 hash 表中的位置，通过对象的内部地址(也就是物理地址)转换成一个整数，然后该整数通过 hash 函数的算法就得到了 hashcode。所以，hashcode <b>就是在 hash 表中对应的位置。</b></p> 
 <p>所有散列函数都有如下一个基本特性：<b>根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。</b></p> 
 <p>两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做<b>碰撞</b>。</p> 
 <p><b>常见的 Hash 函数有以下几个：</b></p> 
 <p><b>直接定址法</b>：直接以关键字 k 或者 k 加上某个常数（k+c）作为哈希地址。</p> 
 <p><b>数字分析法</b>：提取关键字中取值比较均匀的数字作为哈希地址。</p> 
 <p><b>除留余数法</b>：用关键字 k 除以某个不大于哈希表长度 m 的数 p，将所得余数作为哈希表地址。</p> 
 <p><b>分段叠加法</b>：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。</p> 
 <p><b>平方取中法</b>：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。</p> 
 <p><b>伪随机数法</b>：采用一个伪随机数当作哈希函数。</p> 
 <h3><b>定义</b> </h3> 
 <p>以下是关于 <b>HashCode</b> 的官方文档定义：</p> 
 <p>hashcode 方法返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。</p> 
 <p>hashCode 的常规协定是：<b>在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。</b></p> 
 <p><b>如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。</b></p> 
 <p>以下情况不是必需的：<br>如果根据 equals(java.lang.Object)方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。<b>但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能</b><br>实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。） <b>当 equals 方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</b></p> 
 <hr> 
 <p>总结一下：<br>1.<b>hashcode 一致性</b> 同一个对象的 hashcode 肯定是一样的，无论调用多少次 hashcode 都不会变化，随着 equals 肯定也是一样的<br>2.<b>两个对象的 hashCode 相同，并不一定表示两个对象就相同</b>，也就是不一定适用于 equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如 Hashtable，他们“存放在同一个篮子里”。<br>3.<b>如果对象的 equals 方法被重写，那么对象的 hashCode 也尽量重写</b>，并且产生 hashCode 使用的对象，一定要和 equals 方法中使用的一致，</p> 
 <p>刚刚提到的碰撞，指的是不同对象的 hashcode 处在同一个 bucket 当中，<b>这个情况发生的概率越大说明这个 hashcode 设计的不够理想</b></p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/58/f9/8daCIBr7_o.png" alt="30a8b4d0d1c427938b61ecce51db79a1.png"> 
 </div> 
 <h3><b>hashcode 和 equals 的联系</b> </h3> 
 <p>当且仅当两个对象的hashcode和equals相同时，这两个对象才是同一个对象，否则不是。</p> 
 <p>那么快速判断两个对象的步骤是怎么样的呢，我们假设这里有两个不同的对象A和B。当我们的hashcode设计合理的时候，这两个对象的hashcode(A)是和hashcode(B)不相等的，那么这个时候我们就可以直接判断A和B不是同一对象。<b>但如果hashcode(A)==hashcode(B)呢？</b> 这个时候就要继续通过equals方法进行比较了，但是整个equals方法比hashcode复杂，所以设计一个好的hashcode函数至少可以节约90%以上的时间。</p> 
 <h3><b>java 中的 hashcode 是如何实现的</b> </h3> 
 <p>我们知道 java 内部 HashSet 和 HashMap 都是基于 hash 算法去实现的<br>hash算法的好坏，直接影响这个hashcode碰撞的几率，好的hashcode可以使得所有对象均匀地分布在bucket中</p> 
 <h4><b>1.Integer、Byte、Short、Character都是转换为int类型作为hashcode</b></h4> 
 <div class="has"> 
  <pre class="has"><code>    public static int hashCode(int value) {<!-- -->
        return value;
    }
</code></pre> 
 </div> 
 <p>可以看到hashcode在遇到Integer、Byte、Short、Character直接返回原数，不做处理。</p> 
 <div class="has"> 
  <pre class="has"><code>public class HashMapTest {<!-- -->
    public static void main(String[] args) {<!-- -->
        Integer a = 1;
        Integer b = 1;
        System.out.println(a.hashCode()+"  "+b.hashCode());
        System.out.println(a.equals(b));
    }
}
------------------------------------------------------------
1  1
true
</code></pre> 
 </div> 
 <h4><b>2.Long 取高32位和低32位与值转成int类型作为hashcode</b></h4> 
 <p>Double 将64bit值转成long类型，然后按照Long类型进行获取hashcode**</p> 
 <div class="has"> 
  <pre class="has"><code>    public static int hashCode(double value) {<!-- -->
        long bits = doubleToLongBits(value);
        return (int)(bits ^ (bits &gt;&gt;&gt; 32));
    }
</code></pre> 
 </div> 
 <p>long型是将自己的高32位和低32位拆成两个部分，然后两个部份直接做与操作得出的数字作为hashcode。</p> 
 <p>demo中a=1,b=1&lt;&lt;32，均为Long型，按照我们的设计两者的hashcode应该是一样的，但是不equals。看看我们的实验是否验证这个说法。</p> 
 <div class="has"> 
  <pre class="has"><code>public class HashMapTest {<!-- -->
    public static void main(String[] args) {<!-- -->
        long number = 1;
        Long a =(long)1;
        Long b = number&lt;&lt;32;
        System.out.println(a+" "+b);
        System.out.println(a.hashCode()+" "+b.hashCode() );
        System.out.println(a.equals(b));
    }
}
------------------
1 4294967296
1 1
false

</code></pre> 
 </div> 
 <p><b>看来还是逃不过equals。</b></p> 
 <p><b>doubleToLongBits</b>该方法可以将double类型数据转换成long类型数据，从而可以使double类型数据按照long的方法判断大小（&lt;, &gt;, ==）。</p> 
 <h4><b>3.String 将字符串里面的字符以31进制求和，既hash=hash*31+value[i]</b></h4> 
 <div class="has"> 
  <pre class="has"><code>    public int hashCode() {<!-- -->
        int h = hash;
        if (h == 0 &amp;&amp; value.length &gt; 0) {<!-- -->
            char val[] = value;

            for (int i = 0; i &lt; value.length; i++) {<!-- -->
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
    }
</code></pre> 
 </div> 
 <p><b>为什么选择31作为乘子</b></p> 
 <ol><li>31是一个不大不小的质数，是作为 hashCode 乘子的优选质数之一。另外一些相近的质数，比如37、41、43等等，也都是不错的选择。那么为啥偏偏选中了31呢？请看第二个原因。</li><li>31可以被 JVM 优化，31 * i = (i &lt;&lt; 5) - i。</li></ol> 
 <h4><b>4.Boolean true值hashcode为1231，false值hashcode为1237</b></h4> 
 <div class="has"> 
  <pre class="has"><code>      public static int hashCode(boolean value) {<!-- -->
        return value ? 1231 : 1237;
    }
</code></pre> 
 </div> 
 <h4><b>5.hashmap 放置元素的hashcode</b></h4> 
 <div class="has"> 
  <pre class="has"><code>    static final int hash(Object key) {<!-- -->
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    }
</code></pre> 
 </div> 
 <p>由于和（length-1）运算，length 绝大多数情况小于2的16次方。所以始终是hashcode 的低16位（甚至更低）参与运算。要是高16位也参与运算，会让得到的下标<b>更加散列</b>。</p> 
 <p>所以这样高16位是用不到的，如何让高16也参与运算呢。所以才有hash(Object key)方法。让他的hashCode()和自己的高16位^运算。所以(h &gt;&gt;&gt; 16)得到他的高16位与hashCode()进行^运算。</p> 
 <p><b>值得注意的是hashset存放的时候也是声明了一个hashmap进行存储，所以原理等同于hashmap</b></p> 
 <h3><b>demo</b> </h3> 
 <h4><b>demo1 案例 不重写 hashcode 和 equals：</b></h4> 
 <div class="has"> 
  <pre class="has"><code>public class HashCodeTest {<!-- -->
    private int number;
    public HashCodeTest(int number){<!-- -->
        this.number =number;
    }



    public static void main(String[] args) {<!-- -->
        HashCodeTest a = new HashCodeTest(1);
        HashCodeTest b = new HashCodeTest(1);
        System.out.println(a.hashCode());
        System.out.println(b.hashCode());
        System.out.println(a.equals(b));
    }
}
</code></pre> 
 </div> 
 <p><b>输出</b></p> 
 <blockquote>
   460141958 
  <br>1163157884 
  <br>false 
 </blockquote> 
 <p><b>分析:</b></p> 
 <p>两个不同的对象hashcode(a)和hashcode(b)肯定不同,a 对象和 b 对象调用 equal 函数肯定返回 false</p> 
 <h4><b>demo2 案例 只重写 hashcode:</b></h4> 
 <div class="has"> 
  <pre class="has"><code>public class HashCodeTest {<!-- -->
    private int number;
    public HashCodeTest(int number){<!-- -->
        this.number =number;
    }

    @Override
    public int hashCode() {<!-- -->
        return number%8;
    }

    public static void main(String[] args) {<!-- -->
        HashCodeTest a = new HashCodeTest(1);
        HashCodeTest b = new HashCodeTest(1);
        System.out.println(a.hashCode());
        System.out.println(b.hashCode());
        System.out.println(a.equals(b));
    }
}
</code></pre> 
 </div> 
 <p><b>输出：</b></p> 
 <blockquote>
   1 
  <br>1 
  <br>false 
 </blockquote> 
 <p><b>分析:</b></p> 
 <p>这个案例中只是覆写了 hashcode 这个方法，没有覆写 equals。<br>这两个不同的对象 hashcode 相同，但是 equals 不同。<br>从定义上看是 可以成立的。</p> 
 <p><b>但是 hashcode 过于简单，可能存在严重的哈希碰撞问题。而且必须满足同一对象的 hashcode 是一致的。最好是 equals 和 hashcode 同时覆写。</b></p> 
 <h4><b>demo3 只重写equals</b></h4> 
 <div class="has"> 
  <pre class="has"><code>public class HashCodeTest {<!-- -->
    private int number;
    public HashCodeTest(int number){<!-- -->
        this.number =number;
    }

    @Override
    public boolean equals(Object o) {<!-- -->
        HashCodeTest that = (HashCodeTest) o;
        return number == that.number;
    }



    public static void main(String[] args) {<!-- -->
        HashCodeTest a = new HashCodeTest(1);
        HashCodeTest b = new HashCodeTest(1);
        System.out.println(a.hashCode());
        System.out.println(b.hashCode());
        System.out.println(a.equals(b));

    }
}
</code></pre> 
 </div> 
 <p><b>输出：</b></p> 
 <blockquote>
   1956725890 
  <br>356573597 
  <br>true 
 </blockquote> 
 <p>只重写equals，可能会因为重写的方法不够完善导致原本两个hashcode不同的对象equals返回true,这是最无法容忍的现象。</p> 
 <p><b>和Jerry哥聊技术，聊生活</b></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2b0d0d94993e4c882228eecfc74399e8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">js 排序—— sort() 对普通数组、对象数组（单属性/多属性）排序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3074c0fe6c02ab28d4423842d97ccaa9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">GitHub使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>