<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java后端面试记录 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java后端面试记录" />
<meta property="og:description" content="2023-3-15： mysql中索引的数据结构，主键索引和普通索引的区别 主键索引和普通索引有什么区别?_主键索引和普通索引的区别_fly_zhaohy的博客-CSDN博客
jvm的内存区域，那些线程共享，那些线程不共享； 说一说jvm的类加载器，双亲委派机制。 造成内存溢出的原因，以及如何解决 以上三个问题请看此篇博客：【JVM】JVM内存模型(详细)_爱穿背带裤的馫的博客-CSDN博客
jvm的垃圾回收机制： JVM之垃圾回收机制（GC）_jvm gc_马小屑的博客-CSDN博客
说一说java中的阻塞队列。 Java 中的阻塞队列_java 阻塞队列_完了学不下的博客-CSDN博客
说一说java中的CopyOnWriteArrayList 线程安全的ArrayList——CopyOnWriteArrayList_copyonwritearraylist线程安全吗_秋枫-沐浠的博客-CSDN博客
说一说平衡二叉树： 平衡二叉树详解 通俗易懂_邓嘉文Jarvan的博客-CSDN博客
TCP/IP的三次握手，四次挥手 TCP 三次握手（Three-way Handshake）是建立 TCP 连接的过程，由客户端和服务器之间交换三个包（Segment）来确认彼此的能力、同步初始序列号（Sequence Number）等信息。具体过程如下：
第一次握手（SYN）：客户端发送一个 SYN 包，其中设置 SYN 标志位为 1，同时随机选择一个初始序列号 seq=x。
第二次握手（SYN&#43;ACK）：服务器收到客户端的 SYN 包后，如果同意连接，则向客户端发送一个 SYN&#43;ACK 包，其中设置 SYN 和 ACK 标志位均为 1，确认序列号 ack=x&#43;1，并随机选择一个自己的初始序列号 seq=y。
第三次握手（ACK）：客户端收到服务器返回的 SYN&#43;ACK 包后，确认序列号 ack=y&#43;1，然后发送一个 ACK 包给服务器，其中设置 ACK 标志位为 1，确认序列号 ack=y&#43;1。
当服务器收到该 ACK 包后，也确认序列号 ack=x&#43;1，并将连接状态设为已连接，至此，TCP 连接建立完成。
TCP 四次挥手（Four-way Handshake）是关闭 TCP 连接的过程，由客户端和服务器之间交换四个包来确认双方已经没有数据需要传输。具体过程如下：
第一次挥手（FIN）：客户端发送一个 FIN 数据包，其中设置 FIN 标志位为 1，表示客户端已经没有数据需要发送了，并请求服务器关闭连接。客户端进入 FIN_WAIT_1 状态。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/31989b774a1dc72bd49bca1459f882b5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-25T04:00:48+08:00" />
<meta property="article:modified_time" content="2023-07-25T04:00:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java后端面试记录</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<h2>2023-3-15：</h2> 
<h4>mysql中索引的数据结构，主键索引和普通索引的区别</h4> 
<p><a href="https://blog.csdn.net/fly_zhaohy/article/details/104014391" title="主键索引和普通索引有什么区别?_主键索引和普通索引的区别_fly_zhaohy的博客-CSDN博客">主键索引和普通索引有什么区别?_主键索引和普通索引的区别_fly_zhaohy的博客-CSDN博客</a></p> 
<h4>jvm的内存区域，那些线程共享，那些线程不共享；</h4> 
<h4>说一说jvm的类加载器，双亲委派机制。</h4> 
<h4>造成内存溢出的原因，以及如何解决</h4> 
<p>以上三个问题请看此篇博客：<a href="https://blog.csdn.net/twotwo22222/article/details/127890270" title="【JVM】JVM内存模型(详细)_爱穿背带裤的馫的博客-CSDN博客">【JVM】JVM内存模型(详细)_爱穿背带裤的馫的博客-CSDN博客</a></p> 
<h4>jvm的垃圾回收机制：</h4> 
<p><a href="https://blog.csdn.net/weixin_72753070/article/details/126011100" title="JVM之垃圾回收机制（GC）_jvm gc_马小屑的博客-CSDN博客">JVM之垃圾回收机制（GC）_jvm gc_马小屑的博客-CSDN博客</a></p> 
<h4>说一说java中的阻塞队列。</h4> 
<p><a href="https://blog.csdn.net/weixin_52383177/article/details/126972951" title="Java 中的阻塞队列_java 阻塞队列_完了学不下的博客-CSDN博客">Java 中的阻塞队列_java 阻塞队列_完了学不下的博客-CSDN博客</a></p> 
<h4>说一说java中的CopyOnWriteArrayList</h4> 
<p><a href="https://blog.csdn.net/weixin_43914913/article/details/120688743" title="线程安全的ArrayList——CopyOnWriteArrayList_copyonwritearraylist线程安全吗_秋枫-沐浠的博客-CSDN博客">线程安全的ArrayList——CopyOnWriteArrayList_copyonwritearraylist线程安全吗_秋枫-沐浠的博客-CSDN博客</a></p> 
<h4>说一说平衡二叉树：</h4> 
<p><a href="https://blog.csdn.net/jarvan5/article/details/112428036" title="平衡二叉树详解 通俗易懂_邓嘉文Jarvan的博客-CSDN博客">平衡二叉树详解 通俗易懂_邓嘉文Jarvan的博客-CSDN博客</a></p> 
<h4>TCP/IP的三次握手，四次挥手</h4> 
<p><strong>TCP 三次握手（Three-way Handshake）</strong>是建立 TCP 连接的过程，由客户端和服务器之间交换三个包（Segment）来确认彼此的能力、同步初始序列号（Sequence Number）等信息。具体过程如下：</p> 
<ol><li> <p>第一次握手（SYN）：客户端发送一个 SYN 包，其中设置 SYN 标志位为 1，同时随机选择一个初始序列号 seq=x。</p> </li><li> <p>第二次握手（SYN+ACK）：服务器收到客户端的 SYN 包后，如果同意连接，则向客户端发送一个 SYN+ACK 包，其中设置 SYN 和 ACK 标志位均为 1，确认序列号 ack=x+1，并随机选择一个自己的初始序列号 seq=y。</p> </li><li> <p>第三次握手（ACK）：客户端收到服务器返回的 SYN+ACK 包后，确认序列号 ack=y+1，然后发送一个 ACK 包给服务器，其中设置 ACK 标志位为 1，确认序列号 ack=y+1。</p> </li></ol> 
<p>当服务器收到该 ACK 包后，也确认序列号 ack=x+1，并将连接状态设为已连接，至此，TCP 连接建立完成。</p> 
<p><strong>TCP 四次挥手（Four-way Handshake）</strong>是关闭 TCP 连接的过程，由客户端和服务器之间交换四个包来确认双方已经没有数据需要传输。具体过程如下：</p> 
<ol><li> <p>第一次挥手（FIN）：客户端发送一个 FIN 数据包，其中设置 FIN 标志位为 1，表示客户端已经没有数据需要发送了，并请求服务器关闭连接。客户端进入 FIN_WAIT_1 状态。</p> </li><li> <p>第二次挥手（ACK）：服务器收到客户端的 FIN 数据包后，向客户端发送一个 ACK 数据包作为确认，其中设置 ACK 标志位为 1，确认序列号 ack=x+1。服务器进入 CLOSE_WAIT 状态。</p> </li><li> <p>第三次挥手（FIN）：当服务器也没有数据需要发送时，向客户端发送一个 FIN 数据包，其中设置 FIN 标志位为 1，请求客户端关闭连接。服务器进入 LAST_ACK 状态。</p> </li><li> <p>第四次挥手（ACK）：客户端收到服务器的 FIN 数据包后，向服务器发送一个 ACK 数据包作为确认，其中设置 ACK 标志位为 1，确认序列号 ack=y+1。客户端进入 TIME_WAIT 状态。当服务器收到该 ACK 数据包后，就可以关闭连接了。</p> </li></ol> 
<h4>对称加密和非对称加密的区别和以及适用场景</h4> 
<p>对称加密和非对称加密是两种常见的加密算法，它们在实现方式、安全性和适用场景等方面存在着一些区别。</p> 
<ol><li> <p>对称加密：对称加密使用同一个密钥来加密和解密数据。由于加密和解密使用相同的密钥，因此需要确保密钥的安全性，否则就容易遭受攻击。对称加密算法通常具有高效性和快速性等特点，适用于传输大量数据的场景，例如文件加密和网络通信等。</p> </li><li> <p>非对称加密：非对称加密使用一对密钥（公钥和私钥）来加密和解密数据。公钥可以公开发布，任何人都可以使用它来加密数据；而私钥只能由密钥拥有者来保管，用于解密数据。由于加密和解密使用不同的密钥，因此非对称加密算法通常更安全可靠，但运算速度较慢，适用于传输少量数据的场景，例如数字签名和密钥交换等。</p> </li></ol> 
<p>总体来说，对称加密适用于传输大量数据的场景，并且密钥需要被保护。而非对称加密则适用于传输少量数据的场景，并且密钥不需要被保护。在实际应用中，常常会将两种加密算法结合起来使用，以充分发挥它们各自的优势。例如，可以使用非对称加密算法来安全地传输对称加密算法使用的密钥。</p> 
<h4>说说https以及htpps是如何保证安全的。</h4> 
<p>HTTPS（Hyper Text Transfer Protocol Secure）是一种运行在 SSL/TLS 加密通道上的 HTTP 协议，它使用公钥加密和私钥解密技术来确保数据传输的安全性。HTTPS 相对于 HTTP 采用了加密传输方式，可以有效地防止窃听、篡改和伪造等网络攻击。</p> 
<p>具体来说，HTTPS 协议通过以下几个步骤来实现加密传输：</p> 
<ol><li> <p>客户端向服务器发起 HTTPS 请求，请求建立 SSL/TLS 安全连接。</p> </li><li> <p>服务器将自己的公钥证书发给客户端，客户端验证证书是否合法。</p> </li><li> <p>如果证书合法，客户端使用公钥加密一个随机密码，并发送给服务器。</p> </li><li> <p>服务器使用私钥解密客户端发送的随机密码，并生成一个对称密钥，用于后续的数据传输。</p> </li><li> <p>双方使用对称密钥进行数据传输，保证数据的机密性和完整性。</p> </li></ol> 
<p>HTTPS 的优点在于可以保证数据传输的安全性和可靠性，可以应用于网站登录、支付结算、在线购物等场景。同时，HTTPS 还有利于提升搜索引擎排名、增强用户信任度等方面。不过，HTTPS 也存在一些缺点，例如占用更多的服务器资源、加载速度较慢等。因此，在使用 HTTPS 时需要根据实际需求和资源情况进行权衡。</p> 
<p> </p> 
<p> </p> 
<h2>2023-3-24</h2> 
<h4>Mysql中的引擎和区别：</h4> 
<p>MySQL支持多种存储引擎，以下是其中一些最常用的引擎：</p> 
<ol><li> <p>InnoDB: 事务型存储引擎，支持ACID特性，提供高并发、高可靠性和高可用性。支持行级锁定，适合于需要频繁修改数据的应用。</p> </li><li> <p>MyISAM: 非事务型存储引擎，不支持ACID特性，只有表级锁定，适合于读操作比写操作多的应用。</p> </li></ol> 
<p>其中，两个最常用的引擎是InnoDB和MyISAM。InnoDB提供了事务处理、外键约束等高级功能，并且支持行锁定，适合于需要高并发读写、事务处理或者数据安全性要求比较高的应用程序。而MyISAM则简单易用，提供了全文搜索等特殊功能，但不支持事务处理和行锁定，适合于大量读取和很少更新的应用程序。</p> 
<h4>Redis中的数据结构，和适用场景  </h4> 
<p>Redis是一种内存数据库，支持多种数据结构。以下是Redis支持的主要数据结构及其适用场景：</p> 
<ol><li> <p>字符串(String): 适用于存储数值或文本字符串等简单类型数据，可作为缓存或计数器使用。</p> </li><li> <p>哈希(Hash): 适用于存储多个字段的对象，常被用来存储用户信息、商品信息等复杂数据。</p> </li><li> <p>列表(List): 适用于按照插入顺序排序的元素集合，可实现队列、堆栈等数据结构。</p> </li><li> <p>集合(Set): 适用于无序不重复元素的集合，可用于实现好友关系、标签搜索等。</p> </li><li> <p>有序集合(Zset): 适用于有序不重复元素的集合，可以根据元素得分(score)排序，可用于排行榜、范围查询等。</p> </li></ol> 
<p>在具体应用时，应根据实际需求选择合适的数据结构。例如，如果需要快速查找某个元素是否存在，可以使用集合(Set)；如果需要对元素进行有效期控制，可以将其存储在字符串(String)中，并设置过期时间；如果需要维护一个排序好的列表，可以使用有序集合(Zset)等。</p> 
<p> </p> 
<h4>SpringBoot中常用的注解</h4> 
<ol><li> <p>@SpringBootApplication: 标记启动类，包含@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan三个注解。</p> </li><li> <p>@RestController: 标记控制器类，并将其所有方法返回值默认解析为JSON格式。</p> </li><li> <p>@RequestMapping: 配置URL映射路径，可以设置请求的URL、请求方式、参数等信息。</p> </li><li> <p>@Autowired: 自动装配注解，自动注入一个对象实例，可以省略set方法。</p> </li><li> <p>@Value: 注入配置文件中的属性值，可以通过${key}或#{SpEL表达式}引用。</p> </li><li> <p>@Service: 标记服务层组件。</p> </li><li> <p>@Repository: 标记数据访问层组件。</p> </li><li> <p>@Component: 通用组件注解，可用于任何Bean组件。</p> </li><li> <p>@ConfigurationProperties: 绑定配置文件中的属性到Java Bean对象中。</p> </li><li> <p>@Transactional: 事务注解，标记方法需要在数据库事务管理下执行。</p> </li></ol> 
<p>以上这些注解仅是Spring Boot中的部分常用注解，还有很多其他注解可以根据实际需求使用。</p> 
<p> </p> 
<h4>@Controller和@RestController的区别</h4> 
<p>@Controller注解通常用于传统的Web应用程序中，该注解返回的数据默认被解析为视图(View)，即HTML、JSP等格式的页面。当然也可以在方法上使用@ResponseBody注解来返回JSON或XML等格式的数据。</p> 
<p>@RestController是新一代的控制器注解，主要用于构建RESTful风格的Web服务，该注解返回的数据默认被解析为JSON或XML等格式的数据，不会被视图解析器解析为视图。</p> 
<p>总之，@Controller用于传统的MVC Web应用程序中，而@RestController则更适合用于构建RESTful Web服务。</p> 
<p> </p> 
<h4>项目中如何解决的跨域问题</h4> 
<p>在Spring Boot项目中，可以通过以下几种方式解决跨域问题：</p> 
<ol><li> <p>在控制器方法上添加@CrossOrigin注解：该注解允许指定特定的源(Origin)可以访问资源，常用参数为origins和allowedHeaders。例如：</p> <pre><code class="language-java">@CrossOrigin(origins = "http://example.com", allowedHeaders = "*")</code></pre> </li><li> <p>配置CorsFilter过滤器：在Spring Boot项目中，可以使用CorsFilter过滤器来设置响应头信息，从而实现跨域访问。需要在@Configuration配置类中创建一个CorsFilter的Bean，并设置相关配置，例如：</p> <pre><code class="language-java">@Bean
public CorsFilter corsFilter() {
    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    CorsConfiguration config = new CorsConfiguration();
    config.setAllowCredentials(true);
    config.addAllowedOrigin("*");
    config.addAllowedHeader("*");
    config.addAllowedMethod("*");
    source.registerCorsConfiguration("/**", config);
    return new CorsFilter(source);
}
</code></pre> </li><li> <p>使用第三方库：Spring Boot还提供了一些第三方库来帮助解决跨域问题，例如spring-boot-starter-security、Spring Session等。</p> </li></ol> 
<p>以上这些方法都可以有效地解决Spring Boot项目中的跨域问题，需要根据具体情况选择合适的解决方案。</p> 
<p> </p> 
<h4>TCP和UDP的区别，TCP为什么可靠？</h4> 
<p>TCP和UDP是两种常用的传输层协议，主要区别如下：</p> 
<ol><li> <p>连接方式：TCP是面向连接的协议，必须先建立连接，然后才能进行通信；而UDP是无连接的协议，不需要事先建立连接就可以发送数据。</p> </li><li> <p>可靠性：TCP是一种可靠的协议，因为它提供了数据传输的确认、重传、拥塞控制等机制，确保数据能够被完整地传输到接收方。而UDP则是不可靠的协议，因为它不提供这些机制，发送的数据可能会丢失或者乱序。</p> </li><li> <p>速度：TCP的速度比UDP慢，因为TCP需要多次握手建立连接和维护状态信息，并进行拥塞控制和数据确认等操作；而UDP的速度比TCP快，因为它没有这些额外的管理机制。</p> </li><li> <p>应用场景：TCP主要用于对数据可靠性要求较高的应用，例如文件传输、电子邮件等；而UDP主要用于对实时性要求较高的应用，例如视频流、游戏等。</p> </li></ol> 
<p>TCP之所以可靠，是因为它提供了以下几个机制：</p> 
<ol><li> <p>序列号和确认机制：每个TCP报文都有一个唯一的序列号，用于重组和排序数据包。接收方会向发送方回复一个确认报文(ACK)来表示已经收到了这个序列号的数据。</p> </li><li> <p>重传机制：如果发送方在一定时间内没有收到接收方的ACK报文，就会重新发送这个数据包，确保数据能够被完整地传输。</p> </li><li> <p>拥塞控制机制：TCP会根据网络状况来动态调整发送数据的速率，避免网络拥塞和数据丢失。</p> </li><li> <p>流量控制机制：TCP会动态调整发送方的窗口大小，以限制发送速率，确保接收方能够处理数据。</p> </li></ol> 
<p>综上所述，TCP是一种可靠的协议，提供了多种机制来确保数据的完整性和可靠性。</p> 
<h4>HTTP常见的状态码</h4> 
<ol><li> <p>1xx: 信息性状态码，表示服务器已接收请求，正在处理请求或需要客户端进一步操作等。</p> 
  <ul><li>100 Continue: 表示服务器正常处理请求，并需要客户端继续提交余下部分的请求。</li><li>101 Switching Protocols: 表示服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。</li></ul></li><li> <p>2xx: 成功状态码，表示服务器成功接收、理解和处理请求。</p> 
  <ul><li>200 OK: 表示请求已成功，且服务器已返回所请求的数据。</li><li>201 Created: 表示请求已完成并创建了一个新的资源。</li><li>204 No Content: 表示请求已成功，但响应报文中没有实体的主体部分。</li></ul></li><li> <p>3xx: 重定向状态码，表示客户端需要采取某些特殊的操作才能完成请求。</p> 
  <ul><li>301 Moved Permanently: 请求的资源已永久移动到新的位置。</li><li>302 Found: 请求的资源已经临时移动到新的位置。</li><li>304 Not Modified: 当浏览器发现自己缓存的页面还没有过期，会发出这个状态码，告诉服务器此时不需要重新发送页面。</li></ul></li><li> <p>4xx: 客户端错误状态码，表示客户端提交的请求有误或无法被服务器处理。</p> 
  <ul><li>400 Bad Request: 请求报文中存在语法错误或无法处理该请求。</li><li>401 Unauthorized: 请求需要身份验证，客户端未提供有效的身份证明。</li><li>403 Forbidden: 请求被服务器拒绝，因为客户端没有访问资源的权限。</li><li>404 Not Found: 请求的资源不存在。</li></ul></li><li> <p>5xx: 服务器错误状态码，表示服务器在尝试处理请求时内部出错或遇到了意外情况。</p> 
  <ul><li>500 Internal Server Error: 服务器在完成请求时遇到了意料不到的条件。</li><li>502 Bad Gateway: 作为代理或网关的服务器收到了无效的响应。</li><li>504 Gateway Timeout: 作为代理或网关的服务器在等待其他服务器响应时超时</li></ul></li></ol> 
<h4>MySQL中的索引类型</h4> 
<p>在MySQL中，常见的索引类型包括主键索引、非主键索引和唯一索引，它们分别如下：</p> 
<ol><li> <p>主键索引（Primary Key Index）：主键索引是一种特殊的索引类型，用于唯一标识表中的每一行数据。主键索引在建表时可以通过PRIMARY KEY关键字指定，或者在后期通过ALTER TABLE语句添加。</p> </li><li> <p>非主键索引（Secondary Index）：非主键索引是除了主键索引以外的索引类型，用于加速查询和排序操作。非主键索引可以根据需要在一个或多个列上定义，不同列之间可以建立联合索引，提高索引效率。</p> </li><li> <p>唯一索引（Unique Index）：唯一索引是一种可以保证索引列的唯一性的索引类型，类似于主键索引。与主键索引不同的是，唯一索引所在的列可以允许NULL值，但只能存在一个NULL值，适用于需要保证数据唯一性且允许NULL值的场景。</p> </li></ol> 
<p>这些索引类型都可以提高查询效率和增强数据完整性，需要根据实际需求选择适合的索引类型。</p> 
<p> </p> 
<p>服务熔断和服务降级。</p> 
<p>在SpringCloud微服务架构中，服务熔断和服务降级是两种常用的应对高并发或系统故障的技术。</p> 
<p>服务熔断（Circuit Breaker）是一种应对高并发的技术，当服务出现故障或响应时间过长时，熔断器会打开，进而停止向该服务的请求，直接返回一个预设的错误响应或者缓存的数据，从而保证系统的稳定性和可用性。在SpringCloud中，可以使用Netflix的Hystrix组件来实现服务熔断。</p> 
<p>服务降级（Fallback）是一种应对系统故障的技术，当系统出现故障时，通过降低服务的质量或性能，来保证整体系统的可用性。例如，当某个服务不可用时，可以通过返回一个默认值或者缓存的数据来代替原本的响应结果。在SpringCloud中，可以使用Hystrix的Fallback功能来实现服务降级。</p> 
<p>总之，服务熔断和服务降级都是为了提高系统的可用性和稳定性，但它们的应用场景和实现方式有所不同。服务熔断是针对高并发的应对技术，服务降级是针对系统故障的应对技术。</p> 
<p> </p> 
<p>各服务之间如何保持独立的通讯。</p> 
<p>微服务架构中，各个服务之间需要进行通讯，以完成业务逻辑的处理。为了保持各服务之间的独立性和可扩展性，通常会采用以下方式进行通讯：</p> 
<p>REST API：服务之间通过REST API进行通讯，每个服务都暴露自己的REST接口，其他服务通过调用该接口来访问该服务的功能。REST API是一种轻量级、灵活性较高的通讯方式，适合于简单的数据交互和业务处理。</p> 
<p>消息队列：服务之间通过消息队列进行异步通讯，每个服务都可以向消息队列中发送消息，其他服务可以订阅该消息队列来接收消息。消息队列可以实现服务之间的解耦和异步化，适合于高并发、复杂的业务场景。</p> 
<p>RPC：服务之间通过RPC（Remote Procedure Call）进行通讯，每个服务都可以暴露自己的RPC接口，其他服务可以通过调用该接口来访问该服务的功能。RPC可以实现服务之间的高效通讯和调用，适合于对性能要求较高的业务场景。</p> 
<p> </p> 
<p>什么是java的反射机制。</p> 
<p>Java的反射机制指的是在程序运行时动态地获取和操作类的信息的能力。通过反射机制，可以在运行时获取类的属性、方法、构造函数等信息，并且可以在运行时调用类的方法、创建对象等。Java的反射机制可以在运行时动态地获取和操作类的信息，使得Java程序具有更高的灵活性和可扩展性。</p> 
<p>反射机制的核心是Java内置的Class类，它表示Java类的类型信息，可以在运行时获取类的各种信息。通过Class类的实例，可以获取类的名称、父类、接口、构造函数、方法、字段等各种信息，并且可以在运行时创建对象、调用方法、设置字段等。</p> 
<p> </p> 
<p>java中的访问修饰符和每个访问修饰符的应用场景。</p> 
<p> </p> 
<p>设计模式和java中那些地方用到了。</p> 
<p> </p> 
<p>mysql的优化，索引和索引使用的原则。</p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1dd8255cf0b3f97006065c907928ef9a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决Typora字数过多造成卡顿现象</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e76c58441b90cd17db206f90b9982bfc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2023年Android程序员长久就业，不得不说的事</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>