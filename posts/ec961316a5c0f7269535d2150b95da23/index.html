<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>opencv——图像遍历以及像素操作 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="opencv——图像遍历以及像素操作" />
<meta property="og:description" content="摘要 我们在图像处理时经常会用到遍历图像像素点的方式，在OpenCV中一般有四种图像遍历的方式，在这里我们通过像素变换的点操作来实现对图像亮度和对比度的调整。
数据格式千万不要搞错:
uchar对应的是CV_8U，char对应的是CV_8S，int对应的是CV_32S，float对应的是CV_32F，double对应的是CV_64F。
补充： 图像变换可以看成
像素变换——点操作邻域变换——区域操作(卷积，特征提取，梯度计算等) 对于点操作：
q(i，j)=αf(i，j)&#43;β
其中f(i，j)是输入点像素值，q(i，j)是输出点像素值。
1，数组遍历-- at&lt;typename&gt;(i,j) 说明：就是把图像看成二维矩阵，at(i,j)索引坐标位置，单通道直接得到坐标位置对应的像素值，三通道就这个位置代表了像素值的一维数组；
Mat类提供了一个at的方法用于取得图像上的点，它是一个模板函数，可以取到任何类型的图像上的点。这里选用参数α=1.5，β=0.5来提高图像亮度。
int main(int argc, char** argv) { Mat src; src = imread(&#34;D:/opencv练习图片/薛之谦.jpg&#34;); imshow(&#34;Image&#34;, src); //创建一个和原图一致的空白图像 Mat dst = Mat::zeros(src.size(), src.type()); for (int i = 0; i &lt; src.rows; i&#43;&#43;) { for (int j = 0; j &lt; src.cols; j&#43;&#43;) { if (src.channels() == 1) //单通道遍历 { dst.at&lt;uchar&gt;(i, j) = src.at&lt;uchar&gt;(i, j) &#43; 100; } else if (src." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ec961316a5c0f7269535d2150b95da23/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-12T16:56:00+08:00" />
<meta property="article:modified_time" content="2021-05-12T16:56:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">opencv——图像遍历以及像素操作</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html" style="font-size: 16px;"> 
 <h2><span style="font-weight: bold;">摘要</span></h2> 
 <p>我们在图像处理时经常会用到遍历图像像素点的方式，在OpenCV中一般有四种图像遍历的方式，在这里我们通过像素变换的点操作来实现对图像亮度和对比度的调整。</p> 
 <p><strong>数据格式千万不要搞错:</strong><br>uchar对应的是CV_8U，char对应的是CV_8S，int对应的是CV_32S，float对应的是CV_32F，double对应的是CV_64F。</p> 
 <hr> 
 <p> 补充： 图像变换可以看成</p> 
 <ul><li>像素变换——点操作</li><li>邻域变换——区域操作(卷积，特征提取，梯度计算等)</li></ul> 
 <p><strong>对于点操作：</strong></p> 
 <p>q(i，j)=αf(i，j)+β</p> 
 <p>其中f(i，j)是输入点像素值，q(i，j)是输出点像素值。</p> 
 <hr> 
 <h3><span style="font-weight: bold;"><strong> 1，数组遍历-- at&lt;typename&gt;(i,j)</strong></span></h3> 
 <p><strong>说明：</strong><strong>就是把图像看成二维矩阵，at(i,j)索引坐标位置，单通道直接得到坐标位置对应的像素值，三通道就这个位置代表了像素值的一维数组；</strong></p> 
 <p>Mat类提供了一个at的方法用于取得图像上的点，它是一个模板函数，可以取到任何类型的图像上的点。这里选用参数α=1.5，β=0.5来提高图像亮度。</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">int main(int argc, char** argv)
{    
    Mat src;
    src = imread("D:/opencv练习图片/薛之谦.jpg");
    imshow("Image", src);
    //创建一个和原图一致的空白图像
    Mat dst = Mat::zeros(src.size(), src.type());
    for (int i = 0; i &lt; src.rows; i++)
    {
        for (int j = 0; j &lt; src.cols; j++)
        {
               if (src.channels() == 1) //单通道遍历
              {
                       dst.at&lt;uchar&gt;(i, j) = src.at&lt;uchar&gt;(i, j) + 100; 

               }
               else if (src.channels() ==3)//三通道遍历
            {
            //通过数组遍历获取图像每个点
            float b = src.at&lt;Vec3b&gt;(i, j)[0];
            float g = src.at&lt;Vec3b&gt;(i, j)[1];
            float r = src.at&lt;Vec3b&gt;(i, j)[2];
            //进行点操作后赋值给空白图像dst
            float alpha = 1.5;
             float beta = 0.5;
            dst.at&lt;Vec3b&gt;(i, j)[0] = saturate_cast&lt;uchar&gt;(b*alpha + beta);
            dst.at&lt;Vec3b&gt;(i, j)[1] = saturate_cast&lt;uchar&gt;(g*alpha + beta);
            dst.at&lt;Vec3b&gt;(i, j)[2] = saturate_cast&lt;uchar&gt;(r*alpha + beta);
            }
        }
    }
    imshow("点操作", dst);
    waitKey(0);
    return 0;
} </code>
</pre> 
 </div> 
 <pre><code class="has">saturate_cast&lt;uchar&gt;是溢出保护，在进行像素的乘法后很容易造成像素点的值超出0-255的范围，因此使用saturate_cast&lt;uchar&gt;确保像素值始终在0-255的范围内。</code>
</pre> 
 <p><img src="https://images2.imgbox.com/54/07/9OcK3z1L_o.png" alt="" width="236" height="261" style="outline: none;"><img src="https://images2.imgbox.com/a6/96/fVZcu8Te_o.png" alt="" width="236" height="258" style="outline: none;"></p> 
 <h3><span style="font-weight: bold;">2，指针遍历法</span></h3> 
 <p>OpenCV中cv::Mat类提供了成员函数ptr得到图像任意行的首地址。ptr函数是一个模板函数，如：<strong>src.ptr&lt;uchar&gt;(i) </strong></p> 
 <p><strong>说明：ptr指针尤其固定格式，就是先把图像看成(src.rows,1)的图像，ptr获取每个位置的地址，地址位置隐藏了列的数据，由于列表名就是列表的地址，所以ptr获取的地址就是此行中列这样一维数据的列表名称。这样通过下标就可以获取像素值</strong></p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">int main(int argc, char** argv)
{    
    Mat src;
    src = imread("D:/opencv练习图片/薛之谦.jpg");
    imshow("Image", src);
    //创建一个和原图一致的空白图像
    Mat dst = Mat::zeros(src.size(), src.type());
    int width ;
    //判断图像是否连续
    if (src.isContinuous() &amp;&amp; dst.isContinuous())
    {
        // 将3通道转换为1通道    
        width = src.cols * src.channels();
    }
    for (int i = 0; i &lt; src.rows; i++)
    {
        // 获取第i行的首地址
        const uchar* src_rows = src.ptr&lt;uchar&gt;(i);
        uchar* dst_ptr = dst.ptr&lt;uchar&gt;(i);
        //像素点操作处理
        for (int j = 0; j &lt; width; j++)
        {
            dst_ptr[j] = saturate_cast&lt;uchar&gt;(src_rows[j] *1.5 + 0.5);
            dst_ptr[j + 1] = saturate_cast&lt;uchar&gt;(src_rows[j + 1] *1.5 + 0.5);
            dst_ptr[j + 2] = saturate_cast&lt;uchar&gt;(src_rows[j + 2] *1.5 + 0.5);
        }
    }
    imshow("点操作", dst);
    waitKey(0);
    return 0;
}</code>
</pre> 
 </div> 
 <p>程序中将三通道的数据转换为1通道，是建立在每一行数据元素之间在内存里是连续存储的。但在opencv中由于的存储机制问题，行与行之间可能有空白单元，因此Mat提供了一个检测图像是否连续的函数isContinuous()，当图像连通时，我们就可以把图像完全展开，看成是一行。</p> 
 <hr> 
 <p><strong>针对at和ptr有很多人容易理解at,却理解不了ptr,下面讲一个用at生成ptr模式的解析例子：</strong></p> 
 <p>说明:这是为了对比at和ptr而增加的，主要是获取at(i,0)位置处的地址，将其看成数值名称，通过下标索引像素值，和ptr原理一样，只是获取地址的方式不一样(数组名)</p> 
 <p><strong>1️⃣</strong><strong>遍历灰度图像像素方法：(采用at方法，使用ptr模式)</strong></p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">    for (int i = 0; i &lt; src.rows; i++)
    {
        //将灰度图片看成(src.rows,1)维度的二维矩阵，获取(i,0)数据的地址
        uchar* src_rows_ptr = &amp;(src.at&lt;uchar&gt;(i, 0));
        uchar* dst_rows_ptr = &amp;(dst.at&lt;uchar&gt;(i, 0));

        for (int j = 0; j &lt; src.cols; j++)
        {
            //将(i,0)数据的地址下的内容看成是一维数组，(i,0)数据的地址是一维数组的名字
            dst_rows_ptr[j] = src_rows_ptr[j] + 100;
        }
    }</code>
</pre> 
 </div> 
 <p>2️⃣<strong>遍历彩色图像像素方法：(</strong><strong>采用at方法，使用ptr模式)</strong></p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">for (int i = 0; i &lt; src.rows; i++)
    {
        //将彩色图片看成(src.rows,1)维度的二维矩阵，获取(i,0)数据的地址
        Vec3b* src_rows_ptr = &amp;(src.at&lt;Vec3b&gt;(i, 0));
        Vec3b* dst1_rows_ptr = &amp;(dst1.at&lt;Vec3b&gt;(i, 0));

        for (int j = 0; j &lt; src.cols; j++)
        {
            //将(i,0)数据的地址下的内容看成是二维数组，(i,0)数据的地址是二维数组的名字
            dst1_rows_ptr[j][0] = src_rows_ptr[j](0) + 100;
            dst1_rows_ptr[j][1] = src_rows_ptr[j](1) + 100;
            dst1_rows_ptr[j][2] = src_rows_ptr[j](2) + 100;
        }
    }</code>
</pre> 
 </div> 
 <p><strong>综上所述：使用ptr指针效率非常高，大家普遍使用的是at和ptr方法；使用的时候，一定要规范格式；</strong><strong>其中：at&lt;类型&gt;(i，j)</strong><strong>ptr&lt;类型&gt;(i)</strong></p> 
 <hr> 
 <h3> <strong><span style="font-weight: bold;">3、迭代器遍历</span></strong></h3> 
 <p>迭代器是专门用于遍历数据集合的一种非常重要的特殊的类，用其遍历隐藏了在给定集合上元素迭代的具体实现方式。迭代器方法是一种更安全的用来遍历图像的方式，首先获取到数据图像的矩阵起始，再通过递增迭代实现移动数据指针。</p> 
 <p>1、迭代器Matlterator_   Matlterator_是Mat数据操作的迭代器，：begin()表示指向Mat数据的起始迭代器，：end()表示指向Mat数据的终止迭代器。</p> 
 <p>2、迭代器Mat_              OpenCV定义了一个Mat的模板子类为Mat_，它重载了operator()让我们可以更方便的取图像上的点。</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">int main(int argc, char** argv)
{        
    Mat src;
    src = imread("D:/opencv练习图片/薛之谦.jpg");
    imshow("Image", src);
    <span class="hljs-comment">// 初始化图像迭代器 </span>
    Mat_&lt;Vec3b&gt;::iterator it = src.begin&lt;Vec3b&gt;();
    Mat_&lt;Vec3b&gt;::iterator itend = src.end&lt;Vec3b&gt;();
    while (it != itend)
    {
        //像素点操作
        (*it)[0] = saturate_cast&lt;uchar&gt;((*it)[0]*1.5+0.5);
        (*it)[1] = saturate_cast&lt;uchar&gt;((*it)[1] * 1.5 + 0.5);
        (*it)[2] = saturate_cast&lt;uchar&gt;((*it)[2] * 1.5 + 0.5);
        it++;
    }
    imshow("点操作", src);
    waitKey(0);
    return 0;
}</code>
</pre> 
 </div> 
 <p><strong>经测试，得到与数组遍历一样的效果。</strong></p> 
 <h3 id="4核心函数lut"><span style="font-weight: bold;">4、核心函数LUT</span></h3> 
 <p> LUT(LOOK -UP-TABLE)查找表。简言之：在一幅图像中，假如我们想将图像某一灰度值换成其他灰度值，用LUT就很好用。这样可以起到突出图像的有用信息，增强图像的光对比度的作用对某图像中的像素值进行替换。。</p> 
 <p>在图像处理中，对于一个给定的值，将其替换成其他的值是一个很常见的操作，OpenCV 提供里一个函数直接实现该操作LUT函数</p> 
 <p>函数 API</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">void LUT(InputArray src, InputArray lut, OutputArray dst);
//src表示的是输入图像(可以是单通道也可是3通道)
//lut表示查找表(查找表也可以是单通道，也可以是3通道；
//...如果输入图像为单通道，那查找表必须为单通道；
//...若输入图像为3通道，查找表可以为单通道，也可以为3通道；
//...若为单通道则表示对图像3个通道都应用这个表，若为3通道则分别应用 )
//dst表示输出图像</code>
</pre> 
 </div> 
 <p> <strong>如何使用该函数？</strong></p> 
 <ol><li>首先我们建立一个mat型用于查表</li><li>然后我们调用函数 (I 是输入 J 是输出):<code>LUT(I, lookUpTable, J);</code></li></ol> 
 <p>LUT函数的作用：</p> 
 <p><strong>(1)改变图像中像素灰度值</strong></p> 
 <p>通过构建查找表，图片0-100灰度的像素灰度就变成0，101-200的变成100,201-255的就变成255。</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">int main(int argc, char** argv)
{        
    Mat src,dst1,dst3;
    src = imread("D:/opencv练习图片/薛之谦.jpg");
    imshow("Image", src);
    //查找表，数组的下标对应图片里面的灰度值
    //例如lutData[20]=0;表示灰度为20的像素其对应的值0.    
    uchar lutData[256];
    for (int i = 0; i &lt; 256; i++)
    {
        if (i &lt;= 100)
            lutData[i] = 0;
        if (i &gt; 100 &amp;&amp; i &lt;= 200)
            lutData[i] = 100;
        if (i &gt; 200)
            lutData[i] = 255;
    }
    Mat lut(1, 256, CV_8UC1, lutData);
    LUT(src, lut, dst1);    
    imshow("LUC", dst1);    
    waitKey(0);
    return 0;
} </code>
</pre> 
 </div> 
 <p><img src="https://images2.imgbox.com/0b/bf/Me7iz7WS_o.png" alt="" width="244" height="257" style="outline: none;"><img src="https://images2.imgbox.com/7a/e5/XdJIGdez_o.png" alt="" width="235" height="257" style="outline: none;"></p> 
 <p><strong>(2)颜色空间缩减</strong></p> 
 <div class="article-title-box"> 
  <p>如果矩阵元素存储的是单通道像素，使用<em>uchar</em> (无符号字符，即0到255之间取值的数)那么像素可有256个不同值。但若是三通道图像，这种存储格式的颜色数就是256*256*256个(有一千六百多万种)。用如此之多的颜色可能会对我们的算法性能造成严重影响。其实有时候，仅用这些颜色的一小部分，就足以达到同样效果。</p> 
  <p>这种情况下，常用的一种方法是 <em>颜色空间缩减</em> 。其做法是：将现有颜色空间值除以某个输入值，以获得较少的颜色数。例如，颜色值0-9的取为0，10-19的取为10，以此类推。就把256个不同值划分为26个，大大减少运算时间。</p> 
  <p><em>uchar</em> 类型的值除以 <em>int</em> 值，结果仍是 <em>char</em> 。因为结果是char类型的，所以求出来小数也要向下取整。利用这一点，刚才提到在 <em>uchar</em> 定义域中进行的颜色缩减运算就可以表达为下列形式：</p> 
  <p>                                                                                       <img src="https://images2.imgbox.com/88/c0/KyiSAvWY_o.png" alt="" width="242" height="78" style="outline: none;"></p> 
  <p>这样的话，简单的颜色空间缩减算法就可由下面两步组成：</p> 
  <p>一、遍历图像矩阵的每一个像素</p> 
  <p>二、对像素应用上述公式。</p> 
  <p><strong>下面将图像压缩级设置为20(即0-19变为0，20-39变为20…)</strong></p> 
  <div class="cnblogs_code"> 
   <pre><code class="has">int main(int argc, char** argv)
{        
    Mat src,dst;
    src = imread("D:/opencv练习图片/薛之谦.jpg");
    imshow("Image", src);
    uchar table[256];
    Mat lut(1, 256, CV_8U);//创建查找表
    int divideWith = 20; //压缩级 20灰度为1级
    for (int i = 0; i &lt; 256; ++i)
    {
        table[i] = divideWith * (i / divideWith);//颜色缩减运算
    }
    uchar *p = lut.data;
    for (int i = 0; i &lt; 256; ++i)
    {
        p[i] = table[i];//这样就实现了利用查找表table的方法来替换源图像中的数据，
                        //这对图像就不是加减乘除这种计算了，而全部是直接去查询表中找对应的值然后再替换。
    }    
        LUT(src, lut, dst);
        imshow("LUT", dst);        
    waitKey(0);
    return 0;
}</code>
</pre> 
  </div> 
  <p><img src="https://images2.imgbox.com/34/be/CoOKPhB1_o.png" alt="" width="244" height="257" style="outline: none;"><img src="https://images2.imgbox.com/c9/9c/VvcgRNj5_o.png" alt="" width="234" height="256" style="outline: none;"></p> 
  <hr> 
  <h3><span style="font-weight: bold;">效率探讨</span></h3> 
  <p>一般图像规模比较大的话，图像的遍历是一项相当耗时的工作，因此为提高效率，以下几点值得我们注意：</p> 
  <ul><li>对于可提前计算的变量应避免写在循环体内；如</li></ul> 
  <div class="cnblogs_code _mce_tagged_br"> 
   <pre><code class="has">int cols=img.cols*img.channels();
for(int i=0;i&lt;cols;i++)   //而不是
// for(int i=p;i&lt;img.cols*img.channels();i++)</code>
</pre> 
  </div> 
  <ul><li>在以上四种图像遍历方法中，从效率来看使用 OpenCV 内置函数LUT可以获得最快的速度，这是因为OpenCV库可以通过英特尔线程架构启用多线程。其次，指针遍历最快，迭代器遍历次之，at方法遍历最慢。一般情况下，我们只有在对任意位置的像素进行读写时才考虑at方法。</li></ul> 
  <hr> 
  <p><strong> 最后顺便提一下图像的邻域操作😁</strong></p> 
  <p>很多时候，我们对图像处理时，要考虑它的邻域，比如3*3是我们常用的，这在图像滤波、去噪中最为常见，下面我们介绍如果在一次图像遍历过程中进行邻域的运算。</p> 
  <p>下面我们进行一个简单的滤波操作，滤波算子为[0 –1 0;-1 5 –1;0 –1 0]。它可以让图像变得尖锐，而边缘更加突出。核心公式即：sharp(i.j)=5*image(i,j)-image(i-1,j)-image(i+1,j)-image(i,j-1)-image(i,j+1)。</p> 
  <div class="math"> 
   <div class="cnblogs_code"> 
    <pre><code class="has">int main(int argc, char** argv)
{        
    Mat src,dst;
    src = imread("D:/opencv练习图片/薛之谦.jpg");
    imshow("Image", src);
    ImgFilter2d(src, dst);
    imshow("filter", dst);
    waitKey(0);
    return 0;
}
//构建滤波函数
void ImgFilter2d(const Mat &amp;image, Mat&amp; result)
{
       result.create(image.size(), image.type());
       int nr = image.rows;
        int nc = image.cols*image.channels();
        for (int i = 1; i &lt; nr - 1; i++)
        {
               //用指针遍历获取当前行，上一行，下一行
                const uchar* up_line = image.ptr&lt;uchar&gt;(i - 1);//指向上一行
                const uchar* mid_line = image.ptr&lt;uchar&gt;(i);//当前行
                 const uchar* down_line = image.ptr&lt;uchar&gt;(i + 1);//下一行
                 uchar* cur_line = result.ptr&lt;uchar&gt;(i);//创建结果图像指针
                for (int j = 1; j &lt; nc - 1; j++)
                {
                         //核心公式
                         cur_line[j] = saturate_cast&lt;uchar&gt;(5 * mid_line[j] - mid_line[j - 1] - mid_line[j + 1] -up_line[j] - down_line[j]);
                }
        }
            // 把图像边缘像素设置为0
             result.row(0).setTo(Scalar(0));
             result.row(result.rows - 1).setTo(Scalar(0));
             result.col(0).setTo(Scalar(0));
             result.col(result.cols - 1).setTo(Scalar(0));
}</code>
</pre> 
   </div> 
   <p> <img src="https://images2.imgbox.com/ab/72/WcfspHMx_o.png" alt="" width="244" height="257" style="outline: none;"><img src="https://images2.imgbox.com/c1/14/pNgwOP2G_o.png" alt="" width="239" height="263" style="outline: none;"></p> 
  </div> 
 </div> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/634c7437209a32102d83054aa3ace4cb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">手把手带你玩转k8s-健康检查之存活探针与就绪探针</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6c9aaf722825483f3a67af9d878c819b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">websphere 64位下载 linux,win10 ubuntu子系统安装Websphere8.5.5</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>