<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32F407 Flash操作笔记 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32F407 Flash操作笔记" />
<meta property="og:description" content="简述 STM32F4XX的闪存擦除方式分为两种：扇区擦除（最小单元16K）和整片擦除。在实际应用中，为满足重要信息的存储，需将信息存入FLASH中，针对以上两种擦除方式，扇区擦除更符合实际的需要。 参考手册： 写FLASH操作 经过以上五个步，就可以擦除某个扇区。但是实际运用过程中，一个扇区只存储一个信息或标志，会造成资源严重浪费。现采用缓存的方式，先读取当下扇区的数据，将读取的数据和要写入的数据组合，待擦除后再次写入。
代码片 写FLASH操作 /* * WriteAddr： 起始地址 (u32)address 是 4 的整数倍, (u32)data * pBuffer： 数据指针 * NumToWrite：字（u32）数 */ void STMFLASH_Write(u32 WriteAddr,u32 *pBuffer,u32 NumToWrite) { FLASH_Status status = FLASH_COMPLETE; u32 addrx=0; u32 endaddr=0; if(WriteAddr&lt;STM32_FLASH_BASE||WriteAddr%4)return; //非法地址 FLASH_Unlock();//解锁 FLASH_DataCacheCmd(DISABLE);//FLASH擦除期间，必须禁止数据缓存 addrx=WriteAddr; //写入起始地址 endaddr=WriteAddr&#43;NumToWrite*4; //写入结束地址 if(addrx&lt;0X1FFF0000) //是否为主存储区 { while(addrx&lt;endaddr) //对非0XFFFF FFFF 的地方，先擦除 { if(STMFLASH_ReadWord(addrx)!=0XFFFFFFFF)//对非0XFFFF FFFF 的地方，先擦除 { status=FLASH_EraseSector(GetSector(addrx),VoltageRange_3);//VCC=2.7~3.6V之间！！ if(status!=FLASH_COMPLETE)break; //异常 }else addrx&#43;=4; } } if(status==FLASH_COMPLETE) { while(WriteAddr&lt;endaddr)//写数据 { if(FLASH_ProgramWord(WriteAddr,*pBuffer)!=FLASH_COMPLETE)//写入数据 { break; //写入异常 } WriteAddr&#43;=4; pBuffer&#43;&#43;; } } FLASH_DataCacheCmd(ENABLE);//FLASH擦除结束，开启数据缓存 FLASH_Lock();//上锁 Printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/86077f27e245288c8622247d818c681a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-11-21T16:52:39+08:00" />
<meta property="article:modified_time" content="2017-11-21T16:52:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32F407 Flash操作笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="简述">简述</h3> 
<p>STM32F4XX的闪存擦除方式分为两种：扇区擦除（最小单元16K）和整片擦除。在实际应用中，为满足重要信息的存储，需将信息存入FLASH中，针对以上两种擦除方式，扇区擦除更符合实际的需要。 <br> <strong>参考手册：</strong> <br> <img src="https://images2.imgbox.com/95/57/LIqTACIl_o.png" alt="闪存模块组织" title=""></p> 
<h3 id="写flash操作">写FLASH操作</h3> 
<p><img src="https://images2.imgbox.com/43/6e/DRbIkjTc_o.png" alt="扇区擦除流程" title=""> <br> 经过以上五个步，就可以擦除某个扇区。但是实际运用过程中，一个扇区只存储一个信息或标志，会造成资源严重浪费。现采用缓存的方式，先读取当下扇区的数据，将读取的数据和要写入的数据组合，待擦除后再次写入。</p> 
<h4 id="代码片">代码片</h4> 
<ul><li>写FLASH操作</li></ul> 
<pre class="prettyprint"><code class=" hljs rust"><span class="hljs-comment">/*
 *  WriteAddr： 起始地址 (u32)address 是 4 的整数倍, (u32)data
 *  pBuffer：   数据指针
 *  NumToWrite：字（u32）数
 */</span>
void STMFLASH_Write(<span class="hljs-keyword">u32</span> WriteAddr,<span class="hljs-keyword">u32</span> *pBuffer,<span class="hljs-keyword">u32</span> NumToWrite)
{ 
  FLASH_Status status = FLASH_COMPLETE;
    <span class="hljs-keyword">u32</span> addrx=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">u32</span> endaddr=<span class="hljs-number">0</span>;  

  <span class="hljs-keyword">if</span>(WriteAddr&lt;STM32_FLASH_BASE||WriteAddr%<span class="hljs-number">4</span>)<span class="hljs-keyword">return</span>;    <span class="hljs-comment">//非法地址</span>

    FLASH_Unlock();<span class="hljs-comment">//解锁                                 </span>
    FLASH_DataCacheCmd(DISABLE);<span class="hljs-comment">//FLASH擦除期间，必须禁止数据缓存</span>

    addrx=WriteAddr;                <span class="hljs-comment">//写入起始地址</span>
    endaddr=WriteAddr+NumToWrite*<span class="hljs-number">4</span>; <span class="hljs-comment">//写入结束地址</span>
    <span class="hljs-keyword">if</span>(addrx&lt;<span class="hljs-number">0</span>X1FFF0000)            <span class="hljs-comment">//是否为主存储区</span>
    {
        <span class="hljs-keyword">while</span>(addrx&lt;endaddr)        <span class="hljs-comment">//对非0XFFFF FFFF 的地方，先擦除</span>
        {
            <span class="hljs-keyword">if</span>(STMFLASH_ReadWord(addrx)!=<span class="hljs-number">0</span>XFFFFFFFF)<span class="hljs-comment">//对非0XFFFF FFFF 的地方，先擦除</span>
            {   
                status=FLASH_EraseSector(GetSector(addrx),VoltageRange_3);<span class="hljs-comment">//VCC=2.7~3.6V之间！！</span>
                <span class="hljs-keyword">if</span>(status!=FLASH_COMPLETE)<span class="hljs-keyword">break</span>;    <span class="hljs-comment">//异常</span>
            }<span class="hljs-keyword">else</span> addrx+=<span class="hljs-number">4</span>;
        } 
    }
    <span class="hljs-keyword">if</span>(status==FLASH_COMPLETE)
    {
        <span class="hljs-keyword">while</span>(WriteAddr&lt;endaddr)<span class="hljs-comment">//写数据</span>
        {
      <span class="hljs-keyword">if</span>(FLASH_ProgramWord(WriteAddr,*pBuffer)!=FLASH_COMPLETE)<span class="hljs-comment">//写入数据</span>
            { 
                <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//写入异常</span>
            }
            WriteAddr+=<span class="hljs-number">4</span>;
            pBuffer++;
        } 
    }
    FLASH_DataCacheCmd(ENABLE);<span class="hljs-comment">//FLASH擦除结束，开启数据缓存</span>
    FLASH_Lock();<span class="hljs-comment">//上锁</span>
    Printf(<span class="hljs-string">"Flash status :%d\r\n"</span>,status);
}</code></pre> 
<ul><li>数据流存储</li></ul> 
<pre class="prettyprint"><code class=" hljs rust">#define SectorLen <span class="hljs-number">128</span> <span class="hljs-comment">//数据长度 128 * 4 = 512 结合实际需要长度调整</span>
<span class="hljs-comment">/*
 *  (u32)address 是 4 的整数倍, (u32)data
 *  FreeStart( 0x08008000 )~FreeEnd( 0x08010000 )
 */</span>
void SaveDataToFlash( <span class="hljs-keyword">u32</span> address, <span class="hljs-keyword">u32</span> data )
{
    FLASH_Status status = FLASH_COMPLETE;

    <span class="hljs-keyword">u32</span> site[SectorLen] = {FreeStart}, FlashBuffer[SectorLen] = {<!-- --><span class="hljs-number">0</span>};

    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">u8</span> i = <span class="hljs-number">0</span>; i &lt; SectorLen; i ++ )<span class="hljs-comment">//读取扇区数据，随即擦除</span>
    {
<span class="hljs-comment">//      if ( STMFLASH_ReadWord( site[i] ) != 0XFFFFFFFF)//0XFFFFFFFF代表无数据</span>
        {
            FlashBuffer[i] = STMFLASH_ReadWord( site[i] );
            site[ i + <span class="hljs-number">1</span> ] = site[i] + <span class="hljs-number">4</span>;
            <span class="hljs-keyword">if</span> ( address == site[i] )
                FlashBuffer[i] = data;
        }
    }
    FLASH_Unlock();<span class="hljs-comment">//解锁</span>
    FLASH_DataCacheCmd(DISABLE);<span class="hljs-comment">//FLASH擦除期间，必须禁止数据缓存</span>
    status = FLASH_EraseSector( GetSector( address ), VoltageRange_3 );<span class="hljs-comment">//VCC=2.7~3.6V之间！！</span>
    <span class="hljs-keyword">if</span> ( status == FLASH_COMPLETE )
    {       
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">u8</span> i = <span class="hljs-number">0</span>; i &lt; SectorLen; i ++)
        {
            <span class="hljs-keyword">if</span> ( FLASH_ProgramWord( site[i], FlashBuffer[i] ) != FLASH_COMPLETE )<span class="hljs-comment">//写入数据</span>
            { 
                <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//写入异常</span>
            }
        } 
    }
    FLASH_DataCacheCmd(ENABLE); <span class="hljs-comment">//FLASH擦除结束，开启数据缓存</span>
    FLASH_Lock();<span class="hljs-comment">//上锁</span>
    Printf(<span class="hljs-string">"Save status = %d\r\n"</span>,status);

<span class="hljs-comment">//  return addr;</span>
}</code></pre> 
<h3 id="读flash操作">读FLASH操作</h3> 
<p>STM23F4 的 FLASH 读取是很简单的。例如，我们要从地址 addr，读取一个字（字节为 8位， 半字为 16 位，字为 32 位），可以通过如下的语句读取：<strong>data=<em>(vu32</em>)addr;</strong> <br> 将 addr 强制转换为 vu32 指针，然后取该指针所指向的地址的值，即得到了 addr 地址的值。</p> 
<h4 id="代码片-1">代码片</h4> 
<pre class="prettyprint"><code class=" hljs rust"><span class="hljs-comment">/*
 *faddr :读地址
 *return:对应数据
 */</span>
<span class="hljs-keyword">u32</span> STMFLASH_ReadWord(<span class="hljs-keyword">u32</span> faddr)
{
    <span class="hljs-keyword">return</span> *(vu32*)faddr; 
}
<span class="hljs-comment">//读FLASH操作</span>
<span class="hljs-comment">/*
 *  ReadAddr  ：起始地址 (u32)address 是 4 的整数倍, (u32)data
 *  pBuffer   ：数据指针
 *  NumToRead ：字（4位）数
 */</span>
void STMFLASH_Read(<span class="hljs-keyword">u32</span> ReadAddr,<span class="hljs-keyword">u32</span> *pBuffer,<span class="hljs-keyword">u32</span> NumToRead)     
{
    <span class="hljs-keyword">u32</span> i;
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;NumToRead;i++)
    {
        pBuffer[i]=STMFLASH_ReadWord(ReadAddr);<span class="hljs-comment">//读取4个字节</span>
        ReadAddr+=<span class="hljs-number">4</span>;<span class="hljs-comment">//偏移4个字节</span>
    }
}</code></pre> 
<h3 id="调试注意事项">调试注意事项</h3> 
<ul><li>在FLASH读写操作时，未使用数据类型（u32），致读到的数据一直为：-1（0xFFFF FFFF 默认值，即该地址<strong>写数据失败</strong>） ；</li><li>主存储区&lt;0x0800 0000 ~ 0x080F FFFF&gt;，存储数据地址小于0x0800 0000，存储出错，主控无响应。<strong>在写操作时，一定要保证其 Address 有效！</strong></li></ul> 
<p><strong>小结</strong>：借助串口打印调试，分析问题，数据读写问题不大o(<em>￣︶￣</em>)o。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fc4a85267c59d889984ef0a24ebcc1bd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">随机数环设想</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d8160f38a779ac60b94073bb59344da9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">STM32 软件按键消抖</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>