<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL 如何避免克隆失败后再次初始化 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySQL 如何避免克隆失败后再次初始化" />
<meta property="og:description" content="本文章讨论了当您没有足够的磁盘空间来存储两个数据集时，使用带有安全选项DATA DIRECTORY 的 CLONE INSTANCE 命令。
作者：Sveta Smirnova，数据库专家。
本文来源：https://www.percona.com/，爱可生开源社区翻译。
本文约 800 字，预计阅读需要 3 分钟。
在我之前关于 CLONE INSTANCE 命令的博客文章《MySQL 克隆插件不是你的备份》中，我提到使用选项 DATA DIRECTORY 有助于避免在克隆操作失败时需要从头开始重新初始化副本和克隆相关设置的情况。
MySQL 克隆插件简化了新副本的配置，但不会简化失败后的服务器恢复，除非您准备从头开始重新安装 MySQL 实例。
但是，当您克隆一个已经有巨大数据集的复制副本时，您可能没有足够的空间容纳两个数据集：一个来自源服务器，另一个来自复制副本上的数据。
由于您决定从另一台服务器克隆复制副本，因此您同意丢失当前数据。DATA DIRECTORY 选项的唯一需要是在出现故障时保持与克隆相关的权限和设置不变。您可以使用以下策略之一安全地执行克隆操作。
从头开始 要执行此操作，请停止当前服务器，删除数据目录，再次初始化它，进行连接，并设置与克隆相关的权限和选项。这样，您将拥有一个带有小数据目录的新实例，因此您可以使用选项 DATA DIRECTORY ，而不用担心超出可用磁盘空间。
保留现有 MySQL 架构 如果不想重新安装实例，可以从中删除用户数据。
列出所有带查询的非系统数据库。 SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME NOT IN (&#39;mysql&#39;, &#39;sys&#39;, &#39;information_schema&#39;, &#39;performance_schema&#39;); 将它们逐一移除。您可以使用以下存储过程来执行此操作。 CREATE PROCEDURE p1() BEGIN DECLARE done INT DEFAULT FALSE; DECLARE dbname VARCHAR(64); DECLARE c1 CURSOR FOR SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e53e2d8f12b396e7ff59b6b431ad113e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-23T15:26:51+08:00" />
<meta property="article:modified_time" content="2023-10-23T15:26:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL 如何避免克隆失败后再次初始化</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>本文章讨论了当您没有足够的磁盘空间来存储两个数据集时，使用带有安全选项DATA DIRECTORY 的 CLONE INSTANCE 命令。</p> 
<blockquote> 
 <p>作者：Sveta Smirnova，数据库专家。</p> 
 <p>本文来源：<a href="https://www.percona.com/%EF%BC%8C%E7%88%B1%E5%8F%AF%E7%94%9F%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA%E7%BF%BB%E8%AF%91%E3%80%82" rel="nofollow">https://www.percona.com/，爱可生开源社区翻译。</a></p> 
 <p>本文约 800 字，预计阅读需要 3 分钟。</p> 
</blockquote> 
<p>在我之前关于 <code>CLONE INSTANCE</code> 命令的博客文章<a href="https://www.percona.com/blog/the-mysql-clone-plugin-is-not-your-backup/" rel="nofollow" title="MySQL 克隆插件不是你的备份">《MySQL 克隆插件不是你的备份》</a>中，我提到使用选项 <code>DATA DIRECTORY</code> 有助于避免在克隆操作失败时需要从头开始重新初始化副本和克隆相关设置的情况。</p> 
<p>MySQL 克隆插件简化了新副本的配置，但不会简化失败后的服务器恢复，除非您准备从头开始重新安装 MySQL 实例。</p> 
<p>但是，当您克隆一个已经有巨大数据集的复制副本时，您可能没有足够的空间容纳两个数据集：一个来自源服务器，另一个来自复制副本上的数据。</p> 
<p>由于您决定从另一台服务器克隆复制副本，因此您同意丢失当前数据。<code>DATA DIRECTORY</code> 选项的唯一需要是在出现故障时保持与克隆相关的权限和设置不变。您可以使用以下策略之一安全地执行克隆操作。</p> 
<h2 id="从头开始">从头开始</h2> 
<p>要执行此操作，请停止当前服务器，删除数据目录，再次初始化它，进行连接，并设置与克隆相关的权限和选项。这样，您将拥有一个带有小数据目录的新实例，因此您可以使用选项 <code>DATA DIRECTORY</code> ，而不用担心超出可用磁盘空间。</p> 
<h2 id="保留现有-mysql-架构">保留现有 MySQL 架构</h2> 
<p>如果不想重新安装实例，可以从中删除用户数据。</p> 
<ul><li>列出所有带查询的非系统数据库。</li></ul> 
<pre><code class="language-sql">SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA 
WHERE SCHEMA_NAME NOT IN ('mysql', 'sys', 'information_schema', 'performance_schema');</code></pre> 
<ul><li>将它们逐一移除。您可以使用以下存储过程来执行此操作。</li></ul> 
<pre><code class="language-sql">CREATE PROCEDURE p1()
BEGIN
  DECLARE done INT DEFAULT FALSE;
  DECLARE dbname VARCHAR(64);
  DECLARE c1 CURSOR FOR SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME NOT IN ('mysql', 'sys', 'information_schema', 'performance_schema', 'test');
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

  OPEN c1;

  drop_loop: LOOP
    FETCH c1 INTO dbname;
    IF done THEN
      LEAVE drop_loop;
    END IF;
    SET @temp = CONCAT('DROP DATABASE ', dbname);
    PREPARE stmt FROM @temp;
    EXECUTE stmt;
  END LOOP;

  CLOSE c1;
END</code></pre> 
<blockquote> 
 <p>如果您将 InnoDB 数据存储在共享表空间中（InnoDB_file_per_table=0），则文件 <code>ibdata</code> 将不会收缩，并且您将无法以这种方式释放磁盘空间。</p> 
</blockquote> 
<h2 id="克隆实例">克隆实例</h2> 
<p>手动删除数据释放磁盘空间后，可以使用带有选项 <code>DATA DIRECTORY</code> 的 <code>CLONE INSTANCE</code> 命令。</p> 
<pre><code class="language-bash">CLONE INSTANCE FROM ‘clone_user'@'source_host':3306 \
IDENTIFIED BY 'password' DATA DIRECTORY = '/path/to/custom_dir';</code></pre> 
<p>如果克隆成功，您需要通过一个额外的步骤来完成它：停止 MySQL 实例，并将数据目录的内容替换为用于克隆操作的目录的内容。之后，启动服务器。</p> 
<p>如果克隆操作失败，请删除克隆的数据，修复错误，然后重试。</p> 
<h2 id="结论">结论</h2> 
<p>克隆操作可能会失败，并迫使您通过重新初始化副本上的 MySQL 实例来执行额外的步骤。要避免这种情况，请使用选项 <code>DATA DIRECTORY</code>。如果磁盘空间不足，无法存储两个数据副本，请在克隆之前清理现有数据。</p> 
<p>更多技术文章，请访问：<a href="https://opensource.actionsky.com/" rel="nofollow">https://opensource.actionsky.com/</a></p> 
<h3 id="关于-sqle">关于 SQLE</h3> 
<p>爱可生开源社区的 SQLE 是一款面向数据库使用者和管理者，支持多场景审核，支持标准化上线流程，原生支持 MySQL 审核且数据库类型可扩展的 SQL 审核工具。</p> 
<h3 id="sqle-获取">SQLE 获取</h3> 
<table><thead><tr><th>类型</th><th>地址</th></tr></thead><tbody><tr><td>版本库</td><td><a href="https://github.com/actiontech/sqle">https://github.com/actiontech/sqle</a></td></tr><tr><td>文档</td><td><a href="https://actiontech.github.io/sqle-docs/" rel="nofollow">https://actiontech.github.io/sqle-docs/</a></td></tr><tr><td>发布信息</td><td><a href="https://github.com/actiontech/sqle/releases">https://github.com/actiontech/sqle/releases</a></td></tr><tr><td>数据审核插件开发文档</td><td><a href="https://actiontech.github.io/sqle-docs/docs/dev-manual/plugins/howtouse" rel="nofollow">https://actiontech.github.io/sqle-docs/docs/dev-manual/plugins/howtouse</a></td></tr></tbody></table>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/00c59f45e8ab2b5562b37a6078a69094/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C# 实现软件证书授权</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0c38dfe9f7bda0cffcb9adbd44230d29/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">意向后端的同学看过来，GO业务在招24届，机会多多！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>