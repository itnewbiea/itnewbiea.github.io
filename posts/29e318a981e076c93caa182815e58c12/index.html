<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ORACLE数据库文件系统简析 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ORACLE数据库文件系统简析" />
<meta property="og:description" content=" 一、数据库文件类型 与实例相关联的文件： 1 、参数文件：这些文件告诉Oracle实例在哪里寻找控制文件。例如，某个内存结构有多大等等。 组成数据库的文件： 2、数据文件：用于数据库（这些文件存储包含表、索引以及其他的部分的信息及数据）。 3、重做日志文件：记录事务日志 4、控制文件：它告诉我们这些数据文件存放在什么地方，以及其他关于其状态的信息。 5、临时文件：用于磁盘上的分类和临时的存储。 6、密码文件：用于在网络上执行管理活动的用户进行身份验证。 二、参数文件 1、数据库的参数文件通常称为init文件，或init.ora文件。这是因为它的默认名是init&lt;ORACLE_SID&gt;.ora。如果没有参数文件，你就不能启动数据库。这使它成为相当重要的文件。然而，由于它是一个纯文本文件，可以由任何一个文本编辑器创建，所以它不是必须特别注意的文件。参数文件的作用至少是获取数据库的名字，以及控制文件的位置。控制文件告诉Oracle其他每个文件的位置。所以它对启动数据库实例是非常重要的。 2、在通常的配置文件中，有许多其他的配置设置。参数的数量和名称随着版本的不同而不同。例如：在Oracle8.1.5中，有一个参数文件是plsql_load_without_compile。在此之前的版本中则没有，在此之后的版本中也没有。在版本8.1.5、版本8.1.6以及版本8.1.7数据库中，分别有199、201、203个不同的参数，可以分别进行配置。在Oracle提供的个版本的Reference手册中，详细回顾了每一个已记录的参数。 3、除了已记录的参数，还有在文档资料中没有记录的参数。区分出已记录的参数和没有记录的参数。没有记录的参数以下划线开始。这些参数并不被人所熟知，基本上没有被使用。实际上大部分不被记录的参数更烦人，它们代表着不被接受的功能和向后兼容性标志。在配置文件中没有理由使用那些没有被记录的参数。许多这样的参数有毁坏性的副作用。一般使用的没有记录的参数【_TRACE_FILES_PUBLIC=TRUE】,这使得所有开发人员都可读跟踪文件。而不是只有DBA用户可以读。 4、参数文件不是必须在某个特殊位置的。启动一个数据库实例时，可以使用startup pfile=filename。当你想观察在不同设置下的影响时，而在数据库上尝试不同的init.ora参数时，这最为有用。 三、数据文件 1、每个数据库至少有一个与之相关的数据文件。其实除了最简单的“测试”数据库会只有一个数据文件以外，任何一个真正的数据库至少有两个文件（一个是“系统（SYSTEM）”数据文件，一个是“用户（USER） ”数据文件）。为了理解ORACLE是如何组织这些文件以及数据在它们内部是如何组织的，必须先理解什么是表空间（Tablespace）、段（Segment）、盘区（Extent）、块（Block）。这些都是Oracle用于保存数据库对象的分配单元。 2、段就是数据库对象，它消耗存储空间（对象），如表、索引、回滚段等等。当你创建一个表的时候，将创建一个表段。当你创建一个分区表时，即在每个分区创建一个表段。当你创建一个索引时，将创建一个索引段，等等。每一个消耗存储空间的对象最终被存储在一个单一的段中。有回滚段、索引段、临时段、聚族段等。段本身是由一个或多个盘区组成。 3、盘区是在文件中一个连续的分配空间。每个段至少开始于一个盘区，一些对象可能至少需要两个盘区（回滚段是一个至少需要两个盘区的例子）。在文件中，盘区中的空间总是连续的。盘区的容量范围是从一个块到2GB。盘区有块组成。 4、一个块是在Oracle中空间分配的最小单元。块是存储数据行、索引项、临时排序结果的地方。块是Oracle读写磁盘的对象。Oracle中的块通常有3个常见的大小（2KB、4KB、8KB）。当然更大大小也是允许的。段、盘区、块之间的关系如下图： 5、一个段由一个或多个盘区组成，一些连续分配的块组成一个盘区。数据库块的大小在数据库创建的时候就固定下来了，数据库中，每个块的容量是相同的，所有的块有相同的通用格式。块头包含关于块类型（表块、索引块等等）的信息、关于块上活动和过时的事务信息、磁盘上块的地址（位置）的信息。表目录，包含此块中存储各行的表的信息。行目录包含着在块中发现的描述行的信息。块头、表目录、行目录统称为块开销（block overhead），即在块上使用的不能提供给存储数据的空间，用来管理块本身。块剩下的两部分为：空闲空间和已用空间。 6、表空间是一个容器，用来保存段。每一个段恰好属于一个表空间，而一个表空间可以有多个段。表空间本身有一个或多个相关联的数据文件。表空间中给定的任何一个段的盘区完全包含在一个数据文件中。然而，一个段可以拥有来自许多不同数据文件中的盘区。 表空间在oracle中是一个逻辑存储容器。 在Oracle中存储的层次结构是： (1)、数据库由一个或多个表空间组成； (2)、表空间由一个或多个数据文件组成，一个表空间包含一个或多个数据库段。 (3)、段（表、索引等等）由一个或多个盘区组成。段存在于表空间中且只能属于一个表空间，但是一个段可以存储在表空间所属的多个数据文件当中。 (4)、盘区是在磁盘上一组连续的块。盘区存在于段中，一个盘区在一个段（表空间）中，但一个盘区只能存在所属表空间的单一数据文件中。 (5)、块是数据库中最小的分配单元，块是数据库使用的最小的I/O单元。 7、在Oracle8.1.5之前的版本中，管理在表空间中分配盘区的方法只有一种。这一方法称为表空间字典管理（directionary-managed tablespace）。即在数据字典中管理表空间的空间。当一个对象需要另一个盘区时，它就会请求系统来获得一个盘区。Oracle会随后到它的数据字典中，运行一些请求，发现空间（或没有发现空间），随后更新一个表中的行（或将之全部删除），并在另一个表中插入一行。Oracle管理空间的方法类非常类似于通过修改数据并四处移动来修改应用程序的方法。为了获取附加空间，运行在后台的SQL称为递归SQL。SQL INSERT语句使其它的递归SQL运行以获得更多的空间。如果频繁使用递归SQL，将是十分昂贵的，因此对数据字典的更新必须串行化。它们不能同时处理。 8、在Oracle8.1.5之后的版本中，引入了一个本地管理表空间的概念，这个概念与字典管理的概念相反。使用本地管理的表空间，在每个数据文件中存储的位图用来管理盘区。现在，要获得盘区，全部的系统需要做的就是在位图中一个位置设为1。要释放表空间，则将它恢复为0。 四、临时文件 Oracle中的临时数据文件是一个特殊的数据文件类型。当内存不足以在RAM中保存一个大规模排序操作的中间结果或结果集时，Oracle将使用临时文件来存储它们。永久数据对象，如表或一个索引，是不会存储到临时文件中的，但临时表或临时索引的内容则可能存储到临时文件中。所以，不能在临时文件中创建自己的应用程序表，但可以使用临时表存储临时数据。临时文件从不生成重做日志，但生成撤销日志，当用于全局临时表时，如果准备回滚一些事务，就可以在自己的会话中完成。 五、控制文件 控制文件是一个相当小的文件（最大为64MB），它包含Oracle需要的其他文件的目录或路径。参数文件告诉我们控制文件的位置，而控制文件则把数据库和联机重做日志文件的位置告诉实例。控制文件也给Oracle提供其他信息，例如关于已经发生的检查点的信息、数据库的名称、数据库创建时的时间戳、归档重做日志历史等等。控制文件应该由硬件或Oracle（RAID）当RAID或镜像不可用时多路服用的，且应该分别保存在分开的磁盘上，以避免万一出现磁盘故障时造成控制文件丢失。 六、重做日志文件 1、重做日志文件对Oracle数据库是至关重要的，它们是数据库的事务日志，仅在数据库恢复时使用（它们的唯一作用就是在实例或介质失败时使用，或作为维护用于数据库故障恢复的后备数据库的方法）。如果关掉数据库所在机器的电源，造成实例失败，Oracle将使用联机重做日志，以将数据库恢复到电源停止之前的那一刹那。如果包含数据文件的磁盘驱动器发生永久性故障，Oracle数据库将使用归档重做日志，与使用联机重做日志一样，将驱动器的备份及时恢复到那一时间点。另外，如果“意外地”丢失了一个表，或删除了一些关键信息，并提交了操作，可以通过这些联机和备份的重做日志来恢复备份，并使Oracle立即将它恢复到事故发生前的时刻。 2、事实上，在Oracle执行的每一个操作都生成一定数量的重做日志，它们被写入联机重做日志中。一些操作可能以生成尽可能少的重做日志的方式来执行。例如，可以用NOLOGGING属性创建一个索引。这意味着日志中将不记录那个索引的初始创建。 联机重做日志： 1、每一个Oracle数据库至少有两个联机重做日志文件，这些联机重做日志文件在大小上是固定的，并以循环的方式使用。重做日志首先写入日志文件1，当日志文件写到末尾时，切换至日志文件2，以此类推，直到写到最后一个日志文件，当最后一个日志文件写到末尾时，将自动切换回日志文件1。 2、从一个日志文件切换到另一个日志文件的动作称为日志切换。日志切换可能在一个优化效果不是很好的数据库中引起临时的“挂起”。因为重做日志是用来在操作失败时进行恢复处理用的，必须保证在重用之前，不需要在失败时重做日志的内容。如果Oracle不确定它需要一个日志文件的内容，它将暂时悬挂数据库的操作，并保证这个重做所“保护”的数据在磁盘上本身是安全的。一旦此事确定，将重新开始处理，重做日志将被重用。 3、数据库缓冲区高速缓存是数据库临时存储数据的地方。这是Oracle的SGA的结构。缓冲区高速缓存是第一个也是最重要的性能优化设备，它单独存在，以便使非常慢的I/O进程显得更快一些。只要高速缓存了修改的块，且没有写到磁盘上，就不能使用那个重做日志文件。 4、检查点是从缓冲区高速缓存到磁盘上脏（被修改过的）块的刷新。DBWn是Oracle的后台进程，负责在缓冲区高速缓存溢出的时候创造空间，更重要的是执行检查点。Oracle在后台做这件事，许多操作会导致检查点的发生，最通常的事情就是重做日志切换。当填满日志文件1，并切换到日志文件2时，Oracle初始化了一个检查点。在这时，启动DBWn，将由日志文件1保护的所有修改块刷新到磁盘上。在DBWn将那个日志文件保护的所有块刷新之前，Oracle 不能重用它。如果在DBWn完成检查点之前试图使用它，将获得如下信息： ... Thread I cannot allocate new log,sequence 66 Checkpoint not complete Current log#2 seq#65 mem# 0:C:\ORACLE\ORADATA\TKYTE816\REDO02.LOG ... 在数据库中，有报警（ALERT）日志（报警日志是服务器上的一个文件，它包含来自服务器的丰富消息，如启动和关闭消息和异常事件，如未完成的检查点）。所以，在此时，当此消息出现时，在数据库中的处理被悬挂，这时DBWn在匆忙地完成它的检查点。Oracle尽其所能地给DBWn提供全部处理能力，以期在那时它可以更快地完成。 5、这时一个在优化得很好的数据库实例中不会看到的信息。如果确实看到了这样的消息，那么就为最终客户引入了人为是、不必要的等待。这时可以避免的。方法是只要分配足够多的联机重做日志文件，以便于不会在检查点完成初始化之前试图重用日志文件。如果这个消息频繁出现，这意味着DBA还没有为应用程序分配足够的联机重做日志，或者需要对DBWn优化得更有效。 6、不同的应用程序将生产不同数量的重做日志。DSS（决策支持系统，Decision Support System）将自然地生成重要的联机重做日志，但它比OLTP（事务处理 Transcation Processing）系统生成得少。数据库中二进制大对象（Binary Large Object，BLOB）中进行很多图像操作的系统，与简单的订单输入系统相比，可以生成多得多的重做日志。 7、在设置联机重做日志的大小和数量的时候，必须考虑各种因素，如下： （1）备用数据库，如果你正在使用备用数据库特性，在此重做日志在它们填满以后发送到另一台机器，并应用到数据库的一个副本上， 你最有可能想要许多小的重做日志文件。这将有助于保证备用数据库与主服务器的异步不会太明显。 （2）许多用户修改相同的块，这里你可能想要大的重做日志文件。因为每个人都在修改相同是块，那么希望在将他们写入磁盘之前，尽可能多的更新它们。每一个日志切换将触发一个检查点，所以希望日志切换不要太频繁。 （3）恢复的平均时间，如果必须保证恢复需要尽可能少的时间。那么可能需要较小的重做日志文件。在恢复上，处理一个或两个小的重做日志文件所花费的时间比处理一个巨大的重做日志文件所花费的时间少。 归档重做日志 Oracle数据库可以在两种模式之中的一种下运行-----非归档模式和归档模式。如果不用归档模式的话，系统不会是一个实用系统。非归档模式的数据库迟早将在某一天丢失数据，这是不可避免的。如果不使用归档模式的话，必将丢失数据。只有测试系统或开发系统才可以运行在非归档模式下。这两种模式之间的区别就是Oracle在重用重做日志文件时，对其做了哪些工作。在包含着有价值数据的系统上，必须使用归档模式。 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/29e318a981e076c93caa182815e58c12/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-05-22T11:17:32+08:00" />
<meta property="article:modified_time" content="2013-05-22T11:17:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ORACLE数据库文件系统简析</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <br> 
<br>  一、数据库文件类型 
<br> 与实例相关联的文件： 
<br> 1 、参数文件：这些文件告诉Oracle实例在哪里寻找控制文件。例如，某个内存结构有多大等等。 
<br> 组成数据库的文件： 
<br> 2、数据文件：用于数据库（这些文件存储包含表、索引以及其他的部分的信息及数据）。 
<br> 3、重做日志文件：记录事务日志 
<br> 4、控制文件：它告诉我们这些数据文件存放在什么地方，以及其他关于其状态的信息。 
<br> 5、临时文件：用于磁盘上的分类和临时的存储。 
<br> 6、密码文件：用于在网络上执行管理活动的用户进行身份验证。 
<br> 二、参数文件 
<br> 1、数据库的参数文件通常称为init文件，或init.ora文件。这是因为它的默认名是init&lt;ORACLE_SID&gt;.ora。如果没有参数文件，你就不能启动数据库。这使它成为相当重要的文件。然而，由于它是一个纯文本文件，可以由任何一个文本编辑器创建，所以它不是必须特别注意的文件。参数文件的作用至少是获取数据库的名字，以及控制文件的位置。控制文件告诉Oracle其他每个文件的位置。所以它对启动数据库实例是非常重要的。 
<br> 2、在通常的配置文件中，有许多其他的配置设置。参数的数量和名称随着版本的不同而不同。例如：在Oracle8.1.5中，有一个参数文件是plsql_load_without_compile。在此之前的版本中则没有，在此之后的版本中也没有。在版本8.1.5、版本8.1.6以及版本8.1.7数据库中，分别有199、201、203个不同的参数，可以分别进行配置。在Oracle提供的个版本的Reference手册中，详细回顾了每一个已记录的参数。 
<br> 3、除了已记录的参数，还有在文档资料中没有记录的参数。区分出已记录的参数和没有记录的参数。没有记录的参数以下划线开始。这些参数并不被人所熟知，基本上没有被使用。实际上大部分不被记录的参数更烦人，它们代表着不被接受的功能和向后兼容性标志。在配置文件中没有理由使用那些没有被记录的参数。许多这样的参数有毁坏性的副作用。一般使用的没有记录的参数【_TRACE_FILES_PUBLIC=TRUE】,这使得所有开发人员都可读跟踪文件。而不是只有DBA用户可以读。 
<br> 4、参数文件不是必须在某个特殊位置的。启动一个数据库实例时，可以使用startup pfile=filename。当你想观察在不同设置下的影响时，而在数据库上尝试不同的init.ora参数时，这最为有用。 
<br> 三、数据文件 
<br> 1、每个数据库至少有一个与之相关的数据文件。其实除了最简单的“测试”数据库会只有一个数据文件以外，任何一个真正的数据库至少有两个文件（一个是“系统（SYSTEM）”数据文件，一个是“用户（USER） ”数据文件）。为了理解ORACLE是如何组织这些文件以及数据在它们内部是如何组织的，必须先理解什么是表空间（Tablespace）、段（Segment）、盘区（Extent）、块（Block）。这些都是Oracle用于保存数据库对象的分配单元。 
<br> 2、段就是数据库对象，它消耗存储空间（对象），如表、索引、回滚段等等。当你创建一个表的时候，将创建一个表段。当你创建一个分区表时，即在每个分区创建一个表段。当你创建一个索引时，将创建一个索引段，等等。每一个消耗存储空间的对象最终被存储在一个单一的段中。有回滚段、索引段、临时段、聚族段等。段本身是由一个或多个盘区组成。 
<br> 3、盘区是在文件中一个连续的分配空间。每个段至少开始于一个盘区，一些对象可能至少需要两个盘区（回滚段是一个至少需要两个盘区的例子）。在文件中，盘区中的空间总是连续的。盘区的容量范围是从一个块到2GB。盘区有块组成。 
<br> 4、一个块是在Oracle中空间分配的最小单元。块是存储数据行、索引项、临时排序结果的地方。块是Oracle读写磁盘的对象。Oracle中的块通常有3个常见的大小（2KB、4KB、8KB）。当然更大大小也是允许的。段、盘区、块之间的关系如下图： 
<br> 
<br> 
<br> 5、一个段由一个或多个盘区组成，一些连续分配的块组成一个盘区。数据库块的大小在数据库创建的时候就固定下来了，数据库中，每个块的容量是相同的，所有的块有相同的通用格式。块头包含关于块类型（表块、索引块等等）的信息、关于块上活动和过时的事务信息、磁盘上块的地址（位置）的信息。表目录，包含此块中存储各行的表的信息。行目录包含着在块中发现的描述行的信息。块头、表目录、行目录统称为块开销（block overhead），即在块上使用的不能提供给存储数据的空间，用来管理块本身。块剩下的两部分为：空闲空间和已用空间。 
<br> 
<br> 
<br> 6、表空间是一个容器，用来保存段。每一个段恰好属于一个表空间，而一个表空间可以有多个段。表空间本身有一个或多个相关联的数据文件。表空间中给定的任何一个段的盘区完全包含在一个数据文件中。然而，一个段可以拥有来自许多不同数据文件中的盘区。 
<br> 
<br> 
<br> 表空间在oracle中是一个逻辑存储容器。 
<br> 在Oracle中存储的层次结构是： 
<br> (1)、数据库由一个或多个表空间组成； 
<br> (2)、表空间由一个或多个数据文件组成，一个表空间包含一个或多个数据库段。 
<br> (3)、段（表、索引等等）由一个或多个盘区组成。段存在于表空间中且只能属于一个表空间，但是一个段可以存储在表空间所属的多个数据文件当中。 
<br> (4)、盘区是在磁盘上一组连续的块。盘区存在于段中，一个盘区在一个段（表空间）中，但一个盘区只能存在所属表空间的单一数据文件中。 
<br> (5)、块是数据库中最小的分配单元，块是数据库使用的最小的I/O单元。 
<br> 7、在Oracle8.1.5之前的版本中，管理在表空间中分配盘区的方法只有一种。这一方法称为表空间字典管理（directionary-managed tablespace）。即在数据字典中管理表空间的空间。当一个对象需要另一个盘区时，它就会请求系统来获得一个盘区。Oracle会随后到它的数据字典中，运行一些请求，发现空间（或没有发现空间），随后更新一个表中的行（或将之全部删除），并在另一个表中插入一行。Oracle管理空间的方法类非常类似于通过修改数据并四处移动来修改应用程序的方法。为了获取附加空间，运行在后台的SQL称为递归SQL。SQL INSERT语句使其它的递归SQL运行以获得更多的空间。如果频繁使用递归SQL，将是十分昂贵的，因此对数据字典的更新必须串行化。它们不能同时处理。 
<br> 8、在Oracle8.1.5之后的版本中，引入了一个本地管理表空间的概念，这个概念与字典管理的概念相反。使用本地管理的表空间，在每个数据文件中存储的位图用来管理盘区。现在，要获得盘区，全部的系统需要做的就是在位图中一个位置设为1。要释放表空间，则将它恢复为0。 
<br> 四、临时文件 
<br> Oracle中的临时数据文件是一个特殊的数据文件类型。当内存不足以在RAM中保存一个大规模排序操作的中间结果或结果集时，Oracle将使用临时文件来存储它们。永久数据对象，如表或一个索引，是不会存储到临时文件中的，但临时表或临时索引的内容则可能存储到临时文件中。所以，不能在临时文件中创建自己的应用程序表，但可以使用临时表存储临时数据。临时文件从不生成重做日志，但生成撤销日志，当用于全局临时表时，如果准备回滚一些事务，就可以在自己的会话中完成。 
<br> 五、控制文件 
<br> 控制文件是一个相当小的文件（最大为64MB），它包含Oracle需要的其他文件的目录或路径。参数文件告诉我们控制文件的位置，而控制文件则把数据库和联机重做日志文件的位置告诉实例。控制文件也给Oracle提供其他信息，例如关于已经发生的检查点的信息、数据库的名称、数据库创建时的时间戳、归档重做日志历史等等。控制文件应该由硬件或Oracle（RAID）当RAID或镜像不可用时多路服用的，且应该分别保存在分开的磁盘上，以避免万一出现磁盘故障时造成控制文件丢失。 
<br> 六、重做日志文件 
<br> 1、重做日志文件对Oracle数据库是至关重要的，它们是数据库的事务日志，仅在数据库恢复时使用（它们的唯一作用就是在实例或介质失败时使用，或作为维护用于数据库故障恢复的后备数据库的方法）。如果关掉数据库所在机器的电源，造成实例失败，Oracle将使用联机重做日志，以将数据库恢复到电源停止之前的那一刹那。如果包含数据文件的磁盘驱动器发生永久性故障，Oracle数据库将使用归档重做日志，与使用联机重做日志一样，将驱动器的备份及时恢复到那一时间点。另外，如果“意外地”丢失了一个表，或删除了一些关键信息，并提交了操作，可以通过这些联机和备份的重做日志来恢复备份，并使Oracle立即将它恢复到事故发生前的时刻。 
<br> 2、事实上，在Oracle执行的每一个操作都生成一定数量的重做日志，它们被写入联机重做日志中。一些操作可能以生成尽可能少的重做日志的方式来执行。例如，可以用NOLOGGING属性创建一个索引。这意味着日志中将不记录那个索引的初始创建。 
<br> 联机重做日志： 
<br> 1、每一个Oracle数据库至少有两个联机重做日志文件，这些联机重做日志文件在大小上是固定的，并以循环的方式使用。重做日志首先写入日志文件1，当日志文件写到末尾时，切换至日志文件2，以此类推，直到写到最后一个日志文件，当最后一个日志文件写到末尾时，将自动切换回日志文件1。 
<br> 2、从一个日志文件切换到另一个日志文件的动作称为日志切换。日志切换可能在一个优化效果不是很好的数据库中引起临时的“挂起”。因为重做日志是用来在操作失败时进行恢复处理用的，必须保证在重用之前，不需要在失败时重做日志的内容。如果Oracle不确定它需要一个日志文件的内容，它将暂时悬挂数据库的操作，并保证这个重做所“保护”的数据在磁盘上本身是安全的。一旦此事确定，将重新开始处理，重做日志将被重用。 
<br> 3、数据库缓冲区高速缓存是数据库临时存储数据的地方。这是Oracle的SGA的结构。缓冲区高速缓存是第一个也是最重要的性能优化设备，它单独存在，以便使非常慢的I/O进程显得更快一些。只要高速缓存了修改的块，且没有写到磁盘上，就不能使用那个重做日志文件。 
<br> 4、检查点是从缓冲区高速缓存到磁盘上脏（被修改过的）块的刷新。DBWn是Oracle的后台进程，负责在缓冲区高速缓存溢出的时候创造空间，更重要的是执行检查点。Oracle在后台做这件事，许多操作会导致检查点的发生，最通常的事情就是重做日志切换。当填满日志文件1，并切换到日志文件2时，Oracle初始化了一个检查点。在这时，启动DBWn，将由日志文件1保护的所有修改块刷新到磁盘上。在DBWn将那个日志文件保护的所有块刷新之前，Oracle 不能重用它。如果在DBWn完成检查点之前试图使用它，将获得如下信息： 
<br>                 ... 
<br>                 Thread I cannot allocate new log,sequence 66  
<br>                 Checkpoint not complete  
<br>                   Current log#2 seq#65 mem# 0:C:\ORACLE\ORADATA\TKYTE816\REDO02.LOG 
<br>                 ... 
<br> 在数据库中，有报警（ALERT）日志（报警日志是服务器上的一个文件，它包含来自服务器的丰富消息，如启动和关闭消息和异常事件，如未完成的检查点）。所以，在此时，当此消息出现时，在数据库中的处理被悬挂，这时DBWn在匆忙地完成它的检查点。Oracle尽其所能地给DBWn提供全部处理能力，以期在那时它可以更快地完成。 
<br> 5、这时一个在优化得很好的数据库实例中不会看到的信息。如果确实看到了这样的消息，那么就为最终客户引入了人为是、不必要的等待。这时可以避免的。方法是只要分配足够多的联机重做日志文件，以便于不会在检查点完成初始化之前试图重用日志文件。如果这个消息频繁出现，这意味着DBA还没有为应用程序分配足够的联机重做日志，或者需要对DBWn优化得更有效。 
<br> 6、不同的应用程序将生产不同数量的重做日志。DSS（决策支持系统，Decision Support System）将自然地生成重要的联机重做日志，但它比OLTP（事务处理 Transcation Processing）系统生成得少。数据库中二进制大对象（Binary Large Object，BLOB）中进行很多图像操作的系统，与简单的订单输入系统相比，可以生成多得多的重做日志。 
<br> 7、在设置联机重做日志的大小和数量的时候，必须考虑各种因素，如下： 
<br> （1）备用数据库，如果你正在使用备用数据库特性，在此重做日志在它们填满以后发送到另一台机器，并应用到数据库的一个副本上， 你最有可能想要许多小的重做日志文件。这将有助于保证备用数据库与主服务器的异步不会太明显。 
<br> （2）许多用户修改相同的块，这里你可能想要大的重做日志文件。因为每个人都在修改相同是块，那么希望在将他们写入磁盘之前，尽可能多的更新它们。每一个日志切换将触发一个检查点，所以希望日志切换不要太频繁。 
<br> （3）恢复的平均时间，如果必须保证恢复需要尽可能少的时间。那么可能需要较小的重做日志文件。在恢复上，处理一个或两个小的重做日志文件所花费的时间比处理一个巨大的重做日志文件所花费的时间少。 
<br> 归档重做日志 
<br> Oracle数据库可以在两种模式之中的一种下运行-----非归档模式和归档模式。如果不用归档模式的话，系统不会是一个实用系统。非归档模式的数据库迟早将在某一天丢失数据，这是不可避免的。如果不使用归档模式的话，必将丢失数据。只有测试系统或开发系统才可以运行在非归档模式下。这两种模式之间的区别就是Oracle在重用重做日志文件时，对其做了哪些工作。在包含着有价值数据的系统上，必须使用归档模式。 
<br> 
<br> 
<br> 
<br> 
<br> 
<br> 
<br> 
<br> 
<br> 
<br> 
<br> 
<br> 
<br> 
<br> 
<br> 
<br>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8c63e16e788ce4c962facddeee28927e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">sqlite 实现top</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bb2c541a084cc14dcdcb1e14799df02d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">win8 64位&#43;Oracle 11g 64位下使用PL/SQL Developer 的解决办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>