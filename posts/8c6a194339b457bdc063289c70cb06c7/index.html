<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android：AppWidget之桌面小电筒 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android：AppWidget之桌面小电筒" />
<meta property="og:description" content="安卓开发中很多控件都是Widget类的，但是我们常说的Widget指的是AppWidget，即一些可以放置在桌面的小部件。
下面用两个实例来说一下这个AppWidget怎么来用。
实例一：AppWidget的基本使用
①创建一个AppWidget的布局文件appwidget_layout.xml
&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; &lt;LinearLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; android:layout_width=&#34;fill_parent&#34; android:layout_height=&#34;fill_parent&#34; &gt; &lt;Button android:id=&#34;@&#43;id/button&#34; android:layout_width=&#34;wrap_content&#34; android:layout_height=&#34;wrap_content&#34; android:text=&#34;今晚打老虎&#34; &gt; &lt;/Button&gt; &lt;/LinearLayout&gt; ②在res文件夹下新建一个xml文件夹，然后在里面添加一个xml文件appwidgetprovider_info.xml
&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; &lt;appwidget-provider xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; android:initialLayout=&#34;@layout/appwidget_layout&#34; //指定布局，这个是最重要的 android:minHeight=&#34;72dp&#34; //最小高度 android:minWidth=&#34;294dp&#34; //最小宽度 android:updatePeriodMillis=&#34;86400000&#34; &gt; //刷新时间 &lt;/appwidget-provider&gt; ③新建一个类继承AppWidgetProvider，重写几个重要的方法 package com.example.d_appwidget; import android.appwidget.AppWidgetManager; import android.appwidget.AppWidgetProvider; import android.content.Context; import android.content.Intent; public class AppWidget extends AppWidgetProvider { @Override public void onEnabled(Context context) { //首次添加AppWidget // TODO Auto-generated method stub super.onEnabled(context); System.out.println(&#34;---&gt; onEnabled&#34;); } @Override public void onUpdate(Context context, AppWidgetManager appWidgetManager, //更新AppWidget int[] appWidgetIds) { // TODO Auto-generated method stub super." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8c6a194339b457bdc063289c70cb06c7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-09-27T14:38:24+08:00" />
<meta property="article:modified_time" content="2014-09-27T14:38:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android：AppWidget之桌面小电筒</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:14px">     安卓开发中很多控件都是Widget类的，但是我们常说的Widget指的是AppWidget，即一些可以放置在桌面的小部件。</span></p> 
<p><span style="font-size:14px">    下面用两个实例来说一下这个AppWidget怎么来用。</span></p> 
<p><span style="font-size:14px">实例一：AppWidget的基本使用</span></p> 
<p><span style="font-size:14px">①创建一个AppWidget的布局文件appwidget_layout.xml</span></p> 
<p></p> 
<pre><code class="language-java">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent" &gt;
    &lt;Button
        android:id="@+id/button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="今晚打老虎" &gt;
    &lt;/Button&gt;
&lt;/LinearLayout&gt;</code></pre> 
<span style="font-size:14px">②在res文件夹下新建一个xml文件夹，然后在里面添加一个xml文件appwidgetprovider_info.xml<br> </span> 
<pre><code class="language-java">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
    android:initialLayout="@layout/appwidget_layout"   //指定布局，这个是最重要的
    android:minHeight="72dp"                     //最小高度
    android:minWidth="294dp"                     //最小宽度
    android:updatePeriodMillis="86400000" &gt;      //刷新时间
&lt;/appwidget-provider&gt;</code></pre> 
<span style="font-size:14px">③新建一个类继承AppWidgetProvider，重写几个重要的方法</span> 
<p></p> 
<p></p> 
<pre><code class="language-java">package com.example.d_appwidget;

import android.appwidget.AppWidgetManager;
import android.appwidget.AppWidgetProvider;
import android.content.Context;
import android.content.Intent;

public class AppWidget extends AppWidgetProvider {
	@Override
	public void onEnabled(Context context) {      //首次添加AppWidget
		// TODO Auto-generated method stub
		super.onEnabled(context);
		System.out.println("---&gt; onEnabled");
	}

	@Override
	public void onUpdate(Context context, AppWidgetManager appWidgetManager,  //更新AppWidget
			int[] appWidgetIds) {
		// TODO Auto-generated method stub
		super.onUpdate(context, appWidgetManager, appWidgetIds);
		System.out.println("---&gt; onUpdate");
	}

	@Override
	public void onDeleted(Context context, int[] appWidgetIds) {           //删除AppWidget
		// TODO Auto-generated method stub
		super.onDeleted(context, appWidgetIds);
		System.out.println("---&gt; onDeleted");
	}

	@Override
	public void onDisabled(Context context) {                              //删除所有AppWidget
		// TODO Auto-generated method stub
		super.onDisabled(context);
		System.out.println("---&gt; onDisabled");
	}

	@Override
	public void onReceive(Context context, Intent intent) {               //接收到广播，比较重要的方法
		// TODO Auto-generated method stub
		super.onReceive(context, intent);
		System.out.println("---&gt; onReceive");
	}
}
</code></pre> 
<span style="font-size:14px">④在AndoridManifest文件中注册receiver，在application节点中添加</span> 
<p></p> 
<p></p> 
<pre><code class="language-java">&lt;receiver android:name="AppWidget" &gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.appwidget.action.APPWIDGET_UPDATE" &gt;
        &lt;/action&gt;
    &lt;/intent-filter&gt;
    &lt;meta-data
        android:name="android.appwidget.provider"
        android:resource="@xml/appwidgetprovider_info" /&gt;
&lt;/receiver&gt;</code></pre> 
<p></p> 
<p><span style="font-size:14px">结果：运行后可以看到窗口小部件中我们自定义的部件</span></p> 
<p><span style="font-size:14px"><img src="https://images2.imgbox.com/21/ca/5RWadIss_o.png" alt=""><br> </span></p> 
<p><span style="font-size:14px"><br> 执行添加删除操作，我的理解是：执行不同操作时系统发出不同的广播，然后执行相应的方法，执行完之后系统再次发出特定广播。</span></p> 
<p><span style="font-size:14px"><img src="https://images2.imgbox.com/9d/c0/hDZ8QplU_o.jpg" alt=""><br> <br> </span></p> 
<p><span style="font-size:14px">实例二：在桌面上来进行手电筒操作，很多手电筒都需要先打开App然后再去开灯关灯，这有点麻烦，所以学了这个AppWidget之后我就写个这个。需要说明的是，程序本身和窗口小部件属于两个进程 ，对控件的使用和在程序本身使用是不同的，这也是最该关注的一点，也就是后面写到的PendingIntent和RemoteViews两个类。前面的步骤和实例一大致相同，主要不同是在继承类中重写的方法。</span></p> 
<p><span style="font-size:14px">①新建一个布局文件appwidget_layout.xml</span></p> 
<p></p> 
<pre><code class="language-java">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" &gt;
    &lt;Button
        android:id="@+id/button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="电筒-开" /&gt;
&lt;/LinearLayout&gt;</code></pre> 
<span style="font-size:14px">②res文件夹下新建一个xml文件夹，新建一个appwidgetprovider_info.xml文件</span> 
<p></p> 
<p></p> 
<pre><code class="language-java">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
    android:initialLayout="@layout/appwidget_layout" &gt;
&lt;/appwidget-provider&gt;</code></pre> 
<span style="font-size:14px">③新建一个类继承AppWidgetProvider，重写几个重要的方法</span> 
<p></p> 
<p></p> 
<pre><code class="language-java">package com.example.e_appwidget_flashlight;

import android.app.PendingIntent;
import android.appwidget.AppWidgetManager;
import android.appwidget.AppWidgetProvider;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.hardware.Camera;
import android.hardware.Camera.Parameters;
import android.widget.RemoteViews;

public class AppWidget extends AppWidgetProvider {
	private static final String ACTION_TAG = "leelit.action.flash";     //待发出的广播
	private static boolean flashOn = false;
	private static Camera camera;
	private static Camera.Parameters parameters;

	@Override
	public void onUpdate(Context context, AppWidgetManager appWidgetManager,
			int[] appWidgetIds) {
		// TODO Auto-generated method stub
		super.onUpdate(context, appWidgetManager, appWidgetIds);
		System.out.println("---&gt; onUpdate");
		Intent intent = new Intent(ACTION_TAG);
		PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0,  //一定条件下才会触发的意图，这个意图是发出
				intent, 0);                                           //广播      
		RemoteViews remoteViews = new RemoteViews(context.getPackageName(),          //获得AppWidget的所有控件对象
				R.layout.appwidget_layout);
		remoteViews.setOnClickPendingIntent(R.id.button, pendingIntent);  //此处就能点击触发上面意图，绑定为button控件
		appWidgetManager.updateAppWidget(appWidgetIds, remoteViews);      //执行update，第一个参数代表部件ID，通常都是一个
	}

	@Override
	public void onReceive(Context context, Intent intent) {
		// TODO Auto-generated method stub
		super.onReceive(context, intent);
		if (intent.getAction().equals(ACTION_TAG)) {                      //点击后会发出一个广播，此处就可接收
			RemoteViews remoteViews = new RemoteViews(context.getPackageName(),
					R.layout.appwidget_layout);               //因为要操作AppWidget控件，所以要再次获取                                                                                           //remoteviews和执行相应的步骤
			AppWidgetManager appWidgetManager = AppWidgetManager      
					.getInstance(context);
			ComponentName provider = new ComponentName(context, AppWidget.class);
			flashOn = !flashOn;                                       //打开或关闭电筒
			if (flashOn) {
				turnOnLight();
				remoteViews.setTextViewText(R.id.button, "电筒-关");   //改变控件状态
				appWidgetManager.updateAppWidget(provider, remoteViews);
			} else {
				turnOffLight();
				remoteViews.setTextViewText(R.id.button, "电筒-开");
				appWidgetManager.updateAppWidget(provider, remoteViews);
			}
		}
	}

	private void turnOnLight() {
		camera = Camera.open();
		parameters = camera.getParameters();
		parameters.setFlashMode(Parameters.FLASH_MODE_TORCH);
		camera.setParameters(parameters);
		camera.release();   //此处必须释放资源，否则后面关不了手电筒，因为相机资源一直在被占据着
	}

	private void turnOffLight() {
		camera = Camera.open();
		parameters = camera.getParameters();
		parameters.setFlashMode(Parameters.FLASH_MODE_OFF);
		camera.setParameters(parameters);
		camera.release();
	}
}
</code></pre> 
<p></p> 
<p><span style="font-size:14px">④在AndoridManifest文件中注册receiver，在application节点中添加。添加相应权限。</span></p> 
<pre><code class="language-java">&lt;receiver android:name="com.example.e_appwidget_flashlight.AppWidget" &gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.appwidget.action.APPWIDGET_UPDATE" /&gt;
    &lt;/intent-filter&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="leelit.action.flash" /&gt;    &lt;!-- 这个广播是自定义的 --&gt;
    &lt;/intent-filter&gt;

    &lt;meta-data
        android:name="android.appwidget.provider"
        android:resource="@xml/appwidgetprovider_info" /&gt;  &lt;!-- 资源文件 --&gt;
&lt;/receiver&gt;</code></pre> 
<p></p> 
<span style="font-size:14px">结果：桌面添加一个部件，点击操作就可以打开或关闭手电筒了。</span> 
<p><span style="font-size:14px">还有其他的一些细节就见上传的Demo吧</span></p> 
<p><span style="font-size:14px"><a target="_blank" href="http://download.csdn.net/detail/leelit/7981825" rel="noopener noreferrer"><span style="color:#ff0000">AppWidget_FlashLight.rar</span></a><br> </span></p> 
<p><span style="font-size:14px"><br> </span></p> 
<p><span style="font-size:14px">小结：四个步骤：①部件布局，②加载布局的xml文件，③继承AppWidgetProvider类，重写方法，④配置AndoridManifest文件<br> <br> <br> </span></p> 
<p><span style="font-size:14px"><br> </span></p> 
<p><span style="font-size:14px"><br> </span></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6b7ef8f271e0b811069c2f5ae7939554/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">图片切切切~~~ 图片热点，局部超链接</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e0439e4424980298e35250387a693df4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">STM32  用定时器产生1Mhz 脉冲，</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>