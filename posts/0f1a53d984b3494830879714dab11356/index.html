<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Swagger2接口文档返回json、map等对象的介绍说明出参 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Swagger2接口文档返回json、map等对象的介绍说明出参" />
<meta property="og:description" content="一、遇到问题 目前使用Swagger2形成接口文档时，当系统设计的接口返回的类型不是实体对象时，Swagger2无法在接口文档页面中显示返回结果字段说明，比如返回json、map等可以存储key-val形式的类型；均无法在接口文档页面上显示返回的字段备注说明，所以怎么才能像实体对象一样显示正常的model字段说明是我们这次需要解决的问题；
二、实现思路 1、首先告诉Swagger2该接口需要返回的字段具体有哪些
定义两个注解，方便来定义返回json或者map的固定参数；如：
/** * @ClassName: ApiReturnJson * @Description: 返回对象的定义 (描述这个类的作用) * @author TangCai * @date 2019年2月22日 下午4:56:33 */ @Target({ElementType.PARAMETER, ElementType.FIELD, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) public @interface ApiReturnJson { String key(); //对象名称 ApiReturnJsonPro[] value(); //对象属性值 } /** * @ClassName: ApiReturnJsonPro * @Description: 每一个字段的定义备注说明 (描述这个类的作用) * @author TangCai * @date 2019年2月22日 下午4:57:09 */ @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface ApiReturnJsonPro { String key(); //key String example() default &#34;&#34;; Class&lt;?&gt; dataType() default String.class; String description() default &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0f1a53d984b3494830879714dab11356/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-16T16:43:48+08:00" />
<meta property="article:modified_time" content="2020-09-16T16:43:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Swagger2接口文档返回json、map等对象的介绍说明出参</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E4%B8%80%E3%80%81%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98">一、遇到问题</h2> 
<p>目前使用Swagger2形成接口文档时，当系统设计的接口返回的类型不是实体对象时，Swagger2无法在接口文档页面中显示返回结果字段说明，比如返回json、map等可以存储key-val形式的类型；均无法在接口文档页面上显示返回的字段备注说明，所以怎么才能像实体对象一样显示正常的model字段说明是我们这次需要解决的问题；</p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><a name="t1"></a>二、实现思路</h2> 
<p>1、首先告诉Swagger2该接口需要返回的字段具体有哪些</p> 
<p>定义两个注解，方便来定义返回json或者map的固定参数；如：</p> 
<pre><code class="language-java">/** 
* @ClassName: ApiReturnJson 
* @Description: 返回对象的定义 (描述这个类的作用) 
* @author TangCai
* @date 2019年2月22日 下午4:56:33  
*/
  	
@Target({ElementType.PARAMETER, ElementType.FIELD, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface ApiReturnJson {
	String key();  //对象名称
    ApiReturnJsonPro[] value(); //对象属性值
}</code></pre> 
<pre><code class="language-java">/** 
* @ClassName: ApiReturnJsonPro 
* @Description: 每一个字段的定义备注说明 (描述这个类的作用) 
* @author TangCai
* @date 2019年2月22日 下午4:57:09  
*/
  	
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ApiReturnJsonPro {
 
    String key();  //key
 
    String example() default "";
 
    Class&lt;?&gt; dataType() default String.class;
 
    String description() default "";
}</code></pre> 
<p> </p> 
<p>2、在Swagger2中将该字段封装成一个model存进Swagger2容器中，继承OperationModelsProviderPlugin类，实现如下方法：</p> 
<pre><code class="language-java">public void apply(RequestMappingContext context) {
		// TODO Auto-generated method stub
		
		if (context.getReturnType().isInstanceOf(Map.class)) {
			// 根据参数上的ApiJsonObject注解中的参数动态生成Class
			Optional&lt;ApiReturnJson&gt; optional = context.findAnnotation(ApiReturnJson.class); 
			ApiReturnJsonPro[] properties = null;
			String name = null;
			try {
				Method method = Swagger2.class.getMethod("restApi");//系统默认取该处的全局变量
				ApiReturnJson apiReturnJson = method.getAnnotation(ApiReturnJson.class);
				name = apiReturnJson.key()+"_"+context.getName();
				ApiReturnJsonPro[] properties0 = apiReturnJson.value();
				if (optional.isPresent()) {
					name = optional.get().key(); // model名称
					ApiReturnJsonPro[] properties1 = optional.get().value();
					properties = new ApiReturnJsonPro[properties1.length+properties0.length];
					int k=0;
					for(;k&lt;properties0.length;k++)  properties[k] = properties0[k];
					for(int p=0;p&lt;properties1.length;p++)  properties[k+p] = properties1[p];
				}
				else properties = properties0;
			} catch (Exception e) {
				e.printStackTrace();
			}
			ResolvedType rt = typeResolver.resolve(createRefModel(properties, name));
			// 像documentContext的Models中添加我们新生成的Class
			context.getDocumentationContext().getAdditionalModels().add(rt); 
			context.operationModelsBuilder().addReturn(rt).build();
		}
	}</code></pre> 
<p> </p> 
<p>3、然后在每一个生成的接口在BuilderPlugin进行解析，并将访问正常的model更新，将json、map等替换，继承OperationBuilderPlugin类，实现如下方法：</p> 
<pre><code class="language-java">public void apply(OperationContext operationContext) {
		// TODO Auto-generated method stub
		if(operationContext.getReturnType().isInstanceOf(Map.class)) {
			//根据参数上的ApiJsonObject注解中的参数动态生成Class
			Optional&lt;ApiReturnJson&gt; optional = operationContext.findAnnotation(ApiReturnJson.class); 
			try {
				Method method = Swagger2.class.getMethod("restApi");//系统默认取该处的全局变量
				ApiReturnJson apiReturnJson = method.getAnnotation(ApiReturnJson.class);
				String name = apiReturnJson.key()+"_"+operationContext.getName();
	            if (optional.isPresent()) 
	                name = optional.get().key();  //model 名称
	            Set&lt;ResponseMessage&gt; set = new HashSet&lt;ResponseMessage&gt;();
	            ModelRef mr = new ModelRef(name);
                set.add(new ResponseMessage(200,"返回json用例说明",mr,null,null));
                operationContext.operationBuilder().responseMessages(set);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}</code></pre> 
<p> </p> 
<h2 id="%E4%B8%89%E3%80%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C">三、运行结果</h2> 
<p>注解样式：</p> 
<pre><code class="language-java">@ApiOperation(value = "获取上传文件表单name值")
	@ApiImplicitParams({
        @ApiImplicitParam(paramType="query", name = "uploadFileType", value = "上传文件类型：saveHeadImg", required = true, dataType = "string",defaultValue="")
    })
	@ApiReturnJson(key = "getUploadFileUrl_api", value = {
            @ApiReturnJsonPro(key = "uploadFileNamesVal", description = "上传文件表单name值")
    })
	@GetMapping("/getUploadFileUrl")
	@ResponseBody
    public Result getUploadFileUrl(@RequestParam(required=true)String uploadFileType) {
		AssertUtil.assertNotFalse(MyConstants.CONFIG.UPLOAD_FILE_TYPES.containsKey(uploadFileType), MyConstants.RESULT.FI1000, "uploadFileType非法");
		String res = HttpUtil.httpGet(MyConstants.CONFIG.GET(SysParamKey.FILE_SYSTEM_AUTH_CODE_URL).toString());
		Result result = (Result) JSONObject.toBean(JSONObject.fromObject(res), Result.class);
		result.put("uploadFileNamesVal", MyConstants.CONFIG.UPLOAD_FILE_TYPES.get(uploadFileType));
		return result;
	}</code></pre> 
<p>接口页面结果：</p> 
<p><img alt="" height="689" src="https://images2.imgbox.com/ec/17/IarCuC0x_o.png" width="996"></p> 
<h2><a name="t3"></a></h2>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/174db5174dd4a04a6242c6a3acc91459/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">试题 算法训练 2的次幂表示（Java）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4bd17617ff65c7d71817d43d4700a7a8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">跨库执行存储过程报错：不允许对系统目录进行即席更新。 (Microsoft SQL Server，错误259)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>