<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>在Unity里使用光线步进（Raymarching） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="在Unity里使用光线步进（Raymarching）" />
<meta property="og:description" content="图中光滑球为光线步进产生，粗糙球为Unity的场景物体 概念 光线步进和光线投射类似，都是从屏幕发射射线，然后求射线和物体的焦点，但是光线投射是一次性算出交点，而光线步进是一步步的前进，不断的向交点趋近，光线步近中的物体使用一种距离场函数来表示（SDF,Signed-distance-field 有向距离场）。通过这个函数你可以知道当前点的位置位置和物体的最近距离，如果距离趋向于0，就说明到达了交点，
每次前进的步长等于计算的距离，这样可以更快的趋近与交点。
如图所示，射线一步步向前，最后到达近似于交点的位置。
光线步进可以看做一个屏幕特效，怎么让shader应用一个屏幕特效我就忽略了，另外shader创建一个Image Effect Shader即可，
直接在上面改就好了，基本的设置几乎不需要变。
射线方向 首先我们需要得到每个像素的射线发射方向，这里我共看到了两种
第一种比较方便，但是可能会比较耗性能，因为每个像素都要计算一次。 思路看这里
Ray CreateCameraRay(float2 uv){ float2 p=uv*2.0f-1.0f; //内置的矩阵unity_CameraToWorld 左右手坐标系需要切换，所以要修改一下 //tips：外部传入的_camera.cameraToWorldMatrix就是反的 float4x4 negativeMat=float4x4( 1,0,0,0, 0,1,0,0, 0,0,-1,0, 0,0,0,1 ); float4x4 n_CameraToWorld=mul(unity_CameraToWorld,negativeMat); float3 origin=mul(n_CameraToWorld,float4(0.0f,0.0f,0.0f,1.0f)).xyz; float3 direction=mul(unity_CameraInvProjection,float4(p.xy,1.0f,1.0f)).xyz; direction=mul(n_CameraToWorld,float4(direction,0.0f)).xyz; direction=normalize(direction); return CreateRay(origin,direction); } 值得一提的是在实际使用中我发现shader中内置的相机世界矩阵和外界传入的相机世界矩阵有所不同，内置的并没有包含左右手坐标系的转换，所以用的时候要么用外面传入的，要么修改一下内置的。如果直接用内置的，你以为的正面其实是背面。
第二种需要shader外的配合，核心思路就是预先计算好屏幕空间四个顶点的发射向量，然后通过插值器得到每个像素点的发射方向
在c#部分，我们预先计算好四个顶点的向量，打包成矩阵传入shader；
//返回一个矩阵，分别表示四个点的向量，在shader里插值后可以得到各像素点的方向 Matrix4x4 CamFrustum() { Matrix4x4 mat=Matrix4x4.identity; float fov = Mathf.Tan(_camera.fieldOfView * 0.5f* Mathf.Deg2Rad) ; //得到向上向右的位移偏亮 进而推出屏幕面片四个点的发射方向 Vector3 up = Vector3.up * fov; Vector3 right = Vector3.right * _camera." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8ab2a1ee018dc6bd19131f042b90224b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-07T19:21:30+08:00" />
<meta property="article:modified_time" content="2019-06-07T19:21:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">在Unity里使用光线步进（Raymarching）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" class="has" src="https://images2.imgbox.com/9d/21/jpeCoWKC_o.gif"></p> 
<p><span style="color:#3399ea;">图中光滑球为光线步进产生，粗糙球为Unity的场景物体 </span></p> 
<h4>概念</h4> 
<p>光线步进和光线投射类似，都是从屏幕发射射线，然后求射线和物体的焦点，但是光线投射是一次性算出交点，而光线步进是一步步的前进，不断的向交点趋近，光线步近中的物体使用一种距离场函数来表示（SDF,Signed-distance-field 有向距离场）。通过这个函数你可以知道当前点的位置位置和物体的最近距离，如果距离趋向于0，就说明到达了交点，</p> 
<p>每次前进的步长等于计算的距离，这样可以更快的趋近与交点。</p> 
<p><img alt="Raymarching variable step" class="has" src="https://images2.imgbox.com/66/38/x8yrPUYR_o.png"></p> 
<p>如图所示，射线一步步向前，最后到达近似于交点的位置。</p> 
<hr> 
<p>光线步进可以看做一个屏幕特效，怎么让shader应用一个屏幕特效我就忽略了，另外shader创建一个Image Effect Shader即可，</p> 
<p>直接在上面改就好了，基本的设置几乎不需要变。</p> 
<hr> 
<h4>射线方向</h4> 
<p>首先我们需要得到每个像素的射线发射方向，这里我共看到了两种</p> 
<p><strong>第一种</strong>比较方便，但是可能会比较耗性能，因为每个像素都要计算一次。 <a href="https://blog.csdn.net/qq_38275140/article/details/90239218">思路看这里</a></p> 
<pre class="has"><code class="language-cs">            Ray CreateCameraRay(float2 uv){
                float2 p=uv*2.0f-1.0f;
                //内置的矩阵unity_CameraToWorld 左右手坐标系需要切换，所以要修改一下
                //tips：外部传入的_camera.cameraToWorldMatrix就是反的
                float4x4 negativeMat=float4x4(
                1,0,0,0,
                0,1,0,0,
                0,0,-1,0,
                0,0,0,1
                );
                float4x4 n_CameraToWorld=mul(unity_CameraToWorld,negativeMat);
                float3 origin=mul(n_CameraToWorld,float4(0.0f,0.0f,0.0f,1.0f)).xyz;
                float3 direction=mul(unity_CameraInvProjection,float4(p.xy,1.0f,1.0f)).xyz;
                direction=mul(n_CameraToWorld,float4(direction,0.0f)).xyz;
                direction=normalize(direction);
                return CreateRay(origin,direction);
            }</code></pre> 
<blockquote> 
 <p>值得一提的是在实际使用中我发现shader中内置的相机世界矩阵和外界传入的相机世界矩阵有所不同，内置的并没有包含左右手坐标系的转换，所以用的时候要么用外面传入的，要么修改一下内置的。如果直接用内置的，你以为的正面其实是背面。</p> 
 <p><img alt="" class="has" height="243" src="https://images2.imgbox.com/c8/f8/kxhvAMwq_o.jpg" width="460"></p> 
</blockquote> 
<p><strong>第二种</strong>需要shader外的配合，核心思路就是预先计算好屏幕空间四个顶点的发射向量，然后通过插值器得到每个像素点的发射方向</p> 
<p>在c#部分，我们预先计算好四个顶点的向量，打包成矩阵传入shader；</p> 
<pre class="has"><code class="language-cs">    //返回一个矩阵，分别表示四个点的向量，在shader里插值后可以得到各像素点的方向
    Matrix4x4 CamFrustum()
    {
        Matrix4x4 mat=Matrix4x4.identity;
        float fov = Mathf.Tan(_camera.fieldOfView * 0.5f* Mathf.Deg2Rad) ;
        //得到向上向右的位移偏亮 进而推出屏幕面片四个点的发射方向 
        Vector3 up = Vector3.up * fov;
        Vector3 right = Vector3.right * _camera.aspect * fov;
        Vector3 TL = (-Vector3.forward + up - right);
        Vector3 TR = (-Vector3.forward + up + right);
        Vector3 BL = (-Vector3.forward - up - right);
        Vector3 BR = (-Vector3.forward - up + right);
        //顺序为左下，右下，左上，右上 不要乱
        mat.SetRow(0,BL);
        mat.SetRow(1,BR);
        mat.SetRow(2,TL);
        mat.SetRow(3,TR);
        return mat;
    }</code></pre> 
<pre class="has"><code class="language-cs">...
raymarchMat.SetMatrix("_CamFrustum",CamFrustum());
...</code></pre> 
<p>在shader中我们通过需要获取每个顶点的向量，我们知道uv左下为（0,0）右上为（1,1）通过这一点我们让x乘1，y乘2，两者相加就可以得到我们想要的序列 即左下=0，右下=1，左上=2，右上=3。在顶点函数中计算好，通过插值我们就可以在片元函数中得到每个像素的方向了。（_CamToWorld是外界传入的相机-世界矩阵，原因方法一提到）</p> 
<pre class="has"><code class="language-cs">            v2f vert (appdata v){
                v2f o;
                int index=(int)dot(v.uv,float2(1,2));
                v.vertex.z=0;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.uv = v.uv;
                o.rayDir= _CamFrustum[index].xyz;
                o.rayDir=mul(_CamToWorld,o.rayDir);
                return o;
            }</code></pre> 
<hr> 
<h4>光线步进算法</h4> 
<p>maxDist是射线的最远距离，maxItera是射线最多走几步。</p> 
<pre class="has"><code class="language-cs">bool  RayMarching(Ray ray,float maxDist,int maxItera,inout float3 p){
                float t=0.0f;//光线走的长度
                for(int i=0;i&lt;maxItera;i++){
                    //最大边界
                    if(t&gt;maxDist) return false;
                    p=ray.origin+t*ray.direction;//现在的位置
                    float d=DistanceField(p);//当前点和物体的距离（要注意不一定是交点的距离，不然直接一步就到了）
                    if(abs(d)&lt;0.01) {
                        return true;//找到了交点
                    }
                    t+=d;
                }
                return false;
            }</code></pre> 
<hr> 
<h4>距离场</h4> 
<p>前面的DistanceField（），其中就包含了多个物体的距离场  不同形状的距离场，以及形状之间的组合操作请看iq的<a href="http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm" rel="nofollow">这篇文章</a></p> 
<p>我们可以尝试画一个最简单的球</p> 
<pre class="has"><code class="language-cs">float sdSphere( float3 p, float s ){

  return length(p)-s;
}
float4 DistanceField(float3 p){
    return sdSphere(p,3);
}</code></pre> 
<pre class="has"><code class="language-cs">            fixed4 frag (v2f i) : SV_Target {
                float2 uv=i.uv;
                float3 result=0.0f;
                Ray ray= CreateRay(_WorldSpaceCameraPos,normalize(i.rayDir));
                float3 hitPosition;
                bool hit=RayMarching(ray,_MaxDistance,_MaxIterations,hitPosition);
                if(hit){
                    result=1.0f;
                }else{
                    result=0.0f;
                }
                return float4(result,1.0f);
            }</code></pre> 
<p><img alt="" class="has" height="219" src="https://images2.imgbox.com/b2/90/EM3ogXzu_o.png" width="281"></p> 
<hr> 
<h4>法线计算</h4> 
<p>我们可以在此利用距离场计算交点位置的法线，法线也就是它的梯度。</p> 
<pre class="has"><code class="language-cs">            float3 calcNormal( in float3 pos ){
                            float2 e = float2(1.0,-1.0)*0.5773*0.0005;
                            return normalize( e.xyy*DistanceField( pos + e.xyy ).x +
                                    e.yyx*DistanceField( pos + e.yyx ).x +
                                    e.yxy*DistanceField( pos + e.yxy ).x +
                                    e.xxx*DistanceField( pos + e.xxx ).x );
                            /*
                             float3 eps = float3( 0.0005, 0.0, 0.0 );
                             float3 nor = float3(
                             DistanceField(pos+eps.xyy).x - DistanceField(pos-eps.xyy).x,
                             DistanceField(pos+eps.yxy).x - DistanceField(pos-eps.yxy).x,
                             DistanceField(pos+eps.yyx).x - DistanceField(pos-eps.yyx).x );
                             return normalize(nor);
                             */
            }</code></pre> 
<p>让输出颜色为法线，结果如图</p> 
<pre>if(hit){
    result=calcNormal(hitPosition);
}</pre> 
<p><img alt="" class="has" height="251" src="https://images2.imgbox.com/3a/fd/mbOdE1uZ_o.png" width="288"></p> 
<hr> 
<h4>光照</h4> 
<p>有了法线就可以计算光照了。<span style="color:#86ca5e;">ps：文中所有"_"开头的都是外界传入的变量，自己按意思设置即可。</span></p> 
<pre class="has"><code>if(hit){
    float3 normal=calcNormal(hitPosition);
    result=_LightCol*saturate(dot(normal,-_LightDir));
}else{
    result=float3(0.2,0.2,0.3);
}</code></pre> 
<p><img alt="" class="has" src="https://images2.imgbox.com/63/f4/S42YYU2g_o.png"></p> 
<hr> 
<h4>调整场景</h4> 
<p>我们先把渲染的部分合并到到单独的一个shade函数中</p> 
<pre class="has"><code class="language-cs">float3 Shade(float3 p,float3 normal){
            
                float3 diffuse=_LightCol*(saturate(dot(normal,-_LightDir))*0.5f+0.5f);
                return diffuse;
}</code></pre> 
<pre class="has"><code class="language-cs">...
if(hit){
    float3 normal=calcNormal(hitPosition);
    result=Shade(hitPosition,normal);
}</code></pre> 
<p>然后调整场景物体，下面就是文章开头图片的距离场 。opSmoothUnion是一个结合两个距离场的操作，他可以平滑的合并两者，更多操作请看前面提到的那篇文章。</p> 
<pre class="has"><code>float4 opSmoothUnion( float d1, float d2, float k ) {
    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
    return lerp( d2, d1, h ) - k*h*(1.0-h); }

</code></pre> 
<pre class="has"><code class="language-cs">float DistanceField(float3 p){
   float d1=sdSphere(p-_Sphere01.xyz+float3(0,fmod(_Time.y*6, 10),0),_Sphere01.w*0.5);
   float d2=sdSphere(p-_Sphere01.xyz,_Sphere01.w);
   float plane=sdPlane(p,_Plane01);
   float comb01=opSmoothUnion(plane,opSmoothUnion(d1,d2,1),1);
   
   float d3=sdSphere(p-_Sphere02.xyz+float3(0,fmod(_Time.y*6, 9),0),_Sphere02.w*0.5);
   float d4=sdSphere(p-_Sphere02.xyz,_Sphere02.w);
   float comb02=opSmoothUnion(d3,d4,1);
   return opSmoothUnion(comb01,comb02,1);
}</code></pre> 
<p><img alt="" class="has" height="399" src="https://images2.imgbox.com/10/93/1mp1r5Mp_o.gif" width="653"> </p> 
<hr> 
<h4>阴影</h4> 
<p>阴影可以看<a href="http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm" rel="nofollow">这篇文章</a>，可以分为硬阴影和软阴影。</p> 
<p>硬阴影思路很简单，就是朝光线方向再来一次光线步进，如果撞到了物体就说明光线被该物体挡住了，自身位于阴影中。</p> 
<pre class="has"><code class="language-cs">float HardShadow(float3 ro,float3 rd,float mint,float maxt){
    for( float t=mint; t &lt; maxt; )
    {
        float h = DistanceField(ro + rd*t);
        if( h&lt;0.001f)
            return 0.0f;
        t += h;
    }
    return 1.0f;
}</code></pre> 
<p>软硬阴影则是在硬阴影基础上进一步拓展，就是让阴影附近能有一层过渡</p> 
<pre class="has"><code class="language-cs">float SoftShadow(float3 ro,float3 rd, float mint, float maxt, float k ){
    float res = 1.0f;//确保阴影衰减值不会大于1
    for( float t=mint; t &lt; maxt; )
    {
        float h = DistanceField(ro + rd*t);
        if( h&lt;0.001f )
            return 0.0f;
        res = min( res, k*h/t );
        t += h;
    }
    return res;
}</code></pre> 
<p>mint和maxt是最近和最远的阴影距离。 </p> 
<blockquote> 
 <p><img alt="" class="has" height="320" src="https://images2.imgbox.com/dd/61/SONBKGd4_o.png" width="570"> </p> 
 <p>如图所示，t表示射线到目标步数走的路场，而h是每走一步和物体的距离，很明显，当两者垂直时，h/t的值最小。而随着光线的原理，h和t之间的差距越来越小，h/t趋向于1，1就是没有阴影的情况，k值是阴影的软化程度，在这里我们也可以知晓其实他就是加速h/t趋向于1，值越大，k*h/t就会越快的趋近1，阴影也就越锐利。</p> 
</blockquote> 
<pre class="has"><code class="language-cs">float3 Shade(float3 p,float3 normal){
    //控制在[0.5,1.0],这样可以用pow(,_ShadowIntensity)的方式对阴影浓度做进一步的调整
    float shadow=SoftShadow(p,-_LightDir,_ShadowDistance.x,_ShadowDistance.y,_ShadowPenumbra)*0.5+0.5;
    shadow=max(0.0,pow(shadow,_ShadowIntensity));
    float3 diffuse=_LightCol*(saturate(dot(normal,-_LightDir))*0.5f+0.5f);
    return diffuse*shadow;
}</code></pre> 
<p> </p> 
<p><img alt="" class="has" height="267" src="https://images2.imgbox.com/73/7e/PGqS4FZp_o.png" width="407"><img alt="" class="has" height="270" src="https://images2.imgbox.com/00/2c/mRaRNvjp_o.png" width="422"></p> 
<p><span style="color:#3399ea;">硬阴影和软阴影</span></p> 
<hr> 
<h4>环境光遮蔽</h4> 
<pre class="has"><code class="language-cs">float calcAO(float3 p,float3 normal){
    float step=_AoStepSize;//每次前进的步长，这里使用固定步长
    float ao=0.0;
    float dist;
    for(int i=0;i&lt;=_AoIterations;i++){
        dist=step*i;
        //如果附近没有其他物体 dist&lt;DistanceField 最终结果为负数并截为0 返回值=1 即无环境光遮蔽
        //如果附近有物体，那么法线步进就会靠近该物体 从而dist&gt;DistanceField 结果大于0，返回值&lt;1
        ao+=max(0.0f,(dist-DistanceField(p+normal*dist))/dist);
    }
    return (1.0f-ao*_AoIntensity);
}</code></pre> 
<blockquote> 
 <p><img alt="" class="has" height="396" src="https://images2.imgbox.com/57/ed/JgbiUWbb_o.png" width="704"> </p> 
 <p>如图所以，同等步长下，越是犄角疙瘩的地方，d值越有可能步dist值小，从而得到更高的ao值，因为ao值高的地方应该越暗，所以最后的返回值是1-ao，让高ao值的趋向于0.</p> 
</blockquote> 
<p><img alt="" class="has" src="https://images2.imgbox.com/ed/0c/3IFoyrfl_o.png"></p> 
<hr> 
<h4>和原有场景的合并</h4> 
<p>带目前为止我们都是完全丢弃了Unity原本渲染的内容，在这里我们要把它补回了，思路很简单，我们通过深度贴图得到深度，如果光线步进的长度超过这个值，就没必要继续计算了，直接返回false，因为就算在这个距离之后碰撞到了距离场物体，它按常理也是应该被Unity场景中的物体所遮挡的。</p> 
<p>我们首先要利用深度贴图计算深度</p> 
<pre class="has"><code>float depth=LinearEyeDepth(tex2D(_CameraDepthTexture,uv).r);</code></pre> 
<p>同时raymarching函数新增一个深度参数。</p> 
<pre class="has"><code class="language-cs">bool  RayMarching(Ray ray,float depth,float maxDist,int maxItera,inout float3 p){
    float t=0.0f;//光线走的长度
    for(int i=0;i&lt;maxItera;i++){
        //注意这里，现在长度既不能超过规定的最大值也不能超过深度值
        if(t&gt;maxDist||t&gt;depth) return false;
        p=ray.origin+t*ray.direction;
        float d=DistanceField(p);
        if(abs(d)&lt;0.01) {
            return true;
        }
        t+=d;
    }
    return false;
}</code></pre> 
<p>在frag函数中，如果是false，就返回原屏幕贴图的颜色， _MainTex一般你用Graphics.Blit()会默认传入原图像。</p> 
<pre class="has"><code class="language-cs">bool hit=RayMarching(ray,depth,_MaxDistance,_MaxIterations,hitPosition);
if(hit){
    float3 normal=calcNormal(hitPosition);
    result=Shade(hitPosition,normal);
}else{
    float3 texCol=tex2D(_MainTex,uv).rgb;
    result=texCol;
}</code></pre> 
<p><img alt="" class="has" height="289" src="https://images2.imgbox.com/6e/dd/toOTtAYS_o.png" width="433"></p> 
<hr> 
<h4>反射</h4> 
<p><strong>1.场景物体的反射</strong></p> 
<p>场景物体的反射我们利用反射探针来完成，因为是imageEffect,所以内置的unity_SpecCube0无法正常配置，我们需要手动把光照探针的贴图传进去。</p> 
<pre class="has"><code class="language-cs">public ReflectionProbe ReflectionProbe;
...
raymarchMat.SetTexture("_SkyBox",ReflectionProbe.texture);</code></pre> 
<p>shader中就是简单的采样叠加</p> 
<pre class="has"><code class="language-cs">if(hit){
    float3 normal=calcNormal(hitPosition);
    result=Shade(hitPosition,normal);
    float3 reflectDir=reflect(ray.direction,normal);
    result=lerp(result,texCUBE(_SkyBox,reflectDir).rgb,_ReflectIntensity);
}</code></pre> 
<p><img alt="" class="has" height="282" src="https://images2.imgbox.com/17/5a/r0pd0Idt_o.png" width="502"></p> 
<p><span style="color:#86ca5e;">红黄色的球是场景中的静态物体，可以看到已经被渲染进了光照探针的立方体贴图中。 </span></p> 
<p><strong>2. 距离场物体的反射</strong></p> 
<blockquote> 
 <p>在开始计算距离场反射之前我们先让距离场物体能够有自己的颜色。</p> 
 <p>思路很简单，我们让距离场函数返回floa4类型，xyz存储颜色，w存储z</p> 
 <p>这里只展示主要的几个函数，要改动的地方其实有很多，首先所有调用DistanceField地方取值都要球改，还有距离场的各个操作函数也要适应flaot4类型。</p> 
 <pre class="has"><code class="language-cs"> float3 Shade(float3 p,float3 normal,float3 hitColor){
     ...
     float3 diffuse=_LightCol*hitColor*(saturate(dot(normal,-_LightDir))*0.5f+0.5f);
     ...
 }
 
 bool  RayMarching(Ray ray,float depth,float maxDist,int maxItera,inout float3 p,inout float3 col){
    float t=0.0f;
    for(int i=0;i&lt;maxItera;i++){
        if(t&gt;maxDist||t&gt;depth) return false;
        p=ray.origin+t*ray.direction;
        float4 d=DistanceField(p);
        if(abs(d.w)&lt;0.01) {
            return true;
        }
        t+=d.w;
        col=d.rgb;
    }
    return false;
}
 
 fixed4 frag (v2f i) : SV_Target {
     ...
     float3 hitPosition,hitColor;
     bool hit=RayMarching(ray,depth,_MaxDistance,_MaxIterations,hitPosition,hitColor);
     if(hit){
         float3 normal=calcNormal(hitPosition);
         result=Shade(hitPosition,normal,hitColor);
     ...
 }</code></pre> 
</blockquote> 
<p>距离场物体的反射思路就是对反射方向进行光线步进。</p> 
<pre class="has"><code class="language-cs">//反射
result=lerp(result,texCUBE(_SkyBox,reflectDir).rgb,_ReflectIntensity);
if(_ReflectBounces&gt;0){
    Ray rRay=CreateRay(hitPosition+0.01*normal,reflectDir);
    hit=RayMarching(rRay,_MaxDistance,_MaxDistance*0.5,_MaxIterations/2,hitPosition,hitColor);
    if(hit){
        normal=calcNormal(hitPosition);
        reflectDir=reflect(ray.direction,normal);
        //第一次的反射结果
        result+=Shade(hitPosition,normal,hitColor)*0.5f*_ReflectIntensity;
        
        if(_ReflectBounces&gt;1){
            rRay=CreateRay(hitPosition+0.01*normal,reflectDir);
            hit=RayMarching(rRay,_MaxDistance,_MaxDistance*0.25,_MaxIterations/4,hitPosition,hitColor);
            if(hit){
                normal=calcNormal(hitPosition);
                reflectDir=reflect(ray.direction,normal);
                //第二次的反射结果
                result+=Shade(hitPosition,normal,hitColor)*0.25f*_ReflectIntensity;
            }
        }
        
    }
}</code></pre> 
<p><img alt="" class="has" src="https://images2.imgbox.com/bd/da/aqoyJsVI_o.png"></p> 
<p><span style="color:#3399ea;">画圈部分就是绿色球对黄色球的反射</span></p> 
<p>参考内容:</p> 
<p><a href="https://www.youtube.com/watch?v=oPnft4z9iJs&amp;list=PL3POsQzaCw53iK_EhOYR39h1J9Lvg-m-g" rel="nofollow">https://www.youtube.com/watch?v=oPnft4z9iJs&amp;list=PL3POsQzaCw53iK_EhOYR39h1J9Lvg-m-g</a><span style="color:#86ca5e;">(推荐看这个系列的视频)</span></p> 
<p><a href="https://www.gamasutra.com/blogs/DavidArppe/20170405/295240/How_to_get_Stunning_Graphics_with_Raymarching_in_Games.php" rel="nofollow">https://www.gamasutra.com/blogs/DavidArppe/20170405/295240/How_to_get_Stunning_Graphics_with_Raymarching_in_Games.php</a></p> 
<p><a href="http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html" rel="nofollow">http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html</a></p> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4c33d7fe56222d958e83434fcef97664/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysql安装遇到的问题，提示 api-ms-win-crt-runtime-l1-1-0.dll丢失</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a06fafcbc21c9d46b94ef33a563252cc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python3 AttributeError: module &#39;string&#39; has no attribute &#39;uppercase&#39;</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>