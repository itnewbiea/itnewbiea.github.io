<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于简单MLP模型的加州房价预测 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于简单MLP模型的加州房价预测" />
<meta property="og:description" content="基于简单MLP模型的加州房价预测 摘要 机器学习是当前热度非常高的领域，可以对房价数据进行预测，具有很高的研究价值。为了更好地学习机器学习，将理论付诸于实践，本文从加州房价预测实验入手，提出了基于简单MLP的房价预测模型方法研究。
本文的主要研究内容为基于简单MLP模型的方法，提出了加州房价预测的模型。本文首先介绍了研究背景和意义，实验选取了来源于Kaggle上的一次竞赛California House Prices。在实验中，首先观察了训练数据以及测试数据，分析了自变量Sold Price与因变量的相关性，选取了用来训练的特征。接着，对数据进行预处理，对数值类型的特征进行特征归一化和缺失值的补充，使用了独热编码处理了离散值，最终得到了用于训练的特征。构建了一个简单MLP模型，共三个线性层，并对前两层使用了Relu()。训练函数借助了Adam优化器，其优点是它对初始学习率敏感度不强。使用了网格搜索结合K折交叉验证对超参数进行了调整。训练结束后将获得的模型应用于测试集，并将预测保存在CSV文件中提交到Kaggle查看结果。最终我在Kaggle上获得的score为。
将我的预测结果与简单线性模型的预测结果进行对比，结果显示在这次竞赛的数据上，所提出的模型预测精度更好，具有稳健性，适合用于加州房价预测。
关键词 房价预测；机器学习；
1. 数据指标说明及处理 1.1 数据来源 为了验证模型的普适性，本文选择的数据是Kaggle竞赛California House Prices的数据。该竞赛的任务是根据房子的信息，如卧室数量、居住面积、位置、附近的学校和卖家的摘要，预测房子的销售价格。数据包括2020年在加州售出的房屋，测试数据集中的房屋在训练数据集中的房屋之后售出。此外，私人排行榜上的房子也是在公共排行榜上的房子之后出售的。
1.2 数据指标说明 &gt; 读入数据集之后首先对数据进行观察，代码和结果如下。
print(train_data.shape) print(test_data.shape) 图1-1
可以观察到训练集共有47439个数据，40个特征，多出的一列是标签Sold Price。测试集有31626个数据，40个特征。
将训练集和测试集合并之后对数据进行总览，结果如下。
图1-2
1.2.1 影响因素特征 通过分析自变量Sold Price与因变量的相关性，得到的结果如下图。
#查看自变量与因变量的相关性 fig = plt.figure(figsize=(14,8)) abs(train_data.corr()[&#39;Sold Price&#39;]).sort_values(ascending=False).plot.bar() plt.xticks(fontsize=20) plt.yticks(fontsize=20) 图1-3
结合上面两步，可以看到相关性大于0.5有这些：Annual tax amount，Tax assessed value，Last Sold
Price，Listed Price，Full bathrooms，Bathrooms。它们全是数值类型，将被加入用于训练的特征列。
1.3 数据预处理 在开始建模前，需要对特征进行预处理。
1.3.1 异常值处理 通过画出上一节中分析出的相关性高的特征的值的分布，通过分析剔除异常的值。
#异常值处理 figure=plt.figure() sns.pairplot(x_vars=[&#39;Annual tax amount&#39;,&#39;Tax assessed value&#39;,&#39;Last Sold Price&#39;,&#39;Listed Price&#39;,&#39;Full bathrooms&#39;,&#39;Bathrooms&#39;], y_vars=[&#39;Sold Price&#39;],data=train_data,dropna=True) plt." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/857808c31d56dafb5f23d08013491953/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-06T11:28:44+08:00" />
<meta property="article:modified_time" content="2022-11-06T11:28:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于简单MLP模型的加州房价预测</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="MLP_2"></a>基于简单MLP模型的加州房价预测</h2> 
<h2><a id="_4"></a>摘要</h2> 
<p>机器学习是当前热度非常高的领域，可以对房价数据进行预测，具有很高的研究价值。为了更好地学习机器学习，将理论付诸于实践，本文从加州房价预测实验入手，提出了基于简单MLP的房价预测模型方法研究。<br> 本文的主要研究内容为基于简单MLP模型的方法，提出了加州房价预测的模型。本文首先介绍了研究背景和意义，实验选取了来源于Kaggle上的一次竞赛California House Prices。在实验中，首先观察了训练数据以及测试数据，分析了自变量Sold Price与因变量的相关性，选取了用来训练的特征。接着，对数据进行预处理，对数值类型的特征进行特征归一化和缺失值的补充，使用了独热编码处理了离散值，最终得到了用于训练的特征。构建了一个简单MLP模型，共三个线性层，并对前两层使用了Relu()。训练函数借助了Adam优化器，其优点是它对初始学习率敏感度不强。使用了网格搜索结合K折交叉验证对超参数进行了调整。训练结束后将获得的模型应用于测试集，并将预测保存在CSV文件中提交到Kaggle查看结果。最终我在Kaggle上获得的score为。<br> 将我的预测结果与简单线性模型的预测结果进行对比，结果显示在这次竞赛的数据上，所提出的模型预测精度更好，具有稳健性，适合用于加州房价预测。</p> 
<h2><a id="_10"></a>关键词</h2> 
<p>房价预测；机器学习；</p> 
<h2><a id="1%09_20"></a>1. 数据指标说明及处理</h2> 
<h3><a id="11%09_21"></a>1.1 数据来源</h3> 
<p>为了验证模型的普适性，本文选择的数据是Kaggle竞赛California House Prices的数据。该竞赛的任务是根据房子的信息，如卧室数量、居住面积、位置、附近的学校和卖家的摘要，预测房子的销售价格。数据包括2020年在加州售出的房屋，测试数据集中的房屋在训练数据集中的房屋之后售出。此外，私人排行榜上的房子也是在公共排行榜上的房子之后出售的。</p> 
<h3><a id="12__23"></a>1.2 数据指标说明</h3> 
<p><em>&gt; 读入数据集之后首先对数据进行观察，代码和结果如下。</em></p> 
<pre><code class="prism language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>train_data<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>test_data<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/af/d5/z7wUWoCr_o.png" alt=""></p> 
<p>图1-1</p> 
<blockquote> 
 <p>可以观察到训练集共有47439个数据，40个特征，多出的一列是标签Sold Price。测试集有31626个数据，40个特征。</p> 
</blockquote> 
<p><em>将训练集和测试集合并之后对数据进行总览，结果如下。</em><br> <img src="https://images2.imgbox.com/db/fe/dHbhhf5s_o.png" alt="在这里插入图片描述"></p> 
<p>图1-2</p> 
<h4><a id="121%09_42"></a>1.2.1 影响因素特征</h4> 
<p><em>通过分析自变量Sold Price与因变量的相关性，得到的结果如下图。</em></p> 
<pre><code class="prism language-python"><span class="token comment">#查看自变量与因变量的相关性</span>
fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token builtin">abs</span><span class="token punctuation">(</span>train_data<span class="token punctuation">.</span>corr<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'Sold Price'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>sort_values<span class="token punctuation">(</span>ascending<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">.</span>plot<span class="token punctuation">.</span>bar<span class="token punctuation">(</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span>fontsize<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span>fontsize<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/0d/80/zxyyYtqE_o.png" alt="在这里插入图片描述"></p> 
<p>图1-3</p> 
<blockquote> 
 <p>结合上面两步，可以看到相关性大于0.5有这些：Annual tax amount，Tax assessed value，Last Sold<br> Price，Listed Price，Full bathrooms，Bathrooms。它们全是数值类型，将被加入用于训练的特征列。</p> 
</blockquote> 
<h3><a id="13%09_59"></a>1.3 数据预处理</h3> 
<p><em>在开始建模前，需要对特征进行预处理。</em></p> 
<h4><a id="131%09_61"></a>1.3.1 异常值处理</h4> 
<p>通过画出上一节中分析出的相关性高的特征的值的分布，通过分析剔除异常的值。</p> 
<pre><code class="prism language-python"><span class="token comment">#异常值处理</span>
figure<span class="token operator">=</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>
sns<span class="token punctuation">.</span>pairplot<span class="token punctuation">(</span>x_vars<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Annual tax amount'</span><span class="token punctuation">,</span><span class="token string">'Tax assessed value'</span><span class="token punctuation">,</span><span class="token string">'Last Sold Price'</span><span class="token punctuation">,</span><span class="token string">'Listed Price'</span><span class="token punctuation">,</span><span class="token string">'Full bathrooms'</span><span class="token punctuation">,</span><span class="token string">'Bathrooms'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
             y_vars<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Sold Price'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>data<span class="token operator">=</span>train_data<span class="token punctuation">,</span>dropna<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>运行结果：<br> <img src="https://images2.imgbox.com/cb/c9/BvZMihmr_o.png" alt="在这里插入图片描述"></p> 
<p>图1-4</p> 
<blockquote> 
 <p>分析第三个坐标轴，存在Last Sold Price大于8，但Sold<br> Price只有4<em>1e7的数据，删除。分析第五个坐标轴，存在Full bathrooms大于15，但Sold<br> Price小于5</em>1e7的数据，删除。分析第六个坐标轴，存在Bathrooms大于20，但Sold Price小于2*1e7的数据，删除。</p> 
</blockquote> 
<p><em>删除异常值后重新打印出特征值的分布图，代码和运行结果如下。</em></p> 
<pre><code class="prism language-python"><span class="token comment">#删除异常值</span>
train_data <span class="token operator">=</span> train_data<span class="token punctuation">.</span>drop<span class="token punctuation">(</span>train_data<span class="token punctuation">[</span><span class="token punctuation">(</span>train_data<span class="token punctuation">[</span><span class="token string">'Last Sold Price'</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token number">8</span><span class="token operator">*</span><span class="token number">1e7</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>
                                        <span class="token punctuation">(</span>train_data<span class="token punctuation">[</span><span class="token string">'Sold Price'</span><span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">4</span><span class="token operator">*</span><span class="token number">1e7</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">)</span>
 
train_data <span class="token operator">=</span> train_data<span class="token punctuation">.</span>drop<span class="token punctuation">(</span>train_data<span class="token punctuation">[</span><span class="token punctuation">(</span>train_data<span class="token punctuation">[</span><span class="token string">'Full bathrooms'</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token number">15</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>
                                        <span class="token punctuation">(</span>train_data<span class="token punctuation">[</span><span class="token string">'Sold Price'</span><span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">5</span><span class="token operator">*</span><span class="token number">1e7</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">)</span>
 
train_data <span class="token operator">=</span> train_data<span class="token punctuation">.</span>drop<span class="token punctuation">(</span>train_data<span class="token punctuation">[</span><span class="token punctuation">(</span>train_data<span class="token punctuation">[</span><span class="token string">'Bathrooms'</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>
                                        <span class="token punctuation">(</span>train_data<span class="token punctuation">[</span><span class="token string">'Sold Price'</span><span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">*</span><span class="token number">1e7</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/9d/4b/Gl5aYdwI_o.png" alt="在这里插入图片描述"></p> 
<p>图1-5</p> 
<h4><a id="132%09_99"></a>1.3.2 特征归一化</h4> 
<p><em>适当地特征缩放可以加速梯度下降过程。通过将特征缩放到均值为0，方差为1来标准化数据：𝑥←(𝑥−𝜇)/𝜎<br> 其中 𝜇 和 𝜎 分别表示均值和标准差。 现在，这些特征具有零均值和单位方差，即 𝐸[𝑥−𝜇𝜎]=𝜇−𝜇𝜎=0 和 𝐸[(𝑥−𝜇)2]=(𝜎2+𝜇2)−2𝜇2+𝜇2=𝜎2 。 直观地说，我们标准化数据有两个原因： 首先，它方便优化。 其次，因为我们不知道哪些特征是相关的， 所以我们不想让惩罚分配给一个特征的系数比分配给其他任何特征的系数更大。</em><br> <em>特征缩放代码如下：</em></p> 
<pre><code class="prism language-python">all_features<span class="token punctuation">[</span>numeric_features<span class="token punctuation">]</span> <span class="token operator">=</span> all_features<span class="token punctuation">[</span>numeric_features<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">apply</span><span class="token punctuation">(</span>
    <span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> x<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>std<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<h4><a id="133%09_109"></a>1.3.3 空缺值填补</h4> 
<p><em>空缺值，如NaN会影响计算，所以需要填补空缺值。一般用该特征的均值来填补，因为之前进行过了特征归一化为均值0，所以每个数值特征的均值都为0，将0对空缺值进行替换。代码如下：</em></p> 
<pre><code class="prism language-python">all_features<span class="token punctuation">[</span>numeric_features<span class="token punctuation">]</span> <span class="token operator">=</span> all_features<span class="token punctuation">[</span>numeric_features<span class="token punctuation">]</span><span class="token punctuation">.</span>fillna<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
</code></pre> 
<h4><a id="134%09_116"></a>1.3.4 独热编码处理</h4> 
<p><em>在进行one-hot之前先观察object类型的特征有哪些，并且他们共有多少种不同的类别。代码和结果如下：</em></p> 
<pre><code class="prism language-python"><span class="token keyword">for</span> in_object <span class="token keyword">in</span> all_features<span class="token punctuation">.</span>dtypes<span class="token punctuation">[</span>all_features<span class="token punctuation">.</span>dtypes<span class="token operator">==</span><span class="token string">'object'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>in_object<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>all_features<span class="token punctuation">[</span>in_object<span class="token punctuation">]</span><span class="token punctuation">.</span>unique<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/d2/3f/UcCTfE6l_o.png" alt="在这里插入图片描述"></p> 
<p>图1-6</p> 
<p><em>&gt; 最终选取了State、Type、Bedrooms加入用于训练的特征，并进行了one-hot。</em></p> 
<pre><code class="prism language-python"><span class="token comment"># 选择特征列</span>
features <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>numeric_features<span class="token punctuation">)</span>
features<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'State'</span><span class="token punctuation">,</span><span class="token string">'Type'</span><span class="token punctuation">,</span><span class="token string">"Bedrooms"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

all_features <span class="token operator">=</span> all_features<span class="token punctuation">[</span>features<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token comment"># 原本第一列是Id，去掉</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>all_features<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>
<span class="token comment">#“Dummy_na=True”将“na”（缺失值）视为有效的特征值，并为其创建指示符特征</span>
all_features <span class="token operator">=</span> pd<span class="token punctuation">.</span>get_dummies<span class="token punctuation">(</span>all_features<span class="token punctuation">,</span> dummy_na<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>all_features<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>
</code></pre> 
<p><em>运行结果：</em></p> 
<pre><code class="prism language-python"><span class="token punctuation">(</span><span class="token number">79065</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">79065</span><span class="token punctuation">,</span> <span class="token number">474</span><span class="token punctuation">)</span>
</code></pre> 
<blockquote> 
 <p>可以观察到，进行one-hot之后，特征列从21变成了474。</p> 
</blockquote> 
<h3><a id="14%09_154"></a>1.4 本章小结</h3> 
<p><em>本节对数据的来源和数据指标进行了说明，分析了影响因素的特征，对数据进行了预处理。数据预处理是房价预测的重要一环，正确的数据预处理使得模型预测事半功倍。这里的预处理做了异常值处理、特征归一化、空缺值填补和独热编码处理。</em></p> 
<h2><a id="2%09MLP_159"></a>2. 基于简单MLP的房价预测模型</h2> 
<h3><a id="21_MLP_160"></a>2.1 MLP模型</h3> 
<p><em>MLP又名多层感知机，也叫人工神经网络（ANN，Artificial Neural Network），除了输入输出层，它中间可以有多个隐藏层，如果没有隐藏层即可解决线性可划分的数据问题。最简单的MLP模型只包含一个隐藏层，即三层的结构，如下图。</em><br> <img src="https://images2.imgbox.com/35/78/Xzjh1v4N_o.png" alt="在这里插入图片描述"><br> 图2-1</p> 
<blockquote> 
 <p>从上图可以看到，多层感知机的层与层之间是全连接的（全连接的意思就是：上一层的任何一个神经元与下一层的所有神经元都有连接）。多层感知机最底层是输入层，中间是隐藏层，最后是输出层。</p> 
</blockquote> 
<h3><a id="22__167"></a>2.2 预测评价指标</h3> 
<h4><a id="221__168"></a>2.2.1 均方误差</h4> 
<p>均方误差（mean-square error, MSE）是反映估计量与被估计量之间差异程度的一种度量。设t是根据子样确定的总体参数θ的一个估计量，(θ-t)<sup>2的数学期望，称为估计量t的均方误差。它等于σ</sup>2+b<sup>2，其中σ</sup>2与b分别是t的方差与偏倚。<br> 均方误差的公式：<br> <img src="https://images2.imgbox.com/dd/55/ISpURa7U_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="23%09_173"></a>2.3 模型与方法</h3> 
<blockquote> 
 <p>本文提出的MLP模型的组成为：Linear+relu()+Linear+relu()+Linear。输入层的输入为474，输出为256。第二层Linear的输入是256，输出64。第三层Linear的输入是64，输出为1。损失函数用的是均方误差函数。</p> 
</blockquote> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">MLP</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>in_features<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span> 
        self<span class="token punctuation">.</span>layer1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>in_features<span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>layer2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>out <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>X<span class="token punctuation">)</span><span class="token punctuation">:</span>
        X <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>layer1<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span>
        X <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>layer2<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>out<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
loss <span class="token operator">=</span> nn<span class="token punctuation">.</span>MSELoss<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<blockquote> 
 <p>房价就像股票价格一样，我们关心的是相对数量，而不是绝对数量。 因此，[我们更关心相对误差 𝑦−𝑦̂ 𝑦 ，] 而不是绝对误差<br> 𝑦−𝑦̂ 。 例如，如果我们在俄亥俄州农村地区估计一栋房子的价格时， 假设我们的预测偏差了10万美元，<br> 然而那里一栋典型的房子的价值是12.5万美元， 那么模型可能做得很糟糕。<br> 另一方面，如果我们在加州豪宅区的预测出现同样的10万美元的偏差，在那里，房价中位数超过400万美元。这可能是一个不错的预测。</p> 
</blockquote> 
<p><em>解决这个问题的一种方法是用价格预测的对数来衡量差异。 事实上，这也是比赛中官方用来评价提交质量的误差指标。 即将 转换为 。这使得预测价格的对数与真实标签价格的对数之间出现以下均方根误差：</em></p> 
<p><img src="https://images2.imgbox.com/24/69/28z17NgH_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">log_rmse</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> features<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 为了在取对数时进一步稳定该值，将小于1的值设置为1</span>
    clipped_preds <span class="token operator">=</span> torch<span class="token punctuation">.</span>clamp<span class="token punctuation">(</span>net<span class="token punctuation">(</span>features<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    rmse <span class="token operator">=</span> torch<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>loss<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>log<span class="token punctuation">(</span>clipped_preds<span class="token punctuation">)</span><span class="token punctuation">,</span>
                           torch<span class="token punctuation">.</span>log<span class="token punctuation">(</span>labels<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> rmse<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><em>训练函数借助了Adam优化器，它的优点是在一开始对学习率不那么敏感。</em></p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">train</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> train_features<span class="token punctuation">,</span> train_labels<span class="token punctuation">,</span> test_features<span class="token punctuation">,</span> test_labels<span class="token punctuation">,</span>
          num_epochs<span class="token punctuation">,</span> learning_rate<span class="token punctuation">,</span> weight_decay<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>
    train_ls<span class="token punctuation">,</span> test_ls <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    train_iter <span class="token operator">=</span> d2l<span class="token punctuation">.</span>load_array<span class="token punctuation">(</span><span class="token punctuation">(</span>train_features<span class="token punctuation">,</span> train_labels<span class="token punctuation">)</span><span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span>
    <span class="token comment"># 这里使用的是Adam优化算法</span>
    optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                 lr <span class="token operator">=</span> learning_rate<span class="token punctuation">,</span>
                                 weight_decay <span class="token operator">=</span> weight_decay<span class="token punctuation">)</span>
    <span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> X<span class="token punctuation">,</span> y <span class="token keyword">in</span> train_iter<span class="token punctuation">:</span>
            optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>
            l <span class="token operator">=</span> loss<span class="token punctuation">(</span>net<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span>
            l<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>
            optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>
        train_ls<span class="token punctuation">.</span>append<span class="token punctuation">(</span>log_rmse<span class="token punctuation">(</span>net<span class="token punctuation">,</span> train_features<span class="token punctuation">,</span> train_labels<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> test_labels <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            test_ls<span class="token punctuation">.</span>append<span class="token punctuation">(</span>log_rmse<span class="token punctuation">(</span>net<span class="token punctuation">,</span> test_features<span class="token punctuation">,</span> test_labels<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> train_ls<span class="token punctuation">,</span> test_ls
</code></pre> 
<blockquote> 
 <p>使用了K折交叉验证。它有助于模型选择和超参数调整。首先需要定义一个函数，在i交叉验证过程中返回第i的数据。具体地说，它选择第i个切片作为验证数据，其余部分作为训练数据。K折交叉验证在数据少的情况下合适使用。一般使用3折或5折。需要注意的是K折交叉验证比较费计算。</p> 
</blockquote> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">get_k_fold_data</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> i<span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">assert</span> k <span class="token operator">&gt;</span> <span class="token number">1</span>
    fold_size <span class="token operator">=</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">//</span> k
    X_train<span class="token punctuation">,</span> y_train <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span>
    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>
        idx <span class="token operator">=</span> <span class="token builtin">slice</span><span class="token punctuation">(</span>j <span class="token operator">*</span> fold_size<span class="token punctuation">,</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> fold_size<span class="token punctuation">)</span>
        X_part<span class="token punctuation">,</span> y_part <span class="token operator">=</span> X<span class="token punctuation">[</span>idx<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>
        <span class="token keyword">if</span> j <span class="token operator">==</span> i<span class="token punctuation">:</span>
            X_valid<span class="token punctuation">,</span> y_valid <span class="token operator">=</span> X_part<span class="token punctuation">,</span> y_part
        <span class="token keyword">elif</span> X_train <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            X_train<span class="token punctuation">,</span> y_train <span class="token operator">=</span> X_part<span class="token punctuation">,</span> y_part
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            X_train <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>X_train<span class="token punctuation">,</span> X_part<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
            y_train <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>y_train<span class="token punctuation">,</span> y_part<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> X_valid<span class="token punctuation">,</span> y_valid
</code></pre> 
<p><em>一般来讲模型的训练误差和验证误差会取K折交叉验证计算结果的平均值。</em></p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">k_fold</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> num_epochs<span class="token punctuation">,</span> learning_rate<span class="token punctuation">,</span> weight_decay<span class="token punctuation">,</span>
           batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>
    train_l_sum<span class="token punctuation">,</span> valid_l_sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>
        data <span class="token operator">=</span> get_k_fold_data<span class="token punctuation">(</span>k<span class="token punctuation">,</span> i<span class="token punctuation">,</span> X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>
        in_features <span class="token operator">=</span> X_train<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
        net <span class="token operator">=</span> MLP<span class="token punctuation">(</span>in_features<span class="token punctuation">)</span>
        train_ls<span class="token punctuation">,</span> valid_ls <span class="token operator">=</span> train<span class="token punctuation">(</span>net<span class="token punctuation">,</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> num_epochs<span class="token punctuation">,</span> learning_rate<span class="token punctuation">,</span>
                                   weight_decay<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span>
        train_l_sum <span class="token operator">+=</span> train_ls<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        valid_l_sum <span class="token operator">+=</span> valid_ls<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
            d2l<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> num_epochs <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>train_ls<span class="token punctuation">,</span> valid_ls<span class="token punctuation">]</span><span class="token punctuation">,</span>
                     xlabel<span class="token operator">=</span><span class="token string">'epoch'</span><span class="token punctuation">,</span> ylabel<span class="token operator">=</span><span class="token string">'rmse'</span><span class="token punctuation">,</span> xlim<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> num_epochs<span class="token punctuation">]</span><span class="token punctuation">,</span>
                     legend<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'train'</span><span class="token punctuation">,</span> <span class="token string">'valid'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> yscale<span class="token operator">=</span><span class="token string">'log'</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'折</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span></span><span class="token string">，训练log rmse</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token builtin">float</span><span class="token punctuation">(</span>train_ls<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token format-spec">f</span><span class="token punctuation">}</span></span><span class="token string">, '</span></span>
              <span class="token string-interpolation"><span class="token string">f'验证log rmse</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token builtin">float</span><span class="token punctuation">(</span>valid_ls<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token format-spec">f</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> train_l_sum <span class="token operator">/</span> k<span class="token punctuation">,</span> valid_l_sum <span class="token operator">/</span> k
</code></pre> 
<h2><a id="3%09_282"></a>3. 模型的预测结果</h2> 
<p><em>经过上面的步骤之后对模型进行训练，得到以下结果：</em><br> 、<img src="https://images2.imgbox.com/80/1a/0TGPu5Wm_o.png" alt="在这里插入图片描述"></p> 
<p>图3-1</p> 
<h3><a id="31%09_288"></a>3.1 测试集预测结果</h3> 
<p>在测试集上进行预测，并且将预测结果保存在.cvs文件中，用于上传到Kaggle平台。</p> 
<p><img src="https://images2.imgbox.com/aa/fc/16at1mWX_o.png" alt="在这里插入图片描述"></p> 
<p>图3-2</p> 
<h3><a id="32%09Kaggle_295"></a>3.2 Kaggle上的预测结果</h3> 
<p>经过Kaggle平台的评测，得到1.02246的成绩。<br> <img src="https://images2.imgbox.com/85/3e/227No1o0_o.png" alt="在这里插入图片描述"></p> 
<p>图3-3</p> 
<h3><a id="33%09_302"></a>3.3 对比简单线性模型</h3> 
<p>这里的简单线性模型仅有一层线性层。且没有做独热编码。其测试结果log rmse为1.066426。其在Kaggle上的score为：1.12455。本文所提出的模型的lg rmse为0.784812。其在Kaggle上的score为1.02246，较前者在精度上有进步。</p> 
<p><img src="https://images2.imgbox.com/a5/f2/b0rEJbSE_o.png" alt="在这里插入图片描述"></p> 
<p>图3-4</p> 
<p><img src="https://images2.imgbox.com/31/0d/Tk0aDjvH_o.png" alt="在这里插入图片描述"></p> 
<p>图3-5</p> 
<h3><a id="34%09_313"></a>3.4 本章小结</h3> 
<blockquote> 
 <p>本章展示了所提出的模型在测试集上的预测结果以及在Kaggle上获得的score。最后与简单线性模型进行了对比，结果表明所提出的模型预测精度更好。</p> 
</blockquote> 
<h2><a id="4%09_317"></a>4. 总结与展望</h2> 
<blockquote> 
 <p>本文通过实战Kaggle平台的竞赛California House<br> Prices，将机器学习课堂所学知识付诸于实践，深刻了知识理解，提高了动手能力。本文提出了基于简单MLP的加州房价预测模型，介绍了研究背景和意义，对数据进行预处理，最终得到了用于训练的特征。构建了一个简单MLP模型。使用了网格搜索结合K折交叉验证对超参数进行了调整。训练结束后将获得的模型应用于测试集，并提交到Kaggle查看结果。最终在Kaggle上获得的score为。<br> 将我的预测结果与简单线性模型的预测结果进行对比，结果显示在这次竞赛的数据上，所提出的模型预测精度更好，具有稳健性，适合用于加州房价预测。</p> 
</blockquote> 
<h2><a id="_324"></a>参考文献</h2> 
<p>[1]伍玉莹. 基于深度学习的房价预测方法研究[D].辽宁大学,2021.DOI:10.27209/d.cnki.glniu.2021.001036.</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cfebd6c962e27d470c7c51b4bd05fb36/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">javaweb</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/02a9cb5ba67ad362479720ff53bf8ce8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue框架背后的故事</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>