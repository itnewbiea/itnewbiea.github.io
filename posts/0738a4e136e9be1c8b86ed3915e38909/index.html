<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32 | 串口打印知多少？ - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32 | 串口打印知多少？" />
<meta property="og:description" content="1024G 嵌入式资源大放送！包括但不限于C/C&#43;&#43;、单片机、Linux等。关注微信公众号【嵌入式大杂烩】，回复1024，即可免费获取！
常规打印方法 在STM32的应用中，我们常常对printf进行重定向的方式来把打印信息printf到我们的串口助手。
在MDK环境中，我们常常使用MicroLIB&#43;fputc的方式实现串口打印功能，即：
要实现fputc函数的原因是：printf函数依赖于fputc函数，重新实现fputc内部从串口发送数据即可间接地实现printf打印输出数据到串口。
不知道大家有没有看过正点原子裸机串口相关的例程，他们的串口例程里不使用MicroLIB，而是使用标准库&#43;fputc的方式。相关代码如：
#if 1 #pragma import(__use_no_semihosting) //标准库需要的支持函数 struct __FILE { int handle; }; FILE __stdout; /** * @brief 定义_sys_exit()以避免使用半主机模式 * @param void * @return void */ void _sys_exit(int x) { x = x; } int fputc(int ch, FILE *f) { while((USART1-&gt;ISR &amp; 0X40) == 0); //循环发送,直到发送完毕 USART1-&gt;TDR = (u8) ch; return ch; } #endif 关于这两种方法的一些说明可以查看Mculover666兄的《重定向printf函数到串口输出的多种方法》这篇文章。这篇文章中不仅包含上面的两种方法，而且也包含着在GCC中使用标准库重定向printf的方法。
自己实现一个打印函数 以上的几种方法基本上是改造C库的printf函数来实现串口打印的功能。其实我们也可以自己实现一个串口打印的功能。
printf本身就是一个变参函数，其原型为：
int printf (const char *__format, ...); 所以，我们要重新封装的一个串口打印函数自然也应该是一个变参函数。具体实现如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0738a4e136e9be1c8b86ed3915e38909/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-17T23:00:00+08:00" />
<meta property="article:modified_time" content="2020-05-17T23:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32 | 串口打印知多少？</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <blockquote> 
  <p><span style="color:#3399ea;"><strong>1024G 嵌入式资源大放送！包括但不限于C/C++、单片机、Linux等。关注微信公众号【嵌入式大杂烩】，回复1024，即可免费获取！</strong></span></p> 
 </blockquote> 
 <h3>常规打印方法</h3> 
 <p>在STM32的应用中，我们常常对printf进行重定向的方式来把打印信息printf到我们的串口助手。</p> 
 <p>在MDK环境中，我们常常使用<code>MicroLIB+fputc</code>的方式实现串口打印功能，即：</p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/14/8c/pB48ztk6_o.png"></p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/28/30/mXZI5yYI_o.png"></p> 
 <p>要实现fputc函数的原因是：printf函数依赖于fputc函数，重新实现fputc内部从串口发送数据即可间接地实现printf打印输出数据到串口。</p> 
 <p>不知道大家有没有看过正点原子裸机串口相关的例程，他们的串口例程里<code>不使用MicroLIB</code>，而是使用<code>标准库+fputc</code>的方式。相关代码如：</p> 
 <pre class="has"><code class="language-go language-cpp">#if 1
#pragma import(__use_no_semihosting)
//标准库需要的支持函数
struct __FILE
{
    int handle;
};

FILE __stdout;
/**
 * @brief 定义_sys_exit()以避免使用半主机模式
 * @param void
 * @return  void
 */
void _sys_exit(int x)
{
    x = x;
}

int fputc(int ch, FILE *f)
{
    while((USART1-&gt;ISR &amp; 0X40) == 0); //循环发送,直到发送完毕

    USART1-&gt;TDR = (u8) ch;
    return ch;
}
#endif
</code></pre> 
 <p>关于这两种方法的一些说明可以查看Mculover666兄的<u><a href="http://mp.weixin.qq.com/s?__biz=MzUyMTE0NTA2Ng%3D%3D&amp;chksm=f9dede4dcea9575b1d4ee9c6e957f0ae37f6bd666b90caf3511f44e88ddf11c42a8465c83c83&amp;idx=1&amp;mid=2247483848&amp;scene=21&amp;sn=efb810393f3849eedfa3d6496465b1bc#wechat_redirect" rel="nofollow"><strong>《重定向printf函数到串口输出的多种方法》</strong></a></u>这篇文章。这篇文章中不仅包含上面的两种方法，而且也包含着在GCC中使用标准库重定向printf的方法。</p> 
 <h3>自己实现一个打印函数</h3> 
 <p>以上的几种方法基本上是改造C库的printf函数来实现串口打印的功能。其实我们也可以自己实现一个串口打印的功能。</p> 
 <p>printf本身就是一个变参函数，其原型为：</p> 
 <pre class="has"><code class="language-go">int printf (const char *__format, ...);
</code></pre> 
 <p>所以，我们要重新封装的一个串口打印函数自然也应该是一个变参函数。具体实现如下：</p> 
 <h4>1、基于STM32的HAL库</h4> 
 <pre class="has"><code class="language-go language-cpp">#define TX_BUF_LEN  256     /* 发送缓冲区容量，根据需要进行调整 */
uint8_t TxBuf[TX_BUF_LEN];  /* 发送缓冲区                       */
void MyPrintf(const char *__format, ...)
{
  va_list ap;
  va_start(ap, __format);
  
  /* 清空发送缓冲区 */
  memset(TxBuf, 0x0, TX_BUF_LEN);
  
  /* 填充发送缓冲区 */
  vsnprintf((char*)TxBuf, TX_BUF_LEN, (const char *)__format, ap);
  va_end(ap);
  int len = strlen((const char*)TxBuf);
  
  /* 往串口发送数据 */
  HAL_UART_Transmit(&amp;huart1, (uint8_t*)&amp;TxBuf, len, 0xFFFF);
}
</code></pre> 
 <p>因为我们使用printf函数基本不使用其返回值，所以这里直接用void类型了。</p> 
 <p>自定义变参函数需要用到va_start、va_end等宏，需要包含头文件<code>stdarg.h</code>。关于变参函数的一些学习可以查看网上的一些博文，如：</p> 
 <blockquote> 
  <p>https://www.cnblogs.com/wulei0630/p/9444062.html</p> 
 </blockquote> 
 <p>这里我们使用的是STM32的HAL库，其给我们提供HAL_UART_Transmit接口可以直接把整个发送缓冲区的内容给一次性发出去。</p> 
 <h4>2、基于STM32标准库</h4> 
 <p>若是基于STM32的标准库，就需要一字节一字节的循环发送出去，具体代码如：</p> 
 <pre class="has"><code class="language-go language-cpp">#define TX_BUF_LEN  256     /* 发送缓冲区容量，根据需要进行调整 */
uint8_t TxBuf[TX_BUF_LEN];  /* 发送缓冲区                       */
void MyPrintf(const char *__format, ...)
{
  va_list ap;
  va_start(ap, __format);
    
  /* 清空发送缓冲区 */
  memset(TxBuf, 0x0, TX_BUF_LEN);
    
  /* 填充发送缓冲区 */
  vsnprintf((char*)TxBuf, TX_BUF_LEN, (const char *)__format, ap);
  va_end(ap);
  int len = strlen((const char*)TxBuf);
  
  /* 往串口发送数据 */
  for (int i = 0; i &lt; len; i++)
  {
 while(USART_GetFlagStatus(USART1, USART_FLAG_TC)==RESET);    
 USART_SendData(USART1, TxBuf[i]);
  }
}
</code></pre> 
 <p>测试结果：</p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e1/af/rXtlWQTj_o.png"></p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3a/cf/JNX4wIbU_o.png"></p> 
 <p>我们也可以使用我们的MyPrintf函数按照上一篇文章：<u><a href="http://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA%3D%3D&amp;chksm=fe0d6035c97ae9231886ff879e19ed2a45e30474c02f1324169754cbccc667fec6bbcd5b8775&amp;idx=1&amp;mid=2247487218&amp;scene=21&amp;sn=c1bfbb9aed844bc1cda724d81f525005#wechat_redirect" rel="nofollow"><strong>《C语言、嵌入式中几个非常实用的宏技巧》</strong></a></u>的方式封装一个宏打印函数：</p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/27/67/ToXH8a5r_o.png"></p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5e/0a/UZXybHyM_o.png"></p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/57/76/lEsTEvOB_o.png"></p> 
 <p>以上就是我们自定义方式实现的一种串口打印函数。</p> 
 <p>但是，我想说：<code>对于串口打印的使用，我们没必要自己创建一个打印函数。</code></p> 
 <p>看到这，是不是有人想要打我了。。。。看了半天，你却跟我说没必要用。。。</p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/43/ee/VFSlp6rO_o.png"></p> 
 <p>哈哈，别急，我们不应用在串口打印调试方面，那可以用在其它方面呀。</p> 
 <p><strong>（1）应用一：</strong></p> 
 <p>比如最近我在实际应用中：我们的MCU跑的是我们老大自己写的一个小的操作系统+我们公司自己开发的上位机。</p> 
 <p>我们MCU端与上位机使用的是串口通讯，MCU往上位机发送的数据有两种类型，一种是HEX格式数据，一种是字符串数据。</p> 
 <p>但是我们下位机的这两种数据，在通过串口发送之前都得统一把数据封包交给那个系统通信任务，然后再由通信任务发出去。</p> 
 <p>在这里，就不能用printf了。老大也针对他的这个系统实现了一个deb_printf函数用于打印调试。</p> 
 <p>但是，那个函数既复杂又很鸡肋，稍微复杂一点的数据就打印不出来了。</p> 
 <p>因此我利用上面的思路给它新封装了一个打印调试函数，很好用，完美地兼容了老大的那个系统。具体代码就不分享了，大体代码、思路如上。</p> 
 <p><strong>（2）应用二：</strong></p> 
 <p>我们在使用串口与ESP8266模块通讯时，可利用类似这样的方式封装一个发送数据的函数，这个函数的使用可以像printf一样简单。</p> 
 <p>可以以很简单的方式把数据透传至服务端，比如我以前的毕设中就有这么应用：</p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/85/92/S4OLahXd_o.png"></p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d2/39/O9taztEY_o.png"></p> 
 <h3>最后</h3> 
 <p>以上就是本次的分享。如有错误，欢迎指出！谢谢</p> 
 <p>本篇笔记会同步至我的个人博客：https://www.lizhengnian.cn/中，欢迎来访。</p> 
 <p>原创不易，期待您的在看、分享~</p> 
 <h3>猜你喜欢：</h3> 
 <p><strong><u><a href="https://blog.csdn.net/zhengnianli/article/details/103837501"><span style="color:#3399ea;">串口通讯你真的会了吗？不妨看看这些经验</span></a></u></strong></p> 
 <p><strong><u><a href="https://blog.csdn.net/zhengnianli/article/details/106168944"><span style="color:#3399ea;">C语言、嵌入式中几个非常实用的宏技巧</span></a></u></strong></p> 
 <p><strong><u><a href="https://blog.csdn.net/zhengnianli/article/details/104190535"><span style="color:#3399ea;">C语言、嵌入式重点知识：回调函数</span></a></u></strong></p> 
 <p><strong><u><a href="http://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA%3D%3D&amp;chksm=fe0d6442c97aed54d5ac5d68f5d5fc8d0e7fb979837410e3d6338d73aa67b98c5737dedf98c5&amp;idx=1&amp;mid=2247486085&amp;scene=21&amp;sn=44aa2b1c5b2988e29c15b54573554254#wechat_redirect" rel="nofollow"><span style="color:#3399ea;">C语言、嵌入式位操作精华技巧大汇总</span></a></u></strong></p> 
 <p><strong><u><a href="https://blog.csdn.net/zhengnianli/article/details/105721944"><span style="color:#3399ea;">【Linux笔记】设备树实例分析</span></a></u></strong></p> 
 <p><strong><u><a href="http://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA%3D%3D&amp;chksm=fe0d63f4c97aeae26af717e99050aa7bbb183d3ee9aac76e27222df8804f26d6519bb90c07e2&amp;idx=1&amp;mid=2247486771&amp;scene=21&amp;sn=0df4aa4c3673b5a25bfa0b9e09122f97#wechat_redirect" rel="nofollow"><span style="color:#3399ea;">【Linux笔记】通俗易懂的Linux驱动基础</span></a></u></strong></p> 
 <p><strong><u><a href="https://blog.csdn.net/zhengnianli/article/details/104630113"><span style="color:#3399ea;">【Linux笔记】pc机_开发板_ubuntu互ping实验</span></a></u></strong></p> 
 <p><strong><u><a href="http://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA%3D%3D&amp;chksm=fe0d6383c97aea95ac1e494cd77a9066b5909bf207f025a2424cd1f8fd9923adf713f87a4e1c&amp;idx=1&amp;mid=2247486788&amp;scene=21&amp;sn=ff32c5cecb481bb3553fb4feb5806af5#wechat_redirect" rel="nofollow"><span style="color:#3399ea;">学习STM32的一些经验分享</span></a></u></strong></p> 
 <p><strong><u><a href="https://blog.csdn.net/zhengnianli/article/details/105402756"><span style="color:#3399ea;">基于LiteOS的智慧农业案例实验分享</span></a></u></strong></p> 
 <p><strong><u><a href="https://blog.csdn.net/zhengnianli/article/details/104712931"><span style="color:#3399ea;">从单片机工程师的角度看嵌入式Linux</span></a></u></strong></p> 
 <blockquote> 
  <p><span style="color:#e579b6;"><strong>1024G 嵌入式资源大放送！包括但不限于C/C++、单片机、Linux等。关注微信公众号【嵌入式大杂烩】，回复1024，即可免费获取！</strong></span></p> 
 </blockquote> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/14770ef44f305ad423defd2cec6982e7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用t-SNE可视化图像embedding 图像特征可视化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/568bde3a15160ea6a826752dfd57cc0d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Liunx服务管理之ftp</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>