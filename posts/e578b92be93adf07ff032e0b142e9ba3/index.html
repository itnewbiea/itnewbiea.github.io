<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STUN工作原理 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STUN工作原理" />
<meta property="og:description" content="目录
一. 前言
二. STUN报文格式
STUN Header
RFC3489
RFC5389
STUN Message Body
RFC3489
RFC5389
三. WebRTC对STUN协议的支持
四. STUN工作流程
1. 使用STUN获取NAT映射后的地址
五. 参考资料
一. 前言 现实网络环境中绝大多数主机都是处于 NAT 之后，对于两个处于同一内网环境的主机，它们只要知道对端的内网地址就能进行通信，而对于不在同一内网的主机，如果它们想通信，要么借助带有公网地址的主机转发，要么通过一定的手段进行 NAT 穿越。
STUN 协议是用来 NAT 穿越的工具，它允许位于 NAT 之后的主机查找到自己 NAT 映射后的公网地址，需要通信的双方交换映射后的公网地址再进行连通性检测。
STUN 最先在 RFC3489 中定义，英文全称是 Simple Traversal of UDP Through NAT，即用 UDP 进行 NAT 穿越，而新的 RFC5389 把 STUN 定义为 Session Traversal Utilities for NAT，即 NAT 会话传输工具，RFC3489 与 RFC5389 相比，最大的区别是后者支持 TCP 穿越。
STUN 协议是一个 C/S 模型的协议，即一端发送请求，另一端进行响应，此外还有指示类型的消息，一端发送指示消息后，另一端不必响应。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e578b92be93adf07ff032e0b142e9ba3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-29T15:26:26+08:00" />
<meta property="article:modified_time" content="2023-07-29T15:26:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STUN工作原理</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%20%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%20%E5%89%8D%E8%A8%80" rel="nofollow">一. 前言</a></p> 
<p id="%E4%BA%8C.%20STUN%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%20STUN%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F" rel="nofollow">二. STUN报文格式</a></p> 
<p id="STUN%20Header-toc" style="margin-left:40px;"><a href="#STUN%20Header" rel="nofollow">STUN Header</a></p> 
<p id="RFC3489-toc" style="margin-left:80px;"><a href="#RFC3489" rel="nofollow">RFC3489</a></p> 
<p id="RFC5389-toc" style="margin-left:80px;"><a href="#RFC5389" rel="nofollow">RFC5389</a></p> 
<p id="STUN%20Message%20Body-toc" style="margin-left:40px;"><a href="#STUN%20Message%20Body" rel="nofollow">STUN Message Body</a></p> 
<p id="RFC3489-toc" style="margin-left:80px;"><a href="#RFC3489" rel="nofollow">RFC3489</a></p> 
<p id="RFC5389-toc" style="margin-left:80px;"><a href="#RFC5389" rel="nofollow">RFC5389</a></p> 
<p id="%E4%B8%89.%20WebRTC%E5%AF%B9STUN%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%94%AF%E6%8C%81-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%20WebRTC%E5%AF%B9STUN%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%94%AF%E6%8C%81" rel="nofollow">三. WebRTC对STUN协议的支持</a></p> 
<p id="%E5%9B%9B.%20STUN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%20STUN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" rel="nofollow">四. STUN工作流程</a></p> 
<p id="1.%20%E4%BD%BF%E7%94%A8STUN%E8%8E%B7%E5%8F%96NAT%E6%98%A0%E5%B0%84%E5%90%8E%E7%9A%84%E5%9C%B0%E5%9D%80-toc" style="margin-left:40px;"><a href="#1.%20%E4%BD%BF%E7%94%A8STUN%E8%8E%B7%E5%8F%96NAT%E6%98%A0%E5%B0%84%E5%90%8E%E7%9A%84%E5%9C%B0%E5%9D%80" rel="nofollow">1. 使用STUN获取NAT映射后的地址</a></p> 
<p id="%E4%BA%94.%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-toc" style="margin-left:0px;"><a href="#%E4%BA%94.%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" rel="nofollow">五. 参考资料</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80.%20%E5%89%8D%E8%A8%80">一. 前言</h2> 
<p>        现实网络环境中绝大多数主机都是处于 NAT 之后，对于两个处于同一内网环境的主机，它们只要知道对端的内网地址就能进行通信，而对于不在同一内网的主机，如果它们想通信，要么借助带有公网地址的主机转发，要么通过一定的手段进行 NAT 穿越。</p> 
<p>        STUN 协议是用来 NAT 穿越的工具，它允许位于 NAT 之后的主机查找到自己 NAT 映射后的公网地址，需要通信的双方交换映射后的公网地址再进行连通性检测。</p> 
<p>        STUN 最先在 <a class="link-info" href="https://datatracker.ietf.org/doc/html/rfc3489" rel="nofollow" title="RFC3489">RFC3489</a> 中定义，英文全称是 Simple Traversal of UDP Through NAT，即用 UDP 进行 NAT 穿越，而新的 <a class="link-info" href="https://datatracker.ietf.org/doc/html/rfc5389" rel="nofollow" title="RFC5389">RFC5389</a> 把 STUN 定义为 Session Traversal Utilities for NAT，即 NAT 会话传输工具，RFC3489 与 RFC5389 相比，最大的区别是后者支持 TCP 穿越。</p> 
<p>        STUN 协议是一个 C/S 模型的协议，即一端发送请求，另一端进行响应，此外还有指示类型的消息，一端发送指示消息后，另一端不必响应。</p> 
<p></p> 
<h2 id="%E4%BA%8C.%20STUN%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F">二. STUN报文格式</h2> 
<p>RFC3489 和 RFC5389 定义的报文格式有些许差别，因此下面会分开说明。</p> 
<p></p> 
<h3 id="STUN%20Header">STUN Header</h3> 
<h4 id="RFC3489"><strong>RFC3489</strong></h4> 
<p><img alt="" height="722" src="https://images2.imgbox.com/5e/73/6G9palsd_o.png" width="1200"></p> 
<p>        STUN 报文以 20 个字节的头部开始，后面跟着若干属性。</p> 
<p>        RFC3489 STUN Header 包含三个字段（2 个字节的 STUN Message Type，2 个字节的 Message Length，16 个字节的 Transaction ID）。</p> 
<p>STUN Message Type 的取值和对应的含义如下。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:174px;">Message Type</td><td style="width:324px;">含义</td></tr><tr><td style="width:174px;">0x0001</td><td style="width:324px;">绑定请求</td></tr><tr><td style="width:174px;">0x0101</td><td style="width:324px;">绑定响应</td></tr><tr><td style="width:174px;">0x0111</td><td style="width:324px;">绑定错误响应</td></tr><tr><td style="width:174px;">0x0002</td><td style="width:324px;">共享私密请求</td></tr><tr><td style="width:174px;">0x0102</td><td style="width:324px;">共享私密响应</td></tr><tr><td style="width:174px;">0x0112</td><td style="width:324px;">共享私密错误响应</td></tr></tbody></table> 
<p>Message Length：STUN 报文长度（不包括固定的 20 字节的头部）。</p> 
<p>Transaction ID：事务 ID，用于关联请求和对应的响应，同一事务的请求和响应事务 ID 相同。</p> 
<p></p> 
<h4 id="RFC5389"><strong>RFC5389</strong></h4> 
<p><img alt="" height="618" src="https://images2.imgbox.com/3f/e2/DvLvUAsd_o.png" width="1200"></p> 
<p>         RFC5389 的 STUN Header 也是 20 个字节，只是 STUN Message Type 从 16bit 变成 14bit，开头的 2bit 固定为 00，Transaction ID 从 128bit 变成 96bit，减少的 32bit 变成 Magic Cookie，其值固定为 0x2112A442，使用 Magic Cookie 可以区分 STUN RFC3489 还是 RFC5389。Message Length 含义与 RFC3489 一样，表示 STUN 报文除去头部后的长度。</p> 
<p>RFC5389 的 STUN Message Type (14bit) 可以进一步分解成以下结构。</p> 
<p><img alt="" height="237" src="https://images2.imgbox.com/3f/16/LQvZFQNH_o.png" width="555"></p> 
<p>        M11~M0 用来表示方法，RFC 规范目前只定义了一个方法：Binding，其他方法可以由使用者自行扩展。</p> 
<p>        C1C0 表示方法的类型，对于 C1C0=0b00 表示这是一个请求，C1C0=0b01 表示指示，C1C0=0b10 表示请求成功的响应，C1C0=0b11 表示请求失败的响应。</p> 
<p>        方法与方法的类型是正交的，即对于每一种方法，其请求，指示，请求成功响应，请求失败响应都是可能的。</p> 
<p></p> 
<h3 id="STUN%20Message%20Body">STUN Message Body</h3> 
<p>        STUN 报文头部之后有 0 或多个属性，每个属性使用 TLV 编码（Type, Length, Value）。</p> 
<p><img alt="" height="402" src="https://images2.imgbox.com/5f/73/mZvsH1zJ_o.png" width="1200"></p> 
<p></p> 
<h4><strong>RFC3489</strong></h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:108px;">Type</td><td style="width:182px;">名称</td><td style="width:209px;">说明</td></tr><tr><td style="width:108px;"><strong>0x0001</strong></td><td style="width:182px;"><strong>MAPPED-ADDRESS</strong></td><td style="width:209px;"><strong>返回客户端NAT映射过的IP和端口</strong></td></tr><tr><td style="width:108px;"><strong>0x0002</strong></td><td style="width:182px;"><strong>RESPONSE-ADDRESS</strong></td><td style="width:209px;"><strong>指明对于MAPPED-ADDRESS的响应应该发送至哪里</strong></td></tr><tr><td style="width:108px;">0x0003</td><td style="width:182px;">CHANGE-REQUEST</td><td style="width:209px;">请求服务端使用不同的IP和端口发送响应</td></tr><tr><td style="width:108px;">0x0004</td><td style="width:182px;">SOURCE-ADDRESS</td><td style="width:209px;">指示服务端的IP和端口</td></tr><tr><td style="width:108px;">0x0005</td><td style="width:182px;">CHANGED-ADDRESS</td><td style="width:209px;">CHANGE-REQUEST的响应</td></tr><tr><td style="width:108px;">0x0006</td><td style="width:182px;">USERNAME</td><td style="width:209px;">用户名，用于安全认证</td></tr><tr><td style="width:108px;">0x0007</td><td style="width:182px;">PASSWORD</td><td style="width:209px;">密码，用于安全认证</td></tr><tr><td style="width:108px;">0x0008</td><td style="width:182px;">MESSAGE-INTEGRITY</td><td style="width:209px;">用于消息完整性验证</td></tr><tr><td style="width:108px;">0x0009</td><td style="width:182px;">ERROR-CODE</td><td style="width:209px;">错误码</td></tr><tr><td style="width:108px;">0x000a</td><td style="width:182px;">UNKNOWN-ATTRIBUTES</td><td style="width:209px;">未知属性</td></tr><tr><td style="width:108px;">0x000b</td><td style="width:182px;">REFLECTED-FROM</td><td style="width:209px;">拒绝</td></tr></tbody></table> 
<p><img alt="" height="892" src="https://images2.imgbox.com/78/33/JLzCKwwY_o.png" width="1200"></p> 
<p>        上图表示的意思是 MAPPED-ADDRESS 这个属性一定不出现在 Binding Req 中，必须出现在 Binding Resp 中，而 RESPONSE-ADDRESS 属性可以出现在 Binding Req 中，一定不出现在其他类型的方法中。</p> 
<p>        N/A 表示不，M 表示必须，O 表示可选，其他类型的属性以此类推。</p> 
<p></p> 
<h4>RFC5389</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:109px;">Type</td><td style="width:186px;">名称</td><td style="width:204px;">说明</td></tr><tr><td style="width:109px;">0x0020</td><td style="width:186px;">XOR-MAPPED-ADDRESS</td><td style="width:204px;">异或地址</td></tr><tr><td style="width:109px;">0x8028</td><td style="width:186px;">FINGERPRINT </td><td style="width:204px;">消息指纹</td></tr></tbody></table> 
<p>        RFC5389 的属性与 RFC3489 有些许不同，大部分 RFC3489 的属性在 RFC5389 中仍然能使用，此外 RFC5389 还扩展了一些属性，例如 XOR-MAPPED-ADDRESS 获取异或后的地址， FINGERPRINT 防止消息被篡改等，其他属性可查阅 RFC5389 文档，此处不过多介绍。</p> 
<p></p> 
<h2 id="%E4%B8%89.%20WebRTC%E5%AF%B9STUN%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%94%AF%E6%8C%81">三. WebRTC对STUN协议的支持</h2> 
<p>        WebRTC 支持的 STUN 消息类型除了 RFC 规范提及的之外，还扩展了 GOOG Ping 的请求/响应消息。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:168px;">Message Type</td><td style="width:330px;">含义</td></tr><tr><td style="width:168px;">0x0001</td><td style="width:330px;">请求消息</td></tr><tr><td style="width:168px;">0x0011</td><td style="width:330px;">指示消息</td></tr><tr><td style="width:168px;">0x0101</td><td style="width:330px;">成功响应消息</td></tr><tr><td style="width:168px;">0x0111</td><td style="width:330px;">错误响应消息</td></tr><tr><td style="width:168px;">0x0200</td><td style="width:330px;">GOOG Ping 请求消息</td></tr><tr><td style="width:168px;">0x0300</td><td style="width:330px;">GOOG Ping 响应消息</td></tr><tr><td style="width:168px;">0x0310</td><td style="width:330px;">GOOG Ping 错误响应消息</td></tr></tbody></table> 
<p>        对于属性值，WebRTC 并没有支持 RFC 规范中提到的所有属性，支持的属性如下所示。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:168px;">Type</td><td style="width:330px;">名称</td></tr><tr><td style="width:168px;">0x0001</td><td style="width:330px;">MAPPED-ADDRESS</td></tr><tr><td style="width:168px;">0x0006</td><td style="width:330px;">USERNAME</td></tr><tr><td style="width:168px;">0x0008</td><td style="width:330px;">MESSAGE-INTEGRITY</td></tr><tr><td style="width:168px;">0x0009</td><td style="width:330px;">ERROR-CODE</td></tr><tr><td style="width:168px;">0x000a</td><td style="width:330px;">UNKNOWN-ATTRIBUTES</td></tr><tr><td style="width:168px;">0x0014</td><td style="width:330px;">REALM</td></tr><tr><td style="width:168px;">0x0015</td><td style="width:330px;">NONCE</td></tr><tr><td style="width:168px;">0x0020</td><td style="width:330px;">XOR-MAPPED-ADDRESS</td></tr><tr><td style="width:168px;">0x8022</td><td style="width:330px;">SOFTWARE</td></tr><tr><td style="width:168px;">0x8023</td><td style="width:330px;">ALTERNATE-SERVER</td></tr><tr><td style="width:168px;">0x8028</td><td style="width:330px;">FINGERPRINT</td></tr><tr><td style="width:168px;">0x802F</td><td style="width:330px;">ORIGIN</td></tr><tr><td style="width:168px;">0xFF00</td><td style="width:330px;">RETRANSMIT-COUNT</td></tr></tbody></table> 
<p></p> 
<h2 id="%E5%9B%9B.%20STUN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">四. STUN工作流程</h2> 
<h3 id="1.%20%E4%BD%BF%E7%94%A8STUN%E8%8E%B7%E5%8F%96NAT%E6%98%A0%E5%B0%84%E5%90%8E%E7%9A%84%E5%9C%B0%E5%9D%80">1. 使用STUN获取NAT映射后的地址</h3> 
<p>        现实网络环境中大部分主机是处于 NAT 之后，即通过 ifconfig/ipconfig 查看到的是内网地址，主机访问外网时 NAT 设备会将其内网地址映射成公网地址，主机本身是无法查看某次访问外网地址 NAT 映射后的地址是多少的，但是通过 STUN 协议，主机发送 STUN binding request， 再由 STUN 服务器回复 STUN binding reponse 即可从属性拿到映射后的地址。</p> 
<p>        webrtc.github.io 提供了一个获取服务器反射地址的<a class="link-info" href="https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/" rel="nofollow" title="页面工具">页面工具</a>，如下所示，输入 STUN 服务地址后，点击 Gather candidates 开始收集地址，type srflx 表示该地址候选项是服务器反射地址类型，即 NAT 映射后公网地址。type host 表示主机地址候选项，跟 ifconfig/ipconfig 查看到的内网地址是一样的。</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/2d/88/Jkm3fNtR_o.png" width="1200"></p> 
<p><br><br>         我们通过 Wireshark 抓包分析上述流程，可以看到我主机发送的是一个 RFC5389 的 STUN binding request 消息，没有携带任何属性，而 stun1.l.google.com STUN 服务器回复的是一个 RFC5389 标准的 STUN binding success reponse 消息，消息携带了一个 XOR-MAPPED-ADDRESS 属性值，属性值中包含了映射后的地址信息。</p> 
<p><img alt="" height="892" src="https://images2.imgbox.com/e6/f4/M4LF3yxa_o.png" width="1200"><img alt="" height="1200" src="https://images2.imgbox.com/b9/02/kSQowxzP_o.png" width="1200"></p> 
<p></p> 
<h2 id="%E4%BA%94.%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">五. 参考资料</h2> 
<p><a href="https://datatracker.ietf.org/doc/html/rfc3489" rel="nofollow" title="RFC 3489 - STUN - Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs)">RFC 3489 - STUN - Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs)</a></p> 
<p><a href="https://datatracker.ietf.org/doc/html/rfc5389" rel="nofollow" title="RFC 5389 - Session Traversal Utilities for NAT (STUN)">RFC 5389 - Session Traversal Utilities for NAT (STUN)</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/15f595d7b9bfbaf159b80a39502d84e2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">设备取电芯片LDR6328Q</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f5426776fdc45ec3005f6f1ebed42722/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VSCode C&#43;&#43; 调试方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>