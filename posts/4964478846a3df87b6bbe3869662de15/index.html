<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>三星研究院上机题（Order of task） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="三星研究院上机题（Order of task）" />
<meta property="og:description" content="Thereare V tasks to do. Some task(s) can begin only after a particular task ends,which we will call precedence relation. A graph indicating precedence relationof tasks is given. In this graph, each task is denoted as vertex, and the precedencerelation as directed edge. Note there is no cycle with this graph (cycle refers to a path that starts from one vertex and returns to the same vertex). The graph below is one example of such graph" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4964478846a3df87b6bbe3869662de15/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-04T16:06:10+08:00" />
<meta property="article:modified_time" content="2019-03-04T16:06:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">三星研究院上机题（Order of task）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0cm;"><span style="color:#000000;">Thereare V tasks to do. Some task(s) can begin only after a particular task ends,which we will call precedence relation. A graph indicating precedence relationof tasks is given. In this graph, each task is denoted as vertex, and the precedencerelation as directed edge. Note there is no cycle with this graph (cycle refers to a path that starts from one vertex and returns to the same vertex). The graph below is one example of such graph</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="238" src="https://images2.imgbox.com/45/cc/rk3DhDza_o.png" width="326">﻿</p> 
<p style="margin-left:0cm;"><span style="color:#000000;">In this graph, task 1 can start after task 4 ends and task 6can when task 5 and task 7 end; there is no cycle with this graph. </span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Manager Kim is going to finish a set of tasks having precedencerelation by taking care of one task at a time. If he is going to do this withthe set of tasks illustrated above, the tasks can be handled with the followingorder.   </span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">8, 9, 4, 1, 5, 2, 3, 7, 6</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">And the order below is also possible. </span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">4, 1, 2, 3, 8, 5, 7, 6, 9</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">But, the order below is not possible. </span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">4, 1, 5, 2, 3, 7, 6, 8, 9</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">With this order, task 5 is handled earlier that task 8, but inthe precedence relation given in the graph above, task 5 can only begin whentask 8 ends so this order is not possible. </span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Given V tasks and their precedence relations, write a programthat finds the order by which one person can does one task at a time. Usuallythere are a number of possible orders so all you need to do is present just oneof them. Since a graph with a cycle is not given in input, you don</span><span style="color:#000000;">’t need toconsider error-handling in such case. In the graph with no cycle, possibleorder(s) always exist. </span></p> 
<p style="margin-left:0cm;"><span style="color:#666666;">输出任务序列</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">[Constraints]</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">The total number of vertices, V, in the graph is 5</span><span style="color:#000000;">≤</span><span style="color:#000000;">V</span><span style="color:#000000;">≤</span><span style="color:#000000;">1000.</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Time limit: 1 sec for 10 test cases combined</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">[Input]</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">10 test cases are given. Throughout 20 lines, one test case isgiven for every two lines. In the first line of each test case, the totalnumber of graph</span><span style="color:#000000;">’s vertices, V, and the total number of edges, E, are given. Inthe next line, E edges are arranged; edges are denoted as comprising twovertices. For example, the edge connecting from vertex 5 to vertex 28 is denotedas “5 28”. The vertex numbers are integers from 1 to V and two neighboringnumbers in the input are separated by a blank space. </span> </p> 
<p style="margin-left:0cm;"><span style="color:#000000;">[Output]</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Print answers for each of the 10 test cases line-by-linethroughout 10 lines. Start each line with </span><span style="color:#000000;">‘#x’, leave a blank space, and recordthe order of tasks. For the order of tasks, arrange V integers with a blankspace in-between. </span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">[Input/output example]</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Input</span></p> 
<table border="1" cellspacing="0" style="width:699px;"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:419.55pt;"> <p style="margin-left:0cm;">﻿</p> <p style="margin-left:0cm;"><span style="color:#000000;">9 9                             </span><span style="color:#000000;">←</span><span style="color:#000000;"> Test case 1 starts</span> </p> <p style="margin-left:0cm;"><span style="color:#000000;">4 1 1 2 2 3 2 7 5 6 7 6 1 5 8 5 8 9</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">5 4                             </span><span style="color:#000000;">←</span><span style="color:#000000;"> Test case 2 starts</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">1 2 2 3 4 1 1 5</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">...</span></p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"><span style="color:#000000;">Output(consisting of 10 lines in total)</span></p> 
<table border="1" cellspacing="0" style="width:699px;"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:419.55pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">#1 8 9 4 1 5 2 3 7 6</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">#2 4 1 2 3 5</span></p> <p style="margin-left:0cm;"><strong><span style="color:#000000;">...</span></strong></p> </td></tr></tbody></table> 
<p style="margin-left:0cm;">思路：拓扑排序，这题很没意思，没有做过多的限制，有很多种输出的结果，无法判断程序结果是否正确。</p> 
<p style="margin-left:0cm;">①给出n个点，m条边（n个点分别是1~n发布的，可以充分利用数组下标）</p> 
<p style="margin-left:0cm;">②记录入度和父亲即可，去除父亲节点时，要把孩子的入度减一。（<strong><a href="https://download.csdn.net/download/hqh131360239/10992954">源码及数据下载</a></strong>）</p> 
<p style="margin-left:0cm;"><span style="color:#f33b45;">错误代码：没有考虑多父亲节点会覆盖的问题</span></p> 
<pre class="has"><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
    freopen("1.txt","r",stdin);
    freopen("2.txt","w",stdout);
    int n,m,x,y;
    while(~scanf("%d%d",&amp;n,&amp;m)){
        //充分利用下标
        int a[10005][2]={0};
        for(int i=0;i&lt;m;i++){
            scanf("%d%d",&amp;x,&amp;y);
            a[y][0]++;   //记录入度
            a[y][1]=x;   //记录父亲
        }
        int visit[10005]={0};
        for(int j=0;j&lt;n;j++){       //依次找到j个点
            int index=0;
            for(int i=1;i&lt;=n;i++){   //找到一个入度为0的点，break
                if(a[i][0]==0&amp;&amp;visit[i]==0){
                    visit[i]=1;
                    index=i;
                    printf("%d ",index);
                    break;
                }
            }
            //遍历哪些点的父亲为index
            for(int i=1;i&lt;=n;i++){
                if(visit[i]==0&amp;&amp;a[i][1]==index) a[i][0]--;
            }
        }
        printf("\n");
    }
    return 0;
}</code></pre> 
<p style="margin-left:0cm;">①用一个二维数组标记，Map[][]表示两者之间存在边的情况，这样空间复杂度和时间复杂度都会高一些。</p> 
<pre class="has"><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int Map[1005][1005];
int main(){
    freopen("1.txt","r",stdin);
    freopen("2.txt","w",stdout);
    int n,m,x,y;
    while(~scanf("%d%d",&amp;n,&amp;m)){
        //充分利用下标
        int a[1005]={0};
        for(int i=0;i&lt;n;i++)
        for(int j=0;j&lt;n;j++)
            Map[i][j]=0;
        for(int i=0;i&lt;m;i++){
            scanf("%d%d",&amp;x,&amp;y);
            a[y]++;   //记录入度
            Map[x][y]=1;
        }
        int visit[1005]={0};
        for(int j=0;j&lt;n;j++){       //依次找到j个点
            int index=0;
            for(int i=1;i&lt;=n;i++){   //找到一个入度为0的点，break
                if(a[i]==0&amp;&amp;visit[i]==0){
                    visit[i]=1;
                    index=i;
                    printf("%d ",index);
                    break;
                }
            }
            //遍历哪些点的父亲为index
            for(int i=1;i&lt;=n;i++){
                if(visit[i]==0&amp;&amp;Map[index][i]==1) a[i]--;
            }
        }
        printf("\n");
    }
    return 0;
}</code></pre> 
<p style="margin-left:0cm;">②在原基础上，用一个vector存储所用的孩子节点，然后删除当前父节点的所有孩子节点。</p> 
<pre class="has"><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
vector&lt;int&gt; V[1005];
int main(){
    freopen("1.txt","r",stdin);
    freopen("2.txt","w",stdout);
    int n,m,x,y;
    while(~scanf("%d%d",&amp;n,&amp;m)){
        //充分利用下标
        int a[1005]={0};
        for(int i=0;i&lt;m;i++){
            scanf("%d%d",&amp;x,&amp;y);
            a[y]++;   //记录入度
            V[x].push_back(y);
        }
        int visit[1005]={0};
        for(int j=0;j&lt;n;j++){       //依次找到j个点
            int index=0;
            for(int i=1;i&lt;=n;i++){   //找到一个入度为0的点，break
                if(a[i]==0&amp;&amp;visit[i]==0){
                    visit[i]=1;
                    index=i;
                    printf("%d ",index);
                    break;
                }
            }
            //遍历哪些点的父亲为index
            for(int i=0;i&lt;V[index].size();i++){
                a[V[index][i]]--;
            }
            V[index].clear();
        }
        printf("\n");
    }
    return 0;
}</code></pre> 
<p style="margin-left:0cm;">③队列，第一步存储所有入度为0的结点，第二步依次把相连的结点入度减1，且满足条件入队。</p> 
<p style="margin-left:0cm;"><a href="https://blog.csdn.net/qq_41713256/article/details/80805338">参考代码</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/109361d0471ec00332eb190c403f841a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">node.js学习第一天</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b9aa73225bce1124d5942e8a2bf42dd4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">TCP/IP详解--基本概念</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>