<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【TCP/IP协议详解】 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【TCP/IP协议详解】" />
<meta property="og:description" content="一、TCP/IP协议简介 TCP/IP传输协议，即传输控制/网络协议，也叫作网络通讯协议。它是在网络的使用中的最基本的通信协议。TCP/IP传输协议对互联网中各部分进行通信的标准和方法进行了规定。并且，TCP/IP传输协议是保证网络数据信息及时、完整传输的两个重要的协议。
TCP/IP协议是Internet最基本的协议，其中应用层的主要协议有Telnet、FTP、SMTP等，是用来接收来自传输层的数据或者按不同应用要求与方式将数据传输至传输层；传输层的主要协议有TCP、UDP，是使用者使用平台和计算机信息网内部数据结合的通道，可以实现数据传输与数据共享；网络层的主要协议有ICMP、IP、IGMP，主要负责网络中数据包的传送等；而网络访问层，也叫网络接口层或数据链路层，主要协议有ARP、RARP，主要功能是提供链路管理错误检测、对不同通信媒介有关信息细节问题进行有效处理等。
二、OSI七层参考模型 OSI的参考模型共有7层，是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系。由低层至高层分别为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
2.1 OSI七层参考模型与TCP/IP协议模型各层对应关系 三、TCP报文结构 下图为TCP首部结构定义，定义了TCP协议如何读取和解析数据。
3.1 TCP端口 TCP的连接需要四个要素来确定唯一的连接：源IP &#43; 源端口、目的IP &#43; 目的端口， 因此TCP首部预留了两个16位作为端口号的存储，IP地址由上一层IP协议负责传递。源端口和目的端口各占16位，即两个字节，因此端口号的范围为216=65536（0 ~ 65535）。此外0 ~ 1023端口是系统保留的，1023 ~ 65535是用户使用的端口范围。
3.2 TCP的序号和确认号 ① 序号（Sequence number，缩写seq，32位）：用于标识数据包在数据流中的位置。发送数据包时数据比较大时则需要分片，序号则用来区分不同的分片并排序，确保了数据的顺序性。
② 确认号（Acknowledge number，缩写ack，32位）：确认数据是否被收到，一般为收到的序号值 &#43; 1。只有 ACK 标志为 1 时确认序号字段才有效。
3.3 数据偏移 表示TCP报文首部长度， 即TCP报文段的数据起始处距离TCP报文段的起始处的长度。以4字节为单位，占4位，取值范围为0~15。由此可计算出TCP首部的最大字节数为 4 * 15 = 60。TCP首部长度 - 20(固定首部长度) = 选项长度。
如果数据偏移值为5，则整个TCP报文头的长度是4 * 5 = 20字节，相当于TCP首部不包含选项。
如果数据偏移值为15，则整个TCP报文头的长度是4 * 5 = 60字节，相当于TCP首部中选项占40字节。
3.4 保留位 占6位，默认为0。
3.5 TCP控制位 URG：紧急标志位，表示数据包的紧急指针生效，数据具有高优先级，优先传送，而不按照原先的队列顺序传送，督促中间设备尽快处理；
ACK：确认标志位，对已接收的数据包进行确认；
PSH：推送标志位，表示该数据包被对方接收后应立即交给上层应用，而不在缓冲区排队；
RST：重置标志位，用于连接复位、拒绝错误和非法的数据包；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/9196fbe3533bc8477ab5dc0eae0c9ba1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-29T18:02:42+08:00" />
<meta property="article:modified_time" content="2023-10-29T18:02:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【TCP/IP协议详解】</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="TCPIP_0"></a>一、TCP/IP协议简介</h2> 
<p>  <code>TCP/IP</code>传输协议，即<code>传输控制/网络协议</code>，也叫作<code>网络通讯协议</code>。它是在网络的使用中的最基本的通信协议。<code>TCP/IP</code>传输协议对互联网中各部分进行通信的标准和方法进行了规定。并且，<code>TCP/IP</code>传输协议是保证网络数据信息及时、完整传输的两个重要的协议。<br>   <code>TCP/IP</code>协议是Internet最基本的协议，其中<code>应用层</code>的主要协议有<code>Telnet</code>、<code>FTP</code>、<code>SMTP</code>等，是用来接收来自传输层的数据或者按不同应用要求与方式将数据传输至传输层；<code>传输层</code>的主要协议有<code>TCP</code>、<code>UDP</code>，是使用者使用平台和计算机信息网内部数据结合的通道，可以实现数据传输与数据共享；<code>网络层</code>的主要协议有<code>ICMP</code>、<code>IP</code>、<code>IGMP</code>，主要负责网络中数据包的传送等；而<code>网络访问层</code>，也叫<code>网络接口层或数据链路层</code>，主要协议有<code>ARP</code>、<code>RARP</code>，主要功能是提供链路管理错误检测、对不同通信媒介有关信息细节问题进行有效处理等。</p> 
<h2><a id="OSI_3"></a>二、OSI七层参考模型</h2> 
<p>  <code>OSI</code>的参考模型共有7层，是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系。由低层至高层分别为：<code>物理层</code>、<code>数据链路层</code>、<code>网络层</code>、<code>传输层</code>、<code>会话层</code>、<code>表示层</code>、<code>应用层</code>。<br> <img src="https://images2.imgbox.com/d9/03/pIp1HrU1_o.png" alt="OSI七层参考模型"></p> 
<h3><a id="21_OSITCPIP_6"></a>2.1 OSI七层参考模型与TCP/IP协议模型各层对应关系</h3> 
<p><img src="https://images2.imgbox.com/b9/d6/1w0MK6QC_o.png" alt="OSI七层参考模型与TCP/IP协议模型各层对应关系"></p> 
<h2><a id="TCP_8"></a>三、TCP报文结构</h2> 
<p>  下图为TCP首部结构定义，定义了TCP协议如何读取和解析数据。<br> <img src="https://images2.imgbox.com/8d/5b/G4tChpDQ_o.png" alt="TCP报文结构"></p> 
<h3><a id="31_TCP_11"></a>3.1 TCP端口</h3> 
<p>  TCP的连接需要四个要素来确定唯一的连接：<strong>源IP + 源端口、目的IP + 目的端口，</strong> 因此TCP首部预留了两个16位作为端口号的存储，IP地址由上一层IP协议负责传递。源端口和目的端口各占16位，即两个字节，因此端口号的范围为2<sup>16</sup>=65536（0 ~ 65535）。此外0 ~ 1023端口是系统保留的，1023 ~ 65535是用户使用的端口范围。</p> 
<h3><a id="32_TCP_13"></a>3.2 TCP的序号和确认号</h3> 
<p>  ① <strong>序号</strong>（Sequence number，缩写<code>seq</code>，32位）：用于标识数据包在数据流中的位置。发送数据包时数据比较大时则需要分片，序号则用来区分不同的分片并排序，确保了数据的顺序性。<br>   ② <strong>确认号</strong>（Acknowledge number，缩写<code>ack</code>，32位）：确认数据是否被收到，一般为收到的序号值 + 1。只有 ACK 标志为 1 时确认序号字段才有效。</p> 
<h3><a id="33__16"></a>3.3 数据偏移</h3> 
<p>  <strong>表示TCP报文首部长度，</strong> 即TCP报文段的数据起始处距离TCP报文段的起始处的长度。以4字节为单位，占4位，取值范围为0~15。由此可计算出TCP首部的最大字节数为 <code>4 * 15 = 60</code>。<code>TCP首部长度 - 20(固定首部长度) = 选项长度</code>。</p> 
<blockquote> 
 <p>如果数据偏移值为5，则整个TCP报文头的长度是<code>4 * 5 = 20</code>字节，相当于TCP首部不包含选项。<br> 如果数据偏移值为15，则整个TCP报文头的长度是<code>4 * 5 = 60</code>字节，相当于TCP首部中选项占40字节。</p> 
</blockquote> 
<h3><a id="34__20"></a>3.4 保留位</h3> 
<p>  占6位，默认为0。</p> 
<h3><a id="35_TCP_22"></a>3.5 TCP控制位</h3> 
<p>  <code>URG</code>：紧急标志位，表示数据包的紧急指针生效，数据具有高优先级，优先传送，而不按照原先的队列顺序传送，督促中间设备尽快处理；<br>   <code>ACK</code>：确认标志位，对已接收的数据包进行确认；<br>   <code>PSH</code>：推送标志位，表示该数据包被对方接收后应立即交给上层应用，而不在缓冲区排队；<br>   <code>RST</code>：重置标志位，用于连接复位、拒绝错误和非法的数据包；<br>   <code>SYN</code>：同步标志位，用于建立会话连接，同步序列号；<br>   <code>FIN</code>：完成标志位，表示数据传输已经完成，即将关闭连接；</p> 
<h3><a id="36__29"></a>3.6 窗口</h3> 
<p>  表示该报文的发送方能接受的字节数，即窗口大小，传输过程中双方可以动态调整窗口大小，即用来控制数据传输速率。一个TCP数据包大小，最大则为65535（2<sup>16</sup> - 1）字节，除去头部20字节，理论上可携带的最大数据量为65515字节。</p> 
<h3><a id="37__31"></a>3.7 检验和</h3> 
<p>  用于验证数据完整性，确保数据未被修改。检验和覆盖了整个 TCP 报文段，包括 TCP 首部和 TCP 数据，发送端根据特定算法对整个报文段计算出一个检验和，接收端会进行计算并验证。</p> 
<h3><a id="38__33"></a>3.8 紧急指针</h3> 
<p>  只在<code>URG</code>标志位置<code>1</code>的时候有效。表示紧急数据在TCP数据中的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。</p> 
<h3><a id="39__35"></a>3.9 选项</h3> 
<p>  <code>非必须</code>，长度可变，最大长度为40字节。用于在TCP头部中传输一些额外的控制信息。</p> 
<h3><a id="310__37"></a>3.10 填充</h3> 
<p>  <code>非必须</code>，填充字段，用来补位，使整个首部长度是4字节的整数倍。</p> 
<h2><a id="TCPIP_40"></a>四、TCP/IP协议的三次握手与四次挥手</h2> 
<h3><a id="41_TCPIP_41"></a>4.1 TCP/IP协议的三次握手</h3> 
<p><img src="https://images2.imgbox.com/eb/4c/0yoh1vAy_o.png" alt="TCP/IP协议的三次握手"></p> 
<table><thead><tr><th align="center">名称</th><th align="center">数据发送方向</th><th align="center">SYN（建立连接）</th><th align="center">seq（自己的数据）</th><th align="center">ACK（收到的请求）</th><th align="center">ack（接收到的对方的数据）</th></tr></thead><tbody><tr><td align="center">第一次握手</td><td align="center">客户端 --&gt; 服务端</td><td align="center">1</td><td align="center">x</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">第二次握手</td><td align="center">服务端 --&gt; 客户端</td><td align="center">1</td><td align="center">y</td><td align="center">1</td><td align="center">x + 1</td></tr><tr><td align="center">第三次握手</td><td align="center">客户端 --&gt; 服务端</td><td align="center">-</td><td align="center">x + 1</td><td align="center">1</td><td align="center">y + 1</td></tr></tbody></table> 
<h3><a id="42_TCPIP_48"></a>4.2 TCP/IP协议的四次挥手</h3> 
<p><img src="https://images2.imgbox.com/c6/c3/zkwm1p2b_o.png" alt="TCP/IP协议的四次挥手"></p> 
<table><thead><tr><th align="center">名称</th><th align="center">数据发送方向</th><th align="center">FIN（断开连接）</th><th align="center">seq（自己的数据）</th><th align="center">ACK（收到的请求）</th><th align="center">ack（接收到的对方的数据）<br>ack = seq + 1</th></tr></thead><tbody><tr><td align="center">第一次挥手</td><td align="center">客户端 --&gt; 服务端</td><td align="center">1</td><td align="center">u</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">第二次挥手<br><code>（期间仍存在数据传输）</code></td><td align="center">服务端 --&gt; 客户端</td><td align="center">-</td><td align="center">v</td><td align="center">1</td><td align="center">u + 1</td></tr><tr><td align="center">第三次挥手</td><td align="center">服务端 --&gt; 客户端</td><td align="center">1</td><td align="center">w</td><td align="center">1</td><td align="center">u + 1</td></tr><tr><td align="center">第四次挥手</td><td align="center">客户端 --&gt; 服务端</td><td align="center">-</td><td align="center">u + 1</td><td align="center">1</td><td align="center">w + 1</td></tr></tbody></table> 
<h3><a id="43__56"></a>4.3 常见问题</h3> 
<p>  <strong>1. 为什么需要三次握手？</strong></p> 
<blockquote> 
 <p>  ① <strong>防止旧连接的混淆。</strong> 由于网络延迟等原因，可能会出现旧连接的数据包在新连接中被误认为是有效数据包的情况。<br>   ② <strong>建立可靠连接。</strong> 三次握手才可以同步双方的初始序列号，序列号能够保证数据包不重复、不丢弃和按序传输。<strong>两次握手无法防止历史连接，也无法同步双方序列号。</strong><br>   ③ <strong>避免资源浪费。</strong> 三次握手可以防止未经授权的恶意连接，例如SYN洪泛攻击等。如果服务器收到的SYN包并没有相应的ACK包，那么服务器就不会认为这是一条有效的连接请求，从而防止恶意连接。</p> 
</blockquote> 
<p>  <strong>2. 为什么四次挥手的第二次和第三次挥手不能合并？</strong></p> 
<blockquote> 
 <p>  ① 第二次挥手的目的是<strong>服务端告诉客户端，我（服务端）已经收到你（客户端）发送的包了。</strong><br>   ② 第三次挥手的目的是<strong>服务端告诉客户端，我（服务端）的数据也已经发送完毕了，不会再发送数据了。</strong><br>   因此，第二次挥手主要是对第一次挥手的响应，第三次挥手主要是告知客户端，服务端已经不会再发送数据了。<strong>在第二次挥手和第三次挥手之间，服务端还是可以向客户端发送数据的，</strong> 因此第二次挥手和第三次挥手不能合并。</p> 
</blockquote> 
<p>  <strong>3. 三次握手和四次挥手的目的是什么？</strong></p> 
<blockquote> 
 <p>  ①三次握手的目的是<strong>保证双方都准备好了资源，双方的发送和接收能力都正常。</strong><br>   ②四次挥手的目的是<strong>保证双方的资源都能正常释放掉。</strong></p> 
</blockquote> 
<p>  <strong>4. 服务端收到第四次挥手的数据包之前，会释放掉资源么？</strong></p> 
<blockquote> 
 <p>  <strong>不会，</strong> 即使服务端调用了<code>close()</code>，仍然会保留资源，直到收到客户端的发来的第四次挥手的数据包为止。当然，如果服务端一直没有收到第四次挥手的数据包，服务端会认为是不是第三次挥手的数据包丢失了，不断重试第三次挥手，重试一定次数，仍然没有收到，服务端直接断开连接。</p> 
</blockquote> 
<p>  <strong>5. 第三次挥手什么时候发？</strong></p> 
<blockquote> 
 <p>  服务端调用<code>close()</code>之后才能发。</p> 
</blockquote> 
<p>  <strong>6. TCP/IP协议在第四次挥手时为什么要等待<code>2MSL</code>(最长报文段寿命，<code>Maximum Segment Lifetime</code>)？</strong></p> 
<blockquote> 
 <p>  ① <strong>保证客户端发送的最后一个ACK报文段能够到达服务端。</strong> 因为该ACK有可能丢失，从而导致处在LAST-ACK状态的服务端收不到对FIN-ACK的确认报文。<br>   ② <strong>防止"已失效的连接请求报文段"出现在本连接中。</strong> 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现滞留在网络中的报文段。</p> 
</blockquote> 
<p>  <strong>7. 为什么客户端先调close()，而服务器不能先调？</strong></p> 
<blockquote> 
 <p>  ① 先调用<code>close()</code>的一方需要等待2MSL之后才能释放资源，在这段时间期间时不允许用<code>bind</code>的方式去重新绑定端口的，这时就会出现端口被占用的情况。<br>   ② 客户端的端口是由操作系统随机分配的，被占用之后会再重新分配一个，而服务端先调<code>close()</code>，则需设定套接字选项，配置重复利用端口资源才可以。</p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5cb2016ad95913a27cba08a40774eb2c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">将输入流（InputStream）转换为字节数组（byte[]）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c51368cc58d9a8c4f8e09207345b0a43/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">git建仓库小记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>