<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker容器技术之存储卷（7） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker容器技术之存储卷（7）" />
<meta property="og:description" content="文章目录 1. COW机制2. 存储卷3. 存储卷的作用4. 存储卷的优缺点5. 存储卷管理方式6. 存储卷的分类7. 容器数据管理7.1 在容器中使用数据卷7.2 数据卷容器7.3 利用数据卷容器迁移数据 1. COW机制 Docker镜像由多个只读层叠加而成，启动容器时，Docker会加载只读镜像层并在镜像栈顶部添加一个读写层。
如果运行中的容器修改了现有的一个已经存在的文件，那么该文件将会从读写层下面的只读层复制到读写层，该文件的只读版本依然存在，只是已经被读写层中该文件的副本所隐藏，这就是“写时复制(COW)”机制。
对于这种方式来说，我们去访问一个文件，修改和删除等一类的操作，其效率会非常的低，因为隔着很多层镜像。
而要想绕过这种限制，我们可以通过使用存储卷的机制来实现。
2. 存储卷 存储卷就是将宿主机的本地文件系统中存在的某个目录直接与容器内部的文件系统上的某一目录建立绑定关系。这就意味着，当我们在容器中的这个目录下写入数据时，容器会将其内容直接写入到宿主机上与此容器建立了绑定关系的目录。
在宿主机上的这个与容器形成绑定关系的目录被称作存储卷。
3. 存储卷的作用 如果容器中跑的进程的所有有效数据都保存在存储卷中，从而脱离容器自身文件系统之后，带来的好处是当容器关闭甚至被删除时，只要不删除与此容器绑定的在宿主机上的这个存储目录，我们就不用担心数据丢失了。因此就可以实现数据持久，脱离容器的生命周期而持久。
我们通过这种方式管理容器，容器就可以脱离主机的限制，可以在任意一台部署了docker的主机上跑容器，而其数据则可以置于一个共享存储文件系统上，比如nfs。
Docker的存储卷默认情况下是使用其所在的宿主机上的本地文件系统目录的，也就是说宿主机上有一块属于自己的硬盘，这个硬盘并没有共享给其他的Docker主机，而在这台主机上启动的容器所使用的存储卷是关联到此宿主机硬盘上的某个目录之上。
这就意味着容器在这台主机上停止运行或者被删除了再重建，只要关联到硬盘上的这个目录下，那么其数据还存在。但如果在另一台主机上启动一个新容器，那么数据就没了。而如果在创建容器的时候我们手动的将容器的数据挂载到一台nfs服务器上，那么这个问题就不再是问题了。
4. 存储卷的优缺点 关闭并重启容器，其数据不受影响，但删除Docker容器，则其更改将会全部丢失。
因此Docker存在的问题有：
存储于联合挂载文件系统中，不易于宿主机访问
容器间数据共享不便
删除容器其数据会丢失
而要解决这些问题，解决方案就是使用存储卷。
5. 存储卷管理方式 存储卷（Data Volume）于容器初始化时被自动创建，由base image提供的卷中的数据会于此期间完成复制。
Volume的初衷是独立于容器的生命周期实现数据持久化，因此删除容器之时既不会删除卷，也不会对未被引用的卷做垃圾回收操作。
存储卷为Docker提供了独立于容器的数据管理机制，我们可以把镜像想象成静态文件，例如“程序”，把卷类比为动态内容，例如“数据”。所以镜像可以重用，而卷则可以共享。
卷实现了“程序(镜像)”和“数据(卷)”的分离，以及“程序(镜像)”和“制作镜像的主机”的分离，用户制作镜像时无须再考虑镜像运行的容器所在的主机的环境。
6. 存储卷的分类 Docker有两种类型的卷，每种类型都在容器中存在一个挂载点，但其在宿主机上的位置有所不同：
Bind mount volume a volume that points to a user-specified location on the host file system Docker-managed volume the Docker daemon creates managed volumes in a portion of the host’s file system that’s owned bye Docker 7." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/180f8f100e13672e6cb9f34784197fda/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-30T13:16:38+08:00" />
<meta property="article:modified_time" content="2020-08-30T13:16:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker容器技术之存储卷（7）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1_COW_1" rel="nofollow">1. COW机制</a></li><li><a href="#2__11" rel="nofollow">2. 存储卷</a></li><li><a href="#3__17" rel="nofollow">3. 存储卷的作用</a></li><li><a href="#4__26" rel="nofollow">4. 存储卷的优缺点</a></li><li><a href="#5__35" rel="nofollow">5. 存储卷管理方式</a></li><li><a href="#6__45" rel="nofollow">6. 存储卷的分类</a></li><li><a href="#7__55" rel="nofollow">7. 容器数据管理</a></li><li><ul><li><a href="#71__64" rel="nofollow">7.1 在容器中使用数据卷</a></li><li><a href="#72__113" rel="nofollow">7.2 数据卷容器</a></li><li><a href="#73__153" rel="nofollow">7.3 利用数据卷容器迁移数据</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1_COW_1"></a>1. COW机制</h2> 
<hr> 
<p>Docker镜像由多个只读层叠加而成，启动容器时，Docker会加载只读镜像层并在镜像栈顶部添加一个读写层。</p> 
<p>如果运行中的容器修改了现有的一个已经存在的文件，那么该文件将会从读写层下面的只读层复制到读写层，该文件的只读版本依然存在，只是已经被读写层中该文件的副本所隐藏，这就是“写时复制(COW)”机制。<br> <img src="https://images2.imgbox.com/81/c3/Djm1gKje_o.png" alt="在这里插入图片描述"><br> 对于这种方式来说，我们去访问一个文件，修改和删除等一类的操作，其效率会非常的低，因为隔着很多层镜像。</p> 
<p>而要想绕过这种限制，我们可以通过使用存储卷的机制来实现。</p> 
<h2><a id="2__11"></a>2. 存储卷</h2> 
<hr> 
<p>存储卷就是将宿主机的本地文件系统中存在的某个目录直接与容器内部的文件系统上的某一目录建立绑定关系。这就意味着，当我们在容器中的这个目录下写入数据时，容器会将其内容直接写入到宿主机上与此容器建立了绑定关系的目录。<br> <img src="https://images2.imgbox.com/59/a2/CALzuIEE_o.png" alt="在这里插入图片描述"><br> 在宿主机上的这个与容器形成绑定关系的目录被称作存储卷。</p> 
<h2><a id="3__17"></a>3. 存储卷的作用</h2> 
<hr> 
<p>如果容器中跑的进程的所有有效数据都保存在存储卷中，从而脱离容器自身文件系统之后，带来的好处是当容器关闭甚至被删除时，只要不删除与此容器绑定的在宿主机上的这个存储目录，我们就不用担心数据丢失了。因此就可以实现数据持久，脱离容器的生命周期而持久。</p> 
<p>我们通过这种方式管理容器，容器就可以脱离主机的限制，可以在任意一台部署了docker的主机上跑容器，而其数据则可以置于一个共享存储文件系统上，比如nfs。</p> 
<p>Docker的存储卷默认情况下是使用其所在的宿主机上的本地文件系统目录的，也就是说宿主机上有一块属于自己的硬盘，这个硬盘并没有共享给其他的Docker主机，而在这台主机上启动的容器所使用的存储卷是关联到此宿主机硬盘上的某个目录之上。</p> 
<p>这就意味着容器在这台主机上停止运行或者被删除了再重建，只要关联到硬盘上的这个目录下，那么其数据还存在。但如果在另一台主机上启动一个新容器，那么数据就没了。而如果在创建容器的时候我们手动的将容器的数据挂载到一台nfs服务器上，那么这个问题就不再是问题了。</p> 
<h2><a id="4__26"></a>4. 存储卷的优缺点</h2> 
<p>关闭并重启容器，其数据不受影响，但删除Docker容器，则其更改将会全部丢失。</p> 
<p>因此Docker存在的问题有：</p> 
<p>存储于联合挂载文件系统中，不易于宿主机访问<br> 容器间数据共享不便<br> 删除容器其数据会丢失<br> 而要解决这些问题，解决方案就是使用存储卷。</p> 
<h2><a id="5__35"></a>5. 存储卷管理方式</h2> 
<hr> 
<p>存储卷（Data Volume）于容器初始化时被自动创建，由base image提供的卷中的数据会于此期间完成复制。</p> 
<p>Volume的初衷是独立于容器的生命周期实现数据持久化，因此删除容器之时既不会删除卷，也不会对未被引用的卷做垃圾回收操作。</p> 
<p>存储卷为Docker提供了独立于容器的数据管理机制，我们可以把镜像想象成静态文件，例如“程序”，把卷类比为动态内容，例如“数据”。所以镜像可以重用，而卷则可以共享。</p> 
<p>卷实现了“程序(镜像)”和“数据(卷)”的分离，以及“程序(镜像)”和“制作镜像的主机”的分离，用户制作镜像时无须再考虑镜像运行的容器所在的主机的环境。<br> <img src="https://images2.imgbox.com/fc/de/U82eKoNH_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="6__45"></a>6. 存储卷的分类</h2> 
<hr> 
<p>Docker有两种类型的卷，每种类型都在容器中存在一个挂载点，但其在宿主机上的位置有所不同：</p> 
<ul><li>Bind mount volume 
  <ul><li>a volume that points to a user-specified location on the host file system</li></ul> </li><li>Docker-managed volume 
  <ul><li>the Docker daemon creates managed volumes in a portion of the host’s file system that’s owned bye Docker</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/f5/59/flZoFjps_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="7__55"></a>7. 容器数据管理</h2> 
<hr> 
<p>用户在使用Docker的过程中，往往需要能查看容器内应用产生的数据，或者需要把容器内的数据进行备份，甚至多个容器之间进行数据的共享，这必然涉及容器的数据管理操作。</p> 
<p>容器中管理数据主要有两种方式：</p> 
<ul><li>数据卷（Data Volumes）</li><li>数据卷容器（Data Volumes Containers）</li></ul> 
<h3><a id="71__64"></a>7.1 在容器中使用数据卷</h3> 
<p><strong>在容器内创建一个数据卷</strong></p> 
<p>下面使用nginx镜像创建一个web容器，并创建一个数据卷挂载到容器的/webapp目录下：</p> 
<pre><code>[root@node02 ~]# docker run -d -P --name web -v /webapp nginx
Unable to find image 'nginx:latest' locally
latest: Pulling from library/nginx
bf5952930446: Pull complete 
cb9a6de05e5a: Pull complete 
9513ea0afb93: Pull complete 
b49ea07d2e93: Pull complete 
a5e4a503d449: Pull complete 
Digest: sha256:b0ad43f7ee5edbc0effbc14645ae7055e21bc1973aee5150745632a24a752661
Status: Downloaded newer image for nginx:latest
119b21b2ec01704a4f1d970a4766d084912c335da0daf474e23808e03ff33b70
</code></pre> 
<p>这里的-P是允许外部访问容器需要暴露的端口。</p> 
<p><strong>挂载一个主机目录作为数据卷</strong></p> 
<pre><code>[root@node02 ~]# docker run -d -P --name web1 -v /var/www/html:/webapp nginx
ffdbbf623878b3409dfb01ac903fa4330acddc83e0c924e558b53cfeb303572c
</code></pre> 
<p>上面的命令加载主机的<code>/var/www/html</code>目录到容器的<code>/webapp</code>目录：<br> 这个功能在进行测试的时候非常方便，比如用户可以放置一些程序或数据到本地目录中，然后在容器内运行和使用。另外，本地目录的路径必须是绝对路径，如果目录不存在，Docker会自动创建。</p> 
<p>Docker挂载数据卷的默认权限是读写(rw)，用户也可以通过(ro)指定为只读：</p> 
<pre><code>[root@node02 ~]# docker run -d -P --name web2 -v /var/www/html:/webapp:ro nginx
83b9e473cf18bc9ddea84530517fa825ef8841a7bd70feb569ee95873178f745
</code></pre> 
<p>加了:ro以后，容器内挂载的数据卷的数据就无法修改了。</p> 
<p><strong>挂载一个本地主机文件作为数据卷</strong><br> -v选项也可以从主机挂载单个文件到容器中作为数据卷：</p> 
<pre><code>[root@node02 ~]# docker run -it --rm -v ~/.bash_history:/.bash_history centos /bin/bash
Unable to find image 'centos:latest' locally
latest: Pulling from library/centos
3c72a8ed6814: Pull complete 
Digest: sha256:76d24f3ba3317fa945743bb3746fbaf3a0b752f10b10376960de01da70685fbd
Status: Downloaded newer image for centos:latest
[root@b75cb678a139 /]# 
</code></pre> 
<p>这样就可以记录在容器输入过的命令历史了。</p> 
<p>如果直接挂载一个文件到容器，使用文件编辑工具，包括vi或者sed去修改文件内容的时候，可能会造成inode的改变，这样将会导致错误。所以推荐的方式是直接挂载文件所在的目录。</p> 
<h3><a id="72__113"></a>7.2 数据卷容器</h3> 
<p>如果用户需要在容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。数据卷容器其实就是一个普通的容器，专门用它提供数据卷供其他容器挂载使用，方法如下：</p> 
<p>首先，创建一个数据卷容器dbdata，并在其中创建一个数据卷挂载到/dbdata：</p> 
<pre><code>[root@node02 ~]# docker run -it -d --name dbdata -v /dbdata centos
adf565845b8a4887c4fb056fd792696bc0e4af8006714b734991b4fb4d044977
</code></pre> 
<p>然后可以在其他容器中使用–volumes-from来挂载dbdata容器中的数据卷，例如创建db1和db2两个容器，并从dbdata容器挂载数据卷：</p> 
<pre><code>[root@node02 ~]# docker run -d --name db1 --volumes-from dbdata centos
6c5aca1e96715c823db4d7628895af7625aa880d777ee0b55dc26e58c43268ac
[root@node02 ~]# docker run -d --name db2 --volumes-from dbdata centos
ac44b8b7e7df94f6e42d780258c2bd63acb020c48ee17fb8fe7ff5dfde141760
</code></pre> 
<p>此时，容器db1和db2都挂载同一个数据卷到相同的/dbdata目录。三个容器任何一方在该目录下的写入，其他容器都可以看到。<br> 例如，在db1容器中创建一个test文件：</p> 
<pre><code>[root@node02 ~]# docker exec -it db1 /bin/bash
[root@75b50c43ce20 /]# ls
bin  dbdata  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
[root@75b50c43ce20 /]# cd dbdata/
[root@75b50c43ce20 dbdata]# touch xixi
[root@75b50c43ce20 dbdata]# ls
xixi
</code></pre> 
<p>在db2容器中查看：</p> 
<pre><code>[root@node02 ~]# docker exec -it db2 /bin/bash
[root@c0b4bb5ff5b9 /]# ls dbdata/
xixi
</code></pre> 
<p>可以多次使用–volumes-from参数来从多个容器挂载多个数据卷。还可以从其他已挂载了容器卷的容器来挂载数据卷：</p> 
<pre><code>[root@node02 ~]# docker run -d --name db3 --volumes-from db1 centos
</code></pre> 
<p><strong>使用–volumes-from参数所挂载数据卷的容器自身并不需要保持在运行状态。</strong></p> 
<p>如果删除了挂载的容器（包括dbdata、db1和db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时显式使用docker rm -v命令来指定同时删除关联的容器。</p> 
<h3><a id="73__153"></a>7.3 利用数据卷容器迁移数据</h3> 
<p>可以利用数据卷容器对其中的数据卷进行备份、恢复，以实现数据的迁移。</p> 
<p><strong>备份</strong><br> 使用下面的命令来备份dbdata数据卷容器内的数据卷：</p> 
<pre><code>[root@node02 ~]# docker run --name worker --volumes-from dbdata -v $(pwd):/backup centos tar cvf /backup/backup.tar /dbdata
</code></pre> 
<p>这个命令稍微有点复杂，具体分析下。<br> 首先利用centos镜像创建了一个容器worker。使用–volumes-from dbdata参数来让worker容器挂载dbdata容器的数据卷（即dbdata数据卷）；使用-v $(pwd):/backup参数来挂载本地的当前目录到worker容器的/backup目录。<br> worker容器启动后，使用了tar cvf /backup/backup.tar /dbdata命令来将/dbdata下内容备份为容器内的/backup/backup.tar，即宿主主机当前目录下的backup.tar。</p> 
<p><strong>恢复</strong><br> 如果要恢复数据到一个容器，可以按照下面的操作。首先创建一个带有数据卷的容器dbdata2：</p> 
<pre><code>[root@node02 ~]# docker run -it --name dbdata2 -v /dbdata centos /bin/bash
[root@b75cb678a139 /]# ls
bin	 dev  home  lib64	media  opt   root  sbin  sys  usr
dbdata2  etc  lib   lost+found	mnt    proc  run   srv	 tmp  var
[root@b75cb678a139 /]# ls dbdata2/
[root@b75cb678a139 /]# 
</code></pre> 
<p>然后创建另一个新的容器，挂载dbdata2容器，并使用untar解压备份文件到所挂载的容器卷中即可：</p> 
<pre><code>[root@node02 ~]# docker run --volumes-from dbdata2 -v $(pwd):/backup busybox tar xvf /backup/backup.tar

[root@b75cb678a139 /]# ls dbdata2/
xixi
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/450473b289e0a8d7cb448996c7784489/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于《Java开发手册（嵩山版）》中：判断所有集合内部的元素是否为空，使用isEmpty()方法，而不是size()==0的方式的疑惑</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5b061ce9c02645201db235f48fe0759b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">cas5.x实现将ticket维护到redis集群（不使用官方提供的哨兵模式）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>