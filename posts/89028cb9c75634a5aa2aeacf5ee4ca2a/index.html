<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>不使用Jsoup读取xml(处理内存不足问题) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="不使用Jsoup读取xml(处理内存不足问题)" />
<meta property="og:description" content="读取xml时使用jsoup简单方便, 但是一旦xml过大, 使用jsoup就无法parse, 会出现java heap溢出
使用字符串的方式读取,可以按照标签选择读取范围
List&lt;String&gt; xxxList = new ArrayList&lt;String&gt;(); StringBuilder sb = new StringBuilder(); InputStreamReader reader = new InputStreamReader( new FileInputStream(xmlFile), &#34;utf-8&#34;); BufferedReader bufferedReader = new BufferedReader(reader); String line = &#34;&#34;; while ((line = bufferedReader.readLine()) != null) { sb.append(line &#43; &#34;\n&#34;); if(line.contains(&#34;&lt;/xxx&gt;&#34;)){ xxxList.add(sb.toString()); sb.setLength(0); } } reader.close(); bufferedReader.close(); for (String xxx : xxxList) {	String tag = StringHelper.GetInnerText(xxx, &#34;子标签名&#34;).trim(); } 每次内存只加载到&lt;xxx&gt;&lt;/xxx&gt;之间的内容, 解约内存
package CodingHelper; import java.net.URLDecoder; import java." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/89028cb9c75634a5aa2aeacf5ee4ca2a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-06T12:20:25+08:00" />
<meta property="article:modified_time" content="2018-07-06T12:20:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">不使用Jsoup读取xml(处理内存不足问题)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>读取xml时使用jsoup简单方便, 但是一旦xml过大, 使用jsoup就无法parse, 会出现java heap溢出</p> 
<p>使用字符串的方式读取,可以按照标签选择读取范围</p> 
<pre><code class="language-java">List&lt;String&gt; xxxList = new ArrayList&lt;String&gt;();
StringBuilder sb = new StringBuilder();
InputStreamReader reader = new InputStreamReader(
		new FileInputStream(xmlFile), "utf-8");
BufferedReader bufferedReader = new BufferedReader(reader);
String line = "";
while ((line = bufferedReader.readLine()) != null) {
        sb.append(line + "\n");
	if(line.contains("&lt;/xxx&gt;")){
		xxxList.add(sb.toString());
		sb.setLength(0);
	}
}
reader.close();
bufferedReader.close();

for (String xxx : xxxList) {	
	String tag = StringHelper.GetInnerText(xxx, "子标签名").trim();
}</code></pre> 
<br> 
<p>每次内存只加载到&lt;xxx&gt;&lt;/xxx&gt;之间的内容, 解约内存</p> 
<p><br></p> 
<pre><code class="language-java">package CodingHelper;

import java.net.URLDecoder;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Hashtable;
import java.util.List;
import java.util.regex.*;

public class StringHelper {

	public static String RegexDelimitter = "[。？！，、；：“＼”‘’（）─…—·《》〈〉﹄﹃﹂﹁〔〕【】～＠＃＄％＾＆＊＿＋｛｝｜＜＞｀＝［］\\[\\]．／￣￥－＂＇\\s~!@#$%^&amp;*()_+{}|:\"&lt;&gt;?`=;',./–-]";
	public static String RegexDelimitterNoSpace = "[。？！，、；：“＼”‘’（）─…—·《》〈〉﹄﹃﹂﹁〔〕【】～＠＃＄％＾＆＊＿＋｛｝｜＜＞｀＝［］\\[\\]．／￣￥－＂＇~!@#$%^&amp;*()_+{}|:\"&lt;&gt;?`=;',./–-]";

	public static Pattern RegSpace = Pattern.compile("\\s+");

	public static Pattern RegPrep = Pattern.compile(
			"\\s+(and|&amp;|of|for|at|in|on|the|to|al|de|et|und)\\s+",
			Pattern.CASE_INSENSITIVE);

	public static Pattern RegPrep2 = Pattern.compile("与|及|的",
			Pattern.CASE_INSENSITIVE);

	public static Pattern RegPrep3 = Pattern.compile(
			"\\s+(and|&amp;|of|for|at|in|on|the|to|al|de|et|und)[A-Z]",
			Pattern.CASE_INSENSITIVE);

	public static Pattern RegIsPrep = Pattern.compile(
			"^(and|&amp;|of|for|at|in|on|the|to|al|de|et|und)$",
			Pattern.CASE_INSENSITIVE);

	public static Pattern RegHtmlDecode = Pattern.compile("&amp;.{2,6}?;",
			Pattern.CASE_INSENSITIVE);

	public static Pattern RegCtrlChars = Pattern.compile("[\\u0001-\\u001f]");// 禁止转义

	public static Pattern RegComma = Pattern.compile("(,|;|-)");// 禁止转义

	public static Pattern RegDelimit = Pattern.compile(RegexDelimitter);

	public static Pattern RegDelimitNoSpace = Pattern
			.compile(RegexDelimitterNoSpace);

	public static byte[] Int32ToByteArray(int number) {
		byte[] buffer = new byte[4];
		buffer[0] = (byte) (number &gt;&gt; 24);
		buffer[1] = (byte) ((number &gt;&gt; 16) &amp; 0xff);
		buffer[2] = (byte) ((number &gt;&gt; 8) &amp; 0xff);
		buffer[3] = (byte) (number &amp; 0xff);
		return buffer;
	}

	public static int ByteArrayToInt32(byte[] buffer, int offset) {
		int number = buffer[offset] &lt;&lt; 24;
		number |= buffer[offset + 1] &lt;&lt; 16;
		number |= buffer[offset + 2] &lt;&lt; 8;
		number |= buffer[offset + 3];
		return number;
	}

	// / &lt;summary&gt;
	// / 将句子转化为字符串
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="bNoPrep"&gt;是否删除介词&lt;/param&gt;
	// / &lt;param name="bNoDelim"&gt;是否删除符号&lt;/param&gt;
	// / &lt;param name="sType"&gt;simple=去除空白字符,wsort=按单词排序,csort=按字母排序&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static String SentenceToString(String sText, boolean bNoPrep,
			boolean bNoDelim, String sType) {
		Matcher RegHtmlDecode1 = RegHtmlDecode.matcher(sText);
		if (RegHtmlDecode1.find()) {
			HtmlDecode(sText);
		}
		Matcher RegComma1 = RegComma.matcher(sText);
		if (RegComma1.find()) {
			sText = RegComma1.replaceAll(" ");
		}
		if (bNoPrep) {
			RemovePreposition(sText);
		}
		Matcher RegDelimitNoSpace1 = RegDelimitNoSpace.matcher(sText);
		if (bNoDelim &amp;&amp; RegDelimitNoSpace1.find()) {
			sText = RegDelimitNoSpace1.replaceAll("");
		}

		Matcher RegDelimit1 = RegDelimit.matcher(sText);
		if (sType == null || sType.equals("") || sType == "simple") {
			if (RegDelimit1.find()) {
				sText = RegDelimit1.replaceAll("");
			}
			return sText.toLowerCase();
		}

		StringBuilder sContent = new StringBuilder(8192);
		if (sType == "wsort") {
			String sepstr = " ";
			String[] sArray1 = sText.split(sepstr);
			String[] sArrsy = null;
			List&lt;String&gt; lstText = new ArrayList&lt;String&gt;();
			int m = 0;
			for (int i = 0; i &lt; sArray1.length; i++) {
				if (sArray1[i] != "") {
					sArrsy[m] = sArray1[i];
					lstText.add(sArray1[i]);
					m++;
				}
			}

			Collections.sort(lstText);

			for (int i = 0; i &lt; lstText.size(); i++) {
				sContent.append(lstText.get(i));
			}
			return sContent.toString().toLowerCase();
		}

		if (RegDelimit1.find()) {
			sText = RegDelimit1.replaceAll("");
		}

		char[] cArray = sText.toCharArray();
		List&lt;Character&gt; lstChars = new ArrayList&lt;Character&gt;();
		for (int i = 0; i &lt; cArray.length; i++) {
			lstChars.add(cArray[i]);
		}
		Collections.sort(lstChars);
		for (int i = 0; i &lt; lstChars.size(); i++) {
			sContent.append(lstChars.get(i));
		}
		return sContent.toString().toLowerCase();
	}

	// / &lt;summary&gt;
	// / 删除句子中的介词
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static boolean RemovePreposition(String sText) {
		Matcher RegPrep1 = RegPrep.matcher(sText);
		if (RegPrep1.find()) {
			sText = RegPrep1.replaceAll(" ");
			return true;
		}
		Matcher RegPrep21 = RegPrep2.matcher(sText);
		if (RegPrep21.find()) {
			sText = RegPrep21.replaceAll("");
			return true;
		}
		Matcher RegPrep31 = RegPrep3.matcher(sText);
		if (RegPrep31.find()) {
			String left = "", right = "";
			Matcher mth = RegPrep3.matcher(sText);
			while (mth.matches()) {
				left = "";
				if (mth.start() &gt; 0) {
					left = sText.substring(0, mth.start());
				}
				right = sText.substring(mth.start() + mth.groupCount() - 1);
				sText = left + " " + right;

				mth = RegPrep3.matcher(sText);
			}
			return true;
		}
		return false;
	}

	// / &lt;summary&gt;
	// / 删除控制字符
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static boolean RemoveControlChars(String sText) {
		Matcher RegCtrlChars1 = RegCtrlChars.matcher(sText);
		if (RegCtrlChars1.find()) {
			sText = RegCtrlChars1.replaceAll("");
			return true;
		}
		return false;
	}

	// / &lt;summary&gt;
	// / 替换HTML特殊字符
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	public static void HtmlDecode(String sText) {
		Matcher RegHtmlDecode1 = RegHtmlDecode.matcher(sText);
		if (RegHtmlDecode1.find()) {
			sText = URLDecoder.decode(sText);
		}
	}

	// / &lt;summary&gt;
	// / 解析数据值
	// / &lt;/summary&gt;
	// / &lt;param name="sType"&gt;&lt;/param&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static Object ParseValue(String sType, String sText) {
		Object objRet = null;
		int casechose = 0;
		if (sType.equals("int"))
			casechose = 1;
		if (sType.equals("long"))
			casechose = 2;
		if (sType.equals("float"))
			casechose = 3;
		if (sType.equals("double"))
			casechose = 4;
		if (sType.equals("char"))
			casechose = 5;
		if (sType.equals("String"))
			casechose = 6;
		switch (casechose) {
		case 1:
			objRet = Integer.parseInt(sText);
			break;
		case 2:
			objRet = Long.parseLong(sText);
			break;
		case 3:
			objRet = Float.parseFloat(sText);
			break;
		case 4:
			objRet = Double.parseDouble(sText);
			break;
		case 5:
			objRet = sText.toCharArray();// 返回char[]数组
			break;
		case 6:
			objRet = sText;
			break;
		}
		return objRet;
	}

	// / &lt;summary&gt;
	// / 判断是否为数字串
	// / &lt;/summary&gt;
	// / &lt;param name="line"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static boolean IsNumberString(String line) {
		Pattern rx = Pattern.compile("^\\d+$");
		Matcher rx1 = rx.matcher(line);
		return rx1.find();
	}

	static public int HexStr2Int(String line) {
		line = line.toUpperCase();
		if (line.startsWith("0X")) {
			line = line.substring(2);
		}

		int temp = 0, result = 0;
		char[] cArray = line.toCharArray();
		for (int i = 0; i &lt; cArray.length; i++) {
			if (cArray[i] &gt;= '0' &amp;&amp; cArray[i] &lt;= '9') {
				temp = (int) (cArray[i] - '0');
			} else {
				temp = (int) (cArray[i] - 'A') + 10;
			}
			result = (result &lt;&lt; 4) + temp;
		}
		return result;
	}

	// / &lt;summary&gt;
	// / 转换字节数组到16进制字符串
	// / &lt;/summary&gt;
	// / &lt;param name="array"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	static public String ToHexString(byte[] array) {
		StringBuilder str = new StringBuilder(1024);

		for (int i = 0; i &lt; array.length; i++) {
			int v = array[i] &amp; 0xFF;
			String hv = Integer.toHexString(v);
			String strr = MessageFormat.format("{0}", hv);
			str.append(strr);
		}
		return str.toString();
	}

	static public String ToHexString2(byte[] array) {
		StringBuilder str = new StringBuilder(1024);

		for (int i = 0; i &lt; array.length; i++) {
			int v = array[i] &amp; 0xFF;
			String hv = Integer.toHexString(v);
			if (hv.length() == 1) {
				hv = '0' + hv;
			}
			String strr = MessageFormat.format("{0}", hv);
			str.append(strr);
		}
		return str.toString();
	}

	public static byte[] FromHexString(String sText) {
		int len = sText.length() / 2;

		byte[] buffer = new byte[len];

		String line = "";
		for (int i = 0; i &lt; len; i++) {
			line = sText.substring(2 * i, 2);
			buffer[i] = (byte) Integer.parseInt(line);
		}
		return buffer;
	}

	// / &lt;summary&gt;
	// / 删除分隔符
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="sArray"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static String RemoveDelimiter(String sText, String[] sArray) {
		StringBuilder str = new StringBuilder(sText);
		String strr = null;
		for (int i = 0; i &lt; sArray.length; i++) {
			strr = str.toString().replace(sArray[i], "");
		}
		return strr;
	}

	// / &lt;summary&gt;
	// / 删除分隔符
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="sRepPunct"&gt;正则表达式,默认为RegexDelimitter&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static String RemoveDelimiter(String sText, String sRepPunct) {
		if (sRepPunct == null || sRepPunct.equals("")
				|| sRepPunct == RegexDelimitter) {
			return sText.replaceAll(RegDelimit.toString(), "");
		}
		// return Regex.Replace(sText, sRepPunct, "", RegexOptions.None);
		Pattern sRepPunctpatt = Pattern.compile(sRepPunct);
		Matcher sRepPunctpatt1 = sRepPunctpatt.matcher(sText);
		if (sRepPunctpatt1.find()) {
			sText = sRepPunctpatt1.replaceAll("");
			return sText;
		}
		return sText;
	}

	// / &lt;summary&gt;
	// / 用正则表达式替换字符串内容
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="sRepPunct"&gt;正则表达式&lt;/param&gt;
	// / &lt;param name="sReplace"&gt;替换字符串&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static String ReplaceContent(String sText, String sRegex,
			String sReplace) {
		// return Regex.Replace(sText, sRegex, sReplace, RegexOptions.None);
		Pattern sRegexpatt = Pattern.compile(sRegex);
		Matcher sRegexpatt1 = sRegexpatt.matcher(sText);
		if (sRegexpatt1.find()) {
			sText = sRegexpatt1.replaceAll(sReplace);
			return sText;
		}
		return sText;
	}

	// / &lt;summary&gt;
	// / 添加GET请求或POST请求的属性值
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="sAttr"&gt;&lt;/param&gt;
	// / &lt;param name="sValue"&gt;&lt;/param&gt;
	public static void AddValue(String sText, String sAttr, String sValue) {
		String line = MessageFormat.format("{0}={1}", sAttr, sValue);
		if (sText == null || sText.equals("")) {
			sText = line;
			return;
		}

		String str = "";
		int pos1 = 0, pos2 = 0;
		pos1 = sText.indexOf('?');
		if (pos1 &gt; 0) {
			str = sText.substring(pos1 + 1);
			if (str == null || str.equals("")) {
				sText += line;
			} else {
				sText += "&amp;" + line;
			}
			return;
		}
		sText += "&amp;" + line;
	}

	// / &lt;summary&gt;
	// / 设置GET请求或POST请求的属性值
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="sAttr"&gt;&lt;/param&gt;
	// / &lt;param name="sValue"&gt;&lt;/param&gt;
	public static boolean SetValue(String sText, String sAttr, String sValue) {
		boolean bFirst = true;
		int pos1 = 0, pos2 = 0;
		String str = MessageFormat.format("&amp;{0}=", sAttr);
		pos1 = sText.indexOf(str);
		if (pos1 &lt; 0) {
			str = MessageFormat.format("?{0}=", sAttr);
			pos1 = sText.indexOf(str);
			if (pos1 &lt; 0) {
				AddValue(sText, sAttr, sValue);
				return true;
			}
			bFirst = false;
		}

		pos2 = sText.indexOf("&amp;", pos1 + str.length());
		if (pos2 &lt; 0) {
			str = sText.substring(pos1);
		} else {
			str = sText.substring(pos1, pos2 - pos1);
		}

		String line = "";
		if (bFirst) {
			line = MessageFormat.format("&amp;{0}={1}", sAttr, sValue);
		} else {
			line = MessageFormat.format("?{0}={1}", sAttr, sValue);
		}
		sText = sText.replace(str, line);
		return true;
	}

	// / &lt;summary&gt;
	// / 获取GET请求或POST请求的属性值
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="sAttr"&gt;&lt;/param&gt;
	// / &lt;param name="sValue"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static boolean ParseValue(String sText, String sAttr, String sValue) {
		int pos1 = 0, pos2 = 0;
		String str = MessageFormat.format("&amp;{0}=", sAttr);
		pos1 = sText.indexOf(str);
		if (pos1 &lt; 0) {
			str = MessageFormat.format("{0}=", sAttr);
			pos1 = sText.indexOf(str);
			if (pos1 &lt; 0) {
				return false;
			}
		}
		pos1 += str.length();

		pos2 = sText.indexOf('&amp;', pos1);
		if (pos2 &lt; 0) {
			sValue = sText.substring(pos1);
		} else {
			sValue = sText.substring(pos1, pos2 - pos1);
		}
		return true;
	}

	// / &lt;summary&gt;
	// / 获取属性值
	// / &lt;/summary&gt;
	// / &lt;param name="line"&gt;&lt;/param&gt;
	// / &lt;param name="sAttr"&gt;&lt;/param&gt;
	// / &lt;param name="sLink"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static boolean ParseAttribute(String line, String sAttr,
			StringBuffer sLink) {
		if (sLink.length() != 0) {
			sLink.replace(0, sLink.length() - 1, "");
		}
		if (line.indexOf(" = ") &gt; 0) {
			line = line.replace(" = ", "=");

		}

		boolean bFirst = true;
		int pos1 = 0, pos2 = 0;
		String str = MessageFormat.format("{0}=\'", sAttr);
		pos1 = line.indexOf(str, pos2);
		if (pos1 &lt; 0) {
			bFirst = false;
			str = str = MessageFormat.format("{0}=\"", sAttr);
			pos1 = line.indexOf(str, pos2);
			if (pos1 &lt; 0) {
				str = MessageFormat.format("{0}=", sAttr);
				pos1 = line.indexOf(str, pos2);
				if (pos1 &lt; 0) {
					return false;
				}
			}
		}
		pos1 += str.length();

		if (bFirst) {
			pos2 = line.toString().indexOf('\'', pos1);
		} else {
			pos2 = line.toString().indexOf('\"', pos1);
		}
		if (pos2 &lt; 0) {
			pos2 = line.toString().indexOf(' ', pos1);
			if (pos2 &lt; 0) {
				pos2 = line.toString().indexOf('&gt;', pos1);
				if (pos2 &lt; 0) {
					return false;
				}
			} else {
				int pos3 = line.toString().indexOf('&gt;', pos1);
				if (pos3 &gt; 0 &amp;&amp; pos3 &lt; pos2) {
					pos2 = pos3;
				}
			}
		}
		sLink.replace(0, sLink.length() - 1, line.substring(pos1, pos2 - pos1));
		return true;
	}

	// / &lt;summary&gt;
	// / 截取字符串开始部分转换成数字,碰到非数字、逗号字符结束
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	static public int ToInteger(String sText) {
		int value = 0;
		// if (Int32.TryParse(sText, value))
		// {
		// return value;
		// }
		try {
			value = Integer.parseInt(sText);
			return value;
		} catch (Exception e) {
		}
		sText = sText.trim();

		int index = 0;
		char[] array = sText.toCharArray();
		for (index = 0; index &lt; array.length; index++) {
			if (!(array[index] == ',' || (array[index] &gt;= '0' &amp;&amp; array[index] &lt;= '9'))) {
				break;
			}
		}

		if (index &gt; 0) {
			sText = sText.substring(0, index);
			if (sText.indexOf(',') &gt; 0) {
				sText = sText.replace(",", "");
			}

			// Int32.TryParse(sText, value);
			try {
				value = Integer.parseInt(sText);
			} catch (Exception e) {
			}
			return value;
		}
		return -1;
	}

	// / &lt;summary&gt;
	// / 抽取格式化XML节点文本
	// / &lt;/summary&gt;
	// / &lt;param name="content"&gt;&lt;/param&gt;
	// / &lt;param name="tagname"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static String GetInnerText(String content, String tagname) {
		String end = MessageFormat.format("&lt;/{0}&gt;", tagname);
		String start = MessageFormat.format("&lt;{0}&gt;", tagname);

		String str = GetInnerText(content, 0, start, end);
		if (str != null &amp;&amp; str != "") {
			return str;
		}

		start = MessageFormat.format("&lt;{0} ", tagname);
		return GetInnerText(content, 0, start, end);
	}

	public static String GetInnerText(String sText, int start, String sTagName) {
		String sEnd = MessageFormat.format("&lt;/{0}&gt;", sTagName);
		String sBeg = MessageFormat.format("&lt;{0}&gt;", sTagName);

		String str = GetInnerText(sText, start, sBeg, sEnd);
		if (str != null &amp;&amp; str != "") {
			return str;
		}

		sBeg = MessageFormat.format("&lt;{0} ", sTagName);
		return GetInnerText(sText, start, sBeg, sEnd);
	}

	// / &lt;summary&gt;
	// / 获取 start 与 end 间文本
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="sBeg"&gt;开始前文本&lt;/param&gt;
	// / &lt;param name="sEnd"&gt;结束后文本&lt;/param&gt;
	// / &lt;returns&gt;结果文本&lt;/returns&gt;
	public static String GetInnerText(String sText, String sBeg, String sEnd) {
		return GetInnerText(sText, 0, sBeg, sEnd);
	}

	public static String GetInnerText(String sText, int start, String sBeg,
			String sEnd) {
		int pos1 = 0, pos2 = 0;
		pos1 = sText.indexOf(sBeg, start);
		if (pos1 &lt; 0) {
			return "";
		}
		pos1 += sBeg.length();

		pos2 = sText.indexOf(sEnd, pos1);
		if (pos2 &lt; 0) {
			return "";
		}

		String str = sText.substring(pos1, pos2);
		if (!sBeg.endsWith("&gt;")) {
			pos1 = str.indexOf('&gt;');
			if (pos1 &gt;= 0) {
				str = str.substring(pos1 + 1);
			}
		}
		str = str.trim();

		if (str.startsWith("&lt;![CDATA[") &amp;&amp; str.endsWith("]]&gt;")) {
			str = str.substring(9, str.length() - 12);
		}
		return str;
	}

	public static int GetInnerText(String sText, int start, String sBeg,
			String sEnd, StringBuffer sResult) {
		int pos1 = 0, pos2 = 0;
		pos1 = sText.indexOf(sBeg, start);
		if (pos1 &lt; 0) {
			return -1;
		}
		pos1 += sBeg.length();

		pos2 = sText.indexOf(sEnd, pos1);
		if (pos2 &lt; 0) {
			return -1;
		}

		String str = sText.substring(pos1, pos2 - pos1);
		if (!sBeg.endsWith("&gt;")) {
			pos1 = str.indexOf('&gt;');
			if (pos1 &gt;= 0) {
				str = str.substring(pos1 + 1);
			}
		}
		str = str.trim();

		if (str.endsWith("&lt;![CDATA[") &amp;&amp; str.endsWith("]]&gt;")) {
			str = str.substring(9, str.length() - 12);
		}
		if (sResult.length() == 0) {
			sResult.append(str);
		} else {
			sResult.replace(0, sResult.length() - 1, str);
		}

		return (pos2 + sEnd.length());
	}

	// / &lt;summary&gt;
	// / 抽取标签内文本
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="bLast"&gt;最后一个标签&lt;/param&gt;
	// / &lt;param name="start"&gt;开始位置&lt;/param&gt;
	// / &lt;param name="sTag"&gt;标签TAG&lt;/param&gt;
	// / &lt;param name="sValue"&gt;&lt;/param&gt;
	// / &lt;returns&gt;成功返回结束位置，错误返回-1&lt;/returns&gt;
	public static int ParseFieldValue(String sText, int start, boolean bLast,
			String sTag, StringBuffer sValue) {
		return GetInnerHTML(sText, start, 1, bLast, sTag, sValue);
	}

	// / &lt;summary&gt;
	// / 抽取标签内文本
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="bLast"&gt;最后一个标签&lt;/param&gt;
	// / &lt;param name="start"&gt;开始位置&lt;/param&gt;
	// / &lt;param name="sTag"&gt;标签TAG&lt;/param&gt;
	// / &lt;param name="sValue"&gt;&lt;/param&gt;
	// / &lt;returns&gt;成功返回结束位置，错误返回-1&lt;/returns&gt;
	public static int GetInnerHTML(String sText, int start, String sTag,
			StringBuffer sValue) {
		return GetInnerHTML(sText, start, 1, false, sTag, sValue);
	}

	// / &lt;summary&gt;
	// / 抽取标签内HTML文本
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="start"&gt;开始位置&lt;/param&gt;
	// / &lt;param name="iRepTimes"&gt;标签重复次数&lt;/param&gt;
	// / &lt;param name="sTag"&gt;A TABLE P等HTML标签&lt;/param&gt;
	// / &lt;param name="sResult"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static int GetInnerHTML(String sText, int start, int iRepTimes,
			String sTag, StringBuffer sResult) {
		return GetInnerHTML(sText, start, iRepTimes, false, sTag, sResult);
	}

	// / &lt;summary&gt;
	// / 抽取标签外部HTML文本
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="bReverse"&gt;是否反向查找&lt;/param&gt;
	// / &lt;param name="start"&gt;开始查找位置&lt;/param&gt;
	// / &lt;param name="iRepTimes"&gt;标签重复次数&lt;/param&gt;
	// / &lt;param name="sTag"&gt;&lt;/param&gt;
	// / &lt;param name="sResult"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static int GetInnerHTML(String sText, int start, int iRepTimes,
			boolean bReverse, String sTag, StringBuffer sResult) {
		String sBeg = MessageFormat.format("&lt;{0}", sTag);
		String sEnd = MessageFormat.format("&lt;/{0}&gt;", sTag);

		return GetInnerHTML(sText, start, iRepTimes, bReverse, sBeg, sEnd,
				sResult);
	}

	// / &lt;summary&gt;
	// / 抽取标签外部HTML文本
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="start"&gt;开始查找位置&lt;/param&gt;
	// / &lt;param name="iRepTimes"&gt;标签重复次数&lt;/param&gt;
	// / &lt;param name="bReverse"&gt;是否反向查找&lt;/param&gt;
	// / &lt;param name="sBeg"&gt;开始文本&lt;/param&gt;
	// / &lt;param name="sEnd"&gt;结束文本&lt;/param&gt;
	// / &lt;param name="sResult"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static int GetInnerHTML(String sText, int start, int iRepTimes,
			boolean bReverse, String sBeg, String sEnd, StringBuffer sResult) {
		int pos1 = 0, pos2 = 0;
		if (!bReverse) {
			pos1 = sText.indexOf(sBeg, start);
			while (pos1 &gt;= 0 &amp;&amp; iRepTimes &gt; 0) {
				iRepTimes--;
				if (iRepTimes == 0) {
					break;
				}
				pos1 += sBeg.length();

				pos1 = sText.indexOf(sBeg, pos1);
			}
		} else {
			pos1 = sText.lastIndexOf(sBeg);
			while (pos1 &gt;= 0 &amp;&amp; iRepTimes &gt; 0) {
				iRepTimes--;
				if (iRepTimes == 0) {
					break;
				}
				sText = sText.substring(0, pos1);

				pos1 = sText.lastIndexOf(sBeg);
			}
		}
		if (pos1 &lt; start) {
			return -1;
		}
		pos1 += sBeg.length();

		pos2 = sText.indexOf(sEnd, pos1);
		if (pos2 &lt; 0) {
			return -1;
		}
		sResult.append(sText.substring(pos1, pos2 - pos1));
		start = pos2 + sEnd.length();

		if (!sBeg.endsWith("&gt;")) {
			pos1 = sResult.toString().indexOf('&gt;');
			if (pos1 &gt;= 0) {
				sResult.append(sResult.substring(pos1 + 1));
			}
		}
		String li = sResult.toString().trim();
		sResult.delete(0, sResult.length() - 1);
		sResult.append(li);
		return start;
	}

	// / &lt;summary&gt;
	// / 获取标签外部HTML串
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="start"&gt;开始位置&lt;/param&gt;
	// / &lt;param name="sTag"&gt;&lt;/param&gt;
	// / &lt;param name="sResult"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static int GetOuterHTML(String sText, int start, String sTag,
			StringBuffer sResult) {//, StringBuffer dResult
		String sBeg = MessageFormat.format("&lt;{0}", sTag);
		String sEnd = MessageFormat.format("&lt;/{0}&gt;", sTag);
//		String sDate = ";;";
		int pos1 = GetOuterHTML(sText, start, 1, false, sBeg, sEnd, sResult);//, sDate, dResult
		if (pos1 &gt; 0) {
			return pos1;
		}
		sEnd = "&gt;";
		return GetOuterHTML(sText, start, 1, false, sBeg, sEnd, sResult);//, sDate, dResult
	}

	public static int GetOuterHTML(String sText, int start, int iRepTimes,
			String sTag, StringBuffer sResult) {//, String sDate, StringBuffer dResult
		String sBeg = MessageFormat.format("&lt;{0}", sTag);
		String sEnd = MessageFormat.format("&lt;/{0}&gt;", sTag);

		int pos1 = GetOuterHTML(sText, start, iRepTimes, false, sBeg, sEnd,
				sResult);//, sDate, dResult
		if (pos1 &gt; 0) {
			return pos1;
		}
		sEnd = "&gt;";
		return GetOuterHTML(sText, start, iRepTimes, false, sBeg, sEnd, sResult);//, sDate, dResult
	}

	public static int GetOuterHTML(String sText, int start, int iRepTimes,
			boolean bReverse, String sTag, StringBuffer sResult) {//, String sDate, StringBuffer dResult
		String sBeg = MessageFormat.format("&lt;{0}", sTag);
		String sEnd = MessageFormat.format("&lt;/{0}&gt;", sTag);

		int pos1 = GetOuterHTML(sText, start, iRepTimes, false, sBeg, sEnd,
				sResult);//, sDate, dResult
		if (pos1 &gt; 0) {
			return pos1;
		}
		sEnd = "&gt;";
		return GetOuterHTML(sText, start, iRepTimes, false, sBeg, sEnd, sResult);//, sDate, dResult
	}

	// / &lt;summary&gt;
	// / 获取标签外部HTML文本
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="start"&gt;开始查找位置&lt;/param&gt;
	// / &lt;param name="iRepTimes"&gt;重复出现次数&lt;/param&gt;
	// / &lt;param name="bReverse"&gt;是否反向匹配&lt;/param&gt;
	// / &lt;param name="sBeg"&gt;开始文本&lt;/param&gt;
	// / &lt;param name="sEnd"&gt;结束文本&lt;/param&gt;
	// / &lt;param name="sResult"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static int GetOuterHTML(String sText, int start, int iRepTimes,
			boolean bReverse, String sBeg, String sEnd, StringBuffer sResult) {//, String sDate, StringBuffer dResult
		int pos1 = 0, pos2 = 0;
		if (!bReverse) {
			pos1 = sText.indexOf(sBeg, start);
			while (pos1 &gt;= 0 &amp;&amp; iRepTimes &gt; 0) {
				iRepTimes--;
				if (iRepTimes == 0) {
					break;
				}
				pos1 += sBeg.length();

				pos1 = sText.indexOf(sBeg, pos1);
			}
		} else {
			pos1 = sText.lastIndexOf(sBeg);
			while (pos1 &gt;= 0 &amp;&amp; iRepTimes &gt; 0) {
				iRepTimes--;
				if (iRepTimes == 0) {
					break;
				}
				sText = sText.substring(0, pos1);

				pos1 = sText.lastIndexOf(sBeg);
			}
		}
		if (pos1 &lt; start) {
			return -1;
		}

		pos2 = sText.indexOf(sEnd, pos1 + sBeg.length());
		if (pos2 &lt; 0) {
			return -1;
		}
		pos2 += sEnd.length();

		if (sResult.length() == 0) {
			sResult.append(sText.substring(pos1, pos2));
		} else {
			sResult.replace(0, sResult.length() - 1,
					sText.substring(pos1, pos2));
		}
		// 添加获取服务器时间
//		if(dResult == null || sDate == null){
//			return pos2;
//		}
//		pos1 = sText.indexOf(sDate, start);
//		if(pos1&lt;0){
//			System.out.println(sText + "----" + start);
//		}
//		if (dResult.length() == 0) {
//			dResult.append(sText.substring(start, pos1));
//		} else {
//			dResult.replace(0, dResult.length() - 1,
//					sText.substring(start, pos1));
//		}
		
		return pos2;
	}

	// / &lt;summary&gt;
	// / 获取HTML页面Meta节点内容
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="start"&gt;&lt;/param&gt;
	// / &lt;param name="sTitle"&gt;节点名称&lt;/param&gt;
	// / &lt;param name="sResult"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static int GetMetaContent(String sText, int start, String sTitle,
			StringBuffer sResult) {
		StringBuffer line = new StringBuffer();
		int pos1 = StringHelper.ExtractContentByAttr(sText, start, 0, "meta",
				"name", sTitle, line);
		if (pos1 &lt; 0) {
			return -1;
		}

		if (!StringHelper.ParseAttribute(line.toString(), "content", sResult)) {
			return -1;
		}
		return pos1;
	}

	// / &lt;summary&gt;
	// / 查找标签内部文本
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="start"&gt;开始查找位置&lt;/param&gt;
	// / &lt;param name="sTag"&gt;A P TABLE table等页面标签&lt;/param&gt;
	// / &lt;param name="sResult"&gt;&lt;/param&gt;
	// / &lt;returns&gt;查找内容结束后位置，-1为查找失败&lt;/returns&gt;
	public static int FindString(String sText, int start, String sTag,
			StringBuffer sResult) {
		String sBegin = MessageFormat.format("&lt;{0}", sTag);
		String sEnd = MessageFormat.format("&lt;/{0}&gt;", sTag);

		return FindString(sText, start, sBegin, sEnd, sResult);
	}

	public static int FindString(String sText, int start, int iRepTimes,
			String sTag, StringBuffer sResult) {
		String sBegin = MessageFormat.format("&lt;{0}", sTag);
		String sEnd = MessageFormat.format("&lt;/{0}&gt;", sTag);

		return FindString(sText, start, iRepTimes, sBegin, sEnd, sResult);
	}

	// / &lt;summary&gt;
	// / 查找sBegin 与 sEnd 间文本
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="start"&gt;开始位置&lt;/param&gt;
	// / &lt;param name="sBegin"&gt;开始前文本&lt;/param&gt;
	// / &lt;param name="sEnd"&gt;结束后文本&lt;/param&gt;
	// / &lt;param name="sResult"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static int FindString(String sText, int start, String sBegin,
			String sEnd, StringBuffer sResult) {
		int pos1 = 0, pos2 = 0;
		pos1 = sText.indexOf(sBegin, start);
		if (pos1 &lt; 0) {
			return -1;
		}
		pos1 += sBegin.length();
		start = pos1;

		if (sEnd == null || sEnd.equals("")) {
			if (sResult.length() == 0) {
				sResult.append(sText.toString().substring(pos1));
			} else {
				sResult.replace(0, sResult.length() - 1, sText.toString()
						.substring(pos1));
			}
		} else {
			pos2 = sText.indexOf(sEnd, pos1);
			if (pos2 &lt; 0) {
				return -1;
			}
			sResult.replace(0, sResult.length() - 1,
					sText.substring(pos1, pos2 - pos1));
			start = pos2 + sEnd.length();
		}

		pos1 = sResult.toString().indexOf('&gt;');
		if (pos1 &gt;= 0) {
			sResult.replace(0, sResult.length() - 1,
					sResult.substring(pos1 + 1));
		}
		sResult.replace(0, sResult.length() - 1, sResult.toString().trim());
		return start;
	}

	// / &lt;summary&gt;
	// / 查找 sBegin 和 sEnd 间文本，重复iRepTimes次
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="start"&gt;&lt;/param&gt;
	// / &lt;param name="iRepTimes"&gt;&lt;/param&gt;
	// / &lt;param name="sBegin"&gt;&lt;/param&gt;
	// / &lt;param name="sEnd"&gt;&lt;/param&gt;
	// / &lt;param name="sResult"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static int FindString(String sText, int start, int iRepTimes,
			String sBegin, String sEnd, StringBuffer sResult) {
		do {
			start = FindString(sText, start, sBegin, sEnd, sResult);
			if (start &lt; 0) {
				break;
			}

			iRepTimes--;
		} while (iRepTimes &gt; 0);
		return start;
	}

	// / &lt;summary&gt;
	// / 将字符串的中词语的第一个字母大写，其他小写
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static String FirstLetterCapital(String sText) {
		sText = sText.trim();
		sText = sText.toLowerCase();

		boolean bPrevSpace = false;
		char[] sArray = sText.toCharArray();
		for (int i = 0; i &lt; sArray.length; i++) {
			if (i == 0 || bPrevSpace) {
				bPrevSpace = false;
				if (Character.isLetter(sArray[i])) {
					sArray[i] = Character.toUpperCase(sArray[i]);
				}
			} else {
				if (Character.isWhitespace(sArray[i])) {
					bPrevSpace = true;
				} else if (Character.isSpaceChar(sArray[i]))// *****************
				{
					bPrevSpace = true;
				} else if (Character.getType(sArray[i]) == Character.OTHER_PUNCTUATION)// **********
				{
					bPrevSpace = true;
				} else if (sArray[i] == ':' || sArray[i] == '-') {
					bPrevSpace = true;
				}
			}
		}

		StringBuilder sb = new StringBuilder();
		sb.append(sArray);
		sText = sb.toString();
		return sText;
	}

	// / &lt;summary&gt;
	// / 判断sText与sValue是否为包含关系
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="bToLower"&gt;是否小写后比较&lt;/param&gt;
	// / &lt;param name="iCompare"&gt;1 sText或子串 包含 sValue;0 sText或子串 相等 sValue;-1
	// sValue 包含sText或子串&lt;/param&gt;
	// / &lt;param name="sValue"&gt;&lt;/param&gt;
	// / &lt;param name="splitstr"&gt;sText分割串数组&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static boolean Contains(String sText, boolean bToLower,
			int iCompare, String sValue, String splitstr) {
		String[] array1 = sText.split(splitstr);
		String[] array = null;
		int m = 0;
		for (int i = 0; i &lt; array1.length; i++) {
			if (array1[i] != "") {
				array[m] = array1[i];
				m++;
			}
		}
		if (array != null &amp;&amp; array.length &gt; 0) {
			String str = "";
			String line = sValue;
			if (bToLower) {
				line = line.toLowerCase();
			}

			for (int i = 0; i &lt; array.length; i++) {
				if (!bToLower) {
					str = array[i];
				} else {
					str = array[i].toLowerCase();
				}

				if (iCompare == 0) {
					if (line == str) {
						return true;
					}
				} else if (iCompare &gt; 0) {
					if (str.indexOf(line) &gt; 0) {
						return true;
					}
				} else {
					if (line.indexOf(str) &gt; 0) {
						return true;
					}
				}
			}
		}
		return false;
	}

	// / &lt;summary&gt;
	// / 获取字符串首字母
	// / &lt;/summary&gt;
	// / &lt;param name="str"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	/*
	 * public static char GetFirstLetter(String text) { if (text == null ||
	 * text.equals("")) { return '\0'; } text = text.toLowerCase(); if
	 * (text.startsWith("the ")) { text = text.substring(4).trim(); }
	 * 
	 * byte[] buffer =
	 * System.Text.Encoding.GetEncoding("GB2312").GetBytes(text.toCharArray(0,
	 * 1));
	 * 
	 * int tmp = 0; if (buffer.length == 1) { tmp = buffer[0]; } else { tmp =
	 * buffer[1] | (buffer[0] &lt;&lt; 8); }
	 * 
	 * if (tmp &gt;= 45217 &amp;&amp; tmp &lt;= 45252) { return 'A'; } if (tmp &gt;= 45253 &amp;&amp; tmp
	 * &lt;= 45760) { return 'B'; } if (tmp &gt;= 45761 &amp;&amp; tmp &lt;= 46317) { return 'C';
	 * } if (tmp &gt;= 46318 &amp;&amp; tmp &lt;= 46825) { return 'D'; } if (tmp &gt;= 46826 &amp;&amp;
	 * tmp &lt;= 47009) { return 'E'; } if (tmp &gt;= 47010 &amp;&amp; tmp &lt;= 47296) { return
	 * 'F'; } if (tmp &gt;= 47297 &amp;&amp; tmp &lt;= 47613) { return 'G'; } if (tmp &gt;= 47614
	 * &amp;&amp; tmp &lt;= 48118) { return 'H'; } if (tmp &gt;= 48119 &amp;&amp; tmp &lt;= 49061) {
	 * return 'J'; } if (tmp &gt;= 49062 &amp;&amp; tmp &lt;= 49323) { return 'K'; } if (tmp
	 * &gt;= 49324 &amp;&amp; tmp &lt;= 49895) { return 'L'; } if (tmp &gt;= 49896 &amp;&amp; tmp &lt;=
	 * 50370) { return 'M'; } if (tmp &gt;= 50371 &amp;&amp; tmp &lt;= 50613) { return 'N'; }
	 * if (tmp &gt;= 50614 &amp;&amp; tmp &lt;= 50621) { return 'O'; } if (tmp &gt;= 50622 &amp;&amp; tmp
	 * &lt;= 50905) { return 'P'; } if (tmp &gt;= 50906 &amp;&amp; tmp &lt;= 51386) { return 'Q';
	 * } if (tmp &gt;= 51387 &amp;&amp; tmp &lt;= 51445) { return 'R'; } if (tmp &gt;= 51446 &amp;&amp;
	 * tmp &lt;= 52217) { return 'S'; } if (tmp &gt;= 52218 &amp;&amp; tmp &lt;= 52697) { return
	 * 'T'; } if (tmp &gt;= 52698 &amp;&amp; tmp &lt;= 52979) { return 'W'; } if (tmp &gt;= 52980
	 * &amp;&amp; tmp &lt;= 53640) { return 'X'; } if (tmp &gt;= 53689 &amp;&amp; tmp &lt;= 54480) {
	 * return 'Y'; } if (tmp &gt;= 54481 &amp;&amp; tmp &lt;= 62289) { return 'Z'; }
	 * 
	 * char first = text.charAt(0);
	 * 
	 * if (first &gt;= 'a' &amp;&amp; first &lt;= 'z') { first = (char)(first - ' '); } return
	 * first; }
	 */

	// / &lt;summary&gt;
	// / 获取最大iMaxWord个单词或字的首字母，形成格式如中国人民-ZGRM,cell research-CR
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="iMaxWord"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	/*
	 * public static String GetInitialLetters(String sText, int iMaxWord) {
	 * String line = "", sResult = ""; if (!CultureHelper.IsForeign(sText)) {
	 * for (int i = 0; i &lt; sText.length() &amp;&amp; i &lt; iMaxWord; i++) { char ch1 =
	 * sText.charAt(i); char ch2 =
	 * StringHelper.GetFirstLetter(String.valueOf(ch1)); if (ch1 == ch2) {
	 * continue; } sResult += ch2; } } else { String[] sepstr = { ";;", ";",
	 * ",", " " }; String[] sArray = sText.Split(sepstr,
	 * StringSplitOptions.RemoveEmptyEntries); if (sArray == null ||
	 * sArray.length &lt;= 0) { return ""; }
	 * 
	 * for (int i = 0; i &lt; sArray.length &amp;&amp; i&lt;iMaxWord; i++) { line = sArray[i];
	 * Matcher RegIsPrep1 = RegIsPrep.matcher(line); if (RegIsPrep1.find()) {
	 * continue; } sResult += String.valueOf(StringHelper.GetFirstLetter(line));
	 * } } return sResult; }
	 */

	// / &lt;summary&gt;
	// / 在sText中查找任意sArray中字符串，并返回位置最前或最后的串位置
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="start"&gt;开始查找位置&lt;/param&gt;
	// / &lt;param name="bMinPos"&gt;最前位置 true，最后位置 false&lt;/param&gt;
	// / &lt;param name="sHitStr"&gt;命中字串&lt;/param&gt;
	// / &lt;param name="sArray"&gt;&lt;/param&gt;
	// / &lt;returns&gt;位置&lt;/returns&gt;
	public static int IndexOfAny(String sText, int start, boolean bMinPos,
			String sHitStr, String[] sArray) {
		int pos1 = -1, pos2 = -1;
		for (int i = 0; i &lt; sArray.length; i++) {
			pos2 = sText.indexOf(sArray[i], start);
			if (pos2 &gt; 0) {
				if (pos1 == -1) {
					sHitStr = sArray[i];
					pos1 = pos2;
				} else {
					if (bMinPos) {
						if (pos2 &lt; pos1) {
							sHitStr = sArray[i];
							pos1 = pos2;
						}
					} else {
						if (pos2 &gt; pos1) {
							sHitStr = sArray[i];
							pos1 = pos2;
						}
					}
				}
			}
		}
		return pos1;
	}

	// / &lt;summary&gt;
	// / 在文本的每一行前加tabTimes制表符
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="tabTimes"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static String TabTextLine(String sText, int tabTimes) {
		String str = "\t";
		if (tabTimes &gt; 1) {
			for (int i = 1; i &lt; tabTimes; i++) {
				str += "\t";
			}
		}

		StringBuilder sb = new StringBuilder();

		String line = "";
		int pos1 = 0, pos2 = 0;
		pos1 = sText.indexOf("\n", pos2);
		while (pos1 &gt; 0) {
			line = sText.substring(pos2, pos1 - pos2);
			pos2 = pos1 + 1;

			line = str + line;
			sb.append(line);

			pos1 = sText.indexOf("\n", pos2);
		}

		if (pos2 &lt; sText.length()) {
			line = sText.substring(pos2);

			line = str + line;
			sb.append(line);
		}
		return sb.toString();
	}

	// / &lt;summary&gt;
	// / 删除以sBeg开始、sEnd结尾的文本
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="start"&gt;&lt;/param&gt;
	// / &lt;param name="sBeg"&gt;&lt;/param&gt;
	// / &lt;param name="sEnd"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static String RemoveText(String sText, int start, String sBeg,
			String sEnd) {
		int pos1 = 0, pos2 = 0;
		pos1 = sText.indexOf(sBeg, start);
		if (pos1 &lt; 0) {
			return sText;
		}

		String left = "", right = "";
		while (pos1 &gt;= 0) {
			pos2 = sText.indexOf(sEnd, pos1);
			if (pos2 &lt; 0) {
				break;
			}
			pos2 += sEnd.length();

			left = sText.substring(0, pos1);

			right = sText.substring(pos2);

			sText = left + right;

			pos1 = sText.indexOf(sBeg, start);
		}
		return sText;
	}

	public static String RemoveHTML(String sText) {
		String left = "", right = "";

		int pos2 = 0;
		int pos1 = sText.indexOf('&lt;');
		while (pos1 &gt;= 0) {
			pos2 = sText.indexOf('&gt;', pos1);
			if (pos2 &lt; 0) {
				sText = sText.substring(0, pos1);
			} else {
				left = sText.substring(0, pos1);
				right = sText.substring(pos2 + 1);
				sText = left + right;
			}
			pos1 = sText.indexOf('&lt;');
		}
		return sText;
	}

	// / &lt;summary&gt;
	// / 将sText中与sResult不同的文本串合并
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="sepstr"&gt;&lt;/param&gt;
	// / &lt;param name="sResult"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static String MergeContent(String sText, String sepstr,
			String sResult) {
		boolean bChanged = false;
		return MergeContent(sText, sepstr, sResult, bChanged);
	}

	public static String MergeContent(String sText, String sepstr,
			String sResult, Boolean bChanged) {
		bChanged = false;
		if (sText == "" || sText == sResult || sText == ";;") {
			return sResult;
		}

		if (sResult == null || sResult.equals("")) {
			sResult = sText;
			if (!sResult.endsWith(";;")) {
				sResult += ";;";
			}
			bChanged = true;
			return sResult;
		}
		if (!sResult.endsWith(";;")) {
			sResult += ";;";
		}
		if (sResult.indexOf(";;;") &gt; 0) {
			sResult = sResult.replace(";;;", "[xxx];;");
		}

		String[] sArray1 = sResult.split(sepstr);
		String[] sArray = null;
		int m = 0;
		for (int i = 0; i &lt; sArray1.length; i++) {
			if (sArray1[i] != "") {
				sArray[m] = sArray1[i];
				m++;
			}
		}
		if (sArray == null || sArray.length == 0) {
			sResult = sText;
			bChanged = true;
			return sResult;
		}

		String line = "";
		if (sText.indexOf(";;;") &gt; 0) {
			sText = sText.replace(";;;", "[xxx];;");
		}
		String[] sArray21 = sText.split(sepstr);
		String[] sArray2 = null;
		int n = 0;
		for (int i = 0; i &lt; sArray21.length; i++) {
			if (sArray21[i] != "") {
				sArray2[n] = sArray21[i];
				n++;
			}
		}
		if (sArray2 != null &amp;&amp; sArray2.length &gt; 0) {
			int pos1 = 0;
			Hashtable mytable = new Hashtable();
			for (int i = 0; i &lt; sArray.length; i++) {
				line = sArray[i].trim();
				if (line.indexOf("[xxx]") &gt; 0) {
					line = line.replace("[xxx]", ";");
				}
				if (!mytable.containsKey(line)) {
					mytable.put(line, line);
				}
			}

			for (int i = 0; i &lt; sArray2.length; i++) {
				line = sArray2[i].trim();
				if (line.indexOf("[xxx]") &gt; 0) {
					line = line.replace("[xxx]", ";");
				}
				if (!mytable.containsKey(line)) {
					sResult += line + ";;";
					bChanged = true;
				}
			}
		}

		if (sResult.indexOf("[xxx]") &gt; 0) {
			sResult = sResult.replace("[xxx]", ";");
		}
		return sResult;
	}

	// / &lt;summary&gt;
	// / 根据标签内包含的文本特征提取元素OuterHTML
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="start"&gt;&lt;/param&gt;
	// / &lt;param name="iCompare"&gt;&lt;/param&gt;
	// / &lt;param name="sTagName"&gt;&lt;/param&gt;
	// / &lt;param name="sInnerText"&gt;&lt;/param&gt;
	// / &lt;param name="sResult"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static int ExtractContentByInnerText(String sText, int start,
			int iCompare, String sTagName, String sInnerText,
			StringBuffer sResult) {
		String line = "";
		StringBuffer sTemp = new StringBuffer();
//		StringBuffer dTemp = new StringBuffer();
		int pos1 = StringHelper.GetOuterHTML(sText, start, sTagName, sTemp);//, dTemp
		while (pos1 &gt; 0) {
			line = StringHelper.GetInnerText(sTemp.toString(), sTagName);
			if (MatchText(line, iCompare, sInnerText)) {
				sResult.append(sTemp);
				return pos1;
			}
			pos1 = StringHelper.GetOuterHTML(sText, pos1, sTagName, sTemp);//, dTemp
		}
		return -1;
	}

	// / &lt;summary&gt;
	// / 根据元素内文本特征获取元素后面的HTML文本
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="start"&gt;&lt;/param&gt;
	// / &lt;param name="iCompare"&gt;&lt;/param&gt;
	// / &lt;param name="sTagName"&gt;&lt;/param&gt;
	// / &lt;param name="sInnerText"&gt;&lt;/param&gt;
	// / &lt;param name="sEndText"&gt;&lt;/param&gt;
	// / &lt;param name="sResult"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static int ExtractContentAfter(String sText, int start,
			int iCompare, String sTagName, String sInnerText, String sEndText,
			StringBuffer sResult) {
		StringBuffer sTemp = new StringBuffer();
		int pos1 = ExtractContentByInnerText(sText, start, iCompare, sTagName,
				sInnerText, sTemp);
		if (pos1 &lt; 0) {
			return -1;
		}

		int pos2 = sText.indexOf(sEndText, pos1);
		if (pos2 &lt; 0) {
			return -1;
		}
		pos2 += sEndText.length();

		sResult.append(sText.substring(pos1, pos2 - pos1));
		return pos2;
	}

	// / &lt;summary&gt;
	// / 根据属性的值提取元素OuterHTML
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="start"&gt;&lt;/param&gt;
	// / &lt;param name="iCompare"&gt;&lt;/param&gt;
	// / &lt;param name="sTagName"&gt;&lt;/param&gt;
	// / &lt;param name="sAttr"&gt;&lt;/param&gt;
	// / &lt;param name="sMatch"&gt;&lt;/param&gt;
	// / &lt;param name="sResult"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static int ExtractContentByAttr(String sText, int start,
			int iCompare, String sTagName, String sAttr, String sMatch,
			StringBuffer sResult) {
		StringBuffer line = new StringBuffer();
		StringBuffer sTemp = new StringBuffer();
//		StringBuffer dTemp = new StringBuffer();
		int pos1 = StringHelper.GetOuterHTML(sText, start, sTagName, sTemp);//, dTemp
		while (pos1 &gt; 0) {
			if (StringHelper.ParseAttribute(sTemp.toString(), sAttr, line)) {
				if (MatchText(line.toString(), iCompare, sMatch)) {
					sResult.append(sTemp);
					return pos1;
				}
			}

			pos1 = StringHelper.GetOuterHTML(sText, pos1, sTagName, sTemp);//, dTemp
		}
		return -1;
	}

	// / &lt;summary&gt;
	// / 根据iCompare指定方式判断sText与sMatch是否匹配
	// / &lt;/summary&gt;
	// / &lt;param name="sText"&gt;&lt;/param&gt;
	// / &lt;param name="iCompare"&gt;0=相等 1=包含 -1=不包含&lt;/param&gt;
	// / &lt;param name="sMatch"&gt;&lt;/param&gt;
	// / &lt;returns&gt;&lt;/returns&gt;
	public static boolean MatchText(String sText, int iCompare, String sMatch) {
		if (iCompare == 0) {
			if (sText == sMatch) {
				return true;
			}
		} else if (iCompare &gt; 0) {
			if (sText.indexOf(sMatch) &gt;= 0) {
				return true;
			}
		} else {
			if (sText.indexOf(sMatch) &lt; 0) {
				return true;
			}
		}
		return false;
	}

}
</code></pre> 
<br>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1741fd52acd683fca4918aabb68626ef/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring5：就这一次，搞定资源加载器之ServletContextResourceLoader</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/198a3acf766f206a60f6a344b96d7e88/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ping命令添加时间戳</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>