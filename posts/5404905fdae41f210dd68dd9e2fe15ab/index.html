<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>VC中的CWnd指针和HWnd的区别于联系 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="VC中的CWnd指针和HWnd的区别于联系" />
<meta property="og:description" content="HWND是Windows系统中对所有窗口的一种标识，即窗口句柄。这是一个SDK概念。 CWnd是MFC类库中所有窗口类的基类。微软在MFC中将所有窗口的通用操作都封装到了这个类中，如：ShowWindow等等，同时它也封装了窗口句柄即m_hWnd成员。
由HWnd得到CWnd*：
CWnd wnd;
HWnd hWnd;
wnd.Attach(hWnd);
通常一个窗口资源已经和一个CWnd类的对象关联起来的，由于一般来说这个类是自己创建的，所以自然知道怎么得到指向这个类的指针。如果没有就创建一个CWnd对象，将这个对象与窗口资源的hWnd句柄关联起来。（如上边的语句）。如果用
static CWnd* CWnd::FromHandle(HWND hWnd) ；
则返回值是一个暂时的CWnd对象，并且我们确保返回值为非空，也就是hWnd是有效的。 static CWnd* CWnd::FromHandlePermanent(HWND hWnd) ；
返回的是一个永久的对象。只有在返回的CWnd在类表里已经存在是返回值为非空。
由CWnd获取HWnd就容易多了，因为它的一个成员m_hWnd就是所对应窗口的句柄。
wnd-&gt;m_hWnd。
——————————————————————————————————————————————————————————
CWnd* 和 HWND 差别很大
HWND 是 SDK 定义的类型, 是一个无确切意义的 32-bit 值，在调用 API 时用于指代窗体。
CWnd* 是一个有确切意义的指针，指向一个 MFC 窗体类 CWnd 的实例。因为 MFC 对 SDK 做了封装，大部分调用都可以用 CWnd* 作为参数，所以很容易混淆。从一个 CWnd* 获取句柄的方法是 pWnd-&gt;GetSafeHwnd(), 他比 pWnd-&gt;m_hWnd 安全，因为前者在 pWnd == NULL 的时候返回 NULL 而后者出现 access violation
从 hWnd 转换到 CWnd * 一个可以使用的方法是 CWnd::FromHandle" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5404905fdae41f210dd68dd9e2fe15ab/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-05T01:46:33+08:00" />
<meta property="article:modified_time" content="2019-07-05T01:46:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">VC中的CWnd指针和HWnd的区别于联系</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p><span style="color:#00ccff;">HWND是Windows系统中对所有窗口的一种标识，即窗口句柄</span>。这是一个SDK概念。   <br><span style="color:#00ccff;">CWnd是MFC类库中所有窗口类的基类</span>。微软在MFC中将所有窗口的通用操作都封装到了这个类中，如：ShowWindow等等，同时它也封装了窗口句柄即m_hWnd成员。</p> 
 <p><span style="color:#ff0000;">由HWnd得到CWnd*：<br>CWnd wnd;<br>HWnd hWnd;<br>wnd.Attach(hWnd);<br></span>通常一个窗口资源已经和一个CWnd类的对象关联起来的，由于一般来说这个类是自己创建的，所以自然知道怎么得到指向这个类的指针。如果没有就创建一个CWnd对象，将这个对象与窗口资源的hWnd句柄关联起来。（如上边的语句）。如果用<br><span style="color:#000000;">static CWnd*   CWnd::FromHandle(HWND   hWnd) ；<br>则返回值是一个暂时的CWnd对象，并且我们确保返回值为非空，也就是hWnd是有效的。 <br>static CWnd*   CWnd::FromHandlePermanent(HWND   hWnd) ；<br>返回的是一个永久的对象。只有在返回的CWnd在类表里已经存在是返回值为非空。</span></p> 
 <p><span style="color:#ff0000;">由CWnd获取HWnd</span>就容易多了，因为它的一个成员m_hWnd就是所对应窗口的句柄。<br><span style="color:#ff0000;">wnd-&gt;m_hWnd</span>。<br>——————————————————————————————————————————————————————————</p> 
 <p>CWnd* 和 HWND 差别很大</p> 
 <p>HWND 是 SDK 定义的类型, 是一个无确切意义的 32-bit 值，在调用 API 时用于指代窗体。</p> 
 <p>CWnd* 是一个有确切意义的指针，指向一个 MFC 窗体类 CWnd 的实例。因为 MFC 对 SDK 做了封装，大部分调用都可以用 CWnd* 作为参数，所以很容易混淆。从一个 CWnd* 获取句柄的方法是 pWnd-&gt;GetSafeHwnd(), 他比 pWnd-&gt;m_hWnd 安全，因为前者在 pWnd == NULL 的时候返回 NULL 而后者出现 access violation</p> 
 <p>从 hWnd 转换到 CWnd * 一个可以使用的方法是 CWnd::FromHandle<br>CWnd *pTempWnd = CWnd::FromHandle(hWnd); // 如果 hWnd 存在对应的 CWnd* ，则返回其指针，否则，创建一个 MFC 临时窗体并返回其指针。<br>注意这个函数会返回临时窗体的指针，如果需要更安全，调用 CWnd::FromHandlePermanent ,他在不存在对应的 CWnd* 时返回 NULL。</p> 
 <p>——————————————————————————————————————————————————————————</p> 
 <p>CWnd是MFC的窗口基类。 HWND是Windows窗口句柄。 前者是一个C++对象，后者是一个类似于指针地址的数字型对象。 <br>CWnd可以看成是对Windows窗口操作的封装，而封装的核心就是使用Windows窗口句柄(即HWND)来操作窗口.</p> 
 <p>CWnd可以通过CWnd::GetSafeHwnd()或成员变量m_hWnd来获得该窗口对象的HWND窗口句柄。 <br>HWND可以通过CWnd的静态函数：CWnd::FromHandle()由句柄实例化一个CWnd对象出来。</p> 
 <p>——————————————————————————————————————————————————————————</p> 
 <p>1: SDK函数<br><br>定义</p> 
 <p>HWND GetDlgItem(HWND hDlg, int nIDDlgItem); </p> 
 <p>参数</p> 
 <p>hDlg</p> 
 <p>    指定对话框的窗口句柄。</p> 
 <p>nIDDlgItem</p> 
 <p>    控件的标识符（ID）。</p> 
 <p>返回值</p> 
 <p>如果函数调用成功，返回值为指定控件的窗口句柄。如果函数调用失败，返回值为 NULL ，表示无效的对话框句柄或者指定控件不存在。要获取更多错误信息，请调用 GetLastError 函数。</p> 
 <p>说明</p> 
 <p>使用该函数时，你可以指定任何窗口，而不只是对话框窗口，只要 hDlg 指定的是一个父窗口并且子窗口具有标识符（在调用 CreateWindow 或 CreateWindowEx 函数创建子窗口时通过 hMenu 参数设置），GetDlgItem 将返回一个有效的子窗口句柄。</p> 
 <p>例如：(调用形式采用如下的方式来调用,而且两个参数的是在平台SDK中调用的)</p> 
 <p>::GetDlgItem(this-&gt;m_hWnd,IDC_XXXX_SIZE); //this-&gt;m_hWnd指的是某个窗口的句柄, IDC_XXX_SIZE是你需要动作的某个控件ID  </p> 
 <p>2: 类成员函数</p> 
 <p>定义</p> 
 <p>CWnd::GetDlgItem(int nID)</p> 
 <p>例如: (CWnd::GetDlgItem(int nID)在窗口中调用)</p> 
 <p>GetDlgItem(IDC_v1)-&gt;ShowWindow(SW_HIDE);<br>GetDlgItem(IDC_v2)-&gt;ShowWindow(SW_HIDE);<br>GetDlgItem(IDC_v3)-&gt;ShowWindow(SW_HIDE);</p> 
</div> 
<p>转载于:https://www.cnblogs.com/rogee/archive/2011/02/20/1959088.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c1a75b8e72e4e61d8b979af51bd30ba2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">XSLT学习笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/518bdd975b2f3219b83193093a7561d4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Delphi Memo中禁止汉字</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>