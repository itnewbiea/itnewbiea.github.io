<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android 12(S) IPV4优先IPV6(优先使用IPv4地址)的实现 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android 12(S) IPV4优先IPV6(优先使用IPv4地址)的实现" />
<meta property="og:description" content="根据RFC 6724中 规定 android 会优先选择IPv6 地址而不是 IPv4 地址，当整个网络中，同时支持IPv4和IPv6 地址时，设备中的应用请求服务器DNS时，会优先返回IPv6地址。
假如IPv6服务器支持内容不够完善，则应用显示内容会与IPv4服务器不一致，甚至有问题。
因此有需求是定制设备平台，使得 IPV4优先IPV6，主要修改2个地方：
1. 当设备或平台连接网络时，原来是先请求ipv6地址，再请求ipv4地址，这样会使用应用会先拿到ipv6地址，所以需要调整顺序，让ipv4先请求dhcp地址，再请求ipv6。
2. DNS域名解析时，调整解析DNS的优先顺序，即先解析IPv4地址，再解析IPv6地址，注：android 12在DnsResolver代码中。
接下来对这2个修改点进行逐一修改并说明。
1. 当设备或平台连接网络时，原来是先请求ipv6地址，再请求ipv4地址，这样会使用应用会先拿到ipv6地址，所以需要调整顺序，让ipv4先请求dhcp地址，再请求ipv6。
文件：packages/modules/NetworkStack/src/android/net/ip/IpClient.java
修改差异如下：
--- a/modules/NetworkStack/src/android/net/ip/IpClient.java &#43;&#43;&#43; b/modules/NetworkStack/src/android/net/ip/IpClient.java @@ -161,6 &#43;161,8 @@ private final NetworkInformationShim mShim = NetworkInformationShimImpl.newInstance(); private final IpProvisioningMetrics mIpProvisioningMetrics = new IpProvisioningMetrics(); private final NetworkQuirkMetrics mNetworkQuirkMetrics; &#43; //CN project let get ipv4 first and then ipv6, tiangui.tang @2023.9.7 //用于区别自定义code与AOSP &#43; private final boolean bStartIPv6AfterIPv4 = true; /** * Dump all state machine and connectivity packet logs to the specified writer." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/51d771443cf47e8f7ec79b273070a1ca/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-14T08:43:37+08:00" />
<meta property="article:modified_time" content="2023-09-14T08:43:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android 12(S) IPV4优先IPV6(优先使用IPv4地址)的实现</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>根据RFC <a href="https://links.jianshu.com/go?to=https%3A%2F%2Furldefense.com%2Fv3%2F__https%3A%2Fwww.ietf.org%2Frfc%2Frfc6724.html__%3B%21%21CTRNKA9wMg0ARbw%21g7qDcPbl_moMTHvqQHwtBPtPKBqIWPIgsI4MD-KpJSGfXU5fJ7em88XU9FO8l3LqgxSgd42uA8CZdQeoPhW2S12Uow%2524" rel="nofollow" title="6724">6724</a>中 规定 android 会优先选择IPv6 地址而不是 IPv4 地址，当整个网络中，同时支持IPv4和IPv6 地址时，设备中的应用请求服务器DNS时，会优先返回IPv6地址。</p> 
<p>假如IPv6服务器支持内容不够完善，则应用显示内容会与IPv4服务器不一致，甚至有问题。</p> 
<p>因此有需求是定制设备平台，使得 IPV4优先IPV6，主要修改2个地方：</p> 
<p><strong>1. 当设备或平台连接网络时，原来是先请求ipv6地址，再请求ipv4地址，这样会使用应用会先拿到ipv6地址，所以需要调整顺序，让ipv4先请求dhcp地址，再请求ipv6。</strong></p> 
<hr> 
<p><strong>2. DNS域名解析时，调整解析DNS的优先顺序，即先解析IPv4地址，再解析IPv6地址，注：android 12在DnsResolver代码中。</strong></p> 
<hr> 
<p><strong>接下来对这2个修改点进行逐一修改并说明。</strong></p> 
<p><strong>1. 当设备或平台连接网络时，原来是先请求ipv6地址，再请求ipv4地址，这样会使用应用会先拿到ipv6地址，所以需要调整顺序，让ipv4先请求dhcp地址，再请求ipv6。</strong></p> 
<p><strong>文件：packages/modules/NetworkStack/src/android/net/ip/IpClient.java</strong></p> 
<p><strong>修改差异如下：</strong></p> 
<p></p> 
<pre><code>--- a/modules/NetworkStack/src/android/net/ip/IpClient.java
+++ b/modules/NetworkStack/src/android/net/ip/IpClient.java
@@ -161,6 +161,8 @@
     private final NetworkInformationShim mShim = NetworkInformationShimImpl.newInstance();
     private final IpProvisioningMetrics mIpProvisioningMetrics = new IpProvisioningMetrics();
     private final NetworkQuirkMetrics mNetworkQuirkMetrics;
+    //CN project let get ipv4 first and then ipv6, tiangui.tang @2023.9.7
//用于区别自定义code与AOSP
+    private final boolean bStartIPv6AfterIPv4 = true;
 
     /**
      * Dump all state machine and connectivity packet logs to the specified writer.
@@ -1734,7 +1736,21 @@
         recordMetric(failureType);
         mCallback.onProvisioningFailure(mLinkProperties);
     }
+    private void enqueueJumpToStoppingState(final DisconnectCode code) {
+        deferMessage(obtainMessage(CMD_JUMP_RUNNING_TO_STOPPING, code.getNumber()));
+    }
+    private void startIPv6AfterIPv4() {
+        if (bStartIPv6AfterIPv4 == false) {
+            return;
+        }
+        Log.d(mTag, "startIPv6AfterIPv4");
 
+        if (mConfiguration.mEnableIPv6 &amp;&amp; !startIPv6()) {
+            doImmediateProvisioningFailure(IpManagerEvent.ERROR_STARTING_IPV6);
+            enqueueJumpToStoppingState(DisconnectCode.DC_ERROR_STARTING_IPV6);
+            return;
+        }
+    }
     private boolean startIPv4() {
         // If we have a StaticIpConfiguration attempt to apply it and
         // handle the result accordingly.
@@ -1744,6 +1760,7 @@
             } else {
                 return false;
             }
+            startIPv6AfterIPv4();
         } else {
             if (mDhcpClient != null) {
                 Log.wtf(mTag, "DhcpClient should never be non-null in startIPv4()");
@@ -2229,7 +2246,7 @@
             mPacketTracker = createPacketTracker();
             if (mPacketTracker != null) mPacketTracker.start(mConfiguration.mDisplayName);
 
-            if (mConfiguration.mEnableIPv6 &amp;&amp; !startIPv6()) {
+            if ((bStartIPv6AfterIPv4 == false) &amp;&amp; mConfiguration.mEnableIPv6 &amp;&amp; !startIPv6()) {
                 doImmediateProvisioningFailure(IpManagerEvent.ERROR_STARTING_IPV6);
                 enqueueJumpToStoppingState(DisconnectCode.DC_ERROR_STARTING_IPV6);
                 return;
@@ -2414,6 +2431,7 @@
                 }
 
                 case EVENT_DHCPACTION_TIMEOUT:
+                    startIPv6AfterIPv4();
                     stopDhcpAction();
                     break;
 
@@ -2431,6 +2449,7 @@
 
                 case DhcpClient.CMD_CONFIGURE_LINKADDRESS: {
                     final LinkAddress ipAddress = (LinkAddress) msg.obj;
+                    startIPv6AfterIPv4();
                     if (mInterfaceCtrl.setIPv4Address(ipAddress)) {
                         mDhcpClient.sendMessage(DhcpClient.EVENT_LINKADDRESS_CONFIGURED);
                     } else {
</code></pre> 
<hr> 
<hr> 
<p><strong>2. DNS域名解析时，调整解析DNS的优先顺序，即先解析IPv4地址，再解析IPv6地址，注：android 12在DnsResolver代码中。</strong></p> 
<p></p> 
<pre><code>diff --git a/modules/DnsResolver/getaddrinfo.cpp b/modules/DnsResolver/getaddrinfo.cpp

--- a/modules/DnsResolver/getaddrinfo.cpp
+++ b/modules/DnsResolver/getaddrinfo.cpp
@@ -1147,7 +1147,8 @@
             return 1;
         } else {
             /* All other IPv6 addresses, including global unicast addresses. */
//DNS解析出来的地址进行排序，IPv4（return 35) 比IPv6(改为return 34)更高优先级
-            return 40;
+            LOG(DEBUG) &lt;&lt; __func__ &lt;&lt; " ttgctt force 34 for ipv6";
+            return 34;
         }
     } else {
         return 1;
@@ -1406,16 +1407,17 @@
                 query_ipv6 = have_ipv6(netcontext-&gt;app_mark, netcontext-&gt;uid);
                 query_ipv4 = have_ipv4(netcontext-&gt;app_mark, netcontext-&gt;uid);
             }
//调整顺序，先请求IPv4对应的DNS，再请求IPv6
-            if (query_ipv6) {
-                q.qtype = T_AAAA;
-                if (query_ipv4) {
+            //query_ipv6 = 0;
+            if (query_ipv4) {
+                q.qtype = T_A;
+                if (query_ipv6) {
                     q.next = &amp;q2;
                     q2.name = name;
                     q2.qclass = C_IN;
-                    q2.qtype = T_A;
+                    q2.qtype = T_AAAA;
                 }
-            } else if (query_ipv4) {
-                q.qtype = T_A;
+            } else if (query_ipv6) {
+                q.qtype = T_AAAA;
             } else { 
                 return EAI_NODATA;
             }
@@ -1452,7 +1454,7 @@
         cur-&gt;ai_next = ai;
         while (cur &amp;&amp; cur-&gt;ai_next) cur = cur-&gt;ai_next;
     }
     if (q.next) {
         ai = getanswer(q2.answer, q2.n, q2.name, q2.qtype, pai, &amp;he);
         if (ai) cur-&gt;ai_next = ai;
     }</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/67244d066860e0de5404ecf16e97b072/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">华为云云耀云服务器L实例评测 | 源码安装 Redis，进行远程连接</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d31f6ddc08806a8cea1f2e44d0426d61/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">高通 Android 12 framework添加自定义按键上报应用层</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>