<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>七大查找算法（Python） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="七大查找算法（Python）" />
<meta property="og:description" content="查找算法 -- 简介
查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素。
查找表（Search Table）：由同一类型的数据元素构成的集合
关键字（Key）：数据元素中某个数据项的值，又称为键值
主键（Primary Key）：可唯一的标识某个数据元素或记录的关键字
查找表按照操作方式可分为：
1.静态查找表（Static Search Table）：只做查找操作的查找表。它的主要操作是：
①查询某个“特定的”数据元素是否在表中
②检索某个“特定的”数据元素和各种属性
2.动态查找表（Dynamic Search Table）：在查找中同时进行插入或删除等操作：
①查找时插入数据
②查找时删除数据
顺序查找
算法简介
顺序查找又称为线性查找，是一种最简单的查找方法。适用于线性表的顺序存储结构和链式存储结构。该算法的时间复杂度为O(n)。
基本思路
从第一个元素m开始逐个与需要查找的元素x进行比较，当比较到元素值相同(即m=x)时返回元素m的下标，如果比较到最后都没有找到，则返回-1。
优缺点
缺点：是当n 很大时，平均查找长度较大，效率低；
优点：是对表中数据元素的存储没有要求。另外，对于线性链表，只能进行顺序查找。
算法实现
# 最基础的遍历无序列表的查找算法
# 时间复杂度O(n)
def sequential_search(lis, key):
length = len(lis)
for i in range(length):
if lis[i] == key:
return i
else:
return False
if __name__ == &#39;__main__&#39;:
LIST = [1, 5, 8, 123, 22, 54, 7, 99, 300, 222]" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ed2548025456aa29afd3a257526a1fa7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-14T10:25:00+08:00" />
<meta property="article:modified_time" content="2019-03-14T10:25:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">七大查找算法（Python）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>查找算法 -- 简介</p> 
 <p>        查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素。<br>        查找表（Search Table）：由同一类型的数据元素构成的集合<br>        关键字（Key）：数据元素中某个数据项的值，又称为键值<br>        主键（Primary Key）：可唯一的标识某个数据元素或记录的关键字</p> 
 <p>查找表按照操作方式可分为：</p> 
 <p>        1.静态查找表（Static Search Table）：只做查找操作的查找表。它的主要操作是：</p> 
 <p>            ①查询某个“特定的”数据元素是否在表中<br>            ②检索某个“特定的”数据元素和各种属性</p> 
 <p>        2.动态查找表（Dynamic Search Table）：在查找中同时进行插入或删除等操作：</p> 
 <p>            ①查找时插入数据<br>            ②查找时删除数据</p> 
 <p>顺序查找</p> 
 <p>算法简介</p> 
 <p>        顺序查找又称为线性查找，是一种最简单的查找方法。适用于线性表的顺序存储结构和链式存储结构。该算法的时间复杂度为O(n)。<br>基本思路</p> 
 <p>        从第一个元素m开始逐个与需要查找的元素x进行比较，当比较到元素值相同(即m=x)时返回元素m的下标，如果比较到最后都没有找到，则返回-1。<br>优缺点</p> 
 <p>        缺点：是当n 很大时，平均查找长度较大，效率低；<br>        优点：是对表中数据元素的存储没有要求。另外，对于线性链表，只能进行顺序查找。<br>算法实现</p> 
 <p># 最基础的遍历无序列表的查找算法<br># 时间复杂度O(n)<br><br>def sequential_search(lis, key):<br> length = len(lis)<br> for i in range(length):<br> if lis[i] == key:<br> return i<br> else:<br> return False<br><br>if __name__ == '__main__':<br> LIST = [1, 5, 8, 123, 22, 54, 7, 99, 300, 222]<br> result = sequential_search(LIST, 123)<br> print(result)<br>二分查找</p> 
 <p>算法简介</p> 
 <p>        二分查找（Binary Search），是一种在有序数组中查找某一特定元素的查找算法。查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则查找过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。<br>        这种查找算法每一次比较都使查找范围缩小一半。</p> 
 <p>算法描述 </p> 
 <p>        给予一个包含 个带值元素的数组A <br>            1、 令 L为0 ， R为 n-1 <br>            2、 如果L&gt;R，则搜索以失败告终 <br>            3、 令 m (中间值元素)为  ⌊(L+R)/2⌋<br>            4、 如果 Am&lt;T，令 L为 m + 1 并回到步骤二 <br>            5、 如果 Am&gt;T，令 R为 m - 1 并回到步骤二</p> 
 <p>复杂度分析 </p> 
 <p>        时间复杂度：折半搜索每次把搜索区域减少一半，时间复杂度为 O(logn) <br>        空间复杂度：O(1)<br>算法实现</p> 
 <p># 针对有序查找表的二分查找算法<br> <br>def binary_search(lis, key):<br>  low = 0<br>  high = len(lis) - 1<br>  time = 0<br>  while low &lt; high:<br>    time += 1<br>    mid = int((low + high) / 2)<br>    if key &lt; lis[mid]:<br>      high = mid - 1<br>    elif key &gt; lis[mid]:<br>      low = mid + 1<br>    else:<br>      # 打印折半的次数<br>      print("times: %s" % time)<br>      return mid<br>  print("times: %s" % time)<br>  return False<br> <br>if __name__ == '__main__':<br>  LIST = [1, 5, 7, 8, 22, 54, 99, 123, 200, 222, 444]<br>  result = binary_search(LIST, 99)<br>  print(result)<br>插值查找</p> 
 <p>算法简介</p> 
 <p>        插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的 查找方法，其核心就在于插值的计算公式 (key-a[low])/(a[high]-a[low])*(high-low)。<br>        时间复杂度o(logn)但对于表长较大而关键字分布比较均匀的查找表来说，效率较高。</p> 
 <p>算法思想</p> 
 <p>        基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。<br>        注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</p> 
 <p>复杂度分析 </p> 
 <p>        时间复杂性：如果元素均匀分布，则O（log log n）），在最坏的情况下可能需要O（n）。<br>        空间复杂度：O（1）。</p> 
 <p>算法实现</p> 
 <p># 插值查找算法<br><br>def binary_search(lis, key):<br> low = 0<br> high = len(lis) - 1<br> time = 0<br> while low &lt; high:<br> time += 1<br> # 计算mid值是插值算法的核心代码<br> mid = low + int((high - low) * (key - lis[low])/(lis[high] - lis[low]))<br> print("mid=%s, low=%s, high=%s" % (mid, low, high))<br> if key &lt; lis[mid]:<br> high = mid - 1<br> elif key &gt; lis[mid]:<br> low = mid + 1<br> else:<br> # 打印查找的次数<br> print("times: %s" % time)<br> return mid<br> print("times: %s" % time)<br> return False<br><br>if __name__ == '__main__':<br> LIST = [1, 5, 7, 8, 22, 54, 99, 123, 200, 222, 444]<br> result = binary_search(LIST, 444)<br> print(result)<br>斐波那契查找</p> 
 <p>算法简介</p> 
 <p>        斐波那契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、····，在数学上，斐波那契被递归方法如下定义：F(1)=1，F(2)=1，F(n)=f(n-1)+F(n-2) （n&gt;=2）。该数列越往后相邻的两个数的比值越趋向于黄金比例值（0.618）。<br>算法描述 </p> 
 <p>        斐波那契查找就是在二分查找的基础上根据斐波那契数列进行分割的。在斐波那契数列找一个等于略大于查找表中元素个数的数F[n]，将原查找表扩展为长度为F[n](如果要补充元素，则补充重复最后一个元素，直到满足F[n]个元素)，完成后进行斐波那契分割，即F[n]个元素分割为前半部分F[n-1]个元素，后半部分F[n-2]个元素，找出要查找的元素在那一部分并递归，直到找到。<br>复杂度分析 </p> 
 <p>        最坏情况下，时间复杂度为O(log2n)，且其期望复杂度也为O(log2n)。<br>算法实现</p> 
 <p># 斐波那契查找算法<br># 时间复杂度O(log(n))<br> <br>def fibonacci_search(lis, key):<br>  # 需要一个现成的斐波那契列表。其最大元素的值必须超过查找表中元素个数的数值。<br>  F = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144,<br>     233, 377, 610, 987, 1597, 2584, 4181, 6765,<br>     10946, 17711, 28657, 46368]<br>  low = 0<br>  high = len(lis) - 1<br>   <br>  # 为了使得查找表满足斐波那契特性，在表的最后添加几个同样的值<br>  # 这个值是原查找表的最后那个元素的值<br>  # 添加的个数由F[k]-1-high决定<br>  k = 0<br>  while high &gt; F[k]-1:<br>    k += 1<br>  print(k)<br>  i = high<br>  while F[k]-1 &gt; i:<br>    lis.append(lis[high])<br>    i += 1<br>  print(lis)<br>   <br>  # 算法主逻辑。time用于展示循环的次数。<br>  time = 0<br>  while low &lt;= high:<br>    time += 1<br>    # 为了防止F列表下标溢出，设置if和else<br>    if k &lt; 2:<br>      mid = low<br>    else:<br>      mid = low + F[k-1]-1<br>     <br>    print("low=%s, mid=%s, high=%s" % (low, mid, high))<br>    if key &lt; lis[mid]:<br>      high = mid - 1<br>      k -= 1<br>    elif key &gt; lis[mid]:<br>      low = mid + 1<br>      k -= 2<br>    else:<br>      if mid &lt;= high:<br>        # 打印查找的次数<br>        print("times: %s" % time)<br>        return mid<br>      else:<br>        print("times: %s" % time)<br>        return high<br>  print("times: %s" % time)<br>  return False<br> <br>if __name__ == '__main__':<br>  LIST = [1, 5, 7, 8, 22, 54, 99, 123, 200, 222, 444]<br>  result = fibonacci_search(LIST, 444)<br>  print(result)<br>树表查找</p> 
 <p>1、二叉树查找算法。</p> 
 <p>        算法简介</p> 
 <p>        二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。 </p> 
 <p>      算法思想</p> 
 <p>　　二叉查找树（BinarySearch Tree）或者是一棵空树，或者是具有下列性质的二叉树：<br>　　        1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>　　        2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>　　        3）任意节点的左、右子树也分别为二叉查找树。</p> 
 <p>　　二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。</p> 
 <p><br>     复杂度分析 </p> 
 <p>        它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。</p> 
 <p>     算法实现</p> 
 <p># 二叉树查找 Python实现<br>class BSTNode:<br> """<br> 定义一个二叉树节点类。<br> 以讨论算法为主，忽略了一些诸如对数据类型进行判断的问题。<br> """<br> def __init__(self, data, left=None, right=None):<br> """<br> 初始化<br> :param data: 节点储存的数据<br> :param left: 节点左子树<br> :param right: 节点右子树<br> """<br> self.data = data<br> self.left = left<br> self.right = right<br><br><br>class BinarySortTree:<br> """<br> 基于BSTNode类的二叉查找树。维护一个根节点的指针。<br> """<br> def __init__(self):<br> self._root = None<br><br> def is_empty(self):<br> return self._root is None<br><br> def search(self, key):<br> """<br> 关键码检索<br> :param key: 关键码<br> :return: 查询节点或None<br> """<br> bt = self._root<br> while bt:<br> entry = bt.data<br> if key &lt; entry:<br> bt = bt.left<br> elif key &gt; entry:<br> bt = bt.right<br> else:<br> return entry<br> return None<br><br> def insert(self, key):<br> """<br> 插入操作<br> :param key:关键码 <br> :return: 布尔值<br> """<br> bt = self._root<br> if not bt:<br> self._root = BSTNode(key)<br> return<br> while True:<br> entry = bt.data<br> if key &lt; entry:<br> if bt.left is None:<br> bt.left = BSTNode(key)<br> return<br> bt = bt.left<br> elif key &gt; entry:<br> if bt.right is None:<br> bt.right = BSTNode(key)<br> return<br> bt = bt.right<br> else:<br> bt.data = key<br> return<br><br> def delete(self, key):<br> """<br> 二叉查找树最复杂的方法<br> :param key: 关键码<br> :return: 布尔值<br> """<br> p, q = None, self._root # 维持p为q的父节点，用于后面的链接操作<br> if not q:<br> print("空树！")<br> return<br> while q and q.data != key:<br> p = q<br> if key &lt; q.data:<br> q = q.left<br> else:<br> q = q.right<br> if not q: # 当树中没有关键码key时，结束退出。<br> return<br> # 上面已将找到了要删除的节点，用q引用。而p则是q的父节点或者None（q为根节点时）。<br> if not q.left:<br> if p is None:<br> self._root = q.right<br> elif q is p.left:<br> p.left = q.right<br> else:<br> p.right = q.right<br> return<br> # 查找节点q的左子树的最右节点，将q的右子树链接为该节点的右子树<br> # 该方法可能会增大树的深度，效率并不算高。可以设计其它的方法。<br> r = q.left<br> while r.right:<br> r = r.right<br> r.right = q.right<br> if p is None:<br> self._root = q.left<br> elif p.left is q:<br> p.left = q.left<br> else:<br> p.right = q.left<br><br> def __iter__(self):<br> """<br> 实现二叉树的中序遍历算法,<br> 展示我们创建的二叉查找树.<br> 直接使用python内置的列表作为一个栈。<br> :return: data<br> """<br> stack = []<br> node = self._root<br> while node or stack:<br> while node:<br> stack.append(node)<br> node = node.left<br> node = stack.pop()<br> yield node.data<br> node = node.right<br><br><br>if __name__ == '__main__':<br> lis = [62, 58, 88, 48, 73, 99, 35, 51, 93, 29, 37, 49, 56, 36, 50]<br> bs_tree = BinarySortTree()<br> for i in range(len(lis)):<br> bs_tree.insert(lis[i])<br> # bs_tree.insert(100)<br> bs_tree.delete(58)<br> for i in bs_tree:<br> print(i, end=" ")<br> # print("\n", bs_tree.search(4))<br>2、平衡查找树之2-3查找树（2-3 Tree）<br>     2-3查找树定义</p> 
 <p>         和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个自己点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下： <br>　　        1）要么为空，要么： <br>　　        2）对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key要小，右节点也是一个2-3节点，所有的值比key要大。 <br>　　        3）对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。</p> 
 <p>     2-3查找树的性质</p> 
 <p>　　 1）如果中序遍历2-3查找树，就可以得到排好序的序列； <br>　　 2）在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。（这也是平衡树中“平衡”一词的概念，根节点到叶节点的最长距离对应于查找算法的最坏情况，而平衡树中根节点到叶节点的距离都一样，最坏情况也具有对数复杂度。） <br>复杂度分析： <br>　　 2-3树的查找效率与树的高度是息息相关的。 </p> 
 <p>         距离来说，对于1百万个节点的2-3树，树的高度为12-20之间，对于10亿个节点的2-3树，树的高度为18-30之间。 <br>　　 对于插入来说，只需要常数次操作即可完成，因为他只需要修改与该节点关联的节点即可，不需要检查其他节点，所以效率和查找类似。</p> 
 <p><br>    算法实现</p> 
 <p>class Node(object):<br> def __init__(self,key):<br> self.key1=key<br> self.key2=None<br> self.left=None<br> self.middle=None<br> self.right=None<br> def isLeaf(self):<br> return self.left is None and self.middle is None and self.right is None<br> def isFull(self):<br> return self.key2 is not None<br> def hasKey(self,key):<br> if (self.key1==key) or (self.key2 is not None and self.key2==key):<br> return True<br> else:<br> return False<br> def getChild(self,key):<br> if key&lt;self.key1:<br> return self.left<br> elif self.key2 is None:<br> return self.middle<br> elif key&lt;self.key2:<br> return self.middle<br> else:<br> return self.right<br>class 2_3_Tree(object):<br> def __init__(self):<br> self.root=None<br> def get(self,key):<br> if self.root is None:<br> return None<br> else:<br> return self._get(self.root,key)<br> def _get(self,node,key):<br> if node is None:<br> return None<br> elif node.hasKey(key):<br> return node<br> else:<br> child=node.getChild(key)<br> return self._get(child,key)<br> def put(self,key):<br> if self.root is None:<br> self.root=Node(key)<br> else:<br> pKey,pRef=self._put(self.root,key)<br> if pKey is not None:<br> newnode=Node(pKey)<br> newnode.left=self.root<br> newnode.middle=pRef<br> self.root=newnode<br> def _put(self,node,key):<br> if node.hasKey(key):<br> return None,None<br> elif node.isLeaf():<br> return self._addtoNode(node,key,None)<br> else:<br> child=node.getChild(key)<br> pKey,pRef=self._put(child,key)<br> if pKey is None:<br> return None,None<br> else:<br> return self._addtoNode(node,pKey,pRef)<br><br><br> def _addtoNode(self,node,key,pRef):<br> if node.isFull():<br> return self._splitNode(node,key,pRef)<br> else:<br> if key&lt;node.key1:<br> node.key2=node.key1<br> node.key1=key<br> if pRef is not None:<br> node.right=node.middle<br> node.middle=pRef<br> else:<br> node.key2=key<br> if pRef is not None:<br> node.right=Pref<br> return None,None<br> def _splitNode(self,node,key,pRef):<br> newnode=Node(None)<br> if key&lt;node.key1:<br> pKey=node.key1<br> node.key1=key<br> newnode.key1=node.key2<br> if pRef is not None:<br> newnode.left=node.middle<br> newnode.middle=node.right<br> node.middle=pRef<br> elif key&lt;node.key2:<br> pKey=key<br> newnode.key1=node.key2<br> if pRef is not None:<br> newnode.left=Pref<br> newnode.middle=node.right<br> else:<br> pKey=node.key2<br> newnode.key1=key<br> if pRef is not None:<br> newnode.left=node.right<br> newnode.middle=pRef<br> node.key2=None<br> return pKey,newnode<br>3、平衡查找树之红黑树（Red-Black Tree）</p> 
 <p>     红黑树的定义</p> 
 <p>　　    红黑树是一种具有红色和黑色链接的平衡查找树，同时满足： <br>　　     ① 红色节点向左倾斜 ；<br>　　     ②一个节点不可能有两个红色链接；<br>             ③整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。</p> 
 <p>    红黑树的性质</p> 
 <p>           整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同（2-3树的第2）性质，从根节点到叶子节点的距离都相等）。</p> 
 <p> </p> 
 <p>    复杂度分析</p> 
 <p>          最坏的情况就是，红黑树中除了最左侧路径全部是由3-node节点组成，即红黑相间的路径长度是全黑路径长度的2倍。 <br>　　  下图是一个典型的红黑树，从中可以看到最长的路径(红黑相间的路径)是最短路径的2倍：</p> 
 <p> </p> 
 <p>      算法实现</p> 
 <p>#红黑树<br>from random import randint<br><br>RED = 'red'<br>BLACK = 'black'<br><br>class RBT:<br> def __init__(self):<br> # self.items = []<br> self.root = None<br> self.zlist = []<br><br> def LEFT_ROTATE(self, x):<br> # x是一个RBTnode<br> y = x.right<br> if y is None:<br> # 右节点为空，不旋转<br> return<br> else:<br> beta = y.left<br> x.right = beta<br> if beta is not None:<br> beta.parent = x<br><br> p = x.parent<br> y.parent = p<br> if p is None:<br> # x原来是root<br> self.root = y<br> elif x == p.left:<br> p.left = y<br> else:<br> p.right = y<br> y.left = x<br> x.parent = y<br><br> def RIGHT_ROTATE(self, y):<br> # y是一个节点<br> x = y.left<br> if x is None:<br> # 右节点为空，不旋转<br> return<br> else:<br> beta = x.right<br> y.left = beta<br> if beta is not None:<br> beta.parent = y<br><br> p = y.parent<br> x.parent = p<br> if p is None:<br> # y原来是root<br> self.root = x<br> elif y == p.left:<br> p.left = x<br> else:<br> p.right = x<br> x.right = y<br> y.parent = x<br><br> def INSERT(self, val):<br><br> z = RBTnode(val)<br> y = None<br> x = self.root<br> while x is not None:<br> y = x<br> if z.val &lt; x.val:<br> x = x.left<br> else:<br> x = x.right<br><br> z.PAINT(RED)<br> z.parent = y<br><br> if y is None:<br> # 插入z之前为空的RBT<br> self.root = z<br> self.INSERT_FIXUP(z)<br> return<br><br> if z.val &lt; y.val:<br> y.left = z<br> else:<br> y.right = z<br><br> if y.color == RED:<br> # z的父节点y为红色，需要fixup。<br> # 如果z的父节点y为黑色，则不用调整<br> self.INSERT_FIXUP(z)<br><br> else:<br> return<br><br> def INSERT_FIXUP(self, z):<br> # case 1:z为root节点<br> if z.parent is None:<br> z.PAINT(BLACK)<br> self.root = z<br> return<br><br> # case 2:z的父节点为黑色<br> if z.parent.color == BLACK:<br> # 包括了z处于第二层的情况<br> # 这里感觉不必要啊。。似乎z.parent为黑色则不会进入fixup阶段<br> return<br><br> # 下面的几种情况，都是z.parent.color == RED:<br> # 节点y为z的uncle<br> p = z.parent<br> g = p.parent # g为x的grandpa<br> if g is None:<br> return<br> # return 这里不能return的。。。<br> if g.right == p:<br> y = g.left<br> else:<br> y = g.right<br><br> # case 3-0:z没有叔叔。即：y为NIL节点<br> # 注意，此时z的父节点一定是RED<br> if y == None:<br> if z == p.right and p == p.parent.left:<br> # 3-0-0:z为右儿子,且p为左儿子，则把p左旋<br> # 转化为3-0-1或3-0-2的情况<br> self.LEFT_ROTATE(p)<br> p, z = z, p<br> g = p.parent<br> elif z == p.left and p == p.parent.right:<br> self.RIGHT_ROTATE(p)<br> p, z = z, p<br><br> g.PAINT(RED)<br> p.PAINT(BLACK)<br> if p == g.left:<br> # 3-0-1:p为g的左儿子<br> self.RIGHT_ROTATE(g)<br> else:<br> # 3-0-2:p为g的右儿子<br> self.LEFT_ROTATE(g)<br><br> return<br><br> # case 3-1:z有黑叔<br> elif y.color == BLACK:<br> if p.right == z and p.parent.left == p:<br> # 3-1-0:z为右儿子,且p为左儿子,则左旋p<br> # 转化为3-1-1或3-1-2<br> self.LEFT_ROTATE(p)<br> p, z = z, p<br> elif p.left == z and p.parent.right == p:<br> self.RIGHT_ROTATE(p)<br> p, z = z, p<br><br> p = z.parent<br> g = p.parent<br><br> p.PAINT(BLACK)<br> g.PAINT(RED)<br> if p == g.left:<br> # 3-1-1:p为g的左儿子，则右旋g<br> self.RIGHT_ROTATE(g)<br> else:<br> # 3-1-2:p为g的右儿子，则左旋g<br> self.LEFT_ROTATE(g)<br><br> return<br><br><br> # case 3-2:z有红叔<br> # 则涂黑父和叔，涂红爷，g作为新的z，递归调用<br> else:<br> y.PAINT(BLACK)<br> p.PAINT(BLACK)<br> g.PAINT(RED)<br> new_z = g<br> self.INSERT_FIXUP(new_z)<br><br> def DELETE(self, val):<br> curNode = self.root<br> while curNode is not None:<br> if val &lt; curNode.val:<br> curNode = curNode.left<br> elif val &gt; curNode.val:<br> curNode = curNode.right<br> else:<br> # 找到了值为val的元素,正式开始删除<br><br> if curNode.left is None and curNode.right is None:<br> # case1:curNode为叶子节点：直接删除即可<br> if curNode == self.root:<br> self.root = None<br> else:<br> p = curNode.parent<br> if curNode == p.left:<br> p.left = None<br> else:<br> p.right = None<br><br> elif curNode.left is not None and curNode.right is not None:<br> sucNode = self.SUCCESOR(curNode)<br> curNode.val, sucNode.val = sucNode.val, curNode.val<br> self.DELETE(sucNode.val)<br><br> else:<br> p = curNode.parent<br> if curNode.left is None:<br> x = curNode.right<br> else:<br> x = curNode.left<br> if curNode == p.left:<br> p.left = x<br> else:<br> p.right = x<br> x.parent = p<br> if curNode.color == BLACK:<br> self.DELETE_FIXUP(x)<br><br> curNode = None<br> return False<br><br> def DELETE_FIXUP(self, x):<br> p = x.parent<br> # w:x的兄弟结点<br> if x == p.left:<br> w = x.right<br> else:<br> w = x.left<br><br> # case1:x的兄弟w是红色的<br> if w.color == RED:<br> p.PAINT(RED)<br> w.PAINT(BLACK)<br> if w == p.right:<br> self.LEFT_ROTATE(p)<br> else:<br> self.RIGHT_ROTATE(p)<br><br> if w.color == BLACK:<br> # case2:x的兄弟w是黑色的，而且w的两个孩子都是黑色的<br> if w.left.color == BLACK and w.right.color == BLACK:<br> w.PAINT(RED)<br> if p.color == BLACK:<br> return<br> else:<br> p.color = BLACK<br> self.DELETE_FIXUP(p)<br><br> # case3:x的兄弟w是黑色的，而且w的左儿子是红色的，右儿子是黑色的<br> if w.left.color == RED and w.color == BLACK:<br> w.left.PAINT(BLACK)<br> w.PAINT(RED)<br> self.RIGHT_ROTATE(w)<br><br> # case4:x的兄弟w是黑色的，而且w的右儿子是红<br> if w.right.color == RED:<br> p.PAINT(BLACK)<br> w.PAINT(RED)<br> if w == p.right:<br> self.LEFT_ROTATE(p)<br> else:<br> self.RIGHT_ROTATE(p)<br><br> def SHOW(self):<br> self.DISPLAY1(self.root)<br> return self.zlist<br><br> def DISPLAY1(self, node):<br> if node is None:<br> return<br> self.DISPLAY1(node.left)<br> self.zlist.append(node.val)<br> self.DISPLAY1(node.right)<br><br> def DISPLAY2(self, node):<br> if node is None:<br> return<br> self.DISPLAY2(node.left)<br> print(node.val)<br> self.DISPLAY2(node.right)<br><br> def DISPLAY3(self, node):<br> if node is None:<br> return<br> self.DISPLAY3(node.left)<br> self.DISPLAY3(node.right)<br> print(node.val)<br><br>class RBTnode:<br> '''红黑树的节点类型'''<br> def __init__(self, val):<br> self.val = val<br> self.left = None<br> self.right = None<br> self.parent = None<br><br> def PAINT(self, color):<br> self.color = color<br><br>def zuoxuan(b, c):<br> a = b.parent<br> a.left = c<br> c.parent = a<br> b.parent = c<br> c.left = b<br><br>if __name__ == '__main__':<br> rbt=RBT()<br> b = []<br><br> for i in range(100):<br> m = randint(0, 500)<br> rbt.INSERT(m)<br> b.append(m)<br><br> a = rbt.SHOW()<br> b.sort()<br> equal = True<br> for i in range(100):<br> if a[i] != b[i]:<br> equal = False<br> break<br><br> if not equal:<br> print('wrong')<br> else:<br> print('OK!')<br>4、B树和B+树（B Tree/B+ Tree）</p> 
 <p>     B树简介</p> 
 <p>        B 树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。<br>            ①根节点至少有两个子节点；<br>            ②每个节点有M-1个key，并且以升序排列；<br>            ③位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间；<br>            ④非叶子结点的关键字个数=指向儿子的指针个数-1；<br>            ⑤非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] ；<br>            ⑥其它节点至少有M/2个子节点；<br>            ⑦所有叶子结点位于同一层；<br>        如：（M=3）</p> 
 <p> </p> 
 <p>     B树算法思想</p> 
 <p>        B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；<br>     B树的特性</p> 
 <p>        1.关键字集合分布在整颗树中；<br>        2.任何一个关键字出现且只出现在一个结点中；<br>        3.搜索有可能在非叶子结点结束；<br>        4.其搜索性能等价于在关键字全集内做一次二分查找；<br>        5.自动层次控制；<br>        由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为O(LogN)</p> 
 <p><br>     B+ 树简介</p> 
 <p>        B+树是B-树的变体，也是一种多路搜索树：<br>            1.其定义基本与B-树同，除了：<br>            2.非叶子结点的子树指针与关键字个数相同；<br>            3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树<br>            4.B-树是开区间；<br>            5.为所有叶子结点增加一个链指针；<br>            6.所有关键字都在叶子结点出现；</p> 
 <p>        如：（M=3）</p> 
 <p> </p> 
 <p>     B+树算法思想</p> 
 <p>        B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p> 
 <p>    B+树的特性</p> 
 <p>           1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；<br>           2.不可能在非叶子结点命中；<br>           3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；<br>           4.更适合文件索引系统；<br>     算法实现</p> 
 <p># -*- coding: UTF-8 -*-<br># B树查找<br><br>class BTree: #B树<br> def __init__(self,value):<br> self.left=None<br> self.data=value<br> self.right=None<br><br> def insertLeft(self,value):<br> self.left=BTree(value)<br> return self.left<br><br> def insertRight(self,value):<br> self.right=BTree(value)<br> return self.right<br><br> def show(self):<br> print(self.data)<br><br><br>def inorder(node): #中序遍历：先左子树，再根节点，再右子树<br> if node.data:<br> if node.left:<br> inorder(node.left)<br> node.show()<br> if node.right:<br> inorder(node.right)<br><br><br>def rinorder(node): #倒中序遍历<br> if node.data:<br> if node.right:<br> rinorder(node.right)<br> node.show()<br> if node.left:<br> rinorder(node.left)<br><br>def insert(node,value):<br> if value &gt; node.data:<br> if node.right:<br> insert(node.right,value)<br> else:<br> node.insertRight(value)<br> else:<br> if node.left:<br> insert(node.left,value)<br> else:<br> node.insertLeft(value)<br><br><br>if __name__ == "__main__":<br><br> l=[88,11,2,33,22,4,55,33,221,34]<br> Root=BTree(l[0])<br> node=Root<br> for i in range(1,len(l)):<br> insert(Root,l[i])<br><br> print("中序遍历（从小到大排序 ）")<br> inorder(Root)<br> print("倒中序遍历（从大到小排序）")<br> rinorder(Root)<br>5、树表查找总结</p> 
 <p>　　二叉查找树平均查找性能不错，为O(logn)，但是最坏情况会退化为O(n)。在二叉查找树的基础上进行优化，我们可以使用平衡查找树。平衡查找树中的2-3查找树，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。 <br>　　除此之外，2-3查找树的另一个扩展——B/B+平衡树，在文件系统和数据库系统中有着广泛的应用。</p> 
 <p>分块查找</p> 
 <p>算法简介</p> 
 <p>        要求是顺序表，分块查找又称索引顺序查找，它是顺序查找的一种改进方法。 </p> 
 <p>算法思想</p> 
 <p>        将n个数据元素"按块有序"划分为m块（m ≤ n）。<br>        每一块中的结点不必有序，但块与块之间必须"按块有序"；<br>        即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；<br>        而第2块中任一元素又都必须小于第3块中的任一元素，……</p> 
 <p><br>算法流程　</p> 
 <p>        1、先选取各块中的最大关键字构成一个索引表；<br>        2、查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；<br>        3、在已确定的块中用顺序法进行查找。</p> 
 <p>复杂度分析</p> 
 <p>        时间复杂度：O(log(m)+N/m)</p> 
 <p>哈希查找</p> 
 <p>算法简介</p> 
 <p>        哈希表就是一种以键-值(key-indexed) 存储数据的结构，只要输入待查找的值即key，即可查找到其对应的值。</p> 
 <p>算法思想</p> 
 <p>        哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。</p> 
 <p>算法流程</p> 
 <p>　　1）用给定的哈希函数构造哈希表；<br>　　2）根据选择的冲突处理方法解决地址冲突；<br>　　　　  常见的解决冲突的方法：拉链法和线性探测法。<br>　　3）在哈希表的基础上执行哈希查找。</p> 
 <p>复杂度分析</p> 
 <p>　　单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。</p> 
 <p>算法实现</p> 
 <p># 忽略了对数据类型，元素溢出等问题的判断。<br> <br>class HashTable:<br>  def __init__(self, size):<br>    self.elem = [None for i in range(size)] # 使用list数据结构作为哈希表元素保存方法<br>    self.count = size # 最大表长<br> <br>  def hash(self, key):<br>    return key % self.count # 散列函数采用除留余数法<br> <br>  def insert_hash(self, key):<br>    """插入关键字到哈希表内"""<br>    address = self.hash(key) # 求散列地址<br>    while self.elem[address]: # 当前位置已经有数据了，发生冲突。<br>      address = (address+1) % self.count # 线性探测下一地址是否可用<br>    self.elem[address] = key # 没有冲突则直接保存。<br> <br>  def search_hash(self, key):<br>    """查找关键字，返回布尔值"""<br>    star = address = self.hash(key)<br>    while self.elem[address] != key:<br>      address = (address + 1) % self.count<br>      if not self.elem[address] or address == star: # 说明没找到或者循环到了开始的位置<br>        return False<br>    return True<br> <br> <br>if __name__ == '__main__':<br>  list_a = [12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34]<br>  hash_table = HashTable(12)<br>  for i in list_a:<br>    hash_table.insert_hash(i)<br> <br>  for i in hash_table.elem:<br>    if i:<br>      print((i, hash_table.elem.index(i)), end=" ")<br>  print("\n")<br> <br>  print(hash_table.search_hash(15))<br>  print(hash_table.search_hash(33))</p> 
 <p> </p> 
</div> 
<p>转载于:https://www.cnblogs.com/chengchengaqin/p/10528578.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2bd419b8349a2b7f7a1ac1a8243e8b4f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">windows系统composer安装使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bdb9d9167890ade90f27caa5b1215e77/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">打包2阶段-使用reshacker修改打包信息</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>