<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java集合（1） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java集合（1）" />
<meta property="og:description" content="Java集合类是一种特别有用的工具类，可用于存储数量不等的对象，并实现常用的数据结构，如栈，队列等。Java集合大致可分为set,List,queue,和map，其中Set代表无序，不可重复的集合，List代表有序，可重复的集合。集合类和数组是不一样的，数组中的元素可以是基本类型，也可以是对象（实际上保存的是对象的引用变量）；而集合里只能保存对象（实际上保存的是对象的引用变量,但是通常习惯上认为集合里保存的是对象）。Collection和Map是Java集合框架的根接口。
Collection集合体系的继承树：
Map集合体系的继承树：
Collection接口是List、Set和Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和Queue集合。Collection接口的操作如下操作集合元素的方法。
boolean add(Object e) ： 该方法用于向集合中添加一个元素，如果添加元素成功返回true。 boolean addAll(Collection c) ：把集合c中的所有元素都添加到此 指定的集合中。 voidclear() ：删除集合里的所有元素，将集合长度变为0。 boolean contains(Object o) ：判断集合是否包含指定的元素o,如果包含返回true。
boolean containsAll(Collection c) ：判断集合是否包含指定的集合c中所有的元素,如果包含返回true。
int hashCode() ：返回此collection 的哈希码值。 boolean isEmpty() ：如果此collection 不包含元素，则返回 true。 boolean remove(Object o) ：删除集合中指定的元素o, 当集合中包含了一个或多个元素o时该方法只删除第一个符合条件的元素，该方法将返回true。
booleanremoveAll(Collection&lt;?&gt; c) ：从集合中删除集合c中包含的所有元素（相当于用调用该方法的集合减去集合c）如果删除一个或一个以上的元素，返回true,。
boolean retainAll(Collection&lt;?&gt; c) :仅保留此 collection 中那些也包含在指定 collection 的元素,如果该操作改变了调用该方法的集合，则返回true
intsize() :返回此 collection 中的元素数。 Object[] toArray() :该方法把集合转换成一个数组，所有的集合元素变成对应的数组元素。
用Collection集合的一些方法操作集合里的元素。
使用Lambda表达式遍历集合 Java8为Iterable接口新增了一个forEach（Consumer action） 默认方法，该方法所需的类型是一个函数式接口，而Iteratle接口是Collection接口的父接口，因此Collection集合也直接调用该方法。
当程序调用Iterable的forEach(Consumeraction)遍历集合元素时，程序会依次将集合元素传给Consumer的accept（T t）方法（该接口唯一的抽象方法）。正因为Consumer是函数式接口，因此可以使用Lambda表达式来遍历集合元素。
使用Lambda表达式来遍历集合元素。
public class CollectionEach {
public static void main(String[] args) {" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/abcc537ba7923f22851c2926d00b0be6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-07-01T21:01:12+08:00" />
<meta property="article:modified_time" content="2017-07-01T21:01:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java集合（1）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Java集合类是一种特别有用的工具类，可用于存储数量不等的对象，并实现常用的数据结构，如栈，队列等。Java集合大致可分为set,List,queue,和map，其中Set代表无序，不可重复的集合，List代表有序，可重复的集合。集合类和数组是不一样的，数组中的元素可以是基本类型，也可以是对象（实际上保存的是对象的引用变量）；而集合里只能保存对象（实际上保存的是对象的引用变量,但是通常习惯上认为集合里保存的是对象）。Collection和Map是Java集合框架的根接口。</p> 
<p>Collection集合体系的继承树：<img src="https://images2.imgbox.com/56/53/hmnipZ6W_o.png" alt=""></p> 
<p></p> 
<p>Map集合体系的继承树：</p> 
<p> <img src="https://images2.imgbox.com/04/60/8oGKRfcV_o.png" alt=""></p> 
<p></p> 
<p><br> Collection接口是List、Set和Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和Queue集合。Collection接口的操作如下操作集合元素的方法。</p> 
<p>boolean add(Object e) ： 该方法用于向集合中添加一个元素，如果添加元素成功返回true。 </p> 
<p> boolean addAll(Collection c) ：把集合c中的所有元素都添加到此 指定的集合中。 </p> 
<p> voidclear() ：删除集合里的所有元素，将集合长度变为0。 </p> 
<p> boolean contains(Object o) ：判断集合是否包含指定的元素o,如果包含返回true。</p> 
<p> boolean containsAll(Collection c) ：判断集合是否包含指定的集合c中所有的元素,如果包含返回true。</p> 
<p>int hashCode() ：返回此collection 的哈希码值。 </p> 
<p> boolean isEmpty() ：如果此collection 不包含元素，则返回 true。 </p> 
<p> boolean remove(Object o) ：删除集合中指定的元素o, 当集合中包含了一个或多个元素o时该方法只删除第一个符合条件的元素，该方法将返回true。</p> 
<p> booleanremoveAll(Collection&lt;?&gt; c) ：从集合中删除集合c中包含的所有元素（相当于用调用该方法的集合减去集合c）如果删除一个或一个以上的元素，返回true,。</p> 
<p> boolean retainAll(Collection&lt;?&gt; c) :仅保留此 collection 中那些也包含在指定 collection 的元素,如果该操作改变了调用该方法的集合，则返回true</p> 
<p> intsize() :返回此 collection 中的元素数。 </p> 
<p> Object[] toArray() :该方法把集合转换成一个数组，所有的集合元素变成对应的数组元素。</p> 
<p>用Collection集合的一些方法操作集合里的元素。</p> 
<h4>使用Lambda表达式遍历集合</h4> 
<p>Java8为Iterable接口新增了一个forEach（Consumer action） 默认方法，该方法所需的类型是一个函数式接口，而Iteratle接口是Collection接口的父接口，因此Collection集合也直接调用该方法。</p> 
<p>当程序调用Iterable的forEach(Consumeraction)遍历集合元素时，程序会依次将集合元素传给Consumer的accept（T t）方法（该接口唯一的抽象方法）。正因为Consumer是函数式接口，因此可以使用Lambda表达式来遍历集合元素。</p> 
<p>使用Lambda表达式来遍历集合元素。</p> 
<p align="left"><strong><span style="color:#7F0055">public</span> <span style="color:#7F0055"> class</span></strong> CollectionEach {<!-- --></p> 
<p align="left">  <strong><span style="color:#7F0055">public</span> <span style="color:#7F0055"> static</span> <span style="color:#7F0055">void</span></strong> main(String[] <span style="color:#6A3E3E"> args</span>) {<!-- --></p> 
<p align="left">     <u>Collection</u> <span style="color:#6A3E3E">books</span>=<strong><span style="color:#7F0055">new</span></strong> <u>HashSet</u>();</p> 
<p align="left">     <u><span style="color:#6A3E3E">books</span>.add(<span style="color:#2A00FF">"java ee"</span>)</u>;</p> 
<p align="left">     <u><span style="color:#6A3E3E">books</span>.add(<span style="color:#2A00FF">"java</span><span style="color:#2A00FF">讲义</span><span style="color:#2A00FF">"</span>)</u>;</p> 
<p align="left">     <u><span style="color:#6A3E3E">books</span>.add(<span style="color:#2A00FF">"javaweb</span><span style="color:#2A00FF">讲义</span><span style="color:#2A00FF">"</span>)</u>;</p> 
<p align="left">     <u><span style="color:#6A3E3E">books</span>.forEach(<span style="color:#6A3E3E">obj</span>-&gt;System.</u><strong><em><u><span style="color:#0000C0">out</span></u></em></strong><u>.println(<span style="color:#2A00FF">"</span><span style="color:#2A00FF">迭代集合元素：</span><span style="color:#2A00FF">"</span>+<span style="color:#6A3E3E">obj</span>))</u>;</p> 
<p align="left">  }</p> 
<p align="left">}</p> 
<h4>使用Iterator遍历集合元素</h4> 
<p>Iterator接口也是Java集合框架的成员，但它与Collection系列、Map系列的集合不一样：Collection系列集合、Map系列集合主要用于盛装其他对象，而Iterator则主要用于遍历（即迭代访问）Collection集合中的元素，Iterator对象也被称为迭代器。</p> 
<p>Iterator接口里定义了如下4个方法：</p> 
<p>-boolean hasNext()：如果被迭代的集合还元素没有被遍历，则返回true。</p> 
<p>-Object next()：返回集合里下一个元素。</p> 
<p>-void remove() ：删除集合里上一次next方法返回的元素 </p> 
<p>-void forEachRemaining(Consumer action)，这是Java 8为Iterator新增的默认方法，该方法可使用Iterator接口来遍历集合元素。</p> 
<p>public class CollectionEach {<!-- --></p> 
<p>       publicstatic void main(String[] args) {<!-- --></p> 
<p>              Collectionbooks=new HashSet();</p> 
<p>              books.add("javaee");</p> 
<p>              books.add("java讲义");</p> 
<p>              books.add("javaweb讲义");</p> 
<p>              Iteratorit=books.iterator();</p> 
<p>              while(it.hasNext()){<!-- --></p> 
<p>                     Stringbook=(String)it.next();</p> 
<p>                     System.out.println(book);</p> 
<p>                     if(book.equals("javaee")){<!-- --></p> 
<p>                            //从集合中删除上一次next()方法返回的元素</p> 
<p>                            it.remove();</p> 
<p>                     }</p> 
<p>//对book变量赋值，不会改变集合元素本身</p> 
<p>                     book="测试数据";</p> 
<p>              }</p> 
<p>              System.out.println("----------------");</p> 
<p>              System.out.println(books);</p> 
<p>       }</p> 
<p>}</p> 
<p>Iterabor仅用于遍历集合，Iterator本身并不提供盛装对象的能力，没有集合的Iterator仿佛无本之木，没有存在的价值。</p> 
<p> </p> 
<p>当使用Iterabor循环迭代访问集合元素时，该集合的元素不能被改变只有通过Iterabor的remove()方法删除上一次next()方法返回的集合元素才可以，否则将引发ConcurrentModificationException异常下面为程序示范了这一点。</p> 
<p>public class CollectionEach {<!-- --></p> 
<p>       publicstatic void main(String[] args) {<!-- --></p> 
<p>              Collectionbooks=new HashSet();</p> 
<p>              books.add("javaee");</p> 
<p>              books.add("java讲义");</p> 
<p>              books.add("javaweb讲义");</p> 
<p>              Iteratorit=books.iterator();</p> 
<p>              it.forEachRemaining(obj-&gt;System.out.println("books:"+obj));</p> 
<p>              for(Objectobj:books){<!-- --></p> 
<p>                     Stringbook=(String)obj;</p> 
<p>                     System.out.println(book);</p> 
<p>                     if(book.equals("javaee")){<!-- --></p> 
<p>                            //使用Iterator迭代过程中，不可修改集合元素，下面代码引发异常</p> 
<p>                            books.remove(book);</p> 
<p>                     }</p> 
<p>              }</p> 
<p>       }</p> 
<p>}</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7026244ab6489d8fce346fa48b298c6a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">An entity object cannot be referenced by multiple instances of IEntityChangeTracker错误解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0b541a04300e749d043d002c8be5704e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java集合(2)HashSet</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>