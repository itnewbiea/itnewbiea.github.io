<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Qt学习笔记 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Qt学习笔记" />
<meta property="og:description" content="信号与槽函数 解释 （1）信号和槽是用于QT对象之间的通信，信号可以有某种动作触发，也可以直接由代码触发。
（2）槽也叫操函数，当完成了信号和槽的连接之后，一旦触发信号，自动调用连接的槽函数。
（3）信号和槽的连接是动态的，对象释放后会自动断开所有的信号和槽。
（4）代码触发信号的写法
什么是信号和槽 信号和槽是用于对象之间的通信，它是Qt的核心机制，在Qt编程中有着广泛的应用。如果想学好Qt，一定要充分掌握信号的槽的概念与使用。
举个例子，在一个十字路口，信号灯变成了绿色，对面的汽车看到后就启动了。信号灯就是发送信号的对象，绿灯亮是它发送的信号 (signal)，汽车是接收对象，汽车行驶是汽车对信号的响应，也叫槽 (slot)。
再举一个例子，比如在一个主窗口内有一个关闭按钮，如果点击这个按钮窗口就会关闭，那么关闭按钮是发送信号的对象，它发送的信号是点击，接收信号的对象是窗口，响应信号的槽是关闭窗口。
添加信号 关键字signals定义一个信号，信号不能也无需实现，并且返回值是void，信号与槽方法都可以携带参数，但是槽方法的参数类型必须是信号参数类型保持一致或者少于信号参数
signals: void Commeon(QString&amp; str); //信号不能也无需实现，且返回值是void 发送信号 使用emit关键字发送信号 。我们可以在任何地方使用emit关键字发送信号，包括在槽方法内
void MainWindow::on_whBtn_clicked() { QString str=&#34;武汉&#34;; emit Commeon(str); } void MainWindow::on_zgBtn_clicked() { QString str=&#34;中国&#34;; emit Commeon(str); } void MainWindow::on_sjBtn_clicked() { QString str=&#34;世界&#34;; emit Commeon(str); } 信号与槽连接 QMetaObject::Connection QObject::connect( const QObject *sender, //信号发送者 const char *signal, //发送的信号 const QObject *receiver, //信号接收者 const char *method, //表示与信号连接的方式的字符串，可以是槽或信号 Qt::ConnectionType type = Qt::AutoConnection //连接方式，默认自动连接 ) 常用格式：connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/da39a2c63f309ca1d83048792d486601/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-11T20:36:02+08:00" />
<meta property="article:modified_time" content="2023-02-11T20:36:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Qt学习笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h2 style="">信号与槽函数 </h2> 
 <h3 style="">解释</h3> 
 <p style="">（1）信号和槽是用于QT对象之间的通信，信号可以有某种动作触发，也可以直接由代码触发。</p> 
 <p style="">（2）槽也叫操函数，当完成了信号和槽的连接之后，一旦触发信号，自动调用连接的槽函数。</p> 
 <p style="">（3）信号和槽的连接是动态的，对象释放后会自动断开所有的信号和槽。</p> 
 <p style="">（4）代码触发信号的写法</p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">什么是信号和槽</span></h3> 
 <p style="">信号和槽是用于对象之间的通信，它是Qt的核心机制，在Qt编程中有着广泛的应用。如果想学好Qt，一定要充分掌握信号的槽的概念与使用。</p> 
 <p style="">举个例子，在一个十字路口，信号灯变成了绿色，对面的汽车看到后就启动了。信号灯就是发送信号的对象，绿灯亮是它发送的信号 (signal)，汽车是接收对象，汽车行驶是汽车对信号的响应，也叫槽 (slot)。</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:265px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:82.26415%;height:0;"> 
    <img src="https://images2.imgbox.com/64/17/e4KFcjdi_o.png" style="margin-left:;display:block;width:265px;margin-top:-82.26415%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">再举一个例子，比如在一个主窗口内有一个关闭按钮，如果点击这个按钮窗口就会关闭，那么关闭按钮是发送信号的对象，它发送的信号是点击，接收信号的对象是窗口，响应信号的槽是关闭窗口。</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:268px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:82.089554%;height:0;"> 
    <img src="https://images2.imgbox.com/8f/56/7bhWZTeY_o.png" style="margin-left:;display:block;width:268px;margin-top:-82.089554%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">添加信号</span></h3> 
 <p style="">关键字signals定义一个信号，信号不能也无需实现，并且返回值是void，信号与槽方法都可以携带参数，但是槽方法的参数类型必须是信号参数类型保持一致或者少于信号参数</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">signals:
    void Commeon(QString&amp; str); //信号不能也无需实现，且返回值是void</code></pre> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">发送信号</span></h3> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">使用emit关键字发送信号</span> 。我们可以在任何地方使用emit关键字发送信号，包括在槽方法内</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">void MainWindow::on_whBtn_clicked()
{
    QString str="武汉";
    emit Commeon(str);
}
 
void MainWindow::on_zgBtn_clicked()
{
    QString str="中国";
    emit Commeon(str);
}
 
void MainWindow::on_sjBtn_clicked()
{
    QString str="世界";
    emit Commeon(str);
}</code></pre> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">信号与槽连接</span></h3> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">QMetaObject::Connection QObject::connect(
const QObject *sender, //信号发送者
const char *signal, //发送的信号
const QObject *receiver, //信号接收者
const char *method, //表示与信号连接的方式的字符串，可以是槽或信号
Qt::ConnectionType type = Qt::AutoConnection //连接方式，默认自动连接
 
)</code></pre> 
 <p style=""> 常用格式：connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));</p> 
 <p style=""> 信号使用SIGNAL，对于槽则使用SLOT，用它们将函数的原型包围起来即可。注意connect方法采用SIGNAL()及SLOT()时，这里的函数原型只能写出类型，不能有任何参数名，否则连接将会失败。</p> 
 <blockquote class="kdocs-blockquote" style="">
   同时信号与槽连接方式： 
  <br>Qt::AutoConnection：(默认连接方式)自动方式，由系统自动选择连接方式。 
  <br>Qt::DirectConnection：直接方式，信号发射时，立即调用槽。 
  <br>Qt::QueuedConnection：队列方式，信号发射时产生一个事件进入队列，事件被处理时槽才能调用。 
  <br>Qt::BlockQueuedConnection：阻塞队列方式，信号发射时产生一个事件进入队列，然后当前线程进入阻塞状态，直到事件处理完毕，若接收方位于发送信号的线程中，则程序会死锁，故此连接方式仅用于多线程。 
 </blockquote> 
 <p style=""> 也可以不使用SIGNAL和SLOT，直接信号和槽的地址。</p> 
 <blockquote class="kdocs-blockquote" style="">
   connect(this,&amp;MainWindow::Common,this,&amp;MainWindow::CommonGuys); 
 </blockquote> 
 <p style=""> 信号可以看做是特殊的函数，需要带括号，可带参数，信号无需实现也不能实现。槽函数需要带括号，有参数时还需要指明参数。当信号和槽函数带有参数时，在 connect()函数里，要写明参数的类型。信号的参数需与槽的参数列表一致,允许比槽参数多。如果不匹配或参数过少，会出现编译错误或运行错误。在使用信号与槽的类中，必须在类的定义中加入宏 Q_OBJECT。当一个信号被发射时，与其关联的槽函数通常被立即执行，就像正常调用一个函数一样。只有当信号关联的所有槽函数执行完毕后，才会执行发射信号处后面的代码。 </p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">连接类型</span></h3> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">一对一</span></h4> 
 <p style="">声明两个信号signal1、signal2 和一个槽方法slot( )，将信号signal1与信号signal2相连，信号signal2与槽方法slot( )相连</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">signals:
    void signal1();
    void signal2();
private slots:
    void slot();</code></pre> 
 <p style="">槽方法实现</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">void MainWindow::slot()
{
    qDebug()&lt;&lt;"我爱QT编程";
}</code></pre> 
 <p style="text-align:null;">在构造函数中将信号与信号，信号与槽方法相连</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext"> connect(this,SIGNAL(signal1()),this,SIGNAL(signal2()));
connect(this,SIGNAL(signal2()),this,SLOT(slot()));</code></pre> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">一对多</span></h4> 
 <p style="text-align:null;">声明一个信号和多个槽方法 </p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext"> signals:
    void comeon(QString&amp;str);
private slots:
    void comeon1();
    void comeon2();
    void comeon3();</code></pre> 
 <p style="">槽方法实现 </p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">void MainWindow::comeon1()
{
    qDebug()&lt;&lt;"我爱编程";
}
 
void MainWindow::comeon2()
{
    qDebug()&lt;&lt;"我爱QT";
}
 
void MainWindow::comeon3()
{
    qDebug()&lt;&lt;"我爱QT编程";
}</code></pre> 
 <p style="">在构造函数中将信号与槽方法连接</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">connect(this,SIGNAL(comeon(QString&amp;)),this,SLOT(comeon1()));
connect(this,SIGNAL(comeon(QString&amp;)),this,SLOT(comeon2()));
connect(this,SIGNAL(comeon(QString&amp;)),this,SLOT(comeon3()));</code></pre> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">信号与槽断开连接 </span></h3> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">QObject::disconnect(
    const QObject* sender,
    const char* signal,
    const QObject *receiver,
    const char* method
);</code></pre> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">信号与槽机制的优越性</span></h3> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>信号与槽机制是类型安全的，相关联的信号与槽参数必须匹配</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>信号与槽是松耦合的，信号发送者不知道也不需知道接受者的信息。</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>信号与槽可以使用任意类型的任意数量的参数。</p></li></ol> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8ce6a4a79de8ada73c8d91460cd4f045/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python3 -m http.server 80</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f127b985228bc7ff90a94741e0f5799f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c#反射-执行方法和创建实例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>