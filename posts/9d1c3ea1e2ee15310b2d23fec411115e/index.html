<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>dyn_threshold对物体轮廓提取很有用的一个阈值分割算子 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="dyn_threshold对物体轮廓提取很有用的一个阈值分割算子" />
<meta property="og:description" content="先来看看这个算子的参数选择：
dyn_threshold(OrigImage, ThresholdImage : RegionDynThresh : Offset, LightDark : )
ThresholdImage是我们用来作为灰度值参考的另外一幅图像，在实际使用过程中通常都是对原图像OrigImage进行一次平滑处理，然后用平滑处理之后得到的图像作为参考图像。
LightDark是问我们提取亮？暗？还是相似的区域？（当然，这是相对于ThresholdImage）
Offset其实是在设定一个比较的区间范围，因为在图像处理这个主观性本来就比较强的领域中“绝对”这个科学名次实在有点太过分，所以什么事情，只要在一个合理的范围内，我们都是可以接受的，而不是死死抓住一个点不放，最后也得不到想要的结果。
dyn_threshold 这个算子就是根据一套灰度值比较规则来选择原图像中那些灰度值符合这个公式的像素点。
令 g_{o} = g_{OrigImage}, g_{t} = g_{ThresholdImage}分别代表原图和参考图中的像素点的灰度值.
我们的做法是把参考图像的灰度值加上（减去）一个Offset，然后去和原图的像素点逐像素对应地进行比较。
下面看Halcon中给出的这些公式：
The condition for LightDark = ‘light’ is:
g_o &gt;= g_t &#43; Offset 既然选择light，那就代表提取相对参考图来说亮一些的地方，那么自然要选择那些灰度值比g_t &#43; Offset要大的像素点。
For LightDark = ‘dark’ the condition is:
g_o &lt;= g_t – Offset 如果要提取的是比参考图要暗一些的区域，那么自然要选择比g_t的灰度值要小的那些像素点，但是这样直接比较的话提取的小区域太多了，并没有很好地提取出相对参考图来说很明显有差别的那部分，所以我们才给定Offset这个参数用来修正。这样给参考图的灰度值一减掉Offset，提取出来的和参考的之间的差距就会很明显。
For LightDark = ‘equal’ it is:
g_t - Offset &lt;= g_o &lt;= g_t &#43; Offset 选择equal的意思是选择那些和参考图的差不多的，只要在这个合理的范围内的都算。
Finally, for LightDark = ‘not_equal’ it is:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/9d1c3ea1e2ee15310b2d23fec411115e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-18T16:29:21+08:00" />
<meta property="article:modified_time" content="2019-01-18T16:29:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">dyn_threshold对物体轮廓提取很有用的一个阈值分割算子</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>先来看看这个算子的参数选择：</p> 
<p>dyn_threshold(OrigImage, ThresholdImage : RegionDynThresh : Offset, LightDark : )</p> 
<p>ThresholdImage是我们用来作为灰度值参考的另外一幅图像，在实际使用过程中通常都是对原图像OrigImage进行一次平滑处理，然后用平滑处理之后得到的图像作为参考图像。</p> 
<p>LightDark是问我们提取亮？暗？还是相似的区域？（当然，这是相对于ThresholdImage）</p> 
<p>Offset其实是在设定一个比较的区间范围，因为在图像处理这个主观性本来就比较强的领域中“绝对”这个科学名次实在有点太过分，所以什么事情，只要在一个合理的范围内，我们都是可以接受的，而不是死死抓住一个点不放，最后也得不到想要的结果。</p> 
<p>dyn_threshold 这个算子就是根据一套灰度值比较规则来选择原图像中那些灰度值符合这个公式的像素点。</p> 
<p>令 g_{o} = g_{OrigImage}, g_{t} = g_{ThresholdImage}分别代表原图和参考图中的像素点的灰度值.</p> 
<p>我们的做法是把参考图像的灰度值加上（减去）一个Offset，然后去和原图的像素点逐像素对应地进行比较。</p> 
<p>下面看Halcon中给出的这些公式：</p> 
<p>The condition for LightDark = ‘light’ is:</p> 
<pre><code>             g_o &gt;= g_t + Offset
</code></pre> 
<p>既然选择light，那就代表提取相对参考图来说亮一些的地方，那么自然要选择那些灰度值比g_t + Offset要大的像素点。<br> For LightDark = ‘dark’ the condition is:</p> 
<pre><code>             g_o &lt;= g_t – Offset
</code></pre> 
<p>如果要提取的是比参考图要暗一些的区域，那么自然要选择比g_t的灰度值要小的那些像素点，但是这样直接比较的话提取的小区域太多了，并没有很好地提取出相对参考图来说很明显有差别的那部分，所以我们才给定Offset这个参数用来修正。这样给参考图的灰度值一减掉Offset，提取出来的和参考的之间的差距就会很明显。<br> For LightDark = ‘equal’ it is:</p> 
<pre><code>             g_t - Offset &lt;= g_o &lt;= g_t + Offset
</code></pre> 
<p>选择equal的意思是选择那些和参考图的差不多的，只要在这个合理的范围内的都算。<br> Finally, for LightDark = ‘not_equal’ it is:</p> 
<pre><code>             g_t - Offset &gt; g_o or g_o &gt; g_t + Offset
</code></pre> 
<p>反正只要不是差不多的就不选，亮的暗的无所谓。</p> 
<p>一般来说，我们所用的ThresholdImage都是原图像的一个平滑图，比如用 mean_image, binomial_filter, gauss_image 等算子处理之后的图像，因此这个算子的作用类似于给一个经过了Highpass Filter处理的图像进行threshold。这句话的意思其实很好理解，因为Highpass的作用是抑制图像中那些高频信号也就是灰度值变化比较大的地方，所以处理之后图像会变的比较平滑。</p> 
<p>经过dyn_threshold这个算子处理之后，我们就可以提取一个物体的轮廓了，具体提取的方法当然要用到什么类似select_shape之类的算子，当然，这里最重要的是gen_contour_region_xld这个算子，用你刚才提取出来的这些区域生成XLD轮廓线，这样就达到了提取物体轮廓的目的。</p> 
<p>所选择的模板越大，找到的region就会越大。一般来说，模板的大小应该是我们要提取的物体直径大小的两倍左右。还有很重要的一点是最好不要把Offset这个变量设置为0，因为这样会导致最后找到太多很小的regions，而这基本上都是噪声。所以这个值最好是在5-40之间，值选择的越大，提取出来的regions就会越小。</p> 
<p>注意，我们这样提取出来的所有符合条件的像素点都会被返回到一个region中去，所以如果你要分开的区域的话，就用connection这个算子再计算一下就好啦。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/225ccac2652f09dc2ba2eaf885ac3377/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">推荐算法技术架构</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fc3e76b2d0b0edb71573c603a5e3d9a8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【CMD命令学习】使用CMD的copy /b命令合并两个文件，分离两个文件。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>