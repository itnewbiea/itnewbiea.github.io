<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>（八）k8s安全 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="（八）k8s安全" />
<meta property="og:description" content="1、机制说明 Kubernetes 作为一个分布式集群的管理工具，保证集群的安全性是其一个重要的任务。API Server 是集群内部各个组件通信的中介，也是外部控制的入口。所以 Kubernetes 的安全机制基本就是围绕保护 API Server 来设计的。Kubernetes 使用了认证（Authentication）、鉴权（Authorization）、准入控制（AdmissionControl）三步来保证API Server的安全
从上面这张图我们可以看出，无论是用户还是我们k8s内部的pod都需要走这个流程。先认证，再判断你是否有权限，最后放行。
2、认证 （Authentication） 默认提供了三种认证方式，如下：
HTTP Token 认证：通过一个 Token 来识别合法用户 （服务器单向检测客户端） HTTP Token 的认证是用一个很长的特殊编码方式的并且难以被模仿的字符串 - Token 来表达客户的一种方式。Token 是一个很长的很复杂的字符串，每一个 Token 对应一个用户名存储在 API Server 能访问的文件中。当客户端发起 API 调用请求时，需要在 HTTP Header 里放入 Token，服务端检验token是否正确
HTTP Base 认证：通过 用户名&#43;密码 的方式认证 （服务器单向检测客户端） 用户名&#43;：&#43;密码 用 BASE64 算法进行编码后的字符串放在 HTTP Request 中的 Heather
Authorization 域里发送给服务端，服务端收到后进行编码，获取用户名及密码
最严格的 HTTPS 证书认证：基于 CA 根证书签名的客户端身份认证方式 （服务器和客户端互相检测对象是否正常），这个是k8s默认采用的方式 2.1、HTTPS 证书认证流程 HTTPS 证书认证，其认证流程如下，其实就是双方都要从第三方获取证书，认证的时候再发给对方去检查。
2.2、需要认证的节点 上图包含两种类型
Kubenetes 组件对 API Server 的访问：kubectl、Controller Manager、Scheduler、kubelet、kube-proxyKubernetes 管理的 Pod 对容器的访问：Pod（dashborad 也是以 Pod 形式运行） 换句话说就是这样" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ee7dfb97ceb7240da89dc98890cd7a48/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-12T17:16:50+08:00" />
<meta property="article:modified_time" content="2022-05-12T17:16:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">（八）k8s安全</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_0"></a>1、机制说明</h2> 
<p>Kubernetes 作为一个分布式集群的管理工具，保证集群的安全性是其一个重要的任务。API Server 是集群内部各个组件通信的中介，也是外部控制的入口。所以 Kubernetes 的安全机制基本就是围绕保护 API Server 来设计的。Kubernetes 使用了<code>认证（Authentication）</code>、<code>鉴权（Authorization）</code>、<code>准入控制（AdmissionControl）</code>三步来保证API Server的安全</p> 
<p><img src="https://images2.imgbox.com/c5/af/iOvmQwZF_o.png" alt="在这里插入图片描述"><br> 从上面这张图我们可以看出，无论是用户还是我们k8s内部的pod都需要走这个流程。先认证，再判断你是否有权限，最后放行。</p> 
<h2><a id="2_Authentication_6"></a>2、认证 （Authentication）</h2> 
<p>默认提供了三种认证方式，如下：</p> 
<ul><li>HTTP Token 认证：通过一个 Token 来识别合法用户 <strong>（服务器单向检测客户端）</strong></li></ul> 
<blockquote> 
 <p>HTTP Token 的认证是用一个很长的特殊编码方式的并且难以被模仿的字符串 - Token 来表达客户的一种方式。Token 是一个很长的很复杂的字符串，每一个 Token 对应一个用户名存储在 API Server 能访问的文件中。当客户端发起 API 调用请求时，需要在 HTTP Header 里放入 Token，服务端检验token是否正确</p> 
</blockquote> 
<ul><li>HTTP Base 认证：通过 用户名+密码 的方式认证 <strong>（服务器单向检测客户端）</strong></li></ul> 
<blockquote> 
 <p>用户名+：+密码 用 BASE64 算法进行编码后的字符串放在 HTTP Request 中的 Heather<br> Authorization 域里发送给服务端，服务端收到后进行编码，获取用户名及密码</p> 
</blockquote> 
<ul><li>最严格的 HTTPS 证书认证：基于 CA 根证书签名的客户端身份认证方式 <strong>（服务器和客户端互相检测对象是否正常），这个是k8s默认采用的方式</strong></li></ul> 
<h3><a id="21HTTPS__19"></a>2.1、HTTPS 证书认证流程</h3> 
<p>HTTPS 证书认证，其认证流程如下，其实就是双方都要从第三方获取证书，认证的时候再发给对方去检查。</p> 
<p><img src="https://images2.imgbox.com/02/59/E5bX2MZB_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="22_25"></a>2.2、需要认证的节点</h3> 
<p><img src="https://images2.imgbox.com/51/75/HA3hDSiR_o.png" alt="在这里插入图片描述"></p> 
<p>上图包含两种类型</p> 
<ul><li>Kubenetes 组件对 API Server 的访问：kubectl、Controller Manager、Scheduler、kubelet、kube-proxy</li><li>Kubernetes 管理的 Pod 对容器的访问：Pod（dashborad 也是以 Pod 形式运行）</li></ul> 
<p>换句话说就是这样<br> <img src="https://images2.imgbox.com/59/26/Nxw26yBj_o.png" alt="在这里插入图片描述"></p> 
<p>安全性说明</p> 
<ul><li>Controller Manager、Scheduler 与 API Server 在同一台机器，所以直接使用 API Server 的非安全端口访问，–insecure-bind-address=127.0.0.1</li></ul> 
<blockquote> 
 <p>因为都在同一台服务器上面了就不再需要使用 https 双向认证了</p> 
</blockquote> 
<ul><li> <p>kubectl、kubelet、kube-proxy 访问 API Server 就都需要证书进行 HTTPS 双向认证</p> </li><li> <p>Pod中的容器访问API Server。</p> </li></ul> 
<blockquote> 
 <p>因为Pod的创建、销毁是动态的，所以要为它手动生成证书就不可行了,也不可能为几百个pod挨个颁发。所以Kubenetes使用了Service Account解决Pod 访问API Server的认证问题(后面会说)</p> 
</blockquote> 
<p>证书颁发</p> 
<ul><li>手动签发：通过 k8s 集群的跟 ca 进行签发 HTTPS 证书</li><li>自动签发：kubelet 首次访问 API Server 时，使用 token 做认证，通过后，Controller Manager 会为kubelet 生成一个证书，以后的访问都是用证书做认证了</li></ul> 
<h3><a id="23kubeconfig_56"></a>2.3、kubeconfig</h3> 
<p>kubeconfig 文件包含集群参数（CA证书、API Server地址），客户端参数（上面生成的证书和私钥），集群context 信息（集群名称、用户名）。Kubenetes 组件通过启动时指定不同的 kubeconfig 文件可以切换到不同的集群</p> 
<p>查看方式如下：<br> <strong>默认是当前用户的根目录下，这个文件的内容很多，也就是上面提到的各个字段了，这里就不放完整内容了。</strong><img src="https://images2.imgbox.com/28/bd/zzMPgOHe_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="24Secret__SA__61"></a>2.4、Secret 与 SA 的关系</h3> 
<p>Kubernetes 设计了一种资源对象叫做 Secret，分为两类，一种是用于 ServiceAccount 的 service-account-token， 另一种是用于保存用户自定义保密信息的 Opaque。ServiceAccount 中用到包含三个部分：Token、ca.crt、namespace</p> 
<ul><li>token是使用 API Server 私钥签名的 JWT。<strong>用于访问API Server时，Server端认证</strong></li><li>ca.crt，根证书。<strong>用于Client端验证API Server发送的证书</strong></li><li>namespace, 标识这个service-account-token的作用域名空间</li></ul> 
<pre><code class="prism language-shell">kubectl get secret 
</code></pre> 
<p>随便选择一个pod，进入容器后，查看认证的信息，认证信息默认放在 <code>/run/secrets/kubernetes.io</code>目录下<br> <img src="https://images2.imgbox.com/a4/4c/KqyARs0f_o.png" alt="在这里插入图片描述"></p> 
<p><strong>默认情况下，每个 namespace 都会有一个 ServiceAccount，如果 Pod 在创建时没有指定 ServiceAccount，就会使用 Pod 所属的 namespace 的 ServiceAccount</strong></p> 
<h3><a id="25_76"></a>2.5、总结</h3> 
<p>其实就是上面那张图，如果是pod 则使用sa，如果是k8s组件则如下图所示。</p> 
<p><img src="https://images2.imgbox.com/4c/32/weoUgXL4_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="3_Authorization_80"></a>3、鉴权 （Authorization）</h2> 
<p>对于第二章的认证过程，只是确认通信的双方都确认了对方是可信的，可以相互通信。而鉴权是确定请求方有哪些资源的权限。<strong>API Server 目前支持以下几种授权策略</strong> （通过 API Server 的启动参数 “–authorization-mode” 设置）</p> 
<table><thead><tr><th>方式</th><th>说明</th></tr></thead><tbody><tr><td>AlwaysDeny</td><td>表示拒绝所有的请求，一般用于测试</td></tr><tr><td>AlwaysAllow</td><td>允许接收所有请求，如果集群不需要授权流程，则可以采用该策略</td></tr><tr><td>ABAC</td><td>ABAC（Attribute-Based Access Control）：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制，已经被淘汰（注意一点，这种方式修改完成，不是实时生效的，得重启API Server）</td></tr><tr><td>Webbook</td><td>通过调用外部 REST 服务对用户进行授权</td></tr><tr><td>RBAC（Role-Based Access Control）</td><td>基于角色的访问控制，现在默认的规则</td></tr></tbody></table> 
<p>下面就直接说 RBAC 授权模式了。</p> 
<h3><a id="31RBAC__95"></a>3.1、RBAC 授权模式</h3> 
<p>RBAC（Role-Based Access Control）基于角色的访问控制，在 Kubernetes 1.5 中引入，现行版本成为默认标准。相对其它访问控制方式，拥有以下优势：</p> 
<ul><li>对集群中的资源（pod，名称空间等）和<strong>非资源(pod的状态等)</strong> 均拥有完整的覆盖</li><li>整个 RBAC 完全由几个 API 对象完成，同其它 API 对象一样，可以用 kubectl 或 API 进行操作<br> 可以在运行时进行调整，<strong>无需重启 API Serve</strong></li></ul> 
<h3><a id="32RBAC__API__103"></a>3.2、RBAC 的 API 资源对象说明</h3> 
<p>RBAC 引入了 4 个新的顶级资源对象：Role、ClusterRole、RoleBinding、ClusterRoleBinding，4 种对象类型均可以通过 kubectl 与 API 操作</p> 
<table><thead><tr><th>资源对象</th><th>说明</th></tr></thead><tbody><tr><td>Role</td><td>角色，有且只有一个命名空间，会在定义的时候，让你提供这个<strong>唯一</strong>的命名空间</td></tr><tr><td>ClusterRole</td><td>集群角色，可以管理多个命名空间，会在定义的时候，让你提供命名空间</td></tr><tr><td>RoleBinding</td><td>单个命名空间的角色和资源绑定，如果使用ClusterRole 配合 RoleBinding，那也只是绑定一个命名空间的资源，而且会在定义RoleBinding的时候，让你提供<strong>唯一</strong>的命名空间</td></tr><tr><td>ClusterRoleBinding</td><td>多个命名口昂见的角色和资源绑定，如果使用ClusterRole 配合 ClusterRoleBinding，那可以绑定集群下所有的命名空间的资源，而且会在定义ClusterRoleBinding的时候，让你提供命名空间</td></tr></tbody></table> 
<p><strong>说白了就是一个（role，RoleBinding）和多个（ClusterRole，ClusterRoleBinding）且可以混搭（以少的为准）的区别而已，举个列子，如下图</strong></p> 
<blockquote> 
 <ul><li>用户 Zhangsan 它被 read pod的角色Role使用 roleBinding 绑定，而这个角色的命名空间是default所以，Zhangsan 只有default命名空间读取pod的权限</li><li>用户 Lisi 它被 read pod的角色Role使用 roleBinding 绑定，而这个角色的命名空间是test所以，Lisi 只有 test 命名空间读取 pod 的权限</li><li>用户 Wangwu 它被 read pod的角色ClusterRole 使用 roleBinding 绑定，而这个角色的命名空间权限是集权，但是 因为使用 RoleBinding ，Wangwu 也只有 其中一个(使用的时候会让你指定的) 命名空间读取 pod 的权限</li><li>同理用户 Zhangliu 和 Wangwu 是一样的</li><li>但是用户 Wangyang 就可以获取 ClusterRole 的所有命名空间读取pod的权限，因为它配合了 ClusterBinding<br> <img src="https://images2.imgbox.com/64/bf/GgeuzG0y_o.png" alt="在这里插入图片描述"></li></ul> 
</blockquote> 
<p>简单的绑定关系如下，至于其它混搭的模式这里就不再画图表示 了。<br> <img src="https://images2.imgbox.com/a7/44/miEA69Jk_o.png" alt="在这里插入图片描述"><br> 需要注意的是 Kubenetes 并不会提供用户管理，那么 User、Group、ServiceAccount 指定的用户又是从哪里来的呢？ Kubenetes 组件（kubectl、kube-proxy）或是其他自定义的用户在向 CA 申请证书时，需要提供一个证书请求文件，如下</p> 
<pre><code class="prism language-json"><span class="token punctuation">{<!-- --></span>
    <span class="token string-property property">"CN"</span><span class="token operator">:</span><span class="token string">"admin"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"hosts"</span><span class="token operator">:</span><span class="token punctuation">[</span>

    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token string-property property">"key"</span><span class="token operator">:</span><span class="token punctuation">{<!-- --></span>
        <span class="token string-property property">"algo"</span><span class="token operator">:</span><span class="token string">"rsa"</span><span class="token punctuation">,</span>
        <span class="token string-property property">"size"</span><span class="token operator">:</span><span class="token number">2048</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string-property property">"names"</span><span class="token operator">:</span><span class="token punctuation">[</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token string-property property">"C"</span><span class="token operator">:</span><span class="token string">"CN"</span><span class="token punctuation">,</span>
            <span class="token string-property property">"ST"</span><span class="token operator">:</span><span class="token string">"HangZhou"</span><span class="token punctuation">,</span>
            <span class="token string-property property">"L"</span><span class="token operator">:</span><span class="token string">"XS"</span><span class="token punctuation">,</span>
            <span class="token string-property property">"O"</span><span class="token operator">:</span><span class="token string">"system:masters"</span><span class="token punctuation">,</span>
            <span class="token string-property property">"OU"</span><span class="token operator">:</span><span class="token string">"System"</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>API Server会把客户端证书的 CN 字段作为User，把 names.O 字段作为Group</li><li>kubelet 使用 TLS Bootstaping 认证时，API Server 可以使用 Bootstrap Tokens 或者 Token authentication file 验证 =token，无论哪一种，Kubenetes 都会为 token 绑定一个默认的 User 和 Group</li><li>Pod使用 ServiceAccount 认证时，service-account-token 中的 JWT 会保存 User 信息，而有了用户信息，再创建一对角色/角色绑定(集群角色/集群角色绑定)资源对象，就可以完成权限绑定了</li></ul> 
<p>也就是说无论哪一种之前的哪一种认证的方式，都会提供用户和组，只是方式不一样<br> <img src="https://images2.imgbox.com/44/e9/8pKMiBRW_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="33Role_and_ClusterRole_153"></a>3.3、Role and ClusterRole</h3> 
<p>在 RBAC API 中，Role 表示一组规则权限，权限只会增加(累加权限)，不存在一个资源一开始就有很多权限而通过RBAC 对其进行减少的操作；Role 可以定义在一个 namespace 中，如果想要跨 namespace 则可以创建 ClusterRole</p> 
<p>示例如下，表示定义一个只可以在 <code>default</code> 名称空间下 <code>get/watch/list pods</code> 的Role的资源</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Role
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1beta1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default  <span class="token comment"># 范围只是在 `default` 名称空间下</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span>reader  <span class="token comment"># 名称叫  pod-reader </span>
<span class="token key atrule">rules</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span> <span class="token comment"># "" 表示作用的范围组是 core API group ，你也可以修改 </span>
  <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"pods"</span><span class="token punctuation">]</span>  <span class="token comment"># 对应的资源是 pods</span>
  <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">]</span>  <span class="token comment"># 权限是 get/watch/list  结合上面就是这个角色只有get/watch/list pod的权限</span>
</code></pre> 
<p>ClusterRole 具有与 Role 相同的权限角色控制能力，不同的是 ClusterRole 是集群级别的,ClusterRole 可以用于:</p> 
<ul><li>集群级别的资源控制( 例如 node 访问权限 )</li><li>非资源型 endpoints( 例如 /healthz 访问 )</li><li>所有命名空间资源控制(例如 pods )</li></ul> 
<p>示例如下，定义了一个可以在任何名称空间下 <code>get/watch/list secrets</code>的角色</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1beta1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token comment"># "namespace" omitted since ClusterRoles are not namespaced</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> secret<span class="token punctuation">-</span>reader
<span class="token key atrule">rules</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>
  <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"secrets"</span><span class="token punctuation">]</span>
  <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">]</span>
</code></pre> 
<h3><a id="34RoleBinding_and_ClusterRoleBinding_189"></a>3.4、RoleBinding and ClusterRoleBinding</h3> 
<p>RoloBinding 可以将角色中定义的权限授予用户或用户组，RoleBinding 包含一组权限列表(subjects)，权限列表中包含有不同形式的待授予权限资源类型 <strong>(users, groups, or service accounts)</strong>；RoloBinding 同样包含对被Bind 的 Role 引用；<strong>RoleBinding 适用于某个命名空间内授权，而 ClusterRoleBinding 适用于集群范围内的授权</strong></p> 
<p>如下将 <code>default</code> 命名空间的 pod-reader Role 授予 jane 用户，此后 jane 用户在 default 命名空间中将具有 pod-reader 的权限</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> RoleBinding
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1beta1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> read<span class="token punctuation">-</span>pods  <span class="token comment"># 当前这个RoleBinding资源的名称</span>
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default <span class="token comment"># 名称空间</span>
<span class="token key atrule">subjects</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> User
  <span class="token key atrule">name</span><span class="token punctuation">:</span> jane
  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io
<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>
  <span class="token key atrule">kind</span><span class="token punctuation">:</span> Role
  <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span>reader <span class="token comment"># 上面定义过</span>
  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io
</code></pre> 
<p>RoleBinding 同样可以引用 ClusterRole 来对当前 namespace 内用户、用户组或 ServiceAccount 进行授权，这种操作允许集群管理员在整个集群内定义一些通用的 ClusterRole，然后在不同的 namespace 中使用RoleBinding 来引用。</p> 
<p>例如，以下 RoleBinding 引用了一个 ClusterRole，这个 ClusterRole 具有整个集群内对 secrets 的访问权限；但是其授权用户 dave 只能访问 development 空间中的 secrets(因为 RoleBinding 定义在 development 命名空间)</p> 
<pre><code class="prism language-yaml"><span class="token comment"># This role binding allows "dave" to read secrets in the "development" namespace.</span>
<span class="token key atrule">kind</span><span class="token punctuation">:</span> RoleBinding
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1beta1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> read<span class="token punctuation">-</span>secrets
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> development <span class="token comment"># This only grants permissions within the "development" namespace.</span>
<span class="token key atrule">subjects</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> User
  <span class="token key atrule">name</span><span class="token punctuation">:</span> dave
  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io
<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>
  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole
  <span class="token key atrule">name</span><span class="token punctuation">:</span> secret<span class="token punctuation">-</span>reader
  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.i
</code></pre> 
<p>使用 ClusterRoleBinding 可以对整个集群中的所有命名空间资源权限进行授权；以下 ClusterRoleBinding 样例展示了授权 manager 组内所有用户在全部命名空间中对 secrets 进行访问</p> 
<pre><code class="prism language-yaml"><span class="token comment"># This cluster role binding allows anyone in the "manager" group to read secrets in any</span>
namespace.
<span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRoleBinding
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1beta1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
 <span class="token key atrule">name</span><span class="token punctuation">:</span> read<span class="token punctuation">-</span>secrets<span class="token punctuation">-</span>global
<span class="token key atrule">subjects</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> Group
  <span class="token key atrule">name</span><span class="token punctuation">:</span> manager
  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io
<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>
  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole
  <span class="token key atrule">name</span><span class="token punctuation">:</span> secret<span class="token punctuation">-</span>reader
  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.i
</code></pre> 
<h3><a id="35Resources_248"></a>3.5、Resources</h3> 
<p>Kubernetes 集群内一些资源一般以其名称字符串来表示，这些字符串一般会在 API 的 URL 地址中出现；同时某些资源也会包含子资源，<strong>例如 logs 资源就属于 pods 的子资源</strong>，API 中 URL 样例如下</p> 
<pre><code class="prism language-shell">GET /api/v1/namespaces/<span class="token punctuation">{<!-- --></span>namespace<span class="token punctuation">}</span>/pods/<span class="token punctuation">{<!-- --></span>name<span class="token punctuation">}</span>
</code></pre> 
<p><strong>意思就是我们可以授权到 <code>/api/v1/namespaces/{namespace}</code>，这个url后面的<code>/pods/{name}</code>也都会被赋予授权，我们也开可以直接缩小到最后一层即 <code>/api/v1/namespaces/{namespace}/pods/{name}</code> 则这个权限只能操作指定名称的<code>pod</code>了。</strong></p> 
<p>如果要在 RBAC 授权模型中控制这些子资源的访问权限，可以通过 / 分隔符来实现，以下是一个定义 pods 资源 logs 访问权限的 Role 定义样例</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Role
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1beta1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default
  <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span>and<span class="token punctuation">-</span>pod<span class="token punctuation">-</span>logs<span class="token punctuation">-</span>reader
<span class="token key atrule">rules</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>
  <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"pods/log"</span><span class="token punctuation">]</span>
  <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">]</span>
</code></pre> 
<h3><a id="36to_Subjects_272"></a>3.6、to Subjects</h3> 
<p>RoleBinding 和 ClusterRoleBinding 可以将 Role 绑定到 Subjects；<strong>Subjects 可以是 groups、users 或者 service accounts</strong></p> 
<p>Subjects 中 Users 使用字符串表示，它可以是一个普通的名字字符串，如 “alice”；也可以是 email 格式的邮箱地址，如 “wangyanglinux@163.com”；甚至是一组字符串形式的数字 ID 。但是 Users 的前缀 system: 是系统保留的，集群管理员应该确保普通用户不会使用这个前缀格式Groups 书写格式与Users 相同，都为一个字符串，并且没有特定的格式要求；同样 system: 前缀为系统保留</p> 
<h3><a id="37_dev__279"></a>3.7、案例：创建一个用户只能管理 dev 空间</h3> 
<h4><a id="371linux__devuser_280"></a>3.7.1、创建linux 用户 devuser</h4> 
<p>1、在k8s-master节点上增加一个用户，打码部分是命令写错了（我故意把他去掉的），不用在意</p> 
<pre><code class="prism language-shell"><span class="token function">useradd</span> devuser
<span class="token function">passwd</span> devuser
</code></pre> 
<p><img src="https://images2.imgbox.com/49/37/OEjWLG18_o.png" alt="在这里插入图片描述"></p> 
<p>2、使用刚刚新建立的用户 devuser 登录 k8s-master节点 再访问k8s资源，发现是不能访问的。</p> 
<p><img src="https://images2.imgbox.com/38/2f/kapFkgxT_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="372k8s__291"></a>3.7.2、k8s 创建用户证书凭证前置准备</h4> 
<p>1、在k8s-master节点上为 <code>devuser</code> 赋权，<strong>注意我们为这个用户赋权，当然得用已经有权限的账号去做这件事，所以还是用我们一开始搭建集群的账号root登录master节点</strong></p> 
<pre><code class="prism language-shell"><span class="token function">mkdir</span> /usr/local/install-k8s/cert <span class="token comment"># 这个目录随意，但是一定要记住，因为后面用户生成的文件我们都准备放在这</span>
<span class="token builtin class-name">cd</span> /usr/local/install-k8s/cert
<span class="token function">mkdir</span> devuser <span class="token comment"># 再在当前这目录下创建一个 专属于 devuser的目录，它的生成的文件我们放在这里，这样后面再添加其它用户，也比较好区分。</span>
<span class="token builtin class-name">cd</span> devuser
<span class="token function">vim</span> devuser-csr.json 
</code></pre> 
<p>devuser-csr.json 文件内容如下，前面有说过这个文件的<code>CN</code>代表用户名，<code>nams.O</code>代表组</p> 
<pre><code class="prism language-json"><span class="token punctuation">{<!-- --></span>    
    <span class="token string-property property">"CN"</span><span class="token operator">:</span><span class="token string">"devuser"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"hosts"</span><span class="token operator">:</span><span class="token punctuation">[</span>

    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token string-property property">"key"</span><span class="token operator">:</span><span class="token punctuation">{<!-- --></span>
        <span class="token string-property property">"algo"</span><span class="token operator">:</span><span class="token string">"rsa"</span><span class="token punctuation">,</span>
        <span class="token string-property property">"size"</span><span class="token operator">:</span><span class="token number">2048</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string-property property">"names"</span><span class="token operator">:</span><span class="token punctuation">[</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token string-property property">"C"</span><span class="token operator">:</span><span class="token string">"CN"</span><span class="token punctuation">,</span>
            <span class="token string-property property">"ST"</span><span class="token operator">:</span><span class="token string">"BeiJing"</span><span class="token punctuation">,</span>
            <span class="token string-property property">"L"</span><span class="token operator">:</span><span class="token string">"BeiJing"</span><span class="token punctuation">,</span>
            <span class="token string-property property">"O"</span><span class="token operator">:</span><span class="token string">"k8s"</span><span class="token punctuation">,</span>
            <span class="token string-property property">"OU"</span><span class="token operator">:</span><span class="token string">"System"</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/24/ac/pkdNlljM_o.png" alt="在这里插入图片描述"></p> 
<p>2、下载证书生成工具（三个文件），再改下名称</p> 
<pre><code class="prism language-shell"><span class="token function">wget</span> https://pkg.cfssl.org/R1.2/cfssl_linux-amd64
<span class="token function">mv</span> cfssl_linux-amd64 /usr/local/bin/cfssl

<span class="token function">wget</span> https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64
<span class="token function">mv</span> cfssljson_linux-amd64 /usr/local/bin/cfssljson
 
<span class="token function">wget</span> https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64
<span class="token function">mv</span> cfssl-certinfo_linux-amd64 /usr/local/bin/cfssl-certin
</code></pre> 
<p>为这三个文件赋予可以执行的权限，后面要用到这几个命令<br> <img src="https://images2.imgbox.com/93/9c/dAIZnrDz_o.png" alt="在这里插入图片描述"></p> 
<p>3、创建授权文件，<strong>最好在 <code>/etc/kubernetes/pki</code>目录下执行，因为这个文件夹下保存的都是证书凭证（当然你也可以不在这个目录中，自己指定一个）</strong>，后面有一个参数 <code>/usr/local/install-k8s/cert/devuser/devuser-csr.json</code> 这个文件就上面我们创建用户名和组的那个json文件。</p> 
<pre><code class="prism language-shell"><span class="token comment"># 这里就要用到上面下载的三个命令了</span>
cfssl gencert -ca<span class="token operator">=</span>ca.crt -ca-key<span class="token operator">=</span>ca.key -profile<span class="token operator">=</span>kubernetes /usr/local/install-k8s/cert/devuser/devuser-csr.json <span class="token operator">|</span> cfssljson  -bare devuser
</code></pre> 
<p><img src="https://images2.imgbox.com/03/e7/dvPecIDb_o.png" alt="在这里插入图片描述"><br> 那么这个文件夹下就会出现如下三个文件<br> <img src="https://images2.imgbox.com/7e/f1/4hHVme55_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="373k8s__351"></a>3.7.3、k8s 创建授权文件</h4> 
<p>1、设置变量名称，最好到 <code>/usr/locl/install-k8s/cert/deuser</code>目录下，因为后面会有一些缓存生成，而这写步骤都是为 devuser 这个用户做的，所以最好都放在同一个目录。</p> 
<pre><code class="prism language-shell"><span class="token comment"># 这个地址就是 k8s的master 的节点地址</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">KUBE_APISERVER</span><span class="token operator">=</span>"https://192.168.66.10:6443
</code></pre> 
<p><img src="https://images2.imgbox.com/6d/26/7FLhZNbO_o.png" alt="在这里插入图片描述"></p> 
<p>2、生成<code>devuser</code>的基础用户凭证 <strong>(信息还不全，后面我们会补充它的内容)</strong> ，最后生成我们指定认证文件的名称 <code>devuser.kubeconfig</code></p> 
<pre><code class="prism language-shell">kubectl config set-cluster kubernetes <span class="token punctuation">\</span>
--certificate-authority<span class="token operator">=</span>/etc/kubernetes/pki/ca.pem <span class="token punctuation">\</span>
--embed-certs<span class="token operator">=</span>true <span class="token punctuation">\</span>
--server<span class="token operator">=</span><span class="token variable">${KUBE_APISERVER}</span> <span class="token punctuation">\</span>
--kubeconfig<span class="token operator">=</span>devuser.kubeconfig
</code></pre> 
<p><img src="https://images2.imgbox.com/55/bf/65WrVz7L_o.png" alt="在这里插入图片描述"><br> 你可以打开看下这个文件，其中后面的几个字段都是空的，那么接下来我们就要补全这些内容<br> <img src="https://images2.imgbox.com/8a/55/sbr3wB5A_o.png" alt="在这里插入图片描述"></p> 
<p>3、设置(补全)客户端认证参数，执行命令后，那个文件的几个字段就会被填充</p> 
<pre><code class="prism language-shell">kubectl config set-credentials devuser <span class="token punctuation">\</span>
--client-certificate<span class="token operator">=</span>/etc/kubernetes/pki/devuser.pem <span class="token punctuation">\</span>
--client-key<span class="token operator">=</span>/etc/kubernetes/pki/devuser-key.pem <span class="token punctuation">\</span>
--embed-certs<span class="token operator">=</span>true <span class="token punctuation">\</span>
--kubeconfig<span class="token operator">=</span>devuser.kubeconfig
</code></pre> 
<p><img src="https://images2.imgbox.com/ba/d3/Kp1I4iMM_o.png" alt="在这里插入图片描述"></p> 
<p>4、设置(补全)上下文参数，执行命令后，那个文件的<strong>又会</strong>填充一部分信息</p> 
<p>创建名称空间 dev，因为后面需要把这个dev 空间赋权给 devuser了，所以先创建<br> <img src="https://images2.imgbox.com/a4/4c/0AKsLVv4_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-shell">kubectl config set-context kubernetes <span class="token punctuation">\</span>
--cluster<span class="token operator">=</span>kubernetes <span class="token punctuation">\</span>
--user<span class="token operator">=</span>devuser <span class="token punctuation">\</span>
--namespace<span class="token operator">=</span>dev <span class="token punctuation">\</span>
--kubeconfig<span class="token operator">=</span>devuser.kubeconfig
</code></pre> 
<p><img src="https://images2.imgbox.com/49/38/ghYPxKet_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="374k8s__398"></a>3.7.4、k8s 授权证书绑定用户角色权限</h4> 
<p>1、创建 roleBinding(当然你也可以用写配置文件的方式创建)，这样关系就算绑定好了。</p> 
<blockquote> 
 <p>创建一个名称叫 vuser-admin-binding 的 rolebinding ，角色选择 admin（这个admin相当于超级管理员，走到哪里都可以为所欲为） ,下发权限到 devuser<br> <img src="https://images2.imgbox.com/3c/61/9LeiBAaI_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>2、在用户 devuser 的家目录下创建 <code>.kube</code>目录，这个是k8s默认去找用户的凭证信息的目录</p> 
<blockquote> 
 <p>你也可以看看root 用户下是不是也有，那就是root用户的凭证</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/e0/69/aYqiafUO_o.png" alt="在这里插入图片描述"><br> 3 、 <strong>将最后的完整的devuser的配置文件拷贝到devuser家下的 <code>.kube</code> 目录，并授权这个文件的用户和组都是它自己</strong>。<br> <img src="https://images2.imgbox.com/4f/ae/WyxE4k4v_o.png" alt="在这里插入图片描述"><br> 修改文件名称，因为对比root 用户，它的 <code>.kube</code>目录下的这个文件就叫config，所以我们和它保持一致，前面叫 devuser.kubeconifg 是为了自己清楚。<br> <img src="https://images2.imgbox.com/0e/08/cGY5hRyg_o.png" alt="在这里插入图片描述"><br> 4、设置 devuser 的默认上下文</p> 
<pre><code class="prism language-shell">kubectl config use-context kubernetes --kubeconfig<span class="token operator">=</span>config
</code></pre> 
<p><img src="https://images2.imgbox.com/6d/54/ToXNgh9U_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="375_417"></a>3.7.5、测试</h4> 
<p>1、创建容器，可以看到我们不用指定命名空间，默认这个用户只有一个 <code>dev</code>空间，<strong>而且你要获取其它名称空间的容器，你发现不能获取，比如下面示例的<code>default</code>空间</strong><br> <img src="https://images2.imgbox.com/e1/16/VOGJYJnn_o.png" alt="在这里插入图片描述"></p> 
<p>不信，我们可以在 root 用户的权限看，刚刚创建的容器确实是在dev空间下的。<br> <img src="https://images2.imgbox.com/85/df/awniZltQ_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="4_424"></a>4、准入控制</h2> 
<p>准入控制是API Server 的插件集合，通过添加不同的插件，<strong>实现额外的准入控制规则</strong>。甚至于API Server的一些主要的功能都需要通过 Admission Controllers 实现，比如 ServiceAccount 官方文档上有一份针对不同版本的准入控制器推荐列表，其中最新的 1.14 的推荐列表是</p> 
<pre><code class="prism language-config">NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,Mutat
ingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota
</code></pre> 
<p>这里列举几个插件的功能：</p> 
<table><thead><tr><th>插件</th><th>功能说明</th></tr></thead><tbody><tr><td>NamespaceLifecycle</td><td>防止在不存在的 namespace 上创建对象，防止删除系统预置 namespace，删除 namespace 时，连带删除它的所有资源对象。</td></tr><tr><td>LimitRanger</td><td>确保请求的资源不会超过资源所在 Namespace 的 LimitRange 的限制。</td></tr><tr><td>ServiceAccount</td><td>实现了自动化添加 ServiceAccount。</td></tr><tr><td>ResourceQuota</td><td>确保请求的资源不会超过资源的 ResourceQuota 限制。</td></tr></tbody></table>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6a202e56df19058f4e58cfa9579db0c5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于Loglet Lab4的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4e37bab6d3c49dc123eead9bb7617ba5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">oracle计算占比和环比增长率案例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>