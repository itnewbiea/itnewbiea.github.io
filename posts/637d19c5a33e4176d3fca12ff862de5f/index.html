<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2021-06-23 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2021-06-23" />
<meta property="og:description" content="C&#43;&#43;中基类的析构函数为什么要用virtual虚析构函数 知识背景 要弄明白这个问题，首先要了解下C&#43;&#43;中的动态绑定。 关于动态绑定的讲解，请参阅： C&#43;&#43;中的动态类型与动态绑定、虚函数、多态实现
正题 直接的讲，C&#43;&#43;中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C&#43;&#43;中基类的析构函数应采用virtual虚析构函数。
示例代码讲解
现有Base基类，其析构函数为非虚析构函数。Derived1和Derived2为Base的派生类，这两个派生类中均有以string* 指向存储其name的地址空间，name对象是通过new创建在堆上的对象，因此在析构时，需要显式调用delete删除指针归还内存，否则就会造成内存泄漏。
示例代码讲解 现有Base基类，其析构函数为非虚析构函数。Derived1和Derived2为Base的派生类，这两个派生类中均有以string* 指向存储其name的地址空间，name对象是通过new创建在堆上的对象，因此在析构时，需要显式调用delete删除指针归还内存，否则就会造成内存泄漏。
class Base {
public:
~Base() {
cout &lt;&lt; &#34;~Base()&#34; &lt;&lt; endl;
}
};
class Derived1 : public Base {
public:
Derived1():name_(new string(&#34;NULL&#34;)) {}
Derived1(const string&amp; n):name_(new string(n)) {}
~Derived1() {
delete name_;
cout &lt;&lt; &#34;~Derived1(): name_ has been deleted.&#34; &lt;&lt; endl;
}
private:
string* name_;
};
class Derived2 : public Base {
public:
Derived2():name_(new string(&#34;NULL&#34;)) {}" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/637d19c5a33e4176d3fca12ff862de5f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-23T23:07:04+08:00" />
<meta property="article:modified_time" content="2021-06-23T23:07:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2021-06-23</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="articleContentId">C++中基类的析构函数为什么要用virtual虚析构函数</h2> 
<h2>知识背景</h2> 
<p>         要弄明白这个问题，首先要了解下C++中的动态绑定。 </p> 
<p>         关于动态绑定的讲解，请参阅：  C++中的动态类型与动态绑定、虚函数、多态实现</p> 
<h2>正题</h2> 
<p>         直接的讲，C++中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。</p> 
<p>示例代码讲解<br> 现有Base基类，其析构函数为非虚析构函数。Derived1和Derived2为Base的派生类，这两个派生类中均有以string* 指向存储其name的地址空间，name对象是通过new创建在堆上的对象，因此在析构时，需要显式调用delete删除指针归还内存，否则就会造成内存泄漏。</p> 
<h2>示例代码讲解</h2> 
<p>现有Base基类，其析构函数为非虚析构函数。Derived1和Derived2为Base的派生类，这两个派生类中均有以string* 指向存储其name的地址空间，name对象是通过new创建在堆上的对象，因此在析构时，需要显式调用delete删除指针归还内存，否则就会造成内存泄漏。</p> 
<p><br> class Base {<!-- --><br>  public:<br> ~Base() {<!-- --><br>   cout &lt;&lt; "~Base()" &lt;&lt; endl;<br> }<br> };</p> 
<p>class Derived1 : public Base {<!-- --><br>  public:<br>   Derived1():name_(new string("NULL")) {}<br>   Derived1(const string&amp; n):name_(new string(n)) {}<br>  <br>   ~Derived1() {<!-- --><br>     delete name_;<br>     cout &lt;&lt; "~Derived1(): name_ has been deleted." &lt;&lt; endl;<br>   }<br>  <br>  private:<br>   string* name_;<br> };<br>  <br> class Derived2 : public Base {<!-- --><br>  public:<br>   Derived2():name_(new string("NULL")) {}<br>   Derived2(const string&amp; n):name_(new string(n)) {}<br>  <br>   ~Derived2() {<!-- --><br>     delete name_;<br>     cout &lt;&lt; "~Derived2(): name_ has been deleted." &lt;&lt; endl;<br>   }<br>  <br>  private:<br>   string* name_;<br> };</p> 
<p>我们看下面对其析构情况进行测试：</p> 
<p>int main() {<!-- --><br>   Derived1* d1 = new Derived1();<br>   Derived2 d2 = Derived2("Bob");<br>   delete d1;<br>   return 0;<br> }</p> 
<p></p> 
<p>d1为Derived1类的指针，它指向一个在堆上创建的Derived1的对象；d2为一个在栈上创建的对象。其中d1所指的对象需要我们显式的用delete调用其析构函数；d2对象在其生命周期结束时，系统会自动调用其析构函数。看下其运行结果：</p> 
<p><img alt="" src="https://images2.imgbox.com/69/a9/AdtPKMwp_o.png"></p> 
<p>刚才我们说，Base基类的析构函数并不是虚析构函数，现在结果显示，派生类的析构函数被调用了，正常的释放了其申请的内存资源。这两者并不矛盾，因为无论是d1还是d2，两者都属于静态绑定，而且其静态类型恰好都是派生类，因此，在析构的时候，即使基类的析构函数为非虚析构函数，也会调用相应派生类的析构函数。</p> 
<p>下面我们来看下，当发生动态绑定时，也就是当用基类指针指向派生类，这时候采用delete显式删除指针所指对象时，如果Base基类的析构函数没有virtual，会发生什么情况？<br> int main() {<!-- --><br>   Base* base[2] = {<!-- --><br>     new Derived1(),<br>     new Derived2("Bob")      <br>   };<br>   for (int i = 0; i != 2; ++i) {<!-- --><br>     delete base[i];    <br>   }<br>   return 0;<br> }</p> 
<p><img alt="" src="https://images2.imgbox.com/37/a9/nBr2so9K_o.png"></p> 
<p>从上面结果我们看到，尽管派生类中定义了析构函数来释放其申请的资源，但是并没有得到调用。原因是基类指针指向了派生类对象，而基类中的析构函数却是非virtual的，之前讲过，虚函数是动态绑定的基础。现在析构函数不是virtual的，因此不会发生动态绑定，而是静态绑定，指针的静态类型为基类指针，因此在delete时候只会调用基类的析构函数，而不会调用派生类的析构函数。这样，在派生类中申请的资源就不会得到释放，就会造成内存泄漏，这是相当危险的：如果系统中有大量的派生类对象被这样创建和销毁，就会有内存不断的泄漏，久而久之，系统就会因为缺少内存而崩溃。<br>         也就是说，在基类的析构函数为非虚析构函数的时候，并不一定会造成内存泄漏；当派生类对象的析构函数中有内存需要收回，并且在编程过程中采用了基类指针指向派生类对象，如为了实现多态，并且通过基类指针将该对象销毁，这时，就会因为基类的析构函数为非虚析构函数而不触发动态绑定，从而没有调用派生类的析构函数而导致内存泄漏。</p> 
<p>        因此，为了防止这种情况下内存泄漏的发生，最好将基类的析构函数写成virtual虚析构函数。</p> 
<p>下面把Base基类的析构函数改为虚析构函数：</p> 
<p>class Base {<!-- --><br>  public:<br> virtual ~Base() {<!-- --><br>   cout &lt;&lt; "~Base()" &lt;&lt; endl;<br> }<br> };</p> 
<p>再看下其运行结果：</p> 
<p><img alt="" src="https://images2.imgbox.com/fa/75/gwOsNMkf_o.png"></p> 
<p>这样就会实现动态绑定，派生类的析构函数就会得到调用，从而避免了内存泄漏。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ce478d3ee198e4963aa24a76b1b576b9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nvidia-smi no devices were found的“奇技淫巧”</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5147d9b0e4cd7e93f6e1f9c464b139a9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">U-Net 3&#43;: 全尺度的跳跃连接的 UNet</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>