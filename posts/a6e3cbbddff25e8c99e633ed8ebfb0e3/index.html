<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>上界通配符（? extends Type） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="上界通配符（? extends Type）" />
<meta property="og:description" content="在Java中，? extends Type是一个上界通配符，表示参数化类型的上限是Type。这意味着容器可以持有Type类型的任何对象或者Type的子类型对象。
使用场景 这种类型的通配符常用于泛型方法中，允许方法接受Type的实例或其子类型的集合。这同样基于PECS原则，即如果你需要一个提供（生产）指定类型元素的集合，使用? extends。
例子
假设我们有以下类的层次结构：
class Animal {} class Dog extends Animal {} class Cat extends Animal {} 现在，我们有一个方法，它的目的是从一个集合里读取Animal对象：
public void processAnimals(List&lt;? extends Animal&gt; animals) { for(Animal animal : animals) { // 这里可以安全地调用Animal类的方法 } } 这个方法接受的参数是一个列表，这个列表的类型是Animal或Animal的任何子类型。因此，以下的调用是有效的：
List&lt;Animal&gt; animalList = new ArrayList&lt;&gt;(); List&lt;Dog&gt; dogList = new ArrayList&lt;&gt;(); List&lt;Cat&gt; catList = new ArrayList&lt;&gt;(); processAnimals(animalList); // 正确：列表的类型正好是Animal processAnimals(dogList); // 正确：Dog是Animal的子类型 processAnimals(catList); // 正确：Cat是Animal的子类型 在这个例子中，无论是Animal列表、Dog列表还是Cat列表，都可以传递给processAnimals方法，因为它们都满足? extends Animal的条件。这样做的好处是你可以将方法的使用范围扩展到更多的子类型，同时能够在提取元素时保持类型安全。
遍历 使用? extends Type时，遍历集合是安全的，因为你确切知道集合中的每个元素至少是Type类型。因此，你可以调用Type中定义的方法，而不需要进行任何类型转换。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a6e3cbbddff25e8c99e633ed8ebfb0e3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-01T22:51:22+08:00" />
<meta property="article:modified_time" content="2024-01-01T22:51:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">上界通配符（? extends Type）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>   在Java中，<code>? extends Type</code>是一个上界通配符，表示参数化类型的上限是<code>Type</code>。这意味着容器可以持有<code>Type</code>类型的任何对象或者<code>Type</code>的子类型对象。</p> 
<h2>使用场景</h2> 
<p>  这种类型的通配符常用于泛型方法中，允许方法接受<code>Type</code>的实例或其子类型的集合。这同样基于PECS原则，即如果你需要一个提供（生产）指定类型元素的集合，使用<code>? extends</code>。</p> 
<p>例子</p> 
<p>  假设我们有以下类的层次结构：</p> 
<pre><code class="language-java">class Animal {}
class Dog extends Animal {}
class Cat extends Animal {}</code></pre> 
<p>  现在，我们有一个方法，它的目的是从一个集合里读取<code>Animal</code>对象：</p> 
<pre><code class="language-java">public void processAnimals(List&lt;? extends Animal&gt; animals) {
    for(Animal animal : animals) {
        // 这里可以安全地调用Animal类的方法
    }
}</code></pre> 
<p>  这个方法接受的参数是一个列表，这个列表的类型是<code>Animal</code>或<code>Animal</code>的任何子类型。因此，以下的调用是有效的：</p> 
<pre><code class="language-java">List&lt;Animal&gt; animalList = new ArrayList&lt;&gt;();
List&lt;Dog&gt; dogList = new ArrayList&lt;&gt;();
List&lt;Cat&gt; catList = new ArrayList&lt;&gt;();

processAnimals(animalList); // 正确：列表的类型正好是Animal
processAnimals(dogList); // 正确：Dog是Animal的子类型
processAnimals(catList); // 正确：Cat是Animal的子类型</code></pre> 
<p>  在这个例子中，无论是<code>Animal</code>列表、<code>Dog</code>列表还是<code>Cat</code>列表，都可以传递给<code>processAnimals</code>方法，因为它们都满足<code>? extends Animal</code>的条件。这样做的好处是你可以将方法的使用范围扩展到更多的子类型，同时能够在提取元素时保持类型安全。</p> 
<h2>遍历</h2> 
<p>  使用<code>? extends Type</code>时，遍历集合是安全的，因为你确切知道集合中的每个元素至少是<code>Type</code>类型。因此，你可以调用<code>Type</code>中定义的方法，而不需要进行任何类型转换。</p> 
<p>例如</p> 
<p>   </p> 
<pre><code class="language-java">public void processAnimals(List&lt;? extends Animal&gt; animals) {
    for(Animal animal : animals) {
        // 可以直接调用Animal类的方法，无需类型转换
    }
}</code></pre> 
<h2>总结</h2> 
<p><code>   ? extends Type</code>通配符的使用提高了代码的灵活性，它允许你编写能够接受更多子类型集合的泛型方法，同时保证了从这些集合中提取元素的类型安全。<strong>这是PECS原则中的“Producer Extends”部分，适用于你的集合是提供或生产元素的情况</strong>。在遍历这样的集合时，可以直接处理<code>Type</code>类型的元素，无需担心类型转换的问题。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/30154694573f2dd2ec115bac14795dbe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">下界通配符（? super Type）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/09a8373a74659a04b394e38ae83668ed/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">开放原子训练营（第四季）TobudOS——TobudOS内核移植（keil版）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>