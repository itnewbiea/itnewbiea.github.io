<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Docker】学习笔记 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Docker】学习笔记" />
<meta property="og:description" content="1. docker基本操作 镜像搜索 // 直接搜索镜像资源 docker search mysql // 搜索过滤 docker search --filter &#34;is-official=true&#34; mysql // 官方发布镜像 拉取镜像 docker pull mysql 查看本地镜像 docker images 删除本地镜像 docker rmi mysql // 强制删除镜像 docker rmi -f mysql 保存加载镜像 docker save 镜像id &gt; 文件名.tar // example: docker save 8da80fe49fcf&gt;./mysql.tar docker load &lt; 文件名.tar // example: docker load &lt; mysql.tar // 加载的镜像会没有名称和TAG，需要重命名 docker tag [镜像id] [新镜像名称]:[新镜像标签] 创建容器 docker create --name=mysqlContainer mysql 创建并运行容器 docker run -itd --name=mysqlContainer mysql 查看容器信息 // 查看运行中的容器信息 docker ps // 查看包括已停止运行的所有容器的信息 docker ps -a 停止运行容器 docker stop mysqlContainer 重新运行容器 docker restart mysqlContainer 删除容器 docker rm mysqlContainer 进入退出容器环境： docker-compose exec -it [容器的name或ID] /bin/bash // 有时候镜像比较精简，没有bash，使用下面的命令 docker-compose exec -it [容器的name或ID] /bin/sh // 退出容器终端界面 exit 提交容器修改 docker commit -m &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/bd9a9262dd31e269e21dc6b897002649/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-20T21:42:56+08:00" />
<meta property="article:modified_time" content="2023-09-20T21:42:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Docker】学习笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="1_docker_1"></a>1. docker基本操作</h4> 
<ul><li>镜像搜索</li></ul> 
<pre><code>// 直接搜索镜像资源
docker search mysql
// 搜索过滤
docker search --filter "is-official=true"  mysql // 官方发布镜像
</code></pre> 
<ul><li>拉取镜像</li></ul> 
<pre><code>docker pull mysql
</code></pre> 
<ul><li>查看本地镜像</li></ul> 
<pre><code>docker images
</code></pre> 
<ul><li>删除本地镜像</li></ul> 
<pre><code>docker rmi mysql
// 强制删除镜像
docker rmi -f mysql
</code></pre> 
<ul><li>保存加载镜像</li></ul> 
<pre><code>docker save 镜像id &gt; 文件名.tar
// example:
docker save 8da80fe49fcf&gt;./mysql.tar

docker load &lt; 文件名.tar
// example:
docker load &lt; mysql.tar

// 加载的镜像会没有名称和TAG，需要重命名
docker tag [镜像id] [新镜像名称]:[新镜像标签]
</code></pre> 
<ul><li>创建容器</li></ul> 
<pre><code>docker create --name=mysqlContainer mysql
</code></pre> 
<ul><li>创建并运行容器</li></ul> 
<pre><code>docker run -itd --name=mysqlContainer mysql
</code></pre> 
<ul><li>查看容器信息</li></ul> 
<pre><code>// 查看运行中的容器信息
docker ps

// 查看包括已停止运行的所有容器的信息
docker ps -a
</code></pre> 
<ul><li>停止运行容器</li></ul> 
<pre><code>docker stop mysqlContainer
</code></pre> 
<ul><li>重新运行容器</li></ul> 
<pre><code>docker restart mysqlContainer
</code></pre> 
<ul><li>删除容器</li></ul> 
<pre><code>docker rm mysqlContainer
</code></pre> 
<ul><li>进入退出容器环境：</li></ul> 
<pre><code>docker-compose exec -it [容器的name或ID] /bin/bash

// 有时候镜像比较精简，没有bash，使用下面的命令
docker-compose exec -it [容器的name或ID] /bin/sh

// 退出容器终端界面
exit
</code></pre> 
<ul><li>提交容器修改</li></ul> 
<pre><code>docker commit -m "do something" mysqlContainer my_mysql
</code></pre> 
<ul><li>导入导出容器</li></ul> 
<pre><code>// 导出容器为镜像包
docker export mysqlContainer &gt; mysql.tar
// 将镜像tar包导入并命名
docker import mysql.tar mysqlimage
</code></pre> 
<h4><a id="2_docker_85"></a>2. docker开发模式</h4> 
<p>Docker开发模式，然后把代码挂载到容器。<br> 在开发和测试环境中，推荐使用- v 共享文件夹来存储开发人员的<br> 程序代码，避免频繁打包操作。</p> 
<ul><li>端口映射</li></ul> 
<pre><code>// 将宿主机的33060端口与docker的3306端口进行映射
docker run -itd --name mysqlContainer -p 33060:3306 mysql
</code></pre> 
<ul><li>文件挂载</li></ul> 
<pre><code>// 将宿主机下指定目录与docker容器目录进行关联,":"前是宿主机目录，后面是容器内目录
docker run -itd --name mysqlContainer -v /test_mysql:/usr/mysql_folder
</code></pre> 
<ul><li>文件拷贝</li></ul> 
<pre><code>// 将宿主机下的A.tar 拷贝到容器的/usr/mysql_folder/目录下
docker cp /test_mysql/A.tar mysqlContainer:/usr/mysql_folder/
</code></pre> 
<h4><a id="3_dockerfile_106"></a>3. dockerfile</h4> 
<blockquote> 
 <p>Dockerfile 是一个文本文件，其中包含我们需要运行以构建 Docker 镜像的所有命令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。Docker 使用 Dockerfile 中的指令自动构建镜像。我们可以 docker build 用来创建按顺序执行多个命令行指令的自动构建。<br> FROM ：使用 FROM 为后续的指令建立基础映像。在所有有效的 Dockerfile 中， FROM 是第一条指令。<br> LABEL： LABEL 指令用于组织项目映像，模块，许可等。在自动化布署方面 LABEL 也有很大用途。在 LABEL 中指定一组键值对，可用于程序化配置或布署 Docker 。<br> RUN： RUN 指令可在映像当前层执行任何命令并创建一个新层，用于在映像层中添加功能层，也许最来的层会依赖它。<br> CMD： 使用 CMD 指令为执行的容器提供默认值。在 Dockerfile 文件中，若添加多个 CMD 指令，只有最后的 CMD 指令运行。<br> 作者：JavaPub<br> 链接：https://www.zhihu.com/question/61349295/answer/2543817956<br> 来源：知乎<br> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p> 
</blockquote> 
<p>补充：</p> 
<ul><li>MAINTAINER：维护者信息，可选。</li></ul> 
<pre><code>MAINTAINER CYK
</code></pre> 
<ul><li>COPY：将dockerfile文件所在目录下的本地文件或目录添加到容器中<br> COPY指令中，宿主主机上的目录必须是相对于构建时所用的dockerfile所在的目录。</li></ul> 
<pre><code>COPY local_folder/ /usr/mysql_folder/
COPY local_folder/a.tar /usr/mysql_folder/
</code></pre> 
<ul><li>ENTRYPOINT: 只允许一个，如果有多个，会发生覆盖，只执行最后一个。</li></ul> 
<pre><code>ENTRYPOINT ["nginx", "-g", "daemon off;"]
</code></pre> 
<ul><li>EXPOSE: 用于指定与外界交互的端口号，但并不会关联，需要在运行容器时通过-p来关联这些端口号</li></ul> 
<pre><code># 声明容器可以使用80和443端口
EXPOSE 80 443
</code></pre> 
<ul><li>VOLUME: 用于指定容器运行时创建的匿名数据卷路径，在启动容器docker run的时候，我们可以通过-v参数修改挂载点。即容器运行时，会创建VOLUME指定的目录，任何向该目录中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化，可以避免容器不断变大。</li><li>WORKDIR: 工作目录，类似于cd命令，会进入到指定目录下</li></ul> 
<h4><a id="5_dockercompose_up_d_build_139"></a>5. docker-compose up -d --build</h4> 
<pre><code>docker-compose up -d --build
</code></pre> 
<p>根据dockerfile重新下载镜像，运行容器，不使用缓存</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bf8c5d8c0232b53a85964604e405d6a0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python中selenium如何定位shadow-root中的元素</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/604e731bdb8fef12004f89bffe64d1a3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">hive 多行转一列</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>