<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>strassen矩阵乘法 java_分治法-Strassen矩阵乘法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="strassen矩阵乘法 java_分治法-Strassen矩阵乘法" />
<meta property="og:description" content="算法思想：分治法 实际问题：Strassen 矩阵乘法 编写语言：Java
问题描述
我们知道，两个大小为 2 * 2 的矩阵相乘，一般需要进行 8 次乘法。而Strassen矩阵乘法可以减少一次乘法，只需要 7 次，看似很少，但当数据量很大时，效率就会有显著提升。不过使用 Strassen矩阵乘法需要满足 矩阵边长为 2 的幂次方。因为该算法会用到分治，如果分治后矩阵两边边长不等，结果会出错。
使用下面的方法计算结果矩阵，假设两个长度为 2 的矩阵是 A，B，相乘后的结果矩阵为 C：
M1 = A11(B12 - B22)注：Anm 表示 A 矩阵第 n 行 k 列的值，Bnm，Cnm 同理
M2 = (A11 &#43; A12)B22
M3 = (A21 &#43; A22)B11
M4 = A22(B21 - B11)
M5 = (A11 &#43; A22)(B11 &#43; B22)
M6 = (A12 - A22)(B21 &#43; B22)
M7 = (A11 - A21)(B11 &#43; B12)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ba4f91305a38ca891a17791e4ebf7158/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-22T03:23:07+08:00" />
<meta property="article:modified_time" content="2021-02-22T03:23:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">strassen矩阵乘法 java_分治法-Strassen矩阵乘法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>算法思想：分治法 实际问题：Strassen 矩阵乘法 编写语言：Java</p> 
 <p>问题描述</p> 
 <p>我们知道，两个大小为 2 * 2 的矩阵相乘，一般需要进行 8 次乘法。而Strassen矩阵乘法可以减少一次乘法，只需要 7 次，看似很少，但当数据量很大时，效率就会有显著提升。不过使用 Strassen矩阵乘法需要满足 矩阵边长为 2 的幂次方。因为该算法会用到分治，如果分治后矩阵两边边长不等，结果会出错。</p> 
 <p>使用下面的方法计算结果矩阵，假设两个长度为 2 的矩阵是 A，B，相乘后的结果矩阵为 C：</p> 
 <p>M1 = A11(B12 - B22)注：Anm 表示 A 矩阵第 n 行 k 列的值，Bnm，Cnm 同理</p> 
 <p>M2 = (A11 + A12)B22</p> 
 <p>M3 = (A21 + A22)B11</p> 
 <p>M4 = A22(B21 - B11)</p> 
 <p>M5 = (A11 + A22)(B11 + B22)</p> 
 <p>M6 = (A12 - A22)(B21 + B22)</p> 
 <p>M7 = (A11 - A21)(B11 + B12)</p> 
 <p>可得结果为：</p> 
 <p>C11 = M5 + M4 - M2 + M6</p> 
 <p>C12 = M1 + M2</p> 
 <p>C21 = M3 + M4</p> 
 <p>C22 = M5 + M1 - M3 - M7</p> 
 <p>Java代码</p> 
 <p>public class StrassenMatrixMultiply</p> 
 <p>{<!-- --></p> 
 <p>public static void main(String[] args)</p> 
 <p>{<!-- --></p> 
 <p>int[] a = new int[]</p> 
 <p>{<!-- --></p> 
 <p>1, 1, 1, 1,</p> 
 <p>2, 2, 2, 2,</p> 
 <p>3, 3, 3, 3,</p> 
 <p>4, 4, 4, 4</p> 
 <p>};</p> 
 <p>int[] b = new int[]</p> 
 <p>{<!-- --></p> 
 <p>1, 2, 3, 4,</p> 
 <p>1, 2, 3, 4,</p> 
 <p>1, 2, 3, 4,</p> 
 <p>1, 2, 3, 4</p> 
 <p>};</p> 
 <p>int length = 4;</p> 
 <p>int[] c = sMM(a, b, length);</p> 
 <p>for(int i = 0; i &lt; c.length; i++)</p> 
 <p>{<!-- --></p> 
 <p>System.out.print(c[i] + " ");</p> 
 <p>if((i + 1) % length == 0) //换行</p> 
 <p>System.out.println();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>public static int[] sMM(int[] a, int[] b, int length)</p> 
 <p>{<!-- --></p> 
 <p>if(length == 2)</p> 
 <p>{<!-- --></p> 
 <p>return getResult(a, b);</p> 
 <p>}</p> 
 <p>else</p> 
 <p>{<!-- --></p> 
 <p>int tlength = length / 2;</p> 
 <p>//把a数组分为四部分，进行分治递归</p> 
 <p>int[] aa = new int[tlength * tlength];</p> 
 <p>int[] ab = new int[tlength * tlength];</p> 
 <p>int[] ac = new int[tlength * tlength];</p> 
 <p>int[] ad = new int[tlength * tlength];</p> 
 <p>//把b数组分为四部分，进行分治递归</p> 
 <p>int[] ba = new int[tlength * tlength];</p> 
 <p>int[] bb = new int[tlength * tlength];</p> 
 <p>int[] bc = new int[tlength * tlength];</p> 
 <p>int[] bd = new int[tlength * tlength];</p> 
 <p>//划分子矩阵</p> 
 <p>for(int i = 0; i &lt; length; i++)</p> 
 <p>{<!-- --></p> 
 <p>for(int j = 0; j &lt; length; j++)</p> 
 <p>{<!-- --></p> 
 <p>/*</p> 
 <p>* 划分矩阵：</p> 
 <p>* 例子：将 4 * 4 的矩阵，变为 2 * 2 的矩阵，</p> 
 <p>* 那么原矩阵左上、右上、左下、右下的四个元素分别归为新矩阵</p> 
 <p>*/</p> 
 <p>if(i &lt; tlength)</p> 
 <p>{<!-- --></p> 
 <p>if(j &lt; tlength)</p> 
 <p>{<!-- --></p> 
 <p>aa[i * tlength + j] = a[i * length + j];</p> 
 <p>ba[i * tlength + j] = b[i * length + j];</p> 
 <p>}</p> 
 <p>else</p> 
 <p>{<!-- --></p> 
 <p>ab[i * tlength + (j - tlength)]</p> 
 <p>= a[i * length + j];</p> 
 <p>bb[i * tlength + (j - tlength)]</p> 
 <p>= b[i * length + j];</p> 
 <p>}</p> 
 <p>}</p> 
 <p>else</p> 
 <p>{<!-- --></p> 
 <p>if(j &lt; tlength)</p> 
 <p>{<!-- --></p> 
 <p>//i 大于 tlength 时，需要减去 tlength，j同理</p> 
 <p>//因为 b，c，d三个子矩阵有对应了父矩阵的后半部分</p> 
 <p>ac[(i - tlength) * tlength + j]</p> 
 <p>= a[i * length + j];</p> 
 <p>bc[(i - tlength) * tlength + j]</p> 
 <p>= b[i * length + j];</p> 
 <p>}</p> 
 <p>else</p> 
 <p>{<!-- --></p> 
 <p>ad[(i - tlength) * tlength + (j - tlength)]</p> 
 <p>= a[i * length + j];</p> 
 <p>bd[(i - tlength) * tlength + (j - tlength)]</p> 
 <p>= b[i * length + j];</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>//分治递归</p> 
 <p>int[] result = new int[length * length];</p> 
 <p>//temp：4个临时矩阵</p> 
 <p>int[] t1 = add(sMM(aa, ba, tlength), sMM(ab, bc, tlength));</p> 
 <p>int[] t2 = add(sMM(aa, bb, tlength), sMM(ab, bd, tlength));</p> 
 <p>int[] t3 = add(sMM(ac, ba, tlength), sMM(ad, bc, tlength));</p> 
 <p>int[] t4 = add(sMM(ac, bb, tlength), sMM(ad, bd, tlength));</p> 
 <p>//归并结果</p> 
 <p>for(int i = 0; i &lt; length; i++)</p> 
 <p>{<!-- --></p> 
 <p>for(int j = 0; j &lt; length; j++)</p> 
 <p>{<!-- --></p> 
 <p>if(i &lt; tlength)</p> 
 <p>{<!-- --></p> 
 <p>if(j &lt; tlength)</p> 
 <p>result[i * length + j]</p> 
 <p>= t1[i * tlength + j];</p> 
 <p>else</p> 
 <p>result[i * length + j]</p> 
 <p>= t2[i * tlength + (j - tlength)];</p> 
 <p>}</p> 
 <p>else</p> 
 <p>{<!-- --></p> 
 <p>if(j &lt; tlength)</p> 
 <p>result[i * length + j]</p> 
 <p>= t3[(i - tlength) * tlength + j];</p> 
 <p>else</p> 
 <p>result[i * length + j]</p> 
 <p>= t4[(i - tlength) * tlength + (j - tlength)];</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>return result;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>public static int[] getResult(int[] a, int[] b)</p> 
 <p>{<!-- --></p> 
 <p>int p1 = a[0] * (b[1] - b[3]);</p> 
 <p>int p2 = (a[0] + a[1]) * b[3];</p> 
 <p>int p3 = (a[2] + a[3]) * b[0];</p> 
 <p>int p4 = a[3] * (b[2] - b[0]);</p> 
 <p>int p5 = (a[0] + a[3]) * (b[0] + b[3]);</p> 
 <p>int p6 = (a[1] - a[3]) * (b[2] + b[3]);</p> 
 <p>int p7 = (a[0] - a[2]) * (b[0] + b[1]);</p> 
 <p>int c00 = p5 + p4 - p2 + p6;</p> 
 <p>int c01 = p1 + p2;</p> 
 <p>int c10 = p3 + p4;</p> 
 <p>int c11 = p5 + p1 -p3 - p7;</p> 
 <p>return new int[] {c00, c01, c10, c11};</p> 
 <p>}</p> 
 <p>public static int[] add(int[] a, int[] b)</p> 
 <p>{<!-- --></p> 
 <p>int[] c = new int[a.length];</p> 
 <p>for(int i = 0; i &lt; a.length; i++)</p> 
 <p>c[i] = a[i] + b[i];</p> 
 <p>return c;</p> 
 <p>}</p> 
 <p>//返回一个数是不是2的幂次方</p> 
 <p>public static boolean adjust(int num)</p> 
 <p>{<!-- --></p> 
 <p>return (num &amp; (num - 1)) == 0;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>运行结果</p> 
 <p align="center"><img src="https://images2.imgbox.com/d5/25/KnT9qPf2_o.png" alt="765656ec56ff874c313a80f0ab5c0bc4.png"></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/85a7bf675b50ef39a2e31f5dcc0a827d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pytorch的两个函数 .detach() .detach_() 的作用和区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1b3c976cd85642a8e033a6396e7a77a6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mysql查询时的多表连接查询，默认连接，等值连接，JOIN，LEFT JOIN，RIGHT JOIN，INNER JOIN</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>