<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前馈神经网络（Feedforward neural network） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="前馈神经网络（Feedforward neural network）" />
<meta property="og:description" content="前馈神经网络（FNN）是一种人工神经网络，其中节点之间的连接不形成循环。因此，它不同于它的后代：递归神经网络。
在前馈网络中，信息总是向一个方向移动；它从不倒退。
前馈神经网络是设计的第一种也是最简单的人工神经网络。在该网络中，信息仅在一个方向上从输入节点向前移动，通过隐藏节点（如果有）并到达输出节点。网络中没有循环或环路。
单层感知器
最简单的神经网络是单层感知器网络，由单层输出节点组成；输入通过一系列权重直接馈给输出。在每个节点中计算权重和输入的乘积之和，如果该值高于某个阈值（通常为0），则神经元触发并取激活值（通常为1）；否则，它将取停用的值（通常为-1）。具有这种激活功能的神经元也称为人工神经元或线性阈值单元。在文献中，术语感知机通常指仅由这些单元之一组成的网络。沃伦·麦卡洛赫和沃尔特·皮茨在20世纪40年代描述了类似的神经元。
可以使用激活和停用状态的任何值来创建感知器，只要阈值介于两者之间。
感知器可以通过一种简单的学习算法来训练，该算法通常称为delta规则。它计算计算出的输出和样本输出数据之间的误差，并使用该误差对权重进行调整，从而实现一种梯度下降形式。
单层感知器只能学习线性可分离模式；1969年，Marvin Minsky和Seymour Papert在一篇名为《感知器》的著名专著中指出，单层感知器网络不可能学习异或函数（尽管如此，众所周知，多层感知器能够产生任何可能的布尔函数）。
虽然单个阈值单元的计算能力非常有限，但已经表明，并行阈值单元网络可以将任何连续函数从实数的紧凑区间近似为区间[-1,1]。这一结果可以在Peter Auer、Harald Burgsteiner和Wolfgang Maas的《由单层感知器组成的非常简单的通用近似器的学习规则》中找到。
单层神经网络可以计算连续输出而不是阶跃函数。一种常见的选择是所谓的逻辑函数：
通过这种选择，单层网络与广泛用于统计建模的逻辑回归模型相同。逻辑函数是称为S形函数的函数族之一，因为它们的S形图类似于希腊字母Sigma的最后一个字母小写。它具有连续导数，这允许它用于反向传播。该函数也是优选的，因为其导数易于计算：
（事实上f满足上述微分方程，可通过应用链式法则轻松表示。）
如果单层神经网络激活函数为模1，则该网络可以解决单个神经元的异或问题。
神经网络多层感知器
能够计算异或的两层神经网络。神经元内的数字表示每个神经元的显式阈值（可以将其分解，以便所有神经元具有相同的阈值，通常为1）。注释箭头的数字表示输入的权重。该网络假设如果未达到阈值，则输出零（非-1）。注意，输入的底层并不总是被视为真正的神经网络层
这类网络由多层计算单元组成，通常以前馈方式互连。一层中的每个神经元都与下一层的神经元有直接连接。在许多应用中，这些网络的单元应用S形函数作为激活函数。然而，S形激活函数在小范围外具有非常小的导数值，并且由于消失梯度问题，在深度神经网络中不能很好地工作。已经提出了S形激活函数的替代方案，以缓解消失梯度问题并允许训练深度网络。
神经网络的通用逼近定理表明，将实数区间映射到某个实数输出区间的每个连续函数都可以由一个只有一个隐藏层的多层感知器任意逼近。这一结果适用于广泛的激活函数，例如S形函数。
多层网络使用多种学习技术，最流行的是反向传播。这里，将输出值与正确答案进行比较，以计算某个预定义误差函数的值。通过各种技术，误差然后通过网络反馈。使用该信息，该算法调整每个连接的权重，以便将误差函数的值减小一小部分。在对足够多的训练周期重复该过程之后，网络通常将收敛到计算误差较小的某个状态。在这种情况下，可以说网络已经学习了某个目标函数。为了适当地调整权重，可以应用一种称为梯度下降的非线性优化的一般方法。为此，网络计算误差函数相对于网络权重的导数，并改变权重，使得误差减小（从而在误差函数的表面上向下）。因此，反向传播只能应用于具有可微激活函数的网络。
一般来说，教一个网络表现良好的问题，即使是在没有用作训练样本的样本上，也是一个相当微妙的问题，需要额外的技术。这对于只有非常有限数量的训练样本可用的情况尤为重要。[7] 危险在于网络过度拟合训练数据，无法捕获生成数据的真实统计过程。计算学习理论关注的是在有限的数据量上训练分类器。在神经网络的上下文中，一种简单的启发式方法，称为早期停止，通常可以确保网络能够很好地推广到不在训练集中的示例。
反向传播算法的其他典型问题是收敛速度和最终导致误差函数局部最小的可能性。今天，有一些实用的方法使多层感知器中的反向传播成为许多机器学习任务的首选工具。
人们还可以使用一系列由某种中介调节的独立神经网络，类似于大脑中发生的行为。这些神经元可以独立地执行和处理大型任务，最终可以将结果组合起来。
其他前馈网络
更一般地，任何有向无环图都可以用于前馈网络，其中一些节点（没有父节点）被指定为输入，而一些节点（无子节点）被设置为输出。这些可以被视为多层网络，其中一些边缘跳过层，从输出向后或从输入向前计数层。可以使用各种激活函数，并且权重之间可以存在关系，如在卷积神经网络中。
其他前馈网络的示例包括使用不同激活函数的径向基函数网络。
有时，多层感知器被松散地用于指代任何前馈神经网络，而在其他情况下，它仅限于特定的前馈神经网络（例如，具有特定的激活函数，或具有完全连接的层，或由感知器算法训练）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/15c908d97a9e4acb3e5a62fdab6216fa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-24T18:05:49+08:00" />
<meta property="article:modified_time" content="2022-08-24T18:05:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前馈神经网络（Feedforward neural network）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>前馈神经网络（FNN）是一种人工神经网络，其中节点之间的连接不形成循环。因此，它不同于它的后代：递归神经网络。</p> 
<p style="text-align:center;"><img alt="" height="409" src="https://images2.imgbox.com/ee/98/7EO1pFXg_o.jpg" width="362"></p> 
<p> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/62/91/U5vOx57O_o.jpg"></p> 
<p> 在前馈网络中，信息总是向一个方向移动；它从不倒退。</p> 
<p>前馈神经网络是设计的第一种也是最简单的人工神经网络。在该网络中，信息仅在一个方向上从输入节点向前移动，通过隐藏节点（如果有）并到达输出节点。网络中没有循环或环路。</p> 
<p><strong>单层感知器</strong></p> 
<p>最简单的神经网络是单层感知器网络，由单层输出节点组成；输入通过一系列权重直接馈给输出。在每个节点中计算权重和输入的乘积之和，如果该值高于某个阈值（通常为0），则神经元触发并取激活值（通常为1）；否则，它将取停用的值（通常为-1）。具有这种激活功能的神经元也称为人工神经元或线性阈值单元。在文献中，术语感知机通常指仅由这些单元之一组成的网络。沃伦·麦卡洛赫和沃尔特·皮茨在20世纪40年代描述了类似的神经元。</p> 
<p>可以使用激活和停用状态的任何值来创建感知器，只要阈值介于两者之间。</p> 
<p>感知器可以通过一种简单的学习算法来训练，该算法通常称为delta规则。它计算计算出的输出和样本输出数据之间的误差，并使用该误差对权重进行调整，从而实现一种梯度下降形式。</p> 
<p>单层感知器只能学习线性可分离模式；1969年，Marvin Minsky和Seymour Papert在一篇名为《感知器》的著名专著中指出，单层感知器网络不可能学习异或函数（尽管如此，众所周知，多层感知器能够产生任何可能的布尔函数）。</p> 
<p>虽然单个阈值单元的计算能力非常有限，但已经表明，并行阈值单元网络可以将任何连续函数从实数的紧凑区间近似为区间[-1,1]。这一结果可以在Peter Auer、Harald Burgsteiner和Wolfgang Maas的《由单层感知器组成的非常简单的通用近似器的学习规则》中找到。</p> 
<p>单层神经网络可以计算连续输出而不是阶跃函数。一种常见的选择是所谓的逻辑函数：</p> 
<p><img alt="f(x)=\frac{1}{1+e^{^{-x}}}" class="mathcode" src="https://images2.imgbox.com/00/d9/Mc2BViaP_o.png"></p> 
<p>通过这种选择，单层网络与广泛用于统计建模的逻辑回归模型相同。逻辑函数是称为S形函数的函数族之一，因为它们的S形图类似于希腊字母Sigma的最后一个字母小写。它具有连续导数，这允许它用于反向传播。该函数也是优选的，因为其导数易于计算：</p> 
<p><img alt="f'(x)=f(x)(1-f(x))." class="mathcode" src="https://images2.imgbox.com/7c/c7/9ZudhZCp_o.png"></p> 
<p>（事实上f满足上述微分方程，可通过应用链式法则轻松表示。）</p> 
<p>如果单层神经网络激活函数为模1，则该网络可以解决单个神经元的异或问题。</p> 
<p><img alt="f(x)=x\mod 1 f'(x)=1" class="mathcode" src="https://images2.imgbox.com/a1/0d/nanOfkx7_o.png"></p> 
<p><strong>神经网络多层感知器</strong></p> 
<p style="text-align:center;"><strong><img alt="" height="318" src="https://images2.imgbox.com/3b/b7/8QmRDpvB_o.jpg" width="344"></strong></p> 
<p> </p> 
<p>能够计算异或的两层神经网络。神经元内的数字表示每个神经元的显式阈值（可以将其分解，以便所有神经元具有相同的阈值，通常为1）。注释箭头的数字表示输入的权重。该网络假设如果未达到阈值，则输出零（非-1）。注意，输入的底层并不总是被视为真正的神经网络层</p> 
<p>这类网络由多层计算单元组成，通常以前馈方式互连。一层中的每个神经元都与下一层的神经元有直接连接。在许多应用中，这些网络的单元应用S形函数作为激活函数。然而，S形激活函数在小范围外具有非常小的导数值，并且由于消失梯度问题，在深度神经网络中不能很好地工作。已经提出了S形激活函数的替代方案，以缓解消失梯度问题并允许训练深度网络。</p> 
<p>神经网络的通用逼近定理表明，将实数区间映射到某个实数输出区间的每个连续函数都可以由一个只有一个隐藏层的多层感知器任意逼近。这一结果适用于广泛的激活函数，例如S形函数。</p> 
<p>多层网络使用多种学习技术，最流行的是反向传播。这里，将输出值与正确答案进行比较，以计算某个预定义误差函数的值。通过各种技术，误差然后通过网络反馈。使用该信息，该算法调整每个连接的权重，以便将误差函数的值减小一小部分。在对足够多的训练周期重复该过程之后，网络通常将收敛到计算误差较小的某个状态。在这种情况下，可以说网络已经学习了某个目标函数。为了适当地调整权重，可以应用一种称为梯度下降的非线性优化的一般方法。为此，网络计算误差函数相对于网络权重的导数，并改变权重，使得误差减小（从而在误差函数的表面上向下）。因此，反向传播只能应用于具有可微激活函数的网络。</p> 
<p>一般来说，教一个网络表现良好的问题，即使是在没有用作训练样本的样本上，也是一个相当微妙的问题，需要额外的技术。这对于只有非常有限数量的训练样本可用的情况尤为重要。[7] 危险在于网络过度拟合训练数据，无法捕获生成数据的真实统计过程。计算学习理论关注的是在有限的数据量上训练分类器。在神经网络的上下文中，一种简单的启发式方法，称为早期停止，通常可以确保网络能够很好地推广到不在训练集中的示例。</p> 
<p>反向传播算法的其他典型问题是收敛速度和最终导致误差函数局部最小的可能性。今天，有一些实用的方法使多层感知器中的反向传播成为许多机器学习任务的首选工具。</p> 
<p>人们还可以使用一系列由某种中介调节的独立神经网络，类似于大脑中发生的行为。这些神经元可以独立地执行和处理大型任务，最终可以将结果组合起来。</p> 
<p><strong>其他前馈网络</strong></p> 
<p>更一般地，任何有向无环图都可以用于前馈网络，其中一些节点（没有父节点）被指定为输入，而一些节点（无子节点）被设置为输出。这些可以被视为多层网络，其中一些边缘跳过层，从输出向后或从输入向前计数层。可以使用各种激活函数，并且权重之间可以存在关系，如在卷积神经网络中。</p> 
<p>其他前馈网络的示例包括使用不同激活函数的径向基函数网络。<br> 有时，多层感知器被松散地用于指代任何前馈神经网络，而在其他情况下，它仅限于特定的前馈神经网络（例如，具有特定的激活函数，或具有完全连接的层，或由感知器算法训练）。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1e303d54e899f73e8e0be2d63889d3e1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">截图神器Snipaste，错过真的太可惜</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ffcf2de43566e874afbf3efb2dbf0d4e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue中的element-ui和react的element-ui</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>