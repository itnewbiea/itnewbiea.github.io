<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 多关键字排序 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java 多关键字排序" />
<meta property="og:description" content="继承 Comparable接口
一开始默认可以在类内部重写排序规则：
首先继承排序接口：Comparable&lt;Person&gt;
int compare(Person p1, Person p2) 返回一个基本类型的整型， 返回负数表示：p1 小于 p2， 返回0 表示： p1 和 p2相等， 返回正数表示：p1 大于 p2 所以重写排序规则的时候很灵活。如果类型是数字的话，可以直接用前一个减后一个， 其他类型用 compareTo 函数。 如果从大到小排就 return 的时候把 p1 and p2 调换一下。 package com.ytc.alpha; import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; public class Person implements Comparable&lt;Person&gt;{ private String name; private Integer age; public Person(String name, Integer age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/aeebb0bb7fdb510e9b3ff4852154b042/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-09T15:07:37+08:00" />
<meta property="article:modified_time" content="2021-03-09T15:07:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 多关键字排序</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>继承 Comparable接口</p> 
<p>一开始默认可以在类内部重写排序规则：</p> 
<p>首先继承排序接口：Comparable&lt;Person&gt;</p> 
<pre><code class="language-java">int compare(Person p1, Person p2) 返回一个基本类型的整型，

返回负数表示：p1 小于 p2，

返回0 表示： p1 和 p2相等，

返回正数表示：p1 大于 p2

所以重写排序规则的时候很灵活。如果类型是数字的话，可以直接用前一个减后一个， 
其他类型用 compareTo 函数。

如果从大到小排就 return 的时候把 p1 and p2 调换一下。</code></pre> 
<pre><code class="language-java">package com.ytc.alpha;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class Person implements Comparable&lt;Person&gt;{
    private String name;
    private Integer age;

    public Person(String name, Integer age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public int compareTo(Person o) {
        return this.age - o.age;
    }

    public static void main(String[] args) {
        List&lt;Person&gt; plist = new ArrayList&lt;Person&gt;();
        Person p1 = new Person("0001", 14);
        Person p4 = new Person("0004",23);
        Person p5 = new Person("0005",25);
        Person p3 = new Person("0003",25);
        Person p6 = new Person("0006",25);
        Person p7 = new Person("0007",25);
        Person p2 = new Person("0002",20);

        plist.add(p1);
        plist.add(p2);
        plist.add(p3);
        plist.add(p4);
        plist.add(p5);
        plist.add(p6);
        plist.add(p7);
        for(Person person : plist){
            System.out.println("排序前的结果："+person.getName() + " " + person.getAge());
        }
        Collections.sort((plist));

        System.out.println();
        for(Person person : plist){
            System.out.println("排序前的结果："+person.getName() + " " + person.getAge());
        }
    }
}</code></pre> 
<p> </p> 
<p>比较器的使用</p> 
<p>默认是用 age 排序，但是有的时候需要用 name 来排序怎么办？ 这个时候比较器 ：Comparator 就排上用场了。</p> 
<p>Comparator 的使用有两种方式：</p> 
<ul><li> <p>Collections.sort(list,Comparator&lt;T&gt;);</p> </li></ul> 
<ul><li> <p>list.sort(Comparator&lt;T&gt;);</p> </li></ul> 
<p>其实主要是看 `Comparator` 接口的实现，重写里面的 `compare` 方法。代码如下：</p> 
<pre><code class="language-java">// 方法一
Collections.sort(plist, new Comparator&lt;Person&gt;(){
  @Override
  public int compare(Person p1, Person p2) {
    //按照Person的年龄进行升序排列,如果年龄一样按照姓名从大到小排序
    if (p1.getAge() == p2.getAge())
      return p2.getName().compareTo(p1.getName());
    return p1.getAge().compareTo(p2.getAge());
  }
});

// 方法二
plist.sort(new Comparator&lt;Person&gt;() {
  // 倒序排列
  @Override
  public int compare(Person o1, Person o2) {
    return o2.age.compareTo(o1.age);
  }
});
// 方法三：
// 定义一个比较器的类，然后直接用就可以了， 可以不用在主程序中写比较的内容
// 这个类要继承比较器的接口，然后重写比较的规则
class idComparator implements Comparator&lt;Person&gt; {
    @Override
    public int compare(Person o1, Person o2) {
        return o2.getAge() - o1.getAge();
    }
}</code></pre> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d279922e29ae90dd3b4729f90b0dabf4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">新希望面试</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f6895b2544b98282ac7f62d894df9687/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">QML-键盘按键事件处理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>