<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浏览器多线程到事件循环机制 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="浏览器多线程到事件循环机制" />
<meta property="og:description" content="浏览器多线程到事件循环机制 进程与线程 进程
进程是CPU分配资源的最小单位，它是一个可以自己独立运行且拥有自己资源空间的任务程序；包括程序以及程序所使用的内存及系统资源
当我们启动一个程序时就会创建一个进程来执行任务代码，同时会为该进程分配内存空间，该应用的状态都保存再该内存空间里；应用关闭时，应用空间就会被回收；进程可以启动更多的进程来执行任务，由于进程之间分配的内存空间是独立的；如果连个进程之间需要传递某些数据 ；则需要通过进程间的通信管道 IPC ；很多进程是多进程，是为了避免一个进程卡死，影响整个应用程序
进程可以将任务划分为多个小任务，启动多个线程并行执行不同的任务；同一个进程中的线程是可以直接通信，共享数据的
线程
线程是CPU调度的最小单位，它就是程序中的一个执行流；也可以理解为一个进程代码的不同执行路径
一个进程中只有一个执行流就是单线程，程序按照顺序执行，前面的处理好才执行后面的；一个进程中有多个执行流就是多线程，多个线程并行执行各自的任务
JS为什么是单线程
单线程就是同一时间只能做一件事情；JS是单线程是因为JS的主要作用是用户的交互，dom的操作；如果它是多线程，一个线程修改dom的内容；另一个线程也改了dom内容，那么到底怎么显示呢；为了避免这种复杂的问题，JS就是单线程（多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。而且，如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期）
为了提高效率，新的标准（html5提出的web worker标准）允许JS创建多个线程，但是子线程完全收主线程控制，且不得操作DOM，所以它本质上还是单线程
谷歌浏览器的进程模型 process-per-site-instance ​ 谷歌浏览器默认模型；访问不同站点或者同一站点的不同Tab标签页都会单独创建一个渲染进程；比如如果跨域使用了iframe，那么iframe的渲染进程是一个单独的进程
​ 它是最安全的，因为每个站点互补影响；但是它进程多，占用的内存空间也多
process-per-site
同一站点使用同一个渲染进程
process-per-tab
每个标签页所有站点使用同一个渲染进程
single process
浏览器 JS 引擎和渲染引擎共用一个进程；不推荐，因为不安全
浏览器从关闭状态进行启动，然后新开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个进程；后续再新开标签页，浏览器、网络进程、GPU进程是共享的，不会重新启动，如果2个页面属于同一站点的话，并且从a页面中打开的b页面，那么他们也会共用一个渲染进程，否则新开一个渲染进程。
最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。
如果我们打开多个Tab标签页，其中一个Tab标签页崩溃了，影响整个浏览器，那体验肯定是不行的，所以不可能是单进程；每个进程有多个线程都会占用资源，所以我们打开多个标签页可能会卡，谷歌浏览器就有标签页限制
浏览器多进程 浏览器（Broswer）进程 浏览器的主进程，该进程只有一个，主要负责与其他进程之间的协调、主控的作用
负责浏览器的页面展示、交互；（前进后退、书签等）
负责页面的子进程管理，创建和销毁其他进程
网络资源的管理，下载等
UI 线程：只有一个，浏览器主进程，负责处理选项卡页面之外的内容，用于控制用户可见的 UI 部分
（比如地址栏，书签，后退、前进按钮）
网络线程：发送请求，接收数据" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/983af2a73a1db2fb7beaa4e629498a7c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-03T14:37:48+08:00" />
<meta property="article:modified_time" content="2023-06-03T14:37:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浏览器多线程到事件循环机制</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>浏览器多线程到事件循环机制</h2> 
<h3><a id="_2"></a>进程与线程</h3> 
<p><strong>进程</strong></p> 
<p>进程是CPU分配资源的最小单位，它是一个可以自己独立运行且拥有自己资源空间的任务程序；包括程序以及程序所使用的内存及系统资源</p> 
<p>当我们启动一个程序时就会创建一个进程来执行任务代码，同时会为该进程分配内存空间，该应用的状态都保存再该内存空间里；应用关闭时，应用空间就会被回收；进程可以启动更多的进程来执行任务，由于进程之间分配的内存空间是独立的；如果连个进程之间需要传递某些数据 ；则需要通过进程间的通信管道 IPC ；很多进程是多进程，是为了避免一个进程卡死，影响整个应用程序</p> 
<p>进程可以将任务划分为多个小任务，启动多个线程并行执行不同的任务；同一个进程中的线程是可以直接通信，共享数据的</p> 
<p><strong>线程</strong></p> 
<p>线程是CPU调度的最小单位，它就是程序中的一个执行流；也可以理解为一个进程代码的不同执行路径</p> 
<p>一个进程中只有一个执行流就是单线程，程序按照顺序执行，前面的处理好才执行后面的；一个进程中有多个执行流就是多线程，多个线程并行执行各自的任务</p> 
<p><strong>JS为什么是单线程</strong></p> 
<p>单线程就是同一时间只能做一件事情；JS是单线程是因为JS的主要作用是用户的交互，dom的操作；如果它是多线程，一个线程修改dom的内容；另一个线程也改了dom内容，那么到底怎么显示呢；为了避免这种复杂的问题，JS就是单线程（多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。而且，如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期）</p> 
<p>为了提高效率，新的标准（html5提出的web worker标准）允许JS创建多个线程，但是子线程完全收主线程控制，且不得操作DOM，所以它本质上还是单线程</p> 
<h3><a id="_24"></a><strong>谷歌浏览器的进程模型</strong></h3> 
<ul><li>process-per-site-instance</li></ul> 
<p>​ 谷歌浏览器默认模型；访问不同站点或者同一站点的不同Tab标签页都会单独创建一个渲染进程；比如如果跨域使用了iframe，那么iframe的渲染进程是一个单独的进程</p> 
<p>​ 它是最安全的，因为每个站点互补影响；但是它进程多，占用的内存空间也多</p> 
<ul><li> <p>process-per-site</p> <p>同一站点使用同一个渲染进程</p> </li><li> <p>process-per-tab</p> <p>每个标签页所有站点使用同一个渲染进程</p> </li><li> <p>single process</p> <p>浏览器 JS 引擎和渲染引擎共用一个进程；不推荐，因为不安全</p> </li></ul> 
<p>浏览器从关闭状态进行启动，然后新开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个进程；后续再新开标签页，浏览器、网络进程、GPU进程是共享的，不会重新启动，如果2个页面属于同一站点的话，并且从a页面中打开的b页面，那么他们也会共用一个渲染进程，否则新开一个渲染进程。</p> 
<p>最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。</p> 
<p>如果我们打开多个Tab标签页，其中一个Tab标签页崩溃了，影响整个浏览器，那体验肯定是不行的，所以不可能是单进程；每个进程有多个线程都会占用资源，所以我们打开多个标签页可能会卡，谷歌浏览器就有标签页限制</p> 
<h3><a id="_51"></a>浏览器多进程</h3> 
<p><img src="https://images2.imgbox.com/2a/bf/SCTikNT3_o.jpg" alt="在这里插入图片描述"></p> 
<h5><a id="Broswer_56"></a><strong>浏览器（Broswer）进程</strong></h5> 
<p>浏览器的主进程，该进程只有一个，主要负责与其他进程之间的协调、主控的作用</p> 
<p>负责浏览器的页面展示、交互；（前进后退、书签等）</p> 
<p>负责页面的子进程管理，创建和销毁其他进程</p> 
<p>网络资源的管理，下载等</p> 
<ul><li> <p>UI 线程：只有一个，浏览器主进程，负责处理选项卡页面之外的内容，用于控制用户可见的 UI 部分</p> <p>（比如地址栏，书签，后退、前进按钮）</p> </li><li> <p>网络线程：发送请求，接收数据</p> </li><li> <p>存储线程：控制对文件的访问</p> </li></ul> 
<h5><a id="_74"></a><strong>第三方插件进程</strong></h5> 
<p>使用插件是才创建，一个插件对应一个进程</p> 
<h5><a id="GPU_78"></a><strong>GPU进程</strong></h5> 
<p>只有一个，处理图像，3d 绘制，提高性能</p> 
<p>其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程；</p> 
<p>它是使用浏览器的硬件加速技术实现的。GPU进程主要负责处理和管理GPU相关的操作和资源，同时确保GPU的安全和稳定性, 负责3D作图和使用GPU加速的网页效果的运行</p> 
<h5><a id="Render_86"></a><strong>渲染（Render）进程</strong></h5> 
<p>Render渲染进程的核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页；（谷歌浏览器排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中）；</p> 
<p>默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下</p> 
<p>​</p> 
<p>内核分为渲染引擎和 JS 引擎，由于js引擎越来越独立，内核就倾向于只指渲染引擎</p> 
<p>浏览器内核：内核分为渲染引擎和 JS 引擎</p> 
<table><thead><tr><th>内核</th><th>浏览器</th><th>说明</th></tr></thead><tbody><tr><td>Trident</td><td>IE</td><td></td></tr><tr><td>Gecko</td><td>Firefox</td><td></td></tr><tr><td>Webkit</td><td>Safari</td><td>苹果</td></tr><tr><td>Blink</td><td>Chrome/Opera/Edge</td><td></td></tr></tbody></table> 
<h5><a id="_105"></a>网络进程</h5> 
<p>主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，后面才独立成为一个单独的进程</p> 
<h3><a id="Render_109"></a>Render进程及它主要的线程</h3> 
<p>render渲染进程是多线程</p> 
<h5><a id="GUI_113"></a><strong>GUI渲染线程</strong></h5> 
<p>主要负责页面的渲染，解析html、css,生成DOM树、CSS规则树，构建Render树，页面的布局绘制</p> 
<h5><a id="JS_117"></a><strong>JS引擎线程程</strong></h5> 
<p>负责解析JavaScript脚本，运行代码；JS是单线程</p> 
<p><em><strong>JS引擎线程与GUI渲染线程互斥</strong></em>：</p> 
<p>因为JS引擎可以修改DOM树，那么如果JS引擎在执行修改了DOM结构的同时，GUI线程也在渲染页面，那么这样就会导致渲染线程获取的DOM的元素信息可能与JS引擎操作DOM后的结果不一致。</p> 
<p>当JS引擎执行的时候，GUI线程需要被冻结，但是GUI的渲染会被保存在一个队列当中，等待JS引擎空闲的时候执行渲染</p> 
<p>如果JS引擎正在进行CPU密集型计算，那么JS引擎将会阻塞，长时间不空闲，导致渲染进程一直不能执行渲染，页面就会看起来卡顿卡顿的，渲染不连贯。所以，要尽量避免JS执行时间过长。</p> 
<h5><a id="_129"></a>事件触发线程</h5> 
<p>属于浏览器而不是JS引擎</p> 
<p>用来控制事件循环，管理事件队列</p> 
<p>当js执行碰到事件绑定和异步操作会走事件触发线程，将对应的事件添加到对用的线程中；当事件触发或异步有了结果将它们的回调事件添加到事件队列等待JS引擎事件线程处理</p> 
<p>因为JS是单线程，所以事件队列中的事件都要等待JS引擎线程处理</p> 
<h5><a id="_139"></a>定时触发线程</h5> 
<p>浏览器定计数器不是在 JS 引擎线程中计数的（JS引擎是单线程，如果处于阻塞线程状态就计不了时,JS引擎线程与GUI渲染线程互斥，GUI进程执行的时候就阻塞了JS引擎线程，就记不了时了）</p> 
<p>计时完成后，会添加到事件触发线程的事件队列中</p> 
<p>W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms</p> 
<h5><a id="http_147"></a>异步http请求线程</h5> 
<p>当执行到一个http异步请求时，就把异步请求事件添加到异步请求线程，等收到响应(准确来说应该是http状态变化)，再把回调函数添加到事件队列，等待js引擎线程来执行</p> 
<h3><a id="Event_Loop_151"></a>事件循环机制Event Loop</h3> 
<p>JS分为同步任务和异步任务，同步任务在主线程也就是JS引擎线程上执行</p> 
<p>除了主线程之外，我们的事件触发线程中有一个任务队列，只要异步事件有了结果就会在任务队列总添加它的回调事件；任务队列中由两个队列，一个宏任务队列，一个时微任务队列</p> 
<p>1》首先我们的同步任务会进入主执行栈，异步任务交给事件触发线程，异步任务有了结果才会被添加到事件队列中</p> 
<p>2》当我们主执行栈中的代码执行之后，会先去微任务队列读取任务，然后执行</p> 
<p>3》执行完所有的微任务后又会到微任务队列中读取微任务（因为刚才可能产生了新的微任务），直到没有读取到微任务，然后GUI渲染线程会进行一次渲染（会阻塞js执行）</p> 
<p>4》渲染后会去宏任务队列读取宏任务，然后执行</p> 
<p>5》宏任务执行完毕会去微任务队列读取任务，有就执行，然后和之前一样，读取微任务直到没有微任务，进行渲染</p> 
<p>6》重复上面的事情，宏任务-微任务-渲染</p> 
<p><img src="https://images2.imgbox.com/c3/09/OdR9FEwQ_o.jpg" alt="在这里插入图片描述"></p> 
<p>每次循环都会检查任务队列中是否有任务存在，如果有，就去取出任务执行，执行完后进入下一次循环，如果没有，进入休眠状态</p> 
<p>当事件队列中有新的事件添加进来了；主线程如果是休眠状态，则会将其唤醒继续循环拿去任务</p> 
<p><strong>宏任务</strong></p> 
<p>所有微任务执行完后，下一个宏任务执行前，GUI渲染线程判断是否渲染一次页面</p> 
<p>常见宏任务：</p> 
<p>setTimeout</p> 
<p>setInterval</p> 
<p>requestAnimationFrame(浏览器)</p> 
<p><strong>微任务</strong></p> 
<p>常见微任务</p> 
<p>Promise.then()</p> 
<p>Promise.catch()</p> 
<p>Promise.finally()</p> 
<p>process.nextTick (node)</p> 
<p>Object.observe</p> 
<p><strong>this.$nextTick()</strong></p> 
<p>Vue异步执行DOM更新。只要观察到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作上非常重要。然后，在下一个的事件循环“tick”中，Vue刷新队列并执行实际 (已去重的) 工作。</p> 
<p>nextTick会创建一个微任务（或宏任务），将其推入微任务队列中，vue中一个事件循环中所有dom更新也是一个微任务，dom更新再这个微任务之前进入微任务队列中，是先更新dom再执行this.$next中的代码，所以可以再里面获取到更新后的dom</p> 
<p>异步处理更新队列的逻辑：在下一个的事件循环“tick”中，去刷新队列，依次尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境都不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替；所以this.$nextTick(vue中) 可能是一个微任务也可能时宏任务</p> 
<p>我们再来梳理一遍上面从数据变更到 dom 更新之前的整个流程</p> 
<ul><li>修改响应式数据</li><li>触发 <code>Object.defineProperty</code> 中的 <code>set</code></li><li>发布通知</li><li>触发 <code>Watcher</code> 中的 <code>update</code> 方法，</li><li><code>update</code> 方法中把 <code>Watcher</code> 缓冲到一个队列</li><li>刷新队列的方法(其实就是更新 dom 的方法)传到 <code>nextTick</code> 方法中</li><li><code>nextTick</code> 方法中把传进来的 <code>callback</code> 都放在一个数组 <code>callbacks</code> 中，然后放在异步队列中去执行</li></ul> 
<p>然后这时你调用了 <code>$nextTick</code> 方法，传进来一个获取最新 dom 的回调，这个回调也会推到那个数组 callbacks 中，此时遍历 callbacks 并执行所有回调的动作已经放到了异步队列中，到这（假设你后面没有其他的代码了）所有的同步代码就执行完了，然后开始执行异步队列中的任务，更新 dom 的方法是最先被推进去的，所以就先执行，你传进来的获取最新 dom 的回调是最后传进来的所以最后执行，显而易见，当执行到你的回调的时候，前面更新 dom 的动作都已经完成了，所以现在你的回调就能获取到最新的 dom 了。</p> 
<p><strong>如何理解JS中的异步</strong>：</p> 
<p>js是一门单线程语言，有i那位它运行在浏览器的渲染主线程中，而渲染主线程只有一个</p> 
<p>渲染主线程有很多任务要出李，如果使用同步的方式，就极有可能导致主线程阻塞，导致其他任务无法执行，这样主线程的事件被浪费掉了，也买你也无法及时更新，体验也差</p> 
<p>所以浏览器采用异步的方式来避免这种情况；当有些任务发送是，主线程会交给其他线程处理，自身立即结束任务的执行其他线程完成是，将实现称帝的回调包装程任务，加到消息队列末尾，等待主线程调度执行</p> 
<p>这种异步模式下，浏览器不会阻塞，最大限度的保证单线程的流畅运行</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2f938c3d832ab8636e1098dc37242110/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Python开发】FastAPI 02：请求参数—路径参数、查询参数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/995c18ece51d73e6a899fac33b10c684/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mongodb在docker容器中的集群部署</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>