<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android线程管理（二）——ActivityThread - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android线程管理（二）——ActivityThread" />
<meta property="og:description" content="线程通信、ActivityThread及Thread类是理解Android线程管理的关键。 线程，作为CPU调度资源的基本单位，在Android等针对嵌入式设备的操作系统中，有着非常重要和基础的作用。本小节主要从以下三个方面进行分析： 《Android线程管理（一）——线程通信》 《Android线程管理（二）——ActivityThread》 《Android线程管理（三）——Thread类的内部原理、休眠及唤醒》 二、ActivityThread的主要工作及实现机制 ActivityThread是Android应用的主线程（UI线程），说起ActivityThread，不得不提到Activity的创建、启动过程以及ActivityManagerService，但本文将仅从线程管理的角度来分析ActivityThread。ActivityManagerService、ActivityStack、ApplicationThread等会在后续文章中详细分析，敬请期待喔~~不过为了说清楚ActivityThread的由来，还是需要简单介绍下。
以下引用自罗升阳大师的博客：《Android应用程序的Activity启动过程简要介绍和学习计划》
Step 1. 无论是通过Launcher来启动Activity，还是通过Activity内部调用startActivity接口来启动新的Activity，都通过Binder进程间通信进入到ActivityManagerService进程中，并且调用ActivityManagerService.startActivity接口； Step 2. ActivityManagerService调用ActivityStack.startActivityMayWait来做准备要启动的Activity的相关信息； Step 3. ActivityStack通知ApplicationThread要进行Activity启动调度了，这里的ApplicationThread代表的是调用ActivityManagerService.startActivity接口的进程，对于通过点击应用程序图标的情景来说，这个进程就是Launcher了，而对于通过在Activity内部调用startActivity的情景来说，这个进程就是这个Activity所在的进程了； Step 4. ApplicationThread不执行真正的启动操作，它通过调用ActivityManagerService.activityPaused接口进入到ActivityManagerService进程中，看看是否需要创建新的进程来启动Activity； Step 5. 对于通过点击应用程序图标来启动Activity的情景来说，ActivityManagerService在这一步中，会调用startProcessLocked来创建一个新的进程，而对于通过在Activity内部调用startActivity来启动新的Activity来说，这一步是不需要执行的，因为新的Activity就在原来的Activity所在的进程中进行启动； Step 6. ActivityManagerServic调用ApplicationThread.scheduleLaunchActivity接口，通知相应的进程执行启动Activity的操作； Step 7. ApplicationThread把这个启动Activity的操作转发给ActivityThread，ActivityThread通过ClassLoader导入相应的Activity类，然后把它启动起来。
大师的这段描述把ActivityManagerService、ActivityStack、ApplicationThread及ActivityThread的调用关系讲的很清楚，本文将从ActivityThread的main()方法开始分析其主要工作及实现机制。
ActivityThread源码来自：https://github.com/android/platform_frameworks_base/blob/master/core/java/android/app/ActivityThread.java
public static void main(String[] args) { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &#34;ActivityThreadMain&#34;); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a2120399652cafdb8f5a43f7dcdf6685/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-01-19T09:19:00+08:00" />
<meta property="article:modified_time" content="2016-01-19T09:19:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android线程管理（二）——ActivityThread</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>      线程通信、ActivityThread及Thread类是理解Android线程管理的关键。 </p> 
 <p>      线程，作为CPU调度资源的基本单位，在Android等针对嵌入式设备的操作系统中，有着非常重要和基础的作用。本小节主要从以下三个方面进行分析： </p> 
 <ol><li><a href="http://www.cnblogs.com/younghao/p/5116819.html" rel="nofollow">《Android线程管理（一）——线程通信》</a> </li><li>《<a href="http://www.cnblogs.com/younghao/p/5126408.html" rel="nofollow">Android线程管理（二）——ActivityThread</a>》  </li><li>《Android线程管理（三）——Thread类的内部原理、休眠及唤醒》 </li></ol> 
 <p> </p> 
 <hr> 
 <h4>二、ActivityThread的主要工作及实现机制</h4> 
 <p>      ActivityThread是Android应用的主线程（UI线程），说起ActivityThread，不得不提到Activity的创建、启动过程以及ActivityManagerService，但本文将仅从线程管理的角度来分析ActivityThread。ActivityManagerService、ActivityStack、ApplicationThread等会在后续文章中详细分析，敬请期待喔~~不过为了说清楚ActivityThread的由来，还是需要简单介绍下。</p> 
 <p>      以下引用自罗升阳大师的博客：《<a href="http://blog.csdn.net/luoshengyang/article/details/6685853">Android应用程序的Activity启动过程简要介绍和学习计划</a>》</p> 
 <blockquote> 
  <p>Step 1. 无论是通过Launcher来启动Activity，还是通过Activity内部调用startActivity接口来启动新的Activity，都通过Binder进程间通信进入到ActivityManagerService进程中，并且调用ActivityManagerService.startActivity接口；  </p> 
  <p>Step 2. ActivityManagerService调用ActivityStack.startActivityMayWait来做准备要启动的Activity的相关信息； </p> 
  <p>Step 3. ActivityStack通知ApplicationThread要进行Activity启动调度了，这里的ApplicationThread代表的是调用ActivityManagerService.startActivity接口的进程，对于通过点击应用程序图标的情景来说，这个进程就是Launcher了，而对于通过在Activity内部调用startActivity的情景来说，这个进程就是这个Activity所在的进程了； </p> 
  <p>Step 4. ApplicationThread不执行真正的启动操作，它通过调用ActivityManagerService.activityPaused接口进入到ActivityManagerService进程中，看看是否需要创建新的进程来启动Activity； </p> 
  <p>Step 5. 对于通过点击应用程序图标来启动Activity的情景来说，ActivityManagerService在这一步中，会调用startProcessLocked来创建一个新的进程，而对于通过在Activity内部调用startActivity来启动新的Activity来说，这一步是不需要执行的，因为新的Activity就在原来的Activity所在的进程中进行启动； </p> 
  <p>Step 6. ActivityManagerServic调用ApplicationThread.scheduleLaunchActivity接口，通知相应的进程执行启动Activity的操作； </p> 
  <p>Step 7. ApplicationThread把这个启动Activity的操作转发给ActivityThread，ActivityThread通过ClassLoader导入相应的Activity类，然后把它启动起来。</p> 
 </blockquote> 
 <p>      大师的这段描述把ActivityManagerService、ActivityStack、ApplicationThread及ActivityThread的调用关系讲的很清楚，本文将从ActivityThread的main()方法开始分析其主要工作及实现机制。</p> 
 <p>      ActivityThread源码来自：<a title="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/app/ActivityThread.java" href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/app/ActivityThread.java">https://github.com/android/platform_frameworks_base/blob/master/core/java/android/app/ActivityThread.java</a></p> 
 <div style="border-bottom:#cccccc 1px solid;border-left:#cccccc 1px solid;border-top:#cccccc 1px solid;border-right:#cccccc 1px solid;" class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">public</span> <span style="color:#0000ff;">static</span> <span style="color:#0000ff;">void</span><span style="color:#000000;"> main(String[] args) {
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, </span>"ActivityThreadMain"<span style="color:#000000;">);
        SamplingProfilerIntegration.start();

        </span><span style="color:#008000;">//</span><span style="color:#008000;"> CloseGuard defaults to true and can be quite spammy.  We
        </span><span style="color:#008000;">//</span><span style="color:#008000;"> disable it here, but selectively enable it later (via
        </span><span style="color:#008000;">//</span><span style="color:#008000;"> StrictMode) on debug builds, but using DropBox, not logs.</span>
        CloseGuard.setEnabled(<span style="color:#0000ff;">false</span><span style="color:#000000;">);

        Environment.initForCurrentUser();

        </span><span style="color:#008000;">//</span><span style="color:#008000;"> Set the reporter for event logging in libcore</span>
        EventLogger.setReporter(<span style="color:#0000ff;">new</span><span style="color:#000000;"> EventLoggingReporter());

        AndroidKeyStoreProvider.install();

        </span><span style="color:#008000;">//</span><span style="color:#008000;"> Make sure TrustedCertificateStore looks in the right place for CA certificates</span>
        <span style="color:#0000ff;">final</span> File configDir =<span style="color:#000000;"> Environment.getUserConfigDirectory(UserHandle.myUserId());
        TrustedCertificateStore.setDefaultUserDirectory(configDir);

        Process.setArgV0(</span>"&lt;pre-initialized&gt;"<span style="color:#000000;">);

        </span><span style="color:#000000;">

        </span><span style="color:#0000ff;">throw</span> <span style="color:#0000ff;">new</span> RuntimeException("Main thread loop unexpectedly exited"<span style="color:#000000;">);
    }</span></pre> 
 </div> 
 <p>      上述代码中，红色部分之前的代码主要用于环境初始化、AndroidKeyStoreProvider安装等，这里不做重点说明。红色部分的代码主要分为两个功能块：1）绑定应用进程到ActivityManagerService；2）主线程Handler消息处理。</p> 
 <p>      关于线程通信机制，Handler、MessageQueue、Message及Looper四者的关系请参考上一篇文章《<a href="http://www.cnblogs.com/younghao/p/5116819.html" rel="nofollow">Android线程管理——线程通信</a>》。</p> 
 <h5>2.1 应用进程绑定</h5> 
 <p>      main()方法通过thread.attach(false)绑定应用进程。ActivityManagerNative通过getDefault()方法返回ActivityManagerService实例，ActivityManagerService通过attachApplication将ApplicationThread对象绑定到ActivityManagerService，而ApplicationThread作为Binder实现ActivityManagerService对应用进程的通信和控制。</p> 
 <div style="border-bottom:#cccccc 1px solid;border-left:#cccccc 1px solid;border-top:#cccccc 1px solid;border-right:#cccccc 1px solid;" class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">private</span> <span style="color:#0000ff;">void</span> attach(<span style="color:#0000ff;">boolean</span><span style="color:#000000;"> system) {
        sCurrentActivityThread </span>= <span style="color:#0000ff;">this</span><span style="color:#000000;">;
        mSystemThread </span>=<span style="color:#000000;"> system;
        </span><span style="color:#0000ff;">if</span> (!<span style="color:#000000;">system) {
            ……</span></pre> 
  <pre><span style="color:#000000;"></span><span style="color:#000000;">            RuntimeInit.setApplicationObject(mAppThread.asBinder());
            </span><span style="color:#0000ff;">final</span> IActivityManager mgr =<span style="color:#000000;"> ActivityManagerNative.getDefault();
            </span><span style="color:#0000ff;">try</span><span style="color:#000000;"> {
                mgr.attachApplication(mAppThread);
            } </span><span style="color:#0000ff;">catch</span><span style="color:#000000;"> (RemoteException ex) {
                </span><span style="color:#008000;">//</span><span style="color:#008000;"> Ignore</span>
<span style="color:#000000;">            }
            </span><span style="color:#008000;">……</span></pre> 
  <pre><span style="color:#008000;"></span><span style="color:#000000;">        } </span><span style="color:#0000ff;">else</span><span style="color:#000000;"> {
    ……
    }
}</span></pre> 
 </div> 
 <p>      在ActivityManagerService内部，attachApplication实际是通过调用attachApplicationLocked实现的，这里采用了<span style="color:#0000ff;">synchronized<font color="#333333">关键字保证同步。</font></span></p> 
 <div style="border-bottom:#cccccc 1px solid;border-left:#cccccc 1px solid;border-top:#cccccc 1px solid;border-right:#cccccc 1px solid;" class="cnblogs_code"> 
  <pre><span style="color:#000000;">@Override
</span><span style="color:#0000ff;">public</span> <span style="color:#0000ff;">final</span> <span style="color:#0000ff;">void</span><span style="color:#000000;"> attachApplication(IApplicationThread thread) {
    </span><span style="color:#0000ff;">synchronized</span> (<span style="color:#0000ff;">this</span><span style="color:#000000;">) {
        </span><span style="color:#0000ff;">int</span> callingPid =<span style="color:#000000;"> Binder.getCallingPid();
        </span><span style="color:#0000ff;">final</span> <span style="color:#0000ff;">long</span> origId =<span style="color:#000000;"> Binder.clearCallingIdentity();
        attachApplicationLocked(thread, callingPid);
        Binder.restoreCallingIdentity(origId);
    }
}</span></pre> 
 </div> 
 <p>      attachApplicationLocked的实现较为复杂，其主要功能分为两部分：</p> 
 <ul><li> <p>thread.bindApplication</p> </li><li> <p><font color="#333333">mStackSupervisor.attachApplicationLocked(app)</font></p></li></ul> 
 <div style="border-bottom:#cccccc 1px solid;border-left:#cccccc 1px solid;border-top:#cccccc 1px solid;border-right:#cccccc 1px solid;" class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">private</span> <span style="color:#0000ff;">final</span> <span style="color:#0000ff;">boolean</span><span style="color:#000000;"> attachApplicationLocked(IApplicationThread thread,
            </span><span style="color:#0000ff;">int</span><span style="color:#000000;"> pid) {

        </span><span style="color:#008000;">//</span><span style="color:#008000;"> Find the application record that is being attached...  either via
        </span><span style="color:#008000;">//</span><span style="color:#008000;"> the pid if we are running in multiple processes, or just pull the
        </span><span style="color:#008000;">//</span><span style="color:#008000;"> next app record if we are emulating process with anonymous threads.</span>
<span style="color:#000000;">        ProcessRecord app;
        </span><span style="color:#0000ff;">if</span> (pid != MY_PID &amp;&amp; pid &gt;= 0<span style="color:#000000;">) {
            </span><span style="color:#0000ff;">synchronized</span><span style="color:#000000;"> (mPidsSelfLocked) {
                app </span>=<span style="color:#000000;"> mPidsSelfLocked.get(pid);
            }
        } </span><span style="color:#0000ff;">else</span><span style="color:#000000;"> {
            app </span>= <span style="color:#0000ff;">null</span><span style="color:#000000;">;
        }
       </span><span style="color:#008000;">//</span><span style="color:#008000;"> ……</span>
        <span style="color:#0000ff;">try</span><span style="color:#000000;"> {
           </span><span style="color:#008000;">//</span><span style="color:#008000;"> ……</span>
<span style="color:#000000;">            </span><span style="color:#000000;">
            updateLruProcessLocked(app, </span><span style="color:#0000ff;">false</span>, <span style="color:#0000ff;">null</span><span style="color:#000000;">);
            app.lastRequestedGc </span>= app.lastLowMemory =<span style="color:#000000;"> SystemClock.uptimeMillis();
        } </span><span style="color:#0000ff;">catch</span><span style="color:#000000;"> (Exception e) {
            </span><span style="color:#008000;">//</span><span style="color:#008000;"> todo: Yikes!  What should we do?  For now we will try to
            </span><span style="color:#008000;">//</span><span style="color:#008000;"> start another process, but that could easily get us in
            </span><span style="color:#008000;">//</span><span style="color:#008000;"> an infinite loop of restarting processes...</span>
            Slog.wtf(TAG, "Exception thrown during bind of " +<span style="color:#000000;"> app, e);

            app.resetPackageList(mProcessStats);
            app.unlinkDeathRecipient();
            startProcessLocked(app, </span>"bind fail"<span style="color:#000000;">, processName);
            </span><span style="color:#0000ff;">return</span> <span style="color:#0000ff;">false</span><span style="color:#000000;">;
        }

        </span><span style="color:#008000;">//</span><span style="color:#008000;"> See if the top visible activity is waiting to run in this process...</span>
        <span style="color:#0000ff;">if</span><span style="color:#000000;"> (normalMode) {
            </span><span style="color:#0000ff;">try</span><span style="color:#000000;"> {
                </span><span style="color:#0000ff;">if</span><span style="color:#000000;"> () {
                    didSomething </span>= <span style="color:#0000ff;">true</span><span style="color:#000000;">;
                }
            } </span><span style="color:#0000ff;">catch</span><span style="color:#000000;"> (Exception e) {
                Slog.wtf(TAG, </span>"Exception thrown launching activities in " +<span style="color:#000000;"> app, e);
                badApp </span>= <span style="color:#0000ff;">true</span><span style="color:#000000;">;
            }
        }
    </span><span style="color:#008000;">//</span><span style="color:#008000;"> ……</span>
    }</pre> 
 </div> 
 <p>      thread对象其实是ActivityThread里ApplicationThread对象在ActivityManagerService的代理对象，故此执行thread.bindApplication，最终会调用ApplicationThread的bindApplication方法。该bindApplication方法的实质是通过向ActivityThread的消息队列发送BIND_APPLICATION消息，消息的处理调用handleBindApplication方法，handleBindApplication方法比较重要的是会调用如下方法：</p> 
 <div style="border-bottom:#cccccc 1px solid;border-left:#cccccc 1px solid;border-top:#cccccc 1px solid;border-right:#cccccc 1px solid;" class="cnblogs_code"> 
  <pre>mInstrumentation.callApplicationOnCreate(app);</pre> 
 </div> 
 <p>      callApplicationOnCreate即调用应用程序Application的onCreate()方法，说明Application的onCreate()方法会比所有activity的onCreate()方法先调用。</p> 
 <p><font color="#333333">      mStackSupervisor为ActivityManagerService的成员变量，类型为ActivityStackSupervisor。</font></p> 
 <div style="border-bottom:#cccccc 1px solid;border-left:#cccccc 1px solid;border-top:#cccccc 1px solid;border-right:#cccccc 1px solid;" class="cnblogs_code"> 
  <pre><span style="color:#008000;">/**</span><span style="color:#008000;"> Run all ActivityStacks through this </span><span style="color:#008000;">*/</span><span style="color:#000000;">
ActivityStackSupervisor mStackSupervisor;</span></pre> 
 </div> 
 <p>      从注释可以看出，<font color="#333333">mStackSupervisor为Activity堆栈管理辅助类实例。ActivityStackSupervisor的attachApplicationLocked()方法的调用了</font><font color="#333333">realStartActivityLocked()方法，在<font color="#333333">realStartActivityLocked()方法中，会调用scheduleLaunchActivity()方法：</font></font></p> 
 <div style="border-bottom:#cccccc 1px solid;border-left:#cccccc 1px solid;border-top:#cccccc 1px solid;border-right:#cccccc 1px solid;" class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">final</span> <span style="color:#0000ff;">boolean</span><span style="color:#000000;"> realStartActivityLocked(ActivityRecord r,
        ProcessRecord app, </span><span style="color:#0000ff;">boolean</span> andResume, <span style="color:#0000ff;">boolean</span><span style="color:#000000;"> checkConfig)
        </span><span style="color:#0000ff;">throws</span><span style="color:#000000;"> RemoteException {
 
    </span><span style="color:#008000;">//</span><span style="color:#008000;">...  </span>
    <span style="color:#0000ff;">try</span><span style="color:#000000;"> {
        </span><span style="color:#008000;">//</span><span style="color:#008000;">...</span>
        app.thread.scheduleLaunchActivity(<span style="color:#0000ff;">new</span><span style="color:#000000;"> Intent(r.intent), r.appToken,
                System.identityHashCode(r), r.info,
                </span><span style="color:#0000ff;">new</span><span style="color:#000000;"> Configuration(mService.mConfiguration),
                r.compat, r.icicle, results, newIntents, </span>!<span style="color:#000000;">andResume,
                mService.isNextTransitionForward(), profileFile, profileFd,
                profileAutoStop);
 
        </span><span style="color:#008000;">//</span><span style="color:#008000;">...</span>
<span style="color:#000000;"> 
    } </span><span style="color:#0000ff;">catch</span><span style="color:#000000;"> (RemoteException e) {
        </span><span style="color:#008000;">//</span><span style="color:#008000;">...</span>
<span style="color:#000000;">    }
    </span><span style="color:#008000;">//</span><span style="color:#008000;">...    </span>
    <span style="color:#0000ff;">return</span> <span style="color:#0000ff;">true</span><span style="color:#000000;">;
}</span></pre> 
 </div> 
 <p>      app.thread也是ApplicationThread对象在ActivityManagerService的一个代理对象，最终会调用ApplicationThread的scheduleLaunchActivity方法。</p> 
 <div style="border-bottom:#cccccc 1px solid;border-left:#cccccc 1px solid;border-top:#cccccc 1px solid;border-right:#cccccc 1px solid;" class="cnblogs_code"> 
  <pre><span style="color:#008000;">//</span><span style="color:#008000;"> we use token to identify this activity without having to send the
</span><span style="color:#008000;">//</span><span style="color:#008000;"> activity itself back to the activity manager. (matters more with ipc)</span>
<span style="color:#000000;">@Override
</span><span style="color:#0000ff;">public</span> <span style="color:#0000ff;">final</span> <span style="color:#0000ff;">void</span> scheduleLaunchActivity(Intent intent, IBinder token, <span style="color:#0000ff;">int</span><span style="color:#000000;"> ident,
    ActivityInfo info, Configuration curConfig, Configuration overrideConfig,
    CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,
    i</span><span style="color:#0000ff;">nt</span><span style="color:#000000;"> procState, Bundle state, PersistableBundle persistentState,
    List</span>&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt;<span style="color:#000000;"> pendingNewIntents,
    </span><span style="color:#0000ff;">boolean</span> notResumed, <span style="color:#0000ff;">boolean</span><span style="color:#000000;"> isForward, ProfilerInfo profilerInfo) {

        updateProcessState(procState, </span><span style="color:#0000ff;">false</span><span style="color:#000000;">);

        ActivityClientRecord r </span>= <span style="color:#0000ff;">new</span><span style="color:#000000;"> ActivityClientRecord();

        ……</span><span style="color:#000000;">
        sendMessage(H.LAUNCH_ACTIVITY, r);
}</span></pre> 
 </div> 
 <p>     同bindApplication()方法，最终是通过向ActivityThread的消息队列发送消息，在ActivityThread完成实际的LAUNCH_ACTIVITY的操作。</p> 
 <div style="border-bottom:#cccccc 1px solid;border-left:#cccccc 1px solid;border-top:#cccccc 1px solid;border-right:#cccccc 1px solid;" class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">public</span> <span style="color:#0000ff;">void</span><span style="color:#000000;"> handleMessage(Message msg) {
    </span><span style="color:#0000ff;">if</span> (DEBUG_MESSAGES) Slog.v(TAG, "&gt;&gt;&gt; handling: " +<span style="color:#000000;"> codeToString(msg.what));
    </span><span style="color:#0000ff;">switch</span><span style="color:#000000;"> (msg.what) {
        </span><span style="color:#0000ff;">case</span><span style="color:#000000;"> LAUNCH_ACTIVITY: {
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, </span>"activityStart"<span style="color:#000000;">);
            </span><span style="color:#0000ff;">final</span> ActivityClientRecord r =<span style="color:#000000;"> (ActivityClientRecord) msg.obj;

            r.packageInfo </span>=<span style="color:#000000;"> getPackageInfoNoCheck(
                r.activityInfo.applicationInfo, r.compatInfo);
            handleLaunchActivity(r, </span><span style="color:#0000ff;">null</span><span style="color:#000000;">);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            } </span><span style="color:#0000ff;">break</span><span style="color:#000000;">;
    ……
}</span></pre> 
 </div> 
 <p>      handleLaunchActivity()用于启动Activity。具体的启动流程不在这里详述了，这里重点说明ApplicationThread及ActivityThread的线程通信机制。</p> 
 <h5>2.2 主线程消息处理</h5> 
 <p>      在《<a href="http://www.cnblogs.com/younghao/p/5116819.html" rel="nofollow">Android线程管理——线程通信</a>》中谈到了普通线程中Handler、MessageQueue、Message及Looper四者的关系，那么，ActivityThread中的线程通信又有什么不同呢？不同之处主要表现为两点：1）Looper的初始化方式；2）Handler生成。</p> 
 <p>      首先，ActivityThread通过Looper.prepareMainLooper()初始化Looper，为了直观比较ActivityThread与普通线程初始化Looper的区别，把两种初始化方法放在一起：</p> 
 <div style="border-bottom:#cccccc 1px solid;border-left:#cccccc 1px solid;border-top:#cccccc 1px solid;border-right:#cccccc 1px solid;" class="cnblogs_code"> 
  <pre><span style="color:#008000;">/**</span><span style="color:#008000;"> Initialize the current thread as a looper.
      * This gives you a chance to create handlers that then reference
      * this looper, before actually starting the loop. Be sure to call
      * {<!-- --></span><span style="color:#808080;">@link</span><span style="color:#008000;"> #loop()} after calling this method, and end it by calling
      * {<!-- --></span><span style="color:#808080;">@link</span><span style="color:#008000;"> #quit()}.
      </span><span style="color:#008000;">*/</span>
    <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">static</span> <span style="color:#0000ff;">void</span><span style="color:#000000;"> prepare() {
        prepare(</span><span style="color:#0000ff;">true</span><span style="color:#000000;">);
    }

    </span><span style="color:#0000ff;">private</span> <span style="color:#0000ff;">static</span> <span style="color:#0000ff;">void</span> prepare(<span style="color:#0000ff;">boolean</span><span style="color:#000000;"> quitAllowed) {
        </span><span style="color:#0000ff;">if</span> (sThreadLocal.get() != <span style="color:#0000ff;">null</span><span style="color:#000000;">) {
            </span><span style="color:#0000ff;">throw</span> <span style="color:#0000ff;">new</span> RuntimeException("Only one Looper may be created per thread"<span style="color:#000000;">);
        }
        sThreadLocal.set(</span><span style="color:#0000ff;">new</span><span style="color:#000000;"> Looper(quitAllowed));
    }

    </span><span style="color:#008000;">/**</span><span style="color:#008000;">
     * Initialize the current thread as a looper, marking it as an
     * application's main looper. The main looper for your application
     * is created by the Android environment, so you should never need
     * to call this function yourself.  See also: {<!-- --></span><span style="color:#808080;">@link</span><span style="color:#008000;"> #prepare()}
     </span><span style="color:#008000;">*/</span>
    <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">static</span> <span style="color:#0000ff;">void</span><span style="color:#000000;"> prepareMainLooper() {
        prepare(</span><span style="color:#0000ff;">false</span><span style="color:#000000;">);
        </span><span style="color:#0000ff;">synchronized</span> (Looper.<span style="color:#0000ff;">class</span><span style="color:#000000;">) {
            </span><span style="color:#0000ff;">if</span> (sMainLooper != <span style="color:#0000ff;">null</span><span style="color:#000000;">) {
                </span><span style="color:#0000ff;">throw</span> <span style="color:#0000ff;">new</span> IllegalStateException("The main Looper has already been prepared."<span style="color:#000000;">);
            }
            sMainLooper </span>=<span style="color:#000000;"> myLooper();
        }
    }</span></pre> 
 </div> 
 <h6> </h6> 
 <ul><li>普通线程的prepare()方法默认quitAllowed参数为true，表示允许退出，ActivityThread在prepareMainLooper()方法中调用prepare()方法，参数为false，表示主线程不允许退出。 </li><li>普通线程只调用prepare()方法，ActivityThread在调用完prepare()方法之后，会通过myLooper()方法将本地线程&lt;ThreadLocal&gt;的Looper对象的引用交给sMainLooper。myLooper()其实就是调用sThreadLocal的get()方法实现的。</li></ul> 
 <div style="border-bottom:#cccccc 1px solid;border-left:#cccccc 1px solid;border-top:#cccccc 1px solid;border-right:#cccccc 1px solid;" class="cnblogs_code"> 
  <pre><span style="color:#008000;">/**</span><span style="color:#008000;">
     * Return the Looper object associated with the current thread.  Returns
     * null if the calling thread is not associated with a Looper.
     </span><span style="color:#008000;">*/</span>
    <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">static</span><span style="color:#000000;"> Looper myLooper() {
        </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> sThreadLocal.get();
    }</span></pre> 
 </div> 
 <ul><li>之所以要通过sMainLooper指向ActivityThread的Looper对象，就是希望通过getMainLooper()方法将主线程的Looper对象开放给其他线程。</li></ul> 
 <div style="border-bottom:#cccccc 1px solid;border-left:#cccccc 1px solid;border-top:#cccccc 1px solid;border-right:#cccccc 1px solid;" class="cnblogs_code"> 
  <pre><span style="color:#008000;">/**</span><span style="color:#008000;"> Returns the application's main looper, which lives in the main thread of the application.
     </span><span style="color:#008000;">*/</span>
    <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">static</span><span style="color:#000000;"> Looper getMainLooper() {
        </span><span style="color:#0000ff;">synchronized</span> (Looper.<span style="color:#0000ff;">class</span><span style="color:#000000;">) {
            </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> sMainLooper;
        }
    }</span></pre> 
 </div> 
 <p>      其次，ActivityThread与普通线程的Handler生成方式也不一样。普通线程生成一个与Looper绑定的Handler即可，ActivityThread通过sMainThreadHandler指向getHandler()的返回值，而getHandler()方法返回的其实是一个继承Handler的H对象。。</p> 
 <div style="border-bottom:#cccccc 1px solid;border-left:#cccccc 1px solid;border-top:#cccccc 1px solid;border-right:#cccccc 1px solid;" class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">private</span> <span style="color:#0000ff;">class</span> H <span style="color:#0000ff;">extends</span><span style="color:#000000;"> Handler {
    ……
}

</span><span style="color:#0000ff;">final</span> H mH = <span style="color:#0000ff;">new</span><span style="color:#000000;"> H();

</span><span style="color:#0000ff;">final</span><span style="color:#000000;"> Handler getHandler() {
    </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> mH;
}</span></pre> 
 </div> 
 <p>      真正实现消息机制“通”信的其实是Looper的loop()方法，loop()方法的核心实现如下：</p> 
 <div style="border-bottom:#cccccc 1px solid;border-left:#cccccc 1px solid;border-top:#cccccc 1px solid;border-right:#cccccc 1px solid;" class="cnblogs_code"> 
  <pre><span style="color:#008000;">/**</span><span style="color:#008000;">
     * Run the message queue in this thread. Be sure to call
     * {<!-- --></span><span style="color:#808080;">@link</span><span style="color:#008000;"> #quit()} to end the loop.
     </span><span style="color:#008000;">*/</span>
    <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">static</span> <span style="color:#0000ff;">void</span><span style="color:#000000;"> loop() {
        </span><span style="color:#0000ff;">final</span> Looper me =<span style="color:#000000;"> myLooper();
        </span><span style="color:#0000ff;">if</span> (me == <span style="color:#0000ff;">null</span><span style="color:#000000;">) {
            </span><span style="color:#0000ff;">throw</span> <span style="color:#0000ff;">new</span> RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."<span style="color:#000000;">);
        }
        </span><span style="color:#0000ff;">final</span> MessageQueue queue =<span style="color:#000000;"> me.mQueue;

        </span><span style="color:#008000;">//</span><span style="color:#008000;"> Make sure the identity of this thread is that of the local process,
        </span><span style="color:#008000;">//</span><span style="color:#008000;"> and keep track of what that identity token actually is.</span>
<span style="color:#000000;">        Binder.clearCallingIdentity();
        </span><span style="color:#0000ff;">final</span> <span style="color:#0000ff;">long</span> ident =<span style="color:#000000;"> Binder.clearCallingIdentity();

        </span><span style="color:#0000ff;">for</span><span style="color:#000000;"> (;;) {
            Message msg </span>= queue.next(); <span style="color:#008000;">//</span><span style="color:#008000;"> might block</span>
            <span style="color:#0000ff;">if</span> (msg == <span style="color:#0000ff;">null</span><span style="color:#000000;">) {
                </span><span style="color:#008000;">//</span><span style="color:#008000;"> No message indicates that the message queue is quitting.</span>
                <span style="color:#0000ff;">return</span><span style="color:#000000;">;
            }

            </span><span style="color:#008000;">//</span><span style="color:#008000;"> This must be in a local variable, in case a UI event sets the logger</span>
            Printer logging =<span style="color:#000000;"> me.mLogging;
            </span><span style="color:#0000ff;">if</span> (logging != <span style="color:#0000ff;">null</span><span style="color:#000000;">) {
                logging.println(</span>"&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " +<span style="color:#000000;">
                        msg.callback </span>+ ": " +<span style="color:#000000;"> msg.what);
            }

            msg.target.dispatchMessage(msg);

            </span><span style="color:#0000ff;">if</span> (logging != <span style="color:#0000ff;">null</span><span style="color:#000000;">) {
                logging.println(</span>"&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " +<span style="color:#000000;"> msg.callback);
            }

            </span><span style="color:#008000;">//</span><span style="color:#008000;"> Make sure that during the course of dispatching the
            </span><span style="color:#008000;">//</span><span style="color:#008000;"> identity of the thread wasn't corrupted.</span>
            <span style="color:#0000ff;">final</span> <span style="color:#0000ff;">long</span> newIdent =<span style="color:#000000;"> Binder.clearCallingIdentity();
            </span><span style="color:#0000ff;">if</span> (ident !=<span style="color:#000000;"> newIdent) {
                Log.wtf(TAG, </span>"Thread identity changed from 0x"
                        + Long.toHexString(ident) + " to 0x"
                        + Long.toHexString(newIdent) + " while dispatching to "
                        + msg.target.getClass().getName() + " "
                        + msg.callback + " what=" +<span style="color:#000000;"> msg.what);
            }

            msg.recycle();
        }
    }</span></pre> 
 </div> 
 <p>      大致流程如下：</p> 
 <ul><li>首先通过上述myLooper()方法获取Looper对象，取出Looper持有的MessageQueue； </li><li>然后从MessageQueue取出Message，如果Message为null，说明线程正在退出； </li><li>Message不为空，则调用Message的target handler对该Message进行分发，具体分发、处理流程可参考《<a href="http://www.cnblogs.com/younghao/p/5116819.html" rel="nofollow">Android线程管理——线程通信</a>》； </li><li>消息处理完毕，调用recycle()方法进行回收。</li></ul> 
</div> 
<p>转载于:https://www.cnblogs.com/younghao/p/5126408.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c17c60d46db5770a9ca954e74c01e950/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle&amp;nbsp;Constraint_type,约束类型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0e6765d437b679480e72b88aec7a5ec6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ios开发-判断邮箱、手机号、车牌、身份证。。。。。合法性</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>