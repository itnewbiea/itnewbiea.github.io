<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>线程不安全的解决方法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="线程不安全的解决方法" />
<meta property="og:description" content="目录
一、此时我们需要知道造成线程不安全的原因
二、我们一条一条分析，看是否能改变，即加上一些操作使多线程变得安全
synchronized的作用
修饰方法
修饰代码块
刷新内存
可重入
其他语言产生死锁的原因是
Java没有产生死锁的原因
注意
标准库中（集合类）线程安全的类
Vector（“弃用”）
HashTable
Stack
ConcurrentHashMap
StringBuffer
String
volatile关键字
那么什么时候该用到volatile呢？
三、JMM(java memory model)java内存模型【重点】
四、synchronized和volatile的区别【经典面试题】 一、此时我们需要知道造成线程不安全的原因 1.线程之间是抢占式执行的
2.多个线程修改同一个变量
3.原子性
4.内存可见性
5.指令重排序
二、我们一条一条分析，看是否能改变，即加上一些操作使多线程变得安全 1.对于第一条，我们没有办法，因为这种执行方式是由操作系统的内核实现的，我们改变不了
2.对于第二条，
一个线程修改一个变量，没有线程安全问题，结果确定；
多个线程读取同一变量，也没有线程安全问题，读只是单纯的把内存中的数据放到CPU中；
多个线程修改不同的变量，举例来说就是十个线程修改十个变量，一对一的关系，也没有线程安全问题，这个类似于第一种情况
所以为了规避线程安全问题，可以变换代码的组织形式，让一个线程只修改一个变量，但是有些场景下可以这么变换，有些却不可以。
3.对于第三条，像&#43;&#43;这样的操作，本质上是三个步骤，是一个“非原子”的操作
像=这样的操作，本质上是一个步骤，是一个“原子”操作，&#43;&#43;操作本身不是原子操作，可以通过加锁（synchronized）的方式，把这个操作变成原子操作，因此它是可以改变的。
public class ThreadDemo16 { static class Counter{ public int count=0; synchronized public void increase(){ count&#43;&#43;; } } public static void main(String[] args) throws InterruptedException { Counter counter=new Counter(); Thread t1=new Thread(){ @Override public void run() { for (int i = 0; i &lt; 50000; i&#43;&#43;) { counter." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c23d208f7becfaba845f88a0edf914ed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-22T15:49:07+08:00" />
<meta property="article:modified_time" content="2022-08-22T15:49:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">线程不安全的解决方法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%AD%A4%E6%97%B6%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E9%80%A0%E6%88%90%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%8E%9F%E5%9B%A0-toc" style="margin-left:0px;"><a href="#%E6%AD%A4%E6%97%B6%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E9%80%A0%E6%88%90%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%8E%9F%E5%9B%A0" rel="nofollow">一、此时我们需要知道造成线程不安全的原因</a></p> 
<p id="%E6%88%91%E4%BB%AC%E4%B8%80%E6%9D%A1%E4%B8%80%E6%9D%A1%E5%88%86%E6%9E%90%EF%BC%8C%E7%9C%8B%E6%98%AF%E5%90%A6%E8%83%BD%E6%94%B9%E5%8F%98%EF%BC%8C%E5%8D%B3%E5%8A%A0%E4%B8%8A%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BD%BF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%98%E5%BE%97%E5%AE%89%E5%85%A8-toc" style="margin-left:0px;"><a href="#%E6%88%91%E4%BB%AC%E4%B8%80%E6%9D%A1%E4%B8%80%E6%9D%A1%E5%88%86%E6%9E%90%EF%BC%8C%E7%9C%8B%E6%98%AF%E5%90%A6%E8%83%BD%E6%94%B9%E5%8F%98%EF%BC%8C%E5%8D%B3%E5%8A%A0%E4%B8%8A%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BD%BF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%98%E5%BE%97%E5%AE%89%E5%85%A8" rel="nofollow">二、我们一条一条分析，看是否能改变，即加上一些操作使多线程变得安全</a></p> 
<p id="synchronized%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:40px;"><a href="#synchronized%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">synchronized的作用</a></p> 
<p id="%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95" rel="nofollow">修饰方法</a></p> 
<p id="%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97-toc" style="margin-left:80px;"><a href="#%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97" rel="nofollow">修饰代码块</a></p> 
<p id="%E5%88%B7%E6%96%B0%E5%86%85%E5%AD%98-toc" style="margin-left:80px;"><a href="#%E5%88%B7%E6%96%B0%E5%86%85%E5%AD%98" rel="nofollow">刷新内存</a></p> 
<p id="%E5%8F%AF%E9%87%8D%E5%85%A5-toc" style="margin-left:80px;"><a href="#%E5%8F%AF%E9%87%8D%E5%85%A5" rel="nofollow">可重入</a></p> 
<p id="%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF-toc" style="margin-left:80px;"><a href="#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF" rel="nofollow">其他语言产生死锁的原因是</a></p> 
<p id="Java%E6%B2%A1%E6%9C%89%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0-toc" style="margin-left:80px;"><a href="#Java%E6%B2%A1%E6%9C%89%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0" rel="nofollow">Java没有产生死锁的原因</a></p> 
<p id="%E6%B3%A8%E6%84%8F-toc" style="margin-left:80px;"><a href="#%E6%B3%A8%E6%84%8F" rel="nofollow">注意</a></p> 
<p id="%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%EF%BC%88%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB-toc" style="margin-left:40px;"><a href="#%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%EF%BC%88%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB" rel="nofollow">标准库中（集合类）线程安全的类</a></p> 
<p id="Vector%EF%BC%88%E2%80%9C%E5%BC%83%E7%94%A8%E2%80%9D%EF%BC%89-toc" style="margin-left:80px;"><a href="#Vector%EF%BC%88%E2%80%9C%E5%BC%83%E7%94%A8%E2%80%9D%EF%BC%89" rel="nofollow">Vector（“弃用”）</a></p> 
<p id="HashTable-toc" style="margin-left:80px;"><a href="#HashTable" rel="nofollow">HashTable</a></p> 
<p id="Stack-toc" style="margin-left:80px;"><a href="#Stack" rel="nofollow">Stack</a></p> 
<p id="ConcurrentHashMap-toc" style="margin-left:80px;"><a href="#ConcurrentHashMap" rel="nofollow">ConcurrentHashMap</a></p> 
<p id="StringBuffer-toc" style="margin-left:80px;"><a href="#StringBuffer" rel="nofollow">StringBuffer</a></p> 
<p id="String-toc" style="margin-left:80px;"><a href="#String" rel="nofollow">String</a></p> 
<p id="volatile%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px;"><a href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">volatile关键字</a></p> 
<p id="%E9%82%A3%E4%B9%88%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E7%94%A8%E5%88%B0volatile%E5%91%A2%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E9%82%A3%E4%B9%88%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E7%94%A8%E5%88%B0volatile%E5%91%A2%EF%BC%9F" rel="nofollow">那么什么时候该用到volatile呢？</a></p> 
<p id="JMM(java%20memory%20model)java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91-toc" style="margin-left:0px;"><a href="#JMM%28java%20memory%20model%29java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91" rel="nofollow">三、JMM(java memory model)java内存模型【重点】</a></p> 
<p id="synchronized%E5%92%8Cvolatile%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%90%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0-toc" style="margin-left:0px;"><a href="#synchronized%E5%92%8Cvolatile%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%90%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0" rel="nofollow">四、synchronized和volatile的区别【经典面试题】                                                                            </a></p> 
<p></p> 
<h2 id="%E6%AD%A4%E6%97%B6%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E9%80%A0%E6%88%90%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%8E%9F%E5%9B%A0">一、此时我们需要知道造成线程不安全的原因</h2> 
<p>1.线程之间是抢占式执行的</p> 
<p>2.多个线程修改同一个变量</p> 
<p>3.原子性</p> 
<p>4.内存可见性</p> 
<p>5.指令重排序</p> 
<h2 id="%E6%88%91%E4%BB%AC%E4%B8%80%E6%9D%A1%E4%B8%80%E6%9D%A1%E5%88%86%E6%9E%90%EF%BC%8C%E7%9C%8B%E6%98%AF%E5%90%A6%E8%83%BD%E6%94%B9%E5%8F%98%EF%BC%8C%E5%8D%B3%E5%8A%A0%E4%B8%8A%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BD%BF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%98%E5%BE%97%E5%AE%89%E5%85%A8">二、我们一条一条分析，看是否能改变，即加上一些操作使多线程变得安全</h2> 
<p>1.对于<strong>第一条</strong>，我们没有办法，因为这种执行方式是由操作系统的内核实现的，<strong><span style="color:#fe2c24;">我们改变不了</span></strong></p> 
<p>2.对于<strong>第二条</strong>，</p> 
<p>一个线程修改一个变量，没有线程安全问题，结果确定；</p> 
<p>多个线程读取同一变量，也没有线程安全问题，读只是单纯的把内存中的数据放到CPU中；</p> 
<p>多个线程修改不同的变量，举例来说就是十个线程修改十个变量，一对一的关系，也没有线程安全问题，这个类似于第一种情况</p> 
<p><strong><span style="color:#a2e043;">所以为了规避线程安全问题，可以变换代码的组织形式，让一个线程只修改一个变量，但是有些场景下可以这么变换，有些却不可以。</span></strong><br> 3.对于<strong>第三条</strong>，像++这样的操作，本质上是三个步骤，是一个“非原子”的操作</p> 
<p>像=这样的操作，本质上是一个步骤，是一个“原子”操作，++操作本身不是原子操作，<strong>可以通过加锁（<span style="color:#fe2c24;">synchronized</span>）的方式，把这个操作变成原子操作，因此它是可以改变的。</strong></p> 
<pre><code class="language-java">public class ThreadDemo16 {
    static class Counter{
        public int count=0;
        synchronized public void increase(){
            count++;
        }
    }
    public static void main(String[] args) throws InterruptedException {
        Counter counter=new Counter();
        Thread t1=new Thread(){
            @Override
            public void run() {
                for (int i = 0; i &lt; 50000; i++) {
                    counter.increase();
                }
            }
        };
        t1.start();

        Thread t2=new Thread(){
            @Override
            public void run() {
                for (int i = 0; i &lt; 50000; i++) {
                    counter.increase();
                }
            }
        };
        t2.start();
        t1.join();
        t2.join();
        System.out.println(counter.count);
    }
}</code></pre> 
<p>执行结果为</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1e/58/t9oZNsUo_o.png"></p> 
<h3 id="synchronized%E7%9A%84%E4%BD%9C%E7%94%A8">synchronized的作用</h3> 
<h4 id="%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95">修饰方法</h4> 
<p>上述代码之前也写过，只不过之前的代码有线程安全问题，即得到的结果不是我们想要的，而现在的代码只不过在increase()方法的前面加了一个synchronized</p> 
<p>如果两个线程同时并发地尝试调用这个synchronized修饰的方法，此时一个线程会先执行这个方法，另外一个线程会等待，等到第一个线程方法执行完了之后，第二个线程才会继续执行。</p> 
<p>其实调用带synchronized的方法，就相当于是加锁和解锁，进入synchronized修饰的方法，就相当于加锁，出来synchronized修饰的方法，就相当于是解锁，如果当前已经是加锁的状态，其他的线程无是法执行这里的逻辑的，只能阻塞等待。</p> 
<p><span style="color:#fe2c24;">synchronized的功能本质上就是把“并发”变成“串行”，适当地牺牲一些速度，换一个更加准确的值</span></p> 
<p></p> 
<h4 id="%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97">修饰代码块</h4> 
<p>synchronized除了修饰方法之外，还可以修饰代码块</p> 
<pre><code class="language-java">public void increase(){
            synchronized(this){
                count++;
            }
}</code></pre> 
<p>synchronized如果是修饰代码块的时候，需要显示地在（）中指定一个要<span style="color:#a2e043;">加锁的对象</span></p> 
<p>如果是synchronized直接修饰的<span style="color:#fe2c24;"><strong>非静态方法</strong></span>，相当于加锁的对象就是this</p> 
<p>Java中任意的对象都可以作为“加锁的对象”</p> 
<h4 id="%E5%88%B7%E6%96%B0%E5%86%85%E5%AD%98">刷新内存</h4> 
<p>synchronized不光可以起到的加锁的作用，还可以<span style="color:#fe2c24;">刷新内存（解决内存可见性的问题）</span></p> 
<pre><code class="language-java">public void run() {
                for (int i = 0; i &lt; 50000; i++) {
                    counter.increase();
                }
            }</code></pre> 
<p>上述代码中每次自增的过程都是load、add、save，编译器为了提升效率就进行了优化，即把中间的一些load和save给省略了</p> 
<p>加上synchronized之后，就把上面的优化给禁止了，保证了每次进行自增的时候都能够从内存中取出数据，进行add操作后，把数据写回内存。它也是为了结果的正确使得速度变慢。</p> 
<h4 id="%E5%8F%AF%E9%87%8D%E5%85%A5">可重入</h4> 
<p>加入这个功能是为了防止程序员误加两次锁（忘了自己加了两次，且很难发现）出现死锁的情况</p> 
<pre><code class="language-java">synchronized public void increase(){
            count++;
}
synchronized public void increase2(){
            increase();
}</code></pre> 
<p>这个仔细看，还可以发现，但实际开发中几百行代码，看出来的难度就可想而知了。</p> 
<p>可重入意思是synchronized可以针对一把锁，连续加锁两次</p> 
<pre><code class="language-java">synchronized public void increase(){
            synchronized(this){
                count++;
            }
        }</code></pre> 
<p>进入increase方法，加了一次锁，进入代码块，又加了一次锁，这种操作对synchronized来说没问题，因为synchronized在这里进行了特殊处理，但是其他语言的话，这里可能会发生死锁。</p> 
<h4 id="%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF">其他语言产生死锁的原因是</h4> 
<p>第一次加锁，加锁成功</p> 
<p>第二次尝试对这个线程加锁的时候，此时<span style="color:#a2e043;">对象头</span>的锁标记已经确认了，比如说为true，按照之前说的，此时这个线程就要阻塞等待，等待这个锁标记被改为false，然后竞争这把锁，可是，这把锁已经被自己用了，是永远等不到的，此时，就被认为是产生死锁了。</p> 
<p>对象头的标记位：对象分为两部分，一部分是对象头，存贮这种对象的公共属性，其中一个属性为“锁标记”，对象的另一部分存储的是字段</p> 
<h4 id="Java%E6%B2%A1%E6%9C%89%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0">Java没有产生死锁的原因</h4> 
<p>Java在这里之所以没有产生死锁是因为synchronized内部记录了当前这个锁是哪个线程持有的。</p> 
<p></p> 
<h4 id="%E6%B3%A8%E6%84%8F">注意</h4> 
<p>synchronized修饰普通方法的话，相当于是对this进行加锁，这时如果两个线程并发的调用这个方法，此时是否会触发锁竞争就要看锁对象是否是同一个了。<strong>上面讲第三条时举的例子就是同一个锁对象，因此会触发锁竞争。</strong></p> 
<p>synchronized修饰静态方法的话，相当于是对<span style="color:#a2e043;">类对象</span>进行加锁，由于类对象是单例的，两个线程并发调用该方法一定会触发锁竞争。</p> 
<p>synchronized(synchronizedDemo.class)</p> 
<p>提到<span style="color:#fe2c24;">类对象</span>，我们首先要了解反射</p> 
<p>反射是面向对象中的一个基本特性，和继承、封装、多态是并列关系</p> 
<p>反射也叫“自省”，在程序运行时，通过反射，我们可以知道这个对象包含哪些属性，每个属性的名字，是什么类型，如public 、private......，包含哪些方法，方法名各是什么，参数列表......，而这些信息是来自.class文件（.java被编译生成的二进制字节码）</p> 
<p>.class文件会在JVM运行的时候加载到内存中，通过“类对象”来描述这个具体的.class文件的内容</p> 
<p><span style="color:#a2e043;">类名.class就得到了这个类对象，特点是每个类的类对象都是单例的</span></p> 
<p></p> 
<h3 id="%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%EF%BC%88%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB">标准库中（集合类）线程安全的类</h3> 
<p>这里的集合类，大部分是线程不安全的，即不能在多线程环境下去并发修改同一个变量。</p> 
<p>线程安全的有</p> 
<h4 id="Vector%EF%BC%88%E2%80%9C%E5%BC%83%E7%94%A8%E2%80%9D%EF%BC%89">Vector（“弃用”）</h4> 
<p>它是一个顺序表（动态数组），可以自动扩容，使用synchronized来保证线程安全，即给它的很多方法都加上了synchronized，因为大多数情况下，并不需要在多线程中使用Vector，加了太多的synchronized会降低单线程环境下的执行效率。所以不建议使用。</p> 
<h4 id="HashTable">HashTable</h4> 
<p>它是哈希表结构。做法和Vector类似，也是把很多方法都加上了synchronized，因此也是不建议使用。</p> 
<h4 id="Stack">Stack</h4> 
<p>继承自Vector</p> 
<h4 id="ConcurrentHashMap">ConcurrentHashMap</h4> 
<p>是一个线程安全的哈希表，和HashMap相比较设计的就非常好了，这个后面介绍。</p> 
<h4 id="StringBuffer">StringBuffer</h4> 
<p>它也是线程安全的，也是很多方法都加上了synchronized，因此也是不建议使用。</p> 
<h4 id="String">String</h4> 
<p>它被认为是线程安全的，但并没有加锁，原因是String是不可变对象，就是说你看似是改了，但实际上是新建了一个String对象，因此不可能存在两个线程并发修改同一个String</p> 
<p></p> 
<h3 id="volatile%E5%85%B3%E9%94%AE%E5%AD%97">volatile关键字</h3> 
<p>在计算机中一般理解为“可变的，容易改变的”</p> 
<p>volatile的功能是<span style="color:#a2e043;">保证内存可见性</span>，<span style="color:#4da8ee;">不保证原子性</span></p> 
<p>举例代码</p> 
<pre><code class="language-java">public class ThreadDemo17 {
    static class Counter{
        //volatile public int count=0;
        public int count=0;

    }
    public static void main(String[] args) {
        Counter counter=new Counter();
        Thread t1=new Thread(){
            @Override
            public void run() {
                while(counter.count==0){

                }
                System.out.println("线程运行结束");
            }
        };
        t1.start();
        Thread t2=new Thread(){
            @Override
            public void run() {
                System.out.println("请输入数据：");
                Scanner scanner=new Scanner(System.in);
                counter.count=scanner.nextInt();
            }
        };
        t2.start();
    }
}</code></pre> 
<p>执行结果为</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3f/2c/AqITM1s6_o.png"></p> 
<p> 可以看出线程1并没有结束，按我们的预期是输入一个不为0的数，线程1就会终止，但是实际情况却没有挺停，没有听的原因就是内存可见性，即编译器优化了执行过程，不再每次都从内存中取数据。解决这个问题的办法就是在</p> 
<p>public int count = 0;这条语句前<span style="color:#fe2c24;">加上关键字volatile，原理是禁止编译器进行刚才的优化。</span></p> 
<p>加上之后，执行结果为</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/15/49/yp65KEp9_o.png"></p> 
<p> <span style="color:#a2e043;">volatile的用法比较单一，只能修饰一个具体的属性，此时代码中针对这个属性的读写操作就一定会涉及内存操作了。</span></p> 
<p>synchronized不仅保证原子性，也保证了内存可见性</p> 
<pre><code class="language-java">public class ThreadDemo17 {
    static class Counter{
        //volatile public int count=0;
        public int count=0;

    }
    public static void main(String[] args) {
        Counter counter=new Counter();
        Thread t1=new Thread(){
            @Override
            public void run() {
                while(true){
                    synchronized (this){
                        if ( counter.count != 0) {
                            break;
                        }
                    }
                }

                System.out.println("线程运行结束");
            }
        };
        t1.start();
        Thread t2=new Thread(){
            @Override
            public void run() {
                System.out.println("请输入数据：");
                Scanner scanner=new Scanner(System.in);
                counter.count=scanner.nextInt();
            }
        };
        t2.start();
    }
}</code></pre> 
<p>执行结果为</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d1/8f/m3J3wJvP_o.png"></p> 
<p></p> 
<h4 id="%E9%82%A3%E4%B9%88%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E7%94%A8%E5%88%B0volatile%E5%91%A2%EF%BC%9F">那么什么时候该用到volatile呢？</h4> 
<p>一般来说，如果某个变量，在同一个线程中读和写，大概率要用到。</p> 
<h2 id="JMM(java%20memory%20model)java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91">三、JMM(java memory model)java内存模型【重点】</h2> 
<p class="img-center"><img alt="" height="342" src="https://images2.imgbox.com/5b/a3/zMPLPjmR_o.png" width="280"></p> 
<p> 我们需要知道的是，代码中需要读一个变量的时候，不一定是真的在读内存，可能这个数据已经在内存或者cache中缓存着了，这个时候就可能绕过内存，直接从CPU或者cache中来取这个数据</p> 
<p>JMM针对计算机的硬件结构又进行了一次抽象（考虑到java的跨平台性）</p> 
<p>把CPU的寄存器L1、L2、L3cache统称为“工作内存”</p> 
<p>把<span style="color:#fe2c24;">真正的内存</span>称为“主内存”</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fe/62/CMpBrs7B_o.png"></p> 
<p>上图中，三个线程都有自己的工作内存，每个线程都有自己独立的上下文，独立的上下文就是各自的一组寄存器/cache上的内容 </p> 
<p>CPU在和内存交互的时候，经常会把主内存的内容拷贝到工作内存，然后进行操作写回到主内存，这个过程就容易出现数据不一致的情况，这一点尤其在编译器开启优化后更严重。</p> 
<p>volatile和synchronized能够强制接下来的操作是操作内存，原理是在生成的Java字节码中强制插入一些“内存屏障”的指令，这些指令的效果是强制同步主内存和工作内存的内容 ，牺牲了效率，换来了正确结果。</p> 
<h2 id="synchronized%E5%92%8Cvolatile%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%90%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0">四、synchronized和volatile的区别【经典面试题】   </h2> 
<p>首先synchronized既保证原子性，又保证内存可见性，而volatile只保证内存可见性</p> 
<p>像++这样的操作，本质上是三个步骤，是一个“非原子”的操作</p> 
<p>像=这样的操作，本质上是一个步骤，是一个“原子”操作</p> 
<p>我们需要知道的是操作系统调度线程的时候是“抢占式执行”的方式，也就是竞争的关系，某个线程什么时候上CPU执行，什么时候切换出CPU，是完全不确定的。而且另一方面，两个线程在两个不同的CPU可以并发执行。因此，两个线程的执行顺序是完全不可预测的。</p> 
<p>我们先假设两个线程针对一个变量进行++操作，我们需要知道count++的操作并不是完全三步都要执行完，也可能是线程1只执行完load，线程2把三步都执行完，线程1再执行后面的两步，此时，算出的结果就会出问题，假设内存中初始值为0，线程2执行完count++后内存中的值变为了1，线程1把后面两步都执行完之后，内存中的值还是1，这就出现了问题，因为我们的两个线程执行了两次count++操作，内存中的结果按理来说应该是2。而且这只是出现问题的其中一种情况。<br> ++操作本身不是原子操作，但是我们可以通过加锁的方式，也就是在方法前加synchronized,把这个操作变成原子操作。</p> 
<p></p> 
<p>内存可见性具体就是同一个线程修改和读取，由于编译器的优化，可能把++操作一些中间环节的LOAD和SAVE省略掉了，此时读的线程可能读到的是未修改过的结果。</p> 
<p>这里我们需要知道：++操作每次执行都有LOAD和SAVE，由于ADD比LOAD和SAVE要快一万倍，所以在执行很多次++操作的时候，很多LOAD和SAVE操作就被省略掉了，这样做是为了提高程序的整体效率。这个省略操作是编译器和JVM综合配合达成的效果。</p> 
<p>这种优化在单线程下具有很高的效率，但是在多线程的时候，另一个线程也尝试读取/修改这个数据，这时候就会出问题。</p> 
<p>提到内存可见性，我们需要提到冯诺伊曼体系结构中的CPU（可能还有缓存cache）和内存，线程在CPU上运行，代码中需要读一个变量的时候，不一定是真的在读内存，可能这个数据已经在CPU或者cache中缓存着了，这个时候就可能绕过内存，直接从CPU或者cache中来取这个数据</p> 
<p>JMM针对计算机的硬件结构又进行了一次抽象（考虑到java的跨平台性）</p> 
<p>我们把CPU的寄存器L1、L2、L3cache统称为“工作内存”，把真正的内存称为“主内存</p> 
<p>CPU在和内存交互的时候，经常会把主内存的内容拷贝到工作内存，然后进行操作写回到主内存，这个过程就容易出现数据不一致的情况，这一点尤其在编译器开启优化后更严重。</p> 
<p>而volatile和synchronized能够强制接下来的操作是操作内存，原理是在生成的Java字节码中强制插入一些“内存屏障”的指令，这些指令的效果是强制同步主内存和工作内存的内容 ，牺牲了效率，换来了正确结果。</p> 
<h2>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </h2> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1000fbe8f6f98306d85f3d2804c43608/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">excel数据分析 - 10个清洗文本类函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1f62dc68484d4ac97f94898a4459866a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">小程序分享给好友以及分享到朋友圈</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>