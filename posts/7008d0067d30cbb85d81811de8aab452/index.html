<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【K8S in Action】第七章 ConfigMap和Secret配置应用程序 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【K8S in Action】第七章 ConfigMap和Secret配置应用程序" />
<meta property="og:description" content="1 配置容器化应用程序 容器化应用通常是如何被配置：
以命令行参数的形式配置应用。 随着配置选项数量的逐渐增多， 将配置文件化。借助环境变量，常见方法。Docker 容器中采用配置文件的方式有困难，配置文件打入容器镜像， 抑或是挂载包含该文件的卷。 2 向容器传递命令行参数 容器中运行的完整指令由两部分组成：命令与参数。了解ENTRYPOINT与CMD。
ENTRYPOINT定义容器启动时被调用的可执行程序CMD指定传递给ENTRYPOINT的参数。 这样， 镜像可以直接运行， 无须添加任何参数
docker run &lt;image&gt; 是添加一些参数， 覆盖Dockerile中任何由CMD指定的默认参数值 docker run &lt;image&gt; &lt;arguments&gt; 了解shell与exec形式的区别，上述两条指令均支持以下两种形式，两者的区别在于指定的命令是否是在shell中被调用。：
shell形式 如ENTRYPOINT node app.js。exec形式 如ENTRYPOINT [“node”, “app. js”] docker exec -it e4bad ps x PID TTY STAT TIME COMMAND 1 ? Ss 0:00 /bin/sh -c node app. J s 7 ? Sl 0:00 node app.js 13 ? Rs&#43; 0:00 ps x 可以看出，主进程(Pid 1)是shell进程而非node进程，node进程(PID 7)在shell中启动。 shell进程往往是多余的， 在fortune脚本中添加VARIABLE变量并用第一个命令行参数对其初始化。 #!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/7008d0067d30cbb85d81811de8aab452/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-01T15:14:22+08:00" />
<meta property="article:modified_time" content="2024-01-01T15:14:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【K8S in Action】第七章 ConfigMap和Secret配置应用程序</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1__0"></a>1 配置容器化应用程序</h3> 
<p>容器化应用通常是如何被配置：</p> 
<ul><li>以命令行参数的形式配置应用。 随着配置选项数量的逐渐增多， 将配置文件化。</li><li>借助环境变量，常见方法。Docker 容器中采用配置文件的方式有困难，配置文件打入容器镜像， 抑或是挂载包含该文件的卷。</li></ul> 
<h4><a id="2__5"></a>2 向容器传递命令行参数</h4> 
<p>容器中运行的完整指令由两部分组成：命令与参数。了解ENTRYPOINT与CMD。</p> 
<ul><li>ENTRYPOINT定义容器启动时被调用的可执行程序</li><li>CMD指定传递给ENTRYPOINT的参数。</li></ul> 
<p>这样， 镜像可以直接运行， 无须添加任何参数</p> 
<pre><code class="prism language-bash"> <span class="token function">docker</span> run <span class="token operator">&lt;</span>image<span class="token operator">&gt;</span>
 是添加一些参数， 覆盖Dockerile中任何由CMD指定的默认参数值
 <span class="token function">docker</span> run <span class="token operator">&lt;</span>image<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>arguments<span class="token operator">&gt;</span>
 
</code></pre> 
<p>了解shell与exec形式的区别，上述两条指令均支持以下两种形式，两者的区别在于指定的命令是否是在shell中被调用。：</p> 
<ul><li>shell形式 如ENTRYPOINT node app.js。</li><li>exec形式 如ENTRYPOINT [“node”, “app. js”]</li></ul> 
<pre><code class="prism language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> e4bad <span class="token function">ps</span> x
PID TTY STAT TIME COMMAND 
<span class="token number">1</span> ? Ss <span class="token number">0</span>:00   /bin/sh <span class="token parameter variable">-c</span> <span class="token function">node</span> app. J s 
<span class="token number">7</span>  ? Sl <span class="token number">0</span>:00   <span class="token function">node</span> app.js 
<span class="token number">13</span> ? Rs+ <span class="token number">0</span>:00  <span class="token function">ps</span> x

可以看出，主进程<span class="token punctuation">(</span>Pid <span class="token number">1</span><span class="token punctuation">)</span>是shell进程而非node进程，node进程<span class="token punctuation">(</span>PID <span class="token number">7</span><span class="token punctuation">)</span>在shell中启动。 shell进程往往是多余的，
</code></pre> 
<pre><code class="prism language-bash">在fortune脚本中添加VARIABLE变量并用第一个命令行参数对其初始化。

<span class="token comment">#!/bin/bash </span>
<span class="token builtin class-name">trap</span> <span class="token string">"exit"</span> SIGINT 
<span class="token assign-left variable">INTERVAL</span><span class="token operator">=</span><span class="token variable">$1</span> 
<span class="token builtin class-name">echo</span> Configured to generate new fortune every <span class="token variable">$INTERVAL</span> seconds 
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /var/htdocs 
<span class="token keyword">while</span> ：
<span class="token keyword">do</span> 
	<span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">date</span><span class="token variable">)</span></span> Writing fortune to /var/htdocs/index.html
	/usr/games/fortune <span class="token operator">&gt;</span> /var/htdocs/index.html
	<span class="token function">sleep</span> <span class="token variable">$INTERVAL</span> 
<span class="token keyword">done</span>



修改fortune镜像的Dockerfile  
FROM ubuntu:latest 
RUN <span class="token function">apt-get</span> update <span class="token punctuation">;</span> <span class="token function">apt-get</span> <span class="token parameter variable">-yinstall</span> fortune 
ADD fortuneloop.sh /bin/fortuneloop.sh
ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"/bin/fortuneloop.sh"</span><span class="token punctuation">]</span>   <span class="token builtin class-name">exec</span>   形式的ENTRYPOINT 
CMD <span class="token punctuation">[</span><span class="token string">"10"</span><span class="token punctuation">]</span>            可执行程序的默认参数
</code></pre> 
<h5><a id="_Kubernetes__58"></a>在 Kubernetes 中覆盖命令和参数。</h5> 
<pre><code class="prism language-bash">kind: Pod
spec: 
	containers:
	- image: some/image 
	  command: <span class="token punctuation">[</span><span class="token string">"/bin/ command"</span><span class="token punctuation">]</span>            命令一般很少被覆盖
	   args: <span class="token punctuation">[</span><span class="token string">"argl"</span>, <span class="token string">"arg2"</span>, <span class="token string">"arg3"</span><span class="token punctuation">]</span>    

少量参数值的设置可以使用上述的数组表示。多参数值情况下可以采用如下标
记。字符串值无须用引号标记，数值需要。

args: 
- foo
- bar
- <span class="token string">"15"</span>
</code></pre> 
<h4><a id="3__76"></a>3 为容器设置环境变量</h4> 
<p>为pod中的每一个容器都指定自定义的环境变量集合。</p> 
<pre><code class="prism language-bash"><span class="token shebang important">#!/bin/bash </span>
<span class="token builtin class-name">trap</span> <span class="token string">"exit"</span> SIGINT 
移除脚本中工NTERVAL初始化所在的行即可
<span class="token comment">#  INTERVAL=$1   </span>
<span class="token builtin class-name">echo</span> Configured to generate new fortune every <span class="token variable">$INTERVAL</span> seconds 
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /var/htdocs 
<span class="token keyword">while</span> ：
<span class="token keyword">do</span> 
	<span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">date</span><span class="token variable">)</span></span> Writing fortune to /var/htdocs/index.html
	/usr/games/fortune <span class="token operator">&gt;</span> /var/htdocs/index.html
	<span class="token function">sleep</span> <span class="token variable">$INTERVAL</span> 
<span class="token keyword">done</span>

在pod中指定环境变量，环境变量被设置在pod的容器定义中，并非是pod级别。
kind: Pod 
spec: 
	containers: 
	- image: luksa/fortune:env
	  env: 
	  - name: INTERVAL 
		value: <span class="token string">"30"</span> 
	  name: html-generator

在环境变量值中引用另二个变量，SECOND_VAR 的值是 foobar
env:
- name <span class="token builtin class-name">:</span> FIRST_VAR 
  value: <span class="token string">"foo"</span>
- name <span class="token builtin class-name">:</span> SECOND_VAR 
  value ：”<span class="token variable"><span class="token variable">$(</span>FIRST_VAR<span class="token variable">)</span></span>bar”
</code></pre> 
<h4><a id="4__ConfigMap_110"></a>4 利用 ConfigMap解耦相配置</h4> 
<p>Kubemetes 将配置选项分离到单独的资源对象 ConfigMap 中， 本质上就是键值对映射，值可以是短字面量，也可以是完整的配置文件。</p> 
<pre><code class="prism language-bash">创建了叫作 fortune-config的ConfigMap ，仅包含单映射条目 <span class="token function">sleep</span> <span class="token assign-left variable">interval</span><span class="token operator">=</span><span class="token number">25</span>
 kubectl create configmap fortune-config --from-literal<span class="token operator">=</span>sleep-interval<span class="token operator">=</span><span class="token number">25</span>


kubectl get configmap fortune-config <span class="token parameter variable">-o</span> yaml
apiVersion: vl 
data <span class="token builtin class-name">:</span> 
	sleeo-interval :”25 ”   描述符定义了一个ConfigMap
kind ：ConfigMap
metadata 
	creationTimestamp: <span class="token number">2016</span> 08-11T20 <span class="token builtin class-name">:</span> <span class="token number">31</span>:08Z 
	name: fortune-config 			     通过这个名称引用 ConfigMap
	namespace: default  
	resourceVersion <span class="token builtin class-name">:</span> ” <span class="token number">910025</span> ” 
	selfLink: /api/vl/namespaces/default/configmaps/fortune-config 
	uid: 88c4167e-6002-lle6-a50d-42010af00237

然后通k8s API 创建对应的ConfigMap
kubectl create - f fo tune config.yaml
</code></pre> 
<p>ConfigMap 创建自多种选项：完整文件夹、单独文件、自定义键名的条目下的文件（替代文件名作键名） 及字面量。</p> 
<h5><a id="_ConfigMap__136"></a>给容器传递 ConfigMap 条目作为环境变量</h5> 
<pre><code class="prism language-bash">apiVersion <span class="token builtin class-name">:</span> vl 
kind: Pod 
metadata: 
	name: fortune-env-from-configrmap
spec: 
	containers: 
	- image <span class="token builtin class-name">:</span> luksa/fortune:env
	  env:
	  - name <span class="token builtin class-name">:</span> INTERVAL 
		valueFrom <span class="token builtin class-name">:</span>                
			configMapKeyRef:           ConfigMap初始化，不设定固定值
				name:fortune-config    引用configMap 的名称
				key: sleep-interval
</code></pre> 
<h5><a id="_ConfigMap__154"></a>一次性传递 ConfigMap 的所有条目作为环境变量</h5> 
<p>如果 ConfigMap 包含不少条日，为每个条目单独设置环境变 的过程是单调乏味且容易出错的。假设 名为 my-config-map包含 FOO、BAR、FOO-BAR 三个键。可以通过 envFrom属性字段将所有条目暴露作为环境变量。</p> 
<pre><code class="prism language-bash">spec: 
	containers: 
	- image <span class="token builtin class-name">:</span> some-iamge
	  envFrom:
	  - prefix: CONFIG_              所有环境变量包含前缀CONFIG_ 
		configMapRef:                前缀设置是可选的，若不设直前缀佳，环境变量的名称与 ConfigMap 的键名相同
			name:my-config-map     引用名为 my-config-map的ConfigMap 

容器中有两个环境变的名称为： CONFIG_FOO CONFIG_BAR.原因在于 CONFIG_FOO-BAR 包含破折号，这并不是一个合法的环境变量名称。忽略时不会发出事件通知）
</code></pre> 
<h5><a id="_ConfigMap__169"></a>传递 ConfigMap 条目作为命令行参数</h5> 
<p>如何将 ConfigMap 中的值作为 数值传递给运行在容器中的主进程。在宇段 pod spec.containers.args 中无法直接引用ConfigMap。ConfigMap 条目初始化某个环境变 ，然后再在参数字段中引用该环境变量。</p> 
<pre><code class="prism language-bash">apiVersion <span class="token builtin class-name">:</span> vl 
kind: Pod 
metadata: 
	name: fortune-args-from-configrmap
spec: 
	containers: 
	- image <span class="token builtin class-name">:</span> luksa/fortune:args
	  env:
	  - name <span class="token builtin class-name">:</span> INTERVAL 
		valueFrom <span class="token builtin class-name">:</span>                
			configMapKeyRef:           ConfigMap初始化，不设定固定值
				name:fortune-config    引用configMap 的名称
				key: sleep-interval
	 args:  <span class="token punctuation">[</span><span class="token string">"$ (INTERVAL ) "</span><span class="token punctuation">]</span>  在参数设置中 引用环境变量 
</code></pre> 
<h5><a id="_configMap__188"></a>使用 configMap 卷将条目暴露为文件</h5> 
<p>ConfigMap 卷会将 ConfigMap 中的每个条目均暴露成 个文件 运行在容器中的进程可通过读取文件内容获得对应的条目值</p> 
<h4><a id="5__Secret_196"></a>5 使用 Secret给容器传递敏感数据</h4> 
<p>Secret 结构与 ConfigMap类似， 均是键／值对的映射。 Secret 的使用方法也与ConfigMap 相同， 可以<br> • 将 Secret 条目作为环境变量传递给容器<br> • 将 Secret 条目暴露为卷中的文件</p> 
<p>首先来分析 一种默认被挂载至所有容器的 Secret, 对任意一 个 pod使用命令kubectl describe pod, 输出往往包含如下信息</p> 
<pre><code class="prism language-bash">Volumes: 
	defaul-token-cfee9:
		Type: Secret<span class="token punctuation">(</span>a volume populated by a Secret）
		SecretName: default－token-cfee9

查看secrets
kubectl get secrets  
kubectl describe secrets 
</code></pre> 
<p>可以看出这个Secret包含三个条目：ca.crt 、 namespace与token, 包含了从pod内部安全访问KubemetesAPI服务器所需的全部信息。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/72e496c814772344c85c2a9248d819af/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python从txt文件中提取特定数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cbc6b746c76447902e20a465e5a570fe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">R语言【base】——table()：使用交叉分类因子来构建每个因子水平组合的计数列联表。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>