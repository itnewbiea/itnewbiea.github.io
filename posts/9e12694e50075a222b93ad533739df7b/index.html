<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>char data[0]问题 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="char data[0]问题" />
<meta property="og:description" content="问题：当进行内存管理时，经常需要一个额外的结构，例如
struct MyData
{
char*data; // 指向分配的内存空间
intlen; // 记录空间大小
};
这样，需要进行四步操作，先分配MyData结构体，再分配要管理的内存，再让data指针指向该内存空间，再把空间大小赋给len。问题，该结构在64位系统上sizeof结果是多少？可以修改结构体的情况下有什么办法能够减少操作？
这实际上是有关char data[0]的问题。
struct MyData {
int len;
char data[0]; // 一定是结构体的最后一个字段，且前面必须有其他字段
};
在结构中，data是一个数组名；但该数组没有元素；由于数组没有元素，该数组在该结构体中不占用空间，所以sizeof(struct Mydata) = 4，这不同于char* data，要占用一个指针的大小（32位系统下4字节，64位系统8字节）。该数组的真实地址紧随结构体MyData之后，而这个地址就是结构体后面数据的地址（如果给这个结构体分配的内容大于这个结构体实际大小，后面多余的部分就是这个data的内容）；这种声明方法可以巧妙的实现C语言里的数组扩展。
使用：
struct MyData *p = (struct MyData *)malloc(sizeof(struct MyData)&#43;strlen(str))
这样就可以通过p-&gt;data 来操作这个str。
这是个广泛使用的常见技巧，常用来构成缓冲区。比起指针，用空数组有这样的优势：
1.不需要初始化，数组名直接就是所在的偏移；
2.不占任何空间，指针需要占用空间；
3.结构体和内存可以一起分配，连续空间。
一次分配解决问题，省了不少麻烦。大家知道为了防止内存泄漏，如果是分两次分配（结构体和缓冲区），那么要是第二次malloc失败了，必须回滚释放第一个分配的结构体。这样带来了编码麻烦。其次，分配了第二个缓冲区以后，如果结构里面用的是指针，还要为这个指针赋值。同样，在free这个buffer的时候，用指针也要两次free。如果用空数组，所有问题一次解决。
其次，大家知道小内存的管理是非常困难的，如果用指针，这个buffer的struct部分就是小内存了，在系统内存在多了势必严重影响内存管理的性能。要是用空数组把struct和实际数据缓冲区一次分配大块问题，就没有这个问题。
补充说明：
char data[0]柔性数组，只能放在struct末尾，表示该struct是可变长度的，多余的容量分配给data数组，实现可变长度的数组。
在早期有些技术牛人都爱这样写，不过在今天这是一种不安全的写法，不推荐，不要指望在所有的编译器上都能得到比想要的结果。
char data[0]是否合法？
ISO/IEC 9899-1999里面，这么写是非法的，这个仅仅是GNU C的扩展，gcc可以允许这一语法现象的存在。
结构体最后使用0或1的长度数组的原因，主要是为了方便的管理内存缓冲区，如果你直接使用指针而不使用数组，那么，你在分配内存缓冲区时，就必须分配结构体一次，然后再分配结构体内的指针一次，（而此时分配的内存已经与结构体的内存不连续了，所以要分别管理即申请和释放）而如果使用数组，那么只需要一次就可以全部分配出来，（见下面的例子），反过来，释放时也是一样，使用数组，一次释放，使用指针，得先释放结构体内的指针，再释放结构体。还不能颠倒次序。
其实就是分配一段连续的的内存，减少内存的碎片化。
这个仅仅是在C99没有出台的情况下，gcc为了使用类似于C99 flexible array member而做出的一个work-around，但是现在C99出现了，并且正式支持了flexiblearray member的语法，这样的一个GNU C扩展就有点显得不合时宜了……按照ISO/IEC 9899-1999的要求，flexible array member的定义应当是这样：
struct foo
{" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/9e12694e50075a222b93ad533739df7b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-06-07T09:05:15+08:00" />
<meta property="article:modified_time" content="2017-06-07T09:05:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">char data[0]问题</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>问题：当进行内存管理时，经常需要一个额外的结构，例如</p> 
<p>struct MyData</p> 
<p>{<!-- --></p> 
<p>    char*data;  // 指向分配的内存空间</p> 
<p>    intlen;  // 记录空间大小</p> 
<p>};</p> 
<p>这样，需要进行四步操作，先分配MyData结构体，再分配要管理的内存，再让data指针指向该内存空间，再把空间大小赋给len。问题，该结构在64位系统上sizeof结果是多少？可以修改结构体的情况下有什么办法能够减少操作？</p> 
<p> </p> 
<p>这实际上是有关char data[0]的问题。</p> 
<p>struct MyData </p> 
<p>{<!-- --></p> 
<p>    int len;</p> 
<p>    char data[0];  // 一定是结构体的最后一个字段，且前面必须有其他字段</p> 
<p>};</p> 
<p>在结构中，data是一个数组名；但该数组没有元素；由于数组没有元素，该数组在该结构体中不占用空间，所以sizeof(struct Mydata) = 4，这不同于char* data，要占用一个指针的大小（32位系统下4字节，64位系统8字节）。该数组的真实地址紧随结构体MyData之后，而这个地址就是结构体后面数据的地址（如果给这个结构体分配的内容大于这个结构体实际大小，后面多余的部分就是这个data的内容）；这种声明方法可以巧妙的实现C语言里的数组扩展。</p> 
<p>使用：</p> 
<p>    struct MyData *p = (struct MyData *)malloc(sizeof(struct MyData)+strlen(str))</p> 
<p>这样就可以通过p-&gt;data 来操作这个str。</p> 
<p> </p> 
<p>这是个广泛使用的常见技巧，常用来构成缓冲区。比起指针，用空数组有这样的优势：</p> 
<p>1.不需要初始化，数组名直接就是所在的偏移；</p> 
<p>2.不占任何空间，指针需要占用空间；</p> 
<p>3.结构体和内存可以一起分配，连续空间。</p> 
<p>一次分配解决问题，省了不少麻烦。大家知道为了防止内存泄漏，如果是分两次分配（结构体和缓冲区），那么要是第二次malloc失败了，必须回滚释放第一个分配的结构体。这样带来了编码麻烦。其次，分配了第二个缓冲区以后，如果结构里面用的是指针，还要为这个指针赋值。同样，在free这个buffer的时候，用指针也要两次free。如果用空数组，所有问题一次解决。</p> 
<p>其次，大家知道小内存的管理是非常困难的，如果用指针，这个buffer的struct部分就是小内存了，在系统内存在多了势必严重影响内存管理的性能。要是用空数组把struct和实际数据缓冲区一次分配大块问题，就没有这个问题。</p> 
<p> </p> 
<p>补充说明：</p> 
<p>char data[0]柔性数组，只能放在struct末尾，表示该struct是可变长度的，多余的容量分配给data数组，实现可变长度的数组。</p> 
<p>在早期有些技术牛人都爱这样写，不过在今天这是一种不安全的写法，不推荐，不要指望在所有的编译器上都能得到比想要的结果。</p> 
<p>char data[0]是否合法？</p> 
<p>ISO/IEC 9899-1999里面，这么写是非法的，这个仅仅是GNU C的扩展，gcc可以允许这一语法现象的存在。</p> 
<p>结构体最后使用0或1的长度数组的原因，主要是为了方便的管理内存缓冲区，如果你直接使用指针而不使用数组，那么，你在分配内存缓冲区时，就必须分配结构体一次，然后再分配结构体内的指针一次，（而此时分配的内存已经与结构体的内存不连续了，所以要分别管理即申请和释放）而如果使用数组，那么只需要一次就可以全部分配出来，（见下面的例子），反过来，释放时也是一样，使用数组，一次释放，使用指针，得先释放结构体内的指针，再释放结构体。还不能颠倒次序。</p> 
<p>其实就是分配一段连续的的内存，减少内存的碎片化。</p> 
<p>这个仅仅是在C99没有出台的情况下，gcc为了使用类似于C99 flexible array member而做出的一个work-around，但是现在C99出现了，并且正式支持了flexiblearray member的语法，这样的一个GNU C扩展就有点显得不合时宜了……按照ISO/IEC 9899-1999的要求，flexible array member的定义应当是这样：</p> 
<p>struct foo</p> 
<p>{<!-- --></p> 
<p>    int variable; </p> 
<p>    char bar[ ];  // here!!!! this is the C99 flexible arraymember</p> 
<p>}; </p> 
<p>这个才是符合标准要求的写法，当你的代码需要跨平台、跨编译器移植，并且需要这个特性的时候，这个才是唯一准确的写法！</p> 
<p>C99中，允许结构中的最后一个成员可以是未知大小的数组（结构中，在该数组之前必须至少有一个其他成员），这被称为 flexible array member。由sizeof返回的结构的大小不包括 flexible array member的大小。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/03374069d8343edd6f61c52e5d96aec8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mongodb基础操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8bcfdca91e34b050ad0bba9f3bcf3e83/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网络共享遇到系统错误1219   “不允许一个用户使用一个以上用户名与服务器或共享资源的多重连接。中断与此服务器或共享资源的所有连接，然后再试一次。”</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>