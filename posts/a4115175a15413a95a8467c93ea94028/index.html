<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GRPC的四种服务类型 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GRPC的四种服务类型" />
<meta property="og:description" content="上次简单介绍了grpc的使用方法，并创建了一个方法调用，在grpc中有四种服务类型，下面分别进行介绍
简单rpc 这就是一般的rpc调用，一个请求对象对应一个返回对象
proto语法： rpc simpleHello(Person) returns (Result) {} service代码 @Override public void simpleHello(ProtoObj.Person request, io.grpc.stub.StreamObserver&lt;ProtoObj.Result&gt; responseObserver) { //返回结果 responseObserver.onNext(ProtoObj.Result.newBuilder().setString(&#34;hello, &#34;&#43;request.getMyName()).build()); responseObserver.onCompleted(); } client代码 @Test public void simple() throws InterruptedException { final ManagedChannel channel = ManagedChannelBuilder.forAddress(&#34;127.0.0.1&#34;, 8080).usePlaintext(true).build(); //定义同步阻塞的stub HelloServiceGrpc.HelloServiceBlockingStub blockingStub = HelloServiceGrpc.newBlockingStub(channel); ProtoObj.Person person = ProtoObj.Person.newBuilder().setMyName(&#34;World&#34;).build(); //simple System.out.println(&#34;---simple rpc---&#34;); System.out.println(blockingStub.simpleHello(person).getString()); channel.shutdown(); } 输出 ---simple rpc--- hello, World 服务端流式rpc 一个请求对象，服务端可以传回多个结果对象
proto语法 rpc serverStreamHello(Person) returns (stream Result) {} service代码 @Override public void serverStreamHello(ProtoObj." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a4115175a15413a95a8467c93ea94028/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-02-05T23:47:01+08:00" />
<meta property="article:modified_time" content="2018-02-05T23:47:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GRPC的四种服务类型</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin:10px auto; color:rgb(94,94,94); font-family:Verdana,Helvetica,Arial; font-size:13px; background-color:rgb(255,255,255)"> <a target="_blank" href="http://www.cnblogs.com/resentment/p/6714610.html" rel="nofollow noopener noreferrer" style="color:rgb(0,153,255)!important">上次</a>简单介绍了grpc的使用方法，并创建了一个方法调用，在grpc中有四种服务类型，下面分别进行介绍</p> 
<h3 id="简单rpc" style="margin-top:10px; margin-bottom:10px; font-size:21px; background-color:rgb(204,255,255); line-height:1.5; color:rgb(94,94,94); font-family:Verdana,Helvetica,Arial; text-align:justify"> 简单rpc</h3> 
<p style="margin:10px auto; color:rgb(94,94,94); font-family:Verdana,Helvetica,Arial; font-size:13px; background-color:rgb(255,255,255)"> 这就是一般的rpc调用，一个请求对象对应一个返回对象</p> 
<pre style="margin-top:10px; margin-bottom:10px; color:rgb(94,94,94); font-size:13px; text-align:justify; background-color:rgb(255,255,255)"><code class="hljs java" style='margin:auto; vertical-align:middle; background-color:rgb(255,255,255); height:auto; overflow-x:auto; color:rgb(0,0,0); line-height:1.5!important; font-family:"Courier New",sans-serif!important; font-size:12px!important; border:1px solid rgb(204,204,204)!important; padding:5px!important'>proto语法：
<span class="hljs-function">rpc <span class="hljs-title" style="color:rgb(163,21,21)">simpleHello</span><span class="hljs-params">(Person)</span> <span class="hljs-title" style="color:rgb(163,21,21)">returns</span> <span class="hljs-params">(Result)</span> </span>{}

service代码
<span class="hljs-meta" style="color:rgb(43,145,175)">@Override</span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255)">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">void</span> <span class="hljs-title" style="color:rgb(163,21,21)">simpleHello</span><span class="hljs-params">(ProtoObj.Person request,
                  io.grpc.stub.StreamObserver&lt;ProtoObj.Result&gt; responseObserver)</span> </span>{
    <span class="hljs-comment" style="color:green">//返回结果</span>
    responseObserver.onNext(ProtoObj.Result.newBuilder().setString(<span class="hljs-string" style="color:rgb(163,21,21)">"hello, "</span>+request.getMyName()).build());
    responseObserver.onCompleted();
}

client代码
<span class="hljs-meta" style="color:rgb(43,145,175)">@Test</span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255)">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">void</span>  <span class="hljs-title" style="color:rgb(163,21,21)">simple</span><span class="hljs-params">()</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">throws</span> InterruptedException </span>{

    <span class="hljs-keyword" style="color:rgb(0,0,255)">final</span> ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string" style="color:rgb(163,21,21)">"127.0.0.1"</span>, <span class="hljs-number">8080</span>).usePlaintext(<span class="hljs-keyword" style="color:rgb(0,0,255)">true</span>).build();
    <span class="hljs-comment" style="color:green">//定义同步阻塞的stub</span>
    HelloServiceGrpc.HelloServiceBlockingStub blockingStub = HelloServiceGrpc.newBlockingStub(channel);

    ProtoObj.Person person = ProtoObj.Person.newBuilder().setMyName(<span class="hljs-string" style="color:rgb(163,21,21)">"World"</span>).build();
    <span class="hljs-comment" style="color:green">//simple</span>
    System.out.println(<span class="hljs-string" style="color:rgb(163,21,21)">"---simple rpc---"</span>);
    System.out.println(blockingStub.simpleHello(person).getString());
    channel.shutdown();
}

输出
---simple rpc---
hello, World</code></pre> 
<h3 id="服务端流式rpc" style="margin-top:10px; margin-bottom:10px; font-size:21px; background-color:rgb(204,255,255); line-height:1.5; color:rgb(94,94,94); font-family:Verdana,Helvetica,Arial; text-align:justify"> 服务端流式rpc</h3> 
<p style="margin:10px auto; color:rgb(94,94,94); font-family:Verdana,Helvetica,Arial; font-size:13px; background-color:rgb(255,255,255)"> 一个请求对象，服务端可以传回多个结果对象</p> 
<pre style="margin-top:10px; margin-bottom:10px; color:rgb(94,94,94); font-size:13px; text-align:justify; background-color:rgb(255,255,255)"><code class="hljs cs" style='margin:auto; vertical-align:middle; background-color:rgb(255,255,255); height:auto; overflow-x:auto; color:rgb(0,0,0); line-height:1.5!important; font-family:"Courier New",sans-serif!important; font-size:12px!important; border:1px solid rgb(204,204,204)!important; padding:5px!important'>proto语法
<span class="hljs-function">rpc <span class="hljs-title" style="color:rgb(163,21,21)">serverStreamHello</span>(<span class="hljs-params">Person</span>) <span class="hljs-title" style="color:rgb(163,21,21)">returns</span> (<span class="hljs-params">stream Result</span>) </span>{}

service代码
@<span class="hljs-function">Override
<span class="hljs-keyword" style="color:rgb(0,0,255)">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">void</span> <span class="hljs-title" style="color:rgb(163,21,21)">serverStreamHello</span>(<span class="hljs-params">ProtoObj.Person request,
                        io.grpc.stub.StreamObserver&lt;ProtoObj.Result&gt; responseObserver</span>) </span>{
    <span class="hljs-comment" style="color:green">//返回多个结果</span>
    responseObserver.onNext(ProtoObj.Result.newBuilder().setString(<span class="hljs-string" style="color:rgb(163,21,21)">"hello, "</span>+request.getMyName()).build());
    responseObserver.onNext(ProtoObj.Result.newBuilder().setString(<span class="hljs-string" style="color:rgb(163,21,21)">"hello2, "</span>+request.getMyName()).build());
    responseObserver.onNext(ProtoObj.Result.newBuilder().setString(<span class="hljs-string" style="color:rgb(163,21,21)">"hello3, "</span>+request.getMyName()).build());
    responseObserver.onCompleted();
}

client代码
@<span class="hljs-function">Test
<span class="hljs-keyword" style="color:rgb(0,0,255)">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">void</span> <span class="hljs-title" style="color:rgb(163,21,21)">serverStream</span>(<span class="hljs-params"></span>)</span>{

    final ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string" style="color:rgb(163,21,21)">"127.0.0.1"</span>, <span class="hljs-number">8080</span>).usePlaintext(<span class="hljs-keyword" style="color:rgb(0,0,255)">true</span>).build();
    <span class="hljs-comment" style="color:green">//定义同步阻塞的stub</span>
    HelloServiceGrpc.HelloServiceBlockingStub blockingStub = HelloServiceGrpc.newBlockingStub(channel);

    ProtoObj.Person person = ProtoObj.Person.newBuilder().setMyName(<span class="hljs-string" style="color:rgb(163,21,21)">"World"</span>).build();

    <span class="hljs-comment" style="color:green">//server side</span>
    System.<span class="hljs-keyword" style="color:rgb(0,0,255)">out</span>.println(<span class="hljs-string" style="color:rgb(163,21,21)">"---server stream rpc---"</span>);
    <span class="hljs-comment" style="color:green">//返回结果是Iterator</span>
    Iterator&lt;ProtoObj.Result&gt; it = blockingStub.serverStreamHello(person);
    <span class="hljs-keyword" style="color:rgb(0,0,255)">while</span> (it.hasNext()) {
        System.<span class="hljs-keyword" style="color:rgb(0,0,255)">out</span>.print(it.next());
    }
    channel.shutdown();
}

输出
---server stream rpc---
<span class="hljs-keyword" style="color:rgb(0,0,255)">string</span>: <span class="hljs-string" style="color:rgb(163,21,21)">"hello, World"</span>
<span class="hljs-keyword" style="color:rgb(0,0,255)">string</span>: <span class="hljs-string" style="color:rgb(163,21,21)">"hello2, World"</span>
<span class="hljs-keyword" style="color:rgb(0,0,255)">string</span>: <span class="hljs-string" style="color:rgb(163,21,21)">"hello3, World"</span></code></pre> 
<h3 id="客户端流式rpc" style="margin-top:10px; margin-bottom:10px; font-size:21px; background-color:rgb(204,255,255); line-height:1.5; color:rgb(94,94,94); font-family:Verdana,Helvetica,Arial; text-align:justify"> 客户端流式rpc</h3> 
<p style="margin:10px auto; color:rgb(94,94,94); font-family:Verdana,Helvetica,Arial; font-size:13px; background-color:rgb(255,255,255)"> 客户端传入多个请求对象，服务端返回一个响应结果</p> 
<pre style="margin-top:10px; margin-bottom:10px; color:rgb(94,94,94); font-size:13px; text-align:justify; background-color:rgb(255,255,255)"><code class="hljs java" style='margin:auto; vertical-align:middle; background-color:rgb(255,255,255); height:auto; overflow-x:auto; color:rgb(0,0,0); line-height:1.5!important; font-family:"Courier New",sans-serif!important; font-size:12px!important; border:1px solid rgb(204,204,204)!important; padding:5px!important'>proto语法
<span class="hljs-function">rpc <span class="hljs-title" style="color:rgb(163,21,21)">clientStreamHello</span><span class="hljs-params">(stream Person)</span> <span class="hljs-title" style="color:rgb(163,21,21)">returns</span> <span class="hljs-params">(Result)</span> </span>{}

service代码
<span class="hljs-meta" style="color:rgb(43,145,175)">@Override</span>
<span class="hljs-keyword" style="color:rgb(0,0,255)">public</span> io.grpc.stub.StreamObserver&lt;ProtoObj.Person&gt; clientStreamHello(
       <span class="hljs-keyword" style="color:rgb(0,0,255)">final</span> io.grpc.stub.StreamObserver&lt;ProtoObj.Result&gt; responseObserver) {
   <span class="hljs-comment" style="color:green">//返回observer应对多个请求对象</span>
   <span class="hljs-keyword" style="color:rgb(0,0,255)">return</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">new</span> StreamObserver&lt;ProtoObj.Person&gt;(){
       <span class="hljs-keyword" style="color:rgb(0,0,255)">private</span> ProtoObj.Result.Builder builder=ProtoObj.Result.newBuilder();
       <span class="hljs-meta" style="color:rgb(43,145,175)">@Override</span>
       <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255)">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">void</span> <span class="hljs-title" style="color:rgb(163,21,21)">onNext</span><span class="hljs-params">(ProtoObj.Person value)</span> </span>{
            builder.setString(builder.getString() +<span class="hljs-string" style="color:rgb(163,21,21)">","</span> + value.getMyName());
       }

       <span class="hljs-meta" style="color:rgb(43,145,175)">@Override</span>
       <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255)">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">void</span> <span class="hljs-title" style="color:rgb(163,21,21)">onError</span><span class="hljs-params">(Throwable t)</span> </span>{

       }

       <span class="hljs-meta" style="color:rgb(43,145,175)">@Override</span>
       <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255)">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">void</span> <span class="hljs-title" style="color:rgb(163,21,21)">onCompleted</span><span class="hljs-params">()</span> </span>{
           builder.setString(<span class="hljs-string" style="color:rgb(163,21,21)">"hello"</span>+builder.getString());
           responseObserver.onNext(builder.build());
           responseObserver.onCompleted();
       }
   };
}

client代码
<span class="hljs-meta" style="color:rgb(43,145,175)">@Test</span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255)">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">void</span> <span class="hljs-title" style="color:rgb(163,21,21)">clientStream</span><span class="hljs-params">()</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">throws</span> InterruptedException </span>{
    <span class="hljs-keyword" style="color:rgb(0,0,255)">final</span> ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string" style="color:rgb(163,21,21)">"127.0.0.1"</span>, <span class="hljs-number">8080</span>).usePlaintext(<span class="hljs-keyword" style="color:rgb(0,0,255)">true</span>).build();
    <span class="hljs-comment" style="color:green">//定义异步的stub</span>
    HelloServiceGrpc.HelloServiceStub asyncStub = HelloServiceGrpc.newStub(channel);
    ProtoObj.Person person = ProtoObj.Person.newBuilder().setMyName(<span class="hljs-string" style="color:rgb(163,21,21)">"World"</span>).build();

    <span class="hljs-comment" style="color:green">//client side</span>
    System.out.println(<span class="hljs-string" style="color:rgb(163,21,21)">"---client stream rpc---"</span>);
    StreamObserver&lt;ProtoObj.Result&gt; responseObserver = <span class="hljs-keyword" style="color:rgb(0,0,255)">new</span> StreamObserver&lt;ProtoObj.Result&gt;() {
        <span class="hljs-meta" style="color:rgb(43,145,175)">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255)">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">void</span> <span class="hljs-title" style="color:rgb(163,21,21)">onNext</span><span class="hljs-params">(ProtoObj.Result result)</span> </span>{
            System.out.println(<span class="hljs-string" style="color:rgb(163,21,21)">"client stream--"</span> + result.getString());
        }

        <span class="hljs-meta" style="color:rgb(43,145,175)">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255)">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">void</span> <span class="hljs-title" style="color:rgb(163,21,21)">onError</span><span class="hljs-params">(Throwable t)</span> </span>{
        }

        <span class="hljs-meta" style="color:rgb(43,145,175)">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255)">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">void</span> <span class="hljs-title" style="color:rgb(163,21,21)">onCompleted</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-comment" style="color:green">//关闭channel</span>
            channel.shutdown();
        }
    };
    StreamObserver&lt;ProtoObj.Person&gt; clientStreamObserver = asyncStub.clientStreamHello(responseObserver);
    clientStreamObserver.onNext(ProtoObj.Person.newBuilder().setMyName(<span class="hljs-string" style="color:rgb(163,21,21)">"World"</span>).build());
    clientStreamObserver.onNext(ProtoObj.Person.newBuilder().setMyName(<span class="hljs-string" style="color:rgb(163,21,21)">"World2"</span>).build());
    clientStreamObserver.onCompleted();
    <span class="hljs-comment" style="color:green">//由于是异步获得结果，所以sleep一秒</span>
    Thread.sleep(<span class="hljs-number">1000</span>);
}

输出
---client stream rpc---
client stream--hello,World,World2</code></pre> 
<h3 id="双向流式rpc" style="margin-top:10px; margin-bottom:10px; font-size:21px; background-color:rgb(204,255,255); line-height:1.5; color:rgb(94,94,94); font-family:Verdana,Helvetica,Arial; text-align:justify"> 双向流式rpc</h3> 
<p style="margin:10px auto; color:rgb(94,94,94); font-family:Verdana,Helvetica,Arial; font-size:13px; background-color:rgb(255,255,255)"> 结合客户端流式rpc和服务端流式rpc，可以传入多个对象，返回多个响应对象</p> 
<pre style="margin-top:10px; margin-bottom:10px; color:rgb(94,94,94); font-size:13px; text-align:justify; background-color:rgb(255,255,255)"><code class="hljs java" style='margin:auto; vertical-align:middle; background-color:rgb(255,255,255); height:auto; overflow-x:auto; color:rgb(0,0,0); line-height:1.5!important; font-family:"Courier New",sans-serif!important; font-size:12px!important; border:1px solid rgb(204,204,204)!important; padding:5px!important'>proto语法
<span class="hljs-function">rpc <span class="hljs-title" style="color:rgb(163,21,21)">biStreamHello</span><span class="hljs-params">(stream Person)</span> <span class="hljs-title" style="color:rgb(163,21,21)">returns</span> <span class="hljs-params">(stream Result)</span> </span>{}

service代码
<span class="hljs-meta" style="color:rgb(43,145,175)">@Override</span>
<span class="hljs-keyword" style="color:rgb(0,0,255)">public</span> io.grpc.stub.StreamObserver&lt;ProtoObj.Person&gt; biStreamHello(
        <span class="hljs-keyword" style="color:rgb(0,0,255)">final</span> io.grpc.stub.StreamObserver&lt;ProtoObj.Result&gt; responseObserver) {
    <span class="hljs-comment" style="color:green">//返回observer应对多个请求对象</span>
    <span class="hljs-keyword" style="color:rgb(0,0,255)">return</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">new</span> StreamObserver&lt;ProtoObj.Person&gt;(){
        <span class="hljs-keyword" style="color:rgb(0,0,255)">private</span> ProtoObj.Result.Builder builder=ProtoObj.Result.newBuilder();
        <span class="hljs-meta" style="color:rgb(43,145,175)">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255)">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">void</span> <span class="hljs-title" style="color:rgb(163,21,21)">onNext</span><span class="hljs-params">(ProtoObj.Person value)</span> </span>{
            responseObserver.onNext(ProtoObj.Result.newBuilder().setString(<span class="hljs-string" style="color:rgb(163,21,21)">"hello2, "</span>+value.getMyName()).build());
            responseObserver.onNext(ProtoObj.Result.newBuilder().setString(<span class="hljs-string" style="color:rgb(163,21,21)">"hello3, "</span>+value.getMyName()).build());
        }

        <span class="hljs-meta" style="color:rgb(43,145,175)">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255)">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">void</span> <span class="hljs-title" style="color:rgb(163,21,21)">onError</span><span class="hljs-params">(Throwable t)</span> </span>{
        }

        <span class="hljs-meta" style="color:rgb(43,145,175)">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255)">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">void</span> <span class="hljs-title" style="color:rgb(163,21,21)">onCompleted</span><span class="hljs-params">()</span> </span>{
            responseObserver.onCompleted();
        }
    };
}

client代码
<span class="hljs-meta" style="color:rgb(43,145,175)">@Test</span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255)">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">void</span> <span class="hljs-title" style="color:rgb(163,21,21)">bidirectStream</span><span class="hljs-params">()</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">throws</span> InterruptedException </span>{

    <span class="hljs-keyword" style="color:rgb(0,0,255)">final</span> ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string" style="color:rgb(163,21,21)">"127.0.0.1"</span>, <span class="hljs-number">8080</span>).usePlaintext(<span class="hljs-keyword" style="color:rgb(0,0,255)">true</span>).build();
    <span class="hljs-comment" style="color:green">//定义异步的stub</span>
    HelloServiceGrpc.HelloServiceStub asyncStub = HelloServiceGrpc.newStub(channel);

    ProtoObj.Person person = ProtoObj.Person.newBuilder().setMyName(<span class="hljs-string" style="color:rgb(163,21,21)">"World"</span>).build();

    <span class="hljs-comment" style="color:green">//bi stream</span>
    System.out.println(<span class="hljs-string" style="color:rgb(163,21,21)">"---bidirectional stream rpc---"</span>);
    StreamObserver&lt;ProtoObj.Result&gt;  responseObserver = <span class="hljs-keyword" style="color:rgb(0,0,255)">new</span> StreamObserver&lt;ProtoObj.Result&gt;() {
        <span class="hljs-meta" style="color:rgb(43,145,175)">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255)">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">void</span> <span class="hljs-title" style="color:rgb(163,21,21)">onNext</span><span class="hljs-params">(ProtoObj.Result result)</span> </span>{
            System.out.println(<span class="hljs-string" style="color:rgb(163,21,21)">"bidirectional stream--"</span>+result.getString());
        }

        <span class="hljs-meta" style="color:rgb(43,145,175)">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255)">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">void</span> <span class="hljs-title" style="color:rgb(163,21,21)">onError</span><span class="hljs-params">(Throwable t)</span> </span>{
        }

        <span class="hljs-meta" style="color:rgb(43,145,175)">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255)">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255)">void</span> <span class="hljs-title" style="color:rgb(163,21,21)">onCompleted</span><span class="hljs-params">()</span> </span>{
            channel.shutdown();
        }
    };
    StreamObserver&lt;ProtoObj.Person&gt; biStreamObserver=asyncStub.biStreamHello(responseObserver);
    biStreamObserver.onNext(ProtoObj.Person.newBuilder().setMyName(<span class="hljs-string" style="color:rgb(163,21,21)">"World"</span>).build());
    biStreamObserver.onNext(ProtoObj.Person.newBuilder().setMyName(<span class="hljs-string" style="color:rgb(163,21,21)">"World2"</span>).build());
    biStreamObserver.onCompleted();
    <span class="hljs-comment" style="color:green">//由于是异步获得结果，所以sleep一秒</span>
    Thread.sleep(<span class="hljs-number">1000</span>);

}

输出
---bidirectional stream rpc---
bidirectional stream--hello2, World
bidirectional stream--hello3, World
bidirectional stream--hello2, World2
bidirectional stream--hello3, World2    </code></pre> 
<h3 id="总结" style="margin-top:10px; margin-bottom:10px; font-size:21px; background-color:rgb(204,255,255); line-height:1.5; color:rgb(94,94,94); font-family:Verdana,Helvetica,Arial; text-align:justify"> 总结</h3> 
<p style="margin:10px auto; color:rgb(94,94,94); font-family:Verdana,Helvetica,Arial; font-size:13px; background-color:rgb(255,255,255)"> grpc通过使用流式的方式，返回/接受多个实例可以用于类似不定长数组的入参和出参</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dd90ad565862e575e1e23c0e5f5cd5f4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux C&#43;&#43;下捕获崩溃日志</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f0abdcf49429cc66da647ba5954023ca/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言字符串输入及输出的几种方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>