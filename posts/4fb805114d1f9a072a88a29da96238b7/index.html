<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>jar命令打包java应用和java打jar包的几种方式详解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="jar命令打包java应用和java打jar包的几种方式详解" />
<meta property="og:description" content="一、Jar命令打包java应用的用法 jar是标准的java打包命令，位于JAVA_HOME/bin/目录下面。主要功能是将多个文件打包成一个单独的jar文件。
创建jar文件
jar c[v0Mmfe] [manifest] [jarfile] [entrypoint] [-C dir] inputfiles [-Joption]
更新jar文件
jar u[v0Mmfe] [manifest] [jarfile] [entrypoint] [-C dir] inputfiles [-Joption]
解压jar文件
jar x[vf] [jarfile] [inputfiles] [-Joption]
显示Jar包结构
jar t[vf] [jarfile] [inputfiles] [-Joption]
添加索引到jar文件
jar i jarfile [-Joption]
其中[]代表可选
参数分析如下： jarfile：被创建、更新、解压或者显示的目标jar文件，和-f选项一起使用
inputfiles：文件或者目录，多个文件或者目录用空格分开，表示需要被打包的文件或者目录，待解压的jar包中的文件或者目录，待显示的jar包的文件或者目录。如果是目录，将按照递归的方式处理。多个文件间以zip方式被压缩，除非添加0选项
manifest：指定manifest文件，和-m参数一起使用
entrypoint：指定类名作为应用的入口，和-e选项一起使用。特别说明，-m、-f、-e参数对应的的manifest、jarfile、entrypoint顺序要相同
-C dir：处理inputfiles时，指定后面inputfile的目录，可以有多个-C dir inputfile
-Joption：指定Java runtiome environment的参数，-J何option之间不能有空格
选项：
-c 创建新的jar包
-u 更新已有的jar包
-x 解压指定的jar包
-t 显示jar包内容
-f 和 jarfile一起使用
-v 输出详细信息
-0 不使用zip压缩
-M 生成jar包时不创建manifest文件(将指定文件作为 MANIFEST." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4fb805114d1f9a072a88a29da96238b7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-24T20:34:10+08:00" />
<meta property="article:modified_time" content="2023-05-24T20:34:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">jar命令打包java应用和java打jar包的几种方式详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、Jar命令打包java应用的用法</h2> 
<p>jar是标准的java打包命令，位于JAVA_HOME/bin/目录下面。主要功能是将多个文件打包成一个单独的jar文件。</p> 
<p><strong>创建jar文件</strong></p> 
<blockquote> 
 <p>jar c[v0Mmfe] [manifest] [jarfile] [entrypoint] [-C dir] inputfiles [-Joption]</p> 
</blockquote> 
<p><strong>更新jar文件</strong></p> 
<blockquote> 
 <p>jar u[v0Mmfe] [manifest] [jarfile] [entrypoint] [-C dir] inputfiles [-Joption]</p> 
</blockquote> 
<p><strong>解压jar文件</strong></p> 
<blockquote> 
 <p>jar x[vf] [jarfile] [inputfiles] [-Joption]</p> 
</blockquote> 
<p><strong>显示Jar包结构</strong></p> 
<blockquote> 
 <p>jar t[vf] [jarfile] [inputfiles] [-Joption]</p> 
</blockquote> 
<p><strong>添加索引到jar文件</strong></p> 
<blockquote> 
 <p>jar i jarfile [-Joption]</p> 
</blockquote> 
<p><strong>其中[]代表可选</strong></p> 
<h3>参数分析如下：</h3> 
<blockquote> 
 <p>jarfile：被创建、更新、解压或者显示的目标jar文件，和-f选项一起使用</p> 
 <p>inputfiles：文件或者目录，多个文件或者目录用空格分开，表示需要被打包的文件或者目录，待解压的jar包中的文件或者目录，待显示的jar包的文件或者目录。如果是目录，将按照递归的方式处理。多个文件间以zip方式被压缩，除非添加0选项</p> 
 <p>manifest：指定manifest文件，和-m参数一起使用</p> 
 <p>entrypoint：指定类名作为应用的入口，和-e选项一起使用。特别说明，-m、-f、-e参数对应的的manifest、jarfile、entrypoint顺序要相同</p> 
 <p>-C dir：处理inputfiles时，指定后面inputfile的目录，可以有多个-C dir inputfile</p> 
 <p>-Joption：指定Java runtiome environment的参数，-J何option之间不能有空格</p> 
 <p>选项：</p> 
 <p>-c 创建新的jar包</p> 
 <p>-u 更新已有的jar包</p> 
 <p>-x 解压指定的jar包</p> 
 <p>-t 显示jar包内容</p> 
 <p>-f 和 jarfile一起使用</p> 
 <p>-v 输出详细信息</p> 
 <p>-0 不使用zip压缩</p> 
 <p>-M 生成jar包时不创建manifest文件(将指定文件作为 MANIFEST.MF 打包进jar)</p> 
 <p>-m 和manifest一起使用</p> 
 <p>-e 和entrypoint一起使用，指定程序的入口类，并将其写入到生成的manifest文件中，对应Main-Class。如果和manifest一起使用并且manifest中指名了Main-Class，打包将会出错</p> 
</blockquote> 
<p><strong>注意：-m 与 -f 的位置很重要。 如果 m 在 f 之前，那么 manifest.txt 就要出现在 app.jar前面，反之亦然。</strong></p> 
<p></p> 
<h2><strong>二、</strong><strong>java打jar包的几种方式详解</strong></h2> 
<p></p> 
<h3><strong>一、制作只含有字节码文件的jar包</strong></h3> 
<p>我们先来看只含有字节码文件，即只含有class文件的jar包怎么制作，这是最简单的形式</p> 
<h4><strong><a name="a11"></a>1、最简单的jar包——直接输出hello</strong></h4> 
<p>最终生成的jar包结构</p> 
<blockquote> 
 <p>META-INF<br> Hello.class</p> 
</blockquote> 
<p>方法步骤</p> 
<p><strong>（1）用记事本写一个Hello.java的文件</strong></p> 
<blockquote> 
 <pre> class Hello{
     public static void main(String[] agrs){
         System.out.println("hello");
     }
 }</pre> 
</blockquote> 
<p><strong>（2）用命令行进入到该目录下，编译这个文件</strong></p> 
<blockquote> 
 <p>　　 javac Hello.java </p> 
</blockquote> 
<p><strong>（3）将编译后的Hello.class文件打成jar包</strong></p> 
<blockquote> 
 <p>　　 jar -cvf hello.jar Hello.class </p> 
</blockquote> 
<p>　　c表示要创建一个新的jar包，v表示创建的过程中在控制台输出创建过程的一些信息，f表示给生成的jar包命名</p> 
<p><strong>（4）运行jar包</strong></p> 
<p>　　 java -jar hello.jar  这时会报如下错误  hello.jar中没有主清单属性 </p> 
<p>　　添加Main-Class属性</p> 
<p>　　用压缩软件打开hello.jar，会发现里面多了一个META-INF文件夹，里面有一个MENIFEST.MF的文件，用记事本打开</p> 
<blockquote> 
 <pre>1 Manifest-Version: 1.0
2 Created-By: 1.8.0_121 (Oracle Corporation)
3 </pre> 
</blockquote> 
<p>　　在第三行的位置写入 Main-Class: Hello （注意冒号后面有一个空格，整个文件最后有一行空行），保存</p> 
<p>　　再次运行 java -jar hello.jar ，此时成功在控制台看到  hello ，成功</p> 
<p></p> 
<h4><strong><a name="a12"></a>2、含有两个类的jar包——通过调用输出hello</strong></h4> 
<p><strong>最终生成的jar包结构</strong></p> 
<blockquote> 
 <p>META-INF<br> Tom.class<br> Hello.class</p> 
</blockquote> 
<p><strong>方法步骤</strong></p> 
<p><strong>（1）用记事本写一个Hello.java和一个Tom.java的文件</strong></p> 
<p>　　目的是让Hello调用Tom的speak方法</p> 
<blockquote> 
 <pre>1 class Hello{
2     public static void main(String[] agrs){
3         Tom.speak();
4     }
5 }</pre> 
</blockquote> 
<blockquote> 
 <pre>1 class Tom{
2     public static void speak(){
3         System.out.println("hello");
4     }
5 }</pre> 
</blockquote> 
<p><strong>（2）编译： javac Hello.java </strong></p> 
<p>　　此时Hello.java和Tom.java同时被编译，因为Hello中调用了Tom，在编译Hello的过程中发现还需要编译Tom</p> 
<p><strong>（3）打jar包，这次我们换一种方式直接定义Main-Class。</strong></p> 
<blockquote> 
 <pre>1 Manifest-Version: 1.0
2 Created-By: 1.8.0_121 (Oracle Corporation)
3 Main-Class: Hello
4  </pre> 
</blockquote> 
<p>　　事先准备好上述的MENIFEST.MF文件，并存放在META-INF文件夹下，此时打jar包的命令如下</p> 
<blockquote> 
 <p>　　 jar -cvfm hello.jar META-INF\MENIFEST.MF Hello.class Tom.class </p> 
</blockquote> 
<p>　　该命令表示用第一个文件当做MENIFEST.MF文件，hello.jar作为名称，将Hello.class和Tom.class打成jar包。其中多了一个参数m，表示要定义MENIFEST文件</p> 
<p><strong>（4）运行 java -jar hello.jar ，此时成功在控制台看到  hello ，成功</strong></p> 
<p></p> 
<h4><strong><a name="a13"></a>3、有目录结构的jar包——通过引包并调用输出hello</strong></h4> 
<p><strong>最终生成的jar包结构</strong></p> 
<blockquote> 
 <p>META-INF<br> com<br> 　Tom.class<br> Hello.class</p> 
</blockquote> 
<p>　　<strong>我们将上一个稍稍变化一下，将Tom这个类放在com包下，源文件目录结构变成</strong></p> 
<blockquote> 
 <p>　　　　com<br> 　　　　　Tom.java<br> 　　　　Hello.java</p> 
</blockquote> 
<p>　　<strong>同时Tom.java需要在第一行声明自己的包名</strong></p> 
<blockquote> 
 <pre>package com;</pre> 
</blockquote> 
<p>　　<strong>Hello.java需要引入Tom这个类，同样要在第一行进行import</strong></p> 
<blockquote> 
 <pre>import com.Tom;</pre> 
</blockquote> 
<p><strong>方法步骤</strong></p> 
<p><strong>（1）编译Hello.java</strong></p> 
<p><strong>（2）打jar包，同样准备好MENIFEST文件</strong></p> 
<blockquote> 
 <p>　　 jar -cvfm hello.jar META-INF\MENIFEST.MF Hello.class com </p> 
</blockquote> 
<p>　　注意，最后一个com表示把com这个文件夹下的所有文件都打进jar包</p> 
<p><strong>（3）运行 java -jar hello.jar  ，此时成功在控制台看到  hello ，成功</strong></p> 
<p><strong>（4）优化过程</strong></p> 
<p>　　我们注意到，com包下是有Tom.java源文件的，也被打进了jar包里，这样不太好，能不能优化一下javac命令，使所有的编译后文件编译到另一个隔离的地方呢，答案是可以的。</p> 
<p>　　在编译Hello.java时，先新建一个target文件夹。然后我们用如下命令</p> 
<blockquote> 
 <p>　　　　<strong> javac Hello.java -d target </strong></p> 
</blockquote> 
<p>　　该命令表示，将所有编译后的文件，都放到target文件夹下。</p> 
<p>　　将META-INF文件夹也复制到target目录下，<strong>进入这个目录</strong>，输入如下命令</p> 
<blockquote> 
 <p>　　　　<strong> jar -cvfm hello.jar META-INF\MENIFEST.MF * </strong></p> 
</blockquote> 
<p>　　注意最后一个位置变成了*，表示把当前目录下所有文件都打在jar包里</p> 
<p>　　优化完毕</p> 
<p></p> 
<p>至此，我们可以总结出，制作一个只含有class字节码文件的jar包，以下命令足以</p> 
<blockquote> 
 <p>javac 要编译的文件 -d 目标位置</p> 
 <p>jar -cvfm 命名 MENIFEST文件 要打包的文件1 要打包的文件2</p> 
</blockquote> 
<p></p> 
<h3><strong>二、制作含有jar文件的jar包</strong></h3> 
<p>我们将场景稍稍变得复杂一点，看看jar包中需要引入其他jar包的场景</p> 
<h4><strong><a name="a21"></a>1、两个jar包间相互调用——调用jar外的jar输出hello</strong></h4> 
<p>最终生成的jar包结构</p> 
<blockquote> 
 <p>hello.jar<br> tom.jar</p> 
</blockquote> 
<p>方法步骤</p> 
<p>准备：将上述一中写好的那个不带包的tom.jar复制过来（目的是调用里面的speak方法）</p> 
<h4>（1）编写一个Hello.java并将其编译成Hello.class，注意，由于Hello里面引用了Tom类的speak方法，因此在打jar包时应使用-cp参数，将tom.jar包引入</h4> 
<blockquote> 
 <p>　　  javac -cp tom.jar Hello.class </p> 
</blockquote> 
<p>　　这里的 -cp 表示 -classpath，指的是把tom.jar加入classpath路径下</p> 
<h4>（2）将hello.class达成jar包，步骤略</h4> 
<h4>（3）此时运行 java -jar 发现报错  ClassNotFoundException：Tom </h4> 
<p>　　原因很简单，引入jar包需要在MENIFEST.MF文件中配置一个新属性：Class-Path，路径指向你需要的所有jar包</p> 
<p>　　现在MENIFEST.MF这个文件应该变成</p> 
<blockquote> 
 <pre>1 Manifest-Version: 1.0
2 Created-By: 1.8.0_121 (Oracle Corporation)
3 Main-Class: Hello
4 Class-Path: Tom.jar
5  </pre> 
</blockquote> 
<h4>（4）好了，修改这个文件，再次运行，发现成功在控制台输出 hello </h4> 
<p>tips：引入多个jar包，中间用空格隔开</p> 
<blockquote> 
 <p>至此，我们可以总结出，命令变化如下</p> 
 <p>javac -cp xxx.jar 要编译的文件 -d 目标位置</p> 
 <p>jar -cvfm 命名 MENIFEST文件 要打包的文件1 要打包的文件2</p> 
</blockquote> 
<p></p> 
<h4><strong><a name="a22"></a>2、jar包中含有jar包——调用jar内的jar输出hello</strong></h4> 
<p>最终生成的jar包结构</p> 
<blockquote> 
 <p>META-INF<br> Hello.class<br> tom.jar</p> 
</blockquote> 
<p>　　当项目中我们把所需要的第三方jar包也打进了我们自己的jar包中时，如果仍然按照上述操作方式，会报找不到Class异常。原因就是jar引用不到放在自己内部的jar包。</p> 
<p>　　这种情况的具体实现细节比较复杂，我会在后一篇介绍一些知名的java应用是如何加载jar包的，来说明这种情况。实现方式的简单说明，可以先参考这篇文章：</p> 
<p>http://www.cnblogs.com/adolfmc/archive/2012/10/07/2713562.html</p> 
<p></p> 
<h3><strong>三、制作含有资源文件的jar包</strong></h3> 
<h4><strong><a name="a31"></a>1、资源文件在jar包内部——读取jar内的文件</strong></h4> 
<p>最终生成的jar包结构</p> 
<blockquote> 
 <p>META-INF<br> Hello.class<br> text.txt</p> 
</blockquote> 
<p> 方法步骤</p> 
<blockquote> 
 <pre> 1 import java.io.InputStream;
 2 import java.io.BufferedReader;
 3 import java.io.InputStreamReader;
 4 
 5 class Hello{
 6     public static void main(String[] args) throws Exception{
 7         Hello hello = new Hello();
 8         InputStream is = hello.getClass().getResourceAsStream("text.txt");
 9         print(is);
10     }
11     
12     /**
13      * 读取文件，输出里面的内容，通用方法
14      */
15     public static void print(InputStream inputStream) throws Exception {
16         InputStreamReader reader = new InputStreamReader(inputStream, "utf-8");
17         BufferedReader br = new BufferedReader(reader);
18         String s = "";
19         while ((s = br.readLine()) != null)
20             System.out.println(s);
21         inputStream.close();
22     }
23 }</pre> 
</blockquote> 
<p></p> 
<h4><strong><a name="a32"></a>2、资源文件在另一个jar包内部——读取另一个jar内的文件</strong></h4> 
<p>最终生成的jar包结构</p> 
<blockquote> 
 <p>hello.jar<br> resource.jar<br> 　text.txt</p> 
</blockquote> 
<p> 方法步骤</p> 
<p>同1一样，只不过需要在MENIFEST文件中将resource.jar加入classpath</p> 
<blockquote> 
 <pre> 1 import java.io.InputStream;
 2 import java.io.BufferedReader;
 3 import java.io.InputStreamReader;
 4 
 5 class Hello{
 6     public static void main(String[] args) throws Exception{
 7         Hello hello = new Hello();
 8         InputStream is = hello.getClass().getResourceAsStream("text.txt");
 9         print(is);
10     }
11     
12     /**
13      * 读取文件，输出里面的内容，通用方法
14      */
15     public static void print(InputStream inputStream) throws Exception {
16         InputStreamReader reader = new InputStreamReader(inputStream, "utf-8");
17         BufferedReader br = new BufferedReader(reader);
18         String s = "";
19         while ((s = br.readLine()) != null)
20             System.out.println(s);
21         inputStream.close();
22     }
23 }</pre> 
</blockquote> 
<p></p> 
<h4><strong><a name="a33"></a>3、资源文件在jar包外部——读取jar外的文件</strong></h4> 
<p>最终生成的jar包结构</p> 
<blockquote> 
 <p>hello.jar<br> text.txt</p> 
</blockquote> 
<p> 方法步骤</p> 
<blockquote> 
 <pre> 1 import java.io.InputStream;
 2 import java.io.BufferedReader;
 3 import java.io.InputStreamReader;
 4 import java.io.FileInputStream;
 5 
 6 class Hello{
 7     public static void main(String[] args) throws Exception{
 8         Hello hello = new Hello();
 9         InputStream is = new FileInputStream("text.txt");
10         print(is);
11     }
12     
13     /**
14      * 读取文件，输出里面的内容，通用方法
15      */
16     public static void print(InputStream inputStream) throws Exception {
17         InputStreamReader reader = new InputStreamReader(inputStream, "utf-8");
18         BufferedReader br = new BufferedReader(reader);
19         String s = "";
20         while ((s = br.readLine()) != null)
21             System.out.println(s);
22         inputStream.close();
23     }
24 }</pre> 
</blockquote> 
<p> 参考：<a href="https://www.cnblogs.com/mq0036/category/1141655.html" rel="nofollow" title="https://www.cnblogs.com/mq0036/category/1141655.html">https://www.cnblogs.com/mq0036/category/1141655.html</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cb039fa734f679b0a785fdd3eb0856f4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">三维欧几里德空间中两个向量叉积的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d79bfb3119f81f003672d6d40e892549/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决Centos7出现grub，停在grub页面</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>