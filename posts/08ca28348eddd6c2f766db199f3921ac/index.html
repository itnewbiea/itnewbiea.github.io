<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c# modbus Rtu类 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c# modbus Rtu类" />
<meta property="og:description" content="//c# modbus 类，在windows系统可以用
//读取输出线圈 功能码0x01
//读取输入线圈 功能码0x02
//读取保持型寄存器 功能码0x03
//强制单线圈 功能码0x05
//预置单字保持型寄存器 功能码0x06
//预置多字保持型寄存器 功能码0x10
using System.IO.Ports;//在vs2019平台.net4.0FrameWork
public class Modbus
{
//定义串口类对象
private SerialPort MyCom;
//定义CRC校验高低位
private byte ucCRCHi = 0xFF;
private byte ucCRCLo = 0xFF;
//定义接收字节数组
byte[] bData = new byte[1024];
byte mReceiveByte;
int mReceiveByteCount = 0;
//定义设备地址
int CurrentAddr;
int iMWordLen;
int iMBitLen;
//定义返回报文
string strUpData;
public Modbus()
{
MyCom = new SerialPort();
}
#region 打开关闭串口方法
/// &lt;summary&gt;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/08ca28348eddd6c2f766db199f3921ac/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-24T20:52:02+08:00" />
<meta property="article:modified_time" content="2022-12-24T20:52:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c# modbus Rtu类</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>//c# modbus 类，在<span style="color:#1a439c;"><strong>windows</strong></span>系统可以用<br> //读取输出线圈  功能码0x01<br> //读取输入线圈  功能码0x02<br> //读取保持型寄存器 功能码0x03<br> //强制单线圈  功能码0x05<br> //预置单字保持型寄存器 功能码0x06<br> //预置多字保持型寄存器 功能码0x10</p> 
<p><span style="color:#1a439c;"><strong>using System.IO.Ports;//在vs2019平台.net4.0FrameWork</strong></span></p> 
<p><span style="color:#1a439c;"><strong>public class</strong></span> <span style="color:#1a439c;"><strong>Modbus</strong></span><br>     {<!-- --><br>         //定义串口类对象<br>         private <span style="color:#1a439c;"><strong>SerialPort</strong></span> MyCom;<br>         //定义CRC校验高低位<br>         private byte <span style="color:#1a439c;"><strong>ucCRCHi</strong></span> = 0xFF;<br>         private byte <span style="color:#1a439c;"><strong>ucCRCLo</strong></span> = 0xFF;<br>         //定义接收字节数组<br>         byte[] <span style="color:#1a439c;"><strong>bData</strong></span> = new byte[1024];<br>         byte <span style="color:#1a439c;"><strong>mReceiveByte</strong></span>;<br>         int <span style="color:#1a439c;"><strong>mReceiveByteCount</strong></span> = 0;<br>         //定义设备地址<br>         int <span style="color:#1a439c;"><strong>CurrentAddr</strong></span>;<br>         int <span style="color:#1a439c;"><strong>iMWordLen</strong></span>;<br>         int <span style="color:#1a439c;"><strong>iMBitLen</strong></span>;<br>         //定义返回报文<br>         string <span style="color:#1a439c;"><strong>strUpData</strong></span>;<br>         public <span style="color:#1a439c;"><strong>Modbus</strong></span>()<br>         {<!-- --><br>             MyCom = new SerialPort();<br>         }</p> 
<p>        #region 打开关闭串口方法<br>         /// &lt;summary&gt;<br>         /// 打开串口方法【9600 N 8 1】<br>         /// &lt;/summary&gt;<br>         /// &lt;param name="iBaudRate"&gt;波特率&lt;/param&gt;<br>         /// &lt;param name="iPortNo"&gt;端口号&lt;/param&gt;<br>         /// &lt;param name="iDataBits"&gt;数据位&lt;/param&gt;<br>         /// &lt;param name="iParity"&gt;校验位&lt;/param&gt;<br>         /// &lt;param name="iStopBits"&gt;停止位&lt;/param&gt;<br>         /// &lt;returns&gt;&lt;/returns&gt;<br>         public bool <span style="color:#1a439c;"><strong>OpenMyComm</strong></span>(int iBaudRate, string iPortNo, int iDataBits, Parity iParity, StopBits iStopBits)<br>         {<!-- --><br>             try<br>             {<!-- --><br>                 //关闭已打开串口<br>                 if (MyCom.IsOpen)<br>                 {<!-- --><br>                     MyCom.Close();<br>                 }<br>                 //设置串口属性<br>                 MyCom.BaudRate = iBaudRate;<br>                 MyCom.PortName = iPortNo;<br>                 MyCom.DataBits = iDataBits;<br>                 MyCom.Parity = iParity;<br>                 MyCom.StopBits = iStopBits;<br>                 MyCom.ReceivedBytesThreshold = 1;<br>                 MyCom.DataReceived += new SerialDataReceivedEventHandler(MyCom_DataReceived);</p> 
<p>                MyCom.Open();<br>                 return true;<br>             }<br>             catch<br>             {<!-- --><br>                 return false;<br>             }<br>         }</p> 
<p>        /// &lt;summary&gt;<br>         /// 关闭串口方法<br>         /// &lt;/summary&gt;<br>         /// &lt;returns&gt;&lt;/returns&gt;<br>         public bool <span style="color:#1a439c;"><strong>ClosePort</strong></span>()<br>         {<!-- --><br>             if (MyCom.IsOpen)<br>             {<!-- --><br>                 MyCom.Close();<br>                 return true;<br>             }<br>             else<br>             {<!-- --><br>                 return false;<br>             }</p> 
<p>        }<br>         #endregion</p> 
<p>        #region 串口接受数据事件<br>         /// &lt;summary&gt;<br>         /// 串口接受数据事件<br>         /// &lt;/summary&gt;<br>         /// &lt;param name="sender"&gt;&lt;/param&gt;<br>         /// &lt;param name="e"&gt;&lt;/param&gt;<br>         void <span style="color:#1a439c;"><strong>MyCom_DataReceived</strong></span>(object sender, SerialDataReceivedEventArgs e)<br>         {<!-- --><br>             while (MyCom.BytesToRead &gt; 0)<br>             {<!-- --><br>                 mReceiveByte = (byte)MyCom.ReadByte();<br>                 bData[mReceiveByteCount] = mReceiveByte;<br>                 mReceiveByteCount += 1;<br>                 if (mReceiveByteCount &gt;= 1024)<br>                 {<!-- --><br>                     mReceiveByteCount = 0;<br>                     //清除输入缓存区<br>                     MyCom.DiscardInBuffer();<br>                     return;<br>                 }<br>             }<br>             //读取保持型寄存器 功能码0x03<br>             if (bData[0] == (byte)CurrentAddr &amp;&amp; bData[1] == 0x03 &amp;&amp; mReceiveByteCount &gt;= (iMWordLen * 2 + 5))<br>             {<!-- --><br>                 strUpData = "";<br>                 for (int i = 0; i &lt; iMWordLen * 2 + 5; i++)<br>                 {<!-- --><br>                     strUpData = strUpData + " " + bData[i].ToString("X2");<br>                 }<br>                 MyCom.DiscardInBuffer();<br>             }<br>             //预置单字保持型寄存器  功能码0x06<br>             if (bData[0] == (byte)CurrentAddr &amp;&amp; bData[1] == 0x06 &amp;&amp; mReceiveByteCount &gt;= 8)<br>             {<!-- --><br>                 strUpData = "";<br>                 for (int i = 0; i &lt; 8; i++)<br>                 {<!-- --><br>                     strUpData = strUpData + " " + bData[i].ToString("X2");<br>                 }<br>                 MyCom.DiscardInBuffer();<br>             }<br>             //预置双字保持型寄存器  功能码0x10<br>             if (bData[0] == (byte)CurrentAddr &amp;&amp; bData[1] == 0x10 &amp;&amp; mReceiveByteCount &gt;= 8)<br>             {<!-- --><br>                 strUpData = "";<br>                 for (int i = 0; i &lt; 8; i++)<br>                 {<!-- --><br>                     strUpData = strUpData + " " + bData[i].ToString("X2");<br>                 }<br>                 MyCom.DiscardInBuffer();</p> 
<p>            }<br>             //读取输出线圈  功能码0x01<br>             if (bData[0] == (byte)CurrentAddr &amp;&amp; bData[1] == 0x01 &amp;&amp; mReceiveByteCount &gt;= iMBitLen + 5)<br>             {<!-- --><br>                 strUpData = "";<br>                 for (int i = 0; i &lt; iMBitLen + 5; i++)<br>                 {<!-- --><br>                     strUpData = strUpData + " " + bData[i].ToString("X2");<br>                 }<br>                 MyCom.DiscardInBuffer();</p> 
<p>            }</p> 
<p>            //读取输入线圈  功能码0x02<br>             if (bData[0] == (byte)CurrentAddr &amp;&amp; bData[1] == 0x02 &amp;&amp; mReceiveByteCount &gt;= iMBitLen + 5)<br>             {<!-- --><br>                 strUpData = "";<br>                 for (int i = 0; i &lt; iMBitLen + 5; i++)<br>                 {<!-- --><br>                     strUpData = strUpData + " " + bData[i].ToString("X2");<br>                 }<br>                 MyCom.DiscardInBuffer();<br>             }</p> 
<p>            //强制单线圈 功能码0x05<br>             if (bData[0] == (byte)CurrentAddr &amp;&amp; bData[1] == 0x05 &amp;&amp; mReceiveByteCount &gt;=8)<br>             {<!-- --><br>                 strUpData = "";<br>                 for (int i = 0; i &lt; 8; i++)<br>                 {<!-- --><br>                     strUpData = strUpData + " " + bData[i].ToString("X2");<br>                 }<br>                 MyCom.DiscardInBuffer();<br>             }</p> 
<p>        }<br>         #endregion</p> 
<p>        #region 读取保持型寄存器 功能码0x03<br>         /// &lt;summary&gt;<br>         /// 读取保持型寄存器 功能码0x03<br>         /// &lt;/summary&gt;<br>         /// &lt;param name="iDevAdd"&gt;从站地址&lt;/param&gt;<br>         /// &lt;param name="iAddress"&gt;起始地址&lt;/param&gt;<br>         /// &lt;param name="iLength"&gt;长度&lt;/param&gt;<br>         /// &lt;returns&gt;&lt;/returns&gt;<br>         public byte[] <span style="color:#1a439c;"><strong>ReadKeepReg</strong></span>(int iDevAdd, int iAddress, int iLength)<br>         {<!-- --><br>             byte[] ResByte = null;<br>             iMWordLen = iLength;<br>             CurrentAddr = iDevAdd;<br>             //第一步：拼接报文<br>             byte[] SendCommand = new byte[8];<br>             SendCommand[0] = (byte)iDevAdd;<br>             SendCommand[1] = 0x03;<br>             SendCommand[2] = (byte)((iAddress - iAddress % 256) / 256);<br>             SendCommand[3] = (byte)(iAddress % 256);<br>             SendCommand[4] = (byte)((iLength - iLength % 256) / 256);<br>             SendCommand[5] = (byte)(iLength % 256);<br>             Crc16(SendCommand, 6);<br>             SendCommand[6] = ucCRCLo;<br>             SendCommand[7] = ucCRCHi;</p> 
<p>            //第二步：发送报文<br>             try<br>             {<!-- --><br>                 MyCom.Write(SendCommand, 0, 8);<br>             }<br>             catch (Exception)<br>             {<!-- --><br>                 return null;<br>             }<br>             //第三步：解析报文<br>             mReceiveByteCount = 0;<br>             Thread.Sleep(100);</p> 
<p>            ResByte = HexStringToByteArray(this.strUpData, 3, 2);</p> 
<p>            return ResByte;</p> 
<p>        }<br>         #endregion</p> 
<p>        #region 预置单字保持型寄存器 功能码0x06<br>         /// &lt;summary&gt;<br>         /// 预置单字保持型寄存器  功能码0x06<br>         /// &lt;/summary&gt;<br>         /// &lt;param name="iDevAdd"&gt;&lt;/param&gt;<br>         /// &lt;param name="iAddress"&gt;&lt;/param&gt;<br>         /// &lt;param name="SetValue"&gt;&lt;/param&gt;<br>         /// &lt;returns&gt;&lt;/returns&gt;<br>         public bool <span style="color:#1a439c;"><strong>PreSetKeepReg</strong></span>(int iDevAdd, int iAddress, int SetValue)<br>         {<!-- --><br>             byte[] ResByte;<br>             byte[] SendCommand = new byte[8];<br>             CurrentAddr = iDevAdd;<br>             //第一步：拼接报文<br>             SendCommand[0] = (byte)iDevAdd;<br>             SendCommand[1] = 0x06;<br>             SendCommand[2] = (byte)((iAddress - iAddress % 256) / 256);<br>             SendCommand[3] = (byte)(iAddress % 256);<br>             SendCommand[4] = (byte)((SetValue - SetValue % 256) / 256);<br>             SendCommand[5] = (byte)(SetValue % 256);<br>             Crc16(SendCommand, 6);<br>             SendCommand[6] = ucCRCLo;<br>             SendCommand[7] = ucCRCHi;<br>             try<br>             {<!-- --><br>                 //第二步：发送报文<br>                 MyCom.Write(SendCommand, 0, 8);<br>             }<br>             catch (Exception)<br>             {<!-- --><br>                 return false;<br>             }<br>             mReceiveByteCount = 0;<br>             Thread.Sleep(100);<br>             //第三步：解析报文<br>             ResByte = HexStringToByteArray(this.strUpData, 0, 0);<br>             return ByteArrayEquals(SendCommand, ResByte);<br>         }<br>         #endregion</p> 
<p>        #region 预置双字保持型寄存器 功能码0x10<br>         /// &lt;summary&gt;<br>         /// 预置双字保持型寄存器 功能码0x10<br>         /// &lt;/summary&gt;<br>         /// &lt;param name="iDevAdd"&gt;&lt;/param&gt;<br>         /// &lt;param name="iAddress"&gt;&lt;/param&gt;<br>         /// &lt;param name="SetValue"&gt;&lt;/param&gt;<br>         /// &lt;returns&gt;&lt;/returns&gt;<br>         public bool <span style="color:#1a439c;"><strong>PreSetFloatKeepReg</strong></span>(int iDevAdd, int iAddress, float SetValue)<br>         {<!-- --><br>             byte[] ResByte;<br>             byte[] SendCommand = new byte[13];<br>             CurrentAddr = iDevAdd;<br>             SendCommand[0] = (byte)iDevAdd;<br>             SendCommand[1] = 0x10;<br>             SendCommand[2] = (byte)((iAddress - iAddress % 256) / 256);<br>             SendCommand[3] = (byte)(iAddress % 256);<br>             SendCommand[4] = 0x00;<br>             SendCommand[5] = 0x02;<br>             SendCommand[6] = 0x04;<br>             byte[] bSetValue = BitConverter.GetBytes(SetValue);<br>             SendCommand[7] = bSetValue[3];<br>             SendCommand[8] = bSetValue[2];<br>             SendCommand[9] = bSetValue[1];<br>             SendCommand[10] = bSetValue[0];<br>             Crc16(SendCommand, 11);<br>             SendCommand[11] = ucCRCLo;<br>             SendCommand[12] = ucCRCHi;<br>             try<br>             {<!-- --><br>                 MyCom.Write(SendCommand, 0, 13);<br>             }<br>             catch (Exception)<br>             {<!-- --><br>                 return false;<br>             }<br>             mReceiveByteCount = 0;<br>             Thread.Sleep(100);<br>             ResByte = HexStringToByteArray(this.strUpData, 0, 0);</p> 
<p>            byte[] byteTemp = GetByteArray(ResByte, 0, 6);<br>             Crc16(byteTemp, 6);<br>             byte[] bytecrc = GetByteArray(ResByte, 6, 2);<br>             if (ByteArrayEquals(GetByteArray(SendCommand, 0, 6), byteTemp) &amp;&amp; bytecrc[0] == ucCRCLo &amp;&amp; bytecrc[1] == ucCRCHi)<br>             {<!-- --><br>                 return true;<br>             }<br>             else<br>             {<!-- --><br>                 return false;<br>             }</p> 
<p>        }<br>         #endregion</p> 
<p>        #region 读取输出线圈  功能码0x01<br>         /// &lt;summary&gt;<br>         /// 读取输出线圈  功能码0x01<br>         /// &lt;/summary&gt;<br>         /// &lt;param name="iDevAdd"&gt;&lt;/param&gt;<br>         /// &lt;param name="iAddress"&gt;&lt;/param&gt;<br>         /// &lt;param name="iLength"&gt;&lt;/param&gt;<br>         /// &lt;returns&gt;&lt;/returns&gt;<br>         public byte[] <span style="color:#1a439c;"><strong>ReadOutputStatus</strong></span>(int iDevAdd, int iAddress, int iLength)<br>         {<!-- --><br>             byte[] SendCommand = new byte[8];<br>             CurrentAddr = iDevAdd;<br>             if (iLength % 8 == 0)<br>             {<!-- --><br>                 iMBitLen = iLength / 8;<br>             }<br>             else<br>             {<!-- --><br>                 iMBitLen = iLength / 8 + 1;<br>             }</p> 
<p>            //第一步：拼接报文<br>             SendCommand[0] = (byte)iDevAdd;<br>             SendCommand[1] = 0x01;<br>             SendCommand[2] = (byte)((iAddress - iAddress % 256) / 256);<br>             SendCommand[3] = (byte)(iAddress % 256);<br>             SendCommand[4] = (byte)((iLength - iLength % 256) / 256);<br>             SendCommand[5] = (byte)(iLength % 256);<br>             Crc16(SendCommand, 6);<br>             SendCommand[6] = ucCRCLo;<br>             SendCommand[7] = ucCRCHi;<br>             try<br>             {<!-- --><br>                 MyCom.Write(SendCommand, 0, 8);<br>             }<br>             catch (Exception)<br>             {<!-- --><br>                 return null;<br>             }<br>             mReceiveByteCount = 0;<br>             Thread.Sleep(100);<br>             return HexStringToByteArray(this.strUpData, 3, 2);<br>         }<br>         #endregion</p> 
<p>        #region 读取输入线圈  功能码0x02<br>         /// &lt;summary&gt;<br>         /// 读取输入线圈  功能码0x02<br>         /// &lt;/summary&gt;<br>         /// &lt;param name="iDevAdd"&gt;&lt;/param&gt;<br>         /// &lt;param name="iAddress"&gt;&lt;/param&gt;<br>         /// &lt;param name="iLength"&gt;&lt;/param&gt;<br>         /// &lt;returns&gt;&lt;/returns&gt;<br>         public byte[] <span style="color:#1a439c;"><strong>ReadInputStatus</strong></span>(int iDevAdd, int iAddress, int iLength)<br>         {<!-- --><br>             byte[] SendCommand = new byte[8];<br>             CurrentAddr = iDevAdd;<br>             if (iLength % 8 == 0)<br>             {<!-- --><br>                 iMBitLen = iLength / 8;<br>             }<br>             else<br>             {<!-- --><br>                 iMBitLen = iLength / 8 + 1;<br>             }</p> 
<p>            //第一步：拼接报文<br>             SendCommand[0] = (byte)iDevAdd;<br>             SendCommand[1] = 0x02;<br>             SendCommand[2] = (byte)((iAddress - iAddress % 256) / 256);<br>             SendCommand[3] = (byte)(iAddress % 256);<br>             SendCommand[4] = (byte)((iLength - iLength % 256) / 256);<br>             SendCommand[5] = (byte)(iLength % 256);<br>             Crc16(SendCommand, 6);<br>             SendCommand[6] = ucCRCLo;<br>             SendCommand[7] = ucCRCHi;<br>             try<br>             {<!-- --><br>                 MyCom.Write(SendCommand, 0, 8);<br>             }<br>             catch (Exception)<br>             {<!-- --><br>                 return null;<br>             }<br>             mReceiveByteCount = 0;<br>             Thread.Sleep(100);<br>             return HexStringToByteArray(this.strUpData, 3, 2);<br>         }<br>         #endregion</p> 
<p>        #region 强制单线圈  功能码0x05<br>         /// &lt;summary&gt;<br>         /// 强制单线圈  功能码0x05<br>         /// &lt;/summary&gt;<br>         /// &lt;param name="iDevAdd"&gt;&lt;/param&gt;<br>         /// &lt;param name="iAddress"&gt;&lt;/param&gt;<br>         /// &lt;param name="SetValue"&gt;&lt;/param&gt;<br>         /// &lt;returns&gt;&lt;/returns&gt;<br>         public bool <span style="color:#1a439c;"><strong>ForceCoil</strong></span>(int iDevAdd,int iAddress,bool SetValue)<br>         {<!-- --><br>             byte[] ResByte;<br>             byte[] SendCommand = new byte[8];<br>             CurrentAddr = iDevAdd;<br>             SendCommand[0] = (byte)iDevAdd;<br>             SendCommand[1] = 0x05;<br>             SendCommand[2] = (byte)((iAddress - iAddress % 256) / 256);<br>             SendCommand[3] = (byte)(iAddress % 256);<br>             if (SetValue)<br>             {<!-- --><br>                 SendCommand[4] = 0xFF;<br>             }<br>             else<br>             {<!-- --><br>                 SendCommand[4] = 0x00;<br>             }<br>             SendCommand[5] = 0x00;<br>             Crc16(SendCommand, 6);<br>             SendCommand[6] = ucCRCLo;<br>             SendCommand[7] = ucCRCHi;</p> 
<p>            try<br>             {<!-- --><br>                 MyCom.Write(SendCommand, 0, 8);<br>             }<br>             catch (Exception)<br>             {<!-- --><br>                 return false;<br>             }<br>             mReceiveByteCount = 0;<br>             Thread.Sleep(100);<br>             ResByte = HexStringToByteArray(this.strUpData,0,0);<br>             return ByteArrayEquals(SendCommand, ResByte);<br>         }<br>         #endregion</p> 
<p>        #region 自定义方法<br>         /// &lt;summary&gt;<br>         /// 报文转换字节数组（自定义截取）<br>         /// &lt;/summary&gt;<br>         /// &lt;param name="S"&gt;&lt;/param&gt;<br>         /// &lt;param name="start"&gt;&lt;/param&gt;<br>         /// &lt;param name="end"&gt;&lt;/param&gt;<br>         /// &lt;returns&gt;&lt;/returns&gt;<br>         private byte[] <span style="color:#1a439c;"><strong>HexStringToByteArray</strong></span>(string S, int start, int end)<br>         {<!-- --><br>             byte[] Res = null;<br>             if (S != null &amp;&amp; S.Length &gt; start + end)<br>             {<!-- --><br>                 string[] str = S.Trim().Split(' ');<br>                 string[] Result = new string[str.Length - start - end];<br>                 for (int i = 0; i &lt; Result.Length; i++)<br>                 {<!-- --><br>                     Result[i] = str[i + start];<br>                 }<br>                 Res = new byte[Result.Length];<br>                 for (int i = 0; i &lt; Result.Length; i++)<br>                 {<!-- --><br>                     Res[i] = Convert.ToByte(Result[i], 16);<br>                 }<br>             }<br>             return Res;<br>         }</p> 
<p>        /// &lt;summary&gt;<br>         /// 判断两个字节数组是否完全一致<br>         /// &lt;/summary&gt;<br>         /// &lt;param name="b1"&gt;&lt;/param&gt;<br>         /// &lt;param name="b2"&gt;&lt;/param&gt;<br>         /// &lt;returns&gt;&lt;/returns&gt;<br>         private bool <span style="color:#1a439c;"><strong>ByteArrayEquals</strong></span>(byte[] b1, byte[] b2)<br>         {<!-- --><br>             if (b1.Length != b2.Length) return false;<br>             if (b1 == null || b2 == null) return false;<br>             for (int i = 0; i &lt; b1.Length; i++)<br>                 if (b1[i] != b2[i])<br>                     return false;<br>             return true;<br>         }</p> 
<p>        /// &lt;summary&gt;<br>         /// 自定义截取字节数组<br>         /// &lt;/summary&gt;<br>         /// &lt;param name="byteArr"&gt;&lt;/param&gt;<br>         /// &lt;param name="start"&gt;&lt;/param&gt;<br>         /// &lt;param name="length"&gt;&lt;/param&gt;<br>         /// &lt;returns&gt;&lt;/returns&gt;<br>         private byte[] <span style="color:#1a439c;"><strong>GetByteArray</strong></span>(byte[] byteArr, int start, int length)<br>         {<!-- --><br>             byte[] Res = new byte[length];<br>             if (byteArr != null &amp;&amp; byteArr.Length &gt; length)<br>             {<!-- --><br>                 for (int i = 0; i &lt; length; i++)<br>                 {<!-- --><br>                     Res[i] = byteArr[i + start];<br>                 }</p> 
<p>            }<br>             return Res;<br>         }<br>         #endregion</p> 
<p>        #region  CRC校验<br>         private static readonly byte[] <span style="color:#1a439c;"><strong>aucCRCHi </strong></span>= {<!-- --><br>              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,<br>              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,<br>              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,<br>              0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,<br>              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,<br>              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,<br>              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,<br>              0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,<br>              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,<br>              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,<br>              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,<br>              0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, <br>              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,<br>              0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, <br>              0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,<br>              0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,<br>              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, <br>              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,<br>              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,<br>              0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,<br>              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,<br>              0x00, 0xC1, 0x81, 0x40<br>          };<br>         private static readonly byte[] <span style="color:#1a439c;"><strong>aucCRCLo</strong></span> = {<!-- --><br>              0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,<br>              0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,<br>              0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,<br>              0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,<br>              0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,<br>              0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,<br>              0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,<br>              0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, <br>              0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,<br>              0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,<br>              0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,<br>              0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,<br>              0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, <br>              0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,<br>              0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,<br>              0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,<br>              0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,<br>              0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,<br>              0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,<br>              0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,<br>              0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,<br>              0x41, 0x81, 0x80, 0x40<br>          };<br>         private void <span style="color:#1a439c;"><strong>Crc16</strong></span>(byte[] pucFrame, int usLen)<br>         {<!-- --><br>             int i = 0;<br>             ucCRCHi = 0xFF;<br>             ucCRCLo = 0xFF;<br>             UInt16 iIndex = 0x0000;</p> 
<p>            while (usLen-- &gt; 0)<br>             {<!-- --><br>                 iIndex = (UInt16)(ucCRCLo ^ pucFrame[i++]);<br>                 ucCRCLo = (byte)(ucCRCHi ^ aucCRCHi[iIndex]);<br>                 ucCRCHi = aucCRCLo[iIndex];<br>             }</p> 
<p>        }</p> 
<p>        #endregion</p> 
<p>    }<br> }</p> 
<p>//下载链接：<a href="https://download.csdn.net/download/weixin_39926429/87323018" title="c#modbus类，可以用-智慧城市文档类资源-CSDN下载">c#modbus类，可以用-智慧城市文档类资源-CSDN下载</a></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aba8bbda217c056901a76aaef70ff130/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vscode 使用插件 code runner 运行php 配置方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/72770c854626cfb5764999b32a748807/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用Docker搭建Nacos的持久化和集群部署</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>