<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>贪心算法详细介绍（贪心算法与动态规划的区别） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="贪心算法详细介绍（贪心算法与动态规划的区别）" />
<meta property="og:description" content="贪心算法 当一个问题具有最优子结构性质时，可用动态规划法求解。有时会有更简单有效的算法。考察找硬币的例子。假设有4种硬币，它们的面值分别为二角五分、一角、五分和一分。现在要找给顾客六角三分钱。这时，自然地拿出2个二角五分的硬币、1个一角的硬币和3个一分的硬币交给顾客。这种找硬币方法与其他找法相比，拿出的硬币个数是最少的。这里使用的找硬币算法为：首先选出一个面值不超过六角三分的最大硬币，即二角五分；然后从六角三分中减去三角五分，剩下三角八分；再选出一个面值不超过三角八分的最大硬币，即又一个二角五分，如此一直做下去。这个方法实际上就是贪心算法。顾名思义，贪心算法总是做出在当前看来是最好的选择。 也就是说，贪心算法并不从整体最优加以考虑，所做的选择只是在某种意义上的最优选择。当然，我们希望贪心算法得到的最终结果也是整体最优的。找硬币算法得到的结果就是一个整体最优解。
找硬币问题本身具有最优子结构性质，可以用动态规划算法来解，但贪心算法更简单，更直接，并且解题效率更高。这利用了问题本身的一些特性。例如，上述找硬币的算法利用了硬币面值的特殊性。如果硬币面值改为一分、五分和一角一分，而要找给顾客的是一角五分钱。还用贪心算法，将给顾客1个一角一分的硬币和4个一分的硬币。然而3个五分的硬币显然是最好的找法。虽然贪心算法不是对所有问题都可以得到整体最优解，但是对范围相当广的许多问题能够产生整体最优解，如最小生成树问题、图的单源最短路径问题等。在一些情况下，即使贪心算法不能得到整体最优解，但其最终结果却是最优解的很好的近似解。
例：活动选择问题 题目描述：设有n个活动的集合E={1,2,…,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间si和一个结束时间fi,且si &lt;fi 。如果选择了活动i，则它在半开时间区间[si, fi)内占用资源。若区间[si, fi)与区间[sj, fj)不相交，则称活动i与活动j是相容的。也就是说，当si≥fj或sj≥fi时，活动i与活动j相容。
活动安排问题： 要在所给的活动集合中选出最大的相容活动子集合。
活动安排问题的关键是如何按照一定的顺序安排活动，使得选出的活动间相容并能安排尽量多的活动。
题解：由于输入的活动以其完成时间的非减序排列，所以每次总是选择具有最早完成时间的相容活动加入集合A中。直观上，按这种方法选择相容活动为未安排活动留下尽可能多的时间。也就是说，贪心选择的意义是使剩余的可安排时间段极大化，以便安排尽可能多的相容活动。
若被检查的活动i的开始时间Si小于最近选择的活动j的结束时间fi，则不选择活动i，否则选择活动i加入集合A中。
贪心算法并不总能求得问题的整体最优解。但对于活动安排问题，贪心算法greedySelector却总能求得的整体最优解，即它最终所确定的相容活动集合A的规模最大。这个结论可以用数学归纳法证明。
#include&lt;iostream&gt; using namespace std; /*假设输入的活动结束时间按照增序排序。 若输入活动的结束时间未排序，可对活动进行排序然后进行选择。 */ int s[12]，f[12]； bool a[11]; int n=11; int Selector() { a[1]=true; int j=1; int count=1; for (int i=2;i&lt;=n;i&#43;&#43;) { if(s[i]&gt;=f[j]) { a[i]=true; j=i; count&#43;&#43;; } else a[i]=false; } return count; } int main() { cout&lt;&lt;&#34;活动序号：&#34;&lt;&lt;endl; for(int i=1;i&lt;=11;i&#43;&#43;) cout&lt;&lt;i&lt;&lt;&#34; &#34;; cout&lt;&lt;endl&lt;&lt;&#34;活动开始时间：&#34;&lt;&lt;endl; for(int i=1;i&lt;=11;i&#43;&#43;) cout&lt;&lt;s[i]&lt;&lt;&#34; &#34;; cout&lt;&lt;endl&lt;&lt;&#34;活动结束时间：&#34;&lt;&lt;endl; for(int i=1;i&lt;=11;i&#43;&#43;) cout&lt;&lt;f[i]&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/7659f06a5b551ee38ecd2ed73f32c3a3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-16T23:24:34+08:00" />
<meta property="article:modified_time" content="2022-01-16T23:24:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">贪心算法详细介绍（贪心算法与动态规划的区别）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>贪心算法</h3> 
<p>当一个问题具有最优子结构性质时，可用动态规划法求解。有时会有更简单有效的算法。考察找硬币的例子。假设有4种硬币，它们的面值分别为二角五分、一角、五分和一分。现在要找给顾客六角三分钱。这时，自然地拿出2个二角五分的硬币、1个一角的硬币和3个一分的硬币交给顾客。这种找硬币方法与其他找法相比，拿出的硬币个数是最少的。<strong>这里使用的找硬币算法为：首先选出一个面值不超过六角三分的最大硬币，即二角五分；然后从六角三分中减去三角五分，剩下三角八分；再选出一个面值不超过三角八分的最大硬币，即又一个二角五分，如此一直做下去。这个方法实际上就是贪心算法。顾名思义，贪心算法总是做出在当前看来是最好的选择。</strong> 也就是说，贪心算法并不从整体最优加以考虑，所做的选择只是在某种意义上的最优选择。当然，我们希望贪心算法得到的最终结果也是整体最优的。找硬币算法得到的结果就是一个整体最优解。</p> 
<p>找硬币问题本身具有最优子结构性质，可以用动态规划算法来解，但贪心算法更简单，更直接，并且解题效率更高。这利用了问题本身的一些特性。例如，上述找硬币的算法利用了硬币面值的特殊性。如果硬币面值改为一分、五分和一角一分，而要找给顾客的是一角五分钱。还用贪心算法，将给顾客1个一角一分的硬币和4个一分的硬币。然而3个五分的硬币显然是最好的找法。虽然贪心算法不是对所有问题都可以得到整体最优解，但是对范围相当广的许多问题能够产生整体最优解，如最小生成树问题、图的单源最短路径问题等。在一些情况下，即使贪心算法不能得到整体最优解，但其最终结果却是最优解的很好的近似解。</p> 
<h6><a id="_5"></a>例：活动选择问题</h6> 
<p>题目描述：设有n个活动的集合E={1,2,…,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间si和一个结束时间fi,且si &lt;fi 。如果选择了活动i，则它在半开时间区间[si, fi)内占用资源。若区间[si, fi)与区间[sj, fj)不相交，则称活动i与活动j是相容的。也就是说，当si≥fj或sj≥fi时，活动i与活动j相容。</p> 
<p>活动安排问题： 要在所给的活动集合中选出最大的相容活动子集合。</p> 
<p>活动安排问题的关键是如何按照一定的顺序安排活动，使得选出的活动间相容并能安排尽量多的活动。</p> 
<p>题解：由于输入的活动以其完成时间的非减序排列，所以每次总是选择具有最早完成时间的相容活动加入集合A中。直观上，按这种方法选择相容活动为未安排活动留下尽可能多的时间。也就是说，贪心选择的意义是使剩余的可安排时间段极大化，以便安排尽可能多的相容活动。</p> 
<p>若被检查的活动i的开始时间Si小于最近选择的活动j的结束时间fi，则不选择活动i，否则选择活动i加入集合A中。</p> 
<p>贪心算法并不总能求得问题的整体最优解。但对于活动安排问题，贪心算法greedySelector却总能求得的整体最优解，即它最终所确定的相容活动集合A的规模最大。这个结论可以用数学归纳法证明。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
using namespace std<span class="token punctuation">;</span>
<span class="token comment">/*假设输入的活动结束时间按照增序排序。
若输入活动的结束时间未排序，可对活动进行排序然后进行选择。
*/</span>
 
<span class="token keyword">int</span> s<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span>，f<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span>；
bool a<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">Selector</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>true<span class="token punctuation">;</span>
    <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;=</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> 
		<span class="token punctuation">{<!-- --></span>   
			a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>true<span class="token punctuation">;</span>   
			j<span class="token operator">=</span>i<span class="token punctuation">;</span>     
			count<span class="token operator">++</span><span class="token punctuation">;</span>          
		<span class="token punctuation">}</span>
        <span class="token keyword">else</span> 
			a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>false<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout<span class="token operator">&lt;&lt;</span><span class="token string">"活动序号："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">11</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
		cout<span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span><span class="token string">"活动开始时间："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">11</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
		cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span><span class="token string">"活动结束时间："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">11</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
		cout<span class="token operator">&lt;&lt;</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> count<span class="token operator">=</span><span class="token function">Selector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span><span class="token string">"一共选择个"</span><span class="token operator">&lt;&lt;</span>count<span class="token operator">&lt;&lt;</span><span class="token string">"活动如下："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
			cout<span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_68"></a>贪心算法的基本要素</h4> 
<p>贪心算法通过一系列选择来得到问题的解，所做的每个选择都是当前状态下局部最好选择，即贪心选择。许多可以用贪心算法求解的问题中可以看到，它们一般具有两个重要的性质：<strong>贪心选择性质和最优子结构性质。</strong></p> 
<p><strong>1. 贪心选择性质</strong><br> 所谓贪心选择性质是指所求问题的<strong>整体最优解</strong>可以通过一系列<strong>局部最优的选择</strong>，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。<strong>在动态规划算法中，每步所做的选择往往依赖于相关子问题的解。因而只有在解出相关子问题后，才可以做出选择。而在贪心算法中，仅在当前状态下做出最好选择，即局部最优选择。</strong> 再去解做出这个选择后产生的相应的子问题。贪心算法所做的贪心选择可以依赖以往所做过的选择，但决不依赖将来所做的选择，也不依赖子问题的解。正是由于这种差别，<strong>动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行，以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。</strong></p> 
<p>对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。证明的大致过程为：<strong>首先考察问题的一个整体最优解，并证明可修改这个最优解，使其以贪心选择开始。做了贪心选择后，原问题简化为规模更小的类似子问题。然后用数学归纳法证明通过每一步做贪心选择，最终可得到问题的整体最优解。其中，证明贪心选择后的问题简化为规模更小的类似子问题的关键在于利用该问题的最优子结构性质。</strong></p> 
<p><strong>2. 最优子结构性质</strong><br> <strong>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。</strong> 问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。</p> 
<p><strong>3. 贪心算法和动态规划算法的差异</strong></p> 
<p><strong>共同点：</strong> 贪心算法和动态规划算法都要求问题具有最优子结构性质，这是这两类算法的一个共同点。<br> <strong>区别：</strong> 动态规划算法中，每步所做的选择往往依赖于相关子问题的解，因而只有在解出相关子问题时才能做出选择。而贪心算法，仅在当前状态下做出最好选择，即局部最优选择，然后再去解做出这个选择后产生的相应的子问题。</p> 
<p>贪心：每一步的最优解一定包含上一步的最优解，上一步之前的最优解则不作保留；</p> 
<p>动态规划：全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有的局部最优解 。</p> 
<blockquote> 
 <p>举例说明：也就是说，假如你要求第十步的最优解，那么第十步的最优解肯定与第九步的最优解有关，而第九步的最优解肯定与第八步的最优解有关。可以这么理解，贪心算法第十步的最优解得把前面九步的最优解都用上了，但是动态规划你需要求第十步的最优解，这个最优解可能只与第八步，第三步，第一步有关，与第九步没有关系，我们为什么选择第八步而不选择第九步呢？是因为我们在计算第十步的最优解的时候其实把1-9步的组合的情况都计算了，选择了其中最优的解，也就是第八步的解，其实第十步解的构成与第九步没有关系，动态规划相当于穷举了1-9步最优情况下的组合，选了其中最优的作为第十步的最优解，而贪心算法第十步的最优解肯定是由第九步构成的。</p> 
</blockquote> 
<p>求一个问题的最优解相当于遍历所有的子集来找最优解，但是这样解随着解空间的维度成指数增长，动态规划其实就是一种遍历，但是他是带备忘录的遍历，对于前面算到的子问题，仅就不在计算而是直接查看备忘录，直接调用之前保存的值，这样就节省了大量的时间。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c1a5a8d514af62f3e6af646e46372bb1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Oracle大作业】基于Java&#43;Oracle的研究生招生管理系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3efa4b3e1750a6c088a6f44e90205c90/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HashMap.computeIfAbsent与computeIfPresent</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>