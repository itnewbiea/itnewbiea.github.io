<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数字图像处理复习总结 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数字图像处理复习总结" />
<meta property="og:description" content="复习着感觉记不住，于是乎，有了这篇博文，如果也同样选修了数字图像处理课程的小伙伴们可以参考一哈！ 纯手码字…逢考必过！
概念 采样与量化
灰度变换缓慢的景物：粗采样、细量化有大量细节变化的图像：细采样、粗量化
采样不够出现马赛克；量化不够出现假轮廓 锐化：突出灰度的过渡部分（增强图像的细节边缘和轮廓，有利于图像的处理）
方法：微分法和高通滤波微分法包括梯度算子法和拉普拉斯算子法；高通滤波包含空域高通滤波和频域高通滤波 平滑：用于模糊处理和降低噪声
例：低通滤波、均值滤波、中值滤波（属于局部处理） 平滑和锐化
区别：图像锐化用于增强图像边缘，导致高频分量增强，会使图像清晰；图像平滑用于消除图像噪声，但也容易引起边缘的模糊
联系：都属于图像增强，改善图像效果
图像增强：通过某种技术有选择的突出对某一具体应用有用的信息，削弱或抑制一些无用的信息
基于图像的灰度直方图，根据所在空间不同，分为空域和频域两种常用的彩色增强有：真彩色增强技术、假彩色增强技术、伪彩色增强技术 一阶微分：用梯度算子来计算
特点：对于亮的边，边的变化起点是正的，结束是负的；对于暗的边，结论相反；常数部分为0用途：用于检测图像中边的存在
二阶微分：用拉普拉斯算子来计算
特点：二阶微分在亮的一边是负的，在暗的一边是正的。常数部分为0用途： 二次导数的符号，用于确定边上像素是亮的一边还是暗的一边。0跨越，确定边的准确位置 一阶微分算子和二阶微分算子在提取图像细节信息时有何不同？
一阶微分算子产生较粗的边缘，二阶微分算子处理对细节有较强的响应，如细线和孤立点。二阶微分有一个过度，即从正回到负。在一幅图像中，该现象表现为双线。
点处理：
例：二值化 灰度方差：说明图像对比度（方差小，对比度小；方差大，对比度大）
直方图均衡化：对在图像中像素的个数多的灰度级进行展宽，而对像素个数少的灰度级进行缩减，从而达到清晰图像的目的。
图像分割的结果图像为二值图像，所以通常又称为图像分割为图像的二值化处理
腐蚀是一种消除连通域边界点，使边界向内收缩的处理
膨胀是将与目标区域背景点合并到该目标物中，使目标物边界向外部扩张的处理
只存在噪声的复原——空间滤波 均值滤波器：
算术均值滤波器（最简单的均值滤波器）几何均值滤波器（几何均值滤波器比算术减少了对图像的模糊）谐波均值滤波器（对于&#34;盐&#34;噪声较好，但不适用于&#34;胡椒&#34;噪声；善于处理高斯噪声）逆谐波均值滤波器 统计排序滤波器：
中值滤波器（过度重复使用可能会对图像造成模糊）最大值和最小值滤波器（对于胡椒噪声（暗，值非常低），用最大值滤波器，发现图像中最亮点非常有用；对于盐粒噪声，用最小值滤波器，发现图像中最暗点非常有用）中点滤波器修正后的阿尔法均值滤波器 由于脉冲噪声(椒盐噪声)的存在，算术均值滤波器和几何均值滤波器没有起到良好作用；中值滤波器和阿尔法滤波器效果更好，阿尔法最好。
共点直线群的Hough变换是一条正弦曲线
边缘检测是将边缘像元识别出来的一种图像分割技术
细化：提取线宽为一个像元大小的中心线操作
图像复原的关键是建立退化模型，原图像f(x,y)是通过一个系统H及加入加性噪声n(x,y)而退化成一幅图像g(x,y)的， g ( x , y ) = H [ f ( x , y ) ] &#43; n ( x , y ) g ( x , y ) = H [ f ( x , y ) ] &#43; n ( x , y ) g(x,y)=H[f(x,y)]&#43;n(x,y)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c230d8c4f13f8887228e8980d0f004bf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-03T22:19:26+08:00" />
<meta property="article:modified_time" content="2019-01-03T22:19:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数字图像处理复习总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>复习着感觉记不住，于是乎，有了这篇博文，如果也同样选修了数字图像处理课程的小伙伴们可以参考一哈！ 纯手码字…逢考必过！</p> 
</blockquote> 
<h3><a id="_2"></a>概念</h3> 
<p><code>采样与量化</code></p> 
<ul><li>灰度变换缓慢的景物：粗采样、细量化</li><li>有大量细节变化的图像：细采样、粗量化<br> <code>采样不够出现马赛克；量化不够出现假轮廓</code></li></ul> 
<p><code>锐化</code>：突出灰度的过渡部分（增强图像的细节边缘和轮廓，有利于图像的处理）</p> 
<ul><li>方法：<code>微分法</code>和<code>高通滤波</code></li><li>微分法包括<code>梯度算子法</code>和<code>拉普拉斯算子法</code>；高通滤波包含<code>空域高通滤波</code>和<code>频域高通滤波</code></li></ul> 
<p><code>平滑</code>：用于模糊处理和降低噪声</p> 
<ul><li>例：低通滤波、均值滤波、中值滤波（属于局部处理）</li></ul> 
<blockquote> 
 <p><strong>平滑和锐化</strong><br> 区别：图像锐化用于增强图像边缘，导致高频分量增强，会使图像清晰；图像平滑用于消除图像噪声，但也容易引起边缘的模糊<br> 联系：都属于图像增强，改善图像效果</p> 
</blockquote> 
<p><code>图像增强</code>：通过某种技术有选择的突出对某一具体应用有用的信息，削弱或抑制一些无用的信息</p> 
<ul><li>基于图像的<code>灰度直方图</code>，根据所在空间不同，分为空域和频域两种</li><li>常用的彩色增强有：真彩色增强技术、假彩色增强技术、伪彩色增强技术</li></ul> 
<p><code>一阶微分：用梯度算子来计算</code></p> 
<ul><li>特点：对于亮的边，边的变化起点是正的，结束是负的；对于暗的边，结论相反；常数部分为0</li><li>用途：用于检测图像中边的存在<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/8a/0d/i3TwAFYL_o.png"></li></ul> 
<p><code>二阶微分：用拉普拉斯算子来计算</code></p> 
<ul><li>特点：二阶微分在亮的一边是负的，在暗的一边是正的。常数部分为0</li><li>用途： 
  <ul><li>二次导数的符号，用于确定边上像素是亮的一边还是暗的一边。</li><li>0跨越，确定边的准确位置</li></ul> </li></ul> 
<div align="center"> 
 <img width="60%" alt="" src="https://images2.imgbox.com/d7/04/fHNnIzfq_o.png"> 
</div> 
<p><strong>一阶微分算子和二阶微分算子在提取图像细节信息时有何不同？</strong><br> 一阶微分算子<code>产生较粗的边缘</code>，二阶微分算子处理<code>对细节有较强的响应</code>，如细线和孤立点。二阶微分有一个过度，即从正回到负。在一幅图像中，该现象表现为双线。</p> 
<p><code>点处理</code>：</p> 
<ul><li>例：二值化</li></ul> 
<p><code>灰度方差</code>：说明图像对比度（方差小，对比度小；方差大，对比度大）</p> 
<p><code>直方图均衡化</code>：对在图像中像素的个数多的灰度级进行展宽，而对像素个数少的灰度级进行缩减，从而达到清晰图像的目的。</p> 
<p><code>图像分割</code>的结果图像为<strong>二值图像</strong>，所以通常又称为<strong>图像分割</strong>为图像的<strong>二值化处理</strong></p> 
<p><code>腐蚀</code>是一种消除连通域边界点，使边界向内收缩的处理<br> <code>膨胀</code>是将与目标区域背景点合并到该目标物中，使目标物边界向外部扩张的处理</p> 
<h4><a id="_52"></a>只存在噪声的复原——空间滤波</h4> 
<p><strong>均值滤波器：</strong></p> 
<ul><li>算术均值滤波器（最简单的均值滤波器）</li><li>几何均值滤波器（几何均值滤波器比算术减少了对图像的模糊）</li><li>谐波均值滤波器（对于"盐"噪声较好，但不适用于"胡椒"噪声；善于处理高斯噪声）</li><li>逆谐波均值滤波器</li></ul> 
<p><strong>统计排序滤波器：</strong></p> 
<ul><li>中值滤波器（过度重复使用可能会对图像造成模糊）</li><li>最大值和最小值滤波器（对于胡椒噪声（暗，值非常低），用最大值滤波器，发现图像中最亮点非常有用；对于盐粒噪声，用最小值滤波器，发现图像中最暗点非常有用）</li><li>中点滤波器</li><li>修正后的阿尔法均值滤波器</li></ul> 
<p><code>由于脉冲噪声(椒盐噪声)的存在，算术均值滤波器和几何均值滤波器没有起到良好作用；中值滤波器和阿尔法滤波器效果更好，阿尔法最好。</code></p> 
<hr> 
<p><code>共点直线群</code>的<strong>Hough变换</strong>是一条正弦曲线</p> 
<p><code>边缘检测</code>是将边缘像元识别出来的一种图像分割技术<br> <code>细化</code>：提取线宽为一个像元大小的中心线操作</p> 
<p><code>图像复原</code>的关键是建立退化模型，原图像f(x,y)是通过一个系统H及加入加性噪声n(x,y)而退化成一幅图像g(x,y)的，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         g 
        
       
         ( 
        
       
         x 
        
       
         , 
        
       
         y 
        
       
         ) 
        
       
         = 
        
       
         H 
        
       
         [ 
        
       
         f 
        
       
         ( 
        
       
         x 
        
       
         , 
        
       
         y 
        
       
         ) 
        
       
         ] 
        
       
         + 
        
       
         n 
        
       
         ( 
        
       
         x 
        
       
         , 
        
       
         y 
        
       
         ) 
        
       
      
        g ( x , y ) = H [ f ( x , y ) ] + n ( x , y ) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.03em;">g</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16em;"></span><span class="mord mathit" style="margin-right: 0.03em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.27em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.27em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.08em;">H</span><span class="mopen">[</span><span class="mord mathit" style="margin-right: 0.1em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16em;"></span><span class="mord mathit" style="margin-right: 0.03em;">y</span><span class="mclose">)</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.22em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit">n</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16em;"></span><span class="mord mathit" style="margin-right: 0.03em;">y</span><span class="mclose">)</span></span></span></span></span></p> 
<div align="center"> 
 <img width="30%" src="https://images2.imgbox.com/60/e6/3QmXJyKH_o.png"> 
</div> 
<p><strong>几种噪声的运用</strong></p> 
<ul><li><code>高斯噪声</code>源于电子电路噪声和由低照明度或高温带来的传感器噪声</li><li><code>瑞利噪声</code>对分布在图像范围内特征化噪声有用</li><li><code>伽马分布和指数分布</code>用于激光成像噪声</li><li><code>均匀密度分布</code>作为模拟随机数产生器的基础</li><li><code>脉冲噪声</code>用于成像中的短暂停留中，如错误的开关</li></ul> 
<p><code>维纳滤波</code>（最小均方误差）通常用于复原图像，在对图像复原过程中要计算<code>噪声功率谱</code>和<code>图像功率谱</code></p> 
<p>彩色图像增强时，<code>加权均值滤波</code>处理可以采用RGB彩色模型</p> 
<p><code>马赫带效应</code>是指图像不同灰度级条带之间在灰度交界处存在<code>毛边现象</code></p> 
<p>采用<code>幂次变换</code>进行图像灰度变换时，若图像偏亮，那么幂次取大于1，使得处理后图像变暗；若图像偏暗，那么幂次取小于1，使得处理后图像变亮；</p> 
<p>高通滤波后的图像通常较暗，为改善这种情况，将高通滤波器的转移函数加上一常量以便引入一些低频分量。这样的滤波器叫做<code>高频提升滤波器</code></p> 
<p>边缘检测算子中，<code>抗噪性能最好</code>的是<code>Prewitt算子</code></p> 
<p><code>链码</code>：1）对于起点不一样导致结果不同，采用起点均一化，2）对于角度位置等不同导致的结果不一，采用差分（当前点值减去前一个值作为结果）</p> 
<div align="center"> 
 <img width="70%" src="https://images2.imgbox.com/0e/2e/YWolX0l3_o.png"> 
</div> 
<hr> 
<h3><a id="_106"></a>简答</h3> 
<p><strong>当白天进入一个黑暗剧场时，在能看清并找到空座位时需要一段时间的适应，试述发生这种现象的视觉原理？</strong><br> 人的视觉绝对不能同时在整个亮度适应范围工作，它是利用改变其亮度适应级来完成亮度适应的，即所谓的<code>亮度适应范围</code>。同整个亮度适应范围相比，能同时鉴别的光强度级的总范围很小。因此，白天进入黑暗剧场时，人的视觉系统需要改变亮度适应级，因此，需要一段时间，亮度适应级才能被改变。</p> 
<hr> 
<p><strong>图像锐化滤波的几种方法</strong><br> 1.直接以梯度值代替<br> 2.辅以门限判断<br> 3.给边缘规定一个特定的灰度级<br> 4.给背景规定灰度级<br> 5.根据梯度二值化图像</p> 
<hr> 
<p><strong>什么是马赫带效应，如何利用这一效应对图像处理？</strong><br> 原理：指图像不同灰度级条带之间在灰度交界处产生的<code>毛边现象</code>，使图像对比度加大，增加相邻灰度级的灰度差<br> 增加灰度级、灰度差，达到锐化效果</p> 
<hr> 
<p><strong>伪彩色增强和假彩色增强有何异同？</strong><br> 伪彩色增强是对一幅灰度图像经过三种变换得到三幅图像，进行彩色合成得到一幅彩色图像；<br> 假彩色增强则是对一幅彩色图像进行处理得到与原图像不同的彩色图像；</p> 
<ul><li>主要差异：处理对象不同</li><li>相同点：利用人眼对彩色的分辨能力高于灰度分辨能力的特点，将目标用人眼敏感的颜色表示</li></ul> 
<hr> 
<p><strong>什么是中值滤波，有何特点？</strong><br> 中值滤波是指将当前像元的窗口（或频域）中所有像元灰度由小到大排序，中间值作为当前像元的输出值<br> <code>特点</code>：是一种非线性的图像平滑法，它对脉冲干扰级椒盐噪声的抑制效果好，在抑制随机噪声的同时能有效保护边缘少受模糊</p> 
<p><strong>对于椒盐噪声，为什么中值滤波效果比均值滤波效果好？</strong><br> 椒盐噪声是复制近似相等但随机分布在不同的位置上，图像中有干净点也有污染点。中值滤波是选择适当的点来代替污染点的值，所以处理效果好。因为噪声的均值不为0，所以均值滤波不能很好地去除噪声</p> 
<hr> 
<p><strong>什么是直方图均衡化？</strong><br> 将原图像的直方图通过变换函数修正为均匀的直方图，然后按均衡直方图修正原图像。图像均衡化处理后，图像的直方图是平直的，即<code>各灰度级具有相同的出现频数</code>，那么由于灰度级具有均匀的概率分布，图像看起来就更清晰了</p> 
<hr> 
<p><strong>图像增强的目的是什么？</strong>（灰度变换、直方图修正、图像锐化、图像平滑）<br> 图像增强的目的是为了改善图像的视觉效果，针对给定图像的应用场合，<code>有目的地强调图像的整体或局部特性</code>，将原来不清晰的图像变得清晰或强调某些感兴趣的特征，扩大图像中不同物体特征之间的差别，<code>抑制不感兴趣的特征</code>，使之改善图像质量、丰富信息量，加强图像判读和识别效果，满足某些特殊分析的需要。<br> <strong>图像增强时，平滑和锐化具有哪些实现方法？</strong><br> 平滑：<code>领域平均法(均值滤波)</code>，<code>中值滤波</code>，<code>多图像平均法</code>，<code>频域低通滤波法</code><br> 锐化：<code>微分法</code>，<code>高通滤波法</code></p> 
<hr> 
<p><strong>简述梯度法与 Laplacian 算子检测边缘的异同点？</strong><br> 答：梯度算子和 Laplacian 检测边缘对应的模板分别为<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/ac/87/lt2yndW5_o.png"><br> <code>梯度算子</code>是利用阶跃边缘灰度变化的<code>一阶</code>导数特性，认为极大值点对应于边缘点；而 <code>Laplacian 算子</code>检测边缘是利用阶跃边缘灰度变化的<code>二阶</code>导数特性，认为边缘点是零交叉点。</p> 
<hr> 
<p><strong>简述基于边缘检测的<code>霍夫变换</code>的原理？</strong><br> 把直线上的点的坐标变换到过点的直线的系数域，通过利用共线和直线相交的关系，使直线的提取问题转化为计数问题</p> 
<hr> 
<h3><a id="_153"></a>计算题</h3> 
<p><strong>Sobel算子</strong><br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/92/46/wfI2U2zd_o.png"></p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/e3/04/SliG8vYm_o.png"><br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/4b/d9/m3Filz7x_o.png"></p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/dd/83/gPLdwiKc_o.png"></p> 
<p><strong>直方图均衡化（离散情况、连续情况），下面这题为离散情况的</strong></p> 
<div align="center"> 
 <img width="70%" src="https://images2.imgbox.com/d4/de/hwk4s5o8_o.png"> 
</div> 
<p><strong>下面这题为连续情况：</strong><br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/9f/3c/VfXSLvz9_o.png"></p> 
<hr> 
<p><strong>理想低通滤波器的截止频率选择不恰当时，会有很强的振铃效应。试从原理上解释振铃效应的产生原因。</strong></p> 
<p>答：理想低通滤波器（频域）的传递函数为：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         H 
        
       
         ( 
        
       
         u 
        
       
         , 
        
       
         v 
        
       
         ) 
        
       
         = 
        
        
        
          { 
         
         
          
           
            
            
              1 
             
            
           
           
            
             
             
               D 
              
             
               ( 
              
             
               u 
              
             
               , 
              
             
               v 
              
             
               ) 
              
             
               ≤ 
              
              
              
                D 
               
              
                0 
               
              
             
            
           
          
          
           
            
            
              0 
             
            
           
           
            
             
             
               D 
              
             
               ( 
              
             
               u 
              
             
               , 
              
             
               v 
              
             
               ) 
              
             
               &amp;gt; 
              
              
              
                D 
               
              
                0 
               
              
             
            
           
          
         
        
       
      
        H ( u , v ) = \left\{ \begin{array} { l l } { 1 } &amp;amp; { D ( u , v ) \leq D _ { 0 } } \\ { 0 } &amp;amp; { D ( u , v ) &amp;gt; D _ { 0 } } \end{array} \right. 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.08em;">H</span><span class="mopen">(</span><span class="mord mathit">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16em;"></span><span class="mord mathit" style="margin-right: 0.03em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.27em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.27em;"></span></span><span class="base"><span class="strut" style="height: 2.4em; vertical-align: -0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size3">{<!-- --></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span></span></span><span style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathit" style="margin-right: 0.02em;">D</span><span class="mopen">(</span><span class="mord mathit">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16em;"></span><span class="mord mathit" style="margin-right: 0.03em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.27em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.27em;"></span><span class="mord"><span class="mord mathit" style="margin-right: 0.02em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3em;"><span style="top: -2.55em; margin-right: 0.05em; margin-left: -0.02em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"></span></span></span></span></span></span></span></span><span style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathit" style="margin-right: 0.02em;">D</span><span class="mopen">(</span><span class="mord mathit">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16em;"></span><span class="mord mathit" style="margin-right: 0.03em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.27em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.27em;"></span><span class="mord"><span class="mord mathit" style="margin-right: 0.02em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3em;"><span style="top: -2.55em; margin-right: 0.05em; margin-left: -0.02em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p> 
<p>滤波器半径交叉部分（侧面图）：</p> 
<div align="center"> 
 <img src="https://images2.imgbox.com/e2/e9/LoUyykwX_o.png"> 
</div> 
<p>对应空间域（进行傅立叶反变换，为sinc函数）：</p> 
<div align="center"> 
 <img src="https://images2.imgbox.com/83/8b/vHHl6yrF_o.png"> 
</div> 
<p>用理想低通滤波器滤波时，频域：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         G 
        
       
         ( 
        
       
         u 
        
       
         , 
        
       
         v 
        
       
         ) 
        
       
         = 
        
       
         F 
        
       
         ( 
        
       
         u 
        
       
         , 
        
       
         v 
        
       
         ) 
        
       
         H 
        
       
         ( 
        
       
         u 
        
       
         , 
        
       
         v 
        
       
         ) 
        
       
      
        G ( u , v ) = F ( u , v ) H ( u , v ) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit">G</span><span class="mopen">(</span><span class="mord mathit">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16em;"></span><span class="mord mathit" style="margin-right: 0.03em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.27em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.27em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.13em;">F</span><span class="mopen">(</span><span class="mord mathit">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16em;"></span><span class="mord mathit" style="margin-right: 0.03em;">v</span><span class="mclose">)</span><span class="mord mathit" style="margin-right: 0.08em;">H</span><span class="mopen">(</span><span class="mord mathit">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16em;"></span><span class="mord mathit" style="margin-right: 0.03em;">v</span><span class="mclose">)</span></span></span></span></span></p> 
<p>傅立叶反变换到时域有：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         g 
        
       
         ( 
        
       
         x 
        
       
         , 
        
       
         y 
        
       
         ) 
        
       
         = 
        
       
         f 
        
       
         ( 
        
       
         x 
        
       
         , 
        
       
         y 
        
       
         ) 
        
       
         ∗ 
        
       
         h 
        
       
         ( 
        
       
         x 
        
       
         , 
        
       
         y 
        
       
         ) 
        
       
      
        g ( x , y ) = f ( x , y ) * h ( x , y ) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.03em;">g</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16em;"></span><span class="mord mathit" style="margin-right: 0.03em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.27em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.27em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.1em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16em;"></span><span class="mord mathit" style="margin-right: 0.03em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.22em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit">h</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16em;"></span><span class="mord mathit" style="margin-right: 0.03em;">y</span><span class="mclose">)</span></span></span></span></span></p> 
<p><code>频域相乘相当于时域作卷积</code>。因此，图像经过理想低通滤波器后，<code>时域上相当于原始图像与sinc函数卷积</code>，由于sinc函数振荡，则卷积后图像也会振荡；或者说由于sinc函数有两个负边带，卷积后图像信号两侧出现<code>“过冲现象”</code>，而且能量不集中，即产生<code>振铃效应</code>。若截止频率越低，即D0越小，则sinc函数主瓣越大，表现为中心环越宽，相应周围环（旁瓣）越大。而中心环主要决定模糊，旁瓣主要决定<code>振铃效应</code>。因此当截止频率较低时，会产生很强的振铃效应。选择适当的截止频率，会减小振铃效应</p> 
<p><code>PS:这里的时域也就是空间域</code></p> 
<hr> 
<p><strong>逆滤波时，为什么在图像存在噪声时，不能采用全滤波？试采用逆滤波原理说明，并给出正确的处理方法。</strong></p> 
<p>复原由退化函数退化的图像最直接的方法是直接逆滤波，在该方法中，用退化函数除退化图像的傅里叶变换来计算原始图像的傅里叶变换。</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          F 
         
        
          ^ 
         
        
       
         ( 
        
       
         u 
        
       
         , 
        
       
         v 
        
       
         ) 
        
       
         = 
        
        
         
         
           G 
          
         
           ( 
          
         
           u 
          
         
           , 
          
         
           v 
          
         
           ) 
          
         
         
         
           H 
          
         
           ( 
          
         
           u 
          
         
           , 
          
         
           v 
          
         
           ) 
          
         
        
       
         = 
        
       
         F 
        
       
         ( 
        
       
         u 
        
       
         , 
        
       
         v 
        
       
         ) 
        
       
         + 
        
        
         
         
           N 
          
         
           ( 
          
         
           u 
          
         
           , 
          
         
           v 
          
         
           ) 
          
         
         
         
           H 
          
         
           ( 
          
         
           u 
          
         
           , 
          
         
           v 
          
         
           ) 
          
         
        
       
      
        \hat { F } ( u , v ) = \frac { G ( u , v ) } { H ( u , v ) }= F(u,v) + \frac { N(u,v) } { H(u,v)} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.19em; vertical-align: -0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.94em;"><span style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathit" style="margin-right: 0.13em;">F</span></span></span><span style="top: -3.25em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.16em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16em;"></span><span class="mord mathit" style="margin-right: 0.03em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.27em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.27em;"></span></span><span class="base"><span class="strut" style="height: 1.53em; vertical-align: -0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.01em;"><span style="top: -2.65em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.08em;">H</span><span class="mopen mtight">(</span><span class="mord mathit mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathit mtight" style="margin-right: 0.03em;">v</span><span class="mclose mtight">)</span></span></span></span><span style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span style="top: -3.48em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">G</span><span class="mopen mtight">(</span><span class="mord mathit mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathit mtight" style="margin-right: 0.03em;">v</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.52em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.27em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.27em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.13em;">F</span><span class="mopen">(</span><span class="mord mathit">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16em;"></span><span class="mord mathit" style="margin-right: 0.03em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.22em;"></span></span><span class="base"><span class="strut" style="height: 1.53em; vertical-align: -0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.01em;"><span style="top: -2.65em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.08em;">H</span><span class="mopen mtight">(</span><span class="mord mathit mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathit mtight" style="margin-right: 0.03em;">v</span><span class="mclose mtight">)</span></span></span></span><span style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span style="top: -3.48em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.1em;">N</span><span class="mopen mtight">(</span><span class="mord mathit mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathit mtight" style="margin-right: 0.03em;">v</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.52em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p> 
<p>上式说明即使知道退化函数，也不能准确地复原未退化的图像。因为噪声是一个随机函数，其傅氏变换未知。并且，实际应用逆滤波复原方法时存在病态的问题，即如果退化为零或非常小的值，则N(u,v)/H(u,v)之比很容易决定复原函数的值。</p> 
<p>实验证明，当退化图像的噪声较小，即轻度降质时，采用逆滤波复原的方法可以获得较好的结果。通常，在离频率平面原点较远的地方数值较小或为零，因此图象复原在原点周围的有限区域内进行，即将退化图象的傅立叶谱限制在没出现零点而且数值又不是太小的有限范围内。</p> 
<p>也就是说，解决退化函数为零或为非常小的值的问题的一种方法是，限制滤波的频率，使其接近原点。</p> 
<p><code>逢考必过！锦鲤附体！逢考必过！锦鲤附体！逢考必过！锦鲤附体！ 重要的事情说三遍！</code></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4bb2b30ebdeed228110acb9e6cd9b688/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">二维坐标系中的向量旋转公式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4e4f79544f02f37bdfd7e5284b431338/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js的replace()方法的用法，以及replace替换含有 &#39;$1&#39;的string字符串的解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>