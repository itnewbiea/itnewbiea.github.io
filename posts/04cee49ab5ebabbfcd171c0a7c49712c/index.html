<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【玩转RT-Thread】 RT-Thread Studio使用（2） 内核实战篇（线程） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【玩转RT-Thread】 RT-Thread Studio使用（2） 内核实战篇（线程）" />
<meta property="og:description" content="详细原理参考：【玩转RT-Thread】线程管理（详细原理）
文章目录 一、线程创建1、函数原型2、线程定义3、线程创建判断4、线程入口函数5、总结6、补充 二、线程启动三、初始化线程1、函数声明2、函数定义3、线程入口函数4、判断创建状态5、实验结果 一、线程创建 1、函数原型 // 线程创建 rt_thread_t rt_thread_create(const char* name, void (*entry)(void* parameter), void* parameter, rt_uint32_t stack_size, rt_uint8_t priority, rt_uint32_t tick); 首先我们来看看线程创建函数返回值类型：
可以看到线程创建函数的返回值类型为：rt_thread_t，找到定义处（如下图），可以看到它的返回值类型是一个结构体指针变量。
2、线程定义 那么我们先定义一个结构体指针的线程th1_ptr，这样通过rt_thread_create函数创建的进程控制块的地址就能直接赋值给th1_ptr变量：
rt_thread_t th1_ptr = NULL 接下来就是我们给进程控制块传参了
3、线程创建判断 由于线程创建有返回值，所以我们此处再加入一个判断函数去判断线程是否创建成功
我们先来看下线程返回值（如下图）
如果成功创建的话，返回值是会返回我们所创建的线程对象的
如果创建失败的话，可以看到是会返回一个RT_NULL，也就是0
// 判断	if(th1_ptr == RT_NULL) { //错误信息打印 LOG_E(&#34;rt_thread_create create failed...\n&#34;); return -RT_ENOMEM; // 设定当线程th1_ptr创建失败后，返回一个空间不足的标志 } //打印debug调试信息 LOG_D(&#34;rt_thread_create create successed ...\n&#34;); 4、线程入口函数 我们在线程的入口处理函数写一个循环函数：
void th_entry(void* parameter) { while(1) { rt_kprintf(&#34;th_entry running ...\n&#34;); rt_thread_mdelay(1000); } } 注意：我们在使用线程的处理函数的循环函数的时候，一定要记得及时释放资源，也就是出让CPU资源，不然这个线程会一直执行并占用系统资源" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/04cee49ab5ebabbfcd171c0a7c49712c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-02T17:58:24+08:00" />
<meta property="article:modified_time" content="2022-05-02T17:58:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【玩转RT-Thread】 RT-Thread Studio使用（2） 内核实战篇（线程）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>详细原理参考：<a href="https://blog.csdn.net/qq_56914146/article/details/124141250">【玩转RT-Thread】线程管理（详细原理）</a></p> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_4" rel="nofollow">一、线程创建</a></li><li><ul><li><ul><li><a href="#1_6" rel="nofollow">1、函数原型</a></li><li><a href="#2_28" rel="nofollow">2、线程定义</a></li><li><a href="#3_44" rel="nofollow">3、线程创建判断</a></li><li><a href="#4_76" rel="nofollow">4、线程入口函数</a></li><li><a href="#5_110" rel="nofollow">5、总结</a></li><li><a href="#6_120" rel="nofollow">6、补充</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_130" rel="nofollow">二、线程启动</a></li><li><a href="#_147" rel="nofollow">三、初始化线程</a></li><li><ul><li><ul><li><a href="#1_150" rel="nofollow">1、函数声明</a></li><li><a href="#2_161" rel="nofollow">2、函数定义</a></li><li><a href="#3_175" rel="nofollow">3、线程入口函数</a></li><li><a href="#4_190" rel="nofollow">4、判断创建状态</a></li><li><a href="#5_207" rel="nofollow">5、实验结果</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_4"></a>一、线程创建</h3> 
<h5><a id="1_6"></a>1、函数原型</h5> 
<pre><code class="prism language-c"><span class="token comment">// 线程创建</span>
<span class="token class-name">rt_thread_t</span> <span class="token function">rt_thread_create</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span>
							 <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>entry<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> parameter<span class="token punctuation">)</span><span class="token punctuation">,</span>
							 <span class="token keyword">void</span><span class="token operator">*</span> parameter<span class="token punctuation">,</span>
							 <span class="token class-name">rt_uint32_t</span> stack_size<span class="token punctuation">,</span>
							 <span class="token class-name">rt_uint8_t</span> priority<span class="token punctuation">,</span>
							 <span class="token class-name">rt_uint32_t</span> tick<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>首先我们来看看线程创建函数返回值类型：</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/ae/c9/rcsaCmps_o.png" alt=""></p> 
<blockquote> 
 <p>可以看到线程创建函数的返回值类型为：<code>rt_thread_t</code>，找到定义处（如下图），可以看到它的返回值类型是一个结构体指针变量。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/e0/bd/2aY89dbw_o.png" alt=""></p> 
<h5><a id="2_28"></a>2、线程定义</h5> 
<p>那么我们先定义一个结构体指针的线程th1_ptr，这样通过rt_thread_create函数创建的进程控制块的地址就能直接赋值给th1_ptr变量：</p> 
<pre><code class="prism language-c"><span class="token class-name">rt_thread_t</span> th1_ptr <span class="token operator">=</span> <span class="token constant">NULL</span>
</code></pre> 
<blockquote> 
 <p>接下来就是我们给进程控制块传参了</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/b0/60/9ytXH6qg_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/cc/ea/ZWeZM17f_o.png" alt=""></p> 
<h5><a id="3_44"></a>3、线程创建判断</h5> 
<p>由于线程创建有返回值，所以我们此处再加入一个判断函数去判断线程是否创建成功</p> 
<p>我们先来看下线程返回值（如下图）</p> 
<blockquote> 
 <p>如果<code>成功创建</code>的话，返回值是会返回我们所创建的线程对象的</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/a7/49/cArN3WZD_o.png" alt=""></p> 
<blockquote> 
 <p>如果创建失败的话，可以看到是会返回一个RT_NULL，也就是0</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/12/b2/kJ1tVyzN_o.png" alt=""></p> 
<pre><code class="prism language-c"><span class="token comment">// 判断	</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>th1_ptr <span class="token operator">==</span> RT_NULL<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//错误信息打印</span>
        <span class="token function">LOG_E</span><span class="token punctuation">(</span><span class="token string">"rt_thread_create create failed...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token keyword">return</span> <span class="token operator">-</span>RT_ENOMEM<span class="token punctuation">;</span> <span class="token comment">// 设定当线程th1_ptr创建失败后，返回一个空间不足的标志</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">//打印debug调试信息</span>
    <span class="token function">LOG_D</span><span class="token punctuation">(</span><span class="token string">"rt_thread_create create successed ...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="4_76"></a>4、线程入口函数</h5> 
<p>我们在线程的入口处理函数写一个循环函数：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">th_entry</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> parameter<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">rt_kprintf</span><span class="token punctuation">(</span><span class="token string">"th_entry running ...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">rt_thread_mdelay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>注意：我们在使用线程的处理函数的循环函数的时候，一定要记得及时释放资源，也就是出让CPU资源，不然这个线程会一直执行并占用系统资源</code></p> 
<ul><li>编译，串口观察</li></ul> 
<p><img src="https://images2.imgbox.com/ad/52/jRPW0F6R_o.png" alt=""></p> 
<p>由于RTT studio有内置的串口终端，我们直接打开</p> 
<p><img src="https://images2.imgbox.com/90/55/B1RStEWO_o.png" alt=""></p> 
<p>终端输入list_thread可以查看所有的线程</p> 
<p><img src="https://images2.imgbox.com/c3/f8/yoaH5fqI_o.png" alt=""></p> 
<h5><a id="5_110"></a>5、总结</h5> 
<p>这里也许就有疑问了，为什么线程入口函数的打印命令没有被执行？</p> 
<p>其实我们再看th_demo线程的状态可以看到是<code>init</code>，参考<a href="https://blog.csdn.net/qq_56914146/article/details/124141250">【玩转RT-Thread】线程管理（详细原理）</a></p> 
<p><code>当线程刚开始创建还没开始运行时就处于初始状态；在初始状态下，线程不参与调度。此状态在RT-Thread 中的宏定义为RT_THREAD_INIT</code></p> 
<p>其实这句话就表明当<code>线程处于初始化状态下是不参与系统调度</code>的！</p> 
<h5><a id="6_120"></a>6、补充</h5> 
<p>线程错误码：</p> 
<p><img src="https://images2.imgbox.com/21/5d/1z43Y6rl_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="_130"></a>二、线程启动</h3> 
<p>函数原型</p> 
<p>在主函数中加入命令，使线程进入就绪态：</p> 
<pre><code>rt_thread_startup(th1_ptr); 
</code></pre> 
<p>但是我们此时打开终端可以发现：线程入口函数虽然被执行，但线程状态为<code>挂起态</code></p> 
<p><img src="https://images2.imgbox.com/7b/a7/LFj7wBuI_o.png" alt=""></p> 
<p><code>解释:</code>虽然我们调用<code>rt_thread_startup</code>函数使线程进入就绪态，但是回到入口函数我们可以看到，我们调用了<code>rt_thread_mdelay</code>函数使其有一定时间的休眠，从而进入了挂起态`</p> 
<h3><a id="_147"></a>三、初始化线程</h3> 
<p><code>rt_thread_init</code></p> 
<h5><a id="1_150"></a>1、函数声明</h5> 
<pre><code class="prism language-c"><span class="token comment">// 模板函数</span>
<span class="token class-name">rt_err_t</span> <span class="token function">rt_thread_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rt_thread</span><span class="token operator">*</span> thread<span class="token punctuation">,</span>
					    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span>
						<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>entry<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> parameter<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> parameter<span class="token punctuation">,</span>
						<span class="token keyword">void</span><span class="token operator">*</span> stack_start<span class="token punctuation">,</span> <span class="token class-name">rt_uint32_t</span> stack_size<span class="token punctuation">,</span>
						<span class="token class-name">rt_uint8_t</span> priority<span class="token punctuation">,</span> <span class="token class-name">rt_uint32_t</span> tick<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="2_161"></a>2、函数定义</h5> 
<pre><code class="prism language-c">ret <span class="token operator">=</span> <span class="token function">rt_thread_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>th2<span class="token punctuation">,</span><span class="token string">"th2_demo"</span><span class="token punctuation">,</span> th2_entry<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> th2_stack<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>th2_stack<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>此处我们需要定义一个ret整型变量用于<code>rt_thread_init</code>的返回值传参，然后定义一个线程结构体，用于静态线程传参。同时需要为线程栈分配内存，所以我们创建一个栈数组，注意这里的线程栈大小我们设定512，而线程的优先级设为19，比线程th1_demo要高一个优先级，后续观察现象。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/ce/f6/QqeoIbXV_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/20/01/t9mKAfrW_o.png" alt=""></p> 
<h5><a id="3_175"></a>3、线程入口函数</h5> 
<p>代码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">th2_entry</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> parameter<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">rt_kprintf</span><span class="token punctuation">(</span><span class="token string">"th2_entry running ...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">rt_thread_mdelay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="4_190"></a>4、判断创建状态</h5> 
<p>静态线程创建成功的话会返回0，失败的话会返回一个负值，若成功创建线程，我们调用<code>rt_thread_startup</code>函数使线程2进入就绪态，并执行线程处理函数。</p> 
<pre><code>if(ret &lt; 0)
    {
        LOG_E("rt2_thread_create create failed ...\n"); // 错误信息打印
        return ret;
    }
    
    LOG_D("rt_thread2_create create successes ...\n"); 
    rt_thread_startup(&amp;th2); // 创建成功后，我们开启线程，使其进入就绪态
</code></pre> 
<blockquote> 
 <p>这里注意：由于我们线程2定义是一个数组，所以需要取地址进行线程开启</p> 
</blockquote> 
<h5><a id="5_207"></a>5、实验结果</h5> 
<blockquote> 
 <p>分析：首先我们把线程1和线程2的启动函数都开启，可以看到线程1和线程2都处于挂起态，线程2的命令先于线程1执行，这是由于前面我们设定优先级给线程2（优先级19）比线程1（优先级20）高，所以在命令执行是先线程2，再线程1。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/f3/cd/9ipGx0vU_o.png" alt=""></p> 
<blockquote> 
 <p>线程2在执行完10次循环后就结束进程了，此时在终端再次输入list_thread可以发现线程2已经退出，只剩下线程1还在循环执行</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/dc/da/3y816BVL_o.png" alt=""></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5848c0d936975b18f530fd400101db3c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">第四单元 用python学习微积分（二十八）参数方程、弧长和表面积</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d623b7f7e9347d2c13d938202f8769fa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">(zichao)我的Spring5学习笔记（仅作简单整理，未深入探究）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>