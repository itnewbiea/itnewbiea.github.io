<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>关于RGB888和RGB565互转代码实现方案推荐 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="关于RGB888和RGB565互转代码实现方案推荐" />
<meta property="og:description" content="1、为什么RGB888要转RGB565呢，这个问题尤其在嵌入式lcd屏中，因为RGB888占用24位，RGB565占用16位及2个字节。
2、例如嵌入式中的LCD屏接口一般位IIC、SPI、8080等，如果传送RGB888每个像素点就要多送一个字节，320*240的LCD屏就要多送76800字节的数据。
3、我看到的一般驱动代码中均是将RGB888进行相与移位等操作得到R，G、B类似操作。速度慢代码不精简。如何优化呢，这里我就开门见山了，使用结构体就能很好解决RGB888和RGB565互转。单使用结构体还不够好，就把结构体和共用体结合了。
4、以下是测试部分，使用原始方案RGB888转RGB565，及原始方案RGB565转RGB888，及新的方案。不难发现新方案测试结果和旧方案一样。
5、最后贴出具体代码，当前使用的是小端模式，切记51单片机一般位大端模式。
//作者：金丝草 //时间：2022/09/24 #include &lt;iostream&gt; //这里重申下，以下为小端模式 /***********************************RGB888 RGB565*************************************/ typedef union { uint32_t RGB888; struct { uint32_t dummy0:3; uint32_t RGB_B :5; uint32_t dummy1:2; uint32_t RGB_G :6; uint32_t dummy2:3; uint32_t RGB_R :5; uint32_t dummy3:8; }Work; }RGB888_struct; typedef union { uint16_t RGB565; struct { uint16_t RGB_B :5; uint16_t RGB_G :6; uint16_t RGB_R :5; }Work; }RGB565_struct; //输入一个RGB888的32位数据地址，返回转换后的RGB565 static uint16_t RGB888_To_RGB565(const RGB888_struct *RGB888) { RGB565_struct RGB565 = { 0 }; RGB565." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2cdcc5e7b0655297c419fe913a9430f3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-24T10:43:17+08:00" />
<meta property="article:modified_time" content="2022-09-24T10:43:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">关于RGB888和RGB565互转代码实现方案推荐</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1、为什么RGB888要转RGB565呢，这个问题尤其在嵌入式lcd屏中，因为RGB888占用24位，RGB565占用16位及2个字节。</p> 
<p>2、例如嵌入式中的LCD屏接口一般位IIC、SPI、8080等，如果传送RGB888每个像素点就要多送一个字节，320*240的LCD屏就要多送76800字节的数据。</p> 
<p>3、我看到的一般驱动代码中均是将RGB888进行相与移位等操作得到R，G、B类似操作。速度慢代码不精简。如何优化呢，这里我就开门见山了，使用结构体就能很好解决RGB888和RGB565互转。单使用结构体还不够好，就把结构体和共用体结合了。</p> 
<p>4、以下是测试部分，使用原始方案RGB888转RGB565，及原始方案RGB565转RGB888，及新的方案。不难发现新方案测试结果和旧方案一样。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f9/c0/SWVjSj3T_o.png"></p> 
<p> 5、最后贴出具体代码，当前使用的是小端模式，切记51单片机一般位大端模式。</p> 
<pre><code class="language-cpp">//作者：金丝草
//时间：2022/09/24

#include &lt;iostream&gt;

//这里重申下，以下为小端模式

/***********************************RGB888 RGB565*************************************/
typedef union
{
	uint32_t RGB888;
	struct
	{
		uint32_t dummy0:3;
		uint32_t RGB_B :5;
		uint32_t dummy1:2;
		uint32_t RGB_G :6;
		uint32_t dummy2:3;
		uint32_t RGB_R :5;
		uint32_t dummy3:8;
	}Work;
}RGB888_struct;
typedef union
{
	uint16_t RGB565;
	struct
	{
		uint16_t RGB_B :5;
		uint16_t RGB_G :6;
		uint16_t RGB_R :5;
	}Work;
}RGB565_struct;

//输入一个RGB888的32位数据地址，返回转换后的RGB565
static uint16_t RGB888_To_RGB565(const RGB888_struct *RGB888)
{
	RGB565_struct RGB565 = { 0 };
	
	RGB565.Work.RGB_R = RGB888-&gt;Work.RGB_R;
	RGB565.Work.RGB_G = RGB888-&gt;Work.RGB_G;
	RGB565.Work.RGB_B = RGB888-&gt;Work.RGB_B;
	return RGB565.RGB565;
}
//输入一个RG565的16位数据地址，返回转换后的RGB888
static uint32_t RGB565_To_RGB888(const RGB565_struct *RGB565)
{
	RGB888_struct RGB888 = { 0 };

	RGB888.Work.RGB_R = RGB565-&gt;Work.RGB_R;
	RGB888.Work.RGB_G = RGB565-&gt;Work.RGB_G;
	RGB888.Work.RGB_B = RGB565-&gt;Work.RGB_B;
	return RGB888.RGB888;
}
/***********************************RGB888 RGB565*************************************/



static void test_RGB888_To_RGB565(void)
{
	uint32_t color888 = 0;
	uint32_t i;

	for (i = 1; i &lt;= 50; i++)
	{
		printf("RGB888-&gt;RGB565 =%5d  ", RGB888_To_RGB565((RGB888_struct*)&amp;color888));
		color888 += 100;
		if ((i % 5) == 0)
			printf("\r\n");
	}
	printf("\r\n");
}
static void test_RGB565_To_RGB888(void)
{
	uint16_t color565 = 0;
	uint32_t i;

	for (i = 1; i &lt;= 50; i++)
	{
		printf("RGB565-&gt;RGB888 =%7d  ", RGB565_To_RGB888((RGB565_struct*)&amp;color565));
		color565 += 100;
		if((i%5) == 0)
			printf("\r\n");
	}
	printf("\r\n");
}


int main()
{
	uint32_t test_data = 0;
	uint32_t i;
	uint32_t color888 = 0;
	uint16_t color565 = 0;

	uint8_t R = 0;
	uint8_t G = 0;
	uint8_t B = 0;


	for (i = 1; i &lt;= 50; i++)//原始方案计算伤脑子
	{
		R = (color888 &amp; 0xff0000) &gt;&gt; (16 + 3);
		G = (color888 &amp; 0x00ff00) &gt;&gt; (8 + 2);
		B = (color888 &amp; 0x0000ff) &gt;&gt; 3;
		test_data = (R &lt;&lt; (5 + 6)) | (G &lt;&lt; 5) | B;
		printf("test__888-&gt;565 =%5d  ", test_data);
		color888 += 100;
		if ((i % 5) == 0)
			printf("\r\n");
	}
	printf("\r\n");
	test_RGB888_To_RGB565();//新方案速度更快还不伤脑子

	for (i = 1; i &lt;= 50; i++)//原始方案计算伤脑子
	{
		R = (color565 &amp; 0xf800) &gt;&gt; (5 + 6);
		G = (color565 &amp; 0x07e0) &gt;&gt; 5;
		B = (color565 &amp; 0x001f) &gt;&gt; 0;
		test_data = (R &lt;&lt; (16 + 3)) | (G &lt;&lt; 8 + 2) | (B &lt;&lt; 3);
		printf("test__565-&gt;888 =%7d  ", test_data);
		color565 += 100;
		if ((i % 5) == 0)
			printf("\r\n");
	}
	printf("\r\n");
	test_RGB565_To_RGB888();//新方案速度更快还不伤脑子



    std::cout &lt;&lt; "Hello World!\n";
}

</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/38b8b21415c87a162acecd1dd4f510ac/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue表单中输入框事件的使用@input、@keyup.enter、@change、@blur</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1c5fbe795400b08bb1cb63036881d9c3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">win11 解决Android Virtual Device Manager HAXM is not installed 报错问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>