<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【面试高频算法解析】算法练习3 双指针 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【面试高频算法解析】算法练习3 双指针" />
<meta property="og:description" content="前言 本专栏旨在通过分类学习算法，使您能够牢固掌握不同算法的理论要点。通过策略性地练习精选的经典题目，帮助您深度理解每种算法，避免出现刷了很多算法题，还是一知半解的状态
专栏导航 二分查找回溯双指针滑动窗口深度优先搜索广度优先搜索 算法解析 双指针技术是一种常用的算法策略，它使用两个指针以不同的速度或方向遍历数据结构（通常是线性结构如数组或链表），从而达到解决问题的目的。双指针技术可以帮助我们简化复杂度，减少不必要的运算，尤其是在解决一些与序列相关的问题时非常有效。
双指针通常有以下几种分类：
快慢指针：
快慢指针通常用于解决链表中的问题，例如检测链表中的循环。快指针每次移动两步，慢指针每次移动一步。如果链表中有循环，则快指针最终会追上慢指针。
左右指针：
左右指针通常用于有序数组或字符串，开始时一个指向头部（左指针），另一个指向尾部（右指针），然后向中间移动。例如在二分查找、合并两个有序数组或是计算一组数的对数（如两数之和）时会用到。
滑动窗口(面试中很常见我将另开一篇详细介绍)：
滑动窗口可以看作是一种特殊的双指针，通常用于解决数组/字符串的子区间问题。两个指针共同定义了一个窗口，可以增加或减少窗口的大小以满足特定条件，例如找出满足条件的最长/最短的子数组/子字符串。
双指针技术的优势在于它可以减少时间复杂度。例如，在排序数组中寻找两数之和等于特定值的问题中，暴力解法需要 O(n^2) 的时间复杂度，而使用双指针技术则可以降低到 O(n)。
下面是一个使用双指针（左右指针）解决“两数之和”问题的示例：
def two_sum_sorted(numbers, target): left, right = 0, len(numbers) - 1 while left &lt; right: current_sum = numbers[left] &#43; numbers[right] if current_sum == target: return [left &#43; 1, right &#43; 1] # 返回的是位置，不是索引 elif current_sum &lt; target: left &#43;= 1 # 和太小，移动左指针 else: right -= 1 # 和太大，移动右指针 return [-1, -1] # 如果没有找到，返回[-1, -1] 在这个函数中，左指针从数组的开始位置向右移动，右指针从数组的结束位置向左移动，直到找到两数之和等于目标值或左右指针相遇。通过这种方式，我们只需要遍历数组一次，从而提高了算法的效率。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/097089dc4ed9d3bf88b8a7658cc44cca/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-04T15:05:16+08:00" />
<meta property="article:modified_time" content="2024-01-04T15:05:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【面试高频算法解析】算法练习3 双指针</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>前言</h2> 
<p>本专栏旨在通过分类学习算法，使您能够牢固掌握不同算法的理论要点。通过策略性地练习精选的经典题目，帮助您深度理解每种算法，避免出现刷了很多算法题，还是一知半解的状态</p> 
<hr> 
<h2><a id="_4"></a>专栏导航</h2> 
<ol><li><a href="https://blog.csdn.net/sinat_41883985/article/details/135339552"><strong>二分查找</strong></a></li><li><a href="https://blog.csdn.net/sinat_41883985/article/details/135346447"><strong>回溯</strong></a></li><li><a href="https://blog.csdn.net/sinat_41883985/article/details/135346712"><strong>双指针</strong></a></li><li><a href="https://blog.csdn.net/sinat_41883985/article/details/135346682"><strong>滑动窗口</strong></a></li><li><strong>深度优先搜索</strong></li><li><strong>广度优先搜索</strong></li></ol> 
<hr> 
<h2><a id="_13"></a>算法解析</h2> 
<p>双指针技术是一种常用的算法策略，它使用两个指针以不同的速度或方向遍历数据结构（通常是线性结构如数组或链表），从而达到解决问题的目的。双指针技术可以帮助我们简化复杂度，减少不必要的运算，尤其是在解决一些与序列相关的问题时非常有效。</p> 
<p>双指针通常有以下几种分类：</p> 
<ol><li> <p><strong>快慢指针</strong>：<br> 快慢指针通常用于解决链表中的问题，例如检测链表中的循环。快指针每次移动两步，慢指针每次移动一步。如果链表中有循环，则快指针最终会追上慢指针。</p> </li><li> <p><strong>左右指针</strong>：<br> 左右指针通常用于有序数组或字符串，开始时一个指向头部（左指针），另一个指向尾部（右指针），然后向中间移动。例如在二分查找、合并两个有序数组或是计算一组数的对数（如两数之和）时会用到。</p> </li><li> <p><strong><a href="https://blog.csdn.net/sinat_41883985/article/details/135346682">滑动窗口(面试中很常见我将另开一篇详细介绍)</a></strong>：<br> 滑动窗口可以看作是一种特殊的双指针，通常用于解决数组/字符串的子区间问题。两个指针共同定义了一个窗口，可以增加或减少窗口的大小以满足特定条件，例如找出满足条件的最长/最短的子数组/子字符串。</p> </li></ol> 
<p>双指针技术的优势在于它可以减少时间复杂度。例如，在排序数组中寻找两数之和等于特定值的问题中，暴力解法需要 O(n^2) 的时间复杂度，而使用双指针技术则可以降低到 O(n)。</p> 
<p>下面是一个使用双指针（左右指针）解决“两数之和”问题的示例：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">two_sum_sorted</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>
    left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>
        current_sum <span class="token operator">=</span> numbers<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>right<span class="token punctuation">]</span>
        <span class="token keyword">if</span> current_sum <span class="token operator">==</span> target<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span>left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment"># 返回的是位置，不是索引</span>
        <span class="token keyword">elif</span> current_sum <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>
            left <span class="token operator">+=</span> <span class="token number">1</span>  <span class="token comment"># 和太小，移动左指针</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            right <span class="token operator">-=</span> <span class="token number">1</span>  <span class="token comment"># 和太大，移动右指针</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment"># 如果没有找到，返回[-1, -1]</span>
</code></pre> 
<p>在这个函数中，左指针从数组的开始位置向右移动，右指针从数组的结束位置向左移动，直到找到两数之和等于目标值或左右指针相遇。通过这种方式，我们只需要遍历数组一次，从而提高了算法的效率。</p> 
<hr> 
<h2><a id="_48"></a>实战练习</h2> 
<h3><a id="httpsleetcodecnproblemsfindtheduplicatenumberdescription_49"></a><a href="https://leetcode.cn/problems/find-the-duplicate-number/description/" rel="nofollow">寻找重复数</a></h3> 
<p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p> 
<p>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</p> 
<p>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p> 
<p><strong>示例 1：</strong><br> 输入：nums = [1,3,4,2,2]<br> 输出：2</p> 
<p><strong>示例 2：</strong><br> 输入：nums = [3,1,3,4,2]<br> 输出：3</p> 
<p><strong>提示：</strong><br> 1 &lt;= n &lt;= 105<br> nums.length == n + 1<br> 1 &lt;= nums[i] &lt;= n<br> nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次</p> 
<p><strong>进阶：</strong><br> 如何证明 nums 中至少存在一个重复的数字?<br> 你可以设计一个线性级时间复杂度 O(n) 的解决方案吗？</p> 
<p><a href="https://leetcode.cn/problems/find-the-duplicate-number/solutions/261119/xun-zhao-zhong-fu-shu-by-leetcode-solution/" rel="nofollow">官方题解</a></p> 
<hr> 
<h3><a id="httpsleetcodecnproblems3sumdescriptionenvTypelistenvIdvYKAo4L7_82"></a><a href="https://leetcode.cn/problems/3sum/description/?envType=list&amp;envId=vYKAo4L7" rel="nofollow">三数之和</a></h3> 
<p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。</p> 
<p><strong>注意：</strong> 答案中不可以包含重复的三元组。</p> 
<p><strong>示例 1：</strong><br> 输入：nums = [-1,0,1,2,-1,-4]<br> 输出：[[-1,-1,2],[-1,0,1]]<br> 解释：<br> nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。<br> nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。<br> nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。<br> 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br> 注意，输出的顺序和三元组的顺序并不重要。</p> 
<p><strong>示例 2：</strong><br> 输入：nums = [0,1,1]<br> 输出：[]<br> 解释：唯一可能的三元组和不为 0 。</p> 
<p><strong>示例 3：</strong><br> 输入：nums = [0,0,0]<br> 输出：[[0,0,0]]<br> 解释：唯一可能的三元组和为 0 。</p> 
<p><a href="https://leetcode.cn/problems/3sum/description/?envType=list&amp;envId=vYKAo4L7" rel="nofollow">官方题解</a></p> 
<hr> 
<h3><a id="IIhttpsleetcodecnproblemsremoveduplicatesfromsortedlistiidescription_111"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/" rel="nofollow">删除排序链表中的重复元素II</a></h3> 
<p>给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。</p> 
<p><strong>示例 1：</strong><br> <img src="https://images2.imgbox.com/9f/d0/Olk5HQP5_o.jpg" alt="请添加图片描述"></p> 
<p>输入：head = [1,2,3,3,4,4,5]<br> 输出：[1,2,5]</p> 
<p><strong>示例 2：</strong><br> <img src="https://images2.imgbox.com/a5/b2/ZEFqLfk2_o.jpg" alt="请添加图片描述"></p> 
<p>输入：head = [1,1,1,2,3]<br> 输出：[2,3]</p> 
<p><strong>提示：</strong><br> 链表中节点数目在范围 [0, 300] 内<br> -100 &lt;= Node.val &lt;= 100<br> 题目数据保证链表已经按升序 排列</p> 
<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/solutions/678122/shan-chu-pai-xu-lian-biao-zhong-de-zhong-oayn/" rel="nofollow">官方题解</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bb2f10de8123b1032dde1b3be9f74903/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Matlab】基于遗传算法优化BP神经网络 (GA-BP)的数据时序预测（附代码）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/26c5c0fc7088b108fb450b658dd10bee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何从单应矩阵H中分解旋转矩阵R和平移向量t？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>