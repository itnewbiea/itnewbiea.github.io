<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LWIP tcp服务器，网线不断插拔，服务器不断重连，最后连不上甚至死机 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LWIP tcp服务器，网线不断插拔，服务器不断重连，最后连不上甚至死机" />
<meta property="og:description" content="1.STM32芯片，tcp服务器，网线连接时候，客户端不断重连可以正常稳定连接。
2.客户端不断重连时候，网线不断断开重连，最后客户端连不上，甚至程序直接死机。
通过仿真发现err_t tcp_server_accept(void *arg, struct tcp_pcb *pcb, err_t err)，客户端申请连接pcb = NULL,也就是说没有空余的pcb给重连客户端使用，直接仿真tcp_active_pcbs信息发现，pcb-&gt;state = FIN_WAIT_1 || FIN_WAIT_2。网线不断断开，pcb关闭4次握手没有实现，只进行一部分，一直等待中。
更改lwip源码不知重哪里下手，也怕改错出现更多bug,只能取巧弄下。
在err_t tcp_server_accept(void *arg, struct tcp_pcb *pcb, err_t err)函数最前面加个判断，客户端连接分配的pcb为空闲（全被占用了），找到等待关闭pcb全释放了（可能会出现其他问题，不过我这只是单对单使用，能重连上就行）。
if(pcb == NULL){
/*网络不稳（不断插拔网线），强制释放pcb*/
tcp_find_waitPcb();
printf(&#34;MBtcp: accept pcb == NULL\r\n&#34;);
return ERR_ARG;
}
tcp_find_waitPcb()的函数定义：
void tcp_find_distant(void)
{
struct tcp_pcb *pcb = NULL;
for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb-&gt;next)
{
if(pcb-&gt;state == FIN_WAIT_1 || pcb-&gt;state == FIN_WAIT_2){
tcp_abort( pcb );
}
}" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/9b41ddfdc23dd52ff20d85727fd30156/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-15T09:57:48+08:00" />
<meta property="article:modified_time" content="2020-06-15T09:57:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LWIP tcp服务器，网线不断插拔，服务器不断重连，最后连不上甚至死机</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.STM32芯片，tcp服务器，网线连接时候，客户端不断重连可以正常稳定连接。</p> 
<p> </p> 
<p>2.客户端不断重连时候，网线不断断开重连，最后客户端连不上，甚至程序直接死机。</p> 
<p> </p> 
<p>通过仿真发现err_t tcp_server_accept(void *arg, struct tcp_pcb *pcb, err_t err)，客户端申请连接pcb = NULL,也就是说没有空余的pcb给重连客户端使用，直接仿真tcp_active_pcbs信息发现，pcb-&gt;state = FIN_WAIT_1 || FIN_WAIT_2。网线不断断开，pcb关闭4次握手没有实现，只进行一部分，一直等待中。</p> 
<p>更改lwip源码不知重哪里下手，也怕改错出现更多bug,只能取巧弄下。</p> 
<p>在err_t  tcp_server_accept(void *arg, struct tcp_pcb *pcb, err_t err)函数最前面加个判断，客户端连接分配的pcb为空闲（全被占用了），找到等待关闭pcb全释放了（可能会出现其他问题，不过我这只是单对单使用，能重连上就行）。</p> 
<p>         if(pcb == NULL){<!-- --><br>                 /*网络不稳（不断插拔网线），强制释放pcb*/<br>                 tcp_find_waitPcb();<br>                 printf("MBtcp: accept  pcb == NULL\r\n");<br>                 return ERR_ARG;<br>             }</p> 
<p> </p> 
<p>tcp_find_waitPcb()的函数定义：</p> 
<p>void tcp_find_distant(void)<br> {<!-- --><br>     struct tcp_pcb *pcb = NULL;</p> 
<p>        for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb-&gt;next)<br>         {<!-- --><br>             if(pcb-&gt;state == FIN_WAIT_1 || pcb-&gt;state == FIN_WAIT_2){<!-- --><br>                 tcp_abort( pcb );<br>             }<br>         }<br> }</p> 
<p>3.网线稳定，但是客户端不断快速断开连接，出现pcb = pcb-&gt;next,进入void tcp_slowtmr(void)函数死循环中出不来了。</p> 
<p> 参照：<a href="http://www.51hei.com/bbs/dpj-140158-1.html" rel="nofollow">http://www.51hei.com/bbs/dpj-140158-1.html</a> 完美解决问题</p> 
<p> </p> 
<table border="1" cellspacing="0"><tbody><tr><td colspan="2" style="border-color:#e3edf5;">需改内容</td><td rowspan="2" style="border-color:#e3edf5;"> 
    <div> 
     <div>
       解释 
     </div> 
    </div> </td></tr><tr><td style="border-color:#e3edf5;"> 
    <div> 
     <div>
       文件名称 
     </div> 
    </div> </td><td style="border-color:#e3edf5;"> 
    <div> 
     <div>
       添加内容（增加红色字体） 
     </div> 
    </div> </td></tr><tr><td style="border-color:#e3edf5;"> 
    <div> 
     <div>
       tcp.h 
     </div> 
    </div> </td><td style="border-color:#e3edf5;"> 
    <div>
      /* the TCP protocol control block */ 
    </div>   struct tcp_pcb { 
    <div>
      ..............................略...................................... 
    </div> 
    <div>
        u8_t pcb_used;  
    </div> 
    <div>
      }; 
    </div> </td><td style="border-color:#e3edf5;"> 
    <div>
      在struct  tcp_pcb 结构体中增加一个字段，pcb_used。这个字段值 = 0 或 = 1。 
    </div> 
    <div>
      0代表这个TCP_PCB块没有在使用，已经释放。  
    </div> 
    <div>
      1代表这个TCP_PCB块正在使用，占用内存。 
    </div> </td></tr><tr><td style="border-color:#e3edf5;"> 
    <div> 
     <div>
       memp.c 
     </div> 
    </div> </td><td style="border-color:#e3edf5;"> 
    <div>
      void   memp_free(memp_t type, void *mem) 
    </div>  {<!-- --><br>    struct memp *memp;<br>    
    <div>
        struct tcp_pcb *pcb;   
    </div> 
    <div> 
     <span style="color:#FF0000;">  if(type == MEMP_TCP_PCB ){<!-- --></span>   
    </div> 
    <div> 
     <span style="color:#FF0000;">      pcb  = (struct tcp_pcb *)mem;</span> 
    </div> 
    <div> 
     <span style="color:#FF0000;">       if(pcb-&gt;pcb_used == 0){<!-- --></span>   
    </div> 
    <div> 
     <span style="color:#FF0000;">              return;</span>   
    </div> 
    <div> 
     <span style="color:#FF0000;">       }</span> 
    </div> 
    <div> 
     <span style="color:#FF0000;">       pcb-&gt;pcb_used = 0;</span>  
    </div> 
    <div> 
     <span style="color:#FF0000;">  }</span> 
    </div> 
    <div>
         SYS_ARCH_DECL_PROTECT(old_level); 
    </div>   ............................略...................................... 
    <div>
      } 
    </div> </td><td style="border-color:#e3edf5;"> 
    <div> 
     <div>
       在释放TCP_PCB块的时候，如果pcb_used==0，那么这个TCP_PCB块已经释放过了，可能是没连接的块系统自己释放，也能是自己误操作，多次释放。总之，不管什么原因，已经释放过的不能再释放了，所有这边直接return退出。没有释放的正常释放，只是字段pcb_used置0。 
     </div> 
    </div> </td></tr><tr><td style="border-color:#e3edf5;"> 
    <div> 
     <div>
       tcp.c 
     </div> 
    </div> </td><td style="border-color:#e3edf5;"> 
    <div>
      struct tcp_pcb * tcp_alloc(u8_t prio)  
    </div> 
    <div>
      {  ....................略.....................................   
    </div> 
    <div>
         if (pcb != NULL) { 
    </div> 
    <div>
           ......................略...................................... 
    </div> 
    <div>
             pcb-&gt;pcb_used = 1; 
    </div> 
    <div>
        } 
    </div> 
    <div>
         return pcb; 
    </div> 
    <div>
      } 
    </div> </td></tr></tbody></table> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/383f53886a80e28ebe17e76f7f2e7e81/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HTTP协议知识点必懂</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e5fa2ba63712bb4bbf94f62eb135ad8c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Edge、Chrome、IE浏览器乱码解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>