<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 数据结构篇-用链表、数组实现队列（数组实现：循环队列） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java 数据结构篇-用链表、数组实现队列（数组实现：循环队列）" />
<meta property="og:description" content="🔥博客主页： 【小扳_-CSDN博客】
❤感谢大家点赞👍收藏⭐评论✍ 文章目录
1.0 队列的说明
1.1 队列的几种常用操作
2.0 使用链表实现队列说明
2.1 链表实现队列
2.2 链表实现队列 - 入栈操作
2.3 链表实现队列 - 出栈操作
2.4 链表实现队列 - 获取队头元素操作(不删除)
2.5 链表实现队列 - 获取队列有效元素个数操作
2.6 链表实现队列 - 判空处理操作
2.7 用链表实现队列的完整代码
3.0 使用数组实现循环队列说明
3.1 数组实现循环队列的操作
3.2 数组实现循环队列 - 入队列操作
3.3 数组实现循环队列 - 出队列操作
3.4 数组实现队列 - 得到队头元素操作(不删除)
3.5 数组实现队列 - 得到队尾元素操作(不删除)
3.6 数组实现队列 - 判空队列操作
3.7 数组实现队列 - 判满队列操作
3.8 用数组实现队列完整代码
1.0 队列的说明 队列是一种线性数据结构，具有先进先出（First In First Out，FIFO）的特性。它类似于排队的概念，新元素被添加到队列的尾部，而从队列中移除元素时则从队列的头部开始。队列通常用于需要按照特定顺序处理元素的场景，比如任务调度、消息传递等。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/44e9fa6e4fc8dc909e7d04b96806e4db/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-03T18:36:40+08:00" />
<meta property="article:modified_time" content="2023-12-03T18:36:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 数据结构篇-用链表、数组实现队列（数组实现：循环队列）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>🔥博客主页： 【<strong><a href="https://blog.csdn.net/Tingfeng__?spm=1000.2115.3001.5343" title="小扳_-CSDN博客】">小扳_-CSDN博客】</a></strong><br> ❤感谢大家点赞👍收藏⭐评论✍</strong> </p> 
</blockquote> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/dd/67/R3GIP2Ri_o.jpg" width="400"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4a/f9/jsmmKvJa_o.gif"></p> 
<p id="main-toc"><strong>文章目录</strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E9%98%9F%E5%88%97%E7%9A%84%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E9%98%9F%E5%88%97%E7%9A%84%E8%AF%B4%E6%98%8E" rel="nofollow">        1.0 队列的说明</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1%20%E9%98%9F%E5%88%97%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1%20%E9%98%9F%E5%88%97%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1%20%E9%98%9F%E5%88%97%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C" rel="nofollow">1.1 队列的几种常用操作</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E4%BD%BF%E7%94%A8%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E4%BD%BF%E7%94%A8%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E8%AF%B4%E6%98%8E" rel="nofollow">        2.0 使用链表实现队列说明</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97" rel="nofollow">2.1 链表实现队列</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%85%A5%E6%A0%88%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%85%A5%E6%A0%88%E6%93%8D%E4%BD%9C" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%85%A5%E6%A0%88%E6%93%8D%E4%BD%9C" rel="nofollow">2.2 链表实现队列 - 入栈操作</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C" rel="nofollow">2.3 链表实现队列 - 出栈操作</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E8%8E%B7%E5%8F%96%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E8%8E%B7%E5%8F%96%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E8%8E%B7%E5%8F%96%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C" rel="nofollow">2.4 链表实现队列 - 获取队头元素操作(不删除)</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.5%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E6%9C%89%E6%95%88%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.5%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E6%9C%89%E6%95%88%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0%E6%93%8D%E4%BD%9C" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.5%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E6%9C%89%E6%95%88%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0%E6%93%8D%E4%BD%9C" rel="nofollow">2.5 链表实现队列 - 获取队列有效元素个数操作</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.6%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E7%A9%BA%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.6%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E7%A9%BA%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.6%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E7%A9%BA%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C" rel="nofollow">2.6 链表实现队列 - 判空处理操作</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.7%20%E7%94%A8%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.7%20%E7%94%A8%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.7%20%E7%94%A8%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">2.7 用链表实现队列的完整代码</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E8%AF%B4%E6%98%8E" rel="nofollow">        3.0 使用数组实现循环队列说明</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%93%8D%E4%BD%9C" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%93%8D%E4%BD%9C" rel="nofollow">3.1 数组实现循环队列的操作</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%20-%20%E5%85%A5%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%20-%20%E5%85%A5%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%20-%20%E5%85%A5%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C" rel="nofollow">3.2 数组实现循环队列 - 入队列操作</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A03.3%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%20-%20%E5%87%BA%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A03.3%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%20-%20%E5%87%BA%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A03.3%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%20-%20%E5%87%BA%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C" rel="nofollow">3.3 数组实现循环队列 - 出队列操作</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.4%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%C2%A0%E5%BE%97%E5%88%B0%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C(%E4%B8%8D%E5%88%A0%E9%99%A4)-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.4%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%C2%A0%E5%BE%97%E5%88%B0%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C%28%E4%B8%8D%E5%88%A0%E9%99%A4%29" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.4%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%C2%A0%E5%BE%97%E5%88%B0%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C%28%E4%B8%8D%E5%88%A0%E9%99%A4%29" rel="nofollow">3.4 数组实现队列 - 得到队头元素操作(不删除)</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A03.5%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%BE%97%E5%88%B0%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C(%E4%B8%8D%E5%88%A0%E9%99%A4)-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A03.5%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%BE%97%E5%88%B0%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C%28%E4%B8%8D%E5%88%A0%E9%99%A4%29" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A03.5%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%BE%97%E5%88%B0%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C%28%E4%B8%8D%E5%88%A0%E9%99%A4%29" rel="nofollow">3.5 数组实现队列 - 得到队尾元素操作(不删除)</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.6%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E7%A9%BA%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.6%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E7%A9%BA%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.6%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E7%A9%BA%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C" rel="nofollow">3.6 数组实现队列 - 判空队列操作</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.7%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%BB%A1%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.7%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%BB%A1%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.7%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%BB%A1%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C" rel="nofollow">3.7 数组实现队列 - 判满队列操作</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.8%20%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.8%20%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">        3.8 用数组实现队列完整代码</a></strong></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E9%98%9F%E5%88%97%E7%9A%84%E8%AF%B4%E6%98%8E" style="background-color:transparent;">        1.0 队列的说明</h2> 
<p>        <strong>队列是一种线性数据结构，具有<span style="color:#fe2c24;">先进先出</span>（<span style="color:#fe2c24;">First In First Out，FIFO</span>）的特性。它类似于排队的概念，<span style="color:#fe2c24;">新元素被添加到队列的尾部</span>，<span style="color:#fe2c24;">而从队列中移除元素时则从队列的头部开始</span>。队列通常用于需要按照特定顺序处理元素的场景，比如任务调度、消息传递等。</strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1%20%E9%98%9F%E5%88%97%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C">        1.1 队列的几种常用操作</h3> 
<p>                <strong>- <span style="color:#fe2c24;">队首元素（front）</span>：队列的头部元素。</strong></p> 
<p><strong>                - <span style="color:#fe2c24;">队尾元素（rear）</span>：队列的尾部元素。</strong></p> 
<p><strong>                - <span style="color:#fe2c24;">入队（offer）</span>：将新元素添加到队列的尾部。</strong></p> 
<p><strong>                - <span style="color:#fe2c24;">出队（poll）</span>：从队列的头部移除元素。</strong></p> 
<p><strong>                - <span style="color:#fe2c24;">获取队头元素（peek）</span>：从队列的头部获取元素，不移除。</strong></p> 
<p><strong>                - <span style="color:#fe2c24;">判空（isEmpty）</span>：判断队列是否为空。</strong></p> 
<p><strong>                - <span style="color:#fe2c24;">判满（isFull）</span>：判断队列是否已满（对于有限大小的队列）。</strong></p> 
<p><strong>                - <span style="color:#fe2c24;">元素个数（size）</span>：获取队列有效的元素个数。</strong></p> 
<p><strong>接口代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">public interface QueueInterface{
    /**
     * 入列
     */
    boolean offer(int e);

    /**
     * 出列
     */
    int poll();

    /**
     * 获取队列头元素
     */
    int peek();

    /**
     * 获取队列中有效元素个数
     */
    int size();

    /**
     * 检验队列是否为空
     */
    boolean isEmpty();
}</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E4%BD%BF%E7%94%A8%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E8%AF%B4%E6%98%8E" style="background-color:transparent;">        2.0 使用链表实现队列说明</h2> 
<p>        <strong>使用链表实现队列，<span style="color:#fe2c24;">无疑就是用链表的数据结构的方式来实现队列的操作（实现队列的接口）</span>。跟栈不同的是：<span style="color:#fe2c24;">栈只能对一端进行操作，而队列是对头尾进行操作</span>。一般对于<span style="color:#fe2c24;">单链表</span>来说，<span style="color:#fe2c24;">头节点当作队列中的队头（front）</span>，<span style="color:#fe2c24;">尾节点当作队列中的队尾（rear）</span>。而<span style="color:#fe2c24;">入队列相当于尾插</span>，在链表尾部插入节点，<span style="color:#fe2c24;">出队列相当于头删</span>，在链表头部删除头节点。对于双向链表来说，就比较自由了，头节点既可以作为队头，也可以作为队尾。尾节点既可以作为队头，也可以作为队尾。</strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">        2.1 链表实现队列</h3> 
<p>        <strong>用双向链表来实现队列，既然头尾都可以作为队列，选其中一种即可，对于队尾来说也是如此。这里就用头节点作为队列中的队头，而尾节点作为队列中的队尾。</strong></p> 
<p><strong>简单分析：</strong></p> 
<p><span style="color:#fe2c24;">        </span><strong><span style="color:#fe2c24;">- 实现入栈操作：</span>在链表尾部插入节点即可。</strong></p> 
<p><strong><span style="color:#fe2c24;">        - 实现出栈操作：</span>在链表头部删除节点即可。</strong></p> 
<p><strong><span style="color:#fe2c24;">        - 实现获取队列头部元素：</span>获取链表头部节点的元素即可。</strong></p> 
<p><strong><span style="color:#fe2c24;">        - 实现总计有效元素个数：</span>需要定义一个成员变量 size ，入栈时进行 size++ ，出栈时  size--</strong></p> 
<p><strong><span style="color:#fe2c24;">        - 实现判空处理：</span>当 size == 0 ，则为空队列。</strong></p> 
<p><strong><span style="color:#fe2c24;">        - 实现判断满队列：</span>当 size &gt;= 创建队列时默认大小，则为满队列。</strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%85%A5%E6%A0%88%E6%93%8D%E4%BD%9C">        2.2 链表实现队列 - 入栈操作</h3> 
<p>                <strong>实现入栈操作：在链表尾部插入节点即可。分为两种情况：<span style="color:#fe2c24;">当队列为空时，则入栈的节点即是队头也是队尾</span>；<span style="color:#fe2c24;">当队列不为空时，则入栈的节点一般来说就是新的队尾</span>。每一次入栈完成后，都需要进行<span style="color:#fe2c24;"> size++</span> 。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //入列
    @Override
    public boolean offer(int e) {
        if (isEmpty()) {
            front = rear = new Node(null,e,null);
            size++;
            return true;
        }
        Node node = new Node(rear,e,null);
        rear.next = node;
        rear = node;
        size++;
        return true;
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C" style="background-color:transparent;">        2.3 链表实现队列 - 出栈操作</h3> 
<p>                <strong>实现出栈操作：在链表头部删除节点即可。出栈一般分为三种情况：</strong></p> 
<p><strong>        <span style="color:#fe2c24;">第一种情况</span>，当队列为空时，不应该出栈了，直接返回 -1 或者抛异常。</strong></p> 
<p><strong>        <span style="color:#fe2c24;">第二种情况</span>，当只有一个节点时，出栈之后，就不会再有元素了，所以<span style="color:#fe2c24;"> front</span> 与 <span style="color:#fe2c24;">rear</span> 需要置为空。返回出栈节点的值即可。</strong></p> 
<p><strong>        <span style="color:#fe2c24;">第三种情况</span>，除了第一、二种情况之后，第三种情况就可以正常的进行头删节点操作处理了。需要注意的是，出栈完成后，进行 <span style="color:#fe2c24;">size--</span> 。最后，返回出栈节点的数值即可。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <p> </p> 
 <pre><code class="language-java">    //出列
    @Override
    public int poll() {
        if (isEmpty()){
            return -1;
        }
        //注意特例:只有一个节点的情况
        if (front.next == null) {
            int temp = front.val;
            front = null;
            rear = null;
            return temp;
        }
        Node temp = front;
        front = front.next;
        front.prev = null;
        size--;
        return temp.val;
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E8%8E%B7%E5%8F%96%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C" style="background-color:transparent;">        2.4 链表实现队列 - 获取队头元素操作(不删除)</h3> 
<p>                <strong>获取链表头部节点的元素即可。一般分为两种情况：<span style="color:#fe2c24;">当队列为空时，可以返回 -1 或者抛异常处理</span>；<span style="color:#fe2c24;">当队列不为空时，直接返回头部节点的值即可</span>。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    @Override
    public int peek() {
        if (isEmpty()) {
            return -1;
        }
        return front.val;
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.5%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E6%9C%89%E6%95%88%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0%E6%93%8D%E4%BD%9C" style="background-color:transparent;">        2.5 链表实现队列 - 获取队列有效元素个数操作</h3> 
<p><strong>                直接返回 size 即可。</strong></p> 
<blockquote> 
 <pre><code class="language-java">    @Override
    public int size() {
        return size;
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.6%20%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E7%A9%BA%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C" style="background-color:transparent;">        2.6 链表实现队列 - 判空处理操作</h3> 
<p>                <strong>当 <span style="color:#fe2c24;">size == 0</span> 时，返回<span style="color:#fe2c24;"> true </span>。否则返回 <span style="color:#fe2c24;">false</span> 。也可以用 <span style="color:#fe2c24;">front == null </span>来判断是否为空队列。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    @Override
    public boolean isEmpty() {
        return front == null;
    }</code></pre> 
 <p></p> 
</blockquote> 
<p> </p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.7%20%E7%94%A8%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">        2.7 用链表实现队列的完整代码</h3> 
<blockquote> 
 <pre><code class="language-java">public class MyLinkedQueue implements QueueInterface {

    static class Node {
        public Node prev;
        public int  val;
        public Node next;

        public Node(Node prev, int val, Node next) {
            this.prev = prev;
            this.val = val;
            this.next = next;
        }
    }

    private Node front;
    private Node rear;
    private int size;

    //入列
    @Override
    public boolean offer(int e) {
        if (isEmpty()) {
            front = rear = new Node(null,e,null);
            size++;
            return true;
        }
        Node node = new Node(rear,e,null);
        node.prev = rear;
        rear.next = node;
        rear = node;
        size++;
        return true;
    }

    //出列
    @Override
    public int poll() {
        if (isEmpty()){
            return -1;
        }
        //注意特例:只有一个节点的情况
        if (front.next == null) {
            int temp = front.val;
            front = null;
            rear = null;
            return temp;
        }
        Node temp = front;
        front = front.next;
        front.prev = null;
        size--;
        return temp.val;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return -1;
        }
        return front.val;
    }

    @Override
    public int size() {
        return size;
    }

    @Override
    public boolean isEmpty() {
        return front == null;
    }

}</code></pre> 
 <p></p> 
</blockquote> 
<p> </p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E8%AF%B4%E6%98%8E" style="background-color:transparent;">        3.0 使用数组实现循环队列说明</h2> 
<p>        <strong><span style="color:#fe2c24;">用数组实现队列，一般来说是循环队列</span>，循环队列可以解决普通队列在出队操作后产生的空间浪费问题，同时可以利用数组的固定大小来实现队列的循环利用。</strong></p> 
<p><strong>循环队列的接口代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">public interface QueueInterface{
    /**
     * 入列
     */
    boolean offer(int e);

    /**
     * 出列
     */
    int poll();

    /**
     * 获取队列头元素，不删除
     */
    int peek();
    
    /**
     * 检验队列是否为空
     */
    boolean isEmpty();

    /**
     * 判断是否为满队列
     */
    boolean isFull();

    /**
     * 得到队尾元素，不删除
     */
    int Rear();
}</code></pre> 
 <p></p> 
</blockquote> 
<p>        <strong><span style="color:#fe2c24;">使用数组实现队列，无疑就是用数组的数据结构的方式来实现队列的操作（实现队列的接口）</span>。循环队列的关键是使用两个指针来标记队列的头部和尾部，分别称为 <span style="color:#fe2c24;">front</span> 和<span style="color:#fe2c24;"> rear </span>。<span style="color:#fe2c24;">当入队时，rear 指针向后移动</span>；<span style="color:#fe2c24;">当出队时，front 指针向后移动</span>。当 rear 指针到达数组的末尾时，可以通过取模运算将 rear 指针置为 0 ，实现循环的效果。</strong></p> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%93%8D%E4%BD%9C">        3.1 数组实现循环队列的操作</h3> 
<p><span style="color:#fe2c24;">               </span><strong><span style="color:#fe2c24;"> - 入队操作：</span>将元素添加到 <span style="color:#fe2c24;">rear</span> 指针所指向的位置，并更新 <span style="color:#fe2c24;">rear</span> 指针。</strong></p> 
<p><strong><span style="color:#fe2c24;">                - 出队操作：</span>从 <span style="color:#fe2c24;">front</span> 指针所指向的位置移除元素，并更新<span style="color:#fe2c24;"> front</span> 指针。</strong></p> 
<p><strong><span style="color:#fe2c24;">                - 判空操作：</span>当 <span style="color:#fe2c24;">front </span>指针等于 <span style="color:#fe2c24;">rear </span>指针时，队列为空。</strong></p> 
<p><strong><span style="color:#fe2c24;">                - 判满操作：</span>当<span style="color:#fe2c24;"> </span><span style="color:#fe2c24;">(rear+1) % 数组长度</span>等于<span style="color:#fe2c24;"> front</span> 指针时，队列为满。</strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%20-%20%E5%85%A5%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C">        3.2 数组实现循环队列 - 入队列操作</h3> 
<p>                <strong>将元素添加到<span style="color:#fe2c24;"> rear</span> 指针所指向的位置，并更新 <span style="color:#fe2c24;">rear</span> 指针。更新 <span style="color:#fe2c24;">rear</span> 就是往后走一步，但是为了实现循环，<span style="color:#fe2c24;">可不能简单的进行 +1 处理</span>，需要 <span style="color:#fe2c24;">rear = (rear + 1) % arr.length</span>，这样就可以数组中循环走了。在入队前，需要先判断是否为满队列了。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    // 入队列
    @Override
    public boolean offer(int e) {
        if (isFull()) {
            return false;
        }
        arr[rear] = e;
        rear = (rear+1) % arr.length;
        return true;
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A03.3%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%20-%20%E5%87%BA%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C">         3.3 数组实现循环队列 - 出队列操作</h3> 
<p>                <strong>从 <span style="color:#fe2c24;">front</span> 指针所指向的位置移除元素，并更新 <span style="color:#fe2c24;">front </span>指针。同样的，更新可不能简单的 <span style="color:#fe2c24;">+1 处理</span>，需要将<span style="color:#fe2c24;"> front = (front + 1) % arr.length</span> ，每次出栈前需要记录一下出栈的元素，接着才往后走，最后返回记录的元素即可。出栈前，需要判断是否为空队列，如果为空队列，就需要<span style="color:#fe2c24;">抛异常</span>或者返回<span style="color:#fe2c24;"> -1 </span>处理。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //出队列
    @Override
    public int poll() {
        if (isEmpty()) {
            return -1;
        }
        int temp = arr[front];
        front = (front + 1) % arr.length;
        return temp;
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.4%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%C2%A0%E5%BE%97%E5%88%B0%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C(%E4%B8%8D%E5%88%A0%E9%99%A4)" style="background-color:transparent;">        3.4 数组实现队列 - 得到队头元素操作(不删除)</h3> 
<p>                <strong><span style="color:#fe2c24;">先判断是否为空队列，若不是，则返回队头元素即可。</span></strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //得到队头元素，不删除
    @Override
    public int peek() {
        if (isEmpty()) {
            return -1;
        }
        return arr[front];
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A03.5%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%BE%97%E5%88%B0%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C(%E4%B8%8D%E5%88%A0%E9%99%A4)">         3.5 数组实现队列 - 得到队尾元素操作(不删除)</h3> 
<p>                <strong>先判断队列是否为空，如果为<span style="color:#fe2c24;">空队列，则返回 -1 或者抛异常</span>。如果<span style="color:#fe2c24;">不为空</span>，则<span style="color:#fe2c24;">需要返回 arr[rear - 1]</span>，但是<span style="color:#fe2c24;">需要注意的是：</span>有一种情况需要额外考虑进去，当<span style="color:#fe2c24;"> rear == 0</span> 时，那么 <span style="color:#fe2c24;">rear - 1 == -1 </span>，<span style="color:#fe2c24;">所以不合理，数组中的索引不存在 -1</span> 。因此这个情况要分开讨论，<span style="color:#fe2c24;">当 rear == 0 时</span>，那么需要返回的值为<span style="color:#fe2c24;"> arr[arr.length - 1]</span>；<span style="color:#fe2c24;">当 rear != 0 时</span>，那么返回的值为 <span style="color:#fe2c24;">arr[rear - 1]</span> 。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //得到队尾元素，不删除
    @Override
    public int Rear() {
        if (isEmpty()) {
            return -1;
        }
        int temp = (rear == 0) ? arr.length - 1 : rear - 1;
        return arr[temp];
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.6%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E7%A9%BA%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C" style="background-color:transparent;">        3.6 数组实现队列 - 判空队列操作</h3> 
<p>                <strong>当且仅当 <span style="color:#fe2c24;">rear == front </span>时，则<span style="color:#fe2c24;">队列为空</span>。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    @Override
    public boolean isEmpty() {
        return front == rear;
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.7%20%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%BB%A1%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C">        3.7 数组实现队列 - 判满队列操作</h3> 
<p>                <strong>有很多种方式可以来判断队列是否满，比如，<span style="color:#fe2c24;">定义 size 变量来总计元素个数，然后跟 arr.lengrh 进行对比，相等即满队列了，不相等即为还没有满队列</span>；<span style="color:#fe2c24;">使用标记也可以实现判断是否为满队列。</span></strong></p> 
<p><strong>        这里<span style="color:#fe2c24;">介绍牺牲空间来判断满队列</span>，即当且仅当 <span style="color:#fe2c24;">(rear + 1) % arr.lengrh == front</span> 时，该队列满了。由于这里<span style="color:#fe2c24;">牺牲了一个空间</span>，所以需要在自定义初始化数组大小的时候<span style="color:#fe2c24;">额外 +1</span> 。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    // 自定义数组大小
    public ArrayQueue(int capacity) {
        arr = new int[capacity + 1];
    }

    // 默认数组大小为: 10
    public ArrayQueue() {
        arr = new int[10];
    }</code></pre> 
 <pre><code class="language-java">    @Override
    //判断是否为满队列（有很多种判断方法，这里使用牺牲空间方法来判断）
    public boolean isFull() {
        return (rear + 1) % arr.length == front;
    }</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.8%20%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">        3.8 用数组实现队列完整代码</h3> 
<blockquote> 
 <pre><code class="language-java">public class ArrayQueue implements QueueInterface{

    private int front;
    private int rear;
    private int[] arr;

    // 自定义数组大小
    public ArrayQueue(int capacity) {
        arr = new int[capacity + 1];
    }

    // 默认数组大小为: 10
    public ArrayQueue() {
        arr = new int[10];
    }

    // 入队列
    @Override
    public boolean offer(int e) {
        if (isFull()) {
            return false;
        }
        arr[rear] = e;
        rear = (rear+1) % arr.length;
        return true;
    }

    //出队列
    @Override
    public int poll() {
        if (isEmpty()) {
            return -1;
        }
        int temp = arr[front];
        front = (front + 1) % arr.length;
        return temp;
    }

    //得到队头元素，不删除
    @Override
    public int peek() {
        if (isEmpty()) {
            return -1;
        }
        return arr[front];
    }

    //得到队尾元素，不删除
    @Override
    public int Rear() {
        if (isEmpty()) {
            return -1;
        }
        int temp = (rear == 0) ? arr.length - 1 : rear - 1;
        return arr[temp];
    }

    @Override
    public boolean isEmpty() {
        return front == rear;
    }

    @Override
    //判断是否为满队列（有很多种判断方法，这里使用牺牲空间方法来判断）
    public boolean isFull() {
        return (rear + 1) % arr.length == front;
    }
    
}</code></pre> 
 <p></p> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/7d/4c/j8NnN3iv_o.gif"></p> 
<p style="text-align:center;"> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c99fd02dfebdad1120fb02aa522495eb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">字体图片rgb565格式转换为ARGB888格式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0d8a47a77089c228aac91cdc08648829/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【公式】逻辑回归的损失函数是什么</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>