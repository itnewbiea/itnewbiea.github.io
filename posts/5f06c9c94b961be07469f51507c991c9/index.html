<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>代理与反射 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="代理与反射" />
<meta property="og:description" content="前言 代理和反射是 ES6 新增的两个特性。他们为开发者提供了拦截对象基本操作并向其嵌入额外行为的能力。可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。本文内容为详读《JavaScript 高级程序设计（第4版）》的笔记。
ES6 学习系列笔记
ES6 总结Symbol、Map、SetES6 中的类（class）代理与反射Promise 与异步函数迭代器和生成器 目录 前言1 代理1.1 代理基础语法1.2 定义捕获器1.3 捕获器参数和反射 API1.4 捕获器不变式和可撤销代理1.5 反射 API 的实用性1.6 代理多层拦截和代理的不足 2 代理捕获器与反射方法2.1 get()2.2 set()2.3 has()2.4 defineProperty()2.5 getOwnPropertyDescriptor()2.6 deleteProperty()2.7 ownKeys()2.8 getPrototypeOf()2.9 setPrototypeOf()2.10 isExtensible()2.11 preventExtensions()2.12 apply()2.13 construct() 3 代理模式 1 代理 在 ES6 之前，ECMAScript 中并没有类似代理的特性。它是一种新的基础性语言能力，很多转译程序都无法将其转为 ES6 之前的兼容性代码。所以只能在支持他们的平台上使用，如果不支持则需提供后备代码或者不能使用代理和反射。
1.1 代理基础语法 代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。这两个参数是必需的，而且是 Object 类型数据，不传或者数据类型不对都会抛出 TypeError 。如下列示例代码创建了一个处理程序对象为空对象的代理 proxy 。
const target = { id: &#39;target&#39; }; const handler = {}; const proxy = new Proxy(target, handler); // 对代理对象的操作会同时放映在两个对象上 proxy." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5f06c9c94b961be07469f51507c991c9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-20T22:17:19+08:00" />
<meta property="article:modified_time" content="2023-04-20T22:17:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">代理与反射</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>前言</h3> 
<p>代理和反射是 <em>ES6</em> 新增的两个特性。他们为开发者提供了<strong>拦截对象基本操作并向其嵌入额外行为的能力</strong>。<strong>可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制</strong>。本文内容为详读《<em>JavaScript</em> 高级程序设计（第<em>4</em>版）》的笔记。</p> 
<p><em>ES6</em> 学习系列笔记</p> 
<ol><li><a href="https://blog.csdn.net/TKOP_/article/details/129963475?spm=1001.2014.3001.5502"><em>ES6</em> 总结</a></li><li><a href="https://blog.csdn.net/TKOP_/article/details/130084739?spm=1001.2014.3001.5502"><em>Symbol、Map、Set</em></a></li><li><a href="https://blog.csdn.net/TKOP_/article/details/130144058?spm=1001.2014.3001.5501"><em>ES6</em> 中的类（<em>class</em>）</a></li><li><a href="https://blog.csdn.net/TKOP_/article/details/130047429?spm=1001.2014.3001.5501">代理与反射</a></li><li><a href="https://blog.csdn.net/TKOP_/article/details/129856827?spm=1001.2014.3001.5501"><em>Promise</em> 与异步函数</a></li><li><a href="https://blog.csdn.net/TKOP_/article/details/129813858?spm=1001.2014.3001.5501">迭代器和生成器</a></li></ol> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><ul><li><a href="#_0" rel="nofollow">前言</a></li><li><a href="#1__15" rel="nofollow">1 代理</a></li><li><ul><li><a href="#11__19" rel="nofollow">1.1 代理基础语法</a></li><li><a href="#12__50" rel="nofollow">1.2 定义捕获器</a></li><li><a href="#13__API_74" rel="nofollow">1.3 捕获器参数和反射 API</a></li><li><a href="#14__117" rel="nofollow">1.4 捕获器不变式和可撤销代理</a></li><li><a href="#15___API__164" rel="nofollow">1.5 反射 API 的实用性</a></li><li><a href="#16___212" rel="nofollow">1.6 代理多层拦截和代理的不足</a></li></ul> 
   </li><li><a href="#2__298" rel="nofollow">2 代理捕获器与反射方法</a></li><li><ul><li><a href="#21_get_302" rel="nofollow">2.1 get()</a></li><li><a href="#22_set_338" rel="nofollow">2.2 set()</a></li><li><a href="#23_has_375" rel="nofollow">2.3 has()</a></li><li><a href="#24_defineProperty_411" rel="nofollow">2.4 defineProperty()</a></li><li><a href="#25_getOwnPropertyDescriptor_445" rel="nofollow">2.5 getOwnPropertyDescriptor()</a></li><li><a href="#26_deleteProperty_489" rel="nofollow">2.6 deleteProperty()</a></li><li><a href="#27_ownKeys_524" rel="nofollow">2.7 ownKeys()</a></li><li><a href="#28_getPrototypeOf_560" rel="nofollow">2.8 getPrototypeOf()</a></li><li><a href="#29_setPrototypeOf_596" rel="nofollow">2.9 setPrototypeOf()</a></li><li><a href="#210_isExtensible_634" rel="nofollow">2.10 isExtensible()</a></li><li><a href="#211_preventExtensions_670" rel="nofollow">2.11 preventExtensions()</a></li><li><a href="#212_apply_707" rel="nofollow">2.12 apply()</a></li><li><a href="#213_construct_746" rel="nofollow">2.13 construct()</a></li></ul> 
   </li><li><a href="#3__784" rel="nofollow">3 代理模式</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1__15"></a>1 代理</h3> 
<p>在 <em>ES6</em> 之前，<em>ECMAScript</em> 中并没有类似代理的特性。它是一种新的基础性语言能力，很多转译程序都无法将其转为 <em>ES6</em> 之前的兼容性代码。所以只能在支持他们的平台上使用，如果不支持则需提供后备代码或者不能使用代理和反射。</p> 
<h4><a id="11__19"></a>1.1 代理基础语法</h4> 
<p><strong>代理是使用 <em>Proxy</em> 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象</strong>。这两个参数是必需的，而且是 <em>Object</em> 类型数据，不传或者数据类型不对都会抛出 <em>TypeError</em> 。如下列示例代码创建了一个处理程序对象为空对象的代理 <em>proxy</em> 。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'target'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 对代理对象的操作会同时放映在两个对象上</span>
proxy<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'object name'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'object name'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'object name'</span>

<span class="token comment">// 对目标对象的操作也会同时反映在两个对象上（会绕过代理施予的行为）</span>
target<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token string">'object id'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'object id'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'object id'</span>

<span class="token comment">// 可以打印两个对象，其实是一样的</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {id: 'object id', name: 'object name'}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Proxy {id: 'object id', name: 'object name'}</span>

<span class="token comment">// 但是他们的引用是不同的</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target <span class="token operator">==</span> proxy<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>

<span class="token comment">// 代理对象不能使用 instanceof 操作符（没有原型对象或者说原型是 undefined）</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy <span class="token keyword">instanceof</span> <span class="token class-name">Proxy</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// TypeError: Function has non-object prototype 'undefined' in instanceof check</span>
</code></pre> 
<h4><a id="12__50"></a>1.2 定义捕获器</h4> 
<p><strong>捕获器即在处理程序对象中定义的“基本操作的拦截器”</strong>。每个<strong>处理程序对象</strong>中可以定义 <em>0</em> 个或多个捕获器，<strong>每个捕获器都对应一种基本操作</strong>，可以直接或者间接在代理对象上调用。每次代理对象上调用这些操作时，<strong>代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为</strong>。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'target'</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'tkop'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prototype<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        target<span class="token punctuation">[</span>prototype<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'proxy_'</span> <span class="token operator">+</span> value<span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>receiver<span class="token punctuation">)</span><span class="token comment">// Proxy {id: 'proxy_id', name: 'tkop'}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token string">'id'</span><span class="token punctuation">;</span>
target<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'name'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'proxy_id'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'proxy_id'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'name'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'name'</span>
</code></pre> 
<p><strong>当通过代理对象执行 <em>set</em> 操作时，会触发定义的 <em>set()</em> 捕获器</strong>。<strong>注意这里的 <em>set()</em> 不是 <em>ECMAScript</em> 对象可以调用的方法</strong>。触发该捕获器后修改了赋值的行为。但是<strong>直接通过目标对象取执行操作时不会触发捕获器，该操作仍然会产生正常的行为</strong>。</p> 
<h4><a id="13__API_74"></a>1.3 捕获器参数和反射 API</h4> 
<p><strong>所有的捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法（触发操作）的原始行为</strong>。比如上面的 <em>set()</em> 捕获器会接收到<strong>目标对象、引用的目标对象上的字符串键属性、赋给属性的新值和接收最初赋值的对象</strong>四个参数。</p> 
<p>但并非所有的捕获器行为都像 <em>set()</em> 或者 <em>get()</em> 那么简单。有些很难去手动重建原始行为，此时可以通过调用<strong>全局 <em>Reflect</em> 对象</strong>上（封装了原始行为）的同名方法进行重建。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'target'</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'tkop'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prototype<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    		<span class="token comment">// 修改参数行为后直接调用 Reflect 相应方法。</span>
    		<span class="token comment">// 无需关系该方法内部详细的操作</span>
        value <span class="token operator">+=</span> <span class="token string">'_set'</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token string">'id'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'id_set'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'id_set'</span>
</code></pre> 
<p><strong>处理程序对象中所有可以捕获的方法都有对象的反射（<em>Reflect</em>）<em>API</em> 方法。这些方法与捕获器拦截的方法具有相同的名称和行为。具体有哪些可以查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect" rel="nofollow"><em>MDN</em>（内置对象 <em>Reflect</em>）</a></strong>。因此如果需要定义的是一个空代理对象（不定义任何捕获器或者定义的捕获器没有重建被捕获方法的原始行为），那么可以写得非常简洁。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'target'</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'tkop'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 甚至可以直接这么写</span>
    <span class="token literal-property property">get</span><span class="token operator">:</span> Reflect<span class="token punctuation">.</span>get<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token string">'id'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'id'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'id'</span>

<span class="token comment">// 可以捕获所有操作，但是不重建，只是将每个方法转发给对应反射 API 的空代理</span>
<span class="token keyword">const</span> target1 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'target'</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'tkop'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> Reflect<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="14__117"></a>1.4 捕获器不变式和可撤销代理</h4> 
<p>对象调用某些操作时是有相应的行为限制的，相应的代理中的捕获器也应遵循这些限制。例如目标对象返回一个只读且不可配置的数据属性时，需要返回实际的属性值，否则会报错。这就是捕获器的不变式，他们因操作（方法）不同而异。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'target'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">'target_name'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'_get'</span><span class="token punctuation">;</span>
        <span class="token comment">// return Reflect.get(...arguments);</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'name'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错（Uncaught TypeError）</span>
<span class="token comment">// 在目标对象中 name 属性是只读和不可配置属性，但是代理没有返回它实际的值</span>
</code></pre> 
<p>使用 <em><strong><code>new Proxy()</code></strong></em> 创建的普通代理对象与目标对象之间的联系会在代理对象的生命周期内一直持续存在。某些时候可能需要中断代理对象与目标对象之间的联系（但是代理对象依旧存在）。这就需要使用 <em><strong><code>Proxy.revocable()</code></strong></em> 方法来创建代理对象。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'target'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'_get'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">proxy</span><span class="token operator">:</span> p1<span class="token punctuation">,</span> <span class="token literal-property property">revoke</span><span class="token operator">:</span> p1Revoke <span class="token punctuation">}</span> <span class="token operator">=</span> Proxy<span class="token punctuation">.</span><span class="token function">revocable</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'target_get'</span>
<span class="token function">p1Revoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Proxy { [[Handler]]: null, [[Target]]: null, [[IsRevoked]]: true }</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>静态方法 <em><strong>Proxy.revocable()</strong></em> 除了对外暴露与目标对象建立联系的可撤销代理对象 <em>proxy</em> 外，还提供了相应的<strong>撤销函数 <em>revoke()</em></strong> 。只需要调用该函数就可以中断相应的代理对象和目标对象之间的联系。撤销的操作是不可逆的，一旦撤销就不可再次建立联系。撤销函数是幂等的，调用多少次都一样。撤销代理后再调用代理会抛出 <em>TypeError</em>。</p> 
</blockquote> 
<h4><a id="15___API__164"></a>1.5 反射 API 的实用性</h4> 
<p>某些情况下，我们应该优先使用反射 <em>API</em> 。</p> 
<p>1、反射 <em>API</em> 与对象 <em>API</em></p> 
<p>反射 <em>API</em> 是非常灵活的，它并不局限于捕获处理程序。大多数反射 <em>API</em> 方法在 <em>Object</em> 类型上有对应的方法（例如 <em>defineProperty、getPrototypeOf</em> 等）。<strong>通常，<em>Object</em> 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作</strong>。</p> 
<p>2、合理利用反射方法返回的操作状态</p> 
<p><strong>很多反射方法会返回表示意图执行的操作是否成功的布尔值。合理利用这些布尔值（状态标记）能够帮助我们写出更易维和的代码</strong>。例如使用 <em><strong><code>Reflect.defineProperty()</code></strong></em> 来代替 <em><strong><code>Object.defineProperty()</code></strong></em> 。如果定义属性时发生问题，前者只会返回 <em>false</em> 标记本次操作失败，而后者会抛出错误。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>myObj<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'tkop'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'success'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'failure'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>myObj<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">'tkop'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">'success'</span> <span class="token operator">:</span> <span class="token string">'failure'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>以下反射方法都会返回状态标记：</p> 
<ul><li><em><strong>Reflect.defineProperty()</strong></em></li><li><em>Reflect.preventExtensions()</em></li><li><em><strong>Reflect.setPrototypeOf()</strong></em></li><li><em><strong>Reflect.set()</strong></em></li><li><em><strong>Reflect.deleteProperty()</strong></em></li></ul> 
<p>3、利用一等函数替代操作符</p> 
<ul><li><em>Reflect.get()</em>：可以替代对象属性访问操作符。</li><li><em>Reflect.set()</em>：可以替代 <em>“=”</em> 赋值操作符。</li><li><em><strong>Reflect.has()</strong></em>：可以替代 <em>in</em> 操作符或者 <em>with()</em> 语句。</li><li><em>Reflect.deleteProperty()</em>：可以替代 <em>delete</em> 操作符。</li><li><em><strong>Reflect.construct()</strong></em>：可以替代 <em>new</em> 操作符。</li></ul> 
<p>4、提供更加安全的方法调用</p> 
<p>需要调用某个函数的 <em>apply</em> 方法时，该函数可能定义了实例方法 <em>apply</em> 。此时为了安全而绕过这个问题，就需要调用原型对象上的 <em>apply</em> 方法。但是如果直接使用 <em><strong>Reflect.apply()</strong></em> 来代替逻辑则会更加清晰。</p> 
<pre><code class="prism language-javascript"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> thisVal<span class="token punctuation">,</span> argumentList<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 使用反射 API</span>
<span class="token function">Reflect</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> thisVal<span class="token punctuation">,</span> argumentsList<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="16___212"></a>1.6 代理多层拦截和代理的不足</h4> 
<p>1、可以通过设置一个代理去代理另一个代理，这样就可以在一个目标对象上构建多层拦截网。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'proxy1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'undefined'</span> <span class="token operator">?</span> <span class="token string">'default'</span> <span class="token operator">:</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> proxy2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>proxy1<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'proxy2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> property <span class="token operator">+</span> <span class="token string">'：'</span> <span class="token operator">+</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy1<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy2<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>2、代理是在 <em>ECMAScript</em> 现有基础上构建起来的一套新的 <em>API</em>，虽然其实现已经做到最好了。很大程度上，代理作为对象的虚拟层可以正常使用。但是在某些情况下，代理也不能与现在的 <em>ECMAScript</em> 机制很好地协同。例如 <strong><em>this</em> 指向的问题</strong>。</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 1、使用 weakMap 保存实例私有变量</span>
<span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        vm<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">set</span> <span class="token function">userId</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        vm<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">get</span> <span class="token function">userId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> vm<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> user1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user1<span class="token punctuation">.</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 通过代理对象获取 userId 的值</span>
<span class="token comment">// User 实例一开始使用目标对象作为 weakMap 中的键来保存私有变量 </span>
<span class="token comment">// 代理对象却尝试用自身作为键获取这个值，所以是 undefined</span>
<span class="token keyword">const</span> proxyUser1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user1<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxyUser1<span class="token punctuation">.</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2、使用代理对象调用目标对象上的方法时，涉及到 this 的问题都应注意</span>
user1<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> proxyUser1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
user1<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
proxyUser1<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token comment">// 3、第一个问题解决方案</span>
<span class="token keyword">const</span> UserProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>User<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxyUser2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserProxy</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxyUser2<span class="token punctuation">.</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>3、代理与内部槽位</p> 
<p>代理与内置引用类型（例如 <em>Array</em>）的实例通常可以很好地协同，但是<strong>有些 <em>ECMAScript</em> 内置类型可能会依赖代理无法控制地机制，结果导致在代理上调用某些方法会出错</strong>。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy <span class="token keyword">instanceof</span> <span class="token class-name">Date</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
proxy<span class="token punctuation">.</span><span class="token function">getDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught TypeError: this is not a Date object.</span>
</code></pre> 
<blockquote> 
 <p>Date 类型方法的执行依赖 this 值上的内部槽位 [[NumberDate]] 。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的 get() 和 set() 操作访问到，于时代理拦截后本应转发给目标对象的方法会抛出 TypeError。</p> 
</blockquote> 
<p>简单理解：本质上跟第二点的问题时一样的。<strong>这个所谓的槽位是日期引用类型的私有变量，外部或者说开发人员无法访问</strong>。<strong>代理对象调用方法时，执行获取该私有变量的操作，但是由于此时 <em>this</em> 是代理对象，无法获取到私有变量 <em>[[NumberDate]]</em></strong>。方法无法继续执行相关操作，所以报错。调用期约 Promise 的方法也是如此。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">,</span> <span class="token string">'resolve'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> promise1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>promise<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>promise1<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
promise1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// TypeError: Method Promise.prototype.then called on incompatible receiver [object Object]</span>
<span class="token comment">// 方法Promise.prototype.then在不兼容的接收器上调用[object对象]</span>
</code></pre> 
<h3><a id="2__298"></a>2 代理捕获器与反射方法</h3> 
<p><strong>代理可以捕获 <em>13</em> 中不同的基本操作</strong>。这些操作有各自不同的<strong>反射 <em>API</em> 方法、参数、关联 <em>ECMAScript</em> 操作和不变式</strong>。同一个捕获器可以捕获几种不同的操作，但是对于同一种操作，只会有一个捕获处理程序被调用。不会存在重复捕获的情况。</p> 
<h4><a id="21_get_302"></a>2.1 get()</h4> 
<p><em><strong>get()</strong></em> 捕获器会在获取属性值的操作中被调用。对应的<strong>反射 <em>API</em> 方法</strong>为 <em><strong><code>Reflect.get()</code></strong></em>。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> myTarget <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>myTarget<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'_get'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span>id<span class="token punctuation">;</span> <span class="token comment">// '_get'</span>
</code></pre> 
<p>1、返回值</p> 
<p>返回值无限制。</p> 
<p>2、拦截的操作</p> 
<ul><li><em>proxy.property</em></li><li><em>proxy[property]</em></li><li><em>Object.create(proxy)[property]</em></li><li><em>Reflect.get(proxy, property, receiver)</em></li></ul> 
<p>3、捕获器处理程序参数</p> 
<ul><li><strong><em>target</em>：目标对象。</strong></li><li><strong><em>property</em>：引用的目标对象上的字符串键属性。</strong></li><li><strong><em>receiver</em>：代理对象或继承代理对象的对象（这个在 <em>MDN</em> 描述更具体）。</strong></li></ul> 
<p>4、捕获器不变式</p> 
<p>如果 <em><strong>target.property</strong></em> 不可写且不可配置，则处理程序的返回值必须与 <em><strong>target.property</strong></em> 匹配。如果 <em><strong>target.property</strong></em> 不可配置且 <em><strong>[[Get]]</strong></em> 特性为 <em><strong>undefined</strong></em>，处理程序的返回值也必须是 <em><strong>undefined</strong></em>。</p> 
<h4><a id="22_set_338"></a>2.2 set()</h4> 
<p><em><strong>set()</strong></em> 捕获器会在设置属性值的操作中被调用。对应的<strong>反射 <em>API</em> 方法</strong>为 <em><strong><code>Reflect.set()</code></strong></em>。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> myTarget <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>myTarget<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'_set'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token string">'tkop'</span><span class="token punctuation">;</span> <span class="token comment">// '_set'</span>
</code></pre> 
<p>1、返回值</p> 
<p>返回 <em>true</em> 表示成功；返回 <em>false</em> 表示失败，严格模式下会抛出 <em>TypeError</em>。</p> 
<p>2、拦截的操作</p> 
<ul><li><em>proxy.property = value</em></li><li><em>proxy[property] = value</em></li><li><em>Object.create(proxy)[property] = value</em></li><li><em>Reflect.set(proxy, property, value, receiver)</em></li></ul> 
<p>3、捕获器处理程序参数</p> 
<ul><li><em>target</em>：目标对象。</li><li><em>property</em>：引用的目标对象上的字符串键属性。</li><li><strong><em>value</em>：要赋给属性的新值。</strong></li><li><em>receiver</em>：接收最初赋值的对象。</li></ul> 
<p>4、捕获器不变式</p> 
<p>如果 <em>target.property</em> 不可写且不可配置，则不能修改目标属性的值。如果 <em>target.property</em> 不可配置且 <em>[[Set]]</em> 特性为 <em>undefined</em>，则不能修改目标属性的值。严格模式下，处理程序会返回 <em>false</em> 且抛出 <em>TypeError</em>。</p> 
<h4><a id="23_has_375"></a>2.3 has()</h4> 
<p><em><strong>has()</strong></em> 捕获器会在 <strong><em>in</em> 操作符</strong>中被调用。对应的反射 <em>API</em> 方法为 <em><strong><code>Reflect.has()</code></strong></em>。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> myTarget <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>myTarget<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">has</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> property</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'_has'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token string">'id'</span> <span class="token keyword">in</span> proxy<span class="token punctuation">;</span> <span class="token comment">// '_has'</span>
</code></pre> 
<p>1、返回值</p> 
<p><em>has()</em> 必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值。</p> 
<p>2、拦截的操作</p> 
<ul><li><em>property in proxy</em></li><li><em>property in Object.create(proxy)</em></li><li><em>with(proxy) { (property); }</em></li><li><em>Reflect.has(proxy, property)</em></li></ul> 
<p>3、捕获器处理程序参数</p> 
<ul><li><em>target</em>：目标对象。</li><li><em>property</em>：引用的目标对象上的字符串键属性。</li></ul> 
<p>4、捕获器不变式</p> 
<p>如果 <em>target.property</em> 存在且不可配置，则处理程序必须返回 <em>true</em>。如果 <em>target.property</em> 存在且目标对象不可扩张，则处理程序必须返回 <em>true</em>。</p> 
<h4><a id="24_defineProperty_411"></a>2.4 defineProperty()</h4> 
<p><em><strong>defineProperty()</strong></em> 捕获器会在 <em><strong>Object.defineProperty()</strong></em> 中被调用。对应的反射 <em>API</em> 方法为 <em><strong><code>Reflect.defineProperty()</code></strong></em>。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> myTarget <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>myTarget<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> descriptor</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'_defineProperty'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> <span class="token string">'id'</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">'tkop'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '_defineProperty'</span>
</code></pre> 
<p>1、返回值</p> 
<p><em>defineProperty()</em> 必须返回布尔值，表示属性是否成功定义。返回非布尔值会被转型为布尔值。</p> 
<p>2、拦截的操作</p> 
<ul><li><em>Object.defineProperty(proxy, property, descriptor)</em></li><li><em>Reflect.defineProperty(proxy, property, descriptor)</em></li></ul> 
<p>3、捕获器处理程序参数</p> 
<ul><li><em>target</em>：目标对象。</li><li><em>property</em>：引用的目标对象上的字符串键属性。</li><li><em>descriptor</em>：包含可选的数据属性或者访问器属性特征描述的对象。</li></ul> 
<p>4、捕获器不变式</p> 
<p>如果目标对象不可扩展，则无法定义属性。如果目标对象上有一个可配置的属性，则不能添加同名的不可配置属性。如果目标对象上有一个不可配置的属性，则不能添加同名的可配置属性。</p> 
<h4><a id="25_getOwnPropertyDescriptor_445"></a>2.5 getOwnPropertyDescriptor()</h4> 
<p><em><strong>getOwnPropertyDescriptor()</strong></em> 捕获器会在 <em><strong>Object.getOwnPropertyDescriptor()</strong></em> 中被调用。对应的反射 <em>API</em> 方法为 <em><strong><code>Reflect.getOwnPropertyDescriptor()</code></strong></em>。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> myTarget <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>myTarget<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> property</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'_getOwnPropertyDescriptor'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> <span class="token string">'id'</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">'tkop'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> <span class="token string">'id'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '_getOwnPropertyDescriptor'</span>
<span class="token comment">// {<!-- --></span>
<span class="token comment">//   value: 'tkop',</span>
<span class="token comment">//   writable: false,</span>
<span class="token comment">//   enumerable: false,</span>
<span class="token comment">//   configurable: false</span>
<span class="token comment">// }</span>
</code></pre> 
<p>1、返回值</p> 
<p><em>defineProperty()</em> 必须返回属性描述对象，或者属性不存在时返回 <em>undefined</em>。</p> 
<p>2、拦截的操作</p> 
<ul><li><em>Object.getOwnPropertyDescriptor(proxy, property)</em></li><li><em>Reflect.getOwnPropertyDescriptor(proxy, property)</em></li></ul> 
<p>3、捕获器处理程序参数</p> 
<ul><li><em>target</em>：目标对象。</li><li><em>property</em>：引用的目标对象上的字符串键属性。</li></ul> 
<p>4、捕获器不变式</p> 
<ul><li><em>target.property</em> 存在且不可配置，则处理程序必须返回一个表示该属性存在的对象。</li><li><em>target.property</em> 存在且可配置，则处理程序必须返回表示该属性可配置的对象。</li><li><em>target.property</em> 存在且 <em>target</em> 不可扩展，则处理程序必须返回一个表示该属性存在的对象。</li><li>如果 <em>target.property</em> 不存在且 <em>target</em> 不可扩展，则处理程序必须返回 <em>undefined</em> 表示该属性不存在。</li><li>如果 <em>target.property</em> 不存在，则处理程序不能返回表示该属性可配置的对象。</li></ul> 
<h4><a id="26_deleteProperty_489"></a>2.6 deleteProperty()</h4> 
<p><em><strong>deleteProperty()</strong></em> 捕获器会在 <strong><em>delete</em> 操作符</strong>中被调用。对应的反射 <em>API</em> 方法为 <em><strong><code>Reflect.deleteProperty()</code></strong></em>。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> myTarget <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>myTarget<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">deleteProperty</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> property</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'_deleteProperty'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">deleteProperty</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">delete</span> proxy<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '_deleteProperty'  true</span>
</code></pre> 
<p>1、返回值</p> 
<p><em>deleteProperty()</em> 必须返回布尔值，表示删除属性是否成功。返回非布尔值会被转型为布尔值。</p> 
<p>2、拦截的操作</p> 
<ul><li><em>delete proxy.property</em></li><li><em>delete proxy[property]</em></li><li><em>Reflect.deleteProperty(proxy, property)</em></li></ul> 
<p>3、捕获器处理程序参数</p> 
<ul><li><em>target</em>：目标对象。</li><li><em>property</em>：引用的目标对象上的字符串键属性。</li></ul> 
<p>4、捕获器不变式</p> 
<p>如果自有的 <em>target.property</em> 存在且不可配置，则处理程序不能删除这个属性。</p> 
<h4><a id="27_ownKeys_524"></a>2.7 ownKeys()</h4> 
<p><em><strong>ownKeys()</strong></em> 捕获器会在 <em><strong>Object.keys()</strong></em> 及类似方法中被调用。对应的反射 <em>API</em> 方法为 <em><strong><code>Reflect.ownKeys()</code></strong></em>。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> myTarget <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'tkop'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>myTarget<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">ownKeys</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'_ownKeys'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>proxy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '_ownKeys' [ 'id' ]</span>
</code></pre> 
<p>1、返回值</p> 
<p><em>ownKeys()</em> 必须返回包含字符串或者符号的可枚举对象。</p> 
<p>2、拦截的操作</p> 
<ul><li><em>Object.getOwnPropertyNames(proxy)</em></li><li><em>Object.getOwnPropertySymbols(proxy)</em></li><li><em>Object.keys(proxy)</em></li><li><em>Reflect.ownKeys(proxy)</em></li></ul> 
<p>3、捕获器处理程序参数</p> 
<ul><li><em>target</em>：目标对象。</li></ul> 
<p>4、捕获器不变式</p> 
<p>返回的可枚举对象必须包含 <em>target</em> 的所有不可配置的自有属性。如果 <em>target</em> 不可扩展，则返回可枚举对象必须准确地包含自有属性键。</p> 
<h4><a id="28_getPrototypeOf_560"></a>2.8 getPrototypeOf()</h4> 
<p><em><strong>getPrototypeOf()</strong></em> 捕获器会在 <em><strong>Object.getPrototypeOf()</strong></em> 中被调用。对应的反射 <em>API</em> 方法为 <em><strong><code>Reflect.getPrototypeOf()</code></strong></em>。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> myTarget <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>myTarget<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'_getPrototypeOf'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>proxy<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '_getPrototypeOf'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '_getPrototypeOf' true</span>
</code></pre> 
<p>1、返回值</p> 
<p><em>getPrototypeOf()</em> 必须返回对象或者 <em>null</em>。</p> 
<p>2、拦截的操作</p> 
<ul><li><em>Object.getPrototypeOf(proxy)</em></li><li><em>Reflect.getPrototypeOf(proxy)</em></li><li><em>proxy.__proto__</em></li><li><em>proxy instanceof Object</em></li><li><em>Object.prototype.isPrototypeOf(proxy)</em></li></ul> 
<p>3、捕获器处理程序参数</p> 
<ul><li><em>target</em>：目标对象。</li></ul> 
<p>4、捕获器不变式</p> 
<p>如果 <em>target</em> 不可扩展，则 <em>Object.getPrototypeOf(proxy)</em> 唯一有效的返回值就是 <em>Object.getPrototypeOf(target)</em> 的返回值。</p> 
<h4><a id="29_setPrototypeOf_596"></a>2.9 setPrototypeOf()</h4> 
<p><em><strong>setPrototypeOf()</strong></em> 捕获器会在 <em><strong>Object.setPrototypeOf()</strong></em> 中被调用。对应的反射 <em>API</em> 方法为 <em><strong><code>Reflect.setPrototypeOf()</code></strong></em>。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> myTarget <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>myTarget<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">setPrototypeOf</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> prototype</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'_setPrototypeOf'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '_setPrototypeOf'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  true</span>
</code></pre> 
<p>1、返回值</p> 
<p><em>setPrototypeOf()</em> 必须返回布尔值，表示原型赋值是否成功。返回非布尔值会被转型为布尔值。</p> 
<p>2、拦截的操作</p> 
<ul><li><em>Object.setPrototypeOf(proxy, prototype)</em></li><li><em>Reflect.setPrototypeOf(proxy, prototype)</em></li></ul> 
<p>3、捕获器处理程序参数</p> 
<ul><li><em>target</em>：目标对象。</li><li><em>prototype：target</em> 的替代原型，如果是顶级原型则为 <em>null</em>。</li></ul> 
<p>4、捕获器不变式</p> 
<p>如果 <em>target</em> 不可扩展，则唯一有效的 <em>prototype</em> 参数就是 <em>Object.getPrototypeOf(target)</em> 的返回值。</p> 
<h4><a id="210_isExtensible_634"></a>2.10 isExtensible()</h4> 
<p><em>isExtensible()</em> 捕获器会在 <em>Object.isExtensible()</em> 中被调用。对应的反射 <em>API</em> 方法为 <em><strong><code>Reflect.isExtensible()</code></strong></em>。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> myTarget <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>myTarget<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">isExtensible</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'_isExtensible'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">isExtensible</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">isExtensible</span><span class="token punctuation">(</span>proxy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '_isExtensible'  true</span>
</code></pre> 
<p>1、返回值</p> 
<p><em>isExtensible()</em> 必须返回布尔值，表示 <em>target</em> 是否可扩展。返回非布尔值会被转型为布尔值。</p> 
<p>2、拦截的操作</p> 
<ul><li><em>Object.isExtensible(proxy)</em></li><li><em>Reflect.isExtensible(proxy)</em></li></ul> 
<p>3、捕获器处理程序参数</p> 
<ul><li><em>target</em>：目标对象。</li></ul> 
<p>4、捕获器不变式</p> 
<p>如果 <em>target</em> 不可扩展，则处理程序必须返回 <em>false</em>。<br> 如果 <em>target</em> 可扩展，则处理程序必须返回 <em>true</em>。</p> 
<h4><a id="211_preventExtensions_670"></a>2.11 preventExtensions()</h4> 
<p><em>preventExtensions()</em> 捕获器会在 <em>Object.preventExtensions()</em> 中被调用。对应的反射 <em>API</em> 方法为 <em><strong><code>Reflect.preventExtensions()</code></strong></em>。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> myTarget <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>myTarget<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">preventExtensions</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'_preventExtensions'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">preventExtensions</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">preventExtensions</span><span class="token punctuation">(</span>proxy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '_preventExtensions'  true</span>
</code></pre> 
<p>1、返回值</p> 
<p><em>preventExtensions()</em> 必须返回布尔值，表示 <em>target</em> 是否成功被设置为不可扩展。返回非布尔值会被转型为布尔值。</p> 
<blockquote> 
 <p>这里自己测试使用 <em>Object.preventExtensions(proxy)</em> 返回的是不可扩展的 <em>proxy</em>（代理对象），并不是布尔值。</p> 
</blockquote> 
<p>2、拦截的操作</p> 
<ul><li><em>Object.preventExtensions(proxy)</em></li><li><em>Reflect.preventExtensions(proxy)</em></li></ul> 
<p>3、捕获器处理程序参数</p> 
<ul><li><em>target</em>：目标对象。</li></ul> 
<p>4、捕获器不变式</p> 
<p>如果 <em>Object.isExtensible(proxy)</em> 返回的是 <em>false</em>，则处理程序必须返回 <em>true</em>。</p> 
<h4><a id="212_apply_707"></a>2.12 apply()</h4> 
<p><strong><em>apply()</em> 捕获器会在调用目标函数时被调用。对应的反射 <em>API</em> 方法为 <em><code>Reflect.apply()</code></em></strong>。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">myTarget</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>myTarget<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 书中将 argunmentsList 进行扩展，个人认为非常没必要。</span>
	<span class="token comment">// 这样会使得 argumentsList 变为二维数组，不易使用</span>
    <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> thisArg<span class="token punctuation">,</span> argumentsList</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'_apply'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">Reflect</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">proxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '_apply'</span>
</code></pre> 
<p>1、返回值</p> 
<p>返回值没有限制。</p> 
<p>2、拦截的操作</p> 
<ul><li><em>proxy(…argumentsList)</em></li><li><em>proxy.call(thisArgument, …argumentsList)</em></li><li><em>proxy.apply(thisArgument, argumentsList)</em></li><li><em>Reflect.apply(target, thisArgument, argumentsList)</em></li></ul> 
<p>3、捕获器处理程序参数</p> 
<ul><li><em>target</em>：目标对象。</li><li><em>thisArg</em>：调用函数时的 <em>this</em> 参数。</li><li><em>argumentsList</em>：调用函数时的参数列表。</li></ul> 
<p>4、捕获器不变式</p> 
<p><em>target</em> 必须是一个函数对象。</p> 
<h4><a id="213_construct_746"></a>2.13 construct()</h4> 
<p><strong><em>construct()</em> 捕获器会在 <em>new</em> 操作符中被调用。对应的反射 <em>API</em> 方法为 <em><code>Reflect.construct()</code></em></strong>。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">Person</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>Person<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">construct</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> argumentsList<span class="token punctuation">,</span> newTarget</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'_construct'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> my <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">proxy</span><span class="token punctuation">(</span><span class="token string">'tkop'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '_construct'</span>
</code></pre> 
<p>1、返回值</p> 
<p><em>construct()</em> 返回值必须是一个对象。</p> 
<p>2、拦截的操作</p> 
<ul><li><em>new proxy(…argumentsList)</em></li><li><em>Reflect.construct(target, argumentsList, newTarget)</em></li></ul> 
<p>3、捕获器处理程序参数</p> 
<ul><li><em>target</em>：目标构造函数。</li><li><em>argumentsList</em>：传给目标构造函数的参数列表。</li><li><em>newTarget</em>：最初被调用的构造函数。</li></ul> 
<p>4、捕获器不变式</p> 
<p>目标对象必须可以用作构造函数。</p> 
<h3><a id="3__784"></a>3 代理模式</h3> 
<p>通过使用代理在代码中实现一些有用的编程模式。书中提到的有关代理的编程模式如下，为了方便我将所有的示例代码进行了整合。</p> 
<p><strong>跟踪属性访问</strong>：通过捕获 <em>get、set、has</em> 等操作，可以知道对象属性什么时候被访问、查询。把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象在何时何处被访问过。</p> 
<p><strong>隐藏属性</strong>：代理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举。</p> 
<p><strong>属性验证</strong>：因为所有赋值操作都会触发 <em>set()</em> 捕获器，所以可以根据所赋的值决定是允许赋值还是拒绝赋值。</p> 
<p><strong>函数与构造函数参数验证</strong>：跟保护和验证对象属性类似，也可以对函数和构造函数参数进行审查。可以让函数只接收某类型的参数。</p> 
<p><strong>数据绑定与可观察对象</strong>：通过代理可以把运行时本不相关的部分联系到一起。例如可以将一个被代理的类绑定到一个全局实例集合，所有创建的实例都被添加到这个集合中。又例如把一个被代理的数组绑定到一个事件分派程序，代理的数组每次插入（修改）数据项时都会发送消息。</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 这里将数组视为目标对象（数组也是 Object 数据类型）</span>
<span class="token keyword">const</span> targetArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">301</span><span class="token punctuation">,</span> <span class="token number">302</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 事件分派程序，每次插入新值时都会发送消息</span>
<span class="token keyword">function</span> <span class="token function">emit</span><span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> proxyArry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>targetArray<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 跟踪属性访问</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Getting </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>property<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 隐藏属性</span>
        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>property<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">undefined</span> <span class="token operator">:</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Setting </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>property<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 属性验证</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">User</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> setResult <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 数据绑定与可观察对象</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>setResult<span class="token punctuation">)</span> <span class="token function">emit</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> setResult<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">has</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> property</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 隐藏属性</span>
        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>property<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token boolean">false</span> <span class="token operator">:</span> Reflect<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> userList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> proxyUser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>User<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">construct</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> argumentsList</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 构造函数参数验证</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> argumentsList<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token string">'The name must be a string'</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">const</span> user <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 数据绑定与可观察对象</span>
        userList<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> user<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 构造函数参数验证</span>
<span class="token keyword">const</span> user1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">proxyUser</span><span class="token punctuation">(</span><span class="token string">'user1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 构造函数参数验证（参数是一个数组会报错）</span>
<span class="token comment">// const user2 = new proxyUser(userList);</span>
<span class="token comment">// 数据绑定与可观察对象</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>userList<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 属性验证、数据绑定与可观察对象（会执行 emit() 输出 user1）</span>
proxyArry<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> user1<span class="token punctuation">;</span>
<span class="token comment">// 这个不会添加成功因为只能添加User类型的对象数据</span>
proxyArry<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">404</span><span class="token punctuation">;</span>
<span class="token comment">// 跟踪属性访问</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxyArry<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxyArry<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 隐藏属性</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxyArry<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 需要注意的是这里因为隐藏了索引为 0 和 1 的两个元素。</span>
<span class="token comment">// 所以在获取数组的 length 属性时得到的是错误的值，使用 push 的话会报错</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxyArry<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> user3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">proxyUser</span><span class="token punctuation">(</span><span class="token string">'user3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// TypeError: 'set' on proxy: trap returned falsish for property 'length'</span>
proxyArry<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>user3<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/28904fb94dd159a02d991870ffa0f8b2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ES6 中的类（class）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f6c9b2812e940a972b36ea3c552ba8b3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Doris-1.2.0升级到Doris-1.2.4</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>