<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java split()方法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java split()方法" />
<meta property="og:description" content="今天是圣诞节,我是中国人,无视圣诞节。
文章可能有点长，看下来必定有所收获。
没有学过正则表达式的去b站看,一个半小时应该可以看完,要看请点这里
这是必备的前置技能，不懂得话没法真正明白split用法
方法1:split(String regex)
split()方法:分割字符串,参数regex称为分割符,可以使用正则表达式来表示
public String[] split(String regex) {
return split(regex, 0);
}
1
2
3
入门案例1
分割符可以是任意字母,符号,数字,字符串等等,这个基本都会
@Test public void splitDemo1(){ String str= &#34;1a2&#34;; String[] split = str.split(&#34;a&#34;); //split:{&#34;1&#34;,&#34;2&#34;} for (int i = 0; i &lt; split.length; i&#43;&#43;) { System.out.println(split[i]); } } 1
2
3
4
5
6
7
8
9
运行结果
1
2
1
2
注意:String类型是不可变的!分隔符会把字符串拆成若干个子字符串,然后生成一个String数组
入门案例2
分割符可以用正则表达式来表示
@Test
public void splitDemo2(){
String str= “a33b444c555d”;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ccefb8ff6628a4047c759c88f1a7510d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-16T15:13:08+08:00" />
<meta property="article:modified_time" content="2021-11-16T15:13:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java split()方法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>今天是圣诞节,我是中国人,无视圣诞节。<br> 文章可能有点长，看下来必定有所收获。<br> 没有学过正则表达式的去b站看,一个半小时应该可以看完,要看请点这里<br> 这是必备的前置技能，不懂得话没法真正明白split用法</p> 
<p>方法1:split(String regex)<br> split()方法:分割字符串,参数regex称为分割符,可以使用正则表达式来表示</p> 
<p>public String[] split(String regex) {<!-- --><br> return split(regex, 0);<br> }<br> 1<br> 2<br> 3<br> 入门案例1<br> 分割符可以是任意字母,符号,数字,字符串等等,这个基本都会</p> 
<pre><code>@Test
public void splitDemo1(){
    String str= "1a2";
    String[] split = str.split("a");
    //split:{"1","2"}
    for (int i = 0; i &lt; split.length; i++) {
        System.out.println(split[i]);
    }
}
</code></pre> 
<p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 运行结果</p> 
<p>1<br> 2<br> 1<br> 2<br> 注意:String类型是不可变的!分隔符会把字符串拆成若干个子字符串,然后生成一个String数组</p> 
<p>入门案例2<br> 分割符可以用正则表达式来表示</p> 
<p>@Test<br> public void splitDemo2(){<!-- --><br> String str= “a33b444c555d”;<br> //正则表达式中\d+表示一个或多个数字,java中\表示一个普通<br> //String[] split = str.split(Pattern.compile("\d+").toString());<br> //两种写法都是一样的,下面写法简洁<br> String[] split = str.split("\d+");<br> for (int i = 0; i &lt; split.length; i++) {<!-- --><br> System.out.println(split[i]);<br> }<br> }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 运行结果</p> 
<p>a<br> b<br> c<br> d<br> 1<br> 2<br> 3<br> 4<br> 入门案例3<br> 正则表达式篇中讲过,正则表达式中有一些特殊的字符,这些字符本身有特殊含义,加了\后表示仅匹配字符本身</p> 
<p>java中两个反斜杠才表示一个\</p> 
<p>@Test<br> public void splitDemo3(){<!-- --><br> String str= “aaa|bbb|ccc”;<br> //使用|作为分隔符,其余特殊字符同理<br> String[] split = str.split("\|");<br> for (int i = 0; i &lt; split.length; i++) {<!-- --><br> System.out.println(split[i]);<br> }<br> }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 运行结果</p> 
<p>aaa<br> bbb<br> ccc<br> 1<br> 2<br> 3<br> 入门案例4<br> 分隔符可以有多个,用|隔开,|分支结构:左右两边表达式之间"或"关系,匹配左边或者右边<br> 这是属于上篇的内容,这里复习一下。正则的语法规则可以在这里灵活运用</p> 
<p>@Test<br> public void splitDemo4(){<!-- --><br> String str= “aaa,bbb#ccc”;<br> //使用,和#分割字符串<br> String[] split = str.split(",|#");<br> for (int i = 0; i &lt; split.length; i++) {<!-- --><br> System.out.println(split[i]);<br> }<br> }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 运行结果</p> 
<p>aaa<br> bbb<br> ccc<br> 1<br> 2<br> 3<br> 分隔符三个特殊位置<br> 入门案例的分隔符都是在字符串中间,非常好切割,但是如果出现以下任意其一,该怎么分割?</p> 
<p>1.字符串开头有分隔符<br> 2.分隔符相互紧挨着<br> 3.字符串最尾部有分割符</p> 
<p>总结:<br> 字符串开头出现的分隔符将分隔出一个空字符串以及其余部分的正常分隔<br> 字符串最尾部出现的分隔符,末尾会分割出一个空字符串<br> 分隔符紧挨着,分隔符之间也会分割出一个空字符串</p> 
<p>特殊案例1<br> 分隔符紧挨着,分隔符之间也会分割出一个空字符串</p> 
<p>@Test<br> public void demo(){<!-- --><br> String str= “19997”;<br> String[] split = str.split(“9”);<br> for (int i = 0; i &lt; split.length; i++) {<!-- --><br> System.out.println(split[i]);<br> }<br> }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 两个9之间会分割出一个空字符串,所以会出现两个空字符串,前面的1和7正常分割</p> 
<p>特殊案例2<br> 字符串开头出现的分隔符将分隔出一个空字符串以及其余部分的正常分隔<br> 字符串最尾部出现的分隔符,其余部分正常分隔,末尾会分割出一个空字符串</p> 
<pre><code>@Test
public void demo(){
    String str= "yky";
    String[] split = str.split("y");
    System.out.println(split.length);
    System.out.println(Arrays.toString(split));
}
</code></pre> 
<p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 运行结果:</p> 
<p>2<br> [, k]<br> //按照我们的结论,返回的数组应该是["",k,""]才对<br> 1<br> 2<br> 3<br> 其实不是结论错了,而是参数limit的问题,接下来<br> 点进去split方法查看,发现调用的是另一个重载方法split(String regex, int limit)<br> 分割时末尾的字符串被丢弃了</p> 
<p>public String[] split(String regex) {<!-- --><br> return split(regex, 0); <br> //3.如果 n = 0,匹配到多少次就切割多少次,数组可以是任何长度,并且结尾空字符串将被丢弃。<br> }<br> 1<br> 2<br> 3<br> 4<br> 方法2:split(String regex,int limit)<br> public String[] split(String regex) {<!-- --><br> return split(regex, 0);<br> }<br> 1<br> 2<br> 3<br> 可以看出只填一个正则表达式的话,limit默认是0,regex表示正则表达式,limit参数控制分割的次数</p> 
<p>limit用法:<br> 1.如果 limit &gt; 0,(从左到右)最多分割 n - 1 次,数组的长度将不会大于 n,结尾的空字符串不会丢弃</p> 
<p>2.如果 limit &lt; 0,匹配到多少次就分割多少次,而且数组可以是任何长度。结尾的空字符串不会丢弃</p> 
<p>3.如果 limit = 0,匹配到多少次就分割多少次,数组可以是任何长度,并且结尾空字符串将被丢弃。</p> 
<p>也就是说,使用split方法时,如果只填一个正则表达式,结尾空字符串将被丢弃</p> 
<p>看看源码大概怎么说的</p> 
<pre><code>   ArrayList&lt;String&gt; matchList = new ArrayList&lt;&gt;();
   //......
    int resultSize = matchList.size();
    if (limit == 0)
        while (resultSize &gt; 0 &amp;&amp; matchList.get(resultSize-1).equals(""))
            resultSize--;
		String[] result = new String[resultSize];
	//...
</code></pre> 
<p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 先从ArrayList的长度开始遍历,如果发现是空字符串,则长度-1,该长度也等于字符串数组的长度</p> 
<p>进阶案例:<br> limit&gt;0限制分割次数<br> 1.如果 limit &gt; 0,(从左到右)最多分割 limit - 1 次,数组的长度将不会大于limit,结尾的空字符串不会丢弃</p> 
<p>limit=1,分割0次,即不分割,将原字符串装进数组并返回</p> 
<p>limit如果太大超出了匹配次数,匹配到多少次就分割多少次</p> 
<p>String[] split = “abc”.split(“b”,999); //limit=999,但是b只匹配到一次,所以只能分割一次<br> //split:{“a”,“c”}</p> 
<p>String[] split2 = “abc”.split(“b”,1); //不切割<br> //split2:{“abc”}<br> 1<br> 2<br> 3<br> 4<br> 5<br> 结尾的空字符串不会丢弃</p> 
<pre><code>@Test
public void demo1(){
    //limit=3,切割2次,末尾会分割出一个""空字符串
    String[] split = "abcb".split("b",3);
        System.out.println(split.length);	//数组长度是3
    //split:{"a","c",""}
}
</code></pre> 
<p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> limit&lt;0不限制分割次数<br> 2.如果 limit &lt; 0,匹配到多少次就分割多少次,而且数组可以是任何长度。结尾的空字符串不会丢弃</p> 
<p>limit=0不限制分割次数<br> 这个是最常用的,要注意结尾的空字符串将会丢弃</p> 
<p>使用o取切割"boo:and:foo",分割后得到数组的长度是3,两个空字符串被丢弃</p> 
<p>特殊案例3(字符串不包含分隔符)<br> 当字符串不包含分隔符时,返回数组只包含一个元素(该字符串本身)</p> 
<p>@Test<br> public void demo2(){<!-- --><br> String str= “abcde”;<br> String[] split = str.split(“f”,-1);<br> //split:{“abcde”}<br> System.out.println(split.length); //1<br> }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 特殊案例4(字符串只含有分隔符本身)<br> 字符串只含有分隔符本身,这种切割没啥意义,但还是测试下吧</p> 
<p>切割出三个空字符串,开头结尾,相连的地方各一个空字符串</p> 
<p>limit=0时,空字符会被丢弃,返回空数组,长度为0</p> 
<p>无聊案例1(切割空字符串)<br> 经过测试,分隔符是空字符串""还是任意正则表达式,都会返回带空字符串的数组(空字符串也是字符串)</p> 
<p>无聊案例2(分隔符是空字符串)<br> 这种切法非常奇怪,字符串的最末尾会分割出一个"",要去掉的话limit=0即可</p> 
<p>@Test<br> public void demo2(){<!-- --><br> String str= “abc”;<br> String[] split = str.split("",-1);<br> System.out.println(split.length);<br> }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 练习<br> 截取自jdk源码,Regex分隔符,limit取值,Result截取后的数组</p> 
<p>字符串 “boo:and:foo”</p> 
<p>能看懂说明split已经理解了</p> 
<p>知识补充:<br> 零宽断言(预搜索)<br> split里还可以使用零宽断言(预搜索)</p> 
<p>@Test<br> public void splitDemo(){<!-- --><br> //分割符是#,但是只要#后面跟123的那个#,其余#不要<br> String str= “22222#123#2234”;<br> String[] split = str.split("#(?=123)");<br> for (int i = 0; i &lt; split.length; i++) {<!-- --><br> System.out.println(split[i]);<br> }<br> }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 运行结果:</p> 
<p>22222<br> 123#2234<br> 1<br> 2<br> 字符边界^$<br> split里还可以使用字符边界^$</p> 
<p>^匹配行首,$匹配行尾,字符边界匹配时是零宽的,匹配的是位置</p> 
<p>@Test<br> public void demo1(){<!-- --><br> //\r\n在window时回车+换行的意思<br> String str = “#第一章\r\n#第二章”;<br> Pattern pattern =Pattern.compile("^#",Pattern.MULTILINE);<br> String[] split = str.split(pattern.toString(),-1);<br> //String[] split = str.split("^#",-1);<br> for (int i = 0; i &lt; split.length; i++) {<!-- --><br> System.out.println(split[i]);<br> }<br> }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 返回的字符串数组是{"",“第一章\r\n#第二章”}<br> 分隔符在行首会分割出一个空串"",其余部分正常分割。但是第二个#没有分割,这个出乎意料。</p> 
<p>Pattern pattern =Pattern.compile("^#",Pattern.MULTILINE);<br> 这个上篇正则表达式讲过,pattern 是正则表达式的编译形式,同时开启多行模式<br> pattern.toString() 是正则表达式的字符串形式</p> 
<p>我猜想:问题一定出在pattern.toString(),既然是字符串形式</p> 
<p>Pattern pattern =Pattern.compile("^#",Pattern.MULTILINE);<br> String[] split = str.split(pattern.toString(),-1);</p> 
<p>这两行代码我直接写成一行就行了String[] split = str.split("^#",-1);</p> 
<p>开启多行模式似乎不是用在这里的。我只想切割每行行首的#,其余的#不想切割,那怎么开启多行模式?</p> 
<p>我仔细想了一下,我上面用的都是String类的split方法,跟Pattern类的多行模式扯不上边啊。<br> 这么一想,有道理,去Pattern类看看有没有类似的方法</p> 
<p>不光有,还有两。用法肯定是类似的,但是CharSequence是啥?没见过</p> 
<p>public final class String<br> implements java.io.Serializable, Comparable, CharSequence {<!-- --><br> 1<br> 2<br> idea通过快捷键crtl + alt + B看接口的实现关系<br> 我发现String类实现了这个CharSequence接口,那参数的意思是输入一个String字符串,而匹配规则已经写在Pattern类里了。</p> 
<pre><code>@Test
public void demo1(){
    Pattern pattern =Pattern.compile("^#",Pattern.MULTILINE);
    //\r\n在window时回车+换行的意思
    String str = "#第一章\r\n#第二章\r\n#第三章";
    String[] split = pattern.split(str, -1);
    System.out.println("数组的长度是:"+split.length);
    //split:{"","第一章","第二章","第三章"}
    for (int i = 0; i &lt; split.length; i++) {
        System.out.print(split[i]);
    }
}
</code></pre> 
<p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 运行结果:</p> 
<p>数组的长度是:4<br> 第一章<br> 第二章<br> 第三章<br> 1<br> 2<br> 3<br> 4<br> 开启多行模式的确有效,数组第一个位置是空字符串,打印时不会打出来,那么是怎么判断行首行尾的位置?<br> 是按照空格,制表符,换行,回车判断的?所以我做了个实验<br> 字符串分别加了以\r,\n,\r\n,空格,\t<br> 再根据数组的长度,就知道分隔了多少次,从而知道判断行首的标准是什么。<br> 如果是4,意味着该字符用来判断行首行尾<br> 如果是2,说明只分隔了一次,字符串最前面分隔了一次</p> 
<p>@Test<br> public void demo2(){<!-- --><br> Pattern pattern =Pattern.compile("^#",Pattern.MULTILINE);<br> String str = “#第一章\r#第二章\r#第三章”;<br> String str2 = “#第一章\n#第二章\n#第三章”;<br> String str3 = “#第一章\r\n#第二章\r\n#第三章”;<br> String str4 = “#第一章 #第二章 #第三章”;<br> String str5 = “#第一章\t#第二章\t#第三章”;<br> String[] split = pattern.split(str, -1);<br> String[] split2 = pattern.split(str2, -1);<br> String[] split3 = pattern.split(str3, -1);<br> String[] split4 = pattern.split(str4, -1);<br> String[] split5 = pattern.split(str5, -1);<br> System.out.println(“str数组的长度是:”+split.length);<br> System.out.println(“str2数组的长度是:”+split2.length);<br> System.out.println(“str3数组的长度是:”+split2.length);<br> System.out.println(“str4数组的长度是:”+split4.length);<br> System.out.println(“str5数组的长度是:”+split5.length);</p> 
<p>}<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 运行结果</p> 
<p>str数组的长度是:4<br> str2数组的长度是:4<br> str3数组的长度是:4<br> str4数组的长度是:2<br> str5数组的长度是:2<br> 1<br> 2<br> 3<br> 4<br> 5<br> 结论:除了字符串开头是行首,\r,\n,\r\n后面都可以当成行首</p> 
<p>$表示匹配字符串结束的地方,开启多行模式后,每一行都相当于一个字符串</p> 
<p>\r,\n,\r\n前面,和字符串最末尾都可以当成行尾被匹配到</p> 
<p>@Test<br> public void demo3(){<!-- --><br> Pattern pattern =Pattern.compile(“章$”,Pattern.MULTILINE);<br> String str = “#第一章\r\n#第二章\r\n#第三章”;<br> String[] split = pattern.split(str, -1);<br> System.out.println(“数组的长度是:”+split.length);<br> for (int i = 0; i &lt; split.length; i++) {<!-- --><br> System.out.print(split[i]);<br> }<br> }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 运行结果</p> 
<p>数组的长度是:4<br> #第一<br> #第二<br> #第三<br> 1<br> 2<br> 3<br> 4<br> 学以致用<br> 写这么多不是白写的,真正使用的地方到了,也是我研究正则表达式一天的目的:整理md文档</p> 
<p>读写文件用到io流,这里推荐hutool工具包,方便快捷,先导入依赖</p> cn.hutool hutool-all 5.5.4 1 2 3 4 5 代码: 
<pre><code>/**
 *
 * @param src  文件的来源
 * @param dest  文件目的地
 */
public void mdTitleClean(String src,String dest){
    //默认UTF-8编码,可以在构造中传入第二个参数做为编码
    //输入流:将md文档一次性读进内存,返回一个String
    FileReader fileReader = new FileReader(src);
    String result = fileReader.readString();

    StringBuilder sb=new StringBuilder();
    //输出流,将字符串打印到文件中,该流使用完会自动关闭
    FileWriter writer = new FileWriter(dest);

    //md标题一共有6级,#空格后面写标题,我们想匹配到这个位置,所以是(?=(^#{1,6}\s+))
    Pattern p =Pattern.compile("^\\r?\\n(?=(^#{1,6}\\s+))",Pattern.MULTILINE);
    String[] split = p.split(result);
    for (int i = 0; i &lt;split.length ; i++) {
        if (split[i].equals("")){
            continue;
        }
        //先清除字符串前后的所有空格,空行,再加4个\r\n,相当于每个标题之间空三行
        sb.append(split[i].trim()).append("\r\n\r\n\r\n\r\n");
    }
    writer.write(sb.toString());
    System.out.println(sb.toString());
}
</code></pre> 
<p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24<br> 25<br> 26<br> 27<br> 28<br> 代码不难,只需要解释两行</p> 
<p>Pattern p =Pattern.compile("\r?\n(?=(#{1,6}\s+))",Pattern.MULTILINE);</p> 
<p>用到了前面讲的零宽断言字符边界</p> 
<p>^\r?\n表示字符串开头是换行符<br> (?=(^#{1,6}\s+)) 表示匹配开头是# ,## ,### 的位置,即一级标题-六级标题<br> 最终的效果是以一级标题-六级标题前面的\r\n作为分隔符,把整个文档按照标题进行隔开。<br> sb.append(split[i].trim()).append("\r\n\r\n\r\n\r\n");</p> 
<p>隔开之后先清除前后空格,再拼接4个\r\n(统一格式),表示每个标题之间空三行</p> 
<p>最终效果图<br> 以后写md文档就不用太关注格式了,写完用代码整理一下即可,注意在文档中使用#时,不要放在开头就行了。</p> 
<p>补充一点中文标点符号替换成英文的,要使用io流,记得导hutool工具包依赖</p> 
<p>/**</p> 
<ul><li>英文标点符号替换成中文的</li><li><li>@param str</li><li>@return<br> */<br> public String punctuationMarksAlter(String str) {<!-- --><br> str = str.replaceAll("(", “(”)<br> .replaceAll(")", “)”)<br> .replaceAll(";", “;”)<br> .replaceAll("’", “’”)<br> .replaceAll("’", “’”)<br> .replaceAll(""", “”")<br> .replaceAll(""", “”")<br> .replaceAll(":", “:”)<br> .replaceAll("?", “?”)<br> .replaceAll("[", “[”)<br> .replaceAll("]", “]”)<br> .replaceAll("!", “!”)<br> .replaceAll(".", “.”)<br> .replaceAll(",", “,”);<br> return str;<br> }</li></ul> 
<p>/**<br> *</p> 
<ul><li> <p>@param src 文件的来源</p> </li><li> <p>@param dest 文件目的地<br> */<br> public void mdClean(String src,String dest){<!-- --><br> //默认UTF-8编码,可以在构造中传入第二个参数做为编码<br> FileReader fileReader = new FileReader(src);<br> String result = fileReader.readString();</p> <p>StringBuilder sb=new StringBuilder();<br> FileWriter writer = new FileWriter(dest);</p> <p>//md标题一共有6级,#空格后面写标题内容,我们想匹配到这个位置,所以是(?=(^#{1,6}\s+))<br> Pattern p =Pattern.compile("<sup>\r?\n(?=(</sup>#{1,6}\s+))",Pattern.MULTILINE);<br> String[] split = p.split(result);<br> for (int i = 0; i &lt;split.length ; i++) {<!-- --><br> if (split[i].equals("")){<!-- --><br> continue;<br> }<br> //先清除字符串前后的所有空格,空行,再加4个\r\n,相当于每个标题之间空三行<br> sb.append(split[i].trim()).append("\r\n\r\n\r\n\r\n");<br> }<br> //中文标点换成英文的<br> String string = this.punctuationMarksAlter(sb.toString());<br> writer.write(string);<br> }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24<br> 25<br> 26<br> 27<br> 28<br> 29<br> 30<br> 31<br> 32<br> 33<br> 34<br> 35<br> 36<br> 37<br> 38<br> 39<br> 40<br> 41<br> 42<br> 43<br> 44<br> 45<br> 46<br> 47<br> 48<br> 49<br> 50<br> 51<br> 逻辑可以自行完善<br> 如果把文档看成一个String字符串，那么就可以写java代码来自动整理md文档的格式了，而不用手动调格式，节约时间精力，更多的时间就可以花在学习上。</p> </li></ul> 
<p>split讲解到此为此,希望有所收获~<br> 上篇正则表达式的笔记我已经写好了,但是md图片粘贴在csdn上太麻烦,有时间再弄了。没有学过正则表达式的去b站看,一个半小时应该可以看完,要看请点这里</p> 
<p>从圣诞中午12点研究现在的时间是:2020年12月26日01:34:52,虽累也值得</p> 
<p>2020年12月28日19:34:21 开始学习jvm中篇[来自b站尚硅谷免费视频]<br> 自从学了正则表达式之后，可以很快速地替换文本<br> 比如下面是笔记的标题</p> 
<p>第十八章：Class文件结构</p> 
<p>01-JVM中篇内容概述</p> 
<p>02-字节码文件的跨平台性<br> 03-了解Java的前端编译器<br> 04-透过亨节码看代码执行细节举例1<br> 05-话过字节码看代码执行细节举例2<br> 06-透过字节码看代码执行细节举例3<br> 07-解读Class文件的三种方式<br> 08-Class文件本质和内部数据类型<br> 09-Class文件内部结构概述<br> 10-字节码数据保存到excel中的操作<br> 11-Class文件的标识:魔数<br> 12-Class文件版本号</p> 
<p>13-常量池概述<br> 14-常量池计数器<br> 15-常量池表中的字面量和符号引用<br> 16-解析得到常量池中所有的常量<br> 17-常量池表数据的解读1<br> 18-常量池表数据的解读2<br> 19-常量池表项数据的总结<br> 20-访问标识<br> 21-类索引、父类索引、接口索引集合<br> 22-字段表集合的整体理解<br> 23-字段表数据的解读<br> 24-方法表集合的整体理解<br> 25-方法表数据的解读<br> 26-屈性表集合的整理理解<br> 27-方法中Code属性的解读<br> 28-LineNumberTable和LocalVariableTable属性的解读<br> 29-SourceFile属性的解读<br> 30-Class文件结构的小结<br> 31-javac -g操作的说明<br> 32-javap主要参数的使用<br> 33-javap解析得到的文件结构的解读<br> 34-javap使用小结</p> 
<p>第十九章：字节码指令集与解析举例</p> 
<p>35-字节码指令集的概述<br> 36-指令与数据类型的关系及指令分类<br> 37-加载与存储指令概述<br> 38-再谈操作数栈与局部变量表<br> 39-局部变量压栈指令<br> 40-常量入栈指令<br> 41-出栈装入局部变量表指令<br> 42-算术指令及举例<br> 43-算法指令再举例<br> 44-彻底搞定++运算符<br> 45-比较指令的说明<br> 46-宽化类型转换</p> 
<p>47-窄化类型转换<br> 48-创建类和数组实例的指令<br> 49-字段访问指令<br> 50-数组操作指令<br> 51-类型检查指令<br> 52-方法调用指令<br> 53-方法返回指令<br> 54-操作数栈管理指令<br> 55-比较指令<br> 56-条件跳转指令<br> 57-比较条件跳转指令<br> 58-多条件分支跳转指令</p> 
<p>59-无条件跳转指令<br> 60-抛出异常指令<br> 61-异常处理与异常表<br> 62-同步控制指令</p> 
<p>第二十章：类的加载过程详解</p> 
<p>63-类的生命周期概述<br> 64-加载完成的操作及二进制的获取方式<br> 65-类模型与Class实例的位置<br> 66-链接之验证环节<br> 67-链接之准备环节<br> 68-链接之解析环节<br> 69-初始化过程与类初始化方法<br> 70-初始化阶段赋值与准备阶段赋值的对比<br> 71-类初始化方法clinit(的线程安全性<br> 72-何为类的主动使用和被动使用<br> 73-类的主动使用1<br> 74-类的主动使用2</p> 
<p>75-类的主动使用3<br> 76-类的主动使用4<br> 77-类的被动使用<br> 78-类的使用介绍<br> 79-类的卸载相关问题</p> 
<p>第二十一章：再谈类的加载器</p> 
<p>80-类加载器的概述<br> 81-命名空间与类的唯一性<br> 82-类的加载器的分类<br> 83-引导类加载器的说明<br> 84-扩展类加载器的说明<br> 85-系统类加载器的说明<br> 86-用户自定义类加载器的说明<br> 87-测试不同类使用的类加载器<br> 88-ClassLoader与Launcher的初步剖析<br> 89-ClassLoader的源码解析1<br> 90-ClassLoader的源码解析2<br> 91-ClassLoader子类的结构剖析</p> 
<p>91-ClassLoader子类的结构剖析<br> 92-双亲委派机制的优势与劣势<br> 93-三次双亲委派机制的破坏<br> 94-热替换的代码实现<br> 95-沙箱安全机制<br> 96-自定义类加载器的好处和应用场景<br> 97-自定义类加载器的代码实现<br> 98-Java9的新特性<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24<br> 25<br> 26<br> 27<br> 28<br> 29<br> 30<br> 31<br> 32<br> 33<br> 34<br> 35<br> 36<br> 37<br> 38<br> 39<br> 40<br> 41<br> 42<br> 43<br> 44<br> 45<br> 46<br> 47<br> 48<br> 49<br> 50<br> 51<br> 52<br> 53<br> 54<br> 55<br> 56<br> 57<br> 58<br> 59<br> 60<br> 61<br> 62<br> 63<br> 64<br> 65<br> 66<br> 67<br> 68<br> 69<br> 70<br> 71<br> 72<br> 73<br> 74<br> 75<br> 76<br> 77<br> 78<br> 79<br> 80<br> 81<br> 82<br> 83<br> 84<br> 85<br> 86<br> 87<br> 88<br> 89<br> 90<br> 91<br> 92<br> 93<br> 94<br> 95<br> 96<br> 97<br> 98<br> 99<br> 100<br> 101<br> 102<br> 103<br> 104<br> 105<br> 106<br> 107<br> 108<br> 109<br> 110<br> 111<br> 112<br> 113<br> 114<br> 115<br> 116<br> 我们想要在每一行的前面加个#，意思是一级标题，就不用自己手动加了，使用正则表达式轻而易举的事</p> 
<p>效果图</p> 
<p>代码：用之前的代码随便改了下<br> 主要是正则表达式的匹配规则<br> 分隔符是(\r?\n)(?=[\d第])<br> 使用hutool工具包只是为了省几行代码，其实可以用传统io流，就不用导包了</p> 
<p>import cn.hutool.core.io.file.FileReader;<br> import cn.hutool.core.io.file.FileWriter;<br> import org.junit.Test;</p> 
<p>import java.util.Arrays;<br> import java.util.Scanner;<br> import java.util.regex.Pattern;</p> 
<p>public class Test2 {<!-- --><br> public static void main(String[] args) {<!-- --><br> // String src =“D:\太阳路\正则表达式\正则表达式.md”;<br> //String dest =“D:\workspace\jvm\chapter05\src\main\java\c.md”;<br> Scanner scanner = new Scanner(System.in);<br> System.out.println(“请输入文件的全路径:”);<br> String src = scanner.next();<br> System.out.println(“请输入文件的保存路径:”);<br> String dest = scanner.next();<br> new Test2().mdClean(src,dest);<br> }<br> /**<br> * 英文标点符号替换成中文的<br> *<br> * @param str<br> * @return<br> */<br> public String punctuationMarksAlter(String str) {<!-- --><br> str = str.replaceAll("（", “(”)<br> .replaceAll("）", “)”)<br> .replaceAll("；", “;”)<br> .replaceAll("‘", “’”)<br> .replaceAll("’", “’”)<br> .replaceAll("“", “”")<br> .replaceAll("”", “”")<br> .replaceAll("：", “:”)<br> .replaceAll("？", “?”)<br> .replaceAll("【", “[”)<br> .replaceAll("】", “]”)<br> .replaceAll("！", “!”)<br> .replaceAll("．", “.”)<br> .replaceAll("，", “,”);<br> System.out.println(“标点符号替换完毕”);<br> return str;<br> }</p> 
<pre><code>/**
 *
 * @param src  文件的来源
 * @param dest  文件目的地
 */
public void mdClean(String src,String dest){
    //默认UTF-8编码，可以在构造中传入第二个参数做为编码
    //hutool工具包，读取文件到String中
    FileReader fileReader = new FileReader(src);
    String result = fileReader.readString();

    //输出流
    StringBuilder sb=new StringBuilder();
    FileWriter writer = new FileWriter(dest);

    //md标题一共有6级，#空格后面写标题内容，我们想匹配到这个位置，所以是(?=(^#{1,6}\s+))
</code></pre> 
<p>// Pattern p =Pattern.compile("<sup>\r?\n(?=(</sup>#{1,6}\s+))",Pattern.MULTILINE);<br> Pattern p =Pattern.compile("(\r?\n)(?=[\d第])",Pattern.MULTILINE);<br> String[] split = p.split(result);<br> for (int i = 0; i &lt;split.length ; i++) {<!-- --><br> if (split[i].equals("")){<!-- --><br> //如果是空字符串，什么都不处理<br> continue;<br> }<br> //先清除字符串前后的所有空格，空行，再加4个\r\n，相当于每个标题之间空三行<br> if (i!=split.length-1){<!-- --><br> sb.append("# “).append(split[i].trim()).append(”\r\n\r\n\r\n\r\n");<br> }else {<!-- --><br> //文章最后一行不需要空空行<br> sb.append("# ").append(split[i].trim());<br> }<br> }<br> System.out.println(“文档标题的格式整理完毕！”);<br> //中文标点换成英文的<br> String string = this.punctuationMarksAlter(sb.toString());<br> writer.write(string);<br> }<br> }</p> 
<p>————————————————<br> 版权声明：本文为CSDN博主「一只光头猿」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：https://blog.csdn.net/qq_41740883/article/details/111696866</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7ef7126ddd625bd8f0a93226954035ec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringCloud中Service类注入同服务下(@Feign)api接口不走http的解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/45ce314a783de52ecf1412a58dd05344/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux(centOS6) 安装Mysql 5.6.19数据库步骤、 问题以及相应的解决办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>