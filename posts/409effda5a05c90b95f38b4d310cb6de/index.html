<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>为什么前端数值精度会丢失?(BigInt解决办法) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="为什么前端数值精度会丢失?(BigInt解决办法)" />
<meta property="og:description" content="相信各位前端小伙伴在日常工作中不免会涉及到使用 JavaScript 处理 数值 相关的操作，例如 数值计算、保留指定小数位、接口返回数值过大 等等，这些操作都有可能导致原本正常的数值在 JavaScript 中确表现得异常（即 精度丢失）。
精度丢失场景 浮点数的计算 1、加法和减法
0.1 &#43; 0.2 // 结果为 0.30000000000000004 0.3 - 0.1 // 结果为 0.19999999999999996 // 这是因为浮点数的二进制表示无法准确表示某些十进制小数，导致计算结果存在微小的误差。 2、乘法和除法
0.1 * 0.2 // 结果为 0.020000000000000004 0.3 / 0.1 // 结果为 2.9999999999999996 // 在进行乘法和除法时，浮点数计算结果的精度问题更为突出，可能会产生更大的误差。 3、比较运算
0.1 &#43; 0.2 === 0.3 // 结果为 false // 直接比较浮点数可能会导致不准确的结果，因为计算结果的微小误差可能使它们不完全相等。 超过最值 所谓 超过最值（最大、最小值） 指的是超过了 Number.MIN_SAFE_INTEGER（- 9007199254740991），即 &#43;（2^53 – 1） 或 Number.MAX_SAFE_INTEGER（&#43; 9007199254740991），即 -（2^53 – 1） 范围的值，项目中最常见的就是如下几种情况：1" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/409effda5a05c90b95f38b4d310cb6de/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-31T10:41:43+08:00" />
<meta property="article:modified_time" content="2023-10-31T10:41:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">为什么前端数值精度会丢失?(BigInt解决办法)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        相信各位前端小伙伴在日常工作中不免会涉及到使用 JavaScript 处理 数值 相关的操作，例如 <strong>数值计算、保留指定小数位、接口返回数值过大</strong> 等等，这些操作都有可能导致原本正常的数值在 JavaScript 中确表现得异常（即 精度丢失）。</p> 
<p></p> 
<h3><strong>精度丢失场景</strong></h3> 
<h4>浮点数的计算</h4> 
<p><strong>1、加法和减法</strong></p> 
<pre><code class="language-javascript">0.1 + 0.2 // 结果为 0.30000000000000004
0.3 - 0.1 // 结果为 0.19999999999999996

// 这是因为浮点数的二进制表示无法准确表示某些十进制小数，导致计算结果存在微小的误差。
</code></pre> 
<p><br><strong>2、乘法和除法</strong></p> 
<pre><code class="language-javascript">0.1 * 0.2 // 结果为 0.020000000000000004
0.3 / 0.1 // 结果为 2.9999999999999996

// 在进行乘法和除法时，浮点数计算结果的精度问题更为突出，可能会产生更大的误差。
</code></pre> 
<p><br><strong>3、比较运算</strong><br>  </p> 
<pre><code class="language-javascript">0.1 + 0.2 === 0.3 // 结果为 false

// 直接比较浮点数可能会导致不准确的结果，因为计算结果的微小误差可能使它们不完全相等。
</code></pre> 
<p></p> 
<h4>超过最值</h4> 
<p>        所谓 <strong>超过最值（<code>最大、最小值</code>）</strong> 指的是超过了 <strong><code>Number.MIN_SAFE_INTEGER（- 9007199254740991）</code>，即 +（2^53 – 1）</strong> 或 <strong><code>Number.MAX_SAFE_INTEGER（+ 9007199254740991）</code>，即 -（2^53 – 1）</strong> 范围的值，项目中最常见的就是如下几种情况：1</p> 
<ul><li><strong>1、后端返回的数值超过最值</strong> 
  <ul><li>例一，后端返回的列表数据，通常都会有相应的 <strong><code>ID</code></strong> 来标识唯一性，但后端生成这个 <strong><code>ID</code></strong> 时是 <strong>Long 类型</strong>，那么该值很可能就会超过 <strong><code>JavaScript</code></strong> 中能表示的最大正整数，此时就导致精度丢失，即前端实际获取到的 <strong><code>ID</code></strong> 值和后端返回的将不一致。</li><li>例二，后端可能需要将一些值通过计算之后，把对应的结果值返回给前端，此时若该值超过了 <strong>最值</strong>，那么也会产生精度丢失。</li></ul></li><li><strong>2、前端进行数值计算时，计算结果超过最值</strong></li></ul> 
<p class="img-center"><img alt="" height="313" src="https://images2.imgbox.com/21/f7/Ulwmk6w3_o.png" width="212"></p> 
<p></p> 
<h4>保留指定小数位</h4> 
<p>        除了上述对涉及浮点数计算、超过最值的场景之外，我们通常还会对数值进行保留指定小数位的处理，而部分开发者可能会直接使用 <strong>Number.prototype.toFixed</strong> 来实现，但这个方法却并不能保证我们期望的效果，例如保留小数位时需要进行 <strong>四舍五入</strong> 时就会有问题，如下：</p> 
<pre><code class="language-javascript">console.log(1.595.toFixed(2)) // 1.59 ——&gt; 期望为：1.60
console.log(1.585.toFixed(2)) // 1.58 ——&gt; 期望为：1.59
console.log(1.575.toFixed(2)) // 1.57 ——&gt; 期望为：1.58
console.log(1.565.toFixed(2)) // 1.56 ——&gt; 期望为：1.57
console.log(1.555.toFixed(2)) // 1.55 ——&gt; 期望为：1.56
console.log(1.545.toFixed(2)) // 1.54 ——&gt; 期望为：1.55
console.log(1.535.toFixed(2)) // 1.53 ——&gt; 期望为：1.54
console.log(1.525.toFixed(2)) // 1.52 ——&gt; 期望为：1.53
console.log(1.515.toFixed(2)) // 1.51 ——&gt; 期望为：1.52
console.log(1.505.toFixed(2)) // 1.50 ——&gt; 期望为：1.51</code></pre> 
<p></p> 
<h3>精度丢失的原因</h3> 
<p>计算机内部实际上只能 <strong>存储/识别</strong> <strong><code>二进制</code></strong>，因此 <strong>文档、图片、数字</strong> 等都会被转换为 <strong>二进制</strong>，而对于数字而言，虽然我们看到的是 <strong>十进制</strong> 的表示结果，但实际上会底层会进行 <strong>十进制</strong> 和 <strong>二进制</strong> 的相互转换，而这个转换过程就有可能会出现 <strong>精度丢失</strong>，因为十进制转二进制后可能产生 <strong>无限循环</strong> 部分，而 <strong>实际存储空间是有限的</strong>。</p> 
<p>由于计算机内部使用二进制浮点数表示法，而不是十进制。这种二进制表示法在某些情况下无法准确地表示某些十进制小数，从而导致精度丢失，如：</p> 
<p><strong>1、无法精确表示的十进制小数：</strong></p> 
<p>        某些十进制小数无法准确地表示为有限长度的二进制小数。例如，0.1 和 0.2 这样的十进制小数在二进制表示中是无限循环的小数，因此在计算机内部以有限的位数进行表示时，会存在舍入误差，导致精度丢失。</p> 
<p><br><strong>2、舍入误差：</strong></p> 
<p>        由于浮点数的位数是有限的，对于无法精确表示的十进制小数，计算机进行舍入来逼近其值。这种舍入操作会引入误差，并导致计算结果与预期值之间的差异。</p> 
<p>        Number.prototype.toFixed 的舍入：关于这个方法的舍入方式，目前最多的说法就是 银行家算法 ，的确在大多情况下确实能够符合 银行家算法 的规则，但是部分情况就并不符合其规则，因此严格意义上来讲 Number.prototype.toFixed 并不算是使用了 银行家算法。（<strong>银行家舍入：所谓银行家舍入法，其实质是一种四舍六入五取偶（又称四舍六入五留双）法。</strong> 简单来说就是：四舍六入五考虑，五后非零就进一，五后为零看奇偶，五前为偶应舍去，五前为奇要进一。具体解释见下文） </p> 
<p><br><strong>3、算术运算的累积误差：</strong></p> 
<p>        在进行一系列浮点数算术运算时，舍入误差可能会累积并导致精度丢失。每一次运算都会引入一些误差，这些误差在多次运算中逐渐累积，导致最终结果的精度降低。</p> 
<p><br><strong>4、比较运算的不精确性：</strong></p> 
<p>        由于浮点数的表示精度有限，直接比较浮点数可能会导致不准确的结果。微小的舍入误差可能使得两个看似相等的浮点数在比较时被认为是不等的。</p> 
<p><br><strong>5、数值范围的限制：</strong></p> 
<p>        浮点数的表示范围是有限的，超出范围的数值可能会导致溢出或下溢，进而影响计算结果的精度。</p> 
<p></p> 
<h4>银行家算法</h4> 
<p>所谓银行家算法用一句话概括为：<br><strong>四舍六入五考虑，<code>五后</code> 有数 <code>就进一</code>，<code>五后</code> 无数 看 <code>奇偶</code>，<code>五前</code> 为偶当 <code>舍去</code>，<code>五后</code> 为奇要 <code>进一</code></strong></p> 
<ul><li><strong>四舍</strong> 指保留位后的 <strong>数值 &lt; 5</strong> 应 <strong><code>舍去</code></strong>，<strong>4</strong> 只是个代表值</li><li><strong>六入</strong> 指保留位后的 <strong>数值 &gt; 5</strong> 应 <strong><code>进一</code></strong>，<strong>6</strong> 只是个代表值</li><li>若保留位后的 <strong>数值 = 5</strong>，看 <strong>5 后</strong> 是否有数 
  <ul><li>若 <strong>5 后 无数</strong>，则看 <strong>5 前</strong> 的数值的 <strong>奇偶</strong> 来判断 
    <ul><li>若 <strong>5 前</strong> 的数值为 <strong>偶数</strong>，则 <strong>舍去</strong></li><li>若 <strong>5 前</strong> 的数值为 <strong>奇数</strong>，则 <strong>进一</strong></li></ul></li><li>若 <strong>5 后 有数</strong>，则 <strong>进一</strong></li></ul></li></ul> 
<p></p> 
<pre><code class="language-javascript">// 四舍
(1.1341).toFixed(2) = '1.13'

// 六入
(1.1361).toFixed(2) = '1.14'

// 五后 有数 ，进一
(1.1351).toFixed(2) = '1.14'

// 五后 无数，看奇偶，五前为 3 奇数，进一 
(1.1350).toFixed(2) = '1.14'

// 五后 无数，看奇偶，五前为 0 偶数，舍去
(1.1050).toFixed(2) = '1.10'
</code></pre> 
<p>这样看起来没啥问题，但是：</p> 
<pre><code class="language-javascript">// 五后 有数，应进一
(1.1051).toFixed(2) = 1.11 （正确 √）
(1.105).toPrecision(17) = '1.1050000000000000' // 精度

// 五后 无数，看奇偶，五前为 0 偶数，应舍去
(1.105).toFixed(2) = 1.10 （正确 √）

// 五后 无数，看奇偶，五前为 2 偶数，应舍去
(1.125).toFixed(2) = 1.13 （不正确 ×）
1.125.toPrecision(17) = '1.1250000000000000' // 精度

// 五后 无数，看奇偶，五前为 4 偶数，应舍去
(1.145).toFixed(2) = 1.15 （不正确 ×）
1.145.toPrecision(17) = '1.1450000000000000' // 精度

// 五后 无数，看奇偶，五前为 6 偶数，应舍去
(1.165).toFixed(2) = 1.17 （不正确 ×）
1.165.toPrecision(17) = '1.1650000000000000' // 精度

// 五后 无数，看奇偶，五前为 8 偶数，应舍去
(1.185).toFixed(2) = 1.19 （不正确 ×）
1.185.toPrecision(17) = '1.1850000000000001' // 精度
</code></pre> 
<p></p> 
<h4>ECMAScript 定义的 toFixed 标准</h4> 
<p class="img-center"><img alt="" height="760" src="https://images2.imgbox.com/90/89/MKLyeMuV_o.png" width="1200"></p> 
<p>简单解释一下：</p> 
<ol><li>让 <strong>x = 目标数字</strong>，如：<strong><code>(1.145).toFixed(2)</code></strong> 中 <strong><code>x = 1.145 。</code></strong></li><li>让 <strong>f = 参数</strong>，如：<strong><code>(1.145).toFixed(2)</code></strong> 中 <strong><code>f = 2 。</code></strong></li><li>若 <strong>f = <code>undefined</code></strong>，即 <strong>未传参</strong>，则将 <strong>f = 0 。</strong></li><li>若 <strong>f = <code>Infinite</code></strong>，即传入了 <strong>无穷值</strong>，则抛出 <strong>RangeError 异常。</strong></li><li>若 <strong>f &lt; <code>0</code> 或 f &gt; <code>100</code></strong>，即传入了不在 <strong><code>0 - 100</code></strong> 之间的值，则抛出 <strong>RangeError 异常。</strong></li><li>若 <strong>x = <code>Infinite</code></strong>，即想要对 <strong>非准确值</strong> 保留位操作，则返回其 <strong>字符串形式。</strong><br> 例如，<strong><code>Infinity.toFixed(2) = 'Infinity'</code>、<code>NaN.toFixed(2) = 'NaN' 。</code></strong></li><li>让 <strong>x = <a href="https://tc39.es/ecma262/#%E2%84%9D" rel="nofollow" title="计算机所能表示的数学值 ℝ(x)">计算机所能表示的数学值 ℝ(x)</a></strong><br> 从 <strong>数字</strong> 或 <strong>BigInt x</strong> 到 <strong>数学值</strong> 的转换表示为 <strong><code>x 的数学值</code></strong>，或 <strong><code>ℝ（x）</code></strong></li><li>让 <strong>返回值符号 s = ''</strong>，即为符号定义 <strong>初始值 。</strong></li><li>若 <strong>x &lt; <code>0</code></strong>，则将 <strong>s = '-'</strong>，并将 <strong>x = -x<code> 。</code></strong></li><li>若 <strong>x ≥ <code>10^21</code></strong>，则 <strong>返回值 m = x 对应的<code>科学计数法</code> 表示的 <code>字符串。<br>  </code></strong> <p class="img-center"><img alt="" height="236" src="https://images2.imgbox.com/5f/95/VGmaDC3q_o.png" width="214"></p> </li><li>若 <strong>x &lt; <code>10^21</code></strong>，则<br> a. 让 <strong>n = <code>一个整数</code></strong>，其中 <strong><code>n / 10^f - x</code></strong> 尽可能接近于 <strong><code>0</code></strong>，如果有两个这样的 <strong>n</strong>，选择 <strong>较大的 n 。</strong><br> b. 若 <strong>n = <code>整数 0</code></strong>，则 <strong>m = <code>"0"</code></strong>，否则，<strong>m = 由 <code>n</code> 的 <code>十进制</code> 表示形式的数字组成的 <code>字符串值（按顺序，不带前导零）。</code></strong><br> c. 若 <strong>指数 f ≠ <code>0</code></strong>，则 <strong>k = <code>m.length 。</code></strong> 
  <ol><li>若 <strong>k ≤ f</strong>，则 
    <ul><li><strong>z = 由代码单元 <code>0x0030（DIGIT ZERO）</code> 的 <code>f+1-k</code> 次出现组成的 <code>字符串</code></strong></li><li><strong>m = <code>z + m</code></strong></li><li><strong>k = <code>f + 1</code></strong></li></ul></li><li>让 <strong>a = <code>m</code> 的第一个 <code>k-f</code> 码单元</strong></li><li>让 <strong>b = <code>m</code> 的其它 <code>f</code> 个编码单元</strong></li><li>将 <strong>m = <code>a + "." + b</code></strong></li></ol></li><li>返回 <strong>s + m</strong> 组成的字符串</li></ol> 
<p></p> 
<blockquote> 
 <p><strong>示例一： (1.125).toFixed(2) = 1.13 </strong></p> 
</blockquote> 
<ul><li>根据上述规范初始 <strong>x = 1.125，f = 2，s = ''</strong></li><li>根据规范 <strong>7</strong> 可知 <strong>x = <code>1.125.toPrecision(53)</code> = 1.125</strong></li></ul> 
<p class="img-center"><img alt="" height="100" src="https://images2.imgbox.com/b5/5a/cY4axM44_o.png" width="395"></p> 
<ul><li>根据规范 <strong>11.a</strong> 提供的公式：<strong><code>n / 10^f - x ≈ 0</code></strong> 代入计算：<strong><code>n ≈ 112.5</code></strong>： 
  <ul><li>此时最接近 <strong><code>n</code></strong> 的 <strong>整数</strong> 有 <strong>两个</strong> 值为 <strong><code>112</code></strong> 和 <strong><code>113</code></strong>，按标准取最大的 <strong><code>113</code></strong></li><li>在按 <strong>11.c</strong> 的规范得到<strong> <code>m = 1.13</code></strong></li></ul></li><li>最终返回 <strong><code>s + m= 1.13</code></strong></li></ul> 
<p></p> 
<blockquote> 
 <p><strong>示例二： </strong> <strong>(-1.105).toFixed(2) = -1.10</strong></p> 
</blockquote> 
<ul><li>根据上述规范初始 <strong>x = 1.105，f = 2，s = '-'</strong></li><li>根据规范 <strong>7</strong> 可知 <strong>x = <code>(-1.105).toPrecision(53)</code> = 1.10499...<br>  </strong> <p class="img-center"><img alt="" height="86" src="https://images2.imgbox.com/b5/49/XYFx4yfA_o.png" width="398"></p> </li><li>根据规范 <strong>11.a</strong> 提供的公式：<strong><code>n / 10^f - x ≈ 0</code></strong> 代入计算：<strong><code>n ≈ 110.4...</code></strong>： 
  <ul><li>此时最接近 <strong><code>n</code></strong> 的 <strong>整数</strong> 只有 <strong>一个</strong> 值为 <strong><code>110</code></strong>（因为只有小数点后为 <strong>5</strong> 时，向上 / 向下 取整才会有两种情况）</li><li>在按 <strong>11.c</strong> 的规范得到 <strong><code>m = 1.10</code></strong></li></ul></li><li>最终返回 <strong><code>s + m= -1.13</code></strong></li></ul> 
<p></p> 
<h3>解决办法</h3> 
<p>以下是一些常见的解决方法：</p> 
<ol><li>使用整数进行计算（<strong>先放大再缩小</strong>）：<br> 既然我们遇到小数计算时才会出现误差，那么我们完全可以先把小数变整数计算之后再变成小数，这样就不会存在精度的问题。尽可能地将浮点数转换为整数进行计算。<br> 例如，通过将小数位数乘以一个固定的倍数，将浮点数转换为整数，进行计算后再将结果转换回浮点数。这可以减少浮点数计算中的精度问题。 <p><br> 以 <strong>0.1 + 0.2 = 0.30000000000000004</strong> 举个例子，如下：</p> 
  <ol><li>原式：<strong>0.1 + 0.2 = x</strong></li><li>扩大 <code>100</code> 倍：<strong>0.1 * 100 + 0.2 * 100 = 100 * x</strong></li><li>变式：<strong>100 * x = 3</strong></li><li>结果：<strong>x = 0.3</strong><br>   <pre><code class="language-javascript">let num1 = 0.1,num2 = 0.2;
console.log((num1*100+num2*100)/100); //0.3
</code></pre> <p>此方法局限就在于需要知道计算数字是几位小数。<br> 且<strong>不是所有的浮点数都刚好被转成整数，例如：</strong><br><br><img alt="" height="144" src="https://images2.imgbox.com/8b/b0/wIY9ZHoI_o.png" width="396"><br><br><strong>(44.8976).toPrecision(53)</strong> 取精度后的结果小数点后四位和实际值有误差，导致最后乘积的结果也是非正确值。</p> </li></ol></li><li><strong>使用专门的库或工具</strong>：<br> 在处理需要高精度计算的场景中，可以使用一些专门的库或工具。例如，JavaScript 中的 Decimal.js、Big.js 或 BigNumber.js 等库提供了高精度的数学计算功能，可以避免精度丢失的问题。<br><br> 需要的自行查阅： 
  <ol><li><a href="https://www.npmjs.com/package/math.js" rel="nofollow" title="math.js">math.js</a></li><li><a href="https://www.npmjs.com/package/big.js" rel="nofollow" title="big.js">big.js</a></li><li><a href="https://www.npmjs.com/package/bignumber.js" rel="nofollow" title="bignumber.js">bignumber.js</a></li><li><a href="https://www.npmjs.com/package/decimal.js" rel="nofollow" title="decimal.js">decimal.js</a></li></ol></li><li>超过最值时，接口以 <strong>字符串</strong> 的形式返回对应的值：<br> 前面提到的 <strong>后端返回</strong> 或 <strong>前端计算</strong> 产生的超过 <strong>安全范围的值</strong>，我们可以使用 <strong>BigInt</strong> 来处理，这是新增的原始值类型，它提供了一种方法来表示 <strong>大于 <code>2^53 - 1</code> 的整数</strong>。<br><br><img alt="" height="185" src="https://images2.imgbox.com/9d/e1/FM3qerTr_o.png" width="307"><br><br> 这里的 <strong>BigInt</strong> 不能用来处理后端返回超过安全范围内的值（如 <strong>id</strong>），因为当我们需要再将这些值转为 <strong>BigInt</strong> 之前就已经发生了精度丢失，所以在进行转换是无意义的。此时<span style="color:#fe2c24;">最好的方式就是让<strong>后端处理</strong>数据，使接口以 <strong>字符串</strong> 的形式返回对应的值</span>。<br><br> 当前端不得不临时转换为字符串时，可以这样处理：<br><br> （1）正则替换：<br> 如果我们使用的是axios请求数据，Axios 提供了自定义处理原始后端返回数据的 API：transformResponse , 可以这样处理：<br>   <pre><code class="language-javascript">axios({  
method: method,  
url: url,  
data: data,  
transformResponse: [function (data) {  
    // 将Long类型数据转换为字符串
    const convertedJsonString = data.replace(/"(\w+)":(\d{15,})/g, '"$1":"$2"'); 
    return JSON.parse(convertedJsonString);  
}],  
})


// 假设后端返回的JSON数据如下：
const responseData = {
  id: 12345678901234567890, // 这是一个Long类型数据
  name: "John Doe"
};

// 处理过的json数据
console.log(responseData.id); // 这将输出字符串："12345678901234567890"
console.log(typeof responseData.id); // 这将输出 "string"</code></pre> （2）json序列化处理<br> 可以借助<code>json-bigint</code>这个第三方包来处理：<br> json-bigint 中的 parse 方法会把超出 JS 安全整数范围的数字转为一个 BigNumber 类型的对象，对象数据是它内部的一个算法处理之后的，我们要做的就是在使用的时候转为字符串来使用。<br> 通过启用storeAsString选项,可以快速将BigNumber转为字符串，代码如下：<br>   <pre><code class="language-javascript">    import JSONbig from "json-bigint";
    axios({  
    method: method,  
    url: url,  
    data: data,  
    transformResponse: [function (data) {  
+        const JSONbigToString = JSONbig({ storeAsString: true });
+          // 将Long类型数据转换为字符串
+          return JSONbigToString.parse(data);  
    }],  
    })
    
    
    // 假设后端返回的JSON数据如下：
    const responseData = {
      id: 12345678901234567890, // 这是一个Long类型数据
      name: "John Doe"
    };
    
    // 处理过的json数据
    console.log(responseData.id); // 这将输出字符串："12345678901234567890"
    console.log(typeof responseData.id); // 这将输出 "string"</code></pre> </li><li>避免直接比较浮点数：<br> 由于精度问题，直接比较浮点数可能会导致不准确的结果。在需要比较浮点数的情况下，可以使用误差范围进行比较，而不是使用精确的相等性判断。<br>  </li><li>限制小数位数：<br> 对于一些特定的应用场景，可以限制浮点数的小数位数，以减少精度丢失的影响。例如，货币计算常常只保留到小数点后两位。<br>  </li><li><strong>使用适当的舍入策略</strong>：<br> 在需要进行舍入的情况下，选择适当的舍入策略以满足实际需求。常见的舍入策略包括<strong>四舍五入、向上取整、向下取整</strong>等。<br>   <pre><code class="language-javascript">Number.prototype.toFixed=function (d) { 
    var s=this+""; 
    if(!d)d=0; 
    if(s.indexOf(".")==-1)s+="."; 
    s+=new Array(d+1).join("0"); 
    if(new RegExp("^(-|\\+)?(\\d+(\\.\\d{0,"+(d+1)+"})?)\\d*$").test(s)){
        var s="0"+RegExp.$2,pm=RegExp.$1,a=RegExp.$3.length,b=true;
        if(a==d+2){
            a=s.match(/\d/g); 
            if(parseInt(a[a.length-1])&gt;4){
                for(var i=a.length-2;i&gt;=0;i--){
                    a[i]=parseInt(a[i])+1;
                    if(a[i]==10){
                        a[i]=0;
                        b=i!=1;
                    }else break;
                }
            }
            s=a.join("").replace(new RegExp("(\\d+)(\\d{"+d+"})\\d$"),"$1.$2");
 
        }if(b)s=s.substr(1); 
        return (pm+s).replace(/\.$/,"");
    }return this+"";
 
}
</code></pre> <br>  </li><li>注意数值范围：<br> 在进行浮点数计算时，要注意数值的范围。超出浮点数表示范围的数值可能会导致精度丢失或溢出的问题。</li></ol> 
<p></p> 
<p></p> 
<p>参考文章：</p> 
<p><a href="https://mp.weixin.qq.com/s/Jj1RJ6qL8br9WQN6eGZAwQ" rel="nofollow" title="线上紧急Bug：80%前端可能会遇到的数据精度问题">线上紧急Bug：80%前端可能会遇到的数据精度问题</a></p> 
<p><a href="https://juejin.cn/post/7264208575973621815" rel="nofollow" title="后端问为什么前端数值精度会丢失？ - 掘金">后端问为什么前端数值精度会丢失？ - 掘金</a></p> 
<p> <a href="https://juejin.cn/post/6960681528338677790" rel="nofollow" title="math.js是如何处理小数问题的 - 掘金">math.js是如何处理小数问题的 - 掘金</a></p> 
<p><a href="https://juejin.cn/post/6844903687010123790" rel="nofollow" title="探寻 JavaScript 精度问题以及解决方案 - 掘金">探寻 JavaScript 精度问题以及解决方案 - 掘金</a></p> 
<p><a href="https://blog.csdn.net/qq_53931766/article/details/132455164" title="【JS】关于精度丢失，产生的原因以及解决方案_js 加法丢失精度_swimxu的博客-CSDN博客">【JS】关于精度丢失，产生的原因以及解决方案_js 加法丢失精度_swimxu的博客-CSDN博客</a></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7e89b0b43299933da9a3d56d2284c3d2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">uniapp使用腾讯地图组件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c5ebe4ede123ed9876a2f99521c91fd2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决谷歌浏览器翻译插件不能用的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>