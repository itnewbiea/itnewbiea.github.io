<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>php使用yield进行大量数据处理方法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="php使用yield进行大量数据处理方法" />
<meta property="og:description" content="我们在处理大量数据，比如100万数据导入数据库，一般常规方法如果使用普通循环做逐个处理，很快会导致内存崩溃，无法实现正常的处理。php提供了yield方法来处理。我们看看如何来做的吧。
for($i=0;$i&lt;1000000;$i&#43;&#43;){ echo $i;	//这里处理业务数据 } 我们看到上面是，普通循环100万次处理，这样处理如果仅输出$i，比较小，但累计起来也会使电脑变得很慢，直至内存耗尽程序崩溃，如果是数据导入，需要每次连接数据库非常耗内存操作的话，会很快崩溃。所以这种方法不可行，原因是什么呢。这种方式逐次累加消耗内存，一直不会减少，所以会耗尽内存。这样便有了yield方式的处理，php的yield生成器。“生成器yield的优雅体现在每次产出一个值之后，生成器的内部状态都会停顿；向生成器请求下一个值时，内部状态又会恢复。生成器内部的状态会一直在停顿和恢复之间切换，直到抵达函数定义体的末尾或遇到空的 return 语句为止。“，我们可以理解上述语句，可以看出yield生成器，是通过逐个生成值，先停顿休息一下，等处理完后，释放内存，再继续处理下一个，这样内存得到休整，不会被耗尽崩溃，使性能得到很大提升。
注意，yiled必须被包装成函数调用，否则会提示“The &#34;yield&#34; expression can only be used inside a function”。
//构造yield生成器 function make_i(){ for($i=0;$i&lt;1000000;$i&#43;&#43;){ yield $i;	} } $i_arr=make_i(); //循环生成的数组 foreach($i_arr as $item){ echo $item.&#39;&lt;br&gt;&#39;; //这里处理业务数据 } 上述代码，这样改进一下处理，我们就可以完成大量数据的处理，内存不会崩溃了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/9ce7a9d6fd5d0488b0a8d1e35cb46b9c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-23T15:19:30+08:00" />
<meta property="article:modified_time" content="2020-11-23T15:19:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">php使用yield进行大量数据处理方法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>       我们在处理大量数据，比如100万数据导入数据库，一般常规方法如果使用普通循环做逐个处理，很快会导致内存崩溃，无法实现正常的处理。php提供了yield方法来处理。我们看看如何来做的吧。</p> 
<pre><code>for($i=0;$i&lt;1000000;$i++){
  echo $i;	
//这里处理业务数据
}</code></pre> 
<p> 我们看到上面是，普通循环100万次处理，这样处理如果仅输出$i，比较小，但累计起来也会使电脑变得很慢，直至内存耗尽程序崩溃，如果是数据导入，需要每次连接数据库非常耗内存操作的话，会很快崩溃。所以这种方法不可行，原因是什么呢。这种方式逐次累加消耗内存，一直不会减少，所以会耗尽内存。这样便有了yield方式的处理，php的yield生成器。“生成器yield的优雅体现在每次产出一个值之后，生成器的内部状态都会停顿；向生成器请求下一个值时，内部状态又会恢复。生成器内部的状态会一直在停顿和恢复之间切换，直到抵达函数定义体的末尾或遇到空的 return 语句为止。“，我们可以理解上述语句，可以看出yield生成器，是通过逐个生成值，先停顿休息一下，等处理完后，释放内存，再继续处理下一个，这样内存得到休整，不会被耗尽崩溃，使性能得到很大提升。</p> 
<p>注意，yiled必须被包装成函数调用，否则会提示“The "yield" expression can only be used inside a function”。</p> 
<pre><code>//构造yield生成器
function make_i(){
 for($i=0;$i&lt;1000000;$i++){
  yield $i;	
 }
}
$i_arr=make_i();
//循环生成的数组
foreach($i_arr as $item){
	echo $item.'&lt;br&gt;';
//这里处理业务数据
}</code></pre> 
<p>上述代码，这样改进一下处理，我们就可以完成大量数据的处理，内存不会崩溃了。</p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7643c6157cb13fb751ac8866fa3fb5d1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">循环中 动态参数 传div 层_通过GSAP让vue实现动态效果</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f1345e9aa8bb1c9ed8901b011b780160/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Flutter中PageView的滑动开始监听、完成监听自定义</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>