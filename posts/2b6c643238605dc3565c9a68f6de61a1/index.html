<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>K8S的概念和基本应用 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="K8S的概念和基本应用" />
<meta property="og:description" content="学习视频：Kubernetes基本概念和应用_哔哩哔哩_bilibili
零 . 架构概览 master节点：管理调度集群资源，一般为多节点构成，可以是物理机，也可以是虚拟机。worker节点：资源的提供者，一般为多节点构成，可以是物理机，也可以是虚拟机。pod：绿色部分，相当于云平台的虚拟机容器container：cpu和内存、资源的隔离单位，多节点部署，主容器&#43;辅助容器。它共享pod的存储资源和网络栈。k8s平台：解决集群资源调度的问题，将空闲的pod合理的分配到worker节点上面去。监控集群，如有节点或pod挂了，重新协调和启动pod，保证应用高可用，称为治愈。保证集群的网络，保证pod服务之间可以互通互联。 master节点组件构成 master节点：k8s集群的大脑，分布式数据库etcd，k8s集群集中的状态存储：节点，pod，发布，配置等都存储在里面。高可用部署的话，至少需要部署3个节点。所有的操作都是通过调用apiserver来实现的，可以认为是etcd的代理。scheduler：负责调度决策的组件，比如：pod应该分配到那些worker里面去。controller manager：保证集群状态最终一致的组件。通过apiserver 监控集群的状态，确保实际状态与预期状态一致。 worker节点组件构成 kubelet ：worker节点的资源管理者，相当于agent角色。监听apiserver的事件，执行master下发的任务，汇报情况给APIserver等，是worker节点的小脑。container runtime：结点容器资源的管理者。kubelet不直接参与动作，而是委托给container runtime。比如：启动或关闭容器，收集容器状态。在启动容器的时候，如果本地没有镜像缓存，会从docker hub 去拉取相应的镜像，缓存到本地。kube-proxy：管理k8s中的服务网络的（servernetwork），当需要把服务暴露给外网的时候，需要kube-proxy代理作为转发。pod：瞬息的，不固定的，ip可能会变（可变&#43;不可变）。 K8S发布pod流程样例 流程解读如下：
1、使用kubectl命令行工具向apiserver发送一个创建一个新的replicaset 的请求。apiserver会将该资源请求先存储到etcd中。
2、controller manager 监听replicaset的 创建或修改相关的事件。接收到上一步的创建pod的一个通知。
3、controller manager比较当前集群状态和预期集群的状态，当发现不一致时，调用第一步中的创建pod的模板，在apiserver中创建预期的pod。
4、scheduler监听到apiserver创建新pod的请求，运行调度算法，选择空闲的work节点。然后通过apiserver更新创建pod的定义。把这些pod指定到具体要发布到哪些work节点上。、
注意，此时：controller manager、scheduler 只是通过apiserver更新了希望创建的集群状态，pod并没有真正创建。
5、一旦pod被分配到某个worker节点，apiserver就会通知相应节点上面的kubelet，kubelet接到通知以后，就会指示他的节点上的container runtime 去运行对应的容器。
6、container runtime就会开始下载镜像，启动容器。同时kubelet开始监控容器的运行。
K8S总体架构 小结各个组件的作用 虚拟机抽象-pod 容器 = 应用 &#43; 操作系统，是一种资源隔离抽象；pod 是容器的包装，是一种虚拟机抽象；k8s 是管理pod虚拟机的数据中心抽象； https://kubernetes.io/docs/concepts/workloads/pods/pod/
一般是一个pod对应一个容器，但也有一对多的情况，一个主，一个辅助。 https://hub.docker.com/r/spring2go/spring-petclinic/tags
发布pod：按照要求书写发布规范。
Pod | Kubernetes
如何访问pod？ 针对测试环境：
端口转发功能开启外部访问：
kubectl port-forword petclinic 8080:8080 （主机端口：pod端口）
nodeport service 传统数据中心反向代理原理 通过在数据中心的网络边界部署反向代理（proxy service）将内网资源暴露出去，使得公网可访问。
反向代理2大作用：
反向路由 &#43; 负载均衡" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2b6c643238605dc3565c9a68f6de61a1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-11T11:14:22+08:00" />
<meta property="article:modified_time" content="2023-07-11T11:14:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">K8S的概念和基本应用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>学习视频：<a href="https://www.bilibili.com/video/BV1Ja4y1x748/?spm_id_from=333.999.0.0&amp;vd_source=1729e86147c46f8fc00152c1779efdd2" rel="nofollow" title="Kubernetes基本概念和应用_哔哩哔哩_bilibili">Kubernetes基本概念和应用_哔哩哔哩_bilibili</a></p> 
<h3>零 . 架构概览</h3> 
<p><img alt="" height="944" src="https://images2.imgbox.com/51/18/S7TbZPoX_o.png" width="1200"></p> 
<ul><li id="u67db9fe9">master节点：管理调度集群资源，一般为多节点构成，可以是物理机，也可以是虚拟机。</li><li id="ub92f393b">worker节点：资源的提供者，一般为多节点构成，可以是物理机，也可以是虚拟机。</li><li id="u8b5a2e55">pod：绿色部分，相当于云平台的虚拟机</li><li id="u4fb1e514">容器container：cpu和内存、资源的隔离单位，多节点部署，主容器+辅助容器。它共享pod的存储资源和网络栈。</li><li id="u9c8a1fc6">k8s平台：解决集群资源调度的问题，将空闲的pod合理的分配到worker节点上面去。监控集群，如有节点或pod挂了，重新协调和启动pod，保证应用高可用，称为治愈。保证集群的网络，保证pod服务之间可以互通互联。</li></ul> 
<p></p> 
<h3>master节点组件构成</h3> 
<p><img alt="" height="600" src="https://images2.imgbox.com/e5/ca/0wyL3Asi_o.png" width="1028"></p> 
<ul><li id="u6be1be9e">master节点：k8s集群的大脑，分布式数据库etcd，k8s集群集中的状态存储：节点，pod，发布，配置等都存储在里面。高可用部署的话，至少需要部署3个节点。</li><li id="ua8204f23">所有的操作都是通过调用apiserver来实现的，可以认为是etcd的代理。</li><li id="uf4e1d564">scheduler：负责调度决策的组件，比如：pod应该分配到那些worker里面去。</li><li id="u1df2cc2b">controller manager：保证集群状态最终一致的组件。通过apiserver 监控集群的状态，确保实际状态与预期状态一致。</li></ul> 
<h3>worker节点组件构成</h3> 
<p><img alt="" height="776" src="https://images2.imgbox.com/53/77/XWdzlVvD_o.png" width="1094"></p> 
<ul><li>kubelet ：worker节点的资源管理者，相当于agent角色。监听apiserver的事件，执行master下发的任务，汇报情况给APIserver等，是worker节点的小脑。</li><li id="ue82ac781">container runtime：结点容器资源的管理者。kubelet不直接参与动作，而是委托给container runtime。比如：启动或关闭容器，收集容器状态。在启动容器的时候，如果本地没有镜像缓存，会从docker hub 去拉取相应的镜像，缓存到本地。</li><li id="uefefa480">kube-proxy：管理k8s中的服务网络的（servernetwork），当需要把服务暴露给外网的时候，需要kube-proxy代理作为转发。</li><li id="u80b3043d">pod：瞬息的，不固定的，ip可能会变（可变+不可变）。</li></ul> 
<p></p> 
<h3>K8S发布pod流程样例</h3> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/82/2d/hGQx0lYn_o.png" width="1200"></p> 
<p><strong>流程解读如下：</strong></p> 
<p>1、使用kubectl命令行工具向apiserver发送一个创建一个新的replicaset 的请求。apiserver会将该资源请求先存储到etcd中。</p> 
<p>2、controller manager 监听replicaset的 创建或修改相关的事件。接收到上一步的创建pod的一个通知。</p> 
<p>3、controller manager比较当前集群状态和预期集群的状态，当发现不一致时，调用第一步中的创建pod的模板，在apiserver中创建预期的pod。</p> 
<p>4、scheduler监听到apiserver创建新pod的请求，运行调度算法，选择空闲的work节点。然后通过apiserver更新创建pod的定义。把这些pod指定到具体要发布到哪些work节点上。、</p> 
<p>注意，此时：controller manager、scheduler 只是通过apiserver更新了希望创建的集群状态，pod并没有真正创建。</p> 
<p>5、一旦pod被分配到某个worker节点，apiserver就会通知相应节点上面的kubelet，kubelet接到通知以后，就会指示他的节点上的container runtime 去运行对应的容器。</p> 
<p>6、container runtime就会开始下载镜像，启动容器。同时kubelet开始监控容器的运行。</p> 
<p></p> 
<h3>K8S总体架构</h3> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/00/18/gnfiHZur_o.png" width="1200"></p> 
<h3></h3> 
<h3>小结各个组件的作用</h3> 
<p><img alt="" height="996" src="https://images2.imgbox.com/8f/d5/edbQpeRQ_o.png" width="1200"></p> 
<h3> 虚拟机抽象-pod</h3> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/31/ae/VOXzhUSl_o.png" width="1200"></p> 
<ul><li id="ue6e09974">容器 = 应用 + 操作系统，是一种资源隔离抽象；</li><li id="u3cdbff5c">pod 是容器的包装，是一种虚拟机抽象；</li><li id="u97208f1a">k8s 是管理pod虚拟机的数据中心抽象； </li></ul> 
<p id="u45d7a8d8">https://kubernetes.io/docs/concepts/workloads/pods/pod/</p> 
<ul><li id="u5119b837">一般是一个pod对应一个容器，但也有一对多的情况，一个主，一个辅助。</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/22/0a/qTwe7CVM_o.png"></p> 
<p id="u87cdcb79">https://hub.docker.com/r/spring2go/spring-petclinic/tags</p> 
<p id="ufa873079"></p> 
<p id="ue642c539">发布pod：按照要求书写发布规范。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ad/94/rUgipxNm_o.png"></p> 
<p id="u1ee5cd4b"><a href="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/" rel="nofollow" title="Pod | Kubernetes">Pod | Kubernetes</a></p> 
<h3 id="Bn5S2">如何访问pod？</h3> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c7/f0/3BJUMHSh_o.png"></p> 
<p id="u10650df3">针对测试环境：<br> 端口转发功能开启外部访问：<br> kubectl port-forword petclinic 8080:8080 （主机端口：pod端口）</p> 
<p id="u240a4749"></p> 
<h3 id="EgFQi">nodeport service</h3> 
<ul><li id="ub569f4e3"><strong>传统数据中心反向代理原理</strong></li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ba/e2/VSVh2Iis_o.png"></p> 
<p id="u0c45df2b">通过在数据中心的网络边界部署反向代理（proxy service）将内网资源暴露出去，使得公网可访问。</p> 
<p id="u943b8b88"></p> 
<p id="u87ac622d">反向代理2大作用：</p> 
<p id="u7311d32b">反向路由 + 负载均衡</p> 
<p id="u69600af7"></p> 
<ul><li id="u0d3e5ab1"><strong>k8s的反向代理</strong></li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2b/fa/MqvExPZe_o.png"></p> 
<p id="ue0c018d0">label：大标签机制，键值对</p> 
<p id="u2e6d7621">selector：路由选择机制，pod一致性。</p> 
<p id="uea1bbc3e">service：负载均衡</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/53/37/cRB5lWRy_o.png"></p> 
<p id="u1f642c39"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/be/2e/sSzt4WCk_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/35/8d/aQ2nWCxh_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9a/cf/dEUflOMM_o.png"></p> 
<p id="u55f55a52">添加一个：labels： 不然无法访问。</p> 
<p id="ub21dbce2"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/85/d1/MU63dish_o.png"></p> 
<h3></h3> 
<h3> K8S反向代理-service</h3> 
<h4>传统反向代理</h4> 
<p><img alt="" height="746" src="https://images2.imgbox.com/bc/3c/nweRlzi6_o.png" width="1200"></p> 
<p>配置反向代理将web应用暴露出去。</p> 
<p>反向代理作用：4层/7层</p> 
<p>1、反向路由：将web请求反向路由到内部的应用地址。里面有个地址映射，比如：将域名映射到内部应用的IP，可直接在代理服务器配置。</p> 
<p>2、负载均衡</p> 
<p></p> 
<h4>nodeport service -k8s的反向代理</h4> 
<p><img alt="" height="756" src="https://images2.imgbox.com/86/46/JILoBeXI_o.png" width="1200"></p> 
<p> 作用：</p> 
<p>1、反向路由</p> 
<p>2、负载均衡</p> 
<p></p> 
<p>解释：</p> 
<p>1、k8s中service是一个抽象概念。在k8s中，service将流量反向路由到后端的pod是通过selector和labels机制实现的。labels是一种打标签机制，selector是一种路由选择机制。selector上的标签和labels上的标签跨域匹配上，那么selector就将流量路由到匹配的pod上。该机制对比传统的nginx更加灵活，，能力更强。</p> 
<p><img alt="" height="894" src="https://images2.imgbox.com/44/7b/TJpyBjeh_o.png" width="1200"></p> 
<p></p> 
<h4>service发布规范样例：</h4> 
<p><img alt="" height="514" src="https://images2.imgbox.com/19/0f/Mfoceaav_o.png" width="946"></p> 
<p>nodeport 范围：30000～32767</p> 
<p><img alt="" height="458" src="https://images2.imgbox.com/31/57/kRriG3xf_o.png" width="1176"></p> 
<h3>通过service实现蓝绿发布</h3> 
<p><img alt="" height="922" src="https://images2.imgbox.com/50/42/P7PNinm8_o.png" width="1200"></p> 
<p> <img alt="" height="884" src="https://images2.imgbox.com/ba/6c/0odDHpJA_o.png" width="1200"></p> 
<p></p> 
<h3> Replicaset</h3> 
<p><img alt="" height="868" src="https://images2.imgbox.com/7b/7c/LYNZltV0_o.png" width="1200"></p> 
<p>随机路由，默认路由到3个pod中的随机一个。</p> 
<p>Replicaset负责pod的高可用，具有自愈能力。若集中中的一个或一些pod删除了或不工作了，Replicaset会负责重新创建新的pod。</p> 
<h4>发布规范案例：</h4> 
<p><img alt="" height="838" src="https://images2.imgbox.com/6a/8f/pUoNAUeW_o.png" width="1200"></p> 
<p>replicas：指定副本数量</p> 
<p></p> 
<h3>滚动发布原理和Deployment</h3> 
<h4>滚动发布- rolling update：</h4> 
<p>定义：一种高级的发布策略，按照批次依次替换老版本，逐步升级到新版本。发布过程中，应用不中断，用户体验平滑。</p> 
<p></p> 
<p></p> 
<h4>流程：逐步替换</h4> 
<p>每批次发布数量可以大于1，每个批次发布数量也可以各不相同。</p> 
<h4><img alt="" height="944" src="https://images2.imgbox.com/cd/2f/b1TD3QJf_o.png" width="1200"></h4> 
<h4>蓝绿发布vs滚动发布</h4> 
<p><img alt="" height="634" src="https://images2.imgbox.com/3f/38/FxH94bko_o.png" width="1200"></p> 
<h4>K8S发布抽象Deployment</h4> 
<p><img alt="" height="784" src="https://images2.imgbox.com/e6/de/wodQzb56_o.png" width="1200"></p> 
<p> Deployment 对replicaset再次包装。</p> 
<p></p> 
<h4>Deployment滚动发布流程</h4> 
<p><img alt="" height="692" src="https://images2.imgbox.com/29/59/Mw5bZnRa_o.png" width="1200"></p> 
<p>发布流程样例：<br><img alt="" height="542" src="https://images2.imgbox.com/a3/44/iwlVg96Q_o.png" width="700"></p> 
<h3>K8S内部反向代理-clusterip-service</h3> 
<p>内部服务之间如何相互访问？</p> 
<p><img alt="" height="710" src="https://images2.imgbox.com/eb/a8/lmiZ67zr_o.png" width="1200"></p> 
<p>解决方法：引入一个反向代理抽象，反向代理不仅可以部署在外部与内部边界，也可在内部pod之间部署。</p> 
<p><img alt="" height="660" src="https://images2.imgbox.com/55/5e/nCnK4n1y_o.png" width="1200"></p> 
<h4>原理：</h4> 
<p>mysql-pod.yml</p> 
<p><img alt="" height="660" src="https://images2.imgbox.com/55/9b/dDRwzSYr_o.png" width="1200"></p> 
<p> mysql-service.yml</p> 
<p><img alt="" height="522" src="https://images2.imgbox.com/7a/7a/xPbMwzSl_o.png" width="1200"></p> 
<p>petclinic-deployment.yml</p> 
<p><img alt="" height="958" src="https://images2.imgbox.com/e2/69/dmxzJOGR_o.png" width="1200"></p> 
<p> petclinic-service.yml</p> 
<p><img alt="" height="570" src="https://images2.imgbox.com/70/ce/9h3IU2kV_o.png" width="1200"></p> 
<h4> 部署：</h4> 
<p>由于依赖关系原因，先部署mysql。</p> 
<p>kubectl  apply -f mysql-pod.yml</p> 
<p>kubectl   apply -f mysql-service.yml</p> 
<p>kubectl  apply -f petclinic-deployment.yml</p> 
<p>kubectl  apply -f petclinic-service.yml</p> 
<p><img alt="" height="484" src="https://images2.imgbox.com/de/2c/W9DV4T7l_o.png" width="910"></p> 
<h4> 总结：</h4> 
<p><img alt="" height="694" src="https://images2.imgbox.com/46/28/Y7KsSU1y_o.png" width="1200"></p> 
<h3>K8S的namespace和kube-dns</h3> 
<h4>域名---&gt;IP  ？</h4> 
<p><img alt="" height="618" src="https://images2.imgbox.com/d5/cd/7BqzPOZc_o.png" width="1200"></p> 
<h4>namespace的概念：</h4> 
<p>名字空间之间是逻辑隔离的，名字空间可自定义。</p> 
<p><img alt="" height="600" src="https://images2.imgbox.com/8f/80/jDVj8PjW_o.png" width="1200"></p> 
<p> 系统名字空间组件：</p> 
<p>get all -n kube-system</p> 
<p><img alt="" height="598" src="https://images2.imgbox.com/c6/65/xZkB7JET_o.png" width="1102"></p> 
<p> 域名---&gt;IP  ？<img alt="" height="342" src="https://images2.imgbox.com/b9/9c/CQukYrqc_o.png" width="1134"></p> 
<h3>K8S的配置抽象configmap原理</h3> 
<p>ConfigMap是一个用于存储应用程序配置数据的Kubernetes对象。它允许将应用程序配置数据与容器镜像分开存储，这样可以更容易地管理和升级应用程序，而不必重新构建和重建容器镜像。</p> 
<p>ConfigMap的实现原理是通过将配置文件数据存储在Kubernetes的etcd中，并将该数据挂载到容器的特定路径中。这样，在容器启动时，它会读取挂载的ConfigMap数据，并将其作为容器内的配置文件使用。</p> 
<p>ConfigMap支持多种类型的数据，包括简单的键值对、INI文件和JSON/YAML格式的文本文件。配置数据可以直接在Kubernetes集群中创建，也可以从外部文件或环境变量中导入。</p> 
<p>当ConfigMap中的配置数据发生更改时，Kubernetes会通知相关的容器，以便它们可以重新加载新的配置数据。这使得应用程序的配置更加灵活和可扩展，可以随时进行修改和升级，而无需重新构建和重建容器镜像。</p> 
<p><img alt="" height="650" src="https://images2.imgbox.com/ab/24/75WYUpHH_o.png" width="1200"></p> 
<p>发布时，configmap的配置以环境变量的形式，注入到pod中。 </p> 
<p></p> 
<p><img alt="" height="918" src="https://images2.imgbox.com/79/8a/z0FaQAaq_o.png" width="1200"></p> 
<p>将配置定义到一个公用的configmap中， 发布后cinfigmap的配置会注入到后台这些pod中，很好的解决了冗余和维护困难的问题。</p> 
<p></p> 
<h4>演示部署架构</h4> 
<p><img alt="" height="768" src="https://images2.imgbox.com/32/a9/Q85NxBwd_o.png" width="1200"></p> 
<p> pod的配置不用直接写到里面，而是从configmap来获取。</p> 
<p></p> 
<h4>ENV--&gt;configmap</h4> 
<p><img alt="" height="482" src="https://images2.imgbox.com/9d/49/Tq1dJeUV_o.png" width="1200"></p> 
<p></p> 
<h4>deployment文件变化： <img alt="" height="846" src="https://images2.imgbox.com/95/4f/md4zieGt_o.png" width="1200"></h4> 
<p> envfrom直接指向configmap，name为configmap的name。</p> 
<h3>K8S机密配置抽象secret</h3> 
<p><img alt="" height="730" src="https://images2.imgbox.com/d1/83/rZafcTE5_o.png" width="1200"></p> 
<p>提供比较安全的存储敏感数据的方式。</p> 
<p><img alt="" height="874" src="https://images2.imgbox.com/f1/16/Ku7KMGfH_o.png" width="1200"> <img alt="" height="794" src="https://images2.imgbox.com/f6/9e/BWtyQYvS_o.png" width="1200"></p> 
<p><img alt="" height="678" src="https://images2.imgbox.com/0b/ba/ZIFMSR2c_o.png" width="1164"></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/74d3b2493495ea1fe0c68fed3d388810/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">华为开发者大会2023（Cloud）之旅</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1acc930ae4ddd09b7d950ab1def1de4a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">React中 setStatez中数组和对象的修改方式？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>