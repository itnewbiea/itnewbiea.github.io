<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mpc模型预测控制原理详解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="mpc模型预测控制原理详解" />
<meta property="og:description" content="mpc模型预测控制原理详解 前言mpc算法步骤mpc算法推导 前言 本文是对mpc模型预测控制学习的记录，主要参照了DR_CAN老师的视频进行学习。视频专栏链接：DR_CAN老师mpc视频专栏。在这篇博客中博主也针对DR_CAN老师的讲解做了详尽的笔记和代码实现。读者可以相结合地进行学习。
mpc算法步骤 MPC算法主要包括以下三步：
估计/测量读取当前系统状态基于 u k , u k &#43; 1 , . . . u k &#43; N u_k,u_{k&#43;1},...u_{k&#43;N} uk​,uk&#43;1​,...uk&#43;N​来进行最优化；只取 u k u_k uk​。（Receding Horizon Control）滚动优化控制
为什么只取 u k u_k uk​那？这是因为如果系统一次预测太多的控制输入，当系统发生变化或者受到外部扰动的时候，接下来的k&#43;1、k&#43;2等时刻预测的未必准。只取 u k u_k uk​的滚动优化控制，可以避免这个问题。 mpc算法推导 考虑一个离散系统，其状态空间表达式为：
系统输出参考值 R = 0 R=0 R=0，误差为 E = y − R = x − 0 = x E=y-R=x-0=x E=y−R=x−0=x。
选取这样简单的系统有利于在推导时降低难度。
在k时刻时，我们令：
其中 u ( k &#43; 1 ∣ k ) u(k&#43;1|k) u(k&#43;1∣k)表示在k时刻预测的k&#43;1时刻的的系统输入u， u ( k &#43; i ∣ k ) u(k&#43;i|k) u(k&#43;i∣k)表示的含义类似于 u ( k &#43; 1 ∣ k ) u(k&#43;1|k) u(k&#43;1∣k)，N表示预测区间。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/783ec20746b7fc98863a725bb1b435a0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-17T10:23:17+08:00" />
<meta property="article:modified_time" content="2022-10-17T10:23:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mpc模型预测控制原理详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>mpc模型预测控制原理详解</h4> 
 <ul><li><a href="#_1" rel="nofollow">前言</a></li><li><a href="#mpc_4" rel="nofollow">mpc算法步骤</a></li><li><a href="#mpc_10" rel="nofollow">mpc算法推导</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>前言</h2> 
<p>本文是对mpc模型预测控制学习的记录，主要参照了DR_CAN老师的视频进行学习。视频专栏链接：<a href="https://space.bilibili.com/230105574/channel/seriesdetail?sid=2391534" rel="nofollow">DR_CAN老师mpc视频专栏</a>。在<a href="https://blog.csdn.net/weixin_44718107/article/details/123944631">这篇博客</a>中博主也针对DR_CAN老师的讲解做了详尽的笔记和代码实现。读者可以相结合地进行学习。</p> 
<h2><a id="mpc_4"></a>mpc算法步骤</h2> 
<p>MPC算法主要包括以下三步：</p> 
<ol><li>估计/测量读取当前系统状态</li><li>基于 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           u 
          
         
           k 
          
         
        
          , 
         
         
         
           u 
          
          
          
            k 
           
          
            + 
           
          
            1 
           
          
         
        
          , 
         
        
          . 
         
        
          . 
         
        
          . 
         
         
         
           u 
          
          
          
            k 
           
          
            + 
           
          
            N 
           
          
         
        
       
         u_k,u_{k+1},...u_{k+N} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6389em; vertical-align: -0.2083em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0315em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0315em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2083em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0315em;">k</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right: 0.109em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2083em;"><span class=""></span></span></span></span></span></span></span></span></span></span>来进行最优化；</li><li>只取<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           u 
          
         
           k 
          
         
        
       
         u_k 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0315em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>。（Receding Horizon Control）滚动优化控制<br> 为什么只取<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           u 
          
         
           k 
          
         
        
       
         u_k 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0315em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>那？这是因为如果系统一次预测太多的控制输入，当系统发生变化或者受到外部扰动的时候，接下来的k+1、k+2等时刻预测的未必准。只取<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           u 
          
         
           k 
          
         
        
       
         u_k 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0315em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的滚动优化控制，可以避免这个问题。</li></ol> 
<h2><a id="mpc_10"></a>mpc算法推导</h2> 
<p>考虑一个离散系统，其状态空间表达式为：<br> <img src="https://images2.imgbox.com/62/3d/Ns6J0ASA_o.png" alt="在这里插入图片描述"></p> 
<p>系统输出参考值<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         R 
        
       
         = 
        
       
         0 
        
       
      
        R=0 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0077em;">R</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span></span></span></span></span>，误差为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         E 
        
       
         = 
        
       
         y 
        
       
         − 
        
       
         R 
        
       
         = 
        
       
         x 
        
       
         − 
        
       
         0 
        
       
         = 
        
       
         x 
        
       
      
        E=y-R=x-0=x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">E</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0077em;">R</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span>。<br> 选取这样简单的系统有利于在推导时降低难度。<br> 在k时刻时，我们令：<br> <img src="https://images2.imgbox.com/ca/bf/m3FfTGXi_o.png" alt="(1.2)"></p> 
<p>其中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         u 
        
       
         ( 
        
       
         k 
        
       
         + 
        
       
         1 
        
       
         ∣ 
        
       
         k 
        
       
         ) 
        
       
      
        u(k+1|k) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">u</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1∣</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mclose">)</span></span></span></span></span>表示在k时刻预测的k+1时刻的的系统输入u，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         u 
        
       
         ( 
        
       
         k 
        
       
         + 
        
       
         i 
        
       
         ∣ 
        
       
         k 
        
       
         ) 
        
       
      
        u(k+i|k) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">u</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">i</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mclose">)</span></span></span></span></span>表示的含义类似于<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         u 
        
       
         ( 
        
       
         k 
        
       
         + 
        
       
         1 
        
       
         ∣ 
        
       
         k 
        
       
         ) 
        
       
      
        u(k+1|k) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">u</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1∣</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mclose">)</span></span></span></span></span>，N表示预测区间。<br> 同样地，令：<br> <img src="https://images2.imgbox.com/7a/6d/bNtKwrur_o.png" alt="(1.3)"></p> 
<p>此时的代价函数（cost function）为<br> <img src="https://images2.imgbox.com/7b/8e/dptjUr1G_o.png" alt="(1.4)"></p> 
<p>其中Q 、R、F 为权重系数矩阵，假设其中 Q、R 均为对称矩阵（简单一些）。代价函数包含系统的误差和控制输入，可以通过代价函数的大小来衡量系统的优劣。<br> 根据系统的状态空间表达式，可以推导出：<br> <img src="https://images2.imgbox.com/15/a1/of7zyU4e_o.png" alt="(1.5)"></p> 
<p>将上式写成矩阵形式：<br> <img src="https://images2.imgbox.com/39/09/U8pRP4Dz_o.png" alt="(1.6)"></p> 
<p><img src="https://images2.imgbox.com/c0/85/X34xXfet_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b5/f4/2yFOBxtC_o.png" alt="(1.7)"></p> 
<p>将(1.4)式展开，得：<br> <img src="https://images2.imgbox.com/e1/ce/OFUesQja_o.png" alt="(1.8)"><br> <img src="https://images2.imgbox.com/da/43/HxP62UQs_o.png" alt="在这里插入图片描述"></p> 
<p>以看到代价函数仍然需要 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
         ( 
        
       
         k 
        
       
         + 
        
       
         1 
        
       
         ∣ 
        
       
         k 
        
       
         ) 
        
       
         , 
        
       
         x 
        
       
         ( 
        
       
         k 
        
       
         + 
        
       
         2 
        
       
         ∣ 
        
       
         k 
        
       
         ) 
        
       
      
        x(k+1|k),x(k+2|k) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1∣</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">2∣</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mclose">)</span></span></span></span></span>等下一步未知的状态。而我们的目标是只用控制输入来表示代价函数。将式(1.7)代入(1.8)中，得<br> <img src="https://images2.imgbox.com/49/fd/czwhSlgf_o.png" alt="(1.9)"></p> 
<p>其中 <img src="https://images2.imgbox.com/75/c3/4z9zv4ux_o.png" alt="在这里插入图片描述"></p> 
<p>，可以看到式(1.9)经化简之后，得到最终的形式只包含初始状态 以及控制输入 。之后便是形如代价函数J的二次型函数的最优化问题。<br> Ps:既然初始状态那一项<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          x 
         
        
          k 
         
        
          T 
         
        
       
         G 
        
        
        
          x 
         
        
          k 
         
        
       
      
        x_k^TGx_k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.1244em; vertical-align: -0.2831em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8413em;"><span class="" style="top: -2.4169em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0315em;">k</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.1389em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2831em;"><span class=""></span></span></span></span></span></span><span class="mord mathnormal">G</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0315em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>是固定的，在计算最优化的时候可以不用计算吧。</p> 
<p>本文主要注重的是过程推导，最后我们得到了系统代价函数的简单形式，关于代码，DR_CAN老师的教程中有详细的讲解和实践，有兴趣的可以自行跳转学习。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fac88765bf4f58c2be4f7177f91d2a2e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">快手上线知识产权保护平台；升级“磁力金牛”投流能力</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cc63aa01b5b39b0839a93b99fe094ed0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LinuxIO总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>