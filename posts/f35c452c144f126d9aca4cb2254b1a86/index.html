<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LeetCode: 26. 删除排序数组中的重复项（Java） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LeetCode: 26. 删除排序数组中的重复项（Java）" />
<meta property="og:description" content="题目：
给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
示例 1:
给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为： 你不需要考虑数组中超出新长度后面的元素。 示例 2:
给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2，3，4。 你不需要考虑数组中超出新长度后面的元素。 解答：
要求O(1)空间，hash表是不要指望了；由于数组是排好序的，如果出现重复元素的话，不需要把这个元素删了，只需要用后面的元素把它覆盖就好了。
可以用两个指针front和back来实现：
如果back与front正好重复了，拉动front，直到back和front不重复为止；
反之，进行覆盖操作（back &#43; 1就正好是要覆盖的位置）
class Solution { public int removeDuplicates(int[] nums) { if (nums == null || nums.length == 0) { return 0; } int back = 0; for (int front = 1; front &lt; nums." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f35c452c144f126d9aca4cb2254b1a86/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-21T22:30:59+08:00" />
<meta property="article:modified_time" content="2018-08-21T22:30:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LeetCode: 26. 删除排序数组中的重复项（Java）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>题目：</p> 
<p>给定一个排序数组，你需要在<strong><a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" rel="nofollow">原地</a></strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p> 
<p>不要使用额外的数组空间，你必须在<strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" rel="nofollow">原地</a>修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p> 
<p><strong>示例 1:</strong></p> 
<pre>给定数组 <em>nums</em> = <strong>[1,1,2]</strong>, 

函数应该返回新的长度 <strong>2</strong>, 并且原数组 <em>nums </em>的前两个元素被修改为：
<code><code><code></code></code></code>

你不需要考虑数组中超出新长度后面的元素。</pre> 
<p><strong>示例 2:</strong></p> 
<pre>给定<em> nums </em>= <strong>[0,0,1,1,1,2,2,3,3,4]</strong>,

函数应该返回新的长度 <strong>5</strong>, 并且原数组 <em>nums </em>的前五个元素被修改为 <strong><code>0, 1, 2，3，4。</code></strong>
你不需要考虑数组中超出新长度后面的元素。
</pre> 
<p>解答：</p> 
<p>要求O(1)空间，hash表是不要指望了；由于数组是排好序的，如果出现重复元素的话，不需要把这个元素删了，只需要用后面的元素把它覆盖就好了。</p> 
<p>可以用两个指针front和back来实现：</p> 
<p>如果back与front正好重复了，拉动front，直到back和front不重复为止；</p> 
<p><img alt="" class="has" height="331" src="https://images2.imgbox.com/c5/db/yetZzeFV_o.png" width="442"></p> 
<p>反之，进行覆盖操作（back + 1就正好是要覆盖的位置）</p> 
<p><img alt="" class="has" height="366" src="https://images2.imgbox.com/98/03/9rsf4oqD_o.png" width="457"></p> 
<pre class="has"><code class="language-java">class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int back = 0;
        for (int front = 1; front &lt; nums.length; front++) {
            if (nums[back] != nums[front]) {
                back++;
                nums[back] = nums[front];
            }
        }
        return back + 1;
    }
}</code></pre> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/00883391aede09e83c09f346e387e335/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">配置pod与容器--将内存资源分配给容器和Pod</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5b6f2ba7bb4c3eb7488f68a9f832e0e4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">乔尔·格林布拉特的神奇公式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>