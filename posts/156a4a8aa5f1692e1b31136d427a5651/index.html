<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL的索引与SQL优化策略 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySQL的索引与SQL优化策略" />
<meta property="og:description" content="文章目录 存储引擎常见的存储引擎 索引索引结构B&#43;Tree的优点索引分类索引语法explain执行计划索引的使用原则最左前缀法则范围查询索引列进行运算操作字符串不加引号模糊查询or连接的条件数据分布影响 覆盖索引前缀索引索引的设计原则 SQL优化insert优化主键优化order by优化group by优化limit分页查询优化count优化update优化 存储引擎 存储引擎就是存储数据，建立索引，更新/查询数据等技术的实现方式，存储引擎是基于表而不是基于数据库的（不同的数据库表可以选择不同的存储引擎），所以存储引擎也可被称为表类型
mysql5.5之后，默认存储引擎是InnoDB
使用show关键字查看建表情况
show create table student; 那如何在建表的时候指定存储引擎呢？
create table student( id int, name varchar(10) )ENGINE=INNODB; 查看当前数据库支持的存储引擎
show engines; 常见的存储引擎 InnoDB存储引擎
一种兼顾高可靠性和高性能的存储引擎，MySQL5.5之后，InnoDB是默认的存储引擎
特点：
增删改语句（DML）遵循ACID，支持事物行级锁，提高并发访问性能支持外键约束，保证数据的完整性和正确性 InnoDB会为每张表都生成一个表空间文件xxx.ibd，存储表结构，数据，索引
MyISAM存储引擎
是MySQL早期的默认存储引擎
特点：
不支持事务，不支持外键支持表锁，不支持行级锁访问速度快 Memory存储引擎
表数据存储在内存中，会受到断电，硬件问题的影响，这些表只能当作临时表和缓存使用
特点：
数据存储在内存中，访问速度快支持hash索引（默认） InnoDB与MyISAM区别
InnoDB支持事务，支持外键，支持行级锁MyISAM不支持事务，支持表锁，不支持外键 索引 索引就是一种帮助我们快速高效获取数据的有序的数据结构
例如这样一条sql：
select * from student where age = 20; 在无索引的情况下，会依次遍历整张表直到找到全部复合条件的
在有索引的情况下，会很快速的找到复合条件的全部数据
优点：
提高查询数据的效率，降低数据库IO的开销 提高了数据排序效率，降低CPU消耗 缺点：
索引需要用一个数据结构来维护，本身是需要占用空间的降低了表的更新效率，因为插入，删除，修改的同时也要更新索引的结构 索引结构 MySQL的索引是在引擎层实现的，也就是不同的引擎有不同的索引结构
B&#43;Tree结构：最常见的索引类型，大部分引擎都支持B&#43;Tree索引Hash索引：底层使用哈希表实现，可精确匹配列的查询，但是不支持范围查询（只有Memory存储引擎支持）Full-text（全文索引）：是一种通过建立倒排索引，快速匹配文档的方式 二叉树
但是如果插入元素的时候就是按顺序插入，该树就变为单支树
此时查询性能大大降低，大数据量情况下层级较深，检索速度慢
为了解决上述单分支情况，我们可以使用红黑树（自平衡的二叉树），但是红黑树一个结点也只有两个分支是一个二叉树，当数据量大的时树的高度也会很深，导致检索速度慢
B-Tree" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/156a4a8aa5f1692e1b31136d427a5651/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-23T12:09:06+08:00" />
<meta property="article:modified_time" content="2023-04-23T12:09:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL的索引与SQL优化策略</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">存储引擎</a></li><li><ul><li><a href="#_25" rel="nofollow">常见的存储引擎</a></li></ul> 
  </li><li><a href="#_59" rel="nofollow">索引</a></li><li><ul><li><a href="#_77" rel="nofollow">索引结构</a></li><li><a href="#BTree_130" rel="nofollow">B+Tree的优点</a></li><li><a href="#_137" rel="nofollow">索引分类</a></li><li><a href="#_154" rel="nofollow">索引语法</a></li><li><a href="#explain_169" rel="nofollow">explain执行计划</a></li><li><a href="#_189" rel="nofollow">索引的使用原则</a></li><li><ul><li><a href="#_192" rel="nofollow">最左前缀法则</a></li><li><a href="#_224" rel="nofollow">范围查询</a></li><li><a href="#_234" rel="nofollow">索引列进行运算操作</a></li><li><a href="#_244" rel="nofollow">字符串不加引号</a></li><li><a href="#_249" rel="nofollow">模糊查询</a></li><li><a href="#or_260" rel="nofollow">or连接的条件</a></li><li><a href="#_266" rel="nofollow">数据分布影响</a></li></ul> 
   </li><li><a href="#_269" rel="nofollow">覆盖索引</a></li><li><a href="#_274" rel="nofollow">前缀索引</a></li><li><a href="#_281" rel="nofollow">索引的设计原则</a></li></ul> 
  </li><li><a href="#SQL_288" rel="nofollow">SQL优化</a></li><li><ul><li><a href="#insert_289" rel="nofollow">insert优化</a></li><li><a href="#_308" rel="nofollow">主键优化</a></li><li><a href="#order_by_316" rel="nofollow">order by优化</a></li><li><a href="#group_by_327" rel="nofollow">group by优化</a></li><li><a href="#limit_331" rel="nofollow">limit分页查询优化</a></li><li><a href="#count_337" rel="nofollow">count优化</a></li><li><a href="#update_356" rel="nofollow">update优化</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>存储引擎</h2> 
<blockquote> 
 <p>存储引擎就是存储数据，建立索引，更新/查询数据等技术的实现方式，存储引擎是<code>基于表</code>而不是基于数据库的（不同的数据库表可以选择不同的存储引擎），所以存储引擎也可被称为表类型</p> 
</blockquote> 
<p>mysql5.5之后，默认存储引擎是<code>InnoDB</code></p> 
<p><img src="https://images2.imgbox.com/9b/07/bbSTKUkj_o.png" alt="在这里插入图片描述"></p> 
<p>使用<code>show</code>关键字查看建表情况</p> 
<pre><code class="prism language-sql"><span class="token keyword">show</span> <span class="token keyword">create</span> <span class="token keyword">table</span> student<span class="token punctuation">;</span>
</code></pre> 
<p>那如何在建表的时候指定存储引擎呢？</p> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> student<span class="token punctuation">(</span>
    id <span class="token keyword">int</span><span class="token punctuation">,</span>
    name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">INNODB</span><span class="token punctuation">;</span>
</code></pre> 
<p>查看当前数据库支持的存储引擎</p> 
<pre><code class="prism language-sql"><span class="token keyword">show</span> engines<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/6e/78/8rL9CUU7_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_25"></a>常见的存储引擎</h3> 
<blockquote> 
 <p>InnoDB存储引擎</p> 
</blockquote> 
<p>一种兼顾高可靠性和高性能的存储引擎，MySQL5.5之后，InnoDB是默认的存储引擎</p> 
<p>特点：</p> 
<ul><li>增删改语句（DML）遵循ACID，支持<code>事物</code></li><li><code>行级锁</code>，提高并发访问性能</li><li>支持<code>外键约束</code>，保证数据的完整性和正确性</li></ul> 
<p>InnoDB会为每张表都生成一个<code>表空间文件</code>xxx.ibd，存储表结构，数据，索引</p> 
<blockquote> 
 <p>MyISAM存储引擎</p> 
</blockquote> 
<p>是MySQL早期的默认存储引擎</p> 
<p>特点：</p> 
<ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行级锁</li><li>访问速度快</li></ul> 
<blockquote> 
 <p>Memory存储引擎</p> 
</blockquote> 
<p>表数据存储在内存中，会受到断电，硬件问题的影响，这些表只能当作临时表和缓存使用</p> 
<p>特点：</p> 
<ul><li>数据存储在内存中，访问速度快</li><li>支持hash索引（默认）</li></ul> 
<blockquote> 
 <p>InnoDB与MyISAM区别</p> 
</blockquote> 
<ul><li>InnoDB支持事务，支持外键，支持行级锁</li><li>MyISAM不支持事务，支持表锁，不支持外键</li></ul> 
<h2><a id="_59"></a>索引</h2> 
<p>索引就是一种帮助我们快速高效获取数据的有序的<code>数据结构</code></p> 
<p>例如这样一条sql：</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
</code></pre> 
<p>在无索引的情况下，会依次遍历整张表直到找到全部复合条件的<br> 在有索引的情况下，会很快速的找到复合条件的全部数据</p> 
<p>优点：</p> 
<ul><li><code>提高查询数据的效率</code>，降低数据库IO的开销</li><li><code> 提高了数据排序效率</code>，降低CPU消耗</li></ul> 
<p>缺点：</p> 
<ul><li>索引需要用一个数据结构来维护，本身是需要占用空间的</li><li><code>降低了表的更新效率</code>，因为插入，删除，修改的同时也要更新索引的结构</li></ul> 
<h3><a id="_77"></a>索引结构</h3> 
<blockquote> 
 <p>MySQL的索引是在<code>引擎层实现</code>的，也就是不同的引擎有不同的索引结构</p> 
</blockquote> 
<ul><li>B+Tree结构：最常见的索引类型，大部分引擎都支持B+Tree索引</li><li>Hash索引：底层使用哈希表实现，可精确匹配列的查询，但是不支持范围查询（只有Memory存储引擎支持）</li><li>Full-text（全文索引）：是一种通过建立倒排索引，快速匹配文档的方式</li></ul> 
<blockquote> 
 <p>二叉树</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/94/03/NKMr8d2p_o.png" alt="在这里插入图片描述"></p> 
<p>但是如果插入元素的时候就是按顺序插入，该树就变为单支树<br> <img src="https://images2.imgbox.com/94/29/tNKNFL7k_o.png" alt="在这里插入图片描述"></p> 
<p>此时查询性能大大降低，大数据量情况下层级较深，检索速度慢</p> 
<p>为了解决上述单分支情况，我们可以使用红黑树（自平衡的二叉树），但是红黑树一个结点也只有两个分支是一个二叉树，当数据量大的时树的高度也会很深，导致检索速度慢</p> 
<blockquote> 
 <p>B-Tree</p> 
</blockquote> 
<p>B树是一个多路平衡查找树，每个结点存<code>n个key，n+1个指针</code>，（key存的其实是数据存储位置的地址）每个key下有对应的数据</p> 
<p>以一颗度数最大为5的B-Tree举例（度数为一个结点的子节点个数），度数最大为5，则最多存4个key，5个指针</p> 
<p><img src="https://images2.imgbox.com/bb/eb/izRgE7JT_o.png" alt="在这里插入图片描述"><br> 在插入数据时，如果某个结点的指针数要大于树的最大度时，该结点的中间元素会向上分裂<br> <img src="https://images2.imgbox.com/9d/35/fydTSukq_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>B+Tree</p> 
</blockquote> 
<p>B+Tree其实是B树的变种</p> 
<p>此处以最大度数为4的B+Tree举例<br> <img src="https://images2.imgbox.com/6e/f1/gt6f4l85_o.png" alt="在这里插入图片描述"><br> 特点：</p> 
<ul><li>所有的元素都会出现在叶子节点（父结点会在孩子结点中体现）</li><li>数据在叶子节点中保存</li><li>叶子结点使用单向链表连接</li></ul> 
<blockquote> 
 <p>MySQL索引数据结构对<code>B+Tree做了优化</code>，叶子结点使用<code>双向链表</code>连接，提高了<code>区间数据</code>的访问性能</p> 
</blockquote> 
<blockquote> 
 <p>Hash索引</p> 
</blockquote> 
<p>使用一定的hash算法，将键值计算出一个哈希地址，映射到对应的哈希桶中，存储在哈希表中</p> 
<p>特点：</p> 
<ul><li>Hash索引只能用于对等比较，<code>不支持范围查询</code></li><li>无法利用索引进行排序操作</li><li>查询效率高，一般只需一次检索就可以</li></ul> 
<p>在MySQL中支持Hash索引的是Memory引擎，但<code>InnoDB具有自适应的哈希功能</code>，hash索引是存储引擎根据B+Tree索引在指定条件下自动创建的</p> 
<h3><a id="BTree_130"></a>B+Tree的优点</h3> 
<p>为什么InnoDB选择用B+Tree作为索引？</p> 
<ul><li>相于对二叉树，层级更少，搜索效率高</li><li>相对于B树，B树的结点中会存储数据，导致存储的key和指针减少，而B+Tree树的数据只存在叶子节点，那非叶子结点的key和指针就更多，导致相同数据量下，B+Tree的层级相对于B树更少，搜索效率更高，并且B+Tree的叶子用双向链表连接便于范围查找</li><li>相对与Hash索引，Hash索引只支持等值匹配，不支持范围匹配</li></ul> 
<h3><a id="_137"></a>索引分类</h3> 
<ul><li>主键索引：根据表中的主键自动创建的索引，只能有一个（PRIMARY KEY）</li><li>唯一索引：避免同一表中列数据的重复，可以有多个(UNIQUE)</li><li>常规索引：快速定位特殊数据，可以有多个</li><li>全文索引：全文索引查找的是文本中的关键词，而不是比较索引中的值(FULLTEXT)</li></ul> 
<p>在InnoDB中根据索引的存储形式又分为聚集索引，二级索引</p> 
<ul><li><code> 聚集索引</code>：将数据与索引存在一起，索引结构的叶子结点存储的是行数据（必须<code>有且只能有一个</code>）</li><li><code>二级索引</code>：将数据与索引分开存储，索引结构的<code>叶子结点存储的是对应的主键</code>（可以有多个）</li></ul> 
<blockquote> 
 <p>聚集索引的选取规则</p> 
</blockquote> 
<ul><li>如果表中有主键，那聚集索引就是主键索引</li><li>如果没有主键，将选取第一个唯一索引作为聚集索引</li><li>如果没有主键也没有唯一索引，则InnoDB会自动创建一个rowid作为隐藏的聚集索引</li></ul> 
<blockquote> 
 <p><code>回表查询</code>：先根据二级索引找到主键值，再拿主键值根据聚集索引找打行数据</p> 
</blockquote> 
<h3><a id="_154"></a>索引语法</h3> 
<blockquote> 
 <p>创建索引</p> 
</blockquote> 
<p><code>create index 索引名 on 表名（字段1，字段2...）；</code></p> 
<p>一个索引可以关联一个字段也可以关联多个字段</p> 
<blockquote> 
 <p>查看索引</p> 
</blockquote> 
<p><code>show index from 表名；</code></p> 
<blockquote> 
 <p>删除索引</p> 
</blockquote> 
<p><code>drop index 索引名 on 表名；</code></p> 
<h3><a id="explain_169"></a>explain执行计划</h3> 
<p>使用<code>explain</code>获取MySQL如何执行select语句的信息</p> 
<blockquote> 
 <p>explain sql语句；</p> 
</blockquote> 
<pre><code class="prism language-sql"> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/d9/6a/bPmU7Dwx_o.png" alt="在这里插入图片描述"><br> explain执行计划各字段的含义：</p> 
<ul><li>id：表示执行select语句操作表的顺序，如果id相同则执行顺序从上往下，id不同，值越大，越先执行（多表查询下，会出现多个行表示不同表的执行情况）</li><li>select_type：表示select的类型</li><li>table：查询访问的表名</li><li>type：表示连接类型，性能由好到差的连接类型为NULL，system，const，eq_ref，ref，range，index，all</li><li>possible_keys：显示这张表中可能用到的索引</li><li><code>key</code>：显示实际用到的索引</li><li><code>key_len</code>：显示表中使用索引的字节数，该字节数为索引的最大长度并非实际长度，长度越短越好</li><li>rows：MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能不准确</li><li>filtered：表示返回结果的行数占需要读取行数百分比，该值越大越好</li><li>Extra：用来展示前面几个字段没有展示出来的额外的信息</li></ul> 
<h3><a id="_189"></a>索引的使用原则</h3> 
<h4><a id="_192"></a>最左前缀法则</h4> 
<p>主要是针对<code>联合索引（</code>索引关联了多个列），要遵循最左前缀法则</p> 
<blockquote> 
 <p>它指的是从索引的最左列开始，并且不跳过索引中的列（索引的字段存在就行，不要求位置严格按照顺序），如果跳过某一列，索引将部分失效（后面的字段索引失效）</p> 
</blockquote> 
<blockquote> 
 <p>示例</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/27/b5/kDhqJalv_o.png" alt="在这里插入图片描述"><br> 发现联合索引字段的顺序从左往右为name，age，height，所以我们使用联合索引的时候必须按照这个顺序，如果跳过某列，则从跳过的开始，后面索引失效</p> 
<p>索引生效:</p> 
<p><img src="https://images2.imgbox.com/18/bd/biiPEduU_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/a0/60/8SxvixPO_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/6a/86/3q2c803j_o.png" alt="在这里插入图片描述"></p> 
<p>索引失效:</p> 
<p><img src="https://images2.imgbox.com/d4/0c/gR6hOSMR_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/84/fe/9shWnqbr_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/23/32/nqVTjMTc_o.png" alt="在这里插入图片描述"></p> 
<p>发现此时跳过了age，但是索引还是生效了，其实此时索引只有name生效了，height并未走索引，可以看索引的长度，只由name的长度</p> 
<p><img src="https://images2.imgbox.com/b9/b2/UnI04e8E_o.png" alt="在这里插入图片描述"></p> 
<p>最左前缀法则不严格要求位置顺序，只要字索引段存在就行</p> 
<h4><a id="_224"></a>范围查询</h4> 
<p>联合索引中，出现范围查询<code>（&gt; &lt;）</code>，<code>范围查询右侧的列索引失效</code>，尽量使用<code>&gt;= &lt;=</code>避免因为范围查询导致索引失效</p> 
<p><img src="https://images2.imgbox.com/7e/79/sPhdIXPN_o.png" alt="在这里插入图片描述"><br> 发现虽然走了索引，但是范围查询右边的列height没有走索引</p> 
<p><img src="https://images2.imgbox.com/99/da/zwvLKmEJ_o.png" alt="在这里插入图片描述"></p> 
<p>给范围查询加上=号后，发现都走了索引</p> 
<h4><a id="_234"></a>索引列进行运算操作</h4> 
<p>如果有索引的列进行了运算操作，那么索引将失效</p> 
<p><img src="https://images2.imgbox.com/69/2a/vRxMVjnX_o.png" alt="在这里插入图片描述"><br> 在索引的列上进行了字符串截取操作，发现索引失效</p> 
<p><img src="https://images2.imgbox.com/d7/04/47TlT3oW_o.png" alt="在这里插入图片描述"></p> 
<p>把索引的列字符串截取操作取消后，发现索引生效</p> 
<h4><a id="_244"></a>字符串不加引号</h4> 
<p>字符串不加引号，索引失效</p> 
<p>这是针对字符串里存的是<code>数字</code>，如果存的不是数字，不加引号会报错</p> 
<h4><a id="_249"></a>模糊查询</h4> 
<p>如果是<code>尾部模糊匹配，索引不会失效</code>，如果是<code>头部模糊匹配，索引失效</code></p> 
<p><img src="https://images2.imgbox.com/3f/7b/aEWhXep7_o.png" alt="在这里插入图片描述"></p> 
<p>头部模糊匹配，索引失效</p> 
<p><img src="https://images2.imgbox.com/78/e9/8ThUUY1R_o.png" alt="在这里插入图片描述"></p> 
<p>尾部模糊匹配，索引生效</p> 
<h4><a id="or_260"></a>or连接的条件</h4> 
<p>用or分割开的条件，如果前面有索引，后面没有索引，那么涉及到的索引都不会用到</p> 
<p><img src="https://images2.imgbox.com/5a/62/jyjcr9RT_o.png" alt="在这里插入图片描述"><br> id有索引，name没有索引，那id的索引也不会用到</p> 
<h4><a id="_266"></a>数据分布影响</h4> 
<blockquote> 
 <p>MySQL会评估使用索引会不会比走全表扫描慢，如果比全表扫描慢则会不走索引</p> 
</blockquote> 
<h3><a id="_269"></a>覆盖索引</h3> 
<p>在查询的时候尽量使用<code>覆盖索引</code>（需要查询的字段，在索引中都能找到）</p> 
<p>减少<code>select *</code>的使用，因为查找全部字段可能某个字段没有索引，就会出现<code>回表查询</code></p> 
<h3><a id="_274"></a>前缀索引</h3> 
<blockquote> 
 <p>当字段类型为varchar，text时，有时候索引需要很长的字符串，这时候索引很大，查询时，浪费大量的磁盘IO，影响查询效率，这时候可以只将字符串的一部分前缀作为索引，减少了索引空间，提升了查询效率</p> 
</blockquote> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> <span class="token keyword">index</span> 索引名 <span class="token keyword">on</span> 表明<span class="token punctuation">(</span>字段<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>将字段的前n个字符作为索引</p> 
<h3><a id="_281"></a>索引的设计原则</h3> 
<ol><li>对于数据量大并且查询比较频繁的表建立合适的索引</li><li>对于常作为查询条件where，order by，group by操作的字段建立索引，使用时注意最左前缀法则</li><li>如果是字符串或者长文本类型，可以根据字段的特点建立前缀索引</li><li>尽量使用联合索引，减少单列索引，因为联合索引可以尽可能做到覆盖索引，避免回表查询</li><li>索引也不是越多越好，因为索引也需要数据结构来维护，索引越多，维护成本越大，增删改效率降低</li></ol> 
<h2><a id="SQL_288"></a>SQL优化</h2> 
<h3><a id="insert_289"></a>insert优化</h3> 
<ul><li>批量插入</li></ul> 
<p>建议使用批量插入，因为单此插入的话每次都要与数据库建立连接然后通过网络进行传输，降低了插入效率</p> 
<ul><li>手动提交事务</li></ul> 
<p>MySQL默认执行每条sql都会开启事务并提交事务，我们可以在多条sql前后手动控制事务的开启与提交</p> 
<ul><li>主键顺序插入</li></ul> 
<p>主键按顺序插入比乱序插入效率更高</p> 
<ul><li>使用load加载大数据量</li></ul> 
<p>如果一次性需要插入大量数据，使用insert语句插入性能较差，可以使用load命令进行插入，load加载文件到数据表中</p> 
<h3><a id="_308"></a>主键优化</h3> 
<ul><li> <p>主键<code>按顺序插入</code>，如果乱序插入则会出现<code>页分裂</code>，也就是存储索引的B+Tree某些结点的中间元素向上分裂，选择auto_increment自增主键</p> </li><li> <p>降低主键索引的长度，因为二级索引叶子存主键数据，如果主键过长，导致二级索引的查找时耗过长，耗费大量的磁盘IO</p> </li><li> <p>尽量不要使用UUID或其他自然数据作为主键，例：身份证，本身主键过程并且无法保证顺序插入</p> </li></ul> 
<h3><a id="order_by_316"></a>order by优化</h3> 
<p>默认创建的索引会按照升序排序</p> 
<ul><li>根据合适的字段建立索引，多字段排序时，也<code>遵循最左前缀法则</code></li><li>尽量使用<code>覆盖索引</code>，避免回表查询</li><li>多字段排序，一个升序，一个降序，注意联合索引创建的规则</li></ul> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> <span class="token keyword">index</span> 索引名 <span class="token keyword">on</span> 表<span class="token punctuation">(</span>字段<span class="token number">1</span> <span class="token keyword">desc</span>，字段<span class="token number">2</span> <span class="token keyword">asc</span><span class="token punctuation">)</span>
</code></pre> 
<ul><li>大数据量排序时，可适当增加排序缓冲区sort_buffer_size（默认为256k）</li></ul> 
<h3><a id="group_by_327"></a>group by优化</h3> 
<ul><li>分组操作，可以通过<code>索引</code>提高效率</li><li>分组操作，索引的使用也是要满足最左前缀法则</li></ul> 
<h3><a id="limit_331"></a>limit分页查询优化</h3> 
<p>通过覆盖索引+子查询的方式优化</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student s，<span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> student <span class="token keyword">limit</span> <span class="token number">20000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> i <span class="token keyword">where</span> s<span class="token punctuation">.</span>id<span class="token operator">=</span>i<span class="token punctuation">.</span>id；
</code></pre> 
<h3><a id="count_337"></a>count优化</h3> 
<ul><li>count(*) count(主键) ：统计表的总行数</li><li>count(字段)：统计的是该字段不为空时的总记录</li><li>count(1)：在表的中添加1这个列，然后统计行数</li></ul> 
<blockquote> 
 <p>区别</p> 
</blockquote> 
<ul><li>count(*)：InnoDB引擎遍历表时，<code>不会把数据取出来</code>，而是进行优化，<code>服务层直接按行累加</code></li><li>count(主键)：遍历表的每一行，<code>获取主键值</code>，按行累加</li><li>count(字段)： 
  <ul><li>当该字段没有not null约束时，遍历整张表，获取每行该字段值，按行累加</li><li>当该字段有not null约束时，遍历整张表，获取每行该字段值，<code>判断是否为null，不是null进行累加</code></li></ul> </li><li>count(1)：遍历整张表，<code>不取值</code>，服务层对于每一行放一个数字1进去，直接按行累加</li></ul> 
<p>故按照效率排序：count(*) = count(1) &gt; count(主键) &gt; count(字段)</p> 
<blockquote> 
 <p>故尽量使用<code>count(*)</code></p> 
</blockquote> 
<h3><a id="update_356"></a>update优化</h3> 
<ul><li> <p>使用update更新数据时，<code>尽量使用索引字段更新，否则行锁会升级为表锁</code>，如果是表锁则并发性能会降低</p> </li><li> <p><code>InnoDB的行锁是针对索引加的锁</code>，不是针对记录加的锁，<code>并且该索引不能失效，否则行锁会升级为表锁</code></p> </li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e0c014c79a6cafa603c0367d798e7479/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">说说“集成平台”</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6a2922fa4f9f7fcfa5e2bbfa494e7de4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">oracle-超全的多表查询连接</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>