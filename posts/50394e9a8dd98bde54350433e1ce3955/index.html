<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python3 Flask Redis 如何切换数据库 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python3 Flask Redis 如何切换数据库" />
<meta property="og:description" content="项目背景： 之前在做项目的时候，由于是采用微服务架构，所有服务通信使用 Redis 作为数据交互层。需求是不同类型的数据存储在不同的数据库中，不同的数据库就需要动态切换 Redis 数据库。
Redis 默认有 16 个数据库，index(值范围：0~15)，默认 index=0。切换数据库命令为：select index。
但是呢，flask_redis 却没有这个功能。为什么会没有呢？因为 redis-py 就没有。flask_redis 是基于 redis-py 进行二次封装的库，redis-py 为了保证 Redis 实例的线程安全，没有实现 SELECT 指令。
Redis 客户端实例可以安全地在线程间共享。从内部实现来说，只有在命令执行时才获取连接实例，完成后直接返回连接池，命令永不修改客户端实例的状态。但是，有一点需要注意：SELECT 命令。SELECT 命令允许切换当前连接使用的数据库。新的数据库保持被选中状态，直到选中另一个数据库或连接关闭。这会导致在返回连接池时，连接可能指定了别的数据库。因此，redis-py 没有在客户端实例中实现 SELECT 命令。如果要在同一个应用中使用多个 Redis 数据库，应该给第一个数据库创建独立的客户端实例（可能也需要独立的连接池）。
参考：https://segmentfault.com/q/1010000012594548
解决方案 flask_redis 既然不能动态切换数据库，那我们就从根源入手——使用前都重新连接并指定数据库。
感觉是挺暴力的，其实，这是官方建议的做法。自己动手丰衣足食，接下来我们就来封装一个支持动态切换数据库的 Redis，需要满足用户在使用的时候无感知。
废话不多说，直接上代码：
#!/usr/bin/env python3 # -*- coding: UTF-8 -*- import copy import datetime from redis import StrictRedis, ConnectionPool class RedisLib(object): def __init__(self, redis_db, redis_url, blacklist=None): self.redis = None self.redis_db = redis_db self." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/50394e9a8dd98bde54350433e1ce3955/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-23T18:05:52+08:00" />
<meta property="article:modified_time" content="2020-09-23T18:05:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python3 Flask Redis 如何切换数据库</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="_0"></a>项目背景：</h4> 
<p>之前在做项目的时候，由于是采用微服务架构，所有服务通信使用 <code>Redis</code> 作为数据交互层。需求是不同类型的数据存储在不同的数据库中，不同的数据库就需要动态切换 <code>Redis</code> 数据库。</p> 
<p><code>Redis</code> 默认有 <code>16</code> 个数据库，<code>index</code>(值范围：<code>0~15</code>)，默认 <code>index=0</code>。切换数据库命令为：<code>select index</code>。</p> 
<p>但是呢，<code>flask_redis</code> 却没有这个功能。为什么会没有呢？因为 <code>redis-py</code> 就没有。<code>flask_redis</code> 是基于 <code>redis-py</code> 进行二次封装的库，<code>redis-py</code> 为了保证 <code>Redis</code> 实例的线程安全，没有实现 <code>SELECT</code> 指令。</p> 
<blockquote> 
 <p>Redis 客户端实例可以安全地在线程间共享。从内部实现来说，只有在命令执行时才获取连接实例，完成后直接返回连接池，命令永不修改客户端实例的状态。但是，有一点需要注意：SELECT 命令。SELECT 命令允许切换当前连接使用的数据库。新的数据库保持被选中状态，直到选中另一个数据库或连接关闭。这会导致在返回连接池时，连接可能指定了别的数据库。因此，redis-py 没有在客户端实例中实现 SELECT 命令。如果要在同一个应用中使用多个 Redis 数据库，应该给第一个数据库创建独立的客户端实例（可能也需要独立的连接池）。</p> 
</blockquote> 
<p>参考：<a href="https://segmentfault.com/q/1010000012594548" rel="nofollow">https://segmentfault.com/q/1010000012594548</a></p> 
<h4><a id="_11"></a>解决方案</h4> 
<p><code>flask_redis</code> 既然不能动态切换数据库，那我们就从根源入手——使用前都重新连接并指定数据库。</p> 
<p>感觉是挺暴力的，其实，这是官方建议的做法。自己动手丰衣足食，接下来我们就来封装一个支持动态切换数据库的 <code>Redis</code>，需要满足用户在使用的时候无感知。</p> 
<p>废话不多说，直接上代码：</p> 
<pre><code>#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

import copy
import datetime

from redis import StrictRedis, ConnectionPool


class RedisLib(object):

    def __init__(self, redis_db, redis_url, blacklist=None):
        self.redis = None
        self.redis_db = redis_db
        self.redis_url = redis_url
        self.blacklist = blacklist
        self.blacklist_data = None

    def select(self, db):
        url = '%s/%s' % (self.redis_url, db.split('db')[1])
        pool = ConnectionPool.from_url(url=url, decode_responses=True)
        self.redis = StrictRedis(connection_pool=pool)

    def push_redis(self, db, data):

        def handle_data():

            self.blacklist_data = [value for value in map(
                lambda index: data.pop(index) if data.get(index) else None, self.blacklist)]

            key = '%s:%s' % (self.redis_db[db], data['id'])

            for k, v in data.items():
                self.redis.hset(key, k, v.strftime("%Y-%m-%d %H:%M:%S") if isinstance(
                    v, datetime.datetime) else (v if v else ''))

        self.select(db)

        if isinstance(data, list):
            for obj in data:
                data = copy.deepcopy(obj.__dict__)
                handle_data()
        else:
            data = copy.deepcopy(data.__dict__)
            handle_data()

    def pull_redis(self, db, _id=None):

        self.select(db)

        key = '%s:%s' % (self.redis_db[db], _id if _id else '')

        if _id is None:
            data = self.redis.dbsize()
        elif _id == 'key':
            data = self.redis.keys()
        elif _id == '*':
            data = [self.redis.hgetall(key) for key in self.redis.keys()]
        else:
            data = self.redis.hgetall(key)
        return data

    def __del__(self):
    	self.redis.connection_pool.disconnect()
</code></pre> 
<p>以上代码就是实现了新增数据、获取数据、切换数据库的功能，在实例化的时候需要进行配置。虽然可以使用了，但是并不友好，因为我每次都得需要指定数据库，那有没有什么方法可以连数据库指定都不用呢？</p> 
<p>当然有的啦！</p> 
<p>那就是再写一个[狗头]哈哈！</p> 
<pre><code>class HandleQueue(RedisLib):

    def __init__(self):

        self.redis_db = {
            'db0': None,
            'db1': 'oss:aop:user',
            'db9': 'oss:aop:role'
        }

        self.redis_url = 'redis://127.0.0.1:6379'

        # Flask app config from redis url
        # from app import app
        # self.redis_url = app.config['REDIS_URL']

        self.blacklist = ['_sa_instance_state', 'version', 'status']

        RedisLib.__init__(self, self.redis_db, self.redis_url, self.blacklist)

    def set_user_data(self, data):
        return self.push_redis('db1', data)

    def get_user_data(self, user_id=None):
        return self.pull_redis('db1', user_id)

    def set_role_data(self, data):
        return self.push_redis('db9', data)

    def get_role_data(self, dict_id=None):
        return self.pull_redis('db9', dict_id)


if __name__ == '__main__':
    handle_queue = HandleQueue()
    return_value = handle_queue.get_user_data(1)
    print(return_value)
</code></pre> 
<p>运行结果：</p> 
<pre><code>{'username': '极客点儿', 'role_id': '2', 'phone': '', 'account': 'GeekDot', 'mail': '', 'update_time': '2020-09-22 15:52:32', 'create_time': '2020-08-13 16:51:51', 'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2MDA4NDc1NTIsImlhdCI6MTYwMDc2MTE1MiwiaXNzIjoiMjF2aWFuZXQiLCJkYXRhIjp7ImlkIjoxfX0.fEAfuRC3tvA-qv5j6Xjbqu9W8ksY4PZwYwFoI3ST3xU', 'number': '', 'id': '1'}
</code></pre> 
<p>通过类继承把切换数据库等基本功都保留，然后通过构造函数配置数据库，最后用到哪些数据和数据库就写一个很简单的方法即可。</p> 
<p>因为我们是 <code>Flask</code> 项目，所以要使用 <code>Flask</code> 的配置文件，方法如下，也很简单。</p> 
<pre><code># Flask app config from redis url
# from app import app
# self.redis_url = app.config['REDIS_URL']
</code></pre> 
<p>因为项目组中用的是 <code>ORM</code> 所以 <code>push_redis</code> 现在只能接受 <code>ORM</code> 对象。如果想支持其他对象，可以自己改写，也简单。</p> 
<p>最后别忘了使用析构函数将数据库关闭！</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/064ab5cec1475b0e1a1b850a462d187d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一张手绘图带你搞懂空间注意力、通道注意力、local注意力及生成过程（附代码注释）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f74bac0617d139aecd26d57df36e6611/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">设计模式之抽象工厂模式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>