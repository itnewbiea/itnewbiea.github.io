<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>acwing蓝桥杯c&#43;&#43;A/B组辅导课--第三讲 数学与简单dp - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="acwing蓝桥杯c&#43;&#43;A/B组辅导课--第三讲 数学与简单dp" />
<meta property="og:description" content="1.买不到的数目 小明开了一家糖果店。
他别出心裁：把水果糖包成4颗一包和7颗一包的两种。
糖果不能拆包卖。
小朋友来买糖的时候，他就用这两种包装来组合。
当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。
你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是17。
大于17的任何数字都可以用4和7组合出来。
本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。
输入格式
两个正整数 n,m，表示每种包装中糖的颗数。
输出格式
一个正整数，表示最大不能买到的糖数。
数据范围
2≤n,m≤1000
保证数据一定有解。
输入样例：
4 7 输出样例：
17 本题考查性质：两个数p，q，最大不能凑出的数是(p-1)*(q-1)-1
可以用打表的方式找规律
#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; int main() { int p,q; cin&gt;&gt;p&gt;&gt;q; cout&lt;&lt;(p-1)*(q-1)-1; return 0; } 2.蚂蚁感冒 长 100 厘米的细长直杆子上有 n 只蚂蚁。
它们的头有的朝左，有的朝右。
每只蚂蚁都只能沿着杆子向前爬，速度是 1 厘米/秒。
当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。
这些蚂蚁中，有 1 只蚂蚁感冒了。
并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。
请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。
输入格式
第一行输入一个整数 n, 表示蚂蚁的总数。
接着的一行是 n 个用空格分开的整数 Xi, Xi 的绝对值表示蚂蚁离开杆子左边端点的距离。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c632b506405a6e12fa53ab0703543891/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-07T20:40:19+08:00" />
<meta property="article:modified_time" content="2022-03-07T20:40:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">acwing蓝桥杯c&#43;&#43;A/B组辅导课--第三讲 数学与简单dp</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.买不到的数目</h2> 
<p>小明开了一家糖果店。</p> 
<p>他别出心裁：把水果糖包成4颗一包和7颗一包的两种。</p> 
<p>糖果不能拆包卖。</p> 
<p>小朋友来买糖的时候，他就用这两种包装来组合。</p> 
<p>当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。</p> 
<p>你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是17。</p> 
<p>大于17的任何数字都可以用4和7组合出来。</p> 
<p>本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。</p> 
<p>输入格式</p> 
<p>两个正整数 n,m，表示每种包装中糖的颗数。</p> 
<p>输出格式</p> 
<p>一个正整数，表示最大不能买到的糖数。</p> 
<p>数据范围</p> 
<p>2≤n,m≤1000<br> 保证数据一定有解。</p> 
<p>输入样例：</p> 
<pre><code>4 7
</code></pre> 
<p>输出样例：</p> 
<pre><code>17
</code></pre> 
<p>  </p> 
<p>本题考查性质：两个数p，q，最大不能凑出的数是(p-1)*(q-1)-1</p> 
<p>可以用打表的方式找规律</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
int main()
{
    int p,q;
    cin&gt;&gt;p&gt;&gt;q;
    cout&lt;&lt;(p-1)*(q-1)-1;
    return 0;
}</code></pre> 
<h2>2.蚂蚁感冒</h2> 
<p>长 100 厘米的细长直杆子上有 n 只蚂蚁。</p> 
<p>它们的头有的朝左，有的朝右。</p> 
<p>每只蚂蚁都只能沿着杆子向前爬，速度是 1 厘米/秒。</p> 
<p>当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。</p> 
<p>这些蚂蚁中，有 1 只蚂蚁感冒了。</p> 
<p>并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。</p> 
<p>请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。</p> 
<p>输入格式</p> 
<p>第一行输入一个整数 n, 表示蚂蚁的总数。</p> 
<p>接着的一行是 n 个用空格分开的整数 Xi, Xi 的绝对值表示蚂蚁离开杆子左边端点的距离。</p> 
<p>正值表示头朝右，负值表示头朝左，数据中不会出现 0 值，也不会出现两只蚂蚁占用同一位置。</p> 
<p>其中，第一个数据代表的蚂蚁感冒了。</p> 
<p>输出格式</p> 
<p>输出1个整数，表示最后感冒蚂蚁的数目。</p> 
<p>数据范围</p> 
<p>1&lt;n&lt;50,<br> 0&lt;|Xi|&lt;100</p> 
<p>输入样例1：</p> 
<pre><code>3
5 -2 8
</code></pre> 
<p>输出样例1：</p> 
<pre><code>1
</code></pre> 
<p>输入样例2：</p> 
<pre><code>5
-10 8 -20 12 25
</code></pre> 
<p>输出样例2：</p> 
<pre><code>3</code></pre> 
<p></p> 
<p>本题思路：</p> 
<p>关键：两只蚂蚁相遇会掉头，我们可以看做两只蚂蚁“灵魂交换”，或者说是相遇之后两只蚂蚁身份交换，1蚂蚁变成了2蚂蚁继续向前，2蚂蚁变成了1蚂蚁继续向前，相当于每只蚂蚁不掉头继续向前走，两只蚂蚁互相穿过</p> 
<p>情况1:</p> 
<p>第一只蚂蚁坐标轴上的位置，左边有向右的蚂蚁数left，右边有向左的蚂蚁right，left与right都不为0</p> 
<p>根据蚂蚁间的穿过性</p> 
<p>第一只蚂蚁左边向右的蚂蚁会被全部感染，第一只蚂蚁右边向左的蚂蚁也会被感染（因为前面左边向右的蚂蚁被感染后，会与这些右边向左的蚂蚁相遇），总感染数res=left+right+1（自身）</p> 
<p>情况2：</p> 
<p>如果left=0（左边向右为0）则，左边的蚂蚁永不被感染</p> 
<p>2.1如果此时第一只蚂蚁的方向也向左（distance&lt;0)，那么它也无法感染右边的蚂蚁，总感染数res=1</p> 
<p>2.2如果此时第一只蚂蚁方向向右，那么它右边向左的right只蚂蚁被感染，res=right+1（可归到情况1）</p> 
<p>情况3：</p> 
<p>如果right=0（右边向左为0），右边的蚂蚁永不被感染</p> 
<p>3.1如果此时第一只蚂蚁方向也向右，那么它也无法感染左边的蚂蚁，总感染数res=1</p> 
<p>3.2如果此时第一只蚂蚁方向向左，那么它能感染左边向右的蚂蚁，总感染数res=left+1（可归到情况1）</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
using namespace std;
const int N = 55;
int x[N];
int main()
{
    int n;
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++) cin&gt;&gt;x[i];

    int left=0,right=0;
    for(int i=1;i&lt;n;i++)
    {
        if(abs(x[i])&lt;abs(x[0]) &amp;&amp; x[i]&gt;0) left++;
        if(abs(x[i])&gt;abs(x[0]) &amp;&amp; x[i]&lt;0) right++;
    }
    if((left==0 &amp;&amp; x[0]&lt;0)||(right==0 &amp;&amp; x[0]&gt;0)) cout&lt;&lt;1&lt;&lt;endl;
    else cout&lt;&lt;left+right+1&lt;&lt;endl;
    return 0;
}</code></pre> 
<h2>3.饮料换购</h2> 
<p>乐羊羊饮料厂正在举办一次促销优惠活动。乐羊羊C型饮料，凭3个瓶盖可以再换一瓶C型饮料，并且可以一直循环下去(但不允许暂借或赊账)。</p> 
<p>请你计算一下，如果小明不浪费瓶盖，尽量地参加活动，那么，对于他初始买入的 n 瓶饮料，最后他一共能喝到多少瓶饮料。</p> 
<p>输入格式</p> 
<p>输入一个整数 n,表示初始买入的饮料数量。</p> 
<p>输出格式</p> 
<p>输出一个整数，表示一共能够喝到的饮料数量。</p> 
<p>数据范围</p> 
<p>0&lt;n&lt;10000</p> 
<p>输入样例：</p> 
<pre><code>100
</code></pre> 
<p>输出样例：</p> 
<pre><code>149</code></pre> 
<p>根据题意做即可，喝一瓶饮料n--,cnt++，多一个盖子num++，(num==3)3个盖子换一个饮料n++,n-=3 </p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
int main()
{
    int n;
    cin&gt;&gt;n;
    int cnt=0;//喝了多少瓶子饮料
    int num=0;//盖子的数量
    while (n)
    {
        n--;//喝了一瓶
        cnt++;
        num++;
        if(num==3) 
        {
            n++;
            num-=3;
        }
    }
    cout&lt;&lt;cnt&lt;&lt;endl;
    return 0;
}</code></pre> 
<h2>4.01背包问题</h2> 
<p>本题是模板题</p> 
<p>01背包问题:<br> 状态表示:<br> f[i][j]:<br> 集合:从前i个物品中选,总体积不超过j的所有选法<br> 属性:获得价值的最大值</p> 
<p>状态计算:<br> 不选第i件物品 f[i-1][j]<br> 选第i件物品 f[i-1][j-v[i]]+w[i]<br> f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i])</p> 
<p>一维优化<br> f[j]=max(f[j],f[j-v]+w);<br> //这里的j要从大到小枚举<br> 原因在于:<br> f[j]如果用f[j-v]+w更新,f[j-v]是i-1层的状态,如果从小到大枚举,f[j-v]先被更新完了<br> 变成了第i层的状态了,再用它来更新是不是用i-1层的状态来更新第i层状态了</p> 
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 1010;
int f[N];
int main()
{
    int n,m;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)
    {
        int v,w;
        cin&gt;&gt;v&gt;&gt;w;
        for(int j=m;j&gt;=v;j--)
        {
            f[j]=max(f[j],f[j-v]+w);
        }
    }
    cout&lt;&lt;f[m]&lt;&lt;endl;
    return 0;
}</code></pre> 
<h2>5.摘花生</h2> 
<p>Hello Kitty想摘点花生送给她喜欢的米老鼠。</p> 
<p>她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。</p> 
<p>地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。</p> 
<p>Hello Kitty只能向东或向南走，不能向西或向北走。</p> 
<p>问Hello Kitty最多能够摘到多少颗花生。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/47/e6/QuHi9Bl6_o.gif"></p> 
<p>输入格式</p> 
<p>第一行是一个整数T，代表一共有多少组数据。</p> 
<p>接下来是T组数据。</p> 
<p>每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C。</p> 
<p>每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有C个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目M。</p> 
<p>输出格式</p> 
<p>对每组输入数据，输出一行，内容为Hello Kitty能摘到得最多的花生颗数。</p> 
<p>数据范围</p> 
<p>1≤T≤100,<br> 1≤R,C≤100,<br> 0≤M≤1000</p> 
<p>输入样例：</p> 
<pre><code>2
2 2
1 1
3 4
2 3
2 3 4
1 6 5
</code></pre> 
<p>输出样例：</p> 
<pre><code>8
16</code></pre> 
<p> </p> 
<p>数字三角形模型的题目:<br> 状态表示:<br> f[i][j]<br> 集合:从起点(1,1)走到(i,j)的所有走法的集合<br> 属性:获取的最大花生数量<br> 状态计算:<br> 看一下上一步是从哪走来的<br> 1.最后一步向东走走到(i,j) f[i][j]=f[i][j-1]+w[i][j]<br> 2.最后一步向南走走到(i,j) f[i][j]=f[i-1][j]+w[i][j]</p> 
<p>f[i][j]=max(f[i][j-1],f[i-1][j])+w[i][j]</p> 
<p>初始f[1][1]=w[1][1];</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 110;
int w[N][N];
int f[N][N];
int main()
{
    int T;
    cin&gt;&gt;T;
    while(T--)
    {
        int n,m;
        cin&gt;&gt;n&gt;&gt;m;
        memset(w,0,sizeof w);
        memset(f,0,sizeof f);
        for(int i=1;i&lt;=n;i++)
        {
            for(int j=1;j&lt;=m;j++)
            {
                cin&gt;&gt;w[i][j];
            }
        }
        f[1][1]=w[1][1];
        for(int i=1;i&lt;=n;i++)
        {
            for(int j=1;j&lt;=m;j++)
            {
                if(i&gt;=2) f[i][j]=max(f[i][j],f[i-1][j]+w[i][j]);
                if(j&gt;=2) f[i][j]=max(f[i][j],f[i][j-1]+w[i][j]);
            }
        }
        cout&lt;&lt;f[n][m]&lt;&lt;endl;
    }
    return 0;
}</code></pre> 
<h2>6.最长上升子序列</h2> 
<p>给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。</p> 
<p>输入格式</p> 
<p>第一行包含整数 N。</p> 
<p>第二行包含 N 个整数，表示完整序列。</p> 
<p>输出格式</p> 
<p>输出一个整数，表示最大长度。</p> 
<p>数据范围</p> 
<p>1≤N≤1000，<br> −10的9次方≤数列中的数≤10的9次方</p> 
<p>输入样例：</p> 
<pre><code>7
3 1 2 1 8 5 6
</code></pre> 
<p>输出样例：</p> 
<pre><code>4</code></pre> 
<p>最长上升子序列模型:<br> 状态表示:<br> f[i]<br> 集合:所有以a[i]结尾的上升子序列<br> 序列:长度最大值<br> 状态计算:<br> 已知该上升子序列最后一个数为a[i]<br> 看看它的倒数第2个数是多少?<br> 倒数第二个数的范围是a[0到i-1]中比a[i]小的数<br> 所以f[i]=max(f[i],f[k]+1)(k=0,1,2...,i-1且a[k]&lt;a[i])</p> 
<p></p> 
<p>二分优化的版本等到写提高课题解的时候再做总结 </p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 1010,INF = 0x3f3f3f3f;
int a[N],f[N];
int main()
{
    int n;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];
    f[1]=1;
    for(int i=1;i&lt;=n;i++)
    {
        f[i]=1;//以a[i]结尾上升子序列长度最少为1
        for(int k=1;k&lt;i;k++)
        {
            if(a[k]&lt;a[i]) f[i]=max(f[i],f[k]+1);
        }
    }
    int res=-INF;
    for(int i=1;i&lt;=n;i++)
    {
        res=max(res,f[i]);
    }
    cout&lt;&lt;res&lt;&lt;endl;
    return 0;
}</code></pre> 
<h2>7.地宫取宝</h2> 
<p>X 国王有一个地宫宝库，是 n×m 个格子的矩阵，每个格子放一件宝贝，每个宝贝贴着价值标签。</p> 
<p>地宫的入口在左上角，出口在右下角。</p> 
<p>小明被带到地宫的入口，国王要求他只能向右或向下行走。</p> 
<p>走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。</p> 
<p>当小明走到出口时，如果他手中的宝贝恰好是 k 件，则这些宝贝就可以送给小明。</p> 
<p>请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这 k 件宝贝。</p> 
<p>输入格式</p> 
<p>第一行 3 个整数，n,m,k，含义见题目描述。</p> 
<p>接下来 n 行，每行有 m 个整数 Ci 用来描述宝库矩阵每个格子的宝贝价值。</p> 
<p>输出格式</p> 
<p>输出一个整数，表示正好取 k 个宝贝的行动方案数。</p> 
<p>该数字可能很大，输出它对 1000000007 取模的结果。</p> 
<p>数据范围</p> 
<p>1≤n,m≤50,<br> 1≤k≤12,<br> 0≤Ci≤12。</p> 
<p>输入样例1：</p> 
<pre><code>2 2 2
1 2
2 1
</code></pre> 
<p>输出样例1：</p> 
<pre><code>2
</code></pre> 
<p>输入样例2：</p> 
<pre><code>2 3 2
1 2 3
2 1 5
</code></pre> 
<p>输出样例2：</p> 
<pre><code>14</code></pre> 
<p>dp分析:<br> 状态表示:<br> f[i][j][k][c]:<br> 集合:从起点走到了(i,j)点,且已经拿了k件宝物,手上最大价值为c的所有走法<br> 属性:走法的数量count</p> 
<p>状态计算:<br> 1.如果没拿(i,j)位置上的物品,<br> 1.1上一步从上方走来<br> f[i-1][j][k][c](c属于[0,13]每件物品的价值范围,0代表一件物品没选)<br> 1.2上一步从左方走来<br> f[i][j-1][k][c]</p> 
<p>f[i][j][k][c]=(f[i-1][j][k][c]+f[i][j-1][k][c])%mod</p> 
<p>2.如果拿了第(i,j)位置上的物品<br> 2.1上一步从上方走来<br> f[i-1][j][k-1][c'](c'&lt;c即可,因为(i-1,j)这个位置的物品可能没拿,所以不一定就是a[i-1][j])<br> 2.1上一步从左方走来<br> f[i][j-1][k-1][c'](c'&lt;c)</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 55,Mod = 1000000007;
int a[N][N];
int f[N][N][13][14];

int main()
{
    int n,m,k;
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;//n*m,恰好取k件物品
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=m;j++)
        {
            cin&gt;&gt;a[i][j];
            a[i][j]+=1;
            //因为题中0≤Ci≤12,但价值从1开始的话,那么价值为0就可以表示什么都没拿,更加方便
            //反正结果是方案数,不影响结果
        }
    }
    f[1][1][0][0]=1;//在起点,什么都没拿
    f[1][1][1][a[1][1]]=1;//在起点,拿了第一件物品
    
    //枚举每个物品,其价值为a[i][j]
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=m;j++)
        {
            if(i==1&amp;&amp;j==1) continue;
            
            //枚举当前已经拿了几个物品
            for(int cnt=0;cnt&lt;=k;cnt++)
            {
                //如果没取(i,j)上的物品
                for(int c=0;c&lt;=13;c++)
                {
                    f[i][j][cnt][c]=(f[i][j][cnt][c]+f[i-1][j][cnt][c])%Mod;
                    f[i][j][cnt][c]=(f[i][j][cnt][c]+f[i][j-1][cnt][c])%Mod;
                    //如果取了第(i,j)上的物品,说明第(i,j)上的物品是当前最大价值
                    if(c==a[i][j] &amp;&amp; cnt&gt;=1)//取了第(i,j)上的物品,最少拿了一件
                    {
                        for(int c1=0;c1&lt;a[i][j];c1++)//枚举一下没取a[i][j]之前最大价值
                        {
                            f[i][j][cnt][c]=(f[i][j][cnt][c]+f[i-1][j][cnt-1][c1])%Mod;
                            f[i][j][cnt][c]=(f[i][j][cnt][c]+f[i][j-1][cnt-1][c1])%Mod;
                        }
                    }
                }
            }
        }
    }
    int res=0;
    for(int c=0;c&lt;=13;c++)
    {
        res=(res+f[n][m][k][c])%Mod;
    }
    cout&lt;&lt;res&lt;&lt;endl;
    return 0;
}</code></pre> 
<h2>8.波动数列 </h2> 
<p>观察这个数列：</p> 
<p>1 3 0 2 -1 1 -2 …</p> 
<p>这个数列中后一项总是比前一项增加2或者减少3，<strong>且每一项都为整数</strong>。</p> 
<p>栋栋对这种数列很好奇，他想知道长度为 n 和为 s 而且后一项总是比前一项增加 a 或者减少 b 的整数数列可能有多少种呢？</p> 
<p>输入格式</p> 
<p>共一行，包含四个整数 n,s,a,b 含义如前面所述。</p> 
<p>输出格式</p> 
<p>共一行，包含一个整数，表示满足条件的方案数。</p> 
<p>由于这个数很大，请输出方案数除以 100000007 的余数。</p> 
<p>数据范围</p> 
<p>1≤n≤1000,<br> −10的9次方9≤s≤10的9次方,<br> 1≤a,b≤10的6次方</p> 
<p>输入样例：</p> 
<pre><code>4 10 2 3
</code></pre> 
<p>输出样例：</p> 
<pre><code>2
</code></pre> 
<p>样例解释</p> 
<p>两个满足条件的数列分别是2 4 1 3和7 4 1 -2。</p> 
<p></p> 
<p></p> 
<p>解析：</p> 
<p>附:同余的定义是这样的:<br> 给定一个正整数n，如果两个整数a和b满足a-b能被n整除,即(a-b) mod n=0,<br> 那么就称整数a与b对模n同余,记作a≡b(mod n),同时可成立a mod n = b。<br> 也就是相当于a被n整除余数等于b的意思</p> 
<p>题目:<br> 设波动序列的第一个数为x,后一个数=前一个数+d(d=+a/-b)<br> x+(x+d1)+(x+d1+d2)+...+(x+d1+d2+..+dn-1)=s;<br> n*x+(n-1)*d1+(n-2)*d2+...+2*dn-2+dn-1=s;<br> s-[(n-1)*d1+(n-2)*d2+...+2*dn-2+dn-1]=n*x</p> 
<p>x = {s-[(n-1)*d1+(n-2)*d2+...+2*dn-2+dn-1]} / n<br> 将(n-1)*d1+(n-2)*d2+...+2*dn-2+dn-1记为s'</p> 
<p>s已知,n已知,对每个d取值,得到不同的s'<br> 如果s-s'是n的倍数,即(s-s')mod n=0,即s≡s'(mod n),即s mod n = s',即s除以n的余数是s'<br> 那么x就是个合法的整数,由x和取值的d可以得到一整组波动序列</p> 
<p>这样就把原问题转化为了一个组合问题,背包问题的根源就是组合问题,每种物品选或不选,看看有多少<br> s'满足题意</p> 
<p>dp分析:<br> 状态表示<br> f[i][j]:<br> 集合:从前i项中对每个d取值,求得当前总和s',且s'mod n = j的所有方案<br> 属性:方案的数量<br> 状态计算:</p> 
<p>1.第i项中d取+a <br> (n-1)*d1+(n-2)*d2+...+(n-i+1)*dn-i+1+(n-i)*a mod n = j;<br> ((n-1)*d1+(n-2)*d2+...+(n-i+1)*dn-i+1+(n-i)*a-j) mod n = 0;<br> (n-1)*d1+(n-2)*d2+...+(n-i+1)*dn-i+1 mod n =(j-(n-i)*a) mod n<br> f[i][j]=f[i-1][(j-(n-i)*a) mod n]</p> 
<p>2.第i项中d取-b<br> (n-1)*d1+(n-2)*d2+...+(n-i+1)*dn-i+1-(n-i)*b mod n = j;<br> ((n-1)*d1+(n-2)*d2+...+(n-i+1)*dn-i+1-(n-i)*b-j) mod n = 0;<br> (n-1)*d1+(n-2)*d2+...+(n-i+1)*dn-i+1 mod n= (j+(n-i)*b) mod n<br> f[i][j]=f[i-1][(j+(n-i)*b) mod n]</p> 
<p>所以f[i][j]=f[i-1][(j-(n-i)*a) mod n]+f[i-1][(j+(n-i)*b) mod n]</p> 
<p>注意:这里的mod得到的数由于是数组下标,所以一定得为正数<br> 用此公式即可<br> int get_mod(int a,int b)<br> {<!-- --><br>     return (a%b+b)%b;<br> }</p> 
<p>x = {s-[(n-1)*d1+(n-2)*d2+...+2*dn-2+dn-1]} / n<br> 由此可知i最大是n-1,从前n-1个d中选择每个d的值,得到s,j=s mod n的所有方案<br> 所以结果是f[n-1][get_mod(s,n)] s mod n也可能是负数(因为s可能为负)</p> 
<p> </p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 1010, Mod = 100000007;
int f[N][N];

int get_mod(int a,int b)
{
    return (a%b+b)%b;
}
int main()
{
    int n,s,a,b;
    cin&gt;&gt;n&gt;&gt;s&gt;&gt;a&gt;&gt;b;
    f[0][0]=1;//啥都不选,1种方案
    for(int i=1;i&lt;=n-1;i++)
    {
        for(int j=0;j&lt;n;j++)//j是当前和s'mod n的值,范围是[0,n-1]
        {
            f[i][j]=(f[i-1][get_mod(j-(n-i)*a,n)]+f[i-1][get_mod(j+(n-i)*b,n)])%Mod;
        }
    }
    cout&lt;&lt;f[n-1][get_mod(s,n)];
    return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/675124934b2cc4a6d85f5845b8c1f821/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">低功耗蓝牙芯片CH579系列开发记录</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c938386ab165497b744ecfa152c1cb5c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Sring-IOC控制反转（详解）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>