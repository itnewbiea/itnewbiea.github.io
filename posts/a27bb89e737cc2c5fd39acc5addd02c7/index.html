<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>目标检测算法——Fast R-CNN - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="目标检测算法——Fast R-CNN" />
<meta property="og:description" content="文章目录 1.Fast R-CNN简介2.Fast R-CNN处理过程1）候选区域的生成2）投影特征图获得相应的特征矩阵3）ROI层缩放4）展平特征图利用全连接层得到预测结果。 3.Fast R-CNN损失函数4.Fast R-CNN总框架 1.Fast R-CNN简介 Fast R-CNN
其论文的名字就是 Fast R-CNN，原文链接。Fast R-CNN与R-CNN相同，同样使用VGG16作为网络的backbone，与R-CNN相比训练时间快9倍，测试推理时间快213倍，准确率从62%提升至66%(再Pascal VOC数据集上)。
Fast R-CNN 算法流程可分为3个步骤
一张图像生成1K~2K个 候选区域(使用Selective Search方法将图像输入网络得到相应的特征图，将SS算法生成的候选框投影到特征图上获得相应的特征矩阵将每个特征矩阵通过ROI(Region of Interest) pooling层缩放到 7x7 大小的特征图，接着将特征图展平通过一系列全连接层得到预测结果 2.Fast R-CNN处理过程 1）候选区域的生成 与R-CNN一样，利用Selective Search算法通过图像分割的方法得到一些原始区域，然后使用一些合并策略将这些区域合并，得到一个层次化的区域结构，而这些结构就包含着可能需要的物体。
但是，Fast R-CNN与R-CNN不同的是，这些生成出来的候选区域不需要每一个都丢到卷积神经网络里面提取特征，而且只需要在特征图上映射便可，见下一个步骤。
2）投影特征图获得相应的特征矩阵 Fast-RCNN没有像RCNN一样，其不限制输入的图像的尺寸，其将整张图像送入网络，得到了一个特征图。紧接着从特征图像上提取相应的候选区域。这些候选区域的特征不需要再重复计算，简洁了不少的时间。
但是这其中涉及训练数据正负样本采样的问题。不过Fast R-CNN与Faster R-CNN处理得不同，也可以不用太过的在意。
在Fast R-CNN中，并不适用SS算法提供的所有的候选区域，SS算法会差不多得到2000个候选框，但是训练的过程中其实只需要使用其中的一部分就可以了，Fast R-CNN中好像只挑选了其中的64个。其中还是分为正样本与负样本，正样本指的是在候选框中确实存在所需检测目标的样本；而负样本指的是候选框中没有所需检测的目标，也就是只有背景。
视频up主所理解的一个意思是，当数据不平衡时，数据会有所偏向。如果全部只有正样本，那么网络就会有很大的一个概率认为候选区域是我们需要的一个检测目标，这样就会有问题，所以存在正负样品。
正样本的定义为候选框与真实的目标边界框的iou大于0.5；负样本的定义为候选框与所有真实的目标边界框的iou值最大的区间为0.1-0.5。重点是其实没有完全适应SS算法提供的所以的边界框。
3）ROI层缩放 有了训练样本之后，将训练样本的候选框通过ROI Pooling层缩放到统一的尺寸。
ROI Pooling层的具体做法是，将候选框所框选的训练样本，这是一个比较抽象的特征信息。将其划分为77，也就是49等份。划分之后，对每一个区域做一个最大池化下采样操作，也就是MaxPooling操作。如此对49等分的候选区域操作，便得到了一个77的特征矩阵。
也就是说，无论候选区域的特征矩阵是怎么样的尺寸，都被缩放到一个77的大小，这样就可以不去限制输入图像的尺寸了。因为，作进一步的工作的是输入图像的候选区域，而候选区域总是能被缩放为77的尺寸的，所以也就和输入图像的尺寸无关。
在R-CNN当中，其使用的卷积神经网络要求输入是227*227大小，但是Fast R-CNN就不需要考虑这个因素。
4）展平特征图利用全连接层得到预测结果。 概率分类器
输出N&#43;1个类别的概率（N为检测目标的种类, 1为背景）共N&#43;1个节点。
其中的第0个节点表示的背景的概率。剩下的20个是其他所需检测的类别概率。这个概率是经过softmax处理之后的，是满足一个概率分布的，其和为1.而既然现在是需要预测21个类别的概率，所以目标概率预测的全连接层为21个节点。
边界框回归器
输出对应N&#43;1个类别的候选边界框回归参数(d x , d y , d w , d h )。需要注意，这是每一个类别都有这4个参数。所以共(N&#43;1)x4个节点。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a27bb89e737cc2c5fd39acc5addd02c7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-05T21:18:38+08:00" />
<meta property="article:modified_time" content="2021-06-05T21:18:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">目标检测算法——Fast R-CNN</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><a href="#1Fast_RCNN_1" rel="nofollow">1.Fast R-CNN简介</a></li><li><a href="#2Fast_RCNN_12" rel="nofollow">2.Fast R-CNN处理过程</a></li><li><ul><li><ul><li><a href="#1_13" rel="nofollow">1）候选区域的生成</a></li><li><a href="#2_18" rel="nofollow">2）投影特征图获得相应的特征矩阵</a></li><li><a href="#3ROI_29" rel="nofollow">3）ROI层缩放</a></li><li><a href="#4_38" rel="nofollow">4）展平特征图利用全连接层得到预测结果。</a></li></ul> 
    </li></ul> 
    </li><li><a href="#3Fast_RCNN_57" rel="nofollow">3.Fast R-CNN损失函数</a></li><li><a href="#4Fast_RCNN_90" rel="nofollow">4.Fast R-CNN总框架</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="1Fast_RCNN_1"></a>1.Fast R-CNN简介</h4> 
<p><strong>Fast R-CNN</strong></p> 
<p>其论文的名字就是 Fast R-CNN，<a href="https://arxiv.org/abs/1504.08083" rel="nofollow">原文链接</a>。Fast R-CNN与R-CNN相同，同样使用<strong>VGG16作为网络的backbone</strong>，与R-CNN相比训练时间快9倍，测试推理时间快213倍，准确率从62%提升至66%(再Pascal VOC数据集上)。</p> 
<p><strong>Fast R-CNN 算法流程可分为3个步骤</strong></p> 
<ul><li>一张图像生成1K~2K个 候选区域(使用Selective Search方法</li><li>将图像输入网络得到相应的特征图，将SS算法生成的候选框投影到特征图上获得相应的特征矩阵</li><li>将每个特征矩阵通过ROI(Region of Interest) pooling层缩放到 7x7 大小的特征图，接着将特征图展平通过一系列全连接层得到预测结果</li></ul> 
<p><img src="https://images2.imgbox.com/86/77/5hsM63Lk_o.png" alt=""></p> 
<h4><a id="2Fast_RCNN_12"></a>2.Fast R-CNN处理过程</h4> 
<h6><a id="1_13"></a>1）候选区域的生成</h6> 
<p>与R-CNN一样，利用Selective Search算法通过图像分割的方法得到一些原始区域，然后使用一些合并策略将这些区域合并，得到一个层次化的区域结构，而这些结构就包含着可能需要的物体。</p> 
<p>但是，Fast R-CNN与R-CNN不同的是，这些生成出来的候选区域不需要每一个都丢到卷积神经网络里面提取特征，而且只需要在特征图上映射便可，见下一个步骤。<br> <img src="https://images2.imgbox.com/64/8d/0fVToftm_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="2_18"></a>2）投影特征图获得相应的特征矩阵</h6> 
<p>Fast-RCNN没有像RCNN一样，其不限制输入的图像的尺寸，其将整张图像送入网络，得到了一个特征图。紧接着从特征图像上提取相应的候选区域。这些候选区域的特征不需要再重复计算，简洁了不少的时间。<br> <img src="https://images2.imgbox.com/22/7c/kcMdVumR_o.png" alt="在这里插入图片描述"><br> 但是这其中涉及训练数据正负样本采样的问题。不过Fast R-CNN与Faster R-CNN处理得不同，也可以不用太过的在意。</p> 
<p>在Fast R-CNN中，并不适用SS算法提供的所有的候选区域，SS算法会差不多得到2000个候选框，但是训练的过程中其实只需要使用其中的一部分就可以了，Fast R-CNN中好像只挑选了其中的64个。其中还是分为正样本与负样本，正样本指的是在候选框中确实存在所需检测目标的样本；而负样本指的是候选框中没有所需检测的目标，也就是只有背景。</p> 
<p>视频up主所理解的一个意思是，当数据不平衡时，数据会有所偏向。如果全部只有正样本，那么网络就会有很大的一个概率认为候选区域是我们需要的一个检测目标，这样就会有问题，所以存在正负样品。</p> 
<p>正样本的定义为候选框与真实的目标边界框的iou大于0.5；负样本的定义为候选框与所有真实的目标边界框的iou值最大的区间为0.1-0.5。重点是其实没有完全适应SS算法提供的所以的边界框。</p> 
<h6><a id="3ROI_29"></a>3）ROI层缩放</h6> 
<p>有了训练样本之后，将训练样本的候选框通过ROI Pooling层缩放到统一的尺寸。<br> <img src="https://images2.imgbox.com/bd/fe/CHpKe3Lh_o.png" alt="在这里插入图片描述"><br> ROI Pooling层的具体做法是，将候选框所框选的训练样本，这是一个比较抽象的特征信息。将其划分为7<em>7，也就是49等份。划分之后，对每一个区域做一个最大池化下采样操作，也就是MaxPooling操作。如此对49等分的候选区域操作，便得到了一个7</em>7的特征矩阵。<br> <img src="https://images2.imgbox.com/4d/ae/3ez5ELtz_o.png" alt="在这里插入图片描述"><br> 也就是说，无论候选区域的特征矩阵是怎么样的尺寸，都被缩放到一个7<em>7的大小，这样就可以不去限制输入图像的尺寸了。因为，作进一步的工作的是输入图像的候选区域，而候选区域总是能被缩放为7</em>7的尺寸的，所以也就和输入图像的尺寸无关。</p> 
<p>在R-CNN当中，其使用的卷积神经网络要求输入是227*227大小，但是Fast R-CNN就不需要考虑这个因素。</p> 
<h6><a id="4_38"></a>4）展平特征图利用全连接层得到预测结果。</h6> 
<p><strong>概率分类器</strong></p> 
<p>输出N+1个类别的概率（N为检测目标的种类, 1为背景）共N+1个节点。<br> <img src="https://images2.imgbox.com/a4/46/6NoWgXLb_o.png" alt="在这里插入图片描述"><br> 其中的第0个节点表示的背景的概率。剩下的20个是其他所需检测的类别概率。这个概率是经过softmax处理之后的，是满足一个概率分布的，其和为1.而既然现在是需要预测21个类别的概率，所以目标概率预测的全连接层为21个节点。</p> 
<p><strong>边界框回归器</strong></p> 
<p>输出对应N+1个类别的候选边界框回归参数(d x , d y , d w , d h )。需要注意，这是每一个类别都有这4个参数。所以共(N+1)x4个节点。<br> <img src="https://images2.imgbox.com/8e/83/CZ2w465p_o.png" alt="在这里插入图片描述"><br> 也就是4个4个为一组，一组为一个边界框回归参数。那么如何根据回归参数得到最后的预测边界框？</p> 
<p>对应着每个类别的候选边界框回归参数（d x , d y , d w , d h）<br> <img src="https://images2.imgbox.com/53/64/CK2Iab45_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/15/f3/px37Hcav_o.png" alt="在这里插入图片描述"><br> Px，Py，Pw，Ph 分别为候选框的中心x，y坐标，以及宽高<br> Gx，Gy，Gw，Gh 分别为最终预测的边界框中心x，y坐标，以及宽高</p> 
<h4><a id="3Fast_RCNN_57"></a>3.Fast R-CNN损失函数</h4> 
<p><img src="https://images2.imgbox.com/04/aa/04utumsQ_o.png" alt="在这里插入图片描述"></p> 
<ul><li>p是分类器预测的softmax概率分布p = (p0, …, pk)</li><li>u对应目标真实类别标签</li><li>tu对应边界框回归器预测的对应类别u的回归参数(tux，tuy，tuw，tuh)</li><li>v对应真实目标的边界框回归参数(vx，vy，vw，vh)</li></ul> 
<p>其中真实目标边界框回归参数的计算公式为：<br> <img src="https://images2.imgbox.com/48/b2/RdCfKKYD_o.png" alt="在这里插入图片描述"></p> 
<p><strong>其中对于分类损失：</strong><br> <img src="https://images2.imgbox.com/67/d6/tPCnr50m_o.png" alt="在这里插入图片描述"></p> 
<ul><li>p是分类器预测的softmax概率分布p = (p0, …, pk)</li><li>u对应目标真实类别标签</li></ul> 
<p><strong>其中对于边界框回归损失：</strong><br> <img src="https://images2.imgbox.com/66/b2/8hegKZrT_o.png" alt="在这里插入图片描述"><br> 注意，这个损失是由4个部分组成的。分别对应着我们回归参数 x 的smoothL1的回归损失，回归参数 y 的smoothL1的回归损失，回归参数 w 的smoothL1的回归损失与最后的回归参数 h 的smoothL1的回归损失。</p> 
<ul><li>tu对应边界框回归器预测的对应类别u的回归参数(tux，tuy，tuw，tuh)</li><li>v对应真实目标的边界框回归参数(vx，vy，vw，vh)</li></ul> 
<p>而具体的smoothL1损失的计算公式为<br> <img src="https://images2.imgbox.com/8e/0f/jQZVidvc_o.png" alt="在这里插入图片描述"><br> λ 是一个平衡系数，用于平衡分类损失与边界框回归损失。</p> 
<p>[u ≥ 1] 是艾佛森括号，也可以理解为一个计算公式。当u满足条件是，公式的值为1；而当u不满足条件时，也就是u&lt;1时，也就是u=0时，（u为类别的标签），此时类别标签为背景，公式的值为0.</p> 
<p>u代表了目标的真是标签，u ≥ 1表示候选区域确实属于所需检测的某一个类别当中，也就是对应着正样本。当u=0时，此时候选区域对应着为背景，不属于所需检测的某一个类别当中。那既然是背景，就没有边界框回归损失这一项了。</p> 
<p>也就是Fast R-CNN的总损失 = 分类损失 + 边界框回归损失然后对其进行反向传播就可以训练Fast R-CNN网络了。</p> 
<h4><a id="4Fast_RCNN_90"></a>4.Fast R-CNN总框架</h4> 
<p>再来看一下Fast R-CNN网络结构的框架<br> <img src="https://images2.imgbox.com/1a/27/MW5IKbJ0_o.png" alt="在这里插入图片描述"></p> 
<p>直接将输入的图像输入到神经网络中得到一个特征图，通过ss算法得到的候选区域，根据映射关系找到每一个候选区域的特征矩阵。将特征矩阵通过ROI Pooling层统一缩放到7*7的大小，然后将其展平处理，然后通过两个全连接层，得到ROI feature Vector。在ROI feature Vector的基础上，并联两个全连接层。其中的一个全连接层用于目标概率的预测，另外的一个全连接层用来边界框回归参数的预测。</p> 
<p>以上便是整个Fast R-CNN的结构处理流程。</p> 
<p><strong>Fast R-CNN框架</strong><br> <img src="https://images2.imgbox.com/3f/0f/p8z03jJV_o.png" alt="在这里插入图片描述"><br> Fast R-CNN比R-CNN快了200多倍，选择Fast R-CNN的速度瓶颈就在ss算法上</p> 
<p><strong>参考资料：</strong><br> https://www.bilibili.com/video/BV1af4y1m7iL?p=2</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/550c99f4061193c04103aae52a4daa12/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue3没有this怎么办?</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4362de5adf46f10b4521b27d4ca107b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">报错 An error happened during template parsing (template: “ServletContext resource [/shiroTest.html]“)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>