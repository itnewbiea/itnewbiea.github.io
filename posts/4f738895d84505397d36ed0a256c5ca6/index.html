<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>google Guava包RateLimiter使用最佳实践 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="google Guava包RateLimiter使用最佳实践" />
<meta property="og:description" content="以下是使用Guava RateLimiter的最佳实践：
1 创建RateLimiter对象的最佳实践 在创建RateLimiter对象时，建议使用静态工厂方法来创建，因为它提供了更清晰的API，并且允许您使用不同的参数值来创建RateLimiter对象。以下是使用静态工厂方法创建RateLimiter对象的示例：
RateLimiter rateLimiter = RateLimiter.create(10); //每秒允许10个请求 1.1 使用 acquire()方法的最佳实践 RateLimiter 的 acquire 方法用于获取一个许可证（permit），表示可进行一个请求或操作。如果没有可用的许可证，则 acquire 方法将阻塞线程，直到 RateLimiter 允许获得新的许可证。acquire方法有多个重载，可以根据不同的参数配置和获取不同数量的许可证，下面主要介绍acquire方法的常用重载：
double acquire() 该方法用于获取一个许可证，并返回等待的时间（即等待 RateLimiter 释放许可证的时间）。如果返回的时间为 0，则表示可以立即执行操作，否则等待相应的时间后再执行操作。如果在等待过程中发生中断，则会抛出 InterruptedException异常。
double acquire(int permits) 该方法用于获取指定数量的许可证，并返回等待的时间。如果返回的时间为0，则表示可以立即执行操作，否则等待相应的时间后再执行操作。如果在等待过程中发生中断，则会抛出 InterruptedException 异常。
以下是使用 acquire()方法的示例：
//创建RateLimiter RateLimiter rateLimiter = RateLimiter.create(10); //每秒允许10个请求 //每次请求之前调用acquire()方法 while (true) { double waitTime = rateLimiter.acquire(1); if (waitTime == 0) { break; } //使用waitTime进行阻塞 Thread.sleep((long) (waitTime * 1000)); } //执行请求 executeRequest(); 1.2 使用tryAcquire()方法的最佳实践 如果您使用的是非阻塞的逻辑，并且需要根据RateLimiter的许可证可用性做出决策，则可以使用tryAcquire()方法来尝试获取许可证。如果tryAcquire()方法返回true，则表示许可证可用，可以执行请求。否则，您需要等待一段时间，直到许可证可用。
以下是使用tryAcquire()方法的示例：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4f738895d84505397d36ed0a256c5ca6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-14T16:18:10+08:00" />
<meta property="article:modified_time" content="2023-04-14T16:18:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">google Guava包RateLimiter使用最佳实践</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>以下是使用Guava RateLimiter的最佳实践：</p> 
<h3><a id="1_RateLimiter_2"></a>1 创建RateLimiter对象的最佳实践</h3> 
<p>在创建RateLimiter对象时，建议使用静态工厂方法来创建，因为它提供了更清晰的API，并且允许您使用不同的参数值来创建RateLimiter对象。以下是使用静态工厂方法创建RateLimiter对象的示例：</p> 
<pre><code>RateLimiter rateLimiter = RateLimiter.create(10); //每秒允许10个请求
</code></pre> 
<h4><a id="11__acquire_12"></a>1.1 使用 acquire()方法的最佳实践</h4> 
<p>RateLimiter 的 acquire 方法用于获取一个许可证（permit），表示可进行一个请求或操作。如果没有可用的许可证，则 acquire 方法将阻塞线程，直到 RateLimiter 允许获得新的许可证。acquire方法有多个重载，可以根据不同的参数配置和获取不同数量的许可证，下面主要介绍acquire方法的常用重载：</p> 
<pre><code>double acquire()
</code></pre> 
<p>该方法用于获取一个许可证，并返回等待的时间（即等待 RateLimiter 释放许可证的时间）。如果返回的时间为 0，则表示可以立即执行操作，否则等待相应的时间后再执行操作。如果在等待过程中发生中断，则会抛出 InterruptedException异常。</p> 
<pre><code>double acquire(int permits)
</code></pre> 
<p>该方法用于获取指定数量的许可证，并返回等待的时间。如果返回的时间为0，则表示可以立即执行操作，否则等待相应的时间后再执行操作。如果在等待过程中发生中断，则会抛出 InterruptedException 异常。</p> 
<p>以下是使用 acquire()方法的示例：</p> 
<pre><code>//创建RateLimiter
RateLimiter rateLimiter = RateLimiter.create(10); //每秒允许10个请求

//每次请求之前调用acquire()方法
while (true) {
  double waitTime = rateLimiter.acquire(1);
  if (waitTime == 0) {
    break;
  }
  //使用waitTime进行阻塞
  Thread.sleep((long) (waitTime * 1000));
}

//执行请求
executeRequest();
</code></pre> 
<h4><a id="12_tryAcquire_50"></a>1.2 使用tryAcquire()方法的最佳实践</h4> 
<p>如果您使用的是非阻塞的逻辑，并且需要根据RateLimiter的许可证可用性做出决策，则可以使用tryAcquire()方法来尝试获取许可证。如果tryAcquire()方法返回true，则表示许可证可用，可以执行请求。否则，您需要等待一段时间，直到许可证可用。</p> 
<p>以下是使用tryAcquire()方法的示例：</p> 
<pre><code>//创建RateLimiter
RateLimiter rateLimiter = RateLimiter.create(10); //每秒允许10个请求

//尝试获取许可证
if (rateLimiter.tryAcquire()) {
  //许可证可用，执行请求
  executeRequest();
} else {
  //许可证不可用，等待一段时间
  //TODO: 等待逻辑
}
</code></pre> 
<p>以上是使用 Guava RateLimiter 的最佳实践。需要根据您的具体情况进行调整和修改。</p> 
<h3><a id="2__Java__74"></a>2 其他 Java 限流方案</h3> 
<h4><a id="21_Sentinel_77"></a>2.1 Sentinel</h4> 
<p>Sentinel 是一款阿里巴巴开源的面向微服务的流量控制组件，支持多种限流策略，包括基于QPS、线程数限流、熔断降级等。Sentinel 提供了丰富的监控和控制手段，可以快速地定位和解决应用程序中的流量控制问题。</p> 
<h4><a id="22_Resilience4j_83"></a>2.2 Resilience4j</h4> 
<p>Resilience4j 是一款支持多种限流和熔断策略的开源库，支持QPS、线程池、超时、重试等熔断和限流策略，可以帮助开发人员轻松实现应用程序的可靠性和弹性。Resilience4j 还支持响应事件和跟踪数据，可以方便地支持应用程序的故障排查和监控。</p> 
<p>PS：以上内容是 GPT 和作业共同创作</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/698fd36dc216443adc8bf46303a0ea25/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">js处理时间为23:59:59</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/466afdc71dd0e3f6492e484c8a17f2c1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uni-app 抖音小程序接入友盟数据统计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>