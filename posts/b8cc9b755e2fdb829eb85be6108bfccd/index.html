<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SRS服务器RTMP2WebRTC外网拉流配置 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SRS服务器RTMP2WebRTC外网拉流配置" />
<meta property="og:description" content="将前端服务开放到外网，并且在外网使用WebRTC拉流，要求全部使用同一端口。
外网地址：10.172.59.42（域名：test.com）外网端口为33333内网SRS服务器地址：192.168.5.177，内网端口为10090路由器将外网33333端口映射到内网192.168.5.177:10090 一、使用docker搭建SRS服务器
1、编辑~/.bashrc，添加export CANDIDATE=&#34;192.168.5.177&#34;，执行source ./bashrc。
2、docker创建SRS服务器，将开放的8000端口改为33333端口。
docker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 --env CANDIDATE=$CANDIDATE -p 33333:33333/udp registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5 ./objs/srs -c conf/rtmp2rtc.conf WebRTC包含信令(Signaling)和媒体(Media)两个部分的协议，信令默认使用1985端口，媒体默认使用UDP8000端口传输，无法单独修改发送给客户端的媒体端口，所以需要将8000端口改为和外网端口一致的端口33333。
3、修改SRS配置文件，将rtc_server中监听的UDP端口8000改为33333，重启容器。
# 将容器中的配置文件复制到本地 docker cp srs:conf/rtmp2rtc.conf ./ # 将本地修改完的配置文件复制回容器内 docker cp rtmp2rtc.conf srs:/usr/local/srs/conf # 重启容器 docker restart srs 二、使用Nginx配置反向代理
http { server { listen 10090; server_name _; # WebRTC拉流时，需要调用API：/rtc/v1/play/ location /rtc { proxy_pass http://localhost:1985; } # WebRTC拉流地址前缀匹配 location /live { proxy_pass http://localhost:1985; } } } # steam块不能放在/etc/nginx/conf." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b8cc9b755e2fdb829eb85be6108bfccd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-02T17:39:52+08:00" />
<meta property="article:modified_time" content="2024-01-02T17:39:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SRS服务器RTMP2WebRTC外网拉流配置</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>将前端服务开放到外网，并且在外网使用WebRTC拉流，要求全部使用同一端口。</p> 
<ul><li>外网地址：10.172.59.42（域名：test.com）外网端口为33333</li><li>内网SRS服务器地址：192.168.5.177，内网端口为10090</li><li>路由器将外网33333端口映射到内网192.168.5.177:10090</li></ul> 
<p>一、使用docker搭建SRS服务器</p> 
<p>1、编辑~/.bashrc，添加export CANDIDATE="192.168.5.177"，执行source ./bashrc。</p> 
<p>2、docker创建SRS服务器，将开放的8000端口改为33333端口。</p> 
<pre><code class="language-bash">docker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 --env CANDIDATE=$CANDIDATE -p 33333:33333/udp registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5 ./objs/srs -c conf/rtmp2rtc.conf</code></pre> 
<p>WebRTC包含信令(Signaling)和媒体(Media)两个部分的协议，信令默认使用1985端口，媒体默认使用UDP8000端口传输，无法单独修改发送给客户端的媒体端口，所以需要将8000端口改为和外网端口一致的端口33333。</p> 
<p>3、修改SRS配置文件，将rtc_server中监听的UDP端口8000改为33333，重启容器。</p> 
<pre><code class="language-bash"># 将容器中的配置文件复制到本地
docker cp srs:conf/rtmp2rtc.conf ./
# 将本地修改完的配置文件复制回容器内
docker cp rtmp2rtc.conf srs:/usr/local/srs/conf
# 重启容器
docker restart srs
</code></pre> 
<p>二、使用Nginx配置反向代理</p> 
<pre><code class="language-bash">http {
    server {
        listen 10090;
        server_name _;

        # WebRTC拉流时，需要调用API：/rtc/v1/play/
        location /rtc {
            proxy_pass http://localhost:1985;
        }
        # WebRTC拉流地址前缀匹配
        location /live {
            proxy_pass http://localhost:1985;
        }
    }
}
# steam块不能放在/etc/nginx/conf.d下，手动创建目录/etc/nginx/stream.d
stream {
    # 外网通过33333端口的udp请求，经过路由器转发到服务器10090端口上，再经过nginx转发到本地33333端口
    server {
        listen 10090 udp;
        proxy_pass localhost:33333;
    }
}</code></pre> 
<p>三、拉流</p> 
<p>内网拉流地址：webrtc://192.168.5.177:10090/live/20240102</p> 
<p>外网拉流地址：webrtc://10.172.59.42:33333/live/20240102</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/36527a3c4ccac8eccb1b17b878b865db/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">履机乘变，轻舟便楫：源启分布式PaaS深度赋能企业级技术平台建设</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2b53d8c1b95b1095ae4b335a1736814b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">openssl 命令详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>