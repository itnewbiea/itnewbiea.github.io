<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringSecurity-OAuth2万文详解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringSecurity-OAuth2万文详解" />
<meta property="og:description" content="SpringSecurity-OAuth2万文详解 Oauth2.0是目前流行的授权机制，用于授权第三方应用，获取数据。Oauth协议为用户资源的授权提供一个安全、开放并且简易的 规范标准 。和以往授权不同的是Oauth不会使第三方触及到用户的账号信息(用户和密码)，也就是说第三方不需要使用用户的用户名和密码就可以获取到该用户的用户资源权限。
OAuth2设计的角色 资源所有者（Resource Owner） :通常是 用户（User） ，如昵称、头像这些资源的拥有者(用户只是将这些资源放到服务提供商的资源服务器中)。第三方应用 ：或者称为第三方客户端(Clinet),希望使用资源服务器提供的资源认证服务器(Authorization Server) :专门用于对资源所有者的身份进行认证，对要访问的资源进行授权、产生令牌的服务器。访问资源，需要通过认证服务器由资源所有者授权才可以访问。资源服务器(Resource Server) :存储用户的资源，验证令牌有效性。比如：微信资源服务器存储了微信用户信息，淘宝资源服务器存储了淘宝的用户信息。服务提供商(Service Provider) :认证服务和资源服务归属于一个机构，该机构就是服务提供商。 OAuth2认证流程 OAuth在第三方应用和服务提供商之间，设置一个授权层(authorization layer)。第三方应用不能直接登录&#34;服务提供商&#34;，只可以通过授权层将&#34;第三方应用&#34;和用户区分开来。&#34;第三方应用&#34;通过授权层获取令牌（accesstoken）,获取令牌后拿令牌去访问服务提供商。令牌和用户密码不同，可以指定授权层令牌的权限范围和有效期，&#34;服务提供商&#34;根据令牌的权限范围和有效期，向&#34;第三方应用&#34;开放用户对应的资源。第三方客户端登录主要步骤如下：
第三方应用，向认证服务器请求授权。用户告知认证服务器同意授权（通常是通过用户扫码或输入“服务提供商”的用户名密码的方式）认证服务器向第三方应用告知授权码（code）第三方应用使用授权码（code）申请Access Token认证服务器验证授权码，颁发Access Token OAuth2四种授权方式 OAuth2有四种授权方式分别如下
授权码模式(Authorization Code) 授权码模式(Authorization Code):功能是最完整的，流程也是最严密的，国内各大服务提供商(微信、微博、淘宝、百度)都是使用此授权模式进行授权。该授权模式可以确定是用户进行授权的， 并且令牌是认证服务器放发到第三方应用服务器，而不是浏览器上 。
简化模式(Implicit) 简化模式(Implicit):和授权码模式不同的是，令牌发放给浏览器，OAuth2客户端运行在浏览器中，通过KS脚本去申请令牌。而不是发放该第三方应用的服务器。
密码模式(resource owner password credentials) 密码模式(resource owner password credentials):将用户和密码传过去，直接获取 accesstokne ,用户同意授权动作是在 第三方应用上完成 ，而不是在认证服务器。第三方应用申请令牌时，直接带用户名和密码去向认证服务器申请令牌。 这种方式认证服务器无法断定用户是否真的授权，用户和密码可能是第三方应用盗取过来的 。
流程如下：
用户向客户端直接提供认证服务器想要的用户名和密码。客户端将用户名和密码发给认证服务器，向认证服务器请求令牌认证服务器确认后，向客户端提供访问令牌 客户端模式(client credentials) 客户端模式(client credentials):使用较少，当一个第三方应用自己本身需要获取资源(而不是以用户的名义)，而不是获取用户资源时，客户端模式十分有用。
具体流程如下：
客户端向认证服务器进行身份认证，并要求一个访问令牌认证服务器确认后，向客户端提供访问令牌 Spring Security OAuth2认证服务器 Spring Security登录信息存储在Session中，每次访问服务的时候，都会查看浏览器中Cookie中是不是存在JSESSIONID,如果不存在JSESSIONID会新建一个Session，将新建的SessionID保存到Cookie中。每一次发送请求都会通过浏览器的SessionID查找到对应的Session对象。从而获取用户信息。
前后端分离后，前端部署在单独的Web服务器，后端部署在另外的应用服务器上，浏览器先访问Web服务器，Web服务器访问请求到应用服务器，这样使用Cookie存储就不合适具体原因如下：
开发复杂安全性差客户体验差有些前端技术不支持Cookie,比如:小程序 解决方式:
使用令牌方式进行认证解决上面说的问题，可以使用OAuth2协议。
基础模块创建 创建spring-oauth2-base模块 在spring-oauth2-base模块的pom.xml中添加相关依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f1cdaca07b1c4cd884ae69836bd8cb9e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-11T16:56:21+08:00" />
<meta property="article:modified_time" content="2022-04-11T16:56:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringSecurity-OAuth2万文详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>SpringSecurity-OAuth2万文详解</h3> 
<p>Oauth2.0是目前流行的授权机制，用于授权第三方应用，获取数据。Oauth协议为用户资源的授权提供一个安全、开放并且简易的 <strong>规范标准</strong> 。和以往授权不同的是Oauth不会使第三方触及到用户的账号信息(用户和密码)，也就是说第三方不需要使用用户的用户名和密码就可以获取到该用户的用户资源权限。</p> 
<h3>OAuth2设计的角色</h3> 
<ul><li><strong>资源所有者（Resource Owner）</strong> :通常是 <strong>用户（User）</strong> ，如昵称、头像这些资源的拥有者(用户只是将这些资源放到服务提供商的资源服务器中)。</li><li><strong>第三方应用</strong> ：或者称为第三方客户端(Clinet),希望使用资源服务器提供的资源</li><li><strong>认证服务器(Authorization Server)</strong> :专门用于对资源所有者的身份进行认证，对要访问的资源进行授权、产生令牌的服务器。访问资源，需要通过认证服务器由资源所有者授权才可以访问。</li><li><strong>资源服务器(Resource Server)</strong> :存储用户的资源，验证令牌有效性。比如：微信资源服务器存储了微信用户信息，淘宝资源服务器存储了淘宝的用户信息。</li><li><strong>服务提供商(Service Provider)</strong> :认证服务和资源服务归属于一个机构，该机构就是服务提供商。</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ab/d4/TNCLTV5f_o.png"></p> 
<h3>OAuth2认证流程</h3> 
<p>OAuth在第三方应用和服务提供商之间，设置一个授权层(authorization layer)。第三方应用不能直接登录"服务提供商"，只可以通过授权层将"第三方应用"和用户区分开来。"第三方应用"通过授权层获取令牌（accesstoken）,获取令牌后拿令牌去访问服务提供商。令牌和用户密码不同，可以指定授权层令牌的权限范围和有效期，"服务提供商"根据令牌的权限范围和有效期，向"第三方应用"开放用户对应的资源。第三方客户端登录主要步骤如下：</p> 
<ol><li>第三方应用，向认证服务器请求授权。</li><li>用户告知认证服务器同意授权（通常是通过用户扫码或输入“服务提供商”的用户名密码的方式）</li><li>认证服务器向第三方应用告知授权码（code）</li><li>第三方应用使用授权码（code）申请Access Token</li><li>认证服务器验证授权码，颁发Access Token</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ea/25/poUtjk1b_o.png"></p> 
<h3>OAuth2四种授权方式</h3> 
<p>OAuth2有四种授权方式分别如下</p> 
<h4>授权码模式(Authorization Code)</h4> 
<p>授权码模式(Authorization Code):功能是最完整的，流程也是最严密的，国内各大服务提供商(微信、微博、淘宝、百度)都是使用此授权模式进行授权。该授权模式可以确定是用户进行授权的， 并且令牌是认证服务器放发到第三方应用服务器，而不是浏览器上 。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2f/d6/VL26WXxr_o.png"></p> 
<h4>简化模式(Implicit)</h4> 
<p>简化模式(Implicit):和授权码模式不同的是，令牌发放给浏览器，OAuth2客户端运行在浏览器中，通过KS脚本去申请令牌。而不是发放该第三方应用的服务器。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ee/35/GK0lWQfd_o.png"></p> 
<h4>密码模式(resource owner password credentials)</h4> 
<p>密码模式(resource owner password credentials):将用户和密码传过去，直接获取 <strong>accesstokne</strong> ,用户同意授权动作是在 <strong>第三方应用上完成</strong> ，而不是在认证服务器。第三方应用申请令牌时，直接带用户名和密码去向认证服务器申请令牌。 这种方式认证服务器无法断定用户是否真的授权，用户和密码可能是第三方应用盗取过来的 。</p> 
<p>流程如下：</p> 
<ol><li>用户向客户端直接提供认证服务器想要的用户名和密码。</li><li>客户端将用户名和密码发给认证服务器，向认证服务器请求令牌</li><li>认证服务器确认后，向客户端提供访问令牌</li></ol> 
<h4>客户端模式(client credentials)</h4> 
<p>客户端模式(client credentials):使用较少，当一个第三方应用自己本身需要获取资源(而不是以用户的名义)，而不是获取用户资源时，客户端模式十分有用。</p> 
<p>具体流程如下：</p> 
<ol><li>客户端向认证服务器进行身份认证，并要求一个访问令牌</li><li>认证服务器确认后，向客户端提供访问令牌</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fa/90/eiOgE6fW_o.png"></p> 
<h3>Spring Security OAuth2认证服务器</h3> 
<p>Spring Security登录信息存储在Session中，每次访问服务的时候，都会查看浏览器中Cookie中是不是存在JSESSIONID,如果不存在JSESSIONID会新建一个Session，将新建的SessionID保存到Cookie中。每一次发送请求都会通过浏览器的SessionID查找到对应的Session对象。从而获取用户信息。</p> 
<p>前后端分离后，前端部署在单独的Web服务器，后端部署在另外的应用服务器上，浏览器先访问Web服务器，Web服务器访问请求到应用服务器，这样使用Cookie存储就不合适具体原因如下：</p> 
<ol><li>开发复杂</li><li>安全性差</li><li>客户体验差</li><li>有些前端技术不支持Cookie,比如:小程序</li></ol> 
<p>解决方式:</p> 
<p>使用令牌方式进行认证解决上面说的问题，可以使用OAuth2协议。</p> 
<h4>基础模块创建</h4> 
<ul><li>创建spring-oauth2-base模块</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4a/84/odJiMbPC_o.png"></p> 
<ul><li>在spring-oauth2-base模块的pom.xml中添加相关依赖</li></ul> 
<pre>&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;
            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;
            &lt;version&gt;5.5.9&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</pre> 
<ul><li>在spring.oauth2.base.api模块下添加IResultCode接口</li></ul> 
<pre>/**
 * 统一返回结果接口
 */
public interface IResultCode {


    /**
     * 返回码
     *
     * @return int
     */
    int getCode();

    /**
     * 返回消息
     *
     * @return String
     */
    String getMsg();
}</pre> 
<ul><li>在spring.oauth2.base.api模块下添加ResultCode实现IResultCode</li></ul> 
<pre>@Getter
@AllArgsConstructor
public enum  ResultCode implements  IResultCode{

    /**
     * 操作成功
     */
    SUCCESS(200, "操作成功"),

    /**
     * 业务异常
     */
    FAILURE(400, "业务异常"),
    /**
     * 服务异常
     */
    ERROR(500, "服务异常"),
    /**
     * 参数错误
     */
    GLOBAL_PARAM_ERROR(540, "参数错误");
    /**
     * 状态码
     */
    final int code;
    /**
     * 消息内容
     */
    final String msg;

}</pre> 
<ul><li>在spring.oauth2.base.api模块下添加Result用于统一结果处理</li></ul> 
<pre>@Data
@Getter
public class Result&lt;T&gt; implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 状态码
     */
    private int code;

    /**
     * 状态信息
     */
    private String msg;


    /**
     *
     */
    private Date time;


    private T data;

    private Result() {
        this.time = new Date();
    }

    private Result(IResultCode resultCode) {
        this(resultCode, null, resultCode.getMsg());
    }

    private Result(IResultCode resultCode, String msg) {
        this(resultCode, null, msg);
    }

    private Result(IResultCode resultCode, T data) {
        this(resultCode, data, resultCode.getMsg());
    }

    private Result(IResultCode resultCode, T data, String msg) {
        this(resultCode.getCode(), data, msg);
    }

    private Result(int code, T data, String msg) {
        this.code = code;
        this.data = data;
        this.msg = msg;
        this.time = new Date();
    }

    /**
     * 返回状态码
     *
     * @param resultCode 状态码
     * @param &lt;T&gt;        泛型标识
     * @return ApiResult
     */
    public static &lt;T&gt; Result&lt;T&gt; success(IResultCode resultCode) {
        return new Result&lt;&gt;(resultCode);
    }

    public static &lt;T&gt; Result&lt;T&gt; success(String msg) {
        return new Result&lt;&gt;(ResultCode.SUCCESS, msg);
    }

    public static &lt;T&gt; Result&lt;T&gt; success(IResultCode resultCode, String msg) {
        return new Result&lt;&gt;(resultCode, msg);
    }

    public static &lt;T&gt; Result&lt;T&gt; data(T data) {
        return data(data, "处理成功");
    }

    public static &lt;T&gt; Result&lt;T&gt; data(T data, String msg) {
        return data(ResultCode.SUCCESS.code, data, msg);
    }

    public static &lt;T&gt; Result&lt;T&gt; data(int code, T data, String msg) {
        return new Result&lt;&gt;(code, data, data == null ? "承载数据为空" : msg);
    }

    public static &lt;T&gt; Result&lt;T&gt; fail() {
        return new Result&lt;&gt;(ResultCode.FAILURE, ResultCode.FAILURE.getMsg());
    }

    public static &lt;T&gt; Result&lt;T&gt; fail(String msg) {
        return new Result&lt;&gt;(ResultCode.FAILURE, msg);
    }

    public static &lt;T&gt; Result&lt;T&gt; fail(int code, String msg) {
        return new Result&lt;&gt;(code, null, msg);
    }

    public static &lt;T&gt; Result&lt;T&gt; fail(IResultCode resultCode) {
        return new Result&lt;&gt;(resultCode);
    }

    public static &lt;T&gt; Result&lt;T&gt; fail(IResultCode resultCode, String msg) {
        return new Result&lt;&gt;(resultCode, msg);
    }

    public static &lt;T&gt; Result&lt;T&gt; condition(boolean flag) {
        return flag ? success("处理成功") : fail("处理失败");
    }
}</pre> 
<h4>认证服务器模块创建</h4> 
<ul><li>创建spring-oauth2-server模块</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f2/a3/euZm1l2j_o.png"></p> 
<ul><li>添加依赖pom.xml</li></ul> 
<pre>&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- for OAuth 2.0 --&gt;
        &lt;!-- https://mvnrepository.com/artifact/org.springframework.security.oauth/spring-security-oauth2 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;
            &lt;version&gt;2.3.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--redis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
            &lt;version&gt;2.3.12.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--mysql驱动--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!--druid--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.1.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--mybatis-plus--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.5.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</pre> 
<ul><li>配置application.yml</li></ul> 
<pre>server:
  port: 8899
spring:
  thymeleaf:
    cache: false
  application:
    name: oauth2-server</pre> 
<h3>认证服务器配置-授权码模式</h3> 
<h4>创建配置类</h4> 
<p>创建作用：</p> 
<ol><li>配置允许访问此认证服务器的客户端信息，没有再次配置的客户端信息不允许访问。</li><li>管理令牌</li></ol> 
<ul><li>配置令牌管理策略(JDBC/Redis/JWT)</li><li>配置令牌生成策略</li><li>配置令牌端点</li><li>令牌端点的安全配置</li></ul> 
<h4>创建认证服务配置类</h4> 
<p>在​ <code>​spring-oauth2-server​</code> ​模块创建认证配置类：</p> 
<ul><li>创建 ​ <code>​spring.oauth2.server.config.OAuth2AuthorizationServerConfig​</code> ​类继承​ <code>​AuthorizationServerConfigurerAdapter​</code> ​</li><li>在​ <code>​OAuth2AuthorizationServerConfig​</code> ​类上添加注解：</li></ul> 
<pre>​@Configuration​
​@EnableAuthorizationServer​
</pre> 
<p>可以配置："authorization_code", "password", "implicit","client_credentials","refresh_token"</p> 
<ul><li>配置说明：</li></ul> 
<ul><li>​ <code>​scopes​</code> ​:授权范围标识，比如指定微服务名称，则只可以访问指定的微服务</li><li>​ <code>​autoApprove​</code> ​: false跳转到授权页面手动点击授权，true不需要手动授权，直接响应授权码</li><li>​ <code>​redirectUris​</code> ​​：当获取授权码后，认证服务器会重定向到指定的这个​ <code>​URL​</code> ​​，并且带着一个授权码​ <code>​code​</code> ​响应。</li><li>​ <code>​withClient​</code> ​:允许访问此认证服务器的客户端ID</li><li>​ <code>​secret​</code> ​:客户端密码， <strong>加密存储</strong></li><li>​ <code>​authorizedGrantTypes​</code> ​:授权类型，支持同时多种授权类型</li></ul> 
<pre>/**
 * 认证服务器
 */
@Configuration
@EnableAuthorizationServer //开启认证服务器
public class OAuth2AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {


    //在 MyOAuth2Config 添加到容器了
    @Autowired
    private  PasswordEncoder passwordEncoder;


    /**
     * 配置被允许访问此认证服务器的客户端详细信息
     * 1.内存管理
     * 2.数据库管理方式
     * @param clients
     * @throws Exception
     */
    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory()
                //客户端名称
                .withClient("test-pc")
                //客户端密码
                .secret(passwordEncoder.encode("123456"))
                //资源id,商品资源
                .resourceIds("oauth2-server")
                //授权类型, 可同时支持多种授权类型
                .authorizedGrantTypes("authorization_code", "password", "implicit","client_credentials","refresh_token")
                //授权范围标识，哪部分资源可访问（all是标识，不是代表所有）
                .scopes("all")
                // false 跳转到授权页面手动点击授权，true 不用手动授权，直接响应授权码
                .autoApprove(false)
                .redirectUris("http://www.baidu.com/")//客户端回调地址
                ;
    }
}</pre> 
<p>统一管理Bean配置类</p> 
<p>创建​ <code>​spring.oauth2.server.config.MyOAuth2Config​</code> ​ 类，向容器中添加加密方式 BCrypt</p> 
<pre>@Configuration
public class MyOAuth2Config {

    @Bean
    public PasswordEncoder passwordEncoder(){
        return  new BCryptPasswordEncoder() ;
    }
}</pre> 
<h4>创建安全配置类</h4> 
<p>指定认证用户的用户名和密码， <strong>用户和密码是资源的所有者</strong> 。 这个用户名和密码和客户端id和密码是不一样的，客户端ID和密码是应用系统的标识，每个应用系统对应一个客户端id和密码 。</p> 
<p>在​ <code>​spring-oauth2-server​</code> ​模块创建安全配置类：</p> 
<ul><li>创建​ <code>​spring.oauth2.server.config.OAuth2SecurityConfig​</code> ​​类继承​ <code>​WebSecurityConfigurerAdapter​</code> ​</li><li>在​ <code>​OAuth2SecurityConfig​</code> ​类上添加注解</li></ul> 
<ul><li>​ <code>​@EnableWebSecurity​</code> ​​,包含了​ <code>​@Confifiguration​</code> ​注解</li></ul> 
<pre>/**
 * 安全配置类
 */
@EnableWebSecurity
public class OAuth2SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private  PasswordEncoder passwordEncoder;
    @Autowired
    private UserDetailsService myUserDetailsService;

    /**
     * 用户类信息
     * @param auth
     * @throws Exception
     */
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {

        auth.inMemoryAuthentication()
                .withUser("admin")
                .password(passwordEncoder.encode("123456"))
                .authorities("admin_role")
                ;
    }
}</pre> 
<p>令牌访问端点</p> 
<p>Spring Security对OAuth2提供了默认可访问端点，即URL</p> 
<ul><li>​ <code>​/oauth/authorize​</code> ​​:申请授权码code，涉及类​ <code>​AuthorizationEndpoint​</code> ​</li><li>​ <code>​/oauth/token​</code> ​​:获取令牌token，涉及类​ <code>​TokenEndpoint​</code> ​</li><li>​ <code>​/oauth/check_token​</code> ​​:用于资源服务器请求端点来检查令牌是否有效，涉及类​ <code>​CheckTokenEndpoint​</code> ​</li><li>​ <code>​/oauth/confirm_access​</code> ​​:用于确认授权提交，涉及类​ <code>​WhitelabelApprovalEndpoint​</code> ​</li><li>​ <code>​/oauth/error​</code> ​​:授权错误信息，涉及​ <code>​WhitelabelErrorEndpoint​</code> ​</li><li>​ <code>​/oauth/token_key​</code> ​​:提供公有密匙的端点，使用JWT令牌时会使用，涉及类​ <code>​TokenKeyEndpoint​</code> ​</li></ul> 
<p>获取请求授权码Code</p> 
<p>涉及类​ <code>​org.springframework.security.oauth2.provider.endpoint.AuthorizationEndpoint​</code> ​</p> 
<ul><li>使用以下地址申请授权码</li></ul> 
<pre>http://localhost:8899/oauth/authorize?client_id=test-pc&amp;response_type=code</pre> 
<ul><li>当请求到达授权中心​ <code>​AuthorizationEndpoint​</code> ​后，授权中心会要求资源所有者进行身份验证</li></ul> 
<p>注：</p> 
<pre>1. 此处输入的用户名、密码是在认证服务器输入的(看端口8899)，而不是在客户端上输入的，这样更加安全，因为客户端不知道用户名和密码
  2. 密码模式中，输入的用户名、密码不是在认证服务器上输入，而是在客户端输入的，这样客户端就不太安全。</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f7/29/UAHA3oW8_o.png"></p> 
<ol><li>点击登录以后，会跳转到指定的​ <code>​redirect_uri​</code> ​​,回调路径会携带一个授权码(​ <code>​code=8OsDS8​</code> ​),如下图</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/00/2c/HjkshdyP_o.png"></p> 
<ol><li>获取到授权码(code) 后，就可以通过它来获取访问令牌(access_token)。</li></ol> 
<p>通过授权码获取令牌token</p> 
<p>涉及:​ <code>​TokenEndpoint​</code> ​</p> 
<p>​ <code>​POST​</code> ​方式请求：http://localhost:8899/oauth/token</p> 
<ol><li>Postman中将 client_id:client_secret 通过 Base64 编码</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/5a/29/WuJIf5vT_o.png"></p> 
<ol><li>​ <code>​post​</code> ​方式，请求体中指定授权方式和授权码</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/87/5c/qWeSto3g_o.png"></p> 
<ol><li>每个授权码申请令牌后就会失效，需要重新发送请求获取授权码再去认证，不然就会请求认证失败</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/df/84/SOpTv1Tr_o.png"></p> 
<h3>认证服务器配置-密码模式</h3> 
<p>密码模式(resource owner password credentials),用户向客户端提供自己在认证服务器上的用户和密码，然后客户端通过用户提供的用户名和密码向认证服务器获取令牌。</p> 
<p>但是如果用户名和密码遗漏，认证服务器无法判断客户端提交的用户和密码是否是盗取的，那意味着令牌就可以随时获取，信息容易泄露。</p> 
<h4>配置密码模式</h4> 
<ul><li>在安全配置类中​ <code>​spring.oauth2.server.config.OAuth2SecurityConfig​</code> ​​,将​ <code>​AuthenticationManager​</code> ​注入到bean</li></ul> 
<pre>/**
     *  password 密码模式要使用此认证管理器
     * @return
     * @throws Exception
     */
    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }</pre> 
<h4>指定密码模式</h4> 
<p>在认证服务器配置类​ <code>​OAuth2AuthorizationServerConfig​</code> ​中</p> 
<ol><li>覆盖父类的​ <code>​configure(AuthorizationServerEndpointsConfigurer endpoints)​</code> ​​方法，用于配置令牌访问端点，把​ <code>​authenticationManager​</code> ​注入并添加</li></ol> 
<pre>@Autowired
    private AuthenticationManager authenticationManager;

 @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
        //密码模式需要配置认证管理器
        endpoints.authenticationManager(authenticationManager);
    }</pre> 
<ol><li>针对​ <code>​test-pc​</code> ​客户端添加支持密码模，可以同时支持多个模式，配置如下</li></ol> 
<pre>.authorizedGrantTypes("authorization_code", "password", "implicit","client_credentials","refresh_token")</pre> 
<h4>获取令牌token</h4> 
<p>使用浏览器访问http://localhost:8899/oauth/token</p> 
<ol><li>重新启动浏览器</li><li>Postman中将 client_id:client_secret 通过 Base64 编码</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/57/95/y2FrQJXC_o.png"></p> 
<ol><li>post 方式，请求体中指定: 授权方式 、用户名、密码</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/db/c3/fvdlFNMZ_o.png"></p> 
<h3>认证服务器配置- 简化授权模式</h3> 
<p>不通过第三方应用程序，直接在浏览器中向认证服务器申请令牌，不需要先获取授权码。直接可以一次请求就可得到令牌，在 redirect_uri 指定的回调地址中传递令牌（ access_token ）。该模式适合直接运行在浏览器上的应用，不用后端支持（例如 Javascript 应用）</p> 
<h4>简化模式</h4> 
<p>在​ <code>​OAuth2AuthorizationServerConfig​</code> ​​类中的​ <code>​configure(ClientDetailsServiceConfigurer clients)​</code> ​​方法中指定​ <code>​implicit​</code> ​</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/bc/24/Wps4E5wU_o.png"></p> 
<h4>获取令牌token</h4> 
<ol><li>打开浏览器，输入访问地址</li></ol> 
<pre>http://localhost:8899/oauth/authorize?client_id=test-pc&amp;response_type=token</pre> 
<p>注：此时​ <code>​response_typ​</code> ​​的参数值必须是​ <code>​token​</code> ​</p> 
<ol><li>当请求到达认证服务器的 AuthorizationEndpoint 后，它会要求资源所有者做身份验证 :</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d8/26/Iti9NRkc_o.png"></p> 
<ol><li>点击登录以后，会跳转到指定的​ <code>​redirect_uri​</code> ​,回调路径会，回调路径携带着令牌 access_token 、 expires_in 、 scope 等 ，如下图：</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8d/96/skJdw7Td_o.png"></p> 
<h3>认证服务器配置- 客户端授权模式</h3> 
<p>客户端模式(client credentials)是指客户端以自己名义，而不是用户 名 义 ，向认证服务器进行认证，严格说客户端模式并不属于​ <code>​OAuth2​</code> ​框架所解决的问题，在这种模式下，用户直接向客户端注册，客户端以自己的名义向认证服务器提供服务，实际上并不存在授权问题。</p> 
<ol><li>客户端向认证服务器进行身份认证，并要求一个访问令牌。</li><li>认证服务器确认无误后，向客户端提供访问令牌。</li></ol> 
<h4>指定客户端模式</h4> 
<p>在​ <code>​OAuth2AuthorizationServerConfig​</code> ​​类的​ <code>​configure(ClientDetailsServiceConfigurer clients)​</code> ​​方法中指定​ <code>​client_credentials​</code> ​</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/27/dd/NPHiZdUl_o.png"></p> 
<h4>获取令牌token</h4> 
<ol><li>Postman中将 client_id:client_secret 通过 Base64 编码</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/35/c6/WCH9Yp9M_o.png"></p> 
<p>2.post 方式，请求体中指定授权类型grant_type ：​ <code>​client_credentials​</code> ​</p> 
<p>注响应结果没有刷新令牌</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/0c/82/b8xG6XnP_o.png"></p> 
<h3>认证服务器配置-令牌刷新策略</h3> 
<p>如果用户访问资源的时候，客户端的令牌已经过期，那么就需要更新令牌，申请一个新的访问令牌。</p> 
<p>客户端发出更新令牌的Http请求，包含以下参数：</p> 
<ol><li>​ <code>​grant_type​</code> ​​:表示使用授权模式，此处固定值为​ <code>​refresh_token​</code> ​</li><li>​ <code>​refresh_token​</code> ​:表示早前收到的需要更新的令牌</li><li>​ <code>​scope​</code> ​:表示申请的授权范围，不可以超出上一次申请的范围。</li></ol> 
<p>**注：刷新令牌只有在授权模式和密码模式中才有，对应的指定这两种模式时，在类型上加上​ <code>​refresh_token​</code> ​**。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c0/24/eN4Pd0JE_o.png"></p> 
<h4>获取新令牌报错</h4> 
<ol><li>Postman中将 client_id:client_secret 通过 Base64 编码</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4d/be/FB1rk4ND_o.png"></p> 
<ol><li>post 方式，请求体中指定：授权类型、刷新令牌</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c3/2b/zqij67wX_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a7/ff/uINL46mG_o.png"></p> 
<p>当前报错: Internal Server Error , 对应idea控制台也发出警告: UserDetailsService is required.</p> 
<p>原因当前需要使用内存方式存储了用户令牌，应用使用UserDetailsService才行</p> 
<h4>解决办法</h4> 
<p>创建UserDetailsService实现</p> 
<ol><li>创建​ <code>​MyUserDetailsService​</code> ​动态获取用户令牌</li></ol> 
<pre>@Component
public class MyUserDetailsService implements UserDetailsService {

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        return new User("admin", passwordEncoder.encode("123456"),
                AuthorityUtils.commaSeparatedStringToAuthorityList("admin_role"));
    }
}</pre> 
<ol><li>在安全配置类​ <code>​OAuth2SecurityConfig​</code> ​​中注入​ <code>​myUserDetailsService​</code> ​</li></ol> 
<pre>@Autowired
    private UserDetailsService myUserDetailsService;

    /**
     * 用户类信息
     * @param auth
     * @throws Exception
     */
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(myUserDetailsService)                ;
    }</pre> 
<p>3.认证配置类​ <code>​OAuth2AuthorizationServerConfig​</code> ​​的​ <code>​configure(AuthorizationServerEndpointsConfigurer endpoints)​</code> ​方法上加入到令牌端点上</p> 
<pre>@Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
        //密码模式需要配置认证管理器
        endpoints.authenticationManager(authenticationManager);
        //刷新令牌获取新令牌时需要
        endpoints.userDetailsService(myUserDetailsService);
    }</pre> 
<p>测试获取新令牌</p> 
<ol><li>重启认证服务器</li><li>Postman中将 client_id:client_secret 通过 Base64 编码</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c2/8e/YnGKEZzN_o.png"></p> 
<ol><li>post 方式，请求体中指定：授权类型 refresh_token 、刷新令牌值</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8b/89/QQtwgbiE_o.png"></p> 
<h3>认证服务器配置-令牌管理策略Redis &amp; JDBC</h3> 
<p>默认情况下，令牌是通过randomUUID产生的32为随机数来进行填充，从而产生的令牌默认是存储在内存中。</p> 
<ol><li>内存存储采用的 是​ <code>​TokenStore​</code> ​ 接口默认实现类 ​ <code>​InMemoryTokenStore​</code> ​ ,开发时方便调试，适用单机版</li><li>​ <code>​RedisTokenStore​</code> ​将令牌存储到Redis非关系型数据库，适用于高并发服务</li><li>​ <code>​JdbcTokenStore​</code> ​基于JDBC将令牌存储到关系型数据库中，可以在不同的服务器间共享令牌</li><li>​ <code>​JWtTokenStore​</code> ​将用户信息存储到令牌中，这样后端就可以不存储，前端拿到令牌后可以直接解析出用户信息。</li></ol> 
<h4>Redis令牌管理</h4> 
<p>启动Redis的服务器端和客户端</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/59/70/gKXiW8On_o.png"></p> 
<p>添加Redis的依赖</p> 
<ul><li>在​ <code>​spring-oauth2-server​</code> ​​模块中添加​ <code>​Redis​</code> ​相关依赖</li></ul> 
<pre>&lt;!--redis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
            &lt;version&gt;2.3.12.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;</pre> 
<ul><li>在​ <code>​application.yml​</code> ​​中添加​ <code>​redis​</code> ​的配置</li></ul> 
<pre>spring:
  thymeleaf:
    cache: false
  application:
    name: oauth2-server
  redis:
    port: 6379
    host: 127.0.0.1
    connect-timeout: 50000</pre> 
<p>配置Redis的管理TokenStore</p> 
<p>在MyOAuth2Config类中注入RedisTokenStore</p> 
<pre>@Autowired
    private RedisConnectionFactory redisConnectionFactory;
     /**
     * Redis令牌管理
     * 步骤：
     * 1.启动redis
     * 2.添加redis依赖
     * 3.添加redis 依赖后, 容器就会有 RedisConnectionFactory 实例
     * @return
     */
    @Bean
    public TokenStore redisTokenStore(){
        return  new RedisTokenStore(redisConnectionFactory);
    }</pre> 
<p>令牌管理策略添加到端点</p> 
<ul><li>将上面令牌管理策略作用到认证服务器端点上，这样策略就可以生效​ <code>​     /**      * 令牌管理策略      */     @Autowired     private TokenStore tokenStore;    @Override     public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {         //密码模式需要配置认证管理器         endpoints.authenticationManager(authenticationManager);         //刷新令牌获取新令牌时需要         endpoints.userDetailsService(myUserDetailsService);         //令牌管理策略         endpoints.tokenStore(tokenStore);         //授权码管理策略，针对授权码模式有效，会将授权码放到 auth_code 表，授权后就会删除它         endpoints.authorizationCodeServices(jdbcAuthorizationCodeS                                             ervices);     } ​</code> ​</li></ul> 
<ul><li>注入TokenStore</li><li>在​ <code>​OAuth2AuthorizationServerConfig​</code> ​​类的​ <code>​configure(AuthorizationServerEndpointsConfigurer endpoints)​</code> ​方法中将tokenStore添加到端点上</li></ul> 
<p>测试</p> 
<ol><li>重启认证服务器</li><li>使用 flflushall 命令清除所有数据，方便后面查看</li><li>使用密码模式获取令牌</li><li>keys * 查看效果如下</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d2/8c/k3eY0rsT_o.png"></p> 
<h4>JDBC管理令牌</h4> 
<p>创建相关数据表</p> 
<p>Spring官方提供了存储OAuth2相关信息的数据库表结构</p> 
<pre>https://github.com/spring-projects/spring-security-oauth/blob/main/spring-security-oauth2/src/test/resources/schema.sql</pre> 
<p>当前使用Mysql数据库，需要修改以下数据类型：</p> 
<ul><li>官方提供的表结构主键类型​ <code>​VARCHAR(256)​</code> ​​，超过了Mysql的限制长度128，需要修改为​ <code>​VARCHAR(128)​</code> ​</li><li>将​ <code>​LONGVARBINARY​</code> ​​类型修改为​ <code>​BLOB​</code> ​类型</li></ul> 
<p>修改后的表结构如下：</p> 
<pre>-- used in tests that use HSQL
create table oauth_client_details (
  client_id VARCHAR(128) PRIMARY KEY,
  resource_ids VARCHAR(256),
  client_secret VARCHAR(256),
  scope VARCHAR(256),
  authorized_grant_types VARCHAR(256),
  web_server_redirect_uri VARCHAR(256),
  authorities VARCHAR(256),
  access_token_validity INTEGER,
  refresh_token_validity INTEGER,
  additional_information VARCHAR(4096),
  autoapprove VARCHAR(256)
);
INSERT INTO `oauth_client_details` VALUES ('test-pc', 'oauth2-server,oauth2-resource', '$2a$10$Q2Dv45wFHgxQkFRaVNAzeOJorpTH2DwHb975VeHET30QsqwuoQOAe', 'all,Base_API', 'authorization_code,password,implicit,client_credentials,refresh_token', 'http://www.baidu.com/', NULL, 50000, NULL, NULL, 'false');

create table oauth_client_token (
  token_id VARCHAR(256),
  token BLOB,
  authentication_id VARCHAR(256) PRIMARY KEY,
  user_name VARCHAR(256),
  client_id VARCHAR(256)
);

create table oauth_access_token (
  token_id VARCHAR(256),
  token BLOB,
  authentication_id VARCHAR(256) PRIMARY KEY,
  user_name VARCHAR(256),
  client_id VARCHAR(256),
  authentication BLOB,
  refresh_token VARCHAR(256)
);

create table oauth_refresh_token (
  token_id VARCHAR(256),
  token BLOB,
  authentication BLOB
);

create table oauth_code (
  code VARCHAR(256), 
  authentication BLOB
);

create table oauth_approvals (
 userId VARCHAR(256),
 clientId VARCHAR(256),
 scope VARCHAR(256),
 status VARCHAR(10),
 expiresAt TIMESTAMP,
 lastModifiedAt TIMESTAMP
);


-- customized oauth_client_details table
create table ClientDetails (
  appId VARCHAR(256) PRIMARY KEY,
  resourceIds VARCHAR(256),
  appSecret VARCHAR(256),
  scope VARCHAR(256),
  grantTypes VARCHAR(256),
  redirectUrl VARCHAR(256),
  authorities VARCHAR(256),
  access_token_validity INTEGER,
  refresh_token_validity INTEGER,
  additionalInformation VARCHAR(4096),
  autoApproveScopes VARCHAR(256)
);</pre> 
<p>添加JDBC相关依赖</p> 
<p>其中有 mybatis-plus 因为后面要用,所以一起添加进来</p> 
<pre>&lt;!--mysql驱动--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!--druid--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.1.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--mybatis-plus--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.5.1&lt;/version&gt;
        &lt;/dependency&gt;</pre> 
<p>配置数据源信息</p> 
<p>在​ <code>​spring-oauth2-server​</code> ​​模块的​ <code>​application.yml​</code> ​中添加数据源</p> 
<pre>server:
  port: 8899
spring:
  thymeleaf:
    cache: false
  application:
    name: oauth2-server
  datasource:
    url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf-8&amp;useSSL=false
    username: root
    password: root
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource
    # 数据源其他配置, 在 DruidConfig配置类中手动绑定 initialSize: 8
    minIdle: 5
    maxActive: 20
    maxWait: 60000
    timeBetweenEvictionRunsMillis: 60000
    minEvictableIdleTimeMillis: 300000
    validationQuery: SELECT 1 FROM DUAL
  redis:
    port: 6379
    host: 127.0.0.1
    connect-timeout: 50000</pre> 
<p>配置JDBC的管理JdbcTokenStore</p> 
<ol><li>在​ <code>​MyOAuth2Config​</code> ​将DruidDataSource 数据源注入</li></ol> 
<pre>/**
     * druid数据源
     * @return
     */
    @Bean
    @ConfigurationProperties(prefix = "spring.datasource")
    public DataSource druidDataSource(){
        return  new DruidDataSource();
    }</pre> 
<ol><li>在​ <code>​MyOAuth2Config​</code> ​指定 JDBC 管理 JdbcTokenStore</li></ol> 
<pre>/**
     * jdbc管理令牌
     *步骤：
     * 1.创建相关表
     * 2.添加jdbc相关依赖
     * 3.配置数据源信息
     * @return
     */
    @Bean
    public TokenStore jdbcTokenStore(){
        return  new JdbcTokenStore(druidDataSource());
    }</pre> 
<p>测试</p> 
<ol><li>重启认证服务器</li><li>使用密码模式进行授权操作，然后查询 oauth_access_token 表就存储了令牌信息</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/93/82/uC4wH88v_o.png"></p> 
<h3>认证服务器配置-JDBC管理授权码</h3> 
<p>授权码主要是操作​ <code>​oauth_code​</code> ​​表，只有当grant_type是​ <code>​authorization_code(授权码模式)​</code> ​​时，该表中才会有数据产生，其他模式下​ <code>​oauth_code​</code> ​表不会生成数据。</p> 
<h4>授权码切换成JDBC</h4> 
<ul><li>在​ <code>​MyOAuth2Config​</code> ​​类中注入​ <code>​AuthorizationCodeServices​</code> ​</li></ul> 
<pre>/**
     * 授权码管理策略
     * @return
     */
    @Bean
    public AuthorizationCodeServices jdbcAuthorizationCodeServices(){
        //使用JDBC方式保存授权码到 oauth_code中
        return new JdbcAuthorizationCodeServices(druidDataSource());
    }</pre> 
<ul><li>在认证服务器配置类​ <code>​OAuth2AuthorizationServerConfig​</code> ​​中的​ <code>​configure(AuthorizationServerEndpointsConfigurer endpoints)​</code> ​方法中将授权码添加到端点上</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8e/4f/FXrXFrj0_o.png"></p> 
<h4>测试</h4> 
<ol><li>重启项目</li><li>发送请求获取授权码</li></ol> 
<pre>http://localhost:8899/oauth/authorize?client_id=test-pc&amp;response_type=code</pre> 
<ol><li>查看 oauth_code 数据表数据</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e1/20/4M5QJbUM_o.png"></p> 
<h3>认证服务器配置-JDBC存储客户端信息</h3> 
<p>查看客户端表​ <code>​oauth_client_details​</code> ​中的字段信息详解：</p> 
<ul><li>​ <code>​client_id​</code> ​:表示客户端ID</li><li>​ <code>​resource_ids​</code> ​:可以访问资源服务器的ID,不写则不需要校验</li><li>​ <code>​client_secret​</code> ​:客户端密码， <strong>此处不能是明文，需要加密</strong></li><li>​ <code>​scope​</code> ​:客户端授权范围，指定默认不需要校验</li><li>​ <code>​authorized_grant_types​</code> ​:客户端授权类型，支持多个使用逗号分隔</li></ul> 
<pre>authorization_code,password,implicit,client_credentials,refresh_token</pre> 
<pre>​web_server_redirect_uri​
​autoapprove​
</pre> 
<p>注：需要使用BCryptPasswordEncoder为client_secret对客户端密码进行加密</p> 
<ul><li>在MyOAuth2Config类中注入ClientDetailsService</li></ul> 
<pre>/**
     * 使用 JDBC 方式管理客户端信息
     * @return
     */
    @Bean
    public ClientDetailsService jdbcClientDetailsService(){
       return new JdbcClientDetailsService(druidDataSource());
    }</pre> 
<ul><li>在认证服务器配置类​ <code>​OAuth2AuthorizationServerConfig​</code> ​​的​ <code>​confifigure(ClientDetailsServiceConfifigurer)​</code> ​ 切换成JDBC 方式管理客户端信息</li></ul> 
<pre>@Autowired
    private ClientDetailsService jdbcClientDetailsService;


    /**
     * 配置被允许访问此认证服务器的客户端详细信息
     * 1.内存管理
     * 2.数据库管理方式
     * @param clients
     * @throws Exception
     */
    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.withClientDetails(jdbcClientDetailsService);
                ;
    }</pre> 
<h4>测试</h4> 
<ol><li>重启认证服务器</li><li>使用 admin 用户获取令牌看是否正常, 可以把数据库中scope值更改下，看是不是响应修改后的</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c9/0d/VcN67Lyj_o.png"></p> 
<h3>认证服务器配置-令牌端点的安全策略</h3> 
<p>端点403不允许访问</p> 
<p>令牌访问端点</p> 
<p>Spring Security对OAuth2提供了默认可访问端点，即URL</p> 
<ul><li>​ <code>​/oauth/authorize​</code> ​​:申请授权码code，涉及类​ <code>​AuthorizationEndpoint​</code> ​</li><li>​ <code>​/oauth/token​</code> ​​:获取令牌token，涉及类​ <code>​TokenEndpoint​</code> ​</li><li>​ <code>​/oauth/check_token​</code> ​​:用于资源服务器请求端点来检查令牌是否有效，涉及类​ <code>​CheckTokenEndpoint​</code> ​</li><li>​ <code>​/oauth/confirm_access​</code> ​​:用于确认授权提交，涉及类​ <code>​WhitelabelApprovalEndpoint​</code> ​</li><li>​ <code>​/oauth/error​</code> ​​:授权错误信息，涉及​ <code>​WhitelabelErrorEndpoint​</code> ​</li><li>​ <code>​/oauth/token_key​</code> ​​:提供公有密匙的端点，使用JWT令牌时会使用，涉及类​ <code>​TokenKeyEndpoint​</code> ​</li></ul> 
<ol><li>默认情况下/oauth/check_token和/oauth/token_key端点默认是 denyAll() 拒绝访问的权限 ，如果这两个端点需要访问，要对他们进行认证和授权，才可以访问</li><li>请求头还是需要设置​ <code>​client_id:client_secret​</code> ​ Base64编码</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c4/03/u7MuSABG_o.png"></p> 
<h4>配置端点权限</h4> 
<p>指定​ <code>​isAuthenticated()​</code> ​​认证后可以访问 ​ <code>​/oauth/check_token​</code> ​​ 端点,指定​ <code>​ permitAll()​</code> ​​ 所有人可访问​ <code>​/oauth/token_key​</code> ​​端点，后面要获取公钥。在 ​ <code>​OAuth2AuthorizationServerConfig​</code> ​​类中覆盖​ <code>​configure(AuthorizationServerSecurityConfigurer security)​</code> ​ 方法如下：</p> 
<pre>@Override
    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
        //所有人可访问 /oauth/token_key 后面要获取公钥, 默认拒绝访问
        security.tokenKeyAccess("permitAll()");
        // 认证后可访问 /oauth/check_token , 默认拒绝访问
        security.checkTokenAccess("isAuthenticated()");
    }</pre> 
<h4>测试检查令牌端点</h4> 
<ol><li>重启认证服务器</li><li>检查令牌对应的用户信息</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c1/90/JzuERjMK_o.png"></p> 
<h3>实现资源服务器</h3> 
<p>实现资源服务器的有两种方式：</p> 
<h4>认证服务器和资源服务器定义在一个SpringBoot中</h4> 
<ul><li>配置资源服务器,对任何“/api/**”接口的访问，都必须经过OAuth2认证服务器认证。</li></ul> 
<pre>@Configuration
@EnableResourceServer
public class OAuth2ResourceServer extends ResourceServerConfigurerAdapter {

    @Override
    public void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .anyRequest().authenticated()
                .and()
                .requestMatchers()
                .antMatchers("/api/**");
    }
}</pre> 
<ul><li>随便写一个业务Api接口，代表该应用对外提供的服务资源:</li></ul> 
<pre>@RestController
@RequestMapping("/api")
public class HelloController {

    @RequestMapping("/hello/{name}")
    public String hello(@PathVariable("name") String name) {
        return "Hello Oauth2 :" +name;
    }
}</pre> 
<ul><li>使用AccessToken访问资源</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/41/be/GFbdgchF_o.png"></p> 
<h4>认证资源服务器分离</h4> 
<p>创建​ <code>​spring-oauth2-resourceapi​</code> ​模块</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6e/61/vU7pth3y_o.png"></p> 
<h4>添加依pom.xml</h4> 
<pre>&lt;dependencies&gt;
        &lt;!-- for OAuth 2.0 --&gt;
        &lt;!-- https://mvnrepository.com/artifact/org.springframework.security.oauth/spring-security-oauth2 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;
            &lt;version&gt;2.3.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--redis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
            &lt;version&gt;2.3.12.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--mysql驱动--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!--druid--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.1.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--mybatis-plus--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.5.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</pre> 
<h4>创建测试API</h4> 
<pre>@RestController
@RequestMapping("/test")
public class HelloController {

    @RequestMapping("/hello/{name}")
    public String hello(@PathVariable("name") String name) {
        return "Hello spring-oauth2-resourceapi :" +name;
    }
}</pre> 
<h4>配置资源服务器</h4> 
<ol><li>创建资源服务器配置类​ <code>​OAuth2ResourceServer​</code> ​类继承​ <code>​ResourceServerConfigurerAdapter​</code> ​</li><li>在类上添加注解</li></ol> 
<pre>​@Configuration​
​@EnableResourceServer ​
​@EnableGlobalMethodSecurity(prePostEnabled = true)​
</pre> 
<p>重写资源服务器相关配置方法​ <code>​configure(ResourceServerSecurityConfigurer resources)​</code> ​</p> 
<ul><li>配置当前资源服务器ID</li><li>添加校验令牌服务</li><li>创建 RemoteTokenServices 远程校验令牌服务，去校验令牌有效性，因为当前认证和资源服务器不是在同一工程中，所以要通过远程调用认证服务器校验令牌是否有效</li><li>如果认证和资源服务器在同一工程中，可以使用 DefaultTokenServices 配置校验令牌。</li></ul> 
<pre>@Configuration
@EnableResourceServer // 标识为资源服务器, 所有发往当前服务的请求，都会去请求头里找token，找不到或 验证不通过不允许访问
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class OAuth2ResourceServer extends ResourceServerConfigurerAdapter {

    @Resource
    private DataSource dataSource;

    @Bean
    public TokenStore tokenStore() {
        return new JdbcTokenStore(dataSource);
    }

    @Override
    public void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .anyRequest().authenticated()
                .and()
                .requestMatchers()
                .antMatchers("/test/**");
    }

    @Override
    public void configure(ResourceServerSecurityConfigurer resources) throws Exception {
        resources.resourceId("oauth2-resource")
                .tokenServices(tokenServices());
    }

    /**
     * 配置资源服务器如何校验token
     * 1. DefaultTokenServices
     * 如果认证服务器和资源服务器在同一个服务，则直接采用默认服务验证
     * 2.RemoteTokenServices
     * 当认证服务器和资源服务器不在同一个服务，要使用此服务器去远程认证服务器验证
     * @return
     */
    @Primary
    @Bean
    public RemoteTokenServices tokenServices() {
        //资源服务器去远程认证服务器验证 token 是否有效
        final RemoteTokenServices tokenService = new RemoteTokenServices();
        //请求认证服务器验证URL，注意：默认这个端点是拒绝访问的，要设置认证后可访问
        tokenService.setCheckTokenEndpointUrl("http://localhost:8899/oauth/check_token");
        //在认证服务器配置的客户端id
        tokenService.setClientId("test-pc");
        //在认证服务器配置的客户端密码
        tokenService.setClientSecret("123456");
        return tokenService;
    }
}</pre> 
<h4>测试</h4> 
<ol><li>启动认证服务器和资源服务器</li><li>通过密码方式获取令牌</li><li>请求头带上令牌请求/test/hello 资源</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a0/97/VfSK67Nv_o.png"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0d17c5e11be9b0fd2a06b30541e57781/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">第一个Unity项目——Flappy Bird</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3a32c18ae44b6b75c8b6204de7f6409c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mmdetection之config文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>