<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python程序日志_如何在python应用程序中实现日志记录 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python程序日志_如何在python应用程序中实现日志记录" />
<meta property="og:description" content="python程序日志
A practical guide to implementing logging
实施日志的实用指南 Recently, I set about building a Python application to query a PostgreSQL database, process the data and push subsequent trigger events to a Kafka queue. However, before tackling the interesting aspects, I knew I needed to get the basics right. And one very important basic for any application is logging!
最近，我着手构建一个Python应用程序来查询PostgreSQL数据库，处理数据并将后续触发事件推送到Kafka队列。 但是，在解决有趣的方面之前，我知道我需要正确了解基础知识。 对于任何应用程序来说，一个非常重要的基础是日志记录！ In this article I’ll first explain some of the key features of logging in Python and, more importantly, demonstrate how I implemented a logger in my application." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/586d67d093708aae98efb97f6c195b13/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-15T15:28:19+08:00" />
<meta property="article:modified_time" content="2020-08-15T15:28:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python程序日志_如何在python应用程序中实现日志记录</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <article style="font-size: 16px;"> 
 <p>python程序日志</p> 
 <div> 
  <section> 
   <div> 
    <div> 
     <p>A practical guide to implementing logging</p> 
     <p> 实施日志的实用指南 </p> 
     <p>Recently, I set about building a Python application to query a PostgreSQL database, process the data and push subsequent trigger events to a Kafka queue. However, before tackling the interesting aspects, I knew I needed to get the basics right. And one very important basic for any application is logging!</p> 
     <p> 最近，我着手构建一个Python应用程序来查询PostgreSQL数据库，处理数据并将后续触发事件推送到Kafka队列。 但是，在解决有趣的方面之前，我知道我需要正确了解基础知识。 对于任何应用程序来说，一个非常重要的基础是日志记录！ </p> 
     <p>In this article I’ll first explain some of the key features of logging in Python and, more importantly, demonstrate how I implemented a logger in my application.</p> 
     <p> 在本文中，我将首先解释Python日志记录的一些关键功能，更重要的是，演示如何在应用程序中实现记录器。 </p> 
     <figure style="display:block;text-align:center;"> 
      <div> 
       <div> 
        <div> 
         <div> 
          <div style="text-align: center;"> 
           <img alt="Image for post" src="https://images2.imgbox.com/50/00/Xsi08nEf_o.png" width="1908" height="420" style="outline: none;"> 
          </div> 
         </div> 
        </div> 
       </div> 
      </div> 
      <figcaption>
        An example of an error log when connecting to PostgreSQL — Image from author 
      </figcaption> 
      <figcaption>
        连接到PostgreSQL时的错误日志的示例—照片作者作者 
      </figcaption> 
     </figure> 
     <h2> 打印(“为什么不呢？”) <span style="font-weight: bold;">(</span>print(‘Why not?’)<span style="font-weight: bold;">)</span></h2> 
     <p>The first question to tackle: Why not just use <code>print()</code>? It’s tempting to take the easy route and add print statements all over your code. We’ve all written code thats looks a bit like this:</p> 
     <p> 要解决的第一个问题：为什么不只使用<code>print()</code> ？ 采取简单的方法并在代码中添加打印语句很诱人。 我们都编写了如下代码： </p> 
     <pre><code class="has">print("Getting some docs...")<br>docs = getDocs()<br>print("Doc count %s", len(docs))<br>print("Finished")</code></pre> 
     <p>Generally this is fine for small scripts, or if you need something quick and dirty while developing or debugging. However, <code>print()</code> is just not a viable logging solution for larger applications. Especially if you are planning on promoting your code into production environments.</p> 
     <p> 通常，这适用于小型脚本，或者在开发或调试时需要快速又肮脏的东西。 但是，对于大型应用程序， <code>print()</code>并不是可行的日志记录解决方案。 特别是如果您打算将代码推广到生产环境中。 </p> 
     <p>To touch on a few of the reasons why print should be avoided. Firstly, It only gives you the option of logging to <code>stdout</code>. This is going to be problematic if you are logging lots of data. Really, you want to be writing your logs somewhere that can be easily persisted, backed up and queried at a later date. Another reason is that print statements are not configurable at run time. To switch on/off specific logs you will need to modify your code every single time. This will mean redeploying your code to production every time you need to turn on debug logging! On top of this, it’s also much more difficult to include valuable information and context, such as the line number and the time the log message was generated.</p> 
     <p> 谈谈应避免打印的一些原因。 首先，它仅使您可以选择登录到<code>stdout</code> 。 如果您要记录大量数据，这将是有问题的。 确实，您希望将日志写入可以轻松保存，备份和稍后查询的地方。 另一个原因是在运行时无法配置打印语句。 要打开/关闭特定的日志，您需要每次都修改代码。 这意味着您每次需要打开调试日志记录时，都将代码重新部署到生产环境中！ 最重要的是，包含有价值的信息和上下文(例如行号和生成日志消息的时间)也要困难得多。 </p> 
     <p>I could go on, but hopefully you are already convinced!</p> 
     <p> 我可以继续，但是希望您已经说服了！ </p> 
     <h2> 输入Python的日志记录模块 <span style="font-weight: bold;">(</span>Enter Python’s Logging Module<span style="font-weight: bold;">)</span></h2> 
     <p>Fortunately, the importance of logging is not a new phenomenon. Python ships with a ready made logging solution as part of the Python standard library. It solves all the afore mentioned problems with using print. For example:</p> 
     <p> 幸运的是，测井的重要性并不是一个新现象。 Python随附了现成的日志记录解决方案，作为Python标准库的一部分。 它解决了使用打印的所有上述问题。 例如： </p> 
     <ul><li>Automatically add context, such as line number &amp; timestamps to logs<p class="nodelete"></p> 自动将上下文(例如行号和时间戳)添加到日志中 </li><li>It’s possible to update our logger at runtime by passing a configuration file to the app<p class="nodelete"></p> 通过将配置文件传递给应用程序，可以在运行时更新记录器 </li><li>It is easy to customise the log severity and configure different logging levels for different environments<p class="nodelete"></p> 自定义日志严重性并针对不同环境配置不同的日志记录级别很容易 </li></ul> 
     <p>Lets try it out and set up a very basic logger:</p> 
     <p> 让我们尝试一下并设置一个非常基本的记录器： </p> 
     <figure style="display:block;text-align:center;"></figure> 
     <p>Running this gives:</p> 
     <p> 运行此命令可获得： </p> 
     <pre><code class="has">INFO:__main__:Getting some docs...<br>INFO:__main__:Doc count 2<br>INFO:__main__:Finished</code></pre> 
     <p>Easy peasy! ✅ 👏</p> 
     <p> 十分简单！ 👏 </p> 
     <p>Here, we have imported the logging module from the Python standard library. We then updated the default basic log level to log <code>INFO</code> messages. Next, <code>logger = logging.getLogger(__name__)</code> instantiates our logging instance. Finally, we passed an event to the logger with a log level of <code>INFO</code> by calling<code>logger.info("")</code>.</p> 
     <p> 在这里，我们从Python标准库中导入了日志记录模块。 然后，我们更新了默认的基本日志级别以记录<code>INFO</code>消息。 接下来， <code>logger = logging.getLogger(__name__)</code>实例化我们的日志记录实例。 最后，我们通过调用<code>logger.info("")</code>将事件传递给日志级别为<code>INFO</code>的记录器。 </p> 
     <p>At first glance, this output might appear suspiciously similar to using <code>print()</code>. Next, we’ll expand our example logger to demonstrate some of the more powerful features that the Python standard logging modules provides.</p> 
     <p> 乍一看，此输出看起来可疑地类似于使用<code>print()</code> 。 接下来，我们将扩展示例记录器，以演示Python标准记录模块提供的一些更强大的功能。 </p> 
     <h3> 日志级别 <span style="font-weight: bold;">(</span>Log Levels<span style="font-weight: bold;">)</span></h3> 
     <p>We can configure the severity of the logs being output and filter out unimportant ones. The module defines five constants throughout the spectrum, making it easy to differentiate between messages. The numeric values of logging levels are given in the following table.</p> 
     <p> 我们可以配置输出日志的严重性，并过滤掉不重要的日志。 该模块在整个频谱中定义了五个常数，从而可以轻松区分消息。 下表中给出了日志记录级别的数值。 </p> 
     <figure style="display:block;text-align:center;"> 
      <div> 
       <div> 
        <div> 
         <div style="text-align: center;"> 
          <img alt="Image for post" src="https://images2.imgbox.com/fd/a7/eNqc7LLs_o.png" width="622" height="576" style="outline: none;"> 
         </div> 
        </div> 
       </div> 
      </div> 
      <figcaption> 
       <a href="https://docs.python.org/3/library/logging.html#logging-levels" rel="noopener nofollow noopener noreferrer" target="_blank">https://docs.python.org/3/library/logging.html#logging-levels</a> 
       <a href="https://docs.python.org/3/library/logging.html#logging-levels" rel="noopener nofollow noopener noreferrer" target="_blank">https://docs.python.org/3/library/logging.html#logging-levels的</a>日志记录级别 
      </figcaption> 
     </figure> 
     <p>It’s important not to flood your logs with lots of messages. To achieve concise logs, we should be careful to define the correct log level for each event.</p> 
     <p> 重要的是不要在日志中充斥大量消息。 为了获得简洁的日志，我们应该为每个事件定义正确的日志级别。 </p> 
     <pre><code class="has">logger.critical("Really bad event"<br>logger.error("An error")<br>logger.warning("An unexpected event")<br>logger.info("Used for tracking normal application flow")<br>logger.debug("Log data or variables for developing")</code></pre> 
     <p>I tend to use the debug level to log the data being passed around the app. Here is an example of using 3 different log levels in the few lines of code responsible for sending events to Kafka.</p> 
     <p> 我倾向于使用调试级别来记录在应用程序周围传递的数据。 这是在几行代码中使用3种不同日志级别的示例，这些代码负责将事件发送到Kafka。 </p> 
     <figure style="display:block;text-align:center;"></figure> 
     <h3> 格式化日志 <span style="font-weight: bold;">(</span>Formatting Logs<span style="font-weight: bold;">)</span></h3> 
     <p>The default formatter of the Python logging module doesn’t provide a great amount of detail. Fortunately, it is easy to configure the log format to add all the context we need to produce super useful log messages.</p> 
     <p> Python日志记录模块的默认格式化程序未提供大量详细信息。 幸运的是，很容易配置日志格式以添加生成超级有用的日志消息所需的所有上下文。 </p> 
     <p>For example, here we add a timestamp and the log level to the log message.</p> 
     <p> 例如，在这里，我们在日志消息中添加时间戳和日志级别。 </p> 
     <pre><code class="has">formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')</code></pre> 
     <p>It’s best practice to add as much context as possible to your logs. This can easily be achieved by adding structured data to the log message’s metadata. For example, you may have scaled your application to run with multiple workers. In this case it might be important to know which worker was logging each event when you’re debugging so lets add a worker id context to the log metadata.</p> 
     <p> 最佳做法是在日志中添加尽可能多的上下文。 通过将结构化数据添加到日志消息的元数据中，可以轻松实现这一点。 例如，您可能已缩放应用程序以与多个工作程序一起运行。 在这种情况下，调试时知道哪个工作程序正在记录每个事件可能很重要，因此让我们将工作程序ID上下文添加到日志元数据中。 </p> 
     <pre><code class="has"># Create the log formatterformatter = <br>handler.setFormatter(formatter)logger.info('Querying database for docs...', extra={'worker': <br>'id_1'})</code></pre> 
     <p>The output becomes:</p> 
     <p> 输出变为： </p> 
     <pre><code class="has">2020-09-02 22:06:18,170 - id_1 - INFO - Querying database for docs...</code></pre> 
     <h3> 日志处理程序 <span style="font-weight: bold;">(</span>Log Handlers<span style="font-weight: bold;">)</span></h3> 
     <p>Now we have perfectly formatted logs being fired at us from all over our application code, we need to consider where those logs are ending up. By default the logs are being written to stdout, but Python’s logging module provides us with the functionality to push logs to alternative locations. For example, to save logs to <code>example.log</code> file on disk.</p> 
     <p> 现在，我们已经从所有应用程序代码中向我们发射了格式正确的日志，我们需要考虑这些日志在哪里结束。 默认情况下，日志会写入stdout，但是Python的日志记录模块为我们提供了将日志推送到其他位置的功能。 例如，将日志保存到磁盘上的<code>example.log</code>文件中。 </p> 
     <pre><code class="has"># create a file handler<br>handler = logging.FileHandler('example.log')<br>handler.setLevel(logging.INFO)</code></pre> 
     <p>There are several types of handlers that can be used. For the complete list, see the <a href="https://docs.python.org/3/library/logging.handlers.html#module-logging.handlers" rel="noopener nofollow noopener noreferrer" target="_blank">documentation for handlers</a>. It is also possible to define custom logging handlers for different use cases. For example, <a href="https://pypi.org/project/slacker-log-handler/" rel="noopener nofollow noopener noreferrer" target="_blank">here</a> is a library that defines a log handler for pushing logs to Slack!</p> 
     <p> 可以使用几种类型的处理程序。 有关完整列表，请参见<a href="https://docs.python.org/3/library/logging.handlers.html#module-logging.handlers" rel="noopener nofollow noopener noreferrer" target="_blank">处理程序</a>的<a href="https://docs.python.org/3/library/logging.handlers.html#module-logging.handlers" rel="noopener nofollow noopener noreferrer" target="_blank">文档</a> 。 也可以为不同用例定义自定义日志记录处理程序。 例如， <a href="https://pypi.org/project/slacker-log-handler/" rel="noopener nofollow noopener noreferrer" target="_blank">这</a>是一个库，该库定义了用于将日志推送到Slack的日志处理程序！ </p> 
     <p>To summarise. We’ve set up the Python standard logging module and configured it to log to different locations with custom log formats. You can find the final code for the example logger below:</p> 
     <p> 总结一下。 我们已经设置了Python标准日志记录模块，并将其配置为使用自定义日志格式记录到其他位置。 您可以在下面找到示例记录器的最终代码： </p> 
     <figure style="display:block;text-align:center;"></figure> 
    </div> 
   </div> 
  </section> 
  <section> 
   <div> 
    <div> 
     <h2> 实作 <span style="font-weight: bold;">(</span>Implementation<span style="font-weight: bold;">)</span></h2> 
     <p>Hopefully, by now you should have a good idea of some of the key features of the Python logging module. That’s all well and good, but how should you implement all this different configuration and manage importing logging modules in your application files? It’s a point often over looked by many guides. Here is how I decided to handle it.</p> 
     <p> 希望到目前为止，您应该对Python日志记录模块的一些关键功能有所了解。 很好，但是您应该如何实现所有这些不同的配置并管理应用程序文件中的导入日志记录模块？ 许多指南经常忽略这一点。 这是我决定处理的方式。 </p> 
     <p>First up, I decided to extract all the logging configuration into a config file called <code>logging.ini</code>. You can find all the information you need on how to format the log file in the <a href="https://docs.python.org/3/library/logging.config.html#configuration-file-format" rel="noopener nofollow noopener noreferrer" target="_blank">official docs</a>, so I won’t go over it all here. Currently, my logging.ini is super basic. When the application is out of development and ready for deployment I’ll be extending the logging configuration to handle different environments, rotate logs on disk and sent alerts to a Slack channel.</p> 
     <p> 首先，我决定将所有日志记录配置提取到一个名为<code>logging.ini</code>的配置文件中。 您可以在<a href="https://docs.python.org/3/library/logging.config.html#configuration-file-format" rel="noopener nofollow noopener noreferrer" target="_blank">官方文档中</a>找到有关如何格式化日志文件所需的所有信息，因此在此不再赘述。 目前，我的logging.ini超级基础。 当应用程序停止开发并准备部署时，我将扩展日志记录配置以处理不同的环境，旋转磁盘上的日志并将警报发送到Slack通道。 </p> 
     <figure style="display:block;text-align:center;"></figure> 
     <p>The great thing is, this really simplifies the implementation from a code point of view because you need <em>much</em> less boilerplate to set up log handlers and formatters. Above, we had 15 lines of code setting up just one formatter and one handler - it’s easy to imagine how this could become a lot bigger with more complex use cases. Now all that complexity has been abstracted away to the config file. The result…to implement your logger you just need two extra lines of code in your app!</p> 
     <p> 伟大的事情是，这真的是从一个码点简化了实现，因为你需要少<em>得多</em>的样板设置日志处理程序和格式化。 上面，我们有15行代码仅设置了一个格式化程序和一个处理程序-可以想象，如果使用更复杂的用例，代码可能会变得更大。 现在，所有这些复杂性已被抽象到配置文件中。 结果……要实现记录器，您只需要在应用程序中多添加两行代码即可！ </p> 
     <pre><code class="has">import logging.configlogging.config.fileConfig(fname='logger.ini')</code></pre> 
     <p>Pretty neat! But where should this code live exactly?</p> 
     <p> 漂亮整齐！ 但是此代码应准确地存放在哪里？ </p> 
     <p>My application is structured with a <code>__main__.py</code> as the entry point. I decided to implement my logger inside this file in order to not distract from the main functionality contained within app.py. The below <code>__main__.py</code> will handle reading the config file and applying the configuration to your logger.</p> 
     <p> 我的应用程序的结构是一个<code>__main__.py</code>作为入口点。 我决定在此文件中实现我的记录器，以免分散app.py中包含的主要功能。 下面的<code>__main__.py</code>将处理读取配置文件并将配置应用于记录器的操作。 </p> 
     <figure style="display:block;text-align:center;"></figure> 
     <p>Finally, we need to make use of our creation, by firing off some logs! But these messages aren’t going to be generated by the<code>__main__</code>function, so how should we handle passing our logger to other files and functions within the application?</p> 
     <p> 最后，我们需要通过释放一些日志来利用我们的创造！ 但是这些消息不会由<code>__main__</code>函数生成，因此我们应该如何处理将记录器传递给应用程序中的其他文件和函数呢？ </p> 
     <p>Again this becomes trivial. To use the logger in another file, we only need to import the logging module and instantiate it. It will automatically inherit the configuration that we passed to it in <code>__main__</code>. For example, to start logging messages in <code>app.py</code>:</p> 
     <p> 再次，这变得微不足道。 要在另一个文件中使用记录器，我们只需要导入记录模块并将其实例化即可。 它将自动继承我们在<code>__main__</code>传递给它的配置。 例如，要开始在<code>app.py</code>记录消息： </p> 
     <figure style="display:block;text-align:center;"></figure> 
     <p>The above debug message will be handled based on the logging configuration read from<code>logging.ini</code>. And the same will be true for every other python file in you application, as long as you <code>import logging</code> at the top. Yes, it is really that simple!</p> 
     <p> 以上调试消息将根据从<code>logging.ini</code>读取的日志配置进行处理。 只要您在顶部<code>import logging</code> ，应用程序中的其他所有python文件都一样。 是的，真的就是这么简单！ </p> 
     <p>To recap, not only have you seen some of the features that make the Python logging module an awesome tool to have in your armoury, you have also seen how easy it is to implement.</p> 
     <p> 回顾一下，您不仅看到了使Python日志记录模块成为强大工具的某些功能，而且还看到了实现的难易程度。 </p> 
     <p>Thank you for reading and I hope you found this guide useful. Happy logging!</p> 
     <p> 感谢您的阅读，希望本指南对您有所帮助。 祝您登录愉快！ </p> 
    </div> 
   </div> 
  </section> 
 </div> 
 <blockquote> 
  <p>翻译自: <a href="https://medium.com/@leo.brack/how-to-implement-logging-in-your-python-application-1730315003c4" rel="nofollow">https://medium.com/@leo.brack/how-to-implement-logging-in-your-python-application-1730315003c4</a></p> 
 </blockquote> 
 <p>python程序日志</p> 
</article>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b63f2fe50c006ded210defded8c2c7ca/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">为什么要用深浅拷贝、什么是深浅拷贝、以及如何实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f6e49c50b4731cbd2c7ab02120563a77/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">操作系统——进程管理的功能</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>