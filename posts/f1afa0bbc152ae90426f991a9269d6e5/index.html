<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue 富文本编辑器 wangeditor 自定义上传图片 以及 解决 复制粘贴 word 没有图片的情况 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue 富文本编辑器 wangeditor 自定义上传图片 以及 解决 复制粘贴 word 没有图片的情况" />
<meta property="og:description" content="本人比较喜欢用这一款编辑器，官方文档：(用于 Vue React | wangEditor)，很详细。我主要来说说怎么使用customPaste 自定义粘贴的，怎么解决 复制粘贴 word ，没有图片的情况。
主要是关于wangeditor在vue2的使用
效果图：
先把完整代码放这里：
&lt;template&gt; &lt;div class=&#34;addpost_course&#34;&gt; &lt;div id=&#34;editor&#34; style=&#34;border: 1px solid #ccc; width: 534px&#34;&gt; &lt;Toolbar style=&#34;border-bottom: 1px solid #ccc&#34; :editor=&#34;editor&#34; :defaultConfig=&#34;toolbarConfig&#34; :mode=&#34;mode&#34; /&gt; &lt;Editor style=&#34;height: 200px; overflow-y: hidden&#34; v-model=&#34;content&#34; :defaultConfig=&#34;editorConfig&#34; :mode=&#34;mode&#34; @onCreated=&#34;onCreated&#34; @onChange=&#34;onChange&#34; @onDestroyed=&#34;onDestroyed&#34; @onMaxLength=&#34;onMaxLength&#34; @onFocus=&#34;onFocus&#34; @onBlur=&#34;onBlur&#34; @customAlert=&#34;customAlert&#34; @customPaste=&#34;customPaste&#34; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { Editor, Toolbar } from &#34;@wangeditor/editor-for-vue&#34;; import { Loading, Message } from &#34;element-ui&#34;; export default { components: { Editor, Toolbar }, data() { return { // 富文本 editor: null, // 富文本里面的所有内容（带标签的） content: &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f1afa0bbc152ae90426f991a9269d6e5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-13T22:07:14+08:00" />
<meta property="article:modified_time" content="2023-11-13T22:07:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue 富文本编辑器 wangeditor 自定义上传图片 以及 解决 复制粘贴 word 没有图片的情况</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本人比较喜欢用这一款编辑器，官方文档：(<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.wangeditor.com%2Fv5%2Ffor-frame.html" rel="nofollow" title="用于 Vue React | wangEditor">用于 Vue React | wangEditor</a>)，很详细。我主要来说说怎么使用<code>customPaste</code> 自定义粘贴的，<strong>怎么解决 复制粘贴 word ，没有图片的情况</strong>。</p> 
<p><strong>主要是关于wangeditor在vue2的使用</strong></p> 
<p>效果图：</p> 
<p></p> 
<p class="img-center"><img alt="CHV)HRXJ[I744C32NX0]NL1.png" height="474" src="https://images2.imgbox.com/d9/5d/Lz7Rx6Lx_o.png" width="560"></p> 
<p>先把完整代码放这里：</p> 
<pre></pre> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div class="addpost_course"&gt;
                &lt;div id="editor" style="border: 1px solid #ccc; width: 534px"&gt;
                  &lt;Toolbar
                    style="border-bottom: 1px solid #ccc"
                    :editor="editor"
                    :defaultConfig="toolbarConfig"
                    :mode="mode"
                  /&gt;
                  &lt;Editor
                    style="height: 200px; overflow-y: hidden"
                    v-model="content"
                    :defaultConfig="editorConfig"
                    :mode="mode"
                    @onCreated="onCreated"
                    @onChange="onChange"
                    @onDestroyed="onDestroyed"
                    @onMaxLength="onMaxLength"
                    @onFocus="onFocus"
                    @onBlur="onBlur"
                    @customAlert="customAlert"
                    @customPaste="customPaste"
                  /&gt;
                &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;



&lt;script&gt;
import { Editor, Toolbar } from "@wangeditor/editor-for-vue";
import { Loading, Message } from "element-ui";
export default {
  components: { Editor, Toolbar },
  data() {
    return {
      // 富文本
      editor: null,
      // 富文本里面的所有内容（带标签的）
      content: "",
      toolbarConfig: {},
      editorConfig: {
        placeholder: "请输入内容...",
        // 所有的菜单配置，都要在 MENU_CONF 属性下
        MENU_CONF: {
          //配置上传图片
          uploadImage: {
            // 自定义上传图片 方法
            customUpload: this.uploadImg,
            // 自定义插入图片 方法
            customInsert: this.insertImg,
            //server必须要配置正确,我这里因为上传图片有点特殊，在下面方法配置了，所以此处不用配置地址
            // server: 'https://xwbdzzz.haiyan.gov.cn:10002/form/temp/update/ajax/img',

            maxFileSize: 4 * 1024 * 1024, // 1M
            // 最多可上传几个文件，默认为 100
            maxNumberOfFiles: 100,
            // 选择文件时的类型限制，默认为 ['image/*'] 。如不想限制，则设置为 []
            allowedFileTypes: [],
            // 自定义上传参数，例如传递验证的 token 等。参数会被添加到 formData 中，一起上传到服务端。
            fieldName: "file",
            meta: {
              //官网中把token放到了这里，但是请求的时候会看不到token
            },
            headers: {
              //所以token放这里
              // token: window.sessionStorage.token,
            },
            // 将 meta 拼接到 url 参数中，默认 false
            metaWithUrl: false,
            // 跨域是否传递 cookie ，默认为 false
            withCredentials: false,
            // 超时时间，默认为 10 秒
            timeout: 5 * 1000, // 5 秒

            // 上传之前触发
            // onBeforeUpload(file) {
            //   console.log(file);    // JS 语法
            //     // file 选中的文件，格式如 { key: file }
            //     return file

            //     // 可以 return
            //     // 1. return file 或者 new 一个 file ，接下来将上传
            //     // 2. return false ，不上传这个 file
            // },

            // // 上传进度的回调函数

            // onProgress(progress) {       // JS 语法
            //     // progress 是 0-100 的数字
            //     console.log('progress', progress)
            // },

            // // 单个文件上传成功之后

            // onSuccess(file, res) {          // JS 语法
            //     console.log(`${file.name} 上传成功`, res)
            // },

            // // 单个文件上传失败

            // onFailed(file, res) {           // JS 语法
            //     console.log(`${file.name} 上传失败`, res)
            // },

            // // 上传错误，或者触发 timeout 超时

            // onError(file, err, res) {               // JS 语法
            //     console.log(`${file.name} 上传出错`, err, res)
            // },
          },
          // 配置上传视频（同上传图片）
          uploadVideo: {},
        },
      },
      mode: "default", // or 'simple'

      
  methods: {

    // 富文本
    onCreated(editor) {
      this.editor = Object.seal(editor); // 一定要用 Object.seal() ，否则会报错
      console.log(this.editor);
    },
    onChange(editor) {
      console.log("onChange", editor.children, this.content);
    },
    onDestroyed(editor) {
      console.log("onDestroyed", editor);
    },
    onMaxLength(editor) {
      console.log("onMaxLength", editor);
    },
    onFocus(editor) {
      console.log("onFocus", editor);
    },
    onBlur(editor) {
      console.log("onBlur", editor);
    },
    customAlert(info, type) {
      window.alert(`customAlert in Vue demo\n${type}:\n${info}`);
    },

    //重点来了： 自定义粘贴。可阻止编辑器的默认粘贴，实现自己的粘贴逻辑。(可以实现复制粘贴 word ，有图片)
    customPaste(editor, event, callback) {
      console.log("ClipboardEvent 粘贴事件对象", event);
      let html = event.clipboardData.getData("text/html"); // 获取粘贴的 html
      // let text = event.clipboardData.getData('text/plain') // 获取粘贴的纯文本
      let rtf = event.clipboardData.getData("text/rtf"); // 获取 rtf 数据（如从 word wsp 复制粘贴）
      var that = this;
      if (html &amp;&amp; rtf) {
        
        // 列表缩进会超出边框，直接过滤掉
        html = html.replace(/text\-indent:\-(.*?)pt/gi, "");

        // 从html内容中查找粘贴内容中是否有图片元素，并返回img标签的属性src值的集合
        const imgSrcs = that.findAllImgSrcsFromHtml(html);

        // 如果有
        if (imgSrcs &amp;&amp; Array.isArray(imgSrcs) &amp;&amp; imgSrcs.length) {
          // 从rtf内容中查找图片数据
          const rtfImageData = that.extractImageDataFromRtf(rtf);

          // 如果找到
          if (rtfImageData.length) {
            // TODO：此处可以将图片上传到自己的服务器上

            // 执行替换：将html内容中的img标签的src替换成ref中的图片数据，如果上面上传了则为图片路径
            html = that.replaceImagesFileSourceWithInlineRepresentation(
              html,
              imgSrcs,
              rtfImageData
            );
            editor.dangerouslyInsertHtml(html);
          }
        }

        // 阻止默认的粘贴行为
        event.preventDefault();
        return false;
      } else {
        return true;
      }
    },
    
    
    //自定义上传图片
    uploadImg(file, insertFn) {
      let imgData = new FormData();
      console.log(file);
      imgData.append("file", file);
      //调用上传图片接口，上传图片
      this.$api.post("/form/temp/update/ajax/img", imgData).then((res) =&gt; {
          console.log(res);
          // 插入后端返回的url
          insertFn(res[0].url);
          this.$message({
            type: "success",
            message: "上传成功",
          });
        })
        .catch((error) =&gt; {
          this.$message("上传失败,请重新上传");
        });
    },

    // 自定义插入图片
    insertImg(file) {
      console.log(file);
    },
    

    /**
     * 从html代码中匹配返回图片标签img的属性src的值的集合
     * @param htmlData
     * @return Array
     */
    findAllImgSrcsFromHtml(htmlData) {
      let imgReg = /&lt;img.*?(?:&gt;|\/&gt;)/gi; //匹配图片中的img标签
      let srcReg = /src=[\'\"]?([^\'\"]*)[\'\"]?/i; // 匹配图片中的src

      let arr = htmlData.match(imgReg); //筛选出所有的img
      if (!arr || (Array.isArray(arr) &amp;&amp; !arr.length)) {
        return false;
      }

      let srcArr = [];
      for (let i = 0; i &lt; arr.length; i++) {
        let src = arr[i].match(srcReg);
        // 获取图片地址
        srcArr.push(src[1]);
      }

      return srcArr;
    },
    /**
     * 从rtf内容中匹配返回图片数据的集合
     * @param rtfData
     * @return Array
     */
    extractImageDataFromRtf(rtfData) {
      if (!rtfData) {
        return [];
      }

      const regexPictureHeader =
        /{\\pict[\s\S]+?({\\\*\\blipuid\s?[\da-fA-F]+)[\s}]*/;
      const regexPicture = new RegExp(
        "(?:(" + regexPictureHeader.source + "))([\\da-fA-F\\s]+)\\}",
        "g"
      );
      const images = rtfData.match(regexPicture);
      const result = [];

      if (images) {
        for (const image of images) {
          let imageType = false;

          if (image.includes("\\pngblip")) {
            imageType = "image/png";
          } else if (image.includes("\\jpegblip")) {
            imageType = "image/jpeg";
          }

          if (imageType) {
            result.push({
              hex: image
                .replace(regexPictureHeader, "")
                .replace(/[^\da-fA-F]/g, ""),
              type: imageType,
            });
          }
        }
      }

      return result;
    },
    /**
     * 将html内容中img标签的属性值替换
     * @param htmlData html内容
     * @param imageSrcs html中img的属性src的值的集合
     * @param imagesHexSources rtf中图片数据的集合，与html内容中的img标签对应
     * @param isBase64Data 是否是Base64的图片数据
     * @return String
     */
    replaceImagesFileSourceWithInlineRepresentation(
      htmlData,
      imageSrcs,
      imagesHexSources,
      isBase64Data = true
    ) {
      if (imageSrcs.length === imagesHexSources.length) {
        for (let i = 0; i &lt; imageSrcs.length; i++) {
          const newSrc = isBase64Data
            ? `data:${
                imagesHexSources[i].type
              };base64,${this._convertHexToBase64(imagesHexSources[i].hex)}`
            : imagesHexSources[i];

          htmlData = htmlData.replace(imageSrcs[i], newSrc);
        }
      }

      return htmlData;
    },

    /**
     * 十六进制转base64
     */
    _convertHexToBase64(hexString) {
      return btoa(
        hexString
          .match(/\w{2}/g)
          .map((char) =&gt; {
            return String.fromCharCode(parseInt(char, 16));
          })
          .join("")
      );
    },

   
   
  // 销毁富文本
  beforeDestroy() {
    const editor = this.editor;
    if (editor == null) return;
    editor.destroy(); // 组件销毁时，及时销毁编辑器
  },
};
&lt;/script&gt;

//记得引入wangeditor样式
&lt;style src="@wangeditor/editor/dist/css/style.css"&gt;&lt;/style&gt;
&lt;style lang='scss' scoped&gt;
@import "../mystyle/addpost_course";
&lt;/style&gt;
</code></pre> 
<p>上传图片我这里有点特殊，就不细说了</p> 
<p>自定义粘贴：就几点：</p> 
<ul><li> <p>实现方法：<strong>通过 wangEditor 的编辑器配置 API 中的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.wangeditor.com%2Fv5%2Feditor-config.html%23custompaste" rel="nofollow" title="customPaste 自定义粘贴">customPaste 自定义粘贴</a></strong></p> </li><li> <p>实现步骤： 注意获取粘贴的 html和获取 rtf 数据 ，用let，不能用const,下面会发生修改 -<strong>特别注意：允许默认粘贴行为 既可以复制图片，也可以复制文本，还可以图片文本；阻止默认的粘贴行为，只能粘贴复制文字带图片的文本</strong></p> </li></ul> 
<pre></pre> 
<pre><code class="language-javascript">// 自定义粘贴。可阻止编辑器的默认粘贴，实现自己的粘贴逻辑。(可以实现复制粘贴 word ，有图片)
    customPaste(editor, event, callback) {
      console.log("ClipboardEvent 粘贴事件对象", event);
      let html = event.clipboardData.getData("text/html"); // 获取粘贴的 html，
      // let text = event.clipboardData.getData('text/plain') // 获取粘贴的纯文本
      let rtf = event.clipboardData.getData("text/rtf"); // 获取 rtf 数据（如从 word wsp 复制粘贴）

      var that = this;

      if (html &amp;&amp; rtf) {
        // 该条件分支即表示要自定义word粘贴

        // 列表缩进会超出边框，直接过滤掉
        html = html.replace(/text\-indent:\-(.*?)pt/gi, "");

        // 从html内容中查找粘贴内容中是否有图片元素，并返回img标签的属性src值的集合
        const imgSrcs = that.findAllImgSrcsFromHtml(html);

        // 如果有
        if (imgSrcs &amp;&amp; Array.isArray(imgSrcs) &amp;&amp; imgSrcs.length) {
          // 从rtf内容中查找图片数据
          const rtfImageData = that.extractImageDataFromRtf(rtf);

          // 如果找到
          if (rtfImageData.length) {
            // TODO：此处可以将图片上传到自己的服务器上

            // 执行替换：将html内容中的img标签的src替换成ref中的图片数据，如果上面上传了则为图片路径
            html = that.replaceImagesFileSourceWithInlineRepresentation(
              html,
              imgSrcs,
              rtfImageData
            );
            editor.dangerouslyInsertHtml(html);
          }
        }

        // 阻止默认的粘贴行为 //此处非常关键 允许默认行为 既可以复制图片，也可以复制文本，还可以图片文本
        // event.preventDefault();
        //event.preventDefault();
        return false;
      } else {
        return true;
      }
    },

</code></pre> 
<ul><li>以上实现步骤涉及到几个方法：</li></ul> 
<ol><li></ol> 
<pre></pre> 
<p>javascript</p> 
<p>复制代码</p> 
<pre><code class="language-javascript">/**
     * 从html代码中匹配返回图片标签img的属性src的值的集合
     * @param htmlData
     * @return Array
     */
    findAllImgSrcsFromHtml(htmlData) {
      let imgReg = /&lt;img.*?(?:&gt;|\/&gt;)/gi; //匹配图片中的img标签
      let srcReg = /src=[\'\"]?([^\'\"]*)[\'\"]?/i; // 匹配图片中的src

      let arr = htmlData.match(imgReg); //筛选出所有的img
      if (!arr || (Array.isArray(arr) &amp;&amp; !arr.length)) {
        return false;
      }

      let srcArr = [];
      for (let i = 0; i &lt; arr.length; i++) {
        let src = arr[i].match(srcReg);
        // 获取图片地址
        srcArr.push(src[1]);
      }

      return srcArr;
    }</code></pre> 
<pre><code class="language-javascript">/** * 从rtf内容中匹配返回图片数据的集合 * @param rtfData * @return Array */ 
    extractImageDataFromRtf(rtfData) { 
        if (!rtfData) 
            { return []; 
        } 
        const regexPictureHeader = /{\\pict[\s\S]+?({\\\*\\blipuid\s?[\da-fA-F]+)[\s}]*/;         
        const regexPicture = new RegExp( "(?:(" + regexPictureHeader.source + "))([\\da-fA-F\\s]+)\\}", "g" ); 
        const images = rtfData.match(regexPicture); 
        const result = []; 
        if (images) { 
            for (const image of images) { 
                let imageType = false; 
                if (image.includes("\\pngblip")) { 
                    imageType = "image/png"; 
                } else if (image.includes("\\jpegblip")) { 
                    imageType = "image/jpeg"; 
                } 
                if (imageType) { 
                    result.push({ hex: image .replace(regexPictureHeader, "") .replace(/[^\da-fA-F]/g, ""), type: imageType, }); 
        } 
        } 
        }
         return result; 
    }</code></pre> 
<pre><code class="language-javascript">/** * 将html内容中img标签的属性值替换 * @param htmlData html内容 * @param imageSrcs html中img的属性src的值的集合 * @param imagesHexSources rtf中图片数据的集合，与html内容中的img标签对应 * @param isBase64Data 是否是Base64的图片数据 * @return String */ replaceImagesFileSourceWithInlineRepresentation( htmlData, imageSrcs, imagesHexSources, isBase64Data = true ) { 
    if (imageSrcs.length === imagesHexSources.length) { 
        for (let i = 0; i &lt; imageSrcs.length; i++) { 
            const newSrc = isBase64Data ? `data:${ imagesHexSources[i].type };base64,${this._convertHexToBase64(imagesHexSources[i].hex)}` : imagesHexSources[i]; htmlData = htmlData.replace(imageSrcs[i], newSrc); 
        } 
    } 
    return htmlData; 
},</code></pre> 
<pre><code class="language-javascript">/** * 十六进制转base64 */ _
convertHexToBase64(hexString) { 
    return btoa( hexString .match(/\w{2}/g) .map((char) =&gt; { return String.fromCharCode(parseInt(char, 16)); }) .join("") ); },</code></pre> 
<p>原理：可以去看看他的文章，不错 (<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fassokoo123%2Farticle%2Fdetails%2F126034566" rel="nofollow" title=" wangEditor 粘贴从 word 复制的带图片内容的最佳实践_ wangeditor粘贴word图片"> wangEditor 粘贴从 word 复制的带图片内容的最佳实践_ wangeditor粘贴word图片</a><a href="https://blog.csdn.net/assokoo123/article/details/126034566" title="https://blog.csdn.net/assokoo123/article/details/126034566">https://blog.csdn.net/assokoo123/article/details/126034566</a><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fassokoo123%2Farticle%2Fdetails%2F126034566" rel="nofollow" title=" wangEditor 粘贴从 word 复制的带图片内容的最佳实践_ wangeditor粘贴word图片"> wangEditor 粘贴从 word 复制的带图片内容的最佳实践_ wangeditor粘贴word图片</a>)</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ac57059ab41c7828e5d7a1b0b74d5224/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux-Docker的基础命令和部署code-server</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/574979af64c8f294a8e43be68c79a9b8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数字电路硬件设计系列（五）之AT89C51/C52最小系统设计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>