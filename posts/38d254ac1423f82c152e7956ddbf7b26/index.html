<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Tencent Shadow—零反射全动态Android插件框架正式开源 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Tencent Shadow—零反射全动态Android插件框架正式开源" />
<meta property="og:description" content="Shadow是一个腾讯自主研发的Android插件框架，主要有以下特点：
Shadow所指的插件是插件的代码完全是一个正常可安装的App代码，无需引用任何Shadow的库。这样的App代码应用了Shadow之后可以免安装运行在另一个App中。
Shadow是一个完全无Hack，甚至零反射实现的Android插件框架。
Shadow是一个全动态实现的插件框架，就是说插件框架的代码跟插件的代码一样都是动态发布的。
Shadow是目前业内唯一的真正能开detectNonSdkApiUsage严格检查模式运行的插件框架。
Shadow主要解决了两个大问题
问题一：Android 9.0开始限制非公开SDK接口访问
Android 9.0出现限制非公开SDK接口访问之后，可以说当时我们已知的所有插件框架实现都或多或少的出现了适配问题。大家的应对方式基本上都是一种对抗的思想，有的去破解限制，有的通过和Google沟通浅灰名单有效期暂时续命。
我们也遇到了这个问题，但是我们没有选择和这个策略进行对抗，我们非常理解Google为什么限制使用非公开SDK接口。所以我们重新Review了插件框架的本质原理和设计缺陷，进而设计了全新的插件框架Shadow。Shadow没有使用任何非公开SDK接口，实现了和原本在用的使用了大量非公开SDK接口的实现一样的功能。
在Shadow的Sample中可以添加这样的代码开启严格检查模式运行，而其他插件框架并不能做到。
StrictMode.VmPolicy.Builder builder = new StrictMode.VmPolicy.Builder();	builder.penaltyDeath();	builder.detectNonSdkApiUsage();	StrictMode.setVmPolicy(builder.build()); 比如，我们看到的一款也宣传未使用非公开SDK接口，支持Android 9.0的插件框架，在它的Sample中开启严格模式运行后，出现了如下Crash信息：
W/.xxx.sampl: Accessing hidden method Landroid/view/View;-&gt;computeFitSystemWindows(Landroid/graphics/Rect;Landroid/graphics/Rect;)Z (light greylist, reflection)	W/System.err: StrictMode VmPolicy violation with POLICY_DEATH; shutting down. 可见，即使它的实现代码中没有出现任何非公开SDK的引用，实际上它依赖的第三方组件内部也使用了非公开SDK接口。
Shadow所支持的功能类型是十分丰富的，Shadow支撑了QQ群视频、Now直播、腾讯即玩等业务比较复杂、访问量巨大的业务，并没有对这些业务的功能做出任何限制。功能细节欢迎持续关注Github上的更新。
问题二：插件框架不完善，其本身的代码需要更新、修复
这是一个在我们长期接触插件框架技术后就意识到的问题。也是我们发现所有已知的插件框架没有解决的问题。我们将它称为全动态插件框架。全动态指的就是除了插件代码之外，插件框架本身的所有逻辑代码也都是动态的。实际上插件框架的代码我们是和插件打包在一起发布的。
这个特性有多重要呢？实际上它比无Hack、零反射实现还要重要！因为有了这个特性之后，就算是我们用了Hack的方案，需要兼容各种手机厂商的系统。我们也不需要等宿主App更新才能解决问题。
实际上，Shadow的这个特性是更早实现的。我们早在2015年就开始大量使用插件技术了。在2016年就实现了这个特性。凭借这个特性不断的动态发布插件框架的代码，去适配各种兼容性问题。在今年更是应用这个特性，在完全不跟宿主版本的前提下，将原本的具有上百个反射Hack调用的旧实现更新为了Shadow无Hack实现。新的Shadow自然也具备这个特性。
这个特性对于新研发的Shadow来说也尤为重要，因为新研发的东西肯定有很多不完善的地方。如果是要打包在宿主里发布的话，那必然要测试的非常小心，还要写大量过设计以满足未来的插件需求。但是，现在Shadow是不需要这样的，Shadow只实现业务眼前所需的功能就可以发布了。
这个特性还有一个好处就是对宿主的增量特别的小。我们的宿主对于业务接入在增量上有极其苛刻的要求。Shadow接入时只使用了15.1KB，160个方法。
而我们已知的其他插件框架对宿主的增量一般在110KB，900个方法到370KB，2300个方法之间。
Shadow为解决所有插件框架问题铺平了道路
我们总结对插件框架发布的版本更新其实只有两种原因：
1. 业务需要新功能
2. 兼容不同的手机系统
Shadow的两大特性正好针对这两类问题，并且一次性的解决了87%的问题。
实现原理
其实实现原理属于一层窗户纸，一捅就破了。重要的在于思路上的转变。以前的插件框架总是想用一些Hack手段去修改系统行为，找到系统的漏洞达到目的。Shadow的原则是不去跟系统对抗。既然只是限制非公开SDK接口访问，而没有限制动态加载代码。那么肯定有办法在不使用非公开SDK接口的前提下实现原来的目的。因为我们插件技术的目的本质上来说还是动态加载代码。
那么一个重要的原则就是，如果一个组件需要安装才能使用，那么就别在没安装的情况下把它交给系统。我们已知的插件框架中，做的最好的也不符合这个原则，所以尽管它的Hook点少，但就是由于它将没有安装的Activity交给系统了，所以后面就不得不做一些Hack的事修补。
所以套一个壳子的方案就非常好。这种思路其他框架很早就有了，但是它们一直想把一个插件Activity套在一个宿主Activity之中，然后想办法实现一个转调关系。如果插件Activity是一个真的Activity，那这个插件就可以正常编译安装运行，对开发插件或者直接上架插件App非常有利。但是由于它是个系统的Activity子类，它就有很多方法不能直接调用，甚至还可能需要避免它的super方法被调用。如果插件Activity不是一个真的Activity，只是一个跟Activity有差不多方法的普通类，这件事就简单多了，只需要让壳子Activity持有它，转调它就行了。但这种插件的代码正常编译成独立App安装运行会比较麻烦，代码中可能会出现很多插件相关的if-else，也不好。
Shadow做了一个非常简单事，通过运用AOP思想，利用字节码编辑工具，在编译期把插件中的所有Activity的父类都改成一个普通类，然后让壳子持有这个普通类型的父类去转调它就不用Hack任何系统实现了。虽然说是非常简单的事，实际上这样修改后还带来一些额外的问题需要解决，比如getActivity()方法返回的也不是Activity了。不过Shadow的实现中都解决了这些问题。
总的来说，Shadow实践的是一个非常著名的理论：
任何软件工程遇到的问题都可以通过增加一个中间层来解决——佚名
具体到每个问题，细节上的原理各不相同，请关注Shadow相关的后续技术分享文章。如果想探究某个功能Shadow能否支持，可以fork项目，然后在Sample里自己写一个用例测试一下。Shadow的工程中的Sample可以直接安装运行，也可以直接以插件方式运行，用来对比插件实现和正常安装时行为是否一致非常方便。如果你的用例Shadow不支持，也欢迎把不支持的用例提一个Pull Request过来，我们可以探讨一下如何实现。
真诚期待开源贡献
Shadow开源的思路是将我们已经实现的功能，最有借鉴价值的代码，分享给大家。我们没有试图实现一个覆盖所有功能的SDK直接给大家用。因为我们自身业务没有在使用的功能，我们实现了也是不可靠的。反过来说，Shadow开源的代码绝大部分代码都是经过了亿级用户线上检验的，是可靠的。由于精力有限，我们的自动化测试用例也还比较少。这些都需要大家共同完善。
Tencent Shadow 正式开源
Github 开源地址：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/38d254ac1423f82c152e7956ddbf7b26/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-19T17:46:27+08:00" />
<meta property="article:modified_time" content="2019-06-19T17:46:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Tencent Shadow—零反射全动态Android插件框架正式开源</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="rich_media_content" id="js_content"> 
 <p style="line-height:1.75em;margin-left:8px;"><span style="letter-spacing:.5px;font-size:15px;">Shadow是一个腾讯自主研发的Android插件框架，主要有以下特点：</span></p> 
 <p><br></p> 
 <ul class="list-paddingleft-2" style="list-style-type:square;margin-left:8px;"><li><p style="line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Shadow所指的插件是插件的代码完全是一个正常可安装的App代码，无需引用任何Shadow的库。这样的App代码应用了Shadow之后可以免安装运行在另一个App中。</span></p></li><li><p style="line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Shadow是一个完全无Hack，甚至零反射实现的Android插件框架。</span></p></li><li><p style="line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Shadow是一个全动态实现的插件框架，就是说插件框架的代码跟插件的代码一样都是动态发布的。</span></p></li><li><p style="line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Shadow是目前业内唯一的真正能开detectNonSdkApiUsage严格检查模式运行的插件框架。<br><br></span></p></li></ul> 
 <p style="font-size:18px;"><span style="color:rgb(68,98,183);"><span style="color:rgb(68,98,183);font-size:18px;">Shadow主要解决了两个大问题</span></span></p> 
 <p style="margin-left:8px;"><br></p> 
 <p><span style="font-family:'-apple-system-font', BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei UI', 'Microsoft YaHei', Arial, sans-serif;text-align:left;font-size:15px;">问题一：Android 9.0开始限制非公开SDK接口访问</span></p> 
 <p style="font-size:16px;margin-left:8px;"><br></p> 
 <p style="line-height:1.75em;margin-left:8px;"><span style="font-size:15px;letter-spacing:.5px;"><span style="font-size:15px;letter-spacing:.5px;">Android 9.0出现限制非公开SDK接口访问之后，可以说当时我们已知的所有插件框架实现都或多或少的出现了适配问题。大家的应对方式基本上都是一种对抗的思想，有的去破解限制，有的通过和Google沟通浅灰名单有效期暂时续命。</span></span></p> 
 <p style="line-height:1.75em;margin-left:8px;"><span style="font-size:15px;letter-spacing:.5px;"><span style="font-size:15px;letter-spacing:.5px;"><br></span></span></p> 
 <p style="line-height:1.75em;margin-left:8px;"><span style="font-size:15px;letter-spacing:.5px;"><span style="font-size:15px;letter-spacing:.5px;"><span style="font-size:15px;letter-spacing:.5px;">我们也遇到了这个问题，但是我们没有选择和这个策略进行对抗，我们非常理解Google为什么限制使用非公开SDK接口。所以我们重新Review了插件框架的本质原理和设计缺陷，进而设计了全新的插件框架Shadow。Shadow没有使用任何非公开SDK接口，实现了和原本在用的使用了大量非公开SDK接口的实现一样的功能。</span></span></span></p> 
 <p style="line-height:1.75em;margin-left:8px;"><span style="font-size:15px;letter-spacing:.5px;"> </span></p> 
 <p style="line-height:1.75em;margin-left:8px;"><span style="font-size:15px;letter-spacing:.5px;">在Shadow的Sample中可以添加这样的代码开启严格检查模式运行，而其他插件框架并不能做到。</span></p> 
 <pre class="code-snippet__fix code-snippet__js"></pre> 
 <pre><code>StrictMode.VmPolicy.Builder builder = new StrictMode.VmPolicy.Builder();	
builder.penaltyDeath();	
builder.detectNonSdkApiUsage();	
StrictMode.setVmPolicy(builder.build());</code></pre> 
 <p style="line-height:1.75em;margin-left:8px;"><span style="font-size:15px;letter-spacing:.5px;">比如，我们看到的一款也宣传未使用非公开SDK接口，支持Android 9.0的插件框架，在它的Sample中开启严格模式运行后，出现了如下Crash信息：</span></p> 
 <pre class="code-snippet__fix code-snippet__js"></pre> 
 <pre><code>W/.xxx.sampl: Accessing hidden method Landroid/view/View;-&gt;computeFitSystemWindows(Landroid/graphics/Rect;Landroid/graphics/Rect;)Z (light greylist, reflection)	
W/System.err: StrictMode VmPolicy violation with POLICY_DEATH; shutting down.</code></pre> 
 <p style="line-height:1.75em;margin-left:8px;"><span style="font-size:15px;letter-spacing:.5px;">可见，即使它的实现代码中没有出现任何非公开SDK的引用，实际上它依赖的第三方组件内部也使用了非公开SDK接口。<br><br></span></p> 
 <p style="line-height:1.75em;margin-left:8px;"><span style="font-size:15px;letter-spacing:.5px;">Shadow所支持的功能类型是十分丰富的，Shadow支撑了QQ群视频、Now直播、腾讯即玩等业务比较复杂、访问量巨大的业务，并没有对这些业务的功能做出任何限制。功能细节欢迎持续关注Github上的更新。<br><br></span></p> 
 <p>问题二：插件框架不完善，其本身的代码需要更新、修复</p> 
 <p style="text-align:left;line-height:1.75em;"><span style="font-family:'-apple-system-font', BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei UI', 'Microsoft YaHei', Arial, sans-serif;font-size:15px;text-align:justify;letter-spacing:.5px;"><br>这是一个在我们长期接触插件框架技术后就意识到的问题。也是我们发现所有已知的插件框架没有解决的问题。我们将它称为全动态插件框架。全动态指的就是除了插件代码之外，插件框架本身的所有逻辑代码也都是动态的。实际上插件框架的代码我们是和插件打包在一起发布的。</span></p> 
 <p style="margin-left:8px;line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;"> </span></p> 
 <p style="margin-left:8px;line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;">这个特性有多重要呢？实际上它比无Hack、零反射实现还要重要！因为有了这个特性之后，就算是我们用了Hack的方案，需要兼容各种手机厂商的系统。我们也不需要等宿主App更新才能解决问题。</span></p> 
 <p style="margin-left:8px;line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;"> </span></p> 
 <p style="margin-left:8px;line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;"><span style="letter-spacing:.5px;font-size:15px;color:rgb(68,68,68);background:#FFFFFF;">实际上，Shadow的这个特性是更早实现的。我们早在2015年就开始大量使用插件技术了。在2016年就实现了这个特性。凭借这个特性不断的动态发布插件框架的代码，去适配各种兼容性问题。在今年更是应用这个特性，在<strong>完全不跟宿主版本的前提下，将原本的具有上百个反射</strong></span><strong><span style="letter-spacing:.5px;font-size:15px;color:rgb(68,68,68);background:#FFFFFF;">Hack</span></strong><strong><span style="letter-spacing:.5px;font-size:15px;color:rgb(68,68,68);background:#FFFFFF;">调用的旧实现更新为了</span></strong><strong><span style="letter-spacing:.5px;font-size:15px;color:rgb(68,68,68);background:#FFFFFF;">Shadow</span></strong><strong><span style="letter-spacing:.5px;font-size:15px;color:rgb(68,68,68);background:#FFFFFF;">无</span></strong><strong><span style="letter-spacing:.5px;font-size:15px;color:rgb(68,68,68);background:#FFFFFF;">Hack</span></strong><strong><span style="letter-spacing:.5px;font-size:15px;color:rgb(68,68,68);background:#FFFFFF;">实现</span></strong><span style="letter-spacing:.5px;font-size:15px;color:rgb(68,68,68);background:#FFFFFF;">。新的Shadow自然也具备这个特性。</span></span></p> 
 <p style="margin-left:8px;line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;"> </span></p> 
 <p style="margin-left:8px;line-height:1.75em;"><span style="color:rgb(68,68,68);background:#FFFFFF;font-size:15px;letter-spacing:.5px;">这个特性对于新研发的Shadow来说也尤为重要，因为新研发的东西肯定有很多不完善的地方。如果是要打包在宿主里发布的话，那必然要测试的非常小心，还要写大量过设计以满足未来的插件需求。但是，现在Shadow是不需要这样的，Shadow只实现业务眼前所需的功能就可以发布了。</span></p> 
 <p style="margin-left:8px;line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;"> </span></p> 
 <p style="margin-left:8px;line-height:1.75em;"><span style="color:rgb(68,68,68);background:#FFFFFF;font-size:15px;letter-spacing:.5px;">这个特性还有一个好处就是对宿主的增量特别的小。我们的宿主对于业务接入在增量上有极其苛刻的要求。Shadow接入时只使用了15.1KB，160个方法。</span></p> 
 <p style="margin-left:8px;line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;">而我们已知的其他插件框架对宿主的增量一般在110KB，900个方法到370KB，2300个方法之间。</span></p> 
 <p style="text-align:center;"><br></p> 
 <p style="text-align:center;"><img class="rich_pages" src="https://images2.imgbox.com/f3/46/nSvsmvpA_o.png" alt="640?wx_fmt=png"></p> 
 <p><br></p> 
 <p><br></p> 
 <p><span style="color:rgb(68,98,183);font-size:18px;">Shadow为解决所有插件框架问题铺平了道路</span></p> 
 <p style="font-size:16px;background:#FFFFFF;line-height:1.75em;margin-left:8px;"><span style="color:rgb(68,68,68);font-size:15px;letter-spacing:.5px;"><br>我们总结对插件框架发布的版本更新其实只有两种原因：</span></p> 
 <p style="font-size:16px;background:#FFFFFF;line-height:1.75em;margin-left:8px;"><span style="color:rgb(68,68,68);font-size:15px;letter-spacing:.5px;">1.<span style="letter-spacing:.5px;color:rgb(68,68,68);font:15px 'Times New Roman';">    </span>业务需要新功能</span></p> 
 <p style="font-size:16px;background:#FFFFFF;line-height:1.75em;margin-left:8px;"><span style="color:rgb(68,68,68);font-size:15px;letter-spacing:.5px;">2.<span style="letter-spacing:.5px;color:rgb(68,68,68);font:15px 'Times New Roman';">    </span>兼容不同的手机系统</span></p> 
 <p style="font-size:16px;text-align:center;line-height:1.75em;margin-left:8px;"><img class="rich_pages" src="https://images2.imgbox.com/98/e2/Hmf1YhpE_o.png" alt="640?wx_fmt=png"></p> 
 <p style="font-size:16px;line-height:1.75em;margin-left:8px;"><span style="font-size:15px;letter-spacing:.5px;">Shadow的两大特性正好针对这两类问题，并且一次性的解决了87%的问题。</span></p> 
 <p style="font-size:16px;"><br></p> 
 <p style="font-size:16px;background:#FFFFFF;line-height:1.75em;margin-left:8px;"><span style="color:rgb(68,68,68);font-size:15px;letter-spacing:.5px;"></span></p> 
 <p><span style="color:rgb(68,98,183);font-size:18px;">实现原理</span></p> 
 <p style="background:#FFFFFF;line-height:1.75em;margin-left:8px;"><span style="color:rgb(68,68,68);font-size:15px;letter-spacing:.5px;"><br>其实实现原理属于一层窗户纸，一捅就破了。重要的在于思路上的转变。以前的插件框架总是想用一些Hack手段去修改系统行为，找到系统的漏洞达到目的。Shadow的原则是不去跟系统对抗。既然只是限制非公开SDK接口访问，而没有限制动态加载代码。那么肯定有办法在不使用非公开SDK接口的前提下实现原来的目的。因为我们插件技术的目的本质上来说还是动态加载代码。</span></p> 
 <p style="background:#FFFFFF;line-height:1.75em;margin-left:8px;"><span style="color:rgb(68,68,68);font-size:15px;letter-spacing:.5px;">那么一个重要的原则就是，如果一个组件需要安装才能使用，那么就别在没安装的情况下把它交给系统。我们已知的插件框架中，做的最好的也不符合这个原则，所以尽管它的Hook点少，但就是由于它将没有安装的Activity交给系统了，所以后面就不得不做一些Hack的事修补。</span></p> 
 <p style="background:#FFFFFF;line-height:1.75em;margin-left:8px;"><span style="color:rgb(68,68,68);font-size:15px;letter-spacing:.5px;">所以套一个壳子的方案就非常好。这种思路其他框架很早就有了，但是它们一直想把一个插件Activity套在一个宿主Activity之中，然后想办法实现一个转调关系。如果插件Activity是一个真的Activity，那这个插件就可以正常编译安装运行，对开发插件或者直接上架插件App非常有利。但是由于它是个系统的Activity子类，它就有很多方法不能直接调用，甚至还可能需要避免它的super方法被调用。如果插件Activity不是一个真的Activity，只是一个跟Activity有差不多方法的普通类，这件事就简单多了，只需要让壳子Activity持有它，转调它就行了。但这种插件的代码正常编译成独立App安装运行会比较麻烦，代码中可能会出现很多插件相关的if-else，也不好。</span></p> 
 <p style="background:#FFFFFF;line-height:1.75em;margin-left:8px;"><span style="color:rgb(68,68,68);font-size:15px;letter-spacing:.5px;">Shadow做了一个非常简单事，通过运用AOP思想，利用字节码编辑工具，在编译期把插件中的所有Activity的父类都改成一个普通类，然后让壳子持有这个普通类型的父类去转调它就不用Hack任何系统实现了。虽然说是非常简单的事，实际上这样修改后还带来一些额外的问题需要解决，比如getActivity()方法返回的也不是Activity了。不过Shadow的实现中都解决了这些问题。</span></p> 
 <p style="background:#FFFFFF;line-height:1.75em;margin-left:8px;"><span style="color:rgb(68,68,68);font-size:15px;letter-spacing:.5px;">总的来说，Shadow实践的是一个非常著名的理论：</span></p> 
 <p><span style="font-size:15px;letter-spacing:.5px;">任何软件工程遇到的问题都可以通过增加一个中间层来解决——佚名</span></p> 
 <p style="background:#FFFFFF;line-height:1.75em;margin-left:8px;"><span style="font-size:15px;color:rgb(68,68,68);letter-spacing:.5px;"><br></span></p> 
 <p style="text-align:center;line-height:1.75em;margin-left:8px;"><img class="rich_pages" src="https://images2.imgbox.com/e6/00/qMVr70MA_o.png" alt="640?wx_fmt=png"></p> 
 <p style="background:#FFFFFF;line-height:1.75em;margin-left:8px;"><span style="color:rgb(68,68,68);font-size:15px;letter-spacing:.5px;">具体到每个问题，细节上的原理各不相同，请关注Shadow相关的后续技术分享文章。如果想探究某个功能Shadow能否支持，可以fork项目，然后在Sample里自己写一个用例测试一下。Shadow的工程中的Sample可以直接安装运行，也可以直接以插件方式运行，用来对比插件实现和正常安装时行为是否一致非常方便。如果你的用例Shadow不支持，也欢迎把不支持的用例提一个Pull Request过来，我们可以探讨一下如何实现。</span></p> 
 <p style="font-size:18px;"><span style="color:#4462b7;">真诚期待开源贡献</span></p> 
 <p style="margin-left:8px;line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;"><br>Shadow开源的思路是将我们已经实现的功能，最有借鉴价值的代码，分享给大家。我们没有试图实现一个覆盖所有功能的SDK直接给大家用。因为我们自身业务没有在使用的功能，我们实现了也是不可靠的。反过来说，Shadow开源的代码绝大部分代码都是经过了亿级用户线上检验的，是可靠的。由于精力有限，我们的自动化测试用例也还比较少。这些都需要大家共同完善。</span><br><br></p> 
 <p style="font-size:16px;min-height:1em;letter-spacing:.544px;text-align:center;"><span style="font-size:15px;letter-spacing:.5px;">Tencent Shadow 正式开源</span></p> 
 <p style="font-size:16px;min-height:1em;letter-spacing:.544px;text-align:center;"><span style="font-size:15px;letter-spacing:.5px;">Github 开源地址：<br></span><span style="font-size:15px;letter-spacing:.5px;text-decoration:underline;">https://github.com/Tencent/Shadow</span></p> 
 <p style="font-size:16px;min-height:1em;letter-spacing:.544px;text-align:center;"><span style="font-size:15px;letter-spacing:.5px;">（点击文末阅读原文直接访问）</span></p> 
 <p style="font-size:16px;min-height:1em;letter-spacing:.544px;text-align:center;"><span style="font-size:15px;letter-spacing:.5px;">请给 <span style="font-size:15px;letter-spacing:.5px;text-align:center;">Shadow</span> 一个 Star !</span></p> 
 <p style="font-size:16px;min-height:1em;letter-spacing:.544px;text-align:center;"><span style="font-size:15px;letter-spacing:.5px;">欢迎提出你的 issue 和 PR！<br><br></span></p> 
 <p style="min-height:1em;letter-spacing:.544px;text-align:center;font-size:15px;"><span style="letter-spacing:.5px;"><span style="font-size:15px;letter-spacing:.5px;text-align:center;">Shadow</span>国内镜像地址：</span></p> 
 <p style="min-height:1em;letter-spacing:.544px;text-align:center;font-size:15px;"><span style="letter-spacing:.5px;text-decoration:underline;">https://git.code.tencent.com/Tencent_Open_Source/Shadow</span></p> 
 <p style="min-height:1em;letter-spacing:.544px;text-align:center;font-size:15px;"><img src="https://images2.imgbox.com/48/67/ECCR2enA_o.png" alt="640?wx_fmt=png"></p> 
 <p style="min-height:1em;letter-spacing:.544px;text-align:center;font-size:15px;"><span style="letter-spacing:.5px;">腾讯工蜂源码系统为开源开发者提供完整、最新的腾讯开源项目国内镜像</span></p> 
 <p style="font-size:16px;"> </p> 
 <p><br></p> 
 <p style="text-align:center;"><img class="rich_pages" src="https://images2.imgbox.com/3b/00/kfzO4lbT_o.png" alt="640?wx_fmt=jpeg"></p> 
 <p><br><br></p> 
 <p style="font-size:16px;margin-left:25px;background:#FFFFFF;"><br></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/775943f9569be7b756a36e129b0170a5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">详解C/C&#43;&#43;中volatile关键字</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6449f45a4272581ff5e8cdc4f4b37ca9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微信公众号开发引入jssdk，分享配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>