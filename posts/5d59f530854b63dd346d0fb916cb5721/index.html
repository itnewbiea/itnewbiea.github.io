<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《Programming in Lua 3》读书笔记(十七) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《Programming in Lua 3》读书笔记(十七)" />
<meta property="og:description" content="日期：2014.7.24
PartⅢ The Standard Libraries
21 The String Library
Lua的string标准库提供了完整的对string型变量进行操作的方法。string库将其操作函数输出为一个叫做string的模块，而从lua的5.1版本开始，也将这些函数输出为string型变量的方法(这里涉及到元表)，因此使用string标准库中的函数有两种方法,这里以upper函数为例：string.upper(s)
21.1 Basic String Functions
string.len(s) 计算s的长度，与#s的结果一样。
string.rep(s,n)/s:rep(n) 返回重复n次的s。如print(string.rep(&#34;a&#34;,5)) -- aaaaa
string.lower(s) 返回s的小写版
string.upper(s) 返回s的大写版
string.sub(s,i,j) /s:sub(i,j) 从s中抽取出从index i至j位的字符。
string.char(s) 、string.byte(s,i) 在字符/数字 之间进行转换。string.char获取0个或多个整数，将每一个数字转换成字符，返回这些字符连接起来的字符串；string.byte(s,i)将字符串s的第i个字符转换成整数，默认i = 1.从lua5.1开始，string.byte接受第三个参数--string.byte(s,i,j)，将字符串s中的第i至j个字符转换成整数，返回值为这些整数
e.g. print(string.char(97)) -- a i = 99; print(string.char(i,i&#43;1,i&#43;2)) -- cde print(string.byte(&#34;a&#34;)) --97 {s:byte(1,-1)} --这将以s中所有的字符转换的整数来创建一个 tablestring.char(table.unpack(t)) --这个相当于上一步的逆向运算 string.format()用来转换string型变量的格式。具体的使用规则与C中的类似。
这里要注意的是，所有对string型的变量进行的操作不会对传进去的参数进行修改，而是会创建一个新的string型变量再返回，如果需要修改原数据，则需要通过赋值来实现。
21.2 Pattern-Matching Functions
模式匹配？？
string标准库中的find，match，gsub(global substitution)，match(global match)函数都是基于模式匹配的？
string.find函数
该函数从给定的string型变量中查找一个待搜索的模式串。组成一个最简单的模式串就是用一个word(单词)，如模式串为&#34;hello&#34;,被查找的字符串&#34;hello world&#34;，该函数将会从中查找hello这个单词。当查到到了，该函数将会返回两个值：匹配到的起始index，和最终index，如果没有查找到将会返回nil：
e.g. s = &#34;hello world&#34; i , j = string." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5d59f530854b63dd346d0fb916cb5721/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-04T11:11:04+08:00" />
<meta property="article:modified_time" content="2019-07-04T11:11:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《Programming in Lua 3》读书笔记(十七)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p><span style="font-size:18px;"><span style="font-family:Arial;">日期：2014.7.24</span><br><span style="font-family:Arial;">PartⅢ The Standard Libraries</span><br><span style="font-family:Arial;">21 The String Library</span><br><br><span style="font-family:Arial;">Lua的string标准库提供了完整的对string型变量进行操作的方法。string库将其操作函数输出为一个叫做string的模块，而从lua的5.1版本开始，也将这些函数输出为string型变量的方法(这里涉及到元表)，因此使用string标准库中的函数有两种方法,这里以upper函数为例：string.upper(s)</span><br><br><span style="font-family:Arial;"><strong>21.1 Basic String Functions</strong></span><br><span style="font-family:Arial;">string.len(s)    计算s的长度，与#s的结果一样。</span><br><span style="font-family:Arial;">string.rep(s,n)/s:rep(n)      返回重复n次的s。如print(string.rep("a",5)) -- aaaaa</span><br><span style="font-family:Arial;">string.lower(s)     返回s的小写版</span><br><span style="font-family:Arial;">string.upper(s)     返回s的大写版</span><br><span style="font-family:Arial;">string.sub(s,i,j) /s:sub(i,j)    从s中抽取出从index i至j位的字符。</span><br><span style="font-family:Arial;">string.char(s)  、string.byte(s,i)   在字符/数字 之间进行转换。string.char获取0个或多个整数，将每一个数字转换成字符，返回这些字符连接起来的字符串；string.byte(s,i)将字符串s的第i个字符转换成整数，默认i = 1.从lua5.1开始，string.byte接受第三个参数--string.byte(s,i,j)，将字符串s中的第i至j个字符转换成整数，返回值为这些整数</span></span></p> 
 <pre><code class="language-plain">e.g.
print(string.char(97))          -- a
i = 99; print(string.char(i,i+1,i+2))     -- cde
print(string.byte("a"))                    --97
{s:byte(1,-1)}     --这将以s中所有的字符转换的整数来创建一个
tablestring.char(table.unpack(t))     --这个相当于上一步的逆向运算</code></pre> 
 <p><br><span style="font-size:18px;"><span style="font-family:Arial;">string.format()用来转换string型变量的格式。具体的使用规则与C中的类似。</span><br><span style="font-family:Arial;">这里要注意的是</span><span style="font-family:Arial;">，所有对string型的变量进行的操作不会对传进去的参数进行修改，而是会创建一个新的string型变量再返回，如果需要修改原数据，则需要通过赋值来实现。</span></span><br><br><br><span style="font-size:18px;"><span style="font-family:Arial;"><strong>21.2 Pattern-Matching Functions</strong></span><br><span style="font-family:Arial;"><strong>模式匹配？？</strong></span><br><span style="font-family:Arial;">string标准库中的find，match，gsub(global substitution)，match(global match)函数都是基于模式匹配的？</span><br><br><span style="font-family:Arial;"><strong>string.find函数</strong></span></span></p> 
 <p><span style="font-size:18px;">该函数从给定的string型变量中查找一个待搜索的模式串。组成一个最简单的模式串就是用一个word(单词)，如模式串为"hello",被查找的字符串"hello world"，该函数将会从中查找hello这个单词。当查到到了，该函数将会返回两个值：匹配到的起始index，和最终index，如果没有查找到将会返回nil：</span></p> 
 <pre><code class="language-plain">e.g.
s = "hello world"
i , j = string.find(s,"hello")     --string的起始index为1
print(i,j)     --1     5
print(string.sub(s,i,j))     --hello 提取s中index 为1至5的字符，组成一个新的字符串返回</code></pre> 
 <p> </p> 
 <p><span style="font-size:18px;">该函数接受第三个可选参数：一个index值用来告诉find函数开始查找的起始位置，默认是1.：</span></p> 
 <pre><code class="language-plain">local t = {}
local i = 0
while true do
     i = string.find(s,"\n",i+1)     --每一次从上一次查找到的位置开始进行新的一次查找
     if i == nil then break end
     t[#t + 1] = i
end</code></pre> 
 <p> </p> 
 <p><br><span style="font-size:18px;"><span style="font-family:Arial;"><strong>string.match函数</strong></span></span></p> 
 <p><span style="font-size:18px;"><span style="font-family:Arial;">该函数也是对给定的string型变量进行查找，但是返回值不是查找到的位置，而是直接将查到到的字符串返回，即</span></span></p> 
 <pre><code class="language-plain">e.g.
print(string.match("hello world","hello"))          --这里将会打印 hello
一个很牛逼很强大的用法是：
e.g.
data = "Today is 17/7/1990"
d = string.match(data,"%d+/%d+/%d+")
print(d)</code></pre> 
 <p><span style="font-size:18px;"><span style="font-family:Arial;">关于传进去的模式串的写法之后会做进一步的解释</span><br><br><br><span style="font-family:Arial;"><strong>string.gsub函数</strong></span><br><span style="font-family:Arial;">该函数强制需要三个参数：源字符串、模式串、替代字符串。使用示例：</span></span></p> 
 <pre><code class="language-plain">e.g.
s = string.gsub("lua is cute","cute","greate")
print(s)
s = string.gsub("all lii","l","x")
print(s)
s = string.gsub("Lua is greate","Sol","Sun")
print(s)
当然有第四个可选参数，用来限制替换的数量
e.g.
--替换一个
s = string.gsub("all lii","l","x",1)
print(s)
--替换两个
s = string.gsub("all lii","l","x",2)
print(s)
该函数也返回第二个值，表示替换的次数
e.g.
s ,i= string.gsub("all lii","l","x")
print(s,i)          --axx xii     3</code></pre> 
 <p> </p> 
 <p><span style="font-family:Arial;font-size:18px;"><strong>string.gmatch函数</strong></span></p> 
 <p><span style="font-size:18px;">该函数返回一个函数迭代遍历所有源字符串里出现的模式串字符。例子：</span></p> 
 <pre><code class="language-plain">words  = {}
for w in string.gmatch(s,"%a+")
     words[#words + 1] = w
end</code></pre> 
 <p><span style="font-family:Arial;font-size:18px;">这个函数会将s内的所有单词存储至words中。这里的模式串"%a+"的意思是表示匹配标准是一个单词(与任何字母配对)</span></p> 
 <p><br><br>  </p> 
 <p><span style="font-size:18px;"><span style="font-family:Arial;"><strong>21.3 Patterns</strong></span></span></p> 
 <p><span style="font-size:18px;">使用字符类可以让模式串发挥出更大的作用。字符类是一种在给定格式下匹配任何字符的模式串。例如%d可以匹配任何的数字，因此假如我们想匹配dd/mm/yyy这种格式，可以写这样的模式串：%d%d/%d%d/%d%d%d</span></p> 
 <pre><code class="language-plain">e.g.
s = "Deadline is 30/05/1999,firm"
data = "%d%d/%d%d/%d%d%d"
print(string.match(s,data))     --30/05/1999</code></pre> 
 <p><span style="font-size:18px;"><span style="font-family:Arial;">一下列出了所有的字符类：</span><br><span style="font-family:Arial;">.                   所有的字符</span><br><span style="font-family:Arial;">%a               字母</span><br><span style="font-family:Arial;">%c               控制字符</span><br><span style="font-family:Arial;">%d               数字</span><br><span style="font-family:Arial;">%g               除空格外所有能打印的字符</span><br><span style="font-family:Arial;">%l                小写字母</span><br><span style="font-family:Arial;">%p               标点符号</span><br><span style="font-family:Arial;">%s               空白字符</span><br><span style="font-family:Arial;">%u               大写字母</span><br><span style="font-family:Arial;">%w               任何字母、数字</span><br><span style="font-family:Arial;">%x               十六进制数</span><br><span style="font-family:Arial;">使用大写就相当于取其补集：%A 相当于匹配所有非字母的</span></span></p> 
 <pre><code class="language-plain">e.g.
print(string.gsub("hello, up-down!","%A","."))     --这里会将所有非字母的字符替换为"."</code></pre> 
 <p><br><span style="font-size:18px;"><span style="font-family:Arial;">还有一些特殊的字符类，作者称之为magic characters：</span><br><span style="font-family:Arial;">()    .     %     +     -     *     ?     []     ^     $</span><br><span style="font-family:Arial;">%相当于对这些magic characters做分隔的分隔符，如：%. 将会匹配"."这个符号，%%将会匹配"%",这个字符不仅可以用来分隔这里提到的magic character，还可以用来分隔任何非字母数字的字符。</span><br><span style="font-family:Arial;">Lua中的模式串跟一般的字符串一致，只是在模式匹配函数中才会发挥出其作用，而且只会以"%"符号作为其escape(分隔符？)</span><br><span style="font-family:Arial;">可以使用char-set技术来创建定制的字符类，使用方法是[ ]进行组合，如[%new_set] 这样就创建了一个新的字符类。[%w_]这个字符类用来匹配任何字母、数字字符和下划线。</span><br><span style="font-family:Arial;">也可以设置一个匹配范围，在第一个和最后一个字符之间使用连接符：[0-7] 此时将会匹配0-7范围内的数值，这里需要使用 "%" 符号。</span><br><span style="font-family:Arial;">另外结合以下几个符号，将会使字符类变得更高效：</span><br><span style="font-family:Arial;">+        一个或多个重复</span><br><span style="font-family:Arial;">*         0个或多个重复</span><br><span style="font-family:Arial;">-         0个或更少的重复</span><br><span style="font-family:Arial;">？       可选匹配(0次或1次匹配)       </span><br><br><span style="font-family:Arial;">使用 "+"将会匹配一个或多个字符。意思是将会取最长的去匹配，如使用"%a+"将会匹配一个单词(匹配最长范围，预空格结束)</span><br><span style="font-family:Arial;">print(string.gsub("one,and two;and three","%a+","word"))     --将会将全部单词替换为word</span></span></p> 
 <p> </p> 
 <p><span style="font-family:Arial;font-size:18px;">"*"的作用与"+"类似，只是这个符号将会接受0次重复的情况，在匹配括号的时候，可能是(),也可能是( )，此时采用"*"便能匹配到空格符0次重复的()情况，%(%s*%)</span></p> 
 <p><br><span style="font-size:18px;">"-"也能匹配到0次重复的情况，但这个符号更多的是做取最短的匹配：字符类为/%*.-%*/",此时将会匹配/**/组合的最短字符组合，如</span></p> 
 <pre><code class="language-plain">e.g.
test = "int x; /* x */ int y; /* y */"
print(string.gsub(test,"/%*.-%*/",""))     --每次匹配的时候取/**/组合的最短串，这样就能将/**/组成的最短字符串替换掉。</code></pre> 
 <pre><code class="language-plain"> </code></pre> 
 <p> </p> 
 <p><span style="font-family:Arial;">"?" 匹配的是可选字符，如想从一个文件中找出一个数字，该数字可选是否带正负号，此时就可以将字符类设计为：[+-]?%d+ 这样正负号就是可选的了。</span><br></p> 
 <p><span style="font-size:18px;">如果一个模式串以"^"开头表示此时只会对源字符串的开头进行匹配，如果以"$"开头，表示只会对源字符串的结尾进行匹配。 </span></p> 
 <pre><code class="language-plain">&lt;span style="font-size:18px;"&gt;e.g.
string.find(s,"^%d")           --检查s是否是以数字开头的&lt;/span&gt;</code></pre> 
 <p> </p> 
 <p><span style="font-size:18px;">"%b",做对称匹配，如"%bxy"，去匹配源字符串是否是以x为开头以y为结尾的部分：</span></p> 
 <pre><code class="language-plain">e.g.
a = "a (enclosed (in) parentheses) line"
print(string.gsub(a,"%b()",""))     --将()包含的部分替换掉。</code></pre> 
 <p> </p> 
 <p><span style="font-size:18px;">"%f[char-set]",所谓的frontier pattern(边界匹配)，该匹配条件是当下一个字符是char-set的而前一个不是的时候匹配一个空的字符串:</span></p> 
 <pre><code class="language-plain">e.g.
s = "the anthem is the theme"
print(s:gsub("%f[%w]the%f[%W]","one"))          --注意这里的两个字符类w和W</code></pre> 
 <p> </p> 
 <p><span style="font-size:18px;"><span style="font-family:Arial;">%f[%w]匹配边界为介于一个非字母数字字符和一个字母数字字符之间；%f[%W]匹配边界为介于一个字母数字字符和一个非字母数字字符之间。感觉被绕晕了，这里一定要注意的是char-set一定要写在[]里面。</span></span></p> 
 <p> </p> 
 <p> </p> 
 <p><span style="font-family:Arial;"><strong>21.4 Captures</strong></span><br><span style="font-family:Arial;">捕获机制是用来允许模式串抽取源字符串的一部分用来匹配当前的模式串，并为下一步使用做准备。语法规则是在模式串中在()里面写要捕获的部分。</span></p> 
 <p><span style="font-size:18px;">当一个模式串里面写了捕获串的时候，string.match函数将会返回每一个捕获到的值，换句话来说就是将源字符串根据捕获串来做分解</span></p> 
 <pre><code class="language-plain">e.g.
pair = "name = Anna"
key,value = string.match(pair,"(%a+)%s*=%s*(%a+)")
print(key,value)</code></pre> 
 <p><span style="font-size:18px;"><span style="font-family:Arial;">这里的模式串"(%a+)%s*=%s*(%a+)"，来稍微分析一番</span><br><span style="font-family:Arial;">(%a+)这里是一个捕获列表，以()括住了要捕获的部分，这里要捕获的是单词(%a+取最长)</span><br><span style="font-family:Arial;">%s*=%s*  这里匹配等于号"="前后所有的空白字符</span><br><span style="font-family:Arial;">(%a+) 再一次捕获单词</span><br><span style="font-family:Arial;">       所以整个模式串匹配的是：一个字母组+空格组+等于号+空格租+一个字母组。</span><br><span style="font-family:Arial;">       而此时match函数返回的是捕获到的值，所以此时返回值是name 和 Anna</span><span style="font-family:Arial;">"([\"'])(.-)"     这个模式串？？</span><br><br><span style="font-family:Arial;">       Lua的模式串格式还是很复杂的，需要多注意！感觉一时半会还不会用啊</span></span><br><br></p> 
 <p><span style="font-size:18px;"><span style="font-family:Arial;">gsub中使用捕获值</span></span></p> 
 <p><span style="font-size:18px;">与模式串一样，gsub中用来替代的字符串也可以包含如"%d"这样的字符类.当替代的字符串创建后这些字符类就会修改各自的捕获值。特别的是，"%0"将会修改所有匹配到的。以下例子中，函数将会以一个连接符分隔复制出源字符串的所有字符：</span></p> 
 <pre><code class="language-plain">e.g.
print(string.gsub("hello Lua!","%a","%0-"))
--打印的是：h-e-l-l-o- L-u-a-!</code></pre> 
 <p><span style="font-size:18px;"><span style="font-family:Arial;">我的理解是，每次匹配一个字符，替代的是其本身加上一个连接符(%0表示匹配到的所有字符，这里的意思就是用匹配到的字符+一个连接符替代捕获到的字符)</span></span></p> 
 <p><span style="font-size:18px;">以上还需要进一步理解</span></p> 
 <p> </p> 
 <pre><code class="language-plain">e.g.
print(string.gsub("hello lua","(.)(.)","%2%1"))
--打印：ehll oula </code></pre> 
 <p><span style="font-size:18px;">我的理解是：两两交换(意思是每次捕获两个任意字符，%2代表的是第二个字符，%1代表的是第一个字符，%2%1表示将捕获到的两个字符，互换位置，所以就实现了两两交换的目的)</span></p> 
 <p> </p> 
 <pre><code class="language-plain">e.g.
s = [[the \quote{tast} is to \em{change} that.]]
s = string.gsub(s,"\\(%a+){(.-)}","&lt;%1&gt;%2&lt;/%1&gt;")
print(s)     --the &lt;quote&gt;tast&lt;/quote&gt; is to &lt;em&gt;change&lt;/em&gt; that.</code></pre> 
 <p><span style="font-size:18px;"><span style="font-family:Arial;">理解一下这个模式串："\\(%a+){(.-)}",这里前面的双\\斜线，第一个是用来控制格式的，如\n表示新一行。之后接一个捕获值列表捕获一个单词，然后是双括号里面加一个捕获列表，捕获最短的任意字符。</span><br><span style="font-family:Arial;">替换串："&lt;%1&gt;%2&lt;/%1&gt;",将捕获到的第一个值，第二个值，分别以格式&lt;xx&gt;yy&lt;/xx&gt;替换到匹配的字符。</span></span></p> 
 <p> </p> 
 <p> </p> 
 <p><span style="font-size:18px;"><span style="font-family:Arial;"><strong>21.5 Replacements</strong></span></span></p> 
 <p><span style="font-size:18px;">我们不仅可以使用字符串作为gsub函数的第三个参数，还可以使用table或者一个函数作为参数类型。当参数是一个函数，那么gsub函数将会在每次匹配到了的时候就调用该函数，捕获到的值将作为函数的参数，而函数的返回值将作为替换字符串。当参数是一个table的时候，gsub函数以捕获到的第一个值作为key来访问table，而该key指向的value则为用来替代的字符串.如果从函数调用或者访问table得到的返回结果是nil，则gsub函数不会替换源字符串的字符。</span></p> 
 <pre><code class="language-plain">e.g.
function expand( s )
     return (string.gsub(s,"$(%w+)",_G))     --从全局变量中寻找捕获到的这个变量的名字，找到了就替换掉，而当没有找到的时候不做任何替换
end
name = "lua";status = "greate"
print(expand("$name is $status,isn't it?"))</code></pre> 
 <p> </p> 
 <p><span style="font-size:18px;">可以使用tostring函数强制将捕获到的值转换为string类型，以用来做替换,保证代码的稳定性。</span></p> 
 <pre><code class="language-plain">e.g.
function expand( s )
     return (string.gsub(s,"$(%w+)",function ( n )
          return tostring(_G[n])
     end))
end
print(expand("print = $print;a = $a"))</code></pre> 
 <p> </p> 
 <p><span style="font-size:18px;">将LaTex格式的文件转换为XML格式，之前已经做了一次实现，在这里则考虑到了嵌套的情况：</span></p> 
 <pre><code class="language-plain">--to xml
function toxml( s )
     s = string.gsub(s,"\\(%a+)(%b{})",function ( tag,body )
          body = string.sub(body,2,-2)     --移除大括号
          body = toxml(body)                    --处理嵌套情况
          return string.format("&lt;%s&gt;%s&lt;/%s&gt;",tag,body,tag)
     end)
     return s
end
LaTex = [[\title{The \bold{big} example}]]
print(toxml(LaTex))</code></pre> 
 <p> </p> 
 <p> </p> 
 <p><span style="font-family:Arial;"><strong>URL encoding</strong></span><br><span style="font-family:Arial;">URL编码：HTTP在URL中用来发送消息的编码。这种编码方式将一些特殊字符(如 '=','&amp;','=')表示为"%xx",xx为16进制中表示的字符，并且将空格转换为'+',例如，a+b = c 将会被表示为:a%2Bb+%3D+c。这种编码方式会将每一个参数名和这个参数的值使用一个等号连接起来，并且将所有的参数名及其值用‘&amp;’连接起来，例如：</span><br><span style="font-family:Arial;">name = "al"; query = "a+b = c"; q = "yes or no"     将会被表示为</span><br><span style="font-family:Arial;">name=al&amp;query=a%2Bb+%3D+c&amp;q=yes+or+no</span><br><span style="font-family:Arial;">注：=的ASCII十进制表示为61，对应的16进制表示为3D</span><br><span style="font-family:Arial;">       +的ASCII十进制表示为43，对应的16进制表示为2B</span><br></p> 
 <p><span style="font-size:18px;">现在假如我们想将这些URL解码并且存储值table中，以其相对应的名字作为index值，以下做具体实现：</span></p> 
 <pre><code class="language-plain">function unescape( s )
     s = string.gsub(s,"+"," ")     --将'+'替换为空格
     s = string.gsub(s,"%%(%x%x)",function ( h )     --将捕获到的16进制数值先转换成10进制数，再将十进制数转换为转换为ASCII字符
          return string.char(tonumber(h,16))
     end)
     return s
end
print(string.char(tonumber("2B",16)))          --这里将16进制表示的字符转换为十进制数</code></pre> 
 <p> </p> 
 <p><span style="font-size:18px;">而对name = value格式进行解码则使用gmatch,因为包括name和value都不能呢个包含字符'&amp;'和'='，所以使用的模式串应该为:'[^&amp;=]+'</span></p> 
 <pre><code class="language-plain">e.g.
--decode pairs-name = value
cgi = {}
function decode( s )
     for name,value in string.gmatch(s,"([^&amp;=]+)=([^&amp;=]+)") do        --当gmatch的模式串里包含捕获值的时候，gmath将会返回每次捕获到的值
          --这里有两个捕获列表，格式都是[^&amp;=]+ 表示匹配所有非&amp;和=格式的最长字符组
          name = unescape(name)
          value = unescape(value)
          cgi[name] = value
     end
end</code></pre> 
 <p> </p> 
 <p><span style="font-size:18px;">做了解码，那么如何编码呢？就是照着URL格式的要求将某系特殊字符进行转换，首先转换特殊字符的编码函数：</span></p> 
 <pre><code class="language-plain">e.g.
--encoding
function escape( s )
     s = string.gsub(s,"[&amp;=+%%%c]",function ( c )     --模式串匹配所有特殊字符
          return string.format("%%%02X",string.byte(c))     --将字符转换成十六进制编码表示
     end)
     s = string.gsub(s," ","+")          --将所有的空格转换为'+'
     return s
end</code></pre> 
 <p> </p> 
 <p><span style="font-size:18px;">然后将table进行转换</span></p> 
 <pre><code class="language-plain">&lt;span style="font-size:18px;"&gt;e.g.
--encode
function encode( t )
     local b = {}
     for k, v in pairs(t) do
          b[#b + 1] = (escape(k) .. "=" .. escape(v))
     end
     return table.concat(b,"&amp;")     --以字符'&amp;'连接所有key-value
end&lt;/span&gt;</code></pre> 
 <p><span style="font-size:18px;"><br></span> </p> 
 <p> <span style="font-size:18px;"><span style="font-family:Arial;"><strong>Tab expansion</strong></span><br><span style="font-family:Arial;">lua中空的捕获值()具有特殊含义，并不是说不做任何捕获，这个模式串捕获的是在源字符串中的位置？</span><br><span style="font-family:Arial;">e.g.</span><br><span style="font-family:Arial;">print(string.match("hello","()ll()"))          -- 3 5</span><br><span style="font-family:Arial;">该结果与使用find得到的结果不同，因为第二个捕获到的是匹配到的位置的下一个，即5，是第二个'l'的下一个位置(第二个l的位置为4)。</span><br></span><span style="font-family:Arial;"><span style="font-size:18px;">一个很好的解释位置捕获的例子是将tab扩展为string？</span></span></p> 
 <pre><code class="language-plain">&lt;span style="font-size:18px;"&gt;e.g.
--expand tab in a string
function expandTabs( s,tab )
     tab = tab or 8     --tab 的大小默认为 8
     local corr = 0
     s = string.gsub(s,"()\t",function ( p )
          local sp = tab - (p -1 + corr)%tab
          corr = corr - 1 + sp
          return string.rep(" ",sp)
     end)
     return s
end&lt;/span&gt;</code></pre> 
 <p> </p> 
 <p><span style="font-family:Arial;font-size:18px;">函数中的gsub函数的模式串将会匹配string型变量中所有的tab键，捕获他们的位置。对于每个tab，替换函数使用这些位置来计算需要为这个tab留出多少空间。最后返回的s就已经计算好了要准备的空格。</span><br></p> 
 <p><span style="font-size:18px;">使用示例：</span></p> 
 <pre><code class="language-plain">print(expandTabs("x\txx\txx"))     --打印出来的值为:x       xx      xx  间隔都是8个</code></pre> 
 <p> </p> 
 <p><span style="font-size:18px;">这个函数的逆向操作，将一些空格转换为tab</span></p> 
 <pre><code class="language-plain">e.g.
function unexpandTabs( s,tab )
     tab = tab or 8
     s = expandTabs(s)
     local pat = string.rep(".",tab)
     s = string.gsub(s,pat,"%0\1")          --将匹配到的tab(8个.)替换为一个标记 \1
     s = string.gsub(s," +\1","\1")          --将多个空格和标记 替换为一个标记(意思应该是某个字符前有多个tab都将替换为一个tab)
     s = string.gsub(s,"\1","")               --最后将这些标记清除
     return s
end
print(unexpandTabs("        x        "))     -- 打印为x</code></pre> 
 <p> </p> 
 <p> </p> 
 <p><span style="font-size:18px;"><span style="font-family:Arial;"><strong>21.6 Tricks of the Trade</strong></span><br><span style="font-family:Arial;">在处理string型变量的时候模式匹配是非常有用的，你可以仅仅使用一个简单的string.gsub函数实现非常多的复杂操作。然而，正是因为这么强大，所以我们更需要小心翼翼。</span><br><span style="font-family:Arial;">写出正确的模式串是非常重要的，这关系到程序运行的效率。</span><br><span style="font-family:Arial;">一个匹配长字符串(有70个字符)的模式串</span></span></p> 
 <pre><code class="language-plain">pattern = string.rep("^[^\n]",70) .. "[^\n]"</code></pre> 
 <p><br><br><br><span style="font-size:18px;"><span style="font-family:Arial;"><strong>21.7 Unicode</strong></span><br><span style="font-family:Arial;">string.reverse、string.byte、string.char、string.upper、string.lower不支持UTF-8编码格式的string型变量</span><br><span style="font-family:Arial;">string.format、string.rep可以支持UTF-8编码格式的string型变量(除了"%c"操作外)，string.len、string.sub同样支持UTF-8编码格式的string型变量。</span><br><span style="font-family:Arial;">在模式匹配函数中，对UTF-8的支持程度决定于模式串的格式，字母组成的模式串是无问题的，字符类和字符组只支持ASCII格式的字符。</span><br><span style="font-family:Arial;">作者指出的一个缺陷：the function to convert between UTF-8 sequences and Unicode code points and to check the validity of UTF-8 string.缺少UTF-8 和 Unicode 格式编码之间的互相转换函数，和检测UTF-8格式字符串正确性的函数。</span></span> </p> 
</div> 
<p>转载于:https://www.cnblogs.com/zhong-dev/p/4044568.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e4cd9f39beb8bb739899ce6f19b2eaa1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">《Programming in Lua 3》读书笔记(三)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f04ba1fe4ecc8587f4e338dbb6c9f7fc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Clang 中 AST 相关类简介（不定时更新）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>