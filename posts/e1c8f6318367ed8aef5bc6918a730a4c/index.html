<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;调用python - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;调用python" />
<meta property="og:description" content="http://blog.csdn.net/pipisorry/article/details/49532341
C&#43;&#43;调用python 在C/C&#43;&#43;中嵌入Python，可以使用Python提供的强大功能，通过嵌入Python可以替代动态链接库形式的接口，这样可以方便地根据需要修改脚本代码，而不用重新编译链接二进制的动态链接库。至少你可以把它当成文本形式的动态链接库，需要的时候还可以改一改，只要不改变接口， C&#43;&#43;的程序一旦编译好了，再改就没那么方便了。
C&#43;&#43;调用Python有两种方式 第一种方式：通过找到Python模块，类，方法，构造参数来调用。
第二中方式，就是通过构造出一个Python的脚本，用python引擎来执行。
第一种方式可能更为优雅，符合大多数的反射调用的特点。（如c#的反射机制，c#调用Com&#43;，c#调用javascript脚本等）。
一个问题：两种语言互相调用的时候，需要做数据结构（如基本类型，字符串，整数类型等，以及自定义的类等类型）间的转换，共享内存中的一个对象。比如，如何将C&#43;&#43;的对象实例传入python中，并在python中使用。c&#43;&#43;和python并不在一个进程中，因此可以使用boost的shared_ptr来实现。Python调用C&#43;&#43;，换句话说就是需要把C&#43;&#43;封装成Python可以“理解”的类型。同理可知C&#43;&#43;怎么去调用Python脚本。
下面这个例子，主要是演示了c&#43;&#43;调用python，可以在c&#43;&#43;中形成一个python脚本，然后利用PyRun_SimpleString调用;并且，构造一个c&#43;&#43;的对象，传入到python中，并在python的脚本中调用其函数。
皮皮blog
VS中编译运行 vs安装配置 安装python3.4，然后配置系统环境变量。
安装Visual Studio2010（注意可以不用安装其它好多东西，只要安装c&#43;&#43;就可以了）。[Visual Studio相关设置]
vs中新建一个win32控制台应用程序，一路确定完成。
VS2010的配置(设置编译环境) 1. c&#43;&#43;调用python需要在vs2010中的cpp文件中加入&lt;Python.h&gt;，这个头文件在python安装目录Python\include下
要成功引入就要把Python.h的头文件目录（如D:\python3.4.2\include放在菜单 &gt; 项目 &gt; 属性 &gt; C/C&#43;&#43; &gt; 常规 &gt; 附加包含目录下（或者右键项目）
2. 还需要一个python34.lib，如果不导入的话，会提示你出现这个文件的缺失。文件在python\libs下，找到此文件之后进入VS2010，菜单 &gt;项目 &gt; 属性 &gt; 配置属性 &gt; VC&#43;&#43;目录 &gt; 库目录，把刚才的绝对路径（如D:\python3.4.2\libs）添加进去，此时变成这样的了：D:\python3.4.2\libs;$(VCInstallDir)lib;$(VCInstallDir)atlmfc\lib;$(WindowsSdkDir)lib;$(FrameworkSDKDir)\lib。这样就可以在VC程序中执行python文件了。
或者把D:\python3.4.2\libs放进项目 &gt; 属性 &gt; 配置属性 &gt; 链接器 &gt; 常规 &gt; 附加库目录中。
Note: 上面的设置是对某个模式生效，如果将运行模式从debug改成了release，要再进去设置，否则设置不成功。
程序编辑 编辑c&#43;&#43;代码
将PythonInvoke.cpp文件改成下面的代码，用于调用python程序helloworld
// PythonInvoke.cpp : 定义控制台应用程序的入口点。
#include &#34;stdafx.h&#34;
#include&lt;Python.h&gt;
void main(){
Py_Initialize(); /*初始化python解释器,告诉编译器要用的python编译器*/" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e1c8f6318367ed8aef5bc6918a730a4c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-10-31T13:35:39+08:00" />
<meta property="article:modified_time" content="2015-10-31T13:35:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;调用python</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>http://<a target="_blank" href="http://blog.csdn.net/pipisorry/article/details/49532341" rel="noopener noreferrer">blog.csdn.net/pipisorry/article/details/49532341</a></p> 
<h2><span style="color:#FF0000;">C++调用python</span></h2> 
<p>在C/C++中嵌入Python，可以使用Python提供的强大功能，通过嵌入Python可以替代动态链接库形式的接口，这样可以方便地根据需要修改脚本代码，而不用重新编译链接二进制的动态链接库。至少你可以把它当成文本形式的动态链接库，需要的时候还可以改一改，只要不改变接口， C++的程序一旦编译好了，再改就没那么方便了。</p> 
<h4><span style="color:#FF0000;">C++调用Python有两种方式</span></h4> 
<p>第一种方式：通过找到Python模块，类，方法，构造参数来调用。</p> 
<p>第二中方式，就是通过构造出一个Python的脚本，用python引擎来执行。</p> 
<p>第一种方式可能更为优雅，符合大多数的反射调用的特点。（如c#的反射机制，c#调用Com+，c#调用javascript脚本等）。<br>一个问题：两种语言互相调用的时候，需要做数据结构（如基本类型，字符串，整数类型等，以及自定义的类等类型）间的转换，共享内存中的一个对象。比如，如何将C++的对象实例传入python中，并在python中使用。c++和python并不在一个进程中，因此可以使用boost的shared_ptr来实现。Python调用C++，换句话说就是需要把C++封装成Python可以“理解”的类型。同理可知C++怎么去调用Python脚本。<br>下面这个例子，主要是演示了c++调用python，可以在c++中形成一个python脚本，然后利用PyRun_SimpleString调用;并且，构造一个c++的对象，传入到python中，并在python的脚本中调用其函数。<br></p> 
<p><a target="_blank" href="http://blog.csdn.net/pipisorry" rel="noopener noreferrer">皮皮blog</a><br></p> 
<p><br></p> 
<h2><span style="color:#FF0000;">VS中编译运行</span></h2> 
<h3><span style="color:#FF0000;">vs安装配置</span></h3> 
<p>安装python3.4，然后配置系统环境变量。</p> 
<p>安装Visual Studio2010（注意可以不用安装其它好多东西，只要安装c++就可以了）。[<span class="link_title"><a target="_blank" href="http://blog.csdn.net/pipisorry/article/details/38687763" rel="noopener noreferrer">Visual Studio相关设置</a></span>]</p> 
<p>vs中新建一个<span style="color:#33CC00;">win32控制台应用程序</span>，一路确定完成。<br></p> 
<h4><span style="color:#FF0000;">VS2010的配置(设置编译环境)</span></h4> 
<p>1. c++调用python需要在vs2010中的cpp文件中加入&lt;Python.h&gt;，这个头文件在python安装目录Python\include下</p> 
<p>要成功引入就要把<span style="color:#33CC00;">Python.h的头文件目录（如D:\python3.4.2\include放在菜单 &gt; 项目 &gt; 属性 &gt; C/C++ &gt; 常规 &gt; 附加包含目录下</span>（或者右键项目）<span style="color:#33CC00;"></span><br></p> 
<p>2. 还需要一个python34.lib，如果不导入的话，会提示你出现这个文件的缺失。文件在python\libs下，找到此文件之后进入VS2010，菜单 &gt;<span style="color:#33CC00;">项目 &gt; 属性 &gt; 配置属性 &gt; VC++目录 &gt; 库目录，把刚才的绝对路径（如D:\python3.4.2\libs）</span>添加进去，此时变成这样的了：D:\python3.4.2\libs;$(VCInstallDir)lib;$(VCInstallDir)atlmfc\lib;$(WindowsSdkDir)lib;$(FrameworkSDKDir)\lib。这样就可以在VC程序中执行python文件了。</p> 
<p>或者把D:\python3.4.2\libs放进<span style="color:#33CC00;">项目 &gt; 属性 &gt; 配置属性 &gt; 链接器 &gt; 常规 &gt; 附加库目录</span>中。<br></p> 
<p><strong>Note</strong>: 上面的设置是对某个模式生效，如果将运行模式从debug改成了release，要再进去设置，否则设置不成功。<br></p> 
<h3><span style="color:#FF0000;">程序编辑</span></h3> 
<h4><span style="color:#FF0000;">编辑c++代码</span><br></h4> 
<p>将PythonInvoke.cpp文件改成下面的代码，用于调用python程序helloworld<br></p> 
<p>// PythonInvoke.cpp : 定义控制台应用程序的入口点。<br>#include "stdafx.h"<br>#include&lt;Python.h&gt;<br><br>void main(){<!-- --><br>    Py_Initialize(); /*初始化python解释器,告诉编译器要用的python编译器*/<br>    PyRun_SimpleString("import helloworld"); /*调用python文件*/<br>    PyRun_SimpleString("helloworld.printHello()");/*调用python文件中的函数*/<br>    Py_Finalize(); /*结束python解释器，释放资源*/<br>    system("pause");<br>}</p> 
<p><strong>Note</strong>: 当python代码有错误时，PyImport_ImportModule函数返回NULL；<br></p> 
<p><strong>另一种调用方式的代码</strong></p> 
<p>#include&lt;Python.h&gt;//前面所做的一切配置都是为了调用这个头文件和相关库<br>#include&lt;iostream&gt;<br>using namespace std;<br>int main(){<!-- --><br><span style="white-space:pre"></span>Py_Initialize();//使用python之前，要调用Py_Initialize();这个函数进行初始化<br><span style="white-space:pre"></span>PyObject * pModule = NULL;//声明变量<br><span style="white-space:pre"></span>PyObject * pFunc = NULL;// 声明变量<br><span style="white-space:pre"></span>pModule =PyImport_ImportModule("helloworld");//这里是要调用的文件名<br><span style="white-space:pre"></span>pFunc= PyObject_GetAttrString(pModule, "Hello");//这里是要调用的函数名<br><span style="white-space:pre"></span>PyEval_CallObject(pFunc, NULL);//调用函数<br><span style="white-space:pre"></span>Py_Finalize();//调用Py_Finalize，这个根Py_Initialize相对应的。<br><span style="white-space:pre"></span>return 0;<br>}<br></p> 
<h4><span style="color:#FF0000;">编辑python代码</span></h4> 
<p>在项目源文件中，添加文件命令为helloworld.py<br></p> 
<p>def printHello():<br>    print("Hello World!")</p> 
<p>.py文件保存在.cpp同目录下</p> 
<p><strong>Note</strong>: 不能将python文件的名字命名为test.py,否则报错，由于test.py是python内置python脚本文件，也就是python有自己的test.py文件，并且其优先级比你的高。。<a target="_blank" href="http://blog.csdn.net/pipisorry" rel="noopener noreferrer"><br></a></p> 
<p><a target="_blank" href="http://blog.csdn.net/pipisorry" rel="noopener noreferrer">皮皮blog</a></p> 
<h3><span style="color:#FF0000;">程序运行</span></h3> 
<p>如果你安装的python是64位的，则vs2010中需要把解决方案平台定位‘X64’的模式下，否则配置不成功。</p> 
<p>报错：<span class="title text_overflow">fatal error LNK1112: 模块计算机类型“X86”与目标计算机类型“x64”冲突。[<a target="_blank" href="http://bbs.csdn.net/topics/340207150" rel="noopener noreferrer"><span class="title text_overflow">fatal error LNK1112</span></a><span class="title text_overflow"></span>]</span><br></p> 
<h4><span style="color:#FF0000;">Release模式下运行</span></h4> 
<p>release模式下运行不用设置太多东西</p> 
<p><strong>修改运行选项<br></strong></p> 
<p><img src="https://images2.imgbox.com/8c/9b/LhRgUydN_o.jpg" alt="" width="278" height="26"></p> 
<p>Debug改为Release</p> 
<p>win32下拉配置，新建x64，一路确定</p> 
<p><img src="https://images2.imgbox.com/5f/09/hAs4IdHM_o.jpg" alt="" width="288" height="28"><br></p> 
<p>注意，执行下面之前要在release模式下再设置一次VS2010的配置<br></p> 
<p><strong>运行<br></strong></p> 
<p><img src="https://images2.imgbox.com/05/6b/GJONI7Oy_o.jpg" alt="" width="446" height="98"></p> 
<p>运行成功！</p> 
<h4><span style="color:#FF0000;">Debug模式下运行</span></h4> 
<p><span style="color:#FF0000;"><strong>1. Debug下，python/libs目录下的python34.lib需要复制并重命名为python34_d.lib的形式</strong></span></p> 
<p>设置：<span style="color:#33CC00;">项目 &gt; 属性 &gt; 配置属性 &gt; 链接器 &gt; 输入 &gt; 附加依赖库 &gt; python34_d.lib</span>。<br></p> 
<p>[<span class="link_title"><a target="_blank" href="http://blog.csdn.net/c_cyoxi/article/details/23969203" rel="noopener noreferrer">源码编译 python 生成 python26_d.lib ； 处理 error c101008d</a></span>]</p> 
<p>为什么会有python34.lib和python34_d.lib的差别就是因为:python_d.lib是 库的调试后形式，当我们以debug模式编译工程时，python就用这个lib文件，但是这个文件是不可用 的。对于这点，最快的办法就是强制要求python在任何情况下都是用非调试版本，就可以了。</p> 
<p><span style="color:#CCCCCC;">就是说，不重命名的解决方法，对python头文件python/include/pyconfig.h进行修改：</span></p> 
<pre><span style="color:#CCCCCC;"><code>#           if defined(_DEBUG)
#               pragma  comment(lib,"python34_d.lib")
#           elif defined(Py_LIMITED_API)
#               pragma comment(lib,"python3.lib")
#           else
#               pragma comment(lib,"python34.lib")
#           endif /* _DEBUG */
</code></span></pre> 
<p></p> 
<p><span style="color:#CCCCCC;">将DEBUG条件下的lib由python34_d.lib改为python34.lib.</span></p> 
<pre><code><span style="color:#CCCCCC;">#           if defined(_DEBUG)
#               pragma  comment(lib,"python34.lib")</span>
</code></pre> 
<p><span style="color:#FF0000;"><strong>2. 64位debug下的方案解决</strong></span><br>右键项目名，点击属性，弹出项目属性页，找到链接器—高级，修改右侧的目标计算机，选择有X64的那个选项。如果没有，则选择编译器Configuration Manager中new，添加amd64等平台，然后工程属性中选择x64。</p> 
<p>这一步好像也不用，只要在运行时选择x64就可以了。见3.运行。<br></p> 
<p><span style="color:#CCCCCC;">Note: 属性 - 链接器 - 命令行 -附加选项:如果里面有"/MACHINE:I386"之类的,要删了。</span></p> 
<p><strong><span style="color:#FF0000;">3. 32位库改成64位库</span></strong></p> 
<p><span style="color:#33CC00;">项目 &gt; 属性 &gt; 配置属性 &gt; Vc++目录&gt; 库目录</span>，这里要将32位库改成64位库，相当重要！</p> 
<p></p> 
<pre><code class="language-cpp"><code><span class="pln">$</span><span class="pun">(</span><span class="typ">VCInstallDir</span><span class="pun">)</span><span class="pln">lib\amd64
$</span><span class="pun">(</span><span class="typ">VCInstallDir</span><span class="pun">)</span><span class="pln">atlmfc\lib\amd64
$</span><span class="pun">(</span><span class="typ">WindowsSdkDir</span><span class="pun">)</span><span class="pln">lib\x</span><span class="lit">64</span></code></code></pre>如：将D:\python3.4.2\libs;$(VCInstallDir)lib;$(VCInstallDir)atlmfc\lib;$(WindowsSdkDir)lib;$(FrameworkSDKDir)\lib 
<br>换成D:\python3.4.2\libs;$(VCInstallDir)lib\amd64;$(VCInstallDir)atlmfc\lib\amd64;$(WindowsSdkDir)lib\x64;$(FrameworkSDKDir)\lib 
<br> 
<p></p> 
<p>没有这样设置会报错：msvcprtd.lib(MSVCP100D.dll) : fatal error LNK1112: module machine type ‘X86’ conflicts with target machine type ‘x64’</p> 
<p>msvcprtd.lib(MSVCP100D.dll) : fatal error LNK1112: 模块计算机类型“X86”与目标计算机类型“x64”冲突</p> 
<p>[<a target="_blank" href="http://dhruba.name/2012/10/18/msvcprtd-libmsvcp100d-dll-fatal-error-lnk1112-module-machine-type-x86-conflicts-with-target-machine-type-x64/" rel="nofollow noopener noreferrer">msvcprtd.lib(MSVCP100D.dll) : fatal error LNK1112: module machine type ‘X86’ conflicts with target machine type ‘x64’</a>]<br></p> 
<p>[<a target="_blank" href="http://stackoverflow.com/questions/16216229/msvcprtd-libmsvcp100d-dll-fatal-error-lnk1112-module-machine-type-x86-con" rel="nofollow noopener noreferrer" class="question-hyperlink">msvcprtd.lib(MSVCP100D.dll) : fatal error LNK1112: module machine type 'X86' conflicts with target machine type 'x64'</a>]</p> 
<p>还有一个cmake类似的问题[<span class="link_title"><a target="_blank" href="http://blog.csdn.net/qtbmp/article/details/7273191" rel="noopener noreferrer">fatal error LNK1112: 模块计算机类型“X86”与目标计算机类型“x64”冲突——我的解决方案</a>]</span><br></p> 
<p><strong>3. 运行：</strong>右键项目名，选择清理解决方案，清理完成之后重新生成解决方案，然后选择X64平台编译器去debug，便可以调试成功。<strong></strong></p> 
<p><img src="https://images2.imgbox.com/3b/0e/mDUChFnJ_o.jpg" alt="" width="282" height="25"></p> 
<p></p> 
<p><img src="https://images2.imgbox.com/5b/00/VGFHoPiy_o.jpg" alt="" width="446" height="98"></p> 
<h4><span style="color:#FF0000;">可能存在的错误<br></span></h4> 
<p><span style="color:#FF0000;"><strong>c++调用python时报错LINK : fatal error LNK1123: 转换到 COFF 期间失败: 文件无效或损坏</strong></span></p> 
<p>这个是由于日志文件引起的，可以将项目\属性\配置属性\清单工具\输入和输出\嵌入清单：原来是“是”，改成“否”。 <br>或者将项目\属性\配置属性\链接器\清单文件\生成清单：原来是“是”，改成“否”。<br>如果仍然无效，判断是否已经安装了VS2012，如果已经安装，需要安装VS2010 sp1补丁。</p> 
<p>[<a target="_blank" href="https://msdn.microsoft.com/zh-cn/library/7dz62kfh.aspx" rel="nofollow noopener noreferrer">链接器工具错误 LNK1123</a>]</p> 
<p>但是如果程序要加写rc，必须带清单才能正常使用。所以这种治标不治本的方法失效了。</p> 
<p><strong>还有一种解决方案：</strong><br></p> 
<p>出现这个问题的原因：可能是因为系统最近多次更新，出现了两个版本的cvtres.exe。而系统变量里将这俩都引用了，编译的时候，不知道用哪个了，导致出错。所以要删掉一个。</p> 
<p>一个在C:\Windows\Microsoft.NET\Framework\v<em id="__mceDel">4.0.30319\</em>cvtres.exe，另一个在你安装VS的软件目录..\Microsoft Visual Studio 10.0\vc\bin\cvtres.exe</p> 
<p>然后右键属性--&gt;详细信息 查看两者版本号，把老的Kill掉，就完了。</p> 
<p>[<a target="_blank" id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/croot/p/3525322.html" rel="nofollow noopener noreferrer">彻底解决 LINK : fatal error LNK1123: 转换到 COFF 期间失败: 文件无效或损坏</a>]</p> 
<p><strong><span style="color:#FF0000;">编译时_RTC_Shutdown和_RTC_InitBase相关错误的解决方法：</span></strong><br></p> 
<p>error LNK2001: 无法解析的外部符号 _RTC_Shutdown;error LNK2001: 无法解析的外部符号 _RTC_InitBase<br></p> 
<p>右键点击项目，修改：属性 &gt; 配置属性 &gt; C/C++ &gt; 代码生成 &gt; 基本运行时检查，将值从“两者(......)”改为“默认值”。</p> 
<p>[<a target="_blank" href="http://blog.csdn.net/huzhenwei/article/details/6394824" rel="noopener noreferrer">编译时_RTC_Shutdown和_RTC_InitBase相关错误的解决方法</a>]<br>LINK : error LNK2001: 无法解析的外部符号 mainCRTStartup<br></p> 
<p><span style="color:#FF0000;"><strong>其它错误<br></strong></span></p> 
<p>error LNK2019: 无法解析的外部符号 __imp_system，该符号在函数 main 中被引用</p> 
<p>原因是system("pause");没有include <br></p> 
<p>[<a target="_blank" id="viewpost1_TitleUrl" href="http://www.cppblog.com/API/archive/2013/04/25/199720.html" rel="nofollow noopener noreferrer">C++调用python配置及编译出现的问题</a>]</p> 
<p><a target="_blank" href="http://blog.csdn.net/pipisorry" rel="noopener noreferrer">皮皮blog</a><br></p> 
<p><br></p> 
<h2><span style="color:#FF0000;">命令行中直接调用执行</span></h2> 
<p>编译选项, 需要手动指定Python 的include 路径， 和链接接路径。<br></p> 
<div> 
 <strong>代码:</strong> 
</div>g++ Python.cpp -o Python-I/usr/include/python2.5 -L/usr/lib/python2.5-lpython2.5 
<p></p> 
<p><a target="_blank" href="http://blog.csdn.net/pipisorry" rel="noopener noreferrer">皮皮blog</a></p> 
<p><br></p> 
<p><br></p> 
<h3><span style="color:#FF0000;">C++调用python带参数传递</span></h3> 
<p>调用Python函数时，参数的传递，就是c++的类型，怎么转换成Python的类型；另外一个问题是，Python函数的返回值，怎么转换成C++中的类型。</p> 
<p>在C程序中用Python脚本传递参数，或者获得Python脚本的返回值，则要使用更多的函数来编写C程序。由于Python有自己的数据类型，因此在C程序中要使用专门的API对相应的数据类型进行操作。</p> 
<h4><span style="color:#FF0000;">常用的函数有以下几种</span></h4> 
<p><strong>1．数字与字符串处理</strong></p> 
<p>在Python/C API中提供了Py_BuildValue()函数对数字和字符串进行转换处理，使之变成Python中相应的数据类型。其函数原型如下所示。</p> 
<p>PyObject* Py_BuildValue( const char *format, ...)</p> 
<p>其参数含义如下。</p> 
<p>·     format：格式化字符串，如表8-1所示。</p> 
<p>Py_BuildValue()函数中剩余的参数即要转换的C语言中的整型、浮点型或者字符串等。其返回值为PyObject型的指针。在C语言中，所有的Python类型都被声明为PyObject型。</p> 
<p> </p> 
<strong>2．列表操作</strong> 
<p>在Python/C API中提供了PyList_New()函数用以创建一个新的Python列表。PyList_New()函数的返回值为所创建的列表。其函数原型如下所示。</p> 
<p>PyObject* PyList_New( Py_ssize_t len)</p> 
<p>其参数含义如下。</p> 
<p>·     len：所创建列表的长度。</p> 
<p>当列表创建以后，可以使用PyList_SetItem()函数向列表中添加项。其函数原型如下所示。</p> 
<p>int PyList_SetItem( PyObject *list, Py_ssize_t index, PyObject *item)</p> 
<p>其参数含义如下。</p> 
<p>·     list：要添加项的列表。</p> 
<p>·     index：所添加项的位置索引。</p> 
<p>·     item：所添加项的值。</p> 
<p>同样可以使用Python/C API中PyList_GetItem()函数来获取列表中某项的值。PyList_GetItem()函数返回项的值。其函数原型如下所示。</p> 
<p>PyObject* PyList_GetItem( PyObject *list, Py_ssize_t index)</p> 
<p>其参数含义如下。</p> 
<p>·     list：要进行操作的列表。</p> 
<p>·     index：项的位置索引。</p> 
<p>Python/C API中提供了与Python中列表操作相对应的函数。例如列表的append方法对应于PyList_Append()函数。列表的sort方法对应于PyList_Sort()函数。列表的reverse方法对应于PyList_Reverse()函数。其函数原型分别如下所示。</p> 
<p>int PyList_Append( PyObject *list, PyObject *item)</p> 
<p>int PyList_Sort( PyObject *list)</p> 
<p>int PyList_Reverse( PyObject *list)</p> 
<p>对于PyList_Append()函数，其参数含义如下。</p> 
<p>·     list：要进行操作的列表。</p> 
<p>·     item：要参加的项。</p> 
<p>对于PyList_Sort()和PyList_Reverse()函数，其参数含义相同。</p> 
<p>·     list：要进行操作的列表。</p> 
<p> </p> 
<strong>3．元组操作</strong> 
<p>在Python/C API中提供了PyTuple_New()函数，用以创建一个新的Python元组。PyTuple_New()函数返回所创建的元组。其函数原型如下所示。</p> 
<p>PyObject* PyTuple_New( Py_ssize_t len)</p> 
<p>其参数含义如下。</p> 
<p>·     len：所创建元组的长度。</p> 
<p>当元组创建以后，可以使用PyTuple_SetItem()函数向元组中添加项。其函数原型如下所示。</p> 
<p>int PyTuple_SetItem( PyObject *p, Py_ssize_t pos, PyObject *o)</p> 
<p>其参数含义如下所示。</p> 
<p>·     p：所进行操作的元组。</p> 
<p>·     pos：所添加项的位置索引。</p> 
<p>·     o：所添加的项值。</p> 
<p>可以使用Python/C API中PyTuple_GetItem()函数来获取元组中某项的值。PyTuple_GetItem()函数返回项的值。其函数原型如下所示。</p> 
<p>PyObject* PyTuple_GetItem( PyObject *p, Py_ssize_t pos)</p> 
<p>其参数含义如下。</p> 
<p>·     p：要进行操作的元组。</p> 
<p>·     pos：项的位置索引。</p> 
<p>当元组创建以后可以使用_PyTuple_Resize()函数重新调整元组的大小。其函数原型如下所示。</p> 
<p>int _PyTuple_Resize( PyObject **p, Py_ssize_t newsize)</p> 
<p>其参数含义如下。</p> 
<p>·     p：指向要进行操作的元组的指针。</p> 
<p>·     newsize：新元组的大小。</p> 
<p> </p> 
<strong>4．字典操作</strong> 
<p>在Python/C API中提供了PyDict_New()函数用以创建一个新的字典。PyDict_New()函数返回所创建的字典。其函数原型如下所示。</p> 
<p>PyObject* PyDict_New()</p> 
<p>当字典创建后，可以使用PyDict_SetItem()函数和PyDict_SetItemString()函数向字典中添加项。其函数原型分别如下所示。</p> 
<p>int PyDict_SetItem( PyObject *p, PyObject *key, PyObject *val)</p> 
<p>int PyDict_SetItemString( PyObject *p, const char *key, PyObject *val)</p> 
<p>其参数含义如下。</p> 
<p>·     p：要进行操作的字典。</p> 
<p>·     key：添加项的关键字，对于PyDict_SetItem()函数其为PyObject型，对于PyDict_SetItemString()函数其为char型。</p> 
<p>·     val：添加项的值。</p> 
<p>使用Python/C API中的PyDict_GetItem()函数和PyDict_GetItemString()函数来获取字典中某项的值。它们都返回项的值。其函数原型分别如下所示。</p> 
<p>PyObject* PyDict_GetItem( PyObject *p, PyObject *key)</p> 
<p>PyObject* PyDict_GetItemString( PyObject *p, const char *key)</p> 
<p>其参数含义如下。</p> 
<p>·     p：要进行操作的字典。</p> 
<p>·     key：添加项的关键字，对于PyDict_GetItem()函数其为PyObject型，对于PyDict_GetItemString()函数其为char型。</p> 
<p>使用Python/C API中的PyDict_DelItem()函数和PyDict_DelItemString()函数可以删除字典中的某一项。其函数原型如下所示。</p> 
<p>int PyDict_DelItem( PyObject *p, PyObject *key)</p> 
<p>int PyDict_DelItemString( PyObject *p, char *key)</p> 
<p>其参数含义如下。</p> 
<p>·     p：要进行操作的字典。</p> 
<p>·     key：添加项的关键字，对于PyDict_DelItem()函数其为PyObject型，对于PyDict_DelItemString()函数其为char型。</p> 
<p>使用Python/C API中的PyDict_Next()函数可以对字典进行遍历。其函数原型如下所示。</p> 
<p>int PyDict_Next( PyObject *p, Py_ssize_t *ppos, PyObject **pkey, PyObject **pvalue)</p> 
<p>其参数含义如下。</p> 
<p>·     p：要进行遍历的字典。</p> 
<p>·     ppos：字典中项的位置，应该被初始化为0。</p> 
<p>·     pkey：返回字典的关键字。</p> 
<p>·     pvalue：返回字典的值。</p> 
<p>在Python/C API中提供了与Python中字典操作相对应的函数。例如字典的item方法对应于PyDict_Items()函数。字典的keys方法对应于PyDict_Keys()函数。字典的values方法对应于PyDict_Values()函数。其函数原型分别如下所示。</p> 
<p>PyObject* PyDict_Items( PyObject *p)</p> 
<p>PyObject* PyDict_Keys( PyObject *p)</p> 
<p>PyObject* PyDict_Values( PyObject *p)</p> 
<p>其参数含义如下。</p> 
<p>·     p：要进行操作的字典。</p> 
<p> </p> 
<strong>5．释放资源</strong> 
<p>Python使用引用计数机制对内存进行管理，实现自动垃圾回收。在C/C++中使用Python对象时，应正确地处理引用计数，否则容易导致内存泄漏。在Python/C API中提供了Py_CLEAR()、Py_DECREF()等宏来对引用计数进行操作。</p> 
<p>当使用Python/C API中的函数创建列表、元组、字典等后，就在内存中生成了这些对象的引用计数。在对其完成操作后应该使用Py_CLEAR()、Py_DECREF()等宏来销毁这些对象。其原型分别如下所示。</p> 
<p>void Py_CLEAR( PyObject *o)</p> 
<p>void Py_DECREF( PyObject *o)</p> 
<p>其参数含义如下。</p> 
<p>·     o：要进行操作的对象。</p> 
<p>对于Py_CLEAR()其参数可以为NULL指针，此时，Py_CLEAR()不进行任何操作。而对于Py_DECREF()其参数不能为NULL指针，否则将导致错误。</p> 
<p> </p> 
<strong>6．模块与函数</strong> 
<p>使用Python/C API中的PyImport_Import()函数可以在C程序中导入Python模块。PyImport_Import()函数返回一个模块对象。其函数原型如下所示。</p> 
<p>PyObject* PyImport_Import( PyObject *name)</p> 
<p>其参数含义如下。</p> 
<p>·     name：要导入的模块名。</p> 
<p>使用Python/C API中的PyObject_CallObject()函数和PyObject_CallFunction()函数，可以在C程序中调用Python中的函数。其参数原型分别如下所示。</p> 
<p>PyObject* PyObject_CallObject( PyObject *callable_object, PyObject *args)</p> 
<p>PyObject* PyObject_CallFunction( PyObject *callable, char *format, ...)</p> 
<p>对于PyObject_CallObject()函数，其参数含义如下。</p> 
<p>·     callable_object：要调用的函数对象。</p> 
<p>·     args：元组形式的参数列表。</p> 
<p>对于PyObject_CallFunction()函数，其参数含义如下。</p> 
<p>·     callable_object：要调用的函数对象。</p> 
<p>·     format：指定参数的类型。</p> 
<p>·     ...：向函数传递的参数。</p> 
<p>使用Python/C API中的PyModule_GetDict()函数可以获得Python模块中的函数列表。PyModule_GetDict()函数返回一个字典。字典中的关键字为函数名，值为函数的调用地址。其函数原型如下所示。</p> 
<p>PyObject* PyModule_GetDict( PyObject *module)</p> 
<p>其参数含义如下。</p> 
<p>·     module：已导入的模块对象。</p>8.2.3 在C中嵌入Python实例 
<p>在VC++ 6.0中新建一个名为“EmbPython”的空“Win32 Console Application”工程。向其添加如下所示的“EmbPython.c”文件。</p> 
<p> </p> 
<p>程序输出如下所示。</p> 
<p>-==在C中嵌入Python==-</p> 
<p>使用Python中的sum函数求解下列数之和</p> 
<p>0       1       2       3       4</p> 
<p>Using Function sum</p> 
<p>The result is: 10</p> 
<p>使用Python中的函数分割以下字符串:</p> 
<p>this is an example</p> 
<p>结果如下所示:</p> 
<p>this</p> 
<p>is</p> 
<p>an</p> 
<p>example</p> 
<p>按回车键退出程序</p> 
<p>[<a target="_blank" id="cb_post_title_url" href="http://www.cnblogs.com/lvpengms/archive/2010/02/03/1663071.html" rel="nofollow noopener noreferrer">Python嵌入C/C++ (Python核心编程)</a>]<br></p> 
<p></p> 
<h4>C++转换成Python类型，Py_BuildValue()</h4> 
<p><a target="_blank" href="http://www.python.org/doc/1.5.2p2/ext/buildValue.html" rel="nofollow noopener noreferrer">http://www.python.org/doc/1.5.2p2/ext/buildValue.html</a></p> 
<div class="highlighter dp-highlighter"> 
 <ol class="highlighter-py"><li>PyObject* pArgs=PyTuple_New(<span class="number">1</span>); //有几个参数，就是几</li><li class="alt">PyTuple_SetItem(pArgs,<span class="number">0</span>,Py_BuildValue(<span class="string">"i"</span>,<span class="number">3</span>));  //初始第一个参数，数据类型是i，就是int，值是<span class="number">3</span></li></ol> 
</div>返回值转换如，PyArg_ParseTuple[ 
<a target="_blank" href="https://docs.python.org/3/c-api/arg.html?highlight=parsetuple#c.PyArg_ParseTuple" rel="nofollow noopener noreferrer"><tt class="descname">PyArg_<span class="highlighted">ParseTuple</span></tt></a>] 
<p></p> 
<p><a target="_blank" href="http://blog.csdn.net/pipisorry" rel="noopener noreferrer">皮皮blog</a><br></p> 
<p><br></p> 
<h2><span style="color:#FF0000;">python调用c++问题</span></h2> 
<p>“如果没有参数从python到C++, 是正常的，但是有参数就废了报错”。我尝试实现并找到答案。<br>http://stackoverflow.com/questions/145270/calling-c-c-from-python<br>1. 无参数 函数声明C可用函数 <br>2. 有参数 那么实用SWIG  也就是我们需要一个接口文件 即<br><br>z.i file<br>%｛<br>#include "z.h"<br>extern 函数名(参数1， 参数2，...);<br>%｝<br>SWIG在不同语言互相调用发挥很重要的作用。</p> 
<p><br></p> 
<h2><span style="color:#FF0000;">相关话题</span></h2> 
<p>SWIG<br>有一个外部工具叫SWIG，是Simplified Wrapper and Interface Generator 的缩写。其作者为David Beazley，同时也是Python Essential Referenc 一书的作者。这个工具可以根据特别注释过的C/C++头文件生成能给Python，Tcl 和Perl 使用的包装代码。使用SWIG 可以省去你写前面所说的样板代码的时间。你只要关心怎么用C/C++解决你的实际问题就好了。你所要做的就是按SWIG 的格式编写文件，其余的就都由SWIG 来完成。你可以通过下面的网址找到关于SWIG 的更多信息。<br>http://swig.org<br>Pyrex<br>创建C/C++扩展的一个很明显的坏处是你必须要写C/C++代码。你能利用它们的优点，但更重要的是，你也会碰到它们的缺点。Pyrex 可以让你只取扩展的优点，而完全没有后顾之忧。它是一种更偏向Python 的C 语言和Python 语言的混合语言。事实上，Pyrex 的官方网站上就说“Pyrex 是具有C 数据类型的Python“。你只要用Pyrex 的语法写代码，然后运行Pyrex 编译器去编译源代码。Pyrex会生成相应的C 代码，这些代码可以被编译成普通的扩展。你可以在它的官方网站下载到Pyrex：<br>http://cosc.canterbury.ac.nz/~greg/python/Pyrex<br>Psyco<br>Pyrex 免去了我们再去写纯C 代码的麻烦。不过，你要去学会它的那一套与众不同的语法。最后，你的Pyrex 代码还是会被转成C 的代码。无论你用C/C++，C/C++加上SWIG，还是Pyrex，都是因为你想要加快你的程序的速度。如果你可以在不改动你的Python 代码的同时，又能获得速度的提升，那该多好啊。<br>Psyco 的理念与其它的方法截然不同。与其改成C 的代码，为何不让你已有的Python 代码<br>运行的更快一些呢？Psyco 是一个just-in-time(JIT)编译器，它能在运行时自动把字节码转为本地代码运行。所以，<br>你只要（在运行时）导入Psyco 模块，然后告诉它要开始优化代码就可以了。而不用修改自己的代<br>码。Psyco 也可以检查你代码各个部分的运行时间，以找出瓶颈所在。你甚至可以打开日志功能，来<br>查看Psyco 在优化你的代码的时候，都做了些什么。你可以访问以下网站获取更多的信息：<br>http://psyco.sf.net<br>嵌入<br>嵌入是Python 的另一功能。与把C 代码包装到Python 中的扩展相对的，嵌入是把Python 解释器包装到C 的程序中。这样做可以给大型的，单一的，要求严格的，私有的并且（或者）极其重要的应用程序内嵌Python 解释器的能力。一旦内嵌了Python，世界完全不一样了。<br>Python 提供了很多官方文档供写扩展的人参考：<br>扩展与嵌入<br>http://docs.python.org/ext<br>Python/C API<br>http://docs.python.org/api<br>分发Python 模块<br>http://docs.python.org/dist</p> 
<p>[python核心编程2e.d. - 扩展Python]<br></p> 
<p>from:<a target="_blank" href="http://blog.csdn.net/pipisorry/article/details/49532341" rel="noopener noreferrer">http://blog.csdn.net/pipisorry/article/details/49532341</a><br></p> 
<p>ref:python doc:<a target="_blank" href="https://docs.python.org/3/c-api/index.html#c-api-index" rel="nofollow noopener noreferrer">Python/C API Reference Manual</a></p> 
<p>python doc: <a target="_blank" href="https://docs.python.org/3/extending/embedding.html?highlight=extending%20embedding" rel="nofollow noopener noreferrer"><span class="highlighted">Embedding</span> Python in Another Application</a></p> 
<p><a target="_blank" href="http://blog.sina.com.cn/s/blog_5eb8ebcb0100skpv.html" rel="nofollow noopener noreferrer">C++中调用Python脚本</a><span class="link_title"><a target="_blank" href="http://blog.csdn.net/marising/article/details/2917892" rel="noopener noreferrer"><br></a></span></p> 
<p><span class="link_title"><a target="_blank" href="http://blog.csdn.net/marising/article/details/2917892" rel="noopener noreferrer">C++调用Python</a></span><a target="_blank" id="cb_post_title_url" href="http://www.cnblogs.com/Hisin/archive/2012/02/27/2370590.html" rel="nofollow noopener noreferrer"><br></a></p> 
<p><a target="_blank" id="cb_post_title_url" href="http://www.cnblogs.com/Hisin/archive/2012/02/27/2370590.html" rel="nofollow noopener noreferrer">C++调Python示例</a><span class="link_title"><a target="_blank" href="http://blog.csdn.net/haimengao/article/details/16867547" rel="noopener noreferrer"><br></a></span></p> 
<p><span class="link_title"><a target="_blank" href="http://blog.csdn.net/haimengao/article/details/16867547" rel="noopener noreferrer">在VS2012中C++嵌入python</a></span></p> 
<p>[<a target="_blank" href="https://www.zhihu.com/question/23003213" rel="nofollow noopener noreferrer">如何实现 C/C++ 与 Python 的通信？</a>]*</p> 
<p>[<a target="_blank" href="https://mp.weixin.qq.com/s?__biz=MjM5NzU0MzU0Nw==&amp;mid=2651374546&amp;idx=1&amp;sn=46e90433452af2f92f93f8de61cc89e7&amp;chksm=bd2408c68a5381d0bc9ee6b60eb2eeb4086a4c29caafa052124b4ad9cc72126853ee748fbddb&amp;mpshare=1&amp;scene=1&amp;srcid=0513y5wGUp3mrDvmtlilJPtK&amp;pass_ticket=bzn6UxMwaOkol54oseNBtD4Uj2%2FzkNmt3nMO%2F2r9rxHQGNr32rMk6xt0tl%2BSR8eB#rd" rel="nofollow noopener noreferrer">Google开发了一个框架让C++和Python交互更容易</a>]让开发者为C++程序生成Python的接口包装器</p> 
<p><br></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bcc241de173a5b88747ceec8ff2e6571/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Windows命令行查看文件的MD5</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7e7522f7e5483a43b03045b199c129d1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言中对结构体赋初值</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>