<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue--ssr - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue--ssr" />
<meta property="og:description" content="目录
一、 什么是服务器端渲染？
1.1 初始化项目
1.2 服务端渲染小案例
1.3 右键查看源代码
二、什么是客户端渲染？
2.1 初始化项目
2.2 查看源代码
三、客户端渲染vs服务端渲染
3.1 运行架构对比
3.2 开发模式对比
四、vue框架中的服务端渲染
4.1 初始化项目
4.2 vue服务端渲染最小demo
4.3 遗留问题
五、理解同构理念
六、Nuxt.js框架使用
6.1. 使用nuxt.js创建一个ssr项目
6.2 启动项目
6.3 查看源代码
6.4 搭建首页
6.5 异步数据获取
七、总结
7.1 服务端渲染和客户端渲染各自指什么？有什么特点？
7.2 同构的本质是什么？
7.3 Nuxt.js中如何实现异步数据获取（asyncData方法）？
一、 什么是服务器端渲染？ server side render 前端页面的产生是由服务器端生成的，我们就称之为服务端渲染
1.1 初始化项目 首先，在 ssr 根目录下新建 server 文件夹
其次，在 server 文件夹里通过 npm init -y 命令初始化一个 node 项目
然后，通过 npm install express --save 命令安装 express 框架（express官方文档）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/619d6ea15a471b1ee739ae8fc86e59b4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-26T12:47:36+08:00" />
<meta property="article:modified_time" content="2022-01-26T12:47:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue--ssr</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%9F" rel="nofollow">一、 什么是服务器端渲染？</a></p> 
<p id="1.1%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE-toc" style="margin-left:80px;"><a href="#1.1%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE" rel="nofollow">1.1 初始化项目</a></p> 
<p id="1.2%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%B0%8F%E6%A1%88%E4%BE%8B-toc" style="margin-left:80px;"><a href="#1.2%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%B0%8F%E6%A1%88%E4%BE%8B" rel="nofollow">1.2 服务端渲染小案例</a></p> 
<p id="1.3%20%E5%8F%B3%E9%94%AE%E6%9F%A5%E7%9C%8B%E6%BA%90%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#1.3%20%E5%8F%B3%E9%94%AE%E6%9F%A5%E7%9C%8B%E6%BA%90%E4%BB%A3%E7%A0%81" rel="nofollow">1.3 右键查看源代码</a></p> 
<p id="%E4%BA%8C%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%9F" rel="nofollow">二、什么是客户端渲染？</a></p> 
<p id="2.1%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE-toc" style="margin-left:80px;"><a href="#2.1%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE" rel="nofollow">2.1 初始化项目</a></p> 
<p id="2.2%20%E6%9F%A5%E7%9C%8B%E6%BA%90%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#2.2%20%E6%9F%A5%E7%9C%8B%E6%BA%90%E4%BB%A3%E7%A0%81" rel="nofollow">2.2 查看源代码</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93vs%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93vs%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93" rel="nofollow">三、客户端渲染vs服务端渲染</a></p> 
<p id="3.1%20%E8%BF%90%E8%A1%8C%E6%9E%B6%E6%9E%84%E5%AF%B9%E6%AF%94-toc" style="margin-left:80px;"><a href="#3.1%20%E8%BF%90%E8%A1%8C%E6%9E%B6%E6%9E%84%E5%AF%B9%E6%AF%94" rel="nofollow">3.1 运行架构对比</a></p> 
<p id="3.2%20%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94-toc" style="margin-left:80px;"><a href="#3.2%20%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94" rel="nofollow">3.2 开发模式对比</a></p> 
<p id="%E5%9B%9B%E3%80%81vue%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81vue%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93" rel="nofollow">四、vue框架中的服务端渲染</a></p> 
<p id="4.1%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE-toc" style="margin-left:80px;"><a href="#4.1%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE" rel="nofollow">4.1 初始化项目</a></p> 
<p id="4.2%20vue%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%9C%80%E5%B0%8Fdemo-toc" style="margin-left:80px;"><a href="#4.2%20vue%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%9C%80%E5%B0%8Fdemo" rel="nofollow">4.2 vue服务端渲染最小demo</a></p> 
<p id="4.3%20%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#4.3%20%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98" rel="nofollow">4.3 遗留问题</a></p> 
<p id="%E4%BA%94%E3%80%81%E7%90%86%E8%A7%A3%E5%90%8C%E6%9E%84%E7%90%86%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81%E7%90%86%E8%A7%A3%E5%90%8C%E6%9E%84%E7%90%86%E5%BF%B5" rel="nofollow">五、理解同构理念</a></p> 
<p id="%E5%85%AD%E3%80%81Nuxt.js%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E5%85%AD%E3%80%81Nuxt.js%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8" rel="nofollow">六、Nuxt.js框架使用</a></p> 
<p id="6.1.%20%E4%BD%BF%E7%94%A8nuxt.js%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAssr%E9%A1%B9%E7%9B%AE-toc" style="margin-left:80px;"><a href="#6.1.%20%E4%BD%BF%E7%94%A8nuxt.js%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAssr%E9%A1%B9%E7%9B%AE" rel="nofollow">6.1. 使用nuxt.js创建一个ssr项目</a></p> 
<p id="6.2%20%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE-toc" style="margin-left:80px;"><a href="#6.2%20%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE" rel="nofollow">6.2 启动项目</a></p> 
<p id="6.3%20%E6%9F%A5%E7%9C%8B%E6%BA%90%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#6.3%20%E6%9F%A5%E7%9C%8B%E6%BA%90%E4%BB%A3%E7%A0%81" rel="nofollow">6.3 查看源代码</a></p> 
<p id="6.4%20%E6%90%AD%E5%BB%BA%E9%A6%96%E9%A1%B5-toc" style="margin-left:80px;"><a href="#6.4%20%E6%90%AD%E5%BB%BA%E9%A6%96%E9%A1%B5" rel="nofollow">6.4 搭建首页</a></p> 
<p id="6.5%20%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96-toc" style="margin-left:80px;"><a href="#6.5%20%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96" rel="nofollow">6.5 异步数据获取</a></p> 
<p id="%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">七、总结</a></p> 
<p id="7.1%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%90%84%E8%87%AA%E6%8C%87%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F-toc" style="margin-left:80px;"><a href="#7.1%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%90%84%E8%87%AA%E6%8C%87%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F" rel="nofollow">7.1 服务端渲染和客户端渲染各自指什么？有什么特点？</a></p> 
<p id="7.2%20%E5%90%8C%E6%9E%84%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:80px;"><a href="#7.2%20%E5%90%8C%E6%9E%84%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">7.2 同构的本质是什么？</a></p> 
<p id="7.3%20Nuxt.js%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%88asyncData%E6%96%B9%E6%B3%95%EF%BC%89%EF%BC%9F-toc" style="margin-left:80px;"><a href="#7.3%20Nuxt.js%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%88asyncData%E6%96%B9%E6%B3%95%EF%BC%89%EF%BC%9F" rel="nofollow">7.3 Nuxt.js中如何实现异步数据获取（asyncData方法）？</a></p> 
<p></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E4%B8%80%E3%80%81%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%9F">一、 什么是服务器端渲染？</h3> 
<blockquote> 
 <p>server side render 前端页面的产生是由服务器端生成的，我们就称之为服务端渲染</p> 
</blockquote> 
<h4 id="1.1%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE">1.1 初始化项目</h4> 
<p>首先，在 ssr 根目录下新建 server 文件夹</p> 
<p>其次，在 server 文件夹里通过 npm init -y 命令初始化一个 node 项目</p> 
<p>然后，通过 npm install express --save 命令安装 express 框架（<a class="link-info" href="https://gitee.com/link?target=https%3A%2F%2Fwww.expressjs.com.cn%2F" rel="nofollow" title="express官方文档">express官方文档</a>）</p> 
<p>最后，在项目根目录下新建 app.js 文件，作为服务端的入口文件</p> 
<pre></pre> 
<h4 id="1.2%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%B0%8F%E6%A1%88%E4%BE%8B">1.2 服务端渲染小案例</h4> 
<p><code>app.js</code></p> 
<pre><code class="language-javascript">const express = require('express')
const app = express()
const port = 3000
// 当路径为跟路径,返回完整的html片段
app.get('/', (req, res) =&gt; res.send(`
    &lt;html&gt;
      &lt;body&gt;
        &lt;h1&gt;hi,hello&lt;/h1&gt;
      &lt;/body&gt;
    &lt;/html&gt;
`))

app.listen(port, () =&gt; console.log(`Example app listening on port ${port}!`))</code></pre> 
<p>在项目根目录下打开终端，通过  node app.js 运行服务器</p> 
<pre></pre> 
<p><code>在浏览器里输入，http://localhost:3000 查看效果，如下：</code></p> 
<p><img alt="" height="145" src="https://images2.imgbox.com/21/02/4r6qwAPB_o.png" width="493"></p> 
<p></p> 
<h4 id="1.3%20%E5%8F%B3%E9%94%AE%E6%9F%A5%E7%9C%8B%E6%BA%90%E4%BB%A3%E7%A0%81">1.3 右键查看源代码</h4> 
<p><img alt="" height="224" src="https://images2.imgbox.com/9a/a2/IkI5lz94_o.png" width="780"></p> 
<p><strong>总结：</strong>所谓的服务端渲染指的是页面的内容完全是由服务端侧决定到底要展示出什么内容</p> 
<p></p> 
<hr> 
<p></p> 
<h3 id="%E4%BA%8C%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%9F">二、什么是客户端渲染？</h3> 
<blockquote> 
 <p>client side render 服务端只提供json格式的数据，渲染成什么样子由客户端通过js控制</p> 
</blockquote> 
<p>通过vite快速创建一个基于vue框架的客户端渲染样例</p> 
<h4 id="2.1%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE">2.1 初始化项目</h4> 
<pre>首先，在 ssr 目录下新建 client 文件夹</pre> 
<blockquote> 
 <p>我们使用vite工具快速生成一个vue项目，<a href="https://gitee.com/link?target=https%3A%2F%2Fvitejs.dev%2F" rel="nofollow" title="https://vitejs.dev/">https://vitejs.dev/</a></p> 
</blockquote> 
<p>其次，通过 npm init @vitejs/app my-vue-app --template vue 命令（npm 6.x）快速创建一个基于 vite 的 名为 my-vue-app 的 vue 项目</p> 
<p>若出现如下即表示项目创建成功：</p> 
<p><img alt="" height="107" src="https://images2.imgbox.com/df/fc/wPRoKh4P_o.png" width="330"></p> 
<p>最后，利用cmd命令通过 npm run dev 启动项目</p> 
<p><strong>注意</strong>：此时可能会出现---&gt; 'vite' 不是内部或外部命令，也不是可运行的程序<br> 或批处理文件。若出现以上提示，那么只需输入 npm install 后，再通过 npm run dev 即可启动项目</p> 
<p><code>http://localhost:3000</code></p> 
<p style="text-align:center;"><img alt="" height="232" src="https://images2.imgbox.com/16/5d/xf9mUGJ8_o.png" width="468"></p> 
<p></p> 
<h4 id="2.2%20%E6%9F%A5%E7%9C%8B%E6%BA%90%E4%BB%A3%E7%A0%81">2.2 查看源代码</h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e1/76/cfi5MGW1_o.png"></p> 
<p><strong>结论：</strong>通过查看源代码我们发现，源代码并没有显示我们页面中实际渲染的内容，我们只看到一个main.js文件，和一个id为app的根元素，所以我们知道网页内容是通过js来动态的进行渲染的，js运行在浏览器，浏览器也就是客户端，这种由浏览器端的js做主导渲染网页内容的方式，我们就称之为<strong>客户端渲染</strong></p> 
<p>思考题：如何得知一个网站是哪种方式的渲染？</p> 
<p></p> 
<hr> 
<p></p> 
<h3 id="%E4%B8%89%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93vs%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93">三、客户端渲染vs服务端渲染</h3> 
<blockquote> 
 <p>客户端渲染我们叫做CSR渲染方式，服务端渲染我们叫做SSR渲染</p> 
</blockquote> 
<h4 id="3.1%20%E8%BF%90%E8%A1%8C%E6%9E%B6%E6%9E%84%E5%AF%B9%E6%AF%94">3.1 运行架构对比</h4> 
<p><img alt="" height="375" src="https://images2.imgbox.com/5b/5a/g7OnjZwP_o.png" width="657"></p> 
<p><strong>说明</strong></p> 
<ul><li>CSR执行流程：浏览器加载html文件 -&gt; 浏览器下载js文件 -&gt; 浏览器运行vue代码 -&gt; 渲染页面</li><li>SSR执行流程：浏览器加载html文件 -&gt; 服务端装填好内容 -&gt; 返回浏览器渲染</li></ul> 
<p></p> 
<h4 id="3.2%20%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94">3.2 开发模式对比</h4> 
<p>CSR：前后端通过接口JSON数据进行通信，各自开发互不影响</p> 
<p>SSR：前后端分工搭配复杂，前端需要写好html模板交给后端，后端装填模板内容返给浏览器</p> 
<h4></h4> 
<table><thead><tr><th></th><th>客户端渲染（CSR）</th><th>服务端渲染（SSR）</th></tr></thead><tbody><tr><td>首次渲染时间</td><td>长</td><td>很短</td></tr><tr><td>seo支持</td><td>差</td><td>良好</td></tr><tr><td>前后端分工开发效率</td><td>快</td><td>慢</td></tr></tbody></table> 
<p>思考：如果我们的项目既想要使用vue高效率的开发项目，同时还想要首屏渲染时间很短，那该怎么办？</p> 
<p></p> 
<hr> 
<p></p> 
<h3 id="%E5%9B%9B%E3%80%81vue%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93">四、vue框架中的服务端渲染</h3> 
<p>为了解决第3章节提出的问题，目前我们的vue组件都是在浏览器侧通过js渲染出来的，所以首次加载时间很慢，那么我们把vue组件交给服务端负责渲染，渲染为完整内容之后直接返给客户端，是不是就可以可以解决既想渲染快，还想继续使用vue进行开发的问题了？</p> 
<p><a href="https://gitee.com/link?target=https%3A%2F%2Fssr.vuejs.org%2Fzh%2Fguide%2F%23%25E5%25AE%2589%25E8%25A3%2585" rel="nofollow" title="vue ssr基础使用">vue ssr基础使用</a></p> 
<p></p> 
<h4 id="4.1%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE">4.1 初始化项目</h4> 
<p>在 ssr 目录下新建 vue-ssr 文件夹</p> 
<p>把之前 server文件夹中的所有文件拷贝到刚创建的 vue-ssr 文件夹里</p> 
<p>通过 npm install vue vue-server-renderer --save 命令安装必要的依赖</p> 
<p></p> 
<h4 id="4.2%20vue%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%9C%80%E5%B0%8Fdemo">4.2 vue服务端渲染最小demo</h4> 
<p><code>app.js</code></p> 
<pre><code class="language-javascript">const Vue = require('vue')
const server = require('express')()

const renderer = require('vue-server-renderer').createRenderer()

server.get('*', (req, res) =&gt; {
  const app = new Vue({
    data: {
      url: req.url
    },
    template: `&lt;div&gt;访问的 URL 是：{<!-- -->{ url }}&lt;/div&gt;`,
  })
  renderer.renderToString(app, (err, html) =&gt; {
    if (err) throw err
    res.send(html)
  })
})

server.listen(8888,() =&gt; console.log(`Example app listening on port 8888!`))</code></pre> 
<p>在项目根目录下通过 node app.js 启动服务器</p> 
<p><code>在浏览器里输入：http://localhost:8888 查看</code></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/83/15/5AZvrUW3_o.png"></p> 
<p></p> 
<p><strong>查看源代码：</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/20/39/2YQHOAWx_o.png"></p> 
<p><strong>结论：</strong>我们通过在服务器端渲染vue组件的方式，让网页中又有了完整的内容，这样我们就可以既使用了vue开发又节省了首次渲染时间</p> 
<p></p> 
<h4 id="4.3%20%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98">4.3 遗留问题</h4> 
<p>修改app.js，添加一个button元素并使用vue的方式绑定click事件</p> 
<pre><code class="language-javascript">// 目标：是把vue组件的渲染从客户端放到了服务端
// 目的： 既想使用vue继续开发项目 享受vue提供的高效的开发方式 而且我们还想让首屏渲染时间短  
// 解决方案：把vue组件的渲染的地方放到服务端进行即可

// 引入vue框架
const Vue = require('vue')

// 引入express框架 进行服务端功能开发
const server = require('express')()

// 引入vue服务端渲染插件 帮助我们把vue组件渲染成字符串
const renderer = require('vue-server-renderer').createRenderer()

// 编写一个通用路由 -&gt;  new一个Vue实例 -&gt;  把vue实例渲染成字符串(组件字符串)

server.get('*', (req, res) =&gt; {
  // 实例化vue 
  const app = new Vue({
    data: {
      url: req.url
    },
    template: `
     &lt;div&gt;
        访问的 URL 是：{<!-- -->{ url }}
        &lt;button @click="alert(123)"&gt;click me!&lt;/button&gt;
     &lt;/div&gt;`,
  })
  // 把vue实例渲染成字符串
  renderer.renderToString(app, (err, html) =&gt; {
    if (err) throw err
    res.send(html)
  })
})


// 监听一个服务 端口8888
server.listen(8888,() =&gt; console.log(`Example app listening on port 8888!`))

// 1.通过访问源代码 我们发现确实是服务端渲染  保证了首屏渲染时间短
// 2.我们还继续使用了vue的组件开发模式</code></pre> 
<p>运行发现，页面成功显示了button按钮，但是可惜的是，没有成功绑定事件，点击无效</p> 
<p><img alt="" height="197" src="https://images2.imgbox.com/63/d2/XOPluaOT_o.gif" width="578"></p> 
<p>事实上除了事件没有绑定之外，服务器端虽然完成了vue的渲染，但是给到客户端的时候已经成了字符串了，一系列我们熟悉的vue应用的特性，我们都无法使用，比如数据响应式更新，那该怎么办呢？</p> 
<p>为了解决以上问题，我们需要引入一个新的概念，称作 <code>同构</code></p> 
<p></p> 
<hr> 
<p></p> 
<h3 id="%E4%BA%94%E3%80%81%E7%90%86%E8%A7%A3%E5%90%8C%E6%9E%84%E7%90%86%E5%BF%B5">五、理解同构理念</h3> 
<blockquote> 
 <p>一套vue（react）代码，在服务端执行一次，在客户端再执行一次，就做同构</p> 
</blockquote> 
<pre><code class="language-javascript">const app = new Vue({
    data: {
      url: req.url
    },
    template: 
    `&lt;div&gt;
      访问的 URL 是：{<!-- -->{ url }}
      &lt;button @click="alert('123')"&gt;click me!&lt;/button&gt;
    &lt;/div&gt;`
})</code></pre> 
<p>上面所示的vue代码，我们在服务端的执行保持不变，只要我们把这段代码在客户端再重新执行一遍，不就可以拥有原本vue应用的所有特性了么，确实如此，不过这个过程的难度太大，我们现在只需要理解，所谓的同构是指：<span style="color:#fe2c24;"><strong>同一套vue代码在服务端执行一次在客户端再执行一次</strong></span></p> 
<ol><li>服务端执行完成渲染解决了首次加载速度慢的问题</li><li>浏览器执行解决了绑定事件及恢复vue本身特性的问题</li></ol> 
<p></p> 
<hr> 
<p></p> 
<h3 id="%E5%85%AD%E3%80%81Nuxt.js%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8">六、Nuxt.js框架使用</h3> 
<blockquote> 
 <p>nuxt.js是一套使用vue框架开发应用的服务端渲染框架，提供了开箱即用的功能</p> 
</blockquote> 
<h4 id="6.1.%20%E4%BD%BF%E7%94%A8nuxt.js%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAssr%E9%A1%B9%E7%9B%AE">6.1. 使用nuxt.js创建一个ssr项目</h4> 
<p>在根目录下也就是 ssr 目录下通过 npm create nuxt-app &lt;项目名&gt; 创建项目</p> 
<p>按照提示选择项目之后完成创建，需要注意，这一步要选择ssr</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/80/80/2NWRQEiu_o.png"></p> 
<p></p> 
<h4 id="6.2%20%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE">6.2 启动项目</h4> 
<p><img alt="" height="173" src="https://images2.imgbox.com/46/33/pJHp23kG_o.png" width="378"></p> 
<p> 进入到项目根目录，通过 npm run dev 运行项目</p> 
<p><img alt="" height="386" src="https://images2.imgbox.com/ea/d0/3S7LHtQT_o.png" width="428"></p> 
<p> 在浏览器里输入 <code>http://localhost:3000 查看</code></p> 
<p style="text-align:center;"><img alt="" height="265" src="https://images2.imgbox.com/4d/a3/YfQLTjRH_o.png" width="413"></p> 
<h4></h4> 
<h4 id="6.3%20%E6%9F%A5%E7%9C%8B%E6%BA%90%E4%BB%A3%E7%A0%81">6.3 查看源代码</h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/71/36/h1RaAIl9_o.png"></p> 
<p>显然，我们看到了网页上有实际渲染的内容，这是服务端负责的渲染</p> 
<h4></h4> 
<h4 id="6.4%20%E6%90%AD%E5%BB%BA%E9%A6%96%E9%A1%B5">6.4 搭建首页</h4> 
<p><code>pages/index.vue</code></p> 
<p>在nuxt.js生成的项目中我们依旧像之前一样写单文件组件.vue代码，ElementUI组件也可以正常使用</p> 
<pre><code>&lt;template&gt;
  &lt;div class="container"&gt;
    &lt;Logo /&gt;
    &lt;div class="articleList"&gt;
      &lt;el-collapse&gt;
        &lt;el-collapse-item title="一致性 Consistency" name="1"&gt;
          &lt;div&gt;与现实生活一致：与现实生活的流程、逻辑保持一致，遵循用户习惯的语言和概念；&lt;/div&gt;
        &lt;/el-collapse-item&gt;
      &lt;/el-collapse&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {}
&lt;/script&gt;

&lt;style&gt;
.container{
  padding:0 200px;
}
.articleList{
  margin-top:30px;
}
&lt;/style&gt;</code></pre> 
<h4></h4> 
<h4 id="6.5%20%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96">6.5 异步数据获取</h4> 
<p><a href="https://gitee.com/link?target=https%3A%2F%2Faxios.nuxtjs.org%2F" rel="nofollow" title="https://axios.nuxtjs.org/">https://axios.nuxtjs.org/</a></p> 
<p>1. 认识asyncData方法</p> 
<p><code>asyncData</code>方法会在组件（<strong>限于页面组件</strong>）每次加载之前被调用。它可以在服务端或路由更新之前被调用，你可以利用 <code>asyncData</code>方法来获取数据，Nuxt.js 会将 <code>asyncData</code> 返回的数据融合组件 <code>data</code> 方法返回的数据一并返回给当前组件</p> 
<p>官网推荐使用的请求方式 <a href="https://gitee.com/link?target=https%3A%2F%2Faxios.nuxtjs.org%2F" rel="nofollow" title="https://axios.nuxtjs.org/">https://axios.nuxtjs.org/</a></p> 
<pre><code>async asyncData({ $axios }) {
  const ip = await $axios.$get('http://icanhazip.com')
  return { ip }
},
data(){
  return {
     name:'cp'
  }
}

----合并完之后的data数据----
{
   name:'cp',
   ip
}</code></pre> 
<p>2. 获取文章列表（移动端项目）</p> 
<pre><code>async asyncData ({ $axios }) {
    const url = 'http://ttapi.research.itcast.cn/app/v1_1/articles?channel_id=0&amp;timestamp=1606309443970&amp;with_top=1'
    const res = await $axios.$get(url)
    // eslint-disable-next-line no-console
    console.log('文章数据列表：', res)
    return {
      list: res.data.results
    }
 }</code></pre> 
<p>3. 渲染接口数据</p> 
<pre><code>&lt;el-collapse&gt;
    &lt;el-collapse-item v-for="item in list" :key="item.id" :title="item.title.slice(0,40)"&gt;
      &lt;div&gt;评论数：{<!-- -->{ item.comm_count }}  点赞数：{<!-- -->{ item.like_count }}&lt;/div&gt;
    &lt;/el-collapse-item&gt;
&lt;/el-collapse&gt;</code></pre> 
<p>4. 预览效果并查看源代码</p> 
<p>结论：我们完成了既使用vue开发模式，又实现了服务端渲染模式，nice~</p> 
<p><span style="color:#4da8ee;"><strong>完整 inde.vue代码</strong></span></p> 
<pre><code>&lt;template&gt;
  &lt;div class="container"&gt;
    &lt;Logo /&gt; {<!-- -->{ name }}
    &lt;div class="articleList"&gt;
      &lt;el-collapse&gt;
        &lt;el-collapse-item
          v-for="article in articleList"
          :key="article.art_id"
          :title="article.title"
        &gt;
          &lt;div&gt;评论数：{<!-- -->{ article.comm_count }}点赞数：{<!-- -->{ article.like_count }}&lt;/div&gt;
        &lt;/el-collapse-item&gt;
      &lt;/el-collapse&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  // asyncData
  // 调用时机:页面组件中组件渲染之前 自动调用
  // 特点：nuxtjs会帮助我们把asyncData函数的返回值 和 data配置项返回的响应式数据做融合处理 融合起来之后一同交给
  // 当前的组件使用
  // api调用写法：async + await的形式 正常使用axios就可以
  async asyncData ({ $axios }) {
    // 使用axios发起get请求
    const url = 'http://ttapi.research.itcast.cn/app/v1_1/articles?channel_id=0&amp;timestamp=1606309443970&amp;with_top=1'
    const res = await $axios.$get(url)
    // eslint-disable-next-line no-console
    console.log('返回值为:', res.data.results)
    return {
      articleList: res.data.results
    }
  },
  data () {
    return {
      name: 'cp'
    }
  }
}
// 1.如何加入路由功能呢？
// 2.如果在nuxtjs中使用状态管理工具呢？vuex
// 3.使用nuxt.js开发的项目如何完成部署上线呢？ 依赖什么？ 客户端  客户端 服务端

&lt;/script&gt;

&lt;style&gt;
.container{
  padding:0 200px;
}
.articleList{
  margin-top:30px;
}
&lt;/style&gt;</code></pre> 
<p></p> 
<hr> 
<p></p> 
<h3 id="%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93">七、总结</h3> 
<h4 id="7.1%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%90%84%E8%87%AA%E6%8C%87%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F">7.1 服务端渲染和客户端渲染各自指什么？有什么特点？</h4> 
<pre>SSR 服务端渲染  网页内容由服务端生成   首屏时间短  有利于seo
CSR 客户端渲染  vue、react框架渲染方式  spa都是客户端渲染   首屏渲染时间长不利于seo</pre> 
<h4 id="7.2%20%E5%90%8C%E6%9E%84%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">7.2 同构的本质是什么？</h4> 
<pre>一份vue代码在服务端渲染一遍  然后在客户端再渲染一遍
服务端渲染解决了首屏显示快  客户端渲染是需要把事件、响应式特性等vue经典的特性都绑回去

我们既可以使用vue的开发模式 又可以享受俩种渲染方式的优势</pre> 
<h4 id="7.3%20Nuxt.js%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%88asyncData%E6%96%B9%E6%B3%95%EF%BC%89%EF%BC%9F">7.3 Nuxt.js中如何实现异步数据获取（asyncData方法）？</h4> 
<pre>asyncData函数时Nuxtjs框架内置的一个函数  
执行结果和和data进行融合  一起返给当前组件 </pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f03a9f758d303ba550222c8ae6f643d0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2.配置Swaggger</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1c94a9d5fba9a8df19076e94b81e96f8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HTML&#43;CSS实现百叶窗效果</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>