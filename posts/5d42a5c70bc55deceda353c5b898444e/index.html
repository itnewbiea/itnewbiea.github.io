<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用 Docker 高效搭建本地开发环境（详细教程） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用 Docker 高效搭建本地开发环境（详细教程）" />
<meta property="og:description" content="Docker本地开发环境的好处 试错 对开发者而言，每天会催生出的各式各样的新技术都需要尝试，然而开发者却不太可能为他们一一搭建好环境并进行测试。时间非常宝贵，正是得益于 Docker，让我们有可能在一条或者几条命令内就搭建完环境，而且这个环境大到一个特定版本的操作系统，小到一个软件。Docker 有一个傻瓜化的获取软件的方法，Docker后台会自动获得环境镜像并且运行环境。
统一开发和生产环境 对于一般的小公司来说，搭建一个公用的开发环境是一件不那么划算的事情。那么就可以用Docker来统一开发环境，因为不管你用的是Windows、Mac 还是 Ubuntu。如果生产环境也使用的Docker的话，你甚至可以直接打包一套环境，直接丢上去就可以运行了，再也不用担心开发-生产环境之间的差异了。
高性能 虚拟机的粒度是虚拟出的机 ，而Docker的粒度则是被限制的应用 ，相比较而言 Docker 的内存占用更少，更加轻量级，性能也更优。
而秒级的启动，也可以让我们启动电脑时候，开发环境的运行是无感知的。
成果展示 我们可能经常要给用户或者是同事展示一样功能的，但是搭建演示环境的过程却是非常麻烦的。现在可以直接将我们的镜像打包丢过去，而不必去做任何环境配置的工作，同时也不必担心他们的环境配置会导致我们的产品无法运行。
安装Docker 在mac平台下，就是去下载一个dmg的安装文件。下载好了之后，双击，然后拖入就可以了，windows应该也是类似的。
就是安装qq一样简单，傻瓜式的。
附上dockerhub上的下载链接：
https://hub.docker.com/search/?type=edition&amp;offering=community&amp;q=
成功之后属于docker version如果出来版本信息就是安装成功，类似如下
Client: Docker Engine - Community Version: 18.09.0 API version: 1.39 Go version: go1.10.4 Git commit: 4d60db4 Built: Wed Nov 7 00:47:43 2018 OS/Arch: darwin/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 18.09.0 API version: 1.39 (minimum version 1.12) Go version: go1.10.4 Git commit: 4d60db4 Built: Wed Nov 7 00:55:00 2018 OS/Arch: linux/amd64 Experimental: true 安装docker-composer 一般来说，mac安装docker之后就会携带docker-composer。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5d42a5c70bc55deceda353c5b898444e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-20T09:02:45+08:00" />
<meta property="article:modified_time" content="2023-06-20T09:02:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用 Docker 高效搭建本地开发环境（详细教程）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <h3><strong><code>Docker</code>本地开发环境的好处</strong></h3> 
 <h5>试错</h5> 
 <p style="text-align:left;">对开发者而言，每天会催生出的各式各样的新技术都需要尝试，然而开发者却不太可能为他们一一搭建好环境并进行测试。时间非常宝贵，正是得益于 <code>Docker</code>，让我们有可能在一条或者几条命令内就搭建完环境，而且这个环境大到一个特定版本的操作系统，小到一个软件。Docker 有一个傻瓜化的获取软件的方法，<code>Docker</code>后台会自动获得环境镜像并且运行环境。</p> 
 <h5>统一开发和生产环境</h5> 
 <p style="text-align:left;">对于一般的小公司来说，搭建一个公用的开发环境是一件不那么划算的事情。那么就可以用<code>Docker</code>来统一开发环境，因为不管你用的是<code>Windows</code>、<code>Mac</code> 还是 <code>Ubuntu</code>。如果生产环境也使用的<code>Docker</code>的话，你甚至可以直接打包一套环境，直接丢上去就可以运行了，再也不用担心开发-生产环境之间的差异了。</p> 
 <h5>高性能</h5> 
 <p style="text-align:left;">虚拟机的粒度是<strong>虚拟出的机</strong> ，而<code>Docker</code>的粒度则是<strong>被限制的应用</strong> ，相比较而言 Docker 的内存占用更少，更加轻量级，性能也更优。</p> 
 <p style="text-align:left;">而秒级的启动，也可以让我们启动电脑时候，开发环境的运行是无感知的。</p> 
 <h5>成果展示</h5> 
 <p style="text-align:left;">我们可能经常要给用户或者是同事展示一样功能的，但是搭建演示环境的过程却是非常麻烦的。现在可以直接将我们的镜像打包丢过去，而不必去做任何环境配置的工作，同时也不必担心他们的环境配置会导致我们的产品无法运行。</p> 
 <h3><strong>安装<code>Docker</code></strong></h3> 
 <p style="text-align:left;">在<code>mac</code>平台下，就是去下载一个<code>dmg</code>的安装文件。下载好了之后，双击，然后拖入就可以了，<code>windows</code>应该也是类似的。</p> 
 <p style="text-align:left;">就是安装<code>qq</code>一样简单，傻瓜式的。</p> 
 <p style="text-align:left;">附上<code>dockerhub</code>上的下载链接：</p> 
 <blockquote> 
  <p>https://hub.docker.com/search/?type=edition&amp;offering=community&amp;q=</p> 
 </blockquote> 
 <p style="text-align:left;">成功之后属于<code>docker version</code>如果出来版本信息就是安装成功，类似如下</p> 
 <pre class="has"><code class="language-go">Client: Docker Engine - Community
 Version:           18.09.0
 API version:       1.39
 Go version:        go1.10.4
 Git commit:        4d60db4
 Built:             Wed Nov  7 00:47:43 2018
 OS/Arch:           darwin/amd64
 Experimental:      false

Server: Docker Engine - Community
 Engine:
  Version:          18.09.0
  API version:      1.39 (minimum version 1.12)
  Go version:       go1.10.4
  Git commit:       4d60db4
  Built:            Wed Nov  7 00:55:00 2018
  OS/Arch:          linux/amd64
  Experimental:     true</code></pre> 
 <h3><strong>安装<code>docker-composer</code></strong></h3> 
 <p style="text-align:left;">一般来说，mac安装<code>docker</code>之后就会携带<code>docker-composer</code>。</p> 
 <p style="text-align:left;">其他平台，附上下载链接：</p> 
 <blockquote> 
  <p>https://github.com/docker/compose/releases</p> 
 </blockquote> 
 <p style="text-align:left;">安装完成之后可以输入命令检测</p> 
 <pre class="has"><code class="language-go">➜  ~ docker-compose version
docker-compose version 1.23.2, build 1110ad01
docker-py version: 3.6.0
CPython version: 3.6.6
OpenSSL version: OpenSSL 1.1.0h  27 Mar 2018</code></pre> 
 <p style="text-align:left;">如果没有出现版本相关信息，可以尝试再次安装</p> 
 <h3><strong>下载<code>laradock</code></strong></h3> 
 <p style="text-align:left;"><code>laradock</code>的项目地址是<code>https://github.com/laradock/laradock</code> 我们找一个地方<code>clone</code>下来即可</p> 
 <p style="text-align:left;">我这里是在我的用户目录下面新建了一个<code>Docker</code>目录，然后<code>clone</code>了项目下来</p> 
 <h3><strong>配置<code>env</code>文件</strong></h3> 
 <ol><li><p>拷贝example成.env</p><pre class="has"><code class="language-go">cp env-example env</code></pre></li><li><p><code>.env</code>文件中<code>APP_CODE_PATH_HOST</code>是本地路径 <code>APP_CODE_PATH_CONTAINER</code>是远程映射路径，看需求修改，大多数情况下是不需要的</p></li><li><p>如果有调试代码的需求，也可以将<code>PHP_FPM_INSTALL_XDEBUG</code>和<code>WORKSPACE_INSTALL_XDEBUG</code>两个选项打开</p></li><li><p>如果还有其他的需求，可以在<code>.env</code>里面搜索，里面已经将大多数配置项都给独立出来了</p></li></ol> 
 <h3><strong>运行容器</strong></h3> 
 <p style="text-align:left;">进入到<code>laradock</code>的工作目录下面，就是<code>clone</code>的项目的根目录我的工作目录就是<code>~/Docker/laradock</code>。</p> 
 <p style="text-align:left;">然后运行如下命令</p> 
 <pre class="has"><code class="language-go">docker-compose up -d nginx mysql</code></pre> 
 <p style="text-align:left;">就会看到在自动执行<code>build</code>操作，并且build完了之后自动后台启动了如下容器</p> 
 <ul><li><p>nginx</p></li><li><p>php-fpm</p></li><li><p>workspace</p></li><li><p>mysql</p></li></ul> 
 <p style="text-align:left;">那是因为<code>php-fpm</code>和<code>workspace</code>还有<code>docker-in-docker</code>是随<code>nginx</code>一并启动的</p> 
 <p style="text-align:left;">所以实际上</p> 
 <pre class="has"><code class="language-go">docker-compose up -d nginx mysql</code></pre> 
 <p style="text-align:left;">和</p> 
 <pre class="has"><code class="language-go">docker-compose up -d nginx workspace php-fpm mysql</code></pre> 
 <p style="text-align:left;">这两条命令的效果是一样的，可以都带上，也可以不写。</p> 
 <p style="text-align:left;"><code>up</code>命令在第一次启动的时候实际上就是<code>build</code> + <code>start</code>的组合，如果容器不存在，那么就<code>build</code>一个容器，并且启动服务，如果容器存在那么直接启动服务，大概就是这么个意思 <code>-d</code>的意思是后台运行</p> 
 <h3><strong>配置web项目</strong></h3> 
 <p style="text-align:left;">一下是我<code>laravel</code>项目的部分配置</p> 
 <pre class="has"><code class="language-go">DB_CONNECTION=mysql
DB_HOST=mysql
DB_PORT=3306
DB_DATABASE=blog
DB_USERNAME=root
DB_PASSWORD=root
......</code></pre> 
 <p style="text-align:left;">注意，数据库主机必须得是别名才可以，如果<code>DB_CONNECTION</code>这个地方输入172.0.0.1或者是<code>localhost</code>都是会连接失败的。</p> 
 <p style="text-align:left;">在其它的项目中也必须是这样的，配置数据库链接，<code>redis</code>，或者<code>MemCache</code>链接都必须设置成具体的别名。或者你说我找到各个容器的ip，可以嘛。可以，但是并不建议这样做，因为ip是会变动的。</p> 
 <p style="text-align:left;">具体别名可以参考<code>./docker-compose.yml</code>文件中的设置</p> 
 <p style="text-align:left;">这个主要的技术实现应该是用了<code>docker</code>的虚拟网桥技术.</p> 
 <h3><strong>配置宿主机的<code>host</code></strong></h3> 
 <p style="text-align:left;">因为，往往我们访问的时候，是通过宿主机上面的浏览器发送请求的，所以，配置宿主机上面的<code>host</code>必不可少。</p> 
 <pre class="has"><code class="language-go">vim /etc/hosts</code></pre> 
 <p style="text-align:left;">我这里加入一条我自己设置的虚拟域名</p> 
 <pre class="has"><code class="language-go">127.0.0.1       blog.test</code></pre> 
 <p style="text-align:left;">然后保存，刷新下host。</p> 
 <h3><strong>配置<code>nginx</code></strong></h3> 
 <p style="text-align:left;">进入到<code>./laradock/nginx/sites</code>文件夹，然后<code>ll</code>一下，我们会发现，laradock已经帮我们放了好多列举的文件进来</p> 
 <pre class="has"><code class="language-go">app.conf.example default.conf laravel.conf.example symfony.conf.example</code></pre> 
 <p style="text-align:left;">根据需求拷贝一份，然后修改一下就可以了，都不是很难，由于我们本地是laravel开发的博客项目，所以我就直接拷贝<code>laravel.conf.example</code>，然后使用vim打开</p> 
 <pre class="has"><code class="language-go">cp laravel.conf.example blog.conf vim blog.conf</code></pre> 
 <p style="text-align:left;">打开后的内容...</p> 
 <pre class="has"><code class="language-go">server {

    listen 80;
    listen [::]:80;

    # For https
    # listen 443 ssl;
    # listen [::]:443 ssl ipv6only=on;
    # ssl_certificate /etc/nginx/ssl/default.crt;
    # ssl_certificate_key /etc/nginx/ssl/default.key;

    server_name laravel.test;
    root /var/www/laravel/public;
    index index.php index.html index.htm;

    location / {
         try_files $uri $uri/ /index.php$is_args$args;
    }

    location ~ \.php$ {
        try_files $uri /index.php =404;
        fastcgi_pass php-upstream;
        fastcgi_index index.php;
        fastcgi_buffers 16 16k;
        fastcgi_buffer_size 32k;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        #fixes timeouts
        fastcgi_read_timeout 600;
        include fastcgi_params;</code></pre> 
 <p style="text-align:left;">我们会发现，如果没有特殊需求的话，这个里面大多数地方我们并不需要修改。我们只需要关注<code>server_name</code>和<code>root</code>这两个参数，把这个里面的<code>laravel</code>换成我们项目名就可以了，这里我们换成<code>blog</code></p> 
 <p style="text-align:left;">下面是修改后的内容</p> 
 <pre class="has"><code class="language-go">server {

    listen 80;
    listen [::]:80;

    # For https
    # listen 443 ssl;
    # listen [::]:443 ssl ipv6only=on;
    # ssl_certificate /etc/nginx/ssl/default.crt;
    # ssl_certificate_key /etc/nginx/ssl/default.key;

    server_name blog.test;
    root /var/www/blog/public;
    index index.php index.html index.htm;

    location / {
         try_files $uri $uri/ /index.php$is_args$args;
    }

    location ~ \.php$ {
        try_files $uri /index.php =404;
        fastcgi_pass php-upstream;
        fastcgi_index index.php;
        fastcgi_buffers 16 16k;
        fastcgi_buffer_size 32k;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        #fixes timeouts
        fastcgi_read_timeout 600;
        include fastcgi_params;</code></pre> 
 <h3><strong>访问</strong></h3> 
 <p style="text-align:left;">输入<code>url</code></p> 
 <pre class="has"><code class="language-go">http://blog.test/</code></pre> 
 <p style="text-align:left;">浏览器返回结果</p> 
 <img src="https://images2.imgbox.com/10/7f/lQyhUFGd_o.jpg" alt="b0e6d3b1945aceb08758d641b87f322f.jpeg"> 
 <h3><strong><code>Docker</code>本地开发环境的好处</strong></h3> 
 <h5>试错</h5> 
 <p style="text-align:left;">对开发者而言，每天会催生出的各式各样的新技术都需要尝试，然而开发者却不太可能为他们一一搭建好环境并进行测试。时间非常宝贵，正是得益于 <code>Docker</code>，让我们有可能在一条或者几条命令内就搭建完环境，而且这个环境大到一个特定版本的操作系统，小到一个软件。Docker 有一个傻瓜化的获取软件的方法，<code>Docker</code>后台会自动获得环境镜像并且运行环境。</p> 
 <h5>统一开发和生产环境</h5> 
 <p style="text-align:left;">对于一般的小公司来说，搭建一个公用的开发环境是一件不那么划算的事情。那么就可以用<code>Docker</code>来统一开发环境，因为不管你用的是<code>Windows</code>、<code>Mac</code> 还是 <code>Ubuntu</code>。如果生产环境也使用的<code>Docker</code>的话，你甚至可以直接打包一套环境，直接丢上去就可以运行了，再也不用担心开发-生产环境之间的差异了。</p> 
 <h5>高性能</h5> 
 <p style="text-align:left;">虚拟机的粒度是<strong>虚拟出的机</strong> ，而<code>Docker</code>的粒度则是<strong>被限制的应用</strong> ，相比较而言 Docker 的内存占用更少，更加轻量级，性能也更优。</p> 
 <p style="text-align:left;">而秒级的启动，也可以让我们启动电脑时候，开发环境的运行是无感知的。</p> 
 <h5>成果展示</h5> 
 <p style="text-align:left;">我们可能经常要给用户或者是同事展示一样功能的，但是搭建演示环境的过程却是非常麻烦的。现在可以直接将我们的镜像打包丢过去，而不必去做任何环境配置的工作，同时也不必担心他们的环境配置会导致我们的产品无法运行。</p> 
 <h3><strong>安装<code>Docker</code></strong></h3> 
 <p style="text-align:left;">在<code>mac</code>平台下，就是去下载一个<code>dmg</code>的安装文件。下载好了之后，双击，然后拖入就可以了，<code>windows</code>应该也是类似的。</p> 
 <p style="text-align:left;">就是安装<code>qq</code>一样简单，傻瓜式的。</p> 
 <p style="text-align:left;">附上<code>dockerhub</code>上的下载链接：</p> 
 <blockquote> 
  <p>https://hub.docker.com/search/?type=edition&amp;offering=community&amp;q=</p> 
 </blockquote> 
 <p style="text-align:left;">成功之后属于<code>docker version</code>如果出来版本信息就是安装成功，类似如下</p> 
 <pre class="has"><code class="language-go">Client: Docker Engine - Community
 Version:           18.09.0
 API version:       1.39
 Go version:        go1.10.4
 Git commit:        4d60db4
 Built:             Wed Nov  7 00:47:43 2018
 OS/Arch:           darwin/amd64
 Experimental:      false

Server: Docker Engine - Community
 Engine:
  Version:          18.09.0
  API version:      1.39 (minimum version 1.12)
  Go version:       go1.10.4
  Git commit:       4d60db4
  Built:            Wed Nov  7 00:55:00 2018
  OS/Arch:          linux/amd64
  Experimental:     true</code></pre> 
 <h3><strong>安装<code>docker-composer</code></strong></h3> 
 <p style="text-align:left;">一般来说，mac安装<code>docker</code>之后就会携带<code>docker-composer</code>。</p> 
 <p style="text-align:left;">其他平台，附上下载链接：</p> 
 <blockquote> 
  <p>https://github.com/docker/compose/releases</p> 
 </blockquote> 
 <p style="text-align:left;">安装完成之后可以输入命令检测</p> 
 <pre class="has"><code class="language-go">➜  ~ docker-compose version
docker-compose version 1.23.2, build 1110ad01
docker-py version: 3.6.0
CPython version: 3.6.6
OpenSSL version: OpenSSL 1.1.0h  27 Mar 2018</code></pre> 
 <p style="text-align:left;">如果没有出现版本相关信息，可以尝试再次安装</p> 
 <h3><strong>下载<code>laradock</code></strong></h3> 
 <p style="text-align:left;"><code>laradock</code>的项目地址是<code>https://github.com/laradock/laradock</code> 我们找一个地方<code>clone</code>下来即可</p> 
 <p style="text-align:left;">我这里是在我的用户目录下面新建了一个<code>Docker</code>目录，然后<code>clone</code>了项目下来</p> 
 <h3><strong>配置<code>env</code>文件</strong></h3> 
 <ol><li><p>拷贝example成.env</p><pre class="has"><code class="language-go">cp env-example env</code></pre></li><li><p><code>.env</code>文件中<code>APP_CODE_PATH_HOST</code>是本地路径 <code>APP_CODE_PATH_CONTAINER</code>是远程映射路径，看需求修改，大多数情况下是不需要的</p></li><li><p>如果有调试代码的需求，也可以将<code>PHP_FPM_INSTALL_XDEBUG</code>和<code>WORKSPACE_INSTALL_XDEBUG</code>两个选项打开</p></li><li><p>如果还有其他的需求，可以在<code>.env</code>里面搜索，里面已经将大多数配置项都给独立出来了</p></li></ol> 
 <h3><strong>运行容器</strong></h3> 
 <p style="text-align:left;">进入到<code>laradock</code>的工作目录下面，就是<code>clone</code>的项目的根目录我的工作目录就是<code>~/Docker/laradock</code>。</p> 
 <p style="text-align:left;">然后运行如下命令</p> 
 <pre class="has"><code class="language-go">docker-compose up -d nginx mysql</code></pre> 
 <p style="text-align:left;">就会看到在自动执行<code>build</code>操作，并且build完了之后自动后台启动了如下容器</p> 
 <ul><li><p>nginx</p></li><li><p>php-fpm</p></li><li><p>workspace</p></li><li><p>mysql</p></li></ul> 
 <p style="text-align:left;">那是因为<code>php-fpm</code>和<code>workspace</code>还有<code>docker-in-docker</code>是随<code>nginx</code>一并启动的</p> 
 <p style="text-align:left;">所以实际上</p> 
 <pre class="has"><code class="language-go">docker-compose up -d nginx mysql</code></pre> 
 <p style="text-align:left;">和</p> 
 <pre class="has"><code class="language-go">docker-compose up -d nginx workspace php-fpm mysql</code></pre> 
 <p style="text-align:left;">这两条命令的效果是一样的，可以都带上，也可以不写。</p> 
 <p style="text-align:left;"><code>up</code>命令在第一次启动的时候实际上就是<code>build</code> + <code>start</code>的组合，如果容器不存在，那么就<code>build</code>一个容器，并且启动服务，如果容器存在那么直接启动服务，大概就是这么个意思 <code>-d</code>的意思是后台运行</p> 
 <h3><strong>配置web项目</strong></h3> 
 <p style="text-align:left;">一下是我<code>laravel</code>项目的部分配置</p> 
 <pre class="has"><code class="language-go">DB_CONNECTION=mysql
DB_HOST=mysql
DB_PORT=3306
DB_DATABASE=blog
DB_USERNAME=root
DB_PASSWORD=root
......</code></pre> 
 <p style="text-align:left;">注意，数据库主机必须得是别名才可以，如果<code>DB_CONNECTION</code>这个地方输入172.0.0.1或者是<code>localhost</code>都是会连接失败的。</p> 
 <p style="text-align:left;">在其它的项目中也必须是这样的，配置数据库链接，<code>redis</code>，或者<code>MemCache</code>链接都必须设置成具体的别名。或者你说我找到各个容器的ip，可以嘛。可以，但是并不建议这样做，因为ip是会变动的。</p> 
 <p style="text-align:left;">具体别名可以参考<code>./docker-compose.yml</code>文件中的设置</p> 
 <p style="text-align:left;">这个主要的技术实现应该是用了<code>docker</code>的虚拟网桥技术.</p> 
 <h3><strong>配置宿主机的<code>host</code></strong></h3> 
 <p style="text-align:left;">因为，往往我们访问的时候，是通过宿主机上面的浏览器发送请求的，所以，配置宿主机上面的<code>host</code>必不可少。</p> 
 <pre class="has"><code class="language-go">vim /etc/hosts</code></pre> 
 <p style="text-align:left;">我这里加入一条我自己设置的虚拟域名</p> 
 <pre class="has"><code class="language-go">127.0.0.1       blog.test</code></pre> 
 <p style="text-align:left;">然后保存，刷新下host。</p> 
 <h3><strong>配置<code>nginx</code></strong></h3> 
 <p style="text-align:left;">进入到<code>./laradock/nginx/sites</code>文件夹，然后<code>ll</code>一下，我们会发现，laradock已经帮我们放了好多列举的文件进来</p> 
 <pre class="has"><code class="language-go">app.conf.example default.conf laravel.conf.example symfony.conf.example</code></pre> 
 <p style="text-align:left;">根据需求拷贝一份，然后修改一下就可以了，都不是很难，由于我们本地是laravel开发的博客项目，所以我就直接拷贝<code>laravel.conf.example</code>，然后使用vim打开</p> 
 <pre class="has"><code class="language-go">cp laravel.conf.example blog.conf vim blog.conf</code></pre> 
 <p style="text-align:left;">打开后的内容...</p> 
 <pre class="has"><code class="language-go">server {

    listen 80;
    listen [::]:80;

    # For https
    # listen 443 ssl;
    # listen [::]:443 ssl ipv6only=on;
    # ssl_certificate /etc/nginx/ssl/default.crt;
    # ssl_certificate_key /etc/nginx/ssl/default.key;

    server_name laravel.test;
    root /var/www/laravel/public;
    index index.php index.html index.htm;

    location / {
         try_files $uri $uri/ /index.php$is_args$args;
    }

    location ~ \.php$ {
        try_files $uri /index.php =404;
        fastcgi_pass php-upstream;
        fastcgi_index index.php;
        fastcgi_buffers 16 16k;
        fastcgi_buffer_size 32k;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        #fixes timeouts
        fastcgi_read_timeout 600;
        include fastcgi_params;</code></pre> 
 <p style="text-align:left;">我们会发现，如果没有特殊需求的话，这个里面大多数地方我们并不需要修改。我们只需要关注<code>server_name</code>和<code>root</code>这两个参数，把这个里面的<code>laravel</code>换成我们项目名就可以了，这里我们换成<code>blog</code></p> 
 <p style="text-align:left;">下面是修改后的内容</p> 
 <pre class="has"><code class="language-go">server {

    listen 80;
    listen [::]:80;

    # For https
    # listen 443 ssl;
    # listen [::]:443 ssl ipv6only=on;
    # ssl_certificate /etc/nginx/ssl/default.crt;
    # ssl_certificate_key /etc/nginx/ssl/default.key;

    server_name blog.test;
    root /var/www/blog/public;
    index index.php index.html index.htm;

    location / {
         try_files $uri $uri/ /index.php$is_args$args;
    }

    location ~ \.php$ {
        try_files $uri /index.php =404;
        fastcgi_pass php-upstream;
        fastcgi_index index.php;
        fastcgi_buffers 16 16k;
        fastcgi_buffer_size 32k;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        #fixes timeouts
        fastcgi_read_timeout 600;
        include fastcgi_params;</code></pre> 
 <h3><strong>访问</strong></h3> 
 <p style="text-align:left;">输入<code>url</code></p> 
 <pre class="has"><code class="language-go">http://blog.test/</code></pre> 
 <p style="text-align:left;">浏览器返回结果</p> 
 <p style="text-align:left;">浏览器返回结果</p> 
 <img src="https://images2.imgbox.com/1c/cb/9MRIn7e9_o.jpg" alt="75e8c87557bf3646c71c65bfe3d176bd.jpeg"> 
 <blockquote> 
  <p style="text-align:left;">来源：juejin.cn/post/<a href="" rel="nofollow">6844903828949565448</a></p> 
 </blockquote> 
 <pre></pre> 
 <pre></pre> 
 <pre></pre> 
 <p style="text-align:center;"><strong>推荐</strong></p> 
 <p><img src="https://images2.imgbox.com/21/3a/vjcvX1oQ_o.gif" alt="13f9f9940746dc784fa9b6178d4f3301.gif"></p> 
 <pre></pre> 
 <pre></pre> 
 <pre></pre> 
 <p>1. <a href="" rel="nofollow">优秀的 Java 代码都是如何分层的 ？看了直呼NB！</a><a href="" rel="nofollow"></a></p> 
 <p>2. <a href="" rel="nofollow">IDEA新UI速览，成了 VS Code 的样子？</a><a href="" rel="nofollow"></a></p> 
 <p>3. <a href="" rel="nofollow">如果有一千万数据，怎么用Java快速查询？</a></p> 
 <p>4. <a href="" rel="nofollow">废物利用，拿自己的旧电脑搭建个服务器吧！</a></p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/ee/3e/m35REvvm_o.png" alt="03f293eef80751275c131369a272b9db.png"></p> 
 <pre class="has"><code class="language-go">最近面试BAT，整理一份面试资料《Java面试BATJ通关手册》，覆盖了Java核心技术、JVM、Java并发、SSM、微服务、数据库、数据结构等等。
获取方式：点“在看”，关注公众号并回复 Java 领取，更多内容陆续奉上。</code></pre> 
 <pre class="has"><code class="language-go">PS：因公众号平台更改了推送规则，如果不想错过内容，记得读完点一下“在看”，加个“星标”，这样每次新文章推送才会第一时间出现在你的订阅列里。
点“在看”支持呀，谢谢啦</code></pre> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4e941b7c89045cf8dbf10758a9346af4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">原生mybatis实现数据加密存储和读取</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f54e5d9802b5792dea5a7b5ffb0b650d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JMeter工具使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>