<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LongAdder为什么快 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LongAdder为什么快" />
<meta property="og:description" content="AtomicLong与LongAdder 同样是原子Long类的加1操作，LongAdder运行速度比AtomicLong速度要快，因为LongAdder使用Base&#43;西格玛Cell累积单元。如果想使用Long的其他运算，使用LongAccumulator具体实现LongBinaryOperator接口（1.8函数式编程）。
为什么LongAdder比较快？ 理论：
通过分散热点的思想，将value值分散到Cell数组中，不同线程通过hash的分配方式到不同的Cell中，各个线程对自己的cell进行CAS操作。可以理解为AtomicLong多个线程争一个自旋锁，LongAdder多个线程争多个自旋锁。
从源码看：
最主要的是LongAdder中，有base和cells单元格。为Striped64父类的成员。
transient volatile Cell[] cells; ​ transient volatile long base; 主要核心方法有三个
add(long x)
longAccumulate(long x, LongBinaryOperator fn,boolean wasUncontended)
sum()
add()方法
public void add(long x) { Cell[] as; long b, v; int m; Cell a; if ((as = cells) != null || !casBase(b = base, b &#43; x)) { boolean uncontended = true; if (as == null || (m = as.length - 1) &lt; 0 || (a = as[getProbe() &amp; m]) == null || !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/eacf26626e3b701b6a77cef5eb85fbb0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-27T23:23:41+08:00" />
<meta property="article:modified_time" content="2021-07-27T23:23:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LongAdder为什么快</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>AtomicLong与LongAdder</h3> 
<p>同样是原子Long类的加1操作，LongAdder运行速度比AtomicLong速度要快，因为LongAdder使用Base+西格玛Cell累积单元。如果想使用Long的其他运算，使用LongAccumulator具体实现LongBinaryOperator接口（1.8函数式编程）。</p> 
<h4>为什么LongAdder比较快？</h4> 
<p>理论：</p> 
<p>通过分散热点的思想，将value值分散到Cell数组中，不同线程通过hash的分配方式到不同的Cell中，各个线程对自己的cell进行CAS操作。可以理解为AtomicLong多个线程争一个自旋锁，LongAdder多个线程争多个自旋锁。</p> 
<p>从源码看：</p> 
<p>最主要的是LongAdder中，有base和cells单元格。为Striped64父类的成员。</p> 
<pre><code class="language-html hljs"> transient volatile Cell[] cells;
 ​
 transient volatile long base;</code></pre> 
<p>主要核心方法有三个</p> 
<p><code>add(long x)</code></p> 
<p><code>longAccumulate(long x, LongBinaryOperator fn,boolean wasUncontended)</code></p> 
<p><code>sum()</code></p> 
<p>add()方法</p> 
<pre><code class="language-html hljs"> public void add(long x) {
     Cell[] as; long b, v; int m; Cell a;
     if ((as = cells) != null || !casBase(b = base, b + x)) {
         boolean uncontended = true;
         if (as == null || (m = as.length - 1) &lt; 0 ||
             (a = as[getProbe() &amp; m]) == null ||
             !(uncontended = a.cas(v = a.value, v + x)))
             longAccumulate(x, null, uncontended);
     }
 }</code></pre> 
<p>对if中的条件开始分析：</p> 
<p><strong>第一个if中的条件</strong></p> 
<p><code>(as = cells) != null</code></p> 
<p>一开始线程竞争不激烈cells为空所以为false。</p> 
<hr> 
<p><code>!casBase(b = base, b + x)</code></p> 
<p>查看casBase()方法，该方法为Striped64父类的方法：</p> 
<p>为UnSafe类的CAS方法，为cas底层依赖；</p> 
<pre><code class="language-html hljs"> final boolean casBase(long cmp, long val) {
     return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);
 }</code></pre> 
<p>对base进行CAS操作，如果修改成功，整个if返回false，就不进入if里的操作，表示低并发的情况，如果修改失败，表示高并发的情况，进入if中的操作。</p> 
<hr> 
<p>如果进入了if，<code>boolean uncontended = true;</code>将争夺标志变为true；uncontended为非争夺，true/false表示是否为非争夺状态。</p> 
<p><strong>第二个if</strong></p> 
<p><code>as == null</code></p> 
<p>判断cells是否为空。如果为null，这个表达式就为true；</p> 
<hr> 
<p><code>(m = as.length - 1) &lt; 0</code></p> 
<p>判断cells的长度是否小于2。如果小于2，这个表达式就为true；</p> 
<p>m为什么要等于as.length - 1，因为as的长度为2的幂次，减一后m的二进制刚好为01111……这种规律。下面进行&amp;位运算时，好让计算的数计算后为：二进制数头去掉1，而其他位数值又不会改变。</p> 
<hr> 
<p><code>(a = as[getProbe() &amp; m])</code></p> 
<p>如果进到了这个条件的判断，说明已经有了cells实例对象。并且cells.length&gt;=2。</p> 
<p>getProbe() &amp; m，获取属于线程的hash码，并对m进行二进制与运算，得到一个cells中的一个Cell对象。</p> 
<p>(a = as[getProbe() &amp; m]) == null 判断取到的cell对象是否为null，如果为null，这个表达式就为true；</p> 
<hr> 
<p><code>a.cas(v = a.value, v + x)</code></p> 
<p>对cell中的值以CAS的方式修改。</p> 
<p>!(uncontended = a.cas(v = a.value, v + x))如果修改失败，这个表达式就为true；</p> 
<hr> 
<p>只要上面有一个条件为true就进入longAccumulate方法：</p> 
<p>longAccumulate方法</p> 
<p>主要分为4个部分（2、3部分对cells进行扩容和新建）</p> 
<p>第一个部分是保证当前线程有一个非0的轻量级的哈希码：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/62/b2/tevZvjJe_o.png"></p> 
<p></p> 
<p>第二个部分是cells扩容或进行修改：</p> 
<pre><code class="language-html hljs"> boolean collide = false;                // True if last slot nonempty
 for (;;) {
     Cell[] as; Cell a; int n; long v;
     if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) {//第二部分，下面分为6个小部分
         //2.1部分，对cells槽中进行创建Cell对象。
         if ((a = as[(n - 1) &amp; h]) == null) {
             if (cellsBusy == 0) {       // Try to attach new Cell
                 Cell r = new Cell(x);   // Optimistically create
                 if (cellsBusy == 0 &amp;&amp; casCellsBusy()) {//锁起来对cells槽中进行创建Cell对象。
                     boolean created = false;
                     try {               // Recheck under lock
                         Cell[] rs; int m, j;
                         if ((rs = cells) != null &amp;&amp;
                             (m = rs.length) &gt; 0 &amp;&amp;
                             rs[j = (m - 1) &amp; h] == null) {
                             rs[j] = r;
                             created = true;
                         }
                     } finally {
                         cellsBusy = 0;//解锁
                     }
                     if (created)//判断槽中的Cell对象是否创建成功，如果为false说明该槽被其他线程抢先创建。
                         break;
                     continue;           // Slot is now non-empty，下一次就会为扩容或者修改操作了。
                 }
             }
             collide = false;
         }
         //2.2部分，说明hash值冲突，是baseCas修改失败后第一次进入循环，直接跳出这6小步，刷新hash值，继续下一次循环。
         else if (!wasUncontended)       // CAS already known to fail
             wasUncontended = true;      // Continue after rehash
         //2.3部分，对cell进行cas修改
         else if (a.cas(v = a.value, ((fn == null) ? v + x ://进行cas修改，修改成功退出循环。
                                      fn.applyAsLong(v, x))))
             break;
         //2.4部分
         else if (n &gt;= NCPU || cells != as)//判断cells容量是否已经大于CPU的最大核数。将扩容意向设置为collide = false
             collide = false;            // At max size or stale
         //2.5部分
         else if (!collide)              //前面条件都不满足，设置扩容意向collide = true，然后换个hash值进行扩容
             collide = true;
         //2.6部分，cells进行扩容
         else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) {//锁起来对cells进行扩容。
             try {
                 if (cells == as) {      // Expand table unless stale
                     Cell[] rs = new Cell[n &lt;&lt; 1];//二进制向左移1位，表示每次扩容2倍。
                     for (int i = 0; i &lt; n; ++i)//复制扩容
                         rs[i] = as[i];
                     cells = rs;
                 }
             } finally {
                 cellsBusy = 0;//解锁
             }
             collide = false;
             continue;                   // Retry with expanded table
         }
         //上面6小步有一步执行完后，刷新线程的hash值
         h = advanceProbe(h);
     }else if(...){//连接下方第三个部分的else if
         //第三个部分
     }else if(...){
         //第四个部分
     }</code></pre> 
<p>第三个部分是新建cells数组容量为2：</p> 
<p>在创建cells时，用casCellsBusy()保证安全。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9e/cb/QZzzSxai_o.png"></p> 
<p></p> 
<p>第四个部分是进行casBase：</p> 
<p>所有if都不行，再试试改变base，如过还是不行，继续循环。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/80/f3/XyC5tLfz_o.png"></p> 
<p></p> 
<hr> 
<p>sum()方法</p> 
<p>其实是base与cells中value累加。线程不安全，需要等待执行的线程完毕。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/59/b6/wggC5E9u_o.png"></p> 
<p></p> 
<p>LongAdder是做到最终一致性。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/66d169099f7de0d75ded10159ee2f231/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机 屏幕卡住,电脑卡屏是怎么回事   电脑屏幕死机或卡死处理方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/10fcaba48566b5300ff07ef04730ed60/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机dns怎么设置方法,电脑的dns怎么设置具体方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>