<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>操作系统-虚拟存储技术 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="操作系统-虚拟存储技术" />
<meta property="og:description" content=" 虚拟存储器 虚拟存储器传统存储管理方式局部性原理虚拟内存技术请求分页缺页中断 页面置换算法最佳置换算法先进先出（FIFO）最近最久未使用置换算法（LRU）时钟置换算法（CLOCK，最近未使用）总结 虚拟存储器 当用户看到自己程序能在系统中正常运行，他会认为，该系统所具有的内存容量一定比自己程序大，但用户所看到的大容量只是一种错觉，是虚的，所以人们把这样的存储器称为虚拟存储器
传统存储管理方式 传统存储管理方式特征、缺点：
特征：
一次性：作业必须一次性全部装入内存后才能开始运行
1、作业很大，不能全部装入内存，导致大作业无法运行 2、只有少量作业能运行，导致多道程序并发度下降 驻留性：一旦作业被放入内存，就会一直驻留在内存中，直至作业结束。事实上一个时间段，只需访问作业一小部分数据即可正常运行（GTA场景）。
1、浪费资源 局部性原理 如何应用：
高速缓冲思想：将近期会频繁访问到的数据放到更高速的存储器当中，暂时不用的数据放到更低速的存储器中。
基于局部性原理：
程序装入时可以将很快会用到的部分装入内存中，暂时不用的部分留在外存。 执行过程中，由操作系统负责将信息从外存调入内存中，然后继续执行程序。 内存空间不够，由操作系统负责将内存中暂时不用的信息换出到外存 在操作系统的管理下，用户看来似乎有一个比实际大的多的内存，叫做虚拟内存
虚拟内存只是在逻辑上进行了扩充
三个特征
虚拟内存技术 建立在离散分配的内存管理分配基础上
请求分页 在基本分页的基础上增加了几个表项：
1、状态位：表示页面是否已在内存中（只有调入内存才能根据表项块号得出最终物理地址，不在的话在外存） 2、访问字段：记录最近被访问过几次，或记录上次访问的时间，供置换算法换出页面做参考 3、修改位：表示页面调入内存后是否被修改过， 由于内存中每一页都在外存上有副本，若未被修改，不需要将该页写回到外存。若被修改，则需要写到外存上 4、外存地址：页面在外存中存放的位置 缺页中断 如果一个页面未调入内存则会产生缺页中断信号
属于内中断
一条指令可能产生多次缺页中断
1、找到页表项时需要检查页面是否在内存中 2、若页面不在内存中，需要请求调页 3、若内存空间不够，还需要换出页面 4、页面调入内存后，需要修改相应表项 页面置换算法 进程运行过程中，所访问的页面不在内存，需要把它们调入内存。但内存已无空闲空间。因此系统必须用算法决定将哪个页面调出。
最佳置换算法 淘汰永远不使用，在长时间内不再被访问的页面
先进先出（FIFO） 淘汰最早进入内存的页面
把调入内存的页面先后顺序排成一个队列。需要换出页面时选择队头页面即可
最近最久未使用置换算法（LRU） 淘汰最近最久未使用的页面
时钟置换算法（CLOCK，最近未使用） 简单CLOCK算法：为每个页面设置访问位，将内存的页面通过链接指针链接成一个循环队列
改进型CLOCK算法：考虑到修改的页面替换成本更大（要写入外存）
除了考虑页面最近没有访问过之外，还应考虑有没有修改过，应先淘汰没有修改过的页面，避免I/O操作。用（访问位，修改位）表示各页面形态
后宫方式打开CLOCK算法
1、首先找（0，0）表示未访问，未修改 2、再退而求其次，找（0，1）表示未访问，已修改，*找的过程中把访问位都置为0 3、若前两个都找不到，先把每个访问位都置0，再去首先找（0，0），还找不到再去重复第二步 总结 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6627a3393090b27437be8ad068f7259e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-05T17:24:33+08:00" />
<meta property="article:modified_time" content="2022-11-05T17:24:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">操作系统-虚拟存储技术</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>虚拟存储器</h4> 
 <ul><li><a href="#_1" rel="nofollow">虚拟存储器</a></li><li><ul><li><a href="#_4" rel="nofollow">传统存储管理方式</a></li><li><a href="#_20" rel="nofollow">局部性原理</a></li><li><a href="#_47" rel="nofollow">虚拟内存技术</a></li><li><ul><li><a href="#_54" rel="nofollow">请求分页</a></li><li><ul><li><a href="#_69" rel="nofollow">缺页中断</a></li></ul> 
    </li><li><a href="#_83" rel="nofollow">页面置换算法</a></li><li><ul><li><a href="#_85" rel="nofollow">最佳置换算法</a></li><li><a href="#FIFO_88" rel="nofollow">先进先出（FIFO）</a></li><li><a href="#LRU_92" rel="nofollow">最近最久未使用置换算法（LRU）</a></li><li><a href="#CLOCK_95" rel="nofollow">时钟置换算法（CLOCK，最近未使用）</a></li><li><a href="#_116" rel="nofollow">总结</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>虚拟存储器</h2> 
<p>当用户看到自己程序能在系统中正常运行，他会认为，该系统所具有的内存容量一定比自己程序大，但用户所看到的大容量只是一种错觉，是虚的，所以人们把这样的存储器称为<code>虚拟存储器</code></p> 
<h3><a id="_4"></a>传统存储管理方式</h3> 
<p><code>传统存储管理方式特征、缺点</code>：<br> <img src="https://images2.imgbox.com/9e/04/uoksfwh4_o.png" alt="在这里插入图片描述"><br> <code>特征</code>：<br> <code>一次性</code>：作业必须一次性全部装入内存后才能开始运行</p> 
<pre><code class="prism language-python"><span class="token number">1</span>、作业很大，不能全部装入内存，导致大作业无法运行
<span class="token number">2</span>、只有少量作业能运行，导致多道程序并发度下降
</code></pre> 
<p><code>驻留性</code>：一旦作业被放入内存，就会一直驻留在内存中，直至作业结束。事实上一个时间段，只需访问作业一小部分数据即可正常运行（<code>GTA场景</code>）。</p> 
<pre><code class="prism language-python"><span class="token number">1</span>、浪费资源
</code></pre> 
<hr> 
<h3><a id="_20"></a>局部性原理</h3> 
<p><img src="https://images2.imgbox.com/df/18/ip1MAOH0_o.png" alt="在这里插入图片描述"><br> <code>如何应用</code>：<br> 高速缓冲思想：将近期会频繁访问到的数据放到更高速的存储器当中，暂时不用的数据放到更低速的存储器中。<br> 基于局部性原理：</p> 
<pre><code class="prism language-python">程序装入时可以将很快会用到的部分装入内存中，暂时不用的部分留在外存。
执行过程中，由操作系统负责将信息从外存调入内存中，然后继续执行程序。
内存空间不够，由操作系统负责将内存中暂时不用的信息换出到外存
</code></pre> 
<p>在操作系统的管理下，用户看来似乎有一个比实际大的多的内存，叫做<code>虚拟内存</code></p> 
<p>虚拟内存只是在逻辑上进行了扩充</p> 
<p><img src="https://images2.imgbox.com/51/5d/PePlFzyk_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/2d/7e/leoOJolL_o.png" alt="在这里插入图片描述"><br> <code>三个特征</code></p> 
<p><img src="https://images2.imgbox.com/2b/2d/XCowPOWn_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/9c/c9/5oEfwIL5_o.png" alt="下·"></p> 
<h3><a id="_47"></a>虚拟内存技术</h3> 
<p>建立在<code>离散分配</code>的内存管理分配基础上</p> 
<h4><a id="_54"></a>请求分页</h4> 
<p>在基本分页的基础上增加了几个<code>表项</code>：</p> 
<pre><code class="prism language-python"><span class="token number">1</span>、状态位：表示页面是否已在内存中（只有调入内存才能根据表项块号得出最终物理地址，不在的话在外存）
<span class="token number">2</span>、访问字段：记录最近被访问过几次，或记录上次访问的时间，供置换算法换出页面做参考
<span class="token number">3</span>、修改位：表示页面调入内存后是否被修改过，
由于内存中每一页都在外存上有副本，若未被修改，不需要将该页写回到外存。若被修改，则需要写到外存上
<span class="token number">4</span>、外存地址：页面在外存中存放的位置
</code></pre> 
<p><img src="https://images2.imgbox.com/ee/94/09kXu1MO_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/a7/96/yg7wbiYm_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_69"></a>缺页中断</h5> 
<p>如果一个页面未调入内存则会产生缺页中断信号<br> 属于内中断<br> 一条指令可能产生多次缺页中断</p> 
<pre><code class="prism language-python"><span class="token number">1</span>、找到页表项时需要检查页面是否在内存中
<span class="token number">2</span>、若页面不在内存中，需要请求调页
<span class="token number">3</span>、若内存空间不够，还需要换出页面
<span class="token number">4</span>、页面调入内存后，需要修改相应表项
</code></pre> 
<p><img src="https://images2.imgbox.com/c3/26/FJiwIhmR_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h4><a id="_83"></a>页面置换算法</h4> 
<p>进程运行过程中，所访问的页面不在内存，需要把它们调入内存。但内存已无空闲空间。因此系统必须用算法决定将哪个页面调出。</p> 
<h5><a id="_85"></a>最佳置换算法</h5> 
<p>淘汰<code>永远不使用</code>，在<code>长时间内不再被访问</code>的页面<br> <img src="https://images2.imgbox.com/da/40/MmTpLcvK_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="FIFO_88"></a>先进先出（FIFO）</h5> 
<p>淘汰<code>最早进入内存的页面</code><br> 把调入内存的页面先后顺序排成一个队列。需要换出页面时选择队头页面即可<br> <img src="https://images2.imgbox.com/df/7d/oWXGXPGy_o.jpg" alt="在这里插入图片描述"></p> 
<h5><a id="LRU_92"></a>最近最久未使用置换算法（LRU）</h5> 
<p>淘汰<code>最近最久未使用的页面</code><br> <img src="https://images2.imgbox.com/79/0c/kqPcCR9n_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="CLOCK_95"></a>时钟置换算法（CLOCK，最近未使用）</h5> 
<p><code>简单CLOCK算法</code>：为每个页面设置<code>访问位</code>，将内存的页面通过链接指针链接成<code>一个循环队列</code><br> <img src="https://images2.imgbox.com/6c/b6/nE4Iv7b5_o.jpg" alt="在这里插入图片描述"></p> 
<p><code>改进型CLOCK算法</code>：<strong>考虑到修改的页面替换成本更大（要写入外存）</strong><br> 除了考虑页面最近没有访问过之外，还应考虑有没有修改过，应先淘汰没有修改过的页面，避免I/O操作。用（访问位，修改位）表示各页面形态</p> 
<p><a href="https://www.bilibili.com/video/BV1QF411A7c3/?spm_id_from=333.337.search-card.all.click&amp;vd_source=d060356bf7da52ca92592e74038d1ea9" rel="nofollow">后宫方式打开CLOCK算法</a><br> <img src="https://images2.imgbox.com/fb/7a/v90WdhDO_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-python"><span class="token number">1</span>、首先找（<span class="token number">0</span>，<span class="token number">0</span>）表示未访问，未修改
<span class="token number">2</span>、再退而求其次，找（<span class="token number">0</span>，<span class="token number">1</span>）表示未访问，已修改，<span class="token operator">*</span>找的过程中把访问位都置为<span class="token number">0</span>
<span class="token number">3</span>、若前两个都找不到，先把每个访问位都置<span class="token number">0</span>，再去首先找（<span class="token number">0</span>，<span class="token number">0</span>），还找不到再去重复第二步
</code></pre> 
<p><img src="https://images2.imgbox.com/05/24/pa5HYZEN_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_116"></a>总结</h5> 
<p><img src="https://images2.imgbox.com/0b/c3/LRSkhzfs_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fa940db672abea9ecd1d7fef97207eca/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python批量数据处理脚本——批量删除文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e8f9c7d414530ca5c3ae4b646506562e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">自学PR剪辑03</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>