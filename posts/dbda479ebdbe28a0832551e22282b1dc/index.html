<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CommonJS 和 ES6 Module 究竟有什么区别？ - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CommonJS 和 ES6 Module 究竟有什么区别？" />
<meta property="og:description" content="CommonJS 和 ES6 Module 究竟有什么区别？
作为前端开发者，你是否也曾有过疑惑，为什么可以代码中可以直接使用 require 方法加载模块，为什么加载第三方包的时候 Node 会知道选择哪个文件作为入口，以及常被问到的，为什么 ES6 Module export 基础数据类型的时候会有【引用类型】的效果？
带着这些疑问和好奇，希望阅读这篇文章能解答你的疑惑。
CommonJS 规范 在 ES6 之前，ECMAScript 并没有提供代码组织的方式，那时候通常是基于 IIFE 来实现“模块化”，随着 JavaScript 在前端大规模的应用，以及服务端 Javascript 的推动，原先浏览器端的模块规范不利于大规模应用。于是早期便有了 CommonJS 规范，其目标是为了定义模块，提供通用的模块组织方式。
模块定义和使用 在 Commonjs 中，一个文件就是一个模块。定义一个模块导出通过 exports 或者 module.exports 挂载即可。
exports.count = 1; 导入一个模块也很简单，通过 require 对应模块拿到 exports 对象。
const counter = require(&#39;./counter&#39;); console.log(counter.count); CommonJS 的模块主要由原生模块 module 来实现，这个类上的一些属性对我们理解模块机制有很大帮助。
Module { id: &#39;.&#39;, // 如果是 mainModule id 固定为 &#39;.&#39;，如果不是则为模块绝对路径 exports: {}, // 模块最终 exports filename: &#39;/absolute/path/to/entry." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/dbda479ebdbe28a0832551e22282b1dc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-23T09:00:35+08:00" />
<meta property="article:modified_time" content="2020-06-23T09:00:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CommonJS 和 ES6 Module 究竟有什么区别？</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <h3></h3> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/c8/50/RxrhLeou_o.png"></p> 
 <h3>CommonJS 和 ES6 Module 究竟有什么区别？<br></h3> 
 <p>作为前端开发者，你是否也曾有过疑惑，为什么可以代码中可以直接使用 <code>require</code> 方法加载模块，为什么加载第三方包的时候 Node 会知道选择哪个文件作为入口，以及常被问到的，为什么 ES6 Module export 基础数据类型的时候会有【引用类型】的效果？</p> 
 <p>带着这些疑问和好奇，希望阅读这篇文章能解答你的疑惑。</p> 
 <h3>CommonJS 规范</h3> 
 <p>在 ES6 之前，ECMAScript 并没有提供代码组织的方式，那时候通常是基于 IIFE 来实现“模块化”，随着 JavaScript 在前端大规模的应用，以及服务端 Javascript 的推动，原先浏览器端的模块规范不利于大规模应用。于是早期便有了 CommonJS 规范，其目标是为了定义模块，提供通用的模块组织方式。</p> 
 <h4>模块定义和使用</h4> 
 <p>在 Commonjs 中，一个文件就是一个模块。定义一个模块导出通过 <code>exports</code> 或者 <code>module.exports</code> 挂载即可。</p> 
 <pre class="has"><code class="language-go">exports.count = 1;
</code></pre> 
 <p>导入一个模块也很简单，通过 <code>require</code> 对应模块拿到 <code>exports</code> 对象。</p> 
 <pre class="has"><code class="language-go">const counter = require('./counter');
console.log(counter.count);
</code></pre> 
 <p>CommonJS 的模块主要由原生模块 module 来实现，这个类上的一些属性对我们理解模块机制有很大帮助。</p> 
 <pre class="has"><code class="language-go">Module {
  id: '.', // 如果是 mainModule id 固定为 '.'，如果不是则为模块绝对路径
  exports: {}, // 模块最终 exports
  filename: '/absolute/path/to/entry.js', // 当前模块的绝对路径
  loaded: false, // 模块是否已加载完毕
  children: [], // 被该模块引用的模块
  parent: '', // 第一个引用该模块的模块
  paths: [ // 模块的搜索路径
   '/absolute/path/to/node_modules',
   '/absolute/path/node_modules',
   '/absolute/node_modules',
   '/node_modules'
  ]
}
</code></pre> 
 <h4>require 从哪里来？</h4> 
 <p>在编写 CommonJS 模块的时候，我们会使用 <code>require</code> 来加载模块，使用 <code>exports</code> 来做模块输出，还有 <code>module</code>，<code>__filename</code>, <code>__dirname</code> 这些变量，为什么它们不需要引入就能使用？</p> 
 <p>原因是 Node 在解析 JS 模块时，会先按文本读取内容，然后将模块内容进行包裹，在外层裹了一个 function，传入变量。再通过 <code>vm.runInThisContext</code> 将字符串转成 <code>Function</code>形成作用域，避免全局污染。</p> 
 <pre class="has"><code class="language-go">let wrap = function(script) {
  return Module.wrapper[0] + script + Module.wrapper[1];
};

const wrapper = [
  '(function (exports, require, module, __filename, __dirname) { ',
  '\n});'
];
</code></pre> 
 <p>于是在 CommmonJS 的模块中可以不需要 require，直接访问到这些方法，变量。</p> 
 <p>参数中的 <code>module</code> 是当前模块的的 <code>module</code> 实例（尽管这个时候模块代码还没编译执行），<code>exports</code> 是 <code>module.exports</code> 的别名，最终被 <code>require</code> 的时候是输出 <code>module.exports</code> 的值。<code>require</code> 最终调用的也是 Module._load 方法。<code>__filename，__dirname</code> 则分别是当前模块在系统中的绝对路径和当前文件夹路径。</p> 
 <h4>模块的查找过程</h4> 
 <p>开发者在使用 require 时非常简单，但实际上为了兼顾各种写法，不同类型的模块，<code>node_module</code>s packages 等模块的查找过程稍微有点麻烦。</p> 
 <p>首先，在创建模块对象时，会有 paths 属性，其值是由当前文件路径计算得到的，从当前目录一直到系统根目录的 <code>node_modules</code>。可以在模块中打印 <code>module.paths</code> 看看。</p> 
 <pre class="has"><code class="language-go">[ 
  '/Users/evan/Desktop/demo/node_modules',
  '/Users/evan/Desktop/node_modules',
  '/Users/evan/node_modules',
  '/Users/node_modules',
  '/node_modules'
]
</code></pre> 
 <p>除此之外，还会查找全局路径（如果存在的话）</p> 
 <pre class="has"><code class="language-go">[
  execPath/../../lib/node_modules, // 当前 node 执行文件相对路径下的 lib/node_modules
  NODE_PATH, // 全局变量 NODE_PATH
  HOME/.node_modules, // HOME 目录下的 .node_module
  HOME/.node_libraries' // HOME 目录下的 .node-libraries
]
</code></pre> 
 <p>按照官方文档给出的查找过程已经足够详细，这里只给出大概流程。</p> 
 <pre class="has"><code class="language-go">从 Y 路径运行 require(X)

1. 如果 X 是内置模块（比如 require('http'）)
&amp;emsp;&amp;emsp;a. 返回该模块。
&amp;emsp;&amp;emsp;b. 不再继续执行。

2. 如果 X 是以 '/' 开头、
   a. 设置 Y 为 '/'

3. 如果 X 是以 './' 或 '/' 或 '../' 开头
   a. 依次尝试加载文件，如果找到则不再执行
      - (Y + X)
      - (Y + X).js
      - (Y + X).json
      - (Y + X).node
   b. 依次尝试加载目录，如果找到则不再执行
      - (Y + X + package.json 中的 main 字段).js
      - (Y + X + package.json 中的 main 字段).json
      - (Y + X + package.json 中的 main 字段).node
&amp;emsp;&amp;emsp;c. 抛出 "not found"
4. 遍历 module paths 查找，如果找到则不再执行
5. 抛出 "not found"
</code></pre> 
 <p>模块查找过程会将软链替换为系统中的真实路径，例如 <code>lib/foo/node_moduels/bar</code> 软链到 <code>lib/bar，bar</code> 包中又 require('quux')，最终运行 foo module 时，require('quux') 的查找路径是 <code>lib/bar/node_moduels/quux</code> 而不是 <code>lib/foo/node_moduels/quux</code>。</p> 
 <h4>模块加载相关</h4> 
 <h5>MainModule</h5> 
 <p>当运行 <code>node index.js</code> 时，Node 调用 Module 类上的静态方法 <code>_load(process.argv[1])</code>加载这个模块，并标记为主模块，赋值给 <code>process.mainModule</code> 和 <code>require.main</code>，可以通过这两个字段判断当前模块是主模块还是被 <code>require</code> 进来的。</p> 
 <p><code>CommonJS</code> 规范是在代码运行时同步阻塞性地加载模块，在执行代码过程中遇到 <code>require(X)</code>时会停下来等待，直到新的模块加载完成之后再继续执行接下去的代码。</p> 
 <p>虽说是同步阻塞性，但这一步实际上非常快，和浏览器上阻塞性下载、解析、执行 <code>js</code> 文件不是一个级别，硬盘上读文件比网络请求快得多。</p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/c6/71/8l7fgZs2_o.png"></p> 
 <h5>缓存和循环引用</h5> 
 <p>文件模块查找挺耗时的，如果每次 require 都需要重新遍历文件夹查找，性能会比较差；还有在实际开发中，模块可能包含<strong>副作用</strong>代码，例如在模块顶层执行 <code>addEventListener</code> ，如果 require 过程中被重复执行多次可能会出现问题。</p> 
 <p><code>CommonJS</code> 中的缓存可以解决重复查找和重复执行的问题。模块加载过程中会以模块绝对路径为 <code>key</code>, <code>module</code> 对象为 <code>value</code> 写入 <code>cache</code>。在读取模块的时候会优先判断是否已在缓存中，如果在，直接返回 <code>module.exports</code>；如果不在，则会进入模块查找的流程，找到模块之后再写入 <code>cache</code>。</p> 
 <pre class="has"><code class="language-go">// a.js
module.exports = {
    foo: 1,
};

// main.js
const a1 = require('./a.js');
a1.foo = 2;

const a2 = require('./a.js');

console.log(a2.foo); // 2
console.log(a1 === a2); // true
</code></pre> 
 <p>以上例子中，<code>require a.js</code> 并修改其中的 <code>foo</code> 属性，接着再次 <code>require a.js</code> 可以看到两次 <code>require</code> 结果是一样的。</p> 
 <p>模块缓存可以打印 <code>require.cache</code> 进行查看。</p> 
 <pre class="has"><code class="language-go">{ 
    '/Users/evan/Desktop/demo/main.js': 
       Module {
         id: '.',
         exports: {},
         parent: null,
         filename: '/Users/evan/Desktop/demo/main.js',
         loaded: false,
         children: [ [Object] ],
         paths: 
          [ '/Users/evan/Desktop/demo/node_modules',
            '/Users/evan/Desktop/node_modules',
            '/Users/evan/node_modules',
            '/Users/node_modules',
            '/node_modules'
          ]
       },
  '/Users/evan/Desktop/demo/a.js': 
       Module {
         id: '/Users/evan/Desktop/demo/a.js',
         exports: { foo: 1 },
         parent: 
          Module {
            id: '.',
            exports: {},
            parent: null,
            filename: '/Users/evan/Desktop/demo/main.js',
            loaded: false,
            children: [Array],
            paths: [Array] },
         filename: '/Users/evan/Desktop/demo/a.js',
         loaded: true,
         children: [],
         paths: 
          [ '/Users/evan/Desktop/demo/node_modules',
            '/Users/evan/Desktop/node_modules',
            '/Users/evan/node_modules',
            '/Users/node_modules',
            '/node_modules' ] } }
</code></pre> 
 <p>缓存还解决了循环引用的问题。举个例子，现在有模块 a require 模块 b；而模块 b 又 require 了模块 a。</p> 
 <pre class="has"><code class="language-go">// main.js
const a = require('./a');
console.log('in main, a.a1 = %j, a.a2 = %j', a.a1, a.a2);

// a.js
exports.a1 = true;
const b = require('./b.js');
console.log('in a, b.done = %j', b.done);
exports.a2 = true;

// b.js
const a = require('./a.js');
console.log('in b, a.a1 = %j, a.a2 = %j', a.a1, a.a2);
</code></pre> 
 <p>程序执行结果如下：</p> 
 <pre class="has"><code class="language-go">in b, a.a1 = true, a.a2 = undefined
in main, a.a1 = true, a.a2 = true
</code></pre> 
 <p>实际上在模块 a 代码执行之前就已经创建了 Module 实例写入了缓存，此时代码还没执行，exports 是个<strong>空对象</strong>。</p> 
 <pre class="has"><code class="language-go">'/Users/evan/Desktop/module/a.js': 
   Module {
     exports: {},
     //...
  }
}
</code></pre> 
 <p>代码 <code>exports.a1 = true</code>; 修改了 <code>module.exports</code> 上的 <code>a1</code> 为 <code>true</code>, 这时候 <code>a2</code> 代码还没执行。</p> 
 <pre class="has"><code class="language-go">'/Users/evan/Desktop/module/a.js': 
   Module {
     exports: {
      a1: true
    }
     //...
  }
}
</code></pre> 
 <p>进入<code>b</code>模块，<code>require a.js</code> 时发现缓存上已经存在了，获取 <code>a</code> 模块上的 <code>exports</code> 。打印 <code>a1</code>, <code>a2</code> 分别是<code>true</code>，和 <code>undefined</code>。</p> 
 <p>运行完 <code>b</code> 模块，继续执行 <code>a</code> 模块剩余的代码，<code>exports.a2 = true</code>; 又往 <code>exports</code> 对象上增加了<code>a2</code>属性，此时 <code>module a</code> 的 <code>export</code>对象 <code>a1</code>, <code>a2</code> 均为 <code>true</code>。</p> 
 <pre class="has"><code class="language-go">exports: { 
  a1: true,
  a2: true
}
</code></pre> 
 <p>再回到 <code>main</code> 模块，由于 require('./a.js') 得到的是 <code>module a export</code> 对象的引用，这时候打印 <code>a1</code>, <code>a2</code> 就都为 <code>true</code>。</p> 
 <p><strong>小结</strong>：</p> 
 <p><code>CommonJS</code> 模块加载过程是同步阻塞性地加载，在模块代码被运行前就已经写入了 <code>cache</code>，同一个模块被多次 <code>require</code> 时只会执行一次，重复的 <code>require</code> 得到的是相同的 <code>exports</code> 引用。</p> 
 <p>值得留意：<code>cache key</code> 使用的是模块在系统中的绝对位置，由于模块调用位置的不同，相同的 <code>require('foo')</code>代码并不能保证返回的是统一个对象引用。我之前恰巧就遇到过，两次 <code>require('egg-core')</code>但是他们并不相等。</p> 
 <h3>ES6 模块</h3> 
 <p><code>ES6</code> 模块是前端开发同学更为熟悉的方式，使用 <code>import</code>, <code>export</code> 关键字来进行模块输入输出。<code>ES6</code> 不再是使用闭包和函数封装的方式进行模块化，而是从语法层面提供了模块化的功能。</p> 
 <p><code>ES6</code> 模块中不存在 <code>require</code>, <code>module.exports</code>, <code>__filename</code> 等变量，<code>CommonJS</code> 中也不能使用 <code>import</code>。两种规范是不兼容的，一般来说平日里写的 <code>ES6</code> 模块代码最终都会经由 <code>Babel</code>, <code>Typescript</code> 等工具处理成 CommonJS 代码。</p> 
 <p>使用 <code>Node</code> 原生 <code>ES6</code> 模块需要将 <code>js</code> 文件后缀改成 <code>mjs</code>，或者 <code>package.json "type"`` 字段改为 "module"，通过这种形式告知</code>Node<code>使用</code>ES Module` 的形式加载模块。</p> 
 <h4>ES6 模块 加载过程</h4> 
 <p>ES6 模块的加载过程分为三步：</p> 
 <h5>1. 查找，下载，解析，构建所有模块实例。</h5> 
 <p>ES6 模块会在程序开始前先根据模块关系查找到所有模块，生成一个无环关系图，并将所有模块实例都创建好，这种方式天然地避免了循环引用的问题，当然也有模块加载缓存，重复 import 同一个模块，只会执行一次代码。</p> 
 <h5>2. 在内存中腾出空间给即将 export 的内容（此时尚未写入 export value）。然后使 import 和 export 指向内存中的这些空间，这个过程也叫连接。</h5> 
 <p>这一步完成的工作是 <code>living binding import export</code>，借助下面的例子来帮助理解。</p> 
 <pre class="has"><code class="language-go">// counter.js
let count = 1;

function increment () {
  count++;
}

module.exports = {
  count,
  increment
}

// main.js
const counter = require('counter.cjs');

counter.increment();
console.log(counter.count); // 1
</code></pre> 
 <p>上面 <code>CommonJS</code> 的例子执行结果很好理解，修改 <code>count++`` 修改的是模块内的基础数据类型变量，不会改变</code>exports.count`，所以打印结果认为 1。</p> 
 <pre class="has"><code class="language-go">// counter.mjs
export let count = 1;

export function increment () {
  count++;
}

// main.mjs
import { increment, count } from './counter.mjs'

increment();
console.log(count); // 2
</code></pre> 
 <p>从结果上看使用 <code>ES6</code> 模块的写法，当 <code>export</code> 的变量被修改时，会影响 <code>import</code> 的结果。这个功能的实现就是 <code>living binding</code>，具体规范底层如何实现可以暂时不管，但是知道 <code>living binding</code> 比网上文章描述为 "ES6 模块输出的是值的引用" 更好理解。</p> 
 <p>更接近 ES6 模块的 CommonJS 代码可以是下面这样：</p> 
 <pre class="has"><code class="language-go">exports.counter = 1;

exports.increment = function () {
    exports.counter++;
}
</code></pre> 
 <h5>3. 运行模块代码将变量的实际值填写在第二步生成的空间中。</h5> 
 <p>到第三步，会基于第一步生成的无环图进行深度优先后遍历填值，如果这个过程中访问了尚未初始化完成的空间，会抛出异常。</p> 
 <pre class="has"><code class="language-go">// a.mjs
export const a1 = true;
import * as b from './b.mjs';
export const a2 = true;

// b.mjs
import { a1, a2 } from './a.mjs'
console.log(a1, a2);
</code></pre> 
 <p>上面的例子会在运行时抛出异常 <code>ReferenceError: Cannot access 'a1' before initialization</code>。如果改成 <code>import * as a from 'a.mjs'</code>可以看到 a 模块中 <code>export</code> 的对象已经占好坑了。</p> 
 <pre class="has"><code class="language-go">// b.mjs
import * as a from './a.mjs'
console.log(a);
</code></pre> 
 <p>将输出 { a1:, a2:} 可以看出，ES6 模块为 export 的变量预留了空间，不过尚未赋值。这里和 CommonJS 不一样，CommonJS 到这里是知道 a1 为 true, a2 为 undefined</p> 
 <p>除此之外，我们还能推导出一些 ES6 模块和 CommonJS 的差异点：</p> 
 <p><code>CommonJS</code> 可以在运行时使用变量进行 <code>require</code>, 例如 <code>require(path.join('xxxx', 'xxx.js'))</code>，而静态 <code>import</code> 语法（还有动态 import，返回 Promise）不行，因为 <code>ES6</code> 模块会先解析所有模块再执行代码。</p> 
 <p><code>require</code> 会将完整的 <code>exports</code> 对象引入，<code>import</code> 可以只 <code>import</code> 部分必要的内容，这也是为什么使用 <code>Tree Shaking</code> 时必须使用 ES6 模块 的写法。import 另一个模块没有 <code>export</code> 的变量，在代码执行前就会报错，而 CommonJS 是在模块运行时才报错。</p> 
 <h4>为什么平时开发可以混写？</h4> 
 <p>前面提到 <code>ES6</code> 模块和 <code>CommonJS</code> 模块有很大差异，不能直接混着写。这和开发中表现是不一样的，原因是开发中写的 <code>ES6</code> 模块最终都会被打包工具处理成 <code>CommonJS</code> 模块，以便兼容更多环境，同时也能和当前社区普通的 <code>CommonJS</code> 模块融合。</p> 
 <p>在转换的过程中会产生一些困惑，比如说：</p> 
 <h5>__esModule 是什么？干嘛用的？</h5> 
 <p>使用转换工具处理 <code>ES6</code> 模块的时候，常看到打包之后出现 <code>__esModule</code> 属性，字面意思就是将其标记为 <code>ES6 Module</code>。这个变量存在的作用是为了方便在引用模块的时候加以处理。</p> 
 <p>例如 <code>ES6</code> 模块中的 <code>export default</code> 在转化成 CommonJS 时会被挂载到 <code>exports['default']</code> 上，当运行 <code>require('./a.js')</code> 时 是不能直接读取到 default 上的值的，为了和 ES6 中 <code>import a from './a.js'</code>的行为一致，会基于 <code>__esModule</code> 判断处理。</p> 
 <pre class="has"><code class="language-go">// a.js
export default 1;

// main.js
import a from './a';

console.log(a);
</code></pre> 
 <p>转化后</p> 
 <pre class="has"><code class="language-go">// a.js
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = 1;

// main.js
'use strict';

var _a = require('./a');

var _a2 = _interopRequireDefault(_a);

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

console.log(_a2.default);
</code></pre> 
 <p>a 模块 <code>export defualt</code> 会被转换成 <code>exports.default = 1</code>;，这也是平时前端项目开发中使用 <code>require</code> 为什么还常常需要 .<code>default</code> 才能取到目标值的原因。</p> 
 <p>接着当运行 <code>import a from './a.js'</code> 时，<code>es module</code> 预期的是返回 export 的内容。工具会将代码转换为 <code>_interopRequireDefault</code> 包裹，在里面判断是否为 esModule，是的话直接返回，如果是 <code>commonjs</code> 模块的话则包裹一层 <code>{default: obj}</code>，最后获取 <code>a</code> 的值时，也会被装换成 <code>_a1.default</code>。</p> 
 <h3>相关链接</h3> 
 <ul><li><p>https://nodejs.org/api/modules.html</p></li><li><p>https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/</p></li><li><p>https://segmentfault.com/a/1190000004940294</p></li><li><p>https://www.infoq.cn/article/nodejs-module-mechanism</p></li></ul> 
 <pre class="has"><code class="language-go">❤️爱心三连击1.看到这里了就点个在看支持下吧，你的「在看」是我创作的动力。
2.关注公众号程序员成长指北，「带你一起学Node」！
3.特殊阶段，带好口罩，做好个人防护。
4.添加微信【ikoala520】，拉你进技术交流群一起学习。



“在看转发”是最大的支持
</code></pre> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bf30b63769675eb665e7d37e4511af00/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VSCode Go Golang不能跳转到定义解决办法 (问题排查)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/564051e033ce5d9c1bfb88ee87760cf0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue全屏组件screenfull的使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>