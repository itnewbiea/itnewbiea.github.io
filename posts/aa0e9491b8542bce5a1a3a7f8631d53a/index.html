<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>React中的useEffect(副作用) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="React中的useEffect(副作用)" />
<meta property="og:description" content="目录
useEffect(副作用)介绍
useEffect(副作用)各种写法的调用时刻
1.写法一：没有依赖项时
父组件给子组件传值：
2.写法二:依赖项中有监听的值时
3.写法三：依赖项为空数组时
4.写法4：清除副作用写法(假如副作用是一个定时器,清除定时器,如果不清的话，会出现内存泄漏)
5.写法五：依赖项是一个函数的时候
注意点
useEffect(副作用)介绍 useEffect是用来使函数组件也可以进行副作用操作的。那么什么是副作用呢？
函数的副作用就是函数除了返回值外对外界环境造成的其它影响。举个例子，假如我们每次执行一个函数，该函数都会操作全局的一个变量，那么对全局变量的操作就是这个函数的副作用。而在React的世界里，我们的副作用大体可以分为两类，一类是调用浏览器的API，例如使用addEventListener来添加事件监听函数等，另外一类是发起获取服务器数据的请求，例如当用户组件挂载的时候去异步获取用户的信息等。
react官方的原话：
如果你熟悉 React class 的生命周期函数，你可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合。
componentDidMount 组件挂载
componentDidUpdate 组件更新
componentWillUnmount 组件将要摧毁
语法：
import {useEffect} from &#34;react&#34; useEffect(() =&gt; { /** 执行逻辑 */ }, dependencies) //dependencies是一个数组，是可选的 //或者： useEffect(effect?=&gt;clean?, dependencies?) useEffect的第一个参数 effect 是要执行的副作用函数，它可以是任意的用户自定义函数，用户可以在这个函数里面操作一些浏览器的API或者和外部环境进行交互,网络请求等，这个函数会在每次组件渲染完成之后被调用。useEffect可以有一个返回值,返回一个函数,系统在组件重新渲染之前调用,用于清除副作用(比如说副作用是定时器，return里面就可以写清除定时器的代码)。它第二个参数dependencies(依赖项)来限制该副作用的执行条件 useEffect(副作用)各种写法的调用时刻 1.写法一：没有依赖项时 useEffect所在组件每次渲染(包括首次)时都要调用:组件中任何变化都会执行(eg:useState解构出的state改了就会引发组件重新渲染，父组件给子组件传递属性的值改变,子组件中的useEffect就会执行)
//没有依赖项 useEffect(()=&gt;{ console.log(&#39;组件每次渲染时都要调用(页面每次刷新)&#39;); }) 组件生命周期里面有一种生命周期父组件给子组件传新的属性就会调用的生命周期函数，useEffect写法一就可以替代。
组件自身状态变化会调用beforeupdate和updated,useEffect写法一就可以替代。
父组件给子组件传值： 2.写法二:依赖项中有监听的值时 根据依赖项中监听的变量是否变化决定是否执行副作用，变了就执行，不变就不执行。
//依赖项中有值时 //页面首次渲染和父组件给子组件传的属性值和子组件自身的值改变(依赖项改变才会打印) useEffect(() =&gt; { console.log(&#39;页面首次渲染和依赖项改变的时候才会打印&#39;); },[num,props." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/aa0e9491b8542bce5a1a3a7f8631d53a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-16T14:57:13+08:00" />
<meta property="article:modified_time" content="2022-11-16T14:57:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">React中的useEffect(副作用)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="useEffect(%E5%89%AF%E4%BD%9C%E7%94%A8)%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#useEffect%28%E5%89%AF%E4%BD%9C%E7%94%A8%29%E4%BB%8B%E7%BB%8D" rel="nofollow">useEffect(副作用)介绍</a></p> 
<p id="useEffect(%E5%89%AF%E4%BD%9C%E7%94%A8)%E5%90%84%E7%A7%8D%E5%86%99%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E5%88%BB-toc" style="margin-left:0px;"><a href="#useEffect%28%E5%89%AF%E4%BD%9C%E7%94%A8%29%E5%90%84%E7%A7%8D%E5%86%99%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E5%88%BB" rel="nofollow">useEffect(副作用)各种写法的调用时刻</a></p> 
<p id="1.%E5%86%99%E6%B3%95%E4%B8%80%EF%BC%9A%E6%B2%A1%E6%9C%89%E4%BE%9D%E8%B5%96%E9%A1%B9%E6%97%B6-toc" style="margin-left:40px;"><a href="#1.%E5%86%99%E6%B3%95%E4%B8%80%EF%BC%9A%E6%B2%A1%E6%9C%89%E4%BE%9D%E8%B5%96%E9%A1%B9%E6%97%B6" rel="nofollow">1.写法一：没有依赖项时</a></p> 
<p id="%E7%88%B6%E7%BB%84%E4%BB%B6%E7%BB%99%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E7%88%B6%E7%BB%84%E4%BB%B6%E7%BB%99%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%EF%BC%9A" rel="nofollow">父组件给子组件传值：</a></p> 
<p id="%C2%A02.%E5%86%99%E6%B3%95%E4%BA%8C%3A%E4%BE%9D%E8%B5%96%E9%A1%B9%E4%B8%AD%E6%9C%89%E7%9B%91%E5%90%AC%E7%9A%84%E5%80%BC%E6%97%B6-toc" style="margin-left:40px;"><a href="#%C2%A02.%E5%86%99%E6%B3%95%E4%BA%8C%3A%E4%BE%9D%E8%B5%96%E9%A1%B9%E4%B8%AD%E6%9C%89%E7%9B%91%E5%90%AC%E7%9A%84%E5%80%BC%E6%97%B6" rel="nofollow"> 2.写法二:依赖项中有监听的值时</a></p> 
<p id="%C2%A03.%E5%86%99%E6%B3%95%E4%B8%89%EF%BC%9A%E4%BE%9D%E8%B5%96%E9%A1%B9%E4%B8%BA%E7%A9%BA%E6%95%B0%E7%BB%84%E6%97%B6-toc" style="margin-left:40px;"><a href="#%C2%A03.%E5%86%99%E6%B3%95%E4%B8%89%EF%BC%9A%E4%BE%9D%E8%B5%96%E9%A1%B9%E4%B8%BA%E7%A9%BA%E6%95%B0%E7%BB%84%E6%97%B6" rel="nofollow"> 3.写法三：依赖项为空数组时</a></p> 
<p id="4.%E5%86%99%E6%B3%954%EF%BC%9A%E6%B8%85%E9%99%A4%E5%89%AF%E4%BD%9C%E7%94%A8%E5%86%99%E6%B3%95(%E5%81%87%E5%A6%82%E5%89%AF%E4%BD%9C%E7%94%A8%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8%2C%E6%B8%85%E9%99%A4%E5%AE%9A%E6%97%B6%E5%99%A8%2C%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%B8%85%E7%9A%84%E8%AF%9D%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F)-toc" style="margin-left:40px;"><a href="#4.%E5%86%99%E6%B3%954%EF%BC%9A%E6%B8%85%E9%99%A4%E5%89%AF%E4%BD%9C%E7%94%A8%E5%86%99%E6%B3%95%28%E5%81%87%E5%A6%82%E5%89%AF%E4%BD%9C%E7%94%A8%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8%2C%E6%B8%85%E9%99%A4%E5%AE%9A%E6%97%B6%E5%99%A8%2C%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%B8%85%E7%9A%84%E8%AF%9D%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%29" rel="nofollow">4.写法4：清除副作用写法(假如副作用是一个定时器,清除定时器,如果不清的话，会出现内存泄漏)</a></p> 
<p id="5.%E5%86%99%E6%B3%95%E4%BA%94%EF%BC%9A%E4%BE%9D%E8%B5%96%E9%A1%B9%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E6%97%B6%E5%80%99-toc" style="margin-left:40px;"><a href="#5.%E5%86%99%E6%B3%95%E4%BA%94%EF%BC%9A%E4%BE%9D%E8%B5%96%E9%A1%B9%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E6%97%B6%E5%80%99" rel="nofollow">5.写法五：依赖项是一个函数的时候</a></p> 
<p id="%E6%B3%A8%E6%84%8F%E7%82%B9-toc" style="margin-left:0px;"><a href="#%E6%B3%A8%E6%84%8F%E7%82%B9" rel="nofollow">注意点</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="useEffect(%E5%89%AF%E4%BD%9C%E7%94%A8)%E4%BB%8B%E7%BB%8D">useEffect(副作用)介绍</h2> 
<p>useEffect是用来使函数组件也可以<strong>进行副作用操作</strong>的。那么什么是副作用呢？</p> 
<blockquote> 
 <p><strong>函数的副作用就是函数除了返回值外对外界环境造成的其它影响</strong>。举个例子，假如我们每次执行一个函数，该函数都会操作全局的一个变量，那么对全局变量的操作就是这个函数的副作用。而在React的世界里，我们的副作用大体可以分为两类，<strong>一类是调用浏览器的API</strong>，例如使用addEventListener来添加事件监听函数等，<strong>另外一类是发起获取服务器数据的请求</strong>，例如当用户组件挂载的时候去异步获取用户的信息等。</p> 
 <p>react官方的原话：</p> 
 <p>如果你熟悉 React class 的生命周期函数，你<strong>可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合。</strong></p> 
 <p>componentDidMount <strong>组件挂载</strong><br> componentDidUpdate <strong>组件更新</strong><br> componentWillUnmount <strong>组件将要摧毁</strong></p> 
</blockquote> 
<p>语法：</p> 
<pre><code class="language-javascript">import {useEffect} from "react"
useEffect(() =&gt; {
  /** 执行逻辑 */
  }, dependencies)  //dependencies是一个数组，是可选的

//或者：
useEffect(effect?=&gt;clean?, dependencies?)</code></pre> 
<p> useEffect的第一个参数 <strong>effect 是要执行的副作用函数</strong>，它可以是任意的用户自定义函数，用户可以在这个函数里面操作一些浏览器的API或者和外部环境进行交互,网络请求等，<strong>这个函数会在每次组件渲染完成之后被调用。useEffect可以有一个返回值,返回一个函数,系统在组件重新渲染之前调用,用于清除副作用</strong>(比如说副作用是定时器，return里面就可以写清除定时器的代码)。它<strong>第二个参数dependencies(依赖项)来限制该副作用的执行条件</strong>  </p> 
<h2 id="useEffect(%E5%89%AF%E4%BD%9C%E7%94%A8)%E5%90%84%E7%A7%8D%E5%86%99%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E5%88%BB">useEffect(副作用)各种写法的调用时刻</h2> 
<h3 id="1.%E5%86%99%E6%B3%95%E4%B8%80%EF%BC%9A%E6%B2%A1%E6%9C%89%E4%BE%9D%E8%B5%96%E9%A1%B9%E6%97%B6">1.写法一：<strong>没有依赖项时</strong></h3> 
<p><strong>useEffect所在组件每次渲染(包括首次)时都要调用:组件中任何变化都会执行</strong>(eg:useState解构出的state改了就会引发组件重新渲染，父组件给子组件传递属性的值改变,子组件中的useEffect就会执行)</p> 
<pre><code class="language-javascript">  //没有依赖项
  useEffect(()=&gt;{
    console.log('组件每次渲染时都要调用(页面每次刷新)');
  })</code></pre> 
<blockquote> 
 <p><strong>组件生命周期里面有一种生命周期父组件给子组件传新的属性就会调用的生命周期函数</strong>，useEffect写法一就可以替代。</p> 
 <p>组件自身状态变化会调用<strong>beforeupdate</strong>和<strong>updated</strong>,useEffect写法一就可以替代。</p> 
</blockquote> 
<h4 id="%E7%88%B6%E7%BB%84%E4%BB%B6%E7%BB%99%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%EF%BC%9A"><strong>父组件给子组件传值：</strong></h4> 
<p><img alt="" height="632" src="https://images2.imgbox.com/32/51/ecuZTAny_o.png" width="790"></p> 
<p><img alt="" height="426" src="https://images2.imgbox.com/65/50/fe0GNGyV_o.png" width="687"></p> 
<h3 id="%C2%A02.%E5%86%99%E6%B3%95%E4%BA%8C%3A%E4%BE%9D%E8%B5%96%E9%A1%B9%E4%B8%AD%E6%9C%89%E7%9B%91%E5%90%AC%E7%9A%84%E5%80%BC%E6%97%B6"> 2.写法二:<strong>依赖项中有监听的值时</strong></h3> 
<p><strong>根据依赖项中监听的变量是否变化决定是否执行副作用，变了就执行，不变就不执行</strong>。</p> 
<pre><code class="language-javascript">    //依赖项中有值时
    //页面首次渲染和父组件给子组件传的属性值和子组件自身的值改变(依赖项改变才会打印)
    useEffect(() =&gt; {
        console.log('页面首次渲染和依赖项改变的时候才会打印');
    },[num,props.title])</code></pre> 
<p><img alt="" height="614" src="https://images2.imgbox.com/ec/df/nlKWiRnk_o.png" width="793"></p> 
<h3 id="%C2%A03.%E5%86%99%E6%B3%95%E4%B8%89%EF%BC%9A%E4%BE%9D%E8%B5%96%E9%A1%B9%E4%B8%BA%E7%A9%BA%E6%95%B0%E7%BB%84%E6%97%B6"> 3.写法三：<strong>依赖项为空数组时</strong></h3> 
<p>相当于Vue生命周期函数<strong>mounted</strong>,也就是页面首次渲染(挂载)后，后面不管组件中值咋改变都不会执行了，<strong>除非该组件销毁了再重新挂载时才会执行。</strong></p> 
<pre><code class="language-javascript">    useEffect(() =&gt; {
        console.log('页面首次渲染');
    },[])</code></pre> 
<p><img alt="" height="623" src="https://images2.imgbox.com/38/09/NsJ5S98V_o.png" width="818"></p> 
<h3 id="4.%E5%86%99%E6%B3%954%EF%BC%9A%E6%B8%85%E9%99%A4%E5%89%AF%E4%BD%9C%E7%94%A8%E5%86%99%E6%B3%95(%E5%81%87%E5%A6%82%E5%89%AF%E4%BD%9C%E7%94%A8%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8%2C%E6%B8%85%E9%99%A4%E5%AE%9A%E6%97%B6%E5%99%A8%2C%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%B8%85%E7%9A%84%E8%AF%9D%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F)">4.写法4：<strong>清除副作用写法</strong>(假如副作用是一个定时器,清除定时器,如果不清的话，会出现内存泄漏)</h3> 
<pre><code class="language-javascript">    useEffect(() =&gt; {
        let timer = setInterval(()=&gt;{
            console.log(66666);
        },1000)
        return ()=&gt;{
            //当组件下一次渲染前,执行这个函数:清除副作用(计时器就是一种副作用)
            console.log('当组件下一次渲染前,执行这个函数:清除副作用');
            clearInterval(timer);
        }
    })//这里没写依赖项，所以页面中的值改变就会刷新，比如useState解构出的state改变</code></pre> 
<p><img alt="" height="871" src="https://images2.imgbox.com/29/04/6OkjCC53_o.png" width="1200"> 问题：副作用函数不会有缓存，那为什么在副作用函数useEffect里面写了定时器，页面(组件)刷新之后上一个定时器没有清除？就非要写return 返回一个函数去清除副作用(定时器)</p> 
<h3 id="5.%E5%86%99%E6%B3%95%E4%BA%94%EF%BC%9A%E4%BE%9D%E8%B5%96%E9%A1%B9%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E6%97%B6%E5%80%99">5.写法五：依赖项是一个函数的时候</h3> 
<pre><code class="language-javascript">    let fn = ()=&gt;{
        console.log(11111111);
    }
    useEffect(() =&gt; {
        console.log('此组件渲染时,就会运行(包括首次渲染)');
        // 该组件渲染时(包括首次渲染)，就会执行副作用
        let timer = setInterval(()=&gt;{
            console.log(66666);
        },1000)
        return ()=&gt;{
            //而当该组件下一次运行(渲染)时，才会执行清除副作用函数(第一次渲染不执行(组件首次渲染时)，下一次渲染才执行)
            console.log('当组件下一次渲染前,执行这个函数:清除副作用');
            clearInterval(timer);
        }
    },[fn])</code></pre> 
<p><img alt="" height="446" src="https://images2.imgbox.com/ff/30/dlEZ5czL_o.png" width="577"> </p> 
<p> 分析：当依赖项 fn 函数运行的时候，副作用函数才会运行（先执行副作用函数的return返回的函数，把上一次渲染生成的定时器清除，才会执行副作用函数，重新生成一个定时器），但是return返回的函数不一定运行，因为return返回的函数必须要是在该组件下一次渲染时，才会执行。因为fn函数虽然执行，但是并没有引起组件重新渲染，所以并不会执行return返回的函数。</p> 
<p>缺点是：<strong>函数组件刷新时，函数fn又会重新生成一模一样的，没必要，会占用内存。</strong>有没有一种技术，在组件刷新时，这种像fn函数的，不重新生成，就用原来内存中的fn，就不用去重新开辟内存空间去生成函数fn。所以就用到了<strong>useCallback</strong></p> 
<p></p> 
<h2 id="%E6%B3%A8%E6%84%8F%E7%82%B9"><strong>注意点</strong></h2> 
<p><strong>1.</strong></p> 
<pre><code class="language-javascript">    //这种没依赖项
    let [data,setData] = useState('');
    useEffect(()=&gt;{
        //这里可以进行请求后台数据，但是不能通过setData()将请求回来的数据把页面刷新
        //会陷入死循环，页面一刷新 useEffect就会执行，就会请求后台数据，请求回来的数据又
        //通过setData()导致页面数据改变然后刷新，这样就会陷入死循环
        setData();
    })   

    //如果有依赖项的话，就不会陷入死循环</code></pre> 
<p>2.组件重新渲染时，会将那些非hook相关的数据重新生成一份，比如说，</p> 
<pre><code class="language-javascript">    let [num,setNum] = useState(100);  //hook相关的数据
    let m = 100;            //普通的数据
    let arr = [100,200,900];//普通的引用数据
    let fm = ()=&gt;{}         //普通的引用数据</code></pre> 
<p><img alt="" height="731" src="https://images2.imgbox.com/bb/02/8qHCR9G3_o.png" width="1200"> </p> 
<p> </p> 
<p>以use开头的那些hook组件刷新时不会重新生成，那些普通的数据会重新生成。如果依赖项是这种普通的arr,fm等引用数据，组件刷新时，就会重新生成，重新开辟内存空间生成，所以就会导致副作用函数执行，所以一般副作用函数的依赖项都是父组件给子组件传的属性或者useState解构出的state值这些。</p> 
<p> </p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/19d38bca71fdf4a342e97b7f0cd85c8d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">多种动态绑定class和style</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/17433e213c91bd7c1636c0ba82bcd47e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决错误syntax error near unexpected token `(‘</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>