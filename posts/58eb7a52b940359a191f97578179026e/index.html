<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker学习 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker学习" />
<meta property="og:description" content="架构 镜像:docker镜像,就相当于是一个root文件系统,比如官方镜像像ubuntu就包含了一套完整的ubuntu最小系统的root文件系统容器:镜像和容器的关系,就像是面向对象程序设计中的类和实例一样,镜像是静态的定义,容器是镜像运行时的实体.容器可以被创建 启动 停止 删除和暂停等仓库:仓库可以被看一个代码控制中心,用来保存镜像 docker使用客户端 服务器架构模式,使用远程api来管理和创建docker容器.docker容器通过docker镜像来创建
概念说明docker镜像(images)docker镜像是用于创建docker容器的模板,比如ubuntu系统docker容器(container)容器是独立运行的一个或一组应用,是镜像运行的实体docker客户端(client)docker客户端通过命令行或者其他工具使用docker sdk与docker的守护进行通信docker主机(host)一个物理或者虚拟的机器用于执行docker守护进程和容器docker registrydocker仓库用来保存镜像,可以理解为代码控制中的代码仓库,docker hub提供了庞大的镜像集合供使用.一个docekr registry中可以包含多个仓库,每个仓库可以包含多个标签,每个标签对应一个镜像,通常,一个仓库会包含同一个软件不同版本的进行,而标签就常用于对应该软件的各个版本.我们可以通过[仓库名]:[标签]的格式来指定具体是这个软件那个版本的镜像.如果不给出标签,将以latest作为默认标签docker machinedocker machine是一个简化docekr安装的命令行工具,通过一个简单的命令行即可在对应的平台上安装docker比如virtualbox digital ocean microsoft azure docker使用 docker helloworld docker允许你在容器内运行应用程序.在容器内运行一个应用程序并输出helloworld
docker run ubuntu:15.10 /bin/echo &#34;Hello world&#34; docker:docker的二进制执行文件run:与前面的docker组合来运行一个容器ubuntu15.10:指定要运行的镜像,docker首先从本地主机上查找镜像是否存在,如果不存在,docker就会从镜像仓库docker hub下载公共镜像/bin/echo “hello world”:在启动的容器里面执行的命令 以上命令的含义:docker以一个ubuntu15.10镜像创建一个新容器,然后再容器里面执行 /bin/echo “helloworld”,然后输出结果
交互式容器 通过docker的两个参数-i -t ,让docker运行的容器实现对话能力
docker run -i -t ubuntu:15.10 /bin/bash -t :在新容器内指定一个伪终端,或者终端
-i :允许你对容器内的标准输入(STDIN)进行交互
cat /proc/version 查看当前系统的版本信息
运行exit命令或者ctrl&#43;d来退出容器
后台启动容器 创建一个以进程方式运行的容器
docker run -d ubuntu:15.10 /bin/sh -c &#34;while true;do echo hello world;sleep 1; done&#34; 这个长字符串叫做容器的id,对每个容器来说都是唯一的,我们可以通过容器的id来查看对应的容器发生了什么." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/58eb7a52b940359a191f97578179026e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-07T12:35:40+08:00" />
<meta property="article:modified_time" content="2022-10-07T12:35:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker学习</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_2"></a>架构</h2> 
<ul><li>镜像:docker镜像,就相当于是一个root文件系统,比如官方镜像像ubuntu就包含了一套完整的ubuntu最小系统的root文件系统</li><li>容器:镜像和容器的关系,就像是面向对象程序设计中的类和实例一样,镜像是静态的定义,容器是镜像运行时的实体.容器可以被创建 启动 停止 删除和暂停等</li><li>仓库:仓库可以被看一个代码控制中心,用来保存镜像</li></ul> 
<p>docker使用客户端 服务器架构模式,使用远程api来管理和创建docker容器.docker容器通过docker镜像来创建</p> 
<table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>docker镜像(images)</td><td>docker镜像是用于创建docker容器的模板,比如ubuntu系统</td></tr><tr><td>docker容器(container)</td><td>容器是独立运行的一个或一组应用,是镜像运行的实体</td></tr><tr><td>docker客户端(client)</td><td>docker客户端通过命令行或者其他工具使用docker sdk与docker的守护进行通信</td></tr><tr><td>docker主机(host)</td><td>一个物理或者虚拟的机器用于执行docker守护进程和容器</td></tr><tr><td>docker registry</td><td>docker仓库用来保存镜像,可以理解为代码控制中的代码仓库,docker hub提供了庞大的镜像集合供使用.一个docekr registry中可以包含多个仓库,每个仓库可以包含多个标签,每个标签对应一个镜像,通常,一个仓库会包含同一个软件不同版本的进行,而标签就常用于对应该软件的各个版本.我们可以通过[仓库名]:[标签]的格式来指定具体是这个软件那个版本的镜像.如果不给出标签,将以latest作为默认标签</td></tr><tr><td>docker machine</td><td>docker machine是一个简化docekr安装的命令行工具,通过一个简单的命令行即可在对应的平台上安装docker比如virtualbox digital ocean microsoft azure</td></tr></tbody></table> 
<h2><a id="docker_19"></a>docker使用</h2> 
<h3><a id="docker_helloworld_21"></a>docker helloworld</h3> 
<p>docker允许你在容器内运行应用程序.在容器内运行一个应用程序并输出helloworld</p> 
<pre><code>docker run ubuntu:15.10 /bin/echo "Hello world"
</code></pre> 
<p><img src="https://images2.imgbox.com/40/5f/tUt5vjMH_o.png" alt="image-20220402145734140"></p> 
<ul><li>docker:docker的二进制执行文件</li><li>run:与前面的docker组合来运行一个容器</li><li>ubuntu15.10:指定要运行的镜像,docker首先从本地主机上查找镜像是否存在,如果不存在,docker就会从镜像仓库docker hub下载公共镜像</li><li>/bin/echo “hello world”:在启动的容器里面执行的命令</li></ul> 
<p>以上命令的含义:docker以一个ubuntu15.10镜像创建一个新容器,然后再容器里面执行 /bin/echo “helloworld”,然后输出结果</p> 
<h3><a id="_38"></a>交互式容器</h3> 
<p>通过docker的两个参数-i -t ,让docker运行的容器实现对话能力</p> 
<pre><code>docker run -i -t ubuntu:15.10 /bin/bash
</code></pre> 
<p><img src="https://images2.imgbox.com/33/1d/0VNKRN59_o.png" alt="image-20220402150556224"></p> 
<ul><li> <p>-t :在新容器内指定一个伪终端,或者终端</p> </li><li> <p>-i :允许你对容器内的标准输入(STDIN)进行交互</p> </li><li> <p>cat /proc/version 查看当前系统的版本信息</p> </li></ul> 
<p>运行exit命令或者ctrl+d来退出容器</p> 
<p><img src="https://images2.imgbox.com/7e/47/XuRqgn6r_o.png" alt="image-20220402150721370"></p> 
<h3><a id="_57"></a>后台启动容器</h3> 
<p>创建一个以进程方式运行的容器</p> 
<pre><code>docker run -d ubuntu:15.10 /bin/sh -c "while true;do echo hello world;sleep 1; done"
</code></pre> 
<p><img src="https://images2.imgbox.com/b8/a0/vrQogGOT_o.png" alt="image-20220402151020314"></p> 
<p>这个长字符串叫做容器的id,对每个容器来说都是唯一的,我们可以通过容器的id来查看对应的容器发生了什么.</p> 
<p>查看容器有无在运行</p> 
<pre><code>docker ps
</code></pre> 
<p><img src="https://images2.imgbox.com/2f/af/iw5tvLXQ_o.png" alt="image-20220402151202084"></p> 
<ul><li>container id 容器id</li><li>image:使用的镜像</li><li>command:启动容器时运行的命令</li><li>created:容器创建的时间</li><li>status:容器状态 
  <ol><li>created(创建中)</li><li>restarting(重启中)</li><li>running或者up(运行中)</li><li>removing(迁移中)</li><li>paused(暂停中)</li><li>exited(停止)</li><li>dead(死亡)</li></ol> </li><li>ports:容器端口信息和使用的连接类型(tcp\udp)</li><li>names:自动分配的容器名称</li></ul> 
<p>原始主机中查看容器内的标准输出</p> 
<pre><code>docker logs 52dfdf29ba58
</code></pre> 
<p><img src="https://images2.imgbox.com/2f/b6/5oaysZel_o.png" alt="image-20220402151756127"></p> 
<h3><a id="_100"></a>停止容器</h3> 
<pre><code>docker stop 52dfdf29ba58
</code></pre> 
<p><img src="https://images2.imgbox.com/0a/cb/rP4vdNiG_o.png" alt="image-20220402152049867"></p> 
<h2><a id="docker_108"></a>docker容器使用</h2> 
<h3><a id="docker_110"></a>docker客户端</h3> 
<p>查看docker客户端的所有命令选项</p> 
<pre><code>docker
</code></pre> 
<p><img src="https://images2.imgbox.com/ff/08/1clW7FrW_o.png" alt="image-20220402152217230"></p> 
<p>查看具体命令的更深用法,如stats指令的具体用法</p> 
<pre><code>docker stats --help
</code></pre> 
<p><img src="https://images2.imgbox.com/bf/fe/a2eqOcTE_o.png" alt="image-20220402152423646"></p> 
<h3><a id="_128"></a>容器获取</h3> 
<h4><a id="_130"></a>来取镜像</h4> 
<pre><code>docker pull ubuntu
</code></pre> 
<p><img src="https://images2.imgbox.com/ee/42/rnnEZI1d_o.png" alt="image-20220402161637099"></p> 
<h4><a id="_138"></a>启动容器</h4> 
<p>使用一个ubuntu镜像启动一个容器,以参数为命令行模式进入该容器</p> 
<pre><code>docker run -it ubuntu /bin/bash
</code></pre> 
<p><img src="https://images2.imgbox.com/5e/ed/kmaM6Dp7_o.png" alt="image-20220402161714895"></p> 
<ul><li>-i 交互式操作</li><li>-t 终端</li><li>ubuntu: ubuntu镜像</li><li>/bin/bash:放在镜像名后的是命令,这里我们希望有一个交互式的shell,因此使用的是/bin/bash</li></ul> 
<h4><a id="_153"></a>查看所有容器的命令</h4> 
<pre><code>docker ps -a
</code></pre> 
<p><img src="https://images2.imgbox.com/f4/37/TObjpwZt_o.png" alt="image-20220402161953071"></p> 
<h4><a id="_161"></a>启动一个已停止的容器</h4> 
<pre><code>docker start 
</code></pre> 
<p><img src="https://images2.imgbox.com/1b/21/RGcR46b4_o.png" alt="image-20220402162105643"></p> 
<h4><a id="_169"></a>后台运行</h4> 
<p>大部分场景下我们是希望docker服务是在后台运行的,我们可以使用-d指定容器的运行模式</p> 
<pre><code>docker run -itd --name ubuntu-test ubuntu /bin/bash
</code></pre> 
<p><img src="https://images2.imgbox.com/02/2c/qZa5kqWp_o.png" alt="image-20220402162500315"></p> 
<ul><li>-d 默认不会进入该容器,想要进入容器需要使用指令docker exec</li></ul> 
<h4><a id="_181"></a>停止一个容器</h4> 
<pre><code>docker stop [容器id]
</code></pre> 
<p><img src="https://images2.imgbox.com/07/ac/kWzQKO4W_o.png" alt="image-20220402162657540"></p> 
<h4><a id="docker_restart_189"></a>停止的容器通过docker restart重启</h4> 
<pre><code>docker restart [容器id]
</code></pre> 
<p><img src="https://images2.imgbox.com/8a/60/diRyS6v2_o.png" alt="image-20220402162756634"></p> 
<h4><a id="_197"></a>进入容器</h4> 
<p>在使用-d参数之后,容器启动后会进入后台,此时想要进入容器,可以通过以下指令进入</p> 
<ul><li>docker attach</li><li>docker exec : 推荐使用docker exec命令,因为此退出容器终端,不会导致容器的停止</li></ul> 
<p><strong>attach命令</strong></p> 
<pre><code>docker attach cd2c8040fba6
</code></pre> 
<p><img src="https://images2.imgbox.com/b4/ef/2op8UKtl_o.png" alt="image-20220402163101384"></p> 
<p>退出容器,会导致容器停止</p> 
<p><strong>exec命令</strong></p> 
<pre><code>docekr exec -it cd2c8040fba6 /bin/bash 
</code></pre> 
<p><img src="https://images2.imgbox.com/89/ad/RW63ZM0E_o.png" alt="image-20220402163247046"></p> 
<h4><a id="_222"></a>导出和导入容器</h4> 
<p>导出本地容器,使用docker export命令</p> 
<pre><code>docker export cd2c8040fba6 &gt; ubuntu.tar
</code></pre> 
<p><img src="https://images2.imgbox.com/29/ce/2K3lKIIB_o.png" alt="image-20220402163423630"></p> 
<h4><a id="_232"></a>导入容器快照</h4> 
<p>可以使用docker import从容器快照文件中在导入为镜像,以下将快照文件ubuntu.tar导入到镜像ubuntu:v1</p> 
<pre><code>cat ./ubuntu.tar | docker import - ubuntu:v1
</code></pre> 
<p><img src="https://images2.imgbox.com/61/60/C7HWfDW1_o.png" alt="image-20220402163749247"></p> 
<p>也可以通过指定url或者某个目录来导入</p> 
<pre><code>docker import http://example.com/exampleimage.tgz example/imagerepo
</code></pre> 
<h4><a id="_248"></a>删除容器</h4> 
<p>删除容器使用docker rm命令</p> 
<pre><code>docker rm -f cd2c8040fba6
</code></pre> 
<p><img src="https://images2.imgbox.com/b7/16/e6ZpDHKp_o.png" alt="image-20220402164056217"></p> 
<h4><a id="_258"></a>清理掉所有处于终止状态的容器</h4> 
<pre><code>docker container prune
</code></pre> 
<p><img src="https://images2.imgbox.com/f4/94/HhP4olVR_o.png" alt="image-20220402164208270"></p> 
<h3><a id="web_266"></a>web应用</h3> 
<h4><a id="web_268"></a>运行一个web应用</h4> 
<p>将在docker容器中运行一个python flask应用来运行一个web应用</p> 
<pre><code>docker pull training/webapp	#载入镜像
docker run -d -P training/webapp python app.py
</code></pre> 
<p><img src="https://images2.imgbox.com/bb/1e/pxlfkQvC_o.png" alt="image-20220402164624732"></p> 
<ul><li>-d 让容器在后台运行</li><li>-P 将容器内部使用的网络端口随机映射到我们使用的主机上</li></ul> 
<h4><a id="web_282"></a>查看web应用容器</h4> 
<pre><code>docker ps
</code></pre> 
<p><img src="https://images2.imgbox.com/ac/d3/ThHokVmT_o.png" alt="image-20220402164749541"></p> 
<p>多了端口信息 ports</p> 
<pre><code>0.0.0.0:49153-&gt;5000/tcp, :::49153-&gt;5000/tcp
</code></pre> 
<p>docker 开放了5000端口(默认python flask端口)映射到主机端口49153上</p> 
<p>我们通过浏览器访问web应用</p> 
<p><img src="https://images2.imgbox.com/31/cd/qZbF340e_o.png" alt="image-20220402164958913"></p> 
<p>也可以通过-p参数来设置不一样的端口</p> 
<pre><code>docker run -d -p 5000:5000 training/webapp python app.py
</code></pre> 
<p><img src="https://images2.imgbox.com/ba/a4/wbQzFZBP_o.png" alt="image-20220402165150285"></p> 
<p>容器内部的5000端口映射到我们本地主机的5000端口上</p> 
<h4><a id="_312"></a>网络端口的快捷方式</h4> 
<p>通过docker ps命令可以查看到容器的端口映射,docker还提供了另一个快捷方式docker port,使用docker post可以查看指定(id 或者 名字)容器的某个确定端口映射到本机的端口号.上面我们创建的容器id为18b8aa6acac6名字为naughty_kalam.我们可以使用</p> 
<pre><code>docker port 18b8aa6acac6
docker port naughty_kalam
</code></pre> 
<p><img src="https://images2.imgbox.com/1d/f6/8NOFk9Ow_o.png" alt="image-20220402165526615"></p> 
<h4><a id="web_323"></a>查看web应用程序日志</h4> 
<p>查看容器内部的标准输出</p> 
<pre><code>docker logs [id或名字] 
</code></pre> 
<p><img src="https://images2.imgbox.com/50/56/zGlfdCbe_o.png" alt="image-20220402165729496"></p> 
<ul><li>-f:让docker logs像使用tail -f 一样来输出容器内部的标准输出,从上面可以看出来应用程序使用的是5000端口并且能够看到应用程序的访问日志</li></ul> 
<h4><a id="web_335"></a>查看web应用程序容器的进程</h4> 
<p>查看容器内部运行的进程</p> 
<pre><code>docker top naughty_kalam
</code></pre> 
<p><img src="https://images2.imgbox.com/ac/05/VEk2Lm8N_o.png" alt="image-20220402170005894"></p> 
<h4><a id="web_345"></a>检查web应用程序</h4> 
<p>使用docker inspect 来查看docker的底层信息,它会返回一个json文件记录着docker容器的配置和状态信息</p> 
<pre><code>docker inspect naughty_kalam
</code></pre> 
<p><img src="https://images2.imgbox.com/0a/87/6PTl0HAY_o.png" alt="image-20220402170144100"></p> 
<h4><a id="web_355"></a>停止web应用容器</h4> 
<pre><code>docker stop friendly_perlman
</code></pre> 
<p><img src="https://images2.imgbox.com/4b/dc/hzV1ccQv_o.png" alt="image-20220402170313865"></p> 
<h4><a id="web_363"></a>重启web应用</h4> 
<p>已经停止的web容器,使用docekr start来启动</p> 
<pre><code>docker start friendly_perlman
</code></pre> 
<p><img src="https://images2.imgbox.com/e9/0f/4iyzM9M8_o.png" alt="image-20220402170416018"></p> 
<p>查询最后一次创建的容器</p> 
<pre><code>docker ps -l
</code></pre> 
<p><img src="https://images2.imgbox.com/ea/21/xeu40DoC_o.png" alt="image-20220402170505563"></p> 
<p>重启正在运行的容器</p> 
<pre><code>docker restart
</code></pre> 
<p><img src="https://images2.imgbox.com/db/f0/Zj1O2Inm_o.png" alt="image-20220402174654864"></p> 
<h4><a id="web_389"></a>移除web应用容器</h4> 
<p>删除不需要的容器</p> 
<pre><code>docker rm friendly_perlman
</code></pre> 
<p><img src="https://images2.imgbox.com/4f/47/ETngT9Ls_o.png" alt="image-20220402174957999"></p> 
<p>删除容器时,容器必须是停止状态,否则会报错</p> 
<h2><a id="docker_401"></a>docker镜像使用</h2> 
<p>在运行容器时,使用的镜像如果在本地不存在,docker就会自动从docker镜像仓库中下载,默认是从docker hub公共镜像源下载</p> 
<h3><a id="_405"></a>列出镜像列表</h3> 
<h4><a id="_407"></a>列出本地主机上的镜像</h4> 
<pre><code>docker images
</code></pre> 
<p><img src="https://images2.imgbox.com/5b/bc/zkrqI9Ks_o.png" alt="image-20220402175248772"></p> 
<ul><li>repository :表示镜像仓库源</li><li>tag :镜像的标签</li><li>image id :镜像id</li><li>created :镜像创建时间</li><li>size :镜像大小</li></ul> 
<p>同一个仓库源可以有多个tag,代表这个仓库源的不同版本,如ubuntu仓库源里,有15.10 14.04等多个不同的版本,我们使用repository:tag来定义不同的镜像.所以当我们要使用版本为15.10的ubuntu系统镜像阿里运行容器时</p> 
<pre><code>docker run -t -i ubuntu:15.10 /bin/bash
</code></pre> 
<p><img src="https://images2.imgbox.com/aa/28/DXL3n827_o.png" alt="image-20220402175641892"></p> 
<ul><li>-i :交互式操作</li><li>-t:终端</li><li>ubuntu:15.10 :这里指用ubuntu15.10版本的镜像为基础来启动容器</li><li>/bin/bash : 放在镜像名后面的是命令.这里我们希望有个交互式shell,因此用的是/bin/bash</li></ul> 
<p>如果要使用ubuntu14.04版本为系统镜像来运行容器时</p> 
<pre><code>docker run -i -t ubuntu:14.04 /bin/bash
</code></pre> 
<p><img src="https://images2.imgbox.com/b7/14/dl9pq7si_o.png" alt="image-20220402180136302"></p> 
<p>如果不指定一个镜像的版本标签,例如你只是用ubuntu,docker将默认使用ubuntu:latest镜像</p> 
<h4><a id="_444"></a>获取一个新的镜像</h4> 
<p>在本地主机上使用一个不存在的镜像时docker就会自动下载这个镜像.如果我们像预先下载这个镜像,我们就可以使用docker pull命令来下载</p> 
<pre><code>docker pull ubuntu:13.10
</code></pre> 
<p>下完之后就可以直接使用这个镜像来运行docker</p> 
<p><img src="https://images2.imgbox.com/99/fa/fDCHUpNQ_o.png" alt="image-20220402180527890"></p> 
<h4><a id="_456"></a>查找镜像</h4> 
<p>我们可以从docker hub网站来搜索镜像,docker hub网站https://hub.docker.com/.我们也可以使用docker search命令搜索镜像.比如我们需要一个httpd的镜像来作为我们的web服务.我们可以通过docker search命令搜索httpd来寻找适合我们的镜像</p> 
<pre><code>docker search httpd
</code></pre> 
<p><img src="https://images2.imgbox.com/07/b8/ifEqPIER_o.png" alt="image-20220402180842513"></p> 
<ul><li>name :镜像仓库源的名称</li><li>description:镜像的描述</li><li>official:是否是docker官方发布</li><li>stars:类似github上的star,表示点赞 喜欢</li><li>automated:自动构建</li></ul> 
<h4><a id="_472"></a>拖取镜像</h4> 
<pre><code>docker pull httpd
</code></pre> 
<p><img src="https://images2.imgbox.com/49/dd/foCUvYF0_o.png" alt="image-20220402181132974"></p> 
<p>接着就可以使用这个镜像了</p> 
<h4><a id="_482"></a>删除镜像</h4> 
<p>使用docker rmi命令</p> 
<pre><code>docker rmi a4c7cb30a6ff
</code></pre> 
<p><img src="https://images2.imgbox.com/8a/f9/Dzol6666_o.png" alt="image-20220402181344695"></p> 
<p>删除所有镜像</p> 
<pre><code>docker rim i `docker images -q`
</code></pre> 
<h4><a id="_500"></a>创建镜像</h4> 
<p>当我们从docker镜像仓库中下载的镜像不能满足我们的需求的时候,我们就可以通过以下两种方式对镜像进行更改</p> 
<ol><li>从已创建的容器中更新镜像,并提交这个镜像</li><li>使用dockerfile指令来创建一个新的镜像</li></ol> 
<h4><a id="_507"></a>更新镜像</h4> 
<p>更新镜像之前我们需要使用镜像来创建一个容器</p> 
<pre><code>docker run  -it ubuntu:15.10 /bin/bash
</code></pre> 
<p><img src="https://images2.imgbox.com/fe/3b/S9lw1eiU_o.png" alt="image-20220402181815783"></p> 
<p>在运行的容器内使用apt-get update命令进行更新,在操作完成之后,输入exit命令来退出容器,此时id为79171d4b8787的容器,是按照我们的需求更改的容器.我们可以通过命令docker commit来提交容器副本</p> 
<pre><code>docker commit -m="has update" -a="wanan" 79171d4b8787 ububtu:v2
</code></pre> 
<p><img src="https://images2.imgbox.com/8e/ac/xNCcEmGR_o.png" alt="image-20220402182250303"></p> 
<ul><li>-m :提交的描述信息</li><li>-a :指定镜像作者</li><li>79171d4b8787 :容器id</li><li>ubuntu:v2 :指定要创建的目标镜像名</li></ul> 
<p>我们可以使用docker images来查看我们的新镜像</p> 
<pre><code>docker images
</code></pre> 
<p><img src="https://images2.imgbox.com/f0/c2/58FXjaKl_o.png" alt="image-20220402182446336"></p> 
<p>使用我们的新镜像ubuntu:v2来启动一个容器</p> 
<p><img src="https://images2.imgbox.com/00/42/qFPYZpW5_o.png" alt="image-20220402182546160"></p> 
<h4><a id="_542"></a>构建镜像</h4> 
<p>使用命令docker bulid,从零开始来创建一个新的镜像,为此我们需要创建一个Dockerfile文件,其中包含一组指令来告诉docker如何构建我们的镜像</p> 
<pre><code>[root@mycentos ~]# cat Dockerfile
FROM    centos:6.7
MAINTAINER      Fisher "fisher@sudops.com"

RUN     /bin/echo 'root:123456' |chpasswd
RUN     useradd runoob
RUN     /bin/echo 'runoob:123456' |chpasswd
RUN     /bin/echo -e "LANG=\"en_US.UTF-8\"" &gt;/etc/default/local
EXPOSE  22
EXPOSE  80
CMD     /usr/sbin/sshd -D
</code></pre> 
<p>每一个指令都会在镜像上创建一个新的层,每一个指令的前缀必须都是大写的.第一条指令FROM 指定使用那个镜像源,RUN指令告诉docker在镜像内执行命令,安装了什么,然后我们使用Dockerfile文件,通过docker build命令来创建一个镜像</p> 
<pre><code>docker build -t wanan/centos:6.7 .
</code></pre> 
<p><img src="https://images2.imgbox.com/8f/5c/FKoA1sEV_o.png" alt="image-20220402183320428"></p> 
<ul><li>-t :指定要创建的目标镜像名</li><li>. : Dockerfile文件所在的目录,可以指定Dockerfile的绝对路径</li></ul> 
<p>使用docker images查看创建的镜像已经在列表中存在</p> 
<p><img src="https://images2.imgbox.com/24/0a/ofsNt0nC_o.png" alt="image-20220402183453351"></p> 
<p>我们可以使用新的镜像来创建容器</p> 
<pre><code>docker run -it wanan/centos:6.7 /bin/bash
</code></pre> 
<p><img src="https://images2.imgbox.com/b0/ba/8Qe3q3Ch_o.png" alt="image-20220402183651889"></p> 
<h4><a id="_583"></a>设置镜像标签</h4> 
<p>我们可以使用docker tag命令,为镜像添加一个新的标签</p> 
<pre><code>docker tag 68bb92d72b8d wanan/centos:dev
</code></pre> 
<p><img src="https://images2.imgbox.com/04/ed/ZPcc5vmH_o.png" alt="image-20220402184032156"></p> 
<p>可以看到id为68bb92d72b8d多一个标签</p> 
<h2><a id="docker_595"></a>docker容器连接</h2> 
<p>前面我们实现了通过网络端口来访问运行在docker容器内的服务.容器中可以运行一些网络应用,要让外部也可以访问这些应用,可以通过-P或者-p参数来指定端口映射,下面通过端口连接到一个docker容器</p> 
<h3><a id="_599"></a>网络端口映射</h3> 
<p>创建一个python应用的容器</p> 
<pre><code>docker run -d -P training/webapp python app.py
</code></pre> 
<p><img src="https://images2.imgbox.com/a8/6d/QSJcoJeq_o.png" alt="image-20220402184528674"></p> 
<p>另外,我们可以指定容器绑定的网络地址,比如绑定127.0.0.1.我们使用-P绑定端口号,使用docker ps可以看到容器5000绑定了主机端口49155</p> 
<p><img src="https://images2.imgbox.com/d6/66/oTxiMkQw_o.png" alt="image-20220402184720594"></p> 
<p>我们也可以使用-p标识来指定容器端口绑定到主机端口</p> 
<ul><li>-P :是容器内部端口随机映射到主机的端口</li><li>-p :是容器内部端口绑定到指定的主机端口</li></ul> 
<pre><code>docker run -d -p 5000:5000 training/webapp python app.py
</code></pre> 
<p><img src="https://images2.imgbox.com/fd/4e/Ys8YuFVb_o.png" alt="image-20220402185042253"></p> 
<p>可以指定容器绑定的网络地址,比如绑定127.0.0.1</p> 
<pre><code>docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py
</code></pre> 
<p><img src="https://images2.imgbox.com/26/04/MYPvxZAi_o.png" alt="image-20220402185245053"></p> 
<p>这样我们就可以通过访问127.0.0.5001来访问容器5000端口了.之前的都是默认绑定tcp端口,如果要绑定udp端口,可以在端口后面加上/udp</p> 
<pre><code>docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py
</code></pre> 
<p><img src="https://images2.imgbox.com/d2/0c/cGDZRToS_o.png" alt="image-20220402185526207"></p> 
<p>docker port 命令可以让我们快捷查看端口的绑定情况</p> 
<pre><code>docker port loving_satoshi 5000/udp
</code></pre> 
<p><img src="https://images2.imgbox.com/80/fe/gNs1d7uN_o.png" alt="image-20220402185638530"></p> 
<h3><a id="docker_648"></a>docker容器互联</h3> 
<p>端口映射并不是唯一把docker连接到另一个容器的方法.docker有一个连接系统允许将多个容器连接在一起,共享连接信息.docker连接会创建一个父子关系,其中父容器可以看到子容器的信息</p> 
<h3><a id="_652"></a>容器命名</h3> 
<p>当我们创建容器的时候,docker会自动对他进行命名.另外我们也可以使用–name 标识来命名容器</p> 
<pre><code>docker run -d -P --name wanan training/webapp python app.py
</code></pre> 
<p><img src="https://images2.imgbox.com/35/68/hjmwCbAM_o.png" alt="image-20220402190131290"></p> 
<h3><a id="_662"></a>新建网络</h3> 
<p>下面创建一个新的docker网络</p> 
<pre><code>docker network create -d bridge test-net
</code></pre> 
<p><img src="https://images2.imgbox.com/d6/b4/sO4biUJI_o.png" alt="image-20220402190625004"></p> 
<ul><li>-d :参数指定docker网络类型,有bridge overlay</li></ul> 
<p>其中overlay网络类型用于swarm mode</p> 
<h3><a id="_676"></a>连接容器</h3> 
<p>运行一个容器并连接到新建的test-net网络</p> 
<pre><code>docker run -itd --name test1 --network test-net ubuntu /bin/bash
</code></pre> 
<p>打开一个新的终端,在运行一个容器并加入到test-net网络</p> 
<pre><code>docker run -itd --name test2 --network test-net ubuntu /bin/bash
</code></pre> 
<p><img src="https://images2.imgbox.com/ec/b6/MbhKP6Vf_o.png" alt="image-20220402191201689"></p> 
<p>通过平来证明test1容器和test2容器建立了互联关系,如果test1或者test2容器中无ping命令,则在容器内执行一下命令安装ping(可以在一个容器内按装好,提交到容器镜像,在以新的镜像重新运行以上两个容器)</p> 
<pre><code>docker exec -it test1 /bin/bash
apt-get update
apt install iputils-ping
</code></pre> 
<p>这样test1容器就和test2容器建立了相互连接,如果有多个容器需要相互连接,推荐使用docker compose</p> 
<h3><a id="dns_702"></a>配置dns</h3> 
<p>可以在原始主机中的/etc/docker/daemon.json文件中添加以下内容来设置全部容器的dns</p> 
<pre><code>{
  "dns" : [
    "114.114.114.114",
    "8.8.8.8"
  ]
}
</code></pre> 
<p>设置完之后,启动容器的dns会自动配置为114.114.114.114和8.8.8.8.配置完,需要重启docker才能生效.查看容器的dns是否生效可以使用以下命令,他会输出容器的dns信息</p> 
<pre><code>docker run -it --rm ubuntu cat etc/resolv.conf
</code></pre> 
<p><img src="https://images2.imgbox.com/53/22/pONuNX9N_o.png" alt="image-20220402192210517"></p> 
<p>手动指定容器的配置</p> 
<p>如果只是想在指定容器设置dns,则可以使用</p> 
<pre><code>docker run -it --rm -h host_ubuntu --dns=114.114.114.114 --dns-search=test.com ubuntu
</code></pre> 
<p><img src="https://images2.imgbox.com/a5/f5/rUYN4FEZ_o.png" alt="image-20220402193017017"></p> 
<ul><li>–rm :容器退出时自动起立容器内部的文件系统</li><li>-h HOSTNAME 或者 --hostname=HOSTNAME :设定容器的主机名,他会被写入到容器内的/etc/hostname和/etc/hosts</li><li>–dns=IP_ADDRESS:添加dns服务器到容器的/etc/resolv.conf中,让容器用这个服务器来解析所有不在/etc/hosts中的主机名</li><li>–dns-search=DOMAIN:设定容器的搜索域,当设定搜索域为.example.com时,在搜索一个名为host的主机时,dns不仅搜索host,还会搜索host.example.com</li></ul> 
<p>如果在容器启动时没有指定–nds和–dns-search,docker会默认用原始主机上的/etc/resolv.conf来配置dns</p> 
<h2><a id="docker_740"></a>docker仓库管理</h2> 
<p>先给我去https://hub.docker.com免费注册一个账号去</p> 
<h3><a id="_744"></a>登录和退出</h3> 
<pre><code>docker login
</code></pre> 
<p><img src="https://images2.imgbox.com/9f/20/SCp0ILt2_o.png" alt="image-20220402193947914"></p> 
<pre><code>docker logout
</code></pre> 
<p><img src="https://images2.imgbox.com/07/a8/TM0uSTSp_o.png" alt="image-20220402194012972"></p> 
<h3><a id="_758"></a>推送镜像</h3> 
<p>登录之后可以通过docker push命令将自己的镜像推送到docker hub</p> 
<p><img src="https://images2.imgbox.com/82/f5/ccbK95AC_o.png" alt="image-20220402195026447"></p> 
<h2><a id="docker_Dockerfile_764"></a>docker Dockerfile</h2> 
<p>dockerfile 是一个用来构建镜像的文本文件,文本内容包含了一条条构建镜像所需要的指令和说明</p> 
<h3><a id="dockerfile_768"></a>使用dockerfile定制镜像</h3> 
<h4><a id="nginx_770"></a>定制一个nginx镜像</h4> 
<p>构建好的镜像内会有一个/usr/share/nginx/html/index.html文件</p> 
<p>在一个空目录下新建一个名为Dockerfile文件,并在文件内添加以下内容</p> 
<pre><code>FROM nginx
RUN echo "这是一个本地创建的nginx镜像" &gt; /usr/share/nginx/html/index.
</code></pre> 
<p><img src="https://images2.imgbox.com/5d/9d/Kqt0jcMs_o.png" alt="image-20220402205956259"></p> 
<h4><a id="FROMRUN_783"></a>FROM和RUN指令的作用</h4> 
<ul><li>FROM:定制的镜像都是基于FROM的镜像,这里的nginx就是定制需要的基础镜像,后续的操作都是基于nginx</li><li>RUN: 用于执行后面跟着的命令行命令.有两种格式</li></ul> 
<p>shell格式</p> 
<pre><code>RUN [命令行命令]
# [命令行命令] 等同于在终端操作的shell命令
</code></pre> 
<p>exec格式</p> 
<pre><code>RUN ["可执行文件","参数1","参数2"]
#例如:
#RUN ["./test.php","dev","offline"]等价于 RUN ./test.php dev offline
</code></pre> 
<p>注意 dockerfile的指令每一次执行都会在docker上新建一层.所以过多无意义的层会造成镜像膨胀过大</p> 
<pre><code>FROM centos
RUN yum -y install wget
RUN wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz"
RUN tar -xvf redis.tar.gz
</code></pre> 
<p>以上执行会创建3层镜像.可简化为以下格式</p> 
<pre><code>FROM centos
RUN yum -y install wget \
&amp;&amp; wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz" \
&amp;&amp; tar -xvf redis.tar.gz
</code></pre> 
<p>如上,以&amp;&amp;符号连接命令,这样执行后,只会创建一层镜像</p> 
<h3><a id="_823"></a>开始构建镜像</h3> 
<p>在dockerfile文件的存放目录下,执行构建动作.以下实例,通过目录下的dcokerfile构建一个nginx:v3(镜像名称:镜像标签)</p> 
<p>最后的.代表本次执行的上下文路径</p> 
<pre><code>docker build -t nginx:v3 .
</code></pre> 
<p><img src="https://images2.imgbox.com/af/9c/no6LgdT7_o.png" alt="image-20220402220820026"></p> 
<p>以上显示说明已经构建成功</p> 
<p>上下文路径,有提到指令最后一个.是上下文路径,那么什么是上下文路径呢</p> 
<pre><code>docker bulid -t nginx:v3 .
</code></pre> 
<p>上下文路径,是指docker在构建镜像,有时候想要使用到本机的文件(比如复制),docker build 命令得知这个路径之后,会将路径下的所有内容打包.</p> 
<p>由于docker的运行模式是c/s.我们本机是c,docker引擎是s.实际的构建过程是在docker引擎下完成的,所以这个时候无法用到我们本机的文件,这就需要我们本机的指定目录下的文件一起打包提供给docker引擎使用.如果未说明最后一个参数,那么默认上下文路径技术dockerfile所在的位置.</p> 
<p>上下文路径不要放无用的文件,因为会一起打包发送给docker引擎,如果文件过多会造成过程缓慢.</p> 
<h2><a id="docker_compose_849"></a>docker compose</h2> 
<p>compose简介</p> 
<p>compose是用于定义和运行多容器docker应用程序的工具.通过compose,您可以使用yml文件来配置应用程序需要的所有服务,然后使用一个命令就可以从yml文件配置中创建并启动所有服务.</p> 
<p>使用compose的三个步骤</p> 
<ul><li>使用dockerfile定义应用程序的环境</li><li>使用docker-compose.yml定义构成应用程序的服务,这样他们可以在隔离环境中一起运行.</li><li>最后,执行docker-compose up命令来启动并运行整个应用程序</li></ul> 
<p>docker-compose.yml的配置案例如下</p> 
<pre><code># yaml 配置实例
version: '3'
services:
  web:
    build: .
    ports:
   - "5000:5000"
    volumes:
   - .:/code
    - logvolume01:/var/log
    links:
   - redis
  redis:
    image: redis
volumes:
  logvolume01: {}
</code></pre> 
<h3><a id="compose_882"></a>compose安装</h3> 
<p>linux上我们可以从github上下载二进制包来使用</p> 
<pre><code>curl -L "https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose

chmod +x /usr/local/bin/docker-compose

 docker-compose --version
</code></pre> 
<p>对于alpine,需要下载依赖包.py-pip，python-dev，libffi-dev，openssl-dev，gcc，libc-dev，和 make。</p> 
<p>新建一个app.py复制进去以下内容</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> time

<span class="token keyword">import</span> redis
<span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask

app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>
cache <span class="token operator">=</span> redis<span class="token punctuation">.</span>Redis<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'redis'</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">)</span>


<span class="token keyword">def</span> <span class="token function">get_hit_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    retries <span class="token operator">=</span> <span class="token number">5</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> cache<span class="token punctuation">.</span>incr<span class="token punctuation">(</span><span class="token string">'hits'</span><span class="token punctuation">)</span>
        <span class="token keyword">except</span> redis<span class="token punctuation">.</span>exceptions<span class="token punctuation">.</span>ConnectionError <span class="token keyword">as</span> exc<span class="token punctuation">:</span>
            <span class="token keyword">if</span> retries <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
                <span class="token keyword">raise</span> exc
            retries <span class="token operator">-=</span> <span class="token number">1</span>
            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>


<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    count <span class="token operator">=</span> get_hit_count<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string">'Hello World! I have been seen {} times.\n'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>
</code></pre> 
<p>在此实例中,redis是应用程序网络上redis容器的主机名,该主机使用的端口为6379.创建一个requirements.txt</p> 
<pre><code>flask
redis
</code></pre> 
<p>创建dockerfile文件</p> 
<pre><code>FROM python:3.7-alpine
WORKDIR /code
ENV FLASK_APP app.py
ENV FLASK_RUN_HOST 0.0.0.0
RUN apk add --no-cache gcc musl-dev linux-headers
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt
COPY . .
CMD ["flask", "run"]
</code></pre> 
<ul><li> <p>FROM python:3.7-alpine:从python3.7映像开始构建镜像</p> </li><li> <p>WORKDIR/code:将工作目录设置为/code</p> </li><li> <pre><code>  ENV FLASK_APP app.py
  ENV FLASK_RUN_HOST 0.0.0.0
</code></pre> <p>设置flask命令使用的环境变量</p> </li><li> <p>RUN apk add --no-cache gcc musl-dev linux-headers:安装gcc ,以便诸如MarkupSafe 和 SQLAlchemy 之类的 Python 包可以编译加速。</p> </li><li> <pre><code>  COPY requirements.txt requirements.txt
  RUN pip install -r requirements
</code></pre> <p>复制requirements.txt并安装python依赖项</p> </li><li> <p>COPY .:将.项目中的当前目录复制到.镜像中的工作目录</p> </li><li> <p>CMD[“flask”,“run”]:容器提供默认的执行命令为:flask run</p> </li></ul> 
<p>创建docker-compose.yml</p> 
<pre><code># yaml 配置
version: '3'
services:
  web:
    build: .
    ports:
     - "5000:5000"
  redis:
    image: "redis:alpine"
</code></pre> 
<p>该compose定义了两个服务:web和redis</p> 
<ul><li>web:该web服务使用从dockerfile当前目录中构建的镜像,然后,它将容器和主句绑定到暴露的端口5000.此示例服务使用Flask web服务的默认端口5000</li><li>redis:该redis服务使用docker hub的公共redis映像</li></ul> 
<p>使用compose命令构建和运行应用</p> 
<pre><code>docker-compose up
</code></pre> 
<h2><a id="dockerubuntu_996"></a>docker安装ubuntu</h2> 
<h3><a id="ubuntu_998"></a>查看可用ubuntu</h3> 
<p>访问 Ubuntu 镜像库地址： https://hub.docker.com/_/ubuntu?tab=tags&amp;page=1。</p> 
<p>可以通过 Sort by 查看其他版本的 Ubuntu。默认是最新版本 ubuntu:latest 。</p> 
<h3><a id="ubuntu_1004"></a>拉取最新的ubuntu镜像</h3> 
<pre><code>docker pull ubuntu
docker pull ubuntu:latest
</code></pre> 
<p><img src="https://images2.imgbox.com/62/6b/GQSG7H2K_o.png" alt="image-20220402225049119"></p> 
<h3><a id="_1013"></a>查看本地镜像</h3> 
<pre><code>docker images
</code></pre> 
<h3><a id="execubuntu_1019"></a>运行容器,并可以通过exec命令进入ubuntu容器</h3> 
<pre><code>docker run -itd --name ubuntu-test ubuntu
</code></pre> 
<p><img src="https://images2.imgbox.com/31/13/xq3yLXOG_o.png" alt="image-20220402225805122"></p> 
<p><img src="https://images2.imgbox.com/e5/71/2iacaIrr_o.png" alt="image-20220402225853671"></p> 
<h2><a id="centos_1029"></a>安装centos</h2> 
<h3><a id="centos_1031"></a>拉取指定版本的centos镜像</h3> 
<pre><code>docker pull centos:centos7
</code></pre> 
<p><img src="https://images2.imgbox.com/d5/77/8N9iPIeT_o.png" alt="image-20220402230220726"></p> 
<h3><a id="_1039"></a>查看本地镜像</h3> 
<pre><code>docker images
</code></pre> 
<p><img src="https://images2.imgbox.com/03/e2/8rvavNmB_o.png" alt="image-20220402230227431"></p> 
<h3><a id="execcentos_1047"></a>运行容器并通过exec命令进入centos容器</h3> 
<pre><code>docker run -itd --name centos-test centos:centos7
docker exec -it centos-test bash
</code></pre> 
<p><img src="https://images2.imgbox.com/8b/1a/dPwFMoYX_o.png" alt="image-20220402230258764"></p> 
<h2><a id="dockernginx_1056"></a>docker安装nginx</h2> 
<h3><a id="_1058"></a>找版本</h3> 
<pre><code>docker search nginx
</code></pre> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-sV9ynXGU-1665117305902)(C:/Users/14980/AppData/Roaming/Typora/typora-user-images/image-20220402230406352.png)]</p> 
<h3><a id="_1066"></a>拉取</h3> 
<pre><code>docker pull nginx
</code></pre> 
<p><img src="https://images2.imgbox.com/48/ea/1zHtgdrx_o.png" alt="image-20220402230527980"></p> 
<h3><a id="_1074"></a>查看本地镜像</h3> 
<pre><code>docker images
</code></pre> 
<h3><a id="_1080"></a>运行容器</h3> 
<pre><code>docker run --name nginx-test -p 8080:80 -d nginx 
</code></pre> 
<ul><li>–name nginxe-test :容器名称</li><li>-p 8080:80 :端口映射,将本地8080端口映射到容器内部的80端口</li><li>-d nginx :设置容器在后台一直执行</li></ul> 
<p><img src="https://images2.imgbox.com/bc/00/ghSXweV2_o.png" alt="image-20220402230702908"></p> 
<pre><code>docker exec -it nginx-test bash
</code></pre> 
<h2><a id="nginxphp_1096"></a>nginx+php部署</h2> 
<h3><a id="php_1098"></a>拉取php</h3> 
<pre><code>docker pull php:5.6-fpm
</code></pre> 
<p><img src="https://images2.imgbox.com/67/3b/U481BL5Q_o.png" alt="image-20220402231119494"></p> 
<pre><code>docker run --name myphp-fpm -v ~/nginx/www:/www -d php:5.6-fpm
</code></pre> 
<ul><li>–name myphp-fpm:将容器命名为myphp-fpm</li><li>-v ~/nginx/www:/www:将主机中项目的目录www挂载到容器的/www</li></ul> 
<p>创建~/nginx/conf/conf.d目录</p> 
<pre><code>mkdir ~/nginx/conf/conf.d
</code></pre> 
<p>添加 ~/nginx/conf/conf.d/runoob-test-php.conf 文件</p> 
<pre><code>server {
    listen       80;
    server_name  localhost;

    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm index.php;
    }

    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }

    location ~ \.php$ {
        fastcgi_pass   php:9000;
        fastcgi_index  index.php;
        fastcgi_param  SCRIPT_FILENAME  /www/$fastcgi_script_name;
        include        fastcgi_params;
    }
}
</code></pre> 
<p>配置文件</p> 
<ul><li>php:9000:表示php-fpm服务中的url</li><li>/www/:是myphp-php中php文件存储路径,映射到本地的~/nginx/www目录</li></ul> 
<p>启动nginx</p> 
<pre><code>docker run --name runoob-php-nginx -p 8083:80 -d \
    -v ~/nginx/www:/usr/share/nginx/html:ro \
    -v ~/nginx/conf/conf.d:/etc/nginx/conf.d:ro \
    --link myphp-fpm:php \
    nginx
</code></pre> 
<ul><li>-p 8083:80:端口映射,把nginx中的80映射到本地的8083端口</li><li>~/nginx/www:是本地html文件的存储目录,/usr/share/nginx/html是容器内html文件的存储目录</li><li>~/nginx/conf/conf.d 是本地nginx配置文件的存储目录,/etc/nginx/conf.d是容器内nginx配置文件的存储目录</li><li>–link myphp-fpm:php :是把myphp-fpm的网络并入nginx,并通过修改nginx的/etc/hosts,把域名php映射成127.0.0.1,让nginx通过php:9000访问php-fpm</li></ul> 
<p>在~/nginx/www目录下创建index.php</p> 
<pre><code>&lt;?php
echo phpinfo();
?&gt;
</code></pre> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CYoKKM8X-1665117305903)(C:/Users/14980/AppData/Roaming/Typora/typora-user-images/image-20220403140022917.png)]</p> 
<h2><a id="dockermysql_1175"></a>docker安装mysql</h2> 
<h3><a id="_1177"></a>拉镜像</h3> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ILhjSVpQ-1665117305903)(C:/Users/14980/AppData/Roaming/Typora/typora-user-images/image-20220403140206082.png)]</p> 
<h3><a id="_1181"></a>运行容器</h3> 
<pre><code>docker run -itd --name mysql -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql
</code></pre> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rzxpy6nV-1665117305904)(C:/Users/14980/AppData/Roaming/Typora/typora-user-images/image-20220403140450894.png)]</p> 
<ul><li>-p 3307:3306 :映射容器服务的3306端口到原始主机的3307端口上,外部主机可以通过宿主机ip:3306访问到mysql服务</li><li>MYSQL_ROOT_PASSWORD=123456:设置mysql服务root用户的密码</li></ul> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-WgTfOAFS-1665117305904)(C:/Users/14980/AppData/Roaming/Typora/typora-user-images/image-20220403141235682.png)]</p> 
<h2><a id="dockertomcat_1194"></a>docker安装tomcat</h2> 
<h3><a id="tomact_1196"></a>创建tomact</h3> 
<p>创建tomcat,用于存放后面相关的东西</p> 
<pre><code>mkdir -p ~/tomcat/webapps ~/tomcat/logs ~/tomcat/conf
</code></pre> 
<ul><li>webapps目录将映射为tomcat容器配置的应用程序目录</li><li>logs目录将映射为tomcat容器的日志目录</li><li>conf目录里的配置文件经映射为tomcat容器的配置文件</li></ul> 
<p>进入tomcat目录,创建Dockerfile文件</p> 
<pre><code>FROM openjdk:8-jre

ENV CATALINA_HOME /usr/local/tomcat
ENV PATH $CATALINA_HOME/bin:$PATH
RUN mkdir -p "$CATALINA_HOME"
WORKDIR $CATALINA_HOME

# let "Tomcat Native" live somewhere isolated
ENV TOMCAT_NATIVE_LIBDIR $CATALINA_HOME/native-jni-lib
ENV LD_LIBRARY_PATH ${LD_LIBRARY_PATH:+$LD_LIBRARY_PATH:}$TOMCAT_NATIVE_LIBDIR

# runtime dependencies for Tomcat Native Libraries
# Tomcat Native 1.2+ requires a newer version of OpenSSL than debian:jessie has available
# &gt; checking OpenSSL library version &gt;= 1.0.2...
# &gt; configure: error: Your version of OpenSSL is not compatible with this version of tcnative
# see http://tomcat.10.x6.nabble.com/VOTE-Release-Apache-Tomcat-8-0-32-tp5046007p5046024.html (and following discussion)
# and https://github.com/docker-library/tomcat/pull/31
ENV OPENSSL_VERSION 1.1.0f-3+deb9u2
RUN set -ex; \
    currentVersion="$(dpkg-query --show --showformat '${Version}\n' openssl)"; \
    if dpkg --compare-versions "$currentVersion" '&lt;&lt;' "$OPENSSL_VERSION"; then \
        if ! grep -q stretch /etc/apt/sources.list; then \
# only add stretch if we're not already building from within stretch
            { \
                echo 'deb http://deb.debian.org/debian stretch main'; \
                echo 'deb http://security.debian.org stretch/updates main'; \
                echo 'deb http://deb.debian.org/debian stretch-updates main'; \
            } &gt; /etc/apt/sources.list.d/stretch.list; \
            { \
# add a negative "Pin-Priority" so that we never ever get packages from stretch unless we explicitly request them
                echo 'Package: *'; \
                echo 'Pin: release n=stretch*'; \
                echo 'Pin-Priority: -10'; \
                echo; \
# ... except OpenSSL, which is the reason we're here
                echo 'Package: openssl libssl*'; \
                echo "Pin: version $OPENSSL_VERSION"; \
                echo 'Pin-Priority: 990'; \
            } &gt; /etc/apt/preferences.d/stretch-openssl; \
        fi; \
        apt-get update; \
        apt-get install -y --no-install-recommends openssl="$OPENSSL_VERSION"; \
        rm -rf /var/lib/apt/lists/*; \
    fi

RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \
        libapr1 \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

# see https://www.apache.org/dist/tomcat/tomcat-$TOMCAT_MAJOR/KEYS
# see also "update.sh" (https://github.com/docker-library/tomcat/blob/master/update.sh)
ENV GPG_KEYS 05AB33110949707C93A279E3D3EFE6B686867BA6 07E48665A34DCAFAE522E5E6266191C37C037D42 47309207D818FFD8DCD3F83F1931D684307A10A5 541FBE7D8F78B25E055DDEE13C370389288584E7 61B832AC2F1C5A90F0F9B00A1C506407564C17A3 713DA88BE50911535FE716F5208B0AB1D63011C7 79F7026C690BAA50B92CD8B66A3AD3F4F22C4FED 9BA44C2621385CB966EBA586F72C284D731FABEE A27677289986DB50844682F8ACB77FC2E86E29AC A9C5DF4D22E99998D9875A5110C01C5A2F6059E7 DCFD35E0BF8CA7344752DE8B6FB21E8933C60243 F3A04C595DB5B6A5F1ECA43E3B7BBB100D811BBE F7DA48BB64BCB84ECBA7EE6935CD23C10D498E23

ENV TOMCAT_MAJOR 8
ENV TOMCAT_VERSION 8.5.32
ENV TOMCAT_SHA512 fc010f4643cb9996cad3812594190564d0a30be717f659110211414faf8063c61fad1f18134154084ad3ddfbbbdb352fa6686a28fbb6402d3207d4e0a88fa9ce

ENV TOMCAT_TGZ_URLS \
# https://issues.apache.org/jira/browse/INFRA-8753?focusedCommentId=14735394#comment-14735394
    https://www.apache.org/dyn/closer.cgi?action=download&amp;filename=tomcat/tomcat-$TOMCAT_MAJOR/v$TOMCAT_VERSION/bin/apache-tomcat-$TOMCAT_VERSION.tar.gz \
# if the version is outdated, we might have to pull from the dist/archive :/
    https://www-us.apache.org/dist/tomcat/tomcat-$TOMCAT_MAJOR/v$TOMCAT_VERSION/bin/apache-tomcat-$TOMCAT_VERSION.tar.gz \
    https://www.apache.org/dist/tomcat/tomcat-$TOMCAT_MAJOR/v$TOMCAT_VERSION/bin/apache-tomcat-$TOMCAT_VERSION.tar.gz \
    https://archive.apache.org/dist/tomcat/tomcat-$TOMCAT_MAJOR/v$TOMCAT_VERSION/bin/apache-tomcat-$TOMCAT_VERSION.tar.gz

ENV TOMCAT_ASC_URLS \
    https://www.apache.org/dyn/closer.cgi?action=download&amp;filename=tomcat/tomcat-$TOMCAT_MAJOR/v$TOMCAT_VERSION/bin/apache-tomcat-$TOMCAT_VERSION.tar.gz.asc \
# not all the mirrors actually carry the .asc files :'(
    https://www-us.apache.org/dist/tomcat/tomcat-$TOMCAT_MAJOR/v$TOMCAT_VERSION/bin/apache-tomcat-$TOMCAT_VERSION.tar.gz.asc \
    https://www.apache.org/dist/tomcat/tomcat-$TOMCAT_MAJOR/v$TOMCAT_VERSION/bin/apache-tomcat-$TOMCAT_VERSION.tar.gz.asc \
    https://archive.apache.org/dist/tomcat/tomcat-$TOMCAT_MAJOR/v$TOMCAT_VERSION/bin/apache-tomcat-$TOMCAT_VERSION.tar.gz.asc

RUN set -eux; \
    \
    savedAptMark="$(apt-mark showmanual)"; \
    apt-get update; \
    \
    apt-get install -y --no-install-recommends gnupg dirmngr; \
    \
    export GNUPGHOME="$(mktemp -d)"; \
    for key in $GPG_KEYS; do \
        gpg --keyserver ha.pool.sks-keyservers.net --recv-keys "$key"; \
    done; \
    \
    apt-get install -y --no-install-recommends wget ca-certificates; \
    \
    success=; \
    for url in $TOMCAT_TGZ_URLS; do \
        if wget -O tomcat.tar.gz "$url"; then \
            success=1; \
            break; \
        fi; \
    done; \
    [ -n "$success" ]; \
    \
    echo "$TOMCAT_SHA512 *tomcat.tar.gz" | sha512sum -c -; \
    \
    success=; \
    for url in $TOMCAT_ASC_URLS; do \
        if wget -O tomcat.tar.gz.asc "$url"; then \
            success=1; \
            break; \
        fi; \
    done; \
    [ -n "$success" ]; \
    \
    gpg --batch --verify tomcat.tar.gz.asc tomcat.tar.gz; \
    tar -xvf tomcat.tar.gz --strip-components=1; \
    rm bin/*.bat; \
    rm tomcat.tar.gz*; \
    rm -rf "$GNUPGHOME"; \
    \
    nativeBuildDir="$(mktemp -d)"; \
    tar -xvf bin/tomcat-native.tar.gz -C "$nativeBuildDir" --strip-components=1; \
    apt-get install -y --no-install-recommends \
        dpkg-dev \
        gcc \
        libapr1-dev \
        libssl-dev \
        make \
        "openjdk-${JAVA_VERSION%%[.~bu-]*}-jdk=$JAVA_DEBIAN_VERSION" \
    ; \
    ( \
        export CATALINA_HOME="$PWD"; \
        cd "$nativeBuildDir/native"; \
        gnuArch="$(dpkg-architecture --query DEB_BUILD_GNU_TYPE)"; \
        ./configure \
            --build="$gnuArch" \
            --libdir="$TOMCAT_NATIVE_LIBDIR" \
            --prefix="$CATALINA_HOME" \
            --with-apr="$(which apr-1-config)" \
            --with-java-home="$(docker-java-home)" \
            --with-ssl=yes; \
        make -j "$(nproc)"; \
        make install; \
    ); \
    rm -rf "$nativeBuildDir"; \
    rm bin/tomcat-native.tar.gz; \
    \
# reset apt-mark's "manual" list so that "purge --auto-remove" will remove all build dependencies
    apt-mark auto '.*' &gt; /dev/null; \
    [ -z "$savedAptMark" ] || apt-mark manual $savedAptMark; \
    apt-get purge -y --auto-remove -o APT::AutoRemove::RecommendsImportant=false; \
    rm -rf /var/lib/apt/lists/*; \
    \
# sh removes env vars it doesn't support (ones with periods)
# https://github.com/docker-library/tomcat/issues/77
    find ./bin/ -name '*.sh' -exec sed -ri 's|^#!/bin/sh$|#!/usr/bin/env bash|' '{}' +

# verify Tomcat Native is working properly
RUN set -e \
    &amp;&amp; nativeLines="$(catalina.sh configtest 2&gt;&amp;1)" \
    &amp;&amp; nativeLines="$(echo "$nativeLines" | grep 'Apache Tomcat Native')" \
    &amp;&amp; nativeLines="$(echo "$nativeLines" | sort -u)" \
    &amp;&amp; if ! echo "$nativeLines" | grep 'INFO: Loaded APR based Apache Tomcat Native library' &gt;&amp;2; then \
        echo &gt;&amp;2 "$nativeLines"; \
        exit 1; \
    fi

EXPOSE 8080
CMD ["catalina.sh", "run"]
</code></pre> 
<p>通过Dockerfile文件创建一个镜像,换成自己的名字</p> 
<pre><code>docker build -t tomcat .
</code></pre> 
<h3><a id="tomcat_1380"></a>使用tomcat镜像</h3> 
<pre><code>docker run --name tomcat -p 8080:8080 -v $PWD/test:/usr/local/tomcat/webapps/test -d tomcat
</code></pre> 
<ul><li>-p 8080:8080:将主机的8080端口映射到容器的8080端口</li><li>-v $PWD/test:/usr/local/tomcat/webapps/test :将主机中当前目录下的test挂载到容器的/test</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/150cac2678caf68fd2e59af2e5ab9318/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言之 goto语句怎么了？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ca65fef300c6029b67f45647762beb6e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux——把用户加入和移除用户组</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>