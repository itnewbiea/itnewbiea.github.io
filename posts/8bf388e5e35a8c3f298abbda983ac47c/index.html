<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>斯坦福大学-自然语言处理入门 笔记 第九课 信息抽取（information extraction） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="斯坦福大学-自然语言处理入门 笔记 第九课 信息抽取（information extraction）" />
<meta property="og:description" content="一、介绍 1、信息抽取（information extraction） 信息抽取（IE）系统 找到并理解文本中的有限的相关性从很多的文档之中收集信息产生一个相关信息的结构化的表征目的： 进行信息的组织使之对人有用以相对精确的语义形式存放信息方便计算机算法后续的查找 信息抽取（IE）系统一般会抽取清晰的实际的信息（谁对谁做了什么在什么时候）
低程度的信息抽取 一般被用在苹果或者是谷歌的邮件上，或者是web索引。通常是基于正则表达和名字列表。
2、命名实体识别（named entity recognition） 这是在信息抽取中十分重要的一个分支：找到并识别文档中的名字
主要用途： 命名实体的索引（index）和链接(link off）分析情感指向的公司或者产品很多信息抽取的关系都是和命名实体相关在问题回答（question answer）领域，答案往往是命名实体。 二、命名实体识别的评估 正确识别一个命名实体，需要包含两个方面，一方面需要找到表示命名实体的词组，另一方面对命名实体正确归类，如果下图所示：
对命名实体识别（NER）或者信息抽取（IE）而言，用之前介绍的recall和precision来进行评估会存在一个问题：没有办法定义边界错误（boundary error）。举例子而言：
对于句子：First Bank of Chicago announced earnings…而言，机器识别Bank of Chicago作为实体，但实际First Bank of Chicago才是命名实体。对于这样的错误，我们在归类的时候即可以归到FN也可以归到FP。所以，基于这样的度量标准，实际上边界错误比无法识别（只会归类到FN）更严重。其他度量，比如MUC得分会好一些 三、命名实体识别的序列模型（sequence model） 1、命名实体识别（NER）的机器学习序列模型 训练 收集一系列有代表性的训练文档给每个token标注它的类别，如果不是命名实体的话就标注other（O)设计适合文档和类别的特征抽取机制训练一个序列分类来预测数据的类别 测试 一系列的测试文档运行序列模型来给每个token进行标注输出识别出的实体 2、对序列标注进行类别编码 这里有两种可以使用的编码方式：
IO编码，只标记每个词的类别。这里需要的标注个数是C＋１。IOB编码，除了标记每个词的类别之外，标记还会表示出这个类别的开始和结束，如下图B－PER表示Person类别的开始，I－PER表示person类别的结束。这样的话，当几个相同的命名实体是连在一起的时候，我们可以区分出有几个命名实体。这里需要的标注个数是２C＋１。
在实际应用中，IO编码效果可能会更好。（在Stanford的姓名粗识别中使用IO编码） 一方面是IO编码的速度更快，标注数量更少另一方面，几个相同的命名实体是连在一起的情况很少，而且在这个情况下IOB编码也很难正确识别出命名实体的开始和结束。 3、序列标记的特征 单词 目前的单词前一个/后一个单词（上下文） 其他推论型的语言分类 词类标记 上下文的标签（label） 前一个（或者后一个）词的标签 单词的子字符串：我们可以利用单词中的某些字符来进行判别，比如含有oxa子字符串的单词都是drug。
单词的形状：包括单词的长度、大小写、是否含有数字、是否含有希腊字母、连词符。利用下面的规则，我们将其抽取成特征。 A，B，C…→Xa,b,c→x1，2，3…→d- → -. → .对于长过四个字母的单词，我们取前两个和后两个；如果单词小于四个的话，我们就按照原来的长度转化。例子如下：
四、最大熵马尔可夫模型（MEMMs）/条件马尔可夫模型 很多在NLP领域的问题的数据都是序列数据（单词序列，方块字序列，行序列，句子序列等等）。而我们的任务则是对每一项都进行标注。
1、最大熵马尔可夫模型（MEMMs）/条件马尔可夫模型 最大熵马尔可夫模型（MEMMs）/条件马尔可夫模型，这两个分类器都是每次做一个决定，基于目前的观测和过去的决定（decision）。每一次进行分类，目的是对目前的单词进行标注，该分类器的计算和标准分类器是类似的。所使用的特征包括单词（之前，目前，之后），标注（之前的单词），还有其他的单词特征（单词类型、后缀、-等等）
整体的推断系统如下
2、三种推断 贪婪推断（greedy inference） 从左边开始，用分类器依次给每个位置标记（label），分类器可以依靠之前的标记结果以及观测数据。优点： 快，没有额外的空间存储要求非常容易实施当特征很多的时候效果很好 缺点 因为使用的是贪婪算法，所以可能会发生标记错误 束推断（beam inference） 这个方法不会简单标记每个单词，相反它会保留下一些可能，在每个位置都保持前k个序列（束），每次完成一个标记就滑动前进一个序列。优点 快，3-5个单词的束就可以得到比较好的效果很容易实施（不需要进行动态规划） 缺点 对有些标记而言，可能在表现出比较好的概率之前，就已经离开波束了 维特比推断（Viterbi Inference） 动态规划，需要关于状态影响的滑动窗口（比如，过去的两个状态是相关的）优点：精确缺点：对长距离的单词与单词之间的影响很难应用（束推断也不允许长距离的序列）。 3、条件随机场（CRFs) 这也是一个整个序列的条件模型，而不是链式的模型（local model）。模型形如下图，只不过c和d是序列。但是如果特征f是当前（local）的，条件序列似然可以用动态规划来计算。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8bf388e5e35a8c3f298abbda983ac47c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-10-18T22:53:19+08:00" />
<meta property="article:modified_time" content="2018-10-18T22:53:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">斯坦福大学-自然语言处理入门 笔记 第九课 信息抽取（information extraction）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>一、介绍</h2> 
<h3><a id="1information_extraction_1"></a>1、信息抽取（information extraction）</h3> 
<ul><li>信息抽取（IE）系统 
  <ul><li>找到并理解文本中的有限的相关性</li><li>从很多的文档之中收集信息</li><li>产生一个相关信息的结构化的表征</li><li>目的： 
    <ul><li>进行信息的组织使之对人有用</li><li>以相对精确的语义形式存放信息方便计算机算法后续的查找</li></ul> </li></ul> </li><li>信息抽取（IE）系统一般会抽取清晰的实际的信息（谁对谁做了什么在什么时候）<br> <img src="https://images2.imgbox.com/54/b8/sudGg2cc_o.png" alt="在这里插入图片描述"></li><li>低程度的信息抽取 
  <ul><li>一般被用在苹果或者是谷歌的邮件上，或者是web索引。通常是基于正则表达和名字列表。<br> <img src="https://images2.imgbox.com/37/4e/dKYfUlbe_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d0/28/nup5U2Vx_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<h3><a id="2named_entity_recognition_15"></a>2、命名实体识别（named entity recognition）</h3> 
<ul><li>这是在信息抽取中十分重要的一个分支：找到并识别文档中的名字<br> <img src="https://images2.imgbox.com/62/9d/04DimHN6_o.png" alt="在这里插入图片描述"></li><li>主要用途： 
  <ul><li>命名实体的索引（index）和链接(link off）</li><li>分析情感指向的公司或者产品</li><li>很多信息抽取的关系都是和命名实体相关</li><li>在问题回答（question answer）领域，答案往往是命名实体。</li></ul> </li></ul> 
<h2><a id="_23"></a>二、命名实体识别的评估</h2> 
<ul><li>正确识别一个命名实体，需要包含两个方面，一方面需要找到表示命名实体的词组，另一方面对命名实体正确归类，如果下图所示：<br> <img src="https://images2.imgbox.com/0c/be/rbht2ly2_o.png" alt="在这里插入图片描述"></li><li>对命名实体识别（NER）或者信息抽取（IE）而言，用之前介绍的recall和precision来进行评估会存在一个问题：没有办法定义边界错误（boundary error）。举例子而言：<br> 对于句子：First <strong>Bank of Chicago</strong> announced earnings…而言，机器识别Bank of Chicago作为实体，但实际First <strong>Bank of Chicago</strong>才是命名实体。对于这样的错误，我们在归类的时候即可以归到FN也可以归到FP。所以，基于这样的度量标准，实际上边界错误比无法识别（只会归类到FN）更严重。</li><li>其他度量，比如MUC得分会好一些</li></ul> 
<h2><a id="sequence_model_29"></a>三、命名实体识别的序列模型（sequence model）</h2> 
<h3><a id="1NER_30"></a>1、命名实体识别（NER）的机器学习序列模型</h3> 
<ul><li>训练 
  <ul><li>收集一系列有代表性的训练文档</li><li>给每个token标注它的类别，如果不是命名实体的话就标注other（O)</li><li>设计适合文档和类别的特征抽取机制</li><li>训练一个序列分类来预测数据的类别</li></ul> </li><li>测试 
  <ul><li>一系列的测试文档</li><li>运行序列模型来给每个token进行标注</li><li>输出识别出的实体</li></ul> </li></ul> 
<h3><a id="2_40"></a>2、对序列标注进行类别编码</h3> 
<p>这里有两种可以使用的编码方式：</p> 
<ul><li>IO编码，只标记每个词的类别。这里需要的标注个数是C＋１。</li><li>IOB编码，除了标记每个词的类别之外，标记还会表示出这个类别的开始和结束，如下图B－PER表示Person类别的开始，I－PER表示person类别的结束。这样的话，当几个相同的命名实体是连在一起的时候，我们可以区分出有几个命名实体。这里需要的标注个数是２C＋１。<br> <img src="https://images2.imgbox.com/98/11/v2Xvqwuw_o.png" alt="在这里插入图片描述"></li><li>在实际应用中，IO编码效果可能会更好。（在Stanford的姓名粗识别中使用IO编码） 
  <ul><li>一方面是IO编码的速度更快，标注数量更少</li><li>另一方面，几个相同的命名实体是连在一起的情况很少，而且在这个情况下IOB编码也很难正确识别出命名实体的开始和结束。</li></ul> </li></ul> 
<h3><a id="3_48"></a>3、序列标记的特征</h3> 
<ul><li>单词 
  <ul><li>目前的单词</li><li>前一个/后一个单词（上下文）</li></ul> </li><li>其他推论型的语言分类 
  <ul><li>词类标记</li></ul> </li><li>上下文的标签（label） 
  <ul><li>前一个（或者后一个）词的标签</li></ul> </li><li>单词的子字符串：我们可以利用单词中的某些字符来进行判别，比如含有oxa子字符串的单词都是drug。<br> <img src="https://images2.imgbox.com/37/31/OLXcnVGg_o.png" alt="在这里插入图片描述"></li><li>单词的形状：包括单词的长度、大小写、是否含有数字、是否含有希腊字母、连词符。利用下面的规则，我们将其抽取成特征。 
  <ul><li>A，B，C…→X</li><li>a,b,c→x</li><li>1，2，3…→d</li><li>- → -</li><li>. → .</li><li>对于长过四个字母的单词，我们取前两个和后两个；如果单词小于四个的话，我们就按照原来的长度转化。</li><li>例子如下：<br> <img src="https://images2.imgbox.com/a6/c2/yQIHpSOP_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<h2><a id="MEMMs_67"></a>四、最大熵马尔可夫模型（MEMMs）/条件马尔可夫模型</h2> 
<p>很多在NLP领域的问题的数据都是序列数据（单词序列，方块字序列，行序列，句子序列等等）。而我们的任务则是对每一项都进行标注。<br> <img src="https://images2.imgbox.com/bd/e5/dTcRFsT6_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1MEMMs_70"></a>1、最大熵马尔可夫模型（MEMMs）/条件马尔可夫模型</h3> 
<ul><li>最大熵马尔可夫模型（MEMMs）/条件马尔可夫模型，这两个分类器都是每次做一个决定，基于目前的观测和过去的决定（decision）。</li><li>每一次进行分类，目的是对目前的单词进行标注，该分类器的计算和标准分类器是类似的。</li><li>所使用的特征包括单词（之前，目前，之后），标注（之前的单词），还有其他的单词特征（单词类型、后缀、-等等）<br> <img src="https://images2.imgbox.com/cd/eb/cJMpS4kU_o.png" alt="在这里插入图片描述"></li><li>整体的推断系统如下<br> <img src="https://images2.imgbox.com/06/63/0RacHIxx_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="2_77"></a>2、三种推断</h3> 
<ul><li>贪婪推断（greedy inference） 
  <ul><li>从左边开始，用分类器依次给每个位置标记（label），分类器可以依靠之前的标记结果以及观测数据。</li><li>优点： 
    <ul><li>快，没有额外的空间存储要求</li><li>非常容易实施</li><li>当特征很多的时候效果很好</li></ul> </li><li>缺点 
    <ul><li>因为使用的是贪婪算法，所以可能会发生标记错误</li></ul> </li></ul> </li><li>束推断（beam inference） 
  <ul><li>这个方法不会简单标记每个单词，相反它会保留下一些可能，在每个位置都保持前k个序列（束），每次完成一个标记就滑动前进一个序列。</li><li>优点 
    <ul><li>快，3-5个单词的束就可以得到比较好的效果</li><li>很容易实施（不需要进行动态规划）</li></ul> </li><li>缺点 
    <ul><li>对有些标记而言，可能在表现出比较好的概率之前，就已经离开波束了</li></ul> </li></ul> </li><li>维特比推断（Viterbi Inference） 
  <ul><li>动态规划，需要关于状态影响的滑动窗口（比如，过去的两个状态是相关的）</li><li>优点：精确</li><li>缺点：对长距离的单词与单词之间的影响很难应用（束推断也不允许长距离的序列）。</li></ul> </li></ul> 
<h3><a id="3CRFs_97"></a>3、条件随机场（CRFs)</h3> 
<p>这也是一个整个序列的条件模型，而不是链式的模型（local model）。模型形如下图，只不过c和d是序列。但是如果特征f是当前（local）的，条件序列似然可以用动态规划来计算。<br> <img src="https://images2.imgbox.com/bd/70/dpDG7OxG_o.png" alt="在这里插入图片描述"></p> 
<ul><li>条件随机场的训练是很慢的，但是可以避免causal-competition偏误</li><li>有一些比较先进的方法都在被广泛的应用：比如a variant using a max margin criterion</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/72dca9887751120a831dfe98289205d0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux中文件名有英文括号的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0dcdab913b14d1ff2d8d81a1105b3850/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;——复制构造函数和赋值运算符</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>