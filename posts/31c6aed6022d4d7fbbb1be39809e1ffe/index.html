<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker容器技术之私有仓库搭建与使用（8） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker容器技术之私有仓库搭建与使用（8）" />
<meta property="og:description" content="文章目录 1. Docker Registry2. Docker私有Registry2.1 使用docker-distribution自建Registry2.2 使用官方镜像自建Registry 3. Harbor3.1 Docker compose3.2 部署Harbor3.3 注意事项 1. Docker Registry 网上有很多的Registry服务器都支持第三方用户注册，而后基于用户名去做自己的仓库，但是使用互联网上的Registry有一个缺陷，那就是我们去推送和下载镜像时都不会很快，而在生产环境中很可能并行启动的容器将达到几十、上百个，而且很有可能每个服务器本地是没有镜像的，此时如果通过互联网去下载镜像会有很多问题，比如下载速度会很慢、带宽会用很多等等，如果带宽不够的话，下载至启动这个过程可能要持续个几十分钟，这已然违背了使用容器会更加轻量、快速的初衷和目的。因此，很多时候我们很有可能需要去做自己的私有Registry。
Docker Registry分类：
Sponsor Registry：第三方的Registry，供客户和Docker社区使用Mirror Registry：第三方的Registry，只让客户使用Vendor Registry：由发布docker镜像的供应商提供的registryPrivate Registry：通过设有防火墙和额外的安全层的私有实体提供的registry 事实上，如果运维的系统环境托管在云计算服务上，比如阿里云，那么用阿里云的Registry则是最好的选择。很多时候我们的生产环境不会在本地，而是托管在数据中心机房里，如果我们在数据中心机房里的某台主机上部署Registry，因为都在同一机房，所以属于同一局域网，此时数据传输走内网，效率会极大的提升。
所有的Registry默认情况下都是基于https工作的，这是Docker的基本要求，而我自建Registry时很可能是基于http工作的，但是Docker默认是拒绝使用http提供Registry服务的，除非明确的告诉它，我们就是要用http协议的Registry。
2. Docker私有Registry 为了帮助我们快速创建私有Registry，Docker专门提供了一个名为docker-distribution的软件包，我们可以通过安装这个软件包快速构建私有仓库。
当然，官方也提供了Registry的镜像，我们可以直接将其pull到本地并启动为容器即可快速实现私有Registry。
2.1 使用docker-distribution自建Registry 环境：
角色主机名IPdockernode02192.168.159.161registrynode01192.168.159.145 在node01上安装docker-distribution
[root@node01 ~]# yum -y install docker-distribution [root@node01 ~]# vim /etc/docker-distribution/registry/config.yml ... version: 0.1 log: fields: service: registry storage: cache: layerinfo: inmemory filesystem: rootdirectory: /var/lib/registry //这里可以修改镜像存放目录 http: addr: :5000 ... [root@node01 ~]# systemctl enable --now docker-distribution [root@node01 ~]# ss -antl|grep 5000 LISTEN 0 128 [::]:5000 [::]:* 在node02上使用自建的Registry去上传镜像" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/31c6aed6022d4d7fbbb1be39809e1ffe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-01T21:31:27+08:00" />
<meta property="article:modified_time" content="2020-09-01T21:31:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker容器技术之私有仓库搭建与使用（8）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1_Docker_Registry_1" rel="nofollow">1. Docker Registry</a></li><li><a href="#2_DockerRegistry_15" rel="nofollow">2. Docker私有Registry</a></li><li><ul><li><a href="#21_dockerdistributionRegistry_20" rel="nofollow">2.1 使用docker-distribution自建Registry</a></li><li><a href="#22_Registry_75" rel="nofollow">2.2 使用官方镜像自建Registry</a></li></ul> 
  </li><li><a href="#3_Harbor_90" rel="nofollow">3. Harbor</a></li><li><ul><li><a href="#31_Docker_compose_99" rel="nofollow">3.1 Docker compose</a></li><li><a href="#32_Harbor_103" rel="nofollow">3.2 部署Harbor</a></li><li><a href="#33__191" rel="nofollow">3.3 注意事项</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1_Docker_Registry_1"></a>1. Docker Registry</h2> 
<hr> 
<p>网上有很多的<code>Registry</code>服务器都支持第三方用户注册，而后基于用户名去做自己的仓库，但是使用互联网上的<code>Registry</code>有一个缺陷，那就是我们去推送和下载镜像时都不会很快，而在生产环境中很可能并行启动的容器将达到几十、上百个，而且很有可能每个服务器本地是没有镜像的，此时如果通过互联网去下载镜像会有很多问题，比如下载速度会很慢、带宽会用很多等等，如果带宽不够的话，下载至启动这个过程可能要持续个几十分钟，这已然违背了使用容器会更加轻量、快速的初衷和目的。因此，很多时候我们很有可能需要去做自己的私有<code>Registry</code>。</p> 
<p><strong>Docker Registry分类：</strong></p> 
<ul><li>Sponsor Registry：第三方的Registry，供客户和Docker社区使用</li><li>Mirror Registry：第三方的Registry，只让客户使用</li><li>Vendor Registry：由发布docker镜像的供应商提供的registry</li><li>Private Registry：通过设有防火墙和额外的安全层的私有实体提供的registry</li></ul> 
<p>事实上，如果运维的系统环境托管在云计算服务上，比如阿里云，那么用阿里云的<code>Registry</code>则是最好的选择。很多时候我们的生产环境不会在本地，而是托管在数据中心机房里，如果我们在数据中心机房里的某台主机上部署<code>Registry</code>，因为都在同一机房，所以属于同一局域网，此时数据传输走内网，效率会极大的提升。</p> 
<p>所有的<code>Registry</code>默认情况下都是基于https工作的，这是Docker的基本要求，而我自建<code>Registry</code>时很可能是基于http工作的，但是Docker默认是拒绝使用http提供<code>Registry</code>服务的，除非明确的告诉它，我们就是要用http协议的<code>Registry</code>。</p> 
<h2><a id="2_DockerRegistry_15"></a>2. Docker私有Registry</h2> 
<hr> 
<p>为了帮助我们快速创建私有<code>Registry</code>，Docker专门提供了一个名为<code>docker-distribution</code>的软件包，我们可以通过安装这个软件包快速构建私有仓库。</p> 
<p>当然，官方也提供了<code>Registry</code>的镜像，我们可以直接将其pull到本地并启动为容器即可快速实现私有<code>Registry</code>。</p> 
<h3><a id="21_dockerdistributionRegistry_20"></a>2.1 使用docker-distribution自建Registry</h3> 
<p>环境：</p> 
<table><thead><tr><th>角色</th><th>主机名</th><th>IP</th></tr></thead><tbody><tr><td>docker</td><td>node02</td><td>192.168.159.161</td></tr><tr><td>registry</td><td>node01</td><td>192.168.159.145</td></tr></tbody></table> 
<p>在node01上安装docker-distribution</p> 
<pre><code>[root@node01 ~]# yum -y install docker-distribution
[root@node01 ~]# vim /etc/docker-distribution/registry/config.yml
...
version: 0.1
log:
  fields:
    service: registry
storage:
    cache:
        layerinfo: inmemory
    filesystem:
        rootdirectory: /var/lib/registry   //这里可以修改镜像存放目录
http:
    addr: :5000
...
[root@node01 ~]# systemctl enable --now docker-distribution
[root@node01 ~]# ss -antl|grep 5000
LISTEN     0      128       [::]:5000                  [::]:*
</code></pre> 
<p>在node02上使用自建的Registry去上传镜像</p> 
<pre><code>//使用insecure-registries参数添加http支持
[root@node02 ~]# vim /etc/docker/daemon.json
{
    "registry-mirrors": ["https://registry.docker-cn.com"],
    "insecure-registries": ["192.168.159.145:5000"]
}
[root@node02 ~]# systemctl restart docker

//将本地镜像传到自建的registry中
[root@node02 ~]# docker images            
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
docker.io/httpd     latest              a6ea92c35c43        3 weeks ago         166 MB
[root@node02 ~]# docker tag httpd:latest node01:5000/httpd:latest
[root@node02 ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
192.168.159.145:5000/httpd   latest              a6ea92c35c43        3 weeks ago         166 MB
docker.io/httpd     latest              a6ea92c35c43        3 weeks ago         166 MB
[root@node02 ~]# docker push 192.168.159.145:5000/httpd
The push refers to a repository [192.168.159.145:5000/httpd]
88b680b1fdfc: Pushed 
843c3701e622: Pushed 
3ba8a4f66ba2: Pushed 
c865989f86f7: Pushed 
d0f104dc0a1f: Pushed 
latest: digest: sha256:fc717ed0d0b55ada05af1c1a95a2d4ee1153a5858fd65b654644a1a5add0c28b size: 1367
</code></pre> 
<h3><a id="22_Registry_75"></a>2.2 使用官方镜像自建Registry</h3> 
<pre><code>[root@node01 ~]# docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry

[root@node01 ~]# ss -antl
State       Recv-Q Send-Q Local Address:Port               Peer Address:Port              
LISTEN      0      100    127.0.0.1:25                  *:*                  
LISTEN      0      128     *:22                  *:*                  
LISTEN      0      100     [::1]:25                   [::]:*                  
LISTEN      0      128      [::]:5000                 [::]:*                  
LISTEN      0      128      [::]:22                   [::]:*
</code></pre> 
<p>无论是使用Docker-distribution去自建仓库，还是通过官方镜像跑容器的方式去自建仓库，通过前面的演示我们可以发现其是非常的简陋的，还不如直接使用官方的Docker Hub去管理镜像来得方便，至少官方的Docker Hub能够通过web界面来管理镜像，还能在web界面执行搜索，还能基于Dockerfile利用Webhooks和Automated Builds实现自动构建镜像的功能，用户不需要在本地执行docker build，而是把所有build上下文的文件作为一个仓库推送到github上，让Docker Hub可以从github上去pull这些文件来完成自动构建。</p> 
<p>但无论官方的Docker Hub有多强大，它毕竟是在国外，所以速度是最大的瓶颈，我们很多时候是不可能去考虑使用官方的仓库的，但是上面说的两种自建仓库方式又十分简陋，不便管理，所以后来就出现了一个被 CNCF 组织青睐的项目，其名为Harbor。</p> 
<h2><a id="3_Harbor_90"></a>3. Harbor</h2> 
<hr> 
<p><code>Harbor</code>是由VMWare在Docker Registry的基础之上进行了二次封装，加进去了很多额外程序，而且提供了一个非常漂亮的web界面。</p> 
<p>Project Harbor是一个开源的受信任云本地注册表项目，用于存储、标记和扫描上下文。</p> 
<p>Harbor通过添加用户通常需要的功能，如安全性、身份标识和管理，扩展了开源Docker发行版。</p> 
<p>Harbor支持用户管理、访问控制、活动监控和实例之间的复制等高级特性。</p> 
<h3><a id="31_Docker_compose_99"></a>3.1 Docker compose</h3> 
<p>Harbor在物理机上部署是非常难的，而为了简化Harbor的应用，Harbor官方直接把Harbor做成了在容器中运行的应用，而且这个容器在Harbor中依赖类似redis、mysql、pgsql等很多存储系统，所以它需要编排很多容器协同起来工作，因此VMWare Harbor在部署和使用时，需要借助于Docker的单机编排工具(Docker compose)来实现。</p> 
<p>Compose是一个用于定义和运行多容器Docker应用程序的工具。使用Compose，您可以使用一个YAML文件来配置应用程序的服务。然后，使用一个命令，您可以从您的配置中创建并启动所有的服务。</p> 
<h3><a id="32_Harbor_103"></a>3.2 部署Harbor</h3> 
<pre><code>[root@node01 ~]# wget -O /etc/yum.repos.d/docker-ce.repo https://download.docker.com/linux/centos/docker-ce.repo
[root@node01 ~]# yum -y install docker-compose docker-ce
[root@node01 ~]# systemctl enable --now docker
[root@node01 ~]# wget https://github.com/goharbor/harbor/releases/download/v2.0.2/harbor-offline-installer-v2.0.2.tgz
[root@node01 ~]# ls
harbor-offline-installer-v2.0.2.tgz
[root@node01 ~]# tar xf harbor-offline-installer-v2.0.2.tgz -C /usr/local/
[root@node01 ~]# cd /usr/local/harbor/
[root@node01 harbor]# ls
common.sh             harbor.yml.tmpl  LICENSE
harbor.v2.0.2.tar.gz  install.sh       prepare
[root@node01 harbor]# mv harbor.yml.tmpl harbor.yml
[root@node01 harbor]# vim harbor.yml
...
hostname: 192.168.159.145   //将此行修改为harbor所在的主机名或IP
...
//如果没有证书将以下内容全部注释，如果有证书将最后两行更改为证书的路径
#https:
  # https port for harbor, default is 443
#  port: 443
  # The path of cert and key files for nginx
#  certificate: /your/certificate/path
#  private_key: /your/private/key/path
...

[root@node01 harbor]# ./install.sh
Clean up the input dir


Creating redis ... done
Creating harbor-core ... done
Creating network "harbor_harbor" with the default driver
Creating nginx ... done
Creating redis ... 
Creating registryctl ... 
Creating harbor-portal ... 
Creating harbor-db ... 
Creating registry ... 
Creating harbor-core ... 
Creating harbor-jobservice ... 
Creating nginx ... 
✔ ----Harbor has been installed and started successfully.----

[root@node01 harbor]# ss -anlt
State       Recv-Q Send-Q Local Address:Port                Peer Address:Port              
LISTEN      0      128        127.0.0.1:1514                           *:*                  
LISTEN      0      128                *:22                             *:*                  
LISTEN      0      100        127.0.0.1:25                             *:*                  
LISTEN      0      128               :::80                            :::*                  
LISTEN      0      128               :::22                            :::*                  
LISTEN      0      100              ::1:25                            :::*
</code></pre> 
<p><strong>使用IP登录Harbor，默认登录用户名为<code>admin</code>，登录密码为<code>Harbor12345</code></strong><br> <img src="https://images2.imgbox.com/b9/86/A867G69E_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c7/c3/CHBG5IgA_o.png" alt="在这里插入图片描述"><br> 在node02上登录harbor</p> 
<pre><code>[root@node02 ~]# vim /etc/docker/daemon.json
[root@node02 ~]# systemctl restart docker
[root@node02 ~]# docker login 192.168.159.145
Username: admin
Password: 
WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded

[root@node02 ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
nginx               latest              4bb46517cac3        2 weeks ago         133MB
[root@node02 ~]# docker tag nginx:latest 192.168.159.145/test/nginx:latest
[root@node02 ~]# docker images
REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
192.168.159.145/test/nginx   latest              4bb46517cac3        2 weeks ago         133MB
nginx                        latest              4bb46517cac3        2 weeks ago         133MB
[root@node02 ~]# docker push 192.168.159.145/test/nginx:latest
The push refers to repository [192.168.159.145/test/nginx]
550333325e31: Pushed 
22ea89b1a816: Pushed 
a4d893caa5c9: Pushed 
0338db614b95: Pushed 
d0f104dc0a1f: Pushed 
latest: digest: sha256:179412c42fe3336e7cdc253ad4a2e03d32f50e3037a860cf5edbeb1aaddb915c size: 1362
</code></pre> 
<p><img src="https://images2.imgbox.com/bd/44/Z16LwsqT_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="33__191"></a>3.3 注意事项</h3> 
<p>在客户端上传镜像时一定要记得执行docker login进行用户认证，否则无法直接push</p> 
<p>在客户端使用的时候如果不是用的https则必须要在客户端的/etc/docker/daemon.json配置文件中配置insecure-registries参数</p> 
<p>数据存放路径应在配置文件中配置到一个容量比较充足的共享存储中</p> 
<p>Harbor是使用docker-compose命令来管理的，如果需要停止Harbor也应用docker-compose stop来停止，其他参数请–help</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f573e8e5269d292bd61d6decef150185/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringMVC的执行流程以及运行原理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/af8c0b355e60d06af1b9feb9db49f956/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WebSphere性能调优</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>