<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>异步爬虫-协程的使用 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="异步爬虫-协程的使用" />
<meta property="og:description" content="协程的基本原理 要想实现异步机制的爬虫，自然和协程逃脱不了关系。
1.案例引入 在介绍协程之前，先引入https://www.httpbin.org/delay/5这个网站，访问这个网站需要服务器强制等待5秒才会返回响应。
我们使用requests写一个遍历程序，直接遍历100次该网站，看下需要多久时间。
import requests import logging import time logging.basicConfig(level=logging.INFO,format=&#39;%(asctime)s - %(levelname)s - %(message)s&#39;) TOTAL_NUMBER = 10 url = &#39;https://www.httpbin.org/delay/5&#39; start_time = time.time() for _ in range(1,TOTAL_NUMBER&#43;1): logging.info(&#39;scraping %s&#39;,url) response = requests.get(url) end_time = time.time() logging.info(&#39;total time %s seconds&#39;,end_time-start_time) 这里使用的requests是单线程，由于每个页面都要等待至少5秒，请求100次至少花费500秒加上网站本身负载问题，总时间大约会在10分钟以上，耗时比较久，所以开启多线程爬取非常有必要。
2.基础概念知识 阻塞
程序在等待某个操作完成期间，自身无法干别的事情，则该程序在操作上是阻塞的。非阻塞
程序在等待某个操作期间，自身不被阻塞可以继续干别的事情，则该程序在操作上是非阻塞的。同步
不同程序单元为了共同完成某个任务，在执行过程中需要靠某种通讯方式保持一致，此时这些程序单元是同步执行的。
同步意味着有序。异步
异步意味着无序。多进程
就是利用cpu的多核优势，在同一时间内并行执行多个任务。协程
又称微线程，是一种运行在用户态的一种轻量级线程。协程本质上是一个单进程。
进程是线程的集合，一个任务对应一个线程。 3.协程的用法 python中使用协程最常用的库莫过于asyncio。
event_loop：相当于一个无限循环，我们可以把一些函数注册到这个事件循环上，当满足条件发生的时候，就调用对应的处理办法。coroutine：协程。我们可以使用async关键字来定义一个方法，这个方法在调用时不会立即执行，而是会返回一个协程对象。task：任务，这是对协程对象的进一步封装，包括协程对象的各个状态。future：代表将来执行或者没有执行的结果，和task没有本质区别。
async和await。前者来定义一个协程，后者用来挂起阻塞方法的执行。 4.准备工作 Python3.5及以上。
5.定义协程 先来定义一个协程，体验下它和普通进程实现上的不同之处。
import asyncio async def execute(x): print(&#39;number:&#39;,x) coroutine = execute(1) print(&#39;Coroutine:&#39;,coroutine) print(&#39;After calling exxecute&#39;) loop = asyncio." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ddc3a071e801a2e78fcf05c3feb2ee0a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-03T10:50:27+08:00" />
<meta property="article:modified_time" content="2024-01-03T10:50:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">异步爬虫-协程的使用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>协程的基本原理</h2> 
<p>  要想实现异步机制的爬虫，自然和协程逃脱不了关系。</p> 
<h3><a id="1_2"></a>1.案例引入</h3> 
<p>  在介绍协程之前，先引入<a href="https://www.httpbin.org/delay/5" rel="nofollow">https://www.httpbin.org/delay/5</a>这个网站，访问这个网站需要服务器强制等待5秒才会返回响应。<br>   我们使用requests写一个遍历程序，直接遍历100次该网站，看下需要多久时间。</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> requests
<span class="token keyword">import</span> logging
<span class="token keyword">import</span> time

logging<span class="token punctuation">.</span>basicConfig<span class="token punctuation">(</span>level<span class="token operator">=</span>logging<span class="token punctuation">.</span>INFO<span class="token punctuation">,</span><span class="token builtin">format</span><span class="token operator">=</span><span class="token string">'%(asctime)s - %(levelname)s - %(message)s'</span><span class="token punctuation">)</span>

TOTAL_NUMBER <span class="token operator">=</span> <span class="token number">10</span>
url <span class="token operator">=</span> <span class="token string">'https://www.httpbin.org/delay/5'</span>

start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>TOTAL_NUMBER<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    logging<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">'scraping %s'</span><span class="token punctuation">,</span>url<span class="token punctuation">)</span>
    response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>

end_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
logging<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">'total time %s seconds'</span><span class="token punctuation">,</span>end_time<span class="token operator">-</span>start_time<span class="token punctuation">)</span>
</code></pre> 
<p>  这里使用的requests是单线程，由于每个页面都要等待至少5秒，请求100次至少花费500秒加上网站本身负载问题，总时间大约会在10分钟以上，耗时比较久，所以开启多线程爬取非常有必要。</p> 
<h3><a id="2_27"></a>2.基础概念知识</h3> 
<ul><li>阻塞<br>   程序在等待某个操作完成期间，自身无法干别的事情，则该程序在操作上是阻塞的。</li><li>非阻塞<br>   程序在等待某个操作期间，自身不被阻塞可以继续干别的事情，则该程序在操作上是非阻塞的。</li><li>同步<br>   不同程序单元为了共同完成某个任务，在执行过程中需要靠某种通讯方式保持一致，此时这些程序单元是同步执行的。<br>   同步意味着有序。</li><li>异步<br>   异步意味着无序。</li><li>多进程<br>   就是利用cpu的多核优势，在同一时间内并行执行多个任务。</li><li>协程<br>   又称微线程，是一种运行在用户态的一种轻量级线程。协程本质上是一个单进程。<br>   进程是线程的集合，一个任务对应一个线程。</li></ul> 
<h3><a id="3_43"></a>3.协程的用法</h3> 
<p>  python中使用协程最常用的库莫过于asyncio。</p> 
<ul><li>event_loop：相当于一个无限循环，我们可以把一些函数注册到这个事件循环上，当满足条件发生的时候，就调用对应的处理办法。</li><li>coroutine：协程。我们可以使用async关键字来定义一个方法，这个方法在调用时不会立即执行，而是会返回一个协程对象。</li><li>task：任务，这是对协程对象的进一步封装，包括协程对象的各个状态。</li><li>future：代表将来执行或者没有执行的结果，和task没有本质区别。<br>   async和await。前者来定义一个协程，后者用来挂起阻塞方法的执行。</li></ul> 
<h3><a id="4_52"></a>4.准备工作</h3> 
<p>  Python3.5及以上。</p> 
<h3><a id="5_54"></a>5.定义协程</h3> 
<p>  先来定义一个协程，体验下它和普通进程实现上的不同之处。</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> asyncio

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">execute</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'number:'</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span>

coroutine <span class="token operator">=</span> execute<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Coroutine:'</span><span class="token punctuation">,</span>coroutine<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'After calling exxecute'</span><span class="token punctuation">)</span>

loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>
loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>coroutine<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'After calling loop'</span><span class="token punctuation">)</span>
</code></pre> 
<p>  首先，引入了asyncio包，这样才可以使用async和await关键字。然后使用了async定义了一个execute方法，该方法接受一个数字参数x，执行之后打印该数字。<br>   随后我们直接调用了execute方法，然而这个方法并没有执行，而是返回了一个coroutine对象。之后使用get_event_loop方法创建了一个时间循环loop，并调用loop对象的run_until_complete方法将协程对象注册到了事件循环中，接着启动，最后才能看到execute打印出了收的数字。<br>   由此可见，async定义的方法会变成一个无法直接执行的协程对象，必须将此对象注册到事件循环中才可以执行。<br>   上面这个例子我们把协程对象coroutine传递给run_until_complete方法的时候，实际上就是将coroutine封装成task对象。task它是对协程对象的进一步封装，比协程对象多了运行状态，例如running，finished等，我们可以利用这些状态获得协程对象的执行情况。相比于上个例子如果想要显示的进行声明，代码如下：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> asyncio 

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">execute</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Number'</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span>
    <span class="token keyword">return</span> x

coroutine <span class="token operator">=</span> execute<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Coroutine:'</span><span class="token punctuation">,</span>coroutine<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'After calling execute'</span><span class="token punctuation">)</span>

loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>
task <span class="token operator">=</span> loop<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>coroutine<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Task:'</span><span class="token punctuation">,</span>task<span class="token punctuation">)</span>
loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>task<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Task:'</span><span class="token punctuation">,</span>task<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'After calling loop'</span><span class="token punctuation">)</span>
</code></pre> 
<p>  这里定义了loop对象后，紧接着调用了他的create_task方法，将协程对象转化为task对象，随后打印输出发现处于pending状态。然后将task对象添加到事件循环中执行，并再次打印出task对象，发现其状态变成了finished，同时还可以看到其result变成了1，也就是我们定义的execute方法返回的结果。<br>   定义task对象还有另外一种方式，就是直接调用asyncio包的ensure_future方法，返回结果也是task对象，这样的话可以不借助loop对象。即使还没有声明loop，也可以提前定义好task对象。</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> asyncio

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">execute</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Number:'</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span>
    <span class="token keyword">return</span> x

coroutine <span class="token operator">=</span> execute<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Coroutine:'</span><span class="token punctuation">,</span>coroutine<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'After calling execute'</span><span class="token punctuation">)</span>

task <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>ensure_future<span class="token punctuation">(</span>coroutine<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Task:'</span><span class="token punctuation">,</span>task<span class="token punctuation">)</span>
loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>
loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>task<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Task:'</span><span class="token punctuation">,</span>task<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'After calling loop'</span><span class="token punctuation">)</span>
</code></pre> 
<p>  可以看到，运行效果是一致的。</p> 
<h3><a id="6_120"></a>6.绑定回调</h3> 
<p>  我们也可以为某个task对象绑定一个回调方法。示例如下：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> asyncio
<span class="token keyword">import</span> requests

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    url <span class="token operator">=</span> <span class="token string">'https://www.baidu.com'</span>
    status <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>
    <span class="token keyword">return</span> status

<span class="token keyword">def</span> <span class="token function">callback</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Status:'</span><span class="token punctuation">,</span>task<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

coroutine <span class="token operator">=</span> request<span class="token punctuation">(</span><span class="token punctuation">)</span>
task <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>ensure_future<span class="token punctuation">(</span>coroutine<span class="token punctuation">)</span>
task<span class="token punctuation">.</span>add_done_callback<span class="token punctuation">(</span>callback<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Task:'</span><span class="token punctuation">,</span>task<span class="token punctuation">)</span>

loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>
loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>task<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Task:'</span><span class="token punctuation">,</span>task<span class="token punctuation">)</span>
</code></pre> 
<p>  这里定义了request方法，用这个方法请求百度，并获取其状态码，但是没有编写任何print语句。随后定义了callback方法，这个方法接收一个参数，参数是task对象，在这个方法中调用print方法打印出了task对象的结果。这样就定义好了一个协程对象和一个回调方法。希望达到的小伙就是：当协程对象执行完毕后，就去执行声明的cellback方法。<br>   两者关联起来，只需调用add_done_callback方法。我们将callback方法传递给封装好的task对象，这样当task执行完毕后，就可以调用callback方法了。同时task对象还会作为参数传递给callback方法，调用task对象的result方法就可以获取任何返回结果了。<br>   实际上，即使不使用回调方法，在task执行完毕后，也可以直接调用result方法获取结果。</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> asyncio
<span class="token keyword">import</span> requests

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    url <span class="token operator">=</span> <span class="token string">'https://www.baidu.com'</span>
    status <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>
    <span class="token keyword">return</span> status
coroutine <span class="token operator">=</span> request<span class="token punctuation">(</span><span class="token punctuation">)</span>
task <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>ensure_future<span class="token punctuation">(</span>coroutine<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Task:'</span><span class="token punctuation">,</span>task<span class="token punctuation">)</span>

loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>
loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>task<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Task:'</span><span class="token punctuation">,</span>task<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Task Result:'</span><span class="token punctuation">,</span>task<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="7_167"></a>7.多任务协程</h3> 
<p>  在上面的例子中，我们都只执行了一次请求，如果想执行多次请求，可以定义一个task列表，然后用asyncio中wait方法执行。</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> asyncio
<span class="token keyword">import</span> requests

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    url <span class="token operator">=</span> <span class="token string">'https://www.baidu.com'</span>
    Status <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>
    <span class="token keyword">return</span> Status

tasks <span class="token operator">=</span> <span class="token punctuation">[</span>asyncio<span class="token punctuation">.</span>ensure_future<span class="token punctuation">(</span>request<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Tasks:'</span><span class="token punctuation">,</span>tasks<span class="token punctuation">)</span>

loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>
loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>asyncio<span class="token punctuation">.</span>wait<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">for</span> task <span class="token keyword">in</span> tasks<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Task Result:'</span><span class="token punctuation">,</span>task<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>  这里我们使用for循环创建了5个task，它们组成一个列表，然后把这个列表优先传递给asyncio包的wait方法，再将其注册到事件循环中，就可以发起5个任务了。最后，输出任务的执行结果。</p> 
<h3><a id="8_190"></a>8.协程实现</h3> 
<p>  接下来，我们正式看看协程在解决IO密集型任务方面有什么优势？<br>   在第一个代码中，我们用一个网络请求作为例子，这本身就是一个耗时等待的操作，因为在请求网页之后需要等待页面响应并返回结果。耗时等待操作一般都是IO操作，例如文件读取、网络请求等。协程在处理这种操作时是有很大优势的，但遇到需要等待的情况时，程序暂时挂起，转而执行其他操作，从而避免一直等待一个程序而耗费更多的时间，能够充分利用资源。<br>   首先，我们利用开头的访问的网站示例，演示下常犯的错误，后面再给出正确的例子做对比。这里还是拿之前的requests库进行请求。</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> asyncio
<span class="token keyword">import</span> requests
<span class="token keyword">import</span> time

start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    url <span class="token operator">=</span> <span class="token string">'https://www.httpbin.org/delay/5'</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Waiting for'</span><span class="token punctuation">,</span>url<span class="token punctuation">)</span>
    response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Get response from'</span><span class="token punctuation">,</span>url<span class="token punctuation">,</span><span class="token string">'response'</span><span class="token punctuation">,</span>response<span class="token punctuation">)</span>

tasks <span class="token operator">=</span> <span class="token punctuation">[</span>asyncio<span class="token punctuation">.</span>ensure_future<span class="token punctuation">(</span>request<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>
loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>asyncio<span class="token punctuation">.</span>wait<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span class="token punctuation">)</span>

end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Cost time'</span><span class="token punctuation">,</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span>
</code></pre> 
<p>  这里我们创建了10个task，然后将task列表传给wait方法并注册到事件循环中执行。但是运行后发现，这和正常请求没区别，依然是顺次执行的，耗费时长依然很久。为什么呢？<br>   其实，要进行异步处理，先得有挂起操作。上面方法都是一连串的执行下来，连挂起都没有，肯定不可能实现异步。<br>   awit关键字它可以将等待的操作进行挂起，转而执行别的协程，直到其他协程挂起或关闭。<br>   所以，代码的请求我们可以更改下。</p> 
<pre><code class="prism language-python"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    url <span class="token operator">=</span> <span class="token string">'https://www.httpbin.org/delay/5'</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Waiting for'</span><span class="token punctuation">,</span>url<span class="token punctuation">)</span>
    response <span class="token operator">=</span> <span class="token keyword">await</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Get response from'</span><span class="token punctuation">,</span>url<span class="token punctuation">,</span><span class="token string">'response'</span><span class="token punctuation">,</span>response<span class="token punctuation">)</span>
</code></pre> 
<p>  更改后执行之前的代码，发现会报如下错误。<br> <img src="https://images2.imgbox.com/63/06/zawP4kiN_o.png" alt="在这里插入图片描述"><br>   这次确实挂起了也等待了，但是却报错。这个错误意思是requests返回的Response对象不能和await一起使用，根据官方文档说明，await后面的对象必须是如下格式之一。</p> 
<ul><li>一个原生协程对象；</li><li>一个由types.coroutine修饰的生成器，这个生成器可以返回协程对象；</li><li>由一个包含_await_方法的对象返回的一个迭代器。<br>   这里requests返回的Response都不符合，所以报错。<br>   既然await后面可以跟随一个协程对象，那么async把请求的方法改成协程对象可以吗？</li></ul> 
<pre><code class="prism language-python"><span class="token keyword">import</span> asyncio
<span class="token keyword">import</span> requests
<span class="token keyword">import</span> time

start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    url <span class="token operator">=</span> <span class="token string">'https://www.httpbin.org/delay/5'</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Waiting for'</span><span class="token punctuation">,</span>url<span class="token punctuation">)</span>
    response <span class="token operator">=</span> <span class="token keyword">await</span> get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Get response from'</span><span class="token punctuation">,</span>url<span class="token punctuation">,</span><span class="token string">'response'</span><span class="token punctuation">,</span>response<span class="token punctuation">)</span>

tasks <span class="token operator">=</span> <span class="token punctuation">[</span>asyncio<span class="token punctuation">.</span>ensure_future<span class="token punctuation">(</span>request<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>
loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>asyncio<span class="token punctuation">.</span>wait<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span class="token punctuation">)</span>

end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Cost time'</span><span class="token punctuation">,</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span>
</code></pre> 
<p>  这里将请求页面的方法独立出来，并用async修饰，就得到了一个协程对象。<br>   但是运行后发现，依然不是异步执行的，也就是说仅仅将涉及IO操作的代码封装到async修饰的方法里是不可行的。只有使用异步操作的请求方式才可以实现真正的异步，这里aiohttp就派上用场了。</p> 
<h3><a id="9aiohttp_264"></a>9.使用aiohttp</h3> 
<p>  aiohttp是一个支持异步请求的库，它和asyncio配合使用，可以非常方便的进行异步请求操作。<br>   下面使用aiohttp将代码改写下：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> asyncio 
<span class="token keyword">import</span> aiohttp
<span class="token keyword">import</span> time

start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>
    session <span class="token operator">=</span> aiohttp<span class="token punctuation">.</span>ClientSession<span class="token punctuation">(</span><span class="token punctuation">)</span>
    response <span class="token operator">=</span> <span class="token keyword">await</span> session<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>
    <span class="token keyword">await</span> response<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> session<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> response

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">resquest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    url <span class="token operator">=</span> <span class="token string">'https://www.httpbin.org/delay/5'</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Waiting for'</span><span class="token punctuation">,</span>url<span class="token punctuation">)</span>
    response <span class="token operator">=</span> <span class="token keyword">await</span> get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Get response from'</span><span class="token punctuation">,</span>url<span class="token punctuation">,</span><span class="token string">'response'</span><span class="token punctuation">,</span>response<span class="token punctuation">)</span>

tasks <span class="token operator">=</span> <span class="token punctuation">[</span>asyncio<span class="token punctuation">.</span>ensure_future<span class="token punctuation">(</span>resquest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>
loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>asyncio<span class="token punctuation">.</span>wait<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span class="token punctuation">)</span>

end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Cost time'</span><span class="token punctuation">,</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span>
</code></pre> 
<p>  运行后我们将发现，10次请求的耗时由之前的60秒已经缩短到6秒多。<br>   这里我们使用了await，其后面跟着get方法。在执行10个协程的时候，如果遇到await，就会将当前协程挂起，转而执行其他协程，直到其他协程也挂起或执行完毕，再执行下一个协程。<br>   开始运行时，事件循环会执行第一个task，对于第一个task来说，当执行到第一个await跟着的get方法时，它会被挂起，但是第一个get方法是非阻塞的，挂起后会被立马唤醒，立即又进入执行，并创建了ClientSession对象。接着又遇到第二个await，session.get，然后就被挂起，这个请求的时间比较长，所以一直没有被唤醒，好在这个task已经被挂起了，接下来事件循环会找到当前未被挂起的协程继续执行，就去执行第二个task，以此类推，直到第十个循环task的第二个session.get也被挂起，这时全部task都被挂起了，只能等待，5秒之后几个请求几乎都会有响应，然后几个task也被唤醒接着执行，并输出结果。<br>   从理论上来说，只要服务器无限抗压，而且可以忽略IO传输时延，可以做到无限个task一起执行，并且在理想时间内得到结果。但是由于不同服务器处理task的实现机制不同，可能某些服务器不能承受那么么高的并发量，因此响应速度也会减慢。</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> asyncio 
<span class="token keyword">import</span> aiohttp
<span class="token keyword">import</span> time

<span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">:</span>
    start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>
        session <span class="token operator">=</span> aiohttp<span class="token punctuation">.</span>ClientSession<span class="token punctuation">(</span><span class="token punctuation">)</span>
        response <span class="token operator">=</span> <span class="token keyword">await</span> session<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>
        <span class="token keyword">await</span> response<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">await</span> session<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> response
    
    <span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        url <span class="token operator">=</span> <span class="token string">'https://www.baidu.com/'</span>
        <span class="token keyword">await</span> get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>

    tasks <span class="token operator">=</span> <span class="token punctuation">[</span>asyncio<span class="token punctuation">.</span>ensure_future<span class="token punctuation">(</span>request<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">]</span>
    loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>
    loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>asyncio<span class="token punctuation">.</span>wait<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span class="token punctuation">)</span>

    end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Number:'</span><span class="token punctuation">,</span>number<span class="token punctuation">,</span><span class="token string">'Cost time:'</span><span class="token punctuation">,</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span>

<span class="token comment"># for number in [1,3,5,10,15,30,75,100,200,500]:</span>
<span class="token comment">#    test(number)</span>
 <span class="token keyword">for</span> number <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">500</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
     test<span class="token punctuation">(</span>number<span class="token punctuation">)</span>
</code></pre> 
<p>  可以看到在服务器能够承受的情况下，即使增加了并发量，爬取速度也不会受太大影响。<br>   综上所述，能够将异步请求应用到爬虫中，速度提升将会相当可观。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1382c845a03734d628b4954d8f82eda1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Weblogic安全漫谈(二)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/193d3b76557c3f5a8e7fe563dba1dce5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于“Python”的核心知识点整理大全58</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>