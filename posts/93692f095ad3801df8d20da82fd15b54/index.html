<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机图形学学习笔记：规则形体的表示 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="计算机图形学学习笔记：规则形体的表示" />
<meta property="og:description" content="实体模型的三类表示：
边界表示（Boundary Representation, B-reps），即用一组曲面（含平面）来描 述物体，这些曲面将物体分为内部和外部。
边界表示具体又包括多边形表面模型和扫 描表示两种。
构造实体几何表示（Constructive Solid Geometry，CSG），它将实体表示成立 方体、长方体、圆柱体、圆锥体等基于体素的组合，可以采用并、交、差等运算构造新的形体。
空间分割表示（Space-Partitioning），用来描述物体的内部性质，将包含一物体的空间区域划分成一组小的、非重叠的、连续实体（通常是立方体）。
多边形表面模型 边界表示(B-reps)的最普遍方式是多边形表面模型，它使用一组包围物 体内部的平面多边形，也即平面多面体，来描述实体。
表面模型的数据结构如下图：
对于一个多边形平面，其几何信息用几何表来组织，它包括顶点坐标和标识多边形平面空间方向的参数。具体包括：顶点表、边表、多边形表。
任何多边形平面都有两个面，内侧面和外侧面。一般来说，法向量方向指向物体外部。当多边形顶点序列指定后，它满足右手定则。
除了这三张表给出的几何信息外，还需要增加额外的信息来表示其拓扑信息。例如， 将边表扩充成包括指向面表和顶点表的指针。如下图的例子：
由此可构造出翼边结构表示（Winged Edges Structure），它对于一个多面体的每一 条边指出它的两个相邻面、两个端点，以及四条邻边。这四条邻边好象伸展的翅膀， 所以叫翼边结构表示。
在存储多边形的几何信息和拓扑信息后，还需要用属性表存储多边形面的属性，指明 物体透明度、表面材质和纹理特征等。
多边形网格：
三维形体的曲面边界通常用多边形网格（polygon mesh）的拼接来模拟。这些多边形往往是简单的三角形或四边形。
下图是Maya中的多边形网格：
构造实体几何表示 在构造实体几何法中，集合运算的实现过程可以用一棵二叉树（称为CSG树）来描述：
其中，树的叶子表示基础几何对象，非终端节点表示交并差补操作，根节点就是最终的CSG对象。
这种方法的优缺点如下：
优点：如果体素设置比较齐全，通过集合运算就可以构造出多种不同的符合需要的实体。
缺点：当用户输入体素时，主要是给定体素的有关参数，然后由系统给出该体素的表面方程，再由系统进行集合的求交运算，最后得到生成的实体。
这里面存在两个问题：
（1）一是集合运算的中间结果难以用简单的代数方程表示，求交困难；
（2）CSG树不能显式地表示形体的边界，因而无法直接显示CSG树表示的形体。
为了解决这两个问题，引入了光线投射算法。
光线投射算法
光线投射算法的核心思想是从显示屏幕（投影平面）的每一象素位置发射一根光线（射线）， 求出射线与距离投影平面最近的可见表面的交点和交点处的表面法矢量，然后根据光照模型计算出表面可见点的色彩和亮度，生成实体的光栅图形。
该算法的关键之处在于确定光线与距离投影平面最近的可见表面的交点，这可以通过集合成员分类算法实现。
具体算法步骤：
(1)将射线与CSG树中的所有基于体素求交，求出所有的交点；
(2)将所有交点相对于CSG树表示的物体进行分类，确定位于物体边界上的那部分交点；
(3)对所有位于物体边界上的交点计算它们在射线上的参数值并进行排序，确定距离最 近的交点。
空间分割表示 有三种表示方法：空间位置枚举表示、八叉树、BSP树。
空间位置枚举表示
将包含实体的空间分割为大小相同、形状规则（正方形或立方体）的体素，然 后，以体素的集合来表示图形对象。
用三维数组P[I][J][K]表示物体，数组中的元素与单位小立方体一一对应。
如上图，当P[I][J][K] = 1时，表示对应的小立方体被物体占据。当P[I][J][K] = 0时，表示对应的小立方体没有被物体占据
八叉树
八叉树（octrees）又称为分层树结构，它对空间进行自适应划分，采用具有层次结构的八叉树来表示实体。
下图展示了平面区域的四叉树表示：
对于3维实体，就需要八叉树来表示了。如下图所示，八叉树表示的形体非常容易进行集合运算：
BSP树
二叉空间分割（Binary Space Partitioning，BSP）方法每次将一实体用任一位置和任一方向的平面分为二部分。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/93692f095ad3801df8d20da82fd15b54/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-28T18:56:18+08:00" />
<meta property="article:modified_time" content="2020-12-28T18:56:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机图形学学习笔记：规则形体的表示</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>实体模型的三类表示：</strong></p> 
<ul><li> <p>边界表示（Boundary Representation, B-reps），即用一组曲面（含平面）来描 述物体，这些曲面将物体分为内部和外部。</p> <p>边界表示具体又包括多边形表面模型和扫 描表示两种。</p> </li></ul> 
<p> </p> 
<ul><li> <p>构造实体几何表示（Constructive Solid Geometry，CSG），它将实体表示成立 方体、长方体、圆柱体、圆锥体等基于体素的组合，可以采用并、交、差等运算构造新的形体。</p> </li></ul> 
<p> </p> 
<ul><li> <p>空间分割表示（Space-Partitioning），用来描述物体的内部性质，将包含一物体的空间区域划分成一组小的、非重叠的、连续实体（通常是立方体）。</p> </li></ul> 
<h4><strong>多边形表面模型</strong></h4> 
<p>边界表示(B-reps)的最普遍方式是多边形表面模型，它使用一组包围物 体内部的平面多边形，也即平面多面体，来描述实体。</p> 
<p><strong>表面模型的数据结构如下图：</strong></p> 
<p><img alt="" height="1" src="https://images2.imgbox.com/f4/f9/DZgKqe1e_o.png" width="1"></p> 
<p>对于一个多边形平面，其几何信息用几何表来组织，它包括顶点坐标和标识多边形平面空间方向的参数。具体包括：顶点表、边表、多边形表。</p> 
<p>任何多边形平面都有两个面，内侧面和外侧面。一般来说，法向量方向指向物体外部。当多边形顶点序列指定后，它满足右手定则。</p> 
<p>除了这三张表给出的几何信息外，还需要增加额外的信息来表示其拓扑信息。例如， 将边表扩充成包括指向面表和顶点表的指针。如下图的例子：</p> 
<p><img alt="图片" height="280" src="https://images2.imgbox.com/48/0c/DRAlO5ZL_o.png" width="1200">由此可构造出<strong>翼边结构表示</strong>（Winged Edges Structure），它对于一个多面体的每一 条边指出它的两个相邻面、两个端点，以及四条邻边。这四条邻边好象伸展的翅膀， 所以叫翼边结构表示。</p> 
<p><img alt="图片" height="200" src="https://images2.imgbox.com/d2/64/Dratlmrp_o.png" width="181"></p> 
<p>在存储多边形的几何信息和拓扑信息后，还需要用属性表存储多边形面的属性，指明 物体透明度、表面材质和纹理特征等。</p> 
<p><strong>多边形网格</strong>：</p> 
<p>三维形体的曲面边界通常用多边形网格（polygon mesh）的拼接来模拟。这些多边形往往是简单的三角形或四边形。</p> 
<p>下图是Maya中的多边形网格：</p> 
<p><img alt="图片" height="250" src="https://images2.imgbox.com/55/bc/U5QjB89q_o.png" width="1113"></p> 
<p> </p> 
<h4>构造实体几何表示</h4> 
<p>在构造实体几何法中，集合运算的实现过程可以用一棵二叉树（称为CSG树）来描述：</p> 
<p><img alt="图片" height="230" src="https://images2.imgbox.com/b9/1d/LwCsLkiS_o.png" width="259"></p> 
<p>其中，树的叶子表示基础几何对象，非终端节点表示交并差补操作，根节点就是最终的CSG对象。</p> 
<p>这种方法的优缺点如下：</p> 
<p>优点：如果体素设置比较齐全，通过集合运算就可以构造出多种不同的符合需要的实体。<br> 缺点：当用户输入体素时，主要是给定体素的有关参数，然后由系统给出该体素的表面方程，再由系统进行集合的求交运算，最后得到生成的实体。</p> 
<p>这里面存在两个问题：<br> （1）一是集合运算的中间结果难以用简单的代数方程表示，求交困难；<br> （2）CSG树不能显式地表示形体的边界，因而无法直接显示CSG树表示的形体。</p> 
<p>为了解决这两个问题，引入了光线投射算法。</p> 
<p><strong>光线投射算法</strong></p> 
<p>光线投射算法的核心思想是从显示屏幕（投影平面）的每一象素位置发射一根光线（射线）， 求出射线与距离投影平面最近的可见表面的交点和交点处的表面法矢量，然后根据光照模型计算出表面可见点的色彩和亮度，生成实体的光栅图形。<br> 该算法的关键之处在于确定光线与距离投影平面最近的可见表面的交点，这可以通过集合成员分类算法实现。</p> 
<p>具体算法步骤：<br> (1)将射线与CSG树中的所有基于体素求交，求出所有的交点；<br> (2)将所有交点相对于CSG树表示的物体进行分类，确定位于物体边界上的那部分交点；<br> (3)对所有位于物体边界上的交点计算它们在射线上的参数值并进行排序，确定距离最 近的交点。</p> 
<p><img alt="图片" height="300" src="https://images2.imgbox.com/4e/58/sSyUq6gQ_o.png" width="1006"></p> 
<h4>空间分割表示</h4> 
<p>有三种表示方法：<strong>空间位置枚举表示、八叉树、BSP树。</strong></p> 
<p><strong>空间位置枚举表示</strong></p> 
<p>将包含实体的空间分割为大小相同、形状规则（正方形或立方体）的体素，然 后，以体素的集合来表示图形对象。</p> 
<p>用三维数组P[I][J][K]表示物体，数组中的元素与单位小立方体一一对应。</p> 
<p><img alt="图片" height="200" src="https://images2.imgbox.com/1b/b2/CYrEJXAw_o.png" width="350"></p> 
<p>如上图，当P[I][J][K] = 1时，表示对应的小立方体被物体占据。当P[I][J][K] = 0时，表示对应的小立方体没有被物体占据</p> 
<p><strong>八叉树</strong></p> 
<p>八叉树（octrees）又称为分层树结构，它对空间进行自适应划分，采用具有层次结构的八叉树来表示实体。</p> 
<p>下图展示了平面区域的四叉树表示：</p> 
<p><img alt="图片" height="330" src="https://images2.imgbox.com/01/06/IOKxj3vC_o.png" width="900"></p> 
<p>对于3维实体，就需要八叉树来表示了。如下图所示，八叉树表示的形体非常容易进行集合运算：</p> 
<p><img alt="图片" height="300" src="https://images2.imgbox.com/2f/9a/z4OtnF3t_o.png" width="745"></p> 
<p><strong>BSP树</strong></p> 
<p>二叉空间分割（Binary Space Partitioning，BSP）方法每次将一实体用任一位置和任一方向的平面分为二部分。</p> 
<p>最早应用BSP树的是在商业游戏《DOOM》中。与八叉树相比，它有两个好处：</p> 
<ul><li> <p>自适应分割：BSP树可以减少场景树的深度，减少搜索时间；</p> </li><li> <p>有向超平面：有效地识别前向面和后向面       </p> </li></ul> 
<p>扫描二维码</p> 
<p>获取更多精彩</p> 
<p>机器之眼</p> 
<p><img alt="图片" src="https://images2.imgbox.com/68/56/42MQLuOY_o.png"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0ac78fcb746808c2ba0415fbf51e31f2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2020Android 开发年度总结：“这一年里我到底做了些啥，掌握了哪些技术？”</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ebba1662381eec76d713cfac8a0f2e1d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">elif在python中啥意思_python中的elif是什么意思</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>