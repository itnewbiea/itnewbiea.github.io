<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>二，Git基础命令 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="二，Git基础命令" />
<meta property="og:description" content="获取 Git 仓库 通常有两种获取 Git 项目仓库的方式：
1. 将尚未进行版本控制的本地目录转换为 Git 仓库；
2. 从其它服务器 克隆 一个已存在的 Git 仓库。
两种方式都会在你的本地机器上得到一个工作就绪的 Git 仓库。
(git init)在已存在目录中初始化仓库 如果你有一个尚未进行版本控制的项目目录，想要用 Git 来控制它，那么首先需要进入该项目目录中。
$ cd /c/user/my_project 之后执行：
$ git init 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是Git仓库的骨干。
(git clone)克隆现有的仓库 克隆仓库的命令是 git clone &lt;url&gt; 。 比如，要克隆 Git 的链接库 libgit2，可以用下面的命令：
$ git clone https://github.com/libgit2/libgit2 这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹， 从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 libgit2 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。
如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名：
这会执行与上一条命令相同的操作，但目标目录名变为了 mylibgit。
$ git clone https://github.com/libgit2/libgit2 mylibgit 记录每次更新到仓库 请记住，你工作目录下的每一个文件都不外乎这两种状态：已跟踪 或 未跟踪。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6e165bbd30ec9bf8633ab56244b6c8ab/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-20T15:38:37+08:00" />
<meta property="article:modified_time" content="2022-11-20T15:38:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">二，Git基础命令</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>获取 Git 仓库</h2> 
<p>通常有两种获取 Git 项目仓库的方式：<br> 1. 将尚未进行版本控制的本地目录转换为 Git 仓库；<br> 2. 从其它服务器 克隆 一个已存在的 Git 仓库。<br> 两种方式都会在你的本地机器上得到一个工作就绪的 Git 仓库。</p> 
<h3><strong>(git init)在已存在目录中初始化仓库</strong></h3> 
<p>     如果你有一个尚未进行版本控制的项目目录，想要用 Git 来控制它，那么首先需要进入该项目目录中。</p> 
<pre><code class="language-bash">$ cd /c/user/my_project</code></pre> 
<p>之后执行：</p> 
<pre><code class="language-bash">$ git init</code></pre> 
<p>     该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是Git仓库的骨干。</p> 
<h3><strong>(git clone)克隆现有的仓库</strong> </h3> 
<p>   克隆仓库的命令是 git clone &lt;url&gt; 。 比如，要克隆 Git 的链接库 libgit2，可以用下面的命令：</p> 
<pre><code class="language-bash">$ git clone https://github.com/libgit2/libgit2</code></pre> 
<p>     这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹， 从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 libgit2 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。</p> 
<p>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名：<br> 这会执行与上一条命令相同的操作，但目标目录名变为了 mylibgit。</p> 
<pre><code class="language-bash">$ git clone https://github.com/libgit2/libgit2 mylibgit</code></pre> 
<h3></h3> 
<h2><strong>记录每次更新到仓库</strong></h2> 
<p>    请记住，你工作目录下的每一个文件都不外乎这两种状态：<strong>已跟踪</strong> 或 <strong>未跟踪</strong>。</p> 
<h3><strong>(git status)检查当前文件状态</strong></h3> 
<p>    可以用 git status 命令查看哪些文件处于什么状态。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p> 
<pre><code class="language-bash">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean</code></pre> 
<h3><strong>(git add)跟踪新文件</strong></h3> 
<p>    使用命令 git add 开始跟踪一个文件。 所以，要跟踪 README 文件，运行：</p> 
<pre><code class="language-bash">$ git add README(文件名)


$ git add --all

可以一次add 全部文件</code></pre> 
<p>此时再运行 git status 命令，会看到 README 文件已被跟踪，并处于暂存状态：</p> 
<pre><code class="language-bash">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
(use "git restore --staged &lt;file&gt;..." to unstage)
new file: README</code></pre> 
<h3><strong>暂存已修改的文件</strong></h3> 
<p>    现在我们来修改一个已被跟踪的文件。 如果你修改了一个名为 CONTRIBUTING.md 的已被跟踪的文件，然后运行 git status 命令，会看到下面内容：</p> 
<pre><code class="language-bash">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
(use "git reset HEAD &lt;file&gt;..." to unstage)
new file: README
Changes not staged for commit:
(use "git add &lt;file&gt;..." to update what will be committed)
(use "git checkout -- &lt;file&gt;..." to discard changes in working
directory)
modified: CONTRIBUTING.md</code></pre> 
<h3><strong>(.gitignore)忽略文件</strong></h3> 
<p>    一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表在这种情况下，我们可以创建一个名为 .gitignore的文件，列出要忽略的文件的模式。来看一个实际的 .gitignore 例子：</p> 
<pre><code class="language-bash">$ cat .gitignore
*.[oa]
*~</code></pre> 
<p>第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件。</p> 
<p><strong>文件 .gitignore 的格式规范如下：</strong><br> • 所有空行或者以 # 开头的行都会被 Git 忽略。<br> • 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。<br> • 匹配模式可以以（/）开头防止递归。<br> • 匹配模式可以以（/）结尾指定目录。<br> • 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。<br> 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。</p> 
<pre><code class="language-bash"># 忽略所有的 .a 文件
*.a
# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件
!lib.a
# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO
/TODO
# 忽略任何目录下名为 build 的文件夹
build/
# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt
doc/*.txt
# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件
doc/**/*.pdf</code></pre> 
<h3>(git diff)查看已暂存和未暂存的修改</h3> 
<p>比较文件差异<br>  git diff [文件名]<br>     将工作区中的文件和暂存区进行比较</p> 
<p> git diff [本地库中历史版本] [文件名]<br>     将工作区中的文件和本地库历史记录比较<br>  不带文件名比较多个文件</p> 
<p>    如果 git status 命令的输出对于你来说过于简略，而你想知道具体修改了什么地方，可以用 git diff 命令。</p> 
<pre><code class="language-bash">$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
Please include a nice description of your changes when you submit your
PR;
if we have to read the whole diff to figure out why you're contributing
in the first place, you're less likely to get feedback and have your
change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your
patch is
+longer than a dozen lines.
If you are starting to work on a particular area, feel free to submit a
PR
that highlights your work in progress (and note in the PR title that it's</code></pre> 
<p>请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件，运行 git diff 后却什么也没有，就是这个原因。</p> 
<p>若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff --staged 命令。 这条命令将比对已暂存文件与最后一次提交的文件差异：</p> 
<pre><code class="language-bash">$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project</code></pre> 
<p>用 git diff --cached 查看已经暂存起来的变化（ --staged 和 --cached 是同义词）：</p> 
<pre><code class="language-bash">$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
Please include a nice description of your changes when you submit your
PR;
if we have to read the whole diff to figure out why you're contributing
in the first place, you're less likely to get feedback and have your
change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your
patch is
+longer than a dozen lines.
If you are starting to work on a particular area, feel free to submit a
PR
that highlights your work in progress (and note in the PR title that it's</code></pre> 
<h3>(git commit)提交更新</h3> 
<p>    现在的暂存区已经准备就绪，可以提交了。 在此之前，请务必确认还有什么已修改或新建的文件还没有 git add 过， 否则提交的时候不会记录这些尚未暂存的变化。 这些已修改但未暂存的文件只会保留在本地磁盘。 所以，每次准备提交前，先用 git status 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令git commit：</p> 
<pre><code class="language-bash">$ git commit</code></pre> 
<p>另外，你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行，如下所示：</p> 
<pre><code class="language-bash">$ git commit -m "Story 182: Fix benchmarks for speed"
[master 463dc4f] Story 182: Fix benchmarks for speed
2 files changed, 2 insertions(+)
create mode 100644 README</code></pre> 
<h3>(git rm)移除文件</h3> 
<p>    要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p> 
<p>如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 “Changes not staged for<br> commit” 部分（也就是 未暂存清单）看到：</p> 
<pre><code class="language-bash">$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
(use "git add/rm &lt;file&gt;..." to update what will be committed)
(use "git checkout -- &lt;file&gt;..." to discard changes in working
directory)
deleted: PROJECTS.md
no changes added to commit (use "git add" and/or "git commit -a")</code></pre> 
<p>然后再运行 git rm 记录此次移除文件的操作：</p> 
<pre><code class="language-bash">$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
(use "git reset HEAD &lt;file&gt;..." to unstage)
deleted: PROJECTS.md</code></pre> 
<p>    下一次提交时，该文件就不再纳入版本管理了。 如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 -f（译注：即 force 的首字母）。<br>     另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 --cached 选项：</p> 
<pre><code class="language-bash">$ git rm --cached README</code></pre> 
<p>git rm 命令后面可以列出文件或者目录的名字，也可以使用 glob 模式。比如：</p> 
<pre><code class="language-bash">$ git rm log/\*.log</code></pre> 
<h3>(git mv)移动文件</h3> 
<p>当你看到 Git 的 mv 命令时一定会困惑不已。 要在 Git 中对文件改名，可以这么做：</p> 
<pre><code class="language-bash">$ git mv file_from file_to</code></pre> 
<p>其实，运行 git mv 就相当于运行了下面三条命令：</p> 
<pre><code class="language-bash">$ mv README.md README
$ git rm README.md
$ git add README</code></pre> 
<h3>(git log)查看提交历史</h3> 
<p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 git log 命令。</p> 
<p>多屏显示控制方式：<br> 空格向下翻页<br> b 向上翻页<br> q 退出</p> 
<pre><code class="language-bash">$ git log
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date: Mon Mar 17 21:52:11 2008 -0700
changed the version number
commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date: Sat Mar 15 16:40:33 2008 -0700
removed unnecessary test
commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date: Sat Mar 15 10:31:28 2008 -0700
first commit</code></pre> 
<p>Table 3. git log 的常用选项<br> 选项说明<br> -p                    按补丁格式显示每个提交引入的差异，如-p -2 显示最近2条。<br> --stat               显示每次提交的文件修改统计信息。<br> --shortstat       只显示 --stat 中最后的行数修改添加移除统计。<br> --name-only    仅在提交信息后显示已修改的文件清单。<br> --name-status 显示新增、修改、删除的文件清单。<br> --abbrev-commit 仅显示 SHA-1 校验和所有 40 个字符中的前几个字符。<br> --relative-date 使用较短的相对时间而不是完整格式显示日期（比如“2 weeks ago”）。<br> --graph             在日志旁以 ASCII 图形显示分支与合并历史。<br> --pretty             使用其他格式显示历史提交信息。可用的选项包括 oneline、short、full、fuller 和<br> format（用来定义自己的格式）。<br> --oneline --pretty=oneline --abbrev-commit 合用的简写。</p> 
<p><strong>git reflog</strong> 能单行显示信息，或<strong>git log --pretty=oneline (git log --oneline)</strong></p> 
<p><img alt="" height="363" src="https://images2.imgbox.com/14/bc/9O0CybdZ_o.png" width="764"></p> 
<p>                     HEAD@{移动到当前版本需要多少步}</p> 
<p>最有意思的是 format ，可以定制记录的显示格式。 这样的输出对后期提取分析格外有用——因为你知道输出的格式不会随着 Git 的更新而发生改变：</p> 
<pre><code class="language-bash">$ git log --pretty=format:"%h - %an, %ar : %s"
ca82a6d - Scott Chacon, 6 years ago : changed the version number
085bb3b - Scott Chacon, 6 years ago : removed unnecessary test
a11bef0 - Scott Chacon, 6 years ago : first commit</code></pre> 
<p>git log --pretty=format 常用的选项 列出了 format 接受的常用格式占位符的写法及其代表的意义。<br> Table 2. git log --pretty=format 常用的选项<br> 选项说明<br> %H    提交的完整哈希值<br> %h    提交的简写哈希值<br> %T    树的完整哈希值<br> %t     树的简写哈希值<br> %P   父提交的完整哈希值<br> %p   父提交的简写哈希值<br> %an 作者名字<br> %ae 作者的电子邮件地址<br> %ad 作者修订日期（可以用 --date=选项 来定制格式）<br> %ar 作者修订日期，按多久以前的方式显示<br> %cn 提交者的名字<br> %ce 提交者的电子邮件地址<br> %cd 提交日期<br> %cr 提交日期（距今多长时间）<br> %s 提交说明</p> 
<p>类似 --since 和 --until 这种按照时间作限制的选项很有用。 例如，下面的命令会列出最近两周的所<br> 有提交：</p> 
<pre><code class="language-bash">$ git log --since=2.weeks</code></pre> 
<p>在 限制 git log 输出的选项 中列出了常用的选项<br> Table 4. 限制 git log 输出的选项<br> 选项说明<br> -&lt;n&gt;                  仅显示最近的 n 条提交。<br> --since, --after  仅显示指定时间之后的提交。<br> --until, --before 仅显示指定时间之前的提交。<br> --author             仅显示作者匹配指定字符串的提交。<br> --committer      仅显示提交者匹配指定字符串的提交。<br> --grep               仅显示提交说明中包含指定字符串的提交。<br> -S                      仅显示添加或删除内容匹配指定字符串的提交。</p> 
<h3>(--amend)撤消操作</h3> 
<p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 --amend 选项的提交命令来重新提交：</p> 
<pre><code class="language-bash">$ git commit --amend</code></pre> 
<p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令）， 那么快照会保持不变，而你所修改的只是提交信息。<br> 文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。<br> 例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p> 
<pre><code class="language-bash">$ git commit -m 'initial commit'
$ git add forgotten_file
$ git commit --amend</code></pre> 
<p>最终你只会有一个提交——第二次提交将代替第一次提交的结果。</p> 
<h3>(git reset)取消暂存的文件</h3> 
<p>使用 git reset HEAD &lt;file&gt;... 来取消暂存。 所以，我们可以这样来取消暂存 CONTRIBUTING.md 文件：</p> 
<pre><code class="language-bash">$ git reset HEAD CONTRIBUTING.md
Unstaged changes after reset:
M CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
(use "git reset HEAD &lt;file&gt;..." to unstage)
renamed: README.md -&gt; README
Changes not staged for commit:
(use "git add &lt;file&gt;..." to update what will be committed)
(use "git checkout -- &lt;file&gt;..." to discard changes in working
directory)
modified: CONTRIBUTING.md</code></pre> 
<h3>(git reset --hard) 后退或前进到版本</h3> 
<p>可以用git reset --hard (局部索引 值) 这个命令退到或前进到之前commit 的版本 </p> 
<p><img alt="" height="601" src="https://images2.imgbox.com/a0/d5/EEBWHtkL_o.png" width="796"></p> 
<p> 基于索引值操作[推荐]<br><strong> git reset --hard [局部索引值]</strong><br>  git reset --hard a6ace91</p> 
<p> 使用<strong><span style="color:#fe2c24;">^</span></strong>符号：<strong><span style="color:#fe2c24;">只能后退</span></strong><br>  <strong>git reset --hard HEAD^</strong><br>  注：一个^表示后退一步，n 个表示后退n 步</p> 
<p> 使用<strong><span style="color:#fe2c24;">~</span></strong>符号：<strong><span style="color:#fe2c24;">只能后退</span></strong><br><strong> git reset --hard HEAD~n</strong><br>  注：表示后退n 步</p> 
<p><strong>reset 命令的三个参数对比</strong><br><strong>--soft 参数</strong><br>  仅仅在本地库移动HEAD 指针</p> 
<p><strong>--mixed 参数</strong><br>  在本地库移动HEAD 指针<br>  重置暂存区</p> 
<p><strong>--hard 参数</strong><br>  在本地库移动HEAD 指针<br>  重置暂存区<br>  重置工作区</p> 
<h3>(git checkout)撤消对文件的修改</h3> 
<p>    如果你并不想保留对 CONTRIBUTING.md 文件的修改怎么办？ 你该如何方便地撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？</p> 
<p>    在 Git 中任何 已提交 的东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 --amend 选项覆盖的提交也可以恢复 。 然而，任何你未提交的东西丢失后很可能再也找不到了。</p> 
<p>    请务必记得 git checkout -- &lt;file&gt; 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。</p> 
<pre><code class="language-bash">$ git checkout -- CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
(use "git reset HEAD &lt;file&gt;..." to unstage)
renamed: README.md -&gt; README</code></pre> 
<h2></h2> 
<h2>远程仓库的使用</h2> 
<p>    为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。 管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。</p> 
<h3>(git remote)查看远程仓库</h3> 
<p>如果想查看你已经配置的远程仓库服务器，可以运行 git remote 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字：</p> 
<pre><code class="language-bash">$ git clone https://github.com/schacon/ticgit
Cloning into 'ticgit'...
remote: Reusing existing pack: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
Resolving deltas: 100% (772/772), done.
Checking connectivity... done.
$ cd ticgit
$ git remote
origin</code></pre> 
<p>你也可以指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p> 
<pre><code class="language-bash">$ git remote -v
origin https://github.com/schacon/ticgit (fetch)
origin https://github.com/schacon/ticgit (push)</code></pre> 
<h3>(git remote add)添加远程仓库</h3> 
<p>我们在之前的章节中已经提到并展示了 git clone 命令是如何自行添加远程仓库的， 不过这里将告诉你如何自己来添加它。 运行 git remote add &lt;shortname&gt; &lt;url&gt; 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写：</p> 
<pre><code class="language-bash">$ git remote
origin
$ git remote add pb https://github.com/paulboone/ticgit
$ git remote -v
origin https://github.com/schacon/ticgit (fetch)
origin https://github.com/schacon/ticgit (push)
pb https://github.com/paulboone/ticgit (fetch)
pb https://github.com/paulboone/ticgit (push)</code></pre> 
<h3>(git pull(fetch))从远程仓库中抓取与拉取</h3> 
<p> pull= fetch + merge<br>  git fetch [远程库地址别名] [远程分支名]<br>  git merge [远程库地址别名/远程分支名]<br>  git pull [远程库地址别名] [远程分支名]</p> 
<p><img alt="" height="343" src="https://images2.imgbox.com/ed/95/jpzdQY3q_o.png" width="898"></p> 
<p><img alt="" height="355" src="https://images2.imgbox.com/87/7d/nwCBiRs9_o.png" width="831"></p> 
<p><img alt="" height="385" src="https://images2.imgbox.com/c9/fd/1ddzKOeb_o.png" width="890"></p> 
<p>    从远程仓库中获得数据，可以执行：</p> 
<pre><code class="language-bash">$ git fetch &lt;remote&gt;</code></pre> 
<p>    这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。必须注意 git fetch 命令只会将数据下载到你的本地仓库——它并<span style="color:#fe2c24;">不会自动合并或修改</span>你当前的工作。</p> 
<p>    如果你的当前分支设置了跟踪远程分支， 那么可以用 git pull 命令来自动抓取后合并该远程分支到当前分支。 默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p> 
<pre><code class="language-bash">$ git pull &lt;remote&gt;</code></pre> 
<h3>(git push)推送到远程仓库</h3> 
<p>当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：git push &lt;remote&gt; &lt;branch&gt;。</p> 
<pre><code class="language-bash">$ git push origin master</code></pre> 
<p>    只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。</p> 
<h3>(git remote show)查看某个远程仓库</h3> 
<p>如果想要查看某一个远程仓库的更多信息，可以使用 git remote show &lt;remote&gt; 命令。 如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息：</p> 
<pre><code class="language-bash">$ git remote show origin
* remote origin
Fetch URL: https://github.com/schacon/ticgit
Push URL: https://github.com/schacon/ticgit
HEAD branch: master
Remote branches:
master tracked
dev-branch tracked
Local branch configured for 'git pull':
master merges with remote master
Local ref configured for 'git push':
master pushes to master (up to date)</code></pre> 
<h3>(git remote rename)远程仓库的重命名与移除(git remote remove)</h3> 
<p>你可以运行 git remote rename 来修改一个远程仓库的简写名。 例如，想要将 pb 重命名为 paul，可以用git remote rename 这样做：</p> 
<pre><code class="language-bash">$ git remote rename pb paul
$ git remote
origin
paul</code></pre> 
<p>值得注意的是这同样也会修改你所有远程跟踪的分支名字。 那些过去引用 pb/master 的现在会引用<br> paul/master。</p> 
<p>如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了， 又或者某一个贡献者不再贡献了——可以使用 git remote remove 或 git remote rm ：</p> 
<pre><code class="language-bash">$ git remote remove paul
$ git remote
origin</code></pre> 
<p>一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</p> 
<p></p> 
<h2>打标签</h2> 
<p>像其他版本控制系统（VCS）一样，Git 可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（ v1.0 、 v2.0 等等）。</p> 
<h3>(git tag)列出标签</h3> 
<p>在 Git 中列出已有的标签非常简单，只需要输入 git tag （可带上可选的 -l 选项 --list）：</p> 
<pre><code class="language-bash">$ git tag
v1.0
v2.0

$ git tag -l "v1.8.5*"
v1.8.5
v1.8.5-rc0
v1.8.5-rc1
v1.8.5.1
v1.8.5.2
v1.8.5.3
</code></pre> 
<h3>创建标签</h3> 
<p>Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。<br>     轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。<br>     而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。</p> 
<h4>轻量标签</h4> 
<p>     另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：</p> 
<pre><code class="language-bash">$ git tag v1.4-lw
$ git tag
v0.1
v1.3
v1.4
v1.4-lw
v1.5

$ git show v1.4-lw
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date: Mon Mar 17 21:52:11 2008 -0700
changed the version number</code></pre> 
<h4><strong>附注标签</strong></h4> 
<p>    在 Git 中创建附注标签十分简单。 最简单的方式是当你在运行 tag 命令时指定 -a 选项：</p> 
<pre><code class="language-bash">$ git tag -a v1.4 -m "my version 1.4"
$ git tag
v0.1
v1.3
v1.4</code></pre> 
<p>-m 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会启动编辑器要求你输入信息。<br> 通过使用 git show 命令可以看到标签信息和与之对应的提交信息：</p> 
<pre><code class="language-bash">$ git show v1.4
tag v1.4
Tagger: Ben Straub &lt;ben@straub.cc&gt;
Date: Sat May 3 20:19:12 2014 -0700
my version 1.4
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date: Mon Mar 17 21:52:11 2008 -0700
changed the version number</code></pre> 
<h3>后期打标签</h3> 
<p>你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）,比如下面忘了打v1.2：</p> 
<pre><code class="language-bash">$ git tag -a v1.2 9fceb02

$ git tag
v0.1
v1.2
v1.3
v1.4
v1.4-lw
v1.5

$ git show v1.2
tag v1.2
Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date: Mon Feb 9 15:32:16 2009 -0800
version 1.2
commit 9fceb02d0ae598e95dc970b74767f19372d61af8
Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;
Date: Sun Apr 27 20:43:35 2008 -0700
updated rakefile
...</code></pre> 
<h3>共享标签</h3> 
<p>    默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 git push origin &lt;tagname&gt;。</p> 
<pre><code class="language-bash">$ git push origin v1.5
Counting objects: 14, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (12/12), done.
Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.
Total 14 (delta 3), reused 0 (delta 0)
To git@github.com:schacon/simplegit.git
* [new tag] v1.5 -&gt; v1.5</code></pre> 
<p>使用 git push &lt;remote&gt; --tags 推送标签并不会区分轻量标签和附注标签， 没有简单的选项能够让你只选择推送一种标签。</p> 
<h3>删除标签</h3> 
<p>要删除掉你本地仓库上的标签，可以使用命令 git tag -d &lt;tagname&gt;。 例如，可以使用以下命令删除一个轻量标签：</p> 
<pre><code class="language-bash">$ git tag -d v1.4-lw
Deleted tag 'v1.4-lw' (was e7d5add)</code></pre> 
<p>注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 git push &lt;remote&gt; refs/tags/&lt;tagname&gt; 来更新你的远程仓库：<br> 第一种变体是 git push &lt;remote&gt; :refs/tags/&lt;tagname&gt; ：</p> 
<pre><code class="language-bash">$ git push origin :refs/tags/v1.4-lw
To /git@github.com:schacon/simplegit.git
- [deleted] v1.4-lw</code></pre> 
<p>上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。<br> 第二种更直观的删除远程标签的方式是：</p> 
<pre><code class="language-bash">$ git push origin --delete &lt;tagname&gt;</code></pre> 
<h2>Git 别名</h2> 
<p>Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：</p> 
<pre><code class="language-bash">$ git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status</code></pre> 
<p>这意味着，当要输入 git commit 时，只需要输入 git ci。 随着你继续不断地使用 Git，可能也会经常使用其他命令，所以创建别名时不要犹豫。</p> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b7364da6954484cebb683c00fddfa5a1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CentOS7安装RabbitMQ详细教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5acbc2452d5adc71350a7f406fb261a4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Win10下如何修改系统用户目录名称</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>