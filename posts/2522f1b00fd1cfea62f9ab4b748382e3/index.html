<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】智能指针 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C&#43;&#43;】智能指针" />
<meta property="og:description" content="一、为什么需要智能指针？ 智能指针就是帮我们 C&#43;&#43; 程序员管理动态分配的内存的，它会帮助我们自动释放 new 出来的内存，从而 避免内存泄漏。 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;memory&gt; using namespace std; // 动态分配内存，没有释放就return void memoryLeak1() { string *str = new string(&#34;动态分配内存！&#34;); return; } // 动态分配内存，虽然有些释放内存的代码，但是被半路截胡return了 int memoryLeak2() { string *str = new string(&#34;内存泄露！&#34;); // ... // 发生某些异常，需要结束函数 if (1) { return -1; } // 另外，使用try、catch结束函数，也会造成内存泄漏！ delete str;	// 虽然写了释放内存的代码，但是遭到函数中段返回，使得指针没有得到释放 return 1; } int main() { memoryLeak1(); memoryLeak2(); return 0; } 在 memoryLeak1 函数中，new 了一个字符串指针，但是没有 delete 就已经 return 结束函数了，导致内存没有被释放，内存泄露。在 memoryLeak2 函数中，new 了一个字符串指针，虽然在函数末尾有些释放内存的代码 delete str，但是在 delete 之前就已经 return 了，所以内存也没有被释放，内存泄露。 使用指针，我们没有释放，就会造成内存泄露。但是如果使用普通对象就不会。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2522f1b00fd1cfea62f9ab4b748382e3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-18T19:35:51+08:00" />
<meta property="article:modified_time" content="2023-12-18T19:35:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】智能指针</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="color:#333333;">一、为什么需要智能指针？ </span></h2> 
<blockquote> 
 <div>
   智能指针就是帮我们 C++ 程序员管理动态分配的内存的，它会帮助我们自动释放 new 出来的内存，从而 
  <strong>避免内存泄漏</strong>。 
 </div> 
</blockquote> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
using namespace std;

// 动态分配内存，没有释放就return
void memoryLeak1()
{
	string *str = new string("动态分配内存！");
	return;
}

// 动态分配内存，虽然有些释放内存的代码，但是被半路截胡return了
int memoryLeak2()
{
	string *str = new string("内存泄露！");
	// ...

	// 发生某些异常，需要结束函数
	if (1)
    {
		return -1;
	}
	// 另外，使用try、catch结束函数，也会造成内存泄漏！

	delete str;	// 虽然写了释放内存的代码，但是遭到函数中段返回，使得指针没有得到释放
	return 1;
}

int main()
{
	memoryLeak1();
	memoryLeak2();

	return 0;
} </code></pre> 
<blockquote> 
 <ol><li>在 memoryLeak1 函数中，new 了一个字符串指针，但是没有 delete 就已经 return 结束函数了，导致内存没有被释放，内存泄露。</li><li>在 memoryLeak2 函数中，new 了一个字符串指针，虽然在函数末尾有些释放内存的代码 delete str，但是在 delete 之前就已经 return 了，所以内存也没有被释放，内存泄露。</li></ol> 
 <p><span style="color:#0d0016;">使用指针，我们没有释放，就会造成内存泄露。但是如果使用普通对象就不会。</span></p> 
</blockquote> 
<p><span style="color:#0d0016;">如果我们分配的动态内存都交由有生命周期的对象来处理，那么在对象过期时，让它的析构函数删除指向的内存，这看似是一个不错的方案。智能指针就是通过这个原理来解决指针自动释放的问题的。</span></p> 
<blockquote> 
 <p><span style="color:#0d0016;">在 C++ 中，<span style="background-color:#ffd900;">动态内存管理</span>是通过一对运算符来完成的：</span></p> 
 <ol><li><span style="color:#fe2c24;"><strong>new</strong></span><span style="color:#0d0016;">，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化。</span></li><li><span style="color:#fe2c24;"><strong>delete</strong></span><span style="color:#0d0016;">，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。</span></li></ol> 
 <p><span style="color:#0d0016;">动态内存的使用很容易出现问题，因为确保在正确的时间释放内存是极其困难的。有时使用完对象后，忘记释放内存，造成内存泄漏的问题。</span></p> 
</blockquote> 
<div> 
 <hr> 
 <h2><span style="color:#333333;">二、内存泄漏 </span></h2> 
 <h4><span style="color:#0d0016;">1、什么是内存泄漏，内存泄漏的危害</span></h4> 
 <blockquote> 
  <ul><li><span style="color:#0d0016;"><span style="background-color:#ffd900;">什么是内存泄漏</span>：内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内</span><span style="color:#0d0016;">存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对</span><span style="color:#0d0016;">该段内存的控制，因而造成了内存的浪费。 </span></li><li><span style="color:#0d0016;"><span style="background-color:#ffd900;">内存泄漏的危害</span>：长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现</span><span style="color:#0d0016;">内存泄漏会导致响应越来越慢，最终卡死。 </span></li></ul> 
 </blockquote> 
 <div> 
  <pre><code class="language-cpp">void MemoryLeaks()
{
    // 1.内存申请了忘记释放
    int* p1 = (int*)malloc(sizeof(int));
    int* p2 = new int;
  
   // 2.异常安全问题
   int* p3 = new int[10];
  
   Func(); // 这里Func函数抛异常导致 delete[] p3未执行，p3没被释放.
  
   delete[] p3;
}</code></pre> 
  <hr> 
  <h4><span style="color:#0d0016;">2、内存泄漏分类<span style="background-color:#d7d8d9;">（了解） </span></span></h4> 
 </div> 
 <div> 
  <div> 
   <span style="color:#0d0016;">C/C++ 程序中一般我们关心两种方面的内存泄漏： </span> 
  </div> 
  <ul><li><span style="color:#0d0016;"><strong>堆内存泄漏（Heap leak）</strong></span></li></ul> 
  <blockquote> 
   <div> 
    <span style="color:#0d0016;">堆内存指的是程序执行中依据须要分配通过 malloc / calloc / realloc / new 等从堆中分配的一 </span> 
   </div> 
   <div> 
    <span style="color:#0d0016;">块内存，用完后必须通过调用相应的 free / delete 删掉。假设程序的设计错误导致这部分内存没有被释放，那么以后这部分空间将无法再被使用，就会产生 Heap Leak。 </span> 
   </div> 
  </blockquote> 
  <ul><li><span style="color:#0d0016;"><strong>系统资源泄漏 </strong></span></li></ul> 
  <blockquote> 
   <div> 
    <span style="color:#0d0016;">指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放 </span> 
   </div> 
   <div> 
    <span style="color:#0d0016;">掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。</span> 
   </div> 
  </blockquote> 
  <div> 
   <hr> 
   <h4><span style="color:#0d0016;">3、如何检测内存泄漏<span style="background-color:#d7d8d9;">（了解） </span></span></h4> 
   <blockquote> 
    <div> 
     <span style="color:#0d0016;">在linux下内存泄漏检测：</span> 
     <a href="https://blog.csdn.net/gatieme/article/details/51959654" title="Linux下几款C++程序中的内存泄露检查工具_c++内存泄露工具分析-CSDN博客">Linux下几款C++程序中的内存泄露检查工具_c++内存泄露工具分析-CSDN博客</a> 
     <span style="color:#4183c4;"> </span> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#0d0016;">在windows下使用第三方工具</span> 
     <span style="color:#777777;">：</span> 
     <a href="https://blog.csdn.net/GZrhaunt/article/details/56839765" title="VS编程内存泄漏：VLD(Visual LeakDetector)内存泄露库-CSDN博客">VS编程内存泄漏：VLD(Visual LeakDetector)内存泄露库-CSDN博客</a> 
     <span style="color:#4183c4;"> </span> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#0d0016;">其他工具：</span> 
    </div> 
    <div> 
     <a href="https://www.cnblogs.com/liangxiaofeng/p/4318499.html" rel="nofollow" title="内存泄露检测工具比较 - 默默淡然 - 博客园 (cnblogs.com)">内存泄露检测工具比较 - 默默淡然 - 博客园 (cnblogs.com)</a> 
    </div> 
   </blockquote> 
  </div> 
  <div> 
   <hr> 
   <h4><span style="color:#0d0016;">4、如何避免内存泄漏 </span></h4> 
   <blockquote> 
    <ol><li><span style="color:#0d0016;">工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。（ps：</span><span style="color:#0d0016;">但是如果碰上异常时，就算注意释放了还是可能会出问题，需要下一条智</span><span style="color:#0d0016;">能指针来管理才有保证）</span></li><li><span style="color:#0d0016;">采用 RAII 思想或者智能指针来管理资源。</span></li><li> 
      <div> 
       <span style="color:#0d0016;">有些公司内部规范使用内部实现的私有内存管理库。这套库自带内存泄漏检测的功能选项。</span> 
      </div> </li><li> 
      <div> 
       <span style="color:#0d0016;">出问题了使用内存泄漏工具检测。（ps：不过很多工具都不够靠谱或者收费昂贵）</span> 
      </div> </li></ol> 
   </blockquote> 
  </div> 
 </div> 
</div> 
<div> 
 <strong><span style="color:#0d0016;">【总结】</span></strong> 
</div> 
<blockquote> 
 <div> 
  <span style="color:#0d0016;">内存泄漏非常常见，解决方案分为两种：</span> 
 </div> 
 <ol><li><span style="color:#0d0016;">事前预防型。如智能指针等。</span></li><li><span style="color:#0d0016;">事后查错型。如泄漏检测工具。 </span></li></ol> 
</blockquote> 
<hr> 
<h2><span style="color:#333333;">三、智能指针的使用及原理 </span></h2> 
<h4><span style="color:#0d0016;">1、RAII</span></h4> 
<blockquote> 
 <div> 
  <span style="color:#0d0016;">RAII（Resource Acquisition Is Initialization）是一种<strong><span style="background-color:#ffd900;">利用对象生命周期来控制程序资源</span></strong>（如内存、文件句柄、网络连接、互斥量等等）的简单技术。</span> 
 </div> 
</blockquote> 
<div> 
 <div> 
  <span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">在对象</span></strong></span> 
  <span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">构造</span></strong></span> 
  <span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">时获取资源</span></strong>，接着控制对资源的访问使之在对象的生命周期内始终保持有效，<strong>最后<span style="background-color:#ffd900;">在</span></strong></span> 
  <span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">对象</span></strong></span> 
  <span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">析构</span></strong></span> 
  <span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">的时候释放资源</span></strong>。借此，实际上我们<span style="background-color:#ffd900;">把管理一份资源的责任托管给了一个对象</span>，这种做法有以下两大好处： </span> 
 </div> 
 <blockquote> 
  <ul><li><span style="color:#0d0016;">不需要显式地释放资源。 </span></li><li><span style="color:#0d0016;">采用这种方式，对象所需的资源在其生命期内始终保持有效。</span></li></ul> 
 </blockquote> 
</div> 
<p><span style="color:#0d0016;">所谓的</span><span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">智能指针的本质</span></strong></span><span style="color:#0d0016;"><span style="background-color:#ffd900;">就是一个</span></span><span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">类模板</span></strong></span><span style="color:#0d0016;">，它可以创建任意类型的指针对象，当智能指针对象使用完之后，<strong>对象会自动调用析构函数去释放该指针所指向的空间</strong>。</span></p> 
<p><span style="color:#0d0016;">下面是智能指针的基本框架，所有的智能指针类模板中都需要包含一个<strong>指针对象</strong>，<strong>构造函数</strong>和<strong>析构函数</strong>。</span></p> 
<div> 
 <pre><code class="language-cpp">template&lt;class T&gt;
class smartptr // 自定义的智能指针
{
public:
    smartptr (T* _ptr) // 构造函数
        : ptr(_ptr)
    {}

    ~smartptr () // 析构函数
    {
        if(ptr!=nullptr)
        {
            cout &lt;&lt; "smartptr: delete" &lt;&lt; endl;
            delete ptr;
            ptr = nullptr;
        }
    }
private:
    T* ptr; // 指针对象
};</code></pre> 
 <hr> 
 <h4>2、<span style="color:#333333;">智能指针的原理 </span></h4> 
 <blockquote> 
  <div> 
   <span style="color:#0d0016;">上述的 smartptr 还不能将其称为智能指针，因为它还不具有指针的行为。指针可以解引用，也可以通过 -&gt; 去访问所指空间中的内容。</span> 
  </div> 
  <div> 
   <strong>智能指针的使用跟普通指针类似</strong>，可以使用运算符 "*" 和 "-&gt;" 去获得指向的对象。因此，我们需要在类中重载 "*" 和 "-&gt;" 函数， 
   <span style="color:#0d0016;"><strong>才可让其像指针一样去使用</strong>。</span> 
  </div> 
 </blockquote> 
</div> 
<pre><code class="language-cpp">template&lt;class T&gt;
class smartptr // 自定义的智能指针
{
public:
    smartptr (T* _ptr) // 构造函数
        : ptr(_ptr)
    {}

    ~smartptr () // 析构函数
    {
        if(ptr!=nullptr)
        {
            cout &lt;&lt; "smartptr: delete" &lt;&lt; endl;
            delete ptr;
            ptr = nullptr;
        }
    }

    T&amp; operator*() {return *ptr;} // 重载出*运算符

    T* operator-&gt;() {return ptr;} // 重载出-&gt;运算符
private:
    T* ptr; // 指针对象
};</code></pre> 
<div></div> 
<div> 
 <p></p> 
 <p>当程序结束时，此时下面的 ptr1 和 ptr2 指针被销毁，对象 ptr1 和 ptr2 会自动调用析构函数去释放所指向的资源，这是智能指针的特点。</p> 
 <pre><code class="language-cpp">int main()
{
    smartptr&lt;int&gt; ptr1(new int(1)); // 指向int类型的智能指针
    smartptr&lt;string&gt; ptr2(new string("string")); // 指向string类型的智能指针
    cout &lt;&lt; *ptr1 &lt;&lt; endl;
    cout &lt;&lt; ptr2-&gt;c_str() &lt;&lt; endl;
    return 0;
}</code></pre> 
 <p><img alt="" height="132" src="https://images2.imgbox.com/7d/bd/0mPtmSDP_o.png" width="260"></p> 
 <p>由于<span style="background-color:#ffd900;">自定义的类中没有定义</span><strong><span style="background-color:#ffd900;">拷贝构造函数</span></strong><span style="background-color:#ffd900;">和</span><strong><span style="background-color:#ffd900;">赋值重载函数</span></strong>，那么我们只能<span style="background-color:#ffd900;">调用类中原生的拷贝构造函数和赋值重载函数</span>。可是这样就会发生<span style="color:#fe2c24;"><strong>程序崩溃</strong></span>。</p> 
 <p><img alt="" height="159" src="https://images2.imgbox.com/2c/34/DUD3gKtx_o.png" width="700"></p> 
</div> 
<blockquote> 
 <div>
   ptr2 和 ptr1 指向的同一块空间，当 ptr2 被销毁时，它会调用它的析构函数去 delete 该资源对象，当 ptr1 被销毁时,也会去调用它的析构函数去释放 ptr1 所指向的资源。 
 </div> 
 <div>
   所以，当程序结束时，ptr2 先被销毁，同时释放 ptr2 所指向的资源，然后 ptr1 被销毁，也去释放它所指向的资源对象，那么相同的资源对象就会被释放两次，因此导致程序崩溃。（资源对象被释放后，如果再去释放该资源，程序就会崩溃） 
 </div> 
 <div></div> 
 <div>
   所以，我们 
  <span style="background-color:#ffd900;">不能使用原生的拷贝构造函数和赋值重载函数</span>，并且自己定义的拷贝构造函数和赋值重载函数 
  <strong><span style="background-color:#ffd900;">需要考虑只能释放一次资源对象的问题</span></strong>。 
 </div> 
</blockquote> 
<div></div> 
<div> 
 <p></p> 
</div> 
<div> 
 <span style="color:#0d0016;">总结一下</span> 
 <strong><span style="color:#0d0016;">智能指针的</span><span style="color:#fe2c24;"><span style="background-color:#ffd900;">原理</span></span><span style="color:#0d0016;">：</span></strong> 
</div> 
<div></div> 
<blockquote> 
 <ol><li><span style="color:#0d0016;"><span style="background-color:#ffd900;">RAII</span> 特性。</span></li><li><span style="color:#0d0016;"><span style="background-color:#ffd900;">重载 operator* 和 opertaor-&gt;</span>，具有像指针一样的行为。</span></li></ol> 
</blockquote> 
<div> 
 <hr> 
 <h4>3、<span style="color:#333333;">std::auto_ptr </span></h4> 
 <p><a href="https://cplusplus.com/reference/memory/auto_ptr/" rel="nofollow" title="cplusplus.com/reference/memory/auto_ptr/">cplusplus.com/reference/memory/auto_ptr/</a></p> 
 <div> 
  <img alt="" height="76" src="https://images2.imgbox.com/4e/2c/WsU2b3r9_o.png" width="700"> 
 </div> 
 <div></div> 
 <blockquote> 
  <div> 
   <span style="color:#0d0016;">C++98 版本的库中就提供了 auto_ptr 的智能指针，该指针解决上诉的问题采取的措施是管理权转移的思想，也就是<strong>原对象拷贝给新对象的时候，</strong></span> 
   <span style="color:#fe2c24;"><strong>原对象就会被设置为 nullptr</strong></span> 
   <span style="color:#0d0016;">，此时就<span style="background-color:#ffd900;">只有新对象指向一块资源空间</span>。</span> 
  </div> 
 </blockquote> 
 <div> 
  <pre><code class="language-cpp">int main()
{
    auto_ptr&lt;int&gt; ptr1(new int);
    auto_ptr&lt;int&gt; ptr2(ptr1); // ptr1置为nullptr
    return 0;
}</code></pre> 
  <p><img alt="" height="414" src="https://images2.imgbox.com/ed/6d/59yqJ3Zd_o.png" width="420"></p> 
  <blockquote> 
   <p>如果 auto_ptr 调用拷贝构造函数或者赋值重载函数后<strong>，再去使用原来的对象的话，那么整个程序就会崩溃掉（因为原来的对象被设置为 nullptr)</strong>，这对程序是有很大的伤害的，所以很多公司会禁用 auto_ptr 智能指针。</p> 
  </blockquote> 
  <hr> 
  <h5 id="auto_ptr%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0">（1）auto_ptr 的拷贝构造函数和赋值重载函数的实现</h5> 
  <pre><code class="language-cpp">// 管理权转移，转移后就不能使用源对象
auto_ptr(auto_ptr ap) // auto_ptr的拷贝构造函数
    : ptr(ap.ptr)
{
    ap.ptr = nullptr;
}

auto_ptr&lt;T&gt; operator=(auto_ptr&lt;T&gt;&amp; ap) // auto_ptr的赋值重载函数
{
    if(ptr != ap.ptr)
    {
        ptr = ap.ptr;
        ap.ptr = nullptr;
    }
    return ptr;
}</code></pre> 
  <hr> 
  <h5><span style="color:#0d0016;"><strong>（2）auto_ptr 被 C++11 抛弃的主要原因</strong></span></h5> 
  <h6>a. 复制或者赋值都会改变资源的所有权</h6> 
  <pre><code class="language-cpp">// auto_ptr被C++11抛弃的主要原因：
auto_ptr&lt;string&gt; p1(new string("I'm xyl!"));
auto_ptr&lt;string&gt; p2(new string("I'm age 19."));

cout &lt;&lt; "p1：" &lt;&lt; p1.get() &lt;&lt; endl;
cout &lt;&lt; "p2：" &lt;&lt; p2.get() &lt;&lt; endl;

// p2赋值给p1后，首先p1会先将自己原先托管的指针释放掉，然后接收托管p2所托管的指针
// 然后p2所托管的指针制NULL，也就是p1托管了p2托管的指针，而p2放弃了托管
p1 = p2;	
cout &lt;&lt; "p1 = p2 赋值后：" &lt;&lt; endl;
cout &lt;&lt; "p1：" &lt;&lt; p1.get() &lt;&lt; endl;
cout &lt;&lt; "p2：" &lt;&lt; p2.get() &lt;&lt; endl;</code></pre> 
  <p><img alt="" height="170" src="https://images2.imgbox.com/21/25/wZoj2gIS_o.png" width="700"></p> 
  <hr> 
  <h6><span style="color:#0d0016;">b. 在 STL 容器中使用 auto_ptr 存在着重大风险，因为容器内的元素必须支持可复制和可赋值</span></h6> 
  <pre><code class="language-cpp">vector&lt;auto_ptr&lt;string&gt;&gt; vec;
auto_ptr&lt;string&gt; p3(new string("I'm p3"));
auto_ptr&lt;string&gt; p4(new string("I'm p4"));

// 必须使用std::move修饰成右值，才可以进行插入容器中
vec.push_back(std::move(p3));
vec.push_back(std::move(p4));

cout &lt;&lt; "vec.at(0)：" &lt;&lt;  *vec.at(0) &lt;&lt; endl;
cout &lt;&lt; "vec[1]：" &lt;&lt;  *vec[1] &lt;&lt; endl;

// 风险：
vec[0] = vec[1]; // 如果进行赋值，就又回到了上面一个问题中
cout &lt;&lt; "vec.at(0)：" &lt;&lt; *vec.at(0) &lt;&lt; endl;
cout &lt;&lt; "vec[1]：" &lt;&lt; *vec[1] &lt;&lt; endl;</code></pre> 
  <p><img alt="" height="242" src="https://images2.imgbox.com/ae/17/lWcqu4Vo_o.png" width="460"><strong>（访问越界）</strong></p> 
  <hr> 
  <h6><span style="color:#0d0016;">c. 不支持对象数组的内存管理</span></h6> 
  <pre><code class="language-cpp">auto_ptr&lt;int[]&gt; array(new int[5]); // 不能这样定义</code></pre> 
  <p><img alt="" height="153" src="https://images2.imgbox.com/ca/c2/HlxzdKo6_o.png" width="700"></p> 
  <blockquote> 
   <p>所以 C++11 选择使用更严谨的 unique_ptr 取代了 auto_ptr。</p> 
  </blockquote> 
  <hr> 
  <h5>（3）std::auto_ptr 的模拟实现</h5> 
  <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;

template &lt;class T&gt;
class auto_ptr
{
public:
	auto_ptr(T* ptr)
		:_ptr(ptr)
	{}

	// 管理权转移，解决二次释放的问题
	auto_ptr(auto_ptr&lt;T&gt; &amp; sp)
		:_ptr(sp._ptr)
	{
        // 管理权转移
		sp._ptr = nullptr;
	}

    auto_ptr&lt;T&gt;&amp; operator=(auto_ptr&lt;T&gt;&amp; sp)
    {
        // 检测是否为自己给自己赋值
        if (this != &amp;ap)
        {
            // 释放当前对象中资源
            if (_ptr)
                delete _ptr;

            // 转移ap中资源到当前对象中
            _ptr = sp._ptr;
            sp._ptr = NULL;
        }
        return *this;
    }

	~auto_ptr()
    {
		if (_ptr)
        {
            cout &lt;&lt; "delete:" &lt;&lt; _ptr &lt;&lt; endl;
			delete _ptr;
			_ptr = nullptr;

		}
	}

	T&amp; operator*()
    {
		return *_ptr;
	}

	T* operator-&gt;()
    {
		return _ptr;
	}
private:
	T* _ptr;
};</code></pre> 
  <hr> 
  <h4><span style="color:#333333;">4、std::unique_ptr </span></h4> 
  <blockquote> 
   <p><span style="color:#0d0016;">C++11 用更严谨的 unique_ptr 取代了 auto_ptr。</span></p> 
  </blockquote> 
  <p><a href="https://cplusplus.com/reference/memory/unique_ptr/" rel="nofollow" title="cplusplus.com/reference/memory/unique_ptr/">cplusplus.com/reference/memory/unique_ptr/</a></p> 
  <div> 
   <div> 
    <img alt="" height="96" src="https://images2.imgbox.com/61/16/MIDqvBjh_o.png" width="700"> 
   </div> 
   <hr> 
   <h5><span style="color:#0d0016;"><strong>（1）实现原理</strong></span></h5> 
   <div>
     unique_ptr 是 C++11 版本库中提供的智能指针， 
    <strong>它<span style="background-color:#ffd900;">直接将拷贝构造函数和赋值重载函数给禁用掉，</span></strong> 
    <span style="background-color:#ffd900;">因此不让其进行拷贝和赋值，是</span> 
    <span style="background-color:#ffd900;color:#0d0016;">简单粗暴的防拷贝</span> 
    <span style="color:#0d0016;">，下面简化模拟实现了一份 unique_ptr 来了解它的原理。</span> 
   </div> 
   <div> 
    <pre><code class="language-cpp">int main()
{
    unique_ptr&lt;int&gt; ptr1(new int);
    //unique_ptr&lt;int&gt; ptr2(ptr1); // error，不能调用unique_ptr的拷贝构造

    unique_ptr&lt;int&gt; ptr3(new int);
    ptr3 = ptr1; // error，不能调用unique_ptr的赋值构造

    return 0;
}</code></pre> 
    <hr> 
    <h5 id="unique_ptr%E7%9A%84%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0">（2）unique_ptr 的拷贝函数和赋值重载函数</h5> 
    <pre><code class="language-cpp">template&lt;class T&gt;
class unique_ptr
{
public:
    //unique_ptr的拷贝构造函数和赋值重载构造给禁用掉
    unique_ptr(unique_ptr&amp;) = delete;
    operator=(unique_ptr&amp;) = delete;
private:
    T* ptr;
};</code></pre> 
    <hr> 
    <h5>（3）std::unique_ptr 的模拟实现</h5> 
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;

namespace xyl
{
    template &lt;class T&gt;
    class unique_ptr
    {
    public:
        unique_ptr(T* ptr)
            :_ptr(ptr)
        {}

        ~unique_ptr()
        {
            if (_ptr)
            {
                cout &lt;&lt; "delete:" &lt;&lt; _ptr &lt;&lt; endl;
                delete _ptr;
            }
        }
        
        // 像指针一样使用
        T&amp; operator*()
        {
            return *_ptr;
        }
    
        T* operator-&gt;()
        {
            return _ptr;
        }
 
        // 防拷贝:两种方式都可以
        unique_ptr(const unique_ptr&lt;T&gt;&amp; sp) = delete;

        unique_ptr&lt;T&gt;&amp; operator=(const unique_ptr&lt;T&gt;&amp; sp) = delete;
    private:
        T* _ptr;
    };
}</code></pre> 
    <hr> 
    <h4><span style="color:#333333;">5、std::shared_ptr </span></h4> 
    <p><a href="https://cplusplus.com/reference/memory/shared_ptr/" rel="nofollow" title="cplusplus.com/reference/memory/shared_ptr/">cplusplus.com/reference/memory/shared_ptr/</a></p> 
   </div> 
   <div> 
    <img alt="" height="76" src="https://images2.imgbox.com/80/55/Be3zq5f7_o.png" width="700"> 
   </div> 
   <div> 
    <div>
      share_ptr 是 C++11 版本库中的智能指针， 
     <strong>shared_ptr <span style="background-color:#ffd900;">允许多个智能指针可以指向同一块资源</span></strong>，并且能够保证共享的资源只会被释放一次，因此程序不会发生崩溃。 
    </div> 
    <div> 
     <hr> 
     <h5><span style="color:#0d0016;"><strong>（1）实现原理</strong></span></h5> 
    </div> 
    <div> 
     <span style="color:#0d0016;">是</span> 
     <span style="background-color:#ffd900;color:#0d0016;">通过引用</span> 
     <span style="color:#fe2c24;"><span style="background-color:#ffd900;"><strong>计数</strong></span></span> 
     <span style="color:#0d0016;"><span style="background-color:#ffd900;">的方式来</span></span> 
     <span style="color:#fe2c24;"><span style="background-color:#ffd900;"><strong>实现多个 shared_ptr 对象之间共享资源</strong></span></span> 
     <span style="color:#0d0016;">。例如，老师晚上在下班之前都会通知，让最后走的学生记得把门锁下。 </span> 
    </div> 
    <div></div> 
    <blockquote> 
     <ol><li><span style="color:#0d0016;">shared_ptr 在其内部，<strong>给每个资源都维护了着一份计数，用来记录该份资源被几个对象共</strong></span><span style="color:#0d0016;"><strong>享</strong>。 </span></li><li><span style="color:#0d0016;">在<strong>对象被销毁</strong>时（也就是<strong>析构函数调用</strong>），说明自己不使用该资源了，对象的引用计数减</span><span style="color:#0d0016;">一。 </span></li><li><span style="color:#0d0016;">如果<strong><span style="background-color:#ffd900;">引用计数是 0</span></strong>，就说明自己是最后一个使用该资源的对象，<strong><span style="background-color:#ffd900;">必须释放该资源</span></strong>； </span></li><li><span style="color:#0d0016;">如果<strong><span style="background-color:#ffd900;">不是 0</span></strong>，就说明除了自己还有其他对象在使用该份资源，<strong><span style="background-color:#ffd900;">不能释放该资源</span></strong><span style="background-color:#ffd900;">，否则其他对</span></span><span style="color:#0d0016;"><span style="background-color:#ffd900;">象就成野指针了。 </span></span></li></ol> 
    </blockquote> 
   </div> 
  </div> 
 </div> 
</div> 
<p>std::shared_ptr::get 获取指针，存储的指针指向 shared_ptr 对象解引用的对象，通常与其拥有的指针相同。头文件为 #include &lt;memory&gt;。 返回 ptr 中保存的指针，要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了。get 用来将指针的访问权限传递给代码，你只有在确定代码不会 delete 指针的情况下，才能使用 get 。特别是，永远不要用 get 初始化另一个智能指针或者为另一个智能指针赋值，因为这样会造成二次释放。</p> 
<pre><code class="language-cpp">int main()
{
    shared_ptr&lt;int&gt; ptr6(new int(2));
    cout &lt;&lt; ptr6.get() &lt;&lt; endl;
    shared_ptr&lt;int&gt; ptr7 = ptr6;
    cout &lt;&lt; ptr7.get() &lt;&lt; endl;
    cout &lt;&lt; ptr6.get() &lt;&lt; endl;
    return 0;
}</code></pre> 
<p><img alt="" height="136" src="https://images2.imgbox.com/3f/5c/l6wcnDW7_o.png" width="460"></p> 
<p><img alt="" height="507" src="https://images2.imgbox.com/66/93/ttqeqnSZ_o.png" width="700"><strong>销毁过程： </strong></p> 
<p><img alt="" height="176" src="https://images2.imgbox.com/6d/e5/uJZ89xnA_o.png" width="700"></p> 
<hr> 
<h5 id="3.%20shared_ptrd%E7%9A%84%E5%AE%9E%E7%8E%B0"><strong>（2）shared_ptrd 的实现</strong></h5> 
<p>赋值重载的三种情况:</p> 
<ol><li>ptr1 = ptr1；智能指针自己给自己赋值，不做处理。</li><li>ptr2 = ptr1；如果 ptr1 和 ptr2 指向同一块空间，不做处理。</li><li>ptr2 = ptr1；如果 ptr2 和 ptr1 指向的空间不一样,处理过程如下：</li></ol> 
<p><img alt="" height="509" src="https://images2.imgbox.com/fd/31/U5GqJZ1T_o.png" width="700"></p> 
<blockquote> 
 <ul><li>因为 _ptrcount 指向的对象是在堆上，因此所有的线程都能够访问到该资源，多线程在修改 _ptrcount 时，则会出现线程安全问题，因此需要在修改 _prtcount 时需要用锁来保证其数据的正确性。</li><li>"*" 会返回 ptr 指向的对象，为什么不需要锁对其进行保护？因为 ptr 返回的对象有可能被读或者被写，这个不是指针内部所考虑的，而是由调用者进行考虑的。</li></ul> 
</blockquote> 
<div> 
 <pre><code class="language-cpp">template&lt;class T&gt;
class shared_ptr
{
public:
    shared_ptr(T* _ptr) // 构造函数
        : ptr(_ptr)
    {
        ptrcount = new int(1);
        mt = new mutex;
    }

    void AddCount()
    {
        mt-&gt;lock();
        (*ptrcount)++;
        mt-&gt;unlock();
    }

    shared_ptr(shared_ptr&lt;T&gt;&amp; sp)
    {
        if(sp.ptr != ptr)
        {
            Realse();//释放旧资源
            ptr = sp.ptr;
            ptrcount = sp.ptrcount;
            mt = sp.mt;
            AddCount();
        }
        return *this;
    }

    ~shared_ptr() // 析构函数
    {
        Realse();
    }

    int&amp; use_count()
    {
        return *ptrcount;
    }

    void Realse()
    {
        bool deleteflag = false;
        mt-&gt;lock();
        if(--(*ptrcount)==0)
        {
            delete ptrcount;
            delete ptr;
            ptrcount = nullptr;
            ptr = nullptr;
            deleteflag = true;
        }
        mt-lock();

        if(deleteflag == true)
        {
            delete mt;
            mt = nullptr;
        }
    }
    T&amp; operator*() {return *ptr;} // 重载出*运算符

    T* operator-&gt;() {return ptr;} // 重载出-&gt;运算符
private:
    T* ptr; // 指针对象
    int* ptrcount; // 引用计数
    mutex* mt;
};</code></pre> 
 <hr> 
 <h5><span style="color:#0d0016;">（3）std::shared_ptr 的线程安全问题</span></h5> 
 <p></p> 
 <h6><span style="color:#fe2c24;"><strong>shared_ptr智能指针是线程安全的吗？ </strong></span></h6> 
 <blockquote> 
  <div> 
   <span style="color:#0d0016;">是的，引用计数的加减是加锁保护的，但是指向资源不是线程安全的。</span> 
  </div> 
 </blockquote> 
</div> 
<div> 
 <span style="color:#0d0016;">通过下面的程序我们来测试 shared_ptr 的线程安全问题。需要注意的是 shared_ptr 的线程安全分 </span> 
</div> 
<div> 
 <span style="color:#0d0016;">为以下两方面： </span> 
</div> 
<blockquote> 
 <ol><li><span style="color:#0d0016;">智能指针对象中引用计数是多个智能指针对象共享的，两个线程中智能指针的引用计数同时 </span><span style="color:#0d0016;">++ / --，这个操作不是原子的，引用计数原来是 1，++ 了两次，可能还是 2，这样引用计数就错</span><span style="color:#0d0016;">乱了。会导致资源未释放或者程序崩溃的问题。所以只能指针中引用计数 ++、-- 是需要加锁</span><span style="color:#0d0016;">的，也就是说引用计数的操作是线程安全的。 </span></li><li><span style="color:#0d0016;">智能指针管理的对象存放在堆上，两个线程中同时去访问，会导致线程安全问题。 </span></li></ol> 
</blockquote> 
<p>演示引用计数线程安全问题，就把 AddRefCount 和 SubRefCount 中的锁去掉。</p> 
<p>演示可能不出现线程安全问题，因为线程安全问题是偶现性问题，main 函数的 n 改大一些概率就变大了，就容易出现了。</p> 
<p>下面代码我们使用 SharedPtr 演示，是为了方便演示引用计数的线程安全问题，将代码中的 SharedPtr 换成 shared_ptr 进行测试，可以验证库的 shared_ptr，发现结论是一样的。 </p> 
<pre><code class="language-cpp">struct Date
{
    int _year = 0;
    int _month = 0;
    int _day = 0;
};

void SharePtrFunc(xyl::shared_ptr&lt;Date&gt;&amp; sp, size_t n, mutex&amp; mtx)
{
    cout &lt;&lt; sp.get() &lt;&lt; endl;

    for (size_t i = 0; i &lt; n; ++i)
    {
        // 这里智能指针拷贝会++计数，智能指针析构会--计数，这里是线程安全的。
        xyl::shared_ptr&lt;Date&gt; copy(sp);

        // 这里智能指针访问管理的资源，不是线程安全的。所以我们看看这些值两个线程++了2n次，但是最终看到的结果，并一定是加了2n
        {
            unique_lock&lt;mutex&gt; lk(mtx);
            copy-&gt;_year++;
            copy-&gt;_month++;
            copy-&gt;_day++;
        }
    }
}

int main()
{
    xyl::shared_ptr&lt;Date&gt; p(new Date);
    cout &lt;&lt; p.get() &lt;&lt; endl;
    const size_t n = 100000;
    mutex mtx;
    thread t1(SharePtrFunc, std::ref(p), n, std::ref(mtx));
    thread t2(SharePtrFunc, std::ref(p), n, std::ref(mtx));

    t1.join();
    t2.join();

    cout &lt;&lt; p-&gt;_year &lt;&lt; endl;
    cout &lt;&lt; p-&gt;_month &lt;&lt; endl;
    cout &lt;&lt; p-&gt;_day &lt;&lt; endl;

    cout &lt;&lt; p.use_count() &lt;&lt; endl;

    return 0;
}</code></pre> 
<hr> 
<h5><span style="color:#0d0016;"><strong><span style="background-color:#38d8f0;">（4）std::shared_ptr 的循环引用</span></strong></span></h5> 
<blockquote> 
 <p><span style="color:#0d0016;">shared_ptr 固然好用，但是它也会有问题存在。</span></p> 
 <p><span style="color:#0d0016;">假设我们要使用定义一个双向链表，如果想要让创建出来的链表的节点都定义成 shared_ptr 智能指针，那么就需要将节点内的 _pre 和 _next 都定义成 shared_ptr 的智能指针。</span></p> 
 <p><span style="color:#0d0016;">如果定义成普通指针，那么就不能赋值给 shared_ptr 的智能指针。</span></p> 
</blockquote> 
<p><img alt="" height="281" src="https://images2.imgbox.com/6c/95/JisgHROO_o.png" width="700"></p> 
<p>当其中<span style="background-color:#ffd900;">两个节点互相引用</span>的时候，就会出现循环引用的现象。如下所示：</p> 
<pre><code class="language-cpp">struct ListNode
{
    int _data;
    shared_ptr&lt;ListNode&gt; _pre;
    shared_ptr&lt;ListNode&gt; _next;
    ~ListNode() { cout &lt;&lt; "~ListNode()" &lt;&lt; endl; }
};

int main()
{
    shared_ptr&lt;ListNode&gt; node1(new ListNode);
    shared_ptr&lt;ListNode&gt; node2(new ListNode);
    cout &lt;&lt; node1.use_count() &lt;&lt; endl;
    cout &lt;&lt; node2.use_count() &lt;&lt; endl;

    node1-&gt;_next = node2;
    node2-&gt;_pre = node1;
    cout &lt;&lt; node1.use_count() &lt;&lt; endl;
    cout &lt;&lt; node2.use_count() &lt;&lt; endl;

    return 0;
}</code></pre> 
<p><img alt="" height="250" src="https://images2.imgbox.com/61/59/TDp6qRiH_o.png" width="700"></p> 
<blockquote> 
 <ul><li><strong> use_count（）</strong>: 返回智能指针对象的引用计数。</li></ul> 
</blockquote> 
<p><img alt="" height="373" src="https://images2.imgbox.com/fc/70/vlzCu7ut_o.png" width="700"></p> 
<p><img alt="" height="226" src="https://images2.imgbox.com/5e/a8/FXrJiydE_o.png" width="700"></p> 
<div> 
 <span style="color:#0d0016;"><strong>循环引用分析： </strong></span> 
</div> 
<blockquote> 
 <ol><li><span style="color:#0d0016;">node1 和 node2 两个智能指针对象指向两个节点，引用计数变成 1，我们不需要手动 </span><span style="color:#0d0016;">delete。 </span></li><li><span style="color:#0d0016;">node1 的 _next 指向 node2，node2 的 _pre 指向 node1，引用计数变成 2。 </span></li><li><span style="color:#0d0016;">node1 和 node2 析构，引用计数减到 1，但是 _next 还指向下一个节点，_pre 还指向上</span><span style="color:#0d0016;">一个节点。</span><span style="color:#0d0016;">也就是说 _next 析构了，node2 就释放了；</span><span style="color:#0d0016;">_pre 析构了，node1 就释放了。 </span></li><li><span style="color:#0d0016;">但是，_next 属于 node 的成员，node1 释放了，_next 才会析构，而 node1 由 _pre 管理，_pre </span><span style="color:#0d0016;">属于 node2 成员，所以这就叫<span style="background-color:#ffd900;">循环引用，谁也不会释放</span>。 </span></li></ol> 
</blockquote> 
<p>解决方案：在引用计数的场景下，把节点中的 _pre 和 _next 改成 weak_ptr 就可以了。<br> 原理：node1-&gt;_next = node2; 和 node2-&gt;_prev = node1; 时，<span style="background-color:#ffd900;">weak_ptr 的 _next 和 _pre 不会增加 node1 和 node2 的引用计数。 </span></p> 
<pre><code class="language-cpp">struct ListNode
{
    int _data;
    weak_ptr&lt;ListNode&gt; _pre;
    weak_ptr&lt;ListNode&gt; _next;
    ~ListNode(){ cout &lt;&lt; "~ListNode()" &lt;&lt; endl; }
};

int main()
{
    shared_ptr&lt;ListNode&gt; node1(new ListNode);
    shared_ptr&lt;ListNode&gt; node2(new ListNode);
    cout &lt;&lt; node1.use_count() &lt;&lt; endl;
    cout &lt;&lt; node2.use_count() &lt;&lt; endl;

    node1-&gt;_next = node2;
    node2-&gt;_pre = node1;

    cout &lt;&lt; node1.use_count() &lt;&lt; endl;
    cout &lt;&lt; node2.use_count() &lt;&lt; endl;

    return 0;
}</code></pre> 
<hr> 
<h6><span style="color:#fe2c24;"><strong>如果不是 new 出来的对象该如何通过智能指针管理呢？</strong></span></h6> 
<div> 
 <span style="color:#0d0016;">其实 <span style="background-color:#ffd900;">shared_ptr 设计了一个删除器</span>来解决这个问题。<span style="background-color:#d7d8d9;">（了解）</span></span> 
</div> 
<div></div> 
<blockquote> 
 <div>
   当 
  <strong>我们释放一个指向数组的指针的时候</strong>， 
  <strong>delete[] 后面的空方括号是必须存在</strong>，它指示编译器此指针指向的是一个对象数组的第一个元素，如果我们在 delete 一个指向数组的指针中忽略了方括号，那么程序可能在执行时没有任何警告下发生行为异常。  
 </div> 
</blockquote> 
<pre><code class="language-cpp">int* ptr = new int[10];
delete[] ptr;
//delete ptr; //error</code></pre> 
<blockquote> 
 <p>我们如果在动态内存中创建出一个数组，用一个 shared_ptr 对象去指向该数组，当 shared_ptr 使用完后，就会去调用析构函数，<strong>由于 shared_ptr 默认的删除方式是 delete ptr，后面没有带方括号</strong>，那么程序就会崩掉。</p> 
</blockquote> 
<p><img alt="" height="213" src="https://images2.imgbox.com/6c/c1/dbW1bSE0_o.png" width="700"></p> 
<blockquote> 
 <p>如果我们打开了一个文件，返回一个文件指针，让一个 shared_ptr 对象去指向该文件，那么在调用析构函数的时候就<strong>不能采用 delete 方法，而是使用 close() 函数去关闭该文件</strong>。</p> 
 <p>因此，shared_ptr 类中提供了一个构造函数可以自定义一个删除器去指定析构函数的删除方式。</p> 
 <p><img alt="" height="26" src="https://images2.imgbox.com/be/c2/vxpsYijc_o.png" width="520"></p> 
 <p>这个自定义删除器可以是<strong>函数指针</strong>，<strong>仿函数</strong>，<strong>lamber，包装器</strong>。</p> 
</blockquote> 
<p id="%E4%BB%BF%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%A0%E9%99%A4%E5%99%A8"><strong>【仿函数的删除器】</strong></p> 
<p>shared_ptr 中的析构函数会去调用 DelArry 仿函数去释放动态数组。</p> 
<p><img alt="" height="245" src="https://images2.imgbox.com/e0/d3/U887MFhC_o.png" width="700"></p> 
<hr> 
<h5>（5）std::shared_ptr 和 std::weak_ptr<span style="color:#aa5500;"> </span>的模拟实现</h5> 
<pre><code class="language-cpp">// 引用计数支持多个拷贝管理同一个资源，最后一个析构对象释放资源
namespace xyl
{
    template &lt;class T&gt;
    class shared_ptr
    {
    public:
        shared_ptr(T* ptr = nullptr)
            : _ptr(ptr)
            , _pRefCount(new int(1))
            , _pmtx(new mutex)
        {}
 
        shared_ptr(const shared_ptr&lt;T&gt;&amp; sp)
            : _ptr(sp._ptr)
            , _pRefCount(sp._pRefCount)
            , _pmtx(sp._pmtx)
        {
            AddRef();
        }

        void Release()
        {
            _pmtx-&gt;lock();
            bool flag = false;
            if (--(*_pRefCount) == 0 &amp;&amp; _ptr)
            {
                cout &lt;&lt; "delete:" &lt;&lt; _ptr &lt;&lt; endl;
                delete _ptr;
                delete _pRefCount;
                flag = true;
            }
            _pmtx-&gt;unlock();
            if (flag == true)
            {
                delete _pmtx;
            }
        }
 
        void AddRef()
        {
            _pmtx-&gt;lock();
            ++(*_pRefCount);
            _pmtx-&gt;unlock();
        }

        shared_ptr&lt;T&gt;&amp; operator=(const shared_ptr&lt;T&gt;&amp; sp)
        {
            //if (this != &amp;sp)
            if (_ptr != sp._ptr)
            {
                Release();
                _ptr = sp._ptr;
                _pRefCount = sp._pRefCount;
                _pmtx = sp._pmtx;
                AddRef();
            }
            return *this;
        }

        int use_count()
        {
            return *_pRefCount;
        }
 
        ~shared_ptr()
        {
            Release();
        }
 
        // 像指针一样使用
        T&amp; operator*()
        {
            return *_ptr;
        }
 
        T* operator-&gt;()
        {
            return _ptr;
        }
 
        T* get() const
        {
            return _ptr;
        }
    private:
        T* _ptr;
        int* _pRefCount;
        mutex* _pmtx;
    };
    
    // 简化版本的weak_ptr实现
    template&lt;class T&gt;
    class weak_ptr
    {
    public:
        weak_ptr()
            : _ptr(nullptr)
        {}
 
        weak_ptr(const shared_ptr&lt;T&gt;&amp; sp)
            :_ptr(sp.get())
        {}
 
        weak_ptr&lt;T&gt;&amp; operator=(const shared_ptr&lt;T&gt;&amp; sp)
        {
            _ptr = sp.get();
            return *this;
        }
 
        T&amp; operator*()
        {
            return *_ptr;
        }
 
        T* operator-&gt;()
        {
            return _ptr;
        }
    private:
        T* _ptr;
    };
}</code></pre> 
<hr> 
<h2><span style="color:#333333;">四、C++11 </span><span style="color:#333333;">和 </span><span style="color:#333333;">boost </span><span style="color:#333333;">中智能指针的关系 </span></h2> 
<blockquote> 
 <ol><li><span style="color:#0d0016;"><span style="background-color:#ffd900;">C++98 中产生了第一个智能指针 auto_ptr。</span></span></li><li><strong><span style="color:#0d0016;">C++boost 给出了更实用的 scoped_ptr 和 shared_ptr 和 weak_ptr。</span></strong></li><li><span style="color:#0d0016;">C++TR1，引入了 shared_ptr 等。不过注意的是 TR1 并不是标准版。 </span></li><li><span style="color:#0d0016;"><span style="background-color:#ffd900;">C++11，引入了 unique_ptr 和 shared_ptr 和 weak_ptr。</span>需要注意的是 <strong>unique_ptr 对应boost </strong></span><span style="color:#0d0016;"><strong>的 scoped_ptr。</strong>并且这些智能指针的实现原理是参考 boost 中的实现的。</span></li></ol> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1413f8b2a2330655cb5eb15250471aab/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">《三十一》开发模式构建工具 Vite</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a72f2a5e7c5051fb14847aa99cf1deed/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;速刷精品】滑动窗口</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>