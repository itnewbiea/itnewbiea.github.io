<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>网格缺陷检测(二值化阈值分析） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="网格缺陷检测(二值化阈值分析）" />
<meta property="og:description" content="摘要 本篇来用OpenCV实现Halcon中一个简单的网格缺陷检测实例。 Halcon中对应的例子为novelty_detection_dyn_threshold.hdev。并对二值化中的三种阈值处理进行介绍和比较：
全局阈值二值化(含OTSU方法) 自适应阈值二值化
双阈值二值化 阈值处理分析 1️⃣全局阈值二值化-threshold() OpenCV的threshold函数一般是给定一个阈值，对超过或者低于这个阈值的像素进行处理，函数如下：
threshold( InputArray src, // 输入图像 OutputArray dst, // 输出图像 double thresh, // 阈值 double maxValue, // 最大值(对于三通道图像一般是255) int thresholdType // 阈值化操作的类型 ) 阈值化操作的类型常用两种： THRESH_BINARY //黑背景找白目标(即超过设定阈值的值置255，其他为0) THRESH_BINARY_INV //白背景找黑目标(即超过设定阈值的值置0，其他为255) 全局阈值类似一刀切的概念。对于整体图像来说，找到一个合适的阈值，将图像分为0(黑色)和255(白色)。
2️⃣自适应阈值二值化-adaptiveThreshold() 对于亮度分布差异较大的图像，因为常常无法找到一个合适的阈值。因此我们需要一种改进的阈值化算法，即自适应阈值化。
adaptiveThreshold( InputArray src, // 输入图像 OutputArray dst, // 输出图像 double maxValue, // 最大值 int adaptiveMethod, // 自适应方法，平均或高斯 int thresholdType // 阈值化类型 int blockSize, // 块大小(大小必须为奇数) double C // 常量(即偏移值调整量) ) //adaptiveThreshold()支持两种自适应方法: ADAPTIVE_THRESH_MEAN_C //平均:阈值是邻域的平均值" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/80dfcb15ba35e579d19defa9afae2b17/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-04T17:30:00+08:00" />
<meta property="article:modified_time" content="2021-06-04T17:30:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">网格缺陷检测(二值化阈值分析）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html" style="font-size: 16px;"> 
 <h3><strong>摘要</strong></h3> 
 <p>本篇来用OpenCV实现Halcon中一个简单的网格缺陷检测实例。 Halcon中对应的例子为novelty_detection_dyn_threshold.hdev。并对二值化中的三种阈值处理进行介绍和比较：</p> 
 <ul><li>全局阈值二值化(含OTSU方法)</li><li> <p id="adaptivethreshold自适应阈值二值化">自适应阈值二值化</p> </li><li>双阈值二值化</li></ul> 
 <hr> 
 <h3><span style="font-weight: bold;"><strong>阈值处理分析</strong></span></h3> 
 <h4><strong>1️⃣全局阈值二值化-threshold()</strong></h4> 
 <p>OpenCV的threshold函数一般是给定一个阈值，对超过或者低于这个阈值的像素进行处理，函数如下：</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">threshold(
    InputArray src,      // 输入图像
    OutputArray dst,     // 输出图像
    double thresh,       // 阈值
    double maxValue,     // 最大值(对于三通道图像一般是255)
    int thresholdType    // 阈值化操作的类型 
          )
 阈值化操作的类型常用两种：
THRESH_BINARY     //黑背景找白目标(即超过设定阈值的值置255，其他为0)
THRESH_BINARY_INV //白背景找黑目标(即超过设定阈值的值置0，其他为255)</code>
</pre> 
 </div> 
 <p> 全局阈值类似一刀切的概念。对于整体图像来说，找到一个合适的阈值，将图像分为0(黑色)和255(白色)。</p> 
 <h4><strong>2️⃣自适应阈值二值化-adaptiveThreshold()</strong></h4> 
 <p>对于亮度分布差异较大的图像，因为常常无法找到一个合适的阈值。因此我们需要一种改进的阈值化算法，即自适应阈值化。</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">adaptiveThreshold(  
    InputArray src,       // 输入图像  
    OutputArray dst,      // 输出图像  
    double maxValue,      // 最大值  
    int adaptiveMethod,   // 自适应方法，平均或高斯  
    int thresholdType     // 阈值化类型  
    int blockSize,        // 块大小(大小必须为奇数)
    double C              // 常量(即偏移值调整量)
                  ) 
//adaptiveThreshold()支持两种自适应方法:
ADAPTIVE_THRESH_MEAN_C       //平均:阈值是邻域的平均值<br>ADAPTIVE_THRESH_GAUSSIAN_C   //高斯:阈值是邻域值的加权和，其中权重是高斯窗口<br></code>
</pre> 
 </div> 
 <p> 自适应阈值化能够根据图像不同区域亮度分布的，改变阈值。因此，我们针对同一图像的不同区域获得不同的阈值，并为具有不同照明的图像提供更好的结果。</p> 
 <h4><strong> 3️⃣双阈值二值化</strong></h4> 
 <p>对于图像具有明显的双分界特征，可以使用双阈值法进行二值化操作，即实现Halcon中的threshold函数。</p> 
 <p>简单来说：</p> 
 <ul><li>Halcon的threshold函数是获取区间[a, b]之间的灰度值(双阈值)</li><li>OpenCV的threshold只能针对大于或者小于a或者b的灰度值处理(单阈值)</li></ul> 
 <p>因此我们可以预设两个特定的阈值量thresh1、thresh2，并且thresh1 &lt; thresh2 。阈值化的过程就是，将在 (thresh1，thresh2) 这个区间内的灰度值设置为maxVal(255)，将其余部分设置为0 。</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">    const int maxVal = 255;        //预设最大值
    int low_threshold = 90;        //较小的阈值量
    int high_threshold = 190;      //较大的阈值量
    //小阈值对源灰度图像进行二进制阈值化操作
    threshold(srcGray, dst1, low_threshold, maxVal, THRESH_BINARY);
    //大阈值对源灰度图像进行反二进制阈值化操作
    threshold(srcGray, dst2, high_threshold, maxVal, THRESH_BINARY_INV);
    //矩阵"与运算"得到二值化结果
    bitwise_and(dst1, dst2, dst); //对像素加和
    imshow("双阈值二值化", dst);</code>
</pre> 
 </div> 
 <div> 
  程序中主要还是用到了threshold()函数，对较小的阈值量进行二进制阈值化，而对较大的阈值量进行反二进制化操作，最后将所得的两幅图像进行与运算，得到最终效果。 
  <hr> 
 </div> 
 <h3><span style="font-weight: bold;"><strong>网格缺陷检测</strong></span></h3> 
 <p>进入正题，本篇对网格缺陷检测的思路很简单：</p> 
 <ol><li>动态阈值处理</li><li>面积筛选显示缺陷</li></ol> 
 <p><strong>opencv实现：</strong></p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">    Mat src = imread("D:/opencv练习图片/网格缺陷检测1.png");
    imshow("原图", src);
    cvtColor(src, gray, COLOR_RGB2GRAY);
    GaussianBlur(gray, gray, Size(3, 3), 1, 0);
    //双阈值方法
    threshold(gray, binary1, 25, 255, THRESH_BINARY);
    threshold(gray, binary2, 80, 255, THRESH_BINARY_INV);
    bitwise_and(binary1, binary2, binary);
    imshow("双阈值二值化", binary);
    vector&lt;vector&lt;Point&gt;&gt;contours;
    findContours(binary, contours, RETR_EXTERNAL, CHAIN_APPROX_NONE, Point());
    for (int i = 0; i &lt; contours.size(); i++)
    {
        float area = contourArea(contours[i]);
        if (area&gt;350)
        {
            drawContours(src, contours, i, Scalar(0, 0, 255), 2, 8);
            int baseline = 0;
            Size textSize = getTextSize("Mesh Not OK", FONT_HERSHEY_SIMPLEX, 1.0, 2, &amp;baseline);        
            rectangle(src, Rect(10, 10, textSize.width, textSize.height + baseline), Scalar(212, 233, 252), -1, 8);
            putText(src, "Mesh Not OK", Point(10, 5 + textSize.height + baseline), FONT_HERSHEY_SIMPLEX, 1, Scalar(0, 0, 255), 2, 8);
        }
        else
        {
            int baseline = 0;
            Size textSize = getTextSize("Mesh OK", FONT_HERSHEY_SIMPLEX, 1.0, 2, &amp;baseline);
            rectangle(src, Rect(10, 10, textSize.width, textSize.height + baseline), Scalar(212, 233, 252), -1, 8);
            putText(src, "Mesh OK", Point(10, 5 + textSize.height + baseline), FONT_HERSHEY_SIMPLEX, 1, Scalar(0, 0, 255), 2, 8);
        }
    }
    imshow("缺陷", src);</code>
</pre> 
 </div> 
 <p><img src="https://images2.imgbox.com/38/4f/LiP0qOb6_o.png" alt="" width="473" height="379" style="outline: none;"><img src="https://images2.imgbox.com/52/1a/xF1zC2gw_o.png" alt="" width="465" height="376" style="outline: none;"></p> 
 <p>这里采用的是双阈值处理。我们可以对比三种阈值处理的情况：</p> 
 <p><strong>(1)全局阈值OTSU方法：</strong></p> 
 <p><img src="https://images2.imgbox.com/54/72/y63ueRhD_o.png" alt="" width="607" height="489" style="outline: none;"></p> 
 <p> 可以看到有部分正常孔洞和网格相连，会导致正常孔洞也被标记为缺陷。</p> 
 <p><strong>(2)自适应阈值：</strong></p> 
 <p><strong></strong></p> 
 <div style="text-align: center;"> 
  <strong><img src="https://images2.imgbox.com/94/0c/q3YMMwzn_o.png" alt="" width="605" height="484" style="outline: none;"></strong> 
 </div> 
 <p></p> 
 <p> 可以看到效果还不错。</p> 
 <p><strong>(3)双阈值：</strong></p> 
 <p><strong></strong></p> 
 <div style="text-align: center;"> 
  <strong><img src="https://images2.imgbox.com/0c/b7/qQ0I8YAm_o.png" alt="" width="600" height="484" style="outline: none;"></strong> 
 </div> 
 <p></p> 
 <p> 对比自适应阈值，可以看到分割的还是比较明显一点的。</p> 
 <p> 参考博文：<a href="https://blog.csdn.net/sinat_21258931/article/details/61418681?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control" rel="noopener">python-opencv函数总结之(一)threshold、adaptiveThreshold、Otsu 二值化_sinat_21258931的博客-CSDN博客</a></p> 
 <p>                 <span id="profileBt" class="rich_media_meta rich_media_meta_nickname"><a id="js_name" rel="noopener"></a>OpenCV与AI深度学习</span></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/09a1273b9aa6c18de77cab67fa7fecbc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nutz跳转html,视图</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bf2acea83d454ef396f6b5bc5384c72f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js中存取cookie</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>