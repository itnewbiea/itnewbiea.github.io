<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ChatGLM接入微信公众号（cpolar的使用） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ChatGLM接入微信公众号（cpolar的使用）" />
<meta property="og:description" content="一，尝试 继上利用frp加上阿里云服务器，借助公网ip实现内网穿透，再加上申请域名，解析云服务器，再frp上建立http连接，但是由于阿里云免费的服务器，不支持备案，所以域名解析的服务器无法通过域名访问，所以我尝试去购买便宜的香港的服务器免去备案的麻烦，但是连接完之后，token依旧验证失败。
二，方法 2.1 解决验证问题 我的连接问题我认为很大概率是我的域名和服务器的问题，所以得找到一个替代省去麻烦，最好就是找一个内网穿透的工具，可以建立http连接并且能够提供备案域名实现连接。
2.2 cpolar的使用 我看到b站视频cpolar，这个工具可以免费进行内网穿透并提供备案域名，但是备案域名只是24h内随机域名，需要固定域名可以购买基础套餐
进入cpolar的官网
cpolar - secure introspectable tunnels to localhost
登录注册之后
按照图片要求操作，下载对应版本的cpolar，解压缩之后，连接自己的账户
./cpolar http 80
开放端口进入
实际效果应该是这样
只需要将对应的连接80端口的提供好的给你的域名，填入微信公众号验证就行，在加上token的验证代码，上一个文章也有，我粘贴部分
def wechat(): timestamp = request.args.get(&#34;timestamp&#34;) nonce = request.args.get(&#34;nonce&#34;) echostr = request.args.get(&#34;echostr&#34;) signature = request.args.get(&#34;signature&#34;) if request.method == &#34;GET&#34;: if not all([signature, echostr, nonce, timestamp]): abort(404) li = [wechatToken, timestamp, nonce] li.sort() tmp_str = &#34;&#34;.join(li) sign = hashlib.sha1(tmp_str.encode(&#34;utf-8&#34;)).hexdigest() if signature != sign: abort(403) else: return echostr 因为微信在给你发送验证请求的是get请求，所以分开执行后面的post发送也会比较方便" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4d9243bf0e48eeb1173f511f588bc6a1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-25T21:23:39+08:00" />
<meta property="article:modified_time" content="2023-09-25T21:23:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ChatGLM接入微信公众号（cpolar的使用）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一，尝试</h2> 
<p>  继上利用frp加上阿里云服务器，借助公网ip实现内网穿透，再加上申请域名，解析云服务器，再frp上建立http连接，但是由于阿里云免费的服务器，不支持备案，所以域名解析的服务器无法通过域名访问，所以我尝试去购买便宜的香港的服务器免去备案的麻烦，但是连接完之后，token依旧验证失败。</p> 
<h2>二，方法</h2> 
<h3>2.1 解决验证问题</h3> 
<p>  我的连接问题我认为很大概率是我的域名和服务器的问题，所以得找到一个替代省去麻烦，最好就是找一个内网穿透的工具，可以建立http连接并且能够提供备案域名实现连接。</p> 
<h3>2.2 cpolar的使用</h3> 
<p>  我看到b站视频cpolar，这个工具可以免费进行内网穿透并提供备案域名，但是备案域名只是24h内随机域名，需要固定域名可以购买基础套餐</p> 
<p>进入cpolar的官网</p> 
<p><a href="https://dashboard.cpolar.com/" rel="nofollow" title="cpolar - secure introspectable tunnels to localhost">cpolar - secure introspectable tunnels to localhost</a></p> 
<p>登录注册之后</p> 
<p><img alt="" height="752" src="https://images2.imgbox.com/bb/4d/vH5C42J9_o.png" width="908"></p> 
<p> 按照图片要求操作，下载对应版本的cpolar，解压缩之后，连接自己的账户</p> 
<p> ./cpolar http 80</p> 
<p>开放端口进入</p> 
<p><img alt="" height="492" src="https://images2.imgbox.com/a9/c1/IUrM1BX2_o.png" width="898"></p> 
<p> 实际效果应该是这样</p> 
<p>只需要将对应的连接80端口的提供好的给你的域名，填入微信公众号验证就行，在加上token的验证代码，上一个文章也有，我粘贴部分</p> 
<pre><code class="language-python">def wechat():
    timestamp = request.args.get("timestamp")
    nonce = request.args.get("nonce")
    echostr = request.args.get("echostr")
    signature = request.args.get("signature")
    if request.method == "GET":
        if not all([signature, echostr, nonce, timestamp]):
            abort(404)
        li = [wechatToken, timestamp, nonce]
        li.sort()
        tmp_str = "".join(li)
        sign = hashlib.sha1(tmp_str.encode("utf-8")).hexdigest()
        if signature != sign:
                abort(403)
        else:
            return echostr</code></pre> 
<p>因为微信在给你发送验证请求的是get请求，所以分开执行后面的post发送也会比较方便</p> 
<h3>2.3 验证成功</h3> 
<p>  输入对应的网址和运行代码就可以验证成功</p> 
<p><img alt="" height="734" src="https://images2.imgbox.com/91/49/vHBMTtRC_o.png" width="1032"></p> 
<p> <img alt="" height="73" src="https://images2.imgbox.com/55/9f/S41Gi0J6_o.png" width="446"></p> 
<p> 对应的也会有这个显示，代表了验证成功，可以去对接微信接口进行开发</p> 
<h2>三， 运行ChatGLM</h2> 
<h3>3.1 公众号的选择</h3> 
<p>  因为当时在创建公众号的时候并没有过多的考虑，不经过微信认证的公众号所开的接口十分有限，在消息回复当中只有自动回复的接口可以使用。可以在接口权限中找到，我放一下我自己的公众号。</p> 
<p><img alt="" height="685" src="https://images2.imgbox.com/2d/7d/hZki9qOU_o.png" width="1200"></p> 
<h3> 3.2 实现聊天</h3> 
<p>github老哥的代码 ,完整代码在</p> 
<p><a href="https://github.com/pli2014/chatGLM-wechat" title="pli2014/chatGLM-wechat: 【技术篇】个人微信公众号对接chatGLM-6B (github.com)">pli2014/chatGLM-wechat: 【技术篇】个人微信公众号对接chatGLM-6B (github.com)</a></p> 
<p>我截取部分</p> 
<pre><code class="language-python">        xml = request.data
        if xml:
            try:
                msg = parse_message(xml)
                print("message from wechat msg:{}".format(msg))
                t1 = Thread(target=asyncTask, args=(msg.source, msg.content))
                t1.start()</code></pre> 
<p>这里是一个xml的一个解析，此刻一定要注意，<strong>老哥的代码使用的是明文模式，不能选择其他模式，否则就会出现找不到MsgType的情况，</strong>这个也弄了我好长时间，此处老哥的代码是一个线程运行，调用asyncTask的函数，后面的就是传进函数的参数，然后线程执行</p> 
<p><strong>问题1 老哥的代码使用权限问题</strong></p> 
<p>无论是这种</p> 
<pre><code class="language-python">tokenizer = AutoTokenizer.from_pretrained("model/chatglm-6b", trust_remote_code=True)
model = AutoModel.from_pretrained("model/chatglm-6b", trust_remote_code=True).float()


def asyncTask(userId, content):
    print("ask a quesion with userId:{}, content:{}".format(userId, content))
    response, history = model.chat(tokenizer, content, history=[])
    print("chat-GLB replay:{}".format(response))
    reply = create_reply('这是条文字消息', msg)
    return reply.render()
</code></pre> 
<p>还是这种</p> 
<pre><code class="language-python">tokenizer = AutoTokenizer.from_pretrained("THUDM/chatglm-6b-int4", trust_remote_code=True)
model = AutoModel.from_pretrained("THUDM/chatglm-6b-int4", trust_remote_code=True).float()


def asyncTask(userId, content):
    print("ask a quesion with userId:{}, content:{}".format(userId, content))
    response, history = model.chat(tokenizer, content, history=[])
    print("chat-GLB replay:{}".format(response))
    client.message.send_text(userId, response)</code></pre> 
<p>里面涉及到的消息转发的函数微信认证的公众号都不可以使用，所以我们需要利用xml的格式进行post转发</p> 
<pre><code class="language-python">        xml = request.data
        if xml:
            try:
                xml = ET.fromstring(request.data)
                fromUser = xml.find('FromUserName').text
                toUser = xml.find('ToUserName').text
                msgType = xml.find("MsgType").text
                createTime = xml.find("CreateTime")
                content = xml.find('Content').text
                xml_sta = '&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;%s&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt;&lt;/xml&gt;'
                GLM_Reply = reply(content)
                res = make_response(xml_sta % (fromUser, toUser, str(int(time.time())), GLM_Reply))
                res.content_type = 'application/xml'
                return res</code></pre> 
<p>这样就不会报，没有接口权限的错误了</p> 
<h4>3.3 问题</h4> 
<p></p> 
<p>  进行到这里，依旧出现了一个问题，当我向客户端发送你好的时候，GLM也作出了回答，但是传递公众号上却不显示，问题的点在于没有报错，所以也没弄明白原因，并且CPU和内存的占有率非常高，但是GPU性能却一点没用，也让我很困惑</p> 
<p><img alt="" height="280" src="https://images2.imgbox.com/a5/41/lv1J5ydM_o.png" width="1200"></p> 
<p><img alt="" height="99" src="https://images2.imgbox.com/f4/05/9F9kp2mr_o.png" width="420"></p> 
<p>这个CPU和内存访问超时的问题已经解决，核心就是在接口的调用错误，阿里云机器学习平台的现存是32G完全够用，然而老哥的代码时使用CPU本地部署，而且微信公众号也是微信认证的。</p> 
<p>应仿照官方文档调用模型</p> 
<p><img alt="" height="683" src="https://images2.imgbox.com/e4/c9/ASitQUka_o.png" width="1186"></p> 
<p></p> 
<p><strong>问题1 因为是否可能是这个响应的问题超过五秒了，服务器拒绝了</strong></p> 
<p><strong>这个问题已经有方法了，如果你们需要接入微信公众号，那么就必须要进行微信认证，获得24h的客服回复接口，才能避免生成结果超过5s的问题。</strong></p> 
<p><strong>问题2 在尝试调用ChatGLM的api也会有响应问题，通过建立流式api，但在服务器运行过程中卡住，这个问题也没有解决，运行卡住了</strong></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9ecd980b6d0ef7fe5a4e5f23eff0eb74/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C#中的委托和事件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a291faa5d046710fa1db4723427e8967/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">离线安装cdh6.3.1</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>