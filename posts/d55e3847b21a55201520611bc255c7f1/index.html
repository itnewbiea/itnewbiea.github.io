<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL 索引优化的 10 个策略 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySQL 索引优化的 10 个策略" />
<meta property="og:description" content="点击“终码一生”，关注，置顶公众号
每日技术干货，第一时间送达！
1、前言 索引策略是指创建使用索引所要遵循的规则，换句话说，违背了这些规则会导致索引失效或者查询效率降低。
策略1：尽量考虑覆盖索引
策略2：遵循最左前缀匹配
策略3：范围查询字段放最后
策略4：不对索引字段进行逻辑操作
策略5：尽量全值匹配
策略6：Like查询，左侧尽量不要加%
策略7：注意null/not null 可能对索引有影响
策略8：尽量减少使用不等于
策略9：字符类型务必加上引号
策略10：OR关键字左右尽量都为索引列
2、介绍 测试数据表：
show index from employees; 策略1：尽量考虑覆盖索引
覆盖索引：SQL只需要通过遍历索引树就可以返回所需要查询的数据，而不必通过辅助索引查到主键值之后再去查询数据（回表操作）。回表操作的详细介绍可以参考本人《MySQL慢查询优化》系列博文之索引。
EG：
EXPLAIN SELECT emp_no,birth_date,gender FROM employees WHERE gender =&#39;M&#39; ; Using index：表示已经使用了覆盖索引。
策略2：遵循最左前缀匹配
联合索引命中必须遵循“最左前缀法则”。即SQL查询Where条件字段必须从索引的最左前列开始匹配，不能跳过索引中的列。联合索引又称复合索引，类似于书籍的目录，多级的目录结构中子目录依赖于父级目录存在，也是遵循“最左前缀法则”。
联合索引结构分析，示例：
EXPLAIN SELECT * FROM employees WHERE birth_date = &#39;1963-06-01&#39; AND gender =&#39;F&#39;; 注：表存在多个索引时，即使Where条件满足最左前缀规则，SQL执行时也未必一定会命中联合索引，根据性能可能直接使用了主键索引。
EG：
EXPLAIN SELECT * FROM employees WHERE emp_no = 10010 AND birth_date = &#39;1963-06-01&#39; AND gender =&#39;F&#39;; PRIMARY KEY (`emp_no`)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d55e3847b21a55201520611bc255c7f1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-20T20:35:22+08:00" />
<meta property="article:modified_time" content="2022-01-20T20:35:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL 索引优化的 10 个策略</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;">点击“终码一生”，关注，置顶公众号</p> 
<p style="text-align:center;">每日技术干货，第一时间送达！</p> 
<p></p> 
<h3></h3> 
<h3>1、前言</h3> 
<p></p> 
<p>索引策略是指创建使用索引所要遵循的规则，换句话说，违背了这些规则会导致索引失效或者查询效率降低。</p> 
<p></p> 
<ul><li> <p>策略1：尽量考虑覆盖索引</p> </li><li> <p>策略2：遵循最左前缀匹配</p> </li><li> <p>策略3：范围查询字段放最后</p> </li><li> <p>策略4：不对索引字段进行逻辑操作</p> </li><li> <p>策略5：尽量全值匹配</p> </li><li> <p>策略6：Like查询，左侧尽量不要加%</p> </li><li> <p>策略7：注意null/not null 可能对索引有影响</p> </li><li> <p>策略8：尽量减少使用不等于</p> </li><li> <p>策略9：字符类型务必加上引号</p> </li><li> <p>策略10：OR关键字左右尽量都为索引列</p> </li></ul> 
<p></p> 
<p></p> 
<h3>2、介绍</h3> 
<p></p> 
<p>测试数据表：</p> 
<p></p> 
<pre><code>show index from employees;</code></pre> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6e/f9/AXjgPED5_o.png"></p> 
<p></p> 
<p><strong>策略1：尽量考虑覆盖索引</strong></p> 
<p></p> 
<p>覆盖索引：SQL只需要通过遍历索引树就可以返回所需要查询的数据，而不必通过辅助索引查到主键值之后再去查询数据（回表操作）。回表操作的详细介绍可以参考本人《MySQL慢查询优化》系列博文之索引。</p> 
<p></p> 
<p><strong>EG：</strong></p> 
<p></p> 
<pre><code>EXPLAIN SELECT emp_no,birth_date,gender FROM employees WHERE  gender ='M' ;</code></pre> 
<p></p> 
<p><img alt="" height="1" src="https://images2.imgbox.com/37/0f/qJQ9QVvJ_o.png" width="1"></p> 
<p></p> 
<p><strong> Using index：</strong>表示已经使用了覆盖索引。</p> 
<p></p> 
<p> <strong>策略2：遵循最左前缀匹配</strong></p> 
<p></p> 
<p>联合索引命中必须遵循“最左前缀法则”。即SQL查询Where条件字段必须从索引的最左前列开始匹配，不能跳过索引中的列。联合索引又称复合索引，类似于书籍的目录，多级的目录结构中子目录依赖于父级目录存在，也是遵循“最左前缀法则”。</p> 
<p></p> 
<p>联合索引结构分析，示例：</p> 
<p></p> 
<p><img alt="" height="1" src="https://images2.imgbox.com/ea/87/gekMHVPo_o.png" width="1"></p> 
<p></p> 
<pre><code>EXPLAIN SELECT * FROM employees WHERE  birth_date = '1963-06-01' AND gender ='F';</code></pre> 
<p></p> 
<p><img alt="" height="1" src="https://images2.imgbox.com/10/ce/jsuxnK0S_o.png" width="1"></p> 
<p></p> 
<p>注：表存在多个索引时，即使Where条件满足最左前缀规则，SQL执行时也未必一定会命中联合索引，根据性能可能直接使用了主键索引。</p> 
<p></p> 
<p><strong> EG：</strong></p> 
<p></p> 
<pre><code>EXPLAIN SELECT * FROM employees WHERE emp_no = 10010 AND  birth_date = '1963-06-01'  AND gender ='F';</code></pre> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/bb/21/UQfZfcgE_o.png"></p> 
<p></p> 
<p>PRIMARY KEY (`emp_no`)</p> 
<p></p> 
<p><strong>策略3：范围查询字段放最后</strong></p> 
<p></p> 
<p>联合索引定义时，尽量将范围查询字段放在最后（放在最后联合索引使用最充分，放在中间联合索引使用不充分）。使用联合索引时范围列（当前范围列索引生效）后面的索引列无法生效，同时索引最多用于一个范围列，如果查询条件中有多个范围列，也只能用到一个范围列索引。</p> 
<p></p> 
<p><strong>EG1：</strong></p> 
<p></p> 
<pre><code>EXPLAIN SELECT emp_no,birth_date,gender FROM employees WHERE  emp_no &gt; 10015  AND gender ='F';</code></pre> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b4/c0/xtmQrMFY_o.png"></p> 
<p></p> 
<p>只是使用到了主键索引PRIMARY(emp_no),联合索引未生效idx_empno_birthdate_gender(emp_no,birth_date,gender)；</p> 
<p></p> 
<p>删除idx_empno_birthdate_gender索引，新建联合索引idx_gender_birthdate_empno(gender,birth_date,emp_no)；</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/aa/99/0HljS103_o.png"></p> 
<p></p> 
<p><strong> EG2：</strong></p> 
<p></p> 
<pre><code>EXPLAIN SELECT emp_no,birth_date,gender FROM employees WHERE  emp_no &gt; 10015 AND birth_date = 1953-09-02 AND gender ='F';</code></pre> 
<p></p> 
<p><img alt="" height="1" src="https://images2.imgbox.com/04/dd/kJXQ1RYK_o.png" width="1"></p> 
<p></p> 
<p><strong>策略4：不对索引字段进行逻辑操作</strong></p> 
<p></p> 
<p>在索引字段上进行计算、函数、类型转换（自动\手动）都会导致索引失效。</p> 
<p></p> 
<p><strong>EG：</strong></p> 
<p></p> 
<pre><code>CREATE INDEX idx_first_name ON employees(first_name);
EXPLAIN SELECT * FROM employees WHERE LEFT(first_name,3) ='Geo';</code></pre> 
<p></p> 
<p><img alt="" height="1" src="https://images2.imgbox.com/f6/60/vC1VYC9r_o.png" width="1"></p> 
<p></p> 
<p><strong>策略5：尽量全值匹配</strong></p> 
<p></p> 
<p>全值匹配也就是精确匹配不使用like查询（模糊匹配），使用like会使查询效率降低。</p> 
<p></p> 
<p><strong>策略6：Like查询，左侧尽量不要加%</strong></p> 
<p></p> 
<p>like 以%开头，当前列索引无效(当为联合索引时，当前列和后续列索引不生效，可能导致索引使用不充分)；当like前缀没有%，后缀有%时，索引有效。</p> 
<p></p> 
<p><strong>EG1：</strong></p> 
<p></p> 
<pre><code>EXPLAIN SELECT * FROM employees WHERE first_name like'Geo%';</code></pre> 
<p></p> 
<p><img alt="" height="1" src="https://images2.imgbox.com/b5/97/GlpqwYFm_o.png" width="1"></p> 
<p></p> 
<p><strong>EG2：</strong></p> 
<p></p> 
<pre><code>EXPLAIN SELECT * FROM employees WHERE first_name like'%Geo%';</code></pre> 
<p> </p> 
<p><img alt="" height="1" src="https://images2.imgbox.com/69/b3/piIX2bKX_o.png" width="1"></p> 
<p></p> 
<p><strong>策略7：注意NULL/NOT NULL可能对索引有影响</strong></p> 
<p></p> 
<p>在索引列上使用 IS NULL 或 IS NOT NULL条件，可能对索引有所影响。</p> 
<p></p> 
<ul><li> <p>字段定义默认为NULL时，NULL索引生效，NOT NULL索引不生效；</p> </li><li> <p>字段定义明确为NOT NULL ，不允许为空时，NULL/NOT NULL索引列，索引均失效；</p> </li></ul> 
<p></p> 
<p>列字段尽量设置为NOT NULL，MySQL难以对使用NULL的列进行查询优化，允许Null会使索引值以及索引统计更加复杂。允许NULL值的列需要更多的存储空间，还需要MySQL内部进行特殊处理。</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b0/73/OBPAMVtN_o.png"></p> 
<p></p> 
<p><strong>EG1：</strong></p> 
<p></p> 
<pre><code>EXPLAIN SELECT * FROM employees WHERE first_name IS  NULL;</code></pre> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9b/e3/zSlh3Ryz_o.png"></p> 
<p></p> 
<p><strong>EG2：</strong></p> 
<p></p> 
<pre><code>EXPLAIN SELECT * FROM employees WHERE first_name IS NOT NULL;</code></pre> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/92/5e/wOPcfX4c_o.png"></p> 
<p></p> 
<p><strong>EG3：</strong></p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ec/31/lVff4sS0_o.png"></p> 
<p></p> 
<pre><code>EXPLAIN SELECT * FROM employees WHERE first_name IS NOT NULL;</code></pre> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/56/da/do8YiwNC_o.png"></p> 
<p></p> 
<p><strong>策略8：尽量减少使用不等于</strong></p> 
<p></p> 
<p>不等于操作符是不会使用索引的。不等于操作符包括：not，&lt;&gt;，!=。</p> 
<p></p> 
<p>优化方法：数值型 key&lt;&gt;0 改为 key&gt;0 or key&lt;0。</p> 
<p></p> 
<p><strong>EG：</strong></p> 
<p></p> 
<pre><code>EXPLAIN SELECT * FROM employees WHERE first_name != 'Georgi';</code></pre> 
<p></p> 
<p><img alt="" height="1" src="https://images2.imgbox.com/66/ba/PeQAFrcD_o.png" width="1"></p> 
<p></p> 
<p><strong>策略9：字符类型务必加上引号</strong></p> 
<p></p> 
<p>若varchar类型字段值不加单引号，可能会发生数据类型隐式转化，自动转换为int型，使索引无效。</p> 
<p></p> 
<p><strong>EG：</strong></p> 
<p></p> 
<pre><code>EXPLAIN SELECT * FROM employees WHERE first_name = 1;</code></pre> 
<p></p> 
<p><img alt="" height="1" src="https://images2.imgbox.com/cc/f6/rHHmt0gK_o.png" width="1"></p> 
<p></p> 
<p><strong>策略10：OR关键字前后尽量都为索引列</strong></p> 
<p></p> 
<p>当OR左右查询字段只有一个是索引，会使该索引失效，只有当OR左右查询字段均为索引列时，这些索引才会生效。OR改UNION效率高。</p> 
<p></p> 
<p><strong>EG1：</strong></p> 
<p></p> 
<pre><code>EXPLAIN SELECT * FROM employees WHERE first_name = 'Georgi' OR emp_no = 20001;</code></pre> 
<p></p> 
<p><img alt="" height="1" src="https://images2.imgbox.com/33/fe/yZxGsyXT_o.png" width="1"></p> 
<p></p> 
<p><strong>EG2：</strong></p> 
<p></p> 
<pre><code>EXPLAIN SELECT * FROM employees WHERE first_name = 'Georgi' OR last_name = 'Facello';</code></pre> 
<p></p> 
<p><img alt="" height="1" src="https://images2.imgbox.com/6c/fe/de9B1PGR_o.png" width="1"></p> 
<p></p> 
<p></p> 
<h3>3、后记</h3> 
<p></p> 
<ul><li> <p>索引的创建需要参照具体的SQL实现。</p> </li><li> <p>当全表扫描速度比索引速度快时，MySQL会使用全表扫描，此时索引失效。</p> </li><li> <p>表中存在多个索引时，即使where条件满足某个索引策略，MySQL查询优化器也不一定会使用该索引，可能使用其他索引，取决于性能。另外，当某个索引没有命中也不一定会走全表扫描，可能走其他索引。</p> </li><li> <p>理论上索引对顺序是敏感的，也就是说where子句的字段列表需要讲究顺序，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以匹配适合的索引，因此，允许我们不去刻意关注where子句的条件顺序</p> </li></ul> 
<p></p> 
<p></p> 
<p><strong>PS：防止找不到本篇文章，可以收藏点赞，方便翻阅查找哦</strong></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bdee2ffd23880d9d9425135f556023fb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">element ui el-icon 图标样式修改</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9f5f618e67de4a8e5a2dced7d0af875d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">laravel composer报错 Please provide a valid cache path.</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>