<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>范围搜索 (Range Query) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="范围搜索 (Range Query)" />
<meta property="og:description" content="范围搜索
Author: Subhash Suri
译者：Koala&#43;&#43; / 屈伟
引 前一阵把搜索引擎的RangeQuery的逻辑重新写了一遍，我写的时候就感觉很不对劲，我们的搜索引擎采用的是一种非常怪异的实现，至少我没在别的搜索引擎里见过，或是在资料中看到过。我要解决的是二维坐标查询，比如你想知道你周围五公里内的医院在什么地方，蛮力解决方法就是把所有医院坐标得到，把x坐标循环过滤一遍，再把y坐标循环过滤一遍。其实这还好，因为一个城市一共也没多少医院，但如果调用方把坐标查询写前面，也就是先过滤x和y坐标，再过滤医院，那就悲剧了。
简单点的办法就是把x和y坐标有序地保存，那用二分查找定位到x-2.5km, x&#43;2.5km, y-2.5km, y&#43;2.5km，然后取x-2.5km到x&#43;2.5km的posting list和y-2.5km到y&#43;2.5km的posting list做and操作就可以了。
但是还能不能再快呢？这个问题我想了想也没什么头绪，偶然发现了RTree这个数据结构，我感觉这才是正道。
下面是Range Searching的翻译。原文地址：http://www.cs.ucsb.edu/~suri/cs235/RangeSearching.pdf
Range Search 我们这里讨论Range Search是希望能找到一个好的数据结构，它能高效地对对象(点，矩形，多边形)的集合进行范围查询。
我们要做的是根据对象的类型和查询的类型，来寻找一个能在多种应用场景下使用的基本数据结构。
时间-空间的平衡：我们在预处理和存储上耗费地越多，那我们就可以更快地完成一次查询。
这里主要考虑使用(近似)线性空间的数据结构。
Orthogonal Range Search 对于一个有n个点的集合P。它有2n个子集。对于一个几何的查询，它会有多少个可能的结果呢？
效率能提高的原因是在查询结果中只会有子集中的一部分。
正交范围搜索只处理与坐标轴平行的矩形空间中的点集合。(译注，也就是不能用查询像圆形，五角形这样的范围)。
接下来，我们先讨论一维空间中的排序和搜索问题，然后将一维空间的数据结构推广到多维空间。
1-Dimensional Search 令一维空间的点集合为P={p1, p2, …,pn}。
查询是一个区间：
如果这个区间包含k个点，我们想在时间复杂度为O(log n &#43; k)的情况下解决这个问题。
Hashing可以做到吗？为什么不能？(译注：Hash的查询时间复杂度为O(1&#43;a),a是负载因子，hash在查询时只能依次查找，它的时间复杂度是O(n&#43;an))。
一个排序后的数组可以得到这个时间复杂度边界，但是它无法推广到多维空间。
我们采用一种替代方案，用一个二叉平衡树。
Tree Search 在一个排序后的点(key)数组上建立一个平衡二叉树。
叶子结点对应的是点，中间结点是分支结点。
给定一个区间[xl0,xhi]，在树上搜索xl0和xhi。
搜索得到的两个叶子结点中的叶子结点就是搜索的结果。
树搜索部分的时间复杂度是2log n，将叶子结点放入结果集的时间复杂度为O(k)，这里假设叶子结点是被链在一起的。
Canonical subsets S1, S1… Sk是Canonical子集，Si属于P。如果范围查询的结果可以写成几个Si的并集。(译注：canonical子集的解释http://en.wikipedia.org/wiki/Canonical，不必深究，就认为是子集就行了)。
Canonical子集有可能会重叠。
键(Key)是用来确定正确的Si，和高效地确定对于一个给定的查询，使用哪个Si。
在一维空间问题上，树中每一个结点都有一个Canonical子集：Sv是以v的根结点的子树的Canonical子集，它其中的元素是这个子树所有根结点中的点。
1D Range Query 给定查询[xl0,xhi]，查询树中满足u&gt;= xl0的最左叶子结点，和满足v&gt;= xhi的最左叶子结点。
所有在u和v之间的叶子结点都在所查询范围之内。
如果u= xl0或是v= xhi，那么u, v的canonical子集也包含在范围中。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/1a18888198cd4f44012d0d206bc35613/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-03-23T11:53:51+08:00" />
<meta property="article:modified_time" content="2017-03-23T11:53:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">范围搜索 (Range Query)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <div id="article_content" class="article_content"> 
 <p align="center"> 范围搜索<span lang="EN-US"></span></p> 
 <p align="center"> <span lang="EN-US">Author: Subhash Suri</span></p> 
 <p align="center"> 译者：<span lang="EN-US">Koala++ / </span>屈伟<span lang="EN-US"></span></p> 
 <h3 id="引"> 引</h3> 
 <p> <span lang="EN-US">       </span>前一阵把搜索引擎的<span lang="EN-US">RangeQuery</span>的逻辑重新写了一遍，我写的时候就感觉很不对劲，我们的搜索引擎采用的是一种非常怪异的实现，至少我没在别的搜索引擎里见过，或是在资料中看到过。我要解决的是二维坐标查询，比如你想知道你周围五公里内的医院在什么地方，蛮力解决方法就是把所有医院坐标得到，把<span lang="EN-US">x</span>坐标循环过滤一遍，再把<span lang="EN-US">y</span>坐标循环过滤一遍。其实这还好，因为一个城市一共也没多少医院，但如果调用方把坐标查询写前面，也就是先过滤<span lang="EN-US">x</span>和<span lang="EN-US">y</span>坐标，再过滤医院，那就悲剧了。</p> 
 <p> <span lang="EN-US">       </span>简单点的办法就是把<span lang="EN-US">x</span>和<span lang="EN-US">y</span>坐标有序地保存，那用二分查找定位到<span lang="EN-US">x-2.5km, x+2.5km, y-2.5km, y+2.5km</span>，然后取<span lang="EN-US">x-2.5km</span>到<span lang="EN-US">x+2.5km</span>的<span lang="EN-US">posting list</span>和<span lang="EN-US">y-2.5km</span>到<span lang="EN-US">y+2.5km</span>的<span lang="EN-US">posting list</span>做<span lang="EN-US">and</span>操作就可以了。</p> 
 <p> <span lang="EN-US">       </span>但是还能不能再快呢？这个问题我想了想也没什么头绪，偶然发现了<span lang="EN-US">RTree</span>这个<a href="http://lib.csdn.net/base/datastructure" rel="nofollow noopener noreferrer" class="replace_word" title="算法与数据结构知识库" target="_blank">数据结构</a>，我感觉这才是正道。</p> 
 <p> <span lang="EN-US">       </span>下面是<span lang="FR">Range Searching</span>的翻译。原文地址：<span lang="FR">http://www.cs.ucsb.edu/~suri/cs235/RangeSearching.pdf</span></p> 
 <h3 id="range-search"> <span lang="EN-US">Range Search</span></h3> 
 <p> 我们这里讨论<span lang="EN-US">Range Search</span>是希望能找到一个好的数据结构，它能高效地对对象<span lang="EN-US">(</span>点，矩形，多边形<span lang="EN-US">)</span>的集合进行范围查询。</p> 
 <p> <span lang="EN-US"> </span></p> 
 <div> 
  <img src="https://images2.imgbox.com/8e/88/hJQOsANs_o.jpg" alt=""> 
  <br> 
 </div> 
 <p>  </p> 
 <p> 我们要做的是根据对象的类型和查询的类型，来寻找一个能在多种应用场景下使用的基本数据结构。<span lang="EN-US"></span></p> 
 <p> 时间<span lang="EN-US">-</span>空间的平衡：我们在预处理和存储上耗费地越多，那我们就可以更快地完成一次查询。<span lang="EN-US"></span></p> 
 <p> 这里主要考虑使用<span lang="EN-US">(</span>近似<span lang="EN-US">)</span>线性空间的数据结构。<span lang="EN-US"></span></p> 
 <h3 id="orthogonal-range-search"> <span lang="EN-US">Orthogonal Range Search</span></h3> 
 <p> 对于一个有<span lang="EN-US">n</span>个点的集合<span lang="EN-US">P</span>。它有<span lang="EN-US">2<sup>n</sup></span>个子集。对于一个几何的查询，它会有多少个可能的结果呢？</p> 
 <p> <span lang="EN-US"> </span></p> 
 <div> 
  <img src="https://images2.imgbox.com/d0/85/PCLX3xd5_o.jpg" alt=""> 
  <br> 
 </div> 
 <p> 效率能提高的原因是在查询结果中只会有子集中的一部分。<span lang="EN-US"></span></p> 
 <p> 正交范围搜索只处理与坐标轴平行的矩形空间中的点集合。<span lang="EN-US">(</span>译注，也就是不能用查询像圆形，五角形这样的范围<span lang="EN-US">)</span>。<span lang="EN-US"></span></p> 
 <p> 接下来，我们先讨论一维空间中的排序和搜索问题，然后将一维空间的数据结构推广到多维空间。<span lang="EN-US"></span></p> 
 <h3 id="1-dimensional-search"> <span lang="EN-US">1-Dimensional Search</span></h3> 
 <p> <span lang="EN-US">    </span>令一维空间的点集合为<span lang="EN-US">P={p<sub>1</sub>, p<sub>2</sub>, …,p<sub>n</sub>}</span>。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>查询是一个区间：</p> 
 <p> <span lang="EN-US"> </span></p> 
 <div> 
  <img src="https://images2.imgbox.com/37/4a/Ig2zpsxL_o.jpg" alt=""> 
  <br> 
 </div> 
 <p>  </p> 
 <p> <span lang="EN-US">    </span>如果这个区间包含<span lang="EN-US">k</span>个点，我们想在时间复杂度为<span lang="EN-US">O(log n + k)</span>的情况下解决这个问题。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    Hashing</span>可以做到吗？为什么不能？<span lang="EN-US">(</span>译注：<span lang="EN-US">Hash</span>的查询时间复杂度为<span lang="EN-US">O(1+a),a</span>是负载因子，<span lang="EN-US">hash</span>在查询时只能依次查找，它的时间复杂度是<span lang="EN-US">O(n+an))</span>。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>一个排序后的数组可以得到这个时间复杂度边界，但是它无法推广到多维空间。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>我们采用一种替代方案，用一个二叉平衡树。<span lang="EN-US"></span></p> 
 <h3 id="tree-search"> <span lang="EN-US">Tree Search</span></h3> 
 <p> <span lang="EN-US">   </span></p> 
 <div> 
  <img src="https://images2.imgbox.com/72/a3/8k9M1z3M_o.jpg" alt=""> 
  <br> 
 </div> 
 <p> <span lang="EN-US">    </span>在一个排序后的点<span lang="EN-US">(key)</span>数组上建立一个平衡二叉树。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>叶子结点对应的是点，中间结点是分支结点。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>给定一个区间<span lang="EN-US">[x<sub>l0</sub>,x<sub>hi</sub>]</span>，在树上搜索<span lang="EN-US">x<sub>l0</sub></span>和<span lang="EN-US">x<sub>hi</sub></span>。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>搜索得到的两个叶子结点中的叶子结点就是搜索的结果。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>树搜索部分的时间复杂度是<span lang="EN-US">2log n</span>，将叶子结点放入结果集的时间复杂度为<span lang="EN-US">O(k)</span>，这里假设叶子结点是被链在一起的。<span lang="EN-US"></span></p> 
 <h3 id="canonical-subsets"> <span lang="EN-US">Canonical subsets</span></h3> 
 <p> <span lang="EN-US">    S<sub>1</sub>, S<sub>1</sub>… S<sub>k</sub></span>是<span lang="EN-US">Canonical</span>子集，<span lang="EN-US">S<sub>i</sub></span>属于<span lang="EN-US">P</span>。如果范围查询的结果可以写成几个<span lang="EN-US">S<sub>i</sub></span>的并集。<span lang="EN-US">(</span>译注：<span lang="EN-US">canonical</span>子集的解释<span lang="EN-US"><a rel="nofollow" href="http://en.wikipedia.org/wiki/Canonical">http://en.wikipedia.org/wiki/Canonical</a></span>，不必深究，就认为是子集就行了<span lang="EN-US">)</span>。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    Canonical</span>子集有可能会重叠。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>键<span lang="EN-US">(Key)</span>是用来确定正确的<span lang="EN-US">S<sub>i</sub></span>，和高效地确定对于一个给定的查询，使用哪个<span lang="EN-US">S<sub>i</sub></span>。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>在一维空间问题上，树中每一个结点都有一个<span lang="EN-US">Canonical</span>子集：<span lang="EN-US">S<sub>v</sub></span>是以<span lang="EN-US">v</span>的根结点的子树的<span lang="EN-US">Canonical</span>子集，它其中的元素是这个子树所有根结点中的点。</p> 
 <p> <span lang="EN-US"> </span></p> 
 <div> 
  <img src="https://images2.imgbox.com/44/34/w8IUvBli_o.jpg" alt=""> 
  <br> 
 </div> 
 <h3 id="1d-range-query"> <span lang="EN-US">1D Range Query</span></h3> 
 <p> <span lang="EN-US">   </span></p> 
 <div> 
  <img src="https://images2.imgbox.com/0e/74/YEeGLjYP_o.jpg" alt=""> 
  <br> 
 </div> 
 <p> <span lang="EN-US">    </span>给定查询<span lang="EN-US">[x<sub>l0</sub>,x<sub>hi</sub>]</span>，查询树中满足<span lang="EN-US">u&gt;= x<sub>l0</sub></span>的最左叶子结点，和满足<span lang="EN-US">v&gt;= x<sub>hi</sub></span>的最左叶子结点。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>所有在<span lang="EN-US">u</span>和<span lang="EN-US">v</span>之间的叶子结点都在所查询范围之内。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>如果<span lang="EN-US">u= x<sub>l0</sub></span>或是<span lang="EN-US">v= x<sub>hi</sub></span>，那么<span lang="EN-US">u, v</span>的<span lang="EN-US">canonical</span>子集也包含在范围中。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>将<span lang="EN-US">[u,v)</span>区间范围内的所有其它点由区间中的最大子树决定。<span lang="EN-US">(</span>译注：阴影中的子树<span lang="EN-US">)</span>。<span lang="EN-US"></span></p> 
 <h3 id="query-processing"> <span lang="EN-US">Query Processing</span></h3> 
 <p> <span lang="EN-US">    </span>令<span lang="EN-US">z</span>为从<span lang="EN-US">root</span>到<span lang="EN-US">u,v</span>搜索路径上的最后一个普通结点。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>先看从<span lang="EN-US">z</span>到<span lang="EN-US">u</span>的最左边路径，当路径向左时，将右子树的<span lang="EN-US">canonical</span>子集加入结果集。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>从<span lang="EN-US">z</span>到<span lang="EN-US">v</span>的右边路径中，当路径向右时，将左子树的<span lang="EN-US">canonical</span>子集加入结果集。</p> 
 <p> <span lang="EN-US"> </span></p> 
 <div> 
  <img src="https://images2.imgbox.com/f0/5e/u2TF4JHs_o.jpg" alt=""> 
  <br> 
 </div> 
 <h3 id="analysis"> <span lang="EN-US">Analysis</span></h3> 
 <p> <span lang="EN-US">   </span></p> 
 <div> 
  <img src="https://images2.imgbox.com/b2/15/R2UrjcxN_o.jpg" alt=""> 
  <br> 
 </div> 
 <p>  </p> 
 <p> <span lang="EN-US"></span>     因为搜索路径有<span lang="EN-US">O(log n)</span>个结点，故有<span lang="EN-US">O(log n)</span>个<span lang="EN-US">canonical</span>子集，所以可以在<span lang="EN-US">O(log n)</span>时间内找到。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>得到结果集合，可以在线性时间内遍历这些子树，时间复杂度为<span lang="EN-US">O(k)</span>。</p> 
  
  
 <p> <span lang="EN-US">    </span>如果只需要得到范围内点的数量，可以在每个结点中记录<span lang="EN-US">canonical</span>集合的元素个数。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>数据结构的空间复杂度为<span lang="EN-US">O(n)</span>，它查询一个范围的时间复杂度为<span lang="EN-US">O(log n)</span>。</p> 
 <p> <br> </p> 
 <p> </p> 
 <h3 id="multi-dimensional-data"> <span lang="EN-US">Multi-Dimensional Data</span></h3> 
 <p> </p> 
 <p> <span lang="EN-US">    </span>如何在高维空间中进行范围搜索？</p> 
 <p> <span lang="EN-US"> </span></p> 
 <div> 
  <img src="https://images2.imgbox.com/03/89/6O7JP2BL_o.jpg" alt=""> 
  <br> 
 </div> 
 <p> <span lang="EN-US">    kD-tree [Jon Bertley 1975]</span>。它是<span lang="EN-US">k-dimensional tree</span>的缩写。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>它适用于一般的任意维空间。渐近搜索复杂度不是很好。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>通过在<span lang="EN-US">x-y</span>坐标上分裂这种方式来推广一维的树。在<span lang="EN-US">k</span>维空间中，将会循环所有维坐标。<span lang="EN-US"></span></p> 
 <h3 id="kd-trees"> <span lang="EN-US">KD-Trees</span></h3> 
 <p> <span lang="EN-US">   </span></p> 
 <div> 
  <img src="https://images2.imgbox.com/73/3d/m4TRMiYu_o.jpg" alt=""> 
  <br> 
 </div> 
 <p> <span lang="EN-US">    </span>一个二叉树，每个结点有两个值，所分裂的维，和分裂的值。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>如果分裂在<span lang="EN-US">x</span>坐标的<span lang="EN-US">s</span>处，那么左子树的点都有<span lang="EN-US">x</span>坐标<span lang="EN-US">&lt;=s</span>，右子树的点都有<span lang="EN-US">x</span>坐标<span lang="EN-US">&gt;s</span>。对<span lang="EN-US">y</span>坐标也是一样。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>当只有<span lang="EN-US">O(1)</span>个点剩余时，将它们放到一个叶子结点。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>只有叶子结点中有点位置的信息，非叶子结点只用于分裂。<span lang="EN-US"></span></p> 
 <h3 id="splitting"> <span lang="EN-US">Splitting</span></h3> 
 <p> <span lang="EN-US">    </span>为得到一个平衡树，使用坐标中位数来分裂——中位数本身放到左子树或是右子树都可以。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>使用中位数分裂，可以保证树的高度为<span lang="EN-US">O(log n)</span>。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>分裂可以使用循环所有维的方式，或是根据数据做出选择，比如，可以选择数据分布最广的维。<span lang="EN-US"></span></p> 
 <h3 id="space-partitioning-view"> <span lang="EN-US">Space Partitioning View</span></h3> 
 <p> <span lang="EN-US">    kD-tree</span>是对空间的划分，每个结点都会引入对<span lang="EN-US">x</span>轴或是<span lang="EN-US">y</span>轴的划分。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>点被划分成两部分，这两部分分别是左子树和右子树。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>这些划分由矩形区域组成，称为单元<span lang="EN-US">(cell)(</span>可能是没有边界的<span lang="EN-US">)</span>。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>根对应的是整个空间，随后每个子结点都只继承一半的空间。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>叶子对应的是终止单元。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>它是二分空间<span lang="EN-US">(Binary space Partitioning)</span>的一种特殊情况。<span lang="EN-US"></span></p> 
 <h3 id="construction"> <span lang="EN-US">construction</span></h3> 
 <p> <span lang="EN-US">    </span>它可以以递归方式在<span lang="EN-US">O(n log n)</span>时间内建成。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>预先对<span lang="EN-US">x</span>坐标和<span lang="EN-US">y</span>坐标排序，并将两个排序数组交叉链接起来。<span lang="EN-US">(</span>译注，即将每个点的<span lang="EN-US">x,y</span>坐标链接起来<span lang="EN-US">)</span>。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>比如，可以通过扫描<span lang="EN-US">x</span>数组得到<span lang="EN-US">x</span>坐标的中位数，将数组分成两部分。再用交叉链接将<span lang="EN-US">y</span>数组在<span lang="EN-US">O(n)</span>时间复杂度内分成两部分。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>现在有两个子问题，每个都有<span lang="EN-US">n/2</span>的大小，并且它们都有自己的排序数据。递归。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>递归式为<span lang="EN-US">T(n)=2T(n/2) + n</span>，故它的时间复杂度为<span lang="EN-US">T(n) = O(n log n)</span>。<span lang="EN-US">(</span>译注，可以参考<a href="http://lib.csdn.net/base/datastructure" rel="nofollow noopener noreferrer" class="replace_word" title="算法与数据结构知识库" target="_blank">算法</a>导论<span lang="EN-US">4.3</span>节的主方法<span lang="EN-US">)</span>。<span lang="EN-US"></span></p> 
 <h3 id="searching-kd-trees"> <span lang="EN-US">Searching kD-Trees</span></h3> 
 <h3 id="title"> <img src="https://images2.imgbox.com/53/46/OPZaT7Yi_o.jpg" alt=""><br> </h3> 
 <p> <span lang="EN-US">    </span>设查询矩形为<span lang="EN-US">R</span>。从根结点开始查找。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>假设当前分裂的线是垂直的<span lang="EN-US">(</span>也可以是水平的<span lang="EN-US">)</span>。令<span lang="EN-US">v,w</span>分别是左子结点和右子结点。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>如果<span lang="EN-US">v</span>是一个叶子结点，返回<span lang="EN-US">cell(v)</span>交<span lang="EN-US">R</span>，如果<span lang="EN-US">cell(v)</span>属于<span lang="EN-US">R</span>，返回<span lang="EN-US">cell(v)</span>中所有点，如果<span lang="EN-US">cell(v)</span>交<span lang="EN-US">R</span>为空集，跳过。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>对<span lang="EN-US">w</span>进行相同的处理。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>查询过程明显是没有问题的。那么它的时间复杂度是什么呢？<span lang="EN-US"></span></p> 
 <h3 id="search-complexity"> <span lang="EN-US">Search complexity</span></h3> 
 <p> <span lang="EN-US">    </span>当<span lang="EN-US">cell(v)</span>属于<span lang="EN-US">R</span>，时间复杂度与<span lang="EN-US">cell(v)</span>的大小成线性关系。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>结点<span lang="EN-US">v</span>访问的结点个数满足由<span lang="EN-US">cell(v)</span>与<span lang="EN-US">R</span>交集边界的限定。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">   </span>如果<span lang="EN-US">cell(v)</span>在<span lang="EN-US">R</span>区域之外，我们就不用去查找它，如果<span lang="EN-US">cell(v)</span>在<span lang="EN-US">R</span>之内，我们就要枚举<span lang="EN-US">v</span>中的所有点。只有在<span lang="EN-US">cell(v)</span>与<span lang="EN-US">R</span>局部重叠时才会去递归调用。<span lang="EN-US">kD-Tree</span>的高度是<span lang="EN-US">O(log n)</span>。<span lang="EN-US"></span></p> 
 <p align="left"> <span lang="EN-US">    </span>令<span lang="EN-US">l</span>为穿过<span lang="EN-US">R</span>的一条直线。<span lang="EN-US"></span></p> 
 <p align="left"> <span lang="EN-US">    </span>有多少个单元会与这条线相交？<span lang="EN-US"></span></p> 
 <p align="left"> <span lang="EN-US">    </span>因为分裂的维是从两个维中选择一个，所以思考的关键在于每次将树的两层一起考虑。<span lang="EN-US"></span></p> 
 <p align="left"> <span lang="EN-US">    </span>假设第一次划分是垂直的，第二次是水平的，我们就有四个单元，每一个有<span lang="EN-US">n/4</span>个点。<span lang="EN-US"></span></p> 
 <p align="left"> <span lang="EN-US">    </span>一条直接只与两个单元相交。单元或是在<span lang="EN-US">R</span>区域之内或是<span lang="EN-US">R</span>区域之外。<span lang="EN-US"></span></p> 
 <p align="left"> <span lang="EN-US">    </span>递归式为：</p> 
 <p align="left"> <span lang="EN-US"> </span></p> 
 <div> 
  <img src="https://images2.imgbox.com/ad/88/HzJYV9md_o.jpg" alt=""> 
  <br> 
 </div> 
 <p align="left">  </p> 
 <p align="left"> <span lang="EN-US">    </span>从递归式可以得到时间复杂度为：<span lang="EN-US">Q(n)=O(n<sup>1/2</sup>)</span>。<span lang="EN-US"></span></p> 
 <p align="left"> <span lang="EN-US">    kD-Tree</span>是一个有<span lang="EN-US">O(n)</span>空间复杂度的数据结构，它可以在最坏时间<span lang="EN-US">O(n<sup>1/2</sup>+m)</span>内完成二维空间范围查找，其中<span lang="EN-US">m</span>是输出的大小。<span lang="EN-US"></span></p> 
 <h3 id="d-dim-search-complexity"> <span lang="EN-US">d-Dim Search Complexity</span></h3> 
 <p> 更高维的时间复杂度是什么呢？<span lang="EN-US"></span></p> 
 <p> 先尝试三维情况，再推广。<span lang="EN-US"></span></p> 
 <p> 递归式是：<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">Q(n)=2<sup>d-1</sup>Q(n/2<sup>d</sup>)+1</span></p> 
 <p> 从它推出时间复杂度：<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    Q(n)=O(n<sup>1-1/d</sup>)</span></p> 
 <p> <span lang="EN-US">    kD-Tree</span>是一个有<span lang="EN-US">(nd)</span>空间复杂度的数据结构，它在<span lang="EN-US">d</span>维空间中查找范围的最坏时间复杂度为<span lang="EN-US">O(n<sup>1-1/d</sup>+m)</span>，其中<span lang="EN-US">m</span>是输出的大小。</p> 
 <br> 
 <p> </p> 
 <h3 id="orthogonal-range-trees"> <span lang="EN-US">Orthogonal Range Trees</span></h3> 
 <p> </p> 
 <p> <span lang="EN-US">   </span></p> 
 <div> 
  <img src="https://images2.imgbox.com/33/3f/gCkZn3Cd_o.jpg" alt=""> 
  <br> 
 </div> 
 <p>  </p> 
 <p> <span lang="EN-US">    </span>将一维查找树推广到<span lang="EN-US">d</span>维空间。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>每次查找都会递归地分解到多个低维空间中去查找。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>查找时间复杂度为<span lang="EN-US">O((log n)<sup>d</sup>+k)</span>，其中<span lang="EN-US">k</span>是结果集大小。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>时间和空间复杂度是<span lang="EN-US">O(n(log n)<sup>d-1</sup>)</span>。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>分散层叠<span lang="EN-US">(fractional cascading)</span>从查找时间中消除了一个<span lang="EN-US">log n</span>因子。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>我们着眼于二维情况，但是它的思想是可以扩展到多维空间的。<span lang="EN-US"></span></p> 
 <h3 id="2d-range-tree"> <span lang="EN-US">2D Range Tree</span></h3> 
 <p> <span lang="EN-US">    </span>令二维空间中的一个点集合为<span lang="EN-US">P={p<sub>1</sub>, p<sub>2</sub>, …,p<sub>n</sub>}</span>。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>一个查询的一般形式为：<span lang="EN-US">R=[x<sub>lo</sub>,x<sub>hi</sub>]*[y<sub>lo</sub>,y<sub>hi</sub>]</span>。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>我们开始不考虑<span lang="EN-US">y</span>坐标，在<span lang="EN-US">P</span>上建立一个一维的<span lang="EN-US">x</span>区域树。</p> 
 <p> <span lang="EN-US"> </span></p> 
 <div> 
  <img src="https://images2.imgbox.com/c0/85/i7srbZ2I_o.jpg" alt=""> 
  <br> 
 </div> 
 <p> <span lang="EN-US">    </span>在<span lang="EN-US">[x<sub>lo</sub>,x<sub>hi</sub>]</span>区间的点集属于<span lang="EN-US">O(log n)</span>个<span lang="EN-US">canonical</span>集合。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>这是一个结果的超集。它明显比<span lang="EN-US">|R</span>交<span lang="EN-US">P|</span>要大，所以我们不能采用依次查看每个点在不在<span lang="EN-US">canonical</span>集合中这种耗时的方式。<span lang="EN-US"></span></p> 
 <h3 id="level-2-trees"> <span lang="EN-US">Level 2 Trees</span></h3> 
 <p> <span lang="EN-US">    </span>思想的核心是取得每个<span lang="EN-US">canonical</span>集合的点，并在它们上面建立<span lang="EN-US">y</span>区域树。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>比如，<span lang="EN-US">canonical</span>集合<span lang="EN-US">{9,12,14,15}</span>，用它的<span lang="EN-US">y</span>坐标建立了一个新的区域树。</p> 
 <p> <span lang="EN-US"> </span></p> 
 <div> 
  <img src="https://images2.imgbox.com/56/c2/YebqodCN_o.jpg" alt=""> 
  <br> 
 </div> 
 <p> <span lang="EN-US">    </span>我们查找每个<span lang="EN-US">O(log n) canonical</span>集合需要查找<span lang="EN-US">x</span>区域树中的<span lang="EN-US">[x<sub>lo</sub>,x<sub>hi</sub>]</span>范围和用它们的<span lang="EN-US">y</span>区域树查找<span lang="EN-US">[y<sub>lo</sub>,y<sub>hi</sub>]</span>范围。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    y</span>区域的查找中得到<span lang="EN-US">R</span>交<span lang="EN-US">P</span>这个结果集。<span lang="EN-US"></span></p> 
 <h3 id="canonical-sets"> <span lang="EN-US">Canonical Sets</span></h3> 
 <h3 id="title-1"> <img src="https://images2.imgbox.com/12/77/cpCb9lhQ_o.jpg" alt=""><br> </h3> 
 <h3 id="title-2"> <span lang="EN-US"></span></h3> 
 <h3 id="analysis-1"> <span lang="EN-US">analysis</span></h3> 
 <p> <span lang="EN-US">    </span>二维的查找时间复杂度为<span lang="EN-US">O((log n)<sup>2</sup>)</span>。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">1.    </span>查找<span lang="EN-US">O(log n)</span>个<span lang="EN-US">canonical</span>集合。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">2.    </span>每个集合进行<span lang="EN-US">y</span>范围查找需要<span lang="EN-US">O(log n)</span>时间复杂性。</p> 
 <p> <span lang="EN-US"> </span></p> 
 <div> 
  <img src="https://images2.imgbox.com/5e/1e/WdR88Ju9_o.jpg" alt=""> 
  <br> 
 </div> 
 <p> 空间复杂度为<span lang="EN-US">O(n log n)</span>。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">1.    </span><span lang="EN-US">x</span>区域树中<span lang="EN-US">cononical</span>集合的总大小是多少？<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">2.    </span>非叶子结点个数<span lang="EN-US">=</span>叶子结点个数。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">3.    </span>有一个大小为<span lang="EN-US">n</span>的集合，二个大小为<span lang="EN-US">n/2</span>的集合，以此类推。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">4.    </span>总共是<span lang="EN-US">O(n log n)</span>。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">5.    </span>每个大小为<span lang="EN-US">m</span>的<span lang="EN-US">canonical</span>集合需要<span lang="EN-US">O(m)</span>的空间来存储<span lang="EN-US">y</span>区域树。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">6.    </span>所以，总的空间复杂度是<span lang="EN-US">O(n log n)</span>。<span lang="EN-US"></span></p> 
 <h3 id="construction-1"> <span lang="EN-US">construction</span></h3> 
 <p> <span lang="EN-US">   </span></p> 
 <div> 
  <img src="https://images2.imgbox.com/85/8f/JIaUGGtR_o.jpg" alt=""> 
  <br> 
 </div> 
 <p> <span lang="EN-US">    x</span>区域树可以在<span lang="EN-US">O(n log n)</span>时间内建立。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>初看起来，因为<span lang="EN-US">y</span>树的总大小是<span lang="EN-US">O(n log n)</span>，所以它需要<span lang="EN-US">O(n(log n)<sup>2</sup>)</span>的时间来建立。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>但是通过自底向上建立它们，我们可以避免在每个结点上的排序时间。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>一旦子结点的<span lang="EN-US">y</span>区域树建立了，我们就可以将它们的<span lang="EN-US">y</span>数组在线性时间内合并。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>建立一维区域树在排序后的时间复杂度是线性的。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>所以，总的时间复杂度是<span lang="EN-US">O(n log n)</span>，是所有<span lang="EN-US">y</span>区域树的总大小。<span lang="EN-US"></span></p> 
 <h3 id="d-dim-range-trees"> <span lang="EN-US">d-Dim Range Trees</span></h3> 
 <p> <span lang="EN-US">    </span>多级区域树的思想可以很自然地扩展到任意<span lang="EN-US">d</span>维。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>在第一维上建立一个<span lang="EN-US">x</span>区域树。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>在树中每个结点<span lang="EN-US">v</span>上，在<span lang="EN-US">v</span>结点的<span lang="EN-US">cononical</span>集合上为剩余的<span lang="EN-US">(d-1)</span>维建立一个<span lang="EN-US">(d-1)</span>维的区域树。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>查找时间复杂度每一维增加<span lang="EN-US">log n</span>因子——每一维都会增加<span lang="EN-US">canonical</span>集合总大小<span lang="EN-US">log n</span>倍。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>所以查找时间为<span lang="EN-US">O((log n)<sup>d</sup>)</span>。<span lang="EN-US"></span></p> 
 <p> <span lang="EN-US">    </span>建树的空间和时间复杂度是<span lang="EN-US">O(n(log n)<sup>d-1</sup>)</span>。</p> 
 <br> 
 <p> </p> 
 <div class="bct fc05 fc11 nbw-blog ztag js-fs2"> 
  <h3 id="fractional-cascading"> <span lang="EN-US">Fractional Cascading</span></h3> 
  <p> <span lang="EN-US">    </span>有一种方法可以提高区域树的查找时间<span lang="EN-US">log n</span>。二维查找可以在<span lang="EN-US">O(log n)</span>时间内完成。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>基本思想：区域树首先找到在<span lang="EN-US">[x<sub>lo</sub>,x<sub>hi</sub>]</span>区间的点集，这些点集是由<span lang="EN-US">O(log n)</span>个<span lang="EN-US">canonical</span>集合组成的。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>接下来，每个<span lang="EN-US">canonical</span>集合用<span lang="EN-US">y</span>区域树查找<span lang="EN-US">[y<sub>lo</sub>,y<sub>hi</sub>]</span>。我们先找到<span lang="EN-US">y<sub>lo</sub></span>的位置，然后一直读到<span lang="EN-US">y<sub>hi</sub></span>边界。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>我们接下来要做的是，首先在<span lang="EN-US">O(log n)</span>时间内进行第一次查找，但是会利用查找的信息到另一种数据结构上更高效地查找。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>方法的关键是在<span lang="EN-US">canonical</span>集合上加上一些指针。<span lang="EN-US"></span></p> 
  <h3 id="basic-idea"> <span lang="EN-US">Basic Idea</span></h3> 
  <p> <span lang="EN-US">    </span>我们通过一个简单的例子来了解这种方法的基本思想。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>假设我们有两个数组，<span lang="EN-US">A<sub>1</sub></span>和<span lang="EN-US">A<sub>2</sub></span>，它们都是无序的。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>给定一个范围<span lang="EN-US">[x,x’]</span>，我们想得到<span lang="EN-US">A<sub>1</sub></span>和<span lang="EN-US">A<sub>2</sub></span>中所有在这个范围中的元素。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>一个直观的做法是用两分查找找到<span lang="EN-US">A<sub>1</sub></span>和<span lang="EN-US">A<sub>2</sub></span>中<span lang="EN-US">k</span>的位置，它的时间复杂度是<span lang="EN-US">O(2log n + k)</span>。<span lang="EN-US"></span></p> 
  <h3 id="fractional-cascading-idea"> <span lang="EN-US">Fractional Cascading Idea</span></h3> 
  <p> <span lang="EN-US">    </span>假设有<span lang="EN-US">A<sub>2</sub></span>属于<span lang="EN-US">A<sub>1</sub></span>，添加一些从<span lang="EN-US">A<sub>1</sub></span>指向<span lang="EN-US">A<sub>2</sub></span>的指针。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>如果<span lang="EN-US">A<sub>1</sub>[i]=y<sub>i</sub></span>，将一个指针指向<span lang="EN-US">A<sub>2</sub></span>中大于<span lang="EN-US">y<sub>i</sub></span>的最小元素。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>假设我们想得到范围<span lang="EN-US">[y,y’]</span>中的元素。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>在<span lang="EN-US">A<sub>1</sub></span>中查找<span lang="EN-US">y</span>，然后一直遍历到<span lang="EN-US">y’</span>，时间复杂度为<span lang="EN-US">O(log n + k<sub>1</sub>)</span>。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>如果<span lang="EN-US">A<sub>1</sub></span>在<span lang="EN-US">A<sub>1</sub>[i]</span>位置找到<span lang="EN-US">y</span>，可以使用它的指针开始在<span lang="EN-US">A<sub>2</sub></span>中的查找。这一步的时候复杂度为<span lang="EN-US">O(1 + k<sub>2</sub>)</span>。</p> 
  <p> <span lang="EN-US"> </span></p> 
  <div> 
   <img src="https://images2.imgbox.com/4e/99/KQlPCiQc_o.jpg" alt=""> 
   <br> 
  </div> 
  <p>  </p> 
  <p> <span lang="EN-US">    </span>例子所示为查找<span lang="EN-US">[20,65]</span>。<span lang="EN-US"></span></p> 
  <h3 id="fc-in-range-trees"> <span lang="EN-US">FC in Range Trees</span></h3> 
  <p> <span lang="EN-US">    </span>元素的特点：<span lang="EN-US">S(l(v))</span>和<span lang="EN-US">S(r(v))</span>的<span lang="EN-US">canonical</span>集合是<span lang="EN-US">S(v)</span>的<span lang="EN-US">canonical</span>集合的子集。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    X</span>区域树还是和以前一样。但在这里不建立<span lang="EN-US">y</span>区域树，而是根据<span lang="EN-US">y</span>坐标将它们保存到排序数组里。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>在<span lang="EN-US">A(v)</span>中的每个<span lang="EN-US">entry</span>保存两个指针，指向<span lang="EN-US">A(l(v))</span>和<span lang="EN-US">A(r(v))</span>数组。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>如果<span lang="EN-US">A(v)[i]</span>保存着点<span lang="EN-US">p</span>，那么指针指向<span lang="EN-US">A(l(v))</span>中最小大于的<span lang="EN-US">y</span>坐标元素<span lang="EN-US">(y(p))</span>。对<span lang="EN-US">r(v)</span>也是一样。<span lang="EN-US"></span></p> 
  <h3 id="range-tree-fc"> <span lang="EN-US">Range Tree FC</span></h3> 
  <p> <span lang="EN-US">    </span>下图中给出了一部分指针的示例。</p> 
  <p> <span lang="EN-US"> </span></p> 
  <div> 
   <img src="https://images2.imgbox.com/f9/27/Bhyro5nt_o.jpg" alt=""> 
   <br> 
  </div> 
  <p>  </p> 
  <div> 
   <img src="https://images2.imgbox.com/e3/34/itTtFSHM_o.jpg" alt=""> 
   <br> 
  </div> 
  <p>  </p> 
  <h3 id="fc-search"> <span lang="EN-US">FC Search</span></h3> 
  <h3 id="title-3"> <img src="https://images2.imgbox.com/87/a1/vs8lx78U_o.jpg" alt=""><br> </h3> 
  <p> <span lang="EN-US">    </span>考虑一个区域<span lang="EN-US">R=[x,x’]*[y,y’]</span>。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>在<span lang="EN-US">x</span>区域树中查找<span lang="EN-US">x, x’</span>。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>令<span lang="EN-US">v<sub>split</sub></span>为两条查找路径开分开的结点。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    O(log n)</span>个<span lang="EN-US">canonical</span>子集对应<span lang="EN-US">v<sub>split</sub></span>下的子结点，它们是在查找<span lang="EN-US">x(x’)</span>路径向左<span lang="EN-US">(</span>右<span lang="EN-US">)</span>时的右<span lang="EN-US">(</span>左<span lang="EN-US">)</span>子结点。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>在<span lang="EN-US">v<sub>split</sub></span>结点，在<span lang="EN-US">A(v<sub>split</sub>)</span>中二分查找<span lang="EN-US">y</span>，时间复杂度为<span lang="EN-US">O(log n)</span>。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>用我们<span lang="EN-US">x</span>区域树查找<span lang="EN-US">x,x’</span>的方式向下查找。从<span lang="EN-US">entries</span>的指向得到指向子结点中<span lang="EN-US">&gt;=y</span>的位置，这个操作的时间复杂度为<span lang="EN-US">O(1)</span>。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>令<span lang="EN-US">A(v)</span>是<span lang="EN-US">O(log n)</span>个<span lang="EN-US">canonical</span>结点的一个，现在要在<span lang="EN-US">A(v)</span>中查找<span lang="EN-US">[y,y’]</span>区域内的元素。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>我们只需要找到<span lang="EN-US">A(v)&gt;=y</span>的最小<span lang="EN-US">entry</span>。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>我们可以在<span lang="EN-US">O(1)</span>时间复杂度内找到是因为<span lang="EN-US">parent(v)</span>在查找路径上，并且我们通过<span lang="EN-US">v</span>数组中的指针，知道最小<span lang="EN-US">&gt;=y</span>的<span lang="EN-US">entry</span>在<span lang="EN-US">A(parent(v))</span>中的位置，<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>所以我们可以将在<span lang="EN-US">A(v)</span>中在<span lang="EN-US">[y,y’]</span>中的所有点在<span lang="EN-US">O(1 + k<sub>v</sub>)</span>时间复杂度内输出，其中<span lang="EN-US">k<sub>v</sub></span>是结果集大小。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    </span>对二维范围搜索，最终的时间复杂度为<span lang="EN-US">O(log n + k)</span>，空间复杂度为<span lang="EN-US">O(n log n)</span>。<span lang="EN-US"></span></p> 
  <p> <span lang="EN-US">    d</span>维范围搜索使用分散层叠的时间复杂度为<span lang="EN-US">O((log n)<sup>d-1</sup>)</span>。<span lang="EN-US"></span></p> 
  <p></p> 
 </div> 
 <div> 
 </div> 
 <div> 
 </div> 
 <div> 
  <div class="wumii-hook"></div> 
 </div> 
 <div class="ptc ztag"> 
  <span class="ptcp"></span> 
 </div> 
 <div class="nbw-act tbar fc03 clearfix"> 
 </div> 
 <p></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fc9c2d4730c89af7f8d829a53fac731e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">混合式APP开发问题记录</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/24d14ab22e62ea201d54c23b623c196b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">后缀自动机详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>