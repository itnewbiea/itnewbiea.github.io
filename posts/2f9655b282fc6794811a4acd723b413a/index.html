<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>opencascade基础 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="opencascade基础" />
<meta property="og:description" content="返回主页
大师之路
千淘万漉虽辛苦，吹尽狂沙始到金。
博客园 首页 新随笔 联系 管理 订阅订阅 随笔- 139 文章- 0 评论- 6
OpenCASCADE 基础
OpenCASCADE 基础
转载▼
一直在用OCC作项目，但这方面的中文资料很少，看来OCC在中国还不是十分普及；
后来，项目中使用OCC和DirectX结合使用，取得了很好的效果；
随着OCC6.3版本的推出，Open CASCADE在速度方面已有了很大的改变。以下为一些OCC的基础知识，愿与各位OCC爱好者共同学习；
一：OCC中的基础类：
gp_Pnt
在OCC中，gp_Pnt表示一个顶点，gp_Vec表示一个向量，可以用两个顶点来生成一个向量。
比如：
gp_Pnt P1(0,0,0);
gp_Pnt P2(5,0,0);
gp_Vec V1 (P1,P2);
向量有一个方法.IsOpposite（），可以用来测试两个向量的方向是相对还是平行;
比如：
gp_Pnt P3(-5,0,2);
gp_Vec V2 (P1,P3);
Standard_Boolean result =V1.IsOpposite(V2,Precision::Angular());
另外向量还有一些重要方法：
–Standard_Real Magnitude() const;计算向量的大小；
–Standard_Real SquareMagnitude() const;计算向量的平方；
–向量的加减乘除操作；
–向量的单位化；
–通过一个点，线，面得出其镜像的向量；
–向量的旋转，平移，缩放；
具体的函数名称可以看OCC的头文件说明；
有时需要决定一组空间点是位于一个点;一条直线,或一个平面,或一个空间:
OCC中提供了相应的算法；
比如：
TColgp_Array1OfPnt array (1,5); // sizing array
array.SetValue(1,gp_Pnt(0,0,1));
array.SetValue(2,gp_Pnt(1,2,2));
array.SetValue(3,gp_Pnt(2,3,3));" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2f9655b282fc6794811a4acd723b413a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-25T16:28:41+08:00" />
<meta property="article:modified_time" content="2020-08-25T16:28:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">opencascade基础</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>返回主页<br> 大师之路<br> 千淘万漉虽辛苦，吹尽狂沙始到金。<br> 博客园 首页 新随笔 联系 管理 订阅订阅 随笔- 139 文章- 0 评论- 6<br> OpenCASCADE 基础<br> OpenCASCADE 基础<br> 转载▼</p> 
<p>一直在用OCC作项目，但这方面的中文资料很少，看来OCC在中国还不是十分普及；</p> 
<p>后来，项目中使用OCC和DirectX结合使用，取得了很好的效果；</p> 
<p>随着OCC6.3版本的推出，Open CASCADE在速度方面已有了很大的改变。以下为一些OCC的基础知识，愿与各位OCC爱好者共同学习；</p> 
<p>一：OCC中的基础类：</p> 
<p>gp_Pnt</p> 
<p>在OCC中，gp_Pnt表示一个顶点，gp_Vec表示一个向量，可以用两个顶点来生成一个向量。</p> 
<p>比如：</p> 
<p>gp_Pnt P1(0,0,0);</p> 
<p>gp_Pnt P2(5,0,0);</p> 
<p>gp_Vec V1 (P1,P2);</p> 
<p>向量有一个方法.IsOpposite（），可以用来测试两个向量的方向是相对还是平行;</p> 
<p>比如：</p> 
<p>gp_Pnt P3(-5,0,2);</p> 
<p>gp_Vec V2 (P1,P3);</p> 
<p>Standard_Boolean result =V1.IsOpposite(V2,Precision::Angular());</p> 
<p>另外向量还有一些重要方法：</p> 
<p>–Standard_Real Magnitude() const;计算向量的大小；</p> 
<p>–Standard_Real SquareMagnitude() const;计算向量的平方；</p> 
<p>–向量的加减乘除操作；</p> 
<p>–向量的单位化；</p> 
<p>–通过一个点，线，面得出其镜像的向量；</p> 
<p>–向量的旋转，平移，缩放；</p> 
<p>具体的函数名称可以看OCC的头文件说明；</p> 
<p>有时需要决定一组空间点是位于一个点;一条直线,或一个平面,或一个空间:</p> 
<p>OCC中提供了相应的算法；</p> 
<p>比如：</p> 
<p>TColgp_Array1OfPnt array (1,5); // sizing array</p> 
<p>array.SetValue(1,gp_Pnt(0,0,1));</p> 
<p>array.SetValue(2,gp_Pnt(1,2,2));</p> 
<p>array.SetValue(3,gp_Pnt(2,3,3));</p> 
<p>array.SetValue(4,gp_Pnt(4,4,4));</p> 
<p>array.SetValue(5,gp_Pnt(5,5,5));</p> 
<p>GProp_PEquation PE (array,1.5 );</p> 
<p>if (PE.IsPoint()){ } //是否是同一个点</p> 
<p>gp_Lin L;</p> 
<p>if (PE.IsLinear()) { L = PE.Line(); } //是否位于一条直线上；</p> 
<p>if (PE.IsPlanar()){ } //是否在一个平面内；</p> 
<p>if (PE.IsSpace()) { }</p> 
<p>gp_Dir类：</p> 
<p>此类用来描述3D空间中的一个单位向量;</p> 
<p>常用方法:</p> 
<p>(1):IsEqual(const gp_Dir&amp; Other,const Standard_Real AngularTolerance) const;两个单位向量是否相等;</p> 
<p>(2):IsNormal(const gp_Dir&amp; Other,const Standard_Real AngularTolerance) const;两个单位向量的夹角是否是PI/2;</p> 
<p>(3):IsOpposite(const gp_Dir&amp; Other,const Standard_Real AngularTolerance) const;两个单位向量是否方向相反;</p> 
<p>(4):IsParallel(const gp_Dir&amp; Other,const Standard_Real AngularTolerance) const;两个单位向量夹角O或PI;</p> 
<p>(5):Angle(const gp_Dir&amp; Other) const;求两个向量之间的夹角;</p> 
<p>(6):void CrossCross(const gp_Dir&amp; V1,const gp_Dir&amp; V2) ;计算三个向量之间的叉积；</p> 
<p>(7)：Standard_Real Dot(const gp_Dir&amp; Other) const;计算点积；</p> 
<p>(8)：Standard_Real DotCross(const gp_Dir&amp; V1,const gp_Dir&amp; V2) const;计算叉积再点积；</p> 
<p>(9):gp_Dir Reversed() const;得到反方向，</p> 
<p>在OCC中用 gp_Lin2d 类，来生成一个二维空间的直线，有它的原点和单位向量；</p> 
<p>gp_Ax2d类：</p> 
<p>通过原点和X方向单位和Y方向单位建立一个二维坐标系；利用sense参数可以决定是右手系还是左手系；</p> 
<p>可以利用平移、旋转、缩放、镜像来更改坐标系；</p> 
<p>类似地，gp_Ax3类：</p> 
<p>用来描述一个3D空间的坐标系。而gp_Ax2类用来表示一个二维空间坐标系；可以为右手系，也可以是左手系；</p> 
<p>二、曲线类</p> 
<p>GeomAPI和GeomConvert包：</p> 
<p>GeomAPI开发包提供了一个几何体的可编程应用程序接口；</p> 
<p>比如：</p> 
<p>求点P和曲线C的距离D：</p> 
<p>D = GeomAPI_ProjectPointOnCurve(P,C);</p> 
<p>或者</p> 
<p>GeomAPI_ProjectPointOnCurve PonC(P,C);</p> 
<p>D = PonC.LowerDistance();</p> 
<p>GeomConvert包提供了一些全局函数，可以用来实现转化一个Geom曲线为BSpline曲线等；</p> 
<p>比如：</p> 
<p>Handle(Geom_BSplineSurface) aPipeSurface =</p> 
<p>Handle(Geom_BSplineSurface)::DownCast(aPipe.Surface());</p> 
<p>Handle(Geom_BSplineSurface) anotherBSplineSurface =</p> 
<p>GeomConvert::SplitBSplineSurface(aPipeSurface,1,2,3,6);</p> 
<p>OCC中三维几何曲线的类型有：</p> 
<p>–线</p> 
<p>–园</p> 
<p>–椭圆</p> 
<p>–二次曲线</p> 
<p>–抛物线</p> 
<p>–Bezier曲线</p> 
<p>–BSpline曲线</p> 
<p>可以将一个二维的几何曲线转化为某个平面内的一个三维曲线：</p> 
<p>比如：</p> 
<p>Standard_Real radius = 5;</p> 
<p>gp_Ax2d ax2d(gp_Pnt2d(2,3),gp_Dir2d(1,0));</p> 
<p>//生成一个二维园</p> 
<p>Handle(Geom2d_Circle) circ2d = new Geom2d_Circle(ax2d,radius);</p> 
<p>gp_Ax2d circ2dXAxis = circ2d-&gt;XAxis();</p> 
<p>// 然后，在这个平面里转化为三维曲线；</p> 
<p>Handle(Geom_Curve) C3D = GeomAPI::To3d(circ2d,gp_Pln(gp_Ax3(gp::XOY())));</p> 
<p>Handle(Geom_Circle) C3DCircle = Handle(Geom_Circle)::DownCast(C3D);</p> 
<p>gp_Ax1 C3DCircleXAxis = C3DCircle-&gt;XAxis();</p> 
<p>另外，可以以将一个三维曲线，投影到一个平面内，从而生成一个二维曲线</p> 
<p>gp_Pln ProjectionPlane(gp_Pnt(1,1,0),gp_Dir( 1,1,1 ));</p> 
<p>Handle(Geom2d_Curve) C2D = GeomAPI::To2d(C3D,ProjectionPlane);</p> 
<p>Handle(Geom2d_Circle) C2DCircle =Handle(Geom2d_Circle)::DownCast(C2D);</p> 
<p>gp_Ax2d C2DCircleXAxis = C2DCircle-&gt;XAxis();</p> 
<p>将一个基本几何图形进行空间变换可以使用它自带的函数:</p> 
<p>比如：</p> 
<p>Handle(Geom_Geometry) aRotatedEntity = circle-&gt;Rotated(gp::OZ(),PI/4);</p> 
<p>如果想获取图形的类型名称:</p> 
<p>Standard_CString aRotatedEntityTypeName = aRotatedEntity-&gt;DynamicType()-&gt;Name();</p> 
<p>gp_Parab2d类：</p> 
<p>描述一个平面内的抛物线；</p> 
<p>示例：</p> 
<p>gp_Pnt2d P(2,3);</p> 
<p>gp_Dir2d D(4,5);</p> 
<p>gp_Ax22d A(P,D);</p> 
<p>gp_Parab2d Para(A,6);</p> 
<p>GCE2d_MakeParabola类：</p> 
<p>生成一个抛物线图形；</p> 
<p>Geom2d_BSplineCurve类：</p> 
<p>描述样条曲线；</p> 
<p>Geom2dAPI_Interpolate类：</p> 
<p>通过一组点来修改一个样条曲线；</p> 
<p>FairCurve_Batten类：</p> 
<p>用一个常量或线性增加的值来构造曲线；可以用来设计木纹或塑料板条；图形为二维的，可以模拟物理样条或板条.</p> 
<p>Geom2d_TrimmedCurve类：</p> 
<p>此类通过两个值，定义曲线的一部分，</p> 
<p>–可以用来计算曲线的参数值和点坐标；</p> 
<p>–可以得到曲线的一般特征，比如连续的等级，封闭特点，周期性，边界参数；</p> 
<p>–当用一个矩阵应用于曲线或原始曲线转化后进行相应参数的改变；</p> 
<p>所有的曲线必须几何连续，曲线至少一阶可导。一般来说，在生成一个曲线时，要先检查一下所应用的参数是否可以生成一个光滑曲线；否则会出现错误；</p> 
<p>另外注意一点：不可以构造空长度的曲线或自相交的曲线；</p> 
<p>此类的基类是Geom2d_BoundedCurve类：</p> 
<p>它是一个抽象类；描述二维空间中的边界曲线的一般行为；除了Geom2d_TrimmedCurve是它的一个派生类外，它还有二个派生类：</p> 
<ul><li> <p>Geom2d_BezierCurve</p> </li><li> <p>Geom2d_BSplineCurve</p> </li></ul> 
<p>Geom2d_BoundedCurve类的基类是Geom2d_Curve类：</p> 
<p>Geom2d_Curve:抽象类；此抽象类描述了2D空间的曲线的一般特征；派生出的类有多个：包括直线，园，二次曲线，Bizier,BSpline曲线等；这些曲线的特点是可以参数化；</p> 
<p>Geom2d_Curve类的基类是Geom2d_Geometry类；</p> 
<p>此抽象类主要定义了曲线的变换，平移，旋转，缩放及拷贝等方法；</p> 
<p>Geom2d_Geometry类的基类是MMgt_TShared类；</p> 
<p>此抽象类为管理对象的基类，可以引用计数，及删除方法；</p> 
<p>Standard_Transient：此抽象类为所有类共同的基类；</p> 
<p>Geom2dAPI_InterCurveCurve类：</p> 
<p>此类用来实现二维曲线的相交；</p> 
<p>一种情况是曲线与曲线的相交，另外一种情况是曲线自身的相交；</p> 
<p>主要方法有：</p> 
<p>–Standard_Integer NbPoints() const;相交点数；</p> 
<p>–Standard_Integer NbSegments() const;切线相交数；</p> 
<p>–void Segment(const Standard_Integer Index,Handle(Geom2d_Curve)&amp; Curve1,Handle(Geom2d_Curve)&amp; Curve2)</p> 
<p>const;返回其中一个线段；</p> 
<p>下面的示例是两个曲线相交的例子：</p> 
<p>首先，生成第一个曲线，在这里，应用点数组来生成一个曲线；</p> 
<p>–定义数组</p> 
<p>Handle(TColgp_HArray1OfPnt2d) harray = new TColgp_HArray1OfPnt2d (1,5); // sizing harray</p> 
<p>–输入点数组的值</p> 
<p>harray-&gt;SetValue(1,gp_Pnt2d (0,0));</p> 
<p>harray-&gt;SetValue(2,gp_Pnt2d (-3,1));</p> 
<p>harray-&gt;SetValue(3,gp_Pnt2d (-2,5));</p> 
<p>harray-&gt;SetValue(4,gp_Pnt2d (2,9));</p> 
<p>harray-&gt;SetValue(5,gp_Pnt2d (-4,14));</p> 
<p>–检测一下点与点之间是否为同一点；0.01为公差值，依实际需要可以更改此参数；</p> 
<p>Geom2dAPI_Interpolate anInterpolation(harray,Standard_False,0.01);</p> 
<p>–生成曲线</p> 
<p>anInterpolation.Perform();</p> 
<p>Handle(Geom2d_BSplineCurve) SPL = anInterpolation.Curve();</p> 
<p>–第二个曲线用两点来生成</p> 
<p>gp_Pnt2d P1(-1,-2);gp_Pnt2d P2(0,15);gp_Dir2d V1 = gp::DY2d();</p> 
<p>Handle(Geom2d_TrimmedCurve) TC1= GCE2d_MakeSegment(P1,V1,P2);</p> 
<p>–下面进行曲线的求交</p> 
<p>Standard_Real tolerance = Precision::Confusion();</p> 
<p>Geom2dAPI_InterCurveCurve ICC (SPL,TC1,tolerance);</p> 
<p>–得到交点</p> 
<p>Standard_Integer NbPoints =ICC.NbPoints();</p> 
<p>gp_Pnt2d PK;</p> 
<p>for (Standard_Integer k = 1;k&lt;=NbPoints;k++)</p> 
<p>{<!-- --></p> 
<p>PK = ICC.Point(k);</p> 
<p>// 针对每个交点，进行相应处理；</p> 
<p>}</p> 
<p>Geom2d_OffsetCurve类:</p> 
<p>此类用来实现偏移曲线；</p> 
<p>比如：</p> 
<p>–生成一个曲线</p> 
<p>TColgp_Array1OfPnt2d array (1,5); // sizing array</p> 
<p>array.SetValue(1,gp_Pnt2d (-4,0)); array.SetValue(2,gp_Pnt2d (-7,2));</p> 
<p>array.SetValue(3,gp_Pnt2d (-6,3)); array.SetValue(4,gp_Pnt2d (-4,3));</p> 
<p>array.SetValue(5,gp_Pnt2d (-3,5));</p> 
<p>Handle(Geom2d_BSplineCurve) SPL1 = Geom2dAPI_PointsToBSpline(array);</p> 
<p>–生成一个偏移曲线</p> 
<p>Standard_Real dist = 1;</p> 
<p>Handle(Geom2d_OffsetCurve) OC =</p> 
<p>new Geom2d_OffsetCurve(SPL1,dist);</p> 
<p>Standard_Boolean result = OC-&gt;IsCN(2);</p> 
<p>GccAna_Pnt2dBisec类</p> 
<p>此类实现两点之间的等分线.</p> 
<p>示例:</p> 
<p>gp_Pnt2d P1(1,2);</p> 
<p>gp_Pnt2d P2(4,5);</p> 
<p>gp_Lin2d L;</p> 
<p>GccAna_Pnt2dBisec B(P1,P2);</p> 
<p>if (B.IsDone())</p> 
<p>{ L = B.ThisSolution(); }</p> 
<p>因为所生成的为直线,所以显示时要转化为线段:</p> 
<p>if (B.IsDone())</p> 
<p>{<!-- --></p> 
<p>Handle(Geom2d_TrimmedCurve) aLine = GCE2d_MakeSegment(L,-8,8);</p> 
<p>Handle(ISession2D_Curve) aCurve = new ISession2D_Curve(aLine);</p> 
<p>aDoc-&gt;GetISessionContext()-&gt;Display(aCurve, Standard_False);</p> 
<p>}</p> 
<p>gce_MakeCirc2d类</p> 
<p>用来创建园:创建园的方法很多，主要构造方法有：</p> 
<p>–园心和通过的一点;</p> 
<p>–通过一个园和一个距离值,创建一个同心园;</p> 
<p>–三点决定一个园;</p> 
<p>–园心和半径;</p> 
<p>gp_Elips2d类：</p> 
<p>可以生成一个椭园,也可以生成椭园上的一段园弧;</p> 
<p>比如：</p> 
<p>Standard_Real major = 12;</p> 
<p>Standard_Real minor = 4;</p> 
<p>gp_Ax2d axis = gp::OX2d();</p> 
<p>gp_Elips2d EE(axis,major,minor);;</p> 
<p>Handle(Geom2d_TrimmedCurve) arc = GCE2d_MakeArcOfEllipse(EE,0.0,PI/4);<br> 上面是利用长短轴的方法构造椭圆,也可以用二次方程的方式来构造椭园;</p> 
<p>其中椭园类中方法可以求出焦点1和焦点2的位置,两焦点之间的位置,离心率;旋转,平移,缩放等操作.</p> 
<p>三、关于面的类</p> 
<p>gp_Pln类:</p> 
<p>定义一个平面,构造的方法可以是点法式,或通过ABCD系数;</p> 
<p>另外，还提供了一些常用的方法，比如：</p> 
<p>–求点到平面,线到平面,平面与平面的距离及平方距离;</p> 
<p>–点是否在平面内,线是否在平面内;</p> 
<p>–通过一个点,一个轴的镜像平面;</p> 
<p>–平面的旋转,缩放与平移;</p> 
<p>Geom_ElementarySurface类：</p> 
<p>此类用来描述一个表面，此类的派生类有：</p> 
<p>平面；园柱面；锥面；球面；园环面；</p> 
<p>它的基类是Geom_Surface，是一个抽象类；</p> 
<p>Geom_Surface类的基类是Geom_Geometry类；</p> 
<p>Geom_RectangularTrimmedSurface类：</p> 
<p>用来生成一个有边界的平面；</p> 
<p>比如：</p> 
<p>Handle(Geom_Plane) aProjectionPlane = GC_MakePlane(ProjectionPlane).Value();</p> 
<p>Handle(Geom_RectangularTrimmedSurface) aProjectionPlaneSurface=</p> 
<p>new Geom_RectangularTrimmedSurface(aProjectionPlane,-8.,8.,-12.,12.);</p> 
<p>DisplaySurface(aDoc,aProjectionPlaneSurface);</p> 
<p>此类的基类是Geom_BoundedSurface类；</p> 
<p>此类的兄弟类还有</p> 
<ul><li> <p>Geom_BezierSurface,</p> </li><li> <p>Geom_BSplineSurface</p> </li></ul> 
<p>ConicalSurface类：用来创建一个园锥表面;</p> 
<p>构造表面的方法有：</p> 
<p>–已知一个园锥表面,和空间一点,过此点的平行于已知园锥表面;</p> 
<p>–已知一个园锥表面,和一个距离,创建一个平行于已知园锥表面的园锥表面;</p> 
<p>–通过四个点构造一个园锥表面;</p> 
<p>–通过一个轴和两个点;</p> 
<p>–通过两个点和两个半径;</p> 
<p>GeomAPI_IntCS类：</p> 
<p>此类用来计算一个园弧和和一个表面的交点或相交线段;</p> 
<p>GeomFill_BSplineCurves类:</p> 
<p>此类用来构造一个可以填充的BSpline表面,构造它可以用两个三个或四个BSpline曲线作为边界;</p> 
<p>填充类型有三种:</p> 
<p>enum GeomFill_FillingStyle {<!-- --></p> 
<p>GeomFill_StretchStyle,</p> 
<p>GeomFill_CoonsStyle,</p> 
<p>GeomFill_CurvedStyle</p> 
<p>};</p> 
<p>以下示例为用两个样条曲线生成一个表面:</p> 
<p>GeomFill_FillingStyle Type = GeomFill_StretchStyle;</p> 
<p>GeomFill_BSplineCurves aGeomFill1(SPL1,SPL2,Type);</p> 
<p>Handle(Geom_BSplineSurface) aBSplineSurface1 = aGeomFill1.Surface();</p> 
<p>GeomFill_Pipe类：</p> 
<p>此类用来构造一个pipe,沿着一个路径sweep一个截面，这两个都是曲线类型；一般来说，结果是一个BSpline表面；</p> 
<p>常见的有几种方法：</p> 
<p>–给定一个路径和一个半径，截面是个园，位置是路径的第一个点，</p> 
<p>比如：</p> 
<p>GeomFill_Pipe aPipe(SPL1,1);</p> 
<p>aPipe.Perform();</p> 
<p>Handle(Geom_Surface) aSurface= aPipe.Surface();</p> 
<p>Standard_CString aSurfaceEntityTypeName=“Not Computed”;</p> 
<p>if (!aSurface.IsNull())</p> 
<p>aSurfaceEntityTypeName = aSurface-&gt;DynamicType()-&gt;Name();</p> 
<p>–给定一个路径和一个截面。</p> 
<p>比如：</p> 
<p>Handle(Geom_Ellipse) E = GC_MakeEllipse( gp::XOY() ,3,1).Value();</p> 
<p>GeomFill_Pipe aPipe2(SPL1,E);</p> 
<p>aPipe2.Perform();</p> 
<p>Handle(Geom_Surface) aSurface2= aPipe2.Surface();</p> 
<p>Standard_CString aSurfaceEntityTypeName2=“Not Computed”;</p> 
<p>if (!aSurface2.IsNull()) {<!-- --></p> 
<p>aSurfaceEntityTypeName2 = aSurface2-&gt;DynamicType()-&gt;Name();</p> 
<p>aSurface2-&gt;Translate(gp_Vec(5,0,0)); }</p> 
<p>–给定一个路径和两个截面，中间截面为过度线；</p> 
<p>示例：</p> 
<p>Handle(Geom_TrimmedCurve) TC1 =</p> 
<p>GC_MakeSegment(gp_Pnt(1,1,1),gp_Pnt(5,5,5));</p> 
<p>Handle(Geom_TrimmedCurve) TC2 =</p> 
<p>GC_MakeSegment(gp_Pnt(1,1,0),gp_Pnt(4,5,6));</p> 
<p>GeomFill_Pipe aPipe3(SPL1,TC1,TC2);</p> 
<p>aPipe3.Perform();</p> 
<p>Handle(Geom_Surface) aSurface3 = aPipe3.Surface();</p> 
<p>Standard_CString aSurfaceEntityTypeName3=“Not Computed”;</p> 
<p>if (!aSurface3.IsNull())</p> 
<p>{<!-- --></p> 
<p>aSurfaceEntityTypeName3 = aSurface3-&gt;DynamicType()-&gt;Name();</p> 
<p>aSurface3-&gt;Translate(gp_Vec(10,0,0));</p> 
<p>}</p> 
<p>–给定一个路径和N个截面，中间为过渡线；</p> 
<p>一般情况下，所生结果为：NURBS，但是，在一些特殊的情况下，可以生成平面，园柱，球，园锥等；</p> 
<p>参数，U，沿着截面的方向，V沿着路径方向；</p> 
<p>Geom_BezierSurface类：</p> 
<p>生成一个Bezier表面；</p> 
<p>Geom_OffsetSurface类：</p> 
<p>用来偏移一个表面；</p> 
<p>比如：</p> 
<p>Standard_Real offset = 1;</p> 
<p>Handle(Geom_OffsetSurface) GOS = new Geom_OffsetSurface(aGeomSurface, offset);</p> 
<p>Geom_SweptSurface类：</p> 
<p>有两个派生类，分别用来生成一个回转体表面和一个延展体表面；</p> 
<p>Geom_SurfaceOfLinearExtrusion：用来描述一个线性延展表面；</p> 
<p>它的基类是：Geom_Surface类</p> 
<p>比如：</p> 
<p>Handle(Geom_BSplineCurve) aCurve =GeomAPI_PointsToBSpline(array).Curve();</p> 
<p>gp_Dir aDir(1,2,3);</p> 
<p>Handle(Geom_SurfaceOfLinearExtrusion) SOLE =new Geom_SurfaceOfLinearExtrusion(aCurve,aDir);</p> 
<p>Handle(Geom_RectangularTrimmedSurface) aTrimmedSurface =new Geom_RectangularTrimmedSurface(SOLE,-10,10,false);</p> 
<p>Geom_SurfaceOfRevolution类，表示一个回转体表面；</p> 
<p>比如：</p> 
<p>Handle(Geom_BSplineCurve) aCurve = GeomAPI_PointsToBSpline(array).Curve();</p> 
<p>Handle(Geom_SurfaceOfRevolution) SOR =new Geom_SurfaceOfRevolution(aCurve,gp::OX());</p> 
<p>1:利用一个二维数组来生成曲面的方法:</p> 
<p>TColgp_Array2OfPnt array3 (1,5,1,5);</p> 
<p>array3.SetValue(1,1,gp_Pnt (-4,-4,5));</p> 
<p>…</p> 
<p>array3.SetValue(2,1,gp_Pnt (-2,-4,4));</p> 
<p>…</p> 
<p>Handle(Geom_BSplineSurface) aSurf2 =GeomAPI_PointsToBSplineSurface(array3).Surface();</p> 
<p>2:GeomAPI_ExtremaSurfaceSurface类:</p> 
<p>计算两个表面之间的极值点;</p> 
<p>主要方法:</p> 
<p>(1):Quantity_Length LowerDistance() const;计算两个表面的最短距离;</p> 
<p>(2):Standard_EXPORT void LowerDistanceParameters(Quantity_Parameter&amp; U1,Quantity_Parameter&amp; V1,Quantity_Parameter&amp; U2,Quantity_Parameter&amp; V2) const;</p> 
<p>得到第一个表面上的极值点的UV参数和第二个表面上的极值点的UV参数;</p> 
<p>(3):void NearestPoints(gp_Pnt&amp; P1,gp_Pnt&amp; P2) const;得到第一个表面上的极值点和第二个表面上的极值点;</p> 
<p>(4): Quantity_Length Distance(const Standard_Integer Index) const;得到第N个极值点的距离;</p> 
<p>(5):Standard_Integer NbExtrema() const;极值的数目;</p> 
<p>…</p> 
<p>示例:</p> 
<p>GeomAPI_ExtremaSurfaceSurface ESS(aSurf1,aSurf2);</p> 
<p>Quantity_Length dist = ESS.LowerDistance();</p> 
<p>gp_Pnt P1,P2;</p> 
<p>ESS.NearestPoints(P1,P2);</p> 
<p>gp_Pnt P3,P4;</p> 
<p>Handle(Geom_Curve) aCurve;</p> 
<p>Standard_Integer NbExtrema = ESS.NbExtrema();</p> 
<p>for(Standard_Integer k=1;k&lt;=NbExtrema;k++){<!-- --></p> 
<p>ESS.Points(k,P3,P4);</p> 
<p>aCurve= GC_MakeSegment(P3,P4).Value();</p> 
<p>DisplayCurve(aDoc,aCurve,Quantity_NOC_YELLOW3,false);</p> 
<p>}</p> 
<p>一些OCC的基础知识，愿与各位OCC爱好者共同学习；mail:tongabcd@yeah.net</p> 
<p>一：关于体的类</p> 
<p>BRepBuilderAPI_MakeVertex类</p> 
<p>创建点；</p> 
<p>BRepBuilderAPI_MakeEdge类</p> 
<p>此类用来创建边；</p> 
<p>比如，由直线生成边：</p> 
<p>gp_Lin line(gp_Ax1(gp_Pnt(10,10,10),gp_Dir(1,0,0)));</p> 
<p>WhiteEdge = BRepBuilderAPI_MakeEdge(line,-20,10);</p> 
<p>下面为生成四分之一园边：</p> 
<p>gp_Elips Elips(gp_Ax2(gp_Pnt(10,0,0),gp_Dir(1,1,1)),60,30);</p> 
<p>RedEdge = BRepBuilderAPI_MakeEdge(Elips,0,PI/2);</p> 
<p>下面是由曲线生成边：</p> 
<p>Handle (Geom_BezierCurve) curve = new Geom_BezierCurve(array);</p> 
<p>BRepBuilderAPI_MakeEdge ME (curve);</p> 
<p>GreenEdge = ME;</p> 
<p>V3 = ME.Vertex1();</p> 
<p>V4 = ME.Vertex2();</p> 
<p>BRepBuilderAPI_MakeWire类</p> 
<p>用来创建一个Wire类；</p> 
<p>用一个Wire和一个边来生成一个新的Wire：</p> 
<p>ExistingWire = BRepBuilderAPI_MakeWire(Edge2);</p> 
<p>Edge3 = BRepBuilderAPI_MakeEdge(gp_Pnt(-300,0,-80),gp_Pnt(-90,20,-30));</p> 
<p>BRepBuilderAPI_MakeWire MW1(ExistingWire,Edge3);</p> 
<p>if (MW1.IsDone()) {YellowWire = MW1;}</p> 
<p>用一个Wire和添加边的方法来生成Wire：</p> 
<p>BRepBuilderAPI_MakeWire MW;</p> 
<p>MW.Add(ExistingWire2);</p> 
<p>MW.Add(Edge5);</p> 
<p>MW.Add(Edge6);</p> 
<p>MW.Add(Edge7);</p> 
<p>if (MW.IsDone()) {<!-- --></p> 
<p>WhiteWire = MW.Wire();</p> 
<p>LastEdge = MW.Edge();</p> 
<p>LastVertex = MW.Vertex();</p> 
<p>}</p> 
<p>BRepBuilderAPI_MakeFace类</p> 
<p>生成一个面；有多种生成面的方法；</p> 
<p>–通过一个封闭曲线生成面：</p> 
<p>BRepBuilderAPI_MakeFace(curve);</p> 
<p>–通过一个Wire生成面：</p> 
<p>BrownFace = BRepBuilderAPI_MakeFace(YellowWire);</p> 
<p>Bnd_Box2d类:</p> 
<p>定义一个二维空间的边界盒,可以得出边界盒各个点的值，有时，在某个方向是无限大,这种情况下，称为在此方向上是开放的;</p> 
<p>示例:</p> 
<p>Bnd_Box2d aCBox;</p> 
<p>Geom2dAdaptor_Curve GACC ©;</p> 
<p>BndLib_Add2dCurve::Add (GACC,Precision::Approximation(),aCBox);</p> 
<p>Bnd_Box类:</p> 
<p>定义一个三维空间的边界盒,可以扩大或缩小边界盒,也可以合并两个轴对齐边界盒;</p> 
<p>BRepPrimAPI_MakeBox类</p> 
<p>用来生成一个立方体;</p> 
<p>构造一个立方体可以是两个对角点,一个角点及三个方向长度,可以是非轴对称的:</p> 
<p>TopoDS_Shape B2 = BRepPrimAPI_MakeBox (gp_Ax2(gp_Pnt(-200.,-80.,-70.), gp_Dir(1.,2.,1.)), 80.,90.,120.);</p> 
<p>使用方法</p> 
<p>TopoDS_Face&amp; BottomFace() ;.可以得到立方体的底面;同样，用其它类似的方法可以获得顶面等；</p> 
<p>方法TopoDS_Solid&amp; Solid() ;可以将box转化为一个Solid;</p> 
<p>方法TopoDS_Shell&amp; Shell() ;可以将box转化为一个shell;</p> 
<p>BRepPrimAPI_MakeCylinder类</p> 
<p>用来生成一个园柱体或园柱体的一部分；</p> 
<p>比如：</p> 
<p>TopoDS_Shape C2 = BRepPrimAPI_MakeCylinder (gp_Ax2(gp_Pnt(200.,0.,200.), gp_Dir(0.,1.,0.)),40.,110.,210.*PI180);</p> 
<p>BRepPrimAPI_MakeCone类</p> 
<p>生成一个园锥或园锥的一部分；</p> 
<p>BRepPrimAPI_MakeSphere类</p> 
<p>生成球体或球体的一部分，可以是U方向切一部分或V方向切一部分；</p> 
<p>BRepPrimAPI_MakeTorus类</p> 
<p>生成环或环的一部分；</p> 
<p>BRepPrimAPI_MakeWedge类</p> 
<p>生成一个楔块或楔块的一部分；</p> 
<p>BRepPrimAPI_MakePrism类</p> 
<p>生成一个线性的swept,称为Prisms;它的基类是BRepPrimAPI_MakeSweep类；BRepPrimAPI_MakeSweep类的基类是</p> 
<p>BRepBuilderAPI_MakeShape类</p> 
<p>注意，原始基本图形不可以包含任何实体：</p> 
<p>应用此类时：</p> 
<p>–顶点“推移”成边：</p> 
<p>TopoDS_Vertex V1 = BRepBuilderAPI_MakeVertex(gp_Pnt(-200.,-200.,0.));</p> 
<p>Handle(AIS_Shape) ais1 = new AIS_Shape(V1);</p> 
<p>TopoDS_Shape S1 = BRepPrimAPI_MakePrism(V1,gp_Vec(0.,0.,100.));</p> 
<p>Handle(AIS_Shape) ais2 = new AIS_Shape(S1);</p> 
<p>–边“推移”成面：.</p> 
<p>TopoDS_Edge E = BRepBuilderAPI_MakeEdge(gp_Pnt(-150.,-150,0.), gp_Pnt(-50.,-50,0.));</p> 
<p>Handle(AIS_Shape) ais3 = new AIS_Shape(E);</p> 
<p>myAISContext-&gt;Display(ais3,Standard_False);</p> 
<p>TopoDS_Shape S2 = BRepPrimAPI_MakePrism(E,gp_Vec(0.,0.,100.));</p> 
<p>–Wires “推移”成Shells.</p> 
<p>TopoDS_Edge E1 = BRepBuilderAPI_MakeEdge(gp_Pnt(0.,0.,0.), gp_Pnt(50.,0.,0.));</p> 
<p>TopoDS_Edge E2 = BRepBuilderAPI_MakeEdge(gp_Pnt(50.,0.,0.), gp_Pnt(50.,50.,0.));</p> 
<p>TopoDS_Edge E3 = BRepBuilderAPI_MakeEdge(gp_Pnt(50.,50.,0.), gp_Pnt(0.,0.,0.));</p> 
<p>TopoDS_Wire W = BRepBuilderAPI_MakeWire(E1,E2,E3);</p> 
<p>TopoDS_Shape S3 = BRepPrimAPI_MakePrism(W,gp_Vec(0.,0.,100.));</p> 
<p>–Faces “推移”成Solids.</p> 
<p>TopoDS_Face F = BRepBuilderAPI_MakeFace(gp_Pln(gp::XOY()),Wc);</p> 
<p>Handle(AIS_Shape) ais7 = new AIS_Shape(F);</p> 
<p>myAISContext-&gt;Display(ais7,Standard_False);</p> 
<p>TopoDS_Shape S4 = BRepPrimAPI_MakePrism(F,gp_Vec(0.,0.,100.));</p> 
<p>–Shells “推移”成复合实体</p> 
<p>BRepPrimAPI_MakeRevol类</p> 
<p>一个回转sweep体；</p> 
<p>类继承关系和前面类似：BRepBuilderAPI_MakeShape–〉BRepPrimAPI_MakeSweep–&gt;BRepPrimAPI_MakeRevol</p> 
<p>，对于角度而言，范围是[0，2PI]，默认值是2PI，生成规则：</p> 
<ul><li> <p>Vertex -&gt; Edge.</p> </li><li> <p>Edge -&gt; Face.</p> </li><li> <p>Wire -&gt; Shell.</p> </li><li> <p>Face-&gt; Solid.</p> </li><li> <p>Shell-&gt; CompSolid.</p> </li></ul> 
<p>BRepOffsetAPI_MakePipe类</p> 
<p>可以生成一个管道</p> 
<p>类继承关系是：BRepBuilderAPI_MakeShape–〉BRepPrimAPI_MakeSweep–&gt;BRepOffsetAPI_MakePipe</p> 
<p>以下为生成一个管道的示例过程：</p> 
<p>–利用生成一个WIRE，作为管道的路径:</p> 
<p>Handle(Geom_BezierCurve) curve = new Geom_BezierCurve(CurvePoles);</p> 
<p>TopoDS_Edge E = BRepBuilderAPI_MakeEdge(curve);</p> 
<p>TopoDS_Wire W = BRepBuilderAPI_MakeWire(E);</p> 
<p>–生成一个面，作为生成管道的截面：</p> 
<p>gp_Circ c = gp_Circ(gp_Ax2(gp_Pnt(0.,0.,0.),gp_Dir(0.,1.,0.)),10.);</p> 
<p>TopoDS_Edge Ec = BRepBuilderAPI_MakeEdge©;</p> 
<p>TopoDS_Wire Wc = BRepBuilderAPI_MakeWire(Ec);</p> 
<p>TopoDS_Face F = BRepBuilderAPI_MakeFace(gp_Pln(gp::ZOX()),Wc);</p> 
<p>–利用前两步生成的路径和截面来生成pipe:</p> 
<p>TopoDS_Shape S = BRepOffsetAPI_MakePipe(W,F);</p> 
<p>Handle(AIS_Shape) ais2 = new AIS_Shape(S);</p> 
<p>BRepOffsetAPI_ThruSections类</p> 
<p>此类继承自BRepBuilderAPI_MakeShape：创建一个loft,通过一组给定的sections，生成一个shell或一个solid;通常，section是wire;但是第一个和最后一个section可以是</p> 
<p>vertices;</p> 
<p>比如：</p> 
<p>BRepOffsetAPI_ThruSections generator(Standard_False,Standard_True);</p> 
<p>generator.AddWire(W1);</p> 
<p>generator.AddWire(W2);</p> 
<p>generator.AddWire(W3);</p> 
<p>generator.AddWire(W4);</p> 
<p>generator.Build();</p> 
<p>TopoDS_Shape S1 = generator.Shape();</p> 
<p>Handle(AIS_Shape) ais1 = new AIS_Shape(S1);</p> 
<p>BRepBuilderAPI_MakePolygon类</p> 
<p>创建一个polygonal wires，可以通过一组点或向量生成，也可以先生成一个空的对象，再添加点。</p> 
<p>示例1：</p> 
<p>BRepBuilderAPI_MakePolygon P;</p> 
<p>P.Add(gp_Pnt(0.,0.,0.));</p> 
<p>P.Add(gp_Pnt(200.,0.,0.));</p> 
<p>P.Add(gp_Pnt(200.,200.,0.));</p> 
<p>P.Add(gp_Pnt(0.,200.,0.));</p> 
<p>P.Add(gp_Pnt(0.,0.,0.));</p> 
<p>TopoDS_Wire W = P.Wire();</p> 
<p>示例2：</p> 
<p>TopoDS_Wire wprof = BRepBuilderAPI_MakePolygon(gp_Pnt(0.,0.,0.),gp_Pnt(-60.,-60.,-200.));</p> 
<p>BRepOffsetAPI_MakeEvolved类</p> 
<p>创建一个可展图形，它是通过一个planar spine (face or wire)和一个rofile (wire)来生成的，它是一个非循环的sweep (pipe),用profile沿着spline;自相交点将被移除；</p> 
<p>比如：</p> 
<p>–沿着一个spline，sweep一个profile;</p> 
<p>Standard_EXPORT BRepOffsetAPI_MakeEvolved(const TopoDS_Face&amp; Spine,const TopoDS_Wire&amp; Profil,const GeomAbs_JoinType Join = GeomAbs_Arc,const Standard_Boolean</p> 
<p>AxeProf = Standard_True,const Standard_Boolean Solid = Standard_False,const Standard_Boolean ProfOnSpine = Standard_False,const Standard_Real Tol = 0.0000001);</p> 
<p>AxeProf参数如果为true,R是0,X,Y,Z;如果solid为真，结果为一个solid或复合的solids;</p> 
<p>示例：</p> 
<p>TopoDS_Shape</p> 
<p>S = BRepOffsetAPI_MakeEvolved(W,wprof,GeomAbs_Arc,Standard_True,Standard_False,Standard_True,0.0001);</p> 
<p>BRepBuilderAPI_ModifyShape类</p> 
<p>当使用BRepTools来创建一个修改类，主要有以下派生类：</p> 
<p>–BRepBuilderAPI_Copy:处理一个图形的拷贝；</p> 
<p>–BRepBuilderAPI_Transform 和BRepBuilderAPI_GTransform：用来对一个图形应用几何变形；</p> 
<p>–BRepBuilderAPI_NurbsConvert:用来将一个图形转化为NURBS几何体；</p> 
<p>–BRepOffsetAPI_DraftAngle：创建一个tapered图形；</p> 
<p>BRepOffsetAPI_DraftAngle类</p> 
<p>创建一个tapered图形；一般过程是：</p> 
<p>–初始化构造算法；</p> 
<p>–输入要taper的特征面；</p> 
<p>–实现算法；</p> 
<p>–生成结果；</p> 
<p>示例：</p> 
<p>TopoDS_Shape S = BRepPrimAPI_MakeBox(200.,300.,150.);</p> 
<p>BRepOffsetAPI_DraftAngle adraft(S);</p> 
<p>TopExp_Explorer Ex;</p> 
<p>for (Ex.Init(S,TopAbs_FACE); Ex.More(); Ex.Next()) {<!-- --></p> 
<p>TopoDS_Face F = TopoDS::Face(Ex.Current());</p> 
<p>Handle(Geom_Plane) surf = Handle(Geom_Plane)::DownCast(BRep_Tool::Surface(F));</p> 
<p>gp_Pln apln = surf-&gt;Pln();</p> 
<p>gp_Dir dirF = apln.Axis().Direction();</p> 
<p>if (dirF.IsNormal(gp_Dir(0.,0.,1.),Precision::Angular()))</p> 
<p>adraft.Add(F, gp_Dir(0.,0.,1.), 15.*PI180, gp_Pln(gp::XOY()));</p> 
<p>}</p> 
<p>ais1-&gt;Set(adraft.Shape());</p> 
<p>二：关于布尔等实体修改操作相关</p> 
<p>BRepAlgoAPI_BooleanOperation类</p> 
<p>此类的基类是BRepBuilderAPI_MakeShape类，它是一个抽象类；</p> 
<p>可以应用的操作有：BOP_SECTION 、BOP_COMMON、BOP_FUSE、BOP_CUT、BOP_CUT21</p> 
<p>有时会产生错误，无法达到想要的结果，根据返回值，可以得到错误信息，含义是：</p> 
<p>0：OK</p> 
<p>1： 对象创建完成，但结果为空；</p> 
<p>2：源图形为空；</p> 
<p>3：参数类型检查错误；</p> 
<p>4：不能为DSFiller分配内存；</p> 
<p>5：此种类型参数的Builder无法工作；</p> 
<p>6：不允许的操作；</p> 
<p>7：不能为Builder分配内存；</p> 
<blockquote> 
 <p>100 参见Builder错误信息；</p> 
</blockquote> 
<p>相关的方法介绍：</p> 
<p>–TopTools_ListOfShape&amp; SectionEdges()方法：返回一组截面的边，它们在布尔操作过程中生成；</p> 
<p>–Standard_Boolean HasDeleted()方法：如果至少一个图形对象被删除了，返回为真；</p> 
<p>–Standard_Boolean HasGenerated()方法：如果至少生成了一个图形，返回为真；</p> 
<p>–Standard_Boolean HasModified()方法：如果至少一个图形被修改了，返回为真；</p> 
<p>–TopTools_ListOfShape&amp; Generated(const TopoDS_Shape&amp; S) 方法：返回生成以后的图形的集合；</p> 
<p>–TopTools_ListOfShape&amp; Modified2(const TopoDS_Shape&amp; aS)方法：返回修改后的图形的集合；</p> 
<p>–Standard_Boolean IsDeleted(const TopoDS_Shape&amp; aS)方法：如果图形S已经被删除，返回为真，即结果图形中不包括图形S；</p> 
<p>-BOP_Operation Operation()方法：返回布尔操作的类型；</p> 
<p>布尔操作类</p> 
<p>包括有BRepAlgoAPI_Cut类， BRepAlgoAPI_Fuse类，BRepAlgoAPI_Common类：布尔交集；</p> 
<p>BRepAlgoAPI_Section类</p> 
<p>计算两个图形或几何体的截面，几何对象可以是平面的表面，转化为face.</p> 
<p>示例：</p> 
<p>给定两个图形S1和S2，计算在S1和S2上的边，在新曲线上生成近似值，结果在第一部分上而不在第二部分上：</p> 
<p>Standard_Boolean PerformNow = Standard_False;</p> 
<p>BRepBoolAPI_Section S(S1,S2,PerformNow);</p> 
<p>S.ComputePCurveOn1(Standard_True);</p> 
<p>S.Approximation(Standard_True);</p> 
<p>S.Build();</p> 
<p>TopoDS_Shape R = S.Shape();</p> 
<p>如果结果为空，调用NotDone()；</p> 
<p>常见方法：</p> 
<p>–BRepAlgoAPI_Section(const Handle(Geom_Surface)&amp; Sf1,const Handle(Geom_Surface)&amp; Sf2,const Standard_Boolean</p> 
<p>PerformNow = Standard_True);</p> 
<p>用来生成线：</p> 
<p>–两个图形SH1和SH2；</p> 
<p>–图形SH和平面P1；</p> 
<p>–表面SF和图形SH；</p> 
<p>–两个表面SF1和SF2；</p> 
<p>参数PerformNow如果为真，将直接计算结果，如果为假，表示后面将通过Build（）这个函数来计算结果；</p> 
<p>生成后的图形是由方法Shape（）得出的；</p> 
<p>这些相交的边是独立的，不在一个链表上，也不在一个wire上，如果不存在一个相交边，返回结果为空；</p> 
<p>示例：</p> 
<p>–计算相交的基本边–利用这些基本边创建一个相交线–决定相交线在两个图形的哪个图形的参数空间；</p> 
<p>TopoDS_Shape S1 = … , S2 = … ;</p> 
<p>Standard_Boolean PerformNow = Standard_False;</p> 
<p>BRepAlgoAPI_Section S ( S1, S2, PerformNow );</p> 
<p>S.ComputePCurveOn1 (Standard_True);</p> 
<p>S.Approximation (Standard_True);</p> 
<p>S.Build();</p> 
<p>TopoDS_Shape R = S.Shape();</p> 
<p>BRepFilletAPI_LocalOperation类</p> 
<p>基类是BRepBuilderAPI_MakeShape；</p> 
<p>构造在一个shell的边的园角；常用方法有</p> 
<p>–void Add(const TopoDS_Edge&amp; E) = 0;在builder上添加一个轮廓线；</p> 
<p>–void ResetContour(const Standard_Integer IC) = 0;重置索引为IC的轮廓线；</p> 
<p>–Standard_Integer NbContours() const = 0;返回轮廓线的数目；</p> 
<p>–Standard_Integer Contour(const TopoDS_Edge&amp; E) const = 0;返回边E的轮廓线的索引，如果边E不在轮廓线内，返回为O；</p> 
<p>–Standard_Integer NbEdges(const Standard_Integer I) const = 0;返回在轮廓线I中的边数；</p> 
<p>–void Remove(const TopoDS_Edge&amp; E) = 0;移除一个边；</p> 
<p>–Standard_Real Length(const Standard_Integer IC) const = 0;得到某个轮廓线的长度；</p> 
<p>–TopoDS_Vertex FirstVertex(const Standard_Integer IC) const = 0;返回某个轮廓线的第一个顶点；LastVertex方法返回最后一个顶点；</p> 
<p>–Abscissa方法，返回某个顶点的横坐标；</p> 
<p>–Standard_Boolean ClosedAndTangent(const Standard_Integer IC) const如果某个轮廓线是封闭切线，返回为真；</p> 
<p>–Standard_Boolean Closed(const Standard_Integer IC) const = 0;如果某个轮廓线是封闭，返回为真；</p> 
<p>–Reset() = 0;重置所有；</p> 
<p>BRepFilletAPI_MakeFillet类</p> 
<p>创建一个园角；</p> 
<p>示例一：</p> 
<p>对一个BOX园角：</p> 
<p>BRepFilletAPI_MakeFillet fillet(Box);</p> 
<p>for (TopExp_Explorer ex(Box,TopAbs_EDGE); ex.More(); ex.Next()) {<!-- --></p> 
<p>TopoDS_Edge Edge =TopoDS::Edge(ex.Current());</p> 
<p>fillet.Add(20,Edge);</p> 
<p>}</p> 
<p>示例二：</p> 
<p>两个BOX，合并后园角；</p> 
<p>TopoDS_Shape fusedShape = BRepAlgoAPI_Fuse(S1,S2);</p> 
<p>BRepFilletAPI_MakeFillet fill(fusedShape);</p> 
<p>for (TopExp_Explorer ex1(fusedShape,TopAbs_EDGE); ex1.More(); ex1.Next()) {<!-- --></p> 
<p>TopoDS_Edge E =TopoDS::Edge(ex1.Current());</p> 
<p>fill.Add(E);</p> 
<p>}</p> 
<p>for (Standard_Integer i = 1;i&lt;=fill.NbContours();i++) {<!-- --></p> 
<p>Standard_Real longueur(fill.Length(i));</p> 
<p>Standard_Real Rad(0.15*longueur);</p> 
<p>fill.SetRadius(Rad,i, 1);</p> 
<p>}</p> 
<p>TopoDS_Shape blendedFusedSolids = fill.Shape();</p> 
<p>Handle(AIS_Shape) aBlend = new AIS_Shape(blendedFusedSolids);</p> 
<p>示例三：</p> 
<p>只园角其中一条边：</p> 
<p>BRepFilletAPI_MakeFillet Rake(theBox);</p> 
<p>TopExp_Explorer ex(theBox,TopAbs_EDGE);</p> 
<p>ex.Next();</p> 
<p>ex.Next();</p> 
<p>ex.Next();</p> 
<p>ex.Next();</p> 
<p>Rake.Add(8,50,TopoDS::Edge(ex.Current()));</p> 
<p>Rake.Build();</p> 
<p>if (Rake.IsDone() ){<!-- --></p> 
<p>TopoDS_Shape evolvedBox = Rake.Shape();</p> 
<p>ais1-&gt;Set(evolvedBox);</p> 
<p>}</p> 
<p>示例四：</p> 
<p>园角一个园柱：</p> 
<p>BRepFilletAPI_MakeFillet fillet(theCylinder);</p> 
<p>TColgp_Array1OfPnt2d TabPoint2(1,20);</p> 
<p>for (Standard_Integer i=0; i&lt;=19; i++) {<!-- --></p> 
<p>gp_Pnt2d Point2d(i<em>2</em>PI/19,60<em>cos(i</em>PI/19-PI/2)+10);</p> 
<p>TabPoint2.SetValue(i+1,Point2d);</p> 
<p>}</p> 
<p>TopExp_Explorer exp2(theCylinder,TopAbs_EDGE);</p> 
<p>fillet.Add(TabPoint2,TopoDS::Edge(exp2.Current()));</p> 
<p>fillet.Build();</p> 
<p>if (fillet.IsDone() ){<!-- --></p> 
<p>TopoDS_Shape LawEvolvedCylinder = fillet.Shape();</p> 
<p>ais3-&gt;Set(LawEvolvedCylinder);</p> 
<p>myAISContext-&gt;Redisplay(ais3,Standard_False);</p> 
<p>myAISContext-&gt;SetCurrentObject(ais3,Standard_False);</p> 
<p>}</p> 
<p>BRepFilletAPI_MakeChamfer类</p> 
<p>创建一个倒角；</p> 
<p>基类：BRepFilletAPI_LocalOperation；</p> 
<p>可以设置相关参数，比如倒角两个距离，角度等参数；</p> 
<p>示例：</p> 
<p>BRepFilletAPI_MakeChamfer MC(theBox);</p> 
<p>// add all the edges to chamfer</p> 
<p>TopTools_IndexedDataMapOfShapeListOfShape M;</p> 
<p>TopExp::MapShapesAndAncestors(theBox,TopAbs_EDGE,TopAbs_FACE,M);</p> 
<p>for (Standard_Integer i = 1;i&lt;=M.Extent();i++) {<!-- --></p> 
<p>TopoDS_Edge E = TopoDS::Edge(M.FindKey(i));</p> 
<p>TopoDS_Face F = TopoDS::Face(M.FindFromIndex(i).First());</p> 
<p>MC.Add(5,5,E,F);</p> 
<p>}</p> 
<p>BRepBuilderAPI_MakeShell类</p> 
<p>生成一个表面的外壳，注意，一个图形的外壳，不是一个由表面和厚度定义的实体模型，如果想要创建这种壳，需要使用BRepOffsetAPI_MakeOffsetShape，一个外壳是由一系列相互通过普通的边连接起来的面；如果表面是C2连续的，外壳将只有一个面；如果表面不是C2连续的，将把一些面细分成所有的面都是C2连续的，结果是外壳包含所有这些面；通过一个非C2连续的表面来生成一个外壳，一般过程是：–构造一个外壳对象–实现算法–生成结果；</p> 
<p>注意：表面分解的这些C2面并没有缝合在一起，需要使用BRepOffsetAPI_Sewing，如果想实现带厚度的外壳，需要使用BRepOffsetAPI_MakeOffsetShape类；</p> 
<p>BRepBuilderAPI_Sewing类</p> 
<p>将多个邻近图形“缝合”成为一个图形；同时有多个边的情况下无法缝合；</p> 
<p>一般操作过程是：</p> 
<p>–创建一个空对象；</p> 
<p>缺省的公差是1.E-06；</p> 
<p>面分析；</p> 
<p>缝合操作；</p> 
<p>根据需要作剪操作；</p> 
<p>–定义公差；</p> 
<p>–添加要缝合的对象；</p> 
<p>–计算生成；</p> 
<p>–输出结果图形；</p> 
<p>–如果需要可以输出自由边；</p> 
<p>–如果需要可以输出多个边；</p> 
<p>–输出其它问题；</p> 
<p>主要方法：</p> 
<p>–构造函数：</p> 
<p>option1 如果为假表示只控制；</p> 
<p>option2：分析退化的图形；</p> 
<p>option3：为自由边的剪操作；</p> 
<p>option4：未复制处理；</p> 
<p>BRepBuilderAPI_Sewing(const Standard_Real tolerance = 1.0e-06,const Standard_Boolean option1 = Standard_True,const Standard_Boolean option2 = Standard_True,const Standard_Boolean option3 = Standard_True,const Standard_Boolean option4 = Standard_False);</p> 
<p>如果必要，可以初始化参数；</p> 
<p>void Init(const Standard_Real tolerance = 1.0e-06,const Standard_Boolean option1 = Standard_True,const Standard_Boolean option2 = Standard_True,const Standard_Boolean option3 = Standard_True,const Standard_Boolean option4 = Standard_False) ;</p> 
<p>–添加一个要缝合的图形的方法是；</p> 
<p>void Add(const TopoDS_Shape&amp; shape) ;</p> 
<p>–生成图形方法是：</p> 
<p>void Perform() ;</p> 
<p>–得到缝合后的图形方法是：</p> 
<p>TopoDS_Shape&amp; SewedShape() const;</p> 
<p>–得到自由边（只被一个面共享的边）的数量方法是：</p> 
<p>Standard_Integer NbFreeEdges() const;</p> 
<p>–得到一个自由边的方法是：</p> 
<p>const TopoDS_Edge&amp; FreeEdge(const Standard_Integer index) const;</p> 
<p>–得到复合边（被两个及以上面共享的边）的数量：</p> 
<p>Standard_Integer NbMultipleEdges() const;</p> 
<p>–得到其中的一个复合边：</p> 
<p>const TopoDS_Edge&amp; MultipleEdge(const Standard_Integer index) const;</p> 
<p>–得到邻近边的数量：</p> 
<p>Standard_Integer NbContigousEdges() const;</p> 
<p>–得到其中一个邻近边：</p> 
<p>const TopoDS_Edge&amp; ContigousEdge(const Standard_Integer index) const;</p> 
<p>–得到有一个邻近边的边的集合（截面）；</p> 
<p>const TopTools_ListOfShape&amp; ContigousEdgeCouple(const Standard_Integer index) const;</p> 
<p>–一个截面是否是有边界的（使用SectionToBoundary方法之前）：</p> 
<p>Standard_Boolean IsSectionBound(const TopoDS_Edge&amp; section) const;</p> 
<p>–得到成为截面的原始边。记住，截面是由普通边所组成的，这个信息对于控制来说是很重要的，因为通过原始边可以找到被附加的截面的表面；</p> 
<p>const TopoDS_Edge&amp; SectionToBoundary(const TopoDS_Edge&amp; section) const;</p> 
<p>–得到每一个退化的图形：</p> 
<p>const TopoDS_Shape&amp; DegeneratedShape(const Standard_Integer index) const;</p> 
<p>–此图形是否是退化的图形：</p> 
<p>Standard_Boolean IsDegenerated(const TopoDS_Shape&amp; shape) const;</p> 
<p>–此图形是否已被修改过：</p> 
<p>Standard_Boolean IsModified(const TopoDS_Shape&amp; shape) const;</p> 
<p>–得到一个修改后的图形：</p> 
<p>const TopoDS_Shape&amp; Modified(const TopoDS_Shape&amp; shape) const;</p> 
<p>–子图形是否被修改过：</p> 
<p>Standard_Boolean IsModifiedSubShape(const TopoDS_Shape&amp; shape) const;</p> 
<p>–得到一个修改过的子图形：</p> 
<p>TopoDS_Shape ModifiedSubShape(const TopoDS_Shape&amp; shape) const;</p> 
<p>–得到每一个被删除的面：</p> 
<p>const TopoDS_Face&amp; DeletedFace(const Standard_Integer index) const;</p> 
<p>–void Dump() const;打印相关信息；</p> 
<p>–得到一个修改后的图形：</p> 
<p>TopoDS_Face WhichFace(const TopoDS_Edge&amp; theEdg,const Standard_Integer index = 1) const;</p> 
<p>示例：</p> 
<p>BRepOffsetAPI_Sewing aMethod;</p> 
<p>aMethod.Add(FirstShape);</p> 
<p>aMethod.Add(SecondShape);</p> 
<p>aMethod.Perform();</p> 
<p>TopoDS_Shape sewedShape = aMethod.SewedShape();</p> 
<p>Handle(AIS_Shape) result = new AIS_Shape(sewedShape);</p> 
<p>BRep_Tool类</p> 
<p>提供了处理BRep图形几何对象的一些方法；</p> 
<p>如果S是一个Solid,Shell,或Compound.返回为真；</p> 
<p>Standard_Boolean IsClosed(const TopoDS_Shape&amp; S) ;</p> 
<p>返回在位置L处的几何表面：</p> 
<p>Handle_Geom_Surface&amp; Surface(const TopoDS_Face&amp; F,TopLoc_Location&amp; L) ;</p> 
<p>返回面的几何表面，如果有一个位置可以是一个拷贝；</p> 
<p>Handle_Geom_Surface Surface(const TopoDS_Face&amp; F) ;</p> 
<p>返回面的多边三角形，如果没有三角形返回一个空句柄：</p> 
<p>const Handle_Poly_Triangulation&amp; Triangulation(const TopoDS_Face&amp; F,TopLoc_Location&amp; L) ;</p> 
<p>返加面的公差值：</p> 
<p>Standard_Real Tolerance(const TopoDS_Face&amp; F) ;</p> 
<p>返回面的自然约束标志：</p> 
<p>Standard_Boolean NaturalRestriction(const TopoDS_Face&amp; F) ;</p> 
<p>如果E是一个3D曲线或表面上的一个曲线，返回为真；</p> 
<p>Standard_Boolean IsGeometric(const TopoDS_Edge&amp; E) ;</p> 
<p>返回边的3D曲线，可以是NULL，返回L位置，及参数范围；</p> 
<p>Handle_Geom_Curve&amp; Curve(const TopoDS_Edge&amp; E,TopLoc_Location&amp; L,Standard_Real&amp; First,Standard_Real&amp; Last) ;</p> 
<p>返回边的3D多边形，返回多边形的位置L；</p> 
<p>Handle_Poly_Polygon3D&amp; Polygon3D(const TopoDS_Edge&amp; E,TopLoc_Location&amp; L)</p> 
<p>TopLoc_Location类</p> 
<p>一个Location 是一个复合的平移；对象类型是TopLoc_Datum3D；</p> 
<p>常见方法：</p> 
<p>–TopLoc_Location();</p> 
<p>构造一个空的局部坐标系统对象；注意，这种被构造的缺省的数据为空；、</p> 
<p>–TopLoc_Location(const gp_Trsf&amp; T);</p> 
<p>通过T构造一个局部坐标系统；</p> 
<p>–TopLoc_Location(const Handle(TopLoc_Datum3D)&amp; D);</p> 
<p>通过3D datum D来构造一个局部坐标系统，如果平移T不能表达一个局部坐标系统，会引发构造异常；</p> 
<p>–Standard_Boolean IsIdentity() const;如果此位置等于一个单位化平移，返回为真；</p> 
<p>– void Identity() ;设置位置为单位化平移；</p> 
<p>–Handle_TopLoc_Datum3D&amp; FirstDatum() 得到位置的第一个基础数据；</p> 
<p>– const TopLoc_Location&amp; NextLocation() const;</p> 
<p>另外，具有加减乘除，是否相等方法；</p> 
<p>示例：</p> 
<p>炸开一个立方体的六个面：</p> 
<p>for (TopExp_Explorer exp (aBox,TopAbs_FACE);exp.More();exp.Next()) {<!-- --></p> 
<p>TopoDS_Face aCurrentFace = TopoDS::Face(exp.Current());</p> 
<p>//测试当前面的方向</p> 
<p>TopAbs_Orientation orient = aCurrentFace.Orientation();</p> 
<p>//重新生成几何平面</p> 
<p>TopLoc_Location location;</p> 
<p>Handle (Geom_Surface) aGeometricSurface = BRep_Tool::Surface(aCurrentFace,location);</p> 
<p>Handle (Geom_Plane) aPlane = Handle (Geom_Plane)::DownCast(aGeometricSurface);</p> 
<p>//Build an AIS_Shape with a new color</p> 
<p>//创建一个新的AIS_Shape</p> 
<p>Handle(AIS_Shape) theMovingFace = new AIS_Shape(aCurrentFace);</p> 
<p>Quantity_NameOfColor aCurrentColor = (Quantity_NameOfColor)j;</p> 
<p>myAISContext-&gt;SetColor(theMovingFace,aCurrentColor,Standard_False);</p> 
<p>myAISContext-&gt;SetMaterial(theMovingFace,Graphic3d_NOM_PLASTIC,Standard_False);</p> 
<p>//查找每个面的法向量</p> 
<p>gp_Pln agpPlane = aPlane-&gt;Pln();</p> 
<p>gp_Ax1 norm = agpPlane.Axis();</p> 
<p>gp_Dir dir = norm.Direction();</p> 
<p>gp_Vec move(dir);</p> 
<p>TopLoc_Location aLocation;</p> 
<p>Handle (AIS_ConnectedInteractive) theTransformedDisplay = new AIS_ConnectedInteractive();</p> 
<p>theTransformedDisplay-&gt;Connect(theMovingFace, aLocation);</p> 
<p>// = myAISContext-&gt;Location(theMovingFace);</p> 
<p>Handle (Geom_Transformation) theMove = new Geom_Transformation(aLocation.Transformation());</p> 
<p>for (Standard_Integer i=1;i&lt;=30;i++) {<!-- --></p> 
<p>theMove-&gt;SetTranslation(move*i);</p> 
<p>if (orient==TopAbs_FORWARD) myAISContext-&gt;SetLocation(theTransformedDisplay,TopLoc_Location(theMove-&gt;Trsf()));</p> 
<p>else myAISContext-&gt;SetLocation(theTransformedDisplay,TopLoc_Location(theMove-&gt;Inverted()-&gt;Trsf()));</p> 
<p>myAISContext-&gt;Redisplay(theTransformedDisplay,Standard_False);</p> 
<p>}</p> 
<p>j+=15;</p> 
<p>}</p> 
<p>BRepAlgo类</p> 
<p>BRepAlgo提供了一些布尔操作的服务；</p> 
<p>注意，在BrepAlgoAPI包中提供了新的布尔操作，代替了旧的布尔操作；</p> 
<p>方法：</p> 
<p>–static Standard_Boolean IsValid(const TopoDS_Shape&amp; S) ;检测图形是否合法；</p> 
<p>–Standard_EXPORT static Standard_Boolean IsValid(const TopTools_ListOfShape&amp; theArgs,const TopoDS_Shape&amp;</p> 
<p>theResult,const Standard_Boolean closedSolid = Standard_False,const Standard_Boolean GeomCtrl = Standard_True) ;</p> 
<p>检查在结果图形中所生成和修改后的面是否合法，参数theArgs可以为空，表示所有的面都被检查；如果closedSolid 为真，表示只有封闭的图形合法，如果参数GeomCtrl为假，几何体的顶点和边不检查，自相交的新的wire也不检查；</p> 
<p>–Standard_Boolean IsTopologicallyValid(const TopoDS_Shape&amp; S) ;</p> 
<p>也是检查图形是否合法，和前一个不同的是，检查 no geometric contols (intersection of wires, pcurve validity) are</p> 
<p>performed.</p> 
<p>GProp_GProps类</p> 
<p>计算图元的属性；</p> 
<p>gp_Trsf类</p> 
<p>定义一个矩阵变换的类</p> 
<p>–可以定义平移、旋转、缩放的矩阵；</p> 
<p>–可以对称于一个点，一条线，一个平面；</p> 
<p>示例一：</p> 
<p>对称于一个点：</p> 
<p>gp_Trsf theTransformation;</p> 
<p>gp_Pnt PntCenterOfTheTransformation(110,60,60);</p> 
<p>theTransformation.SetMirror(PntCenterOfTheTransformation);</p> 
<p>示例二：</p> 
<p>绕一个轴旋转：</p> 
<p>gp_Trsf theTransformation;</p> 
<p>gp_Ax1 axe = gp_Ax1(gp_Pnt(200,60,60),gp_Dir(0.,1.,0.));</p> 
<p>theTransformation.SetRotation(axe,30*PI/180);</p> 
<p>示例三：</p> 
<p>缩放：</p> 
<p>gp_Trsf theTransformation;</p> 
<p>gp_Pnt theCenterOfScale(200,60,60);</p> 
<p>theTransformation.SetScale(theCenterOfScale,0.5);</p> 
<p>示例四：</p> 
<p>平移：</p> 
<p>gp_Trsf theTransformation;</p> 
<p>gp_Vec theVectorOfTranslation(-6,-6,6);</p> 
<p>theTransformation.SetTranslation(theVectorOfTranslation);</p> 
<p>示例五：</p> 
<p>Displacement：</p> 
<p>TopoDS_Shape S = BRepPrimAPI_MakeWedge(60.,100.,80.,20.);</p> 
<p>gp_Trsf theTransformation;</p> 
<p>gp_Ax3 ax3_1(gp_Pnt(0,0,0),gp_Dir(0,0,1));</p> 
<p>gp_Ax3 ax3_2(gp_Pnt(60,60,60),gp_Dir(1,1,1));</p> 
<p>theTransformation.SetDisplacement(ax3_1,ax3_2);</p> 
<p>BRepBuilderAPI_Transform myBRepTransformation(S,theTransformation);</p> 
<p>TopoDS_Shape TransformedShape = myBRepTransformation.Shape();</p> 
<p>示例六：</p> 
<p>变形</p> 
<p>gp_GTrsf theTransformation;</p> 
<p>gp_Mat rot(1, 0, 0, 0, 0.5, 0, 0, 0, 1.5);</p> 
<p>theTransformation.SetVectorialPart(rot);</p> 
<p>theTransformation.SetTranslationPart(gp_XYZ(5,5,5));</p> 
<p>BRepBuilderAPI_GTransform myBRepTransformation(S,theTransformation);</p> 
<p>TopoDS_Shape S2 = myBRepTransformation.Shape();</p> 
<p>BuilderAPI_MakeEdge类</p> 
<p>定义一生成一个边；此类有多个构造函数，现举其中一个介绍如下：</p> 
<p>Standard_EXPORT BRepBuilderAPI_MakeEdge(const Handle(Geom2d_Curve)&amp; L,const Handle(Geom_Surface)&amp; S,const TopoDS_Vertex&amp; V1,const TopoDS_Vertex&amp; V2,const Standard_Real p1,const Standard_Real p2);</p> 
<p>其参数含义是：</p> 
<p>顶点V1和V2用来限制曲线（定义边的约束），值p1和p2为顶点的参数；</p> 
<p>曲线可以定义成在一个表面的2D曲线，应用缺省的公差；</p> 
<p>参数规则：</p> 
<p>对于曲线来说：</p> 
<p>–句柄不能为空；</p> 
<p>–如果曲线是一个trimmed曲线，使用基础曲线；</p> 
<p>对于顶点来说：</p> 
<p>–可以为空，表示此参数为无限大；静态方法 Precision::Infinite()用来定义一个无限大的数；</p> 
<p>–两个顶点如果位于同一位置，必须一样，当曲线是封闭时使用相同的顶点；</p> 
<p>对于参数来说：</p> 
<p>–参数为必须在曲线参数范围内，如果曲线是trimmed,使用基础曲线；如果边的条件不满足，返回BRepAPI_ParameterOutOfRange错误；</p> 
<p>–参数值不能相等，如果条件不满足，边无法创建，返回BRepAPI_LineThroughIdenticPoints错误；</p> 
<p>–参数值可以这样给出C-&gt;FirstParameter()</p> 
<p>–如果参数值需要切换，比如第一个顶点的参数为P2，第二个顶点的参数为P1，边的方向可以“reversed”；</p> 
<p>–对于一个周期曲线，值P1和P2可以通过加或减周期来得到；</p> 
<p>–参数值可以无限大，在对应的方向上边是开放的。然而，对应的顶点必须是空图形，如果条件不满足，边无法创建，返回BRepAPI_PointWithInfiniteParameter错误；</p> 
<p>–参数值可以被忽略，将通过曲线上的投影进行计算；</p> 
<p>–可以给定空间三维点；</p> 
<p>BRepFeat_MakePipe类</p> 
<p>基类为：BRepFeat_Form；</p> 
<p>通过基本图形生成一个Pipe;</p> 
<p>BRepFeat_MakeLinearForm 类</p> 
<p>基类为：BRepFeat_RibSlot</p> 
<p>在一个平面表面上建一个肋或开凹槽；</p> 
<p>BRepFeat_Gluer类</p> 
<p>粘合两个实体为一个实体；</p> 
<p>示例：</p> 
<p>（1）：创建两个BOX，并找到要粘合的面；</p> 
<p>（2）：创建要粘合的对象：</p> 
<p>BRepFeat_Gluer glue2(S4,S3);</p> 
<p>（3）：用两个面粘合对象；</p> 
<p>glue2.Bind(F4,F3);</p> 
<p>（4）：重新生成对象：</p> 
<p>LocOpe_FindEdges CommonEdges(F4,F3);</p> 
<p>for (CommonEdges.InitIterator(); CommonEdges.More(); CommonEdges.Next())</p> 
<p>glue2.Bind(CommonEdges.EdgeFrom(),CommonEdges.EdgeTo());</p> 
<p>TopoDS_Shape res2 = glue2.Shape();</p> 
<p>myAISContext-&gt;Erase(ais3,Standard_False,Standard_False);</p> 
<p>ais4-&gt;Set(res2);</p> 
<p>myAISContext-&gt;Redisplay(ais4,Standard_False);</p> 
<p>Graphic2d_Polyline类</p> 
<p>创建一个多边形．</p> 
<p>常见方法：</p> 
<p>–Length()得到线的点数；</p> 
<p>–void Values(const Standard_Integer aRank,Quantity_Length&amp; X,Quantity_Length&amp; Y) const;得到序号为aRank的点；</p> 
<p>–void DrawElement(const Handle(Graphic2d_Drawer)&amp; aDrawer,const Standard_Integer anIndex) ;绘制多边形的一条边；</p> 
<p>–void DrawVertex(const Handle(Graphic2d_Drawer)&amp; aDrawer,const Standard_Integer anIndex) ;绘制多边形的一个顶点；</p> 
<p>–Standard_Boolean Pick(const Standard_ShortReal X,const Standard_ShortReal Y,const Standard_ShortReal aPrecision,const Handle(Graphic2d_Drawer)&amp; aDrawer) ;得到此多边形是否被拾取，注意：PickIndex()方法得到的是最后拾取的点，如果拾取点在线的内部，返回０；</p> 
<p>Graphic2d_Line类</p> 
<p>是Polyline, Circle … 等图元的基类；</p> 
<p>常见方法：</p> 
<p>–SetWidthIndex(const Standard_Integer anIndex) ;得到在width map中的宽度的索引；设定对应的线宽值；</p> 
<p>–SetTypeIndex(const Standard_Integer anIndex) ;设置线型；</p> 
<p>–SetInteriorColorIndex(const Standard_Integer anIndex) ;设置颜色；</p> 
<p>–void SetDrawEdge(const Standard_Boolean aDraw) ;设置边是否绘出，注意，这种情况下，polygon的类型必须为：</p> 
<p>Graphic2d_TOPF_FILLED 或者 Graphic2d_TOPF_PATTERNED；</p> 
<p>–SetInteriorPattern(const Standard_Integer anIndex) ;定义封闭线的内部图案，polygon的填充类型必须是：Graphic2d_TOPF_PATTERNED；</p> 
<p>–SetTypeOfPolygonFilling(const Graphic2d_TypeOfPolygonFilling aType) ;定义封闭线的图案，TypeOfPolygonFilling可选类型有：</p> 
<ul><li>Graphic2d_TOPF_EMPTY - Graphic2d_TOPF_FILLED - Graphic2d_TOPF_PATTERNED ；</li></ul> 
<p>–Standard_Integer InteriorColorIndex() const;得到颜色索引；</p> 
<p>–Standard_Integer InteriorPattern() const;得到所使用的图案索引；</p> 
<p>–Graphic2d_TypeOfPolygonFilling TypeOfPolygonFilling() const;得到多边形填充模式；</p> 
<p>Graphic2d_Primitive类</p> 
<p>是Graphic2d_Line类的基类，</p> 
<p>常见方法：</p> 
<p>–得到及获取颜色索引；</p> 
<p>–得到图元元素的数量和顶点的数量：</p> 
<p>Standard_Integer NumOfElemIndices() const;</p> 
<p>Standard_Integer NumOfVertIndices() const;</p> 
<p>–Standard_Integer PickedIndex() const;得到最后拾取的图元元素的索引值；</p> 
<p>–void Highlight(const Standard_Integer anIndex = 0) ;高亮显示图元或图元的一部分，当anIndex＝０表示所有的图元高亮显示，&gt;0为当所要求的图元元素高亮显示时，&lt;0为所要求的顶点高亮显示时；</p> 
<p>–void Unhighlight() ;禁止图元高亮显示；</p> 
<p>– Standard_Boolean IsHighlighted() const;图元是否高亮显示；</p> 
<p>–Handle_TColStd_HSequenceOfInteger HighlightIndices() const;得到图元高亮显示的索引序列；</p> 
<p>–void SetDisplayMode(const Standard_Integer aMode) ;设置图元显示的模式；</p> 
<p>–Standard_Integer DisplayMode() const;得到图元显示的模式；</p> 
<p>–Standard_Boolean Graphic2d_GraphicObject::Pick(const Standard_Real X,const Standard_Real Y,const Standard_Real aPrecision,const Handle(Graphic2d_Drawer)&amp; aDrawer) ;</p> 
<p>用一个矩形框拾取图形对象，如果图形对象被拾取，返回为真，通过方法Graphic2d_View::Pick调用；</p> 
<p>–Standard_Boolean Graphic2d_GraphicObject::PickByCircle(const Standard_Real X,const Standard_Real Y,const Standard_Real Radius,const Handle(Graphic2d_Drawer)&amp; aDrawer) ;</p> 
<p>用一个园来拾取图形对象，如果图形对象被拾取，返回为真，通过方法Graphic2d_View::PickByCircle调用；</p> 
<p>–Standard_Boolean Graphic2d_GraphicObject::Pick(const Standard_Real Xmin,const Standard_Real Ymin,const Standard_Real Xmax,const Standard_Real Ymax,const Handle(Graphic2d_Drawer)&amp; aDrawer,const Graphic2d_PickMode aPickMode) ;</p> 
<p>以下情况下返回值为真：</p> 
<p>包括在矩形内：included in rectangle (),</p> 
<p>不在矩形内：excluded from rectangle (),</p> 
<p>相交于矩形框：intersected by rectangle (),</p> 
<p>通过 Xmin, Ymin, Xmax, Ymax定义矩形框。</p> 
<p>–得到所有在图元内的markers的最小最大值，注意，如果me为空，或未显示，或没有markers返回为假，</p> 
<p>Minx = Miny = RealFirst () ；Maxx = Maxy = RealLast ()</p> 
<p>Standard_EXPORT Standard_Boolean Graphic2d_GraphicObject::MarkerMinMax(Quantity_Length&amp; Minx,Quantity_Length&amp; Maxx,Quantity_Length&amp; Miny,Quantity_Length&amp; Maxy) const;</p> 
<p>–移除图元；Standard_EXPORT void Graphic2d_GraphicObject::RemovePrimitive(const Handle(Graphic2d_Primitive)&amp; aPrimitive) ;</p> 
<p>–绘制图元，以默认的图元属性绘制；void Graphic2d_TransientManager::Draw(const Handle(Graphic2d_Primitive)&amp; aPrimitive) ;</p> 
<p>AIS2D_InteractiveObject类</p> 
<p>使用显示和选择服务，来可视化和选择机制，交互式对象常用来显示数据，曲线，图形，markers,尺寸标注等。</p> 
<p>常用方法：</p> 
<p>–获取及设置属性</p> 
<p>Handle_Prs2d_Drawer Attributes() const;</p> 
<p>void SetAttributes(const Handle(Prs2d_Drawer)&amp; aDrawer) ;</p> 
<p>–通过Aspect设置属性，到所有图元分配这个Aspect.</p> 
<p>Standard_EXPORT void SetAspect(const Handle(Prs2d_AspectRoot)&amp; anAspect) ;</p> 
<p>–通过Aspect设置属性,到所有通过InteractiveContext被链接的图元对象；</p> 
<p>Standard_EXPORT void SetAspect(const Handle(Prs2d_AspectRoot)&amp; anAspect,const Handle(Graphic2d_Primitive)&amp; aPrimitive) ;</p> 
<p>–得到图元的Aspect;</p> 
<p>Standard_EXPORT Handle_Prs2d_AspectRoot GetAspect(const Handle(Graphic2d_Primitive)&amp; aPrimitive) const;</p> 
<p>–如果图元用一个aspect链接的话返回为真；</p> 
<p>Standard_EXPORT Standard_Boolean HasAspect(const Handle(Graphic2d_Primitive)&amp; aPrimitive) const;</p> 
<p>–指出交互对象是否有一个交互上下文设备；</p> 
<p>Standard_EXPORT Standard_Boolean HasInteractiveContext() const;</p> 
<p>–得到交互对象的上下文设备；</p> 
<p>Standard_EXPORT Handle_AIS2D_InteractiveContext GetContext() const;</p> 
<p>Graphic2d_GraphicObject类</p> 
<p>是AIS2D_InteractiveObject类的基类；在一个view内创建一个图形对象，一个图形对象管理一系列图元；默认值为：空，可输出，可绘制，可拾取，不显示，不高亮，优先权为０；</p> 
<p>主要方法：</p> 
<p>设置视图，设置一个变形，设置获取图层，设置获取优先权，禁用/使用输出，是否可输出，禁用/使用Draw.是否可显示，Erase，高亮显示，颜色，拾取等；</p> 
<p>Graphic2d_ImageFile类</p> 
<p>定义一个图像，以图像的中心位置作为插入点，Ｘ，Ｙ定义在模型空间的位置，adx,ady 定义在设备空间的偏移量.ascale定义一个缩放系数；</p> 
<p>Aspect_WidthMap类</p> 
<p>定义一个WidthMap集合对象；</p> 
<p>主要方法有，</p> 
<p>–添加一个入口：</p> 
<p>Standard_Integer AddEntry(const Aspect_WidthOfLine aStyle) ;</p> 
<p>void AddEntry(const Aspect_WidthMapEntry&amp; AnEntry) ;</p> 
<p>Standard_Integer AddEntry(const Quantity_Length aStyle) ;</p> 
<p>–根据索引得到一个入口：</p> 
<p>Aspect_WidthMapEntry Entry(const Standard_Integer AnIndex) const;</p> 
<p>示例：</p> 
<p>–定义private :</p> 
<p>Handle(Aspect_WidthMap) myWidthMap;</p> 
<p>–遍历：</p> 
<p>for(int i =1;i&lt;=myWidthMap-&gt;Size();i++)</p> 
<p>{<!-- --></p> 
<p>Aspect_WidthMapEntry aWidthMapEntry = myWidthMap-&gt;Entry(i);</p> 
<p>}</p> 
<p>–得到一个入口： Aspect_WidthMapEntry aWidthMapEntry = myWidthMap-&gt;Entry(CurrentSelectionIndex);</p> 
<p>Aspect_TypeMap类</p> 
<p>定义一个线型集合对象：</p> 
<p>Aspect_MarkMap类</p> 
<p>定义一个MarkMap集合对象；</p> 
<p>Aspect_FontMap类</p> 
<p>定义一个字体集合对象；</p> 
<p>Aspect_ColorMap类</p> 
<p>定义一个颜色集合对象；</p> 
<p>GGraphic2d_SetOfCurves类</p> 
<p>基类是：Graphic2d_Line；</p> 
<p>定义一图元为由多个curves 的集合；主要方法有添加一个curves, 得到curves的数量，得到其中一个curves等；只绘制其中一个元素，是否为拾取状态；</p> 
<p>示例：</p> 
<p>Handle(Prs2d_AspectLine) aLineAspect = new Prs2d_AspectLine;</p> 
<p>aLineAspect-&gt;SetTypeOfFill(Graphic2d_TOPF_EMPTY);</p> 
<p>aLineAspect-&gt;SetTypeIndex(…);</p> 
<p>aLineAspect-&gt;SetColorIndex(…);</p> 
<p>aLineAspect-&gt;SetWidthIndex(…);</p> 
<p>Handle(Graphic2d_SetOfCurves) segment;</p> 
<p>segment = new Graphic2d_SetOfCurves(this);</p> 
<p>segment-&gt;Add(myGeom2dCurve);</p> 
<p>将此曲线集合应用所定义的线型线宽等；</p> 
<p>SetAspect(aLineAspect, segment);</p> 
<p>创建交互式对象相关的类介绍</p> 
<p>AIS_Line</p> 
<p>此类的继承关系是：</p> 
<p>Standard_Transient-&gt;MMgt_TShared-&gt;PrsMgr_PresentableObject–&gt;SelectMgr_SelectableObject–&gt;AIS_InteractiveObject－&gt;AIS_Line</p> 
<p>Standard_Transient:抽象类，主要定义分配空间，得到类型，引用计数等；</p> 
<p>MMgt_TShared：抽象类，主要用来管理对象的内存；</p> 
<p>PrsMgr_PresentableObject类：表示一个可表达的二维或三维图形对象；主要方法有设置位置，更新，图形类型等；</p> 
<p>此类的派生类类型有：</p> 
<p>-AIS_InteractiveObject</p> 
<p>-AIS_ConnectedInteractive</p> 
<p>-AIS_MultipleConnectedInteractive</p> 
<p>-AIS_Shape</p> 
<p>SelectMgr_SelectableObject类：表示一个可选择的对象；</p> 
<p>AIS_Line，AIS_Circle等类</p> 
<p>定义一个直线，园等；主要方法有，返回对象的类型，设置线宽，线型，颜色等；</p> 
<p>示例：</p> 
<p>GC_MakeCircle C(gp_Pnt(-100.,-300.,0.),gp_Pnt(-50.,-200.,0.),gp_Pnt(-10.,-250.,0.));</p> 
<p>Handle(AIS_Circle) anAISCirc = new AIS_Circle(C.Value());</p> 
<p>myAISContext-&gt;Display(anAISCirc);</p> 
<p>AIS_InteractiveContext类</p> 
<p>交互式设备类，可以用它来管理交互式图形对象，可以在一个或多个视图中。如果图形对象已经装入交互式设备，可以直接调用交互式对象的方法。</p> 
<p>使用设备时必须区分两种状态：</p> 
<p>－没有打开本地设备。也称为不确定点；</p> 
<p>－打开了一个或多个设备；</p> 
<p>有的方法可以使用在打开的设备中，有的方法用在关闭的设备中，有的方法与设备状态无关；</p> 
<p>–当想工作在一个入口类型上，应设置选项UseDisplayedObjects为假，可显示对象可以重新可视化交互对象；</p> 
<p>–当使用缺省的选项来打开一个设备时，注意：</p> 
<p>：可视化的交互对象在缺省选择模式下是活动的，必须分离那些不想使用的对象；</p> 
<p>：交互式对象可以自动分解为子图形；</p> 
<p>：“临时的”交互对象不会自动计入总数，，如果想使用它，必须手动装载它；</p> 
<p>使用过程是：</p> 
<p>－－用正确的选项打开设备；</p> 
<p>－－装载／显示对象；</p> 
<p>－－如果需要，激活标准模式；</p> 
<p>－－创建一个过滤器，添加到设备中；</p> 
<p>－－查找／选择／重置所需的入口；</p> 
<p>－－根据索引关闭设备；</p> 
<p>－－创建一个交互设备编辑器很有用，可以设置不同的设备用不用的选择／表达方式；</p> 
<p>常见方法：</p> 
<p>–如果没有设备打开，交互对象没有显示模式，缺省的显示模式是０，如果一个设备是打开的并且更新为假，对象不会更新显示。</p> 
<p>void Display(const Handle(AIS_InteractiveObject)&amp; anIobj,const Standard_Integer amode,const Standard_Integer</p> 
<p>aSelectionMode,const Standard_Boolean updateviewer = Standard_True,const Standard_Boolean allowdecomposition =</p> 
<p>Standard_True) ;</p> 
<p>–使用给定的选择模式载入一个交互对象：</p> 
<p>void Load(const Handle(AIS_InteractiveObject)&amp; aniobj,const Standard_Integer SelectionMode = -1,const Standard_Boolean</p> 
<p>AllowDecomp = Standard_False) ;</p> 
<p>–擦除一个对象：如果putinCollector为假，对象被擦除但不放入集合中；</p> 
<p>void Erase(const Handle(AIS_InteractiveObject)&amp; aniobj,const Standard_Boolean updateviewer = Standard_True,const</p> 
<p>Standard_Boolean PutInCollector = Standard_True) ;</p> 
<p>–擦除视图集合中的每个对象；</p> 
<p>void EraseAll(const Standard_Boolean PutInCollector = Standard_True,const Standard_Boolean updateviewer = Standard_True) ；</p> 
<p>–从集合中显示所有对象；</p> 
<p>void DisplayAll(const Standard_Boolean OnlyFromCollector = Standard_True,const Standard_Boolean updateviewer =</p> 
<p>Standard_True) ;</p> 
<p>–从集合中显示一个对象；</p> 
<p>void DisplayFromCollector(const Handle(AIS_InteractiveObject)&amp; anIObj,const Standard_Boolean updateviewer = Standard_True)</p> 
<p>–擦除选择的对象；</p> 
<p>void EraseSelected(const Standard_Boolean PutInCollector = Standard_True,const Standard_Boolean updateviewer =</p> 
<p>Standard_True) ;</p> 
<p>–改变临时对象的状态，</p> 
<p>Standard_Boolean KeepTemporary(const Handle(AIS_InteractiveObject)&amp; anIObj,const Standard_Integer InWhichLocal = -1) ;</p> 
<p>–从所有的视图中移除交互对象；</p> 
<p>void Clear(const Handle(AIS_InteractiveObject)&amp; aniobj,const Standard_Boolean updateviewer = Standard_True) ;</p> 
<p>–从每个视图中移除对象；</p> 
<p>void Remove(const Handle(AIS_InteractiveObject)&amp; aniobj,const Standard_Boolean updateviewer = Standard_True) ;</p> 
<p>–从所有打开的设备中移除所有对象；</p> 
<p>void RemoveAll(const Standard_Boolean updateviewer = Standard_True) ;</p> 
<p>–通过鼠标动态检测，感知的图元被高亮显示。缺省的鼠标移过时的颜色为白色。</p> 
<p>void Hilight(const Handle(AIS_InteractiveObject)&amp; aniobj,const Standard_Boolean updateviewer = Standard_True) ;</p> 
<p>–改变视图中线的颜色；</p> 
<p>void HilightWithColor(const Handle(AIS_InteractiveObject)&amp; aniobj,const Quantity_NameOfColor aCol,const Standard_Boolean updateviewer = Standard_True) ;</p> 
<p>–从入口对象中移除高亮；更新视图；</p> 
<p>void Unhilight(const Handle(AIS_InteractiveObject)&amp; aniobj,const Standard_Boolean updateviewer = Standard_True) ;</p> 
<p>–设置显示的优先权；</p> 
<p>void SetDisplayPriority(const Handle(AIS_InteractiveObject)&amp; anIobj,const Standard_Integer aPriority) ;</p> 
<p>–设置所看到的交互对象的显示模式；</p> 
<p>void SetDisplayMode(const Handle(AIS_InteractiveObject)&amp; aniobj,const Standard_Integer aMode,const Standard_Boolean</p> 
<p>updateviewer = Standard_True) ;</p> 
<p>–设置/移除交互对象的选择模式：</p> 
<p>void SetSelectionMode(const Handle(AIS_InteractiveObject)&amp; aniobj,const Standard_Integer aMode) ;</p> 
<p>void UnsetSelectionMode(const Handle(AIS_InteractiveObject)&amp; aniobj) ;</p> 
<p>–设置感知的精度：</p> 
<p>void SetSensitivity(const Standard_Real aPrecision) ;</p> 
<p>–定义当前选择感知的像素：</p> 
<p>void SetSensitivity(const Standard_Integer aPrecision = 4) ;</p> 
<p>–设置/重置初始图形的位置；如果有一个位置返回为真；</p> 
<p>void SetLocation(const Handle(AIS_InteractiveObject)&amp; aniobj,const TopLoc_Location&amp; aLocation) ;</p> 
<p>void ResetLocation(const Handle(AIS_InteractiveObject)&amp; aniobj) ;</p> 
<p>Standard_Boolean HasLocation(const Handle(AIS_InteractiveObject)&amp; aniobj) const;</p> 
<p>得到实体对象的位置；</p> 
<p>const TopLoc_Location&amp; Location(const Handle(AIS_InteractiveObject)&amp; aniobj) const;</p> 
<p>–改变当前面的模式；缺省模式是Aspect_TOFM_TWO_SIDE。意味着属性在前面和后面都应用；</p> 
<p>void SetCurrentFacingModel(const Handle(AIS_InteractiveObject)&amp; aniobj,const Aspect_TypeOfFacingModel aModel =</p> 
<p>Aspect_TOFM_BOTH_SIDE) ;</p> 
<p>–设置／获得三角形的尺寸，缺省值是１００mm.</p> 
<p>void SetTrihedronSize(const Standard_Real aSize,const Standard_Boolean updateviewer = Standard_True) ;</p> 
<p>Standard_Real TrihedronSize() const;</p> 
<p>–设置／获取平面的尺寸：</p> 
<p>Standard_EXPORT void SetPlaneSize(const Standard_Real aSizeX,const Standard_Real aSizeY,const Standard_Boolean</p> 
<p>updateviewer = Standard_True) ;</p> 
<p>–得到实体对象的显示状态；</p> 
<p>AIS_DisplayStatus DisplayStatus(const Handle(AIS_InteractiveObject)&amp; anIobj) const;</p> 
<p>–得到实体对象的显示模式的列表：</p> 
<p>const TColStd_ListOfInteger&amp; DisplayedModes(const Handle(AIS_InteractiveObject)&amp; aniobj) const;</p> 
<p>–关于绘制隐藏线相关的一些函数，通过名称就可以知道函数的意思；</p> 
<p>EnableDrawHiddenLine（）；</p> 
<p>DisableDrawHiddenLine（）；</p> 
<p>Standard_Boolean DrawHiddenLine()；</p> 
<p>–设置／得到ＵＶ等高参数；等高参数是否可用；</p> 
<p>Standard_Integer IsoNumber(const AIS_TypeOfIso WhichIsos = AIS_TOI_Both) ;</p> 
<p>–设置／添加／移除当前对象…</p> 
<p>InitCurrent() ;MoreCurrent();NextCurrent();</p> 
<p>Standard_Boolean IsCurrent(const Handle(AIS_InteractiveObject)&amp; aniobj) const;</p> 
<p>Handle_AIS_InteractiveObject Current() const;</p> 
<p>Handle_AIS_InteractiveObject FirstCurrentObject() ;</p> 
<p>void HilightCurrents(const Standard_Boolean updateviewer = Standard_True) ;</p> 
<p>void UnhilightCurrents(const Standard_Boolean updateviewer = Standard_True) ;</p> 
<p>void ClearCurrents(const Standard_Boolean updateviewer = Standard_True) ;</p> 
<p>标签: OpenCASCADE, 3d<br> 好文要顶 关注我 收藏该文<br> 一花一世界,一叶一乾坤<br> 关注 - 86<br> 粉丝 - 59<br> +加关注<br> 0 0<br> « 上一篇： Boost format<br> » 下一篇： Open CASCADE 基础类(Foundation Classes)<br> posted @ 2016-12-26 16:56 一花一世界,一叶一乾坤 阅读(6330) 评论(0) 编辑 收藏<br> 刷新评论刷新页面返回顶部<br> 注册用户登录后才能发表评论，请 登录 或 注册， 访问 网站首页。<br> 【推荐】超50万行VC++源码: 大型组态工控、电力仿真CAD与GIS源码库<br> 【推荐】1200件T恤+6万奖金，阿里云编程大赛报名开启<br> 【推荐】未知数的距离，毫秒间的传递，声网与你实时互动<br> 【推荐】了不起的开发者，挡不住的华为，园子里的品牌专区<br> 【推荐】如何在面试中成长？来看阿里前端终面官的面试心得</p> 
<p>相关博文：<br> · Render OpenCascade Geometry Surfaces in OpenSceneGraph<br> · OpenCascade Shape Representation in OpenSceneGraph<br> · OpenCASCADE构造一般曲面<br> · Delaunay Triangulation in OpenCascade<br> · Topology and Geometry in OpenCascade-Topology<br> » 更多推荐…<br> 最新 IT 新闻:<br> · 韩国的“5G领先”故事也讲不下去了<br> · 一个富士康打工妹 十年逆袭成了市值千亿的苹果代工厂老板<br> · 隐秘“娃圈”：一个“成品娃”拍出22万元天价<br> · 美团市值破2000亿美元 王兴：我们本质是家移动公司<br> · 如何成为理论学家中的理论学家？<br> » 更多新闻…<br> 喜欢请用微信打赏</p> 
<p>喜欢请用支付宝打赏</p> 
<p>昵称： 一花一世界,一叶一乾坤<br> 园龄： 8年1个月<br> 粉丝： 59<br> 关注： 86<br> +加关注<br> &lt; 2020年8月 &gt;<br> 日 一 二 三 四 五 六<br> 26 27 28 29 30 31 1<br> 2 3 4 5 6 7 8<br> 9 10 11 12 13 14 15<br> 16 17 18 19 20 21 22<br> 23 24 25 26 27 28 29<br> 30 31 1 2 3 4 5<br> 搜索</p> 
<p>常用链接<br> 我的随笔<br> 我的评论<br> 我的参与<br> 最新评论<br> 我的标签<br> 我的标签<br> iOS(24)<br> Python(19)<br> Math(18)<br> C++(12)<br> Blender(8)<br> Boost(6)<br> OpenCASCADE(6)<br> Swift 学习笔记(6)<br> osg(5)<br> 学习笔记(5)<br> 更多<br> 随笔档案<br> 2020年8月(2)<br> 2020年5月(5)<br> 2020年4月(4)<br> 2020年3月(10)<br> 2019年6月(2)<br> 2019年5月(5)<br> 2018年12月(3)<br> 2018年11月(1)<br> 2018年10月(1)<br> 2018年9月(1)<br> 2018年8月(2)<br> 2018年7月(7)<br> 2018年5月(2)<br> 2018年3月(1)<br> 2018年2月(1)<br> 2018年1月(1)<br> 2017年9月(6)<br> 2017年8月(3)<br> 2017年7月(1)<br> 2017年6月(2)<br> 2017年5月(3)<br> 2017年4月(7)<br> 2017年3月(1)<br> 2017年2月(8)<br> 2017年1月(2)<br> 2016年12月(9)<br> 2016年11月(2)<br> 2016年9月(1)<br> 2016年8月(4)<br> 2016年6月(1)<br> 2016年5月(1)<br> 2016年4月(1)<br> 2015年10月(1)<br> 2015年8月(1)<br> 2015年7月(1)<br> 2015年5月(1)<br> 2015年4月(2)<br> 2015年3月(1)<br> 2014年11月(1)<br> 2014年10月(3)<br> 2014年8月(5)<br> 2014年7月(6)<br> 2014年6月(10)<br> 2014年5月(3)<br> 2014年4月(4)<br> 最新评论</p> 
<ol><li>Re:PyQt5.9 Html与本地代码交互实例<br> @翔少 这个调用就有意思了…<br> –清风止水</li><li>Re:Mac OS X10.9安装的Python2.7升级Python3.4步骤详解<br> 更新到python3.8sudo rm /usr/local/bin/pythonsudo rm /usr/bin/pipsudo rm /usr/bin/pythonsudo rm /usr/bin…<br> –一花一世界,一叶一乾坤</li><li>Re:PyQt5.9 Html与本地代码交互实例<br> @ 一花一世界,一叶一乾坤 你html的调用方式有些问题！所以弹不出来。 window.onload = function () { new QWebChannel(qt.webChannelTran…<br> –翔少</li><li>Re:PyQt5.9 Html与本地代码交互实例<br> @ kxdd我使用的是Python3.6.2 + PyQt5.9.3, 注意要点还要注意:1. url_string = "file:///D:/qt5/201709/webengine/test.h…<br> –一花一世界,一叶一乾坤</li><li>Re:PyQt5.9 Html与本地代码交互实例<br> 同样，没有返回值返回，是调用的不对还是pyqt的bug？<br> –kxdd<br> 阅读排行榜</li><li>OpenCASCADE 基础(6329)</li><li>PyQt5.9 Html与本地代码交互实例(4847)</li><li>软件需求规范说明 (Software Requirements Specification, 简称SRS)(4706)</li><li>Qt5.9 WebEngine 概述(4520)</li><li>PyQt5信号-槽机制(4388)<br> 评论排行榜</li><li>PyQt5.9 Html与本地代码交互实例(4)</li><li>Mac OS X10.9安装的Python2.7升级Python3.4步骤详解(1)</li><li>Win7 + VS2015 + CMake3.6.1-GUI + Makefile 编译开源库(1)<br> 推荐排行榜</li><li>iOS: performSelectorOnMainThread(译)(1)</li><li>Win7 + VS2015 + Python3.6编译(1)</li><li>Win7 + VS2015 + CMake3.6.1-GUI + Makefile 编译开源库(1)</li><li>公路工程三维坐标系研究(1)<br> Copyright © 2020 一花一世界,一叶一乾坤<br> Powered by .NET Core on Kubernetes</li></ol> 
<p>返回主页<br> 大师之路<br> 千淘万漉虽辛苦，吹尽狂沙始到金。<br> 博客园 首页 新随笔 联系 管理 订阅订阅 随笔- 139 文章- 0 评论- 6<br> Open CASCADE 基础类(Foundation Classes)<br> 1 介绍(Introduction) 1<br> 如何使用Open CASCADE技术(OCCT)基础类.</p> 
<p>This manual explains how to use Open CASCADE Technology (OCCT) Foundation Classes. It provides basic<br> documentation on foundation classes. For advanced information on foundation classes and their applications, see<br> our E-learning &amp; Training offerings.</p> 
<p>基础类提供了常规目的服务如动态内存管理(由handle管理), 集合, 异常处理, 常规转换, 插件生成.<br> Foundation Classes provide a variety of general-purpose services such as automated dynamic memory management<br> (manipulation of objects by handle), collections, exception handling, genericity by down-casting and plug-in<br> creation.</p> 
<p>基础类包括: Foundation Classes include the following:</p> 
<p>基类 Root Classes (其它数据类型和类的根基)<br> Root classes are the basic data types and classes on which all the other classes are built. They provide:<br> • fundamental types such as Boolean, Character, Integer or Real,<br> • safe handling of dynamically created objects, ensuring automatic deletion of unreferenced objects (see<br> Standard_Transient class),<br> • configurable optimized memory manager increasing the performance of applications that intensively use dynamically created objects,<br> • extended run-time type information (RTTI) mechanism facilitating the creation of complex programs,<br> • management of exceptions,<br> • encapsulation of C++ streams. Root classes are mainly implemented in Standard and MMgt packages.</p> 
<p>字符串 Strings<br> Strings are implemented in the TCollection package.</p> 
<p>集合 Collections<br> 集合处理动态增长的聚合数据 Collections are the classes that handle dynamically sized aggregates of data.</p> 
<p>Collections include a wide range of generic classes such as run-time sized arrays, lists, stacks, queues, sets and<br> hash maps. Collections are implemented in the TCollection and NCollection packages.</p> 
<p>标准对象集合 Collections of Standard Objects<br> The TColStd package provides frequently used instantiations of generic classes from the TCollection package with<br> objects from the Standard package or strings from the TCollection package.</p> 
<p>向量和矩阵 Vectors and Matrices<br> 它们提供了常用数学算法和基础计算(加, 乘, 平移, 反转)</p> 
<p>These classes provide commonly used mathematical algorithms and basic calculations (addition, multiplication,<br> transposition, inversion, etc.) involving vectors and matrices.</p> 
<p>原始几何类型 Primitive Geometric Types<br> Open CASCADE Technology primitive geometric types are a STEP-compliant implementation of basic geometric<br> and algebraic entities. They provide:<br> • Descriptions of elementary geometric shapes:<br> • Points,<br> • Vectors,<br> • Lines,<br> • Circles and conics,<br> • Planes and elementary surfaces,<br> • Positioning of these shapes in space or in a plane by means of an axis or a coordinate system,<br> • Definition and application of geometric transformations to these shapes:<br> • Translations<br> • Rotations<br> • Symmetries<br> • Scaling transformations<br> • Composed transformations<br> • Tools (coordinates and matrices) for algebraic computation.</p> 
<p>Common Math Algorithms<br> Open CASCADE Technology common math algorithms provide a C++ implementation of the most frequently used<br> mathematical algorithms. These include:<br> • Algorithms to solve a set of linear algebraic equations,<br> • Algorithms to find the minimum of a function of one or more independent variables,<br> • Algorithms to find roots of one, or of a set, of non-linear equations,<br> • Algorithms to find the eigen-values and eigen-vectors of a square matrix.</p> 
<p>Exceptions<br> A hierarchy of commonly used exception classes is provided, all based on class Failure, the root of exceptions.<br> Exceptions describe exceptional situations, which can arise during the execution of a function. With the raising of<br> an exception, the normal course of program execution is abandoned. The execution of actions in response to this<br> situation is called the treatment of the exception.</p> 
<p>Quantities<br> These are various classes supporting date and time information and fundamental types representing most physical<br> quantities such as length, area, volume, mass, density, weight, temperature, pressure etc.</p> 
<p>Application services<br> Foundation Classes also include implementation of several low-level services that facilitate the creation of customizable<br> and user-friendly applications with Open CASCADE Technology. These include:<br> • Unit conversion tools, providing a uniform mechanism for dealing with quantities and associated physical<br> units: check unit compatibility, perform conversions of values between different units and so on (see package<br> UnitsAPI);<br> • Basic interpreter of expressions that facilitates the creation of customized scripting tools, generic definition of<br> expressions and so on (see package ExprIntrp);<br> • Tools for dealing with configuration resource files (see package Resource) and customizable message files<br> (see package Message), making it easy to provide a multi-language support in applications;<br> • Progress indication and user break interfaces, giving a possibility even for low-level algorithms to communicate<br> with the user in a universal and convenient way.</p> 
<p>2 基础(Basics) 3<br> This chapter deals with basic services such as library organization, persistence, data types, memory management,<br> programming with handles, exception handling, genericity by downcasting and plug-in creation.</p> 
<p>2.1 库组织(Library organization) 6</p> 
<p>This chapter introduces some basic concepts, which are used not only in Foundation Classes, but throughout the<br> whole OCCT library.</p> 
<p>2.1.1 模块和工具Modules and toolkits 6</p> 
<p>在物理上, 一个共享库(.so或.dll)表示一个工具箱.</p> 
<p>The whole OCCT library is organized in a set of modules. The first module, providing most basic services and used<br> by all other modules, is called Foundation Classes and described by this manual.<br> Every module consists primarily of one or several toolkits (though it can also contain executables, resource units<br> etc.). Physically a toolkit is represented by a shared library (e.g. .so or .dll). The toolkit is built from one or several<br> packages.</p> 
<p>2.1.2 包 Packages 6</p> 
<p>语义相关的一些类组成一个包. 如: 一个几何包 会包含点,线,圆类.</p> 
<p>通常, 每个类名会有包前缀.</p> 
<p>A package groups together a number of classes which have semantic links. For example, a geometry package<br> would contain Point, Line, and Circle classes. A package can also contain enumerations, exceptions and package<br> methods (functions). In practice, a class name is prefixed with the name of its package e.g. Geom_Circle. Data<br> types described in a package may include one or more of the following data types:<br> • Enumerations<br> • Object classes<br> • Exceptions<br> • Pointers to other object classes Inside a package, two data types cannot bear the same name.</p> 
<p>image</p> 
<p>2.1.3 类 Classes 7<br> 2.1.4 继承 Inheritance 8<br> 2.2 数据类型 Data Types 8</p> 
<p>在OCCT中, Handles能安全的操作动态对象内存分配与释放.</p> 
<p>A variable of a type manipulated by handle which is not attached to an object is said to be null. To reference an<br> object, we instantiate the class with one of its constructors. For example, in C++:</p> 
<p>Handle(myClass) m = new myClass;</p> 
<p>In Open CASCADE Technology, the Handles are specific classes that are used to safely manipulate objects allocated<br> in the dynamic memory by reference, providing reference counting mechanism and automatic destruction of<br> the object when it is not referenced.</p> 
<p>2.2.1 原始类型Primitive Types 9</p> 
<p>Table 1: Equivalence between C++ Types and OCCT Primitive Types<br> C++ Types OCCT Types<br> int Standard_Integer<br> double Standard_Real<br> float Standard_ShortReal<br> unsigned int Standard_Boolean<br> char Standard_Character<br> short Standard_ExtCharacter<br> char* Standard_CString<br> void* Standard_Address<br> short* Standard_ExtString<br> 2.2.2 值类型 Types manipulated by value 10<br> 2.2.3 引用(handle)类型 Types manipulated by reference (handle) 11<br> 2.2.4 什么时候必须用handle When is it necessary to use a handle? 11<br> 2.3 使用Handles Programming with Handles 12</p> 
<p>Class Standard_Transient is a root of a big hierarchy of OCCT classes that are said to be operable by handles.</p> 
<p>Handle(Geom_Line) aLine; // “Handle(Geom_Line)” is expanded to “opencascade::handleL&lt;Geom_Line&gt;”</p> 
<p>In addition, for standard OCCT classes additional typedef is defined for a handle, as the name of a class prefixed<br> by Handle_. For instance, the above example can be also coded as:</p> 
<p>Handle_Geom_Line aLine; // “Handle_Geom_Line” is typedef to “opencascade::handleL&lt;Geom_Line&gt;”</p> 
<p>2.3.1 Handle定义 Handle Definition 12<br> 2.3.2 类型管理 Type Management 12<br> 2.3.3 使用Handles创建对象 Using Handles to Create Objects 14<br> 2.3.4 调用方法 Invoking Methods 14<br> 2.3.5 Handle释放 Handle deallocation 15<br> 2.3.6 循环引用Cycles 16<br> 2.4 内存管理 Memory Management 16<br> 2.4.1 使用内存管理器 Usage of Memory Manager 16<br> 2.4.2 如何配置内存管理器 How to configure the Memory Manager 16<br> 2.4.3 优化技巧 Optimization Techniques 17<br> 2.4.4 优点和drawbacks Benefits and drawbacks 17<br> 2.5 异常 Exceptions 18<br> 2.5.1 介绍 Introduction 18<br> 2.5.2 抛出异常 Raising an Exception 18<br> 2.5.3 处理异常 Handling an Exception 19<br> 2.5.4 多平台实现 Implementation on various platforms. 21<br> 2.6 插件管理 Plug-In Management 22<br> 2.6.1 插件发布 Distribution by Plug-Ins 22</p> 
<p>3 集合,字符串,数量和单位转换 Collections, Strings, Quantities and Unit Conversion 24<br> 3.1 集合 Collections 24<br> 3.1.1 总览 Overview 24<br> 3.1.2 一般集合 Generic general-purpose Aggregates 24<br> 3.1.3 一般表 Generic Maps 26<br> 3.1.4 遍历 Iterators 29<br> 3.2 标准对象集合 Collections of Standard Objects 29<br> 3.2.1 总览 Overview 30<br> 3.2.2 描述 Description 30<br> 3.3 NCollections 30<br> 3.3.1 Overview 30<br> 3.3.2 Instantiation of collection classes 31<br> 3.3.3 Arrays and sequences 31<br> 3.3.4 Maps 32<br> 3.3.5 Other collection types 32<br> 3.3.6 Features 34<br> 3.4 字符串 Strings 36<br> 3.4.1 示例 Examples 36<br> 3.4.2 约定 Conversion 37<br> 3.5 数量 Quantities 37<br> 3.6 单位转换 Unit Conversion 38</p> 
<p>4 数学基础和算法 Math Primitives and Algorithms 39<br> 4.1 总览 Overview 39<br> 4.2 向量和矩阵 Vectors and Matrices 39<br> 4.3 基础几何类型 Primitive Geometric Types 40<br> 4.4 基础几何类型集合 Collections of Primitive Geometric Types 41<br> 4.5 基本几何库 Basic Geometric Libraries 41<br> 4.6 常用数学算法 Common Math Algorithms 41<br> 4.7 精度 Precision 43<br> 4.7.1 精度包 The Precision package 44<br> 4.7.2 标准精度值 Standard Precision values 44</p> 
<p>好文要顶 关注我 收藏该文<br> 一花一世界,一叶一乾坤<br> 关注 - 86<br> 粉丝 - 59<br> +加关注<br> 0 0<br> « 上一篇： OpenCASCADE 基础<br> » 下一篇： CGAL 介绍<br> posted @ 2016-12-27 16:10 一花一世界,一叶一乾坤 阅读(485) 评论(0) 编辑 收藏<br> 刷新评论刷新页面返回顶部<br> 注册用户登录后才能发表评论，请 登录 或 注册， 访问 网站首页。<br> 【推荐】超50万行VC++源码: 大型组态工控、电力仿真CAD与GIS源码库<br> 【推荐】1200件T恤+6万奖金，阿里云编程大赛报名开启<br> 【推荐】未知数的距离，毫秒间的传递，声网与你实时互动<br> 【推荐】了不起的开发者，挡不住的华为，园子里的品牌专区<br> 【推荐】精品问答：微服务架构 Spring 核心知识 50 问</p> 
<p>相关博文：<br> · Construction of Primitives in Open Cascade<br> · Open Cascade DataExchange IGES<br> · Open Cascade Data Exchange STL<br> · 【原创】开源Math.NET基础数学类库使用(01)综合介绍<br> · 学习C++ -&gt; 类(Classes)的定义与实现<br> » 更多推荐…<br> 最新 IT 新闻:<br> · 韩国的“5G领先”故事也讲不下去了<br> · 一个富士康打工妹 十年逆袭成了市值千亿的苹果代工厂老板<br> · 隐秘“娃圈”：一个“成品娃”拍出22万元天价<br> · 美团市值破2000亿美元 王兴：我们本质是家移动公司<br> · 如何成为理论学家中的理论学家？<br> » 更多新闻…<br> 喜欢请用微信打赏</p> 
<p>喜欢请用支付宝打赏</p> 
<p>昵称： 一花一世界,一叶一乾坤<br> 园龄： 8年1个月<br> 粉丝： 59<br> 关注： 86<br> +加关注<br> &lt; 2020年8月 &gt;<br> 日 一 二 三 四 五 六<br> 26 27 28 29 30 31 1<br> 2 3 4 5 6 7 8<br> 9 10 11 12 13 14 15<br> 16 17 18 19 20 21 22<br> 23 24 25 26 27 28 29<br> 30 31 1 2 3 4 5<br> 搜索</p> 
<p>常用链接<br> 我的随笔<br> 我的评论<br> 我的参与<br> 最新评论<br> 我的标签<br> 我的标签<br> iOS(24)<br> Python(19)<br> Math(18)<br> C++(12)<br> Blender(8)<br> Boost(6)<br> OpenCASCADE(6)<br> Swift 学习笔记(6)<br> osg(5)<br> 学习笔记(5)<br> 更多<br> 随笔档案<br> 2020年8月(2)<br> 2020年5月(5)<br> 2020年4月(4)<br> 2020年3月(10)<br> 2019年6月(2)<br> 2019年5月(5)<br> 2018年12月(3)<br> 2018年11月(1)<br> 2018年10月(1)<br> 2018年9月(1)<br> 2018年8月(2)<br> 2018年7月(7)<br> 2018年5月(2)<br> 2018年3月(1)<br> 2018年2月(1)<br> 2018年1月(1)<br> 2017年9月(6)<br> 2017年8月(3)<br> 2017年7月(1)<br> 2017年6月(2)<br> 2017年5月(3)<br> 2017年4月(7)<br> 2017年3月(1)<br> 2017年2月(8)<br> 2017年1月(2)<br> 2016年12月(9)<br> 2016年11月(2)<br> 2016年9月(1)<br> 2016年8月(4)<br> 2016年6月(1)<br> 2016年5月(1)<br> 2016年4月(1)<br> 2015年10月(1)<br> 2015年8月(1)<br> 2015年7月(1)<br> 2015年5月(1)<br> 2015年4月(2)<br> 2015年3月(1)<br> 2014年11月(1)<br> 2014年10月(3)<br> 2014年8月(5)<br> 2014年7月(6)<br> 2014年6月(10)<br> 2014年5月(3)<br> 2014年4月(4)<br> 最新评论</p> 
<ol><li>Re:PyQt5.9 Html与本地代码交互实例<br> @翔少 这个调用就有意思了…<br> –清风止水</li><li>Re:Mac OS X10.9安装的Python2.7升级Python3.4步骤详解<br> 更新到python3.8sudo rm /usr/local/bin/pythonsudo rm /usr/bin/pipsudo rm /usr/bin/pythonsudo rm /usr/bin…<br> –一花一世界,一叶一乾坤</li><li>Re:PyQt5.9 Html与本地代码交互实例<br> @ 一花一世界,一叶一乾坤 你html的调用方式有些问题！所以弹不出来。 window.onload = function () { new QWebChannel(qt.webChannelTran…<br> –翔少</li><li>Re:PyQt5.9 Html与本地代码交互实例<br> @ kxdd我使用的是Python3.6.2 + PyQt5.9.3, 注意要点还要注意:1. url_string = "file:///D:/qt5/201709/webengine/test.h…<br> –一花一世界,一叶一乾坤</li><li>Re:PyQt5.9 Html与本地代码交互实例<br> 同样，没有返回值返回，是调用的不对还是pyqt的bug？<br> –kxdd<br> 阅读排行榜</li><li>OpenCASCADE 基础(6330)</li><li>PyQt5.9 Html与本地代码交互实例(4847)</li><li>软件需求规范说明 (Software Requirements Specification, 简称SRS)(4706)</li><li>Qt5.9 WebEngine 概述(4522)</li><li>PyQt5信号-槽机制(4388)<br> 评论排行榜</li><li>PyQt5.9 Html与本地代码交互实例(4)</li><li>Mac OS X10.9安装的Python2.7升级Python3.4步骤详解(1)</li><li>Win7 + VS2015 + CMake3.6.1-GUI + Makefile 编译开源库(1)<br> 推荐排行榜</li><li>iOS: performSelectorOnMainThread(译)(1)</li><li>公路工程三维坐标系研究(1)</li><li>Win7 + VS2015 + Python3.6编译(1)</li><li>Win7 + VS2015 + CMake3.6.1-GUI + Makefile 编译开源库(1)<br> Copyright © 2020 一花一世界,一叶一乾坤<br> Powered by .NET Core on Kubernetes</li></ol>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d525be3ee16aa6dbd4cff30c3528a659/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Big Data tools插件连接 &#43; yarn 集群</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9008efdb9eb0978b2e5a1e5698c7d07f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue v-if和v-show的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>