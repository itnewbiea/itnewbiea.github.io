<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Leetcode周赛370补题（3 / 3） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Leetcode周赛370补题（3 / 3）" />
<meta property="og:description" content="目录
1、找到冠军 Ⅰ- 暴力
2、找到冠军 Ⅱ - 寻找入度为0的点
3、在树上执行操作以后得到的最大分数 - dfs树 &#43; 逆向思考
1、找到冠军 Ⅰ- 暴力 100115. 找到冠军 I
class Solution { public int findChampion(int[][] g) { int n=g.length; for(int i=0;i&lt;n;i&#43;&#43;) { int cnt=0; for(int j=0;j&lt;n;j&#43;&#43;) if(g[i][j]==1) cnt&#43;&#43;; if(cnt==n-1) return i; } return 1; } } 2、找到冠军 Ⅱ - 寻找入度为0的点 100116. 找到冠军 II
思路：
我们通过样例发现冠军点的入度肯定为0，假设有多个入度为0的点，是否能判断出谁是冠军？我们画几种情况看看
我们发现如果有多个入度为0的点，则无法判断出冠军，因为冠军并不是由战胜队伍的数量来衡量的，因此我们只需要找入度为0的点，如果有多个则返回-1
简化代码可以标记入度为0的点，然后遍历找出入度为0的点，如果出现多个则返回-1
class Solution { public int findChampion(int n, int[][] edges) { int[] st=new int[n]; for(int[] e:edges) st[e[1]]=1; //将入度不为0的点标记 int res=-1; for(int i=0;i&lt;n;i&#43;&#43;) { if(st[i]==0) { if(res!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6c2a3ab92a8569da3e53bfc77f499fe6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-06T11:46:54+08:00" />
<meta property="article:modified_time" content="2023-11-06T11:46:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Leetcode周赛370补题（3 / 3）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E6%89%BE%E5%88%B0%E5%86%A0%E5%86%9B%20%E2%85%A0-%20%E6%9A%B4%E5%8A%9B-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E6%89%BE%E5%88%B0%E5%86%A0%E5%86%9B%20%E2%85%A0-%20%E6%9A%B4%E5%8A%9B" rel="nofollow">1、找到冠军 Ⅰ- 暴力</a></p> 
<p id="2%E3%80%81%E6%89%BE%E5%88%B0%E5%86%A0%E5%86%9B%20%E2%85%A1%20-%20%E5%AF%BB%E6%89%BE%E5%85%A5%E5%BA%A6%E4%B8%BA0%E7%9A%84%E7%82%B9-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E6%89%BE%E5%88%B0%E5%86%A0%E5%86%9B%20%E2%85%A1%20-%20%E5%AF%BB%E6%89%BE%E5%85%A5%E5%BA%A6%E4%B8%BA0%E7%9A%84%E7%82%B9" rel="nofollow">2、找到冠军 Ⅱ - 寻找入度为0的点</a></p> 
<p id="3%E3%80%81%E5%9C%A8%E6%A0%91%E4%B8%8A%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%90%8E%E5%BE%97%E5%88%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0%20-%20dfs%E6%A0%91%20%2B%20%E9%80%86%E5%90%91%E6%80%9D%E8%80%83-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E5%9C%A8%E6%A0%91%E4%B8%8A%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%90%8E%E5%BE%97%E5%88%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0%20-%20dfs%E6%A0%91%20%2B%20%E9%80%86%E5%90%91%E6%80%9D%E8%80%83" rel="nofollow">3、在树上执行操作以后得到的最大分数 - dfs树 + 逆向思考</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1%E3%80%81%E6%89%BE%E5%88%B0%E5%86%A0%E5%86%9B%20%E2%85%A0-%20%E6%9A%B4%E5%8A%9B">1、找到冠军 Ⅰ- 暴力</h2> 
<p><a href="https://leetcode.cn/problems/find-champion-i/" rel="nofollow" title="100115. 找到冠军 I">100115. 找到冠军 I</a></p> 
<p><img alt="" class="left" height="581" src="https://images2.imgbox.com/fe/08/pfuuHFhE_o.png" width="800"></p> 
<p><img alt="" class="left" height="200" src="https://images2.imgbox.com/d0/10/yP8SBu8f_o.png" width="500"></p> 
<pre><code class="language-java">class Solution {
    public int findChampion(int[][] g) {
        int n=g.length;
        for(int i=0;i&lt;n;i++)
        {
            int cnt=0;
            for(int j=0;j&lt;n;j++)
                if(g[i][j]==1) cnt++;
            if(cnt==n-1) return i;
        }
        return 1;
    }
}</code></pre> 
<p> </p> 
<h2 id="2%E3%80%81%E6%89%BE%E5%88%B0%E5%86%A0%E5%86%9B%20%E2%85%A1%20-%20%E5%AF%BB%E6%89%BE%E5%85%A5%E5%BA%A6%E4%B8%BA0%E7%9A%84%E7%82%B9">2、找到冠军 Ⅱ - 寻找入度为0的点</h2> 
<p><a href="https://leetcode.cn/problems/find-champion-ii/" rel="nofollow" title="100116. 找到冠军 II">100116. 找到冠军 II</a></p> 
<p><img alt="" class="left" height="384" src="https://images2.imgbox.com/99/c0/dTcGrqRr_o.png" width="800"></p> 
<p><img alt="" class="left" height="436" src="https://images2.imgbox.com/83/14/C4ggNERq_o.png" width="500"></p> 
<blockquote> 
 <p><strong>思路：</strong></p> 
 <p>我们通过样例发现冠军点的入度肯定为0，假设有多个入度为0的点，是否能判断出谁是冠军？我们画几种情况看看</p> 
 <p><img alt="" class="left" height="336" src="https://images2.imgbox.com/1b/e2/L0I8MVjT_o.jpg" width="400"></p> 
 <p>我们发现如果有多个入度为0的点，则无法判断出冠军，因为冠军并不是由战胜队伍的数量来衡量的，因此我们只需要找入度为0的点，如果有多个则返回-1</p> 
 <p></p> 
 <p>简化代码可以标记入度为0的点，然后遍历找出入度为0的点，如果出现多个则返回-1</p> 
</blockquote> 
<pre><code class="language-java">class Solution {
    public int findChampion(int n, int[][] edges) {
        int[] st=new int[n];
        for(int[] e:edges)
            st[e[1]]=1;  //将入度不为0的点标记

        int res=-1;
        for(int i=0;i&lt;n;i++)
        {
            if(st[i]==0)
            {
                if(res!=-1) return -1; //如果入度为0且有多个则无法判断冠军
                res=i;
            }
        }
        return res;
    }
}</code></pre> 
<p></p> 
<h2 id="3%E3%80%81%E5%9C%A8%E6%A0%91%E4%B8%8A%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%90%8E%E5%BE%97%E5%88%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0%20-%20dfs%E6%A0%91%20%2B%20%E9%80%86%E5%90%91%E6%80%9D%E8%80%83">3、在树上执行操作以后得到的最大分数 - dfs树 + 逆向思考</h2> 
<p><a href="https://leetcode.cn/problems/maximum-score-after-applying-operations-on-a-tree/" rel="nofollow" title="100118. 在树上执行操作以后得到的最大分数">100118. 在树上执行操作以后得到的最大分数</a></p> 
<p><img alt="" class="left" height="302" src="https://images2.imgbox.com/41/6e/34HZvekf_o.png" width="700"></p> 
<p><img alt="" class="left" height="491" src="https://images2.imgbox.com/e0/95/Vt46oNcT_o.png" width="700"></p> 
<p><img alt="" class="left" height="280" src="https://images2.imgbox.com/fa/f9/1wNbb51w_o.png" width="300"></p> 
<blockquote> 
 <p><strong>思路：</strong></p> 
 <p>要保证这棵树是健康的，且要保证得分最大，即保证<strong>每条分支至少保留一个节点不操作</strong>（保证该路径和不为0）</p> 
 <p>所以问题转换为找出<strong>每个分支满足健康情况下的【代价和最小】的不操作点</strong></p> 
 <p>则<span style="background-color:#ffd900;">操作点最大代价和 = 总代价 - 不操作点最小代价和</span></p> 
 <p>如下图，选2，5，6为不操作点，则能保证每条分支代价和均不为0，且价值最大</p> 
 <p><img alt="" class="left" height="278" src="https://images2.imgbox.com/30/fc/EaV1G8yF_o.png" width="400"></p> 
 <p>我们设<span style="background-color:#ffd900;">dfs(x)为以x为根节点的健康子树中不操作节点的最小代价</span></p> 
 <p></p> 
 <p>     <img alt="dfs(cur)=min\left \{ v[cur],cnt \right \}" class="mathcode" src="https://images2.imgbox.com/fc/fb/j14JWTOO_o.png">   其中cnt为以cur为根节点的子树的最小代价和</p> 
 <p></p> 
 <p>则答案=总value - <span style="background-color:#d7d8d9;">dfs(0) 【整棵健康数中不操作节点的最小代价】</span></p> 
 <ul><li>在dfs函数中，遍历cur节点的子节点，求出子节点的最小代价和cnt</li><li>返回 min(cur的价值，以cur为根节点的子树的最小代价cnt)</li><li>如果cur为叶子节点，则dfs值为val[cur]</li></ul> 
 <p><img alt="" class="left" height="322" src="https://images2.imgbox.com/1b/71/mB3I65eu_o.png" width="480"></p> 
</blockquote> 
<blockquote> 
 <p><strong>为什么需要st[ ]数组标记，建双向边？</strong></p> 
 <p>因为题目声明根节点为0，从0开始，且为无向树，因此需要双向建边</p> 
 <p>如果单向建边就会出现下面的这种错误样例</p> 
 <p><img alt="" class="left" height="155" src="https://images2.imgbox.com/2d/80/bpPCBcAg_o.png" width="300"></p> 
</blockquote> 
<pre><code class="language-java">class Solution {

    public long dfs(int cur,int[] v,List&lt;Integer&gt;[] g,int[] st )
    {
        long cnt=0;
        for(int x:g[cur]) 
            if(st[x]==0)
            {
                st[x]=1;
                cnt+=dfs(x,v,g,st);
            }
        //cnt=0表示该节点为叶子节点
        //说白了就是看：是选某子树的根节点值or根节点下子树代价和最小值
        return cnt==0? v[cur]:Math.min((long)v[cur],cnt);
    } 

    public long maximumScoreAfterOperations(int[][] edges, int[] values) {
        int n=values.length;
        List&lt;Integer&gt;[] g=new ArrayList[n+1];
        for(int i=0;i&lt;n;i++) g[i]=new ArrayList&lt;&gt;();
        int[] st=new int[n+1];
        long res=0;
        for(int x:values) res+=x;
        
        //建树
        for(int[] e:edges)
        {
            g[e[0]].add(e[1]);
            g[e[1]].add(e[0]);
        }
        st[0]=1;
        
        return res-dfs(0,values,g,st);  //dfs(x)表示以x为根节点的健康子树中不操作节点的最小代价
        //最大代价 = 总代价 - 不操作节点的最小代价和
    }
}</code></pre> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/db9d27cc13bb7aae2bddeb0ec4355544/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Node.js：JavaScript世界的全能工具</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7d37ffb41085b1769fd4bbfd335c1e8a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java 数据结构与算法-堆</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>