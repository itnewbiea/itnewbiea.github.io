<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java责任链模式：优雅解耦系统处理流程，实现高效灵活的请求处理与分发 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java责任链模式：优雅解耦系统处理流程，实现高效灵活的请求处理与分发" />
<meta property="og:description" content="一、什么是责任链模式 1.1 责任链模式定义 责任链模式是一种行为型设计模式，它用于将多个请求处理器对象连接成一条链，可以让请求沿着这条链不断地传递，直到有一个请求处理器处理完成为止。
在责任链模式中，每个请求处理器都可以选择将请求进行处理，或将请求转发给下一个请求处理器。因此，责任链模式可以将系统中的请求处理逻辑进行解耦，使得请求的发送者和接收者之间的关系更加灵活。
1.2 责任链模式角色 抽象处理器（Handler）：定义了一个处理请求的接口，并维护了一个后继处理器对象。具体处理器（ConcreteHandler）：实现了处理请求的接口，并决定能否处理该请求。如果不能处理，则将请求转发给后继处理器。客户端（Client）：创建一个请求处理器对象，并将其添加到责任链中。 1.3 责任链模式应用场景 责任链模式通常用于以下几种情况：
有多个对象可以处理一个请求，而处理器的具体类型在运行时才能确定。想要将请求的处理流程从请求发送者中解耦。想要动态地指定可处理请求的对象集合。 举个例子，在一个银行卡支付系统中，用户可以使用多种方式进行支付，如支付宝、微信支付、银行卡支付等，每个支付方式都有其自身的处理逻辑，且处理顺序可能也不同。此时可以使用责任链模式来将支付请求通过多个支付处理器进行处理，直至请求完成为止。这样可以避免代码耦合度过高，增加代码的可维护性和可扩展性。
二、责任链模式的实现方式 2.1 单向链表实现 首先，我们需要创建一个抽象处理器接口：
public interface Handler { void handleRequest(Request request); void setNextHandler(Handler nextHandler); } 复制代码 然后，我们创建具体的请求处理器，实现handleRequest()方法，并将请求转发给下一个处理器：
public class ConcreteHandler1 implements Handler { private Handler nextHandler; public void setNextHandler(Handler nextHandler) { this.nextHandler = nextHandler; } public void handleRequest(Request request) { if (request.getType() == RequestType.TYPE1) { System.out.println(request.getName() &#43; &#34; is handle by ConcreteHandler1&#34;); } else { if (nextHandler !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/3ebd10076908964283cfc2aa13567e15/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-04T17:00:20+08:00" />
<meta property="article:modified_time" content="2023-05-04T17:00:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java责任链模式：优雅解耦系统处理流程，实现高效灵活的请求处理与分发</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" src="https://images2.imgbox.com/d1/e4/jrhCo7CV_o.png"></p> 
<h2>一、什么是责任链模式</h2> 
<h3>1.1 责任链模式定义</h3> 
<p>责任链模式是一种行为型设计模式，它用于将多个请求处理器对象连接成一条链，可以让请求沿着这条链不断地传递，直到有一个请求处理器处理完成为止。</p> 
<p>在责任链模式中，每个请求处理器都可以选择将请求进行处理，或将请求转发给下一个请求处理器。因此，责任链模式可以将系统中的请求处理逻辑进行解耦，使得请求的发送者和接收者之间的关系更加灵活。</p> 
<h3>1.2 责任链模式角色</h3> 
<ol><li>抽象处理器（Handler）：定义了一个处理请求的接口，并维护了一个后继处理器对象。</li><li>具体处理器（ConcreteHandler）：实现了处理请求的接口，并决定能否处理该请求。如果不能处理，则将请求转发给后继处理器。</li><li>客户端（Client）：创建一个请求处理器对象，并将其添加到责任链中。</li></ol> 
<h3>1.3 责任链模式应用场景</h3> 
<p>责任链模式通常用于以下几种情况：</p> 
<ol><li>有多个对象可以处理一个请求，而处理器的具体类型在运行时才能确定。</li><li>想要将请求的处理流程从请求发送者中解耦。</li><li>想要动态地指定可处理请求的对象集合。</li></ol> 
<p>举个例子，在一个银行卡支付系统中，用户可以使用多种方式进行支付，如支付宝、微信支付、银行卡支付等，每个支付方式都有其自身的处理逻辑，且处理顺序可能也不同。此时可以使用责任链模式来将支付请求通过多个支付处理器进行处理，直至请求完成为止。这样可以避免代码耦合度过高，增加代码的可维护性和可扩展性。</p> 
<h2>二、责任链模式的实现方式</h2> 
<h3>2.1 单向链表实现</h3> 
<p>首先，我们需要创建一个抽象处理器接口：</p> 
<pre><code>public interface Handler {
    void handleRequest(Request request);
    void setNextHandler(Handler nextHandler);
}

复制代码</code></pre> 
<p>然后，我们创建具体的请求处理器，实现handleRequest()方法，并将请求转发给下一个处理器：</p> 
<pre><code>public class ConcreteHandler1 implements Handler {
    private Handler nextHandler;

    public void setNextHandler(Handler nextHandler) {
        this.nextHandler = nextHandler;
    }

    public void handleRequest(Request request) {
        if (request.getType() == RequestType.TYPE1) {
            System.out.println(request.getName() + " is handle by ConcreteHandler1");
        } else {
            if (nextHandler != null) {
                nextHandler.handleRequest(request);
            }
        }
    }
}

复制代码</code></pre> 
<h3>2.2 集合迭代器实现</h3> 
<ol><li>定义一个集合类，用于存储责任链节点对象；</li><li>在集合类中定义一个迭代器类，用于依次遍历集合中的节点对象，并执行它们的处理逻辑；</li><li>在集合迭代器类中定义一个指针变量，用于记录当前迭代器所指向的节点对象；</li><li>在迭代器类中实现next()方法，用于获取下一个节点对象，并将指针变量指向下一个节点；</li><li>在集合中实现add()方法，用于向集合中添加新的节点对象；</li><li>在客户端中创建集合对象，并依次向集合中添加节点对象；</li><li>在客户端中创建集合迭代器对象，并依次调用next()方法获取每个节点对象，从而执行它们的处理逻辑。</li></ol> 
<h2>三、责任链模式的优化</h2> 
<h3>3.1 责任链模式的优点</h3> 
<ol><li> <p>降低耦合度：责任链模式将请求的发送者和接收者解耦，请求会从链的开端一直沿着链传递到链的结尾，期间每个节点只需要关注自己的处理逻辑，从而降低了节点之间的耦合度。</p> </li><li> <p>灵活性增强：责任链模式可以动态地增加或删除节点对象，可以通过改变链中节点对象的顺序来定义不同的调用顺序，从而灵活地控制整个流程的处理顺序和过程。</p> </li><li> <p>可扩展性好：在责任链模式中增加新的节点对象并不影响原有责任链的结构和处理过程，只需要更改链中节点对象的顺序或者重新定义链的结构，就可以实现系统的功能扩展。</p> </li><li> <p>简化了对象之间的连接：责任链模式通过将每个处理者对象连接成一条链，可以避免对象之间相互引用，从而简化了对象之间的连接，方便系统进行维护和升级。</p> </li></ol> 
<h3>3.2 责任链模式的缺点</h3> 
<ol><li> <p>链太长：责任链中的每个节点都需要处理请求，当链比较长时，会降低系统的性能和效率。</p> </li><li> <p>请求不一定被处理：由于请求在责任链上传递，所以有可能到达链的末端后，仍然没有合适的处理节点对其进行处理，这时候需要特殊的处理机制来处理这种情况。</p> </li><li> <p>可能引起循环调用：如果链中某个节点的调用出现问题，可能会导致整个链的请求无法被处理。</p> </li><li> <p>难以调试：由于责任链中任何一个节点都可能处理请求，当出现问题时，需要逐个排查每个节点的处理逻辑，从而增加了调试的难度。</p> </li></ol> 
<h3>3.3 优化方式：使用函数式编程简化实现</h3> 
<p>码量和维护难度。为了简化实现，可以使用函数式编程来实现责任链模式。</p> 
<p>在函数式编程中，可以使用Lambda表达式来代替独立的类，从而避免定义大量的类文件，简化代码实现。具体来说，可以将责任链中每个节点的处理逻辑封装成一个Lambda表达式，并将这些表达式组合成一个链式结构。当需要进行请求处理时，只需按顺序将这些Lambda表达式逐个执行，就可以实现责任链模式的功能。</p> 
<p>使用函数式编程可以使代码更加简洁易懂，减少了繁琐的类定义，同时也提高了代码的执行效率。</p> 
<h3>3.4 优化方式：使用AOP实现责任链模式</h3> 
<p>如前所述，在传统的责任链模式实现中，每个处理节点的实现都需要定义一个独立的类，从而增加了代码量和维护难度。为了简化实现，可以使用面向切面编程（AOP）来实现责任链模式。</p> 
<p>在AOP中，可以使用切面来定义责任链模式中每个节点的处理逻辑，并将这些切面连接成一个链式结构。当需要进行请求处理时，只需要按顺序将这些切面逐个执行，就可以实现责任链模式的功能。</p> 
<p>使用AOP可以避免定义大量的类文件，简化代码实现，同时也提高了代码的执行效率。此外，AOP还提供了更加灵活的配置方式，可以根据业务需求对责任链结构进行动态配置，支持动态增加、删除节点对象。由此，AOP实现的责任链模式具有更高的可扩展性和灵活性。</p> 
<p>示例代码：</p> 
<pre><code>// 定义切面，定义每个节点的处理逻辑  
@Aspect  
public class Responsibilities {  
      
    // 定义处理请求的切入点  
    @Pointcut("execution(* com.example.Application.*(..))")  
    public void handleRequest() {  
        // 声明需要执行的切面方法  
        @Before("handleRequest()")  
        public void beforeHandleRequest(JoinPoint joinPoint) {  
            // 获取请求对象  
            Request request = (Request) joinPoint.getArgs()[0];  
              
            // 执行前置处理逻辑  
            beforeHandleRequest(request);  
              
            // 执行处理逻辑  
            handleRequest(request);  
              
            // 执行后置处理逻辑  
            afterHandleRequest(request);  
        }  
    }  
      
    // 定义处理前置处理逻辑的切面方法  
    @Before("handleRequest()")  
    public void beforeHandleRequest(Request request) {  
        // 执行前置处理逻辑  
        // ...  
    }  
      
    // 定义处理后置处理逻辑的切面方法  
    @After("handleRequest()")  
    public void afterHandleRequest(Request request) {  
        // 执行后置处理逻辑  
        // ...  
    }  
}

// 定义请求处理类，实现责任链模式  
public class Request {  
      
    // 处理请求的逻辑  
    public void handleRequest() {  
        // 执行处理逻辑  
        // ...  
    }  
      
    // 前置处理逻辑  
    public void beforeHandleRequest(Request request) {  
        // 执行前置处理逻辑  
        // ...  
    }  
      
    // 后置处理逻辑  
    public void afterHandleRequest(Request request) {  
        // 执行后置处理逻辑  
        // ...  
    }  
}

// 应用上下文，声明需要执行的责任链  
@ApplicationContext  
public class ApplicationContext {  
      
    // 声明需要执行的责任链  
    @Autowired  
    private ResponsibilitiesResponsibilities;  
      
    // 处理请求的方法  
    public void handleRequest(Request request) {  
        Responsibilities.beforeHandleRequest(request);  
        request.handleRequest();  
        Responsibilities.afterHandleRequest(request);  
    }  
}

复制代码</code></pre> 
<p>在上面的示例代码中，<code>Responsibilities</code>类是切面类，它定义了每个节点的处理逻辑。<code>handleRequest()</code>方法是请求处理类实现的处理方法，它实现了责任链模式的核心功能。<code>beforeHandleRequest()</code>和<code>afterHandleRequest()</code>方法是前置处理逻辑和后置处理逻辑，它们被注入到请求处理类中，以便在请求处理类中调用。</p> 
<h2>四、责任链模式的注意事项</h2> 
<h3>4.1 存在循环调用的风险</h3> 
<p>在实现责任链模式时，需要注意节点之间的循环调用，避免出现死循环的情况。</p> 
<p>循环调用的风险通常出现在两种情况下：一是责任链节点自身会对请求进行多次处理，从而形成死循环；二是责任链节点之间相互调用，出现互相调用的情况。</p> 
<p>为了避免循环调用的风险，需要对责任链节点的处理逻辑进行严格的控制和规范，确保节点的处理逻辑只能一次性地对请求进行处理，并且不会出现相互调用的情况。</p> 
<p>另外，可以通过设置最大处理次数或者设置超时时间等机制来防止出现死循环，从而避免对系统的影响。</p> 
<h3>4.2 确定责任链顶端和底端</h3> 
<p>在实现责任链模式时，需要确定责任链的顶端和底端，以确保请求能够被正确地传递和处理。</p> 
<p>责任链的顶端一般是由客户端发起请求的地方，底端则是链的末尾，即最后一个节点的处理逻辑。</p> 
<p>在确定责任链的顶端和底端时，需要考虑业务需求和系统结构，避免出现环状结构或节点缺失的情况。</p> 
<p>如果责任链没有明确的顶端和底端，则会出现请求无法被正确处理的情况，从而影响系统的正常运行。因此，在实现责任链模式时，需要对节点的逻辑和业务流程进行仔细的分析和设计，并合理地确定责任链的顶端和底端。</p> 
<h2>五、责任链模式的例子</h2> 
<h3>5.1 实例：多个银行卡支付问题</h3> 
<p>假设有一个在线支付系统，用户可以选择使用多个银行卡中的任意一张，但是每个银行卡都有不同的支付限制，如下所示：</p> 
<ul><li>银行卡A支付限制：每次支付金额不超过500元；</li><li>银行卡B支付限制：每日支付金额不超过2000元；</li><li>银行卡C支付限制：每月支付金额不超过10000元。</li></ul> 
<p>如果用户选择的银行卡支付限制不符合要求，则无法完成支付。为了解决这个问题，可以使用责任链模式，创建一个银行卡支付处理链，根据银行卡的支付限制依次进行处理，直到找到可以完成支付的银行卡。</p> 
<p><strong>代码实现：</strong></p> 
<p>首先，定义银行卡处理器接口和抽象类。银行卡处理器接口包含一个处理方法，用于判断当前银行卡是否可以完成支付；抽象类实现了银行卡处理器接口，并提供了一个链式处理器的引用，以及一个设置下一个处理器的方法。</p> 
<pre><code>public interface BankCardHandler {
    boolean canPay(int amount);
}

public abstract class AbstractBankCardHandler implements BankCardHandler {
    private BankCardHandler nextHandler;

    public BankCardHandler setNextHandler(BankCardHandler handler) {
        this.nextHandler = handler;
        return nextHandler;
    }

    public boolean canPay(int amount) {
        if (check(amount)) {
            return true;
        } else if (nextHandler != null) {
            return nextHandler.canPay(amount);
        } else {
            return false;
        }
    }

    protected abstract boolean check(int amount);
}
复制代码</code></pre> 
<p>然后，创建三个具体的银行卡处理器类，分别处理上述三个场景：</p> 
<pre><code>public class BankCardAHandler extends AbstractBankCardHandler {
    protected boolean check(int amount) {
        return amount &lt;= 500;
    }
}

public class BankCardBHandler extends AbstractBankCardHandler {
    private int dailyLimit;

    public BankCardBHandler(int dailyLimit) {
        this.dailyLimit = dailyLimit;
    }

    protected boolean check(int amount) {
        return amount &lt;= dailyLimit;
    }
}

public class BankCardCHandler extends AbstractBankCardHandler {
    private int monthlyLimit;

    public BankCardCHandler(int monthlyLimit) {
        this.monthlyLimit = monthlyLimit;
    }

    protected boolean check(int amount) {
        return amount &lt;= monthlyLimit;
    }
}
复制代码</code></pre> 
<p>最后，组合银行卡处理器类，形成一个处理链：</p> 
<pre><code>public class BankCardPayment {
    private BankCardHandler handlerChain;

    public BankCardPayment() {
        handlerChain = new BankCardAHandler();
        handlerChain.setNextHandler(new BankCardBHandler(2000))
            .setNextHandler(new BankCardCHandler(10000));
    }

    public boolean pay(int amount) {
        return handlerChain.canPay(amount);
    }
}

复制代码</code></pre> 
<p>在客户端代码中，创建一个银行卡支付实例，根据用户输入的支付金额进行支付操作：</p> 
<pre><code>BankCardPayment payment = new BankCardPayment();
if (payment.pay(300)) {
    System.out.println("支付成功！");
} else {
    System.out.println("支付失败，金额超过所有银行卡的限制！");
}
复制代码</code></pre> 
<h3>5.2 实例：Java Web过滤器</h3> 
<p>Java Web过滤器用于拦截Web请求并对它们进行相应的处理，它可以对特定的请求进行过滤、修改它们的参数、检查用户权限等。下面是一个简单的Java Web过滤器示例，对其代码进行详细说明：</p> 
<p>首先，我们需要创建一个实现Filter接口的Java类：</p> 
<pre><code>public class MyFilter implements Filter {
  @Override
  public void init(FilterConfig filterConfig) throws ServletException {
    // 初始化代码
  }

  @Override
  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    // 过滤代码
    chain.doFilter(request, response); // 继续执行其他过滤器或Servlet
  }

  @Override
  public void destroy() {
    // 清理资源代码
  }
}
复制代码</code></pre> 
<p>上面的代码中，我们实现了Filter接口中的三个方法：</p> 
<ul><li>init方法：在过滤器被初始化时被调用。在这个方法中，我们可以进行一些初始化工作（例如读取配置文件或建立数据库连接等）。</li><li>doFilter方法：这是过滤器最重要的方法，它会对请求进行过滤处理。我们可以在这个方法中检查请求参数、修改请求或响应数据、检查用户权限等。如果需要，我们还可以使用FilterChain的doFilter方法，将请求传递给链中的下一个过滤器或最终的Servlet。</li><li>destroy方法：在过滤器被销毁时被调用。在这个方法中，我们可以进行一些清理操作（例如释放资源或关闭数据库连接等）。</li></ul> 
<p>在doFilter方法中，我们可以根据需要对请求进行处理。例如，以下代码将检查请求参数中是否包含名为"username"的参数：</p> 
<pre><code>@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
  String username = request.getParameter("username");
  if (username != null) {
    // 对于包含username参数的请求，我们可以进行相应的处理
  }
  chain.doFilter(request, response); // 继续执行其他过滤器或Servlet
}

复制代码</code></pre> 
<p>在实际使用中，我们需要将这个过滤器注册到我们的Web应用程序中。以下是一个简单的web.xml配置示例：</p> 
<pre><code>&lt;web-app&gt;
  &lt;filter&gt;
    &lt;filter-name&gt;myFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;com.example.MyFilter&lt;/filter-class&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;myFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
&lt;/web-app&gt;
复制代码</code></pre> 
<p>以上示例将我们的过滤器注册到应用程序中，并将其映射到所有的URL上。这样，每当有请求访问我们的Web应用程序时，过滤器就会被自动调用。</p> 
<p>以上是一个简单的Java Web过滤器的实例和说明。尽管这个示例非常简单，但它可以作为你编写更复杂的过滤器的参考。</p> 
<h2>六、总结与结论</h2> 
<p>责任链模式是一种行为型设计模式，用于将多个请求处理器对象连接成一条链，可以让请求沿着这条链不断地传递，直到有一个请求处理器处理完成为止。在责任链模式中，每个请求处理器都可以选择将请求进行处理，或将请求转发给下一个请求处理器，从而将系统中的请求处理逻辑进行解耦，使得请求的发送者和接收者之间的关系更加灵活。</p> 
<p>责任链模式的实现方式有单向链表实现和集合迭代器实现，优化方式可以使用函数式编程和AOP来简化实现和提高可扩展性。在使用责任链模式时需要注意存在循环调用的风险和确定责任链的顶端和底端。</p> 
<p>在实际应用中，责任链模式可以用于银行卡支付、Java Web过滤器等场景。通过使用责任链模式，可以避免代码耦合度过高，增加代码的可维护性和可扩展性，提高系统的效率和灵活性。</p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cb4d8c2d97bef2ddc5d2e4811301d0a5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android仿系统provision应用实现开机向导</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/be99846b27474db009b591c887b6ce5a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">nodejs给密码加密 报错 ，找bug全过程。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>