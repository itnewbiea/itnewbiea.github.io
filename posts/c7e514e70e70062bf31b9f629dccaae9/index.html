<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>神经网络——torch.optim优化器的使用 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="神经网络——torch.optim优化器的使用" />
<meta property="og:description" content="optimizer.step()是大多数优化器支持的简化版本。 一旦使用例如计算梯度，就可以调用该函数。 backward()反向传播。
文章目录
一、 官方文档
1. 什么是torch.optim？
2. How to use an optimizer（如何使用优化器）
2.1 Constructing it（构建它）
2.2 Per-parameter options（每个参数选项） 2.3 Taking an optimization step（采取优化步骤）
二、torch.optim的算法
2.1 torch.optim.Optimizer(params, defaults)
2.2 Adadelta
2.3 使用torch.optim.SGD进行学习
一、 官方文档
1. 什么是torch.optim？
torch.optim 是一个实现各种优化算法的包。 最常用的方法都已经支持了，接口也足够通用，以后也可以轻松集成更复杂的方法。
2. How to use an optimizer（如何使用优化器）
要使用 torch.optim，必须构造一个优化器对象，该对象将保持当前状态并根据计算的梯度更新参数。
2.1 Constructing it（构建它）
要构造一个优化器，你必须给它一个包含要优化的参数（都应该是变量）的迭代。 然后，您可以指定优化器特定的选项，例如学习率、权重衰减等。
Note:
如果您需要通过 .cuda() 将模型移动到 GPU，请在为其构建优化器之前执行此操作。 .cuda() 之后的模型参数将与调用之前的对象不同。
通常，在构建和使用优化器时，应该确保优化的参数位于一致的位置。
2.2 Per-parameter options（每个参数选项） 不会，后面补充。
2.3 Taking an optimization step（采取优化步骤）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c7e514e70e70062bf31b9f629dccaae9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-02T15:54:18+08:00" />
<meta property="article:modified_time" content="2024-01-02T15:54:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">神经网络——torch.optim优化器的使用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p><br><br> optimizer.step()是大多数优化器支持的简化版本。 一旦使用例如计算梯度，就可以调用该函数。 backward()反向传播。</p> 
<p>文章目录</p> 
<p>一、 官方文档</p> 
<p>1. 什么是torch.optim？</p> 
<p>2. How to use an optimizer（如何使用优化器）</p> 
<p>2.1 Constructing it（构建它）</p> 
<p>2.2 Per-parameter options（每个参数选项）    </p> 
<p>2.3 Taking an optimization step（采取优化步骤）</p> 
<p>二、torch.optim的算法</p> 
<p>2.1 torch.optim.Optimizer(params, defaults)</p> 
<p>2.2 Adadelta</p> 
<p>2.3 使用torch.optim.SGD进行学习</p> 
<p>一、 官方文档<br> 1. 什么是torch.optim？<br> torch.optim 是一个实现各种优化算法的包。 最常用的方法都已经支持了，接口也足够通用，以后也可以轻松集成更复杂的方法。</p> 
<p>2. How to use an optimizer（如何使用优化器）<br> 要使用 torch.optim，必须构造一个优化器对象，该对象将保持当前状态并根据计算的梯度更新参数。</p> 
<p>2.1 Constructing it（构建它）<br> 要构造一个优化器，你必须给它一个包含要优化的参数（都应该是变量）的迭代。 然后，您可以指定优化器特定的选项，例如学习率、权重衰减等。</p> 
<p>Note:<br> 如果您需要通过 .cuda() 将模型移动到 GPU，请在为其构建优化器之前执行此操作。 .cuda() 之后的模型参数将与调用之前的对象不同。<br> 通常，在构建和使用优化器时，应该确保优化的参数位于一致的位置。</p> 
<p>2.2 Per-parameter options（每个参数选项）    <br> 不会，后面补充。</p> 
<p>2.3 Taking an optimization step（采取优化步骤）<br> 所有优化器都实现了一个更新参数的 step() 方法。 它可以通过两种方式使用：</p> 
<p>第一种是optimizer.step()<br> 这是大多数优化器支持的简化版本。 一旦使用例如计算梯度，就可以调用该函数。 backward()反向传播。</p> 
<p>for input, target in dataset:<br>     optimizer.zero_grad()        #这是将上一步求得每个参数对应的梯度进行清0，以防上一步的梯度造成影响<br>     output = model(input)      #数据经过神经网络得到一个输出<br>     loss = loss_fn(output, target)    #计算出losss,得到输出与目标之间的误差<br>     loss.backward()                  #反向传播，得到每一个要更新的参数的梯度<br>     optimizer.step()                 #调用optimizer.step，每一个参数都会根据反向传播得到的梯度进行优化</p> 
<p><br> 第二种是optimizer.step(closure)<br> 一些优化算法，如 Conjugate Gradient 和 LBFGS 需要多次重新评估函数，因此您必须传入一个允许它们重新计算模型的闭包。 闭包应该清除梯度，计算损失并返回它。</p> 
<p>for input, target in dataset:<br>     def closure():<br>         optimizer.zero_grad()<br>         output = model(input)<br>         loss = loss_fn(output, target)<br>         loss.backward()<br>         return loss<br>     optimizer.step(closure)</p> 
<p>二、torch.optim的算法<br> 2.1 torch.optim.Optimizer(params, defaults)<br> 这是优化器的基本结构，每个优化器类都有着两个参数。<br>  </p> 
<p>参数：<br> params (iterable) – an iterable of torch.Tensor s or dict s. Specifies what Tensors should be optimized.<br> （ 可迭代的 torch.Tensor 或 dict 。 指定应该优化哪些张量。）<br> defaults – (dict): a dict containing default values of optimization options (used when a parameter group doesn’t specify them).<br> （包含优化选项默认值的字典（在参数组未指定它们时使用）。）</p> 
<p>2.2 Adadelta<br> torch.optim.Adadelta(params, lr=1.0, rho=0.9, eps=1e-06, weight_decay=0)</p> 
<p>params：参数，需要将模型的参数输入<br> lr：学习速率，即learning rate</p> 
<p>不同的优化器，只有params和lr前面两个参数是一样的，其他的参数是不一样的。</p> 
<p>2.3 使用torch.optim.SGD进行学习<br> 代码如下：</p> 
<p>import torch<br> import torchvision<br> from torch import nn<br> from torch.nn import Sequential, Conv2d, MaxPool2d, Flatten, Linear<br> from torch.utils.data import DataLoader<br>  <br> #调用CIFAR10数据集<br> dataset = torchvision.datasets.CIFAR10("./dataset", train=False, transform=torchvision.transforms.ToTensor(),<br>                                        download=True)<br> #使用dataloader数据迭代器<br> dataloader = DataLoader(dataset, batch_size=1)<br>  <br> #搭建神经网络，这个Test网络就是CIFAR10数据集的网络<br> class Test(nn.Module):<br>     def __init__(self):    #初始化<br>         super(Test, self).__init__()<br>         self.seq = Sequential(<br>             Conv2d(in_channels=3, out_channels=32, kernel_size=5, padding=2),<br>             MaxPool2d(2),<br>             Conv2d(32, 32, 5, padding=2),<br>             MaxPool2d(2),<br>             Conv2d(32, 64, 5, padding=2),<br>             MaxPool2d(2),<br>             Flatten(),<br>             Linear(1024, 64),<br>             Linear(64, 10)<br>         )<br>  <br>     def forward(self,x):<br>         x = self.seq(x)<br>         return x<br>  <br> #创建网络<br> test = Test()<br>  <br> #使用nn.CrossEntropyLoss<br> loss_cross = nn.CrossEntropyLoss()<br> optim = torch.optim.SGD(test.parameters(), lr=0.01)<br> for data in dataloader:<br>     imgs, targets = data<br>     optim.zero_grad()    #上一步求得的参数归零<br>     output = test(imgs)<br>     result_loss = loss_cross(output, targets)<br>     result_loss.backward()<br>     optim.step()<br>     print(result_loss)<br> 结点运行一下，一开始grad梯度是没有值的none</p> 
<p><br> 运行一次backward,grad梯度值就计算出来了</p> 
<p><br> 运行optim.step().会发现grad梯度改变了</p> 
<p><br> 运行optim.zero_grad()，grad梯度又清零了</p> 
<p><br> 如此往复。让我们的Loss变小。</p> 
<p>输入print(result_loss)，来查看一下代码运行的结果</p> 
<p><br> 在每一个节点上，loss值好像并没有减小，那是因为dataloder的数据在这个神经网络中都只看了一遍，<br> 一般情况下，我们需要对数据进行很多轮的学习，这里才学习了一次<br> 故，可以使用for循环，来进行多轮学习</p> 
<p>代码如下：</p> 
<p>loss_cross = nn.CrossEntropyLoss()<br> optim = torch.optim.SGD(test.parameters(), lr=0.01)<br> for epoch in range(20):                  #epoch就是一轮一轮的意思<br>     running_loss = 0.0       #为了方便观察，用这个查看每一轮中loss值为多少<br>     for data in dataloader:<br>         imgs, targets = data<br>         optim.zero_grad()     #上一步求得的参数归零<br>         output = test(imgs)<br>         result_loss = loss_cross(output, targets)<br>         result_loss.backward()<br>         optim.step()<br>         running_loss = running_loss + result_loss<br>     print(running_loss)<br> 输出结果：</p> 
<p>可以看见，Loss值在变小。<br>  </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/27deb3d5309166e8dd8c420f61bcf7a5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Axure软件大全：原型设计下载与学习指南！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0a20702e07b92085a14814a364e78a67/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深度解刨性能测试工具Locust</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>