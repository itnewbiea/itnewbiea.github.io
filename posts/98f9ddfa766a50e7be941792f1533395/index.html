<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>入门激光雷达点云的3D目标检测 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="入门激光雷达点云的3D目标检测" />
<meta property="og:description" content="前言 虽然业界有很多的争论，但是LiDAR在目前的L3/L4级自动驾驶系统中依然是不可或缺的传感器，因为它可以提供稠密的3D点云，非常精确的测量物体在3D空间中的位置和形状，而这是摄像头和毫米波雷达很难做到的。那么相应的，基于LiDAR点云的感知算法也就成为了近年来自动驾驶研发的重点之一。与图像的感知算法类似，LiDAR点云的感知算法也分为物体检测（包括跟踪）和语义分割两大类。这篇文章主要关注基于LiDAR点云的物体检测算法，语义分割算法留待以后再做介绍。
很多综述性的文章把LiDAR点云的物体检测算法粗略分为四类：Multi-view方法，Voxel方法, Point方法，以及Point和Voxel结合的方法。这种基于分类的综述更像是一个算法图书馆，读者可以根据关键字（或者说关键技术）进行索引，方便于查询和归档，可能更适合于该领域内的工作者。但是我想并不是所有的读者都对这个方向有比较深入的了解，直接讲方法分类和技术细节可能会从一开始就让读者迷失在算法的森林里。
所以，与一般的综述不同，在这篇文章里我以时间为线索，将LiDAR点云物体检测的发展历程粗略地划分为了四个时期：萌芽期，起步期，发展期和成落地期。我会从技术发展的角度，结合自己在研究中的一些体会来介绍各种算法。这篇综述的目的不在于包罗这个方向所有的文章，我只会选一些在技术发展的道路上具有重要意义的工作。当然本人水平有限，其中肯定会有疏漏。但是，如果大家读完以后能够对该方向的发展脉络有一个基本的认识，那我想我的目的就达到了。
基本概念 在进入具体的介绍之前，还是有必要简单说一下一些基本的概念。LiDAR的输出数据是3D点云，每一个点除了包含X，Y，Z坐标，还包含一个反射强度R，类似与毫米波雷达里的RCS。3D物体检测的目标是要根据点云数据来找到场景中所有感兴趣的物体，比如自动驾驶场景中的车辆，行人，静态障碍物等等。下图以车辆为例，来说明输出结果的格式。简单来说，检测算法输出多个3D矩形框（术语称为3D BoundingBox，简称3D BBox），每个框对应一个场景中的物体。3D BBox可以有多种表示方法，一般最常用的就是用中心点3D坐标，长宽高，以及3D旋转角度来表示（简单一些的话可以只考虑平面内旋转，也就是下图中的θ）。
检测算法输出的3D BBox与人工标注的数据进行对比，一般采用3D IoU （Intersection over Unoin）来衡量两个BBox重合的程度，高于设定的阈值就被认为是一个成功的检测，反之则认为物体没有被检测到（False Negative）。如果在没有物体的区域出现了BBox输出，则被认为是一个误检（False Positive）。评测算法会同时考虑这两个指标，给出一个综合的分数，比如AP（Average Precision）以此为标准来评价算法的优劣。由于不是本文的重点，具体的细节这里就不做赘述了。
萌芽期 （2017年之前） 有了前面的铺垫，下面我们的算法之旅正式开始了。话说物体检测算法的兴起主要来自于计算机视觉领域，自从2012年深度学习出现以来，图像和视频中的物体检测算法在性能上有了大幅度的提高，各种经典算法也是层数不穷，比如最早的R-CNN，到后来的Faster RCNN，再到YOLO以及最新的CenterNet等等，可以说已经研究的非常透彻了。
那么，在做点云中的物体检测时，人们自然的就会想到要借鉴视觉领域的成功经验。VeloFCN[2]就是其中的代表性方法。它将3D点云转换到与图像相似的正视图（Front View），得到一个&#34;点云伪图像&#34;。这种数据在格式和性质上与图像非常类似，自然的也就可以照搬图像上的物体检测算法。但是这种表示的缺陷也很明显，首先多个点可能映射到图像坐标的同一个位置，这样会造成信息的丢失。更为重要的是，将3D的点映射到2D平面，丢掉了深度信息，而这个信息对3D物体检测来说是非常重要的。
因此，人们又想到可以把3D点云映射到俯视图（也称作鸟瞰视图，Bird’s Eye View, 简称BEV）。这种映射是非常直观的，你可以简单的认为把3D点的高度坐标忽略（将其看作点的特征），从而得到2D平面上的数据表示。MV3D[3]就是将3D点云同时映射到正视图和俯视图，并与2D图像数据进行融合。以上说的都是数据构建和特征提取，至于后端的检测算法，一般来说这个时期都是采用基于R-CNN或者类似的方法。这里就不做解释了，网上可以找到很多介绍性文章。
起步期（2017年） 时间进入2017年，在这个年份里出现了两个在点云物体检测领域堪称里程碑式的工作：
VoxelNet[4]和PointNet&#43;&#43;[5]。这两个工作代表了点云处理的两个基本方向，VoxelNet将点云量化为网格数据，而PointNet&#43;&#43;直接处理非结构化的数据点。下面我会稍微详细的介绍一下这两个方法，因为之后点云物体检测领域几乎所有的方法都离不开这两个工作里的概念。
VoxelNet 这个工作是2017年由苹果公司的两位研究人员提出的，并且发表在了CVPR 2018上（计算机视觉和模式识别领域的顶会）。
其思路并不复杂，首先将点云量化到一个均匀的3D网格中（下图中的grouping）。每个网格内部随机采样固定数量的点（不足的就重复），每个点用7维特征表示，包括该点的X，Y，Z坐标，反射强度R，以及该点相对网格质心（网格内所有点位置的均值）的位置差ΔX，ΔY和ΔZ。全连接层被用来提取点的特征，然后每个点的特征再与网格内所有点的特征均值进行拼接，得到新的点特征。这种特征的优点在于同时保留了单个点的特性和该点周围一个局部小区域（网格）的特性。这个点特征提取的过程可以重复多次，以增强特征的描述能力（下图中的Stacked Voxel Feature Encoding）。最终网格内的所有点进行最大池化操作（Max Pooling），以得到一个固定长度的特征向量。
以上这些步骤称为特征学习网络，其输出是一个4D的Tensor（对应X，Y，Z坐标和特征）。这与一般的图像数据不同（图像是3D Tensor，只有X，Y坐标和特征），因此还没法直接采用图像物体检测的方法。VoxelNet中采用3D卷积对Z维度进行压缩（比如stride=2）。假设4D Tensor的维度为HxWxDxC，经过若干次3D卷积后，Z维度的大小被压缩为2（也就是HxWx2xC’），然后直接将Z维度与特征维度合并，生成一个3D的Tensor（HxWx2C’）。这就和标准的图像数据格式相似了，因此可以接上图像物体检测网络（比如Region Proposal Network，RPN）来生成物体检测框，只不过这里生成的是3D的检测框。
从上面的介绍可以看出，VoxelNet的框架非常简洁，也是第一个可以真正进行端对端的学习的点云物体检测网络。实验结果表明，这种端对端的方式可以自动地从点云中学习到可用的信息，比手工设计特征的方式更为高效。
PointNet&#43;&#43; 该方法的前身是PointNet[6]，由斯坦福大学的研究者在2017年发表，这也是点云处理领域的开创性工作之一。PointNet处理的是点云分类任务，其主要思路是直接处理原始的点云。除了一些几何变换之外，PointNet主要有两个操作：MLP（多个全连接层）提取点特征，MaxPooling得到全局特征。物体分类网络采用全局特征作为输入，而分割网络则同时采用全局特征和点特征。
简单来说，你可以把PointNet分类网络看做一个分类器，比如可以理解为传统方法中的SVM。但是要进行物体检测的话，就还需要一个类似于Sliding Window的机制，也就是说在场景内的各个位置应用PointNet来区分物体和背景，以达到物体检测的效果。当然对于相对稀疏的点云数据来说，这种做法是非常低效的。因此，PointNet的作者同年就提出了升级版本，也就是PointNet&#43;&#43;。
其主要思路是用聚类的方式来产生多个候选区域（每个区域是一个点集），在每个候选区域内采用PointNet来提取点的特征。这个过程以一种层级化的方式重复多次，每一次聚类算法输出的多个点集都被当做抽象后的点云再进行下一次处理（Set Abstraction，SA）。这样得到的点特征具有较大的感受野，包含了局部邻域内丰富的上下文信息。最后，在多层SA输出的点集上进行PointNet分类，以区分物体和背景。同样的，这个方法也可以做点云分割。
PointNet网络结构[6]
与VoxelNet相比，PointNet&#43;&#43;的优点在于：1）没有量化带来的信息损失，也无需调节量化超参数；2）忽略空白区域，避免了无效的计算。但是缺点也显而易见：1）无法利用成熟的基于空间卷积的2D物体检测算法；2）虽然避免了无效计算，但是GPU对于点云的处理效率远低于网格数据，因此实际的运行速度甚至更慢。
发展期（2018年-2020年） 在VoxelNet和PointNet&#43;&#43;相继提出后，3D物体检测领域迎来了一个快速发展期，很多算法被提出，用来改进这两个工作中的不足。
对Voxel方法的改进
VoxelNet的主要问题在于数据表示比较低效，中间层的3D卷积计算量太大，导致其运行速度只有大约2FPS（Frame Per Second），远低于实时性的要求，因此后续很多工作针对其运行效率的问题进行了改进。
**SECOND[7]**采用稀疏卷积策略，避免了空白区域的无效计算，将运行速度提升到了26FPS，同时也降低了显存的使用量。
**PIXOR[8]**提出通过手工设计的方式，将3D的Voxel压缩到2D的Pixel。这样做避免了3D卷积，但是损失了高度方向上的信息，导致检测准确度下降很多。
**PointPillar[9]**的思路也是3D转2D，也就是将点3D云量化到2D的XY平面网格。但是与PIXOR手工设计特征的方式不同，PointPillar把落到每个网格内的点直接叠放在一起，形象的称其为柱子(Pillar)，然后利用与PointNet相似的方式来学习特征，最后再把学到的特征向量映射回网格坐标上，得到与图像类似的数据。这样做一来避免了VoxelNet中的3D卷积和空白区域的无效计算(运行速度达到62FPS)，二来避免了手工设计特征导致信息丢失和网络适应性不强的问题，可以说是很巧妙的思路。不好的方面是，点特征的学习被限制在网格内，无法有效的提取邻域的上下文信息。
对Point方法的改进 PointNet&#43;&#43;采用基于聚类的方法来层级化的提取邻域特征以及获得物体候选，这种做法效率比较低，而且也很难做并行加速。而这恰巧是传统的2D卷积网络的强项，因此后续的工作逐渐将2D物体检测算法中的一些思路拿过来，用来解决PointNet&#43;&#43;中的问题。
Point-RCNN[10]首先在这个方向了进行了探索，可以称得上3D物体检测领域的又一个里程碑式的工作。从名字上就能看出，这个方法将点云处理和2D物体检测领域的开山之作Faster RCNN结合了起来。首先，PointNet&#43;&#43;被用来提取点特征。点特征被用来进行前景分割，以区分物体上的点和背景点。同时，每个前景点也会输出一个3D候选BBox。接下来就是将候选BBox内的点再做进一步的特征提取，输出BBox所属的物体类别，并且对其位置，大小进行细化。
看到这里，熟悉2D物体检测的朋友肯定会说，这不就是一个典型的两阶段检测模型嘛。没错，但不同的是，Point-RCNN只在前景点上生成候选，这样避免了3D空间中生成稠密候选框所带来的巨大计算量。尽管如此，作为一个两阶段的检测器，加上PointNet&#43;&#43;本身较大的计算量，Point-RCNN的运行效率依然不高，只有大约13FPS 。Point-RCNN后来被扩展为Part-A2[11]，速度和准确度都有一定的提升。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/98f9ddfa766a50e7be941792f1533395/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-16T18:34:08+08:00" />
<meta property="article:modified_time" content="2022-05-16T18:34:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">入门激光雷达点云的3D目标检测</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>前言</h2> 
<p>虽然业界有很多的争论，但是LiDAR在目前的L3/L4级自动驾驶系统中依然是不可或缺的传感器，因为它可以提供稠密的3D点云，非常精确的测量物体在3D空间中的位置和形状，而这是摄像头和毫米波雷达很难做到的。那么相应的，基于LiDAR点云的感知算法也就成为了近年来自动驾驶研发的重点之一。与图像的感知算法类似，LiDAR点云的感知算法也分为物体检测（包括跟踪）和语义分割两大类。这篇文章主要关注基于LiDAR点云的物体检测算法，语义分割算法留待以后再做介绍。<br> 很多综述性的文章把LiDAR点云的物体检测算法粗略分为四类：Multi-view方法，Voxel方法, Point方法，以及Point和Voxel结合的方法。这种基于分类的综述更像是一个算法图书馆，读者可以根据关键字（或者说关键技术）进行索引，方便于查询和归档，可能更适合于该领域内的工作者。但是我想并不是所有的读者都对这个方向有比较深入的了解，直接讲方法分类和技术细节可能会从一开始就让读者迷失在算法的森林里。<br> 所以，与一般的综述不同，在这篇文章里我以时间为线索，将LiDAR点云物体检测的发展历程粗略地划分为了四个时期：萌芽期，起步期，发展期和成落地期。我会从技术发展的角度，结合自己在研究中的一些体会来介绍各种算法。这篇综述的目的不在于包罗这个方向所有的文章，我只会选一些在技术发展的道路上具有重要意义的工作。当然本人水平有限，其中肯定会有疏漏。但是，如果大家读完以后能够对该方向的发展脉络有一个基本的认识，那我想我的目的就达到了。</p> 
<h2><a id="_5"></a>基本概念</h2> 
<p>在进入具体的介绍之前，还是有必要简单说一下一些基本的概念。LiDAR的输出数据是3D点云，每一个点除了包含X，Y，Z坐标，还包含一个反射强度R，类似与毫米波雷达里的RCS。3D物体检测的目标是要根据点云数据来找到场景中所有感兴趣的物体，比如自动驾驶场景中的车辆，行人，静态障碍物等等。下图以车辆为例，来说明输出结果的格式。简单来说，检测算法输出多个3D矩形框（术语称为3D BoundingBox，简称3D BBox），每个框对应一个场景中的物体。3D BBox可以有多种表示方法，一般最常用的就是用中心点3D坐标，长宽高，以及3D旋转角度来表示（简单一些的话可以只考虑平面内旋转，也就是下图中的θ）。<br> 检测算法输出的3D BBox与人工标注的数据进行对比，一般采用3D IoU （Intersection over Unoin）来衡量两个BBox重合的程度，高于设定的阈值就被认为是一个成功的检测，反之则认为物体没有被检测到（False Negative）。如果在没有物体的区域出现了BBox输出，则被认为是一个误检（False Positive）。评测算法会同时考虑这两个指标，给出一个综合的分数，比如AP（Average Precision）以此为标准来评价算法的优劣。由于不是本文的重点，具体的细节这里就不做赘述了。<br> <img src="https://images2.imgbox.com/de/01/A2xIEYZY_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_2017_9"></a>萌芽期 （2017年之前）</h4> 
<p>有了前面的铺垫，下面我们的算法之旅正式开始了。话说物体检测算法的兴起主要来自于计算机视觉领域，自从2012年深度学习出现以来，图像和视频中的物体检测算法在性能上有了大幅度的提高，各种经典算法也是层数不穷，比如最早的R-CNN，到后来的Faster RCNN，再到YOLO以及最新的CenterNet等等，可以说已经研究的非常透彻了。<br> 那么，在做点云中的物体检测时，人们自然的就会想到要借鉴视觉领域的成功经验。VeloFCN[2]就是其中的代表性方法。它将3D点云转换到与图像相似的正视图（Front View），得到一个"点云伪图像"。这种数据在格式和性质上与图像非常类似，自然的也就可以照搬图像上的物体检测算法。但是这种表示的缺陷也很明显，首先多个点可能映射到图像坐标的同一个位置，这样会造成信息的丢失。更为重要的是，将3D的点映射到2D平面，丢掉了深度信息，而这个信息对3D物体检测来说是非常重要的。<br> 因此，人们又想到可以把3D点云映射到俯视图（也称作鸟瞰视图，Bird’s Eye View, 简称BEV）。这种映射是非常直观的，你可以简单的认为把3D点的高度坐标忽略（将其看作点的特征），从而得到2D平面上的数据表示。MV3D[3]就是将3D点云同时映射到正视图和俯视图，并与2D图像数据进行融合。以上说的都是数据构建和特征提取，至于后端的检测算法，一般来说这个时期都是采用基于R-CNN或者类似的方法。这里就不做解释了，网上可以找到很多介绍性文章。<br> <img src="https://images2.imgbox.com/d2/4f/u2Jkpnxc_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2017_14"></a>起步期（2017年）</h4> 
<p>时间进入2017年，在这个年份里出现了两个在点云物体检测领域堪称里程碑式的工作：<br> VoxelNet[4]和PointNet++[5]。这两个工作代表了点云处理的两个基本方向，VoxelNet将点云量化为网格数据，而PointNet++直接处理非结构化的数据点。下面我会稍微详细的介绍一下这两个方法，因为之后点云物体检测领域几乎所有的方法都离不开这两个工作里的概念。<br> VoxelNet 这个工作是2017年由苹果公司的两位研究人员提出的，并且发表在了CVPR 2018上（计算机视觉和模式识别领域的顶会）。<br> 其思路并不复杂，首先将点云量化到一个均匀的3D网格中（下图中的grouping）。每个网格内部随机采样固定数量的点（不足的就重复），每个点用7维特征表示，包括该点的X，Y，Z坐标，反射强度R，以及该点相对网格质心（网格内所有点位置的均值）的位置差ΔX，ΔY和ΔZ。全连接层被用来提取点的特征，然后每个点的特征再与网格内所有点的特征均值进行拼接，得到新的点特征。这种特征的优点在于同时保留了单个点的特性和该点周围一个局部小区域（网格）的特性。这个点特征提取的过程可以重复多次，以增强特征的描述能力（下图中的Stacked Voxel Feature Encoding）。最终网格内的所有点进行最大池化操作（Max Pooling），以得到一个固定长度的特征向量。<br> 以上这些步骤称为特征学习网络，其输出是一个4D的Tensor（对应X，Y，Z坐标和特征）。这与一般的图像数据不同（图像是3D Tensor，只有X，Y坐标和特征），因此还没法直接采用图像物体检测的方法。VoxelNet中采用3D卷积对Z维度进行压缩（比如stride=2）。假设4D Tensor的维度为HxWxDxC，经过若干次3D卷积后，Z维度的大小被压缩为2（也就是HxWx2xC’），然后直接将Z维度与特征维度合并，生成一个3D的Tensor（HxWx2C’）。这就和标准的图像数据格式相似了，因此可以接上图像物体检测网络（比如Region Proposal Network，RPN）来生成物体检测框，只不过这里生成的是3D的检测框。<br> 从上面的介绍可以看出，VoxelNet的框架非常简洁，也是第一个可以真正进行端对端的学习的点云物体检测网络。实验结果表明，这种端对端的方式可以自动地从点云中学习到可用的信息，比手工设计特征的方式更为高效。<br> <img src="https://images2.imgbox.com/40/c7/60fJ3ISl_o.png" alt="在这里插入图片描述"><br> <strong>PointNet++</strong> 该方法的前身是PointNet[6]，由斯坦福大学的研究者在2017年发表，这也是点云处理领域的开创性工作之一。PointNet处理的是点云分类任务，其主要思路是直接处理原始的点云。除了一些几何变换之外，PointNet主要有两个操作：MLP（多个全连接层）提取点特征，MaxPooling得到全局特征。物体分类网络采用全局特征作为输入，而分割网络则同时采用全局特征和点特征。<br> 简单来说，你可以把PointNet分类网络看做一个分类器，比如可以理解为传统方法中的SVM。但是要进行物体检测的话，就还需要一个类似于Sliding Window的机制，也就是说在场景内的各个位置应用PointNet来区分物体和背景，以达到物体检测的效果。当然对于相对稀疏的点云数据来说，这种做法是非常低效的。因此，PointNet的作者同年就提出了升级版本，也就是PointNet++。<br> 其主要思路是用聚类的方式来产生多个候选区域（每个区域是一个点集），在每个候选区域内采用PointNet来提取点的特征。这个过程以一种层级化的方式重复多次，每一次聚类算法输出的多个点集都被当做抽象后的点云再进行下一次处理（Set Abstraction，SA）。这样得到的点特征具有较大的感受野，包含了局部邻域内丰富的上下文信息。最后，在多层SA输出的点集上进行PointNet分类，以区分物体和背景。同样的，这个方法也可以做点云分割。<br> <img src="https://images2.imgbox.com/9a/d9/AjurkQUm_o.png" alt="在这里插入图片描述">PointNet网络结构[6]<br> <img src="https://images2.imgbox.com/1b/11/oLdjDZIV_o.png" alt="在这里插入图片描述"><br> 与VoxelNet相比，PointNet++的优点在于：1）没有量化带来的信息损失，也无需调节量化超参数；2）忽略空白区域，避免了无效的计算。但是缺点也显而易见：1）无法利用成熟的基于空间卷积的2D物体检测算法；2）虽然避免了无效计算，但是GPU对于点云的处理效率远低于网格数据，因此实际的运行速度甚至更慢。</p> 
<h4><a id="20182020_28"></a>发展期（2018年-2020年）</h4> 
<p>在VoxelNet和PointNet++相继提出后，3D物体检测领域迎来了一个快速发展期，很多算法被提出，用来改进这两个工作中的不足。<br> <strong>对Voxel方法的改进</strong><br> <strong>VoxelNet</strong>的主要问题在于数据表示比较低效，中间层的3D卷积计算量太大，导致其运行速度只有大约2FPS（Frame Per Second），远低于实时性的要求，因此后续很多工作针对其运行效率的问题进行了改进。<br> **SECOND[7]**采用稀疏卷积策略，避免了空白区域的无效计算，将运行速度提升到了26FPS，同时也降低了显存的使用量。<br> **PIXOR[8]**提出通过手工设计的方式，将3D的Voxel压缩到2D的Pixel。这样做避免了3D卷积，但是损失了高度方向上的信息，导致检测准确度下降很多。<br> **PointPillar[9]**的思路也是3D转2D，也就是将点3D云量化到2D的XY平面网格。但是与PIXOR手工设计特征的方式不同，PointPillar把落到每个网格内的点直接叠放在一起，形象的称其为柱子(Pillar)，然后利用与PointNet相似的方式来学习特征，最后再把学到的特征向量映射回网格坐标上，得到与图像类似的数据。这样做一来避免了VoxelNet中的3D卷积和空白区域的无效计算(运行速度达到62FPS)，二来避免了手工设计特征导致信息丢失和网络适应性不强的问题，可以说是很巧妙的思路。不好的方面是，点特征的学习被限制在网格内，无法有效的提取邻域的上下文信息。<br> <img src="https://images2.imgbox.com/e2/64/TsO0SYV1_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Point_36"></a>对Point方法的改进</h4> 
<p>PointNet++采用基于聚类的方法来层级化的提取邻域特征以及获得物体候选，这种做法效率比较低，而且也很难做并行加速。而这恰巧是传统的2D卷积网络的强项，因此后续的工作逐渐将2D物体检测算法中的一些思路拿过来，用来解决PointNet++中的问题。<br> <strong>Point-RCNN</strong>[10]首先在这个方向了进行了探索，可以称得上3D物体检测领域的又一个里程碑式的工作。从名字上就能看出，这个方法将点云处理和2D物体检测领域的开山之作Faster RCNN结合了起来。首先，PointNet++被用来提取点特征。点特征被用来进行前景分割，以区分物体上的点和背景点。同时，每个前景点也会输出一个3D候选BBox。接下来就是将候选BBox内的点再做进一步的特征提取，输出BBox所属的物体类别，并且对其位置，大小进行细化。<br> 看到这里，熟悉2D物体检测的朋友肯定会说，这不就是一个典型的两阶段检测模型嘛。没错，但不同的是，Point-RCNN只在前景点上生成候选，这样避免了3D空间中生成稠密候选框所带来的巨大计算量。尽管如此，作为一个两阶段的检测器，加上PointNet++本身较大的计算量，Point-RCNN的运行效率依然不高，只有大约13FPS 。Point-RCNN后来被扩展为Part-A2[11]，速度和准确度都有一定的提升。<br> <img src="https://images2.imgbox.com/7f/d6/Hd2rFNDA_o.png" alt="在这里插入图片描述"><br> Point-RCNN网络结构[10]</p> 
<p><strong>3D-SSD</strong>[12]通过对之前Point-based方法的各个模块进行分析，得出结论：FP（Feature Propagation）层和细化层（Refinement）是系统运行速度的瓶颈。<br> FP层的作用是将SA层抽象后的点特征再映射回原始的点云，可以理解为上图中Point-RCNN的Point Cloud Decoder。这一步非常必要，因为SA输出的抽象点并不能很好的覆盖所有的物体，会导致很大的信息丢失。3D-SSD提出了一种新的聚类方法，同时考虑点与点之间在几何空间和特征空间的相似度。通过这种改进的聚类方法，SA层的输出可以直接用来生成物体Proposal，避免了FP层带来的大计算量。<br> 同时，为了避免Refinement阶段的Region Pooling，3D-SSD直接采用SA输出的代表点，利用前面提到了改进聚类算法找到其邻域点，用一个简单的MLP来预测类别和物体框3D BBox。3D-SSD可以认为是一个Anchor-Free的单阶段检测器，这也符合整个物体检测领域的发展趋势。通过以上改进，3D-SSD的运行速度可以达到25FPS。<br> <img src="https://images2.imgbox.com/6c/e9/lhyWOmhK_o.png" alt="在这里插入图片描述"><br> 3D-SSD网络结构[12]<br> 对于非结构化的点云数据，用图模型来表示也是一种很自然的想法。但是图神经网络相对比较复杂，虽然近些年发展也很快，但是在3D物体检测上的工作并不多。<strong>PointGNN</strong>[13]是其中一个比较典型的工作。其流程主要分为三步：首先根据一个预设的距离阈值来建立图模型；然后更新每个顶点以获取邻域点的信息，用来检测物体类别和位置，最后融合多个顶点输出的3D物体框，作为最终的检测结果。这种基于图模型的方法在思路上非常新颖，但是训练和推理过程的计算量太大。论文中指出完成一次训练需要花费将近一周的时间，这大大降低了该类方法的实用性。<br> <img src="https://images2.imgbox.com/18/b2/2hh78zjQ_o.png" alt="在这里插入图片描述"><br> PointGNN网络结构[13]<br> <strong>Voxel和Point方法的融合</strong><br> 以上回顾了Voxel-based和Point-based两个主要方向上的改进。其实，在这个阶段，研究者已经有意无意的将两种策略进行融合，以取长补短。PointPillar就是一个例子，虽然点云被按照类似Voxel的方式进行量化，但是点特征的学习是采用类似PointNet的方式。虽然说算法的性能并不是最好的，但是其思路还是非常值得思考的。沿着这个方向，后续又出现了很多不错的工作。<br> 在介绍更多的工作之前，有必要来总结一下之前的代表性方法，看看它们在检测率和速度上的对比如何。这里我们采用行业内最流行的KITTI数据库来作为评测的基准。至于更大规模和更针对自动驾驶应用的nuScenes和Waymo数据库，我们留在后面再讨论。<br> KITTI采用Velodyne激光雷达，在城市道路环境下采集数据，其3D物体识别任务的类别包括车辆，行人和骑车的人。因为早期一些算法只提供了车辆检测的正确率，因此这里我们就只对比车辆这个类别。这里算法的准确度采用中等难度测试集上的AP作为指标，而速度则采用FPS来衡量，这两个指标都是越高越好。</p> 
<p><img src="https://images2.imgbox.com/b5/de/9X2v1DmO_o.png" alt="在这里插入图片描述"><br> 从上表的对比中可以看出，基于Voxel的方法速度较快，准确度偏低。基于Point的方法速度明显偏慢，但是准确度相对较高。一个成功的算法要同时考虑速度和准确度，在两者之间寻求最优的平衡。<br> 那么再来回顾一下Voxel和Point的主要问题。前者非常依赖于量化的参数：网格大的话信息损失比较大，网格小的话的计算量和内存使用量又非常高。后者很难提取邻域的上下文特征，并且内存的访问是不规则的（大约80%的运行时间都耗费在数据构建，而不是真正的特征提取上）。<br> 因此，两者融合的基本思路是：利用较低分辨率的Voxel来提取上下文特征（比如PV-CNN [14]）或者生成物体候选（Fast Point RCNN [15]），或者二者兼有（比如PV-RCNN [16]，SA-SSD[17]），然后再与原始的点云结合，这样单个点的特征和点点之间的空间关系也可以同时保留。<br> 在PV-CNN中，一个分支采用低分辨率的Voxel来提取具有邻域信息的特征，然后再通过插值的方法映射回每个点上。另一个分支直接从原始点出发，利用MLP来提取点特征，这时虽然没有邻域信息，但是单个点的特征提取是相对精确的。最后把两个分支的特征进行拼接，作为下一步的输入。<br> <img src="https://images2.imgbox.com/3e/9d/nSx0hBpV_o.png" alt="在这里插入图片描述"><br> PV-CNN网络结构[14]</p> 
<p>类似的，PV-RCNN的一个分支将点云量化到不同分辨率的Voxel，以提取上下文特征和生成3D物体候选。另外一条分支上采用类似于PointNet++中Set Abstraction的操作来提取点特征。这里比较特别的是，每个点的领域点并不是原始点云中的点，而是Voxel中的点。由于Voxel中的点具有多分辨率的上下文信息，点特征提取也就同时兼顾了单个点以及邻域信息，这与PV-CNN中的思路是类似的。值得一提的是，PV-RCNN和Fast Point RCNN都属于两阶段的检测方法，有一个ROI Pooling的步骤，因此运行速度会收到影响（PV-RCNN只有12.5FPS，Fast Point R-CNN也只有16.7FPS）。<br> <img src="https://images2.imgbox.com/15/49/fvdHtznW_o.png" alt="在这里插入图片描述"><br> PV-RCNN网络结构[16]<br> SA-SSD通过附加的前景分割和物体中心点估计任务引导Voxel分支去更好的学习点特征和利用点之间的空间关系，同时也避免了3D物体候选框和ROI Pooling步骤。作为一个单阶段的检测器，SA-SSD可以达到25FPS，准确度也仅比PV-RCNN略低（79.79% vs. 81.43%）。<br> <img src="https://images2.imgbox.com/7f/bd/p4kRKE2l_o.png" alt="在这里插入图片描述"><br> SA-SSD网络结构[17]</p> 
<h4><a id="2020_71"></a>落地期（2020年至今）</h4> 
<p>在之前的快速发展期中，3D物体检测的各种策略都被充分的研究和实验，人们也获得了很多宝贵的经验。那么，下一步很自然就是需要确定最优的策略，以及如何将算法与实际的应用相结合。因此，在这一阶段，研究的重心开始往算法的实用性上和可落地性上转移。<br> 针对自动驾驶应用来说，基于激光雷达的3D物体检测一方面是重要的感知信号来源，是自动驾驶系统的核心之一，因此我们需要充分的考虑实时性和准确性的平衡。另一方面，激光雷达在很多时候会作为辅助的传感器来辅助离线的数据标注。比如，毫米波雷达的点云非常稀疏，底层数据又无法直观的理解，因此很难在其上进行精确的物体标注。这个时候激光雷达或者摄像头的辅助就变得非常重要。一般来说，自动的物体检测算法会和人工标注进行结合，以提高标注效率。在这种应用中，最关注的是检测算法的准确度而不是速度。<br> 因此，个人认为现阶段3D物体检测的发展有两个趋势：一个是追求速度和准确度的平衡，另一个是在保证一定速度的前提下最大化准确度。前者一般会采用Voxel加单阶段检测器，后者一般会融合Voxel和Point，甚至采用两阶段的检测器，以获得更为精细的物体框。下面结合几个2021年最新的工作，来做进一步的分析。<br> <strong>SIENet</strong>[18]是一个基于Voxel和Point融合的两阶段检测方法，其融合策略与PV-RCNN相似。为了解决远处物体点云相对稀疏的问题，SIENet采用了一个附加分支，将Voxel的网格看做额外的点，以此来对远处物体进行补全。SIENet在KITTI车辆检测上的AP为81.71%，但是速度只有12.5FPS，基本上与PV-RCNN相当。<br> <img src="https://images2.imgbox.com/f7/13/ORGWe6UM_o.png" alt="在这里插入图片描述"><br> SIENet网络结构[18]<br> Voxel R-CNN[19]也是一个两阶段检测器，但是只采用了Voxel来做特征提取，其结构更加简洁。通过一个特别设计的Voxel ROI Pooling模块，该方法可以进一步提高物体检测的精确度。其余的部分与一般的基于Voxel方法非常相似，这里就不详细描述了。Voxel RCNN在KITTI车辆检测上的AP为81.62%，与SIENet相当，但是速度提升了一倍，达到25.2FPS。<br> <img src="https://images2.imgbox.com/35/bd/W254kS0z_o.png" alt="在这里插入图片描述"><br> Voxel R-CNN网络结构[19]</p> 
<p><strong>CIA-SSD</strong>[20]是一个基于Voxel的单阶段检测方法。其特征提取阶段与SECOND类似，都是采用稀疏3D卷积。不同的是CIA-SSD将网格内点的均值作为起始特征（没有采用VoxelNet中的多阶段MLP），而且通过不断降低空间分辨率来进一步减少计算量，最后将Z方向的特征拼接以得到2D特征图（类似VoxelNet中的做法）。<br> 作为一个单阶段的检测器，CIA-SSD借鉴了图像物体检测领域的一些技巧。比如，为了更好的提取空间和语义特征，CIA-SSD采用了一种类似于Feature Pyramid Network （FPN）的结构，当然这里的细节设计稍微复杂一些。此外，为了解决单阶段检测器分类置信度和定位准确度之间的差异问题，CIA-SSD采用了IoU预测分支，以修正分类的置信度和辅助NMS。结合以上这些策略，CIA-SSD在KITTI车辆检测的AP达到80.28%，速度为33FPS。CIA-SSD之后被扩展为<strong>SE-SSD</strong>[21]，速度不变，AP提升到82.54%，这其实已经超越了基于Voxel和Point融合的两阶段检测器。<br> <img src="https://images2.imgbox.com/3f/7d/xsTsmabU_o.png" alt="在这里插入图片描述"><br> CIA-SSD[20]网络结构<br> CenterPoint[22]是由目前图像物体检测中流行的CenterNet演化得到的。与CenterNet的单阶段检测不同，CenterPoint采用了两阶段的方式。在第一阶段中，其特征提取的主干网络可以采用VoxelNet或者PointPillar的方式，得到的是一个HxWxC的二维图像加通道的数据结构。检测网络的部分和CenterNet非常相似，只是针对BEV数据非常稀疏的特点，调整高斯分布的参数，以增加正样本的数量。在第二阶段中，从已经预测的BBox出发，收集BBox边缘的点特征，用一个MLP对置信度和BBox参数进行细化。这与传统的两阶段检测非常相似，只不过ROI Pooling只在一些稀疏的点上进行，效率比较高。CenterNet的整个流程非常简洁，但是在NuScenes和Waymo数据库上的准确度都到达了state-of-the-art，充分说明了目前业界追求简单高效的趋势。<br> <img src="https://images2.imgbox.com/d4/8b/iJTgcIy4_o.png" alt="在这里插入图片描述"><br> CenterPoint网络结构图[22]</p> 
<h4><a id="_89"></a>新的数据库和基准评测</h4> 
<p>以上关于检测准确度和速度的分析都是基于KITTI数据库。近两年来，为了更好的评测3D物体检测算法，并且更加贴近自动驾驶场景，工业界构建了两个更大规模的数据库：Waymo Open Dataset和NuScenes，其数据量比KITTI高出两个量级。这两个数据库上都组织了3D物体识别竞赛，使得业界的研究和工程人员可以清楚的了解当前最实用的技术。尤其是2021年的Waymo 3D物体识别竞赛，还特别增加了对运行时间的要求，进一步的强调了算法的可落地性。从近两届比赛获胜的算法来看，基于Voxel的单阶段方法成为主流，这也与图像物体检测领域的发展趋势相契合。前文介绍的很多技巧，比如轻量级的Voxel特征提取，稀疏3D卷积，FPN，IoU预测分支等等，都在获胜的算法中有所体现。这从另一个侧面说明了当前技术的最高水平，也为3D物体检测领域的进一步发展提供了方向。</p> 
<p>链接：https://www.zhihu.com/question/448472033/answer/2136340327</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cc15dc25899a305c6d8a848ac5edda2d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysql事务</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/94307427f66c6de6d5f6d0cfaae8dfe2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">javaweb简单的图书购买系统，超详细教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>