<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LINUX ：（面试题）三次握手、四次挥手的过程 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LINUX ：（面试题）三次握手、四次挥手的过程" />
<meta property="og:description" content="一、三次握手过程（每一次都携带了什么数据？ACK为什么加一？） 首先来看一下TCP的头部：
其中标志位分别为：
序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。
确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号&#43;1即为确认号。
确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效
同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。
终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接
PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。
图解三次握手： SYN：同步序列编号(Synchronize Sequence Numbers)
文字说明： (1).第一次握手：建立连接。客户端发送连接请求报文段(SYN),然后客户端进入SYN_SEND状态，等待服务器的确认。
(2).第二次握手：服务器收到请求。服务器收到SYN请求报文段之后，去要对这个SYN报文段进行确认，同时自己还要发送SYN信息，表示同意连接。服务器将上述信息都放在同一个报文段中(SYN&#43;ACK)报文段,一并发送给客户端。此时，客户端进入SYN_RECV状态。【listen之后（内核的网络模块完成），accept之前（从内核维护的已完成连接的队列中获取一个客户端）】
(3).第三次握手：客户端收到服务器发来的SYN&#43;ACK报文段。客户端向服务器发送ACK报文段，这个报文段发送完毕，客户端和服务器都进入ESTABLISHED状态，完成TCP三次握手。
ACK加一：确认号是为了保证在整个数据发送过程中，确认之前发送的数据都已经收到，可以放心对后面数据进行发送。Ack&#43;1可以确认下一次发送的起始位置。
二、四次挥手 图解： 文字说明： (1).第一次挥手：主机1向主机2发送FIN报文段，表示要断开连接，之后主机1进入FIN_WAIT_1的状态，表示已经没有数据要进行发送了。【主机1和主机2可以理解为主动断开方与被动断开方，客户端/服务器端都可以作为主动断开方与被动断开方】
(2).第二次挥手：主机2收到主机1发来的FIN断开连接请求后，向主机1发送一个ACK报文段，表示同意你的断开连接请求，此时主机1进入FIN_WAIT_2状态，主机2进入CLOSE_WAIT状态，开始处理未传输完的数据。
(3).第三次挥手：主机2这时候已经处理完未发送的数据，并向主机1发送FIN报文段，表示关闭连接，此时主机2进入LAST_ACK状态。
(4).第四次挥手：主机1接收到主机2的FIN关闭连接请求后，向主机2发送ACK报文段，主机1进入TIME_WAIT状态，主机2收到ACK响应报文段之后就可以关闭连接处于CLOSED状态，主机1在等待2MSL后，没有收到来自主机2的任何回应后，关闭连接。
六大标志位： SYN:同步标志位；ACK:确认标志位；PSH:传送标志位【数据传输】；FIN:结束标志位；RST:重置标志位【连接重置】；URG：紧急标志位；
2MSL含义： 任何报文段在被丢弃前允许在网络中存在的最长时间。为了更安全的断开连接，保证迟来的数据被丢弃。
TIME_WAIT状态含义(2MSL等待状态)： 保证迟来的数据能被识别并丢弃，完成可靠的中止TCP连接。
三、相关问题： （1）为什么是三次不是两次？ （2） 那个阶段容易受到攻击？ （3） 什么时候开始进行三次握手 （4）为什么连接的时候是三次握手，关闭的时候却是四次握手？ 因为当Server端收到Client端的SYN连接求报文后，可以直接发送SYN&#43;ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，&#34;你发的FIN报文我收到了&#34;。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
（5）为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。
（6）如果已经建立了连接，但是客户端突然出现故障了怎么办？ TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
参考：https://blog.csdn.net/scuzoutao/article/details/81774100" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5c96689c0fe3ef342d4cbbae555f1823/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-22T23:43:59+08:00" />
<meta property="article:modified_time" content="2019-07-22T23:43:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LINUX ：（面试题）三次握手、四次挥手的过程</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、三次握手过程（每一次都携带了什么数据？ACK为什么加一？）</h3> 
<p>首先来看一下TCP的头部：</p> 
<p> </p> 
<p style="text-align:center;"><img alt="" class="has" height="281" src="https://images2.imgbox.com/50/92/4E4jaGTG_o.png" width="488"></p> 
<p>其中标志位分别为：</p> 
<p> <strong>序列号seq</strong>：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。</p> 
<p>  <strong>确认号ack：</strong>占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</p> 
<p><strong>  确认ACK：</strong>占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效</p> 
<p>  <strong>同步SYN：</strong>连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</p> 
<p>  <strong>终止FIN：</strong>用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</p> 
<p>    PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。<br>  </p> 
<h4><strong>图解三次握手：</strong></h4> 
<p style="text-align:center;"><img alt="" class="has" height="247" src="https://images2.imgbox.com/96/8c/7zxd8Ncu_o.png" width="553"></p> 
<p>SYN：同步序列编号(Synchronize Sequence Numbers)</p> 
<h4><strong>文字说明：</strong></h4> 
<p style="margin-left:0cm;">(1).第一次握手：建立连接。客户端<span style="color:#00b0f0;">发送连接请求报文段(SYN)</span>,然后客户端进入<span style="color:#00b0f0;">SYN_SEND</span><span style="color:#00b0f0;">状态</span>，等待服务器的确认。</p> 
<p style="margin-left:0cm;">(2).第二次握手：服务器收到请求。服务器收到SYN请求报文段之后，去要对这个<span style="color:#000000;">SYN</span><span style="color:#000000;">报文段进行确认</span>，同时自己还要发送SYN信息，表示同意连接。服务器将上述信息都<span style="color:#00b0f0;">放在同一个报文段中(SYN+ACK)报文段</span>,一并发送给客户端。此时，客户端进入<span style="color:#00b0f0;">SYN_RECV</span><span style="color:#00b0f0;">状态</span>。【<span style="color:#ff0000;">listen</span><span style="color:#ff0000;">之后</span>（内核的网络模块完成），<span style="color:#ff0000;">accept</span><span style="color:#ff0000;">之前</span>（从内核维护的已完成连接的队列中获取一个客户端）】</p> 
<p style="margin-left:0cm;">(3).第三次握手：客户端收到服务器发来的SYN+ACK报文段。客户端向服务器发送ACK报文段，这个报文段发送完毕，<span style="color:#00b0f0;">客户端和服务器都进入ESTABLISHED状态</span>，完成TCP三次握手。</p> 
<p style="margin-left:0cm;"><span style="color:#ff0000;">ACK</span><span style="color:#ff0000;">加一</span>：确认号是为了保证在整个数据发送过程中，确认之前发送的数据都已经收到，可以放心对后面数据进行发送。Ack+1可以确认下一次发送的起始位置。</p> 
<p style="margin-left:0cm;"> </p> 
<h3>二、四次挥手</h3> 
<h4>图解：</h4> 
<p style="text-align:center;"><img alt="" class="has" height="316" src="https://images2.imgbox.com/77/5e/NauxLMRD_o.png" width="461"></p> 
<h4>文字说明：</h4> 
<p style="margin-left:0cm;">(1).第一次挥手：主机1向主机2<span style="color:#00b0f0;">发送FIN报文段</span>，表示要断开连接，之后主机1<span style="color:#00b0f0;">进入FIN_WAIT_1的状态</span>，表示已经没有数据要进行发送了。【主机1和主机2可以理解为<span style="color:#00b0f0;">主动断开方与被动断开方</span>，客户端/服务器端都可以作为主动断开方与被动断开方】</p> 
<p style="margin-left:0cm;">(2).第二次挥手：主机2收到主机1发来的FIN断开连接请求后，向主机1<span style="color:#00b0f0;">发送一个ACK报文段</span>，表示同意你的断开连接请求，此时<span style="color:#00b0f0;">主机1进入FIN_WAIT_2状态</span>，主机2进入<span style="color:#00b0f0;">CLOSE_WAIT</span><span style="color:#00b0f0;">状态</span>，开始处理未传输完的数据。</p> 
<p style="margin-left:0cm;">(3).第三次挥手：主机2这时候已经处理完未发送的数据，并向主机1发送FIN报文段，表示关闭连接，此时<span style="color:#00b0f0;">主机2进入LAST_ACK状态</span>。</p> 
<p style="margin-left:0cm;">(4).第四次挥手：主机1接收到主机2的FIN关闭连接请求后，向主机2发送<span style="color:#00b0f0;">ACK</span><span style="color:#00b0f0;">报文段</span>，主机1进入<span style="color:#00b0f0;">TIME_WAIT</span><span style="color:#00b0f0;">状态</span>，主机2收到ACK响应报文段之后就可以关闭连接处于CLOSED状态，主机1在<span style="color:#00b0f0;">等待2MSL</span>后，没有收到来自主机2的任何回应后，关闭连接。</p> 
<h4 style="margin-left:0cm;">六大标志位：</h4> 
<p style="margin-left:0cm;">SYN:同步标志位；ACK:确认标志位；PSH:传送标志位【数据传输】；FIN:结束标志位；RST:重置标志位【连接重置】；URG：紧急标志位；</p> 
<h4 style="margin-left:0cm;">2MSL含义：</h4> 
<p style="margin-left:0cm;">任何报文段在被丢弃前允许在网络中存在的最长时间。为了更安全的断开连接，保证迟来的数据被丢弃。</p> 
<h4 style="margin-left:0cm;">TIME_WAIT状态含义(2MSL等待状态)：</h4> 
<p style="margin-left:0cm;">保证迟来的数据能被识别并丢弃，完成可靠的中止TCP连接。</p> 
<p style="margin-left:0cm;"> </p> 
<h3><strong> 三、相关问题：</strong></h3> 
<h4>（1）为什么是三次不是两次？</h4> 
<p> </p> 
<p style="text-align:center;"><img alt="" class="has" height="422" src="https://images2.imgbox.com/a9/bd/xeDaF9mR_o.png" width="690"></p> 
<h4>（2） 那个阶段容易受到攻击？</h4> 
<p style="text-align:center;"><img alt="" class="has" height="181" src="https://images2.imgbox.com/bb/6a/Ph27NFgd_o.png" width="704"></p> 
<p> </p> 
<h4>（3） 什么时候开始进行三次握手</h4> 
<p style="text-align:center;"><img alt="" class="has" height="36" src="https://images2.imgbox.com/4e/1e/P7WwlC58_o.png" width="607"></p> 
<h4>（4）为什么连接的时候是三次握手，关闭的时候却是四次握手？</h4> 
<p>因为当Server端收到Client端的SYN连接求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p> 
<h4><br> （5）为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</h4> 
<p> 虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，<span style="color:#f33b45;">有可以最后一个ACK丢失。</span>所以TIME_WAIT状态就是用来重发<span style="color:#f33b45;">可能丢失的ACK报文</span>。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p> 
<h4><br> （6）如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4> 
<p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。<br>  </p> 
<h3> </h3> 
<p><a href="https://blog.csdn.net/scuzoutao/article/details/81774100">参考：https://blog.csdn.net/scuzoutao/article/details/81774100</a></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a1df1acad8cce7859a47c1ea13510988/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">链表的基本操作:建立，增加，删除指定位置元素，销毁（C语言）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8026b184462157271f91f803a31573e8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一个会“说话”的油箱盖，告诉你每一滴油的去向</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>