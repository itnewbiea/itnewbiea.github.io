<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Set 接口常用实现类底层分析 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Set 接口常用实现类底层分析" />
<meta property="og:description" content="一、Set 接口 1.1 特点 无序（添加和取出的顺序不一致），没有索引。不允许重复元素，所以最多包含一个 null。
1.2 常用实现类 HashSet、TreeSet、CopyOnWriteArraySet
1.3 常用方法 和 List 接口一样，Set 接口也是 Collection 的子接口，因此，常用方法和 Collection 接口是一样的。 1.4 遍历方式 同 Collection 的遍历方式一样，因为 Set 接口是 Collection 接口的子接口。可以使用迭代器、增强 for 循环、但是不能使用索引的方式来获取。
1.5 代码展示 public class SetTest { public static void main(String[] args) { // Set 接口的实现类对象不能存放重复元素，可以添加一个 null // Set 接口对象存放的数据是无序的（添加的顺序和取出的顺序不一致） // 注意：取出元素的顺序虽然不是添加的顺序，但是他每次打印顺序都是固定的 Set set = new HashSet(); set.add(&#34;zhangSan&#34;); set.add(&#34;liSi&#34;); set.add(&#34;zhangSan&#34;); set.add(null); set.add(null); System.out.println(&#34;set=&#34;&#43;set); System.out.println(&#34;----------------&#34;); // 遍历的方式一：使用迭代器 Iterator iterator = set.iterator(); while (iterator." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0abbcc7ecb4c48b9e7f1e1c867e7a108/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-08T15:03:54+08:00" />
<meta property="article:modified_time" content="2023-11-08T15:03:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Set 接口常用实现类底层分析</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、Set 接口</h2> 
<h3>1.1 特点</h3> 
<p>        无序（添加和取出的顺序不一致），没有索引。不允许重复元素，所以最多包含一个 <strong>null</strong>。</p> 
<h3>1.2 常用实现类</h3> 
<p>        <strong>HashSet</strong>、<strong>TreeSet</strong>、<strong>CopyOnWriteArraySet</strong></p> 
<h3><strong>1.3 常用方法</strong></h3> 
<p>        和 <strong>List </strong>接口一样，<strong>Set </strong>接口也是 <strong>Collection </strong>的子接口，因此，常用方法和 <strong>Collection </strong>接口是一样的。   <strong> </strong></p> 
<h3><strong>1.4 遍历方式</strong></h3> 
<p>        同 <strong>Collection </strong>的遍历方式一样，因为 <strong>Set </strong>接口是 <strong>Collection </strong>接口的子接口。可以使用迭代器、增强 <strong>for </strong>循环、但是不能使用索引的方式来获取。</p> 
<h3>1.5 代码展示</h3> 
<pre><code class="language-java">public class SetTest {
    public static void main(String[] args) {
        // Set 接口的实现类对象不能存放重复元素，可以添加一个 null
        // Set 接口对象存放的数据是无序的（添加的顺序和取出的顺序不一致）
        // 注意：取出元素的顺序虽然不是添加的顺序，但是他每次打印顺序都是固定的
        Set set = new HashSet();
        set.add("zhangSan");
        set.add("liSi");
        set.add("zhangSan");
        set.add(null);
        set.add(null);
        System.out.println("set="+set);
        System.out.println("----------------");
        // 遍历的方式一：使用迭代器
        Iterator iterator = set.iterator();
        while (iterator.hasNext()) {
            Object o =  iterator.next();
            System.out.println(o);
        }
        System.out.println("----------------");
        // 遍历的方式二：使用增强for循环
        for (Object o :set) {
            System.out.println(o);
        }
    }
}</code></pre> 
<h2>二、HashSet</h2> 
<h3>2.1 特点</h3> 
<p>        <strong>HashSet </strong>实现了 <strong>Set </strong>接口，可以存放 <strong>null</strong>，但只能有一个 <strong>null</strong>。<strong>HashSet </strong>不保证元素是有序的，即不保证存放元素的顺序和取出的顺序一致。<strong>HashSet </strong>其实是 <strong>HashMap</strong>，源码如下：</p> 
<pre><code class="language-bash">public HashSet() {
    map = new HashMap&lt;&gt;();
}</code></pre> 
<h3>2.2 底层机制</h3> 
<p>        <strong>HashSet </strong>底层是 <strong>HashMap</strong>，添加一个元素的时候，会先使用 <strong>hashCode() </strong>方法计算该元素的 <strong>hash </strong>值。然后对 <strong>hash </strong>值进行运算得到一个索引值，这个索引值即为要存放在哈希表的位置号。</p> 
<p>        如果该位置上没有其他元素，则直接存放；如果该位置上已经有其他元素了，则需要进行 <strong>equals </strong>判断（<strong>equals </strong>方法一般都需要根据业务进行重写），如果相等，则不再添加，如果不相等，则以链表的形式添加到后面。</p> 
<p class="img-center"><img alt="" height="561" src="https://images2.imgbox.com/fc/67/REExKyFS_o.png" width="731"></p> 
<h3>2.3 扩容机制</h3> 
<p>        <strong>HashSet </strong>底层是 <strong>HashMap</strong>，第一次添加元素的时候，<strong>table </strong>数组扩容到 <strong>16</strong>，临界值 = <strong>16 *</strong> <strong>0.75 = 12</strong>；即<strong>临界值  = 容量 * 加载因子</strong>。</p> 
<p>        如果 <strong>table </strong>数组使用到了临界值 <strong>12</strong> ，就会扩容到 <strong>16 * 2 = 32</strong>，新的临界值就是<strong> 32 * 0.75 = 24</strong>，依次类推。</p> 
<h3>2.4 转红黑树机制</h3> 
<p>        在 <strong>java8 </strong>中，如果一条链表的元素个数到达<strong> 8 </strong>个，此时 <strong>table </strong>数组的长度是 <strong>16</strong>，那么此时就会发生数组扩容，此时的状态为：链表长度为 <strong>8</strong>，<strong>table </strong>数组的长度为 <strong>32</strong>；此时再向链表里面添加元素，又会发生扩容，此时的状态为：链表长度为<strong> 9</strong> ，<strong>table </strong>数组的长度为 <strong>64</strong>；此时再向链表里面添加元素，就会触发树化，即这一条链表变为红黑树，其他的链表不受任何影响。</p> 
<p>        在 <strong>java8 </strong>中，如果一条链表的元素个数到达 <strong>TREEIFY_THRESHOLD </strong>(默认是 <strong>8</strong> ) 并且 <strong>table </strong>数组的大小<strong> &gt;= MIN_TREEIF_CAPACITY</strong>(默认是 <strong>64</strong>)，就会进行树化，否则仍然采用数组的扩容机制。</p> 
<h3>2.5 习题练习</h3> 
<h4>2.5.1 简单</h4> 
<p>        定义一个 <strong>Employee </strong>类，该类包含 <strong>private </strong>成员属性 <strong>name </strong>和 <strong>age</strong>，要求：创建 <strong>3</strong> 个 <strong>Employee </strong>对象放入 <strong>HashSet </strong>中，当 <strong>name </strong>和 <strong>age </strong>的值相同时，认为是相同员工，不能添加到 <strong>HashSet </strong>中。代码如下：</p> 
<pre><code class="language-java">public class Employee{

    private String name;
    private int age;

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Employee() {
    }

   // setter、getter、toString()

    // 重写 hashCode 方法，因为这三个元素的 hashCode 都不一样
    @Override
    public int hashCode() {
        String name = this.getName();
        int  age = this.getAge();
        int nameCode = name.hashCode();
        int result = age + nameCode;
        return result;
    }
    // 重写 equals 方法，若 name 和 age 相同就认为是同一个元素
    @Override
    public boolean equals(Object obj) {
        Employee employee =(Employee)obj;
        if(this.getName() == employee.getName() &amp;&amp; this.getAge() == employee.getAge()){
            return true;
        }else{
            return false;
        }
    }
}</code></pre> 
<p>        测试代码类如下：</p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {

        Set set = new HashSet();

        Employee e1 = new Employee("张三",18);
        Employee e2 = new Employee("李四",18);
        Employee e3 = new Employee("张三",18);
        set.add(e1);
        set.add(e2);
        set.add(e3);

        System.out.println("set = "+set);
    }
}</code></pre> 
<h4>2.5.2 复杂</h4> 
<p>        定义一个 <strong>Employee </strong>类，该类包含 <strong>private </strong>成员属性 <strong>name、sal 和 birthday</strong>，其中 <strong>birthady </strong>为 <strong>MyDate </strong>类型（属性包括：<strong>year</strong>、<strong>month</strong>、<strong>day</strong>）。要求</p> 
<p>        1、创建<strong> 3 </strong>个 <strong>Employee </strong>对象放入 <strong>HashSet </strong>中</p> 
<p>        2、当 <strong>name </strong>和 <strong>birthday </strong>的值相同时，认为是相同员工，不能添加到 <strong>HashSet </strong>集合中。</p> 
<pre><code class="language-java">public class MyDate {

    private int year;
    private int month;
    private int day;

    public MyDate(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }
   // setter、getter、toString()
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        MyDate myDate = (MyDate) o;
        return year == myDate.year &amp;&amp; month == myDate.month &amp;&amp; day == myDate.day;
    }
    @Override
    public int hashCode() {
        return Objects.hash(year, month, day);
    }
}</code></pre> 
<pre><code class="language-java">class Employee {

    private String name;
    private String sal;
    private MyDate birthday;

   // getter、setter、toString()

    public Employee(String name, String sal, MyDate birthday) {
        this.name = name;
        this.sal = sal;
        this.birthday = birthday;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employee employee = (Employee) o;
        return Objects.equals(name, employee.name)  &amp;&amp; Objects.equals(birthday, employee.birthday);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, birthday);
    }
}</code></pre> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        Set set = new HashSet();

        set.add(new Employee("张三","30",new MyDate(1992,8,19)));
        set.add(new Employee("李四","30",new MyDate(1993,8,19)));
        set.add(new Employee("张三","50",new MyDate(1992,8,19)));

        System.out.println("set =" + set);
    }
}</code></pre> 
<h2>三、LinkedHashSet</h2> 
<h3>3.1 特点</h3> 
<p>        <strong>LinkedHashSet </strong>是 <strong>HashSet </strong>的子类，<strong>LinkedHashSet </strong>底层是一个 <strong>LinkedHashMap</strong>，底层维护了一个<strong>数组+双向链表</strong>。</p> 
<p>        <strong>LinkedHashSet </strong>根据元素的 <strong>hashCode</strong> 值来决定元素的存储位置，同时使用链表维护元素的次序，<strong>这使得元素看起来是以插入顺序保存的</strong>。也是不允许插入重复元素。</p> 
<h3>3.2 底层机制</h3> 
<p><strong>        LinkedHashSet</strong> 中维护了一个 <strong>hash </strong>表和双向链表（<strong>LinkedHashSet </strong>有 <strong>head </strong>和 <strong>tail</strong>），每一个节点有 <strong>before </strong>和 <strong>after </strong>属性，这样就形成了双向链表。</p> 
<p>        在添加一个元素时，先求 <strong>hash </strong>值再求索引，根据索引确定元素在 <strong>table </strong>表中的位置，然后将添加的元素加入到双向链表（如果已经存在则不添加）。</p> 
<p>        这样的话，我们遍历 <strong>LinkedHashSet </strong>也能确保插入顺序和遍历顺序一致。</p> 
<h3>3.3 扩容机制</h3> 
<p><strong>        LinkedHashSet </strong>的底层结构为<strong>数组 + 双向链表</strong>。第一次添加元素的时候，直接将数组 <strong>table </strong>扩容到 <strong>16</strong>。临界值 = <strong>16 *</strong> <strong>0.75 = 12</strong>；即 <strong>临界值  = 容量 * 加载因子</strong>。</p> 
<p>        如果 <strong>table </strong>数组使用到了临界值 <strong>12</strong> ，就会扩容到 <strong>16 * 2 = 32</strong>，新的临界值就是<strong> 32 * 0.75 = 24</strong>，依次类推。</p> 
<h3>3.4 转红黑树机制</h3> 
<p>        在 <strong>java8 </strong>中，如果一条链表的元素个数到达<strong> 8 </strong>个，此时 <strong>table </strong>数组的长度是 <strong>16</strong>，那么此时就会发生数组扩容，此时的状态为：链表长度为 <strong>8</strong>，<strong>table </strong>数组的长度为 <strong>32</strong>；此时再向链表里面添加元素，又会发生扩容，此时的状态为：链表长度为<strong> 9</strong> ，<strong>table </strong>数组的长度为 <strong>64</strong>；此时再像链表里面添加元素，就会触发树化，即这一条链表变为红黑树，其他的链表不受任何影响。</p> 
<p>        在 <strong>java8 </strong>中，如果一条链表的元素个数到达 <strong>TREEIFY_THRESHOLD </strong>(默认是 <strong>8</strong> ) 并且 <strong>table </strong>数组的大小<strong> &gt;= MIN_TREEIF_CAPACITY</strong>(默认是 <strong>64</strong>)，就会进行树化，否则仍然采用数组的扩容机制。</p> 
<h3>3.5 LinkedHashSet 和 HashSet 比较</h3> 
<p>        <strong>LinkedHashSet </strong>和 <strong>HashSet </strong>相比，唯一的变化就是由单向链表变成了双向链表，这样做的好处是保证了元素的顺序性。</p> 
<h3>3.6 习题练习</h3> 
<p>        有一个 <strong>Car </strong>类（属性为 <strong>name </strong>和 <strong>price</strong>），如果 <strong>name </strong>和 <strong>price </strong>一样，则认为是相同元素，就不能添加。</p> 
<pre><code class="language-java">class Car {
    private String name;
    private String price;

    public Car(String name, String price) {
        this.name = name;
        this.price = price;
    }
   // setter、getter、toString()

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Car car = (Car) o;
        return Objects.equals(name, car.name) &amp;&amp; Objects.equals(price, car.price);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, price);
    }
}</code></pre> 
<pre><code class="language-java">public class TestLink {
    public static void main(String[] args) {
        Set set = new LinkedHashSet();

        set.add(new Car("小汽车","30"));
        set.add(new Car("小玩偶","40"));
        set.add(new Car("小汽车","30"));

        System.out.println("set="+set);
    }
}</code></pre> 
<h2>四、TreeSet</h2> 
<h3>4.1 特点</h3> 
<h4 style="background-color:transparent;">4.1.1 无参构造</h4> 
<p>        当我们使用无参构造器创建 <strong>TreeSet </strong>时，属于自然排序，当进行去重操作时，会调用 <strong>key </strong>默认实现的 <strong>Comparable </strong>类的<strong> compareTo() </strong>方法进行去重。</p> 
<pre><code class="language-java">public class TreeSetTest {
    public static void main(String[] args) {
        TreeSet treeSet = new TreeSet();
        // 添加元素
        // 未指定排序方式时会调用 String 本身的 Comparable 类的 compare() 方法进行排序和去重
        treeSet.add("jack");
        treeSet.add("tom");
        treeSet.add("sp");
        treeSet.add("a");
        System.out.println("treeSet="+treeSet);
    }
}</code></pre> 
<p class="img-center"><img alt="" height="152" src="https://images2.imgbox.com/33/d7/8R5DglQf_o.png" width="309"></p> 
<pre><code class="language-java">public static void main(String[] args) {
	TreeSet&lt;Object&gt; set = new TreeSet&lt;&gt;();
    // 当执行add 方法时会报错，因为 TreeSet() 构造器没有传入 Comparator 接口的匿名内部类
    // jvm 会尝试着把 Person 对象转换成 Comparable 类型，但是 Person  类并没有实现 Comparator 接口
    // 所以下面的代码会报 ClassCastExecption
	set.add(new Person())
}</code></pre> 
<h4>4.1.2 有参构造</h4> 
<p>        <strong>TreeSet </strong>提供了一个有参的构造器，可以传入一个比较器（匿名内部类）并指定排序规则。</p> 
<pre><code class="language-java">public class TreeSetTest {
    public static void main(String[] args) {
        TreeSet treeSet = new TreeSet(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                // 下面调用 String 的 compareTo 方法进行字符串大小比较
                return ((String)o1).compareTo((String)o2);
            }
        });
        // 添加元素
        treeSet.add("jack");
        treeSet.add("tom");
        treeSet.add("sp");
        treeSet.add("a");
        System.out.println("treeSet="+treeSet);
    }
}</code></pre> 
<p class="img-center"><img alt="" height="142" src="https://images2.imgbox.com/bb/02/NfSk6sqW_o.png" width="323"></p> 
<h3>4.2 底层机制</h3> 
<p>         构造器把传入的比较器对象，赋给了 <strong>TreeSet </strong>的底层为 <strong>TreeMap </strong>的属性，在添加元素的时候会调用我们实现的匿名内部类里面指定的排序方法 <strong>compare()</strong>。</p> 
<p>        <strong>compare() </strong>方法执行完毕后会返回一个 <strong>int </strong>类型的结果，若结果小于 <strong>0</strong> ，则该元素放在比较元素左边；若结果大于 <strong>0</strong>，则该元素放在比较元素右边；若结果等于 <strong>0</strong>，数据不添加进去。</p> 
<h3>4.3 习题演练</h3> 
<p>        现在我想要按照长度大小排序，该如何写呢？如下</p> 
<pre><code class="language-java">public class TreeSetTest {
    public static void main(String[] args) {
        TreeSet treeSet = new TreeSet(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                // 按照长度大小排序
                return ((String)o1).length()-((String)o2).length();
            }
        });
        // 添加元素
        treeSet.add("jack");
        treeSet.add("tom");
        treeSet.add("sp");
        treeSet.add("a");
        // 此时 abc 元素是无法添加进去的，因为 tom 的长度也为 3，compare() 方法返回 0 了，认为是相同元素
        treeSet.add("abc");
        System.out.println("treeSet="+treeSet);
    }
}</code></pre> 
<p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/dc/6a/aeoBRzIp_o.png" width="307"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a13ec6ca6e06e4fd5c865d4d43e8a4d4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【node&#43;JS】前端使用nodemailer发送邮件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ecb72fa49e48b1befbb32901ab1fdba2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">阿里云linux cenots7 设置不同账号密钥</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>