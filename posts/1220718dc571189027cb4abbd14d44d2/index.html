<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>李宏毅机器学习第十七周周报GAN - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="李宏毅机器学习第十七周周报GAN" />
<meta property="og:description" content="文章目录 week 17 GAN摘要Abstract一、李宏毅机器学习——GAN1. Introduce1.1 Network as Generator1.2 Why distribution 2. Generative Adversarial Network2.1 Unconditional generation2.2 Basic idea of GAN 二、文献阅读1. 题目2. abstract3. 网络架构3.1 Theoretical Results 4. 文献解读4.1 Introduction4.2 创新点4.3 实验过程4.3.1 数据集4.3.2 参数设置 4.4 结论 三、实现GAN1. 任务要求2. 实验结果3.实验代码3.1数据准备3.2 模型构建3.3 展示函数3.4 训练过程 小结本周内容简报下周计划 参考文献 week 17 GAN 摘要 本文主要讨论了生成式对抗神经网络。首先，本文介绍了生成式对抗网络的设计思路。在此基础下，本文阐述了GAN的网络结构以及训练过程。生成器与解释器相互迭代，随着更新，生成器的效果趋近于真实图片。其次，本文展示了题为Generative Adversarial Networks论文的主要内容。这篇论文提出了生成式对抗网络的网络结构以及训练过程，该模型填补了生成任务方面神经网络的空白。此外，这篇论文还从理论角度证明了生成器的数据分布能够达到全局最优以及训练算法的可收敛性。最后，本文基于pytorch以及MNIST数据集实现了GAN绘制手写数字。
Abstract This article mainly discusses Generative Adversarial Networks (GANs). Firstly, this article introduces design philosophy of Generative Adversarial Networks. Building upon this foundation, the article elucidates the network structure and training process of GANs." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/1220718dc571189027cb4abbd14d44d2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-18T20:39:00+08:00" />
<meta property="article:modified_time" content="2023-11-18T20:39:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">李宏毅机器学习第十七周周报GAN</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#week_17_GAN_3" rel="nofollow">week 17 GAN</a></li><li><a href="#_5" rel="nofollow">摘要</a></li><li><a href="#Abstract_9" rel="nofollow">Abstract</a></li><li><a href="#GAN_15" rel="nofollow">一、李宏毅机器学习——GAN</a></li><li><ul><li><a href="#1_Introduce_17" rel="nofollow">1. Introduce</a></li><li><ul><li><a href="#11__Network_as_Generator_19" rel="nofollow">1.1 Network as Generator</a></li><li><a href="#12_Why_distribution_25" rel="nofollow">1.2 Why distribution</a></li></ul> 
   </li><li><a href="#2_Generative_Adversarial_Network_33" rel="nofollow">2. Generative Adversarial Network</a></li><li><ul><li><a href="#21_Unconditional_generation_35" rel="nofollow">2.1 Unconditional generation</a></li><li><a href="#22_Basic_idea_of_GAN_43" rel="nofollow">2.2 Basic idea of GAN</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_70" rel="nofollow">二、文献阅读</a></li><li><ul><li><a href="#1__72" rel="nofollow">1. 题目</a></li><li><a href="#2_abstract_82" rel="nofollow">2. abstract</a></li><li><a href="#3__88" rel="nofollow">3. 网络架构</a></li><li><ul><li><a href="#31_Theoretical_Results_105" rel="nofollow">3.1 Theoretical Results</a></li></ul> 
   </li><li><a href="#4__150" rel="nofollow">4. 文献解读</a></li><li><ul><li><a href="#41_Introduction_152" rel="nofollow">4.1 Introduction</a></li><li><a href="#42__156" rel="nofollow">4.2 创新点</a></li><li><a href="#43__164" rel="nofollow">4.3 实验过程</a></li><li><ul><li><a href="#431__166" rel="nofollow">4.3.1 数据集</a></li><li><a href="#432__170" rel="nofollow">4.3.2 参数设置</a></li></ul> 
    </li><li><a href="#44__194" rel="nofollow">4.4 结论</a></li></ul> 
  </li></ul> 
  </li><li><a href="#GAN_202" rel="nofollow">三、实现GAN</a></li><li><ul><li><a href="#1__204" rel="nofollow">1. 任务要求</a></li><li><a href="#2__208" rel="nofollow">2. 实验结果</a></li><li><a href="#3_214" rel="nofollow">3.实验代码</a></li><li><ul><li><a href="#31_216" rel="nofollow">3.1数据准备</a></li><li><a href="#32__256" rel="nofollow">3.2 模型构建</a></li><li><a href="#33__309" rel="nofollow">3.3 展示函数</a></li><li><a href="#34__326" rel="nofollow">3.4 训练过程</a></li></ul> 
   </li><li><a href="#_400" rel="nofollow">小结</a></li><li><ul><li><a href="#_404" rel="nofollow">本周内容简报</a></li><li><a href="#_413" rel="nofollow">下周计划</a></li></ul> 
   </li><li><a href="#_417" rel="nofollow">参考文献</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="week_17_GAN_3"></a>week 17 GAN</h2> 
<h2><a id="_5"></a>摘要</h2> 
<p>本文主要讨论了生成式对抗神经网络。首先，本文介绍了生成式对抗网络的设计思路。在此基础下，本文阐述了GAN的网络结构以及训练过程。生成器与解释器相互迭代，随着更新，生成器的效果趋近于真实图片。其次，本文展示了题为Generative Adversarial Networks论文的主要内容。这篇论文提出了生成式对抗网络的网络结构以及训练过程，该模型填补了生成任务方面神经网络的空白。此外，这篇论文还从理论角度证明了生成器的数据分布能够达到全局最优以及训练算法的可收敛性。最后，本文基于pytorch以及MNIST数据集实现了GAN绘制手写数字。</p> 
<h2><a id="Abstract_9"></a>Abstract</h2> 
<p>This article mainly discusses Generative Adversarial Networks (GANs). Firstly, this article introduces design philosophy of Generative Adversarial Networks. Building upon this foundation, the article elucidates the network structure and training process of GANs. The generator and discriminator iteratively improve, and with updates, the generator’s output approaches that of real images. Next, the article presents the key contents of the paper titled “Generative Adversarial Networks”. This paper proposes the network structure and training process of Generative Adversarial Networks, filling a gap in neural networks for generative tasks. Furthermore, the paper theoretically proves that the generator’s data distribution can reach global optimality and demonstrates the convergence of the training algorithm. Finally, based on PyTorch and the MNIST dataset, this article implements GANs to generate hand-written digits.</p> 
<h2><a id="GAN_15"></a>一、李宏毅机器学习——GAN</h2> 
<h3><a id="1_Introduce_17"></a>1. Introduce</h3> 
<h4><a id="11__Network_as_Generator_19"></a>1.1 Network as Generator</h4> 
<p>之前学习的神经网络，其输入主要是作为输入特征的x，该值是固定的。但今天学习的神经网络，其输入还包括简单分布中的样本z，该值是不固定的。因为简单分布的采样是多样的。作为输入的z应当是较为简单，且知道简单分布的公式（例如高斯分布），从而可以在输入时使用公式生成z。最后，在经过网络处理之后得到复杂的分布y</p> 
<p><img src="https://images2.imgbox.com/2d/f6/Sf6HrZE6_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="12_Why_distribution_25"></a>1.2 Why distribution</h4> 
<p>例如设计一个神经网络，给出下列游戏的运行画面，令其生成下一时刻的游戏画面。若使用曾经的网络结构，可能吃豆人在拐角会分裂成多个，因为两种操作都存在与分布中。然而，两个操作在单独存在时是正确的，而一张图片中同时具有两种操作状态的吃豆人却是错误的（即互斥）。因此需要给出一个<strong>简单分布——操作指令</strong>。网络在接收游戏画面和操作指令后，会按照操作指令输出对应的<strong>复杂分布——游戏画面</strong>。</p> 
<p>生成式神经网络主要用于一些带有创造性的任务中。例如绘画，根据输入tag输出图像；例如chatbot，根据提出的问题给出可能的多种答案。</p> 
<p><img src="https://images2.imgbox.com/b0/c3/u6pwu5zH_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_Generative_Adversarial_Network_33"></a>2. Generative Adversarial Network</h3> 
<h4><a id="21_Unconditional_generation_35"></a>2.1 Unconditional generation</h4> 
<p>这类GAN相较于上述中的GAN模型，其输入仅包含简单的分布，通常是分布中采样出的低维向量。而输出则是高维向量。例如在下图的动漫人脸生成中，输出是动漫人脸。</p> 
<p>在生成式神经网络中，还需要训练解释器。其是一个神经网络，输入为复杂分布（例如人脸），输出为一个值。当输出值较大时，意味着图像接近生成目标，低时相反。对于下图中的任务，可以使用CNN作为解释器，也可以选用其他的神经网络架构。</p> 
<p><img src="https://images2.imgbox.com/ac/7b/k9wa9fzk_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="22_Basic_idea_of_GAN_43"></a>2.2 Basic idea of GAN</h4> 
<p>生成式网络启发于生物进化，生成器生成图片，解释器辨识图片。二者相互迭代，随着版本更新，生成器的效果逐渐趋近于真实图片。</p> 
<p><img src="https://images2.imgbox.com/df/f7/H4c1udNk_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>算法</strong></p> 
</blockquote> 
<ul><li> <p>初始化生成器与解释器</p> </li><li> <p>在每个训练过程的迭代中</p> 
  <ol><li> <p>修正生成器G，更新解释器D</p> 
    <ul><li>从真实数据集中取样一部分数据，另外由生成器根据随机生成的输入向量生成一部分数据。由解释器针对两部分数据给出输出，解释器从中学习如何分辨真实图片，即更新。过程中，并不对生成器进行修改</li><li><img src="https://images2.imgbox.com/e9/d5/KiYgXGmp_o.png" alt="在这里插入图片描述"></li></ul> </li><li> <p>修正解释器G，更新生成器D</p> 
    <ul><li>通过更新生成器使得解释器的输出值更高，让生成器学习如何“骗过”解释器。可以将两个网络拼接在一起组成一个大型的神经网络，其中生成器输出部分是一个较宽的隐藏层，即输出图片。然后将输出作为解释器部分的输入即可。过程中不修改解释器部分。</li><li>若可以调整解释器部分的参数，则可以仅调整解释器部分参数使得输出值变大，但整个过程中生成器并没有学到任何东西。</li><li><img src="https://images2.imgbox.com/f1/89/g5pmA9br_o.png" alt="在这里插入图片描述"></li></ul> <p>若将上述两个部分组合起来，就有下图中过程</p> <p><img src="https://images2.imgbox.com/7c/d9/lAb9ePbu_o.png" alt="在这里插入图片描述"></p> </li></ol> </li></ul> 
<h2><a id="_70"></a>二、文献阅读</h2> 
<h3><a id="1__72"></a>1. 题目</h3> 
<p>标题：Generative Adversarial Networks</p> 
<p>作者：<a href="https://arxiv.org/search/stat?searchtype=author&amp;query=Goodfellow,+I+J" rel="nofollow">Ian J. Goodfellow</a>, <a href="https://arxiv.org/search/stat?searchtype=author&amp;query=Pouget-Abadie,+J" rel="nofollow">Jean Pouget-Abadie</a>, <a href="https://arxiv.org/search/stat?searchtype=author&amp;query=Mirza,+M" rel="nofollow">Mehdi Mirza</a>, <a href="https://arxiv.org/search/stat?searchtype=author&amp;query=Xu,+B" rel="nofollow">Bing Xu</a>, <a href="https://arxiv.org/search/stat?searchtype=author&amp;query=Warde-Farley,+D" rel="nofollow">David Warde-Farley</a>, <a href="https://arxiv.org/search/stat?searchtype=author&amp;query=Ozair,+S" rel="nofollow">Sherjil Ozair</a>, <a href="https://arxiv.org/search/stat?searchtype=author&amp;query=Courville,+A" rel="nofollow">Aaron Courville</a>, <a href="https://arxiv.org/search/stat?searchtype=author&amp;query=Bengio,+Y" rel="nofollow">Yoshua Bengio</a></p> 
<p>期刊名：<a href="https://v.guet.edu.cn/http/77726476706e69737468656265737421e3e40f862f3972587b06c7af9758/nav/mag/info?mags=1b1834d0b59f5aa0ca7bd14bc75e515c" rel="nofollow">Communications of the ACM</a></p> 
<p>链接：<a href="https://arxiv.org/abs/1406.2661" rel="nofollow">arXiv:1406.2661</a></p> 
<h3><a id="2_abstract_82"></a>2. abstract</h3> 
<p>该文提出了名为对抗性生成模型的新框架。该框架同时训练两个模型：生成模型G提取数据分布特征，判别模型D分辨输入数据来自训练数据还是由G生成。G的训练过程时最大限度的提高D出错的概率。在文中实验通过对生成样本进行定性和定量评估，展示了该框架的潜力。</p> 
<p>This article proposes a new framework for estimating generative models via an adversarial process. This framework includes two model: a generative model G that captures the data distribution, and a discriminative model D that estimates the probability that a sample came from the training data rather than G. Experiments demonstrate the potential of the framework through qualitative and quantitative evaluation of the generated samples in this article.</p> 
<h3><a id="3__88"></a>3. 网络架构</h3> 
<p>为了学习生成器在数据x上的分布<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          g 
         
        
       
      
        p_g 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，定义输入噪声变量<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          z 
         
        
       
         ( 
        
       
         z 
        
       
         ) 
        
       
      
        p_{\mathbf z}(\mathbf z) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1611em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">z</span><span class="mclose">)</span></span></span></span></span>的先验概率，然后将到数据空间的映射表示为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         G 
        
       
         ( 
        
       
         z 
        
       
         ; 
        
        
        
          θ 
         
        
          g 
         
        
       
         ) 
        
       
      
        G(\mathbf z; \theta_g) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0361em; vertical-align: -0.2861em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathbf">z</span><span class="mpunct">;</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0278em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，其中G是由多层感知器表示的可微函数，该函数的参数为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          θ 
         
        
          g 
         
        
       
      
        \theta_g 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9805em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0278em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>。此外，定义了输出单个标量的第二个多层感知器<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         D 
        
       
         ( 
        
       
         x 
        
       
         ; 
        
        
        
          θ 
         
        
          d 
         
        
       
         ) 
        
       
      
        D(\mathbf x; \theta_d) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mpunct">;</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: -0.0278em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>。 D(x)表示x来自数据而不是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          g 
         
        
       
      
        p_g 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的概率。以最大化训练数据和G生成样本分配正确标签的概率为目标训练D。同时训练G以最小化<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         log 
        
       
         ( 
        
       
         1 
        
       
         − 
        
       
         D 
        
       
         ( 
        
       
         G 
        
       
         ( 
        
       
         z 
        
       
         ) 
        
       
         ) 
        
       
         ) 
        
       
      
        \text{log}(1 −D(G(\mathbf z))) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">log</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathbf">z</span><span class="mclose">)))</span></span></span></span></span>。从而有如下损失函数：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
           
            
            
              min 
             
            
              G 
             
            
            
            
              max 
             
            
              D 
             
            
           
             V 
            
           
             ( 
            
           
             D 
            
           
             , 
            
           
             G 
            
           
             ) 
            
           
             = 
            
            
            
              E 
             
             
             
               x 
              
             
               ∼ 
              
              
              
                p 
               
               
               
                 d 
                
               
                 a 
                
               
                 t 
                
               
                 a 
                
               
              
             
               ( 
              
             
               x 
              
             
               ) 
              
             
            
           
             [ 
            
           
             log 
            
           
             D 
            
           
             ( 
            
           
             x 
            
           
             ) 
            
           
             ] 
            
           
             + 
            
            
            
              E 
             
             
             
               x 
              
             
               ∼ 
              
              
              
                z 
               
              
                z 
               
              
             
               ( 
              
             
               z 
              
             
               ) 
              
             
            
           
             [ 
            
           
             log 
            
           
             ( 
            
           
             1 
            
           
             − 
            
           
             D 
            
           
             ( 
            
           
             G 
            
           
             ( 
            
           
             z 
            
           
             ) 
            
           
             ) 
            
           
             ) 
            
           
             ] 
            
           
          
          
          
          
            (1) 
           
          
         
        
       
         \text{min}_G\text{max}_DV(D,G)=\mathbb E_{x\sim p_{data}(\mathbf x)}[\text{log}D(\mathbf x)]+\mathbb E_{x\sim z_z(z)}[\text{log}(1-D(G(\mathbf z)))] \tag{1} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord text"><span class="mord">min</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3283em;"><span class="" style="top: -2.55em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord text"><span class="mord">max</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3283em;"><span class="" style="top: -2.55em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right: 0.2222em;">V</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.1052em; vertical-align: -0.3552em;"></span><span class="mord"><span class="mord mathbb">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3448em;"><span class="" style="top: -2.5198em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">∼</span><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3448em;"><span class="" style="top: -2.3488em; margin-left: 0em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.1512em;"><span class=""></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathbf mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3552em;"><span class=""></span></span></span></span></span></span><span class="mopen">[</span><span class="mord text"><span class="mord">log</span></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)]</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1.1052em; vertical-align: -0.3552em;"></span><span class="mord"><span class="mord mathbb">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3448em;"><span class="" style="top: -2.5198em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">∼</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.044em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1645em;"><span class="" style="top: -2.357em; margin-left: -0.044em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.044em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right: 0.044em;">z</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3552em;"><span class=""></span></span></span></span></span></span><span class="mopen">[</span><span class="mord text"><span class="mord">log</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathbf">z</span><span class="mclose">)))]</span></span><span class="tag"><span class="strut" style="height: 1.1052em; vertical-align: -0.3552em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span></span></span><br> <img src="https://images2.imgbox.com/eb/17/Y63HBwEF_o.png" alt="在这里插入图片描述"></p> 
<p>GAN训练时同步更新判别分布（D，蓝色虚线），从而区分数据分布<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          x 
         
        
       
      
        p_x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>（黑色虚线）和生成数据分布<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          g 
         
        
       
         ( 
        
       
         G 
        
       
         ) 
        
       
      
        p_g(G) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0361em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span></span>的样本（绿色实线）。下面水平线是在本例中均匀分布的从z采样的域。上面水平线是x域的一部分。箭头表示<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
         = 
        
       
         G 
        
       
         ( 
        
       
         z 
        
       
         ) 
        
       
      
        x=G(z) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.044em;">z</span><span class="mclose">)</span></span></span></span></span>在变换后样本上施加非均匀分布<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          g 
         
        
       
      
        p_g 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>。</p> 
<p>若模型处于收敛状态，则<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          g 
         
        
       
      
        p_g 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>类似于<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
         
         
           d 
          
         
           a 
          
         
           t 
          
         
           a 
          
         
        
       
      
        p_{data} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，此时D分类准确。D收敛时有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          D 
         
        
          ∗ 
         
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
         = 
        
        
         
          
          
            p 
           
           
           
             d 
            
           
             a 
            
           
             t 
            
           
             a 
            
           
          
         
           ( 
          
         
           x 
          
         
           ) 
          
         
         
          
          
            p 
           
           
           
             d 
            
           
             a 
            
           
             t 
            
           
             a 
            
           
          
         
           ( 
          
         
           x 
          
         
           ) 
          
         
           + 
          
          
          
            p 
           
          
            g 
           
          
         
           ( 
          
         
           x 
          
         
           ) 
          
         
        
       
      
        D^*(x) = \frac{p_{data}(x)}{p_{data}(x)+p_g(x)} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.6887em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.5523em; vertical-align: -0.5423em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.01em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3448em;"><span class="" style="top: -2.3488em; margin-left: 0em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.1512em;"><span class=""></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1645em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2819em;"><span class=""></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.485em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3448em;"><span class="" style="top: -2.3488em; margin-left: 0em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.1512em;"><span class=""></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.5423em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>。在更新G后，D更有可能将其分类为真实数据。若D和G有足够容量，则经过几次迭代后，将趋于收敛，此时<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          g 
         
        
       
         = 
        
        
        
          p 
         
         
         
           d 
          
         
           a 
          
         
           t 
          
         
           a 
          
         
        
       
      
        p_g=p_{data} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，辨别器无法区分二者，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         D 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
         = 
        
        
        
          1 
         
        
          2 
         
        
       
      
        D(x)=\frac 12 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.1901em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8451em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p> 
<p>单个迭代内的训练循环：D优化k次，G优化一次</p> 
<p>式1可能无法为G提供足够的梯度。在训练的早期，当G很差时，D可以以高置信度拒绝样本，因为它们与训练数据明显不同。在这种情况下，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         log 
        
       
         ⁡ 
        
       
         ( 
        
       
         1 
        
       
         − 
        
       
         D 
        
       
         ( 
        
       
         G 
        
       
         ( 
        
       
         z 
        
       
         ) 
        
       
         ) 
        
       
         ) 
        
       
      
        \log(1 − D(G(z))) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">lo<span style="margin-right: 0.0139em;">g</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.044em;">z</span><span class="mclose">)))</span></span></span></span></span>饱和。此时，以<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         argmax 
        
       
         log 
        
       
         ⁡ 
        
       
         D 
        
       
         ( 
        
       
         G 
        
       
         ( 
        
       
         z 
        
       
         ) 
        
       
         ) 
        
       
      
        \text{argmax}\log D(G(z)) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">argmax</span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop">lo<span style="margin-right: 0.0139em;">g</span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.044em;">z</span><span class="mclose">))</span></span></span></span></span>为目标，训练G。使用这种方式可以在训练早期提供更强的梯度。</p> 
<h4><a id="31_Theoretical_Results_105"></a>3.1 Theoretical Results</h4> 
<p>生成器定义了一个概率分布<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          g 
         
        
       
      
        p_g 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，该分布当<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         z 
        
       
         ∼ 
        
        
        
          p 
         
        
          z 
         
        
       
      
        z\sim p_z 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.044em;">z</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.044em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>时得到样本<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         G 
        
       
         ( 
        
       
         z 
        
       
         ) 
        
       
      
        G(z) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.044em;">z</span><span class="mclose">)</span></span></span></span></span>。因此有设计目标：若有足够容量和训练时间，则下列算法收敛至好的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
         
         
           d 
          
         
           a 
          
         
           t 
          
         
           a 
          
         
        
       
      
        p_{data} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>。下图解释了算法1以及上述的损失函数</p> 
<p><img src="https://images2.imgbox.com/7a/87/92lMMPF1_o.jpg" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/4b/66/MXlFDUOP_o.png" alt="在这里插入图片描述"></p> 
<p>上图即算法1</p> 
<p><strong>Global Optimality of</strong> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          g 
         
        
       
         = 
        
        
        
          p 
         
         
         
           d 
          
         
           a 
          
         
           t 
          
         
           a 
          
         
        
       
      
        p_g=p_{data} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></p> 
<p>命题1：对于固定G，最优辨别器D为<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
           
            
            
              D 
             
            
              G 
             
            
              ∗ 
             
            
           
             = 
            
            
             
              
              
                p 
               
               
               
                 d 
                
               
                 a 
                
               
                 t 
                
               
                 a 
                
               
              
             
               ( 
              
             
               x 
              
             
               ) 
              
             
             
              
              
                p 
               
               
               
                 d 
                
               
                 a 
                
               
                 t 
                
               
                 a 
                
               
              
             
               ( 
              
             
               x 
              
             
               ) 
              
             
               + 
              
              
              
                p 
               
              
                g 
               
              
             
               ( 
              
             
               x 
              
             
               ) 
              
             
            
           
          
          
          
          
            (2) 
           
          
         
        
       
         D_G^*=\frac{p_{data}(x)}{p_{data}(x)+p_g(x)} \tag{2} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9857em; vertical-align: -0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.7387em;"><span class="" style="top: -2.453em; margin-left: -0.0278em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">G</span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.247em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.3991em; vertical-align: -0.9721em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.427em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.9721em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="tag"><span class="strut" style="height: 2.3991em; vertical-align: -0.9721em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">2</span></span><span class="mord">)</span></span></span></span></span></span></span><br> 证明：对于任意生成器G，辨别器D的训练标准是最大化<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         V 
        
       
         ( 
        
       
         G 
        
       
         . 
        
       
         D 
        
       
         ) 
        
       
      
        V(G.D) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.2222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mclose">)</span></span></span></span></span><br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
           
            
             
              
               
               
                 V 
                
               
                 ( 
                
               
                 D 
                
               
                 , 
                
               
                 G 
                
               
                 ) 
                
               
                 = 
                
                
                
                  ∫ 
                 
                
                  x 
                 
                
                
                
                  p 
                 
                 
                 
                   d 
                  
                 
                   a 
                  
                 
                   t 
                  
                 
                   a 
                  
                 
                
               
                 ( 
                
               
                 x 
                
               
                 ) 
                
               
                 log 
                
               
                 D 
                
               
                 ( 
                
               
                 x 
                
               
                 ) 
                
               
                 dx 
                
               
                 + 
                
                
                
                  ∫ 
                 
                
                  x 
                 
                
                
                
                  p 
                 
                
                  z 
                 
                
               
                 ( 
                
               
                 z 
                
               
                 ) 
                
               
                 log 
                
               
                 ( 
                
               
                 1 
                
               
                 − 
                
               
                 D 
                
               
                 ( 
                
               
                 G 
                
               
                 ( 
                
               
                 z 
                
               
                 ) 
                
               
                 ) 
                
               
                 ) 
                
               
                 dz 
                
               
              
             
            
            
             
              
               
               
                 = 
                
                
                
                  ∫ 
                 
                
                  x 
                 
                
                
                
                  p 
                 
                 
                 
                   d 
                  
                 
                   a 
                  
                 
                   t 
                  
                 
                   a 
                  
                 
                
               
                 ( 
                
               
                 x 
                
               
                 ) 
                
               
                 log 
                
               
                 D 
                
               
                 ( 
                
               
                 x 
                
               
                 ) 
                
               
                 dx 
                
               
                 + 
                
                
                
                  p 
                 
                
                  x 
                 
                
               
                 ( 
                
               
                 z 
                
               
                 ) 
                
               
                 log 
                
               
                 ( 
                
               
                 1 
                
               
                 − 
                
               
                 D 
                
               
                 ( 
                
               
                 G 
                
               
                 ( 
                
               
                 z 
                
               
                 ) 
                
               
                 ) 
                
               
                 ) 
                
               
                 dz 
                
               
              
             
            
           
          
          
          
          
            (3) 
           
          
         
        
       
         \begin{aligned} V(D,G)=\int_xp_{data}(\mathbf x)\text{log}D(\mathbf x)\text{dx}+\int_x p_z(z)\text{log}(1-D(G(\mathbf z)))\text{dz}\\ =\int_xp_{data}(\mathbf x)\text{log}D(\mathbf x)\text{dx}+ p_x(z)\text{log}(1-D(G(\mathbf z)))\text{dz} \end{aligned} \tag{3} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 5.1439em; vertical-align: -2.322em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.822em;"><span class="" style="top: -4.822em;"><span class="pstrut" style="height: 3.36em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.2222em;">V</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right: 0.4445em; position: relative; top: -0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="" style="top: -1.7881em; margin-left: -0.4445em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.9119em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)</span><span class="mord text"><span class="mord">log</span></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)</span><span class="mord text"><span class="mord">dx</span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right: 0.4445em; position: relative; top: -0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="" style="top: -1.7881em; margin-left: -0.4445em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.9119em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.044em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.044em;">z</span><span class="mclose">)</span><span class="mord text"><span class="mord">log</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathbf">z</span><span class="mclose">)))</span><span class="mord text"><span class="mord">dz</span></span></span></span><span class="" style="top: -2.25em;"><span class="pstrut" style="height: 3.36em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right: 0.4445em; position: relative; top: -0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="" style="top: -1.7881em; margin-left: -0.4445em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.9119em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)</span><span class="mord text"><span class="mord">log</span></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)</span><span class="mord text"><span class="mord">dx</span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.044em;">z</span><span class="mclose">)</span><span class="mord text"><span class="mord">log</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathbf">z</span><span class="mclose">)))</span><span class="mord text"><span class="mord">dz</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 2.322em;"><span class=""></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height: 5.1439em; vertical-align: -2.322em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">3</span></span><span class="mord">)</span></span></span></span></span></span></span><br> 对于任意<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
       
         a 
        
       
         , 
        
       
         b 
        
       
         ) 
        
       
         ∈ 
        
        
        
          R 
         
        
          2 
         
        
       
         \ 
        
       
         { 
        
       
         0 
        
       
         , 
        
       
         0 
        
       
         } 
        
       
      
        (a,b)\in \mathbb R^2\backslash \{0,0\} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">\</span><span class="mopen">{<!-- --></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">0</span><span class="mclose">}</span></span></span></span></span>，函数<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         y 
        
       
         → 
        
       
         a 
        
       
         log 
        
       
         ⁡ 
        
       
         ( 
        
       
         y 
        
       
         ) 
        
       
         + 
        
       
         b 
        
       
         log 
        
       
         ⁡ 
        
       
         ( 
        
       
         1 
        
       
         − 
        
       
         y 
        
       
         ) 
        
       
      
        y\rightarrow a\log(y)+b\log(1-y) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop">lo<span style="margin-right: 0.0139em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop">lo<span style="margin-right: 0.0139em;">g</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mclose">)</span></span></span></span></span>在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         [ 
        
       
         0 
        
       
         , 
        
       
         1 
        
       
         ] 
        
       
      
        [0,1] 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span>范围内达到其最大值<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          a 
         
         
         
           a 
          
         
           + 
          
         
           b 
          
         
        
       
      
        \frac{a}{a+b} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0987em; vertical-align: -0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.6954em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">b</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.4033em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p> 
<p>首先给定 G 很容易计算出 D 存在一个最优解。而 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
         
         
           d 
          
         
           a 
          
         
           t 
          
         
           a 
          
         
        
       
      
        p_{data} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是一个概率，所以积分本质仍然在求期望。在第二项中做了一个换元 。那么原来<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          z 
         
        
       
         ( 
        
       
         z 
        
       
         ) 
        
       
      
        p_z(z) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.044em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.044em;">z</span><span class="mclose">)</span></span></span></span></span>也就是随机变量 z 的一个噪声的随机分布，就相应的被映射成了<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          g 
         
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
      
        p_g(x) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0361em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span>也就是生成的样例的分布。原来对 z 的积分，当然也就变成了对此处 x 的积分，注意积分的值与积分变量无关，所以x 并没有什么实际含义可以换成任意字母，换成 x 是为了与前面合并为一项。</p> 
<p>从而有（3）式结尾的积分。若将<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
         
         
           d 
          
         
           a 
          
         
           t 
          
         
           a 
          
         
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
      
        p_{data}(x) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          g 
         
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
      
        p_g(x) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0361em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span>抽象为a、b，则有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         ⋅ 
        
       
         log 
        
       
         ⁡ 
        
       
         ( 
        
       
         y 
        
       
         ) 
        
       
         + 
        
       
         b 
        
       
         ⋅ 
        
       
         log 
        
       
         ⁡ 
        
       
         ( 
        
       
         1 
        
       
         − 
        
       
         y 
        
       
         ) 
        
       
      
        a\cdot \log(y)+b\cdot\log(1-y) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4445em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">lo<span style="margin-right: 0.0139em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">lo<span style="margin-right: 0.0139em;">g</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mclose">)</span></span></span></span></span>，易得最大值<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          a 
         
         
         
           a 
          
         
           + 
          
         
           b 
          
         
        
       
      
        \frac{a}{a+b} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0987em; vertical-align: -0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.6954em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">b</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.4033em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>，即证明对于任意G总有最优D</p> 
<p>D 的训练目标可以解释为最大化估计条件概率 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         P 
        
       
         ( 
        
       
         Y 
        
       
         = 
        
       
         y 
        
       
         ∣ 
        
       
         x 
        
       
         ) 
        
       
      
        P(Y = y|\mathbf x) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.2222em;">Y</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mord">∣</span><span class="mord mathbf">x</span><span class="mclose">)</span></span></span></span></span>的对数似然，其中 Y 表示 x 是来自 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
         
         
           d 
          
         
           a 
          
         
           t 
          
         
           a 
          
         
        
       
         ( 
        
       
         y 
        
       
         = 
        
       
         1 
        
       
         ) 
        
       
      
        p_{data}(y = 1) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>还是来自 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          g 
         
        
       
         ( 
        
       
         y 
        
       
         = 
        
       
         0 
        
       
         ) 
        
       
      
        p_g(y = 0) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0361em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span>。方程 1 现在可以重新表述为</p> 
<p><img src="https://images2.imgbox.com/05/f3/PYiZghyo_o.jpg" alt="请添加图片描述"></p> 
<p>下图为定理1及其证明过程</p> 
<p><img src="https://images2.imgbox.com/9a/f4/kB2gkPyB_o.jpg" alt="在这里插入图片描述"></p> 
<p>证明 G 存在全局最优解。把刚才 D 的最优解直接带回损失函数，就得到了上面的（4）式。然后分母乘上一个二分之一，并对应的在log外面抵消掉二分之一，这个操作是为了让分数线下面的数值在 [0,1] 范围内，从而描述了 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
         
         
           d 
          
         
           a 
          
         
           t 
          
         
           a 
          
         
        
       
      
        p_{data} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 与 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          g 
         
        
       
      
        p_g 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 综合起来这样一个分布。从而得到了两个分布的KL散度，KL散度越小就说明分子两个分布越相似。KL散度越小，说明两个分布越相似，说明 G 学习真实分布学习的越好。这两个KL散度求平均，又是JSD散度，同理JSD散度越小说明两个分布越相似，也说明 G 学习真实分布学习的越好。</p> 
<p><strong>Convergence of Algorithm 1</strong></p> 
<p><img src="https://images2.imgbox.com/e2/bb/3EuupzyG_o.jpg" alt="请添加图片描述"></p> 
<h3><a id="4__150"></a>4. 文献解读</h3> 
<h4><a id="41_Introduction_152"></a>4.1 Introduction</h4> 
<p>为了在生成式任务中充分利用ReLU的优点，该文提出了一种新的生成模型评估程序。辨别模型学习确定样本来自于训练数据以及生成模型的概率。生成模型学习训练数据的概率，从而生成在辨别模型结果中属于训练数据概率尽可能高的数据。在对抗性网络框架下，二者相互促进，直至辨别模型判别训练数据与生成数据的概率相近。文中主要探讨了两者均是多层感知器的情况。</p> 
<h4><a id="42__156"></a>4.2 创新点</h4> 
<ol><li>本文提出了新型框架——生成式对抗网络（GAN）</li><li>对于该网络给出两个证明，分别证明 
  <ol><li>其生成器拟合的分布能够达到全局最优</li><li>其训练算法——上文中算法1，能够收敛</li></ol> </li></ol> 
<h4><a id="43__164"></a>4.3 实验过程</h4> 
<h5><a id="431__166"></a>4.3.1 数据集</h5> 
<p>使用一系列数据集训练对抗网络，包括MNIST[23]、Toronto Face Database(TFD)[28] 和 CIFAR-10[21]。</p> 
<h5><a id="432__170"></a>4.3.2 参数设置</h5> 
<p>生成器网络G使用两个激活函数：ReLU和 sigmoid的混合，而鉴别器网D络使用 maxout激活函数。 使用Dropout训练鉴别器网络。仅使用噪声作为生成器网络最底层的输入</p> 
<p>通过将高斯Parzen窗口拟合到G生成的样本并报告该分布下的对数似然来估计 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          g 
         
        
       
      
        p_g 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 下测试集数据的概率。高斯函数的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         σ 
        
       
      
        \sigma 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">σ</span></span></span></span></span>参数是通过验证集上的交叉验证获得的。结果如下表所示。这种评估可能性的方法具有较高的方差，并且在高维空间中表现不佳，但是当时最佳方法。</p> 
<p><img src="https://images2.imgbox.com/8b/2f/K45IJXue_o.png" alt="在这里插入图片描述"></p> 
<p>上表是基于 Parzen 窗口的对数似然估计。</p> 
<p>MNIST上的数字是测试集上样本的平均对数似然，以及跨示例计算的平均值的标准误差。</p> 
<p>TFD上，计算了数据集折叠的标准误差，并使用每个折叠的验证集选择不同的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         σ 
        
       
      
        \sigma 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">σ</span></span></span></span></span>。在TFD上，对每个折叠的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         σ 
        
       
      
        \sigma 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">σ</span></span></span></span></span>进行交叉验证，并计算每个折叠的平均对数似然。</p> 
<p>对于MNIST，与数据集实值（而不是二进制）版本的其他模型进行比较。</p> 
<p>下图展示了训练后从生成网络中抽取的样本</p> 
<p><img src="https://images2.imgbox.com/fa/d7/2b2BhZe0_o.png" alt="在这里插入图片描述"></p> 
<p>上图左上来自MNIIST、右上TFD、左下CIFAR-10（全连接模型）、右下CIFAR-10（卷积判别器和“反卷积”生成器）</p> 
<p><img src="https://images2.imgbox.com/94/ca/g0uAMzrW_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="44__194"></a>4.4 结论</h4> 
<p>该模型填补了生成领域模型框架的空白，且证明了其实际可行性以及理论可行性。</p> 
<p>缺点主要是没有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          g 
         
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
      
        p_g(x) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0361em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span>的显式表示，并且训练时D必须与G很好地同步</p> 
<p>优点是不需要马尔可夫链，仅使用反向传播来获取梯度，学习过程中不需要推理，并且可以将多种函数合并到模型中。</p> 
<h2><a id="GAN_202"></a>三、实现GAN</h2> 
<h3><a id="1__204"></a>1. 任务要求</h3> 
<p>使用pytorch实现GAN网络，并使用MNIST数据库训练GAN，GAN绘制手写数字图片。其中，GAN使用MLP构建</p> 
<h3><a id="2__208"></a>2. 实验结果</h3> 
<p>GAN进行十九次迭代后的绘制效果</p> 
<p><img src="https://images2.imgbox.com/df/73/9EvQLI0c_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3_214"></a>3.实验代码</h3> 
<h4><a id="31_216"></a>3.1数据准备</h4> 
<pre><code class="prism language-python"><span class="token keyword">import</span> torch
<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn
<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>functional <span class="token keyword">as</span> F
<span class="token keyword">import</span> torch<span class="token punctuation">.</span>optim <span class="token keyword">as</span> optim
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt
<span class="token keyword">import</span> torchvision
<span class="token keyword">from</span> torchvision <span class="token keyword">import</span> transforms
</code></pre> 
<pre><code class="prism language-python"><span class="token comment"># 数据准备</span>

<span class="token comment"># 对数据做归一化 （-1， 1）</span>
transform <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>
    transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>         <span class="token comment"># 将数据转换成Tensor格式，channel, high, witch,数据在（0， 1）范围内</span>
    transforms<span class="token punctuation">.</span>Normalize<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token comment"># 通过均值和方差将数据归一化到（-1， 1）之间</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment"># 下载数据集</span>
train_ds <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>MNIST<span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span>
                                      train<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>
                                      transform<span class="token operator">=</span>transform<span class="token punctuation">,</span>
                                      download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
                                      
<span class="token comment"># 设置dataloader</span>
dataloader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>train_ds<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>

<span class="token comment"># 返回一个批次的数据</span>
imgs<span class="token punctuation">,</span> _ <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">(</span><span class="token builtin">iter</span><span class="token punctuation">(</span>dataloader<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># imgs的大小</span>
imgs<span class="token punctuation">.</span>shape
</code></pre> 
<p><img src="https://images2.imgbox.com/1a/16/V8KU61kT_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="32__256"></a>3.2 模型构建</h4> 
<pre><code class="prism language-python"><span class="token comment"># 定义生成器</span>

<span class="token comment"># 输入是长度为 100 的 噪声（正态分布随机数）</span>
<span class="token comment"># 输出为（1， 28， 28）的图片</span>
<span class="token comment"># linear 1 :   100----256</span>
<span class="token comment"># linear 2:    256----512</span>
<span class="token comment"># linear 2:    512----28*28</span>
<span class="token comment"># reshape:     28*28----(1, 28, 28)</span>

<span class="token keyword">class</span> <span class="token class-name">Generator</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">#创建的 Generator 类继承自 nn.Module</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 定义初始化方法</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span>Generator<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#继承父类的属性</span>
        self<span class="token punctuation">.</span>main <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span> <span class="token comment">#使用Sequential快速创建模型</span>
                                  nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                  nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                  nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                  nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                  nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token operator">*</span><span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                  nn<span class="token punctuation">.</span>Tanh<span class="token punctuation">(</span><span class="token punctuation">)</span>                     <span class="token comment"># 输出层使用Tanh()激活函数，使输出-1, 1之间</span>
        <span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>              <span class="token comment"># 定义前向传播 x 表示长度为100 的noise输入</span>
        img <span class="token operator">=</span> self<span class="token punctuation">.</span>main<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
        img <span class="token operator">=</span> img<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span> <span class="token comment">#将img展平，转化成图片的形式，channel为1可写可不写</span>
        <span class="token keyword">return</span> img
    
<span class="token comment"># 定义判别器</span>

<span class="token comment">## 输入为（1， 28， 28）的图片  输出为二分类的概率值，输出使用sigmoid激活 0-1</span>
<span class="token comment"># BCEloss计算交叉熵损失</span>

<span class="token comment"># nn.LeakyReLU   f(x) : x&gt;0 输出 x， 如果x&lt;0 ,输出 a*x  a表示一个很小的斜率，比如0.1</span>
<span class="token comment"># 判别器中一般推荐使用 LeakyReLU</span>

<span class="token keyword">class</span> <span class="token class-name">Discriminator</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span>Discriminator<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>main <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>
                                  nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">28</span><span class="token operator">*</span><span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">#输入是28*28的张量，也就是图片</span>
                                  nn<span class="token punctuation">.</span>LeakyReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment"># 小于0的时候保存一部分梯度</span>
                                  nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                  nn<span class="token punctuation">.</span>LeakyReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                  nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment"># 二分类问题，输出到1上</span>
                                  nn<span class="token punctuation">.</span>Sigmoid<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        x <span class="token operator">=</span> x<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token operator">*</span><span class="token number">28</span><span class="token punctuation">)</span>
        x <span class="token operator">=</span> self<span class="token punctuation">.</span>main<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
        <span class="token keyword">return</span> x
</code></pre> 
<h4><a id="33__309"></a>3.3 展示函数</h4> 
<pre><code class="prism language-python"><span class="token comment"># 绘图函数</span>

<span class="token keyword">def</span> <span class="token function">gen_img_plot</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> epoch<span class="token punctuation">,</span> test_input<span class="token punctuation">)</span><span class="token punctuation">:</span>
    prediction <span class="token operator">=</span> np<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span>model<span class="token punctuation">(</span>test_input<span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token punctuation">(</span>prediction<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment"># 确保prediction[i] + 1)/2输出的结果是在0-1之间</span>
        plt<span class="token punctuation">.</span>axis<span class="token punctuation">(</span><span class="token string">'off'</span><span class="token punctuation">)</span>
    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>
    
test_input <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> device<span class="token operator">=</span>device<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="34__326"></a>3.4 训练过程</h4> 
<pre><code class="prism language-python"><span class="token comment"># GAN的训练</span>

<span class="token comment"># 保存每个epoch所产生的loss值</span>
D_loss <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
G_loss <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token comment"># 训练循环</span>
<span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">#训练20个epoch</span>
   d_epoch_loss <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment"># 初始损失值为0</span>
   g_epoch_loss <span class="token operator">=</span> <span class="token number">0</span>
   <span class="token comment"># len(dataloader)返回批次数，len(dataset)返回样本数</span>
   count <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>dataloader<span class="token punctuation">)</span>
   <span class="token comment"># 对dataloader进行迭代</span>
   <span class="token keyword">for</span> step<span class="token punctuation">,</span> <span class="token punctuation">(</span>img<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>dataloader<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># enumerate加序号</span>
       img <span class="token operator">=</span> img<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span> <span class="token comment">#将数据上传到设备</span>
       size <span class="token operator">=</span> img<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment"># 获取每一个批次的大小</span>
       random_noise <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> device<span class="token operator">=</span>device<span class="token punctuation">)</span>  <span class="token comment"># 随机噪声的大小是size个</span>
       
       d_optim<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 将判别器前面的梯度归0</span>
       
       real_output <span class="token operator">=</span> dis<span class="token punctuation">(</span>img<span class="token punctuation">)</span>      <span class="token comment"># 判别器输入真实的图片，real_output是对真实图片的预测结果 </span>
       
       <span class="token comment"># 得到判别器在真实图像上的损失</span>
       <span class="token comment"># 判别器对于真实的图片希望输出的全1的数组，将真实的输出与全1的数组进行比较</span>
       d_real_loss <span class="token operator">=</span> loss_fn<span class="token punctuation">(</span>real_output<span class="token punctuation">,</span> 
                             torch<span class="token punctuation">.</span>ones_like<span class="token punctuation">(</span>real_output<span class="token punctuation">)</span><span class="token punctuation">)</span>      
       d_real_loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 求解梯度</span>
       
       
       gen_img <span class="token operator">=</span> gen<span class="token punctuation">(</span>random_noise<span class="token punctuation">)</span>    
       <span class="token comment"># 判别器输入生成的图片，fake_output是对生成图片的预测</span>
       <span class="token comment"># 优化的目标是判别器，对于生成器的参数是不需要做优化的，需要进行梯度阶段，detach()会截断梯度，</span>
       <span class="token comment"># 得到一个没有梯度的Tensor，这一点很关键</span>
       fake_output <span class="token operator">=</span> dis<span class="token punctuation">(</span>gen_img<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
       <span class="token comment"># 得到判别器在生成图像上的损失</span>
       d_fake_loss <span class="token operator">=</span> loss_fn<span class="token punctuation">(</span>fake_output<span class="token punctuation">,</span> 
                             torch<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>fake_output<span class="token punctuation">)</span><span class="token punctuation">)</span>      
       d_fake_loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 求解梯度</span>
       
       d_loss <span class="token operator">=</span> d_real_loss <span class="token operator">+</span> d_fake_loss <span class="token comment"># 判别器总的损失等于两个损失之和</span>
       d_optim<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 进行优化</span>
       
       g_optim<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 将生成器的所有梯度归0</span>
       fake_output <span class="token operator">=</span> dis<span class="token punctuation">(</span>gen_img<span class="token punctuation">)</span> <span class="token comment"># 将生成器的图片放到判别器中，此时不做截断，因为要优化生成器</span>
       <span class="token comment"># 生层器希望生成的图片被判定为真</span>
       g_loss <span class="token operator">=</span> loss_fn<span class="token punctuation">(</span>fake_output<span class="token punctuation">,</span> 
                        torch<span class="token punctuation">.</span>ones_like<span class="token punctuation">(</span>fake_output<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment"># 生成器的损失</span>
       g_loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 计算梯度</span>
       g_optim<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 优化</span>
       
       <span class="token comment"># 将损失累加到定义的数组中，这个过程不需要计算梯度</span>
       <span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
           d_epoch_loss <span class="token operator">+=</span> d_loss
           g_epoch_loss <span class="token operator">+=</span> g_loss
     
   <span class="token comment"># 计算每个epoch的平均loss，仍然使用这个上下文关联器</span>
   <span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
       <span class="token comment"># 计算平均的loss值</span>
       d_epoch_loss <span class="token operator">/=</span> count
       g_epoch_loss <span class="token operator">/=</span> count
       <span class="token comment"># 将平均loss放入到loss数组中</span>
       D_loss<span class="token punctuation">.</span>append<span class="token punctuation">(</span>d_epoch_loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
       G_loss<span class="token punctuation">.</span>append<span class="token punctuation">(</span>g_epoch_loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
       <span class="token comment"># 打印当前的epoch</span>
       <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Epoch:'</span><span class="token punctuation">,</span> epoch<span class="token punctuation">)</span>
       <span class="token comment"># 调用绘图函数</span>
       gen_img_plot<span class="token punctuation">(</span>gen<span class="token punctuation">,</span> epoch<span class="token punctuation">,</span> test_input<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="_400"></a>小结</h3> 
<p>本文主要讨论了生成式对抗神经网络。首先，本文介绍了生成式对抗网络的设计思路。在此基础下，本文阐述了GAN的网络结构以及训练过程。生成器与解释器相互迭代，随着更新，生成器的效果趋近于真实图片。其次，本文展示了题为Generative Adversarial Networks论文的主要内容。这篇论文提出了生成式对抗网络的网络结构以及训练过程，该模型填补了生成任务方面神经网络的空白。此外，这篇论文还从理论角度证明了生成器的数据分布能够达到全局最优以及训练算法的可收敛性。最后，本文基于pytorch以及MNIST数据集实现了GAN绘制手写数字。</p> 
<h4><a id="_404"></a>本周内容简报</h4> 
<p>之前学习的神经网络以特征值x为输入，GAN除了x以外还能将简单的数据分布作为输入。</p> 
<p>设计者可以将GAN当作游戏手柄，以指令控制神经网络，这提升了神经网络的可操作性。</p> 
<p>随后是GAN的训练过程，首先固定生成器、更新解释器，解释器将更能识破生成器的伪装。越接近真实数据分布的样本，在解释器的得分越高。其次固定解释器、更新生成器，生成器更能逃过解释器的识别。从而生成器的数据分布也越接近真实数据。将两步迭代进行便是GAN的训练过程。</p> 
<p>此外，本周阅读的论文中还提出了k step的概念，即更新k步D然后更新一步G。</p> 
<h4><a id="_413"></a>下周计划</h4> 
<p>继续学习GAN模型以及阅读相关论文，实现较为复杂的GAN网络，可能考虑HW6。</p> 
<h3><a id="_417"></a>参考文献</h3> 
<p>[1] Goodfellow, Ian J., et al. “Generative Adversarial Networks.” <em>arXiv.Org</em>, 10 June 2014, arxiv.org/abs/1406.2661.</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a45e0df2db996b84a91bad310bc916a2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux系统编程学习 NO.9——git、gdb</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/44964eba8c98e206461d8e6acaf86815/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Linux网络】详解使用http和ftp搭建yum仓库，以及yum网络源优化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>