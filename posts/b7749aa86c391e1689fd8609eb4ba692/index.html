<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>工业缺陷检测项目实战(一)——基于opencv的工件缺陷检测C&#43;&#43;和python实现 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="工业缺陷检测项目实战(一)——基于opencv的工件缺陷检测C&#43;&#43;和python实现" />
<meta property="og:description" content="基于opencv的工件缺陷检测C&#43;&#43;和python实现 作为研究生，每一个项目都很重要，这里给大家分享一个好入门项目，代码纯自己写，网上都是python的，但是有些企业要求C&#43;&#43;编写项目，所以希望大家能学到东西。
一. 问题陈述
工件的展示，这是一个视频，然后工件一个个经过，要检测出哪个工件有缺陷，并且分类缺陷的种类。可以看到缺陷是不止一种。
二. 代码步骤
1.读取图像，转为灰度图并二值化
cvtColor(img, gray, COLOR_BGR2GRAY); threshold(gray, thresh, 127, 255, THRESH_TOZERO_INV);、 2.寻找轮廓
std::vector&lt;Vec4i&gt; hireachy; std::vector&lt;std::vector&lt;Point&gt;&gt; contours; findContours(thresh, contours, hireachy, RETR_LIST, CHAIN_APPROX_NONE); 3.遍历轮廓，对工件圈进行统计，防止重复标记
原理是计算图像矩，可以确定图像的灰度中心，根据每个时刻每个工件的中心位置的变换，可以判断画面里是否出现新的工件。同时，也要记得更新每个时刻每个工件的位置。具体代码实现可以参考完整工程文件。这里贴出部分：
for (size_t cnt = 0; cnt &lt; contours.size(); cnt&#43;&#43;) { double area = contourArea(contours[cnt]); //求轮廓面积(大约的) if (area &gt; 18000 &amp; area &lt; 28000) //把工件圈出来 { mu[cnt] = moments(contours[cnt], false); //计算图像矩，表示工件的位置 //计算图像质心位置 double cx = mu[cnt].m10 / mu[cnt].m00; double cy = mu[cnt].m01 / mu[cnt]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b7749aa86c391e1689fd8609eb4ba692/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-01T15:14:50+08:00" />
<meta property="article:modified_time" content="2023-03-01T15:14:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">工业缺陷检测项目实战(一)——基于opencv的工件缺陷检测C&#43;&#43;和python实现</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="opencvCpython_0"></a>基于opencv的工件缺陷检测C++和python实现</h3> 
<p>作为研究生，每一个项目都很重要，这里给大家分享一个好入门项目，代码纯自己写，网上都是python的，但是有些企业要求C++编写项目，所以希望大家能学到东西。<br> <strong>一. 问题陈述</strong><br> 工件的展示，这是一个视频，然后工件一个个经过，要检测出哪个工件有缺陷，并且分类缺陷的种类。可以看到缺陷是不止一种。<br> <img src="https://images2.imgbox.com/19/e5/zz0GSW9d_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/98/a4/4KrRmElV_o.png" alt="在这里插入图片描述"><br> <strong>二. 代码步骤</strong><br> 1.读取图像，转为灰度图并二值化</p> 
<pre><code>cvtColor(img, gray, COLOR_BGR2GRAY);
threshold(gray, thresh, 127, 255, THRESH_TOZERO_INV);、
</code></pre> 
<p>2.寻找轮廓</p> 
<pre><code>std::vector&lt;Vec4i&gt; hireachy;
std::vector&lt;std::vector&lt;Point&gt;&gt; contours;
findContours(thresh, contours, hireachy, RETR_LIST, CHAIN_APPROX_NONE);
</code></pre> 
<p>3.遍历轮廓，对工件圈进行统计，防止重复标记<br> 原理是计算图像矩，可以确定图像的灰度中心，根据每个时刻每个工件的中心位置的变换，可以判断画面里是否出现新的工件。同时，也要记得更新每个时刻每个工件的位置。具体代码实现可以参考完整工程文件。这里贴出部分：</p> 
<pre><code>for (size_t cnt = 0; cnt &lt; contours.size(); cnt++)
        {
            double area = contourArea(contours[cnt]); //求轮廓面积(大约的)
            if (area &gt; 18000 &amp; area &lt; 28000)          //把工件圈出来
            {
                mu[cnt] = moments(contours[cnt], false); //计算图像矩，表示工件的位置
                //计算图像质心位置
                double cx = mu[cnt].m10 / mu[cnt].m00;
                double cy = mu[cnt].m01 / mu[cnt].m00;
                boundRect[cnt] = boundingRect(Mat(contours[cnt])); //计算外接矩形

                new_object = true;
                //通过质心位置判断视频出现的工件是否是最新的
                if (cx &gt; 100) //工件要全部出现
                {
                    if (products.size() &gt; 0) //判断出现的工件是不是新的
                    {
                        for (size_t i = 0; i &lt; products.size(); i++)
                        {
                            //存在一个
                            if (fabs(cx - products[i].getX()) &lt;= 35 &amp;&amp; fabs(cy - products[i].getY()) &lt;= 35)
                            {
                                new_object = false;
                                //更新位置参数
                                products[i].updateCoords(cx, cy, boundRect[cnt].x, boundRect[cnt].y, boundRect[cnt].width, boundRect[cnt].height);
                            }
                        }
                    }
                    if (new_object == true)
                    {
                        Product p(pid, cx, cy, boundRect[cnt].x, boundRect[cnt].y, boundRect[cnt].width, boundRect[cnt].height);
                        p.save_pic(img);
                        products.emplace_back(p);
                        p.count = pid;
                        defects = p.defect_detect(); //缺陷检测
                        pid += 1;
                    }
                }
                //圈出来
                rectangle(img, boundRect[cnt].tl(), boundRect[cnt].br(), Scalar(0, 0, 255), 2, 8, 0);
            }
        }
</code></pre> 
<p>效果是这样：<br> <img src="https://images2.imgbox.com/13/c8/e8tv16AJ_o.png" alt="在这里插入图片描述"></p> 
<p>4.遍历轮廓，把工件圈出来，顺便保存调试，如下图。圈出来的原理也不难，其实就是通过函数</p> 
<pre><code>boundRect[cnt] = boundingRect(Mat(contours[cnt])); 
</code></pre> 
<p>计算外接矩形，就可以获得矩形的左上角和右下角坐标，就可以画了。效果如下：<br> <img src="https://images2.imgbox.com/38/f2/QZ06vFzk_o.jpg" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/75/1a/0PszqUuo_o.jpg" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b3/e8/Z28cHVXz_o.jpg" alt="在这里插入图片描述"></p> 
<p>5.对每个框进行缺陷提取，原理依然是轮廓检测加面积判断。效果如下：<br> <img src="https://images2.imgbox.com/9b/6a/cLFdR60R_o.jpg" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e4/9d/qf1Gr9x3_o.jpg" alt="在这里插入图片描述"><br> 6.缺陷类型判断，这里利用直方图统计。即统计0-255中每个像素的个数，根据个数，转为百分比，接着我们设定一个阈值，就可以判断出缺陷类型。部分代码：</p> 
<pre><code>          //------------------------直方图计算
            Mat hist;
            //设定像素取值范围
            int histSize = 256;
            float range[] = {0, 256};
            const float *histRanges = {range};
            // hist索引为像素，值为像素点的个数
            calcHist(&amp;resul, 1, 0, Mat(), hist, 1, &amp;histSize, &amp;histRanges, true, false);
            //-------------------------判断缺陷
            float sum = 0;
            for (int i = 0; i &lt; 256; i++)
            {
                float bin_val = hist.at&lt;float&gt;(i); //遍历hist元素（注意hist中是float类型）
                sum = sum + bin_val;               //计算总的个数
            }
            // std::cout &lt;&lt; "sum:"
            //           &lt;&lt; sum &lt;&lt; "\n";
            //计算各个像素点的个数百分比
            for (int i = 0; i &lt; 256; i++)
            {
                if (hist.at&lt;float&gt;(i) &gt; 0) //像素点个数大于0的时候
                {
                    hist.at&lt;float&gt;(i) = hist.at&lt;float&gt;(i) / sum;
                }
                // std::cout &lt;&lt; "hist:"
                //           &lt;&lt; hist.at&lt;float&gt;(i) &lt;&lt; "\n";
            }
            float hist_sum_scratch = 0;
            float hist_sum_blot = 0;
            for (int i = 90; i &lt; 135; i++) //比较灰的
            {
                hist_sum_scratch = hist_sum_scratch + hist.at&lt;float&gt;(i);
            }
            std::cout &lt;&lt; "hist_sum_scratch:"
                      &lt;&lt; hist_sum_scratch &lt;&lt; "\n";
            for (int i = 15; i &lt; 90; i++) //比较黑的
            {
                hist_sum_blot = hist_sum_blot + hist.at&lt;float&gt;(i);
            }
            std::cout &lt;&lt; "hist_sum_blot:"
                      &lt;&lt; hist_sum_blot &lt;&lt; "\n";
            if (hist_sum_scratch &gt;= hist_sum_blot)
            {
                Defect d(1, boundRect[cnt].x, boundRect[cnt].y, boundRect[cnt].width, boundRect[cnt].height);
                Result.emplace_back(d);
                state = 1;
                std::cout &lt;&lt; "此处缺陷划痕"
                          &lt;&lt; "\n";
            }
            if (hist_sum_scratch &lt; hist_sum_blot)
            {
                Defect d(2, boundRect[cnt].x, boundRect[cnt].y, boundRect[cnt].width, boundRect[cnt].height);
                Result.emplace_back(d);
                state = 2;
                std::cout &lt;&lt; "此处缺陷污渍"
                          &lt;&lt; "\n";
            }
</code></pre> 
<p>到此就可以完成啦!!!<br> <strong>三. 最终效果：</strong><br> <img src="https://images2.imgbox.com/37/69/qDt6iCAe_o.png" alt="在这里插入图片描述"><br> 可以看到，会在终端打印相关消息</p> 
<p><strong>C++代码纯自己写，有多文件，花了一些时间总结，大家可以私信我拿代码</strong><br> 另外，也准备了python代码，需要的也可以私信我。</p> 
<p>因为花费不少时间，所以希望大家给点报酬支持一下，<strong>继续加油进入下一个实战项目分享</strong>。</p> 
<h3><a id="_154"></a><strong>------------------------------------补充内容---------------------------------</strong></h3> 
<p>由于很多小伙伴下载代码之后不知道怎么使用这代码，今天就补充一下。首先，我们需要安装<strong>opencv与dlib</strong>，参考下我的另外一篇文章：<br> <a href="https://blog.csdn.net/weixin_39735688/article/details/120958148?spm=1001.2014.3001.5502">ubuntu20+dlib19.22+0pencv4.5.0的机器视觉算法之路(一)</a>.<br> 1.删除buiild文件夹里面的<strong>所有</strong>文件<br> 2.路径打开到build, 执行</p> 
<pre><code>cmake ..
</code></pre> 
<p>3.接着</p> 
<pre><code>make
</code></pre> 
<p>4.执行</p> 
<pre><code>./result
</code></pre> 
<p>搞定，完结，欢迎大家来学习，当作自己的一个项目，或者可以进一步去扩展成其他东西，懂的都懂。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9a9450da111d744f17e85c16b2447737/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决vue3没有this造成的无法使用vue2</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/83ee58df0b21cca57ce3716a76efbfe5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">以太网调试经验总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>