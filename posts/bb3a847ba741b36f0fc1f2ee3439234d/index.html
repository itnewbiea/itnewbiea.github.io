<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Bazel 与 gtest：构建一个最简单的测试驱动开发环境 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Bazel 与 gtest：构建一个最简单的测试驱动开发环境" />
<meta property="og:description" content="Bazel 介绍 Google 自家的构建工具，相比 CMake 的优势，主要是多语言构建和相比 Make 语法有更好的可读性。最著名的使用 Bazel 的项目大概是 Tensorflow 吧。目前生态上还是不太好和 CMake 相提并论，毕竟下面的命令已经像魔法一样刻在 Unix 的世界里。
./configure make make install 安装 Bazel Mac 用户当然是使用 brew 解决了：
brew install bazel 安装参考官网吧～
Hello Bazel 要使用 Bazel，首先在项目顶层目录创建一个名为 WORKSPACE 的文件。值得一提的是 Bazel 推崇的是 Monorepo ，建议的项目结构是把代码、测试代码放到一起。在 C/C&#43;&#43; 中，意味着更加推荐头文件、源码文件、测试文件都放到同一个目录下。如果按 include、src、lib、test 拆分，在 Bazel 的设计下，反而会增加难度。
因此我们就创建一个 src 文件夹，并在该文件夹下建立 BUILD 文件。WORKSPACE 顾名思义是工作区，BUILD 就是具体的构建目标。
. ├── WORKSPACE └── src ├── BUILD 在 src 下创建一个最简单的 C&#43;&#43; 文件：
#include &lt;iostream&gt; using namespace std; int main(int argc, char* argv[]) { cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/bb3a847ba741b36f0fc1f2ee3439234d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-12T16:40:59+08:00" />
<meta property="article:modified_time" content="2020-11-12T16:40:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Bazel 与 gtest：构建一个最简单的测试驱动开发环境</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Bazel__0"></a>Bazel 介绍</h3> 
<p>Google 自家的构建工具，相比 CMake 的优势，主要是多语言构建和相比 Make 语法有更好的可读性。最著名的使用 Bazel 的项目大概是 Tensorflow 吧。目前生态上还是不太好和 CMake 相提并论，毕竟下面的命令已经像魔法一样刻在 Unix 的世界里。</p> 
<pre><code>./configure
make
make install
</code></pre> 
<h3><a id="_Bazel_8"></a>安装 Bazel</h3> 
<p>Mac 用户当然是使用 brew 解决了：</p> 
<pre><code>brew install bazel
</code></pre> 
<p>安装参考官网吧～</p> 
<h3><a id="Hello_Bazel_15"></a>Hello Bazel</h3> 
<p>要使用 Bazel，首先在项目<strong>顶层目录</strong>创建一个名为 <code>WORKSPACE</code> 的文件。值得一提的是 Bazel 推崇的是 Monorepo ，建议的项目结构是把<strong>代码、测试代码</strong>放到一起。在 C/C++ 中，意味着更加推荐头文件、源码文件、测试文件都放到同一个目录下。如果按 <code>include</code>、<code>src</code>、<code>lib</code>、<code>test</code> 拆分，在 Bazel 的设计下，反而会增加难度。</p> 
<p>因此我们就创建一个 <code>src</code> 文件夹，并在该文件夹下建立 <code>BUILD</code> 文件。<code>WORKSPACE</code> 顾名思义是工作区，<code>BUILD</code> 就是具体的构建目标。</p> 
<pre><code>.
├── WORKSPACE
└── src
    ├── BUILD
</code></pre> 
<p>在 <code>src</code> 下创建一个最简单的 C++ 文件：</p> 
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello, bazel"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这个代码会编译成可执行文件，而不是库文件，因此在 <code>BUILD</code> 中写入第一个构建目标：</p> 
<pre><code>cc_binary(
  name = "main",
  srcs = ["main.cpp"]
)
</code></pre> 
<p>接下来，就可以使用 Bazel 进行构建了：</p> 
<pre><code>bazel build src:main
</code></pre> 
<p>如果终端的工作目录在 <code>src</code>，可以省略 <code>src</code>，<code>bazel build :main</code>：</p> 
<pre><code>INFO: Analyzed target //src:main (14 packages loaded, 105 targets configured).
INFO: Found 1 target...
Target //src:main up-to-date:
  bazel-bin/src/main
INFO: Elapsed time: 4.106s, Critical Path: 0.86s
INFO: 2 processes: 2 darwin-sandbox.
INFO: Build completed successfully, 5 total actions
</code></pre> 
<p>之后就使用 <code>bazel run src:main</code> 运行构建好的程序：</p> 
<pre><code>INFO: Analyzed target //src:main (0 packages loaded, 0 targets configured).
INFO: Found 1 target...
Target //src:main up-to-date:
  bazel-bin/src/main
INFO: Elapsed time: 0.132s, Critical Path: 0.01s
INFO: 0 processes.
INFO: Build completed successfully, 1 total action
INFO: Build completed successfully, 1 total action
hello, bazel
</code></pre> 
<p>Bazel 会生成几个目录，可以在 bazel-bin 中找到构建好的程序。</p> 
<h3><a id="Google_Test_74"></a>Google Test</h3> 
<p>Google Test 是 Google 开发的一套 C++ 测试框架，原生支持了 Bazel 构建。为了自动导入所需的依赖（一般只有支持的 Bazel 的项目才可以），我们在 WORKSPACE 中写入针对 google test 的依赖条目。</p> 
<pre><code>workspace(name = "com_googletest_driven")
load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")

# Google Test
http_archive(
  name = "com_google_googletest",
  urls = ["https://github.com/google/googletest/archive/release-1.10.0.zip"],
  strip_prefix = "googletest-release-1.10.0",
  sha256 = "94c634d499558a76fa649edb13721dce6e98fb1e7018dfaeba3cd7a083945e91",
)
</code></pre> 
<p><code>workspace</code> 那一行可以简单的理解为项目名称。<code>load</code> 用来发现本地路径和加载对应的符号规则，这里引入的 <code>http_archive</code> 用来引用和检索打包好的 Bazel 库。一旦检索到压缩的仓库，就会自动解压，里面包含的规则、构建目标都可以直接在项目中使用。</p> 
<p><code>strip_prefix</code> 就是解压后的文件夹名称，用来指定抽取的文件目录。<code>sha256</code> 对下载的内容进行校验，可以极大的增加依赖的可入性。在 Linux 中，可以使用 <code>sha256sum</code> 获得该项内容；Mac OSX 上使用的 <code>shasum -a 256</code>。</p> 
<p>可以将 <code>curl</code> 和 <code>shasum</code> 组合起来获得所需要的 sha256 校验码：</p> 
<pre><code>curl -L https://github.com/google/googletest/archive/release-1.10.0.zip | shasum -a 256
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
94c634d499558a76fa649edb13721dce6e98fb1e7018dfaeba3cd7a083945e91  
</code></pre> 
<p>由于 Google Test 原生支持了 Bazel，这样就已经集成了 Google Test。</p> 
<h3><a id="_103"></a>单元测试</h3> 
<p>Bazel 原生支持 <code>test</code> 目标的构建，编写基于 Google Test 的测试非常简单，甚至都不需要添加测试启动的入口。</p> 
<p>我们试着构建一个最简单的测试用例，新建一个库的构建目标，在 src 中的 BUILD 中新增下面内容：</p> 
<pre><code>cc_library(
  name = "add",
  hdrs = ["add.hpp"],
  srcs = ["add.cpp"]
)
</code></pre> 
<p><code>hdrs</code> 显然就是公开的头文件。<br> 示例代码的内容：</p> 
<pre><code>// add.hpp
#pragma once

int add(int a, int b);
</code></pre> 
<pre><code class="prism language-cpp"><span class="token comment">// add.cpp</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"add.hpp"</span></span>

<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>再创建一个 add_test.cpp 文件，引入 google test：</p> 
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"gtest/gtest.h"</span></span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"add.hpp"</span></span>
 
<span class="token function">TEST</span><span class="token punctuation">(</span>testAdd<span class="token punctuation">,</span> test0<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token function">EXPECT_EQ</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>为了构建测试，在 BUILD 中新增测试目标：</p> 
<pre><code>cc_test(
  name = "test_add",
  srcs = ["hello_test.cpp"],
  deps = [
    ":add",
    "@com_google_googletest//:gtest_main",
  ],
)
</code></pre> 
<p><code>deps</code> 指明了依赖的代码和 google test 库。导入外部依赖库的规则是这样的：<br> <img src="https://images2.imgbox.com/74/86/zYM1CYcs_o.png" alt="依赖的路径写法"><br> 至此，就完成了一个测试环境的搭建，由于 Bazel 原生的支持，<strong>不需要</strong>写类似下面的测试入口方法来运行测试：</p> 
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"gtest/gtest.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  testing<span class="token operator">::</span><span class="token function">InitGoogleTest</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">RUN_ALL_TESTS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>接下来，直接使用 <code>bazel run src:test_add</code>，还可以使用 <code>bazel test src:test_add</code> 直接获取测试结果。</p> 
<pre><code>bazel run :test_add 
INFO: Analyzed target //src:test_add (0 packages loaded, 0 targets configured).
INFO: Found 1 target...
Target //src:test_add up-to-date:
  bazel-bin/src/test_add
INFO: Elapsed time: 0.151s, Critical Path: 0.00s
INFO: 0 processes.
INFO: Build completed successfully, 1 total action
INFO: Build completed successfully, 1 total action
exec ${PAGER:-/usr/bin/less} "$0" || exit 1
Executing tests from //src:test_add
-----------------------------------------------------------------------------
Running main() from gmock_main.cc
[==========] Running 1 test from 1 test suite.
[----------] Global test environment set-up.
[----------] 1 test from testAdd
[ RUN      ] testAdd.test0
[       OK ] testAdd.test0 (0 ms)
[----------] 1 test from testAdd (0 ms total)

[----------] Global test environment tear-down
[==========] 1 test from 1 test suite ran. (1 ms total)
[  PASSED  ] 1 test.
</code></pre> 
<h3><a id="_199"></a>小结</h3> 
<p>Bazel 最大的优势还是多语言构建，当然 Bazel 的功能不止这些，还有类似包可见性等概念并没有涉及。不过，还是可以看到 Bazel 的使用还是比较简单的（如果原生支持）。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/923c03fed5dcc0bda4ab7fc05021e647/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">有人在开课吧学习过吗？值得信任吗？教学质量如何？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/de09739593b61ec8341d1b6239b38e2f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LeetCode 915. 分割数组</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>