<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>你所不知道的C和C&#43;&#43;运行库 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="你所不知道的C和C&#43;&#43;运行库" />
<meta property="og:description" content="你所不知道的C和C&#43;&#43;运行库
周五晚，小雨，少见的未加班。无聊，遂准备写一篇博客，介绍一下C和C&#43;&#43;运行库，只因发现工作几年的人对此一知半解的大有人在。
在使用VC构建项目时，经常会遇到下面的链接错误：
初学者面对这些错误常常不知所错：libcmt.lib是什么东西？msvcrtd.dll又是干吗用的？在使用VC&#43;&#43;时我们也常常对下面的运行库配置项感到疑惑，它们到底究竟是什么意思呢？甚至一些工作了很多年的程序员也对此一知半解。今天让我们来了解一下它们。 从C和C&#43;&#43;运行库说起 为了提高C语言的开发效率，C标准定义了一系列常用的函数，称为C库函数。C标准仅仅定义了函数原型，并没有提供实现。因此这个任务留给了各个支持C语言标准的编译器。每个编译器通常实现了标准C的超集，称为C运行时库(C Run Time Libray) ，简称CRT。对于VC&#43;&#43;编译器来说，它提供的CRT库支持C标准定义的标准C函数，同时也有一些专门针对windows系统特别设计的函数。 与C语言类似，C&#43;&#43;也定义了自己的标准，同时提供相关支持库，我们把它称为C&#43;&#43;运行时库或C&#43;&#43;标准库。 由于C&#43;&#43;对C的兼容性，C&#43;&#43;标准库包括了C标准库，除此之外还包括IO流和标准模板库STL。 VC&#43;&#43;在何处实现C和C&#43;&#43;运行库 VC&#43;&#43;完美的支持C和C&#43;&#43;标准，因此也就按照C和C&#43;&#43;的标准定义的函数原型实现了上述运行时库。为了方便有不同需求的客户的使用，VC&#43;&#43;分别实现了动态链接库DLL版本和静态库LIB版本。同时为了支持程序调试且不影响程序的性能，又分别提供了对应的调试版本。调试版本的名称在Release版本名称后添了字母d。 对于C运行时库CRT，VC6.0、VC2005、VC2008和VC2010均提供了DLL版本和LIB版本。上述各个编译器提供的LIB版的CRT库，均实现在libcmt.lib。对应的调试版名称为libcmtd.lib。 而DLL版本名称根据编译器不同而不同，我们可以从名称上加以分辨。 VC6.使用的CRT库的DLL版本在MSVCRT.DLL中实现， 对应调试版本为MSVCRTD.LIB。 VC2005使用的CRT库的DLL版本在MSVCR80.DLL中实现，对应调试版本为MSVCR80.DLL。 VC2008使用的CRT库的DLL版本在MSVCR90.DLL中实现，对应调试版本为MSVCR90D.DLL。 VC2010使用的CRT库的DLL版本在MSVCR100.DLL中实现，对应调试版本为MSVCR100D.DLL。 C&#43;&#43;标准兼容C标准，但VC各版本将C&#43;&#43;编译器使用的C标准库与C编译器使用的C运行库一起实现，它们使用相同的运行库。 对于C&#43;&#43;标准库中的IO流和STL，VC6.0、VC2005、VC2008和VC2010也提供了DLL版本和LIB版本。 LIB版均实现在libcpmt.lib中，对应的调试版本为libcpmtd.lib。 不同版本的编译器实现的DLL也不相同。 VC6.使用的C&#43;&#43;类库的 DLL版本在MSVCP60.DLL中实现， 对应调试版本为MSVCP60D.LIB。 VC2005使用的C&#43;&#43;类库的DLL版本在MSVCP80.DLL中实现，对应调试版本为MSVCP80.DLL。 VC2008使用的C&#43;&#43;类库的 DLL版本在MSVCP90.DLL中实现，对应调试版本为MSVCP90D.DLL。 VC2010使用的C&#43;&#43;类库的DLL版本在MSVCP100.DLL中实现，对应调试版本为MSVCP100D.DLL。 在各个版本的编译器中，我们可以通过配置选项来设置程序使用的C和C&#43;&#43;运行时库的类型。如下图(其他版本编译器大同小异)： MT选项：链接LIB版的C和C&#43;&#43;运行库。在链接时就会在将C和C&#43;&#43;运行时库集成到程序中成为程序中的代码，程序体积会变大。 MTd选项：LIB的调试版。 MD选项：使用DLL版的C和C&#43;&#43;运行库，这样在程序运行时会动态的加载对应的DLL，程序体积会减小，缺点是在系统没有对应DLL时程序无法运行。 MDd选项：表示使用DLL的调试版。 在 《由使用LeakDialog时遇到的问题而引出的一些分析》 这篇文章中的实验一，使用VC6.0的默认配置没有拦截到内存泄露。其原因是VC6.0的控制台项目默认配置是静态链接CRT库（单线程版，后面会介绍）。 动态版（DLL）和静态版（LIB）C和C&#43;&#43;运行库的优缺点 因为静态版必须把C和C&#43;&#43;运行库复制到目标程序中，所以产生的可执行文件会比较大。同时对于使用多个模块的大型软件来说，如果每个模块均选择静态链接C或C&#43;&#43;运行库，在程序运行时就会存在多个运行库。在链接时也会出现重复定义的问题，如文章首第一张图所示。 使用DLL版的C和C&#43;&#43;运行库，程序在运行时动态的加载对应的DLL。程序体积变小，但一个很大的问题就是一旦找不到对应DLL,程序将无法运行。假设使用VC6.0并选择使用MD选项构建，那么当用户使用VC2005来使用这个DLL时很可能出现找不到MSVCRT.DLL或MSVCP60.DLL的情况。 在这里介绍一个很好的工具：Dependency Walker，可以用来分析DLL的依赖关系，同时查看DLL导出的函数，使用方法请Google。 使用该工具打开MSVCRT.DLL，如下图： 我们可以在其中找到我们经常使用使用的C函数，如printf ,getchar,malloc等。 打开MSVCP100.DLL，也可以找到这些C函数： 在开发的过程中我们也会遇到如下图的链接错误，LIBCD.lib究竟是何方神圣呢？ 它其实是LIBC.lib的调试版，而LIBC.lib是只有在VC6.0才会使用的静态库，该库是CRT的单线程版，用于支持单线程版本的CRT。VC2005等更高版本的编译器已经不再提供单线程版本，转而使用多线程版的MSVCR80.DLL或libcmt.lib。 当遇到上述符号定义冲突的链接错误时，可以选择忽略libcd.lib。
2014.2.28 于浙江杭州" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b0a3cf1b6e98484fa2d11bbd81ca93c0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-02-28T22:17:10+08:00" />
<meta property="article:modified_time" content="2014-02-28T22:17:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">你所不知道的C和C&#43;&#43;运行库</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p><span style="font-size:18px;">                                       你所不知道的C和C++运行库</span><br><br><span style="font-size:18px;">　　 周五晚，小雨，少见的未加班。无聊，遂准备写一篇博客，介绍一下C和C++运行库，只因发现工作几年的人对此一知半解的大有人在。</span><br><span style="font-size:18px;">　　</span><br><span style="font-size:18px;">　　在使用VC构建项目时，经常会遇到下面的链接错误：</span><br><br></p> 
<p class="p0" style="font-size:18px; margin-bottom: 0pt; margin-top: 0pt; ">                   <img src="https://images2.imgbox.com/7c/e1/PuFozhSJ_o.jpg" alt=""><br></p> 
<br> 
<span style="font-size:18px;">　　初学者面对这些错误常常不知所错：libcmt.lib是什么东西？msvcrtd.dll又是干吗用的？在使用VC++时我们也常常对下面的运行库配置项感到疑惑，它们到底究竟是什么意思呢？甚至一些工作了很多年的程序员也对此一知半解。今天让我们来了解一下它们。</span> 
<br> 
<span style="font-size:18px;">    <img src="https://images2.imgbox.com/58/99/CKtWrjsU_o.jpg" alt=""></span> 
<br> 
<br> 
<span style="font-size:18px;">从C和C++运行库说起</span> 
<br> 
<br> 
<span style="font-size:18px;">　　为了提高C语言的开发效率，C标准定义了一系列常用的函数，称为C库函数。C标准仅仅定义了函数原型，并没有提供实现。因此这个任务留给了各个支持C语言标准的编译器。每个编译器通常实现了标准C的超集，称为C运行时库(C Run Time Libray) ，简称CRT。对于VC++编译器来说，它提供的CRT库支持C标准定义的标准C函数，同时也有一些专门针对windows系统特别设计的函数。</span> 
<br> 
<span style="font-size:18px;">　　与C语言类似，C++也定义了自己的标准，同时提供相关支持库，我们把它称为C++运行时库或C++标准库。</span> 
<br> 
<span style="font-size:18px;">　　由于C++对C的兼容性，C++标准库包括了C标准库，除此之外还包括IO流和标准模板库STL。</span> 
<br> 
<br> 
<span style="font-size:18px;">VC++在何处实现C和C++运行库</span> 
<br> 
<br> 
<span style="font-size:18px;">　　VC++完美的支持C和C++标准，因此也就按照C和C++的标准定义的函数原型实现了上述运行时库。为了方便有不同需求的客户的使用，VC++分别实现了动态链接库DLL版本和静态库LIB版本。同时为了支持程序调试且不影响程序的性能，又分别提供了对应的调试版本。调试版本的名称在Release版本名称后添了字母d。</span> 
<br> 
<br> 
<span style="font-size:18px;">　　对于C运行时库CRT，VC6.0、VC2005、VC2008和VC2010均提供了DLL版本和LIB版本。上述各个编译器提供的LIB版的CRT库，均实现在libcmt.lib。对应的调试版名称为libcmtd.lib。</span> 
<br> 
<br> 
<span style="font-size:18px;">　　而DLL版本名称根据编译器不同而不同，我们可以从名称上加以分辨。</span> 
<br> 
<span style="font-size:18px;">　　VC6.使用的CRT库的DLL版本在MSVCRT.DLL中实现， 对应调试版本为MSVCRTD.LIB。</span> 
<br> 
<span style="font-size:18px;">　　VC2005使用的CRT库的DLL版本在MSVCR80.DLL中实现，对应调试版本为MSVCR80.DLL。</span> 
<br> 
<span style="font-size:18px;">　　VC2008使用的CRT库的DLL版本在MSVCR90.DLL中实现，对应调试版本为MSVCR90D.DLL。</span> 
<br> 
<span style="font-size:18px;">　　VC2010使用的CRT库的DLL版本在MSVCR100.DLL中实现，对应调试版本为MSVCR100D.DLL。</span> 
<br> 
<br> 
<span style="font-size:18px;">　　C++标准兼容C标准，但VC各版本将C++编译器使用的C标准库与C编译器使用的C运行库一起实现，它们使用相同的运行库。</span> 
<br> 
<br> 
<span style="font-size:18px;">　　对于C++标准库中的IO流和STL，VC6.0、VC2005、VC2008和VC2010也提供了DLL版本和LIB版本。</span> 
<br> 
<span style="font-size:18px;">　　LIB版均实现在libcpmt.lib中，对应的调试版本为libcpmtd.lib。</span> 
<br> 
<br> 
<span style="font-size:18px;">　　不同版本的编译器实现的DLL也不相同。</span> 
<br> 
<span style="font-size:18px;">　　VC6.使用的C++类库的 DLL版本在MSVCP60.DLL中实现， 对应调试版本为MSVCP60D.LIB。</span> 
<br> 
<span style="font-size:18px;">　　VC2005使用的C++类库的DLL版本在MSVCP80.DLL中实现，对应调试版本为MSVCP80.DLL。</span> 
<br> 
<span style="font-size:18px;">　　VC2008使用的C++类库的 DLL版本在MSVCP90.DLL中实现，对应调试版本为MSVCP90D.DLL。</span> 
<br> 
<span style="font-size:18px;">　　VC2010使用的C++类库的DLL版本在MSVCP100.DLL中实现，对应调试版本为MSVCP100D.DLL。</span> 
<br> 
<br> 
<span style="font-size:18px;">　　在各个版本的编译器中，我们可以通过配置选项来设置程序使用的C和C++运行时库的类型。如下图(其他版本编译器大同小异)：</span> 
<br> 
<span style="font-size:18px;">　　</span> 
<br> 
<span style="font-size:18px;">   <img src="https://images2.imgbox.com/a3/15/I4ICeMi0_o.jpg" alt=""></span> 
<br> 
<span style="font-size:18px;">　　MT选项：链接LIB版的C和C++运行库。在链接时就会在将C和C++运行时库集成到程序中成为程序中的代码，程序体积会变大。</span> 
<br> 
<span style="font-size:18px;">　　MTd选项：LIB的调试版。</span> 
<br> 
<span style="font-size:18px;">　　MD选项：使用DLL版的C和C++运行库，这样在程序运行时会动态的加载对应的DLL，程序体积会减小，缺点是在系统没有对应DLL时程序无法运行。</span> 
<br> 
<span style="font-size:18px;">　　MDd选项：表示使用DLL的调试版。</span> 
<br> 
<span style="font-size:18px;">　　在</span> 
<a target="_blank" href="http://blog.csdn.net/ithzhang/article/details/19086139" style="font-size:18px; " rel="noopener noreferrer">《由使用LeakDialog时遇到的问题而引出的一些分析》</a> 
<span style="font-size:18px;">这篇文章中的实验一，使用VC6.0的默认配置没有拦截到内存泄露。其原因是VC6.0的控制台项目默认配置是静态链接CRT库（单线程版，后面会介绍）。</span> 
<br> 
<br> 
<span style="font-size:18px;">动态版（DLL）和静态版（LIB）C和C++运行库的优缺点</span> 
<br> 
<br> 
<span style="font-size:18px;">　　因为静态版必须把C和C++运行库复制到目标程序中，所以产生的可执行文件会比较大。同时对于使用多个模块的大型软件来说，如果每个模块均选择静态链接C或C++运行库，在程序运行时就会存在多个运行库。在链接时也会出现重复定义的问题，如文章首第一张图所示。</span> 
<br> 
<span style="font-size:18px;">　　使用DLL版的C和C++运行库，程序在运行时动态的加载对应的DLL。程序体积变小，但一个很大的问题就是一旦找不到对应DLL,程序将无法运行。假设使用VC6.0并选择使用MD选项构建，那么当用户使用VC2005来使用这个DLL时很可能出现找不到MSVCRT.DLL或MSVCP60.DLL的情况。</span> 
<br> 
<br> 
<span style="font-size:18px;">　　在这里介绍一个很好的工具：Dependency Walker，可以用来分析DLL的依赖关系，同时查看DLL导出的函数，使用方法请Google。</span> 
<br> 
<span style="font-size:18px;">　　使用该工具打开MSVCRT.DLL，如下图：</span> 
<br> 
<span style="font-size:18px;">   <img src="https://images2.imgbox.com/9e/41/Nk6mIHhy_o.jpg" alt=""></span> 
<br> 
<span style="font-size:18px;">　　我们可以在其中找到我们经常使用使用的C函数，如printf ,getchar,malloc等。</span> 
<br> 
<span style="font-size:18px;">　　打开MSVCP100.DLL，也可以找到这些C函数：</span> 
<br> 
<br> 
<span style="font-size:18px;">    <img src="https://images2.imgbox.com/90/16/mOgrfmqr_o.jpg" alt=""></span> 
<br> 
<span style="font-size:18px;">　　在开发的过程中我们也会遇到如下图的链接错误，LIBCD.lib究竟是何方神圣呢？</span> 
<br> 
<br>                          
<img src="https://images2.imgbox.com/d1/33/9kMk8Hrb_o.jpg" alt=""> 
<br> 
<span style="font-size:18px;">　　它其实是LIBC.lib的调试版，而LIBC.lib是只有在VC6.0才会使用的静态库，该库是CRT的单线程版，用于支持单线程版本的CRT。VC2005等更高版本的编译器已经不再提供单线程版本，转而使用多线程版的MSVCR80.DLL或libcmt.lib。</span> 
<br> 
<p><span style="font-size:18px;">　　当遇到上述符号定义冲突的链接错误时，可以选择忽略libcd.lib。</span></p> 
<p><span style="white-space:pre"> </span>2014.2.28 于浙江杭州</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fa031e52e45083ef7b7fcbe59ac87a59/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">电脑没声音 怎么办？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/97887a00ad61b89ebdc9cbcb2d21c214/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java中的a&#43;&#43;和&#43;&#43;a的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>