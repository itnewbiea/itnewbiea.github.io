<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker容器技术之常用操作（6） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker容器技术之常用操作（6）" />
<meta property="og:description" content="文章目录 容器的常用操作1 查看容器的主机名2 在容器启动时注入主机名3 手动指定容器要使用的DNS4 手动往/etc/hosts文件中注入主机名到IP地址的映射5 开放容器端口6 自定义docker0桥的网络属性信息 7. docker创建自定义桥 容器的常用操作 1 查看容器的主机名 [root@node02 ~]# docker run -it --rm busybox / # hostname 10f87984f514 2 在容器启动时注入主机名 [root@node02 ~]# docker run -it --rm --hostname dragonyear busybox / # hostname dragonyear / # cat /etc/hosts 127.0.0.1	localhost ::1	localhost ip6-localhost ip6-loopback fe00::0	ip6-localnet ff00::0	ip6-mcastprefix ff02::1	ip6-allnodes ff02::2	ip6-allrouters 172.17.0.6	dragonyear / # cat /etc/resolv.conf # Generated by NetworkManager search localdomain nameserver 192." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/99cb9f530d5b28821f1b87d99e902d15/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-30T12:43:21+08:00" />
<meta property="article:modified_time" content="2020-08-30T12:43:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker容器技术之常用操作（6）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">容器的常用操作</a></li><li><ul><li><a href="#1__3" rel="nofollow">1 查看容器的主机名</a></li><li><a href="#2__9" rel="nofollow">2 在容器启动时注入主机名</a></li><li><a href="#3_DNS_35" rel="nofollow">3 手动指定容器要使用的DNS</a></li><li><a href="#4_etchostsIP_52" rel="nofollow">4 手动往/etc/hosts文件中注入主机名到IP地址的映射</a></li><li><a href="#5__65" rel="nofollow">5 开放容器端口</a></li><li><a href="#6_docker0_111" rel="nofollow">6 自定义docker0桥的网络属性信息</a></li></ul> 
  </li><li><a href="#7_docker_134" rel="nofollow">7. docker创建自定义桥</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>容器的常用操作</h2> 
<hr> 
<h3><a id="1__3"></a>1 查看容器的主机名</h3> 
<pre><code>[root@node02 ~]# docker run -it --rm busybox
/ # hostname
10f87984f514
</code></pre> 
<h3><a id="2__9"></a>2 在容器启动时注入主机名</h3> 
<pre><code>[root@node02 ~]# docker run -it --rm --hostname dragonyear busybox
/ # hostname
dragonyear
/ # cat /etc/hosts 
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
ff00::0	ip6-mcastprefix
ff02::1	ip6-allnodes
ff02::2	ip6-allrouters
172.17.0.6	dragonyear
/ # cat /etc/resolv.conf 
# Generated by NetworkManager
search localdomain
nameserver 192.168.159.2
/ # ping www.baidu.com
PING www.baidu.com (14.215.177.38): 56 data bytes
64 bytes from 14.215.177.38: seq=0 ttl=127 time=24.434 ms
64 bytes from 14.215.177.38: seq=1 ttl=127 time=22.653 ms
^C
--- www.baidu.com ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max = 22.653/23.543/24.434 ms
</code></pre> 
<h3><a id="3_DNS_35"></a>3 手动指定容器要使用的DNS</h3> 
<pre><code>[root@node02 ~]# docker run -it --rm --dns 114.114.114.114 busybox
/ # cat /etc/resolv.conf
search localdomain
nameserver 114.114.114.114
/ # nslookup -type=a www.baidu.com
Server:		114.114.114.114
Address:	114.114.114.114:53

Non-authoritative answer:
www.baidu.com	canonical name = www.a.shifen.com
Name:	www.a.shifen.com
Address: 14.215.177.39
Name:	www.a.shifen.com
Address: 14.215.177.38
</code></pre> 
<h3><a id="4_etchostsIP_52"></a>4 手动往/etc/hosts文件中注入主机名到IP地址的映射</h3> 
<pre><code>[root@node02 ~]# docker run -it --rm --add-host www.a.com:1.1.1.1 busybox
/ # cat /etc/hosts
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
ff00::0	ip6-mcastprefix
ff02::1	ip6-allnodes
ff02::2	ip6-allrouters
1.1.1.1	www.a.com
172.17.0.6	bab4c7b50245
</code></pre> 
<h3><a id="5__65"></a>5 开放容器端口</h3> 
<p>执行docker run的时候有个-p选项，可以将容器中的应用端口映射到宿主机中，从而实现让外部主机可以通过访问宿主机的某端口来访问容器内应用的目的。<br> -p选项能够使用多次，其所能够暴露的端口必须是容器确实在监听的端口。<br> -p选项的使用格式：</p> 
<ul><li> <p>-p &lt;containerPort&gt;</p> 
  <ul><li>将指定的容器端口映射至主机所有地址的一个动态端口</li></ul> </li><li> <p>-p &lt;hostPort&gt;:&lt;containerPort&gt;</p> 
  <ul><li>将容器端口&lt;containerPort&gt;映射至指定的主机端口&lt;hostPort&gt;</li></ul> </li><li> <p>-p &lt;ip&gt;::&lt;containerPort&gt;</p> 
  <ul><li>将指定的容器端口&lt;containerPort&gt;映射至主机指定&lt;ip&gt;的动态端口</li></ul> </li><li> <p>-p &lt;ip&gt;:&lt;hostPort&gt;:&lt;containerPort&gt;</p> 
  <ul><li>将指定的容器端口&lt;containerPort&gt;映射至主机指定&lt;ip&gt;的端口&lt;hostPort&gt;</li></ul> </li></ul> 
<p>动态端口指的是随机端口，具体的映射结果可使用docker port命令查看。</p> 
<pre><code>[root@node02 ~]# docker run --name web --rm -p 80 nginx
/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration
/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/
/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh
10-listen-on-ipv6-by-default.sh: Getting the checksum of /etc/nginx/conf.d/default.conf
10-listen-on-ipv6-by-default.sh: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf
/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh
/docker-entrypoint.sh: Configuration complete; ready for start up
</code></pre> 
<p>以上命令执行后会一直占用着前端，我们新开一个终端连接来看一下容器的80端口被映射到了宿主机的什么端口上</p> 
<pre><code>[root@node02 ~]# docker port web
80/tcp -&gt; 0.0.0.0:32769
</code></pre> 
<p>由此可见，容器的80端口被暴露到了宿主机的32769端口上，此时我们在宿主机上访问一下这个端口看是否能访问到容器内的站点<br> <img src="https://images2.imgbox.com/db/b7/Ypfj2mE0_o.png" alt="在这里插入图片描述"><br> iptables防火墙规则将随容器的创建自动生成，随容器的删除自动删除规则。</p> 
<p>将容器端口映射到指定IP的随机端口</p> 
<pre><code>[root@node02 ~]# docker run --name web --rm -p 192.168.10.144::80 nginx
</code></pre> 
<p>在另一个终端上查看端口映射情况</p> 
<pre><code>[root@node02 ~]# docker port web
80/tcp -&gt; 192.168.10.144:32768
</code></pre> 
<h3><a id="6_docker0_111"></a>6 自定义docker0桥的网络属性信息</h3> 
<p><a href="https://docs.docker.com/network/bridge/" rel="nofollow">官方文档相关配置</a><br> 自定义docker0桥的网络属性信息需要修改<code>/etc/docker/daemon.json</code>配置文件</p> 
<pre><code>{
    "bip": "192.168.1.5/24",
    "fixed-cidr": "192.168.1.5/25",
    "fixed-cidr-v6": "2001:db8::/64",
    "mtu": 1500,
    "default-gateway": "10.20.1.1",
    "default-gateway-v6": "2001:db8:abcd::89",
    "dns": ["10.20.1.2","10.20.1.3"]
}
</code></pre> 
<p>核心选项为bip，即bridge ip之意，用于指定docker0桥自身的IP地址；其它选项可通过此地址计算得出。<br> dockerd守护进程的C/S，其默认仅监听Unix Socket格式的地址(/var/run/docker.sock)，如果要使用TCP套接字，则需要修改/etc/docker/daemon.json配置文件，添加如下内容，然后重启docker服务：</p> 
<pre><code>"hosts": ["tcp://0.0.0.0:2375", "unix:///var/run/docker.sock"]
</code></pre> 
<p>在客户端上向dockerd直接传递“-H|–host”选项指定要控制哪台主机上的docker容器</p> 
<pre><code>docker -H 192.168.10.145:2375 ps
</code></pre> 
<h2><a id="7_docker_134"></a>7. docker创建自定义桥</h2> 
<p>创建一个额外的自定义桥，区别于docker0</p> 
<pre><code>[root@node02 ~]# docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
64e882ec3284        bridge              bridge              local
520966d1cd1f        host                host                local
a883c57d1e63        none                null                local

[root@node02 ~]# docker network create -d bridge --subnet "192.168.2.0/24" --gateway "192.168.2.1" br0
0f55ccc07a6aa06cd010005cac531ecccc96c508f8dccffc866472f7623c4d87
[root@node02 ~]# docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
0f55ccc07a6a        br0                 bridge              local
64e882ec3284        bridge              bridge              local
520966d1cd1f        host                host                local
a883c57d1e63        none                null                local
</code></pre> 
<p>使用新创建的自定义桥来创建容器：</p> 
<pre><code>[root@node02 ~]# docker run -it --name b1 --network br0 busybox
Unable to find image 'busybox:latest' locally
latest: Pulling from library/busybox
61c5ed1cbdf8: Pull complete 
Digest: sha256:4f47c01fa91355af2865ac10fef5bf6ec9c7f42ad2321377c21e844427972977
Status: Downloaded newer image for busybox:latest
/ # ifconfig
eth0      Link encap:Ethernet  HWaddr 02:42:C0:A8:02:02  
          inet addr:192.168.2.2  Bcast:192.168.2.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:13 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:1102 (1.0 KiB)  TX bytes:0 (0.0 B)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
</code></pre> 
<p>再创建一个容器，使用默认的bridge桥：</p> 
<pre><code>[root@node02 ~]# docker run --name b2 -it busybox
/ # ls
bin   dev   etc   home  proc  root  sys   tmp   usr   var
/ # ifconfig
eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:02  
          inet addr:172.17.0.2  Bcast:172.17.255.255  Mask:255.255.0.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:12 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:1032 (1.0 KiB)  TX bytes:0 (0.0 B)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
</code></pre> 
<p>这个时候容器b1与b2之间是不能通信的，因为两个网桥不在一个网段，所以要开机宿主机的IP转发功能</p> 
<pre><code>[root@node02 ~]# vim /etc/sysctl.conf 
[root@node02 ~]# sysctl -p
net.ipv4.ip_forward = 1
</code></pre> 
<p>在b1上测试能否与b2互通</p> 
<pre><code>/ # ping 172.17.0.2
PING 172.17.0.2 (172.17.0.2): 56 data bytes
64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.077 ms
64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.131 ms
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7331baac42847cee3c8c0be143df723e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Putty &#43; Xming实现远程登陆Linux显示图形化界面</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/450473b289e0a8d7cb448996c7784489/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于《Java开发手册（嵩山版）》中：判断所有集合内部的元素是否为空，使用isEmpty()方法，而不是size()==0的方式的疑惑</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>