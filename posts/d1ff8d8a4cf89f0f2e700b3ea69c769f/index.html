<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【AcWing每日一题】4366. 上课睡觉 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【AcWing每日一题】4366. 上课睡觉" />
<meta property="og:description" content="有 N 堆石子，每堆的石子数量分别为 a1,a2,…,aN。
你可以对石子堆进行合并操作，将两个相邻的石子堆合并为一个石子堆，例如，如果 a=[1,2,3,4,5]，合并第 2,3 堆石子，则石子堆集合变为 a=[1,5,4,5]。
我们希望通过尽可能少的操作，使得石子堆集合中的每堆石子的数量都相同。
请你输出所需的最少操作次数。
本题一定有解，因为可以将所有石子堆合并为一堆。
输入格式
第一行包含整数 T，表示共有 T 组测试数据。
每组数据第一行包含整数 N。
第二行包含 N 个整数 a1,a2,…,aN。
输出格式
每组数据输出一行结果。
数据范围
1≤T≤10,
1≤N≤105,
0≤ai≤106,
∑ai≤106,
每个输入所有 N 之和不超过 105。
自己的解法：
用堆排序的方法，对于每一组数据，建立初始小根堆，进行堆排序。每次排好一个元素后，进行对已排序序列检查，如果已经完成堆排序的序列的部分和（从前往后）可以大于等于目前的最大值，则合并这部分。（全是0的情况除外）合并后更新下次排序需要的参数，继续进行堆排序，合并。直至所有的数都一样或者合成一堆，算法停止，输出答案，进行下一组的堆排序。这需要每次合并后都检查是否每个数都一样。因为考虑到数据量的问题，用枚举是O(n2)的复杂度，会超时，用堆排序降到O(nlog2n)的复杂度。 我的推导过程：
但是考虑到如果每次排序后都进行检查，那么时间复杂度也会上升到O(n2)
自己的代码（没写完）：
#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; vector&lt;vector&lt;int&gt; &gt; v;	//v存放所有的数组 int max_vj = -0xffff; //每组数据的最大值 int res = 0; //小根堆的建立 void HeapAdjust(vector&lt;int&gt; &amp;A, int k, int len){ int t = A[k];	//暂存这个分支结点 for(int i = 2*k; i &lt;= len; i *= 2){	//从这个分支结点开始向下调整 if(i &lt; len &amp;&amp; A[i] &gt; A[i&#43;1]) i&#43;&#43;;	//右孩子更小 if(t &lt;= A[i]) break;	//分支结点已是子堆中的最小值，符合特性 else{	//不符合特性，需要调整 A[k] = A[i];	//换的时候只是覆盖 k = i;	//下标要交换，下次还说与A[0]比较 } } A[k] = t;	//放到最终符合特性的位置上 } void BuildMinHeap(vector&lt;int&gt; &amp;A, int len){ //从最后一个分支结点开始，逐级向上建堆 for(int i = len/2; i &gt; 0; i--) HeapAdjust(A, i, len); } //堆排序 void HeapSort(vector&lt;int&gt; &amp;A, int len){	for(int i = len; i &gt; 1; i--){	//n-1趟交换和建堆过程 swap(A[i], A[1]);	//堆顶元素和堆底元素互换 //交换后检查是否符合合并的条件 //如果已经完成堆排序的序列的部分和（从后往前）可以大于等于目前的最大值，则合并这部分 //合并后更新下一次需要的参数 if(){ A[len-1] = A[len]&#43;A[len-1];	//合并 if(A[len-1] &gt; max_vj) max_vj = A[len-1];	//更新最大值、长度、合并次数 A[0]--;	len--; res&#43;&#43;; } HeapAdjust(A, 1, i-1);	//将剩余的元素调整 } } int main(){ int T, N, an;	//T组测试数据，每组数据包含N个整数an cin &gt;&gt; T;	//测试数据的数量 vector&lt;int&gt; vj;	//每组数据存放的数组 //下面搞定输入 for(int i = 0; i &lt; T; i&#43;&#43;){ cin &gt;&gt; N;	//N个整数 vj." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d1ff8d8a4cf89f0f2e700b3ea69c769f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-14T21:24:09+08:00" />
<meta property="article:modified_time" content="2023-06-14T21:24:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【AcWing每日一题】4366. 上课睡觉</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>有 N 堆石子，每堆的石子数量分别为 a1,a2,…,aN。</p> 
<p>你可以对石子堆进行合并操作，将两个相邻的石子堆合并为一个石子堆，例如，如果 a=[1,2,3,4,5]，合并第 2,3 堆石子，则石子堆集合变为 a=[1,5,4,5]。</p> 
<p>我们希望通过尽可能少的操作，使得石子堆集合中的每堆石子的数量都相同。</p> 
<p>请你输出所需的最少操作次数。</p> 
<p>本题一定有解，因为可以将所有石子堆合并为一堆。</p> 
<p><strong>输入格式</strong><br> 第一行包含整数 T，表示共有 T 组测试数据。<br> 每组数据第一行包含整数 N。<br> 第二行包含 N 个整数 a1,a2,…,aN。</p> 
<p><strong>输出格式</strong><br> 每组数据输出一行结果。</p> 
<p><strong>数据范围</strong><br> 1≤T≤10,<br> 1≤N≤10<sup>5</sup>,<br> 0≤ai≤10<sup>6</sup>,<br> ∑a<sub>i</sub>≤10<sup>6</sup>,<br> 每个输入所有 N 之和不超过 10<sup>5</sup>。</p> 
<p><strong>自己的解法：</strong></p> 
<ul><li>用<strong>堆排序</strong>的方法，对于每一组数据，建立初始小根堆，进行堆排序。</li><li>每次排好一个元素后，进行对已排序序列检查，<strong>如果已经完成堆排序的序列的部分和（从前往后）可以大于等于目前的最大值，则合并这部分。（全是0的情况除外）</strong></li><li><strong>合并后更新</strong>下次排序需要的参数，继续进行堆排序，合并。</li><li><strong>直至所有的数都一样或者合成一堆</strong>，算法停止，输出答案，进行下一组的堆排序。</li><li>这需要每次合并后都检查是否每个数都一样。</li><li><strong>因为考虑到数据量的问题，用枚举是O(n<sup>2</sup>)的复杂度，会超时，用堆排序降到O(nlog<sub>2</sub>n)的复杂度。</strong></li></ul> 
<p>我的推导过程：<br> <img src="https://images2.imgbox.com/55/2a/x0k6gEEl_o.jpg" alt="在这里插入图片描述"></p> 
<p>但是考虑到如果每次排序后都进行检查，那么时间复杂度也会上升到O(n<sup>2</sup>)</p> 
<p>自己的代码（没写完）：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span> v<span class="token punctuation">;</span>	<span class="token comment">//v存放所有的数组 </span>
<span class="token keyword">int</span> max_vj <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">0xffff</span><span class="token punctuation">;</span> 	<span class="token comment">//每组数据的最大值 </span>
<span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token comment">//小根堆的建立</span>
<span class="token keyword">void</span> <span class="token function">HeapAdjust</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>A<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> t <span class="token operator">=</span> A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>							<span class="token comment">//暂存这个分支结点 </span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>k<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> i <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>		<span class="token comment">//从这个分支结点开始向下调整 </span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> A<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span>	<span class="token comment">//右孩子更小 </span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>t <span class="token operator">&lt;=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>				<span class="token comment">//分支结点已是子堆中的最小值，符合特性 </span>
		<span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>								<span class="token comment">//不符合特性，需要调整 </span>
			A<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>					<span class="token comment">//换的时候只是覆盖</span>
			k <span class="token operator">=</span> i<span class="token punctuation">;</span>							<span class="token comment">//下标要交换，下次还说与A[0]比较 </span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	A<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>								<span class="token comment">//放到最终符合特性的位置上 </span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">BuildMinHeap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>A<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token comment">//从最后一个分支结点开始，逐级向上建堆 </span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
		<span class="token function">HeapAdjust</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
<span class="token comment">//堆排序</span>
<span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>A<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>	 
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len<span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>	<span class="token comment">//n-1趟交换和建堆过程 </span>
		<span class="token function">swap</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//堆顶元素和堆底元素互换</span>
		<span class="token comment">//交换后检查是否符合合并的条件 </span>
		<span class="token comment">//如果已经完成堆排序的序列的部分和（从后往前）可以大于等于目前的最大值，则合并这部分</span>
		<span class="token comment">//合并后更新下一次需要的参数 </span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			A<span class="token punctuation">[</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token operator">+</span>A<span class="token punctuation">[</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>					<span class="token comment">//合并 </span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> max_vj<span class="token punctuation">)</span> max_vj <span class="token operator">=</span> A<span class="token punctuation">[</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">//更新最大值、长度、合并次数 </span>
			A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>	len<span class="token operator">--</span><span class="token punctuation">;</span> res<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">HeapAdjust</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//将剩余的元素调整 </span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> T<span class="token punctuation">,</span> N<span class="token punctuation">,</span> an<span class="token punctuation">;</span>		<span class="token comment">//T组测试数据，每组数据包含N个整数an </span>
	cin <span class="token operator">&gt;&gt;</span> T<span class="token punctuation">;</span>			<span class="token comment">//测试数据的数量 </span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vj<span class="token punctuation">;</span>		<span class="token comment">//每组数据存放的数组 </span>
	<span class="token comment">//下面搞定输入 </span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> T<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		cin <span class="token operator">&gt;&gt;</span> N<span class="token punctuation">;</span>		<span class="token comment">//N个整数 </span>
		vj<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//对数组先清空 </span>
		vj<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//每个数组的第一个位置存放这个数组的长度 </span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			cin <span class="token operator">&gt;&gt;</span> an<span class="token punctuation">;</span>	<span class="token comment">//输入a1~an </span>
			vj<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>an<span class="token punctuation">)</span><span class="token punctuation">;</span>			 
		<span class="token punctuation">}</span>
		v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>vj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将每组数据放入v </span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> T<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vj <span class="token operator">=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>vj<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> vj<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> vj<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>	<span class="token comment">//如果只有两个数且不相等 </span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			<span class="token keyword">continue</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>vj<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>				<span class="token comment">//如果只有一个数 </span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			<span class="token keyword">continue</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//找出每组数据的最大值</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> vj<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>vj<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> max_vj<span class="token punctuation">)</span> max_vj <span class="token operator">=</span> vj<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token comment">//对于每组数据建立初始的小根堆</span>
		<span class="token function">BuildMinHeap</span><span class="token punctuation">(</span>vj<span class="token punctuation">,</span> vj<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//建堆</span>
		<span class="token function">HeapSort</span><span class="token punctuation">(</span>vj<span class="token punctuation">,</span> vj<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">//堆排序的同时合并 </span>
		cout <span class="token operator">&lt;&lt;</span> res <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		max_vj <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">0xffff</span><span class="token punctuation">;</span>					<span class="token comment">//重置 </span>
		res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>		
		
		<span class="token comment">//测试堆排序结果 </span>
<span class="token comment">//		for(int i = 1; i &lt;= vj[0]; i++) cout &lt;&lt; vj[i] &lt;&lt; " ";</span>
<span class="token comment">//		cout &lt;&lt; endl;</span>
<span class="token comment">//		cout &lt;&lt; max_vj &lt;&lt; endl; 		</span>
	<span class="token punctuation">}</span> 	
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>y总的方法：</strong><br> 他的方法是用的数论的推导<br> 总的石子个数sum，最终每堆石子cnt个，<strong>cnt只有整除sum才可以</strong><br> <strong>cnt的数量等于sum的约数个数，平均每个数的约数个数是O(logn)个</strong></p> 
<blockquote> 
 <p>10<sup>6</sup>以内，约数个数最多的数是720720，有240个约数<br> int范围内，约数个数最多的数有1600个</p> 
</blockquote> 
<ul><li>知道了这个前提，我们就可以用<strong>枚举</strong>的方法，<strong>枚举所有的约数</strong>，<strong>找到可以取到的并整除sum的数</strong></li><li><strong>在所有的数里面找到合并次数最少的方案</strong></li><li>我们知道，最终合并后有sum/cnt堆石子，原来有n堆</li><li><strong>所以合并的次数为</strong> n-sum/cnt</li><li>我们只需要找到一个<strong>最小的符合条件的cnt</strong></li><li>所以我们只需要从小到大枚举cnt，看是否成立就可以了</li></ul> 
<p>一开始还有一个条件我没注意到，只能合并相邻的两堆，这样堆排序好像没法用了</p> 
<p><strong>那我们如何判断cnt是否成立？（能否将每一堆的数量变成cnt）</strong></p> 
<ul><li><strong>对于每个cnt</strong>，我们对原始序列从前向后枚举</li><li>如果当前堆的石子数量<strong>大于cnt，那一定无解</strong>，枚举下一个cnt</li><li>如果当前堆的石子数量<strong>等于cnt</strong>，如果后面的数量是0，可以加到前面或后面的一堆；如果不是0，那就合并到下一段</li><li>根据计算，大约240个约数，最多用10<sup>7</sup>次计算量，可以在规定的时间内完成</li></ul> 
<p>最后附一下代码：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> n<span class="token punctuation">;</span>
<span class="token keyword">int</span> w<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">//判断当前的约数是否符合条件</span>
<span class="token keyword">bool</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token keyword">int</span> cnt<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//从前向后枚举序列的每一段</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        s <span class="token operator">+=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>					<span class="token comment">//合并相邻的两段</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;</span> cnt<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>	<span class="token comment">//如果合并后的石子数量大于cnt，无解</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> cnt<span class="token punctuation">)</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>		<span class="token comment">//如果等于这个约数cnt，继续合并后面的段</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> T<span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>T <span class="token operator">--</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">//石子的堆数</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>					<span class="token comment">//石子的总数sum</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>	<span class="token comment">//输入每堆石子个数</span>
        <span class="token punctuation">{<!-- --></span>	
            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		
            sum <span class="token operator">+=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>				<span class="token comment">//计入到总数sum</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token punctuation">;</span> i<span class="token punctuation">;</span> i <span class="token operator">--</span> <span class="token punctuation">)</span>		<span class="token comment">//对于每堆石子，枚举寻找符合条件的cnt</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">check</span><span class="token punctuation">(</span>sum <span class="token operator">/</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//如果cnt能够整除sum，并且操作次数最小，且有解</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> n <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//输出答案</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>					
            <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//作者：yxc</span>
<span class="token comment">//链接：https://www.acwing.com/activity/content/code/content/5027948/</span>
<span class="token comment">//来源：AcWing</span>
<span class="token comment">//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span>
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b65442858add3288fe8fdad503ec3db5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Selenium UI自动化测试中元素定位不到的原因和解决方法汇总</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/df3c1dae24752b84b39dde960235202e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ubuntu环境下开启定时任务crontab</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>