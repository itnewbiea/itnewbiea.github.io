<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【动态规划】查找最长公共子序列 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【动态规划】查找最长公共子序列" />
<meta property="og:description" content="1.什么是最长公共子序列（lcs）
定义：一个数列S,如果分别是另个或多个已知数列的子序列，且是所有匹配此条件中最长的，则称S是已知数列的最长公共子序列；
需要注意的是：子序列不需要在原序列中占用连续的位置。
ege:
x序列：A B C B D A B
y序列：B D C A B A
他们的最长公共子序列为：B C A B,B D A B,B C B A
那么我们是如何查找出这个公共子序列？
（1）穷举法
一个一个找，容易理解，但是解法很麻烦，所占用的时间复杂度很大，为O(n*2^m)，一般不推荐。
（2）简化：a.查找最长公共子序列的长度
b.找子序列
如：
法1：（递归）
package 查找最长公共子序列; public class 递归 { public static int lcs(char[] a, char[] b, int i, int j) { if (i == 0 || j == 0) { return 0; } else if (a[i] == b[j]) { return lcs(a, b, i - 1, j - 1) &#43; 1; } else { return max(lcs(a, b, i - 1, j), lcs(a, b, i, j - 1)); } } private static int max(int x, int y) { if (x &gt; y) { return y; } else { return y; } } public static void main(String[] args) { String s1 = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f583d477a5d44237da537c6c3893e973/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-05-20T12:31:49+08:00" />
<meta property="article:modified_time" content="2019-05-20T12:31:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【动态规划】查找最长公共子序列</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>1.什么是最长公共子序列（lcs）<br> 定义：一个数列S,如果分别是另个或多个已知数列的子序列，且是所有匹配此条件中最长的，则称S是已知数列的最长公共子序列；<br> 需要注意的是：子序列不需要在原序列中占用连续的位置。<br> ege:<br> x序列：A B C B D A B<br> y序列：B D C A B A<br> 他们的最长公共子序列为：B C A B,B D A B,B C B A<br> 那么我们是如何查找出这个公共子序列？<br> （1）穷举法<br> 一个一个找，容易理解，但是解法很麻烦，所占用的时间复杂度很大，为O(n*2^m)，一般不推荐。<br> （2）简化：a.查找最长公共子序列的长度<br> b.找子序列<br> 如：<br> <img src="https://images2.imgbox.com/28/08/2aUb4iSx_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ba/c5/SYtvlEi2_o.png" alt="在这里插入图片描述"><br> 法1：（递归）</p> 
<pre><code>package 查找最长公共子序列;

public class 递归 {
	public static int lcs(char[] a, char[] b, int i, int j) {
		if (i == 0 || j == 0) {
			return 0;
		} else if (a[i] == b[j]) {
			return lcs(a, b, i - 1, j - 1) + 1;
		} else {
			return max(lcs(a, b, i - 1, j), lcs(a, b, i, j - 1));
		}
	}

	private static int max(int x, int y) {
		if (x &gt; y) {
			return y;
		} else {
			return y;
		}
	}

	public static void main(String[] args) {
		String s1 = "ABCBDAB";
		String s2 = "BDCABA";
		System.out.println(lcs(s1.toCharArray(), s2.toCharArray(), s1.length() - 1, s2.length() - 1));

	}

}

</code></pre> 
<p>这样执行的结果是3，显然不对，原因是在判断的时候第0个元素是空，但是实际上传的数组第0个元素是A，并不是空， 所以返回0有可能会少算，所以需要对两个子序列进行扩张，也就是想办法在两个子序列前面加上0<br> 解决方法：将两个子序列分别变成一个带0号字符的新字符数组。如：</p> 
<pre><code>package 查找最长公共子序列;

public class 递归 {
	public static int lcs(char[] a, char[] b, int i, int j) {
		if (i == 0 || j == 0) {
			return 0;
		} else if (a[i] == b[j]) {
			return lcs(a, b, i - 1, j - 1) + 1;
		} else {
			return max(lcs(a, b, i - 1, j), lcs(a, b, i, j - 1));
		}
	}
	private static int max(int x, int y) {
		if (x &gt; y) {
			return x;
		} else {
			return y;
		}
	}
	public static void main(String[] args) {
		String s1 = "ABCBDAB";
		char[] c1 = new char[s1.length() + 1];
		char[] t1 = s1.toCharArray();
		c1[0] = (char)0;
		for(int i = 0;i &lt; t1.length;i++) {
			c1[i + 1] = t1[i];
		}
		String s2 = "BDCABA";
		char[] c2 = new char[s2.length() + 1];
		char[] t2 = s2.toCharArray();
		c2[0] = (char)0;
		for(int i = 0;i &lt; t2.length;i++) {
			c2[i + 1] = t2[i];
		}
		System.out.println(lcs(c1, c2, c1.length - 1, c2.length - 1));
	}
}
</code></pre> 
<p>这样输出结果就为4.<br> 法2：（备忘录）</p> 
<pre><code>package 查找最长公共子序列;

public class 递归 {
	public static int lcs(char[] a, char[] b, int i, int j, int[][] bak) {
		//如果bak[i][j] != -1,说明不是初值，已经计算过了，直接返回备忘录里面的值 
		if (bak[i][j] != -1) {
			return bak[i][j];
		}
		/*
		 * 否则将数值存进备忘录里面
		 */
		if (i == 0 || j == 0) {
			bak[i][j] = 0;
		} else if (a[i] == b[j]) {
			bak[i][j] = lcs(a, b, i - 1, j - 1, bak) + 1;
		} else {
			bak[i][j] = max(lcs(a, b, i - 1, j, bak), lcs(a, b, i, j - 1, bak));
		}
		return bak[i][j];
	}

	private static int max(int x, int y) {
		if (x &gt; y) {
			return x;
		} else {
			return y;
		}
	}

	public static void main(String[] args) {
		String s1 = "ABCBDAB";
		char[] c1 = new char[s1.length() + 1];
		char[] t1 = s1.toCharArray();
		c1[0] = (char) 0;
		for (int i = 0; i &lt; t1.length; i++) {
			c1[i + 1] = t1[i];
		}
		String s2 = "BDCABA";
		char[] c2 = new char[s2.length() + 1];
		char[] t2 = s2.toCharArray();
		c2[0] = (char) 0;
		for (int i = 0; i &lt; t2.length; i++) {
			c2[i + 1] = t2[i];
		}
		int[][] bak = new int[c1.length][c2.length];
		//将备忘录里面的值初始化为 -1；
		for (int i = 0; i &lt; c1.length; i++) {
			for (int j = 0; j &lt; c2.length; j++) {
				bak[i][j] = -1;
			}
		}
		System.out.println(lcs(c1, c2, c1.length - 1, c2.length - 1, bak));
	}
}

</code></pre> 
<p>法3：（自底向上）<br> <img src="https://images2.imgbox.com/cb/83/e7SBYq4p_o.png" alt="在这里插入图片描述"></p> 
<pre><code>package 查找最长公共子序列;

import java.util.Scanner;

public class 自底向上 {
	public static int lcs(char[] a, char[] b, int i, int j, int[][] bak) {
		/*
		 * i和j 都是索引
		 */
		for (int ii = 0; ii &lt;= i; ii++) {
			for (int jj = 0; jj &lt;= j; jj++) {
				if (ii == 0 || jj == 0) {
					bak[ii][jj] = 0;
				} else if (a[ii] == b[jj]) {
					bak[ii][jj] = bak[ii - 1][jj - 1] + 1;// 前面已经计算过了
				} else {
					bak[ii][jj] = max(bak[ii - 1][jj], bak[ii][jj - 1]);
				}
			}
		}
		return bak[i][j];// 返回最大值的位置
	}

	private static int max(int x, int y) {
		if (x &gt; y) {
			return x;
		} else {
			return y;
		}
	}

	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		String s1 = s.nextLine();
		char[] c1 = new char[s1.length() + 1];
		char[] t1 = s1.toCharArray();
		c1[0] = (char) 0;
		for (int i = 0; i &lt; t1.length; i++) {
			c1[i + 1] = t1[i];
		}
		String s2 = s.nextLine();
		char[] c2 = new char[s2.length() + 1];
		char[] t2 = s2.toCharArray();
		c2[0] = (char) 0;
		for (int i = 0; i &lt; t2.length; i++) {
			c2[i + 1] = t2[i];
		}
		int[][] bak = new int[c1.length][c2.length];
		System.out.println(lcs(c1, c2, c1.length - 1, c2.length - 1, bak));
	}

}

</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8f5e542e244e5d98ca01331374faea90/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">利用git执行gradle项目（图解）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8b00bd7ca2df3281702a1669b674364c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用Hive处理敏感字段</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>