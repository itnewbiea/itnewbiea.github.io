<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java多线程【三种实现方法】 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java多线程【三种实现方法】" />
<meta property="og:description" content="java多线程 并发与并行 小伙伴们有兴趣想了解内容和更多相关学习资料的请点赞收藏&#43;评论转发&#43;关注我，后面会有很多干货。我有一些面试题、架构、设计类资料可以说是程序员面试必备！
所有资料都整理到网盘了，需要的话欢迎下载！私信我回复【111】即可免费获取
并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行
并行：一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的。
对比：并发是指:在同一个时间段内，两个或多个程序执行，有时间上的重叠(宏观上是同时,微观上仍是顺序执行)
进程与线程 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础
线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。
java的线程 java多线程机制
多线程是指一个应用程序同时存在几个执行体，按照几条不同的执行线索共同工作的情况。java多线程机制，它使得编程人员可以很方便的开发出具有多线程功能、能同时处理多个任务的强大应用程序。java内置对多线程的支持，java虚拟机可以快速的从一个线程切换到另一个线程。这些线程的轮流执行使得每个线程都有机会使用cpu资源。
java的主线程
每个java程序都含有一个线程，那就是主线程（main线程）。Java应用程序都是从主类main方法执行的，当jvm加载代码，发现卖弄方法之后，就会启动一个线程，这个线程就是主线程，负责执行main方法。如果在主线程里面创建其他线程，就会在主线程和其他线程来回切换，直到其他所有线程结束才会结束主线程。
线程的生命周期
运行
线程创建之后只占有了内存资源，在JVM管理的线程中并没有刚刚创建的这个线程，只有这个线程调用start（）方法后，JVM才知道有一个新线程进入队列等待cpu调用。
中断原因（4种）
jVM把cpu资源切换给其他线程。线程使用cpu期间，执行了sleep(int millsecond)方法，使当前线程进入休眠状态，调用该方法之后会立即让出cpu，经过参数millsecond指定的毫秒后，重新加入队列等待cpu。
-使用cpu期间，执行了wait()方法，使得当前进程进入等待状态，这个等待个sleep()不同，这个等待需要其他线程调用notify()方法唤醒该线程，此线程才会重新进入队列，等待cpu。
线程使用cpu期间，执行了某个操作进入阻塞状态，例如（读、写、打印等），只有这些造成阻塞的原因完成，这个线程才会进入队列，等待cpu。 创建线程（3种） 继承Thread类实现线程创建
一种是创建一个类继承Thread类，这种继承可以重复使用！一种是直接使用匿名内部类继承，这种类型只能使用一次，每次使用都要重新创建不论哪种都需要重写run()方法，并且在定义之后调用start()方法，把这个线程调入线程队列等待调用。 下面我们使用匿名内部类创建一个打印100以内的奇数线程，使用类继承Thread类打印100内的偶数线程。
package hello; public class Hello { public static void main(String[] args) { Thread1 thread1 = new Thread1(); Thread thread = new Thread() { @Override public void run() { for (int i = 0; i &lt; 100; i&#43;&#43;) { if (i % 2 == 1) { //打印线程名，线程名是从0开始的 System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a389edc2a261d2d640a9587c01523421/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-06T19:38:14+08:00" />
<meta property="article:modified_time" content="2022-06-06T19:38:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java多线程【三种实现方法】</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="java多线程">java多线程</h3> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6f/dd/W1oFCdV6_o.png"></p> 
<h4 id="并发与并行">并发与并行</h4> 
<p>小伙伴们有兴趣想了解内容和更多相关学习资料的请点赞收藏+评论转发+关注我，后面会有很多干货。我有一些面试题、架构、设计类资料可以说是程序员面试必备！<br> 所有资料都整理到网盘了，需要的话欢迎下载！私信我回复【111】即可免费获取</p> 
<p><strong>并发</strong>：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行<br><strong>并行</strong>：一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的。<br> 对比：并发是指:在同一个时间段内，两个或多个程序执行，有时间上的重叠(宏观上是同时,微观上仍是顺序执行)</p> 
<h4 id="进程与线程">进程与线程</h4> 
<p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础</p> 
<p>线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c5/8c/N9cA6EY5_o.png"></p> 
<h4 id="java的线程">java的线程</h4> 
<p>java多线程机制</p> 
<p>多线程是指一个应用程序同时存在几个执行体，按照几条不同的执行线索共同工作的情况。java多线程机制，它使得编程人员可以很方便的开发出具有多线程功能、能同时处理多个任务的强大应用程序。java内置对多线程的支持，java虚拟机可以快速的从一个线程切换到另一个线程。这些线程的轮流执行使得每个线程都有机会使用cpu资源。</p> 
<p>java的主线程</p> 
<p>每个java程序都含有一个线程，那就是主线程（main线程）。Java应用程序都是从主类main方法执行的，当jvm加载代码，发现卖弄方法之后，就会启动一个线程，这个线程就是主线程，负责执行main方法。如果在主线程里面创建其他线程，就会在主线程和其他线程来回切换，直到其他所有线程结束才会结束主线程。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/df/e1/tiIh2MBW_o.png"></p> 
<p>线程的生命周期</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e9/03/tJAWivyg_o.png"></p> 
<ul><li> <p>运行<br> 线程创建之后只占有了内存资源，在JVM管理的线程中并没有刚刚创建的这个线程，只有这个线程调用start（）方法后，JVM才知道有一个新线程进入队列等待cpu调用。</p> </li><li> <p>中断原因（4种）</p> 
  <ul><li>jVM把cpu资源切换给其他线程。</li><li>线程使用cpu期间，执行了sleep(int millsecond)方法，使当前线程进入休眠状态，调用该方法之后会立即让出cpu，经过参数millsecond指定的毫秒后，重新加入队列等待cpu。<br> -使用cpu期间，执行了wait()方法，使得当前进程进入等待状态，这个等待个sleep()不同，这个等待需要其他线程调用notify()方法唤醒该线程，此线程才会重新进入队列，等待cpu。<br> 线程使用cpu期间，执行了某个操作进入阻塞状态，例如（读、写、打印等），只有这些造成阻塞的原因完成，这个线程才会进入队列，等待cpu。</li></ul></li></ul> 
<h4 id="创建线程3种">创建线程（3种）</h4> 
<p>继承Thread类实现线程创建</p> 
<ul><li>一种是创建一个类继承Thread类，这种继承可以重复使用！</li><li>一种是直接使用匿名内部类继承，这种类型只能使用一次，每次使用都要重新创建</li><li>不论哪种都需要重写run()方法，并且在定义之后调用start()方法，把这个线程调入线程队列等待调用。</li></ul> 
<p>下面我们使用匿名内部类创建一个打印100以内的奇数线程，使用类继承Thread类打印100内的偶数线程。</p> 
<pre><code class="language-java">package hello;

public class Hello {
    public static void main(String[] args) {
        Thread1 thread1 = new Thread1();
        Thread thread = new Thread() {
            @Override
            public void run() {
                for (int i = 0; i &lt; 100; i++) {
                    if (i % 2 == 1) {
                    //打印线程名，线程名是从0开始的
                        System.out.println(Thread.currentThread().getName() + ":" + i);
                    }
                }
            }
        };

        thread1.start();
        thread.start();


    }
}

class Thread1 extends Thread{
    @Override
    public void run() {
        super.run();
        for(int i=0;i&lt;100;i++){
            if (i%2==0){
                System.out.println(Thread.currentThread().getName()+":"+i);
            }
        }
    }
}
</code></pre> 
<p></p> 
<p>方法说明<br> start()启动当前线程；调用当前线程的run()方法<br> run()：需要重写Thread类中的此方法，将创建线程需要执行的操作声明在此方法中<br> currentThread()：返回执行当前代码的线程<br> getName()：获取当前线程的名字<br> setName(String name)：设置当前线程的名字<br> yield()：释放当前CPU的执行权<br> join()：在线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到线程b完全执行完之后，线程a在结束阻塞状态<br> sleep(int millitime)：让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前进程是阻塞状态<br> isAlive()：判断当前线程是否存活（线程执行完之前都是存活的）</p> 
<p>实现Runnable接口</p> 
<ul><li>我们还是创建两个线程，一个打印奇数，一个打印偶数，但是有一个线程每次调用会睡眠（阻塞）10ms。</li><li>使用实现接口Runnable方法，必须重写run()方法。</li></ul> 
<pre><code class="language-java">package hello;

public class Hello {
    public static void main(String[] args) {
        Thread thread = new Thread(new MyThread1());
        /*
        Thread thread = new Thread(new MyThread1());
        就相当于 ,就是创建实现类的对象，再把这个对象用Thread()构造器的方法创建
        MyThread1 myThread1 = new MyThread1();
        Thread thread = new Thread(myThread1);
         */
        Thread thread1 = new Thread(new MyThread2());
        thread.start();
        thread1.start();

    }
}


class MyThread1 implements Runnable{
    @Override
    public void run() {
        for(int i=0;i&lt;100;i++) {
            if (i % 2 == 1) {
                System.out.println(Thread.currentThread().getName() + ":" + i);
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
        }
    }
}

class MyThread2 implements Runnable{
    @Override
    public void run() {
        for(int i=0;i&lt;100;i++) {
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName() + ":" + i);

            }
        }
    }
}

</code></pre> 
<p></p> 
<p>开发中，优先选择实现Runnable接口的方式创建线程</p> 
<p>原因：</p> 
<p>实现Runnable接口的方式没有类的单继承性的局限性（一个类只能继承一个父类，继承了Thread类就不能在继承其他类了）<br> 实现Runnable接口的方式更适合来处理多个线程之间有共享数据的情况</p> 
<p>实现Callable接口</p> 
<p>Runnable接口是没有返回值的 Callable有返回值，可以抛出异常<br> Thread类并不接受Callable对象。可以使用FutureTask类实现Runnable接口和Future接口<br> Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p> 
<p>Java的类是单继承的设计，如果采用继承Thread的方式实现多线程，则不能继承其他的类，采用接口能够更好的实现数据共享</p> 
<p>FutureTask有两个构造函数，一个以Callable为参数，另外一个以Runnable为参数。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b4/7e/sAhBfUkX_o.png"></p> 
<p>我理解的就是通过FutureTask把Callable变成通过Runnable接口创建的，因为FutureTask继承了Runnable接口。主要原因是Thread类不接受Callable创建，但是接受Runnable创建的线程。</p> 
<pre><code class="language-java">package hello;

import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

public class Hello {
    public static void main(String[] args) throws Exception {

        MyThread1 myThread1 = new MyThread1();
        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new MyThread1());
        new Thread(futureTask).start();//开启线程
        System.out.println(futureTask.get());//获取返回值

    }
}


class  MyThread1 implements Callable&lt;Integer&gt; {

    @Override
    public Integer call() throws Exception {
        int count = 0;
        for (int i = 1;i&lt;100;i++){
            if (i%3==0){
                count++;
            }
        }
        return count;
    }
}

</code></pre> 
<p></p> 
<p>线程池</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d7/41/0Xk8BITG_o.png"></p> 
<p>线程池的执行过程</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/15/a9/bbqYife2_o.png"></p> 
<ul><li>实例</li></ul> 
<pre><code class="language-java">package hello;


import java.util.concurrent.*;

public class Hello {
    public static void main(String[] args) throws Exception {

        //创建线程池
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 4, 5, TimeUnit.MILLISECONDS,
                new ArrayBlockingQueue&lt;&gt;(2),
                new ThreadFactory() {
                    @Override
                    public Thread newThread(Runnable r) {
                        Thread thread = new Thread(r);
                        thread.setName("myThread");
                        return thread;
                    }
                },
                new ThreadPoolExecutor.AbortPolicy());

        //threadPoolExecutor.submit();
        threadPoolExecutor.execute(new MyThread());//提交任务
        threadPoolExecutor.shutdown();//关闭线程池


    }
}

class MyThread implements Runnable{

    @Override
    public void run() {
        for (int i=0;i&lt;10;i++){
            System.out.println(i);
        }
    }
}

</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d6e776898092632815f8c7f384890222/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">TX2超详细，超有用的刷机教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/53fd4c6a6ecba2faf4a25de82d9fb119/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CTFshow之web171~180---SQL注入（1）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>