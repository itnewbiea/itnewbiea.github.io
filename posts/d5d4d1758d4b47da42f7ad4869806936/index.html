<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>go-zero微服务框架入门教程 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="go-zero微服务框架入门教程" />
<meta property="og:description" content="为什么使用go-zero 你还在手撕微服务？快试试 go-zero 的微服务自动生成神器，这可能是我见过最简单好用的微服务框架。
还有比它更简单好用的吗？欢迎留言评论和推荐。
几分钟搞定个接口和微服务，还不用担心稳定性和高并发，这不香吗？还有比这更简单和高效的吗？
工具大于约定和文档的理念，编码自动化，大幅度的提高效率和生产力，这会是个趋势，让精力更多的放在业务和创新上。
推荐下go-zero 微服务框架，致力于打造国内最简单好用的框架。
为什么使用go-zero？
可以有第三个选择 golang圈子不大,微服务框架框架屈指可数:除了go-micro、go-kit,几乎没有其他选择。go-zero为此提供第三个可能。
go-micro 对webapi支持并不友好，需要运行micro指令,难以定制
需要一款支持业务成长的框架 我们到底需要什么样的框架?
我们需要一款可以支持业务成长的框架!产品运营初期,比如需求验证阶段，我们并不需要采取微服务架构，因为运营成本太高，一款单体应用足以应付。随着业务发展,微服务成为必要,此时我们又希望不进行太多的代码编写工作，柔性升级。这正是go-zero价值所在。
go-zero是什么 以下安利是copy的的，具体参考https://github.com/tal-tech/go-zero
go-zero是一个集成了各种工程实践的包含web和rpc框架，有如下主要特点：
强大的工具支持，尽可能少的代码编写
极简的接口
完全兼容net/http
支持中间件，方便扩展
高性能
面向故障编程，弹性设计
内建服务发现、负载均衡
内建限流、熔断、降载，且自动触发，自动恢复
API参数自动校验
超时级联控制
自动缓存控制
链路跟踪、统计报警等
高并发支撑，稳定保障了晓黑板疫情期间每天的流量洪峰
怎么用 在阅读本文档前,请将golang 升级到go14及以上版本,并开启go module支持,GO14以上只是为了支持Gorm
export GOPROXY=https://goproxy.io,direct export GO111MODULE=on 安装goctl goctl是go-zero配套的代码生成器,偷懒神器,毕竟写代码大多时间是体力活
如何安装呢?先把源代码下载下来吧!
git clone https://github.com/tal-tech/go-zero cd go-zero/tools/goctl go build goctl.go 最后生成goctl.exe 复制到$gopath/bin下
goctl指令说明 自行浏览文档吧https://github.com/tal-tech/go-zero/blob/master/tools/goctl/goctl.md
本文用到指令如下
goctl api go -api open.api -dir . #代码说明如下 goctl api go -api open." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d5d4d1758d4b47da42f7ad4869806936/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-02T18:36:33+08:00" />
<meta property="article:modified_time" content="2020-09-02T18:36:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">go-zero微服务框架入门教程</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>为什么使用go-zero</h2> 
<p>你还在手撕微服务？快试试 go-zero 的微服务自动生成神器，这可能是我见过最简单好用的微服务框架。</p> 
<p>还有比它更简单好用的吗？欢迎留言评论和推荐。</p> 
<p>几分钟搞定个接口和微服务，还不用担心稳定性和高并发，这不香吗？还有比这更简单和高效的吗？</p> 
<p><strong>工具大于约定和文档的理念</strong>，<strong>编码自动化</strong>，大幅度的<strong>提高效率和生产力</strong>，这会是个趋势，<strong>让精力更多的放在业务和创新上</strong>。<br><br> 推荐下go-zero 微服务框架，致力于打造国内最简单好用的框架。</p> 
<p>为什么使用go-zero？</p> 
<h3>可以有第三个选择</h3> 
<ul><li> <p>golang圈子不大,微服务框架框架屈指可数:除了go-micro、go-kit,几乎没有其他选择。go-zero为此提供第三个可能。</p> </li><li> <p>go-micro 对webapi支持并不友好，需要运行micro指令,难以定制</p> </li></ul> 
<h3>需要一款支持业务成长的框架</h3> 
<p>我们到底需要什么样的框架?</p> 
<p>我们需要一款可以支持业务成长的框架!产品运营初期,比如需求验证阶段，我们并不需要采取微服务架构，因为运营成本太高，一款单体应用足以应付。随着业务发展,微服务成为必要,此时我们又希望不进行太多的代码编写工作，柔性升级。这正是go-zero价值所在。</p> 
<h3>go-zero是什么</h3> 
<p>以下安利是copy的的，具体参考<code>https://github.com/tal-tech/go-zero</code><br> go-zero是一个集成了各种工程实践的包含web和rpc框架，有如下主要特点：</p> 
<ul><li> <p>强大的工具支持，尽可能少的代码编写</p> </li><li> <p>极简的接口</p> </li><li> <p>完全兼容net/http</p> </li><li> <p>支持中间件，方便扩展</p> </li><li> <p>高性能</p> </li><li> <p>面向故障编程，弹性设计</p> </li><li> <p>内建服务发现、负载均衡</p> </li><li> <p>内建限流、熔断、降载，且自动触发，自动恢复</p> </li><li> <p>API参数自动校验</p> </li><li> <p>超时级联控制</p> </li><li> <p>自动缓存控制</p> </li><li> <p>链路跟踪、统计报警等</p> </li><li> <p>高并发支撑，稳定保障了晓黑板疫情期间每天的流量洪峰</p> </li></ul> 
<h2>怎么用</h2> 
<p>在阅读本文档前,请将golang 升级到<code>go14</code>及以上版本,并开启go module支持,GO14以上只是为了支持Gorm</p> 
<pre><code class="language-html hljs">export GOPROXY=https://goproxy.io,direct
export GO111MODULE=on
</code></pre> 
<h3>安装goctl</h3> 
<p>goctl是go-zero配套的代码生成器,偷懒神器,毕竟<code>写代码大多时间是体力活</code><br> 如何安装呢?先把源代码下载下来吧!</p> 
<pre><code class="language-html hljs">git clone https://github.com/tal-tech/go-zero
cd go-zero/tools/goctl
go build goctl.go
</code></pre> 
<p>最后生成goctl.exe 复制到<code>$gopath/bin</code>下</p> 
<h3>goctl指令说明</h3> 
<p>自行浏览文档吧<code>https://github.com/tal-tech/go-zero/blob/master/tools/goctl/goctl.md</code></p> 
<p>本文用到指令如下</p> 
<pre><code class="language-html hljs">goctl api    go    -api       open.api   -dir    .
</code></pre> 
<pre><code class="language-html hljs">#代码说明如下
goctl  api      go       -api             open.api            -dir                     .
 |      |        |         |                 |                  |                      | 
      生成api  go语言     指定api模板文件   模板文件名称         指定生成代码存放路径     当前文件夹
</code></pre> 
<h2>创建项目</h2> 
<h3>生成go.mod文件</h3> 
<p>输入如下指令,创建项目</p> 
<pre><code class="language-html hljs">mkdir hello
cd hello
go mod init  hello
</code></pre> 
<h3>定义hello.api</h3> 
<p>本文设计API如下</p> 
<table><thead><tr><th>描述</th><th>格式</th><th>方法</th><th>参数</th><th>返回</th></tr></thead><tbody><tr><td>用户注册</td><td>/open/register</td><td>post</td><td>mobile:手机号,passwd:密码,code:图片验证码</td><td>id:用户ID,token:用户token</td></tr><tr><td>用户登录</td><td>/open/authorization</td><td>post</td><td>mobile:手机号,passwd:密码,code:图片验证码</td><td>id:用户ID,token:用户token</td></tr><tr><td>图片验证码请求</td><td>/open/verify</td><td>get</td><td>ticket:图片验证码的id</td><td>data:base64格式的图片</td></tr></tbody></table> 
<p>根据以上描述,书写api的模板文件如下</p> 
<pre><code>type (
	UserOptReq struct {
		mobile string `json:"mobile"`
		passwd string `json:"passwd"`
		code   string `json:"code"`
	}

	UserOptResp struct {
		id    uint   `json:"id"`
		token string `json:"token"`
	}
	//图片验证码支持
	VerifyReq struct {
		ticket string `json:"ticket"`
	}
	//图片验证码支持
	VerifyResp struct {
		data string `json:"data"`
	}
)

service open-api {
	@doc(
        summary: 公开的api函数
        desc: &gt;
        register 用户注册,
        authorization 用户登录,
        verify 图片验证码接口
    )
	@server(
		handler: registerHandler
		folder: open
	)
	post /open/register(UserOptReq) returns(UserOptResp)
	
	
	@server(
		handler: authorizationHandler
		folder: open
	)
	post /open/authorization(UserOptReq) returns(UserOptResp)

	@server(
		handler: verifyHandler
		folder: open
	)
	post /open/verify(VerifyReq) returns(VerifyResp)
	
}

</code></pre> 
<p>注意</p> 
<ul><li> <p>一个文件里面只能有一个service</p> </li><li> <p>工具最后会以type里面模型为样板生成各种结构体,所以参数和结构体保持一致即可</p> </li><li> <p>如果我们需要分文件夹管理业务, 可以用folder属性来定义</p> </li></ul> 
<h3>生成代码</h3> 
<p>采用如下指令生成代码</p> 
<pre><code class="language-html hljs">goctl api  go   -api   open.api   -dir  .
</code></pre> 
<p>最后代码结构如下</p> 
<pre><code class="language-html hljs">#tree /F /A
|   go.mod
|   go.sum
|   hello.api
|   open.go
|
+---etc
|       open-api.yaml
|
\---internal
    +---config
    |       config.go
    |
    +---handler
    |   |   routes.go
    |   |
    |   \---open
    |           authorizationhandler.go
    |           registerhandler.go
    |           verifyhandler.go
    |
    +---logic
    |   \---open
    |           authorizationlogic.go
    |           registerlogic.go
    |           verifylogic.go
    |
    +---svc
    |       servicecontext.go
    |
    \---types
            types.go
</code></pre> 
<p>运行一下</p> 
<pre><code class="language-html hljs">go run open.go
</code></pre> 
<p>测试一下</p> 
<pre><code class="language-html hljs">curl http://127.0.0.1:8888/open/register -X POST -H "Content-Type: application/json" -d {\"mobile\":\"15367151352\",\"passwd\":\"testpwd\",\"code\":\"asdf\"}
{"id":0,"token":""}
</code></pre> 
<h2>集成明星产品Gorm V2</h2> 
<p>金珠大佬升级了Gorm V2,集成测试一下吧</p> 
<h3>配置文件</h3> 
<p>配置文件在<code>etc/open-api.yaml</code></p> 
<pre><code>Name: open-api
Host: 0.0.0.0
Port: 8888
DataSourceName: root:1D007648b4f8@(127.0.0.1:3306)/gozero?charset=utf8
</code></pre> 
<p>在<code>etc/open-api.yaml</code>中添加参数DataSourceName,<br> 在<code>internal/config/config.go</code>中添加DataSourceName</p> 
<pre><code>type Config struct {
	rest.RestConf
	DataSourceName string
}

</code></pre> 
<p>关于配置文件,系统内置了一部分关键字 如Cache,资料不多;</p> 
<p>基本上可以随便配置,然后在Conf中定义同名变量即可。</p> 
<h3>启动Gorm支持</h3> 
<p>修改<code>svc/servicecontext.go</code>代码如下</p> 
<pre><code>package svc

import (
	"hello/internal/config"
	"hello/internal/models"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/schema"
)

type ServiceContext struct {
	Config  config.Config
	DbEngin *gorm.DB
}

func NewServiceContext(c config.Config) *ServiceContext {
    //启动Gorm支持
	db, err := gorm.Open(mysql.Open(c.DataSourceName), &amp;gorm.Config{
		NamingStrategy: schema.NamingStrategy{
			TablePrefix:   "tech_", // 表名前缀，`User` 的表名应该是 `t_users`
			SingularTable: true,    // 使用单数表名，启用该选项，此时，`User` 的表名应该是 `t_user`
		},
    })
    //如果出错就GameOver了
	if err != nil {
		panic(err)
    }
    //自动同步更新表结构,不要建表了O(∩_∩)O哈哈~
	db.AutoMigrate(&amp;models.User{})

	return &amp;ServiceContext{Config: c, DbEngin: db}
}

</code></pre> 
<p> </p> 
<h3>新建模型文件</h3> 
<p>新建<code>models\models.go</code>文件</p> 
<pre><code>//models\models.go文件
package models

import (
	"errors"
	"hello/internal/utils"

	"gorm.io/gorm"
)

type User struct {
	gorm.Model
	Mobile string `gorm:"index:mobile;type:varchar(13)"`
	Passwd string `gorm:"type:varchar(64)"`
}
//在创建前检验验证一下密码的有效性
func (u *User) BeforeCreate(db *gorm.DB) error {
	if len(u.Passwd) &lt; 6 {
		return errors.New("密码太简单了")
    }
    //对密码进行加密存储
	u.Passwd = utils.Password(u.Passwd)
	return nil
}
</code></pre> 
<p>utils.Password是我们编写的工具包,代码如下</p> 
<p> </p> 
<pre><code>package utils

import (
	"fmt"

	"golang.org/x/crypto/bcrypt"
)

//密码加密
func Password(plainpwd string) string {
    //谷歌的加密包
	hash, err := bcrypt.GenerateFromPassword([]byte(plainpwd), bcrypt.DefaultCost) //加密处理
	if err != nil {
		fmt.Println(err)
	}
	encodePWD := string(hash) // 保存在数据库的密码，虽然每次生成都不同，只需保存一份即可
	return encodePWD
}
//密码校验
func CheckPassword(plainpwd, cryptedpwd string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(cryptedpwd), []byte(plainpwd)) //验证（对比）
	return err == nil
}

</code></pre> 
<p> </p> 
<h3>实现业务逻辑</h3> 
<p>在<code>logic\open\registerlogic.go</code>中修改代码如下</p> 
<pre><code>package logic

import (
	"context"

	"hello/internal/models"
	"hello/internal/svc"
	"hello/internal/types"

	"github.com/tal-tech/go-zero/core/logx"
)

type RegisterLogic struct {
	ctx context.Context
	logx.Logger
	svcCtx *svc.ServiceContext
}

func NewRegisterLogic(ctx context.Context, svcCtx *svc.ServiceContext) RegisterLogic {
	return RegisterLogic{
		ctx:    ctx,
		Logger: logx.WithContext(ctx),
		svcCtx: svcCtx,
	}
}

func (l *RegisterLogic) Register(req types.UserOptReq) (*types.UserOptResp, error) {
	user := models.User{
		Mobile: req.Mobile,
		Passwd: req.Passwd,
	}
	result := l.svcCtx.DbEngin.Create(&amp;user)
	return &amp;types.UserOptResp{
		Id: user.ID,
	}, result.Error
}

</code></pre> 
<ul><li> <p>RegisterLogic中添加svcCtx *svc.ServiceContext,因为需要用到里面的DbEngin</p> </li><li> <p>NewRegisterLogic 配置svcCtx</p> </li><li> <p>在Register函数中实现逻辑<code>result := l.svcCtx.DbEngin.Create(&amp;user)</code></p> </li></ul> 
<h3>测试一下</h3> 
<pre><code class="language-html hljs">&gt;curl http://127.0.0.1:8888/open/register -X POST -H "Content-Type: application/json" -d {\"mobile\":\"15367151352\",\"passwd\":\"testpwd\"}
{"id":3,"token":""}

</code></pre> 
<h2>期待更新的功能点</h2> 
<h3>go-zero</h3> 
<h4>接口定义希望支持多种content-type</h4> 
<pre><code class="language-html hljs">UserOptReq struct {
	mobile string `json:"mobile" form:"mobile" xml:"mobile"`
	passwd string `json:"passwd" form:"passwd" xml:"passwd"`
	code   string `json:"code" form:"code" xml:"code"`
}
</code></pre> 
<p>一种可能的解决方法是<br> 修改<code>github.com/tal-tech/go-zero/rest/httpx/requests.go</code>中的<code>Parse</code>成如下模型</p> 
<pre><code>func Parse(r *http.Request, v interface{}) error {
	if err := ParsePath(r, v); err != nil {
		return err
	}
	if strings.Contains(r.Header.Get(ContentType), multipartFormData) {
		return ParseForm(r, v)
	} else if strings.Contains(r.Header.Get(ContentType), urlencodeformdata) {
		return ParseForm(r, v)
	} else if strings.Contains(r.Header.Get(ContentType), applicationjson) {
		return ParseJsonBody(r, v)
	} else {
		return errors.New("不支持的请求类型")
	}
}
</code></pre> 
<p> </p> 
<h4>支持一个文件多个方法</h4> 
<p>比如如下写法,则生成俩个方法在verifyHandler.go文件中</p> 
<pre><code>	@server(
		handler: verifyHandler
		folder: open
	)
	post /open/verify(VerifyReq) returns(VerifyResp)
    post /open/authorization(UserOptReq) returns(UserOptResp)
</code></pre> 
<p><strong>支持类似Swagger的文档和Api接口自动生成和自动化测试</strong></p> 
<h3>gorm v2</h3> 
<h4>建议默认<code>SingularTable</code>属性为<code>true</code></h4> 
<pre><code>NamingStrategy: schema.NamingStrategy{
			TablePrefix:   "tech_", // 表名前缀，`User` 的表名应该是 `t_users`
			SingularTable: true,    // 使用单数表名，启用该选项，此时，`User` 的表名应该是 `t_user`
		},
</code></pre> 
<p> </p> 
<h4>建议增强缓存功能</h4> 
<p>建议提供缓存如redis/memcache/内存缓存支持</p> 
<h2>本文代码获取</h2> 
<p>关注公众号<code>betaidea</code> 输入gozero或者gormv2即可获得</p> 
<p><img alt="" height="203" src="https://images2.imgbox.com/6a/1d/KdWxsMOG_o.png" width="209"></p> 
<p><img alt="" height="236" src="https://images2.imgbox.com/32/3a/LTSvTThU_o.png" width="239"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/110f830bbcd36903acbb8b64be5df8c7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C中printf函数的实现原理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6dc919e46aae1c4fe584b992f4b0e1dd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HPACK和twitter hpack源码解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>