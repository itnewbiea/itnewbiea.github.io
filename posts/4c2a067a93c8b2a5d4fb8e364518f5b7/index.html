<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RDD是什么 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RDD是什么" />
<meta property="og:description" content="RDD是Spark的基础，是对大数据的抽象，所以先破解Spark，首先从RDD开始。
* RDD 是什么？有什么特点？
* RDD 包含什么？
* RDD 能做什么？
文尾有结论
RDD 的注释
org.apache.spark.rdd.RDD 类源代码中有详细的注释：
A Resilient Distributed Dataset (RDD), the basic abstraction in Spark.
翻译：弹性的 分布式 数据集是 Spark 基础的抽象。
解释：弹性的（可复原的），说明数据集具有容错性、可修复性。 分布式，说明数据集可以分布在不同的机器上
Represents an immutable, partitioned collection of elements that can be operated on in parallel.
翻译：RDD 是不可变的 分区的 可并行处理的 元素集合
解释：不可变的，这和 Scala 的设计理念相同，数据集一旦构建完成，就不能再修改，这样能轻松解决多个线程读数据的一致性问题。 分区的=可并行处理的=分布式
This class contains the basic operations available on all RDDs, such as map, filter, and persist." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4c2a067a93c8b2a5d4fb8e364518f5b7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-13T15:42:40+08:00" />
<meta property="article:modified_time" content="2023-12-13T15:42:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RDD是什么</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>RDD是Spark的基础，是对大数据的抽象，所以先破解Spark，首先从RDD开始。<br> * RDD 是什么？有什么特点？<br> * RDD 包含什么？<br> * RDD 能做什么？<br> 文尾有结论</p> 
</blockquote> 
<p>RDD 的注释<br> org.apache.spark.rdd.RDD 类源代码中有详细的注释：</p> 
<blockquote> 
 <p>A Resilient Distributed Dataset (RDD), the basic abstraction in Spark.<br> 翻译：弹性的 分布式 数据集是 Spark 基础的抽象。<br> 解释：弹性的（可复原的），说明数据集具有容错性、可修复性。 分布式，说明数据集可以分布在不同的机器上</p> 
</blockquote> 
<blockquote> 
 <p>Represents an immutable, partitioned collection of elements that can be operated on in parallel.<br> 翻译：RDD 是不可变的 分区的 可并行处理的 元素集合<br> 解释：不可变的，这和 Scala 的设计理念相同，数据集一旦构建完成，就不能再修改，这样能轻松解决多个线程读数据的一致性问题。 分区的=可并行处理的=分布式</p> 
</blockquote> 
<blockquote> 
 <p>This class contains the basic operations available on all RDDs, such as map, filter, and persist.<br> 翻译：这个抽象类包含了所有 RDD 都应该有的基本操作，比如 map 、filter 、persist等<br> 解释：这三个操作分别是：批量转换、筛选、持久化</p> 
</blockquote> 
<blockquote> 
 <p>In addition, [[org.apache.spark.rdd.PairRDDFunctions]] contains operations available only on RDDs of key-value pairs, such as groupByKey and join;<br> 翻译：另外 PairRDDFunctions 对象中包含了 键值对型（KV型） RDD 的操作，例如 groupByKey和 join；<br> 解释：KV 型可以支持按 Key 分组、关联等操作</p> 
</blockquote> 
<blockquote> 
 <p>[[org.apache.spark.rdd.DoubleRDDFunctions]] contains operations available only on RDDs of Doubles;<br> 翻译：DoubleRDDFunctions提供可 double 数据集的操作；<br> 解释：数值型数据集有求和、平均、分布图等统计性操作</p> 
</blockquote> 
<blockquote> 
 <p>and [[org.apache.spark.rdd.SequenceFileRDDFunctions]] contains operations available on RDDs that can be saved as SequenceFiles.<br> 翻译：SequenceFileRDDFunctions 提供了顺序存储操作</p> 
</blockquote> 
<blockquote> 
 <p>All operations are automatically available on any RDD of the right type (e.g. RDD[(Int, Int)]) through implicit.<br> 翻译：所有的的类通过隐式转换自动地用于RDD实例中<br> 解释：RDD 伴生对象里包含了隐式转换函数，用implicit 修饰。隐式转换是 Scala 的语法特性。</p> 
</blockquote> 
<blockquote> 
 <p>Internally, each RDD is characterized by five main properties:</p> 
 <p>A list of partitions<br> A function for computing each split<br> A list of dependencies on other RDDs<br> Optionally, a Partitioner for key-value RDDs (e.g. to say that the RDD is hash-partitioned)<br> Optionally, a list of preferred locations to compute each split on (e.g. block locations for an HDFS file)<br> 翻译：在 RDD 中，包含这样的5个属性（也就说要实现抽象方法或给空对象赋值）：</p> 
 <p>一个分区的列表（getPartitions）<br> 一个用于计算分区中数据的函数（compute）<br> 一个对其他 RDD 的依赖列表（getDependencies）<br> 可选：KV 型 RDD 应该有一个分区器，例如 hash-分区器（partitioner）<br> 可选：分区数据计算完后优先存储的位置，例如 HDFS 的某个块（getPreferredLocations）<br> All of the scheduling and execution in Spark is done based on these methods, allowing each RDD to implement its own way of computing itself. Indeed, users can implement custom RDDs (e.g. for reading data from a new storage system) by overriding these functions.<br> 翻译： Spark 中所有的任务调度、任务执行都依赖于这些方法。RDD 可以覆盖这些方法，实现有自己的计算方法。例如从一个新的存储系统中读取数据。</p> 
</blockquote> 
<blockquote> 
 <p>Please refer to the http://101.96.8.165/people.csail.mit.edu/matei/papers/2012/nsdi_spark.pdf for more details on RDD internals.<br> 翻译：更多细节，可以 Spark 的论文</p> 
</blockquote> 
<p>一段示例代码<br> 是的，我们从HelloWorld开始，官方推荐的第一个程序是计算π的近似值：</p> 
<blockquote> 
 <p>import scala.math.random<br> import org.apache.spark.sql.SparkSession</p> 
 <p>object SparkPi {<!-- --><br>   def main(args: Array[String]) {<!-- --><br>     val spark = SparkSession<br>       .builder<br>       .appName("Spark Pi")<br>       .getOrCreate()<br>     val slices = if (args.length &gt; 0) args(0).toInt else 2<br>     val n = math.min(100000L * slices, Int.MaxValue).toInt // avoid overflow<br>     val count = spark.sparkContext.parallelize(1 until n, slices).map { i =&gt;<br>       val x = random * 2 - 1<br>       val y = random * 2 - 1<br>       if (x*x + y*y &lt;= 1) 1 else 0<br>     }.reduce(_ + _)<br>     println("Pi is roughly " + 4.0 * count / (n - 1))<br>     spark.stop()<br>   }<br> }</p> 
</blockquote> 
<p><br> ?什么，RDD 在哪里？ </p> 
<p>1、获得 Spark 会话 和 Spark 上下文</p> 
<blockquote> 
 <p>val spark = SparkSession.builder.appName("xx").getOrCreate()</p> 
</blockquote> 
<p>这4行，只能算是1行代码。调用内部的构造器产生了一个Spark 会话对象，赋值给 spark。后面 spark.sparkContext 是获得 Spark 的上下文对象。至于会话对象和上下文对象，以后再分析。</p> 
<p>2、创建一个 RDD</p> 
<blockquote> 
 <p>spark.sparkContext.parallelize(1 until n, slices)</p> 
</blockquote> 
<p>SparkContext 对象中有一个parallelize 函数，创建了一个RDD对象。 RDD是抽象类。进入源码我们可以看到 创建的 RDD 是 ParallelCollectionRDD（字面翻译为并行容器 RDD）。这个RDD是最简单的RDD了。如果是我，我会将它命名为SimpleRDD。 这句话创建了一个包含slices个分区的 RDD，RDD 的内容是1到 n，这 n+1 个数。数据存在内存中，从内存读分区的数据。</p> 
<p>3、看看这个 RDD 中的细节<br> 还记得前一节翻译的文字吗？RDD 应该实现5个方法。这个并行容器 RDD 是怎么实现的呢？</p> 
<ul><li>一个分区的列表 将数据分成slices份，放在slices个容器中。每个容器就是一个分区，所有容器构成了分区列表</li><li>一个用于计算分区中数据的函数 什么都没做，返回分区的迭代器</li><li>一个依赖列表 依赖列表为Nil空列表。即，这个 RDD 不依赖别的 RDD</li><li>一个分区器 不是 KV 型的，不需要</li><li>一个运算存储优先位置 SparkContext传入了一个 Map，Map 有slices个key，对应slices个容器。可见，SparkContext希望结果存在内存中。</li></ul> 
<p>4、map<br> map是将分组中每一个元素映射成另一个元素的操作。我们说过，RDD是不可变的，map这个操作产生新MapPartitionsRDD对象。 那MapPartitionsRDD的5个方法呢？</p> 
<ul><li>一个依赖列表：只依赖于上游的 RDD，本例中依赖于上游的ParallelCollectionRDD。</li><li>一个分区列表：就是上游分区列表，直接读取上游数据</li><li>一个计算：计算过程就是“映射关系”，由外部传入一个函数对象表达映射关系</li><li>一个分区器：上游 RDD 的分区器，直接读上游的分区</li><li>一个优先存储位置：上游 RDD 的优先位置，本例中直接写到SparkContext传入的 Map</li></ul> 
<p>5、reduce<br> reduce 也是一个操作，是多对一的聚合操作，聚合前后类型必须一致。本例中是求和操作。 过程可以简述成，先计算每个分区的聚合结果，再将多个分区的结果再聚合。过程比较复杂，以后再深入。</p> 
<p>6、如何计算π？<br> random 是随机数，范围是 [0, 1)，那么x 和 y 是 [-1, 1)范围内的随机数。 计算x*x+y*y，这是点(x, y)到(0, 0) 的距离，当距离不大1（点落在r=1的圆内）时，取1，否则取0。<br> 那么随机取 N 个点，点落圆内的几率等于圆的面积／边长为2的正方形的面积。所以：</p> 
<p>圆的面积 ≌ 正方形面积 * 落在圆内的点数 / 所有的点数<br> 圆的面积＝π，正方形面积=4<br> 根据大数定理和中心极限定理，取的点越多，π的估值越近似于正态分布；取得的点越多，正态分布的标准差越小；取得的点越多，正态分布的均值越接近π的真值。<br> 所以，随着取点的增加，π估值约精确。</p> 
<p><strong>Scala 语法</strong></p> 
<blockquote> 
 <p>1 until n</p> 
</blockquote> 
<p>用到了三个 Scala 语法：</p> 
<ol><li>一切皆对象 在 Java 中，1会被认为是一个基本类型int，可以装包成对象，在 Scala 中，1 就是一个对象。</li><li>隐式转换 util是调用 RichInt.util 方法。Int 转换成 RichInt 是隐式的，定义在 scala.Predef对象中的intWrapper方法。scala.Predef类似于宏。 参考： scala source implicit conversion from Int to RichInt - Stack Overflow</li><li>函数调用的写法 1 until n等价于1.until(n)，也就是说，如果对象方法若只有一个参数，可以省略掉点和括号，这样代码更接近自然语言。</li></ol> 
<p>OK，那么1 until n 这句话写全了应该是什么样的呢？ 答：scala.this.Predef.intWrapper(1).until(n);</p> 
<p><strong>总结：</strong></p> 
<p><strong>RDD 是数据集<br> RDD 的特点是有弹性、分布式、不可变。<br> RDD应该包含5个部分：一个分区集、一个依赖集、一个运算、[一个分区器、一个优先结果存储位置]。<br> RDD 有一系列的操作，包括映射、过滤、聚合、存储等。</strong><br>  </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d7cd7ac165d55619104084c63fef7587/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">iptables v1.6.1: can‘t initialize iptables table `filter‘</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5c756acfb01a4a7790ea159b6faadf07/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spark RDD的转换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>