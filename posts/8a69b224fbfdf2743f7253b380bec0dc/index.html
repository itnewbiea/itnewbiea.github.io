<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Verilog 基础知识(一) Verilog 基础语法与注意事项 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Verilog 基础知识(一) Verilog 基础语法与注意事项" />
<meta property="og:description" content="基础知识 0.1 模块(Module) Verilog中的module可以看成一个具有输入输出端口的黑盒子，该黑盒子有输入和输出接口(信号)，通过把输入在盒子中执行某些操作来实现某项功能。(类似于C语言中的函数)
图1 模块示意图
0.1.1 模块描述 图1 所示的顶层模块(top_module)结构用Verilog语言可描述为：
module top_module( input a, input b, output out ); ....... endmodule 模块以module 开始，endmodule结束top_module 为模块名input : 为输入端口output: 为输出端口所有代码必须处于module模块中！ 同理，图1 所示的次级模块(mod_a)结构用Verilog语言可描述为：
module top_module( input in1, input in2, output out ); ....... endmodule 注意事项：每个模应单独块处于一个.v文件中，模块名即为文件名(规范代码！)
0.1.2 模块输入输出信号 输出： output输入： input 模块的输入输出端口都可看出模块的信号，若不写信号类型则默认为wire类型信号！
// 以下这两个语句本质是一直的 input a; input wire a; 除了wire型信号，还有reg型信号，具体详见1.4节！
0.1.3 模块实例化 如图1所示，top_module的两个输入端口连接到次级模块(mod_a)的输入端口，那如何在top_module模块模块中使用mod_a模块的功能呢？这就需要通过模块实例化，可以把top_module看成C语言中的主函数，次级模块mod_a看成普通函数，这样就可以在主函数中调用其他函数来完成相应的功能！
在top_module中实例化mod_a的方式为：
模块实例化语法： 模块名 实例名(定义连接port的信号);
module top_module( input a, input b, output out ); mod_a instance2 (." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8a69b224fbfdf2743f7253b380bec0dc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-17T22:25:35+08:00" />
<meta property="article:modified_time" content="2022-05-17T22:25:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Verilog 基础知识(一) Verilog 基础语法与注意事项</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="text-align:center;">基础知识</h2> 
<h3> 0.1 模块(Module)</h3> 
<p>        Verilog中的module可以看成一个具有输入输出端口的黑盒子，该黑盒子有输入和输出接口(信号)，通过把输入在盒子中执行某些操作来实现某项功能。(类似于C语言中的函数)</p> 
<p><img alt="" height="391" src="https://images2.imgbox.com/8e/40/BWH6EejI_o.png" width="933"></p> 
<p style="text-align:center;">图1  模块示意图</p> 
<h4>0.1.1 模块描述</h4> 
<p>图1 所示的顶层模块(top_module)结构用Verilog语言可描述为：</p> 
<pre><code>module  top_module(
    input a,
    input b,
    output out
);

   ....... 

endmodule</code></pre> 
<ul><li>模块以module 开始，endmodule结束</li><li>top_module 为模块名</li><li>input : 为输入端口</li><li>output:  为输出端口</li><li><span style="background-color:#a2e043;">所有代码必须处于module模块中</span>！</li></ul> 
<p> 同理，图1 所示的次级模块(mod_a)结构用Verilog语言可描述为：</p> 
<pre><code>module  top_module(
    input in1,
    input in2,
    output out
);

   ....... 

endmodule</code></pre> 
<p><strong>注意事项</strong>：<span style="color:#fe2c24;"><strong>每个模应单独块处于一个.v文件中，模块名即为文件名</strong></span>(规范代码！)</p> 
<h4>0.1.2  模块输入输出信号</h4> 
<ul><li>输出： output</li><li>输入： input</li></ul> 
<p>模块的输入输出端口都可看出模块的信号，若不写信号类型则<span style="color:#fe2c24;">默认为wire类型信号</span>！</p> 
<pre><code>// 以下这两个语句本质是一直的
input a;

input wire a;</code></pre> 
<p>除了wire型信号，还有reg型信号，具体详见<span style="color:#a2e043;">1.4</span>节！</p> 
<h4>0.1.3 模块实例化</h4> 
<p>        如图1所示，top_module的两个输入端口连接到次级模块(mod_a)的输入端口，那如何在top_module模块模块中使用mod_a模块的功能呢？这就需要通过模块实例化，可以把top_module看成C语言中的主函数，次级模块mod_a看成普通函数，这样就可以在主函数中调用其他函数来完成相应的功能！</p> 
<p>在top_module中实例化mod_a的方式为：</p> 
<p><span style="background-color:#38d8f0;">模块实例化语法</span>： 模块名 实例名(定义连接port的信号);</p> 
<pre><code>module  top_module(
    input a,
    input b,
    output out
);

	mod_a instance2 (.in1(a), .in2(b), .out(out));

endmodule</code></pre> 
<ul><li>按mod_a定义的端口顺序实例化: mod_a instance1 (a, b, out);</li><li><span style="color:#fe2c24;">按mod_a端口名实例化</span>: mod_a instance2 (.in1(a), .in2(b), .out(out));   (推荐此种写法)</li></ul> 
<h3>0.2 逻辑块(always、generate)</h3> 
<h4>0.2.1 always逻辑块</h4> 
<p>        always块可构建 组合逻辑块 和 时序逻辑块，复杂的逻辑操作都需要处于该逻辑块中，如if、case、for等</p> 
<p>(1) 组合逻辑块</p> 
<pre><code>module top_module();

    always @(*) begin
        ....
    end

endmodule</code></pre> 
<ul><li>always逻辑块中<span style="background-color:#ff9900;">任意信号变化时立即触发</span>，执行begin - end之间的语句</li><li>begin - end用于<span style="color:#fe2c24;">将多条语句组成一个代码块</span>，只有一条语句时可省略</li></ul> 
<p>(1) 时序逻辑电路</p> 
<pre><code>module top_module();

    always @(posedge clk) begin
        ....
    end

endmodule</code></pre> 
<ul><li><span style="background-color:#a2e043;">clk </span>信号的上升沿触发</li><li>posedge:  上升沿</li><li>negedge: 下降沿</li></ul> 
<h4>0.2.2 generate逻辑块</h4> 
<p>generate主要结合for循环使用，主要用途有：</p> 
<ul><li>对<span style="color:#4da8ee;">向量</span>中的多个位进行重复操作</li><li><span style="color:#fe2c24;">对同一个模块进行多次重复实例化</span>(主要用途)</li></ul> 
<p>(1) 操作向量</p> 
<pre><code>module top_module(input [7:0] in,  output [7:0] out);
    genvar i;        // genvar i; 也可以定义在generate内部
    generate
        for(i=0; i&lt;8; i++) begin: bit
             assign out[i]=^in[8-1:i];
        end
    endgenerate
endmodule</code></pre> 
<p>(2) 模块重复多次实例化</p> 
<pre><code>module  top_module(
    input a,
    input b,
    output out
);
    genvar i;
    generate
        for(i=0; i&lt;8; i++)  begin: gen_mod_a   //  gen_mod_a 为每个begin_end的结构的名称
            mod_a instance2 (.in1(a), .in2(b), .out(out));
        end
    endgenerate
endmodule</code></pre> 
<ul><li>注意：模块多次实例化时<span style="color:#fe2c24;">必须写每个begin_end结构的名称</span>(gen_mod_a)</li><li>仿真器会通过gen_mod_a来标识生成结构: gen_mod_a[0],gen_mod_a[1]....</li></ul> 
<h4> 0.2.3 initial块 </h4> 
<p>        initial块可以理解为一个<span style="color:#fe2c24;">初始化块</span>，在initial的起始位置的语句<span style="background-color:#a2e043;">在0时刻即开始执行，之后如果遇到延时，则延时之后执行接下来的语句</span>。</p> 
<p>        初始块是<span style="color:#fe2c24;">不可综合的</span>，因此<span style="background-color:#fe2c24;">不能将其转化为带有数字元素的硬件原理图。因此初始块除了在仿真中使用外，并没有太大的作用</span>。</p> 
<p>如:在仿真文件中初始化各种参数：</p> 
<pre><code>initial                                                
begin                                                  
    sys_clk    = 1'b1;                
    sys_rst_n  = 1'b0; 
	#50
	sys_rst_n  = 1'b1;                
end  </code></pre> 
<p>注意：</p> 
<ul><li>initial 块在电路中不可综合，故一般不出现在RTL代码中</li><li> <span style="background-color:#a2e043;">initial 一般只在仿真文件中使用</span></li></ul> 
<p>若需要在RTL代码中初始化参数，需要用always块，用initial块会导致错误！</p> 
<p>如下所示，<span style="color:#fe2c24;">在RTL代码中初始化存储器的方式为</span>：</p> 
<pre><code>reg [255:0]char_data[4:0];

always@(posedge clk)
    begin
        char_data[0]     &lt;=  256'h0000000000000000000000000000000000000000000000000000000000000000;
        char_data[1]     &lt;=  256'h0000000000000000000000000000000000000000000000000000000000000000;
        char_data[2]     &lt;=  256'h0000000000000000000000200000000000000000002000000008000010000000;
        char_data[3]     &lt;=  256'h000000000000000000000038000000000000020000380000000600001C000000;
        char_data[4]     &lt;=  256'h02000000000100000000003E0000000000000700003E0000000780001F000000;
    end</code></pre> 
<h3>0.3 赋值方式</h3> 
<p>Verilog 中赋值方式有三种： 连续赋值、阻塞赋值、非阻塞赋值</p> 
<h4>0.3.1 连续赋值(assign)</h4> 
<pre><code>assign x = y;</code></pre> 
<ul><li>该语句表示把x和y两个信号进行连接，<span style="color:#4da8ee;">真实的物理连接</span>！</li><li><span style="color:#ff9900;">不能在always块中使用</span></li></ul> 
<h4>0.3.2 阻塞赋值(=)</h4> 
<pre><code>// 组合块
always @(*)  begin
	out1 = a ;
    a = b ;
    out2 = a ;
end</code></pre> 
<ul><li><span style="color:#fe2c24;">组合always块中用阻塞式赋值</span></li><li>执行顺序：按照begin_end语句块中的<span style="color:#fe2c24;">顺序依次执行</span>，上述输出结果为：out1 = a ，out2 = b</li></ul> 
<h4> 0.3.3 非阻塞赋值(&lt;=)</h4> 
<pre><code>// 时序块
always @(posedge clk)  begin
	out1 &lt;= a ;
    a &lt;= b ;
    out2 &lt;= a ;
end</code></pre> 
<ul><li><span style="color:#fe2c24;">时序always块中用非阻塞赋值</span></li><li>执行顺序：begin_end中<span style="color:#fe2c24;">所有语句并行执行</span>，上述输出结果为：out1 = a ，out2 = a</li></ul> 
<p></p> 
<hr> 
<h2 id="1%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95" style="text-align:center;">第一章   基础语法</h2> 
<h3 id="1.1%20%E6%A0%87%E8%AF%86%E7%AC%A6">1.1 标识符</h3> 
<p id="main-toc">(1)用途： 标识符用于定义常数、变量、信号、端口、参数名、模块名等。</p> 
<p>(2)组成： 字母、数字、$、下划线任意组合而成</p> 
<p>(3)注意事项：</p> 
<ul><li>区分大小写(Verilog 和 verilog是不同的)</li><li><span style="color:#fe2c24;">第一个字符只能是字母或下划线</span><span style="color:#0d0016;">(123demo 是非法标识符)</span></li></ul> 
<h3>1.2 逻辑值与逻辑运算</h3> 
<h4>1.2.1 逻辑值</h4> 
<p>Verilog中有4中逻辑值：0、1、x、z</p> 
<ul><li>0:  低电平</li><li>1：高电平</li><li>x:  表示状态未知</li><li>z：表示高阻状态</li></ul> 
<p>注意：这里的z、x是<span style="color:#a2e043;">不区分大小写</span>的(X、Z也可)</p> 
<h4>1.2.2 逻辑运算</h4> 
<p>(1) 逻辑运算符：&amp;&amp;(与)、==（相等）、||（或）、!=（不等）</p> 
<ul><li>如 m&amp;&amp;n  : 判断m和n是否全为真(<span style="color:#fe2c24;">非0即为真</span>)，真则输出1'b1，否则输出1'b0 (4’b1010&amp;4’b0101 = <span style="color:#38d8f0;">1’b1</span>)</li><li>最后输出<span style="background-color:#fe2c24;">结果只有1bit</span></li></ul> 
<p>(2) 按位运算符： &amp;、|、~、^、~&amp;、~^、~| </p> 
<ul><li>如 m&amp;n  : 是把m的每一位与n的每一位按位做与运算 (4’b1010&amp;4’b0101 = <span style="color:#38d8f0;">4’b0000</span>)</li><li>输出结果与m/n的bit数相同</li></ul> 
<p>(3) 归约运算符：  &amp;、|、~、^、&amp;、~^、~| </p> 
<ul><li>只有一个参量参与运算时( &amp;为一元运算符),表示规约与，即向量内部进行与运算</li></ul> 
<pre><code>&amp;a [3：0] // AND:a[3]&amp;a[2]&amp;a[1]&amp;a [0]相当于(a[3：0]== 4'hf)
|b [3：0] // OR: b[3]|b[2]|b[1]|b [0]相当于(b[3：0]!= 4'h0)
^c [2：0] // XOR:c[2]^c[1]^c[0]</code></pre> 
<ul><li>即(&amp;4’b0101 = 0&amp;1&amp;0&amp;1 = <span style="color:#38d8f0;">1'b0</span> )</li><li>最后输出<span style="background-color:#fe2c24;">结果只有1bit</span></li></ul> 
<h3>1.3 常量的表示方法</h3> 
<p>与C语言类似，常量主要有：整数型、实数型和字符串型三种</p> 
<h4>1.3.1 用十进制整数表示整型常量</h4> 
<p>(1) 正数： 直接写 10 表示<span style="color:#ff9900;">位宽为32bit的十进制整数</span>(系统默认)</p> 
<p>(2) 负数：  -10需要用二进制补码表示，多了一位符号位(<span style="color:#fe2c24;">1</span> 1010)</p> 
<p>(3) 用科学计数法表示：12.345e3   表示 12345</p> 
<h4>1.3.2 用基数法表示整数型常量</h4> 
<pre><code>[换算成二进制数后的位宽]'[数制符号][与数制对应的值]</code></pre> 
<p>(1) 二进制(b):     8'b1000_1100      </p> 
<p>(2) 十六进制(h):  8'h8c</p> 
<p>(3) 八进制(o):      8'o214</p> 
<p>(4) 十进制(d):      8'140</p> 
<p>注意事项：</p> 
<ul><li>当表示二进制时，最好每4位写一个下划线以增强可读性：如8'b1000<span style="color:#fe2c24;">_</span>1100   与8'b10001100 是一样的</li><li>基数表示法中<span style="color:#a2e043;">遇到x时</span>：十六进制表示4个x，八进制中表示3个x  </li><li><span style="color:#fe2c24;">当位宽大于二进制位数时左边自动补0，小于二进制数时2从左边截断</span>！</li></ul> 
<h4>1.3.3 字符串(用双引号)</h4> 
<p>(1)<span style="color:#fe2c24;"> 每个字符</span>由1个8位的ASCII码值表示，即需要1byte存储空间</p> 
<p>(2) 如：<span style="background-color:#a2e043;">“Hello world”  </span> 字符串由11个ASCII符号构成，需要11byte存储空间</p> 
<h3>1.3  注释方式</h3> 
<p>Verilog中注释主要有行注释(//)和块注释(/*  ....     */)两种，表示方法与C语言一致！</p> 
<pre><code>// 行注释

/*
        块注释

*/</code></pre> 
<h3>1.4 变量(wire、reg)</h3> 
<p>Verilog中的变量主要有两种： wire和reg</p> 
<h4>1.4.1 wire</h4> 
<p>(1) 线网型(wire): 表示电路间的物理连接，wire定义的变量也可看成<span style="background-color:#a2e043;">信号端口</span></p> 
<p>(2) 当两个wire信号被连续赋值时，在逻辑块中会被映射成真实的物理连线，<span style="color:#38d8f0;">此时这两个信号端口的变化是同步的</span>！</p> 
<pre><code>wire a;

wire b;

assign b = a;    // 表示a与b之间生成实际的物理连线</code></pre> 
<h4>1.4.2 reg</h4> 
<p>(1) 寄存器型(reg): 表示一个<span style="color:#0d0016;"><span style="background-color:#a2e043;">抽象的数据存储单元</span></span></p> 
<p>(2) reg 具有对某一时间点状态进行保持的功能</p> 
<h4>1.4.3 用法与注意事项</h4> 
<p><span style="background-color:#fe2c24;">(1) </span>在<span style="color:#ff9900;">always、initial</span>语句中被赋值的变量(<u>赋值号左边的变量</u>)都是<span style="color:#ff9900;">reg</span>型变量</p> 
<p>(2) 在<span style="color:#956fe7;">assign</span>语句中被赋值的变量，为<span style="color:#956fe7;">wire</span>型变量</p> 
<h3>1.5 向量(vector)与 参数(常量)</h3> 
<h4>1.5.1 parameter 参数(常量)</h4> 
<p>(1) 参数是一种常量，通常出现在<span style="color:#a2e043;">module内部</span>，常被用于定义状态、数据位宽等</p> 
<pre><code>parameter STATE = 1'b0;</code></pre> 
<p>(2) <span style="color:#fe2c24;">只作用于声明的那个文件，且可以被灵活改变</span>！</p> 
<p>(3) 局部参数localparam，只在本模块中使用</p> 
<pre><code>localparam  STATE= 1'b1’;</code></pre> 
<p>(4) 参数的名称一般为<span style="color:#fe2c24;">大写</span>，以区分其他变量 </p> 
<h4>1.5.2 向量(vector)</h4> 
<p>vector(向量)，是<span style="color:#ff9900;">一组信号的集合</span>,可视为位宽超过1bit  的 wire 信号。</p> 
<p>(1) 定义方式：</p> 
<pre><code>格式：input/output  wire/reg [upper:lower] vector_name

//输入输出型
input [7:0] a,b,
output reg [7:0] out

// 模块中间向量
wire [7:0] c, e;
reg [7:0] d;</code></pre> 
<ul><li>[upper:lower] 定义位宽，如 [7:0] 表示位宽为8 bit ，即upper=7，lower=0</li><li>vector_name可以一次<span style="color:#38d8f0;">写多个向量</span></li></ul> 
<h4>1.5.3 向量片选</h4> 
<ul><li>a[3:0]   取向量a的0~4位数据</li><li>b[n]      取向量b的第n位数据</li><li>c[-1:-2]  取向量c的最<span style="background-color:#38d8f0;">低2位</span>数据</li><li>c[0:3]     取向量c的最<span style="background-color:#38d8f0;">高4位</span>数据</li></ul> 
<p>多路选择器应用：实现一个 256 选 1 选择器，sel 信号作为选择信号，当 sel = 0 时选择 in[3:0]，sel = 1 时选择 in[7:4],以此类推。</p> 
<pre><code>module top_module (
	input [1023:0] in,
	input [7:0] sel,
	output [3:0] out
);
	assign out = {in[sel*4+3], in[sel*4+2], in[sel*4+1], in[sel*4+0]};

	// assign out = in[sel*4 +: 4];		
	// assign out = in[sel*4+3 -: 4];	
endmodule</code></pre> 
<ul><li>片选信号sel输入为n位二进制数，当<span style="background-color:#a2e043;">参与运算、充当索引</span>时会自动转换成十进制数</li><li>该题所选取的信号片段为: in[sel*4+3: sel*4] ,但这不符合Verilog的片选语法规则故应写成：<br><span style="background-color:#38d8f0;">in[sel*4 +: 4] </span>  表示索引从sel*4开始的<span style="background-color:#ff9900;">高4bit信号</span><br><span style="background-color:#38d8f0;">in[sel*4+3 -: 4]</span> 表示索引从sel*4+3开始的<span style="background-color:#ff9900;">低4bit信号</span></li><li>或是<span style="background-color:#a2e043;">直接选出需要的每一位</span>，再用{ }拼接成新向量：<br> {in[sel*4+3], in[sel*4+2], in[sel*4+1], in[sel*4+0]}</li></ul> 
<p></p> 
<p>参考文章：<a href="https://zhuanlan.zhihu.com/p/59548254" rel="nofollow" title="HDLBits：在线学习 Verilog （十三 · Problem 60-64） - 知乎 (zhihu.com)">HDLBits：在线学习 Verilog （十三 · Problem 60-64） - 知乎 (zhihu.com)</a></p> 
<p></p> 
<h3>1.6 三元表达式</h3> 
<p>(1) 与C语言相同，Verilog也有<span style="color:#38d8f0;">三元表达式</span>：</p> 
<pre><code>condition ? if_true : if_false</code></pre> 
<p>当条件为真，表达式值为if_true ，否则表达式值为if_false。</p> 
<p>(2) 应用</p> 
<pre><code>(sel ? b : a)   // 一个二选一MUX，通过sel的值选择a或者b

always @(posedge clk)         // 一个T触发器
  q &lt;= toggle ? ~q : q;

assign out = ena ? q : 1'bz;  // 三态缓冲器</code></pre> 
<p>(3) 参考文章： <a href="https://zhuanlan.zhihu.com/p/61379442" rel="nofollow" title="HDLBits：在线学习Verilog（八 · Problem 35-39） - 知乎 (zhihu.com)">HDLBits：在线学习Verilog（八 · Problem 35-39） - 知乎 (zhihu.com)</a></p> 
<h3>1.7 分支语句(if-else、case)</h3> 
<h4>1.7.1 if-else语句</h4> 
<p>(1) <span style="background-color:#a2e043;">最常用的形式</span>：(优势：<span style="color:#fe2c24;">输出的所有可能都写到，不存在未知电平输出</span>！)</p> 
<pre><code class="language-cpp">if(&lt;条件表达式 1&gt;)
    语句或语句块 1;
else if(&lt;条件表达式 2&gt;)
    语句或语句块 2;
    ………
else
    语句或语句块 n;
</code></pre> 
<p>(2)  不建议使用if-else嵌套，会存在优先级问题，导致逻辑混乱，</p> 
<p>(3)  <span style="background-color:#fe2c24;">所有if-else语句都应写成(1)的形式</span>！</p> 
<p>(4) 根据条件表达式依次比较，<span style="background-color:#a2e043;">存在优先级</span>！</p> 
<h4>1.7.2 case 语句</h4> 
<p>(1) 书写形式：</p> 
<pre><code class="language-cpp">case(&lt;控制表达式&gt;)
    &lt;分支语句 1&gt; : 语句块 1;
    &lt;分支语句 2&gt; : 语句块 2;
    &lt;分支语句 3&gt; : 语句块 3;
    ………
    &lt;分支语句 n&gt; : 语句块 n;

    default : 语句块 n+1;
endcase
</code></pre> 
<p>比较&lt;控制表达式&gt;与&lt;分支语句n&gt;的取值相等则执行对应语句，否则执行default后语句！</p> 
<p>(2) <span style="color:#4da8ee;">执行完某一分支语句后立即跳出case语句结构</span>，终止case语句执行。</p> 
<p>(3) <span style="background-color:#38d8f0;">&lt;分支语句n&gt;</span>的取值必须<span style="color:#fe2c24;">互不相同</span>！</p> 
<p>(4) <span style="background-color:#ff9900;">以encase结束</span>case语句块</p> 
<p>(5) 各分支语句间<span style="background-color:#a2e043;">不存在优先级</span>！</p> 
<p>(6) 具体应用: 用case语句搭建多路选择器，（以9选1多路选择器为例）</p> 
<pre><code>module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    always @(*) begin
        case(sel)
            4'h0:begin out = a; end
            4'h1:begin out = b; end
            4'h2:begin out = c; end
            4'h3:begin out = d; end
            4'h4:begin out = e; end
            4'h5:begin out = f; end
            4'h6:begin out = g; end
            4'h7:begin out = h; end
            4'h8:begin out = i; end
            default: out = 16'hffff;
        endcase
    end
endmodule</code></pre> 
<h3>1.8 for循环语句</h3> 
<p>(1) 书写形式：</p> 
<pre><code>integer i;
always @(*)  begin 
    for(i=0; i&lt;n; i++)  begin: for_name
        &lt;循环语句&gt;
    end
end</code></pre> 
<ul><li>执行&lt;循环语句&gt;<span style="color:#4da8ee;">n次</span></li><li>for_name为每一次循环的名称</li></ul> 
<h3>1.9 关系运算符(&gt;、&lt;、&gt;=、&lt;=)</h3> 
<ul><li>运算结果为真返回 1</li><li>运算结果为假返回 0</li><li>若某个操作<span style="background-color:#38d8f0;">数值不定(x)</span>，则返回值为 x</li></ul> 
<h3>2.0  拼接运算符({ , })</h3> 
<h4>2.0.1 拼接</h4> 
<p>用一对花括号加逗号组成“<span style="background-color:#fbd4d0;">{ , }</span>”拼接运算符，逗号隔开的数据<span style="color:#fe2c24;">按顺序拼接成新数据</span>！</p> 
<pre><code>wire [1:0] a;
wire [3:0] b;
wire [5:0] c;
wire [11:0] d = {a, b, c} </code></pre> 
<h4>2.0.2 通过拼接实现移位</h4> 
<p>在左边拼接实现右移，右边拼接实现左移！</p> 
<pre><code>always @(posedge clk) begin
    if(rst_n == 1'b0)
        out &lt;= 4'b0;
    else
        out &lt;= {in, out[3:1]};    // 右移
end</code></pre> 
<h4>2.0.2 连接符中重复多次的操作</h4> 
<p>语法：<span style="background-color:#ffd7b9;"> {重复次数{vector}}</span></p> 
<pre><code>{3{a}} = {a, a, a}
{3'd5, {2{3'd6}}}   // 9'b101_110_110.</code></pre> 
<h3>2.1  移位运算符</h3> 
<p>移位运算符用于将左边操作数左移或右移指定的位数！<span style="color:#fe2c24;">移位后空闲位用0填充</span>。</p> 
<ul><li>左移运算符： &lt;&lt;</li></ul> 
<p>如： 4‘b1101 &lt;&lt; 3 结果为：4‘b1000</p> 
<ul><li>右移算法符:   &gt;&gt;</li></ul> 
<p>如： 4‘b1101 &gt;&gt; 3 结果为：4‘b0001 </p> 
<ul><li>移位运算符其他用途：<span style="background-color:#a2e043;">左移一位可以看成是乘以 2，右移一位可以看成是除以 2</span>。</li><li>移位运算符代替乘除法可以节省资源！</li></ul> 
<h3>3  二进制全加器</h3> 
<p></p> 
<p style="text-align:center;"><img alt="" height="140" src="https://images2.imgbox.com/0a/56/opF2683k_o.png" width="131"></p> 
<ul><li>a、b为输入 1bit 数据</li><li>cin为上一个加法器进位输入</li><li>cout为本加法器的进位输出</li><li>sum = a+b</li></ul> 
<p style="text-align:center;"><img alt="" height="118" src="https://images2.imgbox.com/bf/c1/BjOEoSOE_o.png" width="556"></p> 
<p></p> 
<p>代码实现：</p> 
<pre><code>module add1 (
	input a,
	input b,
	input cin,	
	output sum,
	output cout
);
	assign sum = a^b^cin;
	assign cout = (a&amp;b) | (a&amp;cin) | (b&amp;cin);
endmodule</code></pre> 
<p></p> 
<h3>4 16进制全加器</h3> 
<p class="img-center"><img alt="" height="586" src="https://images2.imgbox.com/56/29/dGlPan2a_o.png" width="373"></p> 
<p></p> 
<p>16进制全加器如上图所示，它可由上节中16个二进制全加器组合而成。</p> 
<p>用Verilog实现16进制全加器代码为：</p> 
<pre><code>module add16 (	
	input [15:0] a,
	input [15:0] b,
	input cin,
	
	output [15:0] sum,
	output cout
);
	wire [16:0] Add_cin;
	assign Add_cin[0] = cin;    // 上图中第一个二进制加法器进位输入为0 assign Add_cin[0] = 1b'0;

//  用 generate 进行模块多次实例化
// generate 应用范围：对矢量(vector)多个位重复操作，模块重复实例化
	genvar i;
	generate
		for(i=0; i&lt;16; i++) begin: gen_add16		// gen_add16 为每个begin_end的结构，仿真器会通过他来标识生成结构，gen_add16[0],gen_add16[1]....
			add1 Add16(.a(a[i]), .b(b[i]), .cin(Add_cin[i]), .sum(sum[i]), .cout(Add_cin[i+1]));
		end
	
	endgenerate
	
	assign cout = Add_cin[16];

endmodule</code></pre> 
<h2>5 模块中的参数传递</h2> 
<h3>5.1 定义可传递参数的模块</h3> 
<pre><code>module counter
// 参数传递
#(
    parameter COUNT_MAX = 25'd24_999_999,
    parameter STATE     = 1'b0            // 多个参数用逗号隔开
)
(
    input  wire  sys_clk,
    output reg led_out
);
// 代码主体
endmodule</code></pre> 
<h3>5.2 带参数模块的实例化</h3> 
<pre><code>// 参数传递
#(
   .COUNT_NUM( 25'd24_999_999),        // 传入参数
   .STATE(1'b0)
)
counter1_init      // 实例化模块的名称位置
(
    .sys_clk   (sys_clk),
    .led_out(led_out)
); </code></pre> 
<p></p> 
<p>参考资料：</p> 
<p>[1] 野火《FPGA Verilog开发实战指南》：<a class="has-card" href="https://doc.embedfire.com/fpga/altera/ep4ce10_pro/zh/latest/index.html" rel="nofollow" title="[野火]FPGA Verilog开发实战指南——基于Altera EP4CE10 征途Pro开发板 — [野火]FPGA Verilog开发实战指南——基于Altera EP4CE10 征途Pro开发板 文档 (embedfire.com)"><span class="link-card-box"><span class="link-title">[野火]FPGA Verilog开发实战指南——基于Altera EP4CE10 征途Pro开发板 — [野火]FPGA Verilog开发实战指南——基于Altera EP4CE10 征途Pro开发板 文档 (embedfire.com)</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/61/2c/0p2cHfeU_o.png">https://doc.embedfire.com/fpga/altera/ep4ce10_pro/zh/latest/index.html</span></span></a></p> 
<p>[2] HDLBits中文导学：<a href="https://zhuanlan.zhihu.com/c_1131528588117385216" rel="nofollow" title="HDLBits 中文导学 - 知乎 (zhihu.com)">HDLBits 中文导学 - 知乎 (zhihu.com)</a></p> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d37c55c4fcee9c4802af1e362708c67c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Simulink基础作业</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4cde978e00ffd98915bf4fa6d1992ee8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">git 命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>