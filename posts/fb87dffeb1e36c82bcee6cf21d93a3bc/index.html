<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CMake的基础知识，看这篇就够了！ - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CMake的基础知识，看这篇就够了！" />
<meta property="og:description" content="大家好，我是杂烩君。
上一篇文章中我们分享了关于make与Makefile的知识：Makefile常用基础知识梳理！。make工具有很多种：gnu make、QT的qmake、微软的MS nmake等。不同的make工具遵循不同的规范，如果我们的程序想要运行在不同的平台上，就需要根据不同地平台的make工具规范编写对应的Makefile文件。显然，这很不方便。
CMake就是一个可以解决上面这个问题的工具。
什么是cmake？ CMake 是一个跨平台的安装(编译)工具。CMakeList.txt是一个与平台无关的、用于定制编译流程的文件。CMake 靠的是 CMakeLists.txt 文件来生成Makefile文件。
CMakeLists.txt文件的编写也需要遵循一些语法规则，CMakeLists.txt文件的语法与shell脚本的语法很相似，shell编程知识可见往期文章：Hello系列 | Shell编程必备简明基础知识。
下面简单了解CMakeLists.txt简单的规则及一些示例。
cmake语法知识 1、直译模式 直译模式简单解释就是不生成Makefile的模式。这很方便我们验证一些CMakeLists.txt的语法及验证一些数学运算等。
下面通过简单实例区分直译模式与非直译模式的区别。
直译模式：
输入 -P参数 指定CMakeLists.txt脚本以直译模式解析。其中，message是CMakeLists.txt中用于输出信息的命令。以直译模式解析就不会生成Makefile文件，并且终端输出的信息就是我们CMakeLists.txt指定输出的内容。
非直译模式：
可见，以非直译模式解析则会生成Makefile文件，并且终端多输出了一些核查编译器相关的信息。
2、定义变量 CMakeLists.txt中只有字串和字串数组两种变量。定义变量通过 set命令 来定义，使用变量时在外面加上 ${} 符号即可。如：
# 定义变量 set(name &#34;LinuxZn&#34;) # 使用变量 message(&#34;My name is ${name}!&#34;) ① 注释使用符号 #。
② 命令不区分大小写，即set也可以替换为SET。
3、数学运算 # EXPR 是一款表达式计算工具 # math 是用于数学运算的命令 # 设置变量a、b的值 set(a &#34;1&#34;) set(b &#34;2&#34;) # 加 math(EXPR res &#34;${a} &#43; ${b}&#34;) message(&#34;a &#43; b : ${res}&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/fb87dffeb1e36c82bcee6cf21d93a3bc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-16T12:09:08+08:00" />
<meta property="article:modified_time" content="2023-06-16T12:09:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CMake的基础知识，看这篇就够了！</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>大家好，我是杂烩君。</p> 
<p>上一篇文章中我们分享了关于make与Makefile的知识：<a href="https://mp.weixin.qq.com/s?__biz=Mzg5ODYzNDU4Nw==&amp;mid=2247484476&amp;idx=1&amp;sn=52f55ba6786d9930d75e5f21993b897b&amp;chksm=c05ec208f7294b1e2fbea43db0992154f4f446df42fbb6e271f23327aaaa51ee9acbffd407d6&amp;token=835109125&amp;lang=zh_CN#rd" rel="nofollow">Makefile常用基础知识梳理！</a>。make工具有很多种：gnu make、QT的qmake、微软的MS nmake等。不同的make工具遵循不同的规范，如果我们的程序想要运行在不同的平台上，就需要根据不同地平台的make工具规范编写对应的Makefile文件。显然，这很不方便。</p> 
<p>CMake就是一个可以解决上面这个问题的工具。</p> 
<h3><a id="cmake_8"></a>什么是cmake？</h3> 
<p>CMake 是一个跨平台的安装(编译)工具。CMakeList.txt是一个与平台无关的、用于定制编译流程的文件。CMake 靠的是 CMakeLists.txt 文件来生成Makefile文件。</p> 
<p>CMakeLists.txt文件的编写也需要遵循一些语法规则，CMakeLists.txt文件的语法与shell脚本的语法很相似，shell编程知识可见往期文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg5ODYzNDU4Nw==&amp;mid=2247484642&amp;idx=1&amp;sn=51579feb6febf3d9cb8c0379da17f703&amp;chksm=c05ec2d6f7294bc0dd3cc5354d2702c07b8405dee54b4428425cc5b53f5630c53820cfb16282&amp;token=835109125&amp;lang=zh_CN#rd" rel="nofollow">Hello系列 | Shell编程必备简明基础知识</a>。</p> 
<p>下面简单了解CMakeLists.txt简单的规则及一些示例。</p> 
<h3><a id="cmake_16"></a>cmake语法知识</h3> 
<h4><a id="1_18"></a>1、直译模式</h4> 
<p>直译模式简单解释就是不生成Makefile的模式。这很方便我们验证一些CMakeLists.txt的语法及验证一些数学运算等。</p> 
<p>下面通过简单实例区分直译模式与非直译模式的区别。</p> 
<p><strong>直译模式：</strong></p> 
<p><img src="https://images2.imgbox.com/d1/86/rAUJjIrm_o.png" alt=""></p> 
<p>输入 <strong><code>-P参数</code></strong> 指定CMakeLists.txt脚本以直译模式解析。其中，message是CMakeLists.txt中用于输出信息的命令。以直译模式解析就不会生成Makefile文件，并且终端输出的信息就是我们CMakeLists.txt指定输出的内容。</p> 
<p><strong>非直译模式：</strong></p> 
<p><img src="https://images2.imgbox.com/55/f4/WCEbBu93_o.png" alt=""></p> 
<p>可见，以非直译模式解析则会生成Makefile文件，并且终端多输出了一些核查编译器相关的信息。</p> 
<h4><a id="2_36"></a>2、定义变量</h4> 
<p>CMakeLists.txt中只有字串和字串数组两种变量。定义变量通过 <strong><code>set命令</code></strong> 来定义，使用变量时在外面加上 ${} 符号即可。如：</p> 
<pre><code># 定义变量
set(name "LinuxZn")

# 使用变量
message("My name is ${name}!")
</code></pre> 
<p><img src="https://images2.imgbox.com/d9/17/WIGIktwN_o.png" alt=""></p> 
<blockquote> 
 <p>① 注释使用符号 <strong><code>#</code></strong>。</p> 
 <p>② 命令不区分大小写，即set也可以替换为SET。</p> 
</blockquote> 
<h4><a id="3_54"></a>3、数学运算</h4> 
<pre><code># EXPR 是一款表达式计算工具
# math 是用于数学运算的命令

# 设置变量a、b的值
set(a "1")
set(b "2")

# 加
math(EXPR res "${a} + ${b}")
message("a + b : ${res}")

# 减
math(EXPR res "${a} - ${b}")
message("a - b : ${res}")

# 乘
math(EXPR res "${a} * ${b}")
message("a * b : ${res}")

# 除
math(EXPR res "${a} / ${b}")
message("a / b : ${res}")

# 取余
math(EXPR res "${a} % ${b}")
message("a % b : ${res}")
</code></pre> 
<p><img src="https://images2.imgbox.com/2a/41/Zqzum999_o.png" alt=""></p> 
<h4><a id="4_87"></a>4、从命令行给变量赋值</h4> 
<pre><code># EXPR 是一款表达式计算工具
# math 是用于数学运算的命令

# 加
math(EXPR res "${a} + ${b}")
message("a + b : ${res}")

# 减
math(EXPR res "${a} - ${b}")
message("a - b : ${res}")

# 乘
math(EXPR res "${a} * ${b}")
message("a * b : ${res}")

# 除
math(EXPR res "${a} / ${b}")
message("a / b : ${res}")

# 取余
math(EXPR res "${a} % ${b}")
message("a % b : ${res}")
</code></pre> 
<p><img src="https://images2.imgbox.com/27/26/2iR9nEan_o.png" alt=""></p> 
<blockquote> 
 <p>-D后面跟着变量及赋值。</p> 
</blockquote> 
<p>我们经常会在命令行配置工程为debug模式还是release模式，如：</p> 
<pre><code>cmake -DCMAKE_BUILD_TYPE=Debug
</code></pre> 
<blockquote> 
 <p>CMAKE_BUILD_TYPE是cmake中的一个内置变量，用于指定构建类型。</p> 
</blockquote> 
<h4><a id="5_126"></a>5、流程控制</h4> 
<h5><a id="1if_128"></a>（1）if</h5> 
<pre><code>set(ARCH "x86")
if(ARCH MATCHES "x86")
    message("ARCH is x86")
else()
    message("ARCH is arm")
endif()
</code></pre> 
<p><img src="https://images2.imgbox.com/c1/84/vaAwt5i8_o.png" alt=""></p> 
<h5><a id="2while_141"></a>（2）while</h5> 
<pre><code>set(a "1")
while(${a} LESS "5")
    message("${a}")          
    math(EXPR a "${a} + 1")
endwhile()
</code></pre> 
<p><img src="https://images2.imgbox.com/f0/5e/ZwMfClL2_o.png" alt=""></p> 
<h5><a id="3foreach_153"></a>（3）foreach</h5> 
<pre><code>message("for 1 =========")
foreach(i RANGE 1 5)
    message("${i}")
endforeach()

message("for 2 =========")
foreach(i 1 5 6 7 9 10)
    message("${i}")
endforeach()

message("for 3 =========")
foreach(str Linux C Cpp Python Shell)
    message("${str}")
endforeach()
</code></pre> 
<p><img src="https://images2.imgbox.com/ac/25/3JE7dCSg_o.png" alt=""></p> 
<h4><a id="6_174"></a>6、自定义宏与函数</h4> 
<h5><a id="1_176"></a>（1）宏</h5> 
<pre><code># 定义名为printf的宏 
macro(printf str)
    message(${str})
endmacro()

# 使用
printf("hello macro")
</code></pre> 
<p><img src="https://images2.imgbox.com/4b/50/HukV45vB_o.png" alt=""></p> 
<h5><a id="2_190"></a>（2）函数</h5> 
<pre><code># 定义名为printf的函数 
function(printf str)
    message(${str})
endfunction()

# 使用
printf("hello function")
</code></pre> 
<p><img src="https://images2.imgbox.com/82/7f/ULwADvcI_o.png" alt=""></p> 
<h5><a id="3_204"></a>（3）宏与函数的区别</h5> 
<p>函数中的变量是局部的，宏中的变量是全局的，宏中的变量在外面也可以被访问到。</p> 
<pre><code># 定义名为func_printf的函数 
function(func_printf str)
    message(${str})
    set(func_var "1111111111")
endfunction()

# 定义名为macro_printf的宏 
macro(macro_printf str)
    message(${str})
    set(macro_var "222222222")
endmacro()

# 使用
func_printf("hello function")
message("func_var = ${func_var}")
macro_printf("hello macro")
message("macro_var = ${macro_var}")
</code></pre> 
<p><img src="https://images2.imgbox.com/6d/d6/iWDbiTLN_o.png" alt=""></p> 
<h4><a id="7cmake_230"></a>7、查看cmake命令说明</h4> 
<p>上面列举的语法知识中，我们并未介绍所用命令的格式及使用方式。各命令详细的解释可以通过如下方式查看。</p> 
<h5><a id="1cmake_234"></a>（1）查看所有cmake命令</h5> 
<pre><code>cmake --help-command-list
</code></pre> 
<p><img src="https://images2.imgbox.com/e8/17/KtKxYRtg_o.png" alt=""></p> 
<h5><a id="2_242"></a>（2）查看具体某个命令说明</h5> 
<p>比如，查看message命令说明：</p> 
<pre><code>cmake --help-command message
</code></pre> 
<p><img src="https://images2.imgbox.com/f0/a6/s49SMEuo_o.png" alt=""></p> 
<h3><a id="cmake_252"></a>cmake与构建</h3> 
<p>上一节分享了cmake的一些基本语法知识。这一节我们一起来看一下cmake与构建相关的内容。</p> 
<h4><a id="1_256"></a>1、几个常用命令</h4> 
<p>下面列出几个常用的命令，在我们下面的例子中会用到。</p> 
<h5><a id="1cmake_minimum_required_260"></a>（1）cmake_minimum_required</h5> 
<p>命令格式：</p> 
<pre><code>cmake_minimum_required(VERSION major.minor[.patch[.tweak]]
                        [FATAL_ERROR])
</code></pre> 
<p>用于指定需要的 CMake 的最低版本。</p> 
<p>使用示例：</p> 
<pre><code>cmake_minimum_required (VERSION 3.10)
</code></pre> 
<h5><a id="2project_277"></a>（2）project</h5> 
<p>命令格式：</p> 
<pre><code>project(&lt;PROJECT-NAME&gt; [LANGUAGES] [&lt;language-name&gt;...])
</code></pre> 
<p>用于指定项目的名称。</p> 
<p>使用示例：</p> 
<pre><code>project (hello)
</code></pre> 
<h5><a id="3add_executable_293"></a>（3）add_executable</h5> 
<p>命令格式：</p> 
<pre><code>add_executable(&lt;name&gt; [WIN32] [MACOSX_BUNDLE]
                [EXCLUDE_FROM_ALL]
                source1 [source2 ...])
</code></pre> 
<p>用于指定从一组源文件 source1 … 编译出一个可执行文件且命名为 name。</p> 
<p>使用示例：</p> 
<pre><code>add_executable(hello main.c)
</code></pre> 
<h5><a id="4aux_source_directory_311"></a>（4）aux_source_directory</h5> 
<p>命令格式：</p> 
<pre><code>aux_source_directory(&lt;dir&gt; &lt;variable&gt;)
</code></pre> 
<p>用于将 dir 目录下的所有源文件的名字保存在变量 variable 中。</p> 
<p>使用示例：</p> 
<pre><code>aux_source_directory(. DIR_SRCS)
</code></pre> 
<h5><a id="5add_subdirectory_327"></a>（5）add_subdirectory</h5> 
<p>命令格式：</p> 
<pre><code>add_subdirectory(source_dir [binary_dir]
                  [EXCLUDE_FROM_ALL])
</code></pre> 
<p>用于添加一个需要进行构建的子目录。</p> 
<p>使用示例：</p> 
<pre><code>add_subdirectory(Lib)
</code></pre> 
<h5><a id="6add_library_344"></a>（6）add_library</h5> 
<p>命令格式：</p> 
<pre><code>add_library(&lt;name&gt; INTERFACE [IMPORTED [GLOBAL]])
</code></pre> 
<p>用于指定从一组源文件中编译出一个库文件且命名为name。</p> 
<p>使用示例：</p> 
<pre><code>add_library(Lib ${DIR_SRCS})
</code></pre> 
<h5><a id="7target_link_libraries_360"></a>（7）target_link_libraries</h5> 
<p>命令格式：</p> 
<pre><code>target_link_libraries(&lt;target&gt; ... &lt;item&gt;... ...)
</code></pre> 
<p>用于指定 target 需要链接 item1 item2 …。</p> 
<p>使用示例：</p> 
<pre><code>target_link_libraries(hello Lib)
</code></pre> 
<h5><a id="8include_directories_376"></a>（8）include_directories</h5> 
<p>命令格式：</p> 
<pre><code>include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...])
</code></pre> 
<p>用于添加头文件路径。</p> 
<p>使用示例：</p> 
<pre><code>include_directories(include)
</code></pre> 
<h4><a id="2_392"></a>2、常用内置变量</h4> 
<h5><a id="1PROJECT_SOURCE_DIR_394"></a>（1）PROJECT_SOURCE_DIR</h5> 
<p>目前正在处理中的专案最上层目录，即内含 project() 指令的 CMakeLists 所在资料夹。</p> 
<h5><a id="2CMAKE_BUILD_TYPE_398"></a>（2）CMAKE_BUILD_TYPE</h5> 
<p>控制构建类型，可选值为：</p> 
<ul><li>None: 编译器默认值</li><li>Debug: 产生除错信息</li><li>Release: 进行最佳化</li><li>RelWithDebInfo: 进行最佳化，但仍然会启用 DEBUG flag</li><li>MinSizeRel: 进行程式码最小化</li></ul> 
<h5><a id="3CMAKE_C_FLAGS_408"></a>（3）CMAKE_C_FLAGS</h5> 
<p>C编译器的编译选项。</p> 
<h5><a id="4CMAKE_CXX_FLAGS_412"></a>（4）CMAKE_CXX_FLAGS</h5> 
<p>C++编译器的编译选项。</p> 
<h4><a id="3_416"></a>3、实例</h4> 
<h5><a id="1_418"></a>（1）基础实例</h5> 
<p><img src="https://images2.imgbox.com/ac/8f/NsCUAi41_o.png" alt=""></p> 
<p><strong>main.c：</strong></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello cmake\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>CMakeLists.txt：</strong></p> 
<pre><code>cmake_minimum_required (VERSION 3.10)
project (hello)
add_executable(hello main.c)
</code></pre> 
<p><img src="https://images2.imgbox.com/dc/61/prCcR2ia_o.png" alt=""></p> 
<h5><a id="2_444"></a>（2）多个文件、多个文件夹</h5> 
<p>上一个demo只有一个源文件，对应的CMakeLists.txt比较简单。下面看看有多个文件夹及文件的工程。</p> 
<p>基于上面的demo，修改工程如：</p> 
<p><img src="https://images2.imgbox.com/bf/0c/gf0dg0bg_o.png" alt=""></p> 
<p><strong>main.c：</strong></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"hello.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">print_hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>CMakeLists.txt：</strong></p> 
<pre><code>cmake_minimum_required (VERSION 3.10)
project (hello)

# 添加头文件路径
include_directories(include)

# 查找src目录下的所有源文件并将名称保存到 SRC_DIR_SRCS 变量中
aux_source_directory(src SRC_DIR_SRCS)

# 查找当前目录下的所有源文件并将名称保存到 CUR_DIR_SRCS 变量中
aux_source_directory(. CUR_DIR_SRCS)

# 从SRC_DIR_SRCS与CUR_DIR_SRCS中编译出可执行文件hello
add_executable(hello 
              ${SRC_DIR_SRCS}
              ${CUR_DIR_SRCS}
              )
</code></pre> 
<p>编译、运行：</p> 
<pre><code>cd build
cmake ..
make
./hello
</code></pre> 
<p><img src="https://images2.imgbox.com/83/e0/ROgOybpP_o.png" alt=""></p> 
<h5><a id="3_497"></a>（3）编译静态库</h5> 
<p>基于demo2，我们把src文件夹下的源文件编译成静态库，再由main.c调用。工程目录基本不变，需要在src下新增一个CMakeLists.txt文件，其内容如：</p> 
<pre><code># 查找当前目录下的所有源文件并将名称保存到 DIR_LIB_SRCS 变量
aux_source_directory(. DIR_LIB_SRCS)

# 生成链接库
add_library (print_hello ${DIR_LIB_SRCS})
</code></pre> 
<p>根目录下的CMakeLists.txt修改为：</p> 
<pre><code>cmake_minimum_required (VERSION 3.10)
project (hello)

# 添加头文件路径
include_directories(include)

# 查找当前目录下的所有源文件并将名称保存到 CUR_DIR_SRCS 变量中
aux_source_directory(. CUR_DIR_SRCS)

# 添加 src 子目录
add_subdirectory(src)

# 从CUR_DIR_SRCS中编译出可执行文件hello
add_executable(hello 
              ${CUR_DIR_SRCS}
              )

# 添加链接库
target_link_libraries(hello print_hello)
</code></pre> 
<p>编译、运行：</p> 
<pre><code>cd build
cmake ..
make
./hello
</code></pre> 
<p><img src="https://images2.imgbox.com/24/d5/jtWvY7ds_o.png" alt=""></p> 
<h5><a id="4_544"></a>（4）编译动态库</h5> 
<p>编译动态库的方式与编译动态库的方式差不多。基于上面的demo3，只需修改src文件夹下的CMakeLists.txt为：</p> 
<pre><code># 查找当前目录下的所有源文件并将名称保存到 DIR_LIB_SRCS 变量
aux_source_directory(. DIR_LIB_SRCS)

# 生成动态库
add_library (print_hello SHARED ${DIR_LIB_SRCS})
</code></pre> 
<p>编译、运行：</p> 
<pre><code>cd build
cmake ..
make
./hello
</code></pre> 
<p><img src="https://images2.imgbox.com/40/84/kjETTuFf_o.png" alt=""></p> 
<h4><a id="4gdb_567"></a>4、支持gdb调试</h4> 
<p>上面工程中根目录加上如下命令可支持gdb调试：</p> 
<pre><code>set(CMAKE_BUILD_TYPE "Debug")
set(CMAKE_CXX_FLAGS_DEBUG "$ENV{CXXFLAGS} -O0 -Wall -g -ggdb")
set(CMAKE_CXX_FLAGS_RELEASE "$ENV{CXXFLAGS} -O0 -Wall")
</code></pre> 
<p>以上就是本次的分享。如果觉得文章有用，欢迎收藏、转发！</p> 
<p>相关资料：</p> 
<p>https://www.hahack.com/codes/cmake/</p> 
<p>https://preshing.com/20170522/learn-cmakes-scripting-language-in-15-minutes/</p> 
<p>https://cmake.org/</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/67f43541c60b37a3d87e1e90b2176125/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java -jar参数详解：掌握Java可执行JAR文件的运行技巧</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dd3b166201b8cc35f6ad7c89e88c6162/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux复习资料</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>