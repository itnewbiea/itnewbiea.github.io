<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43;  1.指针和结构体 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43;  1.指针和结构体" />
<meta property="og:description" content="一、指针运算符
C&#43;&#43; 提供了两种指针运算符，一种是取地址运算符 &amp;，一种是间接寻址运算符 *
&amp; 是一元运算符，返回操作数的内存地址。例如，如果 var 是一个整型变量，则 &amp;var 是它的地址。该运算符与其他一元运算符具有相同的优先级，在运算时它是从右向左顺序进行的。 &amp; 运算符读作&#34;取地址运算符&#34;，这意味着，&amp;var 读作&#34;var 的地址&#34;。
间接寻址运算符 *，它是 &amp; 运算符的补充。* 是一元运算符，返回操作数所指定地址的变量的值。
箭头运算符与点运算符有关，对于一个指针ptr，表达式ptr-&gt;mem等价于(*ptr).mem；
string s1 = &#34;a string&#34;,*p = &amp;s1; auto n = s1.size();//运行string对象s1的size()成员 n = (*p).size();//运行p所指对象的size成员 n = p-&gt;size(;)//等价于(*p).size //点运算符针对对象和对象的成员，箭头运算符针对的是指针和成员； #include &lt;iostream&gt; using namespace std; int main () { int var; int *ptr; int val; var = 3000; // 获取 var 的地址 ptr = &amp;var;//ptr存放取出来的地址 // 获取 ptr 的值 val = *ptr;//*寻找地址的内容，存放在val中 cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2c64501ccca73ef6ce6c56583d6445f6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-12-03T10:44:23+08:00" />
<meta property="article:modified_time" content="2019-12-03T10:44:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;  1.指针和结构体</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、指针运算符</p> 
<p>C++ 提供了两种指针运算符，一种是取地址运算符 &amp;，一种是间接寻址运算符 *</p> 
<p><span style="color:#f33b45;">&amp; 是一元运算符</span>，返回操作数的内存地址。例如，如果 var 是一个整型变量，则 &amp;var 是它的地址。该运算符与其他一元运算符具有相同的优先级，在运算时它是从右向左顺序进行的。 &amp; 运算符读作<strong>"取地址运算符"</strong>，这意味着，<strong>&amp;var</strong> 读作"var 的地址"。</p> 
<p><span style="color:#f33b45;">间接寻址运算符 *</span>，它是 &amp; 运算符的补充。* 是一元运算符，返回操作数所指定地址的变量的值。</p> 
<p>箭头运算符与点运算符有关，对于一个指针ptr，表达式ptr-&gt;mem等价于(*ptr).mem；</p> 
<pre class="has"><code class="language-cpp">string s1 = "a string",*p = &amp;s1;
auto n = s1.size();//运行string对象s1的size()成员
n = (*p).size();//运行p所指对象的size成员
n = p-&gt;size(;)//等价于(*p).size
//点运算符针对对象和对象的成员，箭头运算符针对的是指针和成员；</code></pre> 
<pre class="has"><code class="language-cpp">#include &lt;iostream&gt;
 
using namespace std;
 
int main ()
{
   int  var;
   int  *ptr;
   int  val;

   var = 3000;

   // 获取 var 的地址
   ptr = &amp;var;//ptr存放取出来的地址

   // 获取 ptr 的值
   val = *ptr;//*寻找地址的内容，存放在val中

   cout &lt;&lt; "Value of var :" &lt;&lt; var &lt;&lt; endl;
   cout &lt;&lt; "Value of ptr :" &lt;&lt; ptr &lt;&lt; endl;
   cout &lt;&lt; "Value of val :" &lt;&lt; val &lt;&lt; endl;

   return 0;
}

//编译结果
Value of var :3000
Value of ptr :0xbff64494
Value of val :3000</code></pre> 
<p> </p> 
<p>二、typedef struct和struct</p> 
<p>（此处博客链接<a href="https://www.cnblogs.com/qyaizs/articles/2039101.html" rel="nofollow">https://www.cnblogs.com/qyaizs/articles/2039101.html</a>以及参考c语言中文网）</p> 
<p>1.在<span style="color:#f33b45;">C</span>中定义一个结构体类型要用typedef:<br> 　　　　<strong>typedef struct Student</strong><br><strong>　　　　{<!-- --></strong><br><strong>　　　　int a;</strong><br><strong>　　　　}Stu;</strong><br> 　　　　于是在声明变量的时候就可：Stu stu1;(<span style="color:#f33b45;">如果没有typedef就必须用struct Student stu1;来声明</span>)　</p> 
<p>             这里的Stu实际上就是struct Student的别名。<strong>Stu==struct Student</strong><br> 　　　　另外这里也可以不写Student（于是也不能struct Student stu1;了，必须是Stu stu1;）</p> 
<p> </p> 
<p> c语言使用例子：</p> 
<p><span style="color:#f33b45;">（char* 是声明一个字符类型的指针。比如：chat*  y；就是声明一个指针y，这个指针指向的地址上只能存放字符类型的值。</span></p> 
<p><span style="color:#f33b45;">指针即为地址，指针几个字节跟语言无关，而是跟系统的寻址能力有关。比如以前是16位系统，指针即为2个字节，现在一般是32位系统，所以是4个字节）</span></p> 
<p>如果只需要 stu1、stu2 两个变量，后面不需要再使用结构体名定义其他变量，那么在定义时也可以不给出结构体名，如下所示：</p> 
<pre class="has"><code class="language-cpp">struct{  //没有写 stu
    char *name;  //姓名
    int num;  //学号
    int age;  //年龄
    char group;  //所在学习小组
    float score;  //成绩
} stu1, stu2;
//这样做书写简单，但是因为没有结构体名，后面就没法用该结构体定义新的变量

struct stu{
    char *name;  //姓名
    int num;  //学号
    int age;  //年龄
    char group;  //所在学习小组
    float score;  //成绩
} stu1, stu2;
//声明一个变量用 struct stu stu1
</code></pre> 
<pre class="has"><code class="language-cpp">#include &lt;stdio.h&gt;
int main(){
    struct{
        char *name;  //姓名
        int num;  //学号
        int age;  //年龄
        char group;  //所在小组
        float score;  //成绩
    } stu1;
    //给结构体成员赋值
    stu1.name = "Tom";
    stu1.num = 12;
    stu1.age = 18;
    stu1.group = 'A';
    stu1.score = 136.5;
    //读取结构体成员的值
    printf("%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！\n", stu1.name, stu1.num, stu1.age, stu1.group, stu1.score);
    return 0;
}

//也可以在定义时整体赋值
struct{
    char *name;  //姓名
    int num;  //学号
    int age;  //年龄
    char group;  //所在小组
    float score;  //成绩
} stu1, stu2 = { "Tom", 12, 18, 'A', 136.5 };</code></pre> 
<p>   但在<span style="color:#f33b45;">c++</span>里很简单，直接<br> 　　　　<strong>struct Student</strong><br><strong>　　　　{<!-- --></strong><br><strong>　　　　int a;</strong><br><strong>　　　　};</strong>　　　　<br> 　　　　于是就定义了结构体类型Student，声明变量时直接Student stu2；</p> 
<p>c++使用</p> 
<pre class="has"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
 
using namespace std;
 
// 声明一个结构体类型 Books 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
int main( )
{
   Books Book1;        // 定义结构体类型 Books 的变量 Book1
   Books Book2;        // 定义结构体类型 Books 的变量 Book2
 
   // Book1 详述
   strcpy( Book1.title, "C++ 教程");
   strcpy( Book1.author, "Runoob"); 
   strcpy( Book1.subject, "编程语言");
   Book1.book_id = 12345;
 
   // Book2 详述
   strcpy( Book2.title, "CSS 教程");
   strcpy( Book2.author, "Runoob");
   strcpy( Book2.subject, "前端技术");
   Book2.book_id = 12346;
 
   // 输出 Book1 信息
   cout &lt;&lt; "第一本书标题 : " &lt;&lt; Book1.title &lt;&lt;endl;
   cout &lt;&lt; "第一本书作者 : " &lt;&lt; Book1.author &lt;&lt;endl;
   cout &lt;&lt; "第一本书类目 : " &lt;&lt; Book1.subject &lt;&lt;endl;
   cout &lt;&lt; "第一本书 ID : " &lt;&lt; Book1.book_id &lt;&lt;endl;
 
   // 输出 Book2 信息
   cout &lt;&lt; "第二本书标题 : " &lt;&lt; Book2.title &lt;&lt;endl;
   cout &lt;&lt; "第二本书作者 : " &lt;&lt; Book2.author &lt;&lt;endl;
   cout &lt;&lt; "第二本书类目 : " &lt;&lt; Book2.subject &lt;&lt;endl;
   cout &lt;&lt; "第二本书 ID : " &lt;&lt; Book2.book_id &lt;&lt;endl;
 
   return 0;
}</code></pre> 
<p>2.</p> 
<p>在c++中如果用typedef的话，又会造成区别：<br> 　　　　<strong>struct   Student  </strong><br><strong>　　　　{  </strong><br><strong>　　　　int   a;  </strong><br><strong>　　　　}stu1;//</strong>stu1是一个变量  </p> 
<p> <br> 　　　　<strong>typedef   struct   Student2  </strong><br><strong>　　　　{  </strong><br><strong>　　　　int   a;  </strong><br><strong>　　　　}stu2;</strong>//stu2是一个结构体类型=struct Student  </p> 
<p> <br> 　　　　使用时可以直接访问stu1.a<br> 　　　　但是stu2则必须先   stu2 s2;<br> 　　　　然后               s2.a=10;</p> 
<p>3.<span style="color:#f33b45;">结构体是一种自定义的数据类型，是创建变量的模板，不占用内存空间；结构体变量才包含了实实在在的数据，需要内存空间来存储</span></p> 
<p>4.理论上讲结构体的各个成员在内存中是连续存储的，和数组非常类似，例如上面的结构体变量 stu1、stu2 的内存分布如下图所示，共占用 4+4+4+1+4 = 17 个字节</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/b3/52/gun269jO_o.jpg"></p> 
<p>但是在编译器的具体实现中，各个成员之间可能会存在缝隙，对于 stu1、stu2，成员变量 group 和 score 之间就存在 3 个字节的空白填充（见下图）。这样算来，stu1、stu2 其实占用了 17 + 3 = 20 个字节。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/16/c8/CvnaDSEW_o.png"></p> 
<p>三、指向结构体的指针</p> 
<p><span style="color:#f33b45;">结构体变量的指针就是该变量那个所占据的内存段的起始地址</span>。可以设一个指针变量，来指向一个结构体变量，此时该指针变量的值是结构体变量的起始地址</p> 
<p> </p> 
<p>创建的对象 stu 在栈上分配内存，需要使用 <code>&amp; </code>获取它的地址，例如：Student stu;Student *pStu = &amp;stu;</p> 
<p>pStu 是一个指针，它指向 Student 类型的数据，也就是通过 Student 创建出来的对象</p> 
<p> </p> 
<p>你也可以在堆上创建对象，这个时候就需要使用前面讲到的<code>new</code>关键字：</p> 
<p>          Student *pStu = new Student;</p> 
<p>在栈上创建出来的对象都有一个名字，比如 stu，使用指针指向它不是必须的。但是通过 new 创建出来的对象就不一样了，它在堆上<span style="color:#f33b45;">分配内存</span>，没有名字，<span style="color:#f33b45;">只能得到一个指向它的指针</span>，所以必须使用一个指针变量来接收这个指针，否则以后再也无法找到这个对象了，更没有办法使用它。也就是说，使用 <span style="color:#f33b45;">new 在堆上创建出来的对象是匿名的，没法直接使用，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。</span></p> 
<p>栈内存是程序自动管理的，不能使用 delete 删除在栈上创建的对象；堆内存由程序员管理，对象使用完毕后可以通过 delete 删除。在实际开发中，new 和 delete 往往成对出现，以保证及时删除不再使用的对象，防止无用内存堆积</p> 
<p>有了对象指针后，可以通过箭头<code>-&gt;</code>来访问对象的成员变量和成员函数，这和通过<a href="http://c.biancheng.net/view/246.html" rel="nofollow">结构体指针</a>(<a href="http://c.biancheng.net/view/246.html" rel="nofollow">http://c.biancheng.net/view/246.html</a>)来访问它的成员类似，请看下面的示例：</p> 
<pre class="has"><code class="language-cpp">pStu -&gt; name = "小明";
pStu -&gt; age = 15;
pStu -&gt; score = 92.5f;
pStu -&gt; say();
//完整例子
#include &lt;iostream&gt;
using namespace std;
class Student{
public:
    char *name;
    int age;
    float score;
    void say(){
        cout&lt;&lt;name&lt;&lt;"的年龄是"&lt;&lt;age&lt;&lt;"，成绩是"&lt;&lt;score&lt;&lt;endl;
    }
};
int main(){
    Student *pStu = new Student;
    pStu -&gt; name = "小明";
    pStu -&gt; age = 15;
    pStu -&gt; score = 92.5f;
    pStu -&gt; say();
    delete pStu;  //删除对象
    return 0;
}</code></pre> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bc23082692bb86483fe7a72d5bcd5b4e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Access to XMLHttpRequest at &#39;http://localhost:8080/api/login&#39; from origin &#39;http://localhost:8080&#39;</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/612cce40ab5460870e01f08218d31854/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Duplicate keys detected: &#39;3&#39;. This may cause an update error.</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>