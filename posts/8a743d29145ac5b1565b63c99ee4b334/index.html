<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>(主机)ARP表(ip/mac)、(交换机)交换/转发/MAC表(mac端口 同一网段)、(路由器)路由表(不同网段) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="(主机)ARP表(ip/mac)、(交换机)交换/转发/MAC表(mac端口 同一网段)、(路由器)路由表(不同网段)" />
<meta property="og:description" content="reference
转发表(Forwarding Table)
MAC地址
以太网地址或物理地址
它是一个用于确认网络设备位置的地址
每个网络设备(如网络适配器(Network Adapter)，
即网卡(Network Interface Card, NIC))都有世上唯一的MAC地址，
一台设备若有多张网卡，
则每个网卡都必须具有一个唯一的MAC地址，
这个是在网络设备出厂时由厂商烧制确定。
工作流
转发表，又称MAC表–交换表
交换机就是根据转发表来转发数据帧的。
维护记录着局域网主机端口MAC地址与交换机端口对应的表，
交换机就是根据这张表负责将数据帧传输到指定的主机端口上的。
步骤如下：
主机A会将一个源MAC地址为本机网卡物理地址，
目的MAC地址为主机B网卡物理地址的数据帧发送给交换机1；
交换机收到此数据帧后，
首先将数据帧中的源MAC地址和对应的输入端口0
记录到交换机维护的MAC地址表中；
然后交换机会检查自己的MAC地址表中
是否有数据帧中的目的MAC地址的信息，
如果有，则从MAC地址表中记录的对应端口发送出去，
如果没有，则会将此数据帧从非接收端口的所有端口发送出去，
这里仅从端口1发出；
这时，局域网的所有主机(通过交换机相连的全部主机)
都会收到此数据帧，
但是只有主机B收到此数据帧时会响应这个广播帧，
并回应一个数据帧
(这个回应由什么机制确定的，需要再查资料确定一下～TCP的ACK包？)，
此数据帧中包括主机B网络设备的MAC地址；
当交换机收到主机B回应的数据帧后，
也会记录数据帧中的源MAC地址，
即主机B网络设备的MAC地址，
这时，再当主机A和主机B相互通信时，
交换机就根据MAC地址表中的记录，实现单播了，
一趟转发流程实际交换机就“学习”到了两个转发表条目。
小结
从以上两幅图可以看出，
交换机具有动态自学习源MAC地址与物理端口映射的功能，
并且交换机的一个端口可以对应多个MAC地址，
但是一个MAC地址只能对应一个端口。
ARP表(Address Resolution Table)
首先明确一点，
在以太网环境下，
同一个网段的主机之间需要知道对方的MAC地址，
(通过交换机相连的节点处于同一网段)
才能进行通信。
了解到交换机是根据MAC寻址，
查表确认输出端口以完成本节点转发任务的。
看到这里其实应该可以抛出从一开始就被我们忽视了的问题：
在初始构造数据包准备发送时，
源主机究竟要如何获得目的主机网络设备MAC地址的呢？
这时，就需要使用到ARP协议。
在网络拓扑中的每个节点或说主机上， 实际都维护有一张ARP表，
它记录着主机的IP地址(网络地址)到MAC地址(物理地址)的映射关系。
ARP协议，
即地址解析协议，它是一个网络层协议，
运行在各网络节点上，负责完成主机IP地址到MAC地址的映射。
工作流" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8a743d29145ac5b1565b63c99ee4b334/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-25T20:22:43+08:00" />
<meta property="article:modified_time" content="2020-10-25T20:22:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">(主机)ARP表(ip/mac)、(交换机)交换/转发/MAC表(mac端口 同一网段)、(路由器)路由表(不同网段)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><a href="https://m.wenda.so.com/q/1514289198211662" rel="nofollow">reference</a><br> <strong>转发表(Forwarding Table)</strong><br> <strong>MAC地址</strong></p> 
<blockquote> 
 <p>以太网地址或物理地址<br> 它是一个用于确认网络设备位置的地址</p> 
</blockquote> 
<p>每个网络设备(如网络适配器(Network Adapter)，<br> 即网卡(Network Interface Card, NIC))都有世上唯一的MAC地址，</p> 
<p>一台设备若有多张网卡，<br> 则每个网卡都必须具有一个唯一的MAC地址，<br> 这个是在网络设备出厂时由厂商烧制确定。</p> 
<p><strong>工作流</strong><br> <strong>转发表，又称MAC表</strong>–交换表</p> 
<blockquote> 
 <p><strong>交换机</strong>就是根据转发表来<strong>转发数据帧</strong>的。</p> 
</blockquote> 
<p>维护记录着<strong>局域网主机端口MAC地址与交换机端口</strong>对应的表，<br> 交换机就是根据这张表负责<strong>将数据帧传输到指定的主机端口</strong>上的。<br> <img src="https://images2.imgbox.com/41/dd/h6El2LuS_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/d3/59/Aca78x9T_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/17/2a/1FpYUaxQ_o.png" alt="在这里插入图片描述">步骤如下：</p> 
<blockquote> 
 <p>主机A会将一个源MAC地址为本机网卡物理地址，<br> 目的MAC地址为主机B网卡物理地址的数据帧发送给交换机1；</p> 
</blockquote> 
<blockquote> 
 <p>交换机收到此数据帧后，<br> <strong>首先将数据帧中的源MAC地址和对应的输入端口0</strong><br> <strong>记录到交换机维护的MAC地址表中；</strong></p> 
</blockquote> 
<blockquote> 
 <p>然后交换机会检查自己的MAC地址表中<br> <strong>是否有数据帧中的目的MAC地址的信息，</strong><br> 如果有，则从MAC地址表中记录的对应端口发送出去，<br> <strong>如果没有，则会将此数据帧从非接收端口的所有端口发送出去，</strong><br> 这里仅从端口1发出；</p> 
</blockquote> 
<blockquote> 
 <p><strong>这时，局域网的所有主机(通过交换机相连的全部主机)</strong><br> <strong>都会收到此数据帧，</strong><br> 但是<em>只有主机B收到此数据帧时会响应这个广播帧</em>，<br> <em>并回应一个数据帧</em><br> (这个回应由什么机制确定的，需要再查资料确定一下～TCP的ACK包？)，<br> <strong>此数据帧中包括主机B网络设备的MAC地址；</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>当交换机收到主机B回应的数据帧后，</strong><br> <strong>也会记录数据帧中的源MAC地址，</strong><br> 即主机<strong>B网络设备的MAC地址</strong>，<br> 这时，再当主机A和主机B相互通信时，<br> <strong>交换机</strong>就根据<strong>MAC地址表中的记录</strong>，<strong>实现单播了，</strong><br> <em>一趟转发流程实际交换机就“学习”到了两个转发表条目。</em></p> 
</blockquote> 
<p><strong>小结</strong></p> 
<blockquote> 
 <p>从以上两幅图可以看出，<br> <strong>交换机具有动态自学习源MAC地址与物理端口映射的功能，</strong><br> 并且交换机的一个端口可以对应多个MAC地址，<br> <strong>但是一个MAC地址只能对应一个端口。</strong></p> 
</blockquote> 
<hr> 
<p><strong>ARP表(Address Resolution Table)</strong><br> 首先明确一点，<br> <strong>在以太网环境下，</strong><br> <strong>同一个<em>网段</em>的主机之间需要知道对方的MAC地址，</strong><br> <s>(通过交换机相连的节点处于同一网段)</s><br> 才能进行通信。</p> 
<blockquote> 
 <p><strong>了解到交换机是根据MAC寻址，</strong><br> <strong>查表确认输出端口以完成本节点转发任务的。</strong><br> 看到这里其实应该可以抛出从一开始就被我们忽视了的问题：<br> <em>在初始构造数据包准备发送时，</em><br> <strong>源主机究竟要如何获得目的主机网络设备MAC地址的呢？</strong></p> 
</blockquote> 
<blockquote> 
 <p>这时，就需要使用到ARP协议。<br> <strong>在网络拓扑中的每个节点或说主机上，</strong> <em>实际都维护有一张ARP表，</em><br> <strong>它记录着主机的IP地址(网络地址)到MAC地址(物理地址)的映射关系。</strong><br> ARP协议，<br> 即地址解析协议，<strong>它是一个网络层协议，</strong><br> 运行在各网络节点上，<strong>负责完成主机IP地址到MAC地址的映射。</strong></p> 
</blockquote> 
<p><strong>工作流</strong><br> 接下来根据下图，详细讲解一下ARP协议的工作原理：<br> <img src="https://images2.imgbox.com/67/e6/9Hv7pWg2_o.png" alt="在这里插入图片描述">步骤如下：</p> 
<blockquote> 
 <p><strong>如果主机A想发送数据包给同一网段内的另一台主机B(通过交换机相连的节点处于同一网段)，</strong><br> <strong>很明显，A的用户应用程序要么已经知道B的IP地址，</strong><br> <strong>或者说域名(Domain Name，DNS协议会完成主机名到IP地址的映射</strong>，这里不是重点)，<br> 那么<strong>主机A首先会检查自己的ARP缓存表(ARPCache)，</strong><br> 查看是否有<strong>主机B的IP地址与其MAC地址的对应关系，</strong><br> 如果有，则<strong>直接将主机B网络设备的MAC地址作为目的MAC地址封装到数据帧中，</strong><br> 无需进一步操作即获取到数据帧封装所需的全部信息，<br> 此后完成封装并发送数据帧到目的MAC地址。</p> 
</blockquote> 
<blockquote> 
 <p>如果没有，主机A则会发送一个ARP请求信息(ARPRequest)，<br> <strong>请求的目的IP地址是主机B的IP地址，</strong><br> 目的MAC地址是MAC层的广播地址(即ff:ff:ff:ff:ff:ff)，<br> <strong>源IP地址和MAC地址是主机A的IP地址及其MAC地址；</strong><br> <strong>当交换机接收到此数据帧之后，发现此帧是广播帧，</strong><br> 因此，<strong>会将此数据帧从非接收的所有端口发送出去；</strong></p> 
</blockquote> 
<blockquote> 
 <p>同一网段中的所有节点都会接收到该ARP请求数据包，<br> 目的IP不匹配的节点会直接忽略该请求，<br> <strong>而当主机B接收到此数据帧后，</strong><br> <strong>解析到IP地址与自己的IP地址一致，</strong><br> 先将<strong>主机A的IP地址及其MAC地址的对应关系</strong><br> <strong>记录到自己的ARP缓存表中</strong>，<br> 同时会发送一个<strong>ARP应答(ARPResponse)，</strong><br> <strong>应答数据包源MAC地址即主机B自身网络设备的MAC地址，</strong><br> 该应答通过交换机转发至主机A；<br> 主机A在收到这个回应的数据帧之后，<br> <strong>在自己的ARP缓存表</strong>中记录<br> 主机B的IP地址和MAC地址的对应关系。<br> 而此时主机A已经可以继续封装准备发往主机B的数据帧，<br> <strong>而交换机也已经学习到了<br> 主机A和主机B的MAC地址与其端口的对应关系</strong>，<br> <strong>之后主机A发送的数据帧通过交换机转发至主机B。</strong></p> 
</blockquote> 
<p>这里有一点值得注意的是传输过程中IP地址与MAC的地址的变化问题：<br> ？？？？？</p> 
<blockquote> 
 <p>MAC地址在同一个广播域中传播时始终不变，<br> <strong>但在跨越广播域(即经过路由器)时，</strong><br> 会由于重新封装而改变，<br> 源MAC地址将变为路由器的输出端口的MAC地址，<br> 目的MAC地址随网络拓扑实际情况而定，</p> 
</blockquote> 
<blockquote> 
 <p>若路由器与目的主机所在网段直连，<br> 此时目的MAC地址就是目的主机的MAC地址；<br> 而不管是源IP地址还是目的IP地址，<br> 在数据包传输过程中都始终不会改变。</p> 
</blockquote> 
<p><strong>小结</strong></p> 
<blockquote> 
 <p><strong>网络中每个节点都会通过运行ARP协议</strong><br> <strong>而维护节点内部的一张ARP缓存表，<br> 用于完成从IP地址到MAC地址的映射</strong>，<br> <strong>在发送数据之前往往会先查询本地ARP表中对应目的IP地址的MAC地址，</strong><br> 若没<strong>没有表项则会发起ARP广播请求直至获取对应主机响应并发来应答</strong>，<br> <strong>将该应答中包含的目的IP地址与MAC地址的映射关系<br> 添加到ARP缓存表之后，</strong><br> <strong>在数据链路层就可以以该MAC地址为目的MAC地址封装数据帧并发送。</strong><img src="https://images2.imgbox.com/8f/af/OhIoDnU6_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/28/19/JmBjWkhO_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/fe/a9/QHeKCZDc_o.png" alt="在这里插入图片描述"><strong>路由表(Routing Table)</strong></p> 
<p>IP地址</p> 
<blockquote> 
 <p>IP地址(Internet Protocol Address)，<br> 即互联网协议地址，<strong>也称为网络层地址或主机地址，</strong><br> 是分配给网络上的各个网络设备的地址。</p> 
</blockquote> 
<blockquote> 
 <p>现在流行的IP协议有两个版本：<br> IPv4(Internet Protocol Version 4) 和IPv6(Internet Protocol Version 6)。</p> 
 <p><strong>其中，IPv4地址为32位，</strong><br> <strong>即4个字节，为便于使用，</strong> 常以<strong>xxx.xxx.xxx.xxx</strong><br> 每个字节8位从二进制表示为十进制数， 这种表示方法称为点分十进制，<br> <strong>地址可分为A、B、C、D、E五大类，</strong><br> 32位全为1的IP地址： 255.255.255.255<br> 称为“受限广播地址” (Limited Broadcasr Destination Address)，<br> 用于将一个分组以广播方式发送给本网络中的所有主机，<br> 路由器则阻挡该分组通过，将其广播功能限制在本网内部，<br> 因此可以说路由器隔离了广播域(交换机隔离了冲突域)。</p> 
</blockquote> 
<blockquote> 
 <p>随着网络规模和节点数量的不断扩展，<br> 出于32位的IPv4将很快被分配使用殆尽的担忧，<br> 又推出了IPv6地址，128位，16个字节，<br> 通常每4位表示为一个16进制数，16个字节分为8组，<br> 每组包含2个字节即4个16进制数，<br> 组与组之间以冒号分割：<br> <strong>ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff为IPv6协议下的广播地址。</strong></p> 
</blockquote> 
<p>IP VS MAC</p> 
<blockquote> 
 <p><strong>MAC地址和IP地址本质都是网络设备物理端口的性质，</strong><br> <strong>都可用于寻址网络设备</strong>，<br> 但如果它们功能类似，仅是工作的层次不同的话，<br> 两者之间应该可以通过某种机制实现相互替换，<br> 但为什么它们能共存至今呢？</p> 
</blockquote> 
<blockquote> 
 <p>对于MAC地址和IP地址的比较，<br> 有人曾这么比喻：一个人已经有了手机号(IP地址)，<br> <strong>为什么还要有身份证号呢(MAC地址)？</strong><br> 身份证号是一个人的唯一标识号，只要有这个号码就能找到该人，<br> 但是为啥他的朋友们不用身份证号来寻找该人而用手机号呢？<br> <strong>对，因为方便。</strong></p> 
</blockquote> 
<blockquote> 
 <p>但是如果该人犯罪，警察用手机号呼叫寻找该人，傻子才会接吧…<br> <strong>而且换了号码怎么办？</strong><br> <strong>那不就得用你的身份证号在全国发布通缉令ip</strong>，<br> 利用身份证号在全国各种系统范围(消费、社交、医疗)内<br> 搜索该人的记录，<br> 才能最终定位该人实施有效逮捕嘛。</p> 
</blockquote> 
<blockquote> 
 <p>上述例子实际就契合了两种地址存在的意义：<br> <strong>IP地址是逻辑地址，</strong><br> 根据网络协议，<br> <strong>在不同的地理位置加入互联网</strong>，<br> <strong>就会分配到完全不同的IP地址(DHCP动态分配IP地址)</strong>，<br> <strong>但由于属于网络层，</strong><br> 相对较高的抽象层次设计的初衷就是为了简化通信，方便使用，<br> <strong>尤其对于用户进程而言；</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>MAC地址是物理地址，工作在数据链路层，</strong><br> 一旦出厂时由厂商确定并烧制入网络设备的EPROM中，<br> 就具有了固定的全球唯一的地址，<br> 任何时候任何条件都不会改变，<br> 虽说使用起来不太方便，<br> <strong>且描述的是较低层的数据链路通信细节，</strong><br> <strong>但在任何时候都可用于数据通信寻址。</strong></p> 
</blockquote> 
<blockquote> 
 <p>更严谨完善的解释如下：<br> 问题：<br> 既然每个以太网设备在出厂时<strong>都有一个唯一的MAC地址了，</strong><br> 那为什么<strong>还需要为每台主机再分配一个IP地址呢？</strong><br> 或者说为什么每台主机都分配唯一的IP地址了，<br> 为什么还要在网络设备（如网卡，集线器，路由器等）<br> 生产时内嵌一个唯一的MAC地址呢？<br> 解答：主要原因基于以下几点：<br> （1）<br> <strong>IP地址的分配是根据网络的拓扑结构，<br> 而不是根据谁制造了网络设置。</strong><br> 若将高效的路由选择方案建立在<strong>设备制造商的基础上</strong><br> 而不是网络所处的拓扑位置基础上，这种方案是不可行的；<br> （2）<br> 当存在一个附加层的地址寻址时，设备更易于移动和维修。<br> 例如，<strong>如果一个以太网卡坏了，可以被更换</strong>，<br> <strong>而无须取得一个新的IP地址。</strong><br> 如果<strong>一个IP主机从一个网络移到另一个网络，<br> 可以给它一个新的IP地址，而无须换一个新的网卡；</strong><br> （3）<br> 无论是局域网，<br> 还是广域网中的计算机之间的通信，<br> 最终都表现为将数据包从某种形式的链路上的初始节点出发，<br> 从一个节点传递到另一个节点，最终传送到目的节点。<br> <strong>数据包在这些节点之间的移动<br> 都是由ARP协议负责将IP地址映射到MAC地址上来完成的。</strong></p> 
</blockquote> 
<p>下面再通过一个例子看看IP地址和MAC地址<br> 是怎样结合起来传送数据包的：</p> 
<blockquote> 
 <p>假设网络上要将 一个数据包（名为PAC）<br> 由北京的一台主机（名称为A，IP地址为IP_A，MAC地址为MAC_A）<br> 发送到<br> 纽约的一台主机（名称为B，IP地址为IP_B，MAC地址为MAC_B）。</p> 
</blockquote> 
<blockquote> 
 <p>这两台主机之间不太可能是直连起来的，<br> 因而数据包在传递时<br> 必然要经过许多中间节点(如路由器，网关服务器等)，<br> 假定在传输过程中要经过C1、C2、C3<br> (其输入、输出端口的<br> MAC地址分别为M1_In/M1_Out，M2_In/M2_Out，M3_In/M3_Out)三个节点。</p> 
</blockquote> 
<blockquote> 
 <p>A在将PAC发出之前，先发送一个ARP请求，<br> 找到其要到达IP_B所必须经历的第一个中间节点C1的到达端口MAC地址M1_In，<br> 然后在其数据包中封装地址：IP_A、IP_B，MAC_A和M1_In。<br> 当PAC传到C1后，再由ARP根据其目的IP地址IP_B，<br> 找到其要经历的第二个中间节点C2的到达端口MAC地址M2_In，<br> 然后再封装目的MAC地址为M2_Out的数据包传送到C2。</p> 
</blockquote> 
<blockquote> 
 <p>如此类推，<br> 直到最后找到IP地址为IP_B的B主机的MAC地址MAC_B，<br> 最终传送给主机B。<br> 在传输过程中，数据包源IP地址IP_A、目的IP地址IP_B不变，<br> 而源MAC地址和目的MAC地址，<br> 由于中间节点重新封装数据帧而不断改变，<br> 直至目的地址MAC地址为MAC_B，<br> 数据包最终到达目的主机B。</p> 
</blockquote> 
<p>综上所述，<br> <strong>IP地址和MAC地址相同点是它们都可以作为设备地址标识，</strong><br> 不同则主要体现以下几个方面：</p> 
<blockquote> 
 <p><strong>对于网络上的某一设备，<br> 如一台计算机或一台路由器，其IP地址可变（但必须唯一），<br> 而MAC地址不可变。</strong><br> 我们可以根据<strong>需要给一台主机指定任意的IP地址，</strong><br> 如我们可以给局域网上的<strong>某台计算机分配IP地址为192.168.0.112 ，</strong><br> 也可以将它改成192.168.0.200。<br> <strong>而任一网络设备（如网卡，路由器）一旦生产出来以后，<br> 其MAC地址永远唯一且不能由用户改变；</strong></p> 
</blockquote> 
<blockquote> 
 <p>长度不同。IP地址为32位4字节，MAC地址为48位6字节；</p> 
</blockquote> 
<blockquote> 
 <p>分配依据不同。<br> IP地址的分配是基于网络拓朴，<br> MAC地址的分配是基于制造商；</p> 
</blockquote> 
<blockquote> 
 <p>寻址协议层不同。<br> IP地址应用于OSI第三层，即网络层，<br> 而MAC地址应用在OSI第二层，即数据链路层。<br> <strong>数据链路层协议mac<br> 可以使数据从一个节点传递到同一段链路的另一个节点上(通过MAC地址寻址)，</strong></p> 
 <p><em><strong>而网络层协议ip使数据可以从一个网络传递到另一个网络上(ARP根据目的IP地址，<br> 找到中间节点的MAC地址，通过中间节点转发，从而最终到达目的网络)。</strong></em></p> 
</blockquote> 
<p>工作流<br> <s><strong>在以太网环境下，</strong><br> <strong>同一个<em>网段</em>的主机之间需要知道对方的MAC地址，</strong><br> <s>(通过交换机相连的节点处于同一网段)</s></s></p> 
<blockquote> 
 <p><strong>路由器负责不同网段(Subnet, 子网)之间的通信，</strong><br> <strong>每个与路由器端口相连的网络被称为<em>一个子网</em>或网段，</strong> 也就是一个广播域。<br> <strong>在路由器中也有一张表，这张表叫做路由表，</strong><br> 通过在网络节点上运行路由协议，记录并更新去往不同网段的路径信息。</p> 
</blockquote> 
<blockquote> 
 <p>路由表中的信息分为直连路由和非直连路由：<br> 直连路由：直接连接到路由器端口的网段，<strong>该信息由路由器自动生成；</strong><br> 非直连路由：不是直接连接到路由器端口的网段，<strong>此记录需要手动添加或使用动态路由生成。</strong></p> 
</blockquote> 
<p>本机Linux系统下,<br> 双网卡em1(114.212.84.179)与virbr0(192.168.122.1)，<br> 执行命令：route -n，获取到内核IP路由表的数值展示形式如下：</p> 
<p>table th:nth-of-type(1) { width: 100px; } table th:nth-of-type(2) { width: 100px; } table th:nth-of-type(3) { width: 100px; }<br> <img src="https://images2.imgbox.com/4a/94/lkfpZpeU_o.png" alt="在这里插入图片描述"></p> 
<p>解析上述路由表：</p> 
<blockquote> 
 <p><strong>第一项：目的网络为114.212.80.0/21，<br> 网关地址为0.0.0.0(“…“的数值形式)，<br> 这表示该网段属于与路由器某端口直连的网段，</strong><br> 数据包将从路由器em1接口输出；</p> 
</blockquote> 
<blockquote> 
 <p><strong>第二项：目的网络为192.168.122.0/24，<br> 网关地址同样为0.0.0.0，<br> 表示该网段属于与路由器某端口直连的网段，</strong><br> 数据包将从路由器virbr0接口输出；</p> 
</blockquote> 
<blockquote> 
 <p><strong>第三项：目的网络为0.0.0.0(“default”的数值形式)时，</strong><br> 即匹配任意网段，由于路由表匹配执行最先匹配策略，<br> 第三项就是当目的IP地址无法与前两项匹配时的成功匹配项，<br> <strong>对应的网关称为默认网关，</strong><br> <strong>即路由器中没有存储某个目的网络的表项时<br> 应该转发至的下一跳地址，从em1端口输出</strong>。<br> 路由器中记录的条目有的需要手动添加，称为静态路由；有的则是动态获取的，称为动态路由。表中的每个条目都有以下属性：</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/61/79/U5LdwLNK_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>目的网络地址(Destination)：<br> 网络地址和网络掩码相与的结果<br> 用于定义本机可以达到的目的网络范围，</strong></p> 
 <p>通常情况下，目的网络范围包含以下几种情况：<br> (1) 主机地址：某个特定主机的网络地址；<br> (2) 子网地址：某个特定子网的网络地址；<br> (3) <strong>默认路由：所有未在路由表中指定的网络地址，<br> 用0.0.0.0统一匹配，用于配置默认网关；</strong></p> 
</blockquote> 
<hr> 
<blockquote> 
 <p>网络掩码(Genmask)：<br> <strong>又称为子网掩码(Subnet Mask)</strong>，是一个32位地址， 作用是将一个同样也是32位的IPv4地址 划分成网络地址(Network Address)和主机地址(Host Address)。<br> <strong>子网掩码不能单独存在，它必须结合IP地址一起使用。</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>子网掩码是用来判断任意两台主机是否处于同一网段的根据，</strong><br> <strong>简单来说就是两台主机各自的IP地址与本机配置的子网掩码做按<em>位</em>与操作，</strong><br> 如果结果相同，则说明这两台主机是处于<strong>同一网段，</strong><br> <strong>可以进行直接的通讯，而无需路由器的转发；</strong></p> 
</blockquote> 
<hr> 
<blockquote> 
 <p>网关(Gateway，<br> 又被称为下一跳服务器(Next Hop Server))：<br> 发送IP数据包时，网关定义了针对特定的网络目的地址，<br> <strong>数据包将要被发送到的下一跳IP地址。(1.网络端口ip2.路由器ip)</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>如果是与路由器直接相连的网段，</strong><br> <strong>网关通常就是路由器对应的网络端口的IP地址</strong>，<br> 但是此时接口必须与网关一致。</p> 
</blockquote> 
<blockquote> 
 <p>如果是远程网络或默认路由，<br> <strong>网关通常是与路由器相连网络上的某个服务器或路由器</strong>。<br> 如果目标是本主机所属网络，不需要路由，网关显示为”*“;</p> 
</blockquote> 
<hr> 
<p>利用下图详细介绍路由器的工作原理：<br> <img src="https://images2.imgbox.com/78/e5/jSHyVgRa_o.png" alt="在这里插入图片描述">小结</p> 
<p><strong>路由表负责记录一个网络到另一个网络的路径，</strong><br> 路由器依赖路由协议及其确定的路由表完成三层，<br> <strong>即网络层的数据转发工作。</strong></p> 
<p>路由表项中最重要的信息在于<strong>目的网段和网关</strong>，<br> <strong>即下一跳IP地址的对应关系，</strong></p> 
<blockquote> 
 <p>网关通常是专门的网关服务器或者路由器，<br> 而网关会负责将该数据包最终转发至目的网段。</p> 
</blockquote> 
<p>综上，看似较为“简单”的跨网段主机通信，<br> 真也不是太容易的一件事儿。</p> 
<blockquote> 
 <p>步骤如下：</p> 
</blockquote> 
<blockquote> 
 <p>主机A在网络层将来自上层的报文封装成IP数据报，<br> IP首部中的源IP地址为自己的IP地址，<br> 目的IP地址为主机B的IP地址。<br> <strong>主机A会用本机配置的24位子网掩码与目的地址进行“与”运算，</strong><br> <strong>得出目的地址与本机不在同一个网段</strong><br> (主机A位于192.168.1.0/24网段，<br> 主机B位于192.168.2.0/24网段，<br> 或称属于不同子网)，<br> <strong>因此发送给主机B的数据包需要经过网关路由器1的转发；</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>主机A通过ARP请求获得网关路由器1的E0端口的MAC地址，</strong><br> 并在数据链路层将路由器E0端口的MAC地址封装成<br> 以太网帧首部中的目的MAC地址，<br> <strong>源MAC地址是自己的MAC地址，</strong><br> 随后发送数据帧给路由器1；</p> 
</blockquote> 
<blockquote> 
 <p>路由器1从端口E0接收到该数据帧，<br> 随后执行解析，将数据链路层的首部剥落去掉，<br> 并在路由表中检查是否有目的IP地址的网段对应表项<br> (即192.168.2.2/24和其所在192.168.2.0/24网段)，<br> <strong>根据路由表中记录，</strong><br> <strong>发往192.168.2.0/24网段(中主机)的数据包的下一跳(NextHop)</strong><br> <strong>或称网关地址为10.1.1.2/8(实际是路由器2的E1端口的IP地址)，</strong><br> 而路由器发现下一跳地址<br> 正好位处与自己E1端口直连的网段(10.0.0.0/8)，<br> 于是数据在路由器1的E1端口重新封装，<br> 此时，<strong>以太网帧的源MAC地址是路由器1的E1端口的MAC地址，</strong><br> <strong>目的MAC地址则是路由器2的E1端口的MAC地址，</strong><br> <strong>通过ARP广播得到，封装完毕发送数据帧给路由器2；</strong></p> 
</blockquote> 
<blockquote> 
 <p>路由器2从端口E1接收到该数据帧，<br> 随后执行解析，将数据链路层的首部剥落去掉，<br> 对目的IP地址进行检测，并与路由表进行匹配，<br> <strong>此时发现目的主机IP地址所在网段正好是自己E0端口的直连网段，</strong><br> <strong>路由器2于是通过ARP广播，获知主机B的MAC地址，</strong><br> 此时数据包在路由器2的E0端口再次封装，<br> <strong>源MAC地址是路由器2的E0端口的MAC地址，</strong><br> <strong>目的MAC地址是主机B的MAC地址，随后发送数据帧给主机B</strong>；</p> 
 <pre><code>完成以上1~4，主机B终于接收到来自主机A的数据包。
</code></pre> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/07d6bb83904d164556b053138052aadb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">sp工具中最疼的是_盘点花园中最值得信赖的园艺工具</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6c02c119d955e28588a6f561338388ba/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">百度Ai studio上运行pytorch和tensorflow（转载）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>