<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Unity中的半透明阴影 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Unity中的半透明阴影" />
<meta property="og:description" content="Unity中的半透明阴影 在Unity中渲染半透明阴影可以使用Unity提供的dither texture。在这之前，先考虑一般半透明物体的渲染流程：
设置render queue为Transparent，这样不透明的物体会先渲染，然后位于被不透明物体遮挡的透明物体就可以不必渲染，减少开销设置render type为Transparent，便于一些replacement操作设置blend mode，例如fade是srcBlend = SrcAlpha，dstBlend = OneMinusSrcAlpha，而Transparent是srcBlend = One，dstBlend = OneMinusSrcAlpha关闭深度写入，zwrite = false Unity中的半透明阴影本质上是不透明的，只是对dither texture进行采样，根据采样的结果，clip掉一些fragment，使得shadow caster过程中只有一部分阴影信息会被绘制到shadowmap上。Unity builtin shaders提供的参考写法如下：
struct Interpolators { UNITY_VPOS_TYPE vpos : VPOS; ... }; float4 MyShadowFragmentProgram (Interpolators i) : SV_TARGET { ... half alphaRef = tex3D(_DitherMaskLOD, float3(vpos.xy*0.25,alpha*0.9375)).a; clip(dither - 0.01); ... } vpos表示的是当前像素在screen space下的坐标，_DitherMaskLOD是一个尺寸为4×4×16的3D纹理，这个可以从frame debug中看出：
这个纹理长啥样呢？我们可以写一个shader手动把它输出：
Shader &#34;Custom/TextureViewShader&#34; { Properties { } SubShader { Tags { &#34;RenderType&#34;=&#34;Opaque&#34; } LOD 100 Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c2bb2dce7431aee040f418366b5ce1b1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-11T20:10:42+08:00" />
<meta property="article:modified_time" content="2021-10-11T20:10:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Unity中的半透明阴影</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Unity中的半透明阴影</h4> 
</div> 
<p></p> 
<p>在Unity中渲染半透明阴影可以使用Unity提供的dither texture。在这之前，先考虑一般半透明物体的渲染流程：</p> 
<ul><li>设置render queue为Transparent，这样不透明的物体会先渲染，然后位于被不透明物体遮挡的透明物体就可以不必渲染，减少开销</li><li>设置render type为Transparent，便于一些replacement操作</li><li>设置blend mode，例如fade是srcBlend = SrcAlpha，dstBlend = OneMinusSrcAlpha，而Transparent是srcBlend = One，dstBlend = OneMinusSrcAlpha</li><li>关闭深度写入，zwrite = false</li></ul> 
<p>Unity中的半透明阴影本质上是不透明的，只是对dither texture进行采样，根据采样的结果，clip掉一些fragment，使得shadow caster过程中只有一部分阴影信息会被绘制到shadowmap上。Unity builtin shaders提供的参考写法如下：</p> 
<pre><code class="prism language-glsl">struct Interpolators {
	UNITY_VPOS_TYPE vpos : VPOS;
    ...
};

float4 MyShadowFragmentProgram (Interpolators i) : SV_TARGET {
    ...
	half alphaRef = tex3D(_DitherMaskLOD, float3(vpos.xy*0.25,alpha*0.9375)).a;
    clip(dither - 0.01);
    ...
}
</code></pre> 
<p>vpos表示的是当前像素在screen space下的坐标，_DitherMaskLOD是一个尺寸为4×4×16的3D纹理，这个可以从frame debug中看出：</p> 
<p><img src="https://images2.imgbox.com/45/99/oCfVF0k4_o.png" alt="在这里插入图片描述"></p> 
<p>这个纹理长啥样呢？我们可以写一个shader手动把它输出：</p> 
<pre><code class="prism language-glsl">Shader "Custom/TextureViewShader"
{
    Properties
    {
    }
    SubShader
    {
        Tags { "RenderType"="Opaque" }
        LOD 100

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include "UnityCG.cginc"

            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct v2f
            {
                float4 vertex : SV_POSITION;
                float2 uv : TEXCOORD0;
            };

            sampler3D _DitherMaskLOD;

            v2f vert (appdata v)
            {
                v2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.uv = v.uv;
                return o;
            }

            fixed4 frag (v2f i) : SV_Target
            {
                // sample the texture
                i.uv *= 16;
                fixed4 col = tex3D(_DitherMaskLOD, float3(i.uv, floor(i.uv.x) * 0.0625)).a;
                return col;
            }
            ENDCG
        }
    }
}
</code></pre> 
<p>从frame debug可知纹理是alpha8格式，因而只需输出alpha通道值：</p> 
<p><img src="https://images2.imgbox.com/d3/75/p5EbMIs9_o.png" alt="在这里插入图片描述"></p> 
<p>由于_DitherMaskLOD纹理是4×4×16的，我们实际上在v方向也重复了16次，因此真正的纹理长这样：</p> 
<p><img src="https://images2.imgbox.com/8e/ec/LadMGSk8_o.png" alt="在这里插入图片描述"></p> 
<p>可以看出，该纹理从4×4的全黑像素开始，随着维度z的增加，黑色像素每次减少1个，直至最后全部变成4×4的全白像素。通过这个规律，不难理解前面代码tex3D的采样坐标z的写法为alpha*0.9375。alpha表示透明度，0为完全透明1为完全不透明，而0.9375实际上就是15/16。这就是说在0的情况下采样的3D纹理是纯黑像素，会被clip掉，不会产生阴影；而1的情况下采样的3D纹理是全白像素，会完全产生阴影，就仿佛跟不透明物体一样。</p> 
<p>最后再看一下这个vpos*0.25是干啥的。vpos表示的是pixel在screen space下的坐标，x和y取值范围类似[0, screenWidth]，[0, screenHeight]。乘以0.25的系数就是对取值范围进行缩放处理，换言之就是将_DitherMaskLOD纹理进行放大，使其更明显。可以看下不同缩放比例的效果对比：</p> 
<p><img src="https://images2.imgbox.com/da/e1/JWSBBeF7_o.png" alt="scale = 1"></p> 
<p><img src="https://images2.imgbox.com/a2/24/RuPfi0rw_o.png" alt="scale = 0.25"></p> 
<p><img src="https://images2.imgbox.com/e3/e9/5kICRtxh_o.png" alt="scale = 0.0025"></p> 
<p>最后提一点的是，由于半透明的物体，render queue设置为transparent，所以在平行光绘制阴影前的depth pass阶段，是不会把半透明物体的深度信息写入depth buffer的，不过在shadow caster阶段，半透明阴影的信息还是正常绘制到shadowmap中的。这些都可以从frame debug中看出来：</p> 
<p><img src="https://images2.imgbox.com/19/1d/quJxPNKm_o.png" alt="在这里插入图片描述"></p> 
<p>如果你觉得我的文章有帮助，欢迎关注我的微信公众号（<strong>大龄社畜的游戏开发之路</strong>）<sup>-</sup></p> 
<p><img src="https://images2.imgbox.com/d2/eb/rQO17xjy_o.jpg" alt="在这里插入图片描述"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/071f14958f34c32f72c093158ea1ac77/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深度学习基础知识（人工智能）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/079782dee6f0be202106e1487b47e664/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pytorch处理CK&#43;数据集</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>