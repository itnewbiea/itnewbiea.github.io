<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; —— 指向对象的指针 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; —— 指向对象的指针" />
<meta property="og:description" content="C&#43;&#43;程序经常使用指向对象的指针，通常会搭配 new 来使用，例如，Class_Name 是类，value 是 Type_Name 类型：
Class_Name * ptr = new Class_Name(value); 该语句会调用如下的构造函数：
Class_Name(Type_Name &amp;); 而下面的初始化则是会调用默认构造函数：
Class_Name * ptr = new Class_Name; 再谈 new 和 delete 对于类对象我们可以在两个层次上使用 new 和 delete。
首先，可以使用 new 为类的数据成员分配存储空间。例如，String 类的char * str 成员，在构造函数中使用 new 生成足够存储字符串的空间，并将地址赋值给 str。由于这是在构造函数中进行的，因此在析构函数中必须使用 delete 释放空间。因为字符串是字符数组，所以构造函数和析构函数中使用带中括号的 new 和 delete。
其次，可以使用 new 来为整个类对象分配内存。String * pstr = new String(&#34;YouKa&#34;);这不是为要存储的字符串分配内存，而是为对象分配内存，即为保存字符串地址的 str 指针和 len 成员分配内存。需要注意，程序不会给 strNum 成员分配内存，因为 strNum 是静态成员，是独立于对象的。创建对象将调用构造函数，构造函数分配用于保存字符串的内容，并将字符串的地址赋给 str。当程序不在需要该对象时，可以使用 delete 删除它，delete pstr;，这里的 delete 只释放保存 str 和 len 成员的空间，不释放 str 指向的空间，该任务是由析构函数完成的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6fffadac2263bb8dc3045af84e669789/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-27T00:43:13+08:00" />
<meta property="article:modified_time" content="2022-05-27T00:43:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; —— 指向对象的指针</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>C++程序经常使用指向对象的指针，通常会搭配 new 来使用，例如，Class_Name 是类，value 是 Type_Name 类型：</p> 
<pre><code class="prism language-cpp">Class_Name <span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Class_Name</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>该语句会调用如下的构造函数：</p> 
<pre><code class="prism language-cpp"><span class="token function">Class_Name</span><span class="token punctuation">(</span>Type_Name <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>而下面的初始化则是会调用默认构造函数：</p> 
<pre><code class="prism language-cpp">Class_Name <span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> Class_Name<span class="token punctuation">;</span>
</code></pre> 
<h2><a id="_new__delete_12"></a>再谈 new 和 delete</h2> 
<p>对于类对象我们可以在两个层次上使用 new 和 delete。<br> 首先，可以使用 new 为类的数据成员分配存储空间。例如，String 类的<code>char * str</code> 成员，在构造函数中使用 new 生成足够存储字符串的空间，并将地址赋值给 str。由于这是在构造函数中进行的，因此在析构函数中必须使用 delete 释放空间。因为字符串是字符数组，所以构造函数和析构函数中使用带中括号的 new 和 delete。<br> 其次，可以使用 new 来为整个类对象分配内存。<code>String * pstr = new String("YouKa");</code>这不是为要存储的字符串分配内存，而是为对象分配内存，即为保存字符串地址的 str 指针和 len 成员分配内存。需要注意，程序不会给 strNum 成员分配内存，因为 strNum 是静态成员，是独立于对象的。创建对象将调用构造函数，构造函数分配用于保存字符串的内容，并将字符串的地址赋给 str。当程序不在需要该对象时，可以使用 delete 删除它，<code>delete pstr;</code>，这里的 delete 只释放保存 str 和 len 成员的空间，不释放 str 指向的空间，该任务是由析构函数完成的。<br> <img src="https://images2.imgbox.com/54/6e/mCZ8WJRN_o.png" alt="在这里插入图片描述"><br> 在下述情况下析构函数将被调用：</p> 
<ul><li>如果对象是自动变量，则当执行完定义该对象的程序块时，将调用改对象的析构函数。</li><li>如果对象是静态变量，则在程序结束时将调用对象的析构函数。</li><li>如果对象是用 new 创建的，则仅当显式使用 delete 删除对象时，析构函数才会被调用。</li></ul> 
<h2><a id="_22"></a>指针和对象的小结</h2> 
<p>使用对象指针时，要注意几点：</p> 
<ul><li>使用常规表示法来声明指向对象的指针：<code>String * pstr;</code></li><li>可以将指针初始化为指向已有的对象。</li><li>可以使用 new 来初始化指针，调用相应的类构造函数来初始化创建一个新的对象。</li><li>可以使用 -&gt; 运算符通过指针访问类方法。</li><li>可以对对象指针应用解除引用运算符(*)来获得指针指向的对象。</li></ul> 
<p><img src="https://images2.imgbox.com/b0/16/a2QjduE7_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1f/b9/ZOrXw9wR_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_new__33"></a>定位 new 运算符</h2> 
<p>定位 new 运算符能够在分配内存时指定内存位置。使用定位 new 运算符必须先包含头文件 。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;new&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">book</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> price<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> buffer1<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> buffer2<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"buffer1 address: "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> buffer1 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"buffer2 address: "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> buffer2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    book <span class="token operator">*</span>p1<span class="token punctuation">,</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>
    p1 <span class="token operator">=</span> <span class="token keyword">new</span> book<span class="token punctuation">;</span>
    <span class="token comment">// 定位 new 运算符，在 buffer1 的位置上创建一个 book 结构的变量</span>
    p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>buffer1<span class="token punctuation">)</span> book<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p1 address: "</span> <span class="token operator">&lt;&lt;</span> p1 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p2 address: "</span> <span class="token operator">&lt;&lt;</span> p2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>buffer2<span class="token punctuation">)</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p3 address: "</span> <span class="token operator">&lt;&lt;</span> p3 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>将 new 定位运算符运用在对象上，还会有所不同。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">TestType</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">TestType</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span> s <span class="token operator">=</span> <span class="token string">"Just use to test"</span><span class="token punctuation">,</span> <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        words <span class="token operator">=</span> s<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token operator">-&gt;</span>number <span class="token operator">=</span> number<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> words <span class="token operator">&lt;&lt;</span> <span class="token string">" constructed.\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">TestType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> words <span class="token operator">&lt;&lt;</span> <span class="token string">" destructed.\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">friend</span> std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span> out<span class="token punctuation">,</span> <span class="token keyword">const</span> TestType <span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>string words<span class="token punctuation">;</span>
    <span class="token keyword">int</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span> out<span class="token punctuation">,</span> <span class="token keyword">const</span> TestType <span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>words <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>number<span class="token punctuation">;</span>
    <span class="token keyword">return</span> out<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> <span class="token operator">*</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Memory address: "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> buffer <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    TestType <span class="token operator">*</span> p1<span class="token punctuation">,</span> <span class="token operator">*</span>p2<span class="token punctuation">,</span> <span class="token operator">*</span>p3<span class="token punctuation">,</span> <span class="token operator">*</span>p4<span class="token punctuation">;</span>
    p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> TestType<span class="token punctuation">;</span>
    p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TestType</span><span class="token punctuation">(</span><span class="token string">"Heap1"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"buffer(p1) address: "</span> <span class="token operator">&lt;&lt;</span> p1 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"heap(p2)  address: "</span> <span class="token operator">&lt;&lt;</span> p2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Memory content:\n"</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> p1 <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p1 <span class="token operator">&lt;&lt;</span> <span class="token string">"; "</span> <span class="token operator">&lt;&lt;</span> p2 <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token function">TestType</span><span class="token punctuation">(</span><span class="token string">"Bad"</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TestType</span><span class="token punctuation">(</span><span class="token string">"Heap2"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Memory content:\n"</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> p3 <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p3 <span class="token operator">&lt;&lt;</span> <span class="token string">"; "</span> <span class="token operator">&lt;&lt;</span> p4 <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p4 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p1: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p1 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    
    <span class="token keyword">delete</span> p2<span class="token punctuation">;</span>
    <span class="token keyword">delete</span> p4<span class="token punctuation">;</span>
    <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> buffer<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Finish.\n"</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>该程序使用 new 运算符创建了一个 512 字节的内存缓冲区；然后使用 new 运算符在堆中创建两个 TestType 对象，使用定位 new 运算符在内存缓冲区中创建两个 TestType 对象；最后，它使用 delete 来释放使用 new 分配的内存。下面是程序的输出：</p> 
<pre><code class="prism language-cpp">Memory address<span class="token operator">:</span> <span class="token number">0xd95e60</span>
Just use to test constructed<span class="token punctuation">.</span>
Heap1 constructed<span class="token punctuation">.</span>
<span class="token function">buffer</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span> address<span class="token operator">:</span> <span class="token number">0xd95e60</span>
<span class="token function">heap</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span>  address<span class="token operator">:</span> <span class="token number">0xd91b10</span>
Memory content<span class="token operator">:</span>
<span class="token number">0xd95e60</span><span class="token operator">:</span> Just use to test<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token number">0xd91b10</span><span class="token operator">:</span> Heap1<span class="token punctuation">,</span> <span class="token number">20</span>

Bad constructed<span class="token punctuation">.</span>
Heap2 constructed<span class="token punctuation">.</span>
Memory content<span class="token operator">:</span>
<span class="token number">0xd95e60</span><span class="token operator">:</span> Bad<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token number">0xd91b40</span><span class="token operator">:</span> Heap2<span class="token punctuation">,</span> <span class="token number">10</span>

p1<span class="token operator">:</span> Bad<span class="token punctuation">,</span> <span class="token number">6</span>

Heap1 destructed<span class="token punctuation">.</span>
Heap2 destructed<span class="token punctuation">.</span>
Finish<span class="token punctuation">.</span>
</code></pre> 
<p>该程序使用定位 new 运算符时存在两个问题：</p> 
<ul><li>在创建第二个对象时，定位 new 运算符使用一个新对象来覆盖第一个对象的内存单元。显然，如果类使用 new 为其成员动态分配内存将引发问题。</li><li>其次，将 delete 用于 p2 和 p4 时，将自动调用 p2 和 p4 指向的对象调用其析构函数；然而，将 delete[] 用于缓存区 buffer 时，不会为使用 定位 new 运算符创建的对象调用析构函数。</li></ul> 
<p>该程序给我们的第一个教训是，程序员必须负责确保使用定位 new 运算符使用的缓冲区内存单元正确。要使用不同的内存单元，程序员需要提供两个位于缓冲区的不同地址，并确保这两个地址单元不重叠。例如，可以这样做：</p> 
<pre><code class="prism language-cpp">p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> TestType<span class="token punctuation">;</span>
p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>buffer <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>TestType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">TestType</span><span class="token punctuation">(</span><span class="token string">"Bad"</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>其中 p3 指针指向相对于 p1 的偏移量为 TestType 对象的地址。</p> 
<p>第二个教训是，如果使用定位 new 运算符来为对象分配内存，必须确保其析构函数被调用。但如何确保呢？对于在堆中创建的对象，可以这样做：<code>delete p2;</code>，但由定位 new 运算符创建的对象不能这样做：<code>delete p1; delete p3;</code>。原因在于 delete 可与常规 new 运算符配合使用，但不能与定位 new 运算符配合使用。另一方面，指针 p1 指向的地址与 buffer 相同，但 buffer 是使用 new[] 初始化的，因此必须使用 delete[] 而不是 delete 来释放。即使 buffer 是使用 new 而不是 new[] 初始化的，delete p1 也将释放 buffer，而不是 p1。这是因为 new/delete 系统知道已分配的 512 字节块 buffer，但对于定位 new 运算符对该内存块做了何种处理一无所知。<br> <code>delete [] buffer;</code>释放使用常规 new 运算符分配的整个内存块，但它没有为定位 new 运算符在该内存块中创建的对象调用析构函数，这一点可以根据输出信息来确定。输出信息中有 p2、p4 这两个在堆中申请内存的对象的析构函数调用痕迹，而 p1 和 p3 指向的对象没有调用析构函数。<br> 这种问题的解决方案是，显式地为使用定位 new 运算符创建的对象调用析构函数。正常情况下需要自动调用析构函数，这是需要显式调用析构函数的少数几种情况之一。显式地调用析构函数时，必须指定要销毁的对象，由于有指向对象的指针，因此可以使用这些指针：</p> 
<pre><code class="prism language-cpp">p3<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">TestType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p1<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">TestType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>需要注意的一点是正确的删除顺序！对于使用 new 运算符创建的对象，应用与创建顺序相反的顺序进行删除。原因在于，晚创建的对象可能依赖于先创建的对象。另外，仅当所有对象都被销毁之后才能释放用于存储这些对象的缓冲区。<br> 正确使用定位 new 运算符创建对象的程序如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> <span class="token operator">*</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Memory address: "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> buffer <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    TestType <span class="token operator">*</span> p1<span class="token punctuation">,</span> <span class="token operator">*</span>p2<span class="token punctuation">,</span> <span class="token operator">*</span>p3<span class="token punctuation">,</span> <span class="token operator">*</span>p4<span class="token punctuation">;</span>
    p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> TestType<span class="token punctuation">;</span>
    p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TestType</span><span class="token punctuation">(</span><span class="token string">"Heap1"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"buffer(p1) address: "</span> <span class="token operator">&lt;&lt;</span> p1 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"heap(p2)  address: "</span> <span class="token operator">&lt;&lt;</span> p2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Memory content:\n"</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> p1 <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p1 <span class="token operator">&lt;&lt;</span> <span class="token string">"; "</span> <span class="token operator">&lt;&lt;</span> p2 <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token comment">// 错误, 这样创建对象会覆盖 p1 指向的对象. 如果类动态为成员分配内存, 会导致内存泄漏.</span>
<span class="token comment">//    p3 = new (buffer) TestType("Bad", 6);</span>
    p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>buffer <span class="token operator">+</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span>TestType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">TestType</span><span class="token punctuation">(</span><span class="token string">"Bad"</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TestType</span><span class="token punctuation">(</span><span class="token string">"Heap2"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Memory content:\n"</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> p3 <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p3 <span class="token operator">&lt;&lt;</span> <span class="token string">"; "</span> <span class="token operator">&lt;&lt;</span> p4 <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p4 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p1: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p1 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">delete</span> p2<span class="token punctuation">;</span>
    p2 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> p4<span class="token punctuation">;</span>
    p4 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    p3<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">TestType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p3 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    p1<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">TestType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p1 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> buffer<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Finish.\n"</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>该程序使用定位 new 运算符在相邻的内存单元中创建了两个对象，并调用了合适的析构函数。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e03f1983cbcd1947611f7bf1bc41bb15/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">double类型的两个数可以直接比较吗？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3b6ecf3e8efe5d36dba22d3e8820c05c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【解决】npm ERR A complete log of this run can be found in: npm ERR</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>