<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue进阶之路：vue3.2-setup语法糖、组合式API、状态库Pinia归纳总结 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue进阶之路：vue3.2-setup语法糖、组合式API、状态库Pinia归纳总结" />
<meta property="og:description" content="大家好，我叫东东吖，你现在看到的是vue进阶系列，如果觉得不错，可以点赞收藏哦，喜欢我的朋友，还可以加个关注鸭。
vue进阶系列包括以下内容：
vue进阶之路：组件通信的8种方式，你搞清楚了吗？
vue进阶之路：父子组件的生命周期执行流程是怎么样的呢？
vue进阶之路：vuex五大核心概念，看完这篇文章就够了。
vue进阶之路：前端技术日新月异，vue3.0的时代已经来临...
vue进阶之路：叮，Vue2与Vue3都有哪些区别？请查收！
前言： vue3.0都没学完，vue3.2又来了，你还学得动吗？（手动滑稽）
vue3.2与vue3.0在语法上存在以下区别:
vue3.0版本：变量和方法必须return出来才能使用。
vue3.2版本：只需要在script标签上加上setup属性，不需要再把变量和方法return出去，代码更加简洁。
本文将重点将重点介绍vue3.2版本的语法，如果对vue3还没有完全接触过的小伙伴，可以先移步去我这篇文章热热身哦。 前端技术日新月异，vue3.0的时代已经来临...
创建项目： vite脚手架创建项目: vue3&#43;vite2&#43;ts
npm create vite@latest 一.组件结构 &lt;script setup lang=&#34;ts&#34;&gt; //直接在script标签上添加setup属性 //... &lt;/script&gt; &lt;template&gt; //vue2只支持一个根节点，vue3支持多个根节点 //... &lt;/template&gt; &lt;style scoped&gt; // 支持CSS变量注入v-bind(color) //... &lt;/style&gt; 二.data &lt;script setup lang=&#34;ts&#34;&gt; import { reactive, ref, toRefs } from &#39;vue&#39; // ref声明响应式数据，用于声明基本数据类型 const name = ref(&#39;东东吖&#39;) // 修改 name.value = &#39;小鲁班&#39; // reactive声明响应式数据，用于声明引用数据类型 const state = reactive({ age: 24, sex: &#39;男&#39; }) // 修改 state." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/824d883aad752d901fe6dd693903386d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-10T09:45:15+08:00" />
<meta property="article:modified_time" content="2022-07-10T09:45:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue进阶之路：vue3.2-setup语法糖、组合式API、状态库Pinia归纳总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>大家好，我叫东东吖，你现在看到的是vue进阶系列，如果觉得不错，可以点赞收藏哦，喜欢我的朋友，还可以加个关注鸭。</p> 
<p><strong>vue进阶系列包括以下内容：</strong></p> 
<p><a href="https://juejin.cn/post/7057434515618136100" rel="nofollow" title="vue进阶之路：组件通信的8种方式，你搞清楚了吗？">vue进阶之路：组件通信的8种方式，你搞清楚了吗？</a></p> 
<p><a href="https://juejin.cn/post/7024151086436974623" rel="nofollow" title="vue进阶之路：父子组件的生命周期执行流程是怎么样的呢？">vue进阶之路：父子组件的生命周期执行流程是怎么样的呢？</a></p> 
<p><a href="https://juejin.cn/post/7050449934297858061" rel="nofollow" title="vue进阶之路：vuex五大核心概念，看完这篇文章就够了。">vue进阶之路：vuex五大核心概念，看完这篇文章就够了。</a></p> 
<p><a href="https://juejin.cn/post/7057434515618136100" rel="nofollow" title="vue进阶之路：前端技术日新月异，vue3.0的时代已经来临...">vue进阶之路：前端技术日新月异，vue3.0的时代已经来临...</a></p> 
<p><a href="https://juejin.cn/post/7067427300924948487" rel="nofollow" title="vue进阶之路：叮，Vue2与Vue3都有哪些区别？请查收！">vue进阶之路：叮，Vue2与Vue3都有哪些区别？请查收！</a></p> 
<h3>前言：</h3> 
<p>vue3.0都没学完，vue3.2又来了，你还学得动吗？（手动滑稽）</p> 
<p><strong>vue3.2与vue3.0在语法上存在以下区别:</strong><br> vue3.0版本：变量和方法必须return出来才能使用。<br> vue3.2版本：只需要在script标签上加上setup属性，不需要再把变量和方法return出去，代码更加简洁。</p> 
<p>本文将重点将重点介绍vue3.2版本的语法，如果对vue3还没有完全接触过的小伙伴，可以先移步去我这篇文章热热身哦。 <a href="https://juejin.cn/post/7057434515618136100" rel="nofollow" title="前端技术日新月异，vue3.0的时代已经来临...">前端技术日新月异，vue3.0的时代已经来临...</a></p> 
<h3>创建项目：</h3> 
<p><strong>vite脚手架创建项目: vue3+vite2+ts</strong></p> 
<pre><code>npm create vite@latest
</code></pre> 
<h3>一.组件结构</h3> 
<pre><code>&lt;script setup lang="ts"&gt;
//直接在script标签上添加setup属性
//...

&lt;/script&gt;

&lt;template&gt;
//vue2只支持一个根节点，vue3支持多个根节点
//...

&lt;/template&gt;

&lt;style scoped&gt;
// 支持CSS变量注入v-bind(color)
//...

&lt;/style&gt;
</code></pre> 
<h3>二.data</h3> 
<pre><code>&lt;script setup lang="ts"&gt;
import { reactive, ref, toRefs } from 'vue'

  // ref声明响应式数据，用于声明基本数据类型
  const name = ref('东东吖')
  // 修改
  name.value = '小鲁班'

  // reactive声明响应式数据，用于声明引用数据类型
  const state = reactive({
    age: 24,
    sex: '男'
  })
  // 修改
  state.age = 24
  
  // 使用toRefs解构  template可直接使用{<!-- -->{name}}、{<!-- -->{sex}}
  const {age, sex} = toRefs(state)
  
&lt;/script&gt;

&lt;template&gt;
  &lt;h1&gt;{<!-- -->{ name }}&lt;/h1&gt;
  &lt;h1&gt;{<!-- -->{ state.age }}&lt;/h1&gt;
  &lt;h1&gt;{<!-- -->{ sex }}&lt;/h1&gt;
&lt;/template&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre> 
<h3>三.method</h3> 
<pre><code>&lt;script setup lang="ts"&gt;
import { reactive, toRefs } from 'vue'

  // reactive声明响应式数据，用于声明引用数据类型
  const state = reactive({
    age: 24,
    sex: '男'
  })
  // 使用toRefs解构  template可直接使用{<!-- -->{name}}、{<!-- -->{sex}}
  const {age, sex} = toRefs(state)

   // 声明method方法
  const changeAge =()=&gt;{
    state.age+=1
  }
  
&lt;/script&gt;

&lt;template&gt;
  &lt;h1&gt;{<!-- -->{ age }}&lt;/h1&gt;
  
  &lt;!-- 调用方法 --&gt;
  &lt;button @click="changeAge()"&gt;点我&lt;/button&gt;
&lt;/template&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre> 
<h3>四.computed</h3> 
<pre><code>&lt;script setup lang="ts"&gt;
import { ref,computed } from 'vue'

 // ref声明响应式数据，用于声明基本数据类型
  const count = ref(1)

  //computed获取双倍count' 
  const doubleCount =computed(()=&gt;{
    return count.value*2
  })

  
&lt;/script&gt;

&lt;template&gt;
  &lt;h1&gt;{<!-- -->{ count }}&lt;/h1&gt;
  &lt;h1&gt;{<!-- -->{doubleCount}}&lt;/h1&gt;

&lt;/template&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre> 
<h3>五.父传子</h3> 
<pre><code>//父组件:

&lt;script setup lang="ts"&gt;
// 引入子组件(组件自动注册)
import HelloWorld from './components/HelloWorld.vue'
&lt;/script&gt;

&lt;template&gt;
  &lt;HelloWorld msg="东东吖" /&gt;
&lt;/template&gt;

&lt;style&gt;

&lt;/style&gt;
</code></pre> 
<pre><code>//子组件：

&lt;script setup lang="ts"&gt;
&lt;script setup lang="ts"&gt;
// import { defineProps } from 'vue'
// defineProps在&lt;script setup&gt;中自动可用，无需导入
// 需在.eslintrc.js文件中【globals】下配置【defineProps: true】

// 声明props
const props = defineProps({
  msg: {
    type: String,
    default: "",
  },
});
&lt;/script&gt;

&lt;template&gt;

{<!-- -->{props.msg}}

&lt;!-- 可省略props --&gt;
  &lt;h1&gt;{<!-- -->{ msg }}&lt;/h1&gt;

&lt;/template&gt;

&lt;style scoped&gt;
&lt;/style&gt;



</code></pre> 
<h3>六.子传父</h3> 
<pre><code>//父组件：

&lt;script setup lang="ts"&gt;
import { reactive } from "vue";
// 引入子组件(组件自动注册)
import HelloWorld from "./components/HelloWorld.vue";

const state = reactive({
  msg: "我是父组件原本的值",
});

const changeMsg = (val) =&gt; {
  state.msg = val;
};
&lt;/script&gt;

&lt;template&gt;
  &lt;HelloWorld :msg='state.msg' @changeMsg="changeMsg" /&gt;
&lt;/template&gt;

&lt;style&gt;
&lt;/style&gt;
</code></pre> 
<pre><code>//子组件：

&lt;script setup lang="ts"&gt;
import { defineEmits } from "vue";

// import { defineEmits, defineProps } from 'vue'
// defineEmits和defineProps在&lt;script setup&gt;中自动可用，无需导入
// 需在.eslintrc.js文件中【globals】下配置【defineEmits: true】、【defineProps: true】

// 声明props
const props = defineProps({
  msg: {
    type: String,
    default: "",
  },
});

// 声明emit
const emit = defineEmits(["changeMsg"]);

// 声明子传父事件
const changeMsg = () =&gt; {
  emit("changeMsg", "我是子组件传过来的值");
};
&lt;/script&gt;

&lt;template&gt;

{<!-- -->{props.msg}}

&lt;!-- 可省略props --&gt;
  &lt;h1&gt;{<!-- -->{ msg }}&lt;/h1&gt;


&lt;!-- 调用子传父事件 --&gt;
  &lt;button @click="changeMsg"&gt;点我&lt;/button&gt;

&lt;/template&gt;

&lt;style scoped&gt;
&lt;/style&gt;


</code></pre> 
<h3>七.原型链绑定和组件使用</h3> 
<pre><code>//main.ts

// 创建vue实例
const app=createApp(App)
// 获取原型
const prototype = app.config.globalProperties
// 绑定参数
prototype.name = '我是挂载在全局上的属性'
</code></pre> 
<pre><code>//组件内获取使用

//引入
import { getCurrentInstance } from "vue";
// 获取原型
const { proxy } = getCurrentInstance();
// 输出
console.log(proxy.name);

</code></pre> 
<h3>八.任意组件通信mitt.js</h3> 
<ul><li>Vue2.x使用EventBus进行组件通信，而Vue3.x推荐使用mitt.js。</li></ul> 
<h3>九.双向绑定v-model</h3> 
<pre><code>//父组件：

&lt;script setup lang="ts"&gt;
import { reactive } from "vue";
// 引入子组件(组件自动注册)
import HelloWorld from "./components/HelloWorld.vue";

const state = reactive({
  msg: "我是父组件原本的值",
  age:24
});

&lt;/script&gt;

&lt;template&gt;
&lt;div&gt;父组件：&lt;/div&gt;
&lt;div&gt;{<!-- -->{state.msg}}&lt;/div&gt;
&lt;input type="text" v-model="state.msg"&gt;

  &lt;HelloWorld
   v-model:msg='state.msg'
   v-model:age="state.age"
   /&gt;
&lt;/template&gt;

&lt;style&gt;
&lt;/style&gt;

</code></pre> 
<pre><code>//子组件：

&lt;script setup lang="ts"&gt;
import { defineEmits } from "vue";

// import { defineEmits, defineProps } from 'vue'
// defineEmits和defineProps在&lt;script setup&gt;中自动可用，无需导入
// 需在.eslintrc.js文件中【globals】下配置【defineEmits: true】、【defineProps: true】

// 声明props
const props = defineProps({
  msg: {
    type: String,
    default: "",
  },
  age: {
    type: Number,
    default: 0,
  },
});

// 声明emit
const emit = defineEmits(["updata:msg", "updata:age"]);
&lt;/script&gt;

&lt;template&gt;
&lt;div&gt;子组件：&lt;/div&gt;
&lt;input type="text" v-model="msg"&gt;

&lt;!-- 可省略props --&gt;
  &lt;h1&gt;{<!-- -->{ msg }}&lt;/h1&gt;
  &lt;h1&gt;{<!-- -->{age}}&lt;/h1&gt;

&lt;/template&gt;

&lt;style scoped&gt;
&lt;/style&gt;


</code></pre> 
<h3>十.nextTick</h3> 
<pre><code>&lt;script setup lang="ts"&gt;
import { reactive ,nextTick } from "vue";
// 引入子组件(组件自动注册)
import HelloWorld from "./components/HelloWorld.vue";

const state = reactive({
  msg: "我是父组件原本的值",
});

 // 调用nextTick
nextTick(()=&gt;{  
 console.log("nextTick执行了...");
 state.msg="我是nextTick执行后的值"
 
})

&lt;/script&gt;

&lt;template&gt;
  &lt;HelloWorld
   v-model:msg='state.msg'
   /&gt;
&lt;/template&gt;

&lt;style&gt;
&lt;/style&gt;
</code></pre> 
<pre><code>子组件：
&lt;script setup lang="ts"&gt;
import { defineProps,nextTick } from "vue";
// 声明props
const props = defineProps({
  msg: {
    type: String,
    default: "",
  },
});

 // 调用nextTick
nextTick(()=&gt;{  
 console.log("nextTick执行了...");
 
})


&lt;/script&gt;

&lt;template&gt;
  &lt;h1&gt;{<!-- -->{ msg }}&lt;/h1&gt;
&lt;/template&gt;

&lt;style scoped&gt;
&lt;/style&gt;

</code></pre> 
<h3>十一.插槽</h3> 
<pre><code>//子组件：

&lt;script setup lang="ts"&gt;
  import { useSlots, reactive } from 'vue'
  const state = reactive({
    name: '东东吖',
    age: '25岁'
  })
  
  const slots = useSlots()
  // 匿名插槽使用情况
  const defaultSlot = reactive(slots.default &amp;&amp; slots.default().length)
  console.log("defaultSlot",defaultSlot) // 1
  // 具名插槽使用情况
  const titleSlot = reactive(slots.title &amp;&amp; slots.title().length)
  console.log("titleSlot",titleSlot) // 3
&lt;/script&gt;

&lt;template&gt;
&lt;!-- 匿名插槽 --&gt;
  &lt;slot/&gt;
  &lt;!-- 具名插槽 --&gt;
  &lt;slot name='title'/&gt;
   &lt;!-- 作用域插槽 --&gt;
  &lt;slot name="footer" :scope="state" /&gt;


&lt;/template&gt;

&lt;style scoped&gt;
&lt;/style&gt;

</code></pre> 
<pre><code>//父组件：

&lt;script setup lang="ts"&gt;
import HelloWorld from "./components/HelloWorld.vue";

&lt;/script&gt;

&lt;template&gt;
&lt;HelloWorld&gt;
   &lt;!-- 匿名插槽 --&gt;
    &lt;span&gt;我是默认插槽&lt;/span&gt;
    &lt;!-- / 具名插槽 --&gt;
    &lt;template #title&gt;
      &lt;h1&gt;我是具名插槽1&lt;/h1&gt;
      &lt;h1&gt;我是具名插槽2&lt;/h1&gt;
      &lt;h1&gt;我是具名插槽3&lt;/h1&gt;
    &lt;/template&gt;
    &lt;!-- 作用域插槽 --&gt;
    &lt;template #footer="{ scope }"&gt;
      &lt;footer&gt;作用域插槽——姓名：{<!-- -->{ scope.name }}，年龄{<!-- -->{ scope.age }}&lt;/footer&gt;
    &lt;/template&gt;
  &lt;/HelloWorld&gt;
&lt;/template&gt;

&lt;style&gt;
&lt;/style&gt;

</code></pre> 
<pre><code>//页面展示情况：

我是默认插槽

# 我是具名插槽1

# 我是具名插槽2

# 我是具名插槽3

作用域插槽——姓名：东东吖，年龄25岁
</code></pre> 
<h3>十二.路由useRoute和useRouter</h3> 
<pre><code>//新建router/index.ts

import { createRouter, createWebHashHistory, RouteRecordRaw } from 'vue-router';
const routes: Array&lt;RouteRecordRaw&gt; = [
  { 
    path: '/',
    redirect: '/home'
  },
  { 
    path: '/home',
    name: 'home',
    component: () =&gt; import('../pages/home/Index.vue'),
    meta: {
      showFooter: true,
      requireAuth: false,
    }
  },
  { 
    path: '/about',
    name: 'about',
    component: () =&gt; import( '../pages/about/Index.vue'),
    meta: {
      showFooter: true,
      requireAuth: false,
    }
  },


];

const router = createRouter({
  history: createWebHashHistory(),
  routes,
});

export default router;
</code></pre> 
<pre><code>//在main.ts将路由router注册
import { createApp } from 'vue'
import App from './App.vue'
import router from './router/index.ts'


const app=createApp(App)
app.use(router).mount('#app')


</code></pre> 
<pre><code>//在页面打印结果

import { useRouter, useRoute } from "vue-router";

// 必须先声明调用
const router = useRouter();
const route = useRoute();

// 路由信息
console.log("router", router);
console.log("route",route);
</code></pre> 
<h3>十三.路由守卫</h3> 
<pre><code>// 路由守卫

router.beforeEach((to, from, next) =&gt; {
 console.log("to",to);
 console.log("from",from);
 next()
})

</code></pre> 
<h3>十四.生命周期</h3> 
<p><strong>选项式 API 的生命周期选项和组合式 API 之间的映射</strong></p> 
<ul><li><code>beforeCreate</code> -&gt; 使用 <code>setup()</code></li><li><code>created</code> -&gt; 使用 <code>setup()</code></li><li><code>beforeMount</code> -&gt; <code>onBeforeMount</code></li><li><code>mounted</code> -&gt; <code>onMounted</code></li><li><code>beforeUpdate</code> -&gt; <code>onBeforeUpdate</code></li><li><code>updated</code> -&gt; <code>onUpdated</code></li><li><code>beforeUnmount</code> -&gt; <code>onBeforeUnmount</code></li><li><code>unmounted</code> -&gt; <code>onUnmounted</code></li><li><code>errorCaptured</code> -&gt; <code>onErrorCaptured</code></li><li><code>renderTracked</code> -&gt; <code>onRenderTracked</code></li><li><code>renderTriggered</code> -&gt; <code>onRenderTriggered</code></li><li><code>activated</code> -&gt; <code>onActivated</code></li><li><code>deactivated</code> -&gt; <code>onDeactivated</code></li></ul> 
<h3>十五.store</h3> 
<ul><li><strong>vuex</strong></li></ul> 
<p>Vue3 中的Vuex不再提供辅助函数写法，想要学习vuex的伙伴可以移步我这篇文章。<a href="https://juejin.cn/post/7050449934297858061" rel="nofollow" title="vue进阶之路：vuex五大核心概念，看完这篇文章就够了。">vue进阶之路：vuex五大核心概念，看完这篇文章就够了。</a></p> 
<ul><li><strong>Pinia</strong>、</li></ul> 
<p>vue3更加推荐的是pinia，2021年11月24日，尤大在 Twitter 上宣布：<code>Pinia</code> 正式成为 Vue 官方的状态库，意味着 <code>Pinia</code> 就是 <code>Vuex 5</code>，让我们全面拥抱pinia吧！</p> 
<p>① <strong>基础使用流程</strong></p> 
<pre><code>//下载pinia

npm install pinia -S
</code></pre> 
<pre><code>//main.ts

import { createApp } from 'vue'
import App from './App.vue'
import router from './router/index.ts'

// 引入pinia
import { createPinia } from 'pinia'

// 创建vue实例
const app=createApp(App)

// 创建 Pinia 实例
const pinia = createPinia()

// 注册挂载到vue实列
app.use(router).use(pinia).mount('#app')

</code></pre> 
<pre><code>// store/index.ts

import { defineStore } from 'pinia'
// 1. 定义容器、导出容器
// 参数1：容器的ID，必须是唯一的，后面Pinia会把所有的容器挂载到根容器
// 参数2：一些选项对象，也就是state、getter和action
// 返回值：一个函数，调用即可得到容器实例

export const useMainStore =  defineStore('main',{
    // 类似于Vue2组件中的data，用于存储全局状态数据，但有两个要求
    // 1. 必须是函数，目的是为了在服务端渲染的时候避免交叉请求导致的数据状态污染
    // 2. 必须是箭头函数，这样是为了更好的 TS 类型推导
    state:()=&gt;{
        return {
            info:"hello,东东吖，我是Pinia"
        }
    },
    getters:{},
    actions:{}
})
</code></pre> 
<pre><code>//组件内使用

&lt;template&gt;
    &lt;div&gt;
   &lt;h1&gt;{<!-- -->{ mainStore.info}}&lt;/h1&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { useMainStore } from "../../store/index.ts";
const mainStore = useMainStore();


&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre> 
<p>② <strong>state 中数据的解构访问</strong></p> 
<pre><code>// store/index.ts
import { defineStore } from 'pinia'
// 1. 定义容器、导出容器
// 参数1：容器的ID，必须是唯一的，后面Pinia会把所有的容器挂载到根容器
// 参数2：一些选项对象，也就是state、getter和action
// 返回值：一个函数，调用即可得到容器实例

export const useMainStore =  defineStore('main',{
    // 类似于Vue2组件中的data，用于存储全局状态数据，但有两个要求
    // 1. 必须是函数，目的是为了在服务端渲染的时候避免交叉请求导致的数据状态污染
    // 2. 必须是箭头函数，这样是为了更好的 TS 类型推导
    state:()=&gt;{
        return {
            info:"hello,东东吖，我是Pinia",
            count:10
        }
    },
    getters:{},
    actions:{}
})
</code></pre> 
<pre><code>//组件内使用

&lt;template&gt;
  &lt;h1&gt;{<!-- -->{ mainStore.count }}&lt;/h1&gt;
  &lt;h1&gt;{<!-- -->{ mainStore.info }}&lt;/h1&gt;
  &lt;hr /&gt;
  &lt;h1&gt;{<!-- -->{ count }}&lt;/h1&gt;
  &lt;h1&gt;{<!-- -->{ info }}&lt;/h1&gt;
  &lt;p&gt;
    &lt;button @click="alertData"&gt;修改数据count&lt;/button&gt;
  &lt;/p&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { toRefs } from 'vue'
import { storeToRefs } from 'pinia'
import { useMainStore } from "../../store";
const mainStore = useMainStore();
// 解构数据，但是得到的数据是不具有响应式的，只是一次性的
// 相当于仅仅只是...mainStore而已，只是做了reactive处理，并没有做toRefs
// const { count, info } = useMainStore();
// 解决方法：
// 1. 通过使用toRefs函数，因为前面所说相当于是通过reactive处理，因此可以
// const { count, info } = toRefs(mainStore);
// 2. 通过pinia中提供的storeToRefs方法来解决，推荐使用
const { count, info } = storeToRefs(mainStore);
const alertData = () =&gt; {
  mainStore.count += 10
}
&lt;/script&gt;

&lt;style&gt;
&lt;/style&gt;

</code></pre> 
<p>③ <strong>state 中数据的修改方式（actions和组件中）</strong></p> 
<pre><code>// 一般的修改

&lt;template&gt;
  &lt;h1&gt;{<!-- -->{ mainStore.count }}&lt;/h1&gt;
  &lt;h1&gt;{<!-- -->{ mainStore.info }}&lt;/h1&gt;
  &lt;hr /&gt;
  &lt;h1&gt;{<!-- -->{ count }}&lt;/h1&gt;
  &lt;h1&gt;{<!-- -->{ info }}&lt;/h1&gt;
  &lt;p&gt;
    &lt;button @click="alertData"&gt;修改数据count&lt;/button&gt;
  &lt;/p&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { toRefs } from 'vue'
import { storeToRefs } from 'pinia'
import { useMainStore } from "../../store";
const mainStore = useMainStore();
// 解构数据，但是得到的数据是不具有响应式的，只是一次性的
// 相当于仅仅只是...mainStore而已，只是做了reactive处理，并没有做toRefs
// const { count, info } = useMainStore();
// 解决方法：
// 1. 通过使用toRefs函数，因为前面所说相当于是通过reactive处理，因此可以
// const { count, info } = toRefs(mainStore);
// 2. 通过pinia中提供的storeToRefs方法来解决，推荐使用
const { count, info } = storeToRefs(mainStore);


const alertData = () =&gt; {
  // 方式一：最简单的方法，如下
  // 解构后更改方式
//   count.value += 10
  // 结构前更改方式
//   mainStore.count += 10
  // 方式二：若要同时修改多个数据，建议使用$patch来实现批量更新，在内部做了优化
//   mainStore.$patch({
//     count: mainStore.count + 1,
//     info: "hello"
//   })
  // 方式三：更好的批量更新方法，通过$patch传递一个函数来实现，这里的state就是useMainStore容器中的state
  mainStore.$patch(state =&gt; {
    state.count += 10
    state.info = "pinia批量更新"+state.count
  })
}
&lt;/script&gt;

&lt;style&gt;
&lt;/style&gt;

</code></pre> 
<pre><code>//通过actions修改
// store/index.ts

import { defineStore } from 'pinia'
// 1. 定义容器、导出容器
// 参数1：容器的ID，必须是唯一的，后面Pinia会把所有的容器挂载到根容器
// 参数2：一些选项对象，也就是state、getter和action
// 返回值：一个函数，调用即可得到容器实例

export const useMainStore =  defineStore('main',{
    // 类似于Vue2组件中的data，用于存储全局状态数据，但有两个要求
    // 1. 必须是函数，目的是为了在服务端渲染的时候避免交叉请求导致的数据状态污染
    // 2. 必须是箭头函数，这样是为了更好的 TS 类型推导
    state:()=&gt;{
        return {
            info:"hello,东东吖，我是Pinia",
            count:10
        }
    },
    getters:{},
    
// store/index.ts
// 类似于vue2组件的methods，用于封装业务逻辑，修改state
// // 注意：不能使用箭头函数来定义actions，因为箭头函数绑定外部的this
actions:{
    changeState (){
        this.count += 10
        this.info = "actions修改数据"
    },
    changeStates (num:number){
        this.count += num + 2
        this.info = "actions修改数据"
    }
}

})

</code></pre> 
<pre><code>//组件内使用

&lt;template&gt;
  &lt;h1&gt;{<!-- -->{ mainStore.count }}&lt;/h1&gt;
  &lt;h1&gt;{<!-- -->{ mainStore.info }}&lt;/h1&gt;
  &lt;hr /&gt;
  &lt;h1&gt;{<!-- -->{ count }}&lt;/h1&gt;
  &lt;h1&gt;{<!-- -->{ info }}&lt;/h1&gt;
  &lt;p&gt;
    &lt;button @click="alertData"&gt;修改数据count&lt;/button&gt;
  &lt;/p&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { toRefs } from 'vue'
import { storeToRefs } from 'pinia'
import { useMainStore } from "../../store";
const mainStore = useMainStore();
// 解构数据，但是得到的数据是不具有响应式的，只是一次性的
// 相当于仅仅只是...mainStore而已，只是做了reactive处理，并没有做toRefs
// const { count, info } = useMainStore();
// 解决方法：
// 1. 通过使用toRefs函数，因为前面所说相当于是通过reactive处理，因此可以
// const { count, info } = toRefs(mainStore);
// 2. 通过pinia中提供的storeToRefs方法来解决，推荐使用
const { count, info } = storeToRefs(mainStore);

const alertData = () =&gt; {
  // 方式四：通过 actions 来修改数据
  mainStore.changeState()
  mainStore.changeStates(10)
}

&lt;/script&gt;

&lt;style&gt;
&lt;/style&gt;

</code></pre> 
<p>③ <strong>getters 的使用</strong></p> 
<pre><code>// store/index.ts
import { defineStore } from 'pinia'
// 1. 定义容器、导出容器
// 参数1：容器的ID，必须是唯一的，后面Pinia会把所有的容器挂载到根容器
// 参数2：一些选项对象，也就是state、getter和action
// 返回值：一个函数，调用即可得到容器实例

export const useMainStore =  defineStore('main',{
    // 类似于Vue2组件中的data，用于存储全局状态数据，但有两个要求
    // 1. 必须是函数，目的是为了在服务端渲染的时候避免交叉请求导致的数据状态污染
    // 2. 必须是箭头函数，这样是为了更好的 TS 类型推导
    state:()=&gt;{
        return {
            info:"hello,东东吖，我是Pinia",
            count:10
        }
    },

    // 类似于组件的computed，用来封装计算属性，具有缓存的功能
    getters:{
        // 函数接收一个可选参数：state状态对象
       count10(state){
           return state.count += 10
       },
       count20(state){
           return this.count += 20
       },
       // 若使用this.count，则必须指明返回数据的类型
       count11():number{
           return this.count += 11
       }
   },
    
// store/index.ts
// 类似于vue2组件的methods，用于封装业务逻辑，修改state
// // 注意：不能使用箭头函数来定义actions，因为箭头函数绑定外部的this
actions:{
    changeState (){
        this.count += 10
        this.info = "actions修改数据"
    },
    changeStates (num:number){
        this.count += num + 2
        this.info = "actions修改数据"
    }
}

})

</code></pre> 
<pre><code>//组件内使用

&lt;template&gt;
  &lt;h1&gt;{<!-- -->{ mainStore.count }}&lt;/h1&gt;
  &lt;h1&gt;{<!-- -->{ mainStore.info }}&lt;/h1&gt;
  &lt;hr /&gt;
  &lt;h1&gt;{<!-- -->{ count }}&lt;/h1&gt;
  &lt;h1&gt;{<!-- -->{ info }}&lt;/h1&gt;
  
 &lt;h1&gt;{<!-- -->{ mainStore.count10 }}&lt;/h1&gt;
 
  &lt;p&gt;
    &lt;button @click="alertData"&gt;修改数据count&lt;/button&gt;
  &lt;/p&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { toRefs } from 'vue'
import { storeToRefs } from 'pinia'
import { useMainStore } from "../../store";
const mainStore = useMainStore();
// 解构数据，但是得到的数据是不具有响应式的，只是一次性的
// 相当于仅仅只是...mainStore而已，只是做了reactive处理，并没有做toRefs
// const { count, info } = useMainStore();
// 解决方法：
// 1. 通过使用toRefs函数，因为前面所说相当于是通过reactive处理，因此可以
// const { count, info } = toRefs(mainStore);
// 2. 通过pinia中提供的storeToRefs方法来解决，推荐使用
const { count, info } = storeToRefs(mainStore);

const alertData = () =&gt; {
  // 方式四：通过 actions 来修改数据
  mainStore.changeState()
  mainStore.changeStates(10)
}

&lt;/script&gt;

&lt;style&gt;
&lt;/style&gt;

</code></pre> 
<p>本文参考文章：<a href="https://juejin.cn/post/7006108454028836895" rel="nofollow" title="Vue3.2 setup语法糖、Composition API、状态库Pinia归纳总结">Vue3.2 setup语法糖、Composition API、状态库Pinia归纳总结</a></p> 
<p><br> 作者：东东吖<br> 链接：https://juejin.cn/post/7079723441674256415<br> 来源：稀土掘金<br> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3d8736806d2292c4ae7ffca745584ced/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">全国大学生数学建模比赛介绍及其入门（国赛&#43;美赛）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/aa0446411a50bb8651da80e916b755f6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2021年CVPR论文Deep Two-View Structure-from-Motion Revisited阅读笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>