<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>nodejs异步和回调 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="nodejs异步和回调" />
<meta property="og:description" content="什么是异步 比如早上起来，我需要洗口3min，烧水3min，冲牛奶，做这三件事的过程我们分析一，假设烧水只需要按一下开关，冲牛奶不耗时
异步：烧水，洗口–&gt;冲牛奶=3min
同步：洗口–&gt;烧水–&gt;冲牛奶=6min
nodejs机制 nodejs是单线程语言，所有事件都是放在一个堆栈中去进行，必须把当前函数栈清空才会去执行后面代码，但是是不是就不能做到异步呢，也不是，它有特例，nodejs针对io操作和部分网络请求提供了异步操作，接下来看一下下面例子
同步例子 function runSync() { for (var i = 0; i &lt; 5; i&#43;&#43;) { var waitUnit = new Date().getTime() &#43; 1000; while (waitUnit &gt; new Date().getTime()) { } console.log(&#39;doing&#39;); } } runSync(); console.log(&#39;end&#39;); 输出结果：
doing doing doing doing doing end 以上就是一个同步的例子，必须等待函数runSync执行完成才会执行下面的log
异步例子 var fs = require(&#39;fs&#39;) function read_file(path){ fs.readFile(path,&#34;UTF-8&#34;,function(err,data){ if(data){ resolve(data); console.log(&#39;resolve&#39;); }else{ reject(err); console.log(&#39;reject&#39;); } }); } read_file(&#39;/Users/jemy/Desktop/player_sdk2.1.5.zip&#39;); console.log(&#39;end&#39;); 输出信息如下：
end resolve 发现先打印了end，这个是为什么呢，因为node内部的io会将readFile这个事件起一个辅助线程，然后就不管它了，而readFile是一个耗时操作，所以会先打印log(‘end’)，当readFile这个耗时操作执行完时会回调告知已经执行完毕" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/68100ccc4617c1a5fc79e3d662cd4a01/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-12T01:29:26+08:00" />
<meta property="article:modified_time" content="2019-03-12T01:29:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">nodejs异步和回调</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>什么是异步</h3> 
<p>比如早上起来，我需要洗口3min，烧水3min，冲牛奶，做这三件事的过程我们分析一，假设烧水只需要按一下开关，冲牛奶不耗时<br> 异步：烧水，洗口–&gt;冲牛奶=3min<br> 同步：洗口–&gt;烧水–&gt;冲牛奶=6min</p> 
<h3><a id="nodejs_5"></a>nodejs机制</h3> 
<p>nodejs是单线程语言，所有事件都是放在一个堆栈中去进行，必须把当前函数栈清空才会去执行后面代码，但是是不是就不能做到异步呢，也不是，它有特例，nodejs针对io操作和部分网络请求提供了异步操作，接下来看一下下面例子</p> 
<h3><a id="_8"></a>同步例子</h3> 
<pre><code>function runSync() {
      for (var i = 0; i &lt; 5; i++) {
        var waitUnit = new Date().getTime() + 1000;
        while (waitUnit &gt; new Date().getTime()) {

        }
        console.log('doing');
      }
}
runSync();
console.log('end');
</code></pre> 
<p>输出结果：</p> 
<pre><code>doing
doing
doing
doing
doing
end
</code></pre> 
<p>以上就是一个同步的例子，必须等待函数runSync执行完成才会执行下面的log</p> 
<h3><a id="_33"></a>异步例子</h3> 
<pre><code>var fs = require('fs')
function read_file(path){
    fs.readFile(path,"UTF-8",function(err,data){
      if(data){
        resolve(data);
        console.log('resolve');
      }else{
        reject(err);
        console.log('reject');
      }
    });
}

read_file('/Users/jemy/Desktop/player_sdk2.1.5.zip');
console.log('end');
</code></pre> 
<p>输出信息如下：</p> 
<pre><code>end
resolve
</code></pre> 
<p>发现先打印了end，这个是为什么呢，因为node内部的io会将readFile这个事件起一个辅助线程，然后就不管它了，而readFile是一个耗时操作，所以会先打印log(‘end’)，当readFile这个耗时操作执行完时会回调告知已经执行完毕</p> 
<h3><a id="nodejs_57"></a>nodejs优缺点</h3> 
<p>比如早期的小白我是这样写代码的(在武汉那种地方，都是java+html+js所谓的全栈)</p> 
<pre><code>var name = '';
$.ajax({
  ...
  success:function(data){name=data.name},
});
$("#name").html(name);
</code></pre> 
<p>最后发现无论如何都不能在html中写进name值<br> 缺点：<br> 1.因为是单线程，一个地方挂了，整个都gg<br> 2.不适用于非IO的复杂性计算，谁在那一直等着你返回<br> 优点：<br> 1.对业务量较小但是IO操作频繁的能够得到充分利用，适用于高并发<br> 2.单线程非阻塞IO了解一下<br> 异步的坑比较多，比如上面我写到的早期的我写代码出现的bug，但是掌握了哪些是异步操作用起来可谓得心应手</p> 
<h3><a id="_75"></a>回调</h3> 
<p>回调这个比较神奇，nodejs很多实现基本上就是异步+回调，那么如何写一个回调函数呢<br> 作为一个由java转向Android的程序员，曾经真是花了不少时间去研究Java中回调的写法 ?<br> 我们直接看一个例子和其中的注释吧</p> 
<pre><code>//别人定义的接口--同步
function printAsTime(name,stop) {
    for(var i = 0;i&lt;5;i++){
    var waitUnit = new Date().getTime()+1000;
      while(waitUnit&gt;new Date().getTime()){

      }
      console.log(name);//3.log一下传进来的参数
    }
    try {
      var str = stop('arg1','arg2','arg3');//4.执行回调函数到调用处
      console.log(str);//7.内部函数接收到来自客户端的返回并打印一下
    } catch (err) {
      console.log('客户端未调用回调方法');//
    }
}


//客户端测试该方法的回调
// function stopPrint(ret01,ret02,ret03){
//   console.log('stop-返回参数'+ret01+'-'+ret02+'-'+ret03);
// }
// console.log('start-function');
// //printAsTime('zhangwei',stopPrint);
// printAsTime('zhangwei');
// console.log('stop-function');

//ES6中定义的箭头指向的匿名函数
console.log('start-function'); //1.start
printAsTime('zhangwei',(ret01,ret02,ret03)=&gt;{//2.执行printAsTime函数
    console.log('stop-返回参数: '+ret01+'-'+ret02+'-'+ret03);//5.匿名函数获取回调返回值提供给客户端处理
    return '回调结束';//6.客户端处理完接口返回的值后还可以再次将客户处理结果返回给内部函数
})
console.log('stop-function');//8.结束
</code></pre> 
<p>结果如下：</p> 
<pre><code>start-function
zhangwei
zhangwei
zhangwei
zhangwei
zhangwei
stop-返回参数: arg1-arg2-arg3
回调结束
stop-function
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c623a1c7239e893b7eeba86e118e7ba6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">notepad&#43;&#43;怎么自动缩进</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8b23c9c2e13c6804392607e1c15c9696/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Oracle数据库的备份与恢复常用方法 详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>