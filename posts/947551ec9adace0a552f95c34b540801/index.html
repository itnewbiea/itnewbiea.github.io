<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>如何对SpringBoot接口参数进行校验？ - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="如何对SpringBoot接口参数进行校验？" />
<meta property="og:description" content="什么是不优雅的参数校验 后端对前端传过来的参数也是需要进行校验的，如果在controller中直接校验需要用大量的if else做判断
以添加用户的接口为例，需要对前端传过来的参数进行校验， 如下的校验就是不优雅的：
@RestController @RequestMapping(&#34;/user&#34;) public class UserController { @PostMapping(&#34;add&#34;) public ResponseEntity&lt;String&gt; add(User user) { if(user.getName()==null) { return ResponseResult.fail(&#34;user name should not be empty&#34;); } else if(user.getName().length()&lt;5 || user.getName().length()&gt;50){ return ResponseResult.fail(&#34;user name length should between 5-50&#34;); } if(user.getAge()&lt; 1 || user.getAge()&gt; 150) { return ResponseResult.fail(&#34;invalid age&#34;); } // ... return ResponseEntity.ok(&#34;success&#34;); } } 针对这个普遍的问题，Java开者在Java API规范 (JSR303) 定义了Bean校验的标准validation-api，但没有提供实现。
hibernate validation是对这个规范的实现，并增加了校验注解如@Email、@Length等。
Spring Validation是对hibernate validation的二次封装，用于支持spring mvc参数自动校验。
接下来，我们以springboot项目为例，介绍Spring Validation的使用。
实现案例 本例子采用 spring validation 对参数绑定进行校验，主要给你提供参数校验的思路。针对接口统一的错误信息（比如绑定参数检查的错误）封装请看" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/947551ec9adace0a552f95c34b540801/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-01T08:07:24+08:00" />
<meta property="article:modified_time" content="2022-11-01T08:07:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何对SpringBoot接口参数进行校验？</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="什么是不优雅的参数校验">什么是不优雅的参数校验</h2> 
<p>后端对前端传过来的参数也是需要进行校验的，如果在controller中直接校验需要用大量的if else做判断</p> 
<p>以添加用户的接口为例，需要对前端传过来的参数进行校验， 如下的校验就是不优雅的：</p> 
<pre><code class="language-java">@RestController
@RequestMapping("/user")
public class UserController {

    @PostMapping("add")
    public ResponseEntity&lt;String&gt; add(User user) {
        if(user.getName()==null) {
            return ResponseResult.fail("user name should not be empty");
        } else if(user.getName().length()&lt;5 || user.getName().length()&gt;50){
            return ResponseResult.fail("user name length should between 5-50");
        }
        if(user.getAge()&lt; 1 || user.getAge()&gt; 150) {
            return ResponseResult.fail("invalid age");
        }
        // ...
        return ResponseEntity.ok("success");
    }
}
</code></pre> 
<p>针对这个普遍的问题，Java开者在Java API规范 (JSR303) 定义了Bean校验的标准<strong>validation-api</strong>，但没有提供实现。</p> 
<p><strong>hibernate validation是对这个规范的实现</strong>，并增加了校验注解如@Email、@Length等。</p> 
<p><strong>Spring Validation是对hibernate validation的二次封装</strong>，用于支持spring mvc参数自动校验。</p> 
<p>接下来，我们以springboot项目为例，介绍Spring Validation的使用。</p> 
<h2 id="实现案例">实现案例</h2> 
<blockquote> 
 <p>本例子采用 spring validation 对参数绑定进行校验，主要给你提供参数校验的思路。针对接口统一的错误信息（比如绑定参数检查的错误）封装请看</p> 
</blockquote> 
<p><a name="_label1_0"></a></p> 
<h4 id="pom">POM</h4> 
<p>添加pom依赖</p> 
<pre><code class="language-java">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-validation --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> 
<p><a name="_label1_1"></a></p> 
<h4 id="请求参数封装">请求参数封装</h4> 
<p>单一职责，所以将查询用户的参数封装到UserParam中， 而不是User（数据库实体）本身。</p> 
<p>对每个参数字段添加validation注解约束和message。</p> 
<pre><code class="language-java">/**
 * user.
 *
 * @author pdai
 */
@Data
@Builder
@ApiModel(value = "User", subTypes = {AddressParam.class})
public class UserParam implements Serializable {

    private static final long serialVersionUID = 1L;

    @NotEmpty(message = "could not be empty")
    private String userId;

    @NotEmpty(message = "could not be empty")
    @Email(message = "invalid email")
    private String email;

    @NotEmpty(message = "could not be empty")
    @Pattern(regexp = "^(\\d{6})(\\d{4})(\\d{2})(\\d{2})(\\d{3})([0-9]|X)$", message = "invalid ID")
    private String cardNo;

    @NotEmpty(message = "could not be empty")
    @Length(min = 1, max = 10, message = "nick name should be 1-10")
    private String nickName;

    @NotEmpty(message = "could not be empty")
    @Range(min = 0, max = 1, message = "sex should be 0-1")
    private int sex;

    @Max(value = 100, message = "Please input valid age")
    private int age;

    @Valid
    private AddressParam address;

}
</code></pre> 
<p><a name="_label1_2"></a></p> 
<h4 id="controller中获取参数绑定结果">Controller中获取参数绑定结果</h4> 
<p>使用@Valid或者@Validate注解，参数校验的值放在BindingResult中</p> 
<pre><code class="language-java">/**
 * @author pdai
 */
@Slf4j
@Api(value = "User Interfaces", tags = "User Interfaces")
@RestController
@RequestMapping("/user")
public class UserController {

    /**
     * http://localhost:8080/user/add .
     *
     * @param userParam user param
     * @return user
     */
    @ApiOperation("Add User")
    @ApiImplicitParam(name = "userParam", type = "body", dataTypeClass = UserParam.class, required = true)
    @PostMapping("add")
    public ResponseEntity&lt;String&gt; add(@Valid @RequestBody UserParam userParam, BindingResult bindingResult) {
        if (bindingResult.hasErrors()) {
            List&lt;ObjectError&gt; errors = bindingResult.getAllErrors();
            errors.forEach(p -&gt; {
                FieldError fieldError = (FieldError) p;
                log.error("Invalid Parameter : object - {},field - {},errorMessage - {}", fieldError.getObjectName(), fieldError.getField(), fieldError.getDefaultMessage());
            });
            return ResponseEntity.badRequest().body("invalid parameter");
        }
        return ResponseEntity.ok("success");
    }
}
</code></pre> 
<p><a name="_label1_3"></a></p> 
<h4 id="校验结果">校验结果</h4> 
<p>POST访问添加User的请求</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/be/b1/fgmrnFYh_o.png"></p> 
<p>后台输出参数绑定错误信息：（包含哪个对象，哪个字段，什么样的错误描述）</p> 
<pre><code class="language-java">2021-09-16 10:37:05.173 ERROR 21216 --- [nio-8080-exec-8] t.p.s.v.controller.UserController        : Invalid Parameter : object - userParam,field - nickName,errorMessage - could not be empty
2021-09-16 10:37:05.176 ERROR 21216 --- [nio-8080-exec-8] t.p.s.v.controller.UserController        : Invalid Parameter : object - userParam,field - email,errorMessage - could not be empty
2021-09-16 10:37:05.176 ERROR 21216 --- [nio-8080-exec-8] t.p.s.v.controller.UserController        : Invalid Parameter : object - userParam,field - cardNo,errorMessage - could not be empty
</code></pre> 
<p>（本例只是springboot-validation的简单用例，针对接口统一的错误信息封装请看</p> 
<h2 id="进一步理解">进一步理解</h2> 
<blockquote> 
 <p>我们再通过一些问题来帮助你更深入理解validation校验。@pdai</p> 
</blockquote> 
<p><a name="_label2_0"></a></p> 
<h4 id="validation分组校验">Validation分组校验？</h4> 
<blockquote> 
 <p>上面的例子中，其实存在一个问题，UserParam既可以作为addUser的参数（id为空），又可以作为updateUser的参数（id不能为空），这时候怎么办呢？分组校验登场。</p> 
</blockquote> 
<pre><code class="language-java">@Data
@Builder
@ApiModel(value = "User", subTypes = {AddressParam.class})
public class UserParam implements Serializable {

    private static final long serialVersionUID = 1L;

    @NotEmpty(message = "could not be empty") // 这里定为空，对于addUser时是不合适的
    private String userId;

}
</code></pre> 
<p>这时候可以使用Validation分组</p> 
<ul><li><strong>先定义分组</strong>（无需实现接口）</li></ul> 
<pre><code class="language-java">public interface AddValidationGroup {
}
public interface EditValidationGroup {
}
</code></pre> 
<ul><li><strong>在UserParam的userId字段添加分组</strong></li></ul> 
<pre><code class="language-java">@Data
@Builder
@ApiModel(value = "User", subTypes = {AddressParam.class})
public class UserParam implements Serializable {

    private static final long serialVersionUID = 1L;

    @NotEmpty(message = "{user.msg.userId.notEmpty}", groups = {EditValidationGroup.class}) // 这里
    private String userId;

}
</code></pre> 
<ul><li><strong>controller中的接口使用校验时使用分组</strong></li></ul> 
<p>PS: 需要使用@Validated注解</p> 
<pre><code class="language-java">@Slf4j
@Api(value = "User Interfaces", tags = "User Interfaces")
@RestController
@RequestMapping("/user")
public class UserController {

    /**
     * http://localhost:8080/user/add .
     *
     * @param userParam user param
     * @return user
     */
    @ApiOperation("Add User")
    @ApiImplicitParam(name = "userParam", type = "body", dataTypeClass = UserParam.class, required = true)
    @PostMapping("add")
    public ResponseEntity&lt;UserParam&gt; add(@Validated(AddValidationGroup.class) @RequestBody UserParam userParam) {
        return ResponseEntity.ok(userParam);
    }

    /**
     * http://localhost:8080/user/add .
     *
     * @param userParam user param
     * @return user
     */
    @ApiOperation("Edit User")
    @ApiImplicitParam(name = "userParam", type = "body", dataTypeClass = UserParam.class, required = true)
    @PostMapping("edit")
    public ResponseEntity&lt;UserParam&gt; edit(@Validated(EditValidationGroup.class) @RequestBody UserParam userParam) {
        return ResponseEntity.ok(userParam);
    }
}
</code></pre> 
<ul><li><strong>测试</strong></li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/48/0c/DGQlwWF7_o.png"></p> 
<p><a name="_label2_1"></a></p> 
<h4 id="validate和valid什么区别">@Validate和@Valid什么区别？</h4> 
<blockquote> 
 <p>细心的你会发现，上个例子中用的是@Validate, 而不是@Valid，那它们之间的区别是什么呢？</p> 
</blockquote> 
<p>在检验Controller的入参是否符合规范时，使用@Validated或者@Valid在基本验证功能上没有太多区别。但是在分组、注解地方、嵌套验证等功能上两个有所不同：</p> 
<ul><li><strong>分组</strong></li></ul> 
<p>@Validated：提供了一个分组功能，可以在入参验证时，根据不同的分组采用不同的验证机制，这个网上也有资料，不详述。@Valid：作为标准JSR-303规范，还没有吸收分组的功能。</p> 
<ul><li><strong>注解地方</strong></li></ul> 
<p>@Validated：可以用在类型、方法和方法参数上。但是不能用在成员属性（字段）上</p> 
<p>@Valid：可以用在方法、构造函数、方法参数和成员属性（字段）上</p> 
<ul><li><strong>嵌套类型</strong></li></ul> 
<p>比如本文例子中的address是user的一个嵌套属性, 只能用@Valid</p> 
<pre><code class="language-java">@Data
@Builder
@ApiModel(value = "User", subTypes = {AddressParam.class})
public class UserParam implements Serializable {

    private static final long serialVersionUID = 1L;

    @Valid // 这里只能用@Valid
    private AddressParam address;

}
</code></pre> 
<p><a name="_label2_2"></a></p> 
<h4 id="有哪些常用的校验">有哪些常用的校验？</h4> 
<blockquote> 
 <p>从以下三类理解。</p> 
</blockquote> 
<ul><li><strong>JSR303/JSR-349</strong>: JSR303是一项标准,只提供规范不提供实现，规定一些校验规范即校验注解，如@Null，@NotNull，@Pattern，位于javax.validation.constraints包下。<strong>JSR-349是其的升级版本，添加了一些新特性</strong>。</li></ul> 
<pre><code class="language-java">@AssertFalse            被注释的元素只能为false
@AssertTrue             被注释的元素只能为true
@DecimalMax             被注释的元素必须小于或等于{value}
@DecimalMin             被注释的元素必须大于或等于{value}
@Digits                 被注释的元素数字的值超出了允许范围(只允许在{integer}位整数和{fraction}位小数范围内)
@Email                  被注释的元素不是一个合法的电子邮件地址
@Future                 被注释的元素需要是一个将来的时间
@FutureOrPresent        被注释的元素需要是一个将来或现在的时间
@Max                    被注释的元素最大不能超过{value}
@Min                    被注释的元素最小不能小于{value}
@Negative               被注释的元素必须是负数
@NegativeOrZero         被注释的元素必须是负数或零
@NotBlank               被注释的元素不能为空
@NotEmpty               被注释的元素不能为空
@NotNull                被注释的元素不能为null
@Null                   被注释的元素必须为null
@Past                   被注释的元素需要是一个过去的时间
@PastOrPresent          被注释的元素需要是一个过去或现在的时间
@Pattern                被注释的元素需要匹配正则表达式"{regexp}"
@Positive               被注释的元素必须是正数
@PositiveOrZero         被注释的元素必须是正数或零
@Size                   被注释的元素个数必须在{min}和{max}之间
</code></pre> 
<ul><li><strong>hibernate validation</strong>：hibernate validation是对这个规范的实现，并增加了一些其他校验注解，如@Email，@Length，@Range等等</li></ul> 
<pre><code class="language-java">@CreditCardNumber       被注释的元素不合法的信用卡号码
@Currency               被注释的元素不合法的货币 (必须是{value}其中之一)
@EAN                    被注释的元素不合法的{type}条形码
@Email                  被注释的元素不是一个合法的电子邮件地址  (已过期)
@Length                 被注释的元素长度需要在{min}和{max}之间
@CodePointLength        被注释的元素长度需要在{min}和{max}之间
@LuhnCheck              被注释的元素${validatedValue}的校验码不合法, Luhn模10校验和不匹配
@Mod10Check             被注释的元素${validatedValue}的校验码不合法, 模10校验和不匹配
@Mod11Check             被注释的元素${validatedValue}的校验码不合法, 模11校验和不匹配
@ModCheck               被注释的元素${validatedValue}的校验码不合法, ${modType}校验和不匹配  (已过期)
@NotBlank               被注释的元素不能为空  (已过期)
@NotEmpty               被注释的元素不能为空  (已过期)
@ParametersScriptAssert 被注释的元素执行脚本表达式"{script}"没有返回期望结果
@Range                  被注释的元素需要在{min}和{max}之间
@SafeHtml               被注释的元素可能有不安全的HTML内容
@ScriptAssert           被注释的元素执行脚本表达式"{script}"没有返回期望结果
@URL                    被注释的元素需要是一个合法的URL
@DurationMax            被注释的元素必须小于${inclusive == true ? '或等于' : ''}${days == 0 ? '' : days += '天'}${hours == 0 ? '' : hours += '小时'}${minutes == 0 ? '' : minutes += '分钟'}${seconds == 0 ? '' : seconds += '秒'}${millis == 0 ? '' : millis += '毫秒'}${nanos == 0 ? '' : nanos += '纳秒'}
@DurationMin            被注释的元素必须大于${inclusive == true ? '或等于' : ''}${days == 0 ? '' : days += '天'}${hours == 0 ? '' : hours += '小时'}${minutes == 0 ? '' : minutes += '分钟'}${seconds == 0 ? '' : seconds += '秒'}${millis == 0 ? '' : millis += '毫秒'}${nanos == 0 ? '' : nanos += '纳秒'}
</code></pre> 
<ul><li><strong>spring validation</strong>：spring validation对hibernate validation进行了二次封装，在springmvc模块中添加了自动校验，并将校验信息封装进了特定的类中</li></ul> 
<p><a name="_label2_3"></a></p> 
<h4 id="自定义validation">自定义validation？</h4> 
<blockquote> 
 <p>如果上面的注解不能满足我们检验参数的要求，我们能不能自定义校验规则呢？ 可以。</p> 
</blockquote> 
<ul><li><strong>定义注解</strong></li></ul> 
<pre><code class="language-java">package tech.pdai.springboot.validation.group.validation.custom;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {TelephoneNumberValidator.class}) // 指定校验器
public @interface TelephoneNumber {
    String message() default "Invalid telephone number";
    Class&lt;?&gt;[] groups() default { };
    Class&lt;? extends Payload&gt;[] payload() default { };
}
</code></pre> 
<ul><li><strong>定义校验器</strong></li></ul> 
<pre><code class="language-java">public class TelephoneNumberValidator implements ConstraintValidator&lt;TelephoneNumber, String&gt; {
    private static final String REGEX_TEL = "0\\d{2,3}[-]?\\d{7,8}|0\\d{2,3}\\s?\\d{7,8}|13[0-9]\\d{8}|15[1089]\\d{8}";

    @Override
    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {
        try {
            return Pattern.matches(REGEX_TEL, s);
        } catch (Exception e) {
            return false;
        }
    }

}
</code></pre> 
<ul><li><strong>使用</strong></li></ul> 
<pre><code class="language-java">@Data
@Builder
@ApiModel(value = "User", subTypes = {AddressParam.class})
public class UserParam implements Serializable {

    private static final long serialVersionUID = 1L;

    @NotEmpty(message = "{user.msg.userId.notEmpty}", groups = {EditValidationGroup.class})
    private String userId;

    @TelephoneNumber(message = "invalid telephone number") // 这里
    private String telephone;

}
</code></pre> 
<h3 id="示例源码"></h3>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cd15f40639760aa804554e0ea47cc783/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Hive配置参数解释</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e5391e41bbfbc367f4f29e02d98bc934/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Uncaught (in promise) TypeError: Cannot read properties of undefined (reading ‘indexOf‘)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>