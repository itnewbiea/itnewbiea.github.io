<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>机器学习_线性回归 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="机器学习_线性回归" />
<meta property="og:description" content="XDU机器学习第一次作业
目录
一、线性回归
二、代价函数的表示
三、梯度下降
四、代码实现
运行结果：
进阶
一、线性回归 回归问题是非常常见的一类问题，目的是寻找变量之间的关系。比如要从数据中寻找房屋面积与价格的关系，年龄和身高的关系，气体压力和体积的关系等等。而机器学习要做的正是要让机器自己来学习这些关系，并为对未知的情况做出预测。
对于线性回归，假设变量之间的关系是线性的，即：
其中 θ\pmb{\theta}θθ 就是学习算法需要学习的参数，在线性回归的问题上，就θ1\theta_{1}θ1​和θ0\theta_{0}θ0​，而 xxx 是我们对于问题所选取的特征，也即输入。hhh表示算法得到的映射。
二、代价函数的表示 为了找到这个算法中合适的参数，我们需要制定一个标准。一般而言算法拟合出来的结果与真实的结果误差越小越好，试想一下如果算法拟合出来的结果与真实值的误差为零，那么就是说算法完美地拟合了数据。所以可以根据“真实值与算法拟合值的误差”来表示算法的“合适程度”。在线性回归中，我们经常使用最小二乘的思路构建代价函数：
这里由假设模型得出。对线性回归任务，代价函数可以展开为：
误差函数的值越小，则代表算法拟合结果与真实结果越接近。 三、梯度下降 梯度下降算法沿着误差函数的反向更新θ\thetaθ的值，知道代价函数收敛到最小值。梯度下降算法更新的方法为：
其中 α表示学习率。对于线性回归的的参数，可以根据代价函数求出其参数更新公式：
四、代码实现 现在让我们开始动手实现，首先让我们回顾一下numpy和matplotlib：
import numpy as np import matplotlib.pyplot as plt #% matplotlib inline def warm_up_exercise(): &#34;&#34;&#34;热身练习&#34;&#34;&#34; # ====================== 你的代码 ========================== # 在下面加入你的代码，使程序返回一个 5x5 的单位矩阵 A = np.eye(5, 5) # ========================================================= return A # 当你的实现正确时，下面会输出一个单位矩阵： print(warm_up_exercise()) 运行结果：
你需要实现绘制数据集中图像的函数，当你的实现|正确时，你应该会得到如下的图像：
def plot_data(x, y): &#34;&#34;&#34;绘制给定数据x与y的图像&#34;&#34;&#34; plt.figure() # ====================== 你的代码 ========================== # 绘制x与y的图像 # 使用 matplotlib." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f4b3d23fedcc8ce256f33dbd1597c47a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-24T15:00:16+08:00" />
<meta property="article:modified_time" content="2021-09-24T15:00:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">机器学习_线性回归</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        XDU机器学习第一次作业</p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92" rel="nofollow" title="一、线性回归">一、线性回归</a></p> 
<p id="%E4%BA%8C%E3%80%81%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA" rel="nofollow" title="二、代价函数的表示">二、代价函数的表示</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D" rel="nofollow" title="三、梯度下降">三、梯度下降</a></p> 
<p id="%C2%A0%E5%9B%9B%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%9B%9B%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow" title=" 四、代码实现"> 四、代码实现</a></p> 
<p id="%C2%A0%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%9A" rel="nofollow" title=" 运行结果："> 运行结果：</a></p> 
<p id="%E8%BF%9B%E9%98%B6-toc" style="margin-left:80px;"><a href="#%E8%BF%9B%E9%98%B6" rel="nofollow" title="进阶">进阶</a></p> 
<hr> 
<h3 id="%E4%B8%80%E3%80%81%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92">一、线性回归</h3> 
<p>        回归问题是非常常见的一类问题，目的是寻找变量之间的关系。比如要从数据中寻找房屋面积与价格的关系，年龄和身高的关系，气体压力和体积的关系等等。而机器学习要做的正是要让机器自己来学习这些关系，并为对未知的情况做出预测。</p> 
<p>        对于线性回归，假设变量之间的关系是线性的，即：</p> 
<p>                                             <img alt="" height="47" src="https://images2.imgbox.com/7d/fd/twfGSjAm_o.png" width="208"></p> 
<p>        其中 θ\pmb{\theta}θθ 就是学习算法需要学习的参数，在线性回归的问题上，就θ1\theta_{1}θ1​和θ0\theta_{0}θ0​，而 xxx 是我们对于问题所选取的特征，也即输入。hhh表示算法得到的映射。</p> 
<h3 id="%E4%BA%8C%E3%80%81%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA"><a id="_26"></a><br><br><br> 二、代价函数的表示</h3> 
<p>        为了找到这个算法中合适的参数，我们需要制定一个标准。一般而言算法拟合出来的结果与真实的结果误差越小越好，试想一下如果算法拟合出来的结果与真实值的误差为零，那么就是说算法完美地拟合了数据。所以可以根据“真实值与算法拟合值的误差”来表示算法的“合适程度”。在线性回归中，我们经常使用最小二乘的思路构建代价函数：</p> 
<p>                                       <img alt="" height="80" src="https://images2.imgbox.com/59/69/PpEQEuD7_o.png" width="250"></p> 
<p>        这里<img alt="" height="38" src="https://images2.imgbox.com/4d/a7/yjgnE393_o.png" width="68">由假设模型得出。对线性回归任务，代价函数可以展开为：</p> 
<p>                                    <img alt="" height="63" src="https://images2.imgbox.com/80/5c/ernKQ1P7_o.png" width="306"> </p> 
<p>        误差函数的值越小，则代表算法拟合结果与真实结果越接近。        </p> 
<h3 id="%E4%B8%89%E3%80%81%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D">三、梯度下降</h3> 
<p>        梯度下降算法沿着误差函数的反向更新θ\thetaθ的值，知道代价函数收敛到最小值。梯度下降算法更新<img alt="" height="28" src="https://images2.imgbox.com/b6/a5/3pXbu8rb_o.png" width="14">的方法为：</p> 
<p>                                   <img alt="" height="53" src="https://images2.imgbox.com/02/70/37VyQlKo_o.png" width="218"></p> 
<p>        其中 α表示学习率。对于线性回归的的参数，可以根据代价函数求出其参数更新公式：</p> 
<p>                                 <img alt="" height="149" src="https://images2.imgbox.com/87/33/pV3Xodjq_o.png" width="309"></p> 
<h3 id="%C2%A0%E5%9B%9B%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"> 四、代码实现</h3> 
<p>         现在让我们开始动手实现，首先让我们回顾一下numpy和matplotlib：</p> 
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
#% matplotlib inline


def warm_up_exercise():
    """热身练习"""
    
    # ====================== 你的代码 ==========================
    # 在下面加入你的代码，使程序返回一个 5x5 的单位矩阵
    A = np.eye(5, 5)
    # =========================================================
    return A

# 当你的实现正确时，下面会输出一个单位矩阵：
print(warm_up_exercise())</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="138" src="https://images2.imgbox.com/98/56/BLAKTtcf_o.png" width="642"></p> 
<p> </p> 
<p></p> 
<p>         你需要实现绘制数据集中图像的函数，当你的实现|正确时，你应该会得到如下的图像：</p> 
<pre><code class="language-python">def plot_data(x, y):
    """绘制给定数据x与y的图像"""
    plt.figure()
    # ====================== 你的代码 ==========================
    # 绘制x与y的图像
    # 使用 matplotlib.pyplt 的命令 plot, xlabel, ylabel 等。
    # 提示：可以使用 'rx' 选项使数据点显示为红色的 "x"，
    #       使用 "markersize=8, markeredgewidth=2" 使标记更大
    # 给制数据
    plt.plot(x, y, 'rx',markersize=8, markeredgewidth=2)
    # 设置y轴标题为 'Profit in $10,000s'
    plt.ylabel('Profit in $10,000s')
    # 设置x轴标题为 'Population of City in 10,000s'
    plt.xlabel('Population of City in 10,000s')

    # =========================================================
    plt.show()
   
#让我们测试一下你的实现是否正确
# 从txt中加载数据
print('Plotting Data ...\n')
data = np.loadtxt('./data/data5984/PRML_LR_data.txt', delimiter=',')
x, y = data[:, 0], data[:, 1]

# 绘图
plot_data(x, y)
plt.show()</code></pre> 
<p> 运行结果：</p> 
<p>        <img alt="" height="404" src="https://images2.imgbox.com/ad/7d/9QNj1lPq_o.png" width="445"></p> 
<p>        现在运用所学的知识，对上述数据利用线性回归进行拟合。首先我们对要学习的参数和数据做一个准备:</p> 
<p></p> 
<pre><code class="language-python"># Add a column of ones to x
m = len(y)
X = np.ones((m, 2))
X[:, 1] = data[:, 0]

# initialize fitting parameters
theta = np.zeros((2, 1))

# Some gradient descent settings
iterations = 1500
alpha = 0.01</code></pre> 
<p>         计算初始误差函数的值，你需要实现误差函数的计算：</p> 
<pre><code class="language-python">def compute_cost(X, y, theta):
    """计算线性回归的代价。"""
    m = len(y)
    J = 0.0
    # ====================== 你的代码 ==========================
    # 计算给定 theta 参数下线性回归的代价
    # 请将正确的代价赋值给 J
    for i in range (m):
        temp = theta[0, :] + theta[1, :]*X[i, -1:] - y[i]
        J = J + temp*temp
    J = J/(2*m)
    # =========================================================
    return J

# compute and display initial cost
# Expected value 32.07
J0 = compute_cost(X, y, theta)
print(J0)</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="385" src="https://images2.imgbox.com/6e/c0/llMnDean_o.png" width="1200"></p> 
<p>         现在你验证了代价计算的正确性，接下来就需要实现最核心的部分：梯度下降。在实现这一部分之前，确定你理解了上述各种变量及其表示。你需要完成梯度下降的核心代码部分：</p> 
<pre><code class="language-python">def gradient_descent(X, y, theta, alpha, num_iters):
    """执行梯度下降算法来学习参数 theta。"""
    m = len(y)
    J_history = np.zeros((num_iters,))
    for iter in range(num_iters):
        
        # ====================== 你的代码 ==========================
        # 计算给定 theta 参数下线性回归的梯度，实现梯度下降算法
        sum0 = 0.
        sum1 = 0.
        for i in range(m):
            temp0 = theta[0, -1:] + theta[1, -1:]*X[i, -1:] - y[i]
            temp1 = (theta[0, -1:] + theta[1, -1:]*X[i, -1:] - y[i])*X[i, -1:]
            
            sum0 = sum0 + temp0
            sum1 = sum1 + temp1

        sum0 = sum0 / m
        sum1 = sum1 / m 
        theta[0, :] = theta[0, :] - alpha*sum0
        theta[1, -1:] = theta[1, -1:] - alpha*sum1

        # =========================================================
        # 将各次迭代后的代价进行记录
        J_history[iter] = compute_cost(X, y, theta)

    return theta, J_history

# run gradient descent
# Expected value: theta = [-3.630291, 1.166362]
theta, J_history = gradient_descent(X, y, theta,
                                    alpha, iterations)
print(theta)</code></pre> 
<p> 运行结果：</p> 
<p><img alt="" height="377" src="https://images2.imgbox.com/66/4e/eet3WfRQ_o.png" width="1200"></p> 
<p></p> 
<p> 为了验证梯度下降方法实现的正确性，你需要把学习的到的直线绘制出来，确定你的实现是否正确。前面你已经绘制了数据集中的点，现在你需要在点的基础上绘制一条直线，如果你的实现正确，那么得到的图像应该是如下这样： </p> 
<p><img alt="" height="476" src="https://images2.imgbox.com/7e/69/lNrJnM1O_o.png" width="676"></p> 
<p>         现在你已经正确实现了线性回归，你可能会对误差函数的优化过程比较好奇。为了更好地理解这个过程，你可以将损失函数的图像绘制出来。为此你需要将需要优化的参数的各个取值时误差函数的取值在图像上绘制出来，以下代码需要你进行填写。</p> 
<p>        </p> 
<pre><code class="language-python">plt.figure()
plt.plot(x, y, 'rx',markersize=8, markeredgewidth=2)

plt.ylabel('Profit in $10,000s')
plt.xlabel('Population of City in 10,000s')

y_predict = theta[1]*x+theta[0]
plt.plot(x,y_predict)

plt.show()</code></pre> 
<h4 id="%C2%A0%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%9A"> 运行结果：</h4> 
<p>        <img alt="" height="369" src="https://images2.imgbox.com/89/22/aesJeM3C_o.png" width="490"></p> 
<hr> 
<h4 id="%E8%BF%9B%E9%98%B6">进阶</h4> 
<p>        在实现中，你可能采取了像上面公式中给出的结果一样逐个样本计算代价函数，或者在梯度下降的更新时也采用了逐个样本计算的方式。但事实上，你可以采用numpy的矩阵函数一次性计算所有样本的代价函数。可以采用矩阵乘法(np.matmul())求和等方式（np.sum（））。利用你学到的线性代数知识，将其实现更改一下吧。</p> 
<p>        在梯度更新时，我们保留了代价的历史信息。在参数的学习过程中，代价函数的变化过程你也可以作一个图来查看。观察最后得到的J(θ)J(\theta)J(θ)的图像以及代价的变化过程，可以加深你的理解。在梯度下降的迭代中，我们设置终止条件为完成了固定的迭代次数，但是在迭代次数完成时，由于学习率等参数的设置，可能得到的参数并不是使得代价最低的值。你可以通过观察代价函数的变化过程，想办法调整学习率等参数或者改进程序，使得参数的取值为搜索到的最优结果。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3505d79db21f60b63ece34cde602342f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">常用电脑快捷键</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e95cd3341adbb8c2da3cbfb66879896a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">图神经网络的分类</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>