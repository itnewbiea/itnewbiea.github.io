<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>netty源码之Channel：注重NioServerSockerChannel和NioSocketChannel - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="netty源码之Channel：注重NioServerSockerChannel和NioSocketChannel" />
<meta property="og:description" content="netty源码之Channel：注重NioServerSockerChannel和NioSocketChannel 类结构展示1、NioServerSockerChannel的类结构：2、NioSocketChannel的类结构： 顶层接口Channel骨架类AbstractChannel1、属性2、构造方法3、实现方法 NIO骨架类AbstractNioChannel1、新增的属性2、构造方法3、实例方法doRegister()方法doBeginRead()方法 AbstractNioMessageChannel1、newUnsafe()2、doWrite(ChannelOutboundBuffer in)方法 AbstractNioByteChannel1、newUnsafe()方法2、doWrite(ChannelOutboundBuffer in)方法3、clearOpWrite()方法4、doWriteInternal(ChannelOutboundBuffer in, Object msg)5、incompleteWrite(boolean setOpWrite)方法 NioServerSocketChannel1、构造方法2、doBind(SocketAddress localAddress)方法3、doReadMessages(List buf)方法 NioSocketChannel1、构造方法2、doBind(SocketAddress localAddress)方法3、doConnect(SocketAddress remoteAddress, SocketAddress localAddress)方法4、doWrite(ChannelOutboundBuffer in)方法 类结构展示 1、NioServerSockerChannel的类结构： 2、NioSocketChannel的类结构： 顶层接口Channel Channel接口中还包含了另一个顶层接口Unsafe，其实这个Unsafe才是承受了最多的脏活累活的家伙。
id()方法返回Channel实例的id。
eventLoop()方法返回给Channel实例关联的EventLoop实例。
parent()方法返回该Channel的父Channel，服务端才有。
unsafe()方法返回该Channel使用的Unsafe实例。
pipeline()方法返回该Channel关联的ChannelPipeline实例。
alloc()方法返回该Channel的内存分配器ByteBufAllocator实例。
read()和flush()是两个出站方法，会调用pipeline的出站方法。
骨架类AbstractChannel 1、属性 定义了netty网络通信的基本属性。
2、构造方法 id是netty提供了一个实现算法。
unsafe是一个钩子方法，执行时调用子类实现方法。
pipeline是new了一个DefaultChannelPipeline。注意，这里实例化DefaultChannelPipeline的时候就会创建HeadContext和TailContext。
3、实现方法 实现了诸如上面的一些网络通信方法，但是只是单纯调用了pipeline的对应方法。
此外，还定义了一批抽象方法，让子类去具体实现。
NIO骨架类AbstractNioChannel 1、新增的属性 新增了网络通信中NIO模式使用的对象，selector用到的一些东西。
SelectableChannel，这个玩意是java提供的，代码中看到的javaChannel()方法返回的就是这个玩意，类比于NIO编程中的ServerSocketChannel和SocketChannel。
2、构造方法 调用父类实例化unsafe和pipline。
赋值SelectableChannel，构造方法传入。
赋值感兴趣的操作readInterestOp，构造方法传入。
设置SelectableChannel为非阻塞模式，类比于NIO设置ServerSockerChannle启动时设置非阻塞模式。
3、实例方法 doRegister()方法 做的事情也很简单，将channel注册到selector上，但是注册的事件是一个0，以为着不关注任何事件。
doBeginRead()方法 检查当前channel的selectionKey，并将构造函数传进来的readInterestOp事件类型添加到其中，表示该channel开始关注readInterestOp事件。
AbstractNioMessageChannel 1、newUnsafe() 负责自己及其子类的unsafe实例化。NioMessageUnsafe的实例。
2、doWrite(ChannelOutboundBuffer in)方法 在一个死循环中进行写操作，具体的操作在一个抽象方法中，由具体的子类实现，如果发现ChannelOutboundBuffer中的内容已经全部写完，则取消对写事件的关注。如果在写数据的时候发现缓冲区满了写不进去，就继续关注写事件。
AbstractNioByteChannel 1、newUnsafe()方法 负责自己及其子类的unsafe实例化。NioByteUnsafe的实例。
2、doWrite(ChannelOutboundBuffer in)方法 首先获取一次性默认写次数限制writeSpinCount，默认值是16，表示该线程在这次写任务中最多写16次，到了16次还没有写完的化，也会释放线程的控制权，将剩余的写需求封装成任务入队列。这样设计的目的是防止有大文件的操作一直占用io线程。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/65596101b5a34e5d80f2ec5a349d28c5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-09T17:45:56+08:00" />
<meta property="article:modified_time" content="2022-06-09T17:45:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">netty源码之Channel：注重NioServerSockerChannel和NioSocketChannel</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>netty源码之Channel：注重NioServerSockerChannel和NioSocketChannel</h4> 
 <ul><li><a href="#_1" rel="nofollow">类结构展示</a></li><li><ul><li><a href="#1NioServerSockerChannel_2" rel="nofollow">1、NioServerSockerChannel的类结构：</a></li><li><a href="#2NioSocketChannel_4" rel="nofollow">2、NioSocketChannel的类结构：</a></li></ul> 
  </li><li><a href="#Channel_6" rel="nofollow">顶层接口Channel</a></li><li><a href="#AbstractChannel_16" rel="nofollow">骨架类AbstractChannel</a></li><li><ul><li><a href="#1_17" rel="nofollow">1、属性</a></li><li><a href="#2_20" rel="nofollow">2、构造方法</a></li><li><a href="#3_26" rel="nofollow">3、实现方法</a></li></ul> 
  </li><li><a href="#NIOAbstractNioChannel_31" rel="nofollow">NIO骨架类AbstractNioChannel</a></li><li><ul><li><a href="#1_32" rel="nofollow">1、新增的属性</a></li><li><a href="#2_36" rel="nofollow">2、构造方法</a></li><li><a href="#3_42" rel="nofollow">3、实例方法</a></li><li><ul><li><a href="#doRegister_43" rel="nofollow">doRegister()方法</a></li><li><a href="#doBeginRead_46" rel="nofollow">doBeginRead()方法</a></li></ul> 
  </li></ul> 
  </li><li><a href="#AbstractNioMessageChannel_49" rel="nofollow">AbstractNioMessageChannel</a></li><li><ul><li><a href="#1newUnsafe_50" rel="nofollow">1、newUnsafe()</a></li><li><a href="#2doWriteChannelOutboundBuffer_in_53" rel="nofollow">2、doWrite(ChannelOutboundBuffer in)方法</a></li></ul> 
  </li><li><a href="#AbstractNioByteChannel_56" rel="nofollow">AbstractNioByteChannel</a></li><li><ul><li><a href="#1newUnsafe_57" rel="nofollow">1、newUnsafe()方法</a></li><li><a href="#2doWriteChannelOutboundBuffer_in_59" rel="nofollow">2、doWrite(ChannelOutboundBuffer in)方法</a></li><li><a href="#3clearOpWrite_68" rel="nofollow">3、clearOpWrite()方法</a></li><li><a href="#4doWriteInternalChannelOutboundBuffer_in_Object_msg_71" rel="nofollow">4、doWriteInternal(ChannelOutboundBuffer in, Object msg)</a></li><li><a href="#5incompleteWriteboolean_setOpWrite_74" rel="nofollow">5、incompleteWrite(boolean setOpWrite)方法</a></li></ul> 
  </li><li><a href="#NioServerSocketChannel_79" rel="nofollow">NioServerSocketChannel</a></li><li><ul><li><a href="#1_80" rel="nofollow">1、构造方法</a></li><li><a href="#2doBindSocketAddress_localAddress_93" rel="nofollow">2、doBind(SocketAddress localAddress)方法</a></li><li><a href="#3doReadMessagesListObject_buf_96" rel="nofollow">3、doReadMessages(List buf)方法</a></li></ul> 
  </li><li><a href="#NioSocketChannel_100" rel="nofollow">NioSocketChannel</a></li><li><ul><li><a href="#1_101" rel="nofollow">1、构造方法</a></li><li><a href="#2doBindSocketAddress_localAddress_104" rel="nofollow">2、doBind(SocketAddress localAddress)方法</a></li><li><a href="#3doConnectSocketAddress_remoteAddress_SocketAddress_localAddress_107" rel="nofollow">3、doConnect(SocketAddress remoteAddress, SocketAddress localAddress)方法</a></li><li><a href="#4doWriteChannelOutboundBuffer_in_110" rel="nofollow">4、doWrite(ChannelOutboundBuffer in)方法</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>类结构展示</h2> 
<h3><a id="1NioServerSockerChannel_2"></a>1、NioServerSockerChannel的类结构：</h3> 
<p><img src="https://images2.imgbox.com/a3/fa/WE8f8rRs_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2NioSocketChannel_4"></a>2、NioSocketChannel的类结构：</h3> 
<p><img src="https://images2.imgbox.com/9b/9e/35GZaxam_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Channel_6"></a>顶层接口Channel</h2> 
<p><img src="https://images2.imgbox.com/be/f7/0YPWXPH9_o.png" alt="在这里插入图片描述"><br> Channel接口中还包含了另一个顶层接口Unsafe，其实这个Unsafe才是承受了最多的脏活累活的家伙。<br> id()方法返回Channel实例的id。<br> eventLoop()方法返回给Channel实例关联的EventLoop实例。<br> parent()方法返回该Channel的父Channel，服务端才有。<br> unsafe()方法返回该Channel使用的Unsafe实例。<br> pipeline()方法返回该Channel关联的ChannelPipeline实例。<br> alloc()方法返回该Channel的内存分配器ByteBufAllocator实例。<br> read()和flush()是两个出站方法，会调用pipeline的出站方法。</p> 
<h2><a id="AbstractChannel_16"></a>骨架类AbstractChannel</h2> 
<h3><a id="1_17"></a>1、属性</h3> 
<p><img src="https://images2.imgbox.com/da/5b/GStZmGjN_o.png" alt="在这里插入图片描述"><br> 定义了netty网络通信的基本属性。</p> 
<h3><a id="2_20"></a>2、构造方法</h3> 
<p><img src="https://images2.imgbox.com/e1/9e/kZ9u8Sws_o.png" alt="在这里插入图片描述"></p> 
<p>id是netty提供了一个实现算法。<br> unsafe是一个钩子方法，执行时调用子类实现方法。<br> pipeline是new了一个DefaultChannelPipeline。注意，这里实例化DefaultChannelPipeline的时候就会创建HeadContext和TailContext。</p> 
<h3><a id="3_26"></a>3、实现方法</h3> 
<p><img src="https://images2.imgbox.com/ef/79/CgMSucVC_o.png" alt="在这里插入图片描述"><br> 实现了诸如上面的一些网络通信方法，但是只是单纯调用了pipeline的对应方法。<br> 此外，还定义了一批抽象方法，让子类去具体实现。<br> <img src="https://images2.imgbox.com/a6/10/inYx7w2V_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="NIOAbstractNioChannel_31"></a>NIO骨架类AbstractNioChannel</h2> 
<h3><a id="1_32"></a>1、新增的属性</h3> 
<p><img src="https://images2.imgbox.com/4d/71/cjq6b8C8_o.png" alt="在这里插入图片描述"><br> 新增了网络通信中NIO模式使用的对象，selector用到的一些东西。<br> SelectableChannel，这个玩意是java提供的，代码中看到的javaChannel()方法返回的就是这个玩意，类比于NIO编程中的ServerSocketChannel和SocketChannel。</p> 
<h3><a id="2_36"></a>2、构造方法</h3> 
<p><img src="https://images2.imgbox.com/0c/df/Z2BFrNOa_o.png" alt="在这里插入图片描述"><br> 调用父类实例化unsafe和pipline。<br> 赋值SelectableChannel，构造方法传入。<br> 赋值感兴趣的操作readInterestOp，构造方法传入。<br> 设置SelectableChannel为非阻塞模式，类比于NIO设置ServerSockerChannle启动时设置非阻塞模式。</p> 
<h3><a id="3_42"></a>3、实例方法</h3> 
<h4><a id="doRegister_43"></a>doRegister()方法</h4> 
<p><img src="https://images2.imgbox.com/c4/72/iAPBMkTY_o.png" alt="在这里插入图片描述"><br> 做的事情也很简单，将channel注册到selector上，但是注册的事件是一个0，以为着不关注任何事件。</p> 
<h4><a id="doBeginRead_46"></a>doBeginRead()方法</h4> 
<p><img src="https://images2.imgbox.com/df/8c/gXEjrnCZ_o.png" alt="在这里插入图片描述"><br> 检查当前channel的selectionKey，并将构造函数传进来的readInterestOp事件类型添加到其中，表示该channel开始关注readInterestOp事件。</p> 
<h2><a id="AbstractNioMessageChannel_49"></a>AbstractNioMessageChannel</h2> 
<h3><a id="1newUnsafe_50"></a>1、newUnsafe()</h3> 
<p><img src="https://images2.imgbox.com/cf/1b/rUHbU3aq_o.png" alt="在这里插入图片描述"><br> 负责自己及其子类的unsafe实例化。NioMessageUnsafe的实例。</p> 
<h3><a id="2doWriteChannelOutboundBuffer_in_53"></a>2、doWrite(ChannelOutboundBuffer in)方法</h3> 
<p><img src="https://images2.imgbox.com/4b/76/MDHWoexF_o.png" alt="在这里插入图片描述"><br> 在一个死循环中进行写操作，具体的操作在一个抽象方法中，由具体的子类实现，如果发现ChannelOutboundBuffer中的内容已经全部写完，则取消对写事件的关注。如果在写数据的时候发现缓冲区满了写不进去，就继续关注写事件。</p> 
<h2><a id="AbstractNioByteChannel_56"></a>AbstractNioByteChannel</h2> 
<h3><a id="1newUnsafe_57"></a>1、newUnsafe()方法</h3> 
<p><img src="https://images2.imgbox.com/b7/8f/6SUvNL3S_o.png" alt="在这里插入图片描述">负责自己及其子类的unsafe实例化。NioByteUnsafe的实例。</p> 
<h3><a id="2doWriteChannelOutboundBuffer_in_59"></a>2、doWrite(ChannelOutboundBuffer in)方法</h3> 
<p><img src="https://images2.imgbox.com/9b/ad/ObN2UUxR_o.png" alt="在这里插入图片描述"><br> 首先获取一次性默认写次数限制writeSpinCount，默认值是16，表示该线程在这次写任务中最多写16次，到了16次还没有写完的化，也会释放线程的控制权，将剩余的写需求封装成任务入队列。这样设计的目的是防止有大文件的操作一直占用io线程。</p> 
<p>如果已经写完了，取消关注写事件。</p> 
<p>调用doWriteInternal（）方法去执行写操作，正常情况会返回1。</p> 
<p>最后判断writeSpinCount与0的大小关系进行incompleteWrite（）处理。</p> 
<h3><a id="3clearOpWrite_68"></a>3、clearOpWrite()方法</h3> 
<p><img src="https://images2.imgbox.com/b3/e8/5RVSWoCq_o.png" alt="在这里插入图片描述"><br> 很easy.</p> 
<h3><a id="4doWriteInternalChannelOutboundBuffer_in_Object_msg_71"></a>4、doWriteInternal(ChannelOutboundBuffer in, Object msg)</h3> 
<p><img src="https://images2.imgbox.com/0b/e6/FDlbooOd_o.png" alt="在这里插入图片描述"><br> 对ByteBuf和文件类型是两种处理方法，但是具体的写操作还是放在了子类中实现。</p> 
<h3><a id="5incompleteWriteboolean_setOpWrite_74"></a>5、incompleteWrite(boolean setOpWrite)方法</h3> 
<p><img src="https://images2.imgbox.com/92/ce/DXGO2hgy_o.png" alt="在这里插入图片描述"><br> 分别对没有写完消息的两种情况作了处理。<br> 如果是因为缓冲区满了，就注册关注写事件，代写缓冲区有空间了继续写。<br> 如果是因为写了16次还没有写完，就生成任务放进线程队列后续继续写。</p> 
<h2><a id="NioServerSocketChannel_79"></a>NioServerSocketChannel</h2> 
<h3><a id="1_80"></a>1、构造方法</h3> 
<p><img src="https://images2.imgbox.com/a3/f6/eWm7QfTr_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">SelectorProvider</span> DEFAULT_SELECTOR_PROVIDER 
	<span class="token operator">=</span> <span class="token class-name">SelectorProvider</span><span class="token punctuation">.</span><span class="token function">provider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/f9/76/LJC171HG_o.png" alt="在这里插入图片描述"><br> 调用JDK NIO的方法返回一个SelectorProvider，这个东西跟操作系统有关，有WindowsSelectorProvider和LinuxSelectorProvider。<br> <img src="https://images2.imgbox.com/16/ce/6r5olkJw_o.png" alt="在这里插入图片描述"><br> 返回一个JDK的ServerSockerChannel。<br> <img src="https://images2.imgbox.com/3f/ce/MDWcg9Do_o.png" alt="在这里插入图片描述"><br> 调用父类的构造方法，注意参数SelectionKey.OP_ACCEPT，它会传递给AbstractNioChannel类将readInterestOp属性赋值，并在其doBeginRead()方法时注册该事件，表示该channel关注接收连接事件。</p> 
<h3><a id="2doBindSocketAddress_localAddress_93"></a>2、doBind(SocketAddress localAddress)方法</h3> 
<p><img src="https://images2.imgbox.com/73/0f/Va5QzDHX_o.png" alt="在这里插入图片描述"><br> 调用JDK channel的绑定方法进行绑定。</p> 
<h3><a id="3doReadMessagesListObject_buf_96"></a>3、doReadMessages(List buf)方法</h3> 
<p>该方法是NioServerSocketChannel的重点，表示接收连接行为。<br> <img src="https://images2.imgbox.com/c3/d0/EWdh5Kix_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/af/b7/ty9h8vR2_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="NioSocketChannel_100"></a>NioSocketChannel</h2> 
<h3><a id="1_101"></a>1、构造方法</h3> 
<p><img src="https://images2.imgbox.com/17/eb/7XHibfc5_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ad/d6/0FpCV3SH_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2doBindSocketAddress_localAddress_104"></a>2、doBind(SocketAddress localAddress)方法</h3> 
<p><img src="https://images2.imgbox.com/2f/06/GxJSh7RS_o.png" alt="在这里插入图片描述"><br> 一样是调用JDK的底层方法。</p> 
<h3><a id="3doConnectSocketAddress_remoteAddress_SocketAddress_localAddress_107"></a>3、doConnect(SocketAddress remoteAddress, SocketAddress localAddress)方法</h3> 
<p><img src="https://images2.imgbox.com/9a/59/rfTqbtx9_o.png" alt="在这里插入图片描述"><br> 调用底层方法进行连接，因为行为是异步的，如果没有直接连接的话，会给channel注册关注连接事件。</p> 
<h3><a id="4doWriteChannelOutboundBuffer_in_110"></a>4、doWrite(ChannelOutboundBuffer in)方法</h3> 
<p><img src="https://images2.imgbox.com/44/e0/6PFD5kfc_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/33/f6/oORoihjw_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/5b/d6/HTFF2tHV_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/95e00eaa7422c9e8bd251a227dd9b66b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">uniapp中sqlite数据库常用操作的简单封装</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ae5d0ed0ab8285e9f22dba39a97de513/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于37%法则的探究</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>