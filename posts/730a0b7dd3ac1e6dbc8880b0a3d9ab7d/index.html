<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java死锁的原因例子及解决方法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java死锁的原因例子及解决方法" />
<meta property="og:description" content="Java发生死锁的根本原因是：在申请锁时发生了交叉闭环申请。即线程在获得了锁A并且没有释放的情况下去申请锁B，这时，另一个线程已经获得了锁B，在释放锁B之前又要先获得锁A，因此闭环发生，陷入死锁循环。
死锁发生的例子1：
public class DeadLockA extends Thread { @Override public void run() { try{ System.out.println(&#34;LockA running&#34;); while(true){ synchronized(Client.obj1){ System.out.println(&#34;LockA locked obj1&#34;); //获取obj1后先等一会儿，让LockB有足够的时间锁住obj2 Thread.sleep(100); System.out.println(&#34;LockA trying to lock obj2...&#34;); synchronized(Client.obj2){ System.out.println(&#34;LockA locked obj2&#34;); } } } }catch(Exception e){ e.printStackTrace(); } } } public class DeadLockB extends Thread { @Override public void run() { try{ System.out.println(&#34;LockB running&#34;); while(true){ synchronized(Client.obj2){ System.out.println(&#34;LockB locked obj2&#34;); System.out.println(&#34;LockB trying to lock obj1...&#34;); synchronized(Client.obj1){ System.out.println(&#34;LockB locked obj1&#34;); } } } }catch(Exception e){ e." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/730a0b7dd3ac1e6dbc8880b0a3d9ab7d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-17T09:26:04+08:00" />
<meta property="article:modified_time" content="2018-07-17T09:26:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java死锁的原因例子及解决方法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><font color="black">Java发生死锁的根本原因是：在申请锁时发生了交叉闭环申请。即线程在获得了锁A并且没有释放的情况下去申请锁B，这时，另一个线程已经获得了锁B，在释放锁B之前又要先获得锁A，因此闭环发生，陷入死锁循环。</font></p> 
<p><font color="black"><strong>死锁发生的例子1：</strong></font></p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLockA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> {<!-- --></span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
        <span class="hljs-keyword">try</span>{
            System.out.println(<span class="hljs-string">"LockA running"</span>);
            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
                <span class="hljs-keyword">synchronized</span>(Client.obj1){
                    System.out.println(<span class="hljs-string">"LockA locked obj1"</span>);
                    <span class="hljs-comment">//获取obj1后先等一会儿，让LockB有足够的时间锁住obj2</span>
                    Thread.sleep(<span class="hljs-number">100</span>);
                    System.out.println(<span class="hljs-string">"LockA trying to lock obj2..."</span>);
                    <span class="hljs-keyword">synchronized</span>(Client.obj2){
                        System.out.println(<span class="hljs-string">"LockA locked obj2"</span>);
                    }
                }
            }
        }<span class="hljs-keyword">catch</span>(Exception e){
            e.printStackTrace();
        }
    }
}</code></pre> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLockB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> {<!-- --></span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
        <span class="hljs-keyword">try</span>{
            System.out.println(<span class="hljs-string">"LockB running"</span>);
            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
                <span class="hljs-keyword">synchronized</span>(Client.obj2){
                    System.out.println(<span class="hljs-string">"LockB locked obj2"</span>);
                    System.out.println(<span class="hljs-string">"LockB trying to lock obj1..."</span>);
                    <span class="hljs-keyword">synchronized</span>(Client.obj1){
                        System.out.println(<span class="hljs-string">"LockB locked obj1"</span>);
                    }
                }
            }
        }<span class="hljs-keyword">catch</span>(Exception e){
            e.printStackTrace();
        }
    }
}
</code></pre> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String obj1 = <span class="hljs-string">"obj1"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String obj2 = <span class="hljs-string">"obj2"</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] ars) {
        <span class="hljs-keyword">new</span> DeadLockA().start();
        <span class="hljs-keyword">new</span> DeadLockB().start();
    }
}</code></pre> 
<p><font color="black">运行结果：</font> <br> <img src="https://images2.imgbox.com/be/41/pvlKM4KZ_o.jpg" alt="这里写图片描述" title=""> <br> <font color="black">结果显示两个线程最后都在等待对方释放锁，最终进入了死锁状态。</font></p> 
<p><font color="black"><strong>死锁发生的例子2：</strong></font></p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span> {<!-- --></span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span>(TestClass clazz) {
        System.out.println(<span class="hljs-string">"TestClass method in"</span>);
        clazz.method2();
        System.out.println(<span class="hljs-string">"TestClass method out"</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span>() {
        System.out.println(<span class="hljs-string">"TestClass method2"</span>);
    }
}
</code></pre> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> {<!-- --></span>
    <span class="hljs-keyword">private</span> TestClass class1;
    <span class="hljs-keyword">private</span> TestClass class2;

    <span class="hljs-keyword">public</span> <span class="hljs-title">TestLock</span>(TestClass class1, TestClass class2) {
        <span class="hljs-keyword">this</span>.class1 = class1;
        <span class="hljs-keyword">this</span>.class2 = class2;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
        class1.method(class2);
    }
}
</code></pre> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] ars) {
        TestClass classA = <span class="hljs-keyword">new</span> TestClass();
        TestClass classB = <span class="hljs-keyword">new</span> TestClass();
        <span class="hljs-keyword">new</span> TestLock(classA, classB).start();
        <span class="hljs-keyword">new</span> TestLock(classB, classA).start();
    }
}</code></pre> 
<p><font color="black">运行结果：</font> <br> <img src="https://images2.imgbox.com/78/fc/45ZVWXyR_o.jpg" alt="这里写图片描述" title=""> <br> <font color="black">结果显示进入两次方法，但是并没有走完，发生死锁。</font></p> 
<p><font color="black">一旦出现死锁，整个程序既不会发生任何错误，也不会给出任何提示，只是所有线程处于阻塞状态，无法继续。java虚拟机没有提供检测，也没有采取任何措施来处理死锁的情况，所以多线程编程中，必须手动应该采取措施避免死锁。</font></p> 
<p><font color="black"><strong>解决方法：</strong></font></p> 
<p><font color="black"><strong>1.调整申请锁的范围</strong></font></p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span> {<!-- --></span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span>(TestClass clazz) {
        System.out.println(<span class="hljs-string">"TestClass method in"</span>);
        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>){
            <span class="hljs-comment">//do something</span>
        }
        clazz.method2();
        System.out.println(<span class="hljs-string">"TestClass method out"</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span>() {
        System.out.println(<span class="hljs-string">"TestClass method2"</span>);
    }
}</code></pre> 
<p><font color="black">上面代码原来锁是加在方法上的，现在改为在方法内的一部分，这样在使用第二个锁时本身的锁已经释放了。如果减小锁的申请范围可以避免锁的申请发生闭环的话，那么就可以避免死锁。</font></p> 
<p><font color="black"><strong>2.调整申请锁的顺序</strong></font></p> 
<p><font color="black">在有些情况下是不允许我们调整锁的范围的，比如银行转账的场景下，我们必须同时获得两个账户上的锁，才能进行操作，两个锁的申请必须发生交叉。这时要想打破死锁闭环，必须调整锁的申请顺序，总是以相同的顺序来申请锁，比如总是先申请 id 大的账户上的锁 ，然后再申请 id 小的账户上的锁，这样就无法形成导致死锁的那个闭环。</font></p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> {<!-- --></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-comment">// 主键</span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> balance;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span>(Account from, Account to, <span class="hljs-keyword">double</span> money){
        <span class="hljs-keyword">if</span>(from.getId() &gt; to.getId()){
            <span class="hljs-keyword">synchronized</span>(from){
                <span class="hljs-keyword">synchronized</span>(to){
                    <span class="hljs-comment">// transfer</span>
                }
            }
        }<span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">synchronized</span>(to){
                <span class="hljs-keyword">synchronized</span>(from){
                    <span class="hljs-comment">// transfer</span>
                }
            }
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span>() {
        <span class="hljs-keyword">return</span> id;
    }
}</code></pre> 
<p><font color="black">这样的话，即使发生了两个账户比如 id=1的和id=100的两个账户相互转账，因为不管是哪个线程先获得了id=100上的锁，另外一个线程都不会去获得id=1上的锁(因为他没有获得id=100上的锁)，只能是哪个线程先获得id=100上的锁，哪个线程就先进行转账。这里除了使用id之外，如果没有类似id这样的属性可以比较，那么也可以使用对象的hashCode()的值来进行比较。</font></p> 
<p><font color="black"><strong>避免死锁的发生</strong></font></p> 
<p><font color="black">很多时候实际锁的交叉可能涉及很多个，要想很好的避免只能人工仔细检查，一旦我们在一个同步方法中，或者说在一个锁的保护的范围中，调用了其它对象的方法时，就要十分的小心：</font></p> 
<p><font color="black">1. 如果其它对象的这个方法会消耗比较长的时间，那么就会导致锁被我们持有了很长的时间；</font> <br> <font color="black">2. 如果其它对象的这个方法是一个同步方法，那么就要注意避免发生死锁的可能性了；</font></p> 
<p><font color="black">总之是尽量避免在一个同步方法中调用其它对象的延时方法和同步方法。</font></p> 
<p><br></p> 
<p>参考： <br> <a href="https://blog.csdn.net/xidianliuy/article/details/51568073">https://blog.csdn.net/xidianliuy/article/details/51568073</a> <br> <a href="https://blog.csdn.net/m0_38126177/article/details/78587845">https://blog.csdn.net/m0_38126177/article/details/78587845</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3b4888b350a02814b1939a43ebcd981f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">台式电脑怎么使用iPhone热点进行上网</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c6f95413b7177c5ba74eecb1da5e7c8a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用JetbrainsCrack-2.6.10-release-enc.jar文件注册激活idea</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>