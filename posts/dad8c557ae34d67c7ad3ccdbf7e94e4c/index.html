<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>对于 join, 如果不写 left ,inner ,right ，默认是什么联接呢？ - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="对于 join, 如果不写 left ,inner ,right ，默认是什么联接呢？" />
<meta property="og:description" content="默认是 inner join #1. select * from a join b on a.id = b.id #2. select * from a inner join b on a.id = b.id #3. select * from a, b where a.id = b.id 上面的三个是相等的. #4.剩下的join类型有: left join right join cross join full join #5.2005新加 cross apply outer apply SQL Server 2005 新增 cross apply 和 outer apply 联接语句，增加这两个东东有啥作用呢？ 我们知道有个 SQL Server 2000 中有个 cross join 是用于交叉联接的。实际上增加 cross apply 和 outer apply 是用于交叉联接表值函数（返回表结果集的函数）的， 更重要的是这个函数的参数是另一个表中的字段。这个解释可能有些含混不请，请看下面的例子： -- 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/dad8c557ae34d67c7ad3ccdbf7e94e4c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-03-13T10:01:52+08:00" />
<meta property="article:modified_time" content="2012-03-13T10:01:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">对于 join, 如果不写 left ,inner ,right ，默认是什么联接呢？</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> 默认是 inner join </p> 
<p> </p> 
<p> </p> 
<table class="mtxt " cellspacing="0" cellpadding="0"><tbody><tr><td id="rbody_73257649"> 
    <div class="msgfont">
      #1. select * from a join b on a.id = b.id 
     <br> #2. select * from a inner join b on a.id = b.id 
     <br> #3. select * from a, b where a.id = b.id 
     <br> 上面的三个是相等的. 
     <br> #4.剩下的join类型有: 
     <br> left join 
     <br> right join 
     <br> cross join 
     <br> full join 
     <br> #5.2005新加 
     <br> cross apply 
     <br> outer apply 
    </div> </td></tr></tbody></table> 
<p></p> 
<p>SQL Server 2005 新增 cross apply 和 outer apply 联接语句，增加这两个东东有啥作用呢？ </p> 
<p>我们知道有个 SQL Server 2000 中有个 cross join 是用于交叉联接的。实际上增加 cross apply 和 outer apply 是用于交叉联接表值函数（返回表结果集的函数）的， 更重要的是<span style="text-decoration:underline">这个函数的参数是另一个表中的字段</span>。这个解释可能有些含混不请，请看下面的例子： </p> 
<pre><code class="language-sql">-- 1. cross join 联接两个表
select *
  from TABLE_1 as T1
 cross join TABLE_2 as T2
</code></pre> 
<pre><code class="language-sql">-- 2. cross join 联接表和表值函数，表值函数的参数是个“常量”
select *
  from TABLE_1 T1
 cross join FN_TableValue(100)
</code></pre> 
<pre><code class="language-sql">-- 3. cross join  联接表和表值函数，表值函数的参数是“表T1中的字段”
select *
  from TABLE_1 T1
 cross join FN_TableValue(T1.column_a)

Msg 4104, Level 16, State 1, Line 1
The multi-part identifier "T1.column_a" could not be bound.
</code></pre> 
<p>最后的这个查询的语法有错误。在 cross join 时，表值函数的参数不能是表 T1 的字段， 为啥不能这样做呢？我猜可能微软当时没有加这个功能：），后来有客户抱怨后， 于是微软就增加了 cross apply 和 outer apply 来完善，请看 cross apply, outer apply 的例子： </p> 
<pre><code class="language-sql">-- 4. cross apply
select *
  from TABLE_1 T1
 cross apply FN_TableValue(T1.column_a)

-- 5. outer apply
select *
  from TABLE_1 T1
 outer apply FN_TableValue(T1.column_a)
</code></pre> 
<p>cross apply 和 outer apply 对于 T1 中的每一行都和派生表（表值函数根据T1当前行数据生成的动态结果集） 做了一个交叉联接。cross apply 和 outer apply 的区别在于： <span style="text-decoration:underline">如果根据 T1 的某行数据生成的派生表为空，cross apply 后的结果集 就不包含 T1 中的这行数据，而 outer apply 仍会包含这行数据，并且派生表的所有字段值都为 NULL</span>。 </p> 
<p>下面的例子摘自微软 SQL Server 2005 联机帮助，它很清楚的展现了 cross apply 和 outer apply 的不同之处： </p> 
<pre><code class="language-sql">-- cross apply
select *
  from Departments as D
 cross apply fn_getsubtree(D.deptmgrid) as ST
</code></pre> 
<pre><code class="language-sql">deptid      deptname      deptmgrid   empid       empname       mgrid       lvl
----------- -----------   ----------- ----------- -----------   ----------- ------
1           HR            2           2           Andrew        1           0
1           HR            2           5           Steven        2           1
1           HR            2           6           Michael       2           1
2           Marketing     7           7           Robert        3           0
2           Marketing     7           11          David         7           1
2           Marketing     7           12          Ron           7           1
2           Marketing     7           13          Dan           7           1
2           Marketing     7           14          James         11          2
3           Finance       8           8           Laura         3           0
4           R&amp;D           9           9           Ann           3           0
5           Training      4           4           Margaret      1           0
5           Training      4           10          Ina           4           1

(12 row(s) affected)
</code></pre> 
<pre><code class="language-sql">-- outer apply
select *
  from Departments as D
 outer apply fn_getsubtree(D.deptmgrid) as ST
</code></pre> 
<pre><code class="language-sql">deptid      deptname      deptmgrid   empid       empname       mgrid       lvl
----------- -----------   ----------- ----------- -----------   ----------- ------
1           HR            2           2           Andrew        1           0
1           HR            2           5           Steven        2           1
1           HR            2           6           Michael       2           1
2           Marketing     7           7           Robert        3           0
2           Marketing     7           11          David         7           1
2           Marketing     7           12          Ron           7           1
2           Marketing     7           13          Dan           7           1
2           Marketing     7           14          James         11          2
3           Finance       8           8           Laura         3           0
4           R&amp;D           9           9           Ann           3           0
5           Training      4           4           Margaret      1           0
5           Training      4           10          Ina           4           1
6           Gardening     NULL        NULL        NULL          NULL        NULL

(13 row(s) affected)
</code></pre> 
<p>注意 outer apply 结果集中多出的最后一行。 当 Departments 的最后一行在进行交叉联接时：deptmgrid 为 NULL，fn_getsubtree(D.deptmgrid) 生成的派生表中没有数据，但 outer apply 仍会包含这一行数据，这就是它和 cross join 的不同之处。 </p> 
<p>下面是完整的测试代码，你可以在 SQL Server 2005 联机帮助上找到： </p> 
<pre><code class="language-sql">-- create Employees table and insert values
create table Employees
(
  empid   int         not null,
  mgrid   int         NULL,
  empname varchar(25) not null,
  salary  money       not null
)
go


-- create Departments table and insert values
create table Departments
(
  deptid    int not null primary key,
  deptname  varchar(25) not null
)
go

-- fill datas
insert into employees values(1 , NULL, 'Nancy'   , 000.00)
insert into employees values(2 , 1   , 'Andrew'  , 00.00)
insert into employees values(3 , 1   , 'Janet'   , 00.00)
insert into employees values(4 , 1   , 'Margaret', 00.00)
insert into employees values(5 , 2   , 'Steven'  , 00.00)
insert into employees values(6 , 2   , 'Michael' , 00.00)
insert into employees values(7 , 3   , 'Robert'  , 00.00)
insert into employees values(8 , 3   , 'Laura'   , 00.00)
insert into employees values(9 , 3   , 'Ann'     , 00.00)
insert into employees values(10, 4   , 'Ina'     , 00.00)
insert into employees values(11, 7   , 'David'   , 00.00)
insert into employees values(12, 7   , 'Ron'     , 00.00)
insert into employees values(13, 7   , 'Dan'     , 00.00)
insert into employees values(14, 11  , 'James'   , 00.00)

insert into departments values(1, 'HR',           2)
insert into departments values(2, 'Marketing',    7)
insert into departments values(3, 'Finance',      8)
insert into departments values(4, 'R&amp;D',          9)
insert into departments values(5, 'Training',     4)
insert into departments values(6, 'Gardening', NULL)
go


-- table-value function
create function dbo.fn_getsubtree(@empid AS INT) returns @TREE table
(
  empid   int not null,
  empname varchar(25) not null,
  mgrid   int null,
  lvl     int not null
)
as
begin
  with Employees_Subtree(empid, empname, mgrid, lvl)
  as
  (
    -- Anchor Member (AM)
    select empid, empname, mgrid, 0
      from employees
     where empid = @empid

    union all

    -- Recursive Member (RM)
    select e.empid, e.empname, e.mgrid, es.lvl+1
      from employees as e
              join employees_subtree as es
        on e.mgrid = es.empid
  )


  insert into @TREE
    select * from Employees_Subtree

  return
end
go

-- cross apply query
select *
  from Departments as D
 cross apply fn_getsubtree(D.deptmgrid) as ST


-- outer apply query
select *
  from Departments as D
 outer apply fn_getsubtree(D.deptmgrid) as ST
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8cde07c20cfebf5e6510efbfa845604e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用wmi连接远程服务器时提示：“RPC 服务器不可用。 (异常来自 HRESULT:0x800706BA)”的解决方法...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9f14b01af45f5746e43a14c2568d8cd0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python 简单的Http服务器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>