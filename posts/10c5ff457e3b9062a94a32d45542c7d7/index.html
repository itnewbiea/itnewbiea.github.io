<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中Comparable接口和Comparator比较器的使用方法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java中Comparable接口和Comparator比较器的使用方法" />
<meta property="og:description" content="Comparable接口和Comparator比较器是实现将一个泛型为某个引用数据类型的集合容器中元素按一定顺序排序的两种方式，下面将对这两种方式进行讲解
一、首先定义一个学生类 public class Student { private String name; private int age; public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } /** * 由于Set集合需要去重，所以当泛型传入这个Student类型的时候， * Student需要重写equals()和hashCode()两个方法来保证两个元素逻辑上的不同 * 逻辑上的不同就是说两个元素应该名字或者年龄这些属性不同就算作是不同对象，如果地址不同，但是名字年龄等所有属性都相同的话应该算作同一个对象） * 如果没有重写equals()和hashCode()方法的话，会造成去重失败 */ /** * equals()和hashCode()方法的重写可以借助IDEA的快捷键(alt&#43;insert)来重写，get和set方法还有构造方法也可以 * 我这里就是借助IDEA自动生成的，但是一定要知道重写的原则是什么 * equals()方法重写原则： * 1、对称性：x,y非空，x.equals(y)和y.equals(x)返回值相同 * 2、自反性：x非空，x.equals(x)应该返回true * 3、传递性：x.equals(y)为true，y.equals(z)也为true，那x.equals(z)应该也为true * 4、一致性：对于非空x,y，只要对象的相关信息没有被修改，x.equals(y)多次调用应该始终返回相同的结果 * * @param o 比较另一个对象 * @return true/false表示是否为同一个对象 */ @Override public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/10c5ff457e3b9062a94a32d45542c7d7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-30T23:39:49+08:00" />
<meta property="article:modified_time" content="2023-08-30T23:39:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中Comparable接口和Comparator比较器的使用方法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>Comparable接口和Comparator比较器是实现将一个泛型为某个引用数据类型的集合容器中元素按一定顺序排序的两种方式，下面将对这两种方式进行讲解</p> 
</blockquote> 
<h2>一、首先定义一个学生类</h2> 
<pre><code class="language-java">public class Student {
    private String name;
    private int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
    /**
     * 由于Set集合需要去重，所以当泛型传入这个Student类型的时候，
     * Student需要重写equals()和hashCode()两个方法来保证两个元素逻辑上的不同
     * 逻辑上的不同就是说两个元素应该名字或者年龄这些属性不同就算作是不同对象，如果地址不同，但是名字年龄等所有属性都相同的话应该算作同一个对象）
     * 如果没有重写equals()和hashCode()方法的话，会造成去重失败
     */

    /**
     * equals()和hashCode()方法的重写可以借助IDEA的快捷键(alt+insert)来重写，get和set方法还有构造方法也可以
     * 我这里就是借助IDEA自动生成的，但是一定要知道重写的原则是什么
     * equals()方法重写原则：
     * 1、对称性：x,y非空，x.equals(y)和y.equals(x)返回值相同
     * 2、自反性：x非空，x.equals(x)应该返回true
     * 3、传递性：x.equals(y)为true，y.equals(z)也为true，那x.equals(z)应该也为true
     * 4、一致性：对于非空x,y，只要对象的相关信息没有被修改，x.equals(y)多次调用应该始终返回相同的结果
     *
     * @param o 比较另一个对象
     * @return true/false表示是否为同一个对象
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Student student = (Student) o;
        return age == student.age &amp;&amp; Objects.equals(name, student.name);
    }

    /**
     * hashCode()方法的重写准则：
     * 1、如果两个对象通过equals()方法比较相等的话，那么它们的hashCode()方法应返回相同的值
     * 2、如果两个对象通过equals()方法比较不相等，那么它们的hashCode()方法可以返回相同或不同的值（尽量避免冲突，以提高哈希表性能）
     * 一般调用顶级父类Objects的hash()方法进行hash计算即可
     *
     * @return 该对象生成的hashCode的int值
     */
    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}</code></pre> 
<h2>二、然后在main()方法中创建学生类对象，并添加到容器treeSet中，使用增强for循环遍历treeSet集合发现……</h2> 
<pre><code class="language-java">public static void main(String[] args) {
    Student s1 = new Student("zhao", 18);
    Student s2 = new Student("li", 20);
    Student s3 = new Student("zhang", 19);
    TreeSet&lt;Student&gt; treeSet = new TreeSet&lt;&gt;();
    treeSet.add(s1);
    treeSet.add(s2);
    treeSet.add(s3);
    for (Student s:treeSet){
        System.out.println(s.getName()+s.getAge());
    }
}</code></pre> 
<h3>报错了</h3> 
<p></p> 
<p class="img-center"><img alt="image.png" height="164" src="https://images2.imgbox.com/6a/d1/PsoG0esC_o.png" width="1200"></p> 
<p>这个报错的原因是Student类没有实现Comparable接口</p> 
<h2>三、修改Student类实现Comparable接口如下</h2> 
<pre><code class="language-java">public class Student implements Comparable&lt;Student&gt; {
 /**
  *
  .......
  */

    /**
     * 实现Comparable接口需要重写compareTo()方法
     *
     * @param o the object to be compared.
     * @return ==0:表示比较的元素与原来的元素相同，所以由于Set集合的不可重复性，在main()方法中添加到treeSet集合中的元素只有第一个学生s1对象
     * &gt;0:表示升序排列，或者是按照add的顺序添加
     * &lt;0:表示降序排列
     */
    @Override
    public int compareTo(Student o) {
        //保证年龄按姓名的字母顺序排序
        int num = this.age - o.age;
        //年龄相同时，按照姓名的字母顺序排序
        int nums2 = num == 0 ? this.name.compareTo(o.name) : num;
        return nums2;
    }
}</code></pre> 
<h2>四、这样就可以实现在集合中按照compareTo()方法中定义的排序方式排序</h2> 
<h4>测试</h4> 
<pre><code class="language-java">public static void main(String[] args) {
    Student s1 = new Student("zhao", 18);
    Student s2 = new Student("li", 20);
    //重复元素不会添加
    Student s4 = new Student("li", 20);
    //虽然名字一样，但是年龄不一样，在equals()的校验中是不同对象所以会被添加到集合
    Student s5 = new Student("li", 21);
    Student s6 = new Student("lin", 19);
    Student s3 = new Student("zhang", 19);
    TreeSet&lt;Student&gt; treeSet = new TreeSet&lt;&gt;();
    treeSet.add(s1);
    treeSet.add(s2);
    treeSet.add(s3);
    treeSet.add(s4);
    treeSet.add(s5);
    treeSet.add(s6);
    for (Student s : treeSet) {
        System.out.println(s.getName() + " - " + s.getAge());
    }
}
</code></pre> 
<h4>测试结果：元素无重复，按照年龄升序，年龄相同时，按照姓名字母顺序排序实现成功</h4> 
<p></p> 
<p class="img-center"><img alt="image.png" height="310" src="https://images2.imgbox.com/b1/6d/yyJzFCoK_o.png" width="855"></p> 
<h2>五、下面使用Comparator比较器来做同样的实现</h2> 
<p>Comparator比较器是在构造方法传入Comparator具体实现时候定义排序规则的</p> 
<h3>程序如下</h3> 
<pre><code class="language-java">public static void main(String[] args) {
    TreeSet&lt;Student&gt; treeSet = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;() {
        @Override
        public int compare(Student o1, Student o2) {
            int num = o1.getAge() - o2.getAge();
            int num2 = num == 0 ? o1.getName().compareTo(o2.getName()) : num;
            return num2;
        }
    });
    /**
     * 可以使用Lambda表达式简化如下
     * TreeSet&lt;Student&gt; treeSet = new TreeSet&lt;&gt;((o1, o2) -&gt; {
     *             int num = o1.getAge() - o2.getAge();
     *             int num2 = num == 0 ? o1.getName().compareTo(o2.getName()) : num;
     *             return num2;
     *         });
     */
    Student s1 = new Student("zhao", 18);
    Student s2 = new Student("li", 20);
    //重复元素不会添加
    Student s4 = new Student("li", 20);
    //虽然名字一样，但是年龄不一样，在equals()的校验中是不同对象所以会被添加到集合
    Student s5 = new Student("li", 21);
    Student s6 = new Student("lin", 19);
    Student s3 = new Student("zhang", 19);
    treeSet.add(s1);
    treeSet.add(s2);
    treeSet.add(s3);
    treeSet.add(s4);
    treeSet.add(s5);
    treeSet.add(s6);

    for (Student s : treeSet) {
        System.out.println(s.getName() + " - " + s.getAge());
    }
}</code></pre> 
<p></p> 
<h4>测试结果：同Comparable接口实现的测试结果</h4> 
<p></p> 
<p class="img-center"><img alt="image.png" height="276" src="https://images2.imgbox.com/ee/64/WTKpWULB_o.png" width="707"></p> 
<h2>最后：关于Comparable接口和Comparator比较器的选择上</h2> 
<blockquote> 
 <p>个人觉得，如果说项目需要在多个地方创建这个对象并且都按这个排序方式去排序的话就是使用Comparable接口来统一排序规则比较好，其他不需要多个地方创建对象调用的话比如刷算法题那选择Comparator比较器来做排序规则显然实现会更简单。</p> 
</blockquote> 
<p>大功告成！</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/edb4f8f548ba26b61e2120a968aa9450/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深度学习论文分享（八）Learning Event-Driven Video Deblurring and Interpolation</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/04abe1627d08891407e1178e887bcb13/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CS144（2023 Spring）Lab 0：networking warmup（环境搭建 &amp; webget &amp; bytestream）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>