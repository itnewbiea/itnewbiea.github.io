<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>React 之 Hooks解析 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="React 之 Hooks解析" />
<meta property="og:description" content="一、概念 1. class组件的优势 class组件可以定义自己的state，用来保存组件自己内部的状态 函数式组件不可以，因为函数每次调用都会产生新的临时变量class组件有自己的生命周期，我们可以在对应的生命周期中完成自己的逻辑，比如在componentDidMount中发送网络请求，并且该生命周期函数只会执行一次 函数式组件在学习hooks之前，如果在函数中发送网络请求，意味着每次重新渲染都会重新发送一次网络请求class组件可以在状态改变时只会重新执行render函数以及我们希望重新调用的生命周期函数componentDidUpdate等 函数式组件在重新渲染时，整个函数都会被执行，似乎没有什么地方可以只让它们调用一次 2. Class组件存在的问题 复杂组件变得难以理解 随着业务的增多，我们的class组件会变得越来越复杂比如componentDidMount中，可能就会包含大量的逻辑代码：包括网络请求、一些事件的监听（还需要在componentWillUnmount中移除）这样的class实际上非常难以拆分：因为它们的逻辑往往混在一起，强行拆分反而会造成过度设计，增加代码的复杂度组件复用状态很难 在前面为了一些状态的复用需要通过高阶组件像之前学习的redux中connect或者react-router中的withRouter，这些高阶组件设计的目的就是为了状态的复用或者类似于Provider、Consumer来共享一些状态，但是多次使用Consumer时，代码就会存在很多嵌套这些代码让我们不管是编写和设计上来说，都变得非常困难 3. 为什么需要Hook Hook 是 React 16.8 的新增特性，它可以让我们在不编写class的情况下使用state以及其他的React特性（比如生命周期）
hooks：
它可以让我们在不编写class的情况下使用state以及其他的React特性但是我们可以由此延伸出非常多的用法，来让我们前面所提到的问题得到解决完全可选的：你无需重写任何已有代码就可以在一些组件中尝试 Hook。但是如果你不想，你不必现在就去学习或使用 Hook100% 向后兼容的：Hook 不包含任何破坏性改动现在可用：Hook 已发布于 v16.8.0 Hook的使用场景：
Hook的出现基本可以代替我们之前所有使用class组件的地方但是如果是一个旧的项目，你并不需要直接将所有的代码重构为Hooks，因为它完全向下兼容，你可以渐进式的来使用它Hook只能在函数组件中使用，不能在类组件，或者函数组件之外的地方使用 4. 计数器案例 函数式组件结合hooks让整个代码变得非常简洁并且再也不用考虑this相关的问题 类组件实现 // 快捷键 =&gt; rpce import React, { PureComponent } from &#39;react&#39;; export class CountClass extends PureComponent { constructor(props) { super(props); this.state = { counter: 0 }; } counterChange(num) { this.setState({ counter: this.state.counter &#43; num }); } render() { // 快捷键 =&gt; dob const { counter } = this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0d2a88b7e2ac53279f88ea160057b7ee/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-12T11:18:32+08:00" />
<meta property="article:modified_time" content="2023-09-12T11:18:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">React 之 Hooks解析</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="411" src="https://images2.imgbox.com/c5/76/MlA9gliu_o.jpg" width="730"></p> 
<h2><span style="color:#956fe7;">一、概念</span></h2> 
<h3><span style="color:#4da8ee;">1. class组件的优势</span></h3> 
<ul><li><span style="color:#fe2c24;"><strong>class组件可以定义自己的state，</strong></span><span style="color:#0d0016;"><strong>用来保存组件自己内部的状态</strong></span> 
  <ul><li><span style="color:#ff9900;"><strong>函数式组件不可以，因为函数每次调用都会产生新的临时变量</strong></span></li></ul></li><li><span style="color:#fe2c24;"><strong>class组件有自己的生命周期</strong></span><span style="color:#ff9900;"><strong>，</strong></span><span style="color:#0d0016;"><strong>我们可以在对应的生命周期中完成自己的逻辑，比如在componentDidMount中发送网络请求，并且该生命周期函数只会执行一次</strong></span> 
  <ul><li><span style="color:#ff9900;"><strong>函数式组件在学习hooks之前，如果在函数中发送网络请求，意味着每次重新渲染都会重新发送一次网络请求</strong></span></li></ul></li><li><span style="color:#fe2c24;"><strong>class组件可以在状态改变时只会重新执行render函数以及我们希望重新调用的生命周期函数componentDidUpdate等</strong></span> 
  <ul><li><span style="color:#ff9900;"><strong>函数式组件在重新渲染时，整个函数都会被执行，似乎没有什么地方可以只让它们调用一次</strong></span></li></ul></li></ul> 
<p class="img-center"><img alt="" height="455" src="https://images2.imgbox.com/cd/0f/tG99PFwX_o.png" width="1061"></p> 
<h3><span style="color:#4da8ee;">2. Class组件存在的问题</span></h3> 
<ul><li><span style="color:#1a439c;"><strong>复杂组件变得难以理解</strong></span> 
  <ul><li><span style="color:#0d0016;"><strong>随着业务的增多，我们的class</strong></span><span style="color:#fe2c24;"><strong>组件会变得越来越复杂</strong></span></li><li><span style="color:#0d0016;"><strong>比如componentDidMount中，可能就会包含</strong></span><span style="color:#fe2c24;"><strong>大量的逻辑代码</strong></span><span style="color:#0d0016;"><strong>：包括网络请求、一些事件的监听（还需要在componentWillUnmount中移除）</strong></span></li><li><span style="color:#0d0016;"><strong>这样的class实际上非常</strong></span><span style="color:#fe2c24;"><strong>难以拆分</strong></span><span style="color:#0d0016;"><strong>：因为它们的逻辑往往混在一起，强行拆分反而会造成过度设计，增加代码的复杂度</strong></span></li></ul></li><li><span style="color:#1a439c;"><strong>组件复用状态很难</strong></span> 
  <ul><li><span style="color:#0d0016;"><strong>在前面为了一些状态的复用需要通过</strong></span><span style="color:#fe2c24;"><strong>高阶组件</strong></span></li><li><span style="color:#0d0016;"><strong>像之前学习的redux中connect或者react-router中的withRouter，这些高阶组件设计的目的就是为了状态的复用</strong></span></li><li><span style="color:#0d0016;"><strong>或者类似于Provider、Consumer来共享一些状态，但是</strong></span><span style="color:#fe2c24;"><strong>多次使用Consumer时，代码就会存在很多嵌套</strong></span></li><li><span style="color:#0d0016;"><strong>这些代码让我们不管是编写和设计上来说，都变得非常困难</strong></span></li></ul></li></ul> 
<h3><span style="color:#4da8ee;">3. 为什么需要Hook</span></h3> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>Hook 是 React 16.8 的新增特性，它可以让我们在不编写class的情况下使用state以及其他的React特性（比如生命周期）</strong></span></p> 
</blockquote> 
<p><strong><span style="color:#fe2c24;">hooks：</span></strong></p> 
<ul><li><span style="color:#fe2c24;"><strong>它可以让我们在不编写class的情况下使用state以及其他的React特性</strong></span></li><li><strong><span style="color:#0d0016;">但是我们可以由此延伸出非常多的用法，来让我们前面所提到的问题得到解决</span></strong></li><li><strong><span style="color:#fe2c24;">完全可选的</span><span style="color:#0d0016;">：你无需重写任何已有代码就可以在一些组件中尝试 Hook。但是如果你不想，你不必现在就去学习或使用 Hook</span></strong></li><li><strong><span style="color:#fe2c24;">100% 向后兼容的</span><span style="color:#0d0016;">：Hook 不包含任何破坏性改动</span></strong></li><li><strong><span style="color:#fe2c24;">现在可用</span><span style="color:#0d0016;">：Hook 已发布于 v16.8.0</span></strong></li></ul> 
<p><span style="color:#fe2c24;"><strong>Hook的使用场景：</strong></span></p> 
<ul><li><strong><span style="color:#0d0016;">Hook的出现基本可以</span><span style="color:#1a439c;">代替</span><span style="color:#0d0016;">我们之前</span><span style="color:#1a439c;">所有使用class组件的地方</span></strong></li><li><strong><span style="color:#0d0016;">但是如果是一个旧的项目，你并不需要直接将所有的代码重构为Hooks，因为它完全向下兼容，你可以渐进式的来使用它</span></strong></li><li><span style="color:#1c7331;"><strong>Hook只能在函数组件中使用，不能在类组件，或者函数组件之外的地方使用</strong></span></li></ul> 
<h3><span style="color:#4da8ee;">4. 计数器案例</span></h3> 
<ul><li><span style="color:#ff9900;"><strong>函数式组件结合hooks让整个代码变得非常简洁</strong></span></li><li><span style="color:#ff9900;"><strong>并且再也不用考虑this相关的问题</strong></span></li></ul> 
<h4><span style="color:#38d8f0;">类组件实现</span></h4> 
<pre><code class="language-javascript">// 快捷键 =&gt; rpce

import React, { PureComponent } from 'react';

export class CountClass extends PureComponent {
  constructor(props) {
    super(props);
    this.state = {
      counter: 0
    };
  }
  counterChange(num) {
    this.setState({
      counter: this.state.counter + num
    });
  }
  render() {
    // 快捷键 =&gt; dob
    const { counter } = this.state;
    return (
      &lt;&gt;
        &lt;div&gt;当前记数 : {counter}&lt;/div&gt;
        &lt;button onClick={(e) =&gt; this.counterChange(1)}&gt;+1&lt;/button&gt;
        &lt;button onClick={(e) =&gt; this.counterChange(-1)}&gt;-1&lt;/button&gt;
      &lt;/&gt;
    );
  }
}

export default CountClass;
</code></pre> 
<h4><span style="color:#38d8f0;">Hook实现</span></h4> 
<pre><code class="language-javascript">// 快捷键盘 =&gt; rmc

import { memo, useState } from 'react';

const App = memo(() =&gt; {
  const [counter, setCounter] = useState(0);
  return (
    &lt;&gt;
      &lt;div&gt;当前计数 : {counter}&lt;/div&gt;
      &lt;button onClick={(e) =&gt; setCounter(counter + 1)}&gt;+1&lt;/button&gt;
      &lt;button onClick={(e) =&gt; setCounter(counter - 1)}&gt;-1&lt;/button&gt;
    &lt;/&gt;
  );
});

export default App;
</code></pre> 
<h4><span style="color:#38d8f0;">Class组件和Hook对比</span></h4> 
<p class="img-center"><img alt="" height="596" src="https://images2.imgbox.com/c3/ff/P2Os2AW8_o.png" width="819"></p> 
<h2><span style="color:#956fe7;">二、useState</span></h2> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>State Hook     =&gt;     用来创建state</strong></span></p> 
</blockquote> 
<h3 style="background-color:transparent;"><span style="color:#4da8ee;">1. 解析</span></h3> 
<p><span style="color:#fe2c24;"><strong>useState来自react，需要从react中导入，它是一个hook</strong></span></p> 
<ul><li><strong><span style="color:#ff9900;">参数</span><span style="color:#4da8ee;">：初始化值，如果不设置为undefined</span></strong> 
  <ul><li><strong><span style="color:#1a439c;">只有在第一次渲染的时候执行</span></strong></li></ul></li><li><strong><span style="color:#ff9900;">返回值</span><span style="color:#4da8ee;">：数组，包含两个元素</span></strong> 
  <ul><li><strong><span style="color:#1a439c;">元素一</span><span style="color:#4da8ee;">：当前状态的值（第一调用为初始化值）</span></strong></li><li><strong><span style="color:#1a439c;">元素二</span><span style="color:#4da8ee;">：设置状态值的函数</span></strong></li></ul></li><li><span style="color:#ff9900;">调用设置状态值的函数</span> 
  <ul><li><strong>设置一个新的值</strong></li><li><strong>组件重新渲染，并且根据新的值返回DOM结构( 相当于重新执行render函数 )</strong></li></ul></li></ul> 
<h3><span style="color:#4da8ee;">2. 规则</span></h3> 
<ul><li><strong>只能在函数</strong><span style="color:#fe2c24;"><strong>最外层调用 Hook。不要在循环、条件判断或者子函数中调用</strong></span></li><li><span style="color:#fe2c24;"><strong>只能在 React 的函数组件中调用 Hook</strong></span><strong>。不要在其他 JavaScript 函数中调用</strong></li></ul> 
<h3><span style="color:#4da8ee;"><strong>3. 详解</strong></span></h3> 
<p><span style="color:#fe2c24;"><strong>State Hook的API就是 useState : </strong></span></p> 
<ul><li><span style="color:#0d0016;"><strong>useState会帮助我们</strong></span><span style="color:#fe2c24;"><strong>定义一个 state变量</strong></span><span style="color:#0d0016;"><strong>，useState 是一种新方法，它与 </strong></span><span style="color:#fe2c24;"><strong>class 里面的 this.state 提供的功能完全相同</strong></span> 
  <ul><li><span style="color:#0d0016;"><strong>一般来说，在函数退出后变量就会”消失”，而 </strong></span><span style="color:#fe2c24;"><strong>state 中的变量会被 React 保留</strong></span></li></ul></li><li><span style="color:#0d0016;"><strong>useState</strong></span><span style="color:#fe2c24;"><strong>接受唯一一个参数，在第一次组件被调用时使用来作为初始化值</strong></span> 
  <ul><li><span style="color:#0d0016;"><strong>如果没有传递参数，那么初始化值为undefined</strong></span></li></ul></li><li><span style="color:#0d0016;"><strong>useState的</strong></span><span style="color:#fe2c24;"><strong>返回值是一个数组</strong></span><span style="color:#0d0016;"><strong>，我们可以通过数组的解构，来完成赋值会非常方便</strong></span></li></ul> 
<pre><code class="language-javascript">  // 1. 直接传入
const [count, setCount] = useState(0);
setCount(100);
const [position, setPosition] = useState({ x: 0, y: 0 });
setPosition({ x: 100, y: 100 });

// 2. 传入方法 =&gt; 方法会立即执行
const [name, setName] = useState(() =&gt; {
  return 'hello';
});</code></pre> 
<h2 style="background-color:transparent;"><span style="color:#956fe7;"><strong>三、useEffect</strong></span></h2> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>Effect Hook     =&gt;     用来创建生命周期</strong></span></p> 
</blockquote> 
<h3><span style="color:#4da8ee;">1. 概念</span></h3> 
<p><strong><span style="color:#fe2c24;">Effect Hook 可以完成一些类似于class中生命周期的功能</span></strong></p> 
<ul><li><strong>网络请求</strong></li><li><strong>手动更新DOM</strong></li><li><strong>一些事件的监听</strong></li><li><strong>对于完成这些功能的Hook被称之为 Effect Hook </strong></li></ul> 
<h3><span style="color:#4da8ee;"><strong>2. 解析</strong></span></h3> 
<p><span style="color:#fe2c24;"><strong>useEffect的解析：</strong></span></p> 
<ul><li><strong>通过useEffect的Hook，可以告诉</strong><span style="color:#fe2c24;"><strong>React需要在渲染后执行某些操作</strong></span></li><li><strong>useEffect要求</strong><span style="color:#fe2c24;"><strong>传入一个回调函数</strong></span><strong>，在React</strong><span style="color:#fe2c24;"><strong>执行完更新DOM操作之后，就会回调这个函数</strong></span></li><li><strong>默认情况下，</strong><span style="color:#fe2c24;"><strong>无论是第一次渲染之后，还是每次更新之后，都会执行这个 回调函数</strong></span></li></ul> 
<h3><span style="color:#4da8ee;"><strong>3. 案例</strong></span></h3> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>页面的title总是显示counter的数字</strong></span></p> 
</blockquote> 
<h4><span style="color:#38d8f0;">类组件实现</span></h4> 
<pre><code class="language-javascript">// 快捷键 =&gt; rpce

import React, { PureComponent } from 'react';

export class CountClass extends PureComponent {
  constructor(props) {
    super(props);
    this.state = {
      counter: 66
    };
  }
  componentDidMount() {
    document.title = this.state.counter;
  }

  // 1. 使用这个生命周期函数的时候
  componentDidUpdate() {
    document.title = this.state.counter;
  }

  counterChange(num) {
    this.setState(
      {
        counter: this.state.counter + num
      },
      () =&gt; {
        // 2. 或者使用这个回调函数
        document.title = this.state.counter;
      }
    );
  }
  render() {
    // 快捷键 =&gt; dob
    const { counter } = this.state;
    return (
      &lt;&gt;
        &lt;div&gt;当前记数 : {counter}&lt;/div&gt;
        &lt;button onClick={(e) =&gt; this.counterChange(1)}&gt;+1&lt;/button&gt;
        &lt;button onClick={(e) =&gt; this.counterChange(-1)}&gt;-1&lt;/button&gt;
      &lt;/&gt;
    );
  }
}

export default CountClass;
</code></pre> 
<h4><span style="color:#38d8f0;">Hook实现</span></h4> 
<pre><code class="language-javascript">// 快捷键盘 =&gt; rmc

import { memo, useState, useEffect } from 'react';

const App = memo(() =&gt; {
  const [counter, setCounter] = useState(999);
  // 1. 直接赋值，因为每次都会重新渲染，所以每次都会重新赋值 =&gt; 不推荐
  // document.title = counter;

  // 2. 使用useEffect，当前传入的回调函数会在组件被渲染完成后，自动执行
  useEffect(() =&gt; {
    // 事件坚听、定时器、网络请求、订阅消息、手动修改DOM、修改ref等等
    document.title = counter;
  });

  return (
    &lt;&gt;
      &lt;div&gt;当前计数 : {counter}&lt;/div&gt;
      &lt;button onClick={(e) =&gt; setCounter(counter + 1)}&gt;+1&lt;/button&gt;
      &lt;button onClick={(e) =&gt; setCounter(counter - 1)}&gt;-1&lt;/button&gt;
    &lt;/&gt;
  );
});

export default App;
</code></pre> 
<h3 style="background-color:transparent;"><span style="color:#4da8ee;">4. 需要清除Effect</span></h3> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>在class组件中，某些副作用的代码，需要在componentWillUnmount中进行清除</strong></span></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>在useEffect中 : </strong></span></p> 
<ul><li><strong>传入的<span style="color:#fe2c24;">回调函数A</span>本身可以有一个返回值，这个返回值是另外一个<span style="color:#fe2c24;">回调函数B</span></strong> 
  <ul><li><strong><span style="color:#fe2c24;">type EffectCallback = () =&gt; (void | (() =&gt; void | undefined))</span></strong></li></ul></li><li><strong>这是 effect 可选的清除机制</strong>，<strong><span style="color:#fe2c24;">每个 effect 都可以返回一个清除函数</span></strong> 
  <ul><li><strong>如此可以将添加和移除订阅的逻辑放在一起</strong></li><li><strong>它们都属于 effect 的一部分</strong></li></ul></li><li><strong>React 会在<span style="color:#fe2c24;">组件更新和卸载的时候执行</span>清除操作</strong></li></ul> 
<pre><code class="language-javascript">useEffect(() =&gt; {

  // 1. 事件坚听、定时器、网络请求、订阅消息、手动修改DOM、修改ref等等   =&gt;   第一次只执行这里，
  const unsubcribe = sotre.subscribe(()=&gt;{

  })
  function foo(){}
  eventBus.on('xxx',foo)

  // 2. 返回一个函数，这个函数会在组件要重新渲染或者被销毁的时候自动执行   =&gt;   之后都是先执行这里，再执行上面的
  return ()=&gt;{
    unsubcribe()
    eventBus.off('xxx',foo)
  }
    
});</code></pre> 
<h3><span style="color:#4da8ee;">5. 使用多个Effect</span></h3> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>一个函数式组件中，可以存在多个useEffect</strong></span></p> 
 <p><span style="color:#ff9900;"><strong>React 将按照 effect 声明的顺序依次调用组件中的每一个 effect</strong></span></p> 
</blockquote> 
<pre><code class="language-javascript">// 1. 修改标题
useEffect(() =&gt; {
  document.title = counter;
});

// 2. 监听事件总线
useEffect(() =&gt; {
  function foo() {}
  eventBus.on('xxx', foo);
  return () =&gt; {
    eventBus.off('xxx', foo);
  };
});

// 3. 监听redux中的数据变化
useEffect(() =&gt; {
  const unsubcribe = sotre.subscribe(() =&gt; {});
  return () =&gt; {
    unsubcribe();
  };
});</code></pre> 
<h3><span style="color:#4da8ee;">6. Effect性能优化</span></h3> 
<h4><span style="color:#38d8f0;">问题</span></h4> 
<p><strong><span style="color:#fe2c24;">默认情况下，useEffect的回调函数会在每次渲染时都重新执行，但是这会导致两个问题</span></strong></p> 
<ul><li><strong>某些代码只是</strong><span style="color:#fe2c24;"><strong>希望执行一次</strong></span><strong>即可，类似于componentDidMount和componentWillUnmount中完成的事情</strong> 
  <ul><li><strong>比如网络请求、订阅和取消订阅</strong></li></ul></li><li><span style="color:#fe2c24;"><strong>多次执行也会导致一定的性能问题</strong></span></li></ul> 
<h4><span style="color:#38d8f0;">解决</span></h4> 
<p><span style="color:#fe2c24;"><strong>useEffect实际上有两个参数</strong></span></p> 
<ul><li><span style="color:#fe2c24;"><strong>参数一</strong></span><strong>：执行的回调函数</strong></li><li><span style="color:#fe2c24;"><strong>参数二</strong></span><strong>：该useEffect在哪些state发生变化时，才重新执行（受谁的影响）</strong> 
  <ul><li><strong><span style="color:#fe2c24;">如果每次都要执行</span>  =&gt;  只要重新渲染组件，都会执行</strong> 
    <ul><li><strong>不传第二个参数即可</strong></li></ul></li><li><strong><span style="color:#fe2c24;">如果只需要执行一次</span></strong> 
    <ul><li><strong>不依赖任何的内容，可以<span style="color:#fe2c24;">传入一个空的数组</span></strong></li><li><strong>相当于componentDidMount和componentWillUnmount</strong></li></ul></li><li><strong><span style="color:#fe2c24;">如果根据修改的值执行对应的effect</span></strong> 
    <ul><li><strong>传入一个数组，数组中放需要监听的数据</strong></li></ul></li></ul></li></ul> 
<h4><span style="color:#38d8f0;"><strong>案例</strong></span></h4> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>受count影响的Effect  =&gt;  </strong></span><span style="color:#fe2c24;"><strong>会重新执行</strong></span></p> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4f/76/MCZMSV8N_o.gif"></p> 
<pre><code class="language-javascript">// 快捷键盘 =&gt; rmc

import { memo, useState, useEffect } from 'react';

const App = memo(() =&gt; {
  const [counter, setCounter] = useState(999);
  const [isShow, setIsShow] = useState(true);

  // 监听counter的变化
  useEffect(() =&gt; {
    document.title = counter;
    console.log('监听counter的变化');
  }, [counter]);

  // 监听isShow的变化
  useEffect(() =&gt; {
    console.log('监听isShow的变化');
  }, [isShow]);

  //  监听事件总线
  useEffect(() =&gt; {
    console.log('事件总线');
  }, []);

  //  监听redux中的数据变化
  useEffect(() =&gt; {
    console.log('订阅数据');
  }, []);

  //  发起网络请求
  useEffect(() =&gt; {
    console.log('发起网络请求');
  }, []);

  return (
    &lt;&gt;
      &lt;div&gt;当前计数 : {counter}&lt;/div&gt;
      &lt;button onClick={(e) =&gt; setCounter(counter + 1)}&gt;+1&lt;/button&gt;
      &lt;button onClick={(e) =&gt; setCounter(counter - 1)}&gt;-1&lt;/button&gt;
      &lt;button onClick={(e) =&gt; setIsShow(!isShow)}&gt;切换 {isShow ? '显示' : '隐藏'}&lt;/button&gt;
    &lt;/&gt;
  );
});

export default App;
</code></pre> 
<h2><span style="color:#956fe7;"> 四、useContext</span></h2> 
<p><span style="color:#fe2c24;"><strong>在之前的开发中，要在组件中使用共享的Context有两种方式：</strong></span></p> 
<ul><li><strong>类组件可以通过 </strong><span style="color:#fe2c24;"><strong>类名.contextType = MyContext</strong></span><strong>方式，在类中获取context</strong></li><li><strong>多个Context或者在函数式组件中通过 MyContext.Consumer 方式共享context</strong></li></ul> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>Context Hook允许通过Hook来直接获取某个Context的值</strong></span></p> 
 <p><span style="color:#ff9900;"><strong>当</strong><strong>Context</strong><strong>传入的值更改时，会触发子组件的重新渲染</strong></span></p> 
</blockquote> 
<h3><span style="color:#4da8ee;">1. 创建context</span></h3> 
<pre><code class="language-javascript">import { createContext } from 'react';

const counterContext = createContext();

const themeContext = createContext();

export { counterContext, themeContext };
</code></pre> 
<h3><span style="color:#4da8ee;">2. 配置context</span></h3> 
<pre><code class="language-javascript">import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import { counterContext, themeContext } from './context';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  &lt;counterContext.Provider value={<!-- -->{ counter: 666 }}&gt;
    &lt;themeContext.Provider value={<!-- -->{ theme: 'dark', color: 'red' }}&gt;
      &lt;App /&gt;
    &lt;/themeContext.Provider&gt;
  &lt;/counterContext.Provider&gt;
);
</code></pre> 
<h3><span style="color:#4da8ee;">3. 使用context</span></h3> 
<pre><code class="language-javascript">import React, { memo, useContext } from 'react';
// 1. 导入context
import { CounterContext, ThemeContext } from './context';

const App = memo(() =&gt; {
  // 2. 使用context
  const count = useContext(CounterContext);
  const theme = useContext(ThemeContext);
  return (
    &lt;&gt;
      &lt;div&gt;App&lt;/div&gt;
      &lt;div style={<!-- -->{ color: theme.color }}&gt;count: {count.counter}&lt;/div&gt;
      &lt;div&gt;theme: {theme.color}&lt;/div&gt;
    &lt;/&gt;
  );
});

export default App;
</code></pre> 
<h2><span style="color:#956fe7;">五、useReducer</span></h2> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>useReducer不是redux的某个替代品</strong></span></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>useReducer仅仅是useState的一种替代方案：</strong></span></p> 
<ul><li><strong>在某些场景下，如果</strong><span style="color:#fe2c24;"><strong>state</strong></span><strong>的处理逻辑比较复杂，我们可以通过</strong><span style="color:#fe2c24;"><strong>useReducer来对其进行拆分</strong></span></li><li><strong>或者这次</strong><span style="color:#fe2c24;"><strong>修改的state需要依赖之前的state</strong></span><strong>时，也可以使用</strong></li></ul> 
<h3><span style="color:#4da8ee;">1. 使用useState</span></h3> 
<pre><code class="language-javascript">import React, { memo, useState } from 'react';

const App = memo(() =&gt; {
  const [count, setCount] = useState(0);

  return (
    &lt;&gt;
      &lt;h2&gt;当前计数: {count}&lt;/h2&gt;
      &lt;button onClick={(e) =&gt; setCount(count + 1)}&gt;+1&lt;/button&gt;
      &lt;button onClick={(e) =&gt; setCount(count - 1)}&gt;-1&lt;/button&gt;
      &lt;button onClick={(e) =&gt; setCount(count + 5)}&gt;+5&lt;/button&gt;
      &lt;button onClick={(e) =&gt; setCount(count - 5)}&gt;-5&lt;/button&gt;
      &lt;button onClick={(e) =&gt; setCount(count + 100)}&gt;+100&lt;/button&gt;
    &lt;/&gt;
  );
});

export default App;</code></pre> 
<h3><span style="color:#4da8ee;">2. 使用useReducer </span></h3> 
<pre><code class="language-javascript">import React, { memo, useReducer } from 'react';

// 1. 定义 reducer 函数
function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { ...state, counter: state.counter + 1 };
    case 'decrement':
      return { ...state, counter: state.counter - 1 };
    case 'add_number':
      return { ...state, counter: state.counter + action.num };
    case 'sub_number':
      return { ...state, counter: state.counter - action.num };
    default:
      return state;
  }
}

const App = memo(() =&gt; {
  // 2. 使用 useReducer 函数，传入 reducer 函数和初始值，得到 state 和 dispatch 函数
  const [state, dispatch] = useReducer(reducer, { counter: 0, friends: [], user: {} });

  return (
    &lt;&gt;
      {/* 3. 使用 state 中的数据, 通过 state.属性名 来获取 */}
      &lt;h2&gt;当前计数: {state.counter}&lt;/h2&gt;
      {/* 4. 使用 dispatch 函数，传入 action 对象，来触发 reducer 函数，从而改变 state */}
      &lt;button onClick={(e) =&gt; dispatch({ type: 'increment' })}&gt;+1&lt;/button&gt;
      &lt;button onClick={(e) =&gt; dispatch({ type: 'decrement' })}&gt;-1&lt;/button&gt;
      &lt;button onClick={(e) =&gt; dispatch({ type: 'add_number', num: 5 })}&gt;+5&lt;/button&gt;
      &lt;button onClick={(e) =&gt; dispatch({ type: 'sub_number', num: 5 })}&gt;-5&lt;/button&gt;
      &lt;button onClick={(e) =&gt; dispatch({ type: 'add_number', num: 100 })}&gt;+100&lt;/button&gt;
    &lt;/&gt;
  );
});

export default App;</code></pre> 
<h2><span style="color:#956fe7;">六、useCallback</span></h2> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>useCallback实际的目的是为了进行性能的优化 =&gt; 返回值是优化后的函数</strong></span></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>如何进行性能的优化 : </strong></span></p> 
<ul><li><strong>useCallback会<span style="color:#fe2c24;">返回一个函数的 memoized（记忆的） 值</span></strong></li><li><strong>在<span style="color:#fe2c24;">依赖不变的情况下，多次定义的时候，返回的值是相同</span>的 </strong></li></ul> 
<h3><span style="color:#4da8ee;"><strong>1. 初始</strong></span></h3> 
<pre><code class="language-javascript">import React, { memo, useState } from 'react';

const App = memo(() =&gt; {
  const [count, setCount] = useState(0);

  return (
    &lt;&gt;
      &lt;h2&gt;当前计数: {count}&lt;/h2&gt;
      {/* 每次点击+1，都会重新渲染App组件，导致子组件也会重新渲染，该箭头函数也会重新创建，浪费性能 */}
      &lt;button onClick={(e) =&gt; setCount(count + 1)}&gt;+1&lt;/button&gt;
    &lt;/&gt;
  );
});

export default App;
</code></pre> 
<h3><span style="color:#4da8ee;"><strong>2. 更改</strong></span></h3> 
<pre><code class="language-javascript">import React, { memo, useState, useCallback } from 'react';

const App = memo(() =&gt; {
  const [count, setCount] = useState(0);

  // useCallback 用于缓存函数,但是不会缓存函数中的变量，也就是传入的函数依然会重新创建，所以这样写是没用的
  // 和原来的写法一样，没有任何优化
  const handleBtnClick = useCallback((e) =&gt; {
    setCount(count + 1);
  });

  return (
    &lt;&gt;
      &lt;h2&gt;当前计数: {count}&lt;/h2&gt;
      &lt;button onClick={handleBtnClick}&gt;+1&lt;/button&gt;
    &lt;/&gt;
  );
});

export default App;
</code></pre> 
<h3><span style="color:#4da8ee;">3. 修复</span></h3> 
<p class="img-center"><img alt="" height="154" src="https://images2.imgbox.com/43/19/wzvIYk8x_o.png" width="406"></p> 
<pre><code class="language-javascript">import React, { memo, useState, useCallback } from 'react';

const App = memo(() =&gt; {
  const [count, setCount] = useState(0);

  // 小心闭包陷阱 =&gt; 当不传依赖的时候，函数只会创建一次。依赖项中的 count 一直是初始值 0，所以每次点击按钮，count 都为 1，而不是累加 =&gt; 没有创建新的函数
  // const handleBtnClick = useCallback(function (e) {
  //   setCount(count + 1);
  // }, []);

  // 传入第二个参数，依赖项数组，当依赖项发生变化时，才会重新创建函数，否则复用之前的函数，避免了闭包陷阱
  const handleBtnClick = useCallback(function (e) {
    setCount(count + 1);
  }, [count]);
  return (
    &lt;&gt;
      &lt;h2&gt;当前计数: {count}&lt;/h2&gt;
      &lt;button onClick={handleBtnClick}&gt;+1&lt;/button&gt;
    &lt;/&gt;
  );
});

export default App;
</code></pre> 
<h3><span style="color:#4da8ee;">4. 解释</span></h3> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>上方做法依然没有进行优化，当count改变的时候，依然会创建新的函数</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>和普通的没有区别</strong></span></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>当把函数从父组件传递给子组件，父组件有其他数据更改时，该优化才能生效</strong></span></p> 
<h4><span style="color:#38d8f0;"><strong>普通函数效果</strong></span></h4> 
<ul><li><span style="color:#fe2c24;"><strong>当点击修改count时</strong></span> 
  <ul><li><strong>不管点击父组件还是子组件，因为handleBtnClick重新创建，所以都会重新渲染</strong></li></ul></li><li><span style="color:#fe2c24;"><strong>当点击修改name的时候</strong></span> 
  <ul><li><strong>子组件也会修改</strong></li><li><strong>因为App组件重新执行，handleBtnClick重新创建，子组件接收的props更改了</strong></li><li><strong>但这是不应该的</strong></li></ul></li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/dc/76/cKRwQFgF_o.gif"></p> 
<pre><code class="language-javascript">import React, { memo, useState, useCallback } from 'react';

const Home = memo((props) =&gt; {
  console.log('Home组件被调用');

  // 3. 子组件通过props接收父组件传递过来的函数
  const { handleBtnClick } = props;
  return (
    &lt;&gt;
      &lt;h2&gt;Home组件&lt;/h2&gt;
      {/* 4. 子组件通过props接收父组件传递过来的函数，并且调用 */}
      &lt;button onClick={handleBtnClick}&gt;Home : +1&lt;/button&gt;
        
      {/* 假如有100个组件 =&gt; 全都会重新渲染 */}
    &lt;/&gt;
  );
});

const App = memo(() =&gt; {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('jack');

  // 1. 使用普通方法定义的函数
  const handleBtnClick = (e) =&gt; setCount(count + 1);

  return (
    &lt;&gt;
      &lt;h2&gt;当前计数: {count}&lt;/h2&gt;
      &lt;button onClick={handleBtnClick}&gt;+1&lt;/button&gt;
      &lt;h2&gt;当前名称: {name}&lt;/h2&gt;
      &lt;button onClick={(e) =&gt; setName(Math.random())}&gt;修改名称&lt;/button&gt;
      &lt;hr /&gt;

      {/* 2. 把函数传递给子组件，子组件通过props接收 */}
      &lt;Home handleBtnClick={handleBtnClick} /&gt;
    &lt;/&gt;
  );
});

export default App;</code></pre> 
<h4><span style="color:#38d8f0;"><strong>使用useCallback效果</strong></span></h4> 
<ul><li><span style="color:#fe2c24;"><strong>当点击修改count时</strong></span> 
  <ul><li><strong>不管点击父组件还是子组件，因为handleBtnClick重新创建，所以都会重新渲染</strong></li></ul></li><li><span style="color:#fe2c24;"><strong>当点击修改name的时候</strong></span> 
  <ul><li><strong>子组件并不会重新渲染</strong></li><li><strong>因为count没有更改，所以handleBtnClick函数不会重新创建，props没有改变</strong></li></ul></li></ul> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c0/33/2BD9arAK_o.gif"></p> 
<pre><code class="language-javascript">import React, { memo, useState, useCallback } from 'react';

const Home = memo((props) =&gt; {
  console.log('Home组件被调用');

  // 3. 子组件通过props接收父组件传递过来的函数
  const { handleBtnClick } = props;
  return (
    &lt;&gt;
      &lt;h2&gt;Home组件&lt;/h2&gt;
      {/* 4. 子组件通过props接收父组件传递过来的函数，并且调用 */}
      &lt;button onClick={handleBtnClick}&gt;Home : +1&lt;/button&gt;

      {/* 假如有100个组件 =&gt; 该组件不重新渲染，其下的组件也都不会，大大优化了 */}
    &lt;/&gt;
  );
});

const App = memo(() =&gt; {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('jack');

  // 1. 通过useCallback包裹函数，把函数传递给子组件
  const handleBtnClick = useCallback(
    function (e) {
      setCount(count + 1);
    },
    [count]
  );

  return (
    &lt;&gt;
      &lt;h2&gt;当前计数: {count}&lt;/h2&gt;
      &lt;button onClick={handleBtnClick}&gt;+1&lt;/button&gt;
      &lt;h2&gt;当前名称: {name}&lt;/h2&gt;
      &lt;button onClick={(e) =&gt; setName(Math.random())}&gt;修改名称&lt;/button&gt;
      &lt;hr /&gt;

      {/* 2. 把函数传递给子组件，子组件通过props接收 */}
      &lt;Home handleBtnClick={handleBtnClick} /&gt;
    &lt;/&gt;
  );
});

export default App;</code></pre> 
<h3><span style="color:#4da8ee;">5. 进一步优化</span></h3> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>当count发生改变的时候，也使用同一个函数</strong></span></p> 
</blockquote> 
<h4><span style="color:#38d8f0;">做法一</span></h4> 
<blockquote> 
 <p><span style="color:#ff9900;"><strong>将count依赖移除掉 =&gt; 缺点 : 闭包陷阱</strong></span></p> 
</blockquote> 
<pre><code class="language-javascript">
// 小心闭包陷阱 =&gt; 当不传依赖的时候，函数只会创建一次。依赖项中的 count 一直是初始值 0，所以每次点击按钮，count 都为 1，而不是累加 =&gt; 没有创建新的函数
const handleBtnClick = useCallback(function (e) {
  setCount(count + 1);
}, []);</code></pre> 
<h4><span style="color:#38d8f0;">做法二 </span></h4> 
<blockquote> 
 <p><span style="color:#ff9900;"><strong>做法一  + 使用useRef =&gt; 特点 : 在组件多次渲染时，返回的是同一个值</strong></span></p> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c2/06/K8Ee420k_o.gif"></p> 
<pre><code class="language-javascript">import React, { memo, useState, useCallback, useRef } from 'react';

const Home = memo((props) =&gt; {
  console.log('Home组件被调用,只会在组件第一次渲染时调用');
  const { handleBtnClick } = props;
  return (
    &lt;&gt;
      &lt;h2&gt;Home组件&lt;/h2&gt;
      &lt;button onClick={handleBtnClick}&gt;Home : +1&lt;/button&gt;
    &lt;/&gt;
  );
});

const App = memo(() =&gt; {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('jack');

  // 1. useRef 保存的值，在组件重新渲染时，不会发生改变
  const countRef = useRef();
  // 2. 但是，可以通过修改 ref.current 的值，来达到保存数据的目的
  countRef.current = count;

  const handleBtnClick = useCallback(
    (e) =&gt; {
      setCount(countRef.current + 1);
    },
    // 3. 去除依赖项，让 useCallback 每次都返回同一个函数
    []
  );

  return (
    &lt;&gt;
      &lt;h2&gt;当前计数: {count}&lt;/h2&gt;
      &lt;button onClick={handleBtnClick}&gt;+1&lt;/button&gt;
      &lt;h2&gt;当前名称: {name}&lt;/h2&gt;
      &lt;button onClick={(e) =&gt; setName(Math.random())}&gt;修改名称&lt;/button&gt;
      &lt;hr /&gt;

      &lt;Home handleBtnClick={handleBtnClick} /&gt;
    &lt;/&gt;
  );
});

export default App;
</code></pre> 
<h3 style="background-color:transparent;"><span style="color:#4da8ee;">6. 总结</span></h3> 
<ul><li><strong>使用useCallback和不使用useCallback定义一个函数是否会带来性能的优化</strong> 
  <ul><li><strong> </strong><span style="color:#fe2c24;"><strong>不会，和普通函数的定义没有区别</strong></span></li></ul></li><li><strong>使用useCallback和不使用useCallback定义一个函数传递给子组件是否会带来性能的优化</strong> 
  <ul><li><strong>​​​​​​​会，</strong><span style="color:#fe2c24;"><strong>当需要将一个函数传递给子组件时，最好使用useCallback进行优化，将优化后的函数传递给子组件</strong></span></li></ul></li></ul> 
<h2><span style="color:#956fe7;">七、useMemo</span></h2> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>useMemo实际的目的也是为了进行性能的优化 =&gt; 返回值是一个值</strong></span></p> 
 <p><span style="color:#ff9900;"><strong>进行大量的计算操作，可以使用useMemo进行优化</strong></span></p> 
</blockquote> 
<h3 style="background-color:transparent;"><span style="color:#4da8ee;">1. 不依赖任何的值</span></h3> 
<blockquote> 
 <p><span style="color:#ff9900;"><strong>只会被执行一次</strong></span></p> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/44/24/1uOrYv8s_o.gif"></p> 
<pre><code class="language-javascript">import React, { memo, useMemo, useState } from 'react';

// 1. 写在函数组件外面的代码, 只会被执行一次，防止被多次创建
function calcNumTotal(num) {
  console.log('calcNumTotal的计算过程被调用~');
  let total = 0;
  for (let i = 1; i &lt;= num; i++) {
    total += i;
  }
  return total;
}

const App = memo(() =&gt; {
  const [count, setCount] = useState(0);

  // 2.不依赖任何的值, 进行计算 =&gt; 只会被执行一次
  const result = useMemo(() =&gt; {
    return calcNumTotal(50);
  }, []);

  return (
    &lt;&gt;
      &lt;h2&gt;计算结果: {result}&lt;/h2&gt;
      &lt;h2&gt;计数器: {count}&lt;/h2&gt;
      &lt;button onClick={(e) =&gt; setCount(count + 1)}&gt;+1&lt;/button&gt;
    &lt;/&gt;
  );
});

export default App;
</code></pre> 
<h3><span style="color:#4da8ee;">2. 依赖count</span></h3> 
<blockquote> 
 <p><span style="color:#ff9900;"><strong>每次count发生变化, 都会重新计算</strong></span></p> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/03/16/REi7sxLu_o.gif"></p> 
<pre><code class="language-javascript">import React, { memo, useMemo, useState } from 'react';

// 1. 写在函数组件外面的代码, 只会被执行一次，防止被多次创建
function calcNumTotal(num) {
  console.log('calcNumTotal的计算过程被调用~');
  let total = 0;
  for (let i = 1; i &lt;= num; i++) {
    total += i;
  }
  return total;
}

const App = memo(() =&gt; {
  const [count, setCount] = useState(0);

  // 2.依赖count, 进行计算 =&gt; 每次count发生变化, 都会重新计算
  const result = useMemo(() =&gt; {
    return calcNumTotal(count * 2);
  }, [count]);

  return (
    &lt;&gt;
      &lt;h2&gt;计算结果: {result}&lt;/h2&gt;
      &lt;h2&gt;计数器: {count}&lt;/h2&gt;
      &lt;button onClick={(e) =&gt; setCount(count + 1)}&gt;+1&lt;/button&gt;
    &lt;/&gt;
  );
});

export default App;</code></pre> 
<h3><span style="color:#4da8ee;">3. useMemo和useCallback的对比</span></h3> 
<pre><code class="language-javascript">  /**
   * useMemo和useCallback的对比. useCallback返回的是一个函数, useMemo返回的是一个值
   * 1. useCallback(fn, []) =&gt; fn
   * 2. useMemo(() =&gt; fn, []) =&gt; fn()
   * 这两种写法表示的意思是一样的
   */
  function fn() {}
  // 返回值是一个函数 =&gt; useCallback
  const increment = useCallback(fn, []);
  // 返回值是一个值 =&gt; useMemo
  const increment2 = useMemo(() =&gt; fn, []);</code></pre> 
<h3><span style="color:#4da8ee;">4. 对子组件渲染进行优化</span></h3> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>如果对子组件传入</strong></span><span style="color:#fe2c24;"><strong>相同内容的对象</strong></span><span style="color:#1a439c;"><strong>时，可以进行优化 =&gt; 因为每次执行函数，都会创建新对象，子组件就会重新渲染</strong></span></p> 
 <p><span style="color:#ff9900;"><strong>如果传递给子组件的是个值的情况下，值不改变，子组件就不会重新渲染</strong></span></p> 
</blockquote> 
<pre><code class="language-javascript">import React, { memo, useMemo, useState } from 'react';

// 创建一个子组件
const HelloWorld = memo(function (props) {
  console.log('HelloWorld被渲染~');
  return &lt;h2&gt;Hello World&lt;/h2&gt;;
});

function calcNumTotal(num) {
  console.log('calcNumTotal的计算过程被调用~');
  let total = 0;
  for (let i = 1; i &lt;= num; i++) {
    total += i;
  }
  return total;
}

const App = memo(() =&gt; {
  const [count, setCount] = useState(0);

  const result = useMemo(() =&gt; {
    return calcNumTotal(50);
  }, []);

  // 1. 每次都会创建一个新的对象，导致子组件的props发生变化
  // const info = { name: 'why', age: 18 }; // 会导致子组件的props发生变化，从而导致子组件的重新渲染

  // 2. 使用useMemo对子组件渲染进行优化，只有当info发生变化的时候，才会重新创建新的对象，否则使用缓存的对象 =&gt; 优化子组件的渲染
  const info = useMemo(() =&gt; ({ name: 'why', age: 18 }), []); // 不会导致子组件的props发生变化，从而不会导致子组件的重新渲染

  return (
    &lt;&gt;
      &lt;h2&gt;计算结果: {result}&lt;/h2&gt;
      &lt;h2&gt;计数器: {count}&lt;/h2&gt;
      &lt;button onClick={(e) =&gt; setCount(count + 1)}&gt;+1&lt;/button&gt;

      &lt;HelloWorld result={result} info={info} /&gt;
    &lt;/&gt;
  );
});

export default App;
</code></pre> 
<h3 style="background-color:transparent;"><span style="color:#4da8ee;">5. 总结</span></h3> 
<ul><li><strong>进行大量的</strong><span style="color:#fe2c24;"><strong>计算操作</strong></span><strong>，是否有必须要每次渲染时都重新计算</strong> 
  <ul><li><strong>​​​​​​​</strong><span style="color:#fe2c24;"><strong>可以使用useMemo进行优化</strong></span></li></ul></li><li><strong>对子组件传递相同内容的对象时，使用useMemo进行性能的优化</strong> 
  <ul><li><span style="color:#fe2c24;"><strong>父组件有不变的静态对象时，可以进行优化</strong></span></li></ul></li></ul> 
<h2 style="background-color:transparent;"><span style="color:#956fe7;"><strong>​​​​​​​八、useRef</strong></span></h2> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>useRef返回一个ref对象，返回的ref对象再组件的整个生命周期保持不变</strong></span></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>ref是两种用法：</strong></span></p> 
<ul><li><strong><span style="color:#fe2c24;">用法一</span>：引入DOM（或者组件，但是需要是class组件）元素</strong></li><li><strong><span style="color:#fe2c24;">用法二</span>：保存一个数据，这个对象在整个生命周期中可以保存不变 </strong></li></ul> 
<h3><span style="color:#4da8ee;"><strong>引入DOM</strong></span></h3> 
<pre><code class="language-javascript">import React, { memo, useRef } from 'react';

const App = memo(() =&gt; {
  // 1. useRef() 生成一个 ref 对象
  const titleRef = useRef();

  //3. 通过 ref 对象的 current 属性获取引用的元素
  const getTitleRef = () =&gt; {
    console.log(titleRef.current);
  };
  
  return (
    &lt;&gt;
      {/* 2. 将 ref 对象传递给需要引用的元素 */}
      &lt;div ref={titleRef}&gt;App111&lt;/div&gt;
      &lt;button onClick={getTitleRef}&gt;获取titleRef&lt;/button&gt;
    &lt;/&gt;
  );
});

export default App;</code></pre> 
<h3 style="background-color:transparent;"><span style="color:#4da8ee;"><strong>保存数据</strong></span></h3> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>使用ref保存上一次的某一个值</strong></span></p> 
</blockquote> 
<pre><code class="language-javascript">import React, { memo, useCallback, useRef, useState } from 'react';

const App = memo(() =&gt; {
  const [count, setCount] = useState(0);

  const countRef = useRef(0);
  countRef.current = count;

  const handleClick = useCallback((e) =&gt; {
    // 如果直接使用 count，会有闭包问题 ！！！ =&gt; 因为这里不依赖外界，所以只会创建一次函数， count 是在 handleClick 函数创建时就已经存在了，而不是每次渲染时才创建
    // setCount(count + 1);

    // 如果使用 countRef.current，就不会有闭包问题 ！！！ =&gt; 因为这里依赖外界，所以每次渲染都会创建新的函数， countRef.current 是在 handleClick 函数执行时才存在的
    setCount(countRef.current + 1);
  }, []);
  return (
    &lt;&gt;
      &lt;div&gt;App ： {count}&lt;/div&gt;
      &lt;button onClick={handleClick}&gt;+1&lt;/button&gt;
    &lt;/&gt;
  );
});

export default App;</code></pre> 
<h2 style="background-color:transparent;"><span style="color:#956fe7;">九、useImperativeHandle</span></h2> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>在父组件中，通过传递ref绑定子组件，获取的权限太高</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>可以通过useImperativeHandle，来约束外界的权限</strong></span></p> 
</blockquote> 
<p class="img-center"><img alt="" height="538" src="https://images2.imgbox.com/59/39/X9GZP4iN_o.png" width="1200"></p> 
<pre><code class="language-javascript">import React, { memo, useRef, forwardRef, useImperativeHandle } from 'react';

// 1. 创建子组件 =&gt; 接收ref
const Child = memo(
  forwardRef((props, ref) =&gt; {
    // 2. 创建自己内部的ref
    const childRef = useRef();

    // 4. 暴露给父组件的方法 =&gt; 通过useImperativeHandle暴露给父组件
    useImperativeHandle(ref, () =&gt; ({
      focus: () =&gt; {
        childRef.current.focus();
      },
      setValue(value) {
        childRef.current.value = value;
      }
    }));

    // 3. 将自己内部的ref绑定
    return &lt;input ref={childRef} /&gt;;
  })
);

const App = memo(() =&gt; {
  // 5. 创建父组件的ref
  const parentRef = useRef();

  function handleDOM() {
    // 6. 调用子组件暴露给父组件的方法 =&gt; parentRef.current拿到的是useImperativeHandle返回的对象
    // console.log(parentRef.current)
    parentRef.current.focus();
    parentRef.current.setValue('哈哈哈');

    // 无法直接操作子组件的value,因为没有暴露给父组件
    // parentRef.current.value = ""

  }
  return (
    &lt;&gt;
      &lt;Child ref={parentRef}&gt;&lt;/Child&gt;
      &lt;button onClick={handleDOM}&gt;DOM操作&lt;/button&gt;
    &lt;/&gt;
  );
});

export default App;
</code></pre> 
<h2 style="background-color:transparent;"><span style="color:#956fe7;">十、useLayoutEffect</span></h2> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>useLayoutEffect看起来和useEffect非常的相似，事实上他们也只有一点区别而已</strong></span></p> 
</blockquote> 
<ul><li><strong><span style="color:#fe2c24;">useEffect</span></strong> 
  <ul><li><strong>会在渲染的内容更新到DOM上后执行，不会阻塞DOM的更新</strong></li></ul></li><li><strong><span style="color:#fe2c24;">useLayoutEffect</span></strong> 
  <ul><li><strong>会在渲染的内容更新到DOM上之前执行，会阻塞DOM的更新 </strong></li></ul></li></ul> 
<blockquote> 
 <p><span style="color:#ff9900;"><strong>如果希望在某些操作发生之后再更新DOM，那么应该将这个操作放到useLayoutEffect</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>官方更推荐使用useEffect而不是useLayoutEffect</strong></span></p> 
</blockquote> 
<p><img alt="" height="330" src="https://images2.imgbox.com/56/39/UGXrRsej_o.png" width="987"></p> 
<pre><code class="language-javascript">import React, { memo, useEffect, useLayoutEffect } from 'react';

const App = memo(() =&gt; {

  useLayoutEffect(() =&gt; {
    console.log('useLayoutEffect', '第二执行');
  });

  useEffect(() =&gt; {
    console.log('useEffect', '第三执行');
  });

  console.log('App', '第一执行');

  return &lt;div&gt;App&lt;/div&gt;;
});

export default App;
</code></pre> 
<h2 style="background-color:transparent;"><span style="color:#956fe7;">十一、自定义Hook</span></h2> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>自定义Hook本质上只是一种函数代码逻辑的抽取，严格意义上来说，它本身并不算React的特性</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>注意 : 名称需要用useXXX</strong></span></p> 
</blockquote> 
<h3><span style="color:#4da8ee;">1. 打印生命周期</span></h3> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>所有的组件在创建和销毁时都进行打印</strong></span></p> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9c/92/QbN35HQk_o.gif"></p> 
<pre><code class="language-javascript">import { memo, useEffect, useState } from 'react';

// 1. 自定义hook，命名必须以use开头 =&gt; 生命周期
const useLife = (name) =&gt; {
  useEffect(() =&gt; {
    console.log(name + '被创建');
    return () =&gt; {
      console.log(name + '被销毁');
    };
  }, [name]);
};

const FirstComponent = memo(() =&gt; {
  // 2. 使用自定义hook
  useLife('firstComponent');
  return &lt;h1&gt;firstComponent&lt;/h1&gt;;
});

const SecondComponent = memo(() =&gt; {
  // 2. 使用自定义hook
  useLife('secondComponent');
  return &lt;h1&gt;secondComponent&lt;/h1&gt;;
});

const App = memo(() =&gt; {
  // 2. 使用自定义hook
  useLife('App');
  const [isShow, setIsShow] = useState(true);

  return (
    &lt;&gt;
      &lt;h1&gt;App&lt;/h1&gt;

      &lt;button onClick={() =&gt; setIsShow(!isShow)}&gt;切换&lt;/button&gt;
      {isShow &amp;&amp; &lt;FirstComponent /&gt;}
      {isShow &amp;&amp; &lt;SecondComponent /&gt;}
    &lt;/&gt;
  );
});

export default App;
</code></pre> 
<h3><span style="color:#4da8ee;">2. Context的共享数据</span></h3> 
<p class="img-center"><img alt="" height="499" src="https://images2.imgbox.com/03/84/02tCnk73_o.png" width="1200"></p> 
<p><span style="color:#1a439c;"><strong>创建context/index.js</strong></span></p> 
<pre><code class="language-javascript">import { createContext } from 'react';

const CounterContext = createContext();

const ThemeContext = createContext();

export { CounterContext, ThemeContext };
</code></pre> 
<p><span style="color:#1a439c;"><strong>index.js</strong></span></p> 
<pre><code class="language-javascript">import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import { CounterContext, ThemeContext } from './context';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  &lt;CounterContext.Provider value={<!-- -->{ counter: 666 }}&gt;
    &lt;ThemeContext.Provider value={<!-- -->{ theme: 'dark', color: 'red' }}&gt;
      &lt;App /&gt;
    &lt;/ThemeContext.Provider&gt;
  &lt;/CounterContext.Provider&gt;
);
</code></pre> 
<p><span style="color:#1a439c;"><strong>App.jsx</strong></span></p> 
<pre><code class="language-javascript">import { memo, useEffect, useContext } from 'react';
import { CounterContext, ThemeContext } from './context';

// 1. 自定义hook，命名必须以use开头 =&gt; context抽取共享
const useSelfContext = (name) =&gt; {
  const counterContext = useContext(CounterContext);
  const themeContext = useContext(ThemeContext);
  return { counterContext, themeContext };
};

const FirstComponent = memo(() =&gt; {
  // 2. 使用自定义hook
  const { counterContext, themeContext } = useSelfContext();
  return (
    &lt;&gt;
      &lt;h1&gt;firstComponent&lt;/h1&gt;
      &lt;div&gt;
        counterContext {'=&gt;'} {counterContext.counter}
      &lt;/div&gt;
      &lt;div&gt;
        themeContext {'=&gt;'} {themeContext.theme}
      &lt;/div&gt;
    &lt;/&gt;
  );
});

const SecondComponent = memo(() =&gt; {
  // 2. 使用自定义hook
  const { counterContext, themeContext } = useSelfContext();
  return (
    &lt;&gt;
      &lt;h1&gt;secondComponent&lt;/h1&gt;
      &lt;div&gt;
        counterContext {'=&gt;'} {counterContext.counter}
      &lt;/div&gt;
      &lt;div&gt;
        themeContext {'=&gt;'} {themeContext.theme}
      &lt;/div&gt;
    &lt;/&gt;
  );
});

const App = memo(() =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;App&lt;/h1&gt;

      &lt;FirstComponent /&gt;
      &lt;SecondComponent /&gt;
    &lt;/&gt;
  );
});

export default App;
</code></pre> 
<h3 style="background-color:transparent;"><span style="color:#4da8ee;">3. 获取滚动位置</span></h3> 
<p class="img-center"><img alt="" height="382" src="https://images2.imgbox.com/15/a1/Nk5zPbUi_o.gif" width="421"></p> 
<pre><code class="language-javascript">import { memo, useEffect, useContext, useState } from 'react';

// 1. 自定义hook，命名必须以use开头 =&gt; 获取滚动位置
const useScrollPosition = () =&gt; {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  useEffect(
    () =&gt; {
      function scrollFn() {
        console.log('scroll', window.scrollY, window.scrollX);
        setPosition({ x: window.scrollX, y: window.scrollY });
      }
      window.addEventListener('scroll', scrollFn);
      return () =&gt; {
        window.removeEventListener('scroll', scrollFn);
      };
    },
    // 不依赖，只执行一次
    []
  );
  return position;
};

const FirstComponent = memo(() =&gt; {
  // 2. 使用自定义hook
  const position = useScrollPosition();
  return (
    &lt;&gt;
      &lt;h1&gt;
        firstComponent : {position.x} - {position.y}
      &lt;/h1&gt;
    &lt;/&gt;
  );
});

const SecondComponent = memo(() =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;secondComponent&lt;/h1&gt;
    &lt;/&gt;
  );
});

const App = memo(() =&gt; {
  return (
    &lt;div style={<!-- -->{ height: '2000px' }}&gt;
      &lt;h1&gt;App&lt;/h1&gt;

      &lt;FirstComponent /&gt;
      &lt;SecondComponent /&gt;
    &lt;/div&gt;
  );
});

export default App;
</code></pre> 
<h3><span style="color:#4da8ee;">4. localStorage数据存储</span></h3> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a8/77/nlg7osZq_o.gif"></p> 
<pre><code class="language-javascript">import { memo, useEffect, useState } from 'react';

// 自定义hook，命名必须以use开头 =&gt; localStorage数据存储
const useLocalStorage = (key) =&gt; {
  // 1. 通过 localStorage 获取数据，初始化 state
  const [data, setData] = useState(() =&gt; {
    return JSON.parse(localStorage.getItem(key)) || '';
  });

  // 2. 监听 localStorage 变化，更新 state
  useEffect(() =&gt; {
    localStorage.setItem(key, JSON.stringify(data));
  }, [data, key]);

  // 3. 返回 state 和更新 state 的函数
  return [data, setData];
};

const SecondComponent = memo(() =&gt; {
  // 1. 使用自定义 hook
  const [name, setName] = useLocalStorage('name');
  return (
    &lt;&gt;
      &lt;h1&gt;secondComponent : {name}&lt;/h1&gt;
      &lt;button onClick={() =&gt; setName(Math.random().toFixed(2))}&gt;setName&lt;/button&gt;
    &lt;/&gt;
  );
});

const App = memo(() =&gt; {
  const [age, setAge] = useLocalStorage('age');

  return (
    &lt;div&gt;
      &lt;h1&gt;App&lt;/h1&gt;
      &lt;h1&gt;age : {age}&lt;/h1&gt;
      &lt;button onClick={() =&gt; setAge((Math.random() + 10).toFixed(2))}&gt;setAge&lt;/button&gt;
      &lt;hr /&gt;
      &lt;SecondComponent /&gt;
    &lt;/div&gt;
  );
});

export default App;
</code></pre> 
<h2><span style="color:#956fe7;">十二、redux hooks</span></h2> 
<p><span style="color:#0d0016;"><strong>在之前的redux开发中，为了让组件和redux结合起来，我们使用了react-redux中的connect：</strong></span></p> 
<ul><li><span style="color:#0d0016;"><strong>但是这种方式必须使用高阶函数结合返回的高阶组件</strong></span></li><li><span style="color:#0d0016;"><strong>并且必须编写：</strong></span><span style="color:#fe2c24;"><strong>mapStateToProps和 mapDispatchToProps</strong></span><span style="color:#0d0016;"><strong>映射的函数</strong></span></li></ul> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>在Redux7.1开始，提供了Hook的方式，再也不需要编写connect以及对应的映射函数了</strong></span></p> 
</blockquote> 
<h3><span style="color:#4da8ee;"><strong>配置</strong></span></h3> 
<h4><span style="color:#38d8f0;"><strong>安装</strong></span></h4> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>npm i react-redux @reduxjs/toolkit</strong></span></p> 
</blockquote> 
<h4><span style="color:#38d8f0;">目录结构</span></h4> 
<p><span style="color:#ff9900;"><strong>store/modules/counter.js</strong></span></p> 
<pre><code class="language-javascript">import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: {
    counter: 66,
    message: 'Hello Redux'
  },
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    // Use the PayloadAction type to declare the contents of `action.payload`
    incrementAction(state, { payload }) {
      state.counter += payload;
    },
    messageChangeAction(state, { payload }) {
      state.message = payload;
    }
  }
});

export default counterSlice.reducer;

export const { incrementAction, messageChangeAction } = counterSlice.actions;
</code></pre> 
<p><span style="color:#ff9900;"><strong>store/index.js</strong></span></p> 
<pre><code class="language-javascript">import { configureStore } from '@reduxjs/toolkit';

import counterReducer from './modules/counter';

const store = configureStore({
  reducer: {
    counter: counterReducer
    // Add the generated reducer as a specific top-level slice
  }
});

export default store;
</code></pre> 
<p><span style="color:#ff9900;"><strong>index.js </strong></span></p> 
<pre><code class="language-javascript">import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';

import { Provider } from 'react-redux';
import store from './store';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;
);</code></pre> 
<h3 style="background-color:transparent;"><span style="color:#4da8ee;">之前的使用方法</span></h3> 
<pre><code class="language-javascript">import React, { memo } from 'react';
import { connect } from 'react-redux';
import { incrementAction } from './store/modules/counter';

const App = memo((props) =&gt; {
  // 4. 接收状态和dispatch
  const { counter, increment } = props;
  return (
    &lt;&gt;
      &lt;div&gt;App&lt;/div&gt;
      &lt;div&gt;counter: {counter}&lt;/div&gt;
      &lt;button onClick={() =&gt; increment(5)}&gt;+5&lt;/button&gt;
      &lt;button onClick={() =&gt; increment(-5)}&gt;-5&lt;/button&gt;
    &lt;/&gt;
  );
});

// 1. 映射状态
const mapStateToProps = (state) =&gt; ({
  counter: state.counter.counter
});

// 2. 映射dispatch
const mapDispatchToProps = (dispatch) =&gt; ({
  increment(num) {
    dispatch(incrementAction(num));
  }
});

// 3. connect高阶组件
export default connect(mapStateToProps, mapDispatchToProps)(App);
</code></pre> 
<h3><span style="color:#4da8ee;">hooks中使用</span></h3> 
<ul><li><strong><span style="color:#fe2c24;">useSelector : 将state映射到组件中</span></strong> 
  <ul><li><strong><span style="color:#1c7331;">​​​​​​​参数</span></strong> 
    <ul><li><strong>参数一：将state映射到需要的数据中 =&gt; <span style="color:#fe2c24;">是个回调函数</span></strong></li><li><strong>参数二：可以进行比较来决定是否组件重新渲染</strong></li></ul></li><li><strong>useSelector默认会<span style="color:#1c7331;">比较</span>我们返回的两个对象<span style="color:#1c7331;">是否相等</span></strong> 
    <ul><li><strong>比较方式  const refEquality = (a, b) =&gt; a === b</strong></li><li><strong>也就是<span style="color:#fe2c24;">必须返回两个完全相等的对象</span>才可以不引起重新渲染</strong></li></ul></li></ul></li><li><span style="color:#fe2c24;"><strong>useDispatch : 接获取dispatch函数</strong></span></li><li><span style="color:#fe2c24;"><strong>useStore : 获取当前的store对象</strong></span></li></ul> 
<h4><span style="color:#38d8f0;"><strong>基本使用</strong></span></h4> 
<pre><code class="language-javascript">import React, { memo } from 'react';
// 1. 导入
import { useSelector, useDispatch } from 'react-redux';
import { incrementAction } from './store/modules/counter';

const Home = memo((props) =&gt; {
  const state = useSelector((state) =&gt; ({
    message: state.counter.message
  }));

  console.log('Home render');
  return (
    &lt;&gt;
      &lt;div&gt;Home&lt;/div&gt;
      &lt;div&gt;message: {state.message}&lt;/div&gt;
    &lt;/&gt;
  );
});

const App = memo((props) =&gt; {
  // 2. 获取store中的数据, 通过useSelector映射到组件中
  const state = useSelector((state) =&gt; ({
    counter: state.counter.counter
  }));

  // 3. 获取dispatch, 通过useDispatch映射到组件中
  const dispatch = useDispatch();
  const incrementHandle = (num) =&gt; {
    // 4. 调用dispatch, 传入action
    dispatch(incrementAction(num));
  };

  console.log('App render');

  return (
    &lt;&gt;
      &lt;div&gt;App&lt;/div&gt;
      &lt;div&gt;counter: {state.counter}&lt;/div&gt;
      &lt;button onClick={(e) =&gt; incrementHandle(5)}&gt;+5&lt;/button&gt;
      &lt;button onClick={(e) =&gt; incrementHandle(-5)}&gt;-5&lt;/button&gt;
      &lt;hr /&gt;
      &lt;Home /&gt;
    &lt;/&gt;
  );
});

export default App;
</code></pre> 
<h4><span style="color:#38d8f0;">存在问题</span></h4> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>子组件home使用了memo : memo包裹的组件，只有当props改变时，才会重新渲染</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>但是App组件更改了counter后，Home组件也跟着刷新了</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>Home组件更改message后，App也重新渲染了</strong></span></p> 
 <p> </p> 
 <p><span style="color:#ff9900;"><strong>原因 : 因为useSelector默认监听的是整个state，只要有一个地方改变了，全部重新渲染</strong></span></p> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/78/d5/p0zleWIu_o.gif"></p> 
<h4><span style="color:#38d8f0;">解决方法</span></h4> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>在使用useSelector时，</strong></span><span style="color:#fe2c24;"><strong>第二个参数</strong></span><span style="color:#1a439c;"><strong>传入浅层比较函数</strong></span><span style="color:#fe2c24;"><strong>shallowEqual</strong></span><span style="color:#1a439c;"><strong>即可</strong></span></p> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a6/6b/OnNnUqst_o.gif"></p> 
<pre><code class="language-javascript">// 导入入shallowEqual
import { useSelector, useDispatch, shallowEqual } from 'react-redux';

// ...

const state = useSelector(
  (state) =&gt; ({
    message: state.counter.message
  }),
  shallowEqual
);

// ...

const state = useSelector(
  (state) =&gt; ({
    counter: state.counter.counter
  }),
  shallowEqual
);</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/98ddfd96f42bb1d70acbd7ccaa094793/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Maya】Unreal5 Livelink for Maya的安装记录和UE5.0中的Maya livelink使用方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b85ee955fe4e38c5066fb39896d8803b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">双系统ubuntu20.04(neotic版本)从0实现Gazebo仿真slam建图</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>