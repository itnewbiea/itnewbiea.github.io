<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【JavaSE】继承 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【JavaSE】继承" />
<meta property="og:description" content="目录
super关键字
1.访问父类成员变量
2.调用父类成员方法
3.super()调用父类构造方法
构造方法 代码块执行顺序
final关键字
1.修饰成员变量
2.修饰成员方法
3.修饰类
super关键字 1.访问父类成员变量 2.调用父类成员方法 class Animal{ //方便后续操作，把成员变量都设置成public public String name; public int age; public void eat(){ System.out.println(name&#43;&#34;吃饭&#34;); } } class Dog extends Animal{ public boolean loyal; //通过构造方法初始化 public Dog(){ //通过super关键字对父类当中的成员变量赋值 super.name = &#34;旺财&#34;; super.age = 4; super.eat(); //通过this关键字对子类当中的成员变量赋值 this.loyal = true; } public void gradHouse(){ System.out.println(name&#43;&#34;守护房子！&#34;); } } class Cat extends Animal{ public boolean lazy; public Cat(){ super.name = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f26214c65b525ccfbdaf9435c0639448/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-09T13:33:23+08:00" />
<meta property="article:modified_time" content="2022-08-09T13:33:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【JavaSE】继承</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="super%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:0px;"><a href="#super%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">super关键字</a></p> 
<p id="1.%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-toc" style="margin-left:40px;"><a href="#1.%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F" rel="nofollow">1.访问父类成员变量</a></p> 
<p id="2.%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#2.%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95" rel="nofollow">2.调用父类成员方法</a></p> 
<p id="3.super()%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#3.super%28%29%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" rel="nofollow">3.super()调用父类构造方法</a></p> 
<p id="%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%C2%A0-toc" style="margin-left:0px;"><a href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%C2%A0" rel="nofollow">构造方法 </a></p> 
<p id="%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-toc" style="margin-left:0px;"><a href="#%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F" rel="nofollow">代码块执行顺序</a></p> 
<p id="final%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:0px;"><a href="#final%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">final关键字</a></p> 
<p id="1.%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-toc" style="margin-left:40px;"><a href="#1.%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F" rel="nofollow">1.修饰成员变量</a></p> 
<p id="2.%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#2.%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95" rel="nofollow">2.修饰成员方法</a></p> 
<p id="3.%E4%BF%AE%E9%A5%B0%E7%B1%BB-toc" style="margin-left:40px;"><a href="#3.%E4%BF%AE%E9%A5%B0%E7%B1%BB" rel="nofollow">3.修饰类</a></p> 
<hr> 
<h2 id="super%E5%85%B3%E9%94%AE%E5%AD%97">super关键字</h2> 
<h3 id="1.%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">1.访问父类成员变量</h3> 
<h3 id="2.%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95">2.调用父类成员方法</h3> 
<pre><code class="language-java">class Animal{
    //方便后续操作，把成员变量都设置成public
    public String name;
    public int age;

    public void eat(){
        System.out.println(name+"吃饭");
    }
}

class Dog extends Animal{
    public boolean loyal;

    //通过构造方法初始化
    public Dog(){
        //通过super关键字对父类当中的成员变量赋值
        super.name = "旺财";
        super.age = 4;
        super.eat();
        //通过this关键字对子类当中的成员变量赋值
        this.loyal = true;

    }

    public void gradHouse(){
        System.out.println(name+"守护房子！");
    }
}

class Cat extends Animal{
    public boolean lazy;

    public Cat(){
        super.name = "咪咪";
        super.age = 3;
        super.eat();
        this.lazy = false;
    }
    public void catchMouse(){
        System.out.println(name+"抓老鼠！");
    }
}

public class Test {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.gradHouse();

        Cat cat = new Cat();
        cat.catchMouse();
    }
}</code></pre> 
<blockquote> 
 <p>注：在子类方法中或者通过子类对象访问成员时：</p> 
 <p>1.若是父类和子类中<strong>没有相同</strong>的成员变量、方法，此时想访问哪个变量就访问哪个变量，也不需要加super关键字。</p> 
 <p>2.若是父类和子类中有<strong>相同</strong>的成员变量，此时访问名字相同的变量时，不用super关键字，<strong>优先访问子类中变量</strong>。</p> 
 <p>3.若是<strong>方法名相同</strong>，但是<strong>返回值与参数不同</strong>，则会匹配到子类或父类中与之对应的方法，若方法名，返回值与参数都相同，优先访问子类中的方法。</p> 
 <p>4.<strong>相同</strong>时，非要访问父类中的成员，通过super关键字就可以了。</p> 
</blockquote> 
<h3 id="3.super()%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">3.super()调用父类构造方法</h3> 
<pre><code class="language-java">class Animal{
    //方便后续操作，把成员变量都设置成public
    public String name;
    public int age;

    //自己写的父类构造方法
    public Animal(String name,int age){
        this.name = name;
        this.age = age;
    }

    public void eat(){
        System.out.println(name+"吃饭");
    }
}

class Dog extends Animal{
    public boolean loyal;

    public Dog() {
        //通过 super() 调用父类的构造方法
        super("旺财", 4);
    }
    public void gradHouse(){
        System.out.println(name+"守护房子！");
    }
}

class Cat extends Animal{
    public boolean lazy;

    public Cat(){
        super("咪咪",4);
    }
    public void catchMouse(){
        System.out.println(name+"抓老鼠！");
    }
}</code></pre> 
<blockquote> 
 <p>注：</p> 
 <p>1.super关键字只能在<strong>非静态</strong>的方法中使用。</p> 
 <p>2.在构造方法调用时，super()和this()<strong>不能同时出现</strong>。</p> 
 <p>3.构造方法中<strong>一定</strong>会有super()的调用，即使没有写上去，编译器也会默认加上去的。在构造方法中详解。</p> 
</blockquote> 
<hr> 
<h2 id="%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%C2%A0">构造方法 </h2> 
<p>1.没有写子类构造方法和父类构造方法</p> 
<pre><code class="language-java">class Father{
    int date1;

    public void func1(){
        System.out.println("这是父类的一个成员方法！");
    }
}

class Son extends Father{
    int date2;

    public void func2(){
        System.out.println("这是子类的一个成员方法！");
    }
}

public class Test {
    public static void main(String[] args) {
        Father f = new Father();
        Son s = new Son();
        
        f.func1();
        s.func2();
    }
}</code></pre> 
<blockquote> 
 <p>虽然在父类和子类中<strong>都没有构造方法</strong>，但是编译器会<strong>自动</strong>帮我们把父类和子类的构造方法(不带任何参数的)写上去，并且在<strong>子类的构造方法</strong>中的<strong>第一行调用  super()</strong>  。</p> 
</blockquote> 
<p>2.写了子类构造方法，父类没有写</p> 
<pre><code class="language-java">class Father{
    int date1;

    public void func1(){
        System.out.println("这是父类的一个成员方法！");
    }
}

class Son extends Father{
    int date2;

    public Son(){
        //super()  
        //由于父类中没有写构造方法，编译器在父类自动生成不带参数的构造方法
        //所以这个super() 虽然没有写，但是编译器一定会在子类构造方法第一行帮我们写上去
        System.out.println("这是子类的一个构造方法！");
    }

    public void func2(){
        System.out.println("这是子类的一个成员方法！");
    }
}

public class Test {
    public static void main(String[] args) {
        Father f = new Father();
        Son s = new Son();

        f.func1();
        s.func2();
    }
}</code></pre> 
<p><img alt="" height="157" src="https://images2.imgbox.com/5e/4d/hDgx15rE_o.png" width="334"></p> 
<p> 3.子类和父类中都写了构造方法</p> 
<pre><code class="language-java">class Father{
    int date1;

    public Father(int n){
        System.out.println("这是带一个参数的父类构造方法！");
    }

    public void func1(){
        System.out.println("这是父类的一个成员方法！");
    }
}

class Son extends Father{
    int date2;

    public Son(){
        //此时的super必须写上去，并且要把参数对应上
        super(66);
        System.out.println("这是子类的一个构造方法！");
    }

    public void func2(){
        System.out.println("这是子类的一个成员方法！");
    }
}

public class Test {
    public static void main(String[] args) {
        Father f = new Father(66);
        Son s = new Son();

        f.func1();
        s.func2();
    }
}
</code></pre> 
<p><img alt="" height="212" src="https://images2.imgbox.com/c0/ce/PX4SNOXq_o.png" width="401"></p> 
<h2 id="%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">代码块执行顺序</h2> 
<pre><code class="language-java">class People{
    public String name;
    int age;

    public People(){
        name = "张三";
        age = 18;
        System.out.println("这是父类中的一个构造方法在初始化");
    }

    {
        System.out.println("这是父类实例化代码块！");
    }

    static {
        System.out.println("这是父类静态代码块！");
    }

    public void A(){
        System.out.println("这是父类中的一个成员方法！");
    }
}

class Student extends People{
    String num;

    public Student(){
        num = "20220809";
        System.out.println("这是子类中的一个构造方法在初始化");
    }

    {
        System.out.println("这是子类实例化代码块！");
    }

    static {
        System.out.println("这是子类静态代码块！");
    }

    public void B(){
        System.out.println("这是子类中的一个成员方法！");
    }
}

public class Test2 {
    public static void main(String[] args) {
        Student s1 = new Student();

        System.out.println("--------------------------------");
        Student s2 = new Student();

    }
}</code></pre> 
<p><img alt="" height="456" src="https://images2.imgbox.com/ab/6e/tk5rO4df_o.png" width="529"></p> 
<blockquote> 
 <p> 小结：</p> 
 <p>1.<strong>静态代码块先执行</strong>，并且<strong>只执行一次</strong>。因为被static修饰的代码块是在类加载阶段执行。</p> 
 <p></p> 
 <p>2.<strong>先</strong>执行<strong>父类</strong>代码，<strong>再</strong>执行<strong>子类</strong>代码。其中<strong>实例代码块</strong>比构造方法要<strong>先</strong>被执行。这是在实例化对象的时候执行的。</p> 
</blockquote> 
<hr> 
<h2 id="final%E5%85%B3%E9%94%AE%E5%AD%97">final关键字</h2> 
<h3 id="1.%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">1.修饰成员变量</h3> 
<p>表示该变量就是<strong>常量</strong>，不能被修改。</p> 
<div> 
 <pre><code class="language-java">final int a = 10; 
//a不能被修改
//a = 20;</code></pre> 
</div> 
<h3 id="2.%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95">2.修饰成员方法</h3> 
<p>表示该方法不能被  重写。 </p> 
<p>多态的文章当中讲解  重写。</p> 
<h3 id="3.%E4%BF%AE%E9%A5%B0%E7%B1%BB">3.修饰类</h3> 
<p>表示该类不能被继承</p> 
<pre><code class="language-java">final public class Animal {
//无法继承此类
}
public class Cat extends Animal {
//编译会出错
}</code></pre> 
<hr> 
<p>有什么错误评论区指出。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/07aa2df7ea4646d5f0022847b1c927a5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">svg图片调整大小和颜色</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6d1877d5c70ab94945f08f53fdc4e719/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JavaScript 面向对象详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>