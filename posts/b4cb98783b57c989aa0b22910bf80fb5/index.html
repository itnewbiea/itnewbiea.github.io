<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>几张图轻松理解String.intern() - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="几张图轻松理解String.intern()" />
<meta property="og:description" content="在翻《深入理解Java虚拟机》的书时，又看到了2-7的 String.intern()返回引用的测试。 其实要搞明白String.intern()，我总结了下面几条规则： 一、new String都是在堆上创建字符串对象。当调用 intern() 方法时，编译器会将字符串添加到常量池中（stringTable维护），并返回指向该常量的引用。 二、通过字面量赋值创建字符串（如：String str=”twm”）时，会先在常量池中查找是否存在相同的字符串，若存在，则将栈中的引用直接指向该字符串；若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串。 三、常量字符串的“&#43;”操作，编译阶段直接会合成为一个字符串。如string str=”JA”&#43;”VA”，在编译阶段会直接合并成语句String str=”JAVA”，于是会去常量池中查找是否存在”JAVA”,从而进行创建或引用。
四、对于final字段，编译期直接进行了常量替换（而对于非final字段则是在运行期进行赋值处理的）。 final String str1=”ja”; final String str2=”va”; String str3=str1&#43;str2; 在编译时，直接替换成了String str3=”ja”&#43;”va”，根据第三条规则，再次替换成String str3=”JAVA”
五、常量字符串和变量拼接时（如：String str3=baseStr &#43; “01”;）会调用stringBuilder.append()在堆上创建新的对象。
六、JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。简单的说，就是往常量池放的东西变了：原来在常量池中找不到时，复制一个副本放到常量池，1.7后则是将在堆上的地址引用复制到常量池。 举例说明：
String str2 = new String(&#34;str&#34;)&#43;new String(&#34;01&#34;); str2.intern(); String str1 = &#34;str01&#34;; System.out.println(str2==str1); 在JDK 1.7下，当执行str2.intern();时，因为常量池中没有“str01”这个字符串，所以会在常量池中生成一个对堆中的“str01”的引用(注意这里是引用 ，就是这个区别于JDK 1.6的地方。在JDK1.6下是生成原字符串的拷贝)，而在进行String str1 = “str01”;字面量赋值的时候，常量池中已经存在一个引用，所以直接返回了该引用，因此str1和str2都指向堆中的同一个字符串，返回true。
String str2 = new String(&#34;str&#34;)&#43;new String(&#34;01&#34;); String str1 = &#34;str01&#34;; str2.intern(); System.out.println(str2==str1); 将中间两行调换位置以后，因为在进行字面量赋值（String str1 = “str01″）的时候，常量池中不存在，所以str1指向的常量池中的位置，而str2指向的是堆中的对象，再进行intern方法时，对str1和str2已经没有影响了，所以返回false。
常见试题解答 有了对以上的知识的了解，我们现在再来看常见的面试或笔试题就很简单了： Q：下列程序的输出结果： String s1 = “abc”; String s2 = “abc”; System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b4cb98783b57c989aa0b22910bf80fb5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-04-12T20:35:49+08:00" />
<meta property="article:modified_time" content="2017-04-12T20:35:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">几张图轻松理解String.intern()</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>在翻《深入理解Java虚拟机》的书时，又看到了2-7的 String.intern()返回引用的测试。 <br> 其实要搞明白String.intern()，我总结了下面几条规则： <br> 一、new String都是在堆上创建字符串对象。当调用 intern() 方法时，编译器会将字符串添加到常量池中（stringTable维护），并返回指向该常量的引用。 <br> <img src="https://images2.imgbox.com/ce/b1/TdOBuNDJ_o.png" alt="这里写图片描述" title=""></p> 
<p><img src="https://images2.imgbox.com/72/e2/hMUoMYqi_o.png" alt="这里写图片描述" title=""></p> 
<p>二、通过字面量赋值创建字符串（如：String str=”twm”）时，会先在常量池中查找是否存在相同的字符串，若存在，则将栈中的引用直接指向该字符串；若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串。 <br> <img src="https://images2.imgbox.com/c9/19/Epbal3vC_o.png" alt="这里写图片描述" title=""></p> 
<p>三、常量字符串的“+”操作，编译阶段直接会合成为一个字符串。如string str=”JA”+”VA”，在编译阶段会直接合并成语句String str=”JAVA”，于是会去常量池中查找是否存在”JAVA”,从而进行创建或引用。</p> 
<p>四、对于final字段，编译期直接进行了常量替换（而对于非final字段则是在运行期进行赋值处理的）。 <br> final String str1=”ja”; <br> final String str2=”va”; <br> String str3=str1+str2; <br> 在编译时，直接替换成了String str3=”ja”+”va”，根据第三条规则，再次替换成String str3=”JAVA”</p> 
<p>五、常量字符串和变量拼接时（如：String str3=baseStr + “01”;）会调用stringBuilder.append()在堆上创建新的对象。</p> 
<p>六、JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。简单的说，就是往常量池放的东西变了：原来在常量池中找不到时，复制一个副本放到常量池，1.7后则是将在堆上的地址引用复制到常量池。 <br> <img src="https://images2.imgbox.com/60/56/qzxP7PHJ_o.png" alt="这里写图片描述" title=""></p> 
<p>举例说明：</p> 
<pre class="prettyprint"><code class=" hljs vhdl"><span class="hljs-typename">String</span> str2 = <span class="hljs-keyword">new</span> <span class="hljs-typename">String</span>(<span class="hljs-string">"str"</span>)+<span class="hljs-keyword">new</span> <span class="hljs-typename">String</span>(<span class="hljs-string">"01"</span>);
str2.intern();
<span class="hljs-typename">String</span> str1 = <span class="hljs-string">"str01"</span>;
System.<span class="hljs-keyword">out</span>.println(str2==str1);</code></pre> 
<p>在JDK 1.7下，当执行str2.intern();时，因为常量池中没有“str01”这个字符串，所以会在常量池中生成一个对堆中的“str01”的<strong>引用</strong>(<strong><em>注意这里是引用 ，就是这个区别于JDK 1.6的地方。在JDK1.6下是生成原字符串的拷贝</em></strong>)，而在进行String str1 = “str01”;字面量赋值的时候，常量池中已经存在一个引用，所以直接返回了该引用，因此str1和str2都指向堆中的同一个字符串，返回true。</p> 
<pre class="prettyprint"><code class=" hljs vhdl"><span class="hljs-typename">String</span> str2 = <span class="hljs-keyword">new</span> <span class="hljs-typename">String</span>(<span class="hljs-string">"str"</span>)+<span class="hljs-keyword">new</span> <span class="hljs-typename">String</span>(<span class="hljs-string">"01"</span>);
<span class="hljs-typename">String</span> str1 = <span class="hljs-string">"str01"</span>;
str2.intern();
System.<span class="hljs-keyword">out</span>.println(str2==str1);</code></pre> 
<p>将中间两行调换位置以后，因为在进行字面量赋值（String str1 = “str01″）的时候，常量池中不存在，所以str1指向的常量池中的位置，而str2指向的是堆中的对象，再进行intern方法时，对str1和str2已经没有影响了，所以返回false。</p> 
<h3 id="常见试题解答">常见试题解答</h3> 
<p>有了对以上的知识的了解，我们现在再来看常见的面试或笔试题就很简单了： <br> Q：下列程序的输出结果： <br> String s1 = “abc”; <br> String s2 = “abc”; <br> System.out.println(s1 == s2); <br> A：true，均指向常量池中对象。</p> 
<p>Q：下列程序的输出结果： <br> String s1 = new String(“abc”); <br> String s2 = new String(“abc”); <br> System.out.println(s1 == s2); <br> A：false，两个引用指向堆中的不同对象。</p> 
<p>Q：下列程序的输出结果： <br> String s1 = “abc”; <br> String s2 = “a”; <br> String s3 = “bc”; <br> String s4 = s2 + s3; <br> System.out.println(s1 == s4); <br> A：false，因为s2+s3实际上是使用StringBuilder.append来完成，会生成不同的对象。</p> 
<p>Q：下列程序的输出结果： <br> String s1 = “abc”; <br> final String s2 = “a”; <br> final String s3 = “bc”; <br> String s4 = s2 + s3; <br> System.out.println(s1 == s4); <br> A：true，因为final变量在编译后会直接替换成对应的值，所以实际上等于s4=”a”+”bc”，而这种情况下，编译器会直接合并为s4=”abc”，所以最终s1==s4。</p> 
<p>Q：下列程序的输出结果： <br> String s = new String(“abc”); <br> String s1 = “abc”; <br> String s2 = new String(“abc”); <br> System.out.println(s == s1.intern()); <br> System.out.println(s == s2.intern()); <br> System.out.println(s1 == s2.intern()); <br> A：false，false，true。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1640a51ea4d8bf316225aeabd60972f7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">EventBus3.0源码分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a05fda7900f4317a3faf9f9fd236cb3a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android FDE 加密过程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>