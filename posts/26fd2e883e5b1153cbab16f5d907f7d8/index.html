<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Effective C# 摘录(2) - .NET资源管理 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Effective C# 摘录(2) - .NET资源管理" />
<meta property="og:description" content="12:变量声明时初始化优于赋值语句。
Prefer Variable Initializers to Assignment Statements。
若类的实例变量成员在声明时初始化，初始化代码会内联到该类的每个实例构造函数中:构造对象实例时，先执行初始化代码，再调用基类构造函数，最后执行构造函数中代码。
当构造函数有多个重载版本时，建议在定义字段时避免进行初始化，而应该将这些公共的初始化语句放在一个构造函数中，然后使其他的构造器显示地调用这个初始化构造函数。 13:使用静态构造器初始化静态类成员。
Initialize Static Class Members with Static Constructors.
若类中的静态变量成员在声明时初始化，初始化代码会内联到类的静态构造函数中:运行时，先执行初始化代码，再执行静态构造函数中的代码。建议：简单静态成员可以直接在声明时初始化，而可能产生异常的初始化则应放在静态构造函数中初始化。
14:利用构造器链。
Utilize Constructor Chaining.
只能使用this(args)(构造器链中的最后一个构造函数中调用Base))和base(args)中一个，不能同时使用。
15:利用using和try/finally语句来清理资源。
Utilize using and Try/finally for Resource Cleanup.
using所使用的对象必须继承IDisposable，且不支持运行时类型检查(可用as转换,但可能会隐藏bug，一般确保每一个实现了IDispose接口的对象分配在在using范围内)。
16:尽量减少内存垃圾。
Minimize Garbage.
使用类成员而代替每个函数中都用到的局部变量；使用Singleton模式来实现公用对象或将其实现为对象池。
17:尽量减少装箱与拆箱。
Minimize Boxing and Unboxing。
防止隐式装箱。eg:Console.WriteLine( &#34;Number list:{0}, {1}, {2}&#34;,1,2,3 );=&gt;Console.WriteLine( &#34;Number list:{0}, {1}, {2}&#34;,1.ToString(),2.ToString(),3.ToString() );
18:实现标准Dispose模式。
Implement the Standard Dispose Pattern.
Dispose()应做的工作：释放所有非托管资源；释放所有托管资源，这包括取消事件绑定；设置标志位，标明对象已经释放；调用“GC.SuppressFinalize(this)”来避免GC再去掉用对象的析构函数。
如果父类和子类都使用了非托管资源，则子类在重载父类的Dispose()函数中，要记得显式调用父类的Dispose()。
转载于:https://www.cnblogs.com/happyhippy/archive/2007/03/15/676392.html" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/26fd2e883e5b1153cbab16f5d907f7d8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-05T01:03:14+08:00" />
<meta property="article:modified_time" content="2019-07-05T01:03:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Effective C# 摘录(2) - .NET资源管理</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p><strong>12:变量声明时初始化优于赋值语句。</strong><br>   Prefer Variable Initializers to Assignment Statements。<br>   若类的实例变量成员在声明时初始化，初始化代码会内联到该类的每个实例构造函数中:构造对象实例时，先执行初始化代码，再调用基类构造函数，最后执行构造函数中代码。<br>   当构造函数有多个重载版本时，建议在定义字段时避免进行初始化，而应该将这些公共的初始化语句放在一个构造函数中，然后使其他的构造器显示地调用这个初始化构造函数。   </p> 
 <p><strong>13:使用静态构造器初始化静态类成员。</strong><br>   Initialize Static Class Members with Static Constructors.<br>   若类中的静态变量成员在声明时初始化，初始化代码会内联到类的静态构造函数中:运行时，先执行初始化代码，再执行静态构造函数中的代码。建议：简单静态成员可以直接在声明时初始化，而可能产生异常的初始化则应放在静态构造函数中初始化。</p> 
 <p><strong>14:利用构造器链。</strong><br>   Utilize Constructor Chaining.<br>   只能使用this(args)(构造器链中的最后一个构造函数中调用Base))和base(args)中一个，不能同时使用。</p> 
 <p><strong>15:利用using和try/finally语句来清理资源。<br></strong>   Utilize using and Try/finally for Resource Cleanup.<br>   using所使用的对象必须继承IDisposable，且不支持运行时类型检查(可用as转换,但可能会隐藏bug，一般确保每一个实现了IDispose接口的对象分配在在using范围内)。</p> 
 <p><strong>16:尽量减少内存垃圾。</strong><br>   Minimize Garbage.<br>   使用类成员而代替每个函数中都用到的局部变量；使用Singleton模式来实现公用对象或将其实现为对象池。</p> 
 <p><strong>17:尽量减少装箱与拆箱。</strong><br>   Minimize Boxing and Unboxing。<br>   防止隐式装箱。eg:Console.WriteLine( "Number list:{0}, {1}, {2}",1,2,3 );=&gt;Console.WriteLine( "Number list:{0}, {1}, {2}",1.ToString(),2.ToString(),3.ToString() );</p> 
 <p><strong>18:实现标准Dispose模式。</strong><br>   Implement the Standard Dispose Pattern.<br>   Dispose()应做的工作：释放所有非托管资源；释放所有托管资源，这包括取消事件绑定；设置标志位，标明对象已经释放；调用“GC.SuppressFinalize(this)”来避免GC再去掉用对象的析构函数。<br>   如果父类和子类都使用了非托管资源，则子类在重载父类的Dispose()函数中，要记得显式调用父类的Dispose()。<br>    </p> 
</div> 
<p>转载于:https://www.cnblogs.com/happyhippy/archive/2007/03/15/676392.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/368af2fb050e723889faa80559316ed2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pdftk - 一个不错的pdf文档合并工具</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c1a75b8e72e4e61d8b979af51bd30ba2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">XSLT学习笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>