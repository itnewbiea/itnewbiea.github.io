<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>无线网phcp服务器异常,DHCP服务异常导致网络故障一例   (ZT) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="无线网phcp服务器异常,DHCP服务异常导致网络故障一例   (ZT)" />
<meta property="og:description" content="有一次单位里的局域网出现问题，有很多机器无法与LAN连接，但另一部分机器却能正常工作。
怎么会这样的呢？这些机器一直都工作得很正常呀。查看一下这些机器相关属性，发现：能正常工作的机器，无论是使用指定IP还是使用通过DHCP自动获取IP，都获得了正确的IP地址；而那些不能正常工作的机器，全都是使用通过DHCP自动获得的IP地址，是不是在IP地址方面有问题导致网络不通？
检查了几台出问题的机器发现，有些机器的IP地址变为169.254打头的地址，这显然不对。正常工作的机器应使用192打头的C类地址，而这些出问题的机器用的却是B类地址。由于169与192打头的机器不处在同一网段，又没有其它跨网段的手段，当然也就无法互通了。
可是，还几台不能正常上网的机器却拥有以192打头的IP地址，那这些机器又为何无法正常接入局域网呢？找到一台这样的机器，记下它的机器名DP，记下它目前获得的IP地址：
192.168.0.42备用。
另找一台能正常上网的机器，从这台机器ping刚刚我们记下的那个IP地址：
ping 192.168.0.42
不通，再试着ping那台机器的机器名：
ping DP
当然不会通，但是却发现了一个意外的情况--机器名DP能够被解析成IP地址，但这个地址192.168.0.57显然不是我们刚刚记下的那个IP地址。
这又是怎么回事？
重启这些有出问题的机器--&#34;老兄，别试了，如果重启管用还要网管干什么？&#34;
我晕……
重启完成后果然故障依旧。
“以前也出现过这种情况，但不象今天一下子坏了一大批。由于不急着用，也就没管它。谁知道过两天它自己就好了。”
“真的这样？”
“那当然！”
呵呵，这就好办了，这一定是DHCP的某个环节出问题了！
那DHCP出问题怎么导致出这种故障现象？这还得从DHCP的工作机制说起。
现在，TCP/IP协议在局域网中已经得到了普遍的应用。一些小规模的网络可以利用HOSTS或LMHOSTS文件实现IP地址的静态管理。这种单纯的命名空间的管理方式相对比较简单，但如果管理的是一个较大的网络，或者是网络中频繁地出现某电脑脱离网络或有新电脑加入网络的情况，特别是那些用笔记本的移动用户，管理起来就相当的费时和烦琐。采用DHCP服务器进行管理是一个很常用的解决办法。
动态主机配置协议(DHCP)是一种动态的机制，它允许客户机在启动引导时向DHCP服务器请求一个地址，并且由DHCP服务器集中管理记录了机器名和IP地址对应关系的一个库。
DHCP服务器中有一个地址池，里面有多个可供分配的IP地址。每个IP地址被分配给某个客户机之后，DHCP服务器会记录下该客户机的机器名与IP地址间的一个对应关系，并且指定一个时间间隔，这个时间间隔称为一个租用周期。
租用周期通常是由网管设定的一个时间间隔，决定一台电脑可以持续使用一个分配的地址多久。
一台客户机在启动的过程中会发一个广播消息，相当于大喊了一声：谁是DHCP服务器呀？
DHCP服务器听到(收到这个广播消息)之后，就会给出应答：我能提供DHCP服务。由于此时客户机还没获得地址，DHCP也是以广播形式给出这个应答。
如果网络里有多个DHCP服务器，客户机就会收到不止一个应答，客户机会从这些应答当中选一个。此时客户机已经知道了DHCP服务器的所在，于是直接向DHCP服务器发一个请求：“嘿！你好，我是DP，给我分配一个IP地址吧。”
DHCP服务器会在应答中给出客户机所需的一些配置信息，并确认IP地址的租赁期。
客户机会把这次与DHCP会话所得的一些信息保存下来，以后在重启的过程中只需验证一下：
&#34;嘿！DHCP你好，我是DP，你还记得我吗？&#34;
DHCP答道：“当然，你还用上次我给你的那些资料吧！”
于是客户机DP就可以直接使用上一次保存在本地的信息了。
看到这里大家也许看出点问题了。
如果某种原因，造成DHCP服务异常，无法正常给客户机应答，甚至出现服务器端的数据与客户端的数据不一致，就会造成那些客户机无法上网了。因为DNS服务器就会从DHCP那里得到错误的信息。
那么，为什么系统重启之后，客户机仍无法上网呢？这些客户机又为什么过几天自己就会好呢？
这与客户端信息的更新机制有关。客户机会把它从DHCP服务器得的IP地址和其它相关信息保存在本地硬盘里。这些信息里包括该IP地址的租赁周期。当过了一个租赁周期的50%时，客户机就必须更新该租用。当过了该租赁周期的87.5%之后，该客户机就会认为，原先的那台DHCP服务器已经不再能提供相应的服务了，于是就再次发一个广播消息，寻找另一个DHCP服务器。
很显然，由于重启后客户机仍认为拥有&#34;最新&#34;的数据，也就没去与DHCP好好沟通一下，导致了数据的不一致。
如果该客户机被关闭一段时候，或租赁过期了，那么再经过一天的延迟之后，系统就可以将该IP地址分配给别的电脑使用。
那么又是什么原因使一些机器获得了形如169.254.*.*之类的IP地址呢？这说明这些机器根本未能获得DHCP服务。比如说，DHCP服务器太忙，无法及时给客户机应答，使客户机认为网络里不存在DHCP服务器。这时，微软的操作系统会自动查找一个形如169.254.*.*的IP地址分配给客户机，如果它发现该地址已被使用，就会去做另一次尝试。如果试了10次也未能成功找到一个可分配的IP地址，才会放弃。
经检查，的确是DHCP服务器出问题所致。于是在DHCP地址池中删除那些不能上网的机器的信息，释放这些地址资源，再重启DHCP服务器。重启完成之后通知各客户机用户，重启系统，故障排除！
当然，另一种解决办法就是给客户端分配固定的IP地址，在机器数量较少的情况下，这个办法显得更好一些。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/667f423d3daf242c905cb73ec55e4ce9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-06T19:05:10+08:00" />
<meta property="article:modified_time" content="2021-08-06T19:05:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">无线网phcp服务器异常,DHCP服务异常导致网络故障一例   (ZT)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>有一次单位里的局域网出现问题，有很多机器无法与LAN连接，但另一部分机器却能正常工作。</p> 
 <p>怎么会这样的呢？这些机器一直都工作得很正常呀。查看一下这些机器相关属性，发现：能正常工作的机器，无论是使用指定IP还是使用通过DHCP自动获取IP，都获得了正确的IP地址；而那些不能正常工作的机器，全都是使用通过DHCP自动获得的IP地址，是不是在IP地址方面有问题导致网络不通？</p> 
 <p>检查了几台出问题的机器发现，有些机器的IP地址变为169.254打头的地址，这显然不对。正常工作的机器应使用192打头的C类地址，而这些出问题的机器用的却是B类地址。由于169与192打头的机器不处在同一网段，又没有其它跨网段的手段，当然也就无法互通了。</p> 
 <p>可是，还几台不能正常上网的机器却拥有以192打头的IP地址，那这些机器又为何无法正常接入局域网呢？找到一台这样的机器，记下它的机器名DP，记下它目前获得的IP地址：</p> 
 <p>192.168.0.42备用。</p> 
 <p>另找一台能正常上网的机器，从这台机器ping刚刚我们记下的那个IP地址：</p> 
 <p>ping 192.168.0.42</p> 
 <p>不通，再试着ping那台机器的机器名：</p> 
 <p>ping DP</p> 
 <p>当然不会通，但是却发现了一个意外的情况--机器名DP能够被解析成IP地址，但这个地址192.168.0.57显然不是我们刚刚记下的那个IP地址。</p> 
 <p>这又是怎么回事？</p> 
 <p>重启这些有出问题的机器--"老兄，别试了，如果重启管用还要网管干什么？"</p> 
 <p>我晕……</p> 
 <p>重启完成后果然故障依旧。</p> 
 <p>“以前也出现过这种情况，但不象今天一下子坏了一大批。由于不急着用，也就没管它。谁知道过两天它自己就好了。”</p> 
 <p>“真的这样？”</p> 
 <p>“那当然！”</p> 
 <p>呵呵，这就好办了，这一定是DHCP的某个环节出问题了！</p> 
 <p>那DHCP出问题怎么导致出这种故障现象？这还得从DHCP的工作机制说起。</p> 
 <p>现在，TCP/IP协议在局域网中已经得到了普遍的应用。一些小规模的网络可以利用HOSTS或LMHOSTS文件实现IP地址的静态管理。这种单纯的命名空间的管理方式相对比较简单，但如果管理的是一个较大的网络，或者是网络中频繁地出现某电脑脱离网络或有新电脑加入网络的情况，特别是那些用笔记本的移动用户，管理起来就相当的费时和烦琐。采用DHCP服务器进行管理是一个很常用的解决办法。</p> 
 <p>动态主机配置协议(DHCP)是一种动态的机制，它允许客户机在启动引导时向DHCP服务器请求一个地址，并且由DHCP服务器集中管理记录了机器名和IP地址对应关系的一个库。</p> 
 <p>DHCP服务器中有一个地址池，里面有多个可供分配的IP地址。每个IP地址被分配给某个客户机之后，DHCP服务器会记录下该客户机的机器名与IP地址间的一个对应关系，并且指定一个时间间隔，这个时间间隔称为一个租用周期。</p> 
 <p>租用周期通常是由网管设定的一个时间间隔，决定一台电脑可以持续使用一个分配的地址多久。</p> 
 <p>一台客户机在启动的过程中会发一个广播消息，相当于大喊了一声：谁是DHCP服务器呀？</p> 
 <p>DHCP服务器听到(收到这个广播消息)之后，就会给出应答：我能提供DHCP服务。由于此时客户机还没获得地址，DHCP也是以广播形式给出这个应答。</p> 
 <p>如果网络里有多个DHCP服务器，客户机就会收到不止一个应答，客户机会从这些应答当中选一个。此时客户机已经知道了DHCP服务器的所在，于是直接向DHCP服务器发一个请求：“嘿！你好，我是DP，给我分配一个IP地址吧。”</p> 
 <p>DHCP服务器会在应答中给出客户机所需的一些配置信息，并确认IP地址的租赁期。</p> 
 <p>客户机会把这次与DHCP会话所得的一些信息保存下来，以后在重启的过程中只需验证一下：</p> 
 <p>"嘿！DHCP你好，我是DP，你还记得我吗？"</p> 
 <p>DHCP答道：“当然，你还用上次我给你的那些资料吧！”</p> 
 <p>于是客户机DP就可以直接使用上一次保存在本地的信息了。</p> 
 <p>看到这里大家也许看出点问题了。</p> 
 <p>如果某种原因，造成DHCP服务异常，无法正常给客户机应答，甚至出现服务器端的数据与客户端的数据不一致，就会造成那些客户机无法上网了。因为DNS服务器就会从DHCP那里得到错误的信息。</p> 
 <p>那么，为什么系统重启之后，客户机仍无法上网呢？这些客户机又为什么过几天自己就会好呢？</p> 
 <p>这与客户端信息的更新机制有关。客户机会把它从DHCP服务器得的IP地址和其它相关信息保存在本地硬盘里。这些信息里包括该IP地址的租赁周期。当过了一个租赁周期的50%时，客户机就必须更新该租用。当过了该租赁周期的87.5%之后，该客户机就会认为，原先的那台DHCP服务器已经不再能提供相应的服务了，于是就再次发一个广播消息，寻找另一个DHCP服务器。</p> 
 <p>很显然，由于重启后客户机仍认为拥有"最新"的数据，也就没去与DHCP好好沟通一下，导致了数据的不一致。</p> 
 <p>如果该客户机被关闭一段时候，或租赁过期了，那么再经过一天的延迟之后，系统就可以将该IP地址分配给别的电脑使用。</p> 
 <p>那么又是什么原因使一些机器获得了形如169.254.*.*之类的IP地址呢？这说明这些机器根本未能获得DHCP服务。比如说，DHCP服务器太忙，无法及时给客户机应答，使客户机认为网络里不存在DHCP服务器。这时，微软的操作系统会自动查找一个形如169.254.*.*的IP地址分配给客户机，如果它发现该地址已被使用，就会去做另一次尝试。如果试了10次也未能成功找到一个可分配的IP地址，才会放弃。</p> 
 <p>经检查，的确是DHCP服务器出问题所致。于是在DHCP地址池中删除那些不能上网的机器的信息，释放这些地址资源，再重启DHCP服务器。重启完成之后通知各客户机用户，重启系统，故障排除！</p> 
 <p>当然，另一种解决办法就是给客户端分配固定的IP地址，在机器数量较少的情况下，这个办法显得更好一些。</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ab29d41eb234564e70da8f6ee89e19a5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux web 服务器性能,Linux系统Web服务器性能测试(2)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/85a51600dc4746f25b3e9336da9a2e61/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">更多笔记~</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>