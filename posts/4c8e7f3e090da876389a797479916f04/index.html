<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>我给面试官讲解了单例模式后，他对我竖起了大拇指！ - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="我给面试官讲解了单例模式后，他对我竖起了大拇指！" />
<meta property="og:description" content="单例模式相信大家都有所听闻，甚至也写过不少了，在面试中也是考得最多的其中一个设计模式，面试官常常会要求写出两种类型的单例模式并且解释其原理，废话不多说，我们开始学习如何很好地回答这一道面试题吧。
1. 什么是单例模式 面试官问什么是单例模式时，千万不要答非所问，给出单例模式有两种类型之类的回答，要围绕单例模式的定义去展开。
单例模式是指在内存中只会创建且仅创建一次对象的设计模式。在程序中多次使用同一个对象且作用相同时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中创建一个对象，让所有需要调用的地方都共享这一单例对象。
2. 单例模式的类型 单例模式有两种类型：
懒汉式：在真正需要使用对象时才去创建该单例类对象饿汉式：在类加载时已经创建好该单例对象，等待被程序使用 懒汉式创建单例对象 懒汉式创建对象的方法是在程序使用对象前，先判断该对象是否已经实例化（判空），若已实例化直接返回该类对象。，否则则先执行实例化操作。
根据上面的流程图，就可以写出下面的这段代码
public class Singleton { private static Singleton singleton; private Singleton(){} public static Singleton getInstance() { if (singleton == null) { singleton = new Singleton(); } return singleton; } } 没错，这里我们已经写出了一个很不错的单例模式，不过它不是完美的，但是这并不影响我们使用这个“单例对象”。
以上就是懒汉式创建单例对象的方法，我会在后面解释这段代码在哪里可以优化，存在什么问题。
饿汉式创建单例对象 饿汉式在类加载时已经创建好该对象，在程序调用时直接返回该单例对象即可，即我们在编码时就已经指明了要马上创建这个对象，不需要等到被调用时再去创建。
关于类加载，涉及到JVM的内容，我们目前可以简单认为在程序启动时，这个单例对象就已经创建好了。
public class Singleton{ private static final Singleton singleton = new Singleton(); private Singleton(){} public static Singleton getInstance() { return singleton; } } 注意上面的代码在第3行已经实例化好了一个Singleton对象在内存中，不会有多个Singleton对象实例存在" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4c8e7f3e090da876389a797479916f04/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-12T11:02:07+08:00" />
<meta property="article:modified_time" content="2020-07-12T11:02:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">我给面试官讲解了单例模式后，他对我竖起了大拇指！</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>单例模式相信大家都有所听闻，甚至也写过不少了，在面试中也是考得最多的其中一个设计模式，面试官常常会要求写出两种类型的单例模式并且解释其原理，废话不多说，我们开始学习如何很好地回答这一道面试题吧。</p> 
<h2 id="FCW8O">1. 什么是单例模式</h2> 
<p>面试官问什么是单例模式时，千万不要答非所问，给出单例模式有两种类型之类的回答，要围绕单例模式的定义去展开。</p> 
<p><strong>单例模式是指在内存中只会创建且仅创建一次对象的设计模式。</strong>在程序中<strong>多次使用同一个对象且作用相同</strong>时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中<strong>创建一个对象</strong>，让所有需要调用的地方都共享这一单例对象。</p> 
<p style="text-align:center;"><img alt="image.png" height="279" src="https://images2.imgbox.com/bf/7d/DBk4c01y_o.png" width="479"></p> 
<h2 id="HkzVe">2. 单例模式的类型</h2> 
<p>单例模式有两种类型：</p> 
<ul><li>懒汉式：在<strong>真正需要使用</strong>对象时才去创建该单例类对象</li><li>饿汉式：在<strong>类加载</strong>时已经创建好该单例对象，等待被程序使用</li></ul> 
<h3 id="oNYok">懒汉式创建单例对象</h3> 
<p>懒汉式创建对象的方法是在程序使用对象前，先判断该对象是否已经实例化<strong>（判空），</strong>若已实例化直接返回该类对象。，否则则先执行实例化操作。</p> 
<p style="text-align:center;"><img alt="image.png" height="369" src="https://images2.imgbox.com/65/7b/htu3ll9P_o.png" width="311"></p> 
<p>根据上面的流程图，就可以写出下面的这段代码</p> 
<pre><code class="language-java">public class Singleton {
    
    private static Singleton singleton;
    
    private Singleton(){}
    
    public static Singleton getInstance() {
        if (singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
    
}</code></pre> 
<p>没错，这里我们已经写出了一个很不错的单例模式，不过它不是完美的，但是这并不影响我们使用这个“单例对象”。</p> 
<p>以上就是懒汉式创建单例对象的方法，我会在后面解释这段代码在哪里可以优化，存在什么问题。</p> 
<h3 id="EVKpy">饿汉式创建单例对象</h3> 
<p>饿汉式在<strong>类加载</strong>时已经创建好该对象，在程序调用时<strong>直接返回</strong>该单例对象即可，即我们在编码时就已经指明了要马上创建这个对象，<strong>不需要等到被调用时再去创</strong><strong>建</strong>。</p> 
<p>关于类加载，涉及到JVM的内容，我们目前可以简单认为在程序启动时，这个单例对象就已经创建好了。</p> 
<p style="text-align:center;"><img alt="image.png" height="342" src="https://images2.imgbox.com/4c/ed/TkCpgimh_o.png" width="398"></p> 
<pre><code class="language-java">public class Singleton{
    
    private static final Singleton singleton = new Singleton();
    
    private Singleton(){}
    
    public static Singleton getInstance() {
        return singleton;
    }
}</code></pre> 
<p>注意上面的代码在第3行已经实例化好了一个Singleton对象在内存中，不会有多个Singleton对象实例存在</p> 
<p>类在加载时会在堆内存中创建一个Singleton对象，当类被卸载时，Singleton对象也随之消亡了。</p> 
<h2 id="g3l8g">3. 懒汉式如何保证只创建一个对象</h2> 
<p>我们再来回顾懒汉式的核心方法</p> 
<pre><code class="language-java">public static Singleton getInstance() {
    if (singleton == null) {
        singleton = new Singleton();
    }
    return singleton;
}</code></pre> 
<p>这个方法其实是存在问题的，试想一下，如果两个线程同时判断singleton为空，那么它们都会去实例化一个Singleton对象，这就变成双例了。所以，我们要解决的是<strong>线程安全</strong>问题。</p> 
<p style="text-align:center;"><img alt="image.png" height="162" src="https://images2.imgbox.com/a0/f5/5uLFrIfU_o.png" width="727"></p> 
<p>最容易想到的解决方法就是在方法上加锁，或者是对类对象加锁，程序就会变成下面这个样子</p> 
<pre><code class="language-java">public static synchronized Singleton getInstance() {
    if (singleton == null) {
        singleton = new Singleton();
    }
    return singleton;
}
// 或者
public static Singleton getInstance() {
    synchronized(Singleton.class) {   
        if (singleton == null) {
            singleton = new Singleton();
        }
    }
    return singleton;
}</code></pre> 
<p>这样就规避了两个线程同时创建Singleton对象的风险，但是引来另外一个问题：<strong>每次去获取对象都需要先获取锁，并发性能非常地差，极端情况下，可能会出现卡顿现象。</strong></p> 
<p>接下来要做的就是<strong>优化性能，目标是：</strong>如果没有实例化对象则加锁创建，如果已经实例化了，则不需要加锁，直接获取实例</p> 
<p><strong>所以直接在方法上加锁的方式就被废掉了，因为这种方式无论如何都需要先获取锁</strong></p> 
<pre><code class="language-java">public static Singleton getInstance() {
    if (singleton == null) {  // 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton
        synchronized(Singleton.class) { // 线程A或线程B获得该锁进行初始化
            if (singleton == null) { // 其中一个线程进入该分支，另外一个线程则不会进入该分支
                singleton = new Singleton();
            }
        }
    }
    return singleton;
}</code></pre> 
<p>上面的代码已经完美地解决了<strong>并发安全+性能低效</strong>问题：</p> 
<ul><li>第2行代码，如果singleton不为空，则直接返回对象，不需要获取锁；而如果多个线程发现singleton为空，则进入分支；</li><li>第3行代码，多个线程尝试争抢同一个锁，只有一个线程争抢成功，第一个获取到锁的线程会再次判断singleton是否为空，因为singleton有可能已经被之前的线程实例化</li><li>其它之后获取到锁的线程在执行到第4行校验代码，发现singleton已经不为空了，则不会再new一个对象，直接返回对象即可</li><li>之后所有进入该方法的线程都不会去获取锁，在第一次判断singleton对象时已经不为空了</li></ul> 
<p> </p> 
<p>因为需要两次判空，且对类对象加锁，该懒汉式写法也被称为：<strong>Double Check（双重校验） + Lock（加锁）</strong></p> 
<p>​完整的代码如下所示：</p> 
<pre><code class="language-java">public class Singleton {
    
    private static Singleton singleton;
    
    private Singleton(){}
    
    public static Singleton getInstance() {
        if (singleton == null) {  // 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton
            synchronized(Singleton.class) { // 线程A或线程B获得该锁进行初始化
                if (singleton == null) { // 其中一个线程进入该分支，另外一个线程则不会进入该分支
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
    
}</code></pre> 
<p>上面这段代码已经近似完美了，但是还存在最后一个问题：指令重排</p> 
<h2 id="LmcmX">4. 使用volatile防止指令重排</h2> 
<p>创建一个对象，在JVM中会经过三步：</p> 
<p>（1）为singleton分配内存空间</p> 
<p>（2）初始化singleton对象</p> 
<p>（3）将singleton指向分配好的内存空间</p> 
<p>指令重排序是指：<strong>JVM在保证最终结果正确的情况下，可以不按照程序编码的顺序执行语句，尽可能提高程序的性能</strong></p> 
<p>在这三步中，第2、3步有可能会发生指令重排现象，创建对象的顺序变为1-3-2，会导致多个线程获取对象时，有可能线程A创建对象的过程中，执行了1、3步骤，线程B判断singleton已经不为空，获取到未初始化的singleton对象，就会报NPE异常。文字较为晦涩，可以看流程图：</p> 
<p style="text-align:center;"><img alt="image.png" height="168" src="https://images2.imgbox.com/b4/7f/5D6MGrVW_o.png" width="846"></p> 
<p>使用volatile关键字可以<strong>防止指令重排序，</strong>​其原理较为复杂，这篇博客不打算展开，可以这样理解：<strong>使用volatile关键字修饰的变量，可以保证其指令执行的顺序与程序指明的顺序一致，不会发生顺序变换</strong>，这样在多线程环境下就不会发生NPE异常了。</p> 
<blockquote> 
 <p>volatile还有第二个作用：使用volatile关键字修饰的变量，可以保证其内存可见性，即每一时刻线程读取到该变量的值都是内存中最新的那个值，<strong>线程每次操作该变量都需要先读取该变量。</strong></p> 
</blockquote> 
<p>最终的代码如下所示：</p> 
<pre><code class="language-java">public class Singleton {
    
    private static volatile Singleton singleton;
    
    private Singleton(){}
    
    public static Singleton getInstance() {
        if (singleton == null) {  // 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton
            synchronized(Singleton.class) { // 线程A或线程B获得该锁进行初始化
                if (singleton == null) { // 其中一个线程进入该分支，另外一个线程则不会进入该分支
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
    
}</code></pre> 
<h3 id="fcff4f71">5. 破坏懒汉式单例与饿汉式单例</h3> 
<p>无论是完美的懒汉式还是饿汉式，终究敌不过<strong>反射和序列化</strong>，它们俩都可以把单例对象破坏掉（产生多个对象）。</p> 
<p>1：演示利用<strong>反射</strong>破坏单例模式</p> 
<pre><code class="language-java">public static void main(String[] args) {
    // 获取类的显式构造器
    Constructor&lt;Singleton&gt; construct = Singleton.class.getDeclaredConstructor();
    // 可访问私有构造器
    construct.setAccessible(true); 
    // 利用反射构造新对象
    Singleton obj1 = construct.newInstance(); 
    // 通过正常方式获取单例对象
    Singleton obj2 = Singleton.getInstance(); 
    System.out.println(obj1 == obj2); // false
}</code></pre> 
<p>上述的代码一针见血了：利用反射，强制访问类的私有构造器，去创建另一个对象</p> 
<p>2：利用<strong>序列化与反序列化</strong>破坏单例模式</p> 
<pre><code class="language-java">public static void main(String[] args) {
    // 创建输出流
    ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("Singleton.file"));
    // 将单例对象写到文件中
    oos.writeObject(Singleton.getInstance());
    // 从文件中读取单例对象
    File file = new File("Singleton.file");
    ObjectInputStream ois =  new ObjectInputStream(new FileInputStream(file));
    Singleton newInstance = (Singleton) ois.readObject();
    // 判断是否是同一个对象
    System.out.println(newInstance == Singleton.getInstance()); // false
}</code></pre> 
<p>两个对象地址不相等的原因是：readObject() 方法读入对象时，<strong>它必定会返回一个新的对象实例</strong>，必然指向新的内存地址。</p> 
<h3 id="745c1277">6. 能让面试官鼓掌的枚举实现</h3> 
<p>我们已经掌握了懒汉式与饿汉式的常见写法了，在《大话设计模式》中的单例模式章节也止步于此。但是，追求极致的我们，怎么能够止步于此，在《Effective Java》书中，给出了终极解决方法，话不多说，学完下面，真的不虚面试官考你了。</p> 
<p>在 JDK1.5 后，使用 Java 语言实现单例模式的方式又多了一种：<strong>枚举</strong></p> 
<p>我们先来看看枚举如何实现单例模式的，如下代码：</p> 
<pre><code class="language-java">public enum Singleton {
    INSTANCE;
    
    public void doSomething() {
        System.out.println("这是枚举类型的单例模式！");
    }
}</code></pre> 
<p>需要思考：<strong>使用枚举实现单例模式的优势在哪里？</strong></p> 
<p>我们从最直观的地方入手，第一眼看到这几行代码，就会感觉到“少”，没错，就是少，虽然这优势有些牵强，但写的代码越少，越不容易出错。</p> 
<p><strong>优势1</strong>：代码对比饿汉式与懒汉式来说，更加地简洁</p> 
<p>其次，既然是实现单例模式，那这种写法<strong>必定满足单例模式</strong>的要求，而且使用枚举实现时，没有做任何额外的处理。</p> 
<p><strong>优势2</strong>：它不需要做任何额外的操作去保证对象单一性与线程安全性</p> 
<p>我写了一段测试代码放在下面，这一段代码可以<strong>证明程序启动时仅会创建一个 Singleton 对象</strong>，且是线程安全的。</p> 
<blockquote> 
 <p>我们可以简单地理解枚举实现单例的过程：<strong>在程序启动时，会调用Singleton的空参构造器，实例化好一个Singleton对象赋给INSTANCE，之后再也不会实例化</strong></p> 
</blockquote> 
<pre><code class="language-java">public enum Singleton {
    INSTANCE;
    Singleton() { System.out.println("枚举创建对象了"); }
    public static void main(String[] args) { /* test(); */ }
    public void test() {
        Singleton t1 = Singleton.INSTANCE;
        Singleton t2 = Singleton.INSTANCE;
        System.out.print("t1和t2的地址是否相同：" + t1 == t2);
    }
}
// 枚举创建对象了
// t1和t2的地址是否相同：true</code></pre> 
<p>除了优势1和优势2，还有最后一个优势让枚举实现单例模式在目前看来已经是“无懈可击”了。</p> 
<p><strong>优势3</strong>：使用枚举可以防止调用者使用<strong>反射</strong>、<strong>序列化与反序列化</strong>机制强制生成多个单例对象，破坏单例模式。</p> 
<p>防破坏的原理如下：</p> 
<p><strong>（1）防反射</strong></p> 
<p style="text-align:center;"><img alt="image-20200718213354831.png" height="479" src="https://images2.imgbox.com/6a/65/LF0FPSOv_o.png" width="419"></p> 
<p>枚举类默认继承了 Enum 类，在利用反射调用 newInstance() 时，会判断该类是否是一个枚举类，如果是，则抛出异常。</p> 
<p><strong>（2）防止反序列化创建多个枚举对象</strong></p> 
<p>在读入Singleton对象时，每个枚举类型和枚举名字都是唯一的，所以在序列化时，仅仅只是对枚举的<strong>类型和变量名</strong>输出到文件中，在读入文件反序列化成对象时，<strong>利用 Enum 类的 valueOf(String name) 方法</strong>根据变量的名字查找对应的枚举对象。</p> 
<p> </p> 
<p>所以，在序列化和反序列化的过程中，只是写出和读入了<strong>枚举类型和名字</strong>，没有任何关于对象的操作。</p> 
<p> </p> 
<p style="text-align:center;"><img alt="image-20200718224707754.png" height="420" src="https://images2.imgbox.com/72/b0/eWtc0Zrm_o.png" width="662"></p> 
<p>小总结：</p> 
<p>（1）Enum 类内部使用<strong>Enum 类型判定</strong>防止通过反射创建多个对象</p> 
<p>（2）Enum 类通过写出（读入）对象类型和枚举名字将对象序列化（反序列化），<strong>通过 valueOf() 方法匹配枚举名</strong>找到内存中的唯一的对象实例，防止通过反序列化构造多个对象</p> 
<p>（3）枚举类不需要关注线程安全、破坏单例和性能问题，因为其创建对象的时机与<strong>饿汉式单例有异曲同工之妙</strong>。</p> 
<h3 id="7e4acf90">7. 总结</h3> 
<p>（1）单例模式常见的写法有两种：<strong>懒汉式、饿汉式</strong></p> 
<p>（2）懒汉式：在需要用到对象时才实例化对象，正确的实现方式是：<strong>Double Check + Lock</strong>，解决了并发安全和性能低下问题</p> 
<p>（3）饿汉式：在<strong>类加载</strong>时已经创建好该单例对象，在获取单例对象时直接返回对象即可，不会存在并发安全和性能问题。</p> 
<p>（4）在开发中如果对<strong>内存要求非常高</strong>，那么使用懒汉式写法，可以在特定时候才创建该对象；</p> 
<p>（5）如果对内存要求不高使用饿汉式写法，因为<strong>简单不易出错</strong>，且没有任何并发安全和性能问题</p> 
<p>（6）为了防止多线程环境下，因为指令重排序导致变量报NPE，<strong>需要在单例对象上添加volatile关键字防止指令重排序</strong></p> 
<p>（7）最优雅的实现方式是使用<strong>枚举</strong>，其代码精简，没有线程安全问题，且 Enum 类内部<strong>防止反射和反序列化时破坏单例</strong>。</p> 
<p><span style="color:#3399ea;"><strong>看到这篇文章如此受欢迎后，有些受宠若惊，也欢迎各位小伙伴转载、收藏、点赞！</strong></span></p> 
<p><span style="color:#3399ea;"><strong>作者：大众程序猿</strong></span></p> 
<p><span style="color:#3399ea;"><strong>座右铭：比我们优秀的人多了去，但这并不防止我们追梦！</strong></span></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a3f7eb92289104178863c12303fe0144/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">华为交换机路由器最新默认密码大全</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b858cdaf633cc5d6f6773a9e5b9fbc75/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">手动下载依赖使用 pip 安装 wxPython</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>