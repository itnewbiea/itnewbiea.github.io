<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C中printf函数的实现原理 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C中printf函数的实现原理" />
<meta property="og:description" content="一、printf函数的实现原理 在C/C&#43;&#43;中，对函数参数的扫描是从后向前的。C/C&#43;&#43;的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了，下面给出printf(&#34;%d,%d&#34;,a,b);（其中a、b都是int型的）的汇编代码
.section .data string out = &#34;%d,%d&#34; push b push a push $out call printf 你会看到，参数是最后的先压入栈中，最先的后压入栈中，参数控制的那个字符串常量是最后被压入的，所以这个常量总是能被找到的。
二、可变参数表函数的设计 标准库提供的一些参数的数目可以有变化的函数。例如我们很熟悉的printf，它需要有一个格式串，还应根据需要为它提供任意多个“其他参数”。这种函数被称作“具有变长度参数表的函数”，或简称为“变参数函数”。我们写程序中有时也可能需要定义这种函数。要定义这类函数，就必须使用标准头文件&lt;stdarg.h&gt;，使用该文件提供的一套机制，并需要按照规定的定义方式工作。本节介绍这个头文件提供的有关功能，它们的意义和使用，并用例子说明这类函数的定义方法。
C中变长实参头文件stdarg.h提供了一个数据类型va_list和三个宏（va_start、va_arg和va_end），用它们在被调用函数不知道参数个数和类型时对可变参数表进行测试，从而为访问可变参数提供了方便且有效的方法。va_list是一个char类型的指针，当被调用函数使用一个可变参数时，它声明一个类型为va_list的变量，该变量用来指向va_arg和va_end所需信息的位置。下面给出va_list在C中的源码：
typedef char * va_list; void va_start(va_list ap,lastfix)是一个宏，它使va_list类型变量ap指向被传递给函数的可变参数表中的第一个参数，在第一次调用va_arg和va_end之前，必须首先调用该宏。va_start的第二个参数lastfix是传递给被调用函数的最后一个固定参数的标识符。va_start使ap只指向lastfix之外的可变参数表中的第一个参数，很明显它先得到第一个参数内存地址，然后又加上这个参数的内存大小，就是下个参数的内存地址了。下面给出va_start在C中的源码：
#define _INTSIZEOF(n) ( (sizeof(n) &#43; sizeof(int) - 1) &amp; ~(sizeof(int) - 1) ) #define va_start(ap,v) ( ap = (va_list)&amp;v &#43; _INTSIZEOF(v) ) //得到可变参数中第一个参数的首地址 type va_arg(va_list ap,type)也是一个宏，其使用有双重目的，第一个是返回ap所指对象的值，第二个是修改参数指针ap使其增加以指向表中下一个参数。va_arg的第二个参数提供了修改参数指针所必需的信息。在第一次使用va_arg时，它返回可变参数表中的第一个参数，后续的调用都返回表中的下一个参数，下面给出va_arg在C中的源码：
#define va_arg(ap,type) ( *(type *)((ap &#43;= _INTSIZEOF(type)) - _INTSIZEOF(type)) ) //将参数转换成需要的类型，并使ap指向下一个参数 在使用va_arg时，要注意第二个参数所用类型名应与传递到堆栈的参数的字节数对应，以保证能对不同类型的可变参数进行正确地寻址，比如实参依次为char型、char* 型、int型和float型时，在va_arg中它们的类型则应分别为int、char *、int和double.
void va_end(va_list ap)也是一个宏，该宏用于被调用函数完成正常返回，功能就是把指针ap赋值为0，使它不指向内存的变量。下面给出va_end在C中的源码：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/110f830bbcd36903acbb8b64be5df8c7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-02T17:03:11+08:00" />
<meta property="article:modified_time" content="2020-09-02T17:03:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C中printf函数的实现原理</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="printf_0"></a>一、printf函数的实现原理</h2> 
<p>在C/C++中，对函数参数的扫描是从后向前的。C/C++的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了，下面给出printf("%d,%d",a,b);（其中a、b都是int型的）的汇编代码</p> 
<pre><code class="prism language-c"><span class="token punctuation">.</span>section
<span class="token punctuation">.</span>data
string out <span class="token operator">=</span> <span class="token string">"%d,%d"</span>
push b
push a
push $out
call printf
</code></pre> 
<p>你会看到，参数是最后的先压入栈中，最先的后压入栈中，参数控制的那个字符串常量是最后被压入的，所以这个常量总是能被找到的。</p> 
<h2><a id="_13"></a>二、可变参数表函数的设计</h2> 
<p>标准库提供的一些参数的数目可以有变化的函数。例如我们很熟悉的printf，它需要有一个格式串，还应根据需要为它提供任意多个“其他参数”。这种函数被称作“具有变长度参数表的函数”，或简称为“变参数函数”。我们写程序中有时也可能需要定义这种函数。要定义这类函数，就必须使用标准头文件&lt;stdarg.h&gt;，使用该文件提供的一套机制，并需要按照规定的定义方式工作。本节介绍这个头文件提供的有关功能，它们的意义和使用，并用例子说明这类函数的定义方法。</p> 
<p>C中变长实参头文件stdarg.h提供了一个数据类型va_list和三个宏（va_start、va_arg和va_end），用它们在被调用函数不知道参数个数和类型时对可变参数表进行测试，从而为访问可变参数提供了方便且有效的方法。va_list是一个char类型的指针，当被调用函数使用一个可变参数时，它声明一个类型为va_list的变量，该变量用来指向va_arg和va_end所需信息的位置。下面给出va_list在C中的源码：</p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span>  va_list<span class="token punctuation">;</span>
</code></pre> 
<p>void va_start(va_list ap,lastfix)是一个宏，它使va_list类型变量ap指向被传递给函数的可变参数表中的第一个参数，在第一次调用va_arg和va_end之前，必须首先调用该宏。va_start的第二个参数lastfix是传递给被调用函数的最后一个固定参数的标识符。va_start使ap只指向lastfix之外的可变参数表中的第一个参数，很明显它先得到第一个参数内存地址，然后又加上这个参数的内存大小，就是下个参数的内存地址了。下面给出va_start在C中的源码：</p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">define</span> _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1) )</span>
<span class="token macro property">#<span class="token directive keyword">define</span> va_start(ap,v)  ( ap = (va_list)&amp;v + _INTSIZEOF(v) )   </span><span class="token comment">//得到可变参数中第一个参数的首地址</span>
</code></pre> 
<p>type va_arg(va_list ap,type)也是一个宏，其使用有双重目的，第一个是返回ap所指对象的值，第二个是修改参数指针ap使其增加以指向表中下一个参数。va_arg的第二个参数提供了修改参数指针所必需的信息。在第一次使用va_arg时，它返回可变参数表中的第一个参数，后续的调用都返回表中的下一个参数，下面给出va_arg在C中的源码：</p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">define</span> va_arg(ap,type)    ( *(type *)((ap += _INTSIZEOF(type)) - _INTSIZEOF(type)) )    </span><span class="token comment">//将参数转换成需要的类型，并使ap指向下一个参数</span>
</code></pre> 
<p>在使用va_arg时，要注意第二个参数所用类型名应与传递到堆栈的参数的字节数对应，以保证能对不同类型的可变参数进行正确地寻址，比如实参依次为char型、char* 型、int型和float型时，在va_arg中它们的类型则应分别为int、char *、int和double.</p> 
<p>void va_end(va_list ap)也是一个宏，该宏用于被调用函数完成正常返回，功能就是把指针ap赋值为0，使它不指向内存的变量。下面给出va_end在C中的源码：</p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">define</span> va_end(ap)      ( ap = (va_list)0 )</span>
</code></pre> 
<p>va_end必须在va_arg读完所有参数后再调用，否则会产生意想不到的后果。特别地，当可变参数表函数在程序执行过程中不止一次被调用时，在函数体每次处理完可变参数表之后必须调用一次va_end，以保证正确地恢复栈。</p> 
<p>一个变参数函数至少需要有一个普通参数，其普通参数可以具有任何类型。在函数定义中，这种函数的最后一个普通参数除了一般的用途之外，还有其他特殊用途。下面从一个例子开始说明有关的问题。</p> 
<p>假设我们想定义一个函数sum，它可以用任意多个整数类型的表达式作为参数进行调用，希望sum能求出这些参数的和。这时我们应该将sum定义为一个只有一个普通参数，并具有变长度参数表的函数，这个函数的头部应该是（函数原型与此类似）：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
</code></pre> 
<p>我们实际上要求在函数调用时，从第一个参数n得到被求和的表达式个数，从其余参数得到被求和的表达式。在参数表最后连续写三个圆点符号，说明这个函数具有可变数目的参数。凡参数表具有这种形式（最后写三个圆点），就表示定义的是一个变参数函数。注意，这样的三个圆点只能放在参数表最后，在所有普通参数之后。</p> 
<p>下面假设函数sum里所用的va_list类型的变量的名字是vap。在能够用vap访问实际参数之前，必须首先用宏va_start对这个变量进行初始化。宏va_start的类型特征可以大致描述为：</p> 
<pre><code class="prism language-c"><span class="token function">va_start</span><span class="token punctuation">(</span>va_list vap<span class="token punctuation">,</span> 最后一个普通参数<span class="token punctuation">)</span>
</code></pre> 
<p>在函数sum里对vap初始化的语句应当写为：</p> 
<pre><code class="prism language-c"><span class="token function">va_start</span><span class="token punctuation">(</span>vap<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> 相当于  <span class="token keyword">char</span> <span class="token operator">*</span>vap<span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>n <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>此时vap正好指向n后面的可变参数表中的第一个参数。</p> 
<p>在完成这个初始化之后，我们就可以通过另一个宏va_arg访问函数调用的各个实际参数了。宏va_arg的类型特征可以大致地描述为：</p> 
<pre><code class="prism language-c">类型 <span class="token function">va_arg</span><span class="token punctuation">(</span>va_list vap<span class="token punctuation">,</span> 类型名<span class="token punctuation">)</span>
</code></pre> 
<p>在调用宏va_arg时必须提供有关实参的实际类型，这一类型也将成为这个宏调用的返回值类型。对va_arg的调用不仅返回了一个实际参数的值（“当前”实际参数的值），同时还完成了某种更新操作，使对这个宏va_arg的下次调用能得到下一个实际参数。对于我们的例子，其中对宏va_arg的一次调用应当写为：</p> 
<pre><code class="prism language-c">v <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>vap<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这里假定v是一个有定义的int类型变量。</p> 
<p>在变参数函数的定义里，函数退出之前必须做一次结束动作。这个动作通过对局部的va_list变量调用宏va_end完成。这个宏的类型特征大致是：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">va_end</span><span class="token punctuation">(</span>va_list vap<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="_75"></a>三、栈中参数分布以及宏使用后的指针变化说明</h2> 
<p><img src="https://images2.imgbox.com/91/d3/dQz0f21F_o.png" alt="在这里插入图片描述"><br> 下面是函数sum的完整定义，从中可以看到各有关部分的写法：</p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
using namespace std<span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdarg.h&gt;</span></span>
 
<span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i <span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	va_list vap<span class="token punctuation">;</span>
	<span class="token function">va_start</span><span class="token punctuation">(</span>vap <span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//指向可变参数表中的第一个参数</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		sum <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>vap <span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//取出可变参数表中的参数，并修改参数指针vap使其增加以指向表中下一个参数</span>
	<span class="token function">va_end</span><span class="token punctuation">(</span>vap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//把指针vap赋值为0</span>
	<span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token punctuation">,</span> <span class="token number">45</span> <span class="token punctuation">,</span> <span class="token number">89</span> <span class="token punctuation">,</span> <span class="token number">72</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span>m<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里首先定义了va_list变量vap，而后对它初始化。循环中通过va_arg取得顺序的各个实参的值，并将它们加入总和。最后调用va_end结束。</p> 
<p>下面是调用这个函数的几个例子：</p> 
<pre><code class="prism language-c">k <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> k<span class="token operator">*</span><span class="token punctuation">(</span>k<span class="token operator">-</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>k<span class="token operator">*</span>k<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>函数sum中首先定义了可变参数表指针vap，而后通过va_start ( vap, n )取得了参数表首地址（赋值给了vap），其后的for循环则用来遍历可变参数表。这种遍历方式与我们在数据结构教材中经常看到的遍历方式是类似的。</p> 
<p>函数sum看起来简洁明了，但是实际上printf的实现却远比这复杂。sum函数之所以看起来简单，是因为：</p> 
<ul><li>sum函数可变参数表的长度是已知的，通过num参数传入；</li><li>sum函数可变参数表中参数的类型是已知的，都为int型。</li></ul> 
<p>而printf函数则没有这么幸运。首先，printf函数可变参数的个数不能轻易的得到，而可变参数的类型也不是固定的，需由格式字符串进行识别（由%f、%d、%s等确定），因此则涉及到可变参数表的更复杂应用。</p> 
<p>在这个函数中，需通过对传入的格式字符串（首地址为lpStr）进行识别来获知可变参数个数及各个可变参数的类型，具体实现体现在for循环中。譬如，在识别为%d后，做的是va_arg ( vap, int )，而获知为%l和%lf后则进行的是va_arg ( vap, long )、va_arg ( vap, double )。格式字符串识别完成后，可变参数也就处理完了。</p> 
<p>在编写和使用具有可变数目参数的函数时，有几个问题值得注意。</p> 
<ul><li>第一：调用va_arg将更新被操作的va_list变量（如在上例的vap），使下次调用可以得到下一个参数。在执行这个操作时，va_arg并不知道实际有几个参数，也不知道参数的实际类型，它只是按给定的类型完成工作。因此，写程序的人应在变参数函数的定义里注意控制对实际参数的处理过程。上例通过参数n提供了参数个数的信息，就是为了控制循环。标准库函数printf根据格式串中的转换描述的数目确定实际参数的个数。如果这方面信息有误，函数执行中就可能出现严重问题。编译程序无法检查这里的数据一致性问题，需要写程序的人自己负责。在前面章节里，我们一直强调对printf等函数调用时，要注意格式串与其他参数个数之间一致性，其原因就在这里。</li><li>第二：编译系统无法对变参数函数中由三个圆点代表的那些实际参数做类型检查，因为函数的头部没有给出这些参数的类型信息。因此编译处理中既不会生成必要的类型转换，也不会提供类型错误信息。考虑标准库函数printf，在调用这个函数时，不但实际参数个数可能变化，各参数的类型也可能不同，因此不可能有统一方式来描述它们的类型。对于这种参数，C语言的处理方式就是不做类型检查，要求写程序的人保证函数调用的正确性。</li></ul> 
<p>假设我们写出下面的函数调用：</p> 
<pre><code class="prism language-c">k <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2.4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5.72</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>编译程序不会发现这里参数类型不对，需要做类型转换，所有实参都将直接传给函数。函数里也会按照内部定义的方式把参数都当作整数使用。编译程序也不会发现参数个数与6不符。这一调用的结果完全由编译程序和执行环境决定，得到的结果肯定不会是正确的。</p> 
<h2><a id="_133"></a>四、源代码</h2> 
<pre><code class="prism language-c"><span class="token comment">/*
* =====================================================================================
*
*       Filename:  printf.c
*
*    Description:  printf 函数的实现
*
*        Version:  1.0
*        Created:  2010年12月12日 14时48分18秒
*       Revision:  none
*       Compiler:  gcc
*
*         Author:  Yang Shao Kun (), cdutyangshaokun@163.com
*        Company:  College of Information Engineering of CDUT
*
* =====================================================================================
*/</span>
要了解变参函数的实现，首先我们的弄清楚几个问题：
<span class="token number">1</span><span class="token punctuation">:</span>该函数有几个参数。
<span class="token number">2</span><span class="token punctuation">:</span>该函数增样去访问这些参数。
<span class="token number">3</span><span class="token punctuation">:</span>在访问完成后，如何从堆栈中释放这些参数。
对于c语言，它的调用规则遵循_cdedl调用规则。
在_cdedl规则中：<span class="token number">1.</span>参数从右到左依次入栈
                <span class="token number">2.</span>调用者负责清理堆栈
                <span class="token number">3.</span>参数的数量类型不会导致编译阶段的错误
要弄清楚变参函数的原理，我们需要解决上述的<span class="token number">3</span>个问题，其中的第三个问题，根据调
用原则，那我们现在可以不管。
要处理变参函数，需要用到 va_list 类型，和 va_start<span class="token punctuation">,</span>va_end<span class="token punctuation">,</span>va_arg 宏定义。我
看网上的许多资料说这些参数都是定义在stdarg<span class="token punctuation">.</span>h这个头文件中，但是在我的linux机
器上，我的版本是fedorea <span class="token number">14</span>，用vim访问的时候，确是在 acenv<span class="token punctuation">.</span>h这个头文件中，估
计是内核的版本不一样的原因吧！！！
上面的这几个宏和其中的类型，在内核中是这样来实现的：
<span class="token macro property">#<span class="token directive keyword">ifndef</span> _VALIST</span>
<span class="token macro property">#<span class="token directive keyword">define</span> _VALIST</span>
<span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span>va_list<span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">endif</span>                </span><span class="token comment">/* _VALIST */</span>
<span class="token comment">/*
* Storage alignment properties
*/</span>
<span class="token macro property">#<span class="token directive keyword">define</span>  _AUPBND                (sizeof (acpi_native_int) - 1)</span>
<span class="token macro property">#<span class="token directive keyword">define</span>  _ADNBND                (sizeof (acpi_native_int) - 1)</span>
<span class="token comment">/*
* Variable argument list macro definitions
*/</span>
<span class="token macro property">#<span class="token directive keyword">define</span> _bnd(X, bnd)            (((sizeof (X)) + (bnd)) &amp; (~(bnd)))</span>
<span class="token macro property">#<span class="token directive keyword">define</span> va_arg(ap, T)           (*(T *)(((ap) += (_bnd (T, _AUPBND))) - (_bnd (T,_ADNBND))))</span>
<span class="token macro property">#<span class="token directive keyword">define</span> va_end(ap)              (void) 0</span>
<span class="token macro property">#<span class="token directive keyword">define</span> va_start(ap, A)         (void) ((ap) = (((char *) &amp;(A)) + (_bnd (A,_AUPBND))))</span>
<span class="token macro property">#<span class="token directive keyword">endif</span>                </span><span class="token comment">/* va_arg */</span>
首先来看 va_list 类型，其实这是一个字符指针。
va_start<span class="token punctuation">,</span>是使ap指针指向变参函数中的下一个参数。
我们现在来看_bnd 宏的实现：
首先：
<span class="token keyword">typedef</span> s32 acpi_native_int<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span>            s32<span class="token punctuation">;</span>
看出来，acpi_native_int 其实就是 <span class="token keyword">int</span> 类型，那么，
<span class="token macro property">#<span class="token directive keyword">define</span>  _AUPBND                (sizeof (acpi_native_int) - 1)</span>
<span class="token macro property">#<span class="token directive keyword">define</span>  _ADNBND                (sizeof (acpi_native_int) - 1)</span>
这两个值就应该是相等的，都<span class="token operator">-</span>等于：<span class="token number">3</span><span class="token operator">==</span><span class="token number">0x00000003</span><span class="token punctuation">,</span>按位取反后的结果就是：<span class="token number">0xfffff</span>
ffc<span class="token punctuation">,</span>因此，
<span class="token function">_bnd</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>bnd<span class="token punctuation">)</span>宏在<span class="token number">32</span>位机下就是
<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span> <span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0xfffffffc</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>那么作用就很明显是取<span class="token number">4</span>的整数，就相当与
整数除法后取ceiling<span class="token operator">--</span>向上取整。
回过头来看 <span class="token function">va_start</span><span class="token punctuation">(</span>ap<span class="token punctuation">,</span>A<span class="token punctuation">)</span><span class="token punctuation">,</span>初始化参数指针ap，将函数参数A右边右边第一个参数地
址赋值给ap，A必须是一个参数的指针，所以，此种类型函数至少要有一个普通的参数
，从而提供给va_start <span class="token punctuation">,</span>这样va_start才能找到可变参数在栈上的位置。
<span class="token function">va_arg</span><span class="token punctuation">(</span>ap<span class="token punctuation">,</span>T<span class="token punctuation">)</span><span class="token punctuation">,</span>获得ap指向参数的值，同时使ap指向下一个参数，T用来指名当前参数类
型。
va_end 在有些简单的实现中不起任何作用，在有些实现中可能会把ap改成无效值，这
里，是把ap指针指向了 <span class="token constant">NULL</span>。
c标准要求在同一个函数中va_start 和va_end 要配对的出现。
那么到现在，处理多参数函数的步骤就是
<span class="token number">1</span>：首先是要保证该函数至少有一个参数，同时用<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>参数申明函数是变参函数。
<span class="token number">2</span>：在函数内部以<span class="token function">va_start</span><span class="token punctuation">(</span>ap<span class="token punctuation">,</span>A<span class="token punctuation">)</span>宏初始化参数指针。
<span class="token number">3</span>：用<span class="token function">va_arg</span><span class="token punctuation">(</span>ap<span class="token punctuation">,</span>T<span class="token punctuation">)</span>从左到右逐个取参数值。
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>格式转换的一般形式如下：
<span class="token operator">%</span><span class="token punctuation">[</span>flags<span class="token punctuation">]</span><span class="token punctuation">[</span>width<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span>prec<span class="token punctuation">]</span><span class="token punctuation">[</span>type<span class="token punctuation">]</span>
prec有一下几种情况：
                    正整数的最小位数
                    在浮点数中表示的小数位数
                    <span class="token operator">%</span>g格式表示有效为的最大值
                    <span class="token operator">%</span>s格式表示字符串的最大长度
                    若为<span class="token operator">*</span>符号表示下个参数值为最大长度
width：为输出的最小长度，如果这个输出参数并非数值，而是<span class="token operator">*</span>符号，则表示以下一个参数当做输出长度。
现在来看看我们的printf函数的实现，在内核中printf函数被封装成下面的代码：
<span class="token keyword">static</span> <span class="token keyword">char</span> sprint_buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    va_list args<span class="token punctuation">;</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token function">va_start</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> fmt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化参数指针</span>
    n <span class="token operator">=</span> <span class="token function">vsprintf</span><span class="token punctuation">(</span>sprint_buf<span class="token punctuation">,</span> fmt<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*函数放回已经处理的字符串长度*/</span>
    <span class="token function">va_end</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//与va_start 配对出现，处理ap指针</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>console_ops<span class="token punctuation">.</span>write<span class="token punctuation">)</span>
        console_ops<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>sprint_buf<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*调用控制台的结构中的write函数，将sprintf_buf中的内容输出n个字节到设备*/</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
vs_printf函数的实现代码是：
<span class="token keyword">int</span> <span class="token function">vsprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fmt<span class="token punctuation">,</span> va_list args<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> len<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> num<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> base<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span> str<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">;</span><span class="token comment">/*s所指向的内存单元不可改写，但是s可以改写*/</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>        <span class="token comment">/* flags to number() */</span>
    <span class="token keyword">int</span> field_width<span class="token punctuation">;</span>    <span class="token comment">/* width of output field */</span>
    <span class="token keyword">int</span> precision<span class="token punctuation">;</span>        <span class="token comment">/* min. # of digits for integers; max
                   number of chars for from string */</span>
    <span class="token keyword">int</span> qualifier<span class="token punctuation">;</span>        <span class="token comment">/* 'h', 'l', or 'L' for integer fields */</span>
                            <span class="token comment">/* 'z' support added 23/7/1999 S.H.    */</span>
                <span class="token comment">/* 'z' changed to 'Z' --davidm 1/25/99 */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>str<span class="token operator">=</span>buf <span class="token punctuation">;</span> <span class="token operator">*</span>fmt <span class="token punctuation">;</span> <span class="token operator">++</span>fmt<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>fmt <span class="token operator">!=</span> <span class="token string">'%'</span><span class="token punctuation">)</span> <span class="token comment">/*使指针指向格式控制符'%,以方便以后处理flags'*/</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token operator">*</span>str<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>fmt<span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">/* process flags */</span>
        flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        repeat<span class="token punctuation">:</span>
            <span class="token operator">++</span>fmt<span class="token punctuation">;</span>        <span class="token comment">/* this also skips first '%'--跳过格式控制符'%' */</span>
            <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token operator">*</span>fmt<span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">case</span> <span class="token string">'-'</span><span class="token punctuation">:</span> flags <span class="token operator">|</span><span class="token operator">=</span> LEFT<span class="token punctuation">;</span> <span class="token keyword">goto</span> repeat<span class="token punctuation">;</span><span class="token comment">/*左对齐-left justify*/</span>
                <span class="token keyword">case</span> <span class="token string">'+'</span><span class="token punctuation">:</span> flags <span class="token operator">|</span><span class="token operator">=</span> PLUS<span class="token punctuation">;</span> <span class="token keyword">goto</span> repeat<span class="token punctuation">;</span><span class="token comment">/*p plus with ’+‘*/</span>
                <span class="token keyword">case</span> <span class="token string">' '</span><span class="token punctuation">:</span> flags <span class="token operator">|</span><span class="token operator">=</span> SPACE<span class="token punctuation">;</span> <span class="token keyword">goto</span> repeat<span class="token punctuation">;</span><span class="token comment">/*p with space*/</span>
                <span class="token keyword">case</span> <span class="token string">'#'</span><span class="token punctuation">:</span> flags <span class="token operator">|</span><span class="token operator">=</span> SPECIAL<span class="token punctuation">;</span> <span class="token keyword">goto</span> repeat<span class="token punctuation">;</span><span class="token comment">/*根据其后的转义字符的不同而有不同含义*/</span>
                <span class="token keyword">case</span> <span class="token string">'0'</span><span class="token punctuation">:</span> flags <span class="token operator">|</span><span class="token operator">=</span> ZEROPAD<span class="token punctuation">;</span> <span class="token keyword">goto</span> repeat<span class="token punctuation">;</span><span class="token comment">/*当有指定参数时，无数字的参数将补上0*/</span>
            <span class="token punctuation">}</span>
<span class="token comment">//#define ZEROPAD    1        /* pad with zero */</span>
<span class="token comment">//#define SIGN    2        /* unsigned/signed long */</span>
<span class="token comment">//#define PLUS    4        /* show plus */</span>
<span class="token comment">//#define SPACE    8        /* space if plus */</span>
<span class="token comment">//#define LEFT    16        /* left justified */</span>
<span class="token comment">//#define SPECIAL    32        /* 0x */</span>
<span class="token comment">//#define LARGE    64        /* use 'ABCDEF' instead of 'abcdef' */</span>
        <span class="token comment">/* get field width ----deal 域宽 取当前参数字段宽度域值，放入field_width 变量中。如果宽度域中是数值则直接取其为宽度值。 如果宽度域中是字符'*'，表示下一个参数指定宽度。因此调用va_arg 取宽度值。若此时宽度值小于0，则该负数表示其带有标志域'-'标志（左靠齐），因此还需在标志变量中添入该标志，并将字段宽度值取为其绝对值。  */</span>
        field_width <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'0'</span> <span class="token operator">&lt;=</span> <span class="token operator">*</span>fmt <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>fmt <span class="token operator">&lt;=</span> <span class="token string">'9'</span><span class="token punctuation">)</span>
            field_width <span class="token operator">=</span> <span class="token function">skip_atoi</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fmt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>fmt <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token operator">++</span>fmt<span class="token punctuation">;</span><span class="token comment">/*skip '*' */</span>
            <span class="token comment">/* it's the next argument */</span>
            field_width <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>field_width <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                field_width <span class="token operator">=</span> <span class="token operator">-</span>field_width<span class="token punctuation">;</span>
                flags <span class="token operator">|</span><span class="token operator">=</span> LEFT<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">/* get the precision-----即是处理.pre 有效位 */</span>
        precision <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>fmt <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token operator">++</span>fmt<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'0'</span> <span class="token operator">&lt;=</span> <span class="token operator">*</span>fmt <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>fmt <span class="token operator">&lt;=</span> <span class="token string">'9'</span><span class="token punctuation">)</span>
                precision <span class="token operator">=</span> <span class="token function">skip_atoi</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fmt<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>fmt <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token comment">/*如果精度域中是字符'*'，表示下一个参数指定精度。因此调用va_arg 取精度值。若此时宽度值小于0，则将字段精度值取为0。*/</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token operator">++</span>fmt<span class="token punctuation">;</span>
                <span class="token comment">/* it's the next argument */</span>
                precision <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>precision <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                precision <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">/* get the conversion qualifier 分析长度修饰符，并将其存入qualifer 变量*/</span>
        qualifier <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>fmt <span class="token operator">==</span> <span class="token string">'l'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span><span class="token punctuation">(</span>fmt <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'l'</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            qualifier <span class="token operator">=</span> <span class="token string">'q'</span><span class="token punctuation">;</span>
            fmt <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>fmt <span class="token operator">==</span> <span class="token string">'h'</span> <span class="token operator">||</span> <span class="token operator">*</span>fmt <span class="token operator">==</span> <span class="token string">'l'</span> <span class="token operator">||</span> <span class="token operator">*</span>fmt <span class="token operator">==</span> <span class="token string">'L'</span><span class="token operator">||</span> <span class="token operator">*</span>fmt <span class="token operator">==</span> <span class="token string">'Z'</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            qualifier <span class="token operator">=</span> <span class="token operator">*</span>fmt<span class="token punctuation">;</span>
            <span class="token operator">++</span>fmt<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">/* default base */</span>
        base <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token comment">/*处理type部分*/</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token operator">*</span>fmt<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">case</span> <span class="token string">'c'</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> LEFT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">/*没有左对齐标志，那么填充field_width-1个空格*/</span>
                    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>field_width <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    <span class="token operator">*</span>str<span class="token operator">++</span> <span class="token operator">=</span> <span class="token string">' '</span><span class="token punctuation">;</span>
                    <span class="token operator">*</span>str<span class="token operator">++</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>field_width <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">/*不是左对齐*/</span>
                    <span class="token operator">*</span>str<span class="token operator">++</span> <span class="token operator">=</span> <span class="token string">' '</span><span class="token punctuation">;</span><span class="token comment">/*在参数后输出field_width-1个空格*/</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token comment">/*如果转换参数是s，则，表示对应的参数是字符串，首先取参数字符串的长度，如果超过了精度域值，则取精度域值为最大长度*/</span>
            <span class="token keyword">case</span> <span class="token string">'s'</span><span class="token punctuation">:</span>
                s <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">)</span>
                    s <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
                    len <span class="token operator">=</span> <span class="token function">strnlen</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> precision<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*字符串的长度，最大为precision*/</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> LEFT<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">while</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> field_width<span class="token operator">--</span><span class="token punctuation">)</span><span class="token comment">/*如果不是左对齐，则左侧补空格=field_width-len个空格*/</span>
                    <span class="token operator">*</span>str<span class="token operator">++</span> <span class="token operator">=</span> <span class="token string">' '</span><span class="token punctuation">;</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
                    <span class="token operator">*</span>str<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>s<span class="token operator">++</span><span class="token punctuation">;</span>
                    <span class="token keyword">while</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> field_width<span class="token operator">--</span><span class="token punctuation">)</span><span class="token comment">/*如果是左对齐，则右侧补空格数=field_width-len*/</span>
                    <span class="token operator">*</span>str<span class="token operator">++</span> <span class="token operator">=</span> <span class="token string">' '</span><span class="token punctuation">;</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span>
<span class="token comment">/*如果格式转换符是'p'，表示对应参数的一个指针类型。此时若该参数没有设置宽度域，则默认宽度为8，并且需要添零。然后调用number()*/</span>
            <span class="token keyword">case</span> <span class="token string">'p'</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>field_width <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
                <span class="token punctuation">{<!-- --></span>
                    field_width <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    flags <span class="token operator">|</span><span class="token operator">=</span> ZEROPAD<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                str <span class="token operator">=</span> <span class="token function">number</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span>
                        field_width<span class="token punctuation">,</span> precision<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token comment">// 若格式转换指示符是'n'，则表示要把到目前为止转换输出的字符数保存到对应参数指针指定的位置中。</span>
        <span class="token comment">// 首先利用va_arg()得该参数指针，然后将已经转换好的字符数存入该指针所指的位置</span>
            <span class="token keyword">case</span> <span class="token string">'n'</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>qualifier <span class="token operator">==</span> <span class="token string">'l'</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">long</span> <span class="token operator">*</span> ip <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">*</span>ip <span class="token operator">=</span> <span class="token punctuation">(</span>str <span class="token operator">-</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>qualifier <span class="token operator">==</span> <span class="token string">'Z'</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                size_t <span class="token operator">*</span> ip <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> size_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">*</span>ip <span class="token operator">=</span> <span class="token punctuation">(</span>str <span class="token operator">-</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">int</span> <span class="token operator">*</span> ip <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">*</span>ip <span class="token operator">=</span> <span class="token punctuation">(</span>str <span class="token operator">-</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token comment">//若格式转换符不是'%'，则表示格式字符串有错，直接将一个'%'写入输出串中。</span>
    <span class="token comment">// 如果格式转换符的位置处还有字符，则也直接将该字符写入输出串中，并返回到继续处理</span>
    <span class="token comment">//格式字符串。</span>
            <span class="token keyword">case</span> <span class="token string">'%'</span><span class="token punctuation">:</span>
            <span class="token operator">*</span>str<span class="token operator">++</span> <span class="token operator">=</span> <span class="token string">'%'</span><span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token comment">/* integer number formats - set up the flags and "break" */</span>
            <span class="token keyword">case</span> <span class="token string">'o'</span><span class="token punctuation">:</span>
            base <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'X'</span><span class="token punctuation">:</span>
            flags <span class="token operator">|</span><span class="token operator">=</span> LARGE<span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'x'</span><span class="token punctuation">:</span>
            base <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token comment">// 如果格式转换字符是'd','i'或'u'，则表示对应参数是整数，'d', 'i'代表符号整数，因此需要加上</span>
<span class="token comment">// 带符号标志。'u'代表无符号整数</span>
            <span class="token keyword">case</span> <span class="token string">'d'</span><span class="token punctuation">:</span>
            <span class="token keyword">case</span> <span class="token string">'i'</span><span class="token punctuation">:</span>
            flags <span class="token operator">|</span><span class="token operator">=</span> SIGN<span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">'u'</span><span class="token punctuation">:</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">default</span><span class="token punctuation">:</span>
            <span class="token operator">*</span>str<span class="token operator">++</span> <span class="token operator">=</span> <span class="token string">'%'</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>fmt<span class="token punctuation">)</span>
                <span class="token operator">*</span>str<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>fmt<span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                <span class="token operator">--</span>fmt<span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">/*处理字符的修饰符，同时如果flags有符号位的话，将参数转变成有符号的数*/</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>qualifier <span class="token operator">==</span> <span class="token string">'l'</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            num <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> SIGN<span class="token punctuation">)</span>
                num <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">signed</span> <span class="token keyword">long</span><span class="token punctuation">)</span> num<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>qualifier <span class="token operator">==</span> <span class="token string">'q'</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            num <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> SIGN<span class="token punctuation">)</span>
                num <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">signed</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> num<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>qualifier <span class="token operator">==</span> <span class="token string">'Z'</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            num <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> size_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>qualifier <span class="token operator">==</span> <span class="token string">'h'</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            num <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">)</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> SIGN<span class="token punctuation">)</span>
                num <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">signed</span> <span class="token keyword">short</span><span class="token punctuation">)</span> num<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{<!-- --></span>
            num <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> SIGN<span class="token punctuation">)</span>
                num <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">signed</span> <span class="token keyword">int</span><span class="token punctuation">)</span> num<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        str <span class="token operator">=</span> <span class="token function">number</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> num<span class="token punctuation">,</span> base<span class="token punctuation">,</span> field_width<span class="token punctuation">,</span> precision<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token string">'/0'</span><span class="token punctuation">;</span><span class="token comment">/*最后在转换好的字符串上加上NULL*/</span>
    <span class="token keyword">return</span> str<span class="token operator">-</span>buf<span class="token punctuation">;</span><span class="token comment">/*返回转换好的字符串的长度值*/</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>原文链接：<a href="https://blog.csdn.net/hackbuteer1/article/details/7558979#">https://blog.csdn.net/hackbuteer1/article/details/7558979#</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2a2353f4ffa5cb393e2db9bc6592251c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue中滚动插件vue-seamless-scroll的安装与使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d5d4d1758d4b47da42f7ad4869806936/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">go-zero微服务框架入门教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>