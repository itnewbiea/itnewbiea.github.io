<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SFTP协议 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SFTP协议" />
<meta property="og:description" content="SCP协议本身打开SSH通道时指定的是scp命令，而是用SFTP时指定的sftp。以下是一些具体的介绍，详细内容需要参考对应的RFC文件。
下面是目前整理的使用的一份：
1） 协议中数据包格式
通过安全通道传输的所有包的格式如下：
uint32 length
byte type
uint32 request-id
... 具体类型域 ...
length：整个包的长度，不包括长度域本身。因此，例如一个不包含具体类型域的包的长度域是5个字节，那么将有9个字节发送到路线上。实际上包的最大尺寸由客户端决定（它发送的读写请求包最大尺寸，外加一些字节的包开销）。所有服务器应当支持至少34000字节的包（这里的包尺寸是指全长，包括上述头部）。也就是允许读写最多32768个字节。
type：包的类型码。
request-id：从客户端来的每一个请求包含一个请求ID域，从服务端返回的每个响应也包含和服务器应答的请求一样的请求ID。一个可能的是实现是客户提供给我们一个单调递增的序号（模除2^32）。然而没有特殊的要求请求ID域是唯一的。
SFTP协议中只有两个包，INIT和VERSION，不需要使用请求ID。
2） 协议中各种包具体格式和响应
包的类型type如下：
SSH_FXP_INIT 1
SSH_FXP_VERSION 2
SSH_FXP_OPEN 3
SSH_FXP_CLOSE 4
SSH_FXP_READ 5
SSH_FXP_WRITE 6
SSH_FXP_LSTAT 7
SSH_FXP_FSTAT 8
SSH_FXP_SETSTAT 9
SSH_FXP_FSETSTAT 10
SSH_FXP_OPENDIR 11
SSH_FXP_READDIR 12
SSH_FXP_REMOVE 13
SSH_FXP_MKDIR 14
SSH_FXP_RMDIR 15
SSH_FXP_REALPATH 16
SSH_FXP_STAT 17
SSH_FXP_RENAME 18
SSH_FXP_READLINK 19
SSH_FXP_LINK 21
SSH_FXP_BLOCK 22
SSH_FXP_UNBLOCK 23
SSH_FXP_STATUS 101
SSH_FXP_HANDLE 102" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/23ef2fdbf3b50628c56a986600294b78/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-08-06T15:25:53+08:00" />
<meta property="article:modified_time" content="2011-08-06T15:25:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SFTP协议</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                      
<p>SCP协议本身打开SSH通道时指定的是scp命令，而是用SFTP时指定的sftp。以下是一些具体的介绍，详细内容需要参考对应的RFC文件。</p> 
<p>下面是目前整理的使用的一份：</p> 
<p align="left"><strong>1） 协议中数据包格式</strong></p> 
<p>通过安全通道传输的所有包的格式如下：</p> 
<p>     uint32           length</p> 
<p>     byte             type</p> 
<p>     uint32           request-id</p> 
<p>     ... 具体类型域 ...</p> 
<p>length：整个包的长度，不包括长度域本身。因此，例如一个不包含具体类型域的包的长度域是5个字节，那么将有9个字节发送到路线上。实际上包的最大尺寸由客户端决定（它发送的读写请求包最大尺寸，外加一些字节的包开销）。所有服务器应当支持至少34000字节的包（这里的包尺寸是指全长，包括上述头部）。也就是允许读写最多32768个字节。</p> 
<p> </p> 
<p>type：包的类型码。</p> 
<p> </p> 
<p>request-id：从客户端来的每一个请求包含一个请求ID域，从服务端返回的每个响应也包含和服务器应答的请求一样的请求ID。一个可能的是实现是客户提供给我们一个单调递增的序号（模除2^32）。然而没有特殊的要求请求ID域是唯一的。</p> 
<p>      </p> 
<p>SFTP协议中只有两个包，INIT和VERSION，不需要使用请求ID。</p> 
<p> </p> 
<p align="left"><strong>2） 协议中各种包具体格式和响应</strong></p> 
<p>包的类型type如下：</p> 
<p>SSH_FXP_INIT                1</p> 
<p>SSH_FXP_VERSION             2</p> 
<p>SSH_FXP_OPEN                3</p> 
<p>SSH_FXP_CLOSE               4</p> 
<p>SSH_FXP_READ                5</p> 
<p>SSH_FXP_WRITE               6</p> 
<p>SSH_FXP_LSTAT               7</p> 
<p>SSH_FXP_FSTAT               8</p> 
<p>SSH_FXP_SETSTAT             9</p> 
<p>SSH_FXP_FSETSTAT           10</p> 
<p>SSH_FXP_OPENDIR            11</p> 
<p>SSH_FXP_READDIR            12</p> 
<p>SSH_FXP_REMOVE             13</p> 
<p>SSH_FXP_MKDIR              14</p> 
<p>SSH_FXP_RMDIR              15</p> 
<p>SSH_FXP_REALPATH           16</p> 
<p>SSH_FXP_STAT               17</p> 
<p>SSH_FXP_RENAME             18</p> 
<p>SSH_FXP_READLINK           19</p> 
<p>SSH_FXP_LINK               21</p> 
<p>SSH_FXP_BLOCK              22</p> 
<p>SSH_FXP_UNBLOCK            23</p> 
<p> </p> 
<p>SSH_FXP_STATUS            101</p> 
<p>SSH_FXP_HANDLE            102</p> 
<p>SSH_FXP_DATA              103</p> 
<p>SSH_FXP_NAME              104</p> 
<p>SSH_FXP_ATTRS             105</p> 
<p> </p> 
<p>SSH_FXP_EXTENDED          200</p> 
<p>SSH_FXP_EXTENDED_REPLY    201</p> 
<p> </p> 
<p>客户端初始化包</p> 
<p>type    SSH_FXP_INIT</p> 
<p>uint32  version</p> 
<p> </p> 
<p>对这个消息的响应是下面的服务器初始化版本包SSH_FXP_VERSION。</p> 
<p> </p> 
<p>服务器初始化包</p> 
<p>type    SSH_FXP_VERSION</p> 
<p>uint32  version</p> 
<p> </p> 
<p>打开文件包</p> 
<p>byte     SSH_FXP_OPEN</p> 
<p>uint32   request-id</p> 
<p>string   filename [UTF-8]</p> 
<p>uint32   desired-access</p> 
<p>uint32   flags</p> 
<p>ATTRS  attrs</p> 
<p> </p> 
<p>对这个消息的响应将会是SSH_FXP_HANDLE(如果操作成功的话)或者SSH_FXP_STATUS（如果操作失败）</p> 
<p> </p> 
<p>关闭句柄</p> 
<p>byte     SSH_FXP_CLOSE</p> 
<p>uint32   request-id</p> 
<p>string   handle</p> 
<p> </p> 
<p>handle是以前SSH_FXP_OPEN或SSH_FXP_OPENDIR返回的句柄。句柄变为无效后立即请求已发送。</p> 
<p>对此请求的响应将是一个SSH_FXP_STATUS消息。请注意，在一些服务器平台上关闭操作可能会失败。例如，如果服务器操作系统缓存写入，在冲洗缓存写入时发生错误，关闭操作就可能失败。</p> 
<p>注意不论SSH_FXP_STATUS的结果，句柄是无效的。没有办法为客户恢复关闭失败的句柄。客户端必须释放与句柄关联的所有资源，无论状态。服务器应采取的任何步骤，它可以恢复从关闭失败，以确保服务器上的处理相关联的所有资源正确释放。</p> 
<p> </p> 
<p>读取文件</p> 
<p>byte     SSH_FXP_READ</p> 
<p>uint32   request-id</p> 
<p>string   handle</p> 
<p>uint64   offset</p> 
<p>uint32   length</p> 
<p> </p> 
<p>handle 是被SSH_FXP_OPEN返回打开的文件句柄。如果不是被SSH_FXP_OPEN返回的句柄，服务器必须返回SSH_FX_INVALID_HANDLE。</p> 
<p>   offset是偏移量（以字节为单位）相对于读取文件开始的地方。此字段被忽略，如果SSH_FXF_TEXT_MODE指定在打开的时候。</p> 
<p>   length 是读取的最大字节数。</p> 
<p>      服务器不能响应比的“length”参数指定的更多的数据。但是，服务器的响应可能较少的数据，如果达到EOF，遇到一个错误，或内部缓冲区的服务器无法处理这么大的要求。</p> 
<p>      如果服务器指定一个非零的max-read-size在它的supported2扩展中，并且length小于max-read-size，没有返回length个字节暗示EOF或者错误发生。</p> 
<p> </p> 
<p>写入文件</p> 
<p>byte     SSH_FXP_WRITE</p> 
<p>uint32   request-id</p> 
<p>string    handle</p> 
<p>uint64    offset</p> 
<p>string    data</p> 
<p> </p> 
<p>   handle是一个打开文件句柄被SSH_FXP_OPEN返回的。如果handle不是一个SSH_FXP_OPEN返回的句柄，服务器必须返回SSH_FX_INVALID_HANDLE。</p> 
<p>   offset是偏移量（以字节为单位），相对于文件的开头写必须开始。此字段被忽略，如果SSH_FXF_TEXT_MODE是在打开期间指定。如果超出文件末尾写的话，会扩展文件。它是合法的，写一个偏移量超出该文件的末尾扩展的语义是从文件末尾写字节值0x00指定的偏移，然后是数据。在大多数操作系统上，如写不分配磁盘空间，而是创建一个稀疏文件。</p> 
<p>   data是要写入文件的数据。</p> 
<p>   服务器响应一个写请求一个SSH_FXP_STATUS消息。</p> 
<p> </p> 
<p>获取文件属性</p> 
<p>很多时候，文件属性是SSH_FXP_READDIR自动返回的。然而，有些时候需要专门获得命名文件的属性。可以使用SSH_FXP_STAT，SSH_FXP_LSTAT和SSH_FXP_FSTAT请求。</p> 
<p>   SSH_FXP_STAT和SSH_FXP_LSTAT不同，仅仅在于SSH_FXP_STAT遵循在服务器上的符号链接，然而SSH_FXP_LSTAT不遵循符号链接。两者的有一样的格式：</p> 
<p>  byte     SSH_FXP_STAT or SSH_FXP_LSTAT</p> 
<p>  uint32   request-id</p> 
<p>  string   path [UTF-8]</p> 
<p>  uint32   flags</p> 
<p> </p> 
<p>   其中request-id是请求标识符，path指定状态被返回的文件系统对象。服务器用SSH_FXP_ATTRS或者SSH_FXP_STATUS返回请求。</p> 
<p>   flag字段指定客户端有特别兴趣的属性标志。这是到服务器的提示。例如，在某些操作系统上获取ower、group和acl信息是昂贵的操作，服务器可能不获取它们除非客户端表达出特别的兴趣。</p> 
<p>   客户端不能保证服务器提供所有它感兴趣的字段。</p> 
<p>   </p> 
<p>   SSH_FXP_FSTAT不同于其他在于它返回一个打开的文件（文件句柄标识）的状态信息。</p> 
<p>   byte      SSH_FXP_FSTAT</p> 
<p>   uint32    request-id</p> 
<p>   string    handle</p> 
<p>   uint32    flags</p> 
<p> </p> 
<p>      handle是一个SSH_FXP_OPEN或者SSH_FXP_OPENDIR打开的文件句柄。</p> 
<p>   服务器用SSH_FXP_ATTRS或者SSH_FXP_STATUS来响应这个请求。</p> 
<p> </p> 
<p>设置文件属性</p> 
<p>文件属性可以使用SSH_FXP_SETSTAT和SSH_FXP_FSETSTAT请求来修改。</p> 
<p>byte      SSH_FXP_SETSTAT</p> 
<p>uint32    request-id</p> 
<p>string    path [UTF-8]</p> 
<p>ATTRS     attrs</p> 
<p> </p> 
<p>byte      SSH_FXP_FSETSTAT</p> 
<p>uint32    request-id</p> 
<p>string    handle</p> 
<p>ATTRS     attrs</p> 
<p> </p> 
<p>path是属性被修改的文件系统对象（例如，文件或者目录）。如果对象不存在，或者用户没有足够的访问权限去改写属性，请求会失败。</p> 
<p>handle是SSH_FXP_OPEN或者SSH_FXP_OPENDIR打开的文件句柄。如果句柄没有被足够的访问权限打开去改写请求的熟悉，请求会失败。</p> 
<p>attrs指定被应用的修改属性。更多细节参看File Attributes节。</p> 
<p>服务器用SSH_FXP_STATUS消息响应。</p> 
<p>因为某些系统可能使用分离的系统调用来设置各种属性，可能某些属性已经被修改了，仍然返回一个失败的响应。如果可能，服务器应该避免这种情况；然而，客户端必须清楚这种可能性。</p> 
<p> </p> 
<p>打开目录</p> 
<p>byte     SSH_FXP_OPENDIR</p> 
<p>uint32   request-id</p> 
<p>string   path [UTF-8]</p> 
<p> </p> 
<p>path字段是列举的（没有任何尾随的斜线）的目录的路径名。更多信息参看“File Names”。</p> 
<p>如果“路径”并不是指到一个目录，服务器必须返回SSH_FX_NOT_A_DIRECTORY。</p> 
<p>此消息的响应，将要么SSH_FXP_HANDLE（如果操作成功）或SSH_FXP_STATUS（如果操作失败）。</p> 
<p> </p> 
<p>读取目录</p> 
<p>byte     SSH_FXP_READDIR</p> 
<p>uint32   request-id</p> 
<p>string   handle</p> 
<p> </p> 
<p>handle是由SSH_FXP_OPENDIR返回的句柄。如果handle是一个SSH_FXP_OPEN返回普通的文件句柄，服务器必须返回SSH_FX_INVALID_HANDLE。</p> 
<p>服务器用一个SSH_FXP_NAME或SSH_FXP_STATUS消息响应这个请求。在一段时间，可能会返回一个或多个名称。完整的状态信息返回每个名称，以加速典型的目录清单。</p> 
<p>如果没有更多的名字可以读取，服务器必须响应一个SSH_FXP_STATUS消息，错误代码的SSH_FX_EOF</p> 
<p> </p> 
<p>删除文件</p> 
<p>byte      SSH_FXP_REMOVE</p> 
<p>uint32    request-id</p> 
<p>string    filename [UTF-8]</p> 
<p>filename是要删除的文件名称。更多信息参考“File Names”。</p> 
<p>如果filename是一个符号链接，链接被删除，指向的文件不会被删除。</p> 
<p>这个请求不能被用于移除目录，在这种情况下，服务器必须返回SSH_FX_FILE_IS_A_DIRECTORY。</p> 
<p>服务器将会用SSH_FXP_STATUS消息响应这个请求。</p> 
<p> </p> 
<p>重命名文件</p> 
<p>byte       SSH_FXP_RENAME</p> 
<p>uint32     request-id</p> 
<p>string     oldpath [UTF-8]</p> 
<p>string     newpath [UTF-8]</p> 
<p>uint32     flags</p> 
<p> </p> 
<p>  其中“request-id”是请求标识符，“oldpath“是现有的文件或目录的名称，”newpath“是为新的文件或目录名称。</p> 
<p>   'flags' 是 0 或者以下值的组合：</p> 
<p>   SSH_FXF_RENAME_OVERWRITE  0x00000001</p> 
<p>   SSH_FXF_RENAME_ATOMIC     0x00000002</p> 
<p>   SSH_FXF_RENAME_NATIVE     0x00000004</p> 
<p>   如果服务器不支持请求的操作模式，它必须返回SSH_FX_OP_UNSUPPORTED。</p> 
<p>   如果flags不包括SSH_FXP_RENAME_OVERWRITE，newpath指定的名称已经存在一个文件，服务器必须响应SSH_FX_FILE_ALREADY_EXISTS。</p> 
<p>   如果flags包括SSH_FXP_RENAME_ATOMIC，目标文件已存在，它是在一个原子的方式取代。例如，有没有在时间上观察到的瞬间，其中的名称并不是指无论是旧的或新的文件。 SSH_FXP_RENAME_ATOMIC意味着SSH_FXP_RENAME_OVERWRITE。</p> 
<p>   服务器将用SSH_FXP_STATUS消息来回应这个请求。</p> 
<p> </p> 
<p>创建目录</p> 
<p>byte      SSH_FXP_MKDIR</p> 
<p>uint32    request-id</p> 
<p>string    path [UTF-8]</p> 
<p>ATTRS  attrs</p> 
<p>其中request-id是请求标识符，path指定被创建的目录，attrs指定了应该被应用到创建上的属性。</p> 
<p>服务器将用SSH_FXP_STATUS消息来响应这个请求。如果指定的文件或者目录已经存在了，错误将被返回。</p> 
<p> </p> 
<p>移除目录</p> 
<p>byte     SSH_FXP_RMDIR</p> 
<p>uint32   request-id</p> 
<p>string   path [UTF-8]</p> 
<p> </p> 
<p>其中request-id是请求标识符，path指定被移除的目录。</p> 
<p>服务器用SSH_FXP_STATUS消息响应请求。</p> 
<p> </p> 
<p>状态响应</p> 
<p>SSH_FXP_STATUS响应数据部分的格式如下：</p> 
<p>byte     SSH_FXP_STATUS</p> 
<p>uint32   request-id</p> 
<p>uint32   error/status code</p> 
<p>string   error message (ISO-10646 UTF-8 [RFC-2279])</p> 
<p>string   language tag (as defined in [RFC-1766])</p> 
<p>error-specific data</p> 
<p> </p> 
<p>request-id指示服务端响应的客户端请求。</p> 
<p>error/status code是机器可读的状态代码指示请求的结果。值SSH_FX_OK指示成功，其他值指示失败。实现必须准备能收到意想不到的错误代码，他们理智地处理（如他们视为等同于SSH_FX_FAILURE）。</p> 
<p>error message是人类可读的错误描述。</p> 
<p>language tag指示错误使用的语言。</p> 
<p>error-specific data可能是空的，可能包含附加的错误信息。</p> 
<p> </p> 
<p>句柄响应</p> 
<p>SSH_FXP_HANDLE响应的格式如下：</p> 
<p>byte      SSH_FXP_HANDLE</p> 
<p>uint32    request-id</p> 
<p>string    handle</p> 
<p> </p> 
<p>handle是一个任意的字符串，用于标识一个打开的文件或服务器上的目录。句柄对客户端是不透明的，不要试图以任何方式解释或修改它。句柄字符串的长度不能超过256个字节的数据。</p> 
<p> </p> 
<p>数据响应</p> 
<p>SSH_FXP_DATA响应的格式如下：</p> 
<p>byte     SSH_FXP_DATA</p> 
<p>uint32   request-id</p> 
<p>string   data</p> 
<p>bool     end-of-file [optional]</p> 
<p>       </p> 
<p>data是一个任意字节的字符串，其中包含请求的数据。数据字符串最多可能被要求在SSH_FXP_READ请求的字节数，但也可能较短。</p> 
<p>end-of-file此字段是可选的，如果是存在和为真的，它表明，EOF的是读期间到达的。这可以帮助客户避免了往返，以确定短读是否正常（由于EOF）或一些其他问题（例如有限的服务器的缓冲区。）</p> 
<p>名称响应</p> 
<p>SSH_FXP_NAME响应的格式如下：</p> 
<p>byte     SSH_FXP_NAME</p> 
<p>uint32   request-id</p> 
<p>uint32   count</p> 
<p>repeats  count times:</p> 
<p>    string       filename [UTF-8]</p> 
<p>    ATTRS        attrs</p> 
<p>bool     end-of-list [optional]</p> 
<p> </p> 
<p>count在这个响应中返回的名称的数目，filename和attrs重复count次。</p> 
<p>filename是被返回的文件名。</p> 
<p>attrs是该文件的属性。</p> 
<p>end-of-list如果这个字段是存在的和为真，没有更多的读取条目了。除非请求是SSH_FXP_READDIR，否则字段应该被省略或为真。</p> 
<p> </p> 
<p>属性响应</p> 
<p>SSH_FXP_ATTRS响应的格式如下：</p> 
<p>byte      SSH_FXP_ATTRS</p> 
<p>uint32    request-id</p> 
<p>ATTRS     attrs</p> 
<p> </p> 
<p>attrs返回的文件属性。</p> 
<p> </p> 
<p align="left"><strong>1） 协议工作流程</strong></p> 
<p align="left">客户端向服务器端上发送文件</p> 
<p align="left"> <img alt="" src="https://images2.imgbox.com/06/cd/oh2KO9K7_o.gif"></p> 
<p align="left">客户端从服务器端上获取文件</p> 
<p align="left"> </p> 
<p> <img alt="" src="https://images2.imgbox.com/79/a7/lldILMNI_o.gif"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/87819d65afcc7c1349762242a5beca3e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【正式发布】火星人敏捷开发手册2012-12-25（基于Scrum的敏捷开发免费培训教材及公司内部宣传材料）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c5a6a90b2c1c1b3232f43a5fd66070db/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">敏捷开发生态系统系列之三：计划跟踪II（需求优先级排序-迭代期内无变更-团队承诺）...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>