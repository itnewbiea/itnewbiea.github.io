<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[BAT]常用的bat命令和用法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[BAT]常用的bat命令和用法" />
<meta property="og:description" content="Part One:
echo、@、call、pause、rem 是批处理文件最常用的几个命令，我们就从他们开始学起。 echo表示显示此命令后的字符 echo off表示在此语句后所有运行的命令都不显示命令行本身 @与echo off相象，但它是加在其它命令行的最前面，表示运行时不显示命令行本身。 call调用另一条批处理文件（如果直接调用别的批处理文件 ，执行完那条文件后将无法执行当前文件后续命令） pause运行此句会暂停，显示Press any key to continue... 等待用户按任意键后继续 rem表示此命令后的字符为解释行(注释)，不执行，只是给自己今后查找用的（::符号具有同样效果）
例：将根目录中所有文件写入a.txt中，启动UCDOS，进入WPS等功能。 批处理文件的内容为: 文件表示： echo off 不显示命令行 dir c:\*.* &gt;a.txt 将c盘文件列表写入a.txt call c:\ucdos\ucdos.bat 调用ucdos echo 你好 显示&#34;你好&#34; pause 暂停,等待按键继续 rem 使用wps 注释将使用wps cd ucdos 进入ucdos目录 wps 使用wps 批处理文件中还可以像C语言一样使用参数，这只需用到一个参数表示符%。%表示参数，参数是指在运行批处理文件时在文件名后加的字符串。变量可以从%0到%9，%0表示文件名本身，字符串用%1到%9顺序表示。 例如，c: 根目录下一批处理文件名为f.bat，内容为 format %1 则如果执行c:\&gt;f a: 则实际执行的是format a: 又如c: 根目录下一批处理文件的名为t.bat，内容为 type %1 type %2 那么运行c:\&gt;t a.txt b.txt 将顺序地显示a.txt和b.txt文件的内容 if goto choice for 是批处理文件中比较高级的命令，如果这几个你用得很熟练，你就是批处理文件的专家啦。 if 表示将判断是否符合规定的条件，从而决定执行不同的命令。 有三种格式:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/06ab137c1c0b300b439847dc402fbc9a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-05T17:43:35+08:00" />
<meta property="article:modified_time" content="2019-07-05T17:43:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[BAT]常用的bat命令和用法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p><span style="color:#33cccc;">Part One:</span></p> 
 <p><span style="color:#ffcc00;">　　</span><span style="line-height:1.5;"><span style="color:#ffcc00;">echo、@、call、pause、rem</span> 是批处理文件最常用的几个命令，我们就从他们开始学起。 </span></p> 
 <p><span style="line-height:1.5;">　　</span>echo表示显示此命令后的字符 <br>　　echo off表示在此语句后所有运行的命令都不显示命令行本身 <br>　　@与echo off相象，但它是加在其它命令行的最前面，表示运行时不显示命令行本身。 <br>　　call调用另一条批处理文件（如果直接调用别的批处理文件 ，执行完那条文件后将无法执行当前文件后续命令） <br>　　pause运行此句会暂停，显示Press any key to continue... 等待用户按任意键后继续 <br>　　rem表示此命令后的字符为解释行(注释)，不执行，只是给自己今后查找用的（::符号具有同样效果）<br>　　例：将根目录中所有文件写入a.txt中，启动UCDOS，进入WPS等功能。 <br>批处理文件的内容为: 文件表示： <br>echo off                               不显示命令行 <br>dir c:\*.* &gt;a.txt                    将c盘文件列表写入a.txt <br>call c:\ucdos\ucdos.bat         调用ucdos <br>echo 你好                           显示"你好" <br>pause                                   暂停,等待按键继续 <br>rem 使用wps                      注释将使用wps <br>cd ucdos                             进入ucdos目录 <br>wps                                     使用wps <br><br>　　批处理文件中还可以像C语言一样使用参数，这只需用到一个参数表示符<span style="color:#ffcc00;">%</span>。%表示参数，参数是指在运行批处理文件时在文件名后加的字符串。变量可以从%0到%9，%0表示文件名本身，字符串用%1到%9顺序表示。 <br>　　例如，c: 根目录下一批处理文件名为f.bat，内容为 format %1 <br>则如果执行c:\&gt;f a: 则实际执行的是format a: <br>又如c: 根目录下一批处理文件的名为t.bat，内容为 type %1 type %2 <br>那么运行c:\&gt;t a.txt b.txt 将顺序地显示a.txt和b.txt文件的内容 <br><br>　　<span style="color:#ffcc00;">if goto choice for</span> 是批处理文件中比较高级的命令，如果这几个你用得很熟练，你就是批处理文件的专家啦。 <br><br>　　if 表示将判断是否符合规定的条件，从而决定执行不同的命令。 有三种格式:<br>1、if [not] "参数" == "字符串" 待执行的命令 <br>参数如果等于指定的字符串，则条件成立，运行命令，否则运行下一句。(注意是两个等号） <br>如if "%1"=="a" format a: <br>2、if exist 文件名 待执行的命令 <br>如果有指定的文件，则条件成立，运行命令，否则运行下一句。<br>如if exist config.sys edit config.sys <br>3、if errorlevel 数字 待执行的命令 <br>如果返回码等于指定的数字，则条件成立，运行命令，否则运行下一句。<br>如if errorlevel 2 goto x2 <br>DOS程序运行时都会返回一个数字给DOS，称为错误码errorlevel或称返回码 <br><br>　　goto 批处理文件运行到这里将跳到goto 所指定的标号处， 一般与if配合使用。 <br>如: <br>goto end <br>:end <br>echo this is the end <br>标号用 :字符串 表示，标号所在行不被执行 <br><br>　　choice 使用此命令可以让用户输入一个字符，从而运行不同的命令。使用时应该加 /c:参数 <br>c:后应写提示可输入的字符，之间无空格，它的返回码为1234…… <br>如: choice /c:dme /m:"defrag,mem,end" <br>将显示 <br>defrag,mem,end[D,M,E]? <br>例如，test.bat的内容如下: <br>@echo off <br>choice /c:dme /m:"defrag,mem,end" <br>if errorlevel 3 goto end                                &lt;==应先判断数值最高的错误码 <br>if errorlevel 2 goto mem <br>if errotlevel 1 goto defrag <br>:defrag <br>c:\dos\defrag <br>goto end <br>:mem <br>mem <br>goto end <br>:end <br>echo good bye <br>此文件运行后，将显示 defrag,mem,end[D,M,E]? 用户可选择d m e ，然后if语句将作出判断，d表示执行标号为defrag的程序段，m表示执行标号为mem的程序段，e表示执行标号为end的程序段，每个程序段最后都以goto end将程序跳到end标号处，然后程序将显示good bye，文件结束。 <br><br>　　<span style="color:#ffcc00;">for</span> 循环命令，只要条件符合，它将多次执行同一命令。 <br>格式FOR [%%f] in (集合) DO [命令] <br>只要参数f在指定的集合内，则条件成立，执行命令 <br>如果一条批处理文件中有一行: <br>for %%c in (*.bat *.txt) do type %%c <br>含义是如果是以bat或txt结尾的文件，则显示文件的内容。 <br><br>　　<span style="color:#ffcc00;">autoexec.bat</span><br>DOS在启动会自动运行autoexec.bat这条文件，一般我们在里面装载每次必用的程序，如: path(设置路径)、smartdrv(磁盘加速)、 mouse(鼠标启动)、mscdex(光驱连接)、 doskey(键盘管理)、set(设置环境变量)等。 <br>如果启动盘根目录中没有这个文件，电脑会让用户输入日期和时间。 <br>例如，一个典型的autoexec.bat内容如下: <br>@echo off                                                           不显示命令行 <br>prompt $p$g                                                       设置提示符前有目录提示 <br>path c:\dos;c:\;c:\windows;c:\ucdos;c:\tools           设置路径 <br>lh c:\dos\doskey.com                                           加载键盘管理 <br>lh c:\mouse\mouse.com                                        加载鼠标管理 <br>lh c:\dos\smartdrv.exe                                          加载磁盘加速管理 <br>lh c:\dos\mscdex /S /D:MSCD000 /M:12 /V        加载CD-ROM驱动 <br>set temp=c:\temp                                                 设置临时目录 <br><br><span style="color:#33cccc;">Part Two: </span><br><br><span style="color:#ffcc00;">if 命令详解</span></p> 
 <p>详细出处参考：<a href="http://www.jb51.net/article/14986.htm" rel="nofollow"><span style="text-decoration:underline;"><span style="color:#800080;">http://www.jb51.net/article/14986.htm</span></span></a></p> 
 <p>主要用来判断：<br>1、两个“字符串”是否相等；<br>2、两个数值是大于、小于、等于,然后执行相应的命令。 <br>当然还有特殊用法，如结合errorlevel：if errorlevel 1 echo error <br>或者结合defined（定义的意思）:if defined test (echo It is defined) else echo It isn't defined <br>用法示例： <br><br>1、检测字符串(注意，用if检测字符串是否相等的时候，后面用的不是“=”，而是“==”)：</p> 
 <p>@echo off <br>set "str=this is a test" <br>REM 检测变量%str%是否等于test，如果相等，显示OK，否则显示NO <br>if "%str%"=="test" (echo OK) else echo NO <br>pause&gt;nul</p> 
 <p>2、检测数值：（注意，批处理中大于符号不能用：“&gt;”,而用"gtr"，其它的也类似） <br>比较运算符一览： <br>equ - 等于 <br>neq - 不等于 <br>lss - 小于 <br>leq - 小于或等于 <br>gtr - 大于 <br>geq - 大于或等于 <br><br>@echo off <br>set /a num1=20 <br>set /a num2=15 <br>if %num1% gtr %num2% echo %num1%大于%num2% <br>if %num1% EQU %num2% echo %num1%等于%num2% <br>if %num1% LSS %num2% echo %num1%小于%num2% <br>pause&gt;nul</p> 
 <p>3、if结合errorlevel使用： <br>说明：环境变量errorlevel的初始值为0，当一些命令执行不成功，就会返回一个数值，如：1 ，2 等 <br>IF-ERRORLEVEL <br>测试代码：</p> 
 <p>@ECHO OFF <br>XCOPY F:\test.bat D:\ <br>IF ERRORLEVEL 1 ECHO 文件拷贝失败 <br>IF ERRORLEVEL 0 ECHO 成功拷贝文件</p> 
 <p>如果文件拷贝成功，屏幕就会显示“成功拷贝文件”，否则就会显示“文件拷贝失败”。 <br>IF ERRORLEVEL 是用来测试它的上一个DOS命令的返回值的，注意只是<span style="text-decoration:underline;">上一个命令</span>的返回值，而且返回值必须依照<span style="text-decoration:underline;">从大到小</span>次序顺序判断。 <br>因此下面的批处理文件是错误的： <br>@ECHO OFF <br>XCOPY C:\AUTOEXEC.BAT D:\ <br>IF ERRORLEVEL 0 ECHO 成功拷贝文件 <br>IF ERRORLEVEL 1 ECHO 未找到拷贝文件 <br>IF ERRORLEVEL 2 ECHO 用户通过ctrl-c中止拷贝操作 <br>IF ERRORLEVEL 3 ECHO 预置错误阻止文件拷贝操作 <br>IF ERRORLEVEL 4 ECHO 拷贝过程中写盘错误 <br>无论拷贝是否成功，后面的： <br>未找到拷贝文件 <br>用户通过ctrl-c中止拷贝操作 <br>预置错误阻止文件拷贝操作 <br>拷贝过程中写盘错误 <br>都将显示出来。</p> 
 <p><span style="line-height:1.5;">以下就是几个常用命令的返回值及其代表的意义： </span><br>backup <br>0 备份成功 <br>1 未找到备份文件 <br>2 文件共享冲突阻止备份完成 <br>3 用户用ctrl-c中止备份 <br>4 由于致命的错误使备份操作中止 <br>diskcomp <br>0 盘比较相同 <br>1 盘比较不同 <br>2 用户通过ctrl-c中止比较操作 <br>3 由于致命的错误使比较操作中止 <br>4 预置错误中止比较 <br>diskcopy <br>0 盘拷贝操作成功 <br>1 非致命盘读/写错 <br>2 用户通过ctrl-c结束拷贝操作 <br>3 因致命的处理错误使盘拷贝中止 <br>4 预置错误阻止拷贝操作 <br>format <br>0 格式化成功 <br>3 用户通过ctrl-c中止格式化处理 <br>4 因致命的处理错误使格式化中止 <br>5 在提示“proceed with format（y/n）?”下用户键入n结束 <br>xcopy <br>0 成功拷贝文件 <br>1 未找到拷贝文件 <br>2 用户通过ctrl-c中止拷贝操作 <br>4 预置错误阻止文件拷贝操作 <br>5 拷贝过程中写盘错误</p> 
 <p>4、if还有一个特殊的用法就是可以用来检测某个变量是否已经被定义 <br>用法示例：</p> 
 <p>@echo off <br>set "str1=ok" <br>set "str2=no" <br>if defined str1 echo str1已经被定义 <br>if defined str2 echo str2已经被定义 <br>if defined str3 (echo str3已经被定义) else echo str3 没有被定义 <br>pause&gt;nul</p> 
 <p><span style="color:#33cccc;">Part Three:</span></p> 
 <p><span style="color:#ffcc00;">for帮助：</span> <br><br>FOR %variable IN (set) DO command [command-parameters] <br><br>%variable 指定一个单一字母可替换的参数。 <br>(set) 指定一个或一组文件。可以使用通配符。 <br>command 指定对每个文件执行的命令。 <br>command-parameters 为特定命令指定参数或命令行开关。 <br><br>在批处理程序中使用 FOR 命令时，指定变量请使用 %%variable而不要用 %variable。变量名称是区分大小写的，所以 %i 不同于 %I. <br><br>如果启用命令扩展，则会支持下列 FOR 命令的其他格式: <br>FOR /D %variable IN (set) DO command [command-parameters]。 <br><br>如果集中包含通配符，则指定与目录名匹配，而不与文件名匹配 <br>FOR /R [[drive:]path] %variable IN (set) DO command [command-parameters] <br>检查以 [drive:]path 为根的目录树，指向每个目录中的 FOR 语句。如果在 /R 后没有指定目录规范，则使用当前目录。如果集仅为一个单点(.)字符，则枚举该目录树。 <br><br>FOR /L %variable IN (start,step,end) DO command [command-parameters] <br>该集表示以增量形式从开始到结束的一个数字序列。因此，(1,1,5)将产生序列 1 2 3 4 5，(5,-1,1)将产生序列(5 4 3 2 1) <br><br>FOR /F ["options"] %variable IN (file-set) DO command [command-parameters] <br>FOR /F ["options"] %variable IN ("string") DO command [command-parameters] <br>FOR /F ["options"] %variable IN ('command') DO command [command-parameters] <br>或者，如果有 usebackq 选项: <br>FOR /F ["options"] %variable IN (file-set) DO command [command-parameters] <br>FOR /F ["options"] %variable IN ("string") DO command [command-parameters] <br>FOR /F ["options"] %variable IN ('command') DO command [command-parameters] <br>fileset 为一个或多个文件名。继续到 fileset 中的下一个文件之前，每份文件都被打开、读取并经过处理。处理包括读取文件，将其分成一行行的文字，然后将每行解析成零或更多的符号。然后用已找到的符号字符串变量值调用 For 循环。以默认方式，/F 通过每个文件的每一行中分开的第一个空白符号。跳过空白行。您可通过指定可选 "options" 参数替代默认解析操作。这个带引号的字符串包括一个 <br>或多个指定不同解析选项的关键字。这些关键字为: <br><br>eol=c - 指一个行注释字符的结尾(就一个) <br>skip=n - 指在文件开始时忽略的行数。 <br>delims=xxx - 指分隔符集。这个替换了空格和跳格键的 <br>默认分隔符集。 <br>tokens=x,y,m-n - 指每行的哪一个符号被传递到每个迭代 <br>的 for 本身。这会导致额外变量名称的分配。m-n <br>格式为一个范围。通过 nth 符号指定 mth。如果 <br>符号字符串中的最后一个字符星号， <br>那么额外的变量将在最后一个符号解析之后 <br>分配并接受行的保留文本。 <br>usebackq - 指定新语法已在下类情况中使用: <br>在作为命令执行一个后引号的字符串并且一个单 <br>引号字符为文字字符串命令并允许在 file-set <br>中使用双引号扩起文件名称。 <br><br>某些范例可能有助: <br><br>FOR /F "eol=; tokens=2,3* delims=, " %i in (myfile.txt) do @echo %i %j %k <br>会分析 myfile.txt 中的每一行，忽略以分号打头的那些行，将每行中的第二个和第三个符号传递给 for 函数体，用逗号和/或空格分隔符号。请注意，此 for 函数体的语句引用 %i 来获得第二个符号，引用 %j 来获得第三个符号，引用 %k来获得第三个符号后的所有剩余符号。对于带有空格的文件名，您需要用双引号将文件名括起来。为了用这种方式来使用双引号，还需要使用 usebackq 选项，否则，双引号会被理解成是用作定义某个要分析的字符串的。%i 在 for 语句中显式声明，%j 和 %k 是通过tokens= 选项隐式声明的。可以通过 tokens= 一行指定最多 26 个符号，只要不试图声明一个高于字母 "z" 或"Z" 的变量。请记住，FOR 变量是单一字母、分大小写和全局的变量；而且，不能同时使用超过 52 个。 <br><br>还可以在相邻字符串上使用 FOR /F 分析逻辑，方法是，用单引号将括号之间的 file-set 括起来。这样，该字符串会被当作一个文件中的一个单一输入行进行解析。 <br><br>最后，可以用 FOR /F 命令来分析命令的输出。方法是，将括号之间的 file-set 变成一个反括字符串。该字符串会被当作命令行，传递到一个子 CMD.EXE，其输出会被捕获到内存中，并被当作文件分析。如以下例子所示: <br>FOR /F "usebackq delims==" %i IN (`set`) DO @echo %i <br>会枚举当前环境中的环境变量名称。 <br><br>另外，FOR 变量参照的替换已被增强。您现在可以使用下列 <br>选项语法: <br><br>%~I - 删除任何引号(")，扩展 %I <br>%~fI - 将 %I 扩展到一个完全合格的路径名 <br>%~dI - 仅将 %I 扩展到一个驱动器号 <br>%~pI - 仅将 %I 扩展到一个路径 <br>%~nI - 仅将 %I 扩展到一个文件名 <br>%~xI - 仅将 %I 扩展到一个文件扩展名 <br>%~sI - 扩展的路径只含有短名 <br>%~aI - 将 %I 扩展到文件的文件属性 <br>%~tI - 将 %I 扩展到文件的日期/时间 <br>%~zI - 将 %I 扩展到文件的大小 <br>%~$PATH:I - 查找列在路径环境变量的目录，并将 %I 扩展 <br>到找到的第一个完全合格的名称。如果环境变量名 <br>未被定义，或者没有找到文件，此组合键会扩展到 <br>空字符串 <br><br>可以组合修饰符来得到多重结果: <br><br>%~dpI - 仅将 %I 扩展到一个驱动器号和路径 <br>%~nxI - 仅将 %I 扩展到一个文件名和扩展名 <br>%~fsI - 仅将 %I 扩展到一个带有短名的完整路径名 <br>%~dp$PATH:I - 搜索列在路径环境变量的目录，并将 %I 扩展 <br>到找到的第一个驱动器号和路径。 <br>%~ftzaI - 将 %I 扩展到类似输出线路的 DIR <br><br>在以上例子中，%I 和 PATH 可用其他有效数值代替。%~ 语法用一个有效的 FOR 变量名终止。选取类似 %I 的大写变量名比较易读，而且避免与不分大小写的组合键混淆。</p> 
 <p><span style="color:#33cccc;line-height:1.5;">Part Four:</span></p> 
 <p><span style="color:#ffcc00;">显示、设置或删除 cmd.exe 环境变量。</span> <br>set帮助内容如下：</p> 
 <p>SET [variable=[string]] <br><br>variable 指定环境变量名。 <br>string 指定要指派给变量的一系列字符串。 <br><span style="line-height:1.5;">要显示当前环境变量，键入不带参数的 SET。 </span><br><br>如果命令扩展被启用，SET 会如下改变: <br><br>可仅用一个变量激活 SET 命令，等号或值不显示所有前缀匹配 SET 命令已使用的名称的所有变量的值。例如: <br><span style="line-height:1.5;">SET P </span><br><span style="line-height:1.5;">会显示所有以字母 P 打头的变量 </span><br><span style="line-height:1.5;">如果在当前环境中找不到该变量名称，SET 命令将把 ERRORLEVEL </span>设置成 1。 <br><br>SET 命令不允许变量名含有等号。 <br><br>在 SET 命令中添加了两个新命令行开关: <br><span style="line-height:1.5;">SET /A expression </span><br>SET /P variable=[promptString] <br><span style="line-height:1.5;">/A 命令行开关指定等号右边的字符串为被评估的数字表达式。该表达式</span>评估器很简单并以递减的优先权顺序支持下列操作: <br><span style="line-height:1.5;">() ：分组 </span><br>! ~ - ：一元运算符 <br>* / % ：算数运算符 <br>+ - ：算数运算符 <br>&lt;&lt; &gt;&gt; ：逻辑移位 <br>&amp; ：按位“与” <br>^ ：按位“异” <br>| ：按位“或” <br>= *= /= %= += -= &amp;= ^= |= &lt;&lt;= &gt;&gt;=：赋值 <br>, ：表达式分隔符 <br><br>如果您使用任何逻辑或取余操作符， 您需要将表达式字符串用引号扩起来。在表达式中的任何非数字字符串键作为环境变量名称，这些环境变量名称的值已在使用前转换成数字。如果指定 <br>了一个环境变量名称，但未在当前环境中定义，那么值将被定为零。这使您可以使用环境变量值做计算而不用键入那些 % 符号来得到它们的值。如果 SET /A 在命令脚本外的命令行执行的， <br>那么它显示该表达式的最后值。该分配的操作符在分配的操作符左边需要一个环境变量名称。除十六进制有 0x 前缀，八进制有 0 前缀的，数字值为十进位数字。因此，0x12 与 18 和 022 相同。请注意八进制公式可能很容易搞混: 08 和 09 是无效的数字，因为 8 和 9 不是有效的八进制位数。(&amp; ) <br><br>/P 命令行开关允许将变量数值设成用户输入的一行输入。读取输入行之前，显示指定的 promptString。promptString 可以是空的。 <br><br>环境变量替换已如下增强: </p> 
 <p><span style="line-height:1.5;">%PATH:str1=str2% </span><br><span style="line-height:1.5;">会扩展 PATH 环境变量，用 "str2" 代替扩展结果中的每个 "str1"。</span>要有效地从扩展结果中删除所有的 "str1"，"str2" 可以是空的。"str1" 可以以星号打头；在这种情况下，"str1" 会从扩展结果的开始到 str1 剩余部分第一次出现的地方，都一直保持相配。 <br><br>也可以为扩展名指定子字符串。 <br><br>%PATH:~10,5% <br><span style="line-height:1.5;">会扩展 PATH 环境变量，然后只使用在扩展结果中从第 11 个(偏 </span><br>移量 10)字符开始的五个字符。如果没有指定长度，则采用默认 <br>值，即变量数值的余数。如果两个数字(偏移量和长度)都是负数， <br>使用的数字则是环境变量数值长度加上指定的偏移量或长度。 <br><br>%PATH:~-10% <br><span style="line-height:1.5;">会提取 PATH 变量的最后十个字符。 </span><br><br>%PATH:~0,-2% <br><span style="line-height:1.5;">会提取 PATH 变量的所有字符，除了最后两个。 </span><br><br>终于添加了延迟环境变量扩充的支持。该支持总是按默认值被停用，但也可以通过 CMD.EXE 的 /V 命令行开关而被启用/停用。请参阅 CMD /? <br><br>考虑到读取一行文本时所遇到的目前扩充的限制时，延迟环境变量扩充是很有用的，而不是执行的时候。以下例子说明直接变量扩充的问题: <br><span style="line-height:1.5;">set VAR=before </span><br>if "%VAR%" == "before" ( <br>set VAR=after <br>if "%VAR%" == "after" @echo If you see this, it worked <br>) <br><span style="line-height:1.5;">不会显示消息，因为在读到第一个 IF 语句时，BOTH IF 语句中</span><span style="line-height:1.5;">的 %VAR% 会被代替；原因是: 它包含 IF 的文体，IF 是一个</span><span style="line-height:1.5;">复合语句。所以，复合语句中的 IF 实际上是在比较 "before" 和 </span><span style="line-height:1.5;">"after"，这两者永远不会相等。同样，以下这个例子也不会达到</span><span style="line-height:1.5;">预期效果: </span><br><span style="line-height:1.5;">set LIST= </span><br>for %i in (*) do set LIST=%LIST% %i <br>echo %LIST% <br><span style="line-height:1.5;">原因是，它不会在目前的目录中建立一个文件列表，而只是将</span>LIST 变量设成找到的最后一个文件。这也是因为 %LIST% 在FOR 语句被读取时，只被扩充了一次；而且，那时的 LIST 变量是空的。因此，我们真正执行的 FOR 循环是: <br><span style="line-height:1.5;">for %i in (*) do set LIST= %i </span><br><span style="line-height:1.5;">这个循环继续将 LIST 设成找到的最后一个文件。 </span><br><br>延迟环境变量扩充允许您使用一个不同的字符(惊叹号)在执行时间扩充环境变量。如果延迟的变量扩充被启用，可以将上面例子写成以下所示，以达到预期效果: <br><span style="line-height:1.5;">set VAR=before </span><br>if "%VAR%" == "before" ( <br>set VAR=after <br>if "!VAR!" == "after" @echo If you see this, it worked <br>) <br><br>set LIST= <br>for %i in (*) do set LIST=!LIST! %i <br>echo %LIST% </p> 
 <p><span style="line-height:1.5;">如果命令扩展被启用，有几个动态环境变量可以被扩展，但</span>不会出现在 SET 显示的变量列表中。每次变量数值被扩展时，这些变量数值都会被动态计算。如果用户用这些名称中任何一个定义变量，那个定义会替代下面描述的动态定义: <br><span style="line-height:1.5;">%CD% - 扩展到当前目录字符串。 </span><br><span style="line-height:1.5;">%DATE% - 用跟 DATE 命令同样的格式扩展到当前日期。 </span><br><span style="line-height:1.5;">%TIME% - 用跟 TIME 命令同样的格式扩展到当前时间。 </span><br><span style="line-height:1.5;">%RANDOM% - 扩展到 0 和 32767 之间的任意十进制数字。 </span><br><span style="line-height:1.5;">%ERRORLEVEL% - 扩展到当前 ERRORLEVEL 数值。 </span><br><span style="line-height:1.5;">%CMDEXTVERSION% - 扩展到当前命令处理器扩展版本号。 </span><br><span style="line-height:1.5;">%CMDCMDLINE% - 扩展到调用命令处理器的原始命令行。</span></p> 
 <p><span style="color:#33cccc;">Part Five:</span></p> 
 <p><span style="color:#ffcc00;">^</span> 转义符 : 用在特殊符号之前 <br>比如: <br>echo ^&amp; <br>---------------- <br><span style="color:#ffcc00;">||</span> 连接符 : 当前面的命令没有成功执行 则执行后面的命令 <br>比如: <br>echo 0123456 | find "789" || echo 字符中没有789 <br>---------------- <br><span style="color:#ffcc00;">&amp;&amp;</span> 连接符 : 当前面的命令成功执行 再执行后面的命令 <br>比如: <br>echo 0123456 | find "123" &amp;&amp; echo 字符中含有123 <br>---------------- <br><span style="color:#ffcc00;">&amp;</span> 连接符 : 无论前面的命令是否成功执行 都执行后面的 <br>比如: <br>echo 0123456 | find "789" &amp; echo 字符中含有123 <br>虽然没有成功到789 但还是会执行echo 命令</p> 
 <p>对于上述符号优先级试验后结果：&amp;&amp; &gt; || &gt; &amp;</p> 
 <p>符号<span style="color:#ffcc00;">&gt;&gt;</span> <br>与符号&gt;相似，但区别在于&gt;&gt;是传递并在文件末尾追加。&gt;&gt;也可将回显传递给控制台。 <br>符号<span style="color:#ffcc00;">| </span><br>|是一个管道传输命令意思，是将上一命令执行的结果传递给下一命令去处理。 <br>例如： <br>dir d:\|find "1508" <br>以上命令的意思为查找d:\的所有，并寻找1508字符串。 <br>符号<span style="color:#ffcc00;">,</span> <br>在某些特殊的情况下可以用 , 来代替空格使用。 <br>符号<span style="color:#ffcc00;">;</span> <br>当命令相同的时候，可以将不同的目标用;隔离开来，但执行效果不变。如执行过程中发生错误，则只返回错误报告。 <br>例： <br>DIR C:\;D:\;E:\F:\ <br>以上的命令相当于 <br>DIR C:\ <br>DIR D:\ <br>DIR E:\ <br>DIR F:\</p> 
 <p><span style="line-height:1.5;"><span style="color:#ffcc00;">筛选器命令传递信息</span> <br>more 命令每次显示一屏文件内容或命令输出。 <br>find 命令在文件和命令输出中搜索指定字符。 <br>sort 命令按字母顺序排列文件和命令输出。 <br>要将输入从文件发送到筛选器命令，请使用小于符号 (&lt;)。如果要筛选器命令从其他命令获得输入，请使用管道 (|)。 <br><span style="color:#ffcc00;">more </span><br>more &lt; list.txt <br>tree c:\ | more <br>/c 显示页面前清除屏幕。 <br>/p 扩展换页符。 <br>/s 将多个空白行更改为一个空白行。 <br>/tn 将制表位更改为 n 个空格 <br>+n 显示由 n 指定的行开始的第一个文件。 <br>以下命令在 more 提示 (-- More --) 下接受。 <br>space 显示下一页。 <br>ENTER 显示下一行。 <br>F 显示下一个文件。 <br>q 退出。 <br>? 显示可用命令。 <br>= 显示行号。 <br>P n 显示以下 n 行。 <br>S n 跳过下面 n 行。 <br><span style="color:#ffcc00;">find </span><br>/v 显示未包含指定字符串的所有行。 <br>/c 只显示包含指定字符串的行数。 <br>/n 将文件行号置于每行开头。 <br>/I 指定搜索不区分大小写 <br>显示每个包含该文本的行 <br>文件名区分大小写 <br>find "Pacific Rim" &lt; trade.txt &gt; nwtrade.txt <br>搜索C盘上的每个目录以查找包含“Log”字符串的文件名，并且每次显示一屏：dir c:\ /s /b | find "LOG" | more <br><span style="color:#ffcc00;">sort </span><br>按字母顺序排列 <br>sort &lt; list.txt &gt; alphlist.txt <br>/r 颠倒排序顺序，即从 Z 到 A 排序，然后从 9 到 0 排序。 <br>/+n 指定字符位置号n，sort 在此处开始每次比较。例如，/+3 表示每次比较在每行的第三个字符开始。少于 n 个字符的行在其他行之前排序。默认情况下，比较在每行的第一个字符开始。</span></p> 
</div> 
<p>转载于:https://www.cnblogs.com/RoyCNNK/articles/2970557.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aba73f6668b54c563855aaea5f888156/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">qml C&#43;&#43;插件plugin.qmltypes</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/722cbb63bb35379c411415ca1dfce697/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Exps on March 21st</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>