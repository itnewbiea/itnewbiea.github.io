<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>1]解决java.util.concurrent.RejectedExecutionException - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="1]解决java.util.concurrent.RejectedExecutionException" />
<meta property="og:description" content="今天学习了java的并发，线程池，同一时间执行一个操作。
报错：java.util.concurrent.RejectedExecutionException，排查发现是等待队列设小了，导致
拒绝策略，当队列满时，处理策略报错异常。 上代码：
package aqs; import java.util.concurrent.*; /** * @author WHM * 实现指定时间内做一定事情 * @date 2021年08月06日 16:27 */ public class CountDownLatchTest { public static int clientTotal = 2000; // 核心线程数，当线程池空闲时保留的线程数 static int corePoolSize = 2; // 线程池最大线程数，线程池繁忙时能够扩容到的最大线程数 static int maximumPoolSize = 5; // 线程活跃时间，当线程数大于核心数时，并且线程开始空闲，此时多余的线程经过活跃时间后自动关闭 static int keepAliveTime = 1; // 线程活跃时间单位 static TimeUnit unit = TimeUnit.SECONDS; static BlockingQueue&lt;Runnable&gt; queue = new ArrayBlockingQueue&lt;&gt;(20); // 等待队列，ArrayBlockingQueue为有界阻塞队列，当队列满时进行阻塞 static RejectedExecutionHandler handler = new ThreadPoolExecutor." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/3965b45dd6c268403906f1633e0fed88/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-06T18:04:01+08:00" />
<meta property="article:modified_time" content="2021-08-06T18:04:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">1]解决java.util.concurrent.RejectedExecutionException</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>今天学习了java的并发，线程池，同一时间执行一个操作。</p> 
<p>报错：java.util.concurrent.RejectedExecutionException，排查发现是等待队列设小了，导致</p> 
<pre><code class="language-html hljs">拒绝策略，当队列满时，处理策略报错异常。</code></pre> 
<p>上代码：</p> 
<pre><code>package aqs;

import java.util.concurrent.*;

/**
 * @author WHM
 * 实现指定时间内做一定事情
 * @date 2021年08月06日 16:27
 */
public class CountDownLatchTest {
    public static int clientTotal = 2000;
    // 核心线程数，当线程池空闲时保留的线程数
    static int corePoolSize = 2;
    // 线程池最大线程数，线程池繁忙时能够扩容到的最大线程数
    static int maximumPoolSize = 5;
    // 线程活跃时间，当线程数大于核心数时，并且线程开始空闲，此时多余的线程经过活跃时间后自动关闭
    static int keepAliveTime = 1;
    // 线程活跃时间单位
    static TimeUnit unit = TimeUnit.SECONDS;
    static BlockingQueue&lt;Runnable&gt; queue = new ArrayBlockingQueue&lt;&gt;(20); // 等待队列，ArrayBlockingQueue为有界阻塞队列，当队列满时进行阻塞
    static RejectedExecutionHandler handler = new ThreadPoolExecutor.AbortPolicy(); // 拒绝策略，当队列满时，处理策略

    static ThreadPoolExecutor executor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, queue, handler);

    public static void main(String[] args) throws  Exception{

        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);

        for(int i = 0;i &lt; clientTotal; i++) {
            final int now = i;
            executor.execute(()-&gt;{
                try{
                    test(now);
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    countDownLatch.countDown();
                }
            });
        }
        countDownLatch.await(5, TimeUnit.SECONDS);
        System.out.println("thread finish");
        executor.shutdown();
    }

    private static void test(final int threadNum) throws Exception {
        Thread.sleep(3000);
        System.out.println("thread: {}" + threadNum);
    }
}
</code></pre> 
<p>本来以为写的还不错的代码执行报错了：</p> 
<p><img alt="" height="315" src="https://images2.imgbox.com/d0/55/3SDGVsFZ_o.png" width="1200"></p> 
<p></p> 
<p>分析<br> 通过对ThreadPoolExecutor类分析，引发java.util.concurrent.RejectedExecutionException主要有两种原因：<br> 1. 线程池显示的调用了shutdown()之后，再向线程池提交任务的时候，如果你配置的拒绝策略是ThreadPoolExecutor.AbortPolicy的话，这个异常就被会抛出来。<br> 2. 当你的排队策略为有界队列，并且配置的拒绝策略是ThreadPoolExecutor.AbortPolicy，当线程池的线程数量已经达到了maximumPoolSize的时候，你再向它提交任务，就会抛出ThreadPoolExecutor.AbortPolicy异常。 (我们设定了)</p> 
<pre><code>static BlockingQueue&lt;Runnable&gt; queue = new ArrayBlockingQueue&lt;&gt;(20); 

但是

线程有2000个</code></pre> 
<p>所以，被拒绝啦。</p> 
<p></p> 
<p>对于分析的第一个我们可以做个例子：</p> 
<p>这一点很好理解。比如说，你向一个仓库去存放货物，一开始，仓库管理员把门给你打开了，你放了第一件商品到仓库里，但是当你放好出去后，有人把仓库门关了，那你下次再来存放物品时，你就会被拒绝。示例代码如下：</p> 
<pre><code>import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
 
 
public class TextExecutor {
	public ExecutorService fixedExecutorService = Executors.newFixedThreadPool(5);
	public ExecutorService cachedExecutorService = Executors.newCachedThreadPool();
	public ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();
	
	public void testExecutorException() {
		for (int i = 0; i &lt; 10; i ++) {
			fixedExecutorService.execute(new SayHelloRunnable());
			fixedExecutorService.shutdown();
		}
	}
	
	private class SayHelloRunnable implements Runnable {
 
		@Override
		public void run() {
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} finally {
				System.out.println("hello world!");
			}
			
		}
	}
	
	public static void main(String[] args) {
		TextExecutor testExecutor = new TextExecutor();
		testExecutor.testExecutorException();
	}
}</code></pre> 
<p>解决方案<br> 1. 不要显示的调用shutdown方法，例如Android里，只有你在Destory方法里cancel掉AsyncTask，则线程池里没有活跃线程会自己回收自己。<br> 2. 调用线程池时，判断是否已经shutdown，通过API方法isShutDown方法判断，示例代码：<br>  </p> 
<pre><code>import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
 
 
public class TextExecutor {
	public ExecutorService fixedExecutorService = Executors.newFixedThreadPool(5);
	public ExecutorService cachedExecutorService = Executors.newCachedThreadPool();
	public ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();
	
	public void testExecutorException() {
		for (int i = 0; i &lt; 10; i ++) {
			// 增加isShutdown()判断
			if (!fixedExecutorService.isShutdown()) {
				fixedExecutorService.execute(new SayHelloRunnable());
			}
			fixedExecutorService.shutdown();
		}
	}
	
	private class SayHelloRunnable implements Runnable {
 
		@Override
		public void run() {
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} finally {
				System.out.println("hello world!");
			}
			
		}
	}
	
	public static void main(String[] args) {
		TextExecutor testExecutor = new TextExecutor();
		testExecutor.testExecutorException();
	}
}</code></pre> 
<p>第二种报错代码已经给出：</p> 
<p>我们看如何解决：</p> 
<p>1.提大排队队列</p> 
<p>static BlockingQueue&lt;Runnable&gt; queue = new ArrayBlockingQueue&lt;&gt;(2000); </p> 
<p> 2.使用LinkedBlockingQueue</p> 
<p> static BlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;&gt;(); </p> 
<p><strong>问题延伸</strong></p> 
<p><strong>1.不建议使用Executors创建线程</strong></p> 
<p><strong>较为方便的Executors工厂方法Executors.newCachedThreadPool() （无界线程池，可以进行自动线程回收）、Executors.newFixedThreadPool(int)（固定大小线程池）和Executors.newSingleThreadExecutor()（单个后台线程），但是通过源码我们可以发现最后他们均调用了ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) 方法，因此我们在分析java.util.concurrent.RejectedExecutionException之前，需要深入学习一下ThreadPoolExecutor的使用。</strong></p> 
<p><img alt="" height="619" src="https://images2.imgbox.com/c6/d6/sEbVeJ0k_o.png" width="957"></p> 
<p> 2.了解一下：TreadPoolExecutor</p> 
<p>核心池和最大池的大小<br> TreadPoolExecutor将根据corePoolSize和maximumPoolSize设置的边界自动调整池大小。当新任务在方法execute(java.lang.Runnable)中提交时，如果运行的线程少于corePoolSize，则创建新线程来处理请求，即使其他辅助线程是空闲的。如果运行的线程多于corePoolSize而少于maximumPoolSize，则仅当队列满时才创建新的线程。如果设置的corePoolSize和maximumPoolSize相同，则创建了固定大小的线程池。如果将maximumPoolSize设置为基本的无界值（如Integer.MAX_VALUE)，则允许线程池适应任意数量的并发任务。</p> 
<p>3. BlockingQueue/LinkedBlockingQueue我们通过异同快速了解一下：</p> 
<p>相同：</p> 
<p>1、LinkedBlockingQueue和ArrayBlockingQueue都实现了BlockingQueue接口；</p> 
<p>2、LinkedBlockingQueue和ArrayBlockingQueue都是可阻塞的队列</p> 
<p>　　内部都是使用ReentrantLock和Condition来保证生产和消费的同步；</p> 
<p>　　当队列为空，消费者线程被阻塞；当队列装满，生产者线程被阻塞；</p> 
<p>使用Condition的方法来同步和通信：await()和signal()</p> 
<p><img alt="" height="359" src="https://images2.imgbox.com/9d/4e/4RD3XixI_o.png" width="552"></p> 
<p><img alt="" height="303" src="https://images2.imgbox.com/23/e1/mNPhfmVQ_o.png" width="591"></p> 
<p>不同：</p> 
<p>1、由上图可以看出，他们的锁机制不同</p> 
<p>　　LinkedBlockingQueue中的锁是分离的，生产者的锁PutLock，消费者的锁takeLock</p> 
<p>　　而ArrayBlockingQueue生产者和消费者使用的是同一把锁；</p> 
<p></p> 
<p>2、他们的底层实现机制也不同</p> 
<p>　　LinkedBlockingQueue内部维护的是一个链表结构</p> 
<p><img alt="" height="320" src="https://images2.imgbox.com/d6/94/vthslOgh_o.png" width="480"></p> 
<p>在生产和消费的时候，需要创建Node对象进行插入或移除，大批量数据的系统中，其对于GC的压力会比较大</p> 
<p>　　而ArrayBlockingQueue内部维护了一个数组</p> 
<p> <img alt="" height="98" src="https://images2.imgbox.com/e1/3c/uEEOIF04_o.png" width="328"></p> 
<p> 在生产和消费的时候，是直接将枚举对象插入或移除的，不会产生或销毁任何额外的对象实例</p> 
<p> 3、构造时候的区别</p> 
<p>　　LinkedBlockingQueue有默认的容量大小为：Integer.MAX_VALUE，当然也可以传入指定的容量大小</p> 
<p><img alt="" height="189" src="https://images2.imgbox.com/c4/69/KnI53JdZ_o.png" width="551"></p> 
<p>ArrayBlockingQueue在初始化的时候，必须传入一个容量大小的值</p> 
<p>　　看其提供的构造方法就能知道 （ideaALT+7 可以查看类方法）</p> 
<p> <img alt="" height="108" src="https://images2.imgbox.com/16/4a/PXdzeuty_o.png" width="454"></p> 
<p>4、执行clear()方法</p> 
<p>　　LinkedBlockingQueue执行clear方法时，会加上两把锁</p> 
<p><img alt="" height="403" src="https://images2.imgbox.com/9a/f3/vc27TSY0_o.png" width="633"></p> 
<p> 要问什么锁，想想，肯定是生产/消费锁</p> 
<p><img alt="" height="209" src="https://images2.imgbox.com/eb/1d/j3tdVr8m_o.png" width="335"></p> 
<p> ArrayBlockingQueue是添加一把锁</p> 
<p><img alt="" height="637" src="https://images2.imgbox.com/6c/7e/DcIPoZ7N_o.png" width="595"></p> 
<p></p> 
<p> 5、统计元素的个数</p> 
<p>　　LinkedBlockingQueue中使用了一个AtomicInteger对象来统计元素的个数</p> 
<p>       毕竟有2个锁，所以保障count的原子性，需要使用AtomicInteger来控制，底层使用CAS来控制同步。  好烦是不是又要看CAS (之前有写过一篇哦)</p> 
<p><img alt="" height="96" src="https://images2.imgbox.com/0a/19/oszF9gVZ_o.png" width="574"></p> 
<p>      ArrayBlockingQueue则使用int类型来统计元素</p> 
<p><img alt="" height="96" src="https://images2.imgbox.com/24/6d/mlCWNpXd_o.png" width="402"></p> 
<p>作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a4202f59f58f661e07c2384b8ed79091/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">slickgrid 中ajax,SlickGrid 插件开发(1)：插件功能总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ab29d41eb234564e70da8f6ee89e19a5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux web 服务器性能,Linux系统Web服务器性能测试(2)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>