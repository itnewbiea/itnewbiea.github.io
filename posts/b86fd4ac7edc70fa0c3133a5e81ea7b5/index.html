<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Pandas教程（四）—— 分层索引及数据联合 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Pandas教程（四）—— 分层索引及数据联合" />
<meta property="og:description" content="1.分层索引 分层索引就是在一个轴上拥有多个（两个及以上）索引级别，能以低维度形式处理高维度数据。
行索引有两层 1.1 分层索引的创建 1.1.1 方式一：直接设置
1）在创建series、dataframe或读取文件时时，行名或列名输入一个二维的列表；2）使用语句：data.set_index（ ） 括号中输入一个含多个列名的列表 set_index会生成一个新的dataframe，使用一个或多个列作为索引
reset_index是它的反函数，分层索引中的索引层级会被移动到列中
import pandas as pd data = {&#34;城市&#34;:[&#34;北京&#34;,&#34;上海&#34;,&#34;深圳&#34;,&#34;广州&#34;], &#34;同比&#34;:[120.7,127.3,119.4,140.9], &#34;环比&#34;:[101.5,101.2,101.3,120.0], &#34;定基&#34;:[121.4,127.8,120.0,145.5]} # 法一 data1 = pd.DataFrame(data, index = [[&#34;A&#34;,&#34;A&#34;,&#34;B&#34;,&#34;B&#34;],[1,2,1,4]], #第一层中相同的要放在一起 columns =[&#34;城市&#34;,&#34;同比&#34;,&#34;环比&#34;,&#34;定基&#34;]) # 法二 data2 = pd.DataFrame(data,columns =[&#34;城市&#34;,&#34;同比&#34;,&#34;环比&#34;,&#34;定基&#34;]) data2 = data2.set_index([&#39;城市&#39;,&#39;同比&#39;]) 输出结果如下：
我们得到的就是一个以 MutiIndex 对象 作为索引的 美化视图
print(data.index) #打印dataframe的索引 返回结果如下： 1.1.2 利用方法属性创建 以下方法只是创建出多维索引 Mutiindex 对象，还需要在定义时将其赋给Dataframe 创建语法：pd. MutiIndex.下述方法（）
方法描述from_arrays接收一个多维数组，高维指定高层索引，低维指定底层索引from_tuples 接收一个元组的列表，每个元组指定每个对应索引
（高维索引，低维索引） 如上图
from_product接收一个可迭代对象的列表，使用笛卡尔积的方式创建 补充：笛卡尔积 两个集合X和Y的笛卡尔积（X × Y）是指 第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员
例如：A={a, b}，B={0, 1, 2}，则笛卡尔积为{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b86fd4ac7edc70fa0c3133a5e81ea7b5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-01T21:47:35+08:00" />
<meta property="article:modified_time" content="2024-01-01T21:47:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Pandas教程（四）—— 分层索引及数据联合</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.分层索引</h2> 
<p style="margin-left:0;">分层索引就是在一个轴上拥有多个（两个及以上）索引级别，能以低维度形式处理高维度数据。</p> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" src="https://images2.imgbox.com/2f/de/GpselzZ4_o.png"> 
  <figcaption>
    行索引有两层 
  </figcaption> 
 </figure> 
</div> 
<h4 style="margin-left:0px;"></h4> 
<h4 style="margin-left:0px;"></h4> 
<h3 style="margin-left:0px;"> 1.1 分层索引的创建</h3> 
<p>  <strong> 1.1.1 方式一：直接设置</strong></p> 
<ul><li>1）在创建series、dataframe或读取文件时时，行名或列名输入一个<strong><span style="background-color:#f9eda6;">二维的列表；</span></strong></li><li>2）使用语句：<span style="background-color:#f9eda6;"><strong>data.set_index（ ）</strong></span>    括号中输入一个含多个列名的列表</li></ul> 
<blockquote> 
 <p>     set_index会生成一个新的dataframe，使用一个或多个列作为索引</p> 
 <p>   <span style="background-color:#c7e6ea;">  reset_index是它的反函数</span>，分层索引中的索引层级会被移动到列中</p> 
</blockquote> 
<pre><code class="language-python">import pandas as pd
data = {"城市":["北京","上海","深圳","广州"],
         "同比":[120.7,127.3,119.4,140.9],
         "环比":[101.5,101.2,101.3,120.0],
         "定基":[121.4,127.8,120.0,145.5]}

# 法一
data1 = pd.DataFrame(data,
                    index = [["A","A","B","B"],[1,2,1,4]],  #第一层中相同的要放在一起
                    columns =["城市","同比","环比","定基"])

# 法二
data2 = pd.DataFrame(data,columns =["城市","同比","环比","定基"])
data2 = data2.set_index(['城市','同比'])</code></pre> 
<p>输出结果如下：</p> 
<p class="img-center"><img alt="" height="139" src="https://images2.imgbox.com/81/08/XxIjhE5X_o.png" width="352"></p> 
<p>我们得到的就是一个以<strong><span style="background-color:#f9eda6;"> MutiIndex 对象 </span></strong>作为索引的 美化视图</p> 
<pre><code class="language-python">print(data.index) #打印dataframe的索引</code></pre> 
<p>返回结果如下： </p> 
<p style="text-align:center;"><img alt="" height="140" src="https://images2.imgbox.com/65/43/W7wzshwL_o.png" width="240"></p> 
<p></p> 
<p></p> 
<p><strong>   1.1.2 利用方法属性创建 </strong></p> 
<ul><li>以下方法只是创建出多维索引 Mutiindex 对象，还需要在定义时将其赋给Dataframe</li></ul> 
<p>       创建语法：<span style="background-color:#f9eda6;">pd. MutiIndex.下述方法（）</span></p> 
<table border="2" cellpadding="1" cellspacing="1" style="width:600px;"><thead><tr><th style="width:179px;">方法</th><th style="width:419px;">描述</th></tr></thead><tbody><tr><td style="width:179px;">from_arrays</td><td style="width:419px;">接收一个多维数组，高维指定高层索引，低维指定底层索引</td></tr><tr><td style="width:179px;">from_tuples</td><td style="width:419px;"> <p>接收一个元组的列表，每个元组指定每个对应索引</p> <p><span style="background-color:#c7e6ea;">（高维索引，低维索引）</span>    如上图</p> </td></tr><tr><td style="width:179px;"><span style="background-color:#f9eda6;">from_product</span></td><td style="width:419px;">接收一个可迭代对象的列表，使用<strong><span style="background-color:#f9eda6;">笛卡尔积</span></strong>的方式创建</td></tr></tbody></table> 
<blockquote> 
 <ul><li>补充：笛卡尔积</li></ul> 
 <p>两个集合X和Y的笛卡尔积（X × Y）是指  第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员</p> 
 <p>例如：A={a, b}，B={0, 1, 2}，则笛卡尔积为{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}</p> 
</blockquote> 
<pre><code class="language-python">import pandas as pd
# 利用数组设置
mult1 = pd.MultiIndex.from_arrays([['a', 'a', 'b', 'b'], [1, 2, 1, 2]],names = ["x","y"])
print(mult1)

# 利用元组设置
mult2 = pd.MultiIndex.from_tuples([('a', 1),('a', 2),('b', 1),('b', 2)],names = ["x","y"])
print(mult2)

# 推荐：利用可迭代对象设置
mult3 = pd.MultiIndex.from_product([[2019,2020],[1,2]])
mult3.names = ["年","月"] # 也可以这样设置索引名
print(mult3)


# 将mutiindex赋给数据
mult4 = pd.MultiIndex.from_product([["山东","北京"],["土豆","茄子"]],names=['城市', '蔬菜'])
data = pd.DataFrame(np.random.random(size=(4,4)),
                    index = mult3,
                    columns = mult4)
print(data)</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<h3> 1.2 分层索引的切片或索引</h3> 
<p>    首先我们先创建一个多层索引的dataframe，并以此为例讲解</p> 
<p>（参考了该文章：<a class="link-info" href="https://blog.csdn.net/qq_35318838/article/details/102469320" title="https://blog.csdn.net/qq_35318838/article/details/102469320">https://blog.csdn.net/qq_35318838/article/details/102469320</a>）</p> 
<pre><code class="language-python">import pandas as pd
mult3 = pd.MultiIndex.from_product([[2019,2020],[1,2]])
mult3.names = ["年","月"]
mult4 = pd.MultiIndex.from_product([["山东","北京"],["土豆","茄子"]],names=['城市', '蔬菜'])
data = pd.DataFrame(np.random.random(size=(4,4)),index = mult3,columns = mult4)
print(data)</code></pre> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" height="182" src="https://images2.imgbox.com/8f/5e/Zw7HOWQH_o.png" width="493"> 
  <figcaption>
    上述代码结果 
  </figcaption> 
 </figure> 
</div> 
<h6></h6> 
<h5><strong>    1.2.1 对列标签层次化索引</strong></h5> 
<ul><li>最外层列标签的索引：<span style="background-color:#f9eda6;">data  [ "外层列名" ] </span></li><li>内层列标签的索引：   <span style="background-color:#f9eda6;">data [ "外层标签"，"内层标签" ]</span></li></ul> 
<pre><code class="language-python">print(data["山东"]) # 索引山东列
print("-"*50)
print(data["山东","土豆"]) #索引山东的土豆列</code></pre> 
<p></p> 
<h5><strong>    1.2.2 对行标签层次化索引</strong></h5> 
<ul><li>最外层行标签的索引：<span style="background-color:#f9eda6;">data<strong>.<span style="color:#fe2c24;">loc</span></strong><span style="color:#fe2c24;"> </span> [ "外层行名" ] </span></li><li>内层行标签的索引：   <span style="background-color:#f9eda6;">data<span style="color:#fe2c24;"><strong>.loc </strong></span>[ "外层标签"，"内层标签" ]</span></li></ul> 
<pre><code class="language-python">print(data.loc[2019]) # 索引2019年 行
print("-"*50)
print(data.loc[2019,1]) # 索引2019一月 行</code></pre> 
<p></p> 
<h5><strong>    1.2.3 使用xs进行索引</strong></h5> 
<p>      pandas 中的 xs 方法在索引时可以直接指定层次化索引中<span style="background-color:#f9eda6;">元素和层级 </span></p> 
<ul><li>语法：<strong><span style="background-color:#f9eda6;">data.xs（ x ,  level=, axis=1)</span></strong></li></ul> 
<blockquote> 
 <p>参数说明：</p> 
 <p>          x：标签或标签的元组</p> 
 <p>         <span style="background-color:#c7e6ea;"> level：层级名</span>（本例中行索引层级包括：蔬菜、城市          列索引层级包括：年、月）</p> 
 <p>          axis：哪个轴向上的层级</p> 
</blockquote> 
<pre><code class="language-python">print(data.xs(1,level="月",axis=0)) # 列切片 月层级上所有1月
print("-"*50)
print(data.xs("土豆",level="蔬菜",axis=1))  # 行切片 蔬菜层级上所有土豆</code></pre> 
<p></p> 
<p></p> 
<h5><strong>    1.2.4 使用l</strong>oc和slice方法切片</h5> 
<p>    在列索引中，“ ：”代表选取全部列，但冒号不能在行索引中使用；</p> 
<p>    <span style="background-color:#f9eda6;">行索引中应该使用<strong>slice（None）</strong>代表选取所有行</span></p> 
<pre><code class="language-python">print(data.loc[(slice(None),1),:]) # 选取所有1月
print(data.loc[slice(None),(slice(None),"茄子")]) # 选取所有的茄子</code></pre> 
<p></p> 
<p></p> 
<h3> 1.3 重排序和层级排序</h3> 
<table border="2" cellpadding="1" cellspacing="1" style="width:600px;"><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>data.swaplevel（“key1”，“key2”）</td><td>传入两个层级序号或层级名称，互换这两个层级的位置</td></tr><tr><td>data.sort_index（level =）</td><td>传入一个层级，使结果按照层级进行字典排序</td></tr></tbody></table> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h2>2.联合与合并数据集</h2> 
<ul><li>基础知识：四种连接方式</li></ul> 
<p>        内连接(inner)、左连接(left)、右连接(right)、全外连接（outer  全部都要)</p> 
<figure class="image"> 
 <img alt="" height="367" src="https://images2.imgbox.com/d5/92/P6RUaQsp_o.png" width="1194"> 
 <figcaption>
   内连接、左连接、右连接 
 </figcaption> 
</figure> 
<p></p> 
<p></p> 
<h3 style="background-color:transparent;"> 2.1 Merge函数</h3> 
<p>   merge函数有点类似sql中的join，主要用于<span style="background-color:#f9eda6;">将两个Dataframe根据一些共有的列连接起来</span></p> 
<p></p> 
<ul><li>语法：<strong><span style="background-color:#f9eda6;"> pd.merge（data1，data2，参数） </span></strong></li></ul> 
<blockquote> 
 <p><strong>常用参数：</strong></p> 
 <p>         </p> 
 <p>          <strong><span style="background-color:#c7e6ea;"> how：</span> </strong>数据连接的方式：inner（默认）、left、right、outer（即上面四种）</p> 
 <p>          <span style="background-color:#c7e6ea;"> </span><strong><span style="background-color:#c7e6ea;">on：</span>    </strong>用来连接的列名，必须是在两边的df中都有的列名；若使用多个键进行合并，</p> 
 <p>                       传入一个含多个列名的列表，<span style="background-color:#f9eda6;">把多个键看作一个元组数据当作单个键处理即可</span></p> 
 <p>           </p> 
 <p><strong>           suffixes：</strong>对于左右表中的重名列，添加后缀进行区分，默认为（"_x"，"_y"）</p> 
 <p>         <strong>  left_on / right_on：</strong>  左（右）表中用作连接键的列名</p> 
 <p>           <strong>left_index / right_index</strong>： 将左（右）表的行索引index用作连接键，布尔值 默认F    </p> 
</blockquote> 
<p></p> 
<h5>   2.1.1 根据单个连接键合并</h5> 
<ul><li><span style="background-color:#f9eda6;">pd.merge(数据1,数据2,on='姓名',how='inner')</span></li></ul> 
<pre><code class="language-python">import pandas as pd
数据1= pd.DataFrame({'姓名':['叶问','李小龙','孙兴华','李小龙','叶问','叶问'],'出手次数1':np.arange(6)})
数据2 = pd.DataFrame({'姓名':['黄飞鸿','孙兴华','李小龙'],'出手次数2':[1,2,3]})
数据3 = pd.merge(数据1,数据2,on='姓名',how='inner')
print(数据3)</code></pre> 
<figure class="image"> 
 <img alt="" height="192" src="https://images2.imgbox.com/38/86/TpHAPps7_o.png" width="697"> 
 <figcaption>
   以姓名为连接键，进行内连接 
 </figcaption> 
</figure> 
<p></p> 
<p></p> 
<h5>   2.1.2 根据多个连接键合并</h5> 
<ul><li>根据多个键进行合并时，on参数需传入一个含多个列名的列表，<span style="background-color:#f9eda6;color:#4d4d4d;">把多个键看作一个元组数据当作单个键处理即可</span></li></ul> 
<pre><code class="language-python">import pandas as pd
数据1 = pd.DataFrame({'姓名': ['张三', '张三', '王五'],'班级': ['1班', '2班', '1班'],'分数': [10,20,30]})
数据2 = pd.DataFrame({'姓名': ['张三', '张三', '王五','王五'],'班级': ['1班', '1班', '1班','2班'],'分数': [40,50,60,70]})

数据3 = pd.merge(数据1,数据2,on=['姓名','班级'],how='outer',suffixes=('_left','_right'))   # 外连接（并集）的结果
print(数据3)</code></pre> 
<figure class="image"> 
 <img alt="" height="346" src="https://images2.imgbox.com/26/7d/2LcLTWQ7_o.png" width="1200"> 
 <figcaption>
   以姓名和班级作为连接键，进行外连接，并处理了重复名 
 </figcaption> 
</figure> 
<p></p> 
<p></p> 
<h5>   2.1.3 索引作为键进行合并</h5> 
<ul><li>如果我们希望以df的索引作为合并的键，只需传递参数 <strong><span style="background-color:#f9eda6;">left_index / right_index = True</span> </strong>即可</li></ul> 
<pre><code class="language-python">import pandas as pd
import numpy as np
data1 = pd.DataFrame({"key1":["Ohio","Ohio","Ohio","Nevada","Nevada"],
                      "key2":[2000,2001,2002,2001,2002],
                      "data":np.arange(5)})

data2 = pd.DataFrame(np.arange(12).reshape(6,2),
                     index = [["Nevada","Nevada","Ohio","Ohio","Ohio","Ohio"],
                              [2001,2000,2000,2000,2001,2002]],
                     columns = ["first","second"])

data3 = pd.merge(data1,data2,left_on=["key1","key2"],right_index=True,how="outer")
print(data3)</code></pre> 
<figure class="image"> 
 <img alt="" height="209" src="https://images2.imgbox.com/db/3a/kjZaLh2q_o.png" width="719"> 
 <figcaption>
   data2以多层索引为连接键，进行外连接 
 </figcaption> 
</figure> 
<p></p> 
<p></p> 
<p></p> 
<h3 style="background-color:transparent;"> 2.2 join函数</h3> 
<p>      join函数可以便捷的进行横向连接，它<span style="background-color:#f9eda6;">默认以索引为连接键</span>，且默认左连接</p> 
<ul><li>语法：<span style="background-color:#f9eda6;">left_data </span><strong><span style="background-color:#f9eda6;">. join</span></strong><span style="background-color:#f9eda6;">（right_data，on = None，</span><span style="color:#0d0016;"><span style="background-color:#f9eda6;">how = 'left'</span></span><span style="background-color:#f9eda6;">） </span></li><li>若要一次组合多个dataframe，只需传入一个列表即可。例如：<span style="background-color:#f9eda6;">result = left.join([right, right2]) </span></li></ul> 
<pre><code class="language-python">import pandas as pd
left = pd.DataFrame({'姓名1':['叶问','李小龙','孙兴华'],'年龄1':[127,80,20]})
right = pd.DataFrame({'姓名2':['大刀王五','霍元甲','陈真'],'年龄2':[176,152,128]})

print(left.join(right))</code></pre> 
<p><img alt="" height="291" src="https://images2.imgbox.com/30/af/5LSLG4nN_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<h3 style="background-color:transparent;"> 2.3 concat函数</h3> 
<p>       contact函数主要负责数据组合中的拼接、绑定或堆叠，也可以总结为沿轴向对数据进行连接</p> 
<p></p> 
<ul><li>语法：<span style="background-color:#f9eda6;">contact（[ data1，data2... ]，axis = ，join = ，keys = ...）</span></li></ul> 
<blockquote> 
 <p> <strong>常用参数：</strong></p> 
 <p><strong> </strong></p> 
 <p><strong>                 axis ：</strong><span style="background-color:#c7e6ea;">沿哪个轴进行数据连接，默认为0，纵向连接</span></p> 
 <p><strong>                 join ：</strong>选择连接方式，inner（默认）或outer</p> 
 <p><strong>                <span style="background-color:#c7e6ea;"> join_axes</span> ：</strong>可以指定根据那个轴来对齐数据，代替join的作用</p> 
 <p><strong>                 ignore_index：</strong>是否忽略原索引，产生一段新的索引（默认False，不忽略）</p> 
 <p><strong>                 keys：</strong>输入一个列表，增加一个区分数据组的键，形成分层索引</p> 
</blockquote> 
<p> </p> 
<p></p> 
<h5>    2.3.1 纵向拼接 / 分层索引</h5> 
<p>      contact函数默认（axis = 0）就是纵向拼接，即首尾相连</p> 
<p>      此时我们可以通过 <span style="background-color:#f9eda6;">添加一个keys或传入字典</span> 来区分拼接后的数据到底来自哪个表</p> 
<ul><li>语法1：<span style="background-color:#f9eda6;">contact（[ df1，df2，df3 ]，axis = 0，</span><strong><span style="color:#fa0000;"><span style="background-color:#f9eda6;">keys</span></span></strong><span style="background-color:#f9eda6;"><strong>=['x', 'y', 'z']</strong>） </span></li><li>语法2：<span style="background-color:#f9eda6;">contact（<strong> { </strong></span><strong><span style="background-color:#f9eda6;">'</span></strong><span style="background-color:#f9eda6;"><strong>x': df1,  'y': df2,  'z': df3 }</strong>，axis = 0）</span></li></ul> 
<p> <img alt="" height="437" src="https://images2.imgbox.com/1f/69/Fzmb3So7_o.png" width="521"></p> 
<p></p> 
<h5 style="background-color:transparent;"><strong>    2.3.2 横向拼接 / 指定拼接键</strong></h5> 
<p>      当axis = 1的时候，concat就是行对齐，即横向合并</p> 
<p>      我们也可以通过传入join_axes，来指定根据那个轴来对齐数据</p> 
<ul><li>语法：<span style="background-color:#f9eda6;">pd.concat ( [ df1, df4 ] , axis = 1 ,  join_axes = [df1.index] )</span></li></ul> 
<figure class="image"> 
 <img alt="" height="291" src="https://images2.imgbox.com/24/02/UqAfZwbZ_o.png" width="1182"> 
 <figcaption>
   根据df1的index 对齐数据 
 </figcaption> 
</figure> 
<p></p> 
<p><strong>    2.3.3 无视原来的index</strong></p> 
<p>        如果两个表的index都没有实际含义，或拼接后变得混乱，我们可以传入 <strong>ignore_index</strong> 参数来生成一个新的index </p> 
<ul><li>语法： <span style="background-color:#f9eda6;">pd.concat ( [ df1, df4 ] , axis = 1 , </span><strong><span style="background-color:#f9eda6;">ignore_index = True）</span></strong></li></ul> 
<p> <img alt="" height="331" src="https://images2.imgbox.com/b1/1f/ZMybHup5_o.png" width="529"></p> 
<p></p> 
<p></p> 
<p></p> 
<h3> 2.4 联合重叠的数据 </h3> 
<p>      在数据操作中，我们经常需要去联合一些重叠的数据，进而去填补一些缺失值</p> 
<p> </p> 
<ul><li><strong>方法一：<span style="background-color:#f9eda6;">np.where（condition，x，y）</span> 等价于 x if condition else y</strong></li></ul> 
<p>       <strong><span style="background-color:#f9eda6;">语法：np.where（pd.isnull（data1），data2，data1）</span> </strong></p> 
<blockquote> 
 <p>该语法相当于先判断data1中的数据是否为空值，如果为空就用data2的数据，如果不为空，就用data1的数据 </p> 
</blockquote> 
<p></p> 
<p></p> 
<ul><li><strong>方法二：combine_first</strong></li></ul> 
<p>       <strong><span style="background-color:#f9eda6;">语法：data1.combine_first（data2）</span></strong></p> 
<blockquote> 
 <p>改语法是逐列对df做相同的操作，可以认为是<span style="background-color:#c7e6ea;">根据data2 来修补 data1的缺失值</span></p> 
</blockquote> 
<p></p> 
<p></p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b9fea87210e3d69bb31a9dc4acae9f9d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言程序设计——输入输出函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6a8d44b522726d50c06ac7aea4319afe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言KMP算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>