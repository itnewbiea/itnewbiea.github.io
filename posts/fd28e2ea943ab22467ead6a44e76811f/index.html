<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;基础知识 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;基础知识" />
<meta property="og:description" content="C&#43;&#43; 1、C&#43;&#43;概述 C&#43;&#43;是一种计算机高级程序设计语言，由C语言扩展升级而来。
C&#43;&#43;既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。即C&#43;&#43;擅长面向对象程序设计的同时，还可以进行基于过程的程序设计。
C&#43;&#43;拥有计算机运行的实用性特征，同时还致力于提高大规模程序的编程质量与程序设计语言的描述问题
-----百度百科
2、C&#43;&#43;关键字 C&#43;&#43;相比较与C语言，增加了将近一倍数量关键字，C&#43;&#43;总计有63个关键字。如图：
3、命名空间 3.1、问题提出
在C语言中，当我们定义变量名时，变量名与库中的函数重名，就会报错。如图：
变量名rand与库中的rand函数重名时，就会报重定义错误。
同样的，当我们在工程中，两个程序员在各自写代码的过程中使用了同名的变量名，就会出现错误，C&#43;&#43;为了解决这一问题引入了命名空间。
3.2、命名空间定义
​ 定义命名空间需要使用namespace关键字，后面跟命名空间的名字，然后接一对｛｝即可，｛｝中即为命名空间的成员。
注意：一个命名空间就定义了一个新的作用域，命名空间中所有内容都局限于该命名空间中
3.3 命名空间的使用
加命名空间名称及作用域限定符（：：） namespace cpp { int n = 0; int m = n &#43; 1; } int main() { int k = cpp::n; //使用作用域限定符（::） std::cout &lt;&lt; cpp::n &lt;&lt; std::endl; return 0; } 使用using将命名空间中某个成员引入 namespace cpp { int n = 0; int m = n &#43; 1; } using cpp::n; //将命名空间中的n释放 int main() { int k = n; return 0; } 使用 &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/fd28e2ea943ab22467ead6a44e76811f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-10T22:05:55+08:00" />
<meta property="article:modified_time" content="2022-11-10T22:05:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;基础知识</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="C_0"></a>C++</h2> 
<h3><a id="1C_2"></a>1、C++概述</h3> 
<blockquote> 
 <p>C++是一种计算机高级程序设计语言，由C语言扩展升级而来。</p> 
 <p>C++既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。即C++擅长面向对象程序设计的同时，还可以进行基于过程的程序设计。</p> 
 <p>C++拥有计算机运行的实用性特征，同时还致力于提高大规模程序的编程质量与程序设计语言的描述问题</p> 
 <p>-----百度百科</p> 
</blockquote> 
<h3><a id="2C_12"></a>2、C++关键字</h3> 
<blockquote> 
 <p>C++相比较与C语言，增加了将近一倍数量关键字，C++总计有63个关键字。如图：</p> 
 <p><img src="https://images2.imgbox.com/16/93/9vrqAq1M_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8fAVn6Ka-1668088494407)(C:\Users\25584\AppData\Roaming\Typora\typora-user-images\image-20221109170001470.png)]"></p> 
</blockquote> 
<h3><a id="3_19"></a>3、命名空间</h3> 
<blockquote> 
 <p>3.1、问题提出</p> 
 <p>在C语言中，当我们定义变量名时，变量名与库中的函数重名，就会报错。如图：<br> <img src="https://images2.imgbox.com/08/eb/zMhHQ5yW_o.png" alt="在这里插入图片描述"></p> 
 <p>变量名rand与库中的rand函数重名时，就会报重定义错误。</p> 
 <p>同样的，当我们在工程中，两个程序员在各自写代码的过程中使用了同名的变量名，就会出现错误，C++为了解决这一问题引入了命名空间。</p> 
 <p>3.2、命名空间定义</p> 
 <p>​ 定义命名空间需要使用namespace关键字，后面跟命名空间的名字，然后接一对｛｝即可，｛｝中即为命名空间的成员。</p> 
 <p><strong>注意：一个命名空间就定义了一个新的作用域，命名空间中所有内容都局限于该命名空间中</strong></p> 
 <p>3.3 命名空间的使用</p> 
 <ul><li>加命名空间名称及作用域限定符（：：）</li></ul> 
 <pre><code class="prism language-c++">namespace cpp
{
   int n = 0;
   int m = n + 1;
}
int main()
{
   int k = cpp::n; //使用作用域限定符（::）
   std::cout &lt;&lt; cpp::n &lt;&lt; std::endl;  
   return 0;
}
</code></pre> 
 <ul><li>使用using将命名空间中某个成员引入</li></ul> 
 <pre><code class="prism language-c++">namespace cpp
{
   int n = 0;
   int m = n + 1;
}
using cpp::n;  //将命名空间中的n释放
int main()
{ 
   int k = n;
   return 0;
}
</code></pre> 
 <ul><li>使用 " using namespace 命名空间 "引入</li></ul> 
 <pre><code class="prism language-c++">namespace cpp
{
   int n = 0;
   int m = n + 1;
}
using namespace cpp;  //将命名空间中的全部成员释放
int main()
{ 
   int k = n;
   std::cout &lt;&lt; m &lt;&lt; std::endl;
   return 0;
}
</code></pre> 
 <p>C++标准库的命名空间为std，在使用std命名空间中，并不推荐上述的第三种方法，而是上面的一二种方法。</p> 
 <p>using namespace std 展开，标准库就全部暴露出来了，如果我们定义和库重名的类型/对象/函数，就又会存在冲突问题。</p> 
 <p>所以在平常的练习中，为了方便可以直接展开，但是在项目中并不推荐这种方法。</p> 
</blockquote> 
<h3><a id="4_94"></a>4、缺省参数</h3> 
<blockquote> 
 <p>4.1 缺省参数概念</p> 
 <p>缺省参数是声明或者定义函数时为函数的参数指定一个缺省（默认）值。在调用该函数时，如果没有指定实参则采用该形参的缺省值，否则使用指定的实参。</p> 
 <pre><code class="prism language-c++">void Func(int a = 0)
{
    std::cout &lt;&lt; a &lt;&lt; std::endl;
}
int main()
{
    Func(); // 没有传参是时默认使用缺省值，即 a = 0
    Func(10);  //传参时使用参数，即 a = 10
}
</code></pre> 
 <p>4.2 缺省参数分类</p> 
 <ul><li>全缺省参数（全部参数都设置缺省值）</li><li>半缺省参数（ 部分参数设置缺省值）</li></ul> 
 <p><strong>注意：</strong></p> 
 <p>1、半缺省参数必须从右往左依次来给，不能间隔给</p> 
 <p>2、缺省参数不能在函数声明和定义时同时给（声明和定义都给缺省值时，编译器无法识别该使用哪个缺省值，所以一般在声明时给缺省值即可）</p> 
 <p>3、缺省值必须为常量或者全局变量</p> 
 <p>4、C语言不支持</p> 
</blockquote> 
<h3><a id="5_127"></a>5、函数重载</h3> 
<blockquote> 
 <p>5.1函数重载概念：</p> 
 <p>函数重载是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表（参数个数，参数类型，参数类型顺序）不同，常用来处理实现功能类似但数据类型不同的问题。</p> 
 <p>5.2 参数列表不同</p> 
 <ul><li>类型不同</li></ul> 
 <pre><code class="prism language-c++">void Add(int a, int b)
{
    std::cout &lt;&lt; "Add(int a, int b)" &lt;&lt; std::endl;
}
void Add(double a, double b)
{
    std::cout &lt;&lt; "Add(int a, int b)" &lt;&lt; std::endl;
}
</code></pre> 
 <ul><li>参数的个数不同</li></ul> 
 <pre><code class="prism language-c++">void Add()
{
    std::std::cout &lt;&lt; "Add()" &lt;&lt; std::endl;
}
void Add(int a, int b)
{
    std::cout &lt;&lt; "Add(int a, int b)" &lt;&lt; std::endl;
}
</code></pre> 
 <ul><li>参数的顺序不同</li></ul> 
 <pre><code class="prism language-c++">void Func(int a, char b)
{
    std::cout &lt;&lt; "Func(int a ,char b)" &lt;&lt; std::endl;
}
void Func(char a , int b)
{
    std::cout &lt;&lt; "Add(char a, int b)" &lt;&lt; std::endl;
}
</code></pre> 
 <p>5.3 函数重载原理 ---- 名字修饰（name mangling）</p> 
 <p>C++代码在编译时会根据参数列表对函数进行重命名（即将参数列表也加入到函数名修饰规则中），这样就方便识别每个同名却不同参的函数。</p> 
 <p>所以函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不同。</p> 
 <p>例如在Linux下修饰：</p> 
 <pre><code class="prism language-c++">int f(char a,int b ); //修饰为 _Z1fci
int f(int a,char b);  //修饰为 _Z1fic
</code></pre> 
 <p><strong>注意：</strong></p> 
 <p>返回值不同不构成重载并不是因为函数名修饰规则中无法加入返回值这一判断条件，而是在调用函数时具有二义性，无法区别调用的是哪个函数，因为调用时不指定返回值类型。</p> 
 <pre><code class="prism language-c++">void func(int a,int b)
{
    std::cout &lt;&lt; "func(int a,int )" &lt;&lt; std::endl;
}
int func(int a, int b)
{
    std::cout &lt;&lt; "func(int a,int )" &lt;&lt; std::endl;
    return a +b;
}
int main()
{
    func(1,1);  //在调用的时候，无法通过返回值来选择。
    func(2,2);   //先调用，再有返回值
    return 0;
}
</code></pre> 
</blockquote> 
<h3><a id="6nullptr_209"></a>6、指针空值nullptr</h3> 
<blockquote> 
 <p>在C/C++编程习惯中，声明一个变量时最好给变量一个合适的初始值，否则可能会出现不可预料的错误。尤其是当我们声明指针时，最好要对指针初始化为NULL</p> 
 <p>NULL是一个宏，在传统的C头文件（stddef.h）中将NULL定义为0或者（（void*）0）</p> 
 <pre><code class="prism language-c++">void f(int a)
{
    std::cout &lt;&lt; "f(int a)" &lt;&lt; std::endl;
}
void f(int* ptr)
{
    std::cout &lt;&lt; "f(int* ptr)"  &lt;&lt; std::endl;
}
int main()
{
    f(0);
    f(NULL);
    return 0;
}
</code></pre> 
 <p>当我们执行上述代码时，会发现无论传NULL还是0，所调用的都是第一个函数。</p> 
 <p>程序本意是想通过f（NULL）调用指针版本的f(int *)函数，但是由于NULL被定义为0，因此与程序的初衷相悖。</p> 
 <p><strong>所以C++在C++11中引入了nullptr作为关键字来表示指针空值</strong></p> 
</blockquote> 
<h3><a id="7_240"></a>7、内联函数</h3> 
<blockquote> 
 <p>7.1 概念</p> 
 <p>以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数调用建立栈帧的开销，内联函数提升程序运行的效率。</p> 
 <p>7.2 特性</p> 
 <ul><li>inline只是向编译器建议次函数可以展开，具体是否展开取决于编译器。</li><li>inline对于编译器而言只是一个请求，编译器可以选择忽略这个请求。一般建议将规模较小，不是递归、且频繁调用的函数采用inline修饰，否则编译器会忽视inline的特性。</li><li>inline修饰的函数不能声明和定义分离，分离会导致链接错误。</li></ul> 
</blockquote> 
<p>联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数调用建立栈帧的开销，内联函数提升程序运行的效率。</p> 
<blockquote> 
 <p>7.2 特性</p> 
 <ul><li>inline只是向编译器建议次函数可以展开，具体是否展开取决于编译器。</li><li>inline对于编译器而言只是一个请求，编译器可以选择忽略这个请求。一般建议将规模较小，不是递归、且频繁调用的函数采用inline修饰，否则编译器会忽视inline的特性。</li><li>inline修饰的函数不能声明和定义分离，分离会导致链接错误。</li></ul> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/072ed1474b5bb2f3a0dd4fca79bc2088/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">t-SNE降维可视化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/25f23c2b929e2bb97a40de33925b4c43/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深度学习4-SVM</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>