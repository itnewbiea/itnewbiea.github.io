<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>USART 、SPI、IIC、常用的通信方式详解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="USART 、SPI、IIC、常用的通信方式详解" />
<meta property="og:description" content="1.我们首先呢，我们谈谈要通信几大要点 1.1串行和并行 串行通信就是设备之间通过少量的线，进行一位一位的数据传输
并行通信就是使用多根数据线同时进行数据传输
1.2 全双工、半双工、单工 全双工：在同一时刻，两个设备之间可以同时收发数据 半双工:两个设备之间可以收发数据，但不能在同一时刻进行 单工：在任何时候都只能进行同一个方向的通信，即一个固定位发送设备，另一固定位接收设备
1.3同步和异步 同步：以时钟线来传输数据的，就是说，发送和接收的时序相同（iic、SPI）
异步：没有时钟线，以数据帧格式来传输数据的(RS485、串口)
1.4 传输速度 这个我认为比较重要的，首先，我们我们提到传输速度，就会想到比特率（Bit/s）和波特率，比特率是从单位看就可以知道是指每秒传输二进制的位数，而波特率是指每秒传输的码元；这里的码元我们给具体化，大家都知道串口，他的数据以帧格式传输的，即一个起始位&#43;8位数据位&#43;1位奇偶位&#43;1位结束位，那么这里时候，这11位加在一起就是一个码元，就是说多位算一个单位。
2 串口通讯 在我看来，通讯都分为物理接口和软件时序（物理层和协议层），掌握这两，就可以基本掌握一种通讯方式，物理层主要还是电压特性，数据位高低的电压；协议层主要就是数据传输的规则
2.1 物理层 串口通信的物理层有很多标准，我们一般有两种电平标准，TTL标准和RS485标准
这里呢，我画个简易图吧，来表示电平的转换，其中设备时STM32,设备B是内一个STM32
USB转串口
当然，这里也可以用CH340
电平标准
2.2 协议层 2.2.1串口的数据传输的帧格式 1位起始位&#43;6/7/8位数据位&#43;1位奇偶位&#43;1位结束位（可以不要校验位）
也就是说数据就按照这种格式发送出去的，这样比直接发送数据位更加的准确和安全
但是在两个设备进行串口通信的时候，要注意的就是他们的波特率要相同，因为他是异步的没有时钟，所以两个设备发送接收之前必须约定好波特率
3 USART 3.1 USART的简单介绍 （1）串口是串行异步全双工的以这种通信方式
（2）串口的数据传输是通过两根数据线传输，即RX、TX，发送和接收
（3）USART 支持使用 DMA （4）我们在用USART最多的还是printf的作用，即用来上位机的调试
3.2 USART的功能框图 3.3.2 ①功能引脚 我们能看到的就是外部引脚
TX：发送数据输出引脚。
RX：接收数据输入引脚。 STM32F103VET6 系统控制器有三个 USART 和两个 UART，其中 USART1 和时钟来源于 APB2 总线时钟，其最大频率为 72MHz，其他四个的时钟来源于 APB1 总线时钟，其最大频率为 36MHz。 3.3.3 ②数据寄存器 （1）数据字长
USART数据寄存器USART_DR只有低9位有效，其他位数保留，并且第 9 位数据是否有效要取决于USART 控制寄存器 1(USART_CR1)的 M 位设置，当 M 位为 0 时表示 8 位数据字长，当 M位为 1 表示 9 位数据字长，我们一般使用 8 位数据字长。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/7cd34b3ad9f7d64f415f5fea6dda2b0e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-13T09:05:04+08:00" />
<meta property="article:modified_time" content="2020-10-13T09:05:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">USART 、SPI、IIC、常用的通信方式详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><strong><strong><strong>1.我们首先呢，我们谈谈要通信几大要点</strong></strong></strong></h2> 
<h3><strong><strong><strong>1.1串行和并行</strong></strong></strong></h3> 
<p style="margin-left:0pt;"><span style="color:#000000;">串行通信就是设备之间通过少量的线，进行一位一位的数据传输</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">并行通信就是使用多根数据线同时进行数据传输</span></p> 
<h3><strong><strong><strong>1.2 全双工、半双工、单工</strong></strong></strong></h3> 
<p style="margin-left:0pt;"><span style="color:#000000;">全双工：</span><span style="color:#000000;">在同一时刻，两个设备之间可以同时收发数据 </span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">半双工</span><span style="color:#000000;">:</span><span style="color:#000000;">两个设备之间可以收发数据，但不能在同一时刻进行</span> </p> 
<p style="margin-left:0pt;">单工：在任何时候都只能进行同一个方向的通信，即一个固定位发送设备，另一固定位接收设备</p> 
<h3><strong><strong><strong>1.3同步和异步</strong></strong></strong></h3> 
<p style="margin-left:0pt;">同步：以时钟线来传输数据的，就是说，发送和接收的时序相同（iic、SPI）</p> 
<p style="margin-left:0pt;">异步：没有时钟线，以数据帧格式来传输数据的(RS485、串口)</p> 
<h3><strong><strong><strong>1.4 传输速度</strong></strong></strong></h3> 
<p style="margin-left:0pt;">这个我认为比较重要的，首先，我们我们提到传输速度，就会想到比特率（Bit/s）和波特率，比特率是从单位看就可以知道是指每秒传输二进制的位数，而波特率是指每秒传输的码元；这里的码元我们给具体化，大家都知道串口，他的数据以帧格式传输的，即一个起始位+8位数据位+1位奇偶位+1位结束位，那么这里时候，这11位加在一起就是一个码元，就是说多位算一个单位。</p> 
<h2><strong><strong><strong>2 串口通讯</strong></strong></strong></h2> 
<p style="margin-left:0pt;">在我看来，通讯都分为物理接口和软件时序（物理层和协议层），掌握这两，就可以基本掌握一种通讯方式，物理层主要还是电压特性，数据位高低的电压；协议层主要就是数据传输的规则</p> 
<h3><strong><strong><strong>2.1 物理层</strong></strong></strong></h3> 
<p style="margin-left:0pt;">串口通信的物理层有很多标准，我们一般有两种电平标准，TTL标准和RS485标准</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fd/8b/BzDheCeX_o.png"></p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">这里呢，我画个简易图吧，来表示电平的转换，其中设备时STM32,设备B是内一个STM32</p> 
<p style="text-align:center;"><img alt="" height="192" src="https://images2.imgbox.com/76/47/olhy9ePb_o.png" width="1200"></p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">USB转串口</p> 
<p style="margin-left:0pt;">当然，这里也可以用CH340</p> 
<p style="margin-left:0pt;">电平标准</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fd/cc/EJGsMzeu_o.png"></p> 
<p style="margin-left:0pt;"> </p> 
<h3><strong><strong><strong>2.2 协议层</strong></strong></strong></h3> 
<h4><strong><strong><strong>2.2.1串口的数据传输的帧格式</strong></strong></strong></h4> 
<p style="margin-left:0pt;">1位起始位+6/7/8位数据位+1位奇偶位+1位结束位（可以不要校验位）</p> 
<p style="margin-left:0pt;">也就是说数据就按照这种格式发送出去的，这样比直接发送数据位更加的准确和安全</p> 
<p style="margin-left:0pt;">但是在两个设备进行串口通信的时候，要注意的就是他们的波特率要相同，因为他是异步的没有时钟，所以两个设备发送接收之前必须约定好波特率</p> 
<h2><strong><strong><strong>3 </strong></strong><strong><strong>USART </strong></strong></strong></h2> 
<h3><strong><strong><strong>3.1 </strong></strong><strong><strong>USART</strong></strong><strong><strong>的简单介绍</strong></strong></strong></h3> 
<p style="margin-left:0pt;">（1）串口是串行异步全双工的以这种通信方式</p> 
<p style="margin-left:0pt;">（2）串口的数据传输是通过两根数据线传输，即RX、TX，发送和接收</p> 
<p style="margin-left:0pt;">（3）USART 支持使用 DMA </p> 
<p style="margin-left:0pt;">（4）我们在用USART最多的还是printf的作用，即用来上位机的调试</p> 
<h3><strong><strong><strong>3.2 </strong></strong><strong><strong>USART</strong></strong><strong><strong>的功能框图</strong></strong></strong></h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/99/7e/SIGQwQLk_o.png"></p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;"> </p> 
<h4><strong><strong><strong>3.3.2 </strong></strong><strong><strong>①功能引脚 </strong></strong></strong></h4> 
<p style="margin-left:0pt;">我们能看到的就是外部引脚</p> 
<p style="margin-left:0pt;"><span style="color:#000000;">TX</span><span style="color:#000000;">：发送数据输出引脚。</span><br><span style="color:#000000;">RX</span><span style="color:#000000;">：接收数据输入引脚。</span> </p> 
<p style="text-align:center;"><img alt="" height="179" src="https://images2.imgbox.com/c6/95/0cHpcQpF_o.png" width="961"></p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">STM32F103VET6 </span><span style="color:#000000;">系统控制器有三个 </span><span style="color:#000000;">USART </span><span style="color:#000000;">和两个 </span><span style="color:#000000;">UART</span><span style="color:#000000;">，其中 </span><span style="color:#000000;">USART1 </span><span style="color:#000000;">和时钟来源于 </span><span style="color:#000000;">APB2 </span><span style="color:#000000;">总线时钟，其最大频率为 </span><span style="color:#000000;">72MHz</span><span style="color:#000000;">，其他四个的时钟来源于 </span><span style="color:#000000;">APB1 </span><span style="color:#000000;">总线时钟，其最大频率为 </span><span style="color:#000000;">36MHz</span><span style="color:#000000;">。 </span></p> 
<h4><strong><strong><strong>3.3.3 </strong></strong><strong><strong>②数据寄存器 </strong></strong></strong></h4> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">（1）数据字长</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">USART数据寄存器USART_DR只有低9位有效，其他位数保留，并且第 </span><span style="color:#000000;">9 </span><span style="color:#000000;">位数据是否有效要取决于</span><span style="color:#000000;">USART </span><span style="color:#000000;">控制寄存器 </span><span style="color:#000000;">1(USART_CR1)</span><span style="color:#000000;">的 </span><span style="color:#000000;">M </span><span style="color:#000000;">位设置，当 </span><span style="color:#000000;">M </span><span style="color:#000000;">位为 </span><span style="color:#000000;">0 </span><span style="color:#000000;">时表示 </span><span style="color:#000000;">8 </span><span style="color:#000000;">位数据字长，当 </span><span style="color:#000000;">M</span><span style="color:#000000;">位为 </span><span style="color:#000000;">1 </span><span style="color:#000000;">表示 </span><span style="color:#000000;">9 </span><span style="color:#000000;">位数据字长，我们一般使用 </span><span style="color:#000000;">8 </span><span style="color:#000000;">位数据字长。</span></p> 
<ol><li><span style="color:#000000;">接收和发送数据都是存在USART_DR</span></li></ol> 
<p style="margin-left:0pt;"><span style="color:#000000;">USART_DR </span><span style="color:#000000;">包含了已发送的数据或者接收到的数据。 </span><span style="color:#000000;">USART_DR </span><span style="color:#000000;">实际是包含了两个寄存器，一个专门用于发送的可写 </span><span style="color:#0000ff;">TDR</span><span style="color:#000000;">，一个专门用于接收的可读</span> <span style="color:#0000ff;">RDR</span><span style="color:#000000;">。当进行发送操作时，往 </span><span style="color:#000000;">USART_DR </span><span style="color:#000000;">写入数据会自动存储在 </span><span style="color:#000000;">TDR </span><span style="color:#000000;">内；当进行读取操作时，向 </span><span style="color:#000000;">USART_DR</span><span style="color:#000000;">读取数据会自动提取 </span><span style="color:#000000;">RDR </span><span style="color:#000000;">数据。</span></p> 
<h4><strong><strong><strong>3.3.3 </strong></strong><strong><strong>③控制器 </strong></strong></strong></h4> 
<p style="margin-left:0pt;">（1）发送器</p> 
<p style="margin-left:0pt;"><span style="color:#000000;">名称 描述</span><br><span style="color:#000000;">TE </span><span style="color:#000000;">发送使能</span><br><span style="color:#000000;">TXE </span><span style="color:#000000;">发送寄存器为空，发送单个字节的时候使用</span><br><span style="color:#000000;">TC </span><span style="color:#000000;">发送完成，发送多个字节数据的时候使用</span><br><span style="color:#000000;">TXIE </span><span style="color:#000000;">发送完成中断使能</span> </p> 
<ol><li>接收器</li></ol> 
<p style="margin-left:0pt;"><span style="color:#000000;">名称 描述</span><br><span style="color:#000000;">RE </span><span style="color:#000000;">接收使能</span><br><span style="color:#000000;">RXNE </span><span style="color:#000000;">读数据寄存器非空</span><br><span style="color:#000000;">RXNEIE </span><span style="color:#000000;">发送完成中断使能</span> </p> 
<h4><strong><strong> </strong><strong><strong>3.3.4 </strong></strong><strong><strong>④小数波特率生成 </strong></strong></strong></h4> 
<p style="text-align:center;"><img alt="" height="136" src="https://images2.imgbox.com/6f/1d/TLcBqWWl_o.png" width="410"></p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">我们在设置波特率的时候，其实也就是计算出USARTDIV然后把它放到波特率寄存器中（BRR），这个寄存器一共是32位，其中高16位保留了，低16位中，最低4位是保存小数的，其他12位是保存整数部分。那么我们举个例子，我们要设置115200，</p> 
<p style="text-align:center;"><img alt="" height="63" src="https://images2.imgbox.com/9b/8f/69pWCmki_o.png" width="218"></p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">解 得 </span><span style="color:#000000;">USARTDIV=39.0625 </span><span style="color:#000000;">， 可 算 得 </span><span style="color:#000000;">DIV_Fraction=0.0625*16=1=0x01 </span><span style="color:#000000;">，</span><br><span style="color:#000000;">DIV_Mantissa=39=0x17</span><span style="color:#000000;">，即应该设置 </span><span style="color:#000000;">USART_BRR </span><span style="color:#000000;">的值为 </span><span style="color:#000000;">0x171</span><span style="color:#000000;">。</span> </p> 
<p style="margin-left:0pt;">float usartdiv=72000000/(brr*16);</p> 
<p style="margin-left:0pt;">mantissa=(u32)usartdiv;</p> 
<p style="margin-left:0pt;">fraction=(usartdiv-mantissa)*16+0.5f;</p> 
<p style="margin-left:0pt;">USART1-&gt;BRR =mantissa&lt;&lt;4|fraction;</p> 
<h4><strong><strong><strong>3.3.5 校验控制</strong></strong></strong></h4> 
<p style="margin-left:0pt;"><span style="color:#000000;">STM32F103 </span><span style="color:#000000;">系列控制器 </span><span style="color:#000000;">USART </span><span style="color:#000000;">支持奇偶校验。当使用校验位时，串口传输的长度将是 </span><span style="color:#000000;">8 </span><span style="color:#000000;">位的数据帧加上 </span><span style="color:#000000;">1 </span><span style="color:#000000;">位的校验位总共 </span><span style="color:#000000;">9 </span><span style="color:#000000;">位，此时 </span><span style="color:#000000;">USART_CR1 </span><span style="color:#000000;">寄存器的 </span><span style="color:#000000;">M </span><span style="color:#000000;">位需要设置为</span><span style="color:#000000;">1</span><span style="color:#000000;">，即 </span><span style="color:#000000;">9 </span><span style="color:#000000;">数据位。将 </span><span style="color:#000000;">USART_CR1 </span><span style="color:#000000;">寄存器的 </span><span style="color:#000000;">PCE </span><span style="color:#000000;">位置 </span><span style="color:#000000;">1 </span><span style="color:#000000;">就可以启动奇偶校验控制，奇偶校验由硬件自动完成。启动了奇偶校验控制之后，在发送数据帧时会自动添加校验位，接收数据时自动验证校验位。接收数据时如果出现奇偶校验位验证失败，会见 </span><span style="color:#000000;">USART_SR </span><span style="color:#000000;">寄存器的 </span><span style="color:#000000;">PE </span><span style="color:#000000;">位置 </span><span style="color:#000000;">1</span><span style="color:#000000;">，并可以产生奇偶校验中断</span><span style="color:#000000;">。</span></p> 
<h4><strong><strong><strong>3.3.6 中断控制</strong></strong></strong></h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2a/31/4FRHgWvo_o.png"></p> 
<p style="margin-left:0pt;"> </p> 
<h3><strong><strong><strong>3.4 库函数结构体分析</strong></strong></strong></h3> 
<p style="margin-left:0pt;"><span style="color:#2b91af;">typedef </span><span style="color:#0000ff;">struct </span><span style="color:#000000;">{<!-- --></span><br><span style="color:#2b91af;">2 </span><span style="color:#0000ff;">uint32_t </span><span style="color:#000000;">USART_BaudRate; </span><span style="color:#008000;">// </span><span style="color:#008000;">波特率</span><br><span style="color:#2b91af;">3 </span><span style="color:#0000ff;">uint16_t </span><span style="color:#000000;">USART_WordLength; </span><span style="color:#008000;">// </span><span style="color:#008000;">字长</span><br><span style="color:#2b91af;">4 </span><span style="color:#0000ff;">uint16_t </span><span style="color:#000000;">USART_StopBits; </span><span style="color:#008000;">// </span><span style="color:#008000;">停止位</span><br><span style="color:#2b91af;">5 </span><span style="color:#0000ff;">uint16_t </span><span style="color:#000000;">USART_Parity; </span><span style="color:#008000;">// </span><span style="color:#008000;">校验位</span><br><span style="color:#2b91af;">6 </span><span style="color:#0000ff;">uint16_t </span><span style="color:#000000;">USART_Mode; </span><span style="color:#008000;">// USART </span><span style="color:#008000;">模式</span><br><span style="color:#2b91af;">7 </span><span style="color:#0000ff;">uint16_t </span><span style="color:#000000;">USART_HardwareFlowControl; </span><span style="color:#008000;">// </span><span style="color:#008000;">硬件流控制</span><br><span style="color:#2b91af;">8 </span><span style="color:#000000;">} USART_InitTypeDef;</span> </p> 
<p style="margin-left:0pt;">这里就不多说了，大家自己跳进去就知道选择什么了</p> 
<h3><strong><strong><strong>3.5 编程(F4)</strong></strong></strong></h3> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">使用库函数操作<br>         首先，配置NVIC使用NVIC_PriorityGroupConfig()设置优先级分组，使用NVIC_Init()对NVIC进行初始化</p> 
<ol><li>void NVIC_Config()</li><li>{<!-- --></li><li>    NVIC_InitTypeDef NVIC_InitStructure;</li><li>    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</li><li>    </li><li>   NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x03;</li><li>    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02;</li><li>    NVIC_InitStructure.NVIC_IRQChannel  = USART1_IRQn;</li><li>    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</li><li>        </li><li>    NVIC_Init(&amp;NVIC_InitStructure);</li><li>}</li></ol> 
<p style="margin-left:0pt;">第二步：配置引脚功能，因为我的板子上PA9被用来驱动LED了，所以只能将将串口映射到PB6，PB7。这个设置跟F1系列的有点差别。首先初始化端口时钟，第二配置端口引脚功能，第三不设置功能映射将串口连接到引脚。</p> 
<ol><li>void USART_Gpio_Config(void)</li><li>{<!-- --></li><li>    GPIO_InitTypeDef GPIO_InitStructure;</li><li>    </li><li>    RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOB  , ENABLE);</li><li>    </li><li>    //PB6-&gt;TX  PB7-&gt;Rx</li><li>    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;</li><li>    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;</li><li>    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</li><li>    GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</li><li>    </li><li>    GPIO_PinAFConfig(GPIOB,GPIO_PinSource6,GPIO_AF_USART1);</li><li>    GPIO_PinAFConfig(GPIOB,GPIO_PinSource7,GPIO_AF_USART1);</li><li>}</li></ol> 
<p style="margin-left:0pt;">第三步：配置串口工作方式。步骤也差不多：打开时钟，用Init函数初始化串口，设置串口的接收中断，最后别忘了使能串口。</p> 
<ol><li>void USART_Config(void)</li><li>{<!-- --></li><li>        USART_Gpio_Config();</li><li>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);</li><li>    </li><li>    USART_InitStructure.USART_BaudRate = 115200;</li><li>    USART_InitStructure.USART_WordLength = USART_WordLength_8b;</li><li>    USART_InitStructure.USART_StopBits = USART_StopBits_1;</li><li>    USART_InitStructure.USART_Parity = USART_Parity_No;</li><li>    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</li><li>    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;</li><li>    </li><li>    USART_Init(USART1,&amp;USART_InitStructure);   </li><li>    USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);</li><li>    </li><li>    USART_Cmd(USART1,ENABLE);</li><li>    </li><li>}</li></ol> 
<p style="margin-left:0pt;">第四步：添加串口中断函数，函数名是固定的：void USART1_IRQHandler(void)。中断进入时候，先判断接收寄存器是否有数据，有数据时候就接收，然后使用USART_SendData()将数据发回</p> 
<ol><li>void USART1_IRQHandler(void)</li><li>{<!-- --></li><li>    char c;</li><li>    if(USART_GetFlagStatus(USART1,USART_FLAG_RXNE)==SET)</li><li>    {<!-- --></li><li>        c = USART_ReceiveData(USART1);</li><li>        USART_SendData(USART1,c);</li><li>    }</li><li>        //while(1);</li><li>}</li></ol> 
<p style="margin-left:0pt;">最后就是main了，没啥可说的</p> 
<ol><li>int main(void)</li><li>{<!-- --></li><li>    NVIC_Config();</li><li>    USART_Config();</li><li>    while(1)</li><li>    {<!-- --></li><li>        while(RESET == USART_GetFlagStatus(USART1,USART_FLAG_TXE));</li><li>        USART_SendData(USART1,'b');</li><li>        while(RESET == USART_GetFlagStatus(USART1,USART_FLAG_TXE));</li><li>        USART_SendData(USART1,'a');</li><li>        delay_ms(1000);</li><li>    }</li><li>} </li></ol> 
<ol><li><strong><strong><strong>我们在来谈谈SPI吧</strong></strong></strong></li></ol> 
<p style="margin-left:0pt;">学习SPI最快的方式就是先先搞清外设的各个引脚即物理结构，在就是搞清通信协议即时序。但是这里我们稍微扎实点，我们得先研究SPI的架构。</p> 
<ol><li> 
  <ol><li><strong><strong><strong>简介：</strong></strong></strong></li></ol></li></ol> 
<p style="margin-left:0pt;">SPI是高速串行全双工同步通信；</p> 
<p style="margin-left:0pt;">他的优势在于速度块、能够实现一对多的通信</p> 
<ol><li> 
  <ol><li><strong><strong><strong>物理接口</strong></strong></strong></li></ol></li></ol> 
<p style="margin-left:0pt;">一个4个引脚；</p> 
<p style="margin-left:0pt;">SS(CS):从设备选择(如果多个从设备的话，也就是靠这个引脚来选择的)</p> 
<p style="margin-left:0pt;">CLK:时钟信号线</p> 
<p style="margin-left:0pt;">SDI(MISO):主机输入，从机输出</p> 
<p style="margin-left:0pt;">SDO(MOSI):主机输出，从机输入</p> 
<ol><li> 
  <ol><li><strong><strong><strong>时序</strong></strong></strong></li></ol></li></ol> 
<p style="margin-left:0pt;"><span style="color:#000000;">SPI </span><span style="color:#000000;">工作方式：</span><br><span style="color:#ff0000;">SPI0:</span><span style="color:#000000;">CPOL=0;CPHA=0;</span><br><span style="color:#000000;">空闲状态低电平， 上升沿数据被采样， 下降沿数据输出</span><br><span style="color:#ff0000;">SPI1:</span><span style="color:#000000;">CPOL=0;CPHA=1;</span><br><span style="color:#000000;">空闲状态低电平， 下降沿数据被采样， 上升沿数据输出</span><br><span style="color:#ff0000;">SPI2:</span><span style="color:#000000;">CPOL=1;CPHA=0;</span><br><span style="color:#000000;">空闲状态高电平， 下降沿数据被采样， 上升沿数据输出</span><br><span style="color:#ff0000;">SPI3:</span><span style="color:#000000;">CPOL=1;CPHA=1;</span><br><span style="color:#000000;">空闲状态高电平， 上升沿数据被采样， 下降沿数据输出</span><br><span style="color:#000000;">SPI0 </span><span style="color:#000000;">和 </span><span style="color:#000000;">SPI3 </span><span style="color:#000000;">时序相同的</span><br><span style="color:#000000;">SPI1 </span><span style="color:#000000;">和 </span><span style="color:#000000;">SPI2 </span><span style="color:#000000;">时序相同的</span><br><span style="color:#000000;">工作方式的选择： 取决于从设备</span> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/80/f1/3Zaz5NOL_o.png"></p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">在时钟的上升沿开始1位数据的采集，在下降沿结束1位数据的采集，但是这里有个另外，就是对于开始的第一位数据的开始，在第一个上升沿来临之前就开始采集。</p> 
<p style="margin-left:0pt;">这里对于主机来说，发送和接收数据时同步的，在同一个时钟下</p> 
<ol><li> 
  <ol><li><strong><strong><strong>库函数结构体讲解</strong></strong></strong></li></ol></li></ol> 
<p style="margin-left:0pt;"><span style="color:#2b91af;">1 typedef </span><span style="color:#0000ff;">struct</span><br><span style="color:#2b91af;">2 </span><span style="color:#000000;">{<!-- --></span><br><span style="color:#2b91af;">3 </span><span style="color:#0000ff;">uint16_t </span><span style="color:#000000;">SPI_Direction; </span><span style="color:#008000;">/*</span><span style="color:#008000;">设置 </span><span style="color:#008000;">SPI </span><span style="color:#008000;">的单双向模式 </span><span style="color:#008000;">*/</span><br><span style="color:#2b91af;">4 </span><span style="color:#0000ff;">uint16_t </span><span style="color:#000000;">SPI_Mode; </span><span style="color:#008000;">/*</span><span style="color:#008000;">设置 </span><span style="color:#008000;">SPI </span><span style="color:#008000;">的主</span><span style="color:#008000;">/</span><span style="color:#008000;">从机端模式 </span><span style="color:#008000;">*/</span><br><span style="color:#2b91af;">5 </span><span style="color:#0000ff;">uint16_t </span><span style="color:#000000;">SPI_DataSize; </span><span style="color:#008000;">/*</span><span style="color:#008000;">设置 </span><span style="color:#008000;">SPI </span><span style="color:#008000;">的数据帧长度，可选 </span><span style="color:#008000;">8/16 </span><span style="color:#008000;">位 </span><span style="color:#008000;">*/</span><br><span style="color:#2b91af;">6 </span><span style="color:#0000ff;">uint16_t </span><span style="color:#000000;">SPI_CPOL; </span><span style="color:#008000;">/*</span><span style="color:#008000;">设置时钟极性 </span><span style="color:#008000;">CPOL</span><span style="color:#008000;">，可选高</span><span style="color:#008000;">/</span><span style="color:#008000;">低电平</span><span style="color:#008000;">*/</span><br><span style="color:#2b91af;">7 </span><span style="color:#0000ff;">uint16_t </span><span style="color:#000000;">SPI_CPHA; </span><span style="color:#008000;">/*</span><span style="color:#008000;">设置时钟相位，可选奇</span><span style="color:#008000;">/</span><span style="color:#008000;">偶数边沿采样 </span><span style="color:#008000;">*/</span><br><span style="color:#2b91af;">8 </span><span style="color:#0000ff;">uint16_t </span><span style="color:#000000;">SPI_NSS; </span><span style="color:#008000;">/*</span><span style="color:#008000;">设置 </span><span style="color:#008000;">NSS </span><span style="color:#008000;">引脚由 </span><span style="color:#008000;">SPI </span><span style="color:#008000;">硬件控制还是软件控制</span><span style="color:#008000;">*/</span><br><span style="color:#2b91af;">9 </span><span style="color:#0000ff;">uint16_t </span><span style="color:#000000;">SPI_BaudRatePrescaler; </span><span style="color:#008000;">/*</span><span style="color:#008000;">设置时钟分频因子， </span><span style="color:#008000;">fpclk/</span><span style="color:#008000;">分频数</span><span style="color:#008000;">=fSCK */</span><br><span style="color:#2b91af;">10 </span><span style="color:#0000ff;">uint16_t </span><span style="color:#000000;">SPI_FirstBit; </span><span style="color:#008000;">/*</span><span style="color:#008000;">设置 </span><span style="color:#008000;">MSB/LSB </span><span style="color:#008000;">先行 </span><span style="color:#008000;">*/</span><br><span style="color:#2b91af;">11 </span><span style="color:#0000ff;">uint16_t </span><span style="color:#000000;">SPI_CRCPolynomial; </span><span style="color:#008000;">/*</span><span style="color:#008000;">设置 </span><span style="color:#008000;">CRC </span><span style="color:#008000;">校验的表达式 </span><span style="color:#008000;">*/</span><br><span style="color:#2b91af;">12 </span><span style="color:#000000;">} SPI_InitTypeDef;</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">SPI_Direction</span> ：<span style="color:#000000;">本成员设置 </span><span style="color:#000000;">SPI </span><span style="color:#000000;">的通讯方向，可设置为双线全双工</span><span style="color:#000000;">(SPI_Direction_2Lines_FullDuplex)</span><span style="color:#000000;">，双线只接收</span><span style="color:#000000;">(SPI_Direction_2Lines_RxOnly)</span><span style="color:#000000;">，单线只接收</span><span style="color:#000000;">(SPI_Direction_1Line_Rx)</span><span style="color:#000000;">、单线只发送模式</span><span style="color:#000000;">(SPI_Direction_1Line_Tx)</span><span style="color:#000000;">。</span> 这里我们一般设置位双线全双工</p> 
<p style="margin-left:0pt;"><span style="color:#000000;">SPI_Mode</span> ：<span style="color:#000000;">本成员设置 </span><span style="color:#000000;">SPI </span><span style="color:#000000;">工作在主机模式</span><span style="color:#000000;">(SPI_Mode_Master)</span><span style="color:#000000;">或从机模式</span><span style="color:#000000;">(SPI_Mode_Slave )</span><span style="color:#000000;">，这两个模式的最大区别为 </span><span style="color:#000000;">SPI </span><span style="color:#000000;">的 </span><span style="color:#0000ff;">SCK </span><span style="color:#0000ff;">信号线的时序</span><span style="color:#000000;">， </span><span style="color:#0000ff;">SCK </span><span style="color:#0000ff;">的时序是由通讯中的主机产生的</span><span style="color:#000000;">。若被配置为从机模式， </span><span style="color:#000000;">STM32 </span><span style="color:#000000;">的 </span><span style="color:#000000;">SPI </span><span style="color:#000000;">外设将接受外来的 </span><span style="color:#000000;">SCK </span><span style="color:#000000;">信号。</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">SPI_DataSize</span> ：<span style="color:#000000;">本成员可以选择 </span><span style="color:#000000;">SPI </span><span style="color:#000000;">通讯的数据帧大小是为 </span><span style="color:#000000;">8 </span><span style="color:#000000;">位 </span><span style="color:#000000;">(SPI_DataSize_8b)</span><span style="color:#000000;">还是 </span><span style="color:#000000;">16 </span><span style="color:#000000;">位</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">SPI_CPOL </span><span style="color:#000000;">和 </span><span style="color:#000000;">SPI_CPHA</span> ：<span style="color:#000000;">时钟极性 </span><span style="color:#000000;">CPOL </span><span style="color:#000000;">成员，可设置为高电平</span><span style="color:#000000;">(SPI_CPOL_High)</span><span style="color:#000000;">或低电平</span><span style="color:#000000;">(SPI_CPOL_Low )</span><span style="color:#000000;">。</span><br><span style="color:#000000;">时钟相位 </span><span style="color:#000000;">CPHA </span><span style="color:#000000;">则可以设置为 </span><span style="color:#000000;">SPI_CPHA_1Edge(</span><span style="color:#000000;">在 </span><span style="color:#000000;">SCK </span><span style="color:#000000;">的奇数边沿采集数据</span><span style="color:#000000;">) </span><span style="color:#000000;">或</span><span style="color:#000000;">SPI_CPHA_2Edge (</span><span style="color:#000000;">在 </span><span style="color:#000000;">SCK </span><span style="color:#000000;">的偶数边沿采集数据</span><span style="color:#000000;">) </span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">SPI_NSS</span> ：<span style="color:#000000;">本成员配置 </span><span style="color:#000000;">NSS </span><span style="color:#000000;">引脚的使用模式，可以选择为硬件模式</span><span style="color:#000000;">(SPI_NSS_Hard )</span><span style="color:#000000;">与软件模式</span><br><span style="color:#000000;">(SPI_NSS_Soft )</span><span style="color:#000000;">，在硬件模式中的 </span><span style="color:#000000;">SPI </span><span style="color:#000000;">片选信号由 </span><span style="color:#000000;">SPI </span><span style="color:#000000;">硬件自动产生，而软件模式则需要我们亲自把相应的 </span><span style="color:#000000;">GPIO </span><span style="color:#000000;">端口拉高或置低产生非片选和片选信号。实际中软件模式应用比较多。</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">SPI_BaudRatePrescaler</span> ：<span style="color:#000000;">本成员设置波特率分频因子，分频后的时钟即为 </span><span style="color:#000000;">SPI </span><span style="color:#000000;">的 </span><span style="color:#000000;">SCK </span><span style="color:#000000;">信号线的时钟频率。这个成员参数可设置为 </span><span style="color:#000000;">fpclk </span><span style="color:#000000;">的 </span><span style="color:#000000;">2</span><span style="color:#000000;">、 </span><span style="color:#000000;">4</span><span style="color:#000000;">、 </span><span style="color:#000000;">6</span><span style="color:#000000;">、 </span><span style="color:#000000;">8</span><span style="color:#000000;">、 </span><span style="color:#000000;">16</span><span style="color:#000000;">、 </span><span style="color:#000000;">32</span><span style="color:#000000;">、 </span><span style="color:#000000;">64</span><span style="color:#000000;">、 </span><span style="color:#000000;">128</span><span style="color:#000000;">、 </span><span style="color:#000000;">256 </span><span style="color:#000000;">分频。</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">SPI_FirstBit</span> ：<span style="color:#000000;">所有串行的通讯协议都会有 </span><span style="color:#000000;">MSB </span><span style="color:#000000;">先行</span><span style="color:#000000;">(</span><span style="color:#000000;">高位数据在前</span><span style="color:#000000;">)</span><span style="color:#000000;">还是 </span><span style="color:#000000;">LSB </span><span style="color:#000000;">先行</span><span style="color:#000000;">(</span><span style="color:#000000;">低位数据在前</span><span style="color:#000000;">)</span><span style="color:#000000;">的问题，而 </span><span style="color:#000000;">STM32 </span><span style="color:#000000;">的 </span><span style="color:#000000;">SPI </span><span style="color:#000000;">模块可以通过这个结构体成员，对这个特性编程控制。</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">SPI_CRCPolynomial</span> ：<span style="color:#000000;">这是 </span><span style="color:#000000;">SPI </span><span style="color:#000000;">的 </span><span style="color:#000000;">CRC </span><span style="color:#000000;">校验中的多项式，若我们使用 </span><span style="color:#000000;">CRC </span><span style="color:#000000;">校验时，就使用这个成员的参数</span><span style="color:#000000;">(</span><span style="color:#000000;">多项式</span><span style="color:#000000;">)</span><span style="color:#000000;">，来计算 </span><span style="color:#000000;">CRC </span><span style="color:#000000;">的值</span>   </p> 
<ol><li> 
  <ol><li><strong><strong><strong>编程</strong></strong></strong></li></ol></li></ol> 
<p style="margin-left:0pt;">SPI是一种通信方式，主要就是读写数据的，我们我们需要先配置好SPI模式，然后在整个单字节的读写函数，然后，这个基本工作做过后后面就是看从设备自己时序了（也就是自己的规则）</p> 
<p style="margin-left:0pt;">void spi_Config(void)</p> 
<p style="margin-left:0pt;">{<!-- --></p> 
<p style="margin-left:0pt;">GPIO_InitTypeDef GPIOInitStructures;</p> 
<p style="margin-left:0pt;">SPI_InitTypeDef SPIInitStructures;</p> 
<p style="margin-left:0pt;">//打开时钟</p> 
<p style="margin-left:0pt;">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB|RCC_APB2Periph_SPI1,ENABLE);</p> 
<p style="margin-left:0pt;">//配置时钟--PA5 MOSI--PA7</p> 
<p style="margin-left:0pt;">GPIOInitStructures.GPIO_Pin=GPIO_Pin_5|GPIO_Pin_7;</p> 
<p style="margin-left:0pt;">GPIOInitStructures.GPIO_Mode=GPIO_Mode_AF_PP;</p> 
<p style="margin-left:0pt;">GPIOInitStructures.GPIO_Speed=GPIO_Speed_10MHz;</p> 
<p style="margin-left:0pt;">GPIO_Init(GPIOA,&amp;GPIOInitStructures);</p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">//配置miso--pa6</p> 
<p style="margin-left:0pt;">GPIOInitStructures.GPIO_Pin=GPIO_Pin_6;</p> 
<p style="margin-left:0pt;">GPIOInitStructures.GPIO_Mode=GPIO_Mode_IN_FLOATING;</p> 
<p style="margin-left:0pt;">GPIO_Init(GPIOA,&amp;GPIOInitStructures);</p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">//配置片选 PB0</p> 
<p style="margin-left:0pt;">GPIOInitStructures.GPIO_Pin=GPIO_Pin_0;</p> 
<p style="margin-left:0pt;">GPIOInitStructures.GPIO_Mode=GPIO_Mode_Out_PP;</p> 
<p style="margin-left:0pt;">GPIOInitStructures.GPIO_Speed=GPIO_Speed_10MHz;</p> 
<p style="margin-left:0pt;">GPIO_Init(GPIOB,&amp;GPIOInitStructures);</p> 
<p style="margin-left:0pt;">SPI1_CS(1);</p> 
<p style="margin-left:0pt;">//配置SPI1</p> 
<p style="margin-left:0pt;">SPIInitStructures.SPI_BaudRatePrescaler=SPI_BaudRatePrescaler_128;</p> 
<p style="margin-left:0pt;">SPIInitStructures.SPI_CPHA=SPI_CPHA_2Edge;</p> 
<p style="margin-left:0pt;">SPIInitStructures.SPI_CPOL=SPI_CPOL_High;</p> 
<p style="margin-left:0pt;">SPIInitStructures.SPI_CRCPolynomial=7;</p> 
<p style="margin-left:0pt;">SPIInitStructures.SPI_DataSize=SPI_DataSize_8b;</p> 
<p style="margin-left:0pt;">SPIInitStructures.SPI_Direction=SPI_Direction_2Lines_FullDuplex;</p> 
<p style="margin-left:0pt;">SPIInitStructures.SPI_FirstBit=SPI_FirstBit_MSB;</p> 
<p style="margin-left:0pt;">SPIInitStructures.SPI_Mode=SPI_Mode_Master;</p> 
<p style="margin-left:0pt;">SPIInitStructures.SPI_NSS=SPI_NSS_Soft;</p> 
<p style="margin-left:0pt;">SPI_Init(SPI1,&amp;SPIInitStructures);</p> 
<p style="margin-left:0pt;">SPI_Cmd(SPI1,ENABLE);</p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">}</p> 
<p style="margin-left:0pt;">/**************************************</p> 
<p style="margin-left:0pt;">函数名:</p> 
<p style="margin-left:0pt;">函数功能:单字节读写函数</p> 
<p style="margin-left:0pt;">备注:</p> 
<p style="margin-left:0pt;">日期:</p> 
<p style="margin-left:0pt;">**************************************/</p> 
<p style="margin-left:0pt;">u8 spi_ReadorWrite(u8 data)</p> 
<p style="margin-left:0pt;">{<!-- --></p> 
<p style="margin-left:0pt;">while(!SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_TXE));//等待发送缓存区为空</p> 
<p style="margin-left:0pt;">SPI_I2S_SendData(SPI1,data);</p> 
<p style="margin-left:0pt;">while(!SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_RXNE));</p> 
<p style="margin-left:0pt;">return SPI_I2S_ReceiveData(SPI1);</p> 
<p style="margin-left:0pt;">}</p> 
<ol><li><strong><strong><strong>我们来简单的谈谈IIC</strong></strong></strong></li></ol> 
<p style="margin-left:0pt;">同样还是从两个方面来描述，物理层和协议层</p> 
<ol><li> 
  <ol><li><strong><strong><strong>简介：</strong></strong></strong></li></ol></li></ol> 
<p style="margin-left:0pt;">他的有点就是引脚少，占用IO资源少，硬件实现也简单不少</p> 
<p style="margin-left:0pt;">串行半双工同步通信</p> 
<ol><li> 
  <ol><li><strong><strong><strong>物理层</strong></strong></strong> <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/bb/83/UzJVkye1_o.png"></p> </li></ol></li></ol> 
<p style="margin-left:0pt;"> </p> 
<ol><li>他是总线，即它可以接入多个从设备</li><li>它只有两根线，即时钟线（SCL）,数据线（SDA）,但是它同一时间只有做发送或者接收线</li><li>每个连接到总线的设备，都要支持IIC，即有自己的设备地址，主机就是靠这个来区别不同的设备的</li><li>总线通过上拉电阻接到电源，即当空闲时，是高电平</li><li><span style="color:#000000;">多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。</span> </li><li><span style="color:#000000;">具有三种传输模式：标准模式传输速率为 </span><span style="color:#000000;">100kbit/s </span><span style="color:#000000;">，快速模式为 </span><span style="color:#000000;">400kbit/s </span><span style="color:#000000;">，高速模式下可达 </span><span style="color:#000000;">3.4Mbit/s</span><span style="color:#000000;">，但目前大多 </span><span style="color:#000000;">I</span><span style="color:#000000;">2</span><span style="color:#000000;">C </span><span style="color:#000000;">设备尚不支持高速模式</span>  
  <ol><li><strong><strong><strong>协议层</strong></strong></strong> <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/81/08/k1fz2MIY_o.png"></p> </li></ol></li></ol> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">这个就是IIC的通信协议，我们分开来解析下</p> 
<p style="margin-left:0pt;">（1）首先，起始信号：<span style="color:#000000;">L </span><span style="color:#000000;">线是高电平时 </span><span style="color:#000000;">SDA </span><span style="color:#000000;">线从高电平向低电平切换，这个情况表示通讯的起始。</span> 起始信号开始后，所以的设备都在那个等待</p> 
<p style="text-align:center;"><img alt="" height="251" src="https://images2.imgbox.com/2c/4d/UNEYWpP8_o.png" width="226"></p> 
<p> </p> 
<p style="margin-left:0pt;"> </p> 
<ol><li>然后，主机发送7位的地址，来选择从机。</li><li>然后，会有一位的读写位来控制是读数据还是写数据</li><li>在然后呢，会有一位的响应信号，然后主机会等待从机的响应，也就是从机把电平拉低才会开始接收数据，然后开始读取数据，并产生个应答或者非应答信号，最后来个结束信号 
  <ol><li><strong><strong><strong>模拟IIC</strong></strong></strong></li></ol></li></ol> 
<p style="margin-left:0pt;">下面是模拟的IIC配置，改改SCL和SDL引脚就可以用啦</p> 
<p style="margin-left:0pt;">#include "iic.h"</p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">//PB8 SCL  PB9 SDA</p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">void IIC_Init(void)</p> 
<p style="margin-left:0pt;">{<!-- --></p> 
<p style="margin-left:0pt;">RCC-&gt;AHB1ENR|=1&lt;&lt;1;    //使能PORTB时钟       </p> 
<p style="margin-left:0pt;">//PB8输出 PB9推挽</p> 
<p style="margin-left:0pt;">GPIOB-&gt;MODER &amp;=~ (0xf&lt;&lt;16);</p> 
<p style="margin-left:0pt;">GPIOB-&gt;MODER |=  (0x5&lt;&lt;16);//通用</p> 
<p style="margin-left:0pt;">GPIOB-&gt;OTYPER &amp;=~ (3&lt;&lt;8);//推挽</p> 
<p style="margin-left:0pt;">GPIOB-&gt;OSPEEDR &amp;=~ (0xf&lt;&lt;16);</p> 
<p style="margin-left:0pt;">GPIOB-&gt;OSPEEDR |=  (0xf&lt;&lt;16);//高速</p> 
<p style="margin-left:0pt;">GPIOB-&gt;PUPDR &amp;=~ (0xf&lt;&lt;16);</p> 
<p style="margin-left:0pt;">GPIOB-&gt;PUPDR |=  (0x5&lt;&lt;16);//上拉</p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">IIC_SCL(1);</p> 
<p style="margin-left:0pt;">IIC_SDA(1);</p> 
<p style="margin-left:0pt;">}</p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">//产生IIC起始信号</p> 
<p style="margin-left:0pt;">void IIC_Start(void)</p> 
<p style="margin-left:0pt;">{<!-- --></p> 
<p style="margin-left:0pt;">SDA_OUT();     //sda线输出</p> 
<p style="margin-left:0pt;">IIC_SDA(1);      </p> 
<p style="margin-left:0pt;">IIC_SCL(1);</p> 
<p style="margin-left:0pt;">Delay_us(4);</p> 
<p style="margin-left:0pt;">  IIC_SDA(0);//时钟线高，数据线拉低</p> 
<p style="margin-left:0pt;">Delay_us(4);</p> 
<p style="margin-left:0pt;">IIC_SCL(0);//钳住I2C总线，准备发送或接收数据</p> 
<p style="margin-left:0pt;">}   </p> 
<p style="margin-left:0pt;">//产生IIC停止信号</p> 
<p style="margin-left:0pt;">void IIC_Stop(void)</p> 
<p style="margin-left:0pt;">{<!-- --></p> 
<p style="margin-left:0pt;">SDA_OUT();//sda线输出</p> 
<p style="margin-left:0pt;">IIC_SCL(0);</p> 
<p style="margin-left:0pt;">IIC_SDA(0);//时钟线高，数据线拉高</p> 
<p style="margin-left:0pt;">  Delay_us(4);</p> 
<p style="margin-left:0pt;">IIC_SCL(1);</p> 
<p style="margin-left:0pt;">IIC_SDA(1);//发送I2C总线结束信号</p> 
<p style="margin-left:0pt;">Delay_us(4);    </p> 
<p style="margin-left:0pt;">}</p> 
<p style="margin-left:0pt;">//等待应答信号到来</p> 
<p style="margin-left:0pt;">//返回值：1，接收应答失败</p> 
<p style="margin-left:0pt;">//        0，接收应答成功</p> 
<p style="margin-left:0pt;">u8 IIC_Wait_Ack(void)</p> 
<p style="margin-left:0pt;">{<!-- --></p> 
<p style="margin-left:0pt;">u8 ucErrTime=0;</p> 
<p style="margin-left:0pt;">SDA_IN();      //SDA设置为输入  </p> 
<p style="margin-left:0pt;">IIC_SDA(1);Delay_us(1);    </p> 
<p style="margin-left:0pt;">IIC_SCL(1);Delay_us(1);  </p> 
<p style="margin-left:0pt;">while(READ_SDA())</p> 
<p style="margin-left:0pt;">{<!-- --></p> 
<p style="margin-left:0pt;">ucErrTime++;</p> 
<p style="margin-left:0pt;">if(ucErrTime&gt;250)</p> 
<p style="margin-left:0pt;">{<!-- --></p> 
<p style="margin-left:0pt;">IIC_Stop();</p> 
<p style="margin-left:0pt;">return 1;</p> 
<p style="margin-left:0pt;">}</p> 
<p style="margin-left:0pt;">}</p> 
<p style="margin-left:0pt;">IIC_SCL(0);//时钟输出0    </p> 
<p style="margin-left:0pt;">return 0;  </p> 
<p style="margin-left:0pt;">}</p> 
<p style="margin-left:0pt;">//主机产生ACK应答</p> 
<p style="margin-left:0pt;">void IIC_Ack(void)</p> 
<p style="margin-left:0pt;">{<!-- --></p> 
<p style="margin-left:0pt;">IIC_SCL(0);</p> 
<p style="margin-left:0pt;">SDA_OUT();</p> 
<p style="margin-left:0pt;">IIC_SDA(0);</p> 
<p style="margin-left:0pt;">Delay_us(2);</p> 
<p style="margin-left:0pt;">IIC_SCL(1);</p> 
<p style="margin-left:0pt;">Delay_us(2);</p> 
<p style="margin-left:0pt;">IIC_SCL(0);</p> 
<p style="margin-left:0pt;">}</p> 
<p style="margin-left:0pt;">//主机不产生ACK应答     </p> 
<p style="margin-left:0pt;">void IIC_NAck(void)</p> 
<p style="margin-left:0pt;">{<!-- --></p> 
<p style="margin-left:0pt;">IIC_SCL(0);</p> 
<p style="margin-left:0pt;">SDA_OUT();</p> 
<p style="margin-left:0pt;">IIC_SDA(1);</p> 
<p style="margin-left:0pt;">Delay_us(2);</p> 
<p style="margin-left:0pt;">IIC_SCL(1);</p> 
<p style="margin-left:0pt;">Delay_us(2);</p> 
<p style="margin-left:0pt;">IIC_SCL(0);</p> 
<p style="margin-left:0pt;">}        </p> 
<p style="margin-left:0pt;">//IIC发送一个字节</p> 
<p style="margin-left:0pt;">//返回从机有无应答</p> 
<p style="margin-left:0pt;">//1，有应答</p> 
<p style="margin-left:0pt;">//0，无应答   </p> 
<p style="margin-left:0pt;">void IIC_Send_Byte(u8 txd)</p> 
<p style="margin-left:0pt;">{                        </p> 
<p style="margin-left:0pt;">u8 t;   </p> 
<p style="margin-left:0pt;">SDA_OUT();     </p> 
<p style="margin-left:0pt;">IIC_SCL(0);//拉低时钟开始数据传输</p> 
<p style="margin-left:0pt;">for(t=0;t&lt;8;t++)</p> 
<p style="margin-left:0pt;">{              </p> 
<p style="margin-left:0pt;">IIC_SDA((txd&amp;0x80)&gt;&gt;7);     //先发高位</p> 
<p style="margin-left:0pt;">txd&lt;&lt;=1;   </p> 
<p style="margin-left:0pt;">Delay_us(2);   //对TEA5767这三个延时都是必须的</p> 
<p style="margin-left:0pt;">IIC_SCL(1);</p> 
<p style="margin-left:0pt;">Delay_us(2);</p> 
<p style="margin-left:0pt;">IIC_SCL(0);</p> 
<p style="margin-left:0pt;">Delay_us(2);</p> 
<p style="margin-left:0pt;">}  </p> 
<p style="margin-left:0pt;">}     </p> 
<p style="margin-left:0pt;">//读1个字节，ack=1时，发送ACK，ack=0，发送nACK   </p> 
<p style="margin-left:0pt;">u8 IIC_Read_Byte(unsigned char ack)</p> 
<p style="margin-left:0pt;">{<!-- --></p> 
<p style="margin-left:0pt;">unsigned char i,receive=0;</p> 
<p style="margin-left:0pt;">SDA_IN();//SDA设置为输入</p> 
<p style="margin-left:0pt;">for(i=0;i&lt;8;i++ )</p> 
<p style="margin-left:0pt;">{<!-- --></p> 
<p style="margin-left:0pt;">IIC_SCL(0);</p> 
<p style="margin-left:0pt;">Delay_us(2);</p> 
<p style="margin-left:0pt;">IIC_SCL(1);</p> 
<p style="margin-left:0pt;">receive&lt;&lt;=1;</p> 
<p style="margin-left:0pt;">if(READ_SDA())</p> 
<p style="margin-left:0pt;">receive++;   </p> 
<p style="margin-left:0pt;">Delay_us(1);</p> 
<p style="margin-left:0pt;">}  </p> 
<p style="margin-left:0pt;">if (!ack)</p> 
<p style="margin-left:0pt;">IIC_NAck();//发送nACK</p> 
<p style="margin-left:0pt;">else</p> 
<p style="margin-left:0pt;">IIC_Ack(); //发送ACK   </p> 
<p style="margin-left:0pt;">return receive;</p> 
<p style="margin-left:0pt;">}</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/85c26de1a38814609d2a6aa292425bb2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">EMNLP’19-Mask-Predict: Parallel Decoding of Conditional Masked Language Models</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/96ea80b7967d79776160966ac13ae2e2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uiscrollview  取消顶部默认间距</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>