<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>List移除元素 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="List移除元素" />
<meta property="og:description" content="List 移除某个元素 四种方式：
方式一，使用 Iterator ，顺序向下，如果找到元素，则使用 remove 方法进行移除。方式二，倒序遍历 List ，如果找到元素，则使用 remove 方法进行移除。方式三，正序遍历 List ，如果找到元素，则使用 remove 方法进行移除，然后进行索引 “自减”。方式四，使用jdk1.8新增的Stream流操作
1.Iterator 迭代器 @Test public void fun9(){ List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&#34;赵云&#34;); list.add(&#34;黄忠&#34;); list.add(&#34;马超&#34;); list.add(&#34;关羽&#34;); list.add(&#34;张飞&#34;); // 获取迭代器 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext()){ String str = it.next(); if(&#34;关羽&#34;.equals(str)){ it.remove(); } } System.out.println(list); } 2.倒序遍历
@Test public void fun10(){ List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&#34;赵云&#34;); list.add(&#34;黄忠&#34;); list.add(&#34;马超&#34;); list.add(&#34;关羽&#34;); list.add(&#34;张飞&#34;); for (int i = list." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/124f6e84f9e4f84710fe1bdf54594d59/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-04T16:33:02+08:00" />
<meta property="article:modified_time" content="2019-03-04T16:33:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">List移除元素</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="List__0"></a>List 移除某个元素</h3> 
<p>四种方式：</p> 
<ul><li>方式一，使用 Iterator ，顺序向下，如果找到元素，则使用 remove 方法进行移除。</li><li>方式二，倒序遍历 List ，如果找到元素，则使用 remove 方法进行移除。</li><li>方式三，正序遍历 List ，如果找到元素，则使用 remove 方法进行移除，然后进行索引 “自减”。</li><li>方式四，使用jdk1.8新增的Stream流操作<br> 1.Iterator 迭代器</li></ul> 
<pre><code>	@Test
    public void fun9(){
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("赵云");
        list.add("黄忠");
        list.add("马超");
        list.add("关羽");
        list.add("张飞");
        // 获取迭代器
        Iterator&lt;String&gt; it = list.iterator();
        while(it.hasNext()){
            String str = it.next();
            if("关羽".equals(str)){
                it.remove();
            }
        }
        System.out.println(list);
    }
</code></pre> 
<p>2.倒序遍历</p> 
<pre><code>	@Test
    public void fun10(){
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("赵云");
        list.add("黄忠");
        list.add("马超");
        list.add("关羽");
        list.add("张飞");
        for (int i = list.size() - 1; i &gt; 0; i--) {
            if("关羽".equals(list.get(i))){
                list.remove(i);
            }
        }
        System.out.println(list);
    }
</code></pre> 
<p>3.正序遍历</p> 
<pre><code> 	@Test
    public void fun11(){
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("赵云");
        list.add("黄忠");
        list.add("马超");
        list.add("关羽");
        list.add("张飞");
        for (int i = 0; i &lt; list.size(); i++) {
            if("关羽".equals(list.get(i))){
                list.remove(i);
                i--;
            }
        }
        System.out.println(list);
    }
</code></pre> 
<p>4.Stream流操作（JDK 1.8 +）</p> 
<pre><code>	@Test
    public void fun8(){
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("赵云");
        list.add("黄忠");
        list.add("马超");
        list.add("关羽");
        list.add("张飞");
        // 筛选出不是“关羽” 的集合
        list = list.stream().filter(e -&gt; !"关羽".equals(e)).collect(Collectors.toList());
        System.out.println("method4|list=" + list);

    }
</code></pre> 
<p>问题：</p> 
<h3><a id="1forEach_87"></a>1.为什么不能使用forEach</h3> 
<pre><code>	@Test
    public void fun5(){
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("赵云");
        list.add("黄忠");
        list.add("马超");
        list.add("关羽");
        list.add("张飞");
        for (String str :list) {
            if ("张飞".equals(str)){
                list.remove(str);
            }
        }
        System.out.println(list);
    }
</code></pre> 
<p><img src="https://images2.imgbox.com/0a/87/yTBsAKsj_o.png" alt="在这里插入图片描述"><br> 原因：<br>          foreach方式遍历元素的时候，是生成iterator，然后使用iterator遍历。在生成iterator的时候，会保存一个expectedModCount参数，这个是生成iterator的时候List中修改元素的次数。如果你在遍历过程中删除元素，List中modCount就会变化，如果这个modCount和exceptedModCount不一致，就会抛出异常。这个是为了安全的考虑。如果使用iterator遍历过程中，使用List修改了元素，可能会出现不正常的现象。如果使用iterator的remove方法则会正常，因为iterator的remove方法会在内部调用List的remove方法，但是会修改excepedModCount的值，因此会正常运行。</p> 
<h3><a id="2forEach__110"></a>2.为什么forEach 删除倒数第二元素不会出现异常</h3> 
<pre><code> 	@Test
    public void fun12() {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("赵云");
        list.add("黄忠");
        list.add("马超");
        list.add("关羽");
        list.add("张飞");
        for (String str:list) {
            if("关羽".equals(str)){
                list.remove(str);
            }
            System.out.println(str);
        }
    }
</code></pre> 
<p><img src="https://images2.imgbox.com/df/7c/HPLqfavN_o.png" alt="在这里插入图片描述"><br> 仔细观察发现集合最后一个元素（“张飞”）并没有被遍历出来，因为当我们移除倒数第二个元素（“关羽”）时 cursor（游标）为 4 ，list 中size 属性的值会发生变化（5 - 1 = 4）变为 4，所以下面代码返回 false ，也就不会继续向下遍历。这也是能够正常执行的原因，因为如果继续遍历就会出现问题1 中的情况，在进行checkForComodification() 时，因为 modCount 发生了变化，而expectedModCount 并没有发生变化，所以会出现 ConcurrentModificationException异常。</p> 
<pre><code>public void remove() {
            if (lastRet &lt; 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                ArrayList.this.remove(lastRet);
                cursor = lastRet;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }
</code></pre> 
<pre><code> public boolean hasNext() {
            return cursor != size;
        }
</code></pre> 
<pre><code>public E next() {
            checkForComodification();
            int i = cursor;
            if (i &gt;= size)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i &gt;= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i + 1;
            return (E) elementData[lastRet = i];
        }
</code></pre> 
<pre><code>final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
</code></pre> 
<h3><a id="3___for__i__171"></a>3 普通正序 for 循环为什么要 i –</h3> 
<p>因为遍历过程中进行remove 操作时，该位置后面的元素会挤到前面来，这时候会发生一种情况就是原来元素的位置会被他后面的元素取代，而该位置已经遍历过了，所以该元素不会背遍历。 所以要进行 i-- 操作从该位置重新遍历。</p> 
<pre><code>	@Test
    public void fun11(){
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("赵云");
        list.add("黄忠");
        list.add("马超");
        list.add("关羽");
        list.add("张飞");
        for (int i = 0; i &lt; list.size(); i++) {
            System.out.println(list.get(i));
            if("关羽".equals(list.get(i))){
                list.remove(i);
            }
        }
        System.out.println(list);
    }
</code></pre> 
<p>就是下面的情况 “张飞” 不见了…<br> <img src="https://images2.imgbox.com/a1/97/JIeSMlF8_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4_for__194"></a>4 为什么倒序for 循环可以</h3> 
<p>当我们倒序遍历元素的时候，无论删除元素之后的元素怎么移动，之前的元素对应的索引（index）是不会发生变化的，所以在删除元素的时候不会发生问题。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b9aa73225bce1124d5942e8a2bf42dd4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">TCP/IP详解--基本概念</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ada93be82102f626e386171ee2eab262/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">centos7安装python3.6</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>