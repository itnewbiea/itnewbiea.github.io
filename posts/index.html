<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f589d05aab800fe143c3481c3b7a83c1/" rel="bookmark">
			Adobe illustrator操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		illustrator 界面 删除最近使用项 illustrator删除最近使用项，选择菜单栏中的“编辑”，然后在“首选项”中选择“常规”。
在“文件处理和剪切版”中，将最近显示的文件数，改为0，即可清除以往的工作记录。
工具栏 “填色” “描边”控件 需要注意出现的“填色”和“描边”的控件。
描边→边框，图形中是“中心黑底四周白框”的符号。
填色→形状内部的颜色。
“填色”和“描边”，在操作的时候，需要留意。
绘制操作 使用画笔 通过使用画笔，可以用图案、图形 纹理或画笔描边装饰路径。点击“窗口”选项，在下拉菜单中，点击“画笔”。这个时候，就会出现“画笔”界面。
在“画笔”界面中，点击后，会出现各种用笔，如艺术钢笔、毛笔等等，这个时候，可以选择自己所需的画笔类型。
点击界面左下脚的按钮，就会出现各种类型的选项，于是可以按照实际的需求进行选择。
在颜色界面、画笔界面，设置所要使用的颜色和用笔类型。
然后，还需要在工具栏中选择“铅笔”工具，这样可以进行绘制。
可以对“铅笔”工具的属性进行设置，然后点击“确定”。
注意事项 注意，只有将“填色”控件中的颜色选定，画笔画出的图，才能够得到显示。如果“填色”控件中的颜色为无色，画笔画出的图，就不能够得到显示。
注意，如果选择的是“填色”控件，那么用“铅笔”绘制的线条，就会自动生成填充的“几何图”。如果只想要“几何线”，那么需要选择“描边”控件，这个时候用“铅笔”绘制的线条，就会是是线条，如下图所示。
在运用画笔的时候，需要注意如下情况：
有时候，因为操作的时候，点击了工具栏中的“选择”，如图中黄圈所示，这个时候，点击右边“画笔”界面中的工具，在画布上，是无法绘制图形的。解决方法，便是重新点击工具栏中的“铅笔”。
还有的时候，因为将“填色”控件和“描边”控件中选择了“无色”，这个时候，点击右边“画笔”界面中的工具，在画布上，是无法绘制图形的。解决方法，是为“填色”控件和“描边”控件选择颜色。
绘制优美曲线 可以使用曲线工具，绘制优美的曲线。
在使用曲线工具的时候，注意，点击线中的小圆点，如果鼠标点击后成为是“实心”，那么就可以拖动该点改变曲线。如果是“空心”，就不能拖动改变曲线。
也可以在线条上增加锚点，这样的话可以增加曲线的精确程度。如下图所示。
点击工具栏中的“选择”，即可以停止曲线锚点的绘制。
组合几何图形 几何图形之间的组合，可以形成不同的图案。
如图所示，可以通过三个锚点，绘制一个弧形。
点击工具栏中的“选择”，即可以停止曲线锚点的绘制。
如果选择“填色”中的颜色为白色，那么在白色的绘图版上，绘制曲线锚点几何图，就会盖住有颜色的部分。将两个几何图叠加，形成的效果则如下所示。
也就是说，通过不同颜色几何图形的组合，可以实现图形的变形。
即可完成。
符号图像描摹 图像，是在画布上的图形对象，是界面中单个图像。
在Indesign中打开图片，选择图像描摹，鼠标点击。
然后，出现如下效果。
在此基础上，可以对图片进行进一步操作。
人物图像绘制 如图所示，在画笔的基础上，绘制人物基本图像。
但是，显然这种绘制，受限于绘画者的水平。且用鼠标操作，用笔不是非常精致。这个时候，就需要对人物图像进行进一步的优化。
图层操作 图层，是多个在不同上下层的图形，在统一的画布上进行叠加。
打开图层窗口 在illustrator中，图层是常见的操作。其运用原理和photoshop的原理一致。在操作的时候，注意“&lt;&lt;”和“&gt;&gt;”符号，点击后可以展开或者隐藏工具窗口界面。
在菜单栏中的“窗口”可以选择各个工具的界面。可以选择不同的工具窗口。勾选后就可以显示。
对于图层的基本操作，如图所示，和photoshop图层操作基本一致。
鼠标点击图层界面中的小圆圈，即可以实现移动图层的上下位置。
图层蒙版 蒙版的原理，简单举例来说，用一个有洞的A4纸张，覆盖另一张带有信息的A4纸张。两个纸张重合后，能看到的就是洞中的信息。也就是说，除了这个“洞”没有被“蒙”外，其余的信息都被“版”片给“蒙”盖上了，简称“蒙版”。
如果想在llustrator创建图层蒙版，可以先在工具栏中选择一个“框”，如下图所示：
这个时候，在编辑的图层下面，会出现这个“框”。鼠标单击“添加图层蒙版”按钮，该按钮位于图层面板底部的第三个图标，即点击下面的“蒙版”，即可实现操作。这个时候，框内的图片会保留，框外的图片会去除。
如果不选择这个框，那么该图标呈现灰色，单击的时候没有反应。
illustrator + photoshop illustrator 可以打开并导入photoshop文件。同属于Adobe公司的软件，二者是可以在同一个平台运行的。
【心得】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c14b1c572c1f095018dfe5b706a4859/" rel="bookmark">
			图神经网络｜7.1-GCN基本模型概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图卷积和卷积的差别 图神经网络常见的情况 半监督 实际情况下并不是所有节点都有打上标签。
比如在交通网络中，点对应城市中各个区域的传感器，由于配置的先后问题和经济考虑，有些偏远地区并没有来得及配得上，会缺乏相关数据的支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23d62e16d87fc9ab7b35f6300767161e/" rel="bookmark">
			图神经网络｜5.消息传递的计算方法 6.多层GNN的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5.消息传递的计算方法 边的存放方式 注意，在实际的边的实现方式中，并不是以邻接矩阵来进行实现的，这是因为在图的更新中，用邻接矩阵进行更新所占用的时间开销相对大，二是因为领接矩阵占用的空间大（N方）。
所以在实际实现中会采用2XN的存储结构，从而避免多余的存储开销。
节点更新 在图神经网络中，某个节点的更新，不应该只关心自身的变化，还应该关心相邻节点与本节点的关系。
6.多层GNN的作用 首先，多层GNN并不会破坏图的结构（拓扑关系/邻接结构）。
而多层GNN能使得本点上的特征信息，不断进行迭代（就好像计算机网络中rip，不断交换路由信息，来得到更远处的路由信息，从而最后收敛）
GCN是Graph Convolutional Network图卷积神经网络的缩写。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8e3d7967173800bd0366068548599ce/" rel="bookmark">
			Python的cryptography库介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python的cryptography是密码库，源码地址为：https://github.com/pyca/cryptography，最新发布版本为41.0.7,license为Apache 2.0/BSD 3，它支持在Windows、Linux、macOS上使用。如果通过源码编译，需要依赖OpenSSL。Python版本需要为3.7+.
通过pip安装,执行：
pip install cryptography 以下是对称加密AES测试code:
关于OpenSSL AES GCM的介绍可以参考：https://blog.csdn.net/fengbingchun/article/details/106113185
import os from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes def aes_gcm_encrypt(plain_text, key, iv, aad): # Construct an AES-GCM Cipher object with the given key and iv encryptor = Cipher(algorithms.AES(key), modes.GCM(iv),).encryptor() # associated_data will be authenticated but not encrypted, it must also be passed in on decryption encryptor.authenticate_additional_data(aad) # Encrypt the plaintext and get the associated ciphertext. GCM does not require padding cipher_text = encryptor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8e3d7967173800bd0366068548599ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6da19b4bacb801a93b55e64a0b13f23b/" rel="bookmark">
			Adobe Photoshop 快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PS快捷键 图层 选择图层 Ctrl + T：可以对图层的大小和位置进行调整
填充图层 MAC: Alt+Backspace (前景) or Ctrl+Backspace (背景)
WINDOWS: Alt+Delete (前景) or Ctrl+Delete (背景)
快速将图层填充为前景色或背景色
平面化图层（盖印图层）
MAC: Ctrl+Alt+Shift+E
WINDOWS: Ctrl+Alt+Shift+E
盖印就是在你将处理图片的时候将处理后的效果盖印到新的图层上，功能和合并图层差不多，不过比合并图层更好用！因为盖印是重新生成一个新的图层而一点都不会影响你之前所处理的图层
合并可见图层
MAC: Ctrl+Shift+E
WINDOWS: Ctrl+Shift+E
“合并可见图层”将图像所有在图层对话框中显示有”眼睛”标志的图像合并成为一个单个图层
复制图层 MAC: Ctrl+J
WINDOWS: Ctrl+J
复制一份已存在的图层。
复制多个图层
MAC: Shift+Ctrl+C
WINDOWS: Shift+Ctrl+C
可实现复制选区内的多个图层
剪切图层 MAC: Ctrl+Shift+J
WINDOWS: Ctrl+Shift+J
移动图层 上移图层至顶端
MAC: Ctrl+Shift+]
WINDOWS: Ctrl+Shift+]
下移至图层底端
MAC: Ctrl+Shift+[
WINDOWS: Ctrl+Shift+[
上移动图层
MAC: Ctrl+]
WINDOWS: Ctrl+]
下移图层
MAC: Ctrl+[
WINDOWS: Ctrl+[
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6da19b4bacb801a93b55e64a0b13f23b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39dd100d34777aa2042d44be75cd069d/" rel="bookmark">
			案例102:基于微信小程序的旅游社交管理系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
后台模块的实现
用户信息管理
景点推荐管理
分享圈管理
美食推荐管理
酒店推荐管理
周边推荐管理
小程序会员模块的实现
系统首页
我的菜单
分享圈
景点推荐
美食推荐
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 随着信息技术在管理上越来越深入而广泛的应用，管理信息系统的实施在技术上已逐步成熟。本文介绍了旅游社交小程序的开发全过程。通过分析旅游社交小程序管理的不足，创建了一个计算机管理旅游社交小程序的方案。文章介绍了旅游社交小程序的系统分析部分，包括可行性分析等，系统设计部分主要介绍了系统功能设计和数据库设计。
本旅游社交小程序功能有管理员和用户。管理员有个人中心，用户管理，每日签到管理，景点推荐管理，景点分类管理，防疫查询管理，美食推荐管理，酒店推荐管理，周边推荐管理，分享圈管理，我的收藏管理，系统管理。用户可以在微信小程序上注册登录，进行每日签到，防疫查询，可以在分享圈里面进行分享自己想要分享的内容，查看和收藏景点以及美食的推荐等操作。因而具有一定的实用性。
本站后台采用Java的SSM框架进行后台管理开发，可以在浏览器上登录进行后台数据方面的管理，MySQL作为本地数据库，微信小程序用到了微信开发者工具，充分保证系统的稳定性。系统具有界面清晰、操作简单，功能齐全的特点，使得旅游社交小程序管理工作系统化、规范化。
系统展示 后台模块的实现 用户信息管理 管理员可以管理用户信息，可以对用户信息添加修改删除。
景点推荐管理 管理员可以对景点推荐信息进行添加修改删除操作。
分享圈管理 管理员可以对分享圈信息进行添加，修改，删除操作。界面如下图所示：
美食推荐管理 管理员可以对美食推荐信息进行添加，修改，删除操作。界面如下图所示
酒店推荐管理 管理员可以对酒店推荐信息进行添加，修改，删除操作。界面如下图所示：
周边推荐管理 管理员可以对周边推荐信息进行添加，修改，删除操作。界面如下图所示：
小程序会员模块的实现 系统首页 小程序用户是需要注册才可以进行登录的，登录后在首页可以查看相关信息，并且下面导航可以点击到其他功能模块。界面如下图所示：
我的菜单 在小程序里点击我的，会出现关于我的界面，在这里可以修改个人信息，以及可以点击其他功能模块。界面如下图所示：
分享圈 用户想要把一些信息分享到分享圈的时候，可以点击新增，然后输入自己想要分享的信息就可以进行分享圈的操作。界面如下图所示：
景点推荐 用户可以在景点推荐里面进行收藏和评论等操作。界面如下图所示：
美食推荐 用户可以在美食推荐模块搜索和查看美食推荐的相关信息。界面如下图所示：
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39dd100d34777aa2042d44be75cd069d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ea7720ab07792e82f8c8eb4548c7b70/" rel="bookmark">
			案例101:基于微信小程序的停车共享管理系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
用户功能模块的实现
用户注册登录界面
首页界面
停车场界面
车辆信息界面
车位预约界面
管理员功能模块的实现
管理员登录界面
用户管理界面
停车场管理界面
停车预约管理界面
停车缴费管理界面
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 随着科技的进步，微信小程序慢慢进入了生活当中，由于轻便快捷，方便使用，基于微信这个大平台，使得小程序飞速发展，趋于成熟，因此，针对用户停车预约的需求，特开发了本基于语音识别的停车共享小程序。
本文主要介绍了基于语音识别的停车共享小程序的开发过程，对开发环境、系统设计、系统实现、系统测试等方面进行分析。在设计时对微信客户端、微信开发者工具进行了充分的了解，掌握微信平台通过的接口。系统应用官方提供的API文档，主要实现了用户管理个人车辆、停车场查询预约、停车缴费的功能。
本基于语音识别的停车共享小程序采用Java技术、MYSQL数据库，基于微信平台开发，系统运行效果稳定，操作方便、快捷，界面友好，是一个功能全面、实用性好、安全性高，并具有良好的可扩展性、可维护性的停车共享小程序。
系统展示 用户功能模块的实现 用户注册登录界面 没有账号的用户可进行注册操作，注册后可进入登录界面进行登录系统
首页界面 用户通过微信平台进入本系统后可查看所有停车场信息 停车场界面 用户在停车场界面可查看所有停车场信息，并可选择查看详情 车辆信息界面 用户登录后可管理个人车辆信息，对已有车辆可进行修改和删除，也可添加车辆信息 车位预约界面 用户可查看个人已有车位预约信息，并可进行缴费和删除操作 管理员功能模块的实现 管理员登录界面 管理员可以通过正确的登录账号和密码进行登录系统后台 用户管理界面 管理员在用户管理界面可查看所有用户信息，并可对其进行修改和删除操作
停车场管理界面 管理员可增删改查停车场信息
停车预约管理界面 管理员可查看用户停车预约信息，并可对其进行删除操作 停车缴费管理界面 管理员可查看所有停车缴费信息，并可对其进行删除操作
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ea7720ab07792e82f8c8eb4548c7b70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1286ccb533dd17519d4e30a2fa5b6d58/" rel="bookmark">
			案例099:基于微信小程序的外卖小程序的研究与开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
微信端功能模块的实现
注册登录界面
首页界面
商家界面
菜品详情界面
购物车界面
我的订单界面
用户信息界面
服务端功能模块的实现
服务端登录界面
用户管理界面
商家管理界面
菜品信息管理界面
菜品分类管理界面
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 随着科技的进步，微信小程序慢慢进入了生活当中，由于轻便快捷，方便使用，基于微信这个大平台，使得小程序飞速发展，趋于成熟，因此，针对用户对外卖点餐方面的需求，特开发了本外卖小程序。
该外卖小程序分为小程序前端和Java后端系统，遵循数据前后端交互，相互分离。前端小程序应用官方提供的API文档，主要功能为查看外卖菜品信息、外卖点餐以及管理个人订单等。后端系统则是由Java语言实现，基于B/S结构，使用MySQL数据库开发，使得管理员、商家后台界面简单整洁，便于管理员和商家使用和管理。
本外卖小程序拥有界面简洁、操作简单易懂，管理方便，功能齐全等优点，具有很高的应用价值。
系统展示 微信端功能模块的实现 注册登录界面 未有账号的用户可进行注册操作，注册后可进入登录界面进行登录系统
首页界面 用户通过微信平台打开本外卖小程序，登录后进入了系统的首页，在首页用户可查看所有菜品 商家界面 用户在商家界面可查看所有商家，并可选择查看详情 菜品详情界面 用户可选择菜品查看菜品详情信息，并可进行加入购物车和立即购买操作 购物车界面 用户在购物车界面可查看购物车已有菜品信息，并可对其进行删除、修改数量或者结算操作 我的订单界面 用户在我的订单界面可查看个人订单信息 用户信息界面 用户可修改个人信息 服务端功能模块的实现 服务端登录界面 管理员和商家要想进入对于角色后台必须进行登录操作 用户管理界面 管理员可进行查看、修改和删除用户信息
商家管理界面 管理员可增删改查商家信息
菜品信息管理界面 商家可增删改查菜品信息，管理员可查看、修改和删除菜品信息 菜品分类管理界面 商家可增删改查菜品分类信息，管理员可查看、修改和删除菜品分类信息 代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1286ccb533dd17519d4e30a2fa5b6d58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21d5ec29699e65dcff9fa1a3217161a3/" rel="bookmark">
			C#不会循环响应的Action设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、简述二、测试代码三、测试的输出四、核心代码五、其它 一、简述 特点：
不光是能防止直接的死循环调用；还能防止间接的死循环调用；还支持对不同参数判定，不同参数的调用可以不当循环调用； 消息事件系统中必备，拒绝死循环
简明、高效、实用
其它编程语言也可以参考实现
二、测试代码 测试代码只为展示组件功能，也完美的展示组件功能。测试用例是完全的
using UnityEngine; namespace Main { /// &lt;summary&gt; /// 将脚本挂到一个空对象上即可测试 /// &lt;/summary&gt; public class SimpleTest_NonLoopAction : MonoBehaviour { private void Start() { // 测试逻辑: [-&gt;A -&gt;A] Logic01.Run(); // 测试逻辑：[-&gt;A -&gt;B -&gt;C -&gt;A] Logic02.Run(); // 测试逻辑：[-&gt;A -&gt;A(1) -&gt;A(1,2) -&gt;A(1,2,3) -&gt;A(1)] // (注：中间相同的消息但参数不一样，只有出现一样的参数的消息，都会中断) Logic03.Run(); } static class Logic01 { static NonLoopAction _nonLoopActionA; /// &lt;summary&gt; /// 执行逻辑 [-&gt;A -&gt;A] /// &lt;/summary&gt; public static void Run() { Debug.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21d5ec29699e65dcff9fa1a3217161a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef91150601c7b621a54cb1253b6ce7e0/" rel="bookmark">
			人类智能不仅仅依赖于数理推理，还包括其他推导方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人类智能的推导方式是多样的，不仅仅局限于数理推理，而是通过多种推理方式相互配合，进行问题解决和决策制定。以下是一些常见的推导方式：
归纳推理：通过观察和总结已有的经验和事实，从特殊情况中得出一般规律或结论。归纳推理是从具体到一般的推理过程。
演绎推理：通过给定的前提和已知的逻辑规则，推导出一个结论。演绎推理是从一般到特殊的推理过程。
类比推理：通过将一个问题或情境与另一个已知的相似问题或情境进行比较，找到相似之处，并从中获得解决问题的思路。
经验推理：基于个人的经验和直觉，通过感觉和非正式的推理过程来做出决策或判断。
直觉推理：基于无意识的思考和直觉的感知，通过模糊和隐含的信息来进行推理。
启发式推理：根据经验和直觉，借助简化方法或规则来解决问题。启发式推理通过快速的、可能是不完全的推理过程来达到快速决策的目的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a06414f93962fbabdd462ef0f7a67f92/" rel="bookmark">
			人类智能中含有不同态、势、感、知的混合微积分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人类智能中包含了不同态、势、感、知的混合微积分。在混合微积分中，不同态代表了人类在不同的状态下对问题的思考和处理能力，势代表了人类在不同的动机和目标驱动下的行为表现，感代表了人类对问题的感觉和理解反应，知代表了人类对问题的知识和信息的联系和运用能力。
混合微积分的基本思想是将人类的感直觉、意图、动机、知觉、知识等因素与微积分方法相结合，以提高问题解决的效率和准确性。例如，在解决数学问题时，人类的知觉状态和动机会影响到思考的深度和关注的重点，直觉和感觉会帮助我们快速捕捉到问题的关键点，知识和信息的理解和运用能力则是解决问题的基础。混合微积分的实际应用也可以涉及到各个领域，比如在工程领域中，人类的感觉和直觉可以帮助我们找到最优的设计方案，知识和信息的运用能力可以帮助我们分析问题的复杂性和解决难题。在医学领域中，混合微积分可以结合人类的情绪状态和直觉来辅助诊断和治疗，结合知识和信息的运用能力来优化治疗方案。人类智能将不同的态、势、感、知进行混合微积分的过程可以简要概括为以下几个步骤：
感知：人类通过感官（如视觉、听觉、触觉等）获取外部世界的信息，并通过感知过程将这些信息转化为可理解的形式。
分析和抽象：人类智能将感知到的信息进行分析和抽象，提取出其中的关键特征和模式。这一步骤涉及到对信息的筛选、分类、比较、归纳等思维过程。通过这些分析和抽象，人类可以从复杂的感知中找到规律和结构。
表征和建模：人类将抽象的信息进行进一步的表征和建模，将其转化为数学形式或其他形式，以便进行更精确的处理和计算。
计算和推理：在建立好模型后，人类智能可以通过计算和推理的方式进行混合微积分。计算包括对模型中的方程或函数进行求导、求积分等数学运算，以推导出关于系统的性质和变化的信息。
综合和决策：人类智能将不同来源的信息进行综合，综合的方式可能是通过权衡不同信息的重要性和可靠性，也可能是通过制定适当的规则和策略来进行决策。
需要强调的是，以上过程是一个简化的描述，实际的人类智能会涉及到更复杂的认知和情感等方面，如上面态势感知秩序可以颠倒成势态知感，可以先综合决策、计算推理、表征建模、分析抽象，然后再进行针对性的感知等等。
混合不同态（即混合了离散态和连续态）、势、感和知的混合微积分模型可以用于研究随机应变现象。这种模型将离散化的离散态和连续态结合起来，将势、感和知考虑在内，可以更好地描述现实世界中的各种复杂现象。
在模型中，势表示系统的潜在变化趋势，可以通过势函数来描述；感表示系统对外部刺激的感知能力，可以通过感函数来描述；知表示系统的知识、信息或记忆，可以通过知函数来描述。随机应变现象是指在给定初始状态和外部刺激的情况下，系统的响应可能出现不确定性和随机性的现象。通过混合微积分模型，可以考虑到势、感和知的影响，从而更准确地描述随机应变现象的发生。具体地说，混合微积分模型可以通过偏微分方程或差分方程来描述系统的演化过程。该模型考虑到了整数态和连续态之间的相互作用，势、感和知对系统演化的影响。通过数值方法，可以模拟出系统的随机应变现象，得到不同时间和空间点上的应变情况。混合微积分模型的应用范围广泛，可以用于研究自然界中的随机应变现象，如地震、气候变化等，也可以用于金融市场、社会系统等领域的研究。通过混合微积分模型，我们可以更好地理解和预测随机应变现象的发生，为相应的决策和控制提供科学依据。
人机协同系统的演化过程可以使用偏微分方程或差分方程来描述，其中包括态、势、感和知的混合微积分模型。偏微分方程或差分方程可以描述系统的状态和势能随时间和空间的变化情况，以及人的感知和知识的更新过程。具体描述人机协同系统演化过程的方程形式将根据具体情况而有所不同，以下是一些常见的方程形式：
1、状态方程
描述系统中各个组成部分的状态随时间和空间的变化情况。常见的状态方程包括物理方程、动力学方程等。例如，描述机器人运动的牛顿第二定律可以使用偏微分方程或差分方程来表示。
2、势能方程
描述系统中存在的势能随时间和空间的变化情况。势能方程可以根据具体情况而定，例如描述机器人与环境之间的相互作用力可以使用势能方程来描述。
3、感知方程
描述人对机器人和环境的感知过程。感知方程可以使用偏微分方程或差分方程来表示，例如描述人的感知决策过程可以使用状态方程或概率模型来描述。
4、知识方程
描述人的知识更新过程，包括学习、记忆和推理等。知识方程可以使用偏微分方程或差分方程来表示，例如描述人的学习过程可以使用差分方程表示。
这些方程可以相互耦合，形成一个综合的人机协同系统模型，从而描述系统的演化过程。方程的具体形式和参数可以根据具体问题和实际情况进行调节和优化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5251cec1cd6e1869825550d2d0d78da7/" rel="bookmark">
			对逻辑的重新认识是类人智能发展的关键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对逻辑的重新认识确实是类人智能发展的关键之一。逻辑是一种推理和思维的方式，它帮助我们理解和解决问题。然而，以前的逻辑被认为是非常规则和固定的，无法灵活适应不同的情境和语境。这导致了传统的计算机系统在处理复杂问题和不确定性方面的局限。数学仅仅是基于公理的逻辑体系。公理是一些被假定为真的前提或基本原则，它们不能被证明，而是被接受为不需要证明的事实。数学从这些公理出发，应用逻辑推理和证明方法来推导出各种数学结论。公理系统可以有不同的形式，例如，欧几里得几何学和非欧几里得几何学可以分别根据不同的公理系统来建立。无论公理系统的形式如何，数学仍然只是一个基于公理的逻辑体系。
近年来，随着机器学习和人工智能的快速发展，对逻辑的认识也有了新的突破。现代的类人智能系统逐渐将逻辑作为一种学习和推理的工具，而不仅仅是一种严格的规则。这种重新认识逻辑的方式在推理、决策和问题解决中发挥了重要作用。例如，传统的逻辑推理主要是建立在确定性的前提和规则之上，而现代的类人智能系统可以处理不确定性和模糊性的情况。它们可以通过学习和推理来推断出可能的结论，而不仅仅是根据已知的事实和规则。这种能力使得类人智能系统在更复杂和真实的情境下更加灵活和适应。
此外，对逻辑的重新认识还帮助类人智能系统更好地理解自然语言和人类的思维方式。传统的逻辑表示方法往往是基于形式化的符号系统，难以处理自然语言中的歧义和隐含信息。然而，现代的类人智能系统可以通过深度学习和自然语言处理技术来从大量的语料库中学习并理解自然语言的语义和语境。这使得它们能够更好地理解人类的语言和意图，并相应地进行推理和决策。
综上所述，对逻辑的重新认识是类人智能发展的关键之一。通过将逻辑作为学习和推理的工具，并结合机器学习和自然语言处理等技术，现代的类人智能系统能够更好地处理复杂问题和不确定性，并更好地理解和应对人类的思维方式。这为类人智能在各种领域的应用提供了更广阔的可能性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d44f590650f9faccbe1b128c31ce378/" rel="bookmark">
			类人智能的突破很可能与逻辑的突破密切相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类人智能的突破与逻辑的突破密切相关，主要体现在以下几个方面：逻辑推理能力的提升：类人智能的核心是拥有类似于人类的推理能力。传统的逻辑推理方法在人工智能领域得到广泛应用，而逻辑的突破可以帮助类人智能系统更好地进行推理和解决问题。例如，推理算法的改进、新的逻辑模型的提出等都可以提高类人智能系统的推理能力。逻辑表示与语义理解的结合：在类人智能的发展过程中，逻辑表示和语义理解的结合非常重要。传统的逻辑推理在符号层面表达和处理信息，但是对于自然语言等复杂信息的处理存在困难。通过将逻辑表示与语义理解相结合，可以更好地处理自然语言，实现类人智能系统对文本和语音的理解和分析。基于逻辑的学习算法：逻辑的突破也可以为类人智能的学习算法提供支持。传统的机器学习算法主要基于统计方法，但是对于逻辑推理和抽象概念的学习存在局限性。通过改进和创新逻辑学习算法，可以使类人智能系统更好地学习和理解复杂的逻辑关系，从而提升其智能水平。总之，逻辑的突破对于类人智能的发展非常重要。通过提升逻辑推理能力、结合逻辑表示与语义理解，以及改进逻辑学习算法等方面的创新，可以进一步推动类人智能的发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5a39b73fb46dd9dc055789fffa3d6e1/" rel="bookmark">
			【机器学习】循环神经网络（二）-LSTM示例（keras）国际航空乘客问题的回归问题...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 Keras 在 Python 中使用 LSTM 循环神经网络进行时间序列预测 国际航空乘客问题的回归问题
这个文件是一个CSV格式的数据集，它包含了从1949年1月到1960年12月的每个月的国际航空乘客的总数（以千为单位）。第一行是列名，分别是"Month"和"International airline passengers: monthly totals in thousands. Jan 49 ? Dec 60"。第一列是每个月的日期，格式是"年份-月份"。第二列是每个月的乘客总数，单位是千人。这个数据集可以用来训练一个LSTM模型，来预测未来的乘客数量。LSTM是一种循环神经网络，它可以利用长期的时间序列信息来进行预测。
"Month","International airline passengers: monthly totals in thousands. Jan 49 ? Dec 60" "1949-01",112 "1949-02",118 "1949-03",132 "1949-04",129 "1949-05",121 "1949-06",135 "1949-07",148 "1949-08",148 "1949-09",136 "1949-10",119 "1949-11",104 "1949-12",118 "1950-01",115 "1950-02",126 "1950-03",141 "1950-04",135 "1950-05",125 "1950-06",149 "1950-07",170 "1950-08",170 "1950-09",158 "1950-10",133 "1950-11",114 "1950-12",140 "1951-01",145 "1951-02",150 "1951-03",178 "1951-04",163 "1951-05",172 "1951-06",178 "1951-07",199 "1951-08",199 "1951-09",184 "1951-10",162 "1951-11",146 "1951-12",166 "1952-01",171 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5a39b73fb46dd9dc055789fffa3d6e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b3db2574cd3a5264ce04d3f07ac16a8/" rel="bookmark">
			小程序弹窗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序弹窗的例子如下：
确认弹窗： wx.showModal({ title: '提示', content: '确定要删除该记录吗？', success: function (res) { if (res.confirm) { console.log('用户点击确定') // 执行删除操作 } else if (res.cancel) { console.log('用户点击取消') } } }) 提示弹窗： wx.showToast({ title: '成功', icon: 'success', duration: 2000 }) 加载中弹窗： wx.showLoading({ title: '加载中', mask: true }) // 隐藏加载弹窗 setTimeout(function () { wx.hideLoading() }, 2000) 自定义弹窗： wx.showModal({ title: '自定义弹窗', content: '这是一个自定义的弹窗示例', showCancel: false, // 不显示取消按钮 confirmText: '知道了', confirmColor: '#3CC51F', success: function (res) { if (res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b3db2574cd3a5264ce04d3f07ac16a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6561b4834ddab3ec5d017e7c0240bb01/" rel="bookmark">
			高级算法设计与分析（八） -- 总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 高级算法设计与分析（一） -- 算法引论
高级算法设计与分析（二） -- 递归与分治策略
高级算法设计与分析（三） -- 动态规划
高级算法设计与分析（四） -- 贪心算法
高级算法设计与分析（五） -- 回溯法
高级算法设计与分析（六） -- 分支限界法
高级算法设计与分析（七） -- 概率算法和NP完全性理论
高级算法设计与分析（八） -- 总结
目录
系列文章目录
一、算法引论
二、递归与分治策略
1、分治法
2、二分法
3、大整数的乘法
4、棋盘覆盖
5、合并排序
6、循环日程表
三、动态规划
1、矩阵连乘问题
2、最长公共子序列
四、贪心算法
1、活动安排问题
2、贪心算法
3、哈夫曼编码
4、单源最短路径--Dijkstra算法
5、最小生成树
5.1、普里姆（Prim）算法
5.2、克鲁斯卡尔（Kruskal）算法
五、回溯法
1、n皇后问题
2、图的m着色问题
六、分支限界法
1、分支限界法
2、单源最短路径问题
七、概率算法
八、NP完全性理论
资料
前言 tips：这里只是总结，不是教程哈。鉴于本人写字如画符，就不出视频教程了，如实在有需要，请在文章下方留言。当然，文章有任何问题，也请留言，谢谢！
这个系列用另一种形式，把习题放在最下面，看看好用不。
思维导图放在本文章最下面，请自行获取。
一、算法引论 ​
递归问题求时间复杂度
​
二、递归与分治策略 1、分治法 累加函数时间复杂度
2、二分法 时间复杂度o(log n)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6561b4834ddab3ec5d017e7c0240bb01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d05e5c10b6f2a0d8ffa9995edcdab69/" rel="bookmark">
			机器学习（四） -- 模型评估（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 机器学习（一） -- 概述
机器学习（二） -- 数据预处理（1-3）
机器学习（三） -- 特征工程（1-2）
机器学习（四） -- 模型评估（1-4）
未完待续……
目录
机器学习（四） -- 模型评估（1）
机器学习（四） -- 模型评估（2）
---
系列文章目录
前言
四、 回归模型评估指标
1、均方误差（Mean Squared Error，MSE）
2、***均方根误差（Root Mean Squared Error，RMSE）
3、***均方对数误差（Mean Squared Log Error，MSLE）
4、平均绝对误差（Mean Absolute Error，MAE）
5、***平均绝对百分比误差（Mean Absolute Percentage Error，MAPE）
6、决定系数（R2，R-square）
7、***校正决定系数（Adjusted R-square）
前言 tips：这里只是总结，不是教程哈。
“***”开头的是给好奇心重的宝宝看的，其实不太重要可以跳过。
此处以下所有内容均为暂定，因为我还没找到一个好的，让小白（我自己）也能容易理解（更系统、嗯应该是宏观）的讲解顺序与方式。
第一文主要简述了一下机器学习大致有哪些东西（当然远远不止这些），对大体框架有了一定了解。接着我们根据机器学习的流程一步步来学习吧，掐掉其他不太用得上我们的步骤，精练起来就4步（数据预处理，特征工程，训练模型，模型评估），其中训练模型则是我们的重头戏，基本上所有算法也都是这一步，so，这个最后写，先把其他三个讲了，然后，在结合这三步来进行算法的学习，兴许会好点（个人拙见）。
衡量模型泛化能力的评价标准就是性能度量（模型评估指标、模型评价标准），而针对不同的任务有不同的评价指标。按照数据集的目标值不同，可以把模型评估分为分类模型评估、回归模型评估和聚类模型评估。
四、 回归模型评估指标 均方误差（MSE）、均方根误差（RMSE）、均方对数误差（MSLE）、
平均绝对误差（MAE）​​​​​​、平均绝对百分比误差（MAPE）、
决定系数（R2，R-square）、校正决定系数（Adjusted R-square）
1、均方误差（Mean Squared Error，MSE） 回归任务最常用的性能度量就是均方误差。是预测数据和原始数据对应点误差的平方和的均值。越小越好。
公式：
​
均方误差存在一个明显的缺陷，
假设，现在有三个样本，它们的预测值与真实值的差分别为 3、4、5，通过均方误差的计算公式，我们可以分别计算出这三个样本的误差为 9、16 和 25；第三个样本的误差等于前两个样本的误差和，也就是说样本的预测值离真实值越远，误差也越大，且增长幅度越来越大。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d05e5c10b6f2a0d8ffa9995edcdab69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4f6ac82d5ff91d98d3cdae399726ac2/" rel="bookmark">
			机器学习（三） -- 特征工程（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 机器学习（一） -- 概述
机器学习（二） -- 数据预处理（1-3）
机器学习（三） -- 特征工程（1-2）
机器学习（四） -- 模型评估（1-4）
未完待续……
目录
机器学习（三） -- 特征工程（1）
--- 系列文章目录
前言
三、特征预处理
1.1、无量纲化
2、归一化
2.2.1、线性归一化
2.2.1、***最大最小均值归一化
2.2.1、***最大绝对值归一化
3、标准化
四、特征降维
2、特征选择
2.4、低方差特征过滤
2.5、皮尔逊相关系数（Pearson Correlation Coefficient）
3、主成分分析（PCA）
前言 tips：这里只是总结，不是教程哈。
“***”开头的是给好奇心重的宝宝看的，其实不太重要可以跳过。
此处以下所有内容均为暂定，因为我还没找到一个好的，让小白（我自己）也能容易理解（更系统、嗯应该是宏观）的讲解顺序与方式。
第一文主要简述了一下机器学习大致有哪些东西（当然远远不止这些），对大体框架有了一定了解。接着我们根据机器学习的流程一步步来学习吧，掐掉其他不太用得上我们的步骤，精练起来就4步（数据预处理，特征工程，训练模型，模型评估），其中训练模型则是我们的重头戏，基本上所有算法也都是这一步，so，这个最后写，先把其他三个讲了，然后，在结合这三步来进行算法的学习，兴许会好点（个人拙见）。
三、特征预处理 1、定义 通过一些转换函数，将特征数据转换成更适合算法模型的特征数据的过程。
1.1、无量纲化 也称为数据的规范化，是指不同指标之间由于存在量纲不同致其不具可比性，故首先需将指标进行无量纲化，消除量纲影响后再进行接下来的分析。
数值数据的无量纲化：主要有两种归一化、标准化
为什么要进行归一化/标准化？
特征的单位或者大小相差较大，或者某特征的方法相比其他的特征要大出几个数量级，容易影响（支配）目标结果，使得一些算法无法学习到其它的特征
特征预处理API
sklearn.preprocessing 2、归一化 tips：归一化也叫离差标准化，（标准化，也叫标准差标准化，Z-Score标准化）
2.1、定义 将特征缩放到一个特定的范围，通常是[0, 1]。
2.2、分类和公式 2.2.1、线性归一化 这是最常用的归一化，也叫最大-最小归一化或最大-最小规范化。（后面也是用的这种哈）
2.2.1、***最大最小均值归一化 2.2.1、***最大绝对值归一化 2.3、API sklearn.preprocessing.MinMaxScaler 导入： from sklearn.preprocessing import MinMaxScaler 2.4、实例 # 2、实例化一个转换器类 transform = MinMaxScaler() # transform = MinMaxScaler(feature_range=[2,3]) # 3、调用fit_transform data_new = transform.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4f6ac82d5ff91d98d3cdae399726ac2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b35aaa48a710e403fea447d54c0befc0/" rel="bookmark">
			深度学习中的知识蒸馏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.概念 知识蒸馏（Knowledge Distillation）是一种深度学习中的模型压缩技术，旨在通过从一个教师模型（teacher model）向一个学生模型（student model）传递知识来减小模型的规模，同时保持性能。这个过程涉及到从教师模型的软标签（soft labels）或者特征中提取知识，然后用这些知识来训练一个更小的学生模型。
简单了解一些知识蒸馏的一般步骤和关键概念：
教师模型（Teacher Model）：
教师模型是一个在任务上表现良好的大型深度神经网络。 它可以是一个复杂的模型，有着较大的参数容量。 学生模型（Student Model）：
学生模型是一个规模较小的深度神经网络，通常是一个浅层或者窄层的模型，用于蒸馏知识。 软标签（Soft Labels）：
由于教师模型输出的概率分布被称为软标签。 相对于传统的独热编码的硬标签，软标签包含了更多信息，可以提供模型输出的不确定性。 蒸馏过程：
使用教师模型来生成软标签，然后用这些软标签来训练学生模型。 在训练过程中，通常使用交叉熵损失函数来衡量学生模型的预测和教师模型的软标签之间的相似性。 特征蒸馏：
除了软标签，还可以通过特征蒸馏传递教师模型的中间层特征给学生模型。 这可以通过计算它们之间的距离（如均方误差）来实现。 温度参数（Temperature Parameter）：
温度参数用于控制软标签的平滑程度，从而更好地传递知识。 较高的温度会导致软标签的概率分布更平滑。 二.知识蒸馏的优势包括： 知识蒸馏（Knowledge Distillation）具有多方面的优势，使其成为深度学习中一个受欢迎的技术。以下是知识蒸馏的一些主要优势：
模型压缩： 知识蒸馏可以帮助将复杂大模型的知识转移到更小、更轻量的学生模型中，实现模型的压缩。这对于在资源受限的设备上进行部署非常重要，例如移动设备和嵌入式系统。 推广性能提升： 通过从教师模型中蒸馏知识到学生模型，学生模型有可能学习到教师模型在训练数据上的泛化能力。这有助于提高学生模型的泛化性能，特别是在训练数据有限的情况下。 降低计算成本： 小型学生模型通常需要较少的计算资源和内存，可以更快地进行推理，降低了在实时或者边缘设备上运行的成本。 防止过拟合： 知识蒸馏的过程可以被视为一种正则化技术，可以帮助防止学生模型过度拟合训练数据。教师模型的知识的引入可以提供更多的约束，防止学生模型记住训练数据的噪声。 拓展模型应用： 通过知识蒸馏，可以将在大规模任务上训练的复杂模型中的知识迁移到适用于资源有限环境的小型模型，从而扩展了模型在不同应用场景的应用范围。 训练效率提高： 学生模型的训练通常比教师模型更快，因为学生模型更简单，参数更少。这使得在相同的计算资源下，可以更迅速地完成训练过程。 知识蒸馏是一种强大的技术，被广泛应用于各种深度学习任务，包括图像分类、目标检测、自然语言处理等。
三.大模型下的知识蒸馏 在深度学习中，知识蒸馏（Knowledge Distillation）在大模型下尤其有用。大模型通常包含大量的参数，因此在计算和内存方面的要求更高，而知识蒸馏可以帮助将大模型中的知识迁移到小型模型中，从而实现模型的压缩。
下面的图片来自于
https://arxiv.org/pdf/1908.09355.pdf
具体细节参考相应的论文
知识蒸馏的应用领域： 移动端应用： 在移动设备上，资源有限，而知识蒸馏为在这些设备上运行更轻量的模型提供了解决方案。 边缘计算： 边缘设备上的计算资源有限，因此需要轻量级的模型，知识蒸馏有助于在这些环境中实现高效的深度学习应用。 实时推理： 对于要求实时推理的任务，知识蒸馏使得模型能够更快地进行预测，适应性更强。 节能环境： 通过使用小型模型，可以减少模型的计算需求，从而在云计算等环境中节省能源。 知识蒸馏的挑战和未来发展方向： 泛化性能： 知识蒸馏的一个挑战是确保学生模型在未见过的数据上能够具有较好的泛化性能。 超参数调整： 温度参数和其他超参数的选择可能对知识蒸馏的效果产生显著影响，需要仔细的调整。 对抗攻击： 知识蒸馏可能对对抗性攻击更为敏感，因此需要考虑模型的安全性。 自动化方法： 未来的发展方向可能包括自动化方法，以更有效地确定适用于特定任务的知识蒸馏超参数。 跨模态蒸馏： 将知识蒸馏扩展到跨模态任务，如图像到文本的转换，是一个有趣的研究方向。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faaca3acd98a2ae834daf0e6060a338d/" rel="bookmark">
			机器学习（二） -- 数据预处理（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 机器学习（一） -- 概述
机器学习（二） -- 数据预处理（1-3）
机器学习（三） -- 特征工程（1-2）
机器学习（四） -- 模型评估（1-4）
未完待续……
目录
机器学习（二） -- 数据预处理（1）
机器学习（二） -- 数据预处理（2）
---
系列文章目录
前言
五、***【数据集成】
六、***【数据变换】
七、***【数据归约】
八、数据拆分
前言 tips：这里只是总结，不是教程哈。本章开始会用到numpy，pandas以及matplotlib，这些就不在这讲了哈。
“***”开头的是给好奇心重的宝宝看的，其实不太重要可以跳过。
此处以下所有内容均为暂定，因为我还没找到一个好的，让小白（我自己）也能容易理解（更系统、嗯应该是宏观）的讲解顺序与方式。
第一文主要简述了一下机器学习大致有哪些东西（当然远远不止这些），对大体框架有了一定了解。接着我们根据机器学习的流程一步步来学习吧，掐掉其他不太用得上我们的步骤，精练起来就4步（数据预处理，特征工程，训练模型，模型评估），其中训练模型则是我们的重头戏，基本上所有算法也都是这一步，so，这个最后写，先把其他三个讲了，然后，在结合这三步来进行算法的学习，兴许会好点（个人拙见）。
五、***【数据集成】 将多个数据源中的数据合并，存放于一个一致的数据存储中。
数据集成过程中的关键问题：1. 实体识别、2. 数据冗余和相关分析、3.元组重复、4. 数据值冲突检测与处理
常见的数据集成方式包括：数据堆叠（stack）、数据合并（merge）和数据拼接（concatenate）等。
不算最重要的，大致了解即可。
六、***【数据变换】 数据变换是指将原始数据集转换成适合机器学习算法模型的新数据集的过程，它是机器学习中重要的一步。在数据变换的过程中，常常需要对数据进行特征缩放、特征选择和特征降维等操作。
（提前解答好奇宝宝：其实数据预处理和特征工程，两者并无明显的界限，都是为了更好的探索数据集的结构，获得更多的信息，将数据送入模型中之前进行整理。可以说数据预处理是初级的特征处理，特征工程是高级的数据预处理，也可以说这里的预处理过程是广义的，包含所有的建模前的数据预处理过程。）既然如此这个就特征工程的时候讲。
七、***【数据归约】 数据挖掘时往往数据量非常大，在大量数据上进行挖掘分析需要很长的时间，数据归约技术可以用来得到数据集的归约表示，它小得多，但仍然接近于保持原数据的完整性，并结果与归约前结果相同或几乎相同。也就是说，在归约后的数据集上挖掘将更有效，而且仍会产生相同或相似的分析结果。
数据归约包括维度归约、数量归约和数据压缩。
维度归约：如果数据只有有些维度对数据挖掘有益,就可以去除不重要的维度,保留对挖掘有帮助的维度。
数量归约：另外一种处理数据相关性的方式是将数据表示为不同的形式来减小数据量，如聚类、回归等
数据压缩：如果数据具有潜在的相关性,那么数据实际的维度可能并不高，可以用变换的方式,用低维的数据对高维数据进行近似的表示。
非参数化数据归约包括直方图、抽样、数据立方体聚集等方法。
直方图：直方图方法就是分箱。
抽样：通过选取随机样本（子集），实现用小数据代表大数据的过程。
数据立方体聚集：数据立方体聚集帮助我们从低粒度的数据分析聚合成汇总粒度的数据分析
八、数据拆分 数据拆分：机器学习的数据集划分一般分为两个部分：
训练数据：用于训练，构建模型。一般占70%-80%（数据量越大，取得比例最好越大）
测试数据：用于模型评估，检验模型是否有效。一般占20%-30%
x_train, x_test, y_train, y_test = train_test_split(data, target, test_size=0.2, random_state=125) data：数据 target：标签 test_size：测试集占比。如0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faaca3acd98a2ae834daf0e6060a338d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dd79944704fa541c3efef4d9c90174a/" rel="bookmark">
			YOLOv5&#43;混合注意力机制再涨4.3%，Transformer混合设计依旧可以卷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在工业生产过程中，由于低效率、不统一的评估、高成本以及缺乏实时数据，传统的手动检测焊接缺陷不再被应用。
为了解决表面贴装技术中焊接缺陷检测的低准确率、高误检率和计算成本问题，提出了一种新方法。该方法是一种专门针对焊接缺陷检测算法的混合注意力机制，通过增加准确度并降低计算成本来提高制造过程中的质量控制。混合注意力机制包括提出的增强多头自注意力机制和协调注意力机制，以增加注意力网络感知上下文信息的能力，并提高网络特征利用率。协调注意力机制增强了不同通道之间的连接，减少了位置信息损失。混合注意力机制增强了网络感知长程位置信息和学习局部特征的能力。
改进的算法模型具有良好的焊接缺陷检测能力，mAP达到91.5%，比Yolov5高4.3%，并优于其他比较算法。与版本相比，平均精确率、精确度、召回率和每秒帧数指标也有所提高。在满足实时检测要求的同时，检测准确度的提高是可以实现的。
1 Introduction 表面贴装器件（SMD）引脚在自动生产过程中容易产生焊接缺陷，如引脚短路和引脚偏移，如图1所示。在焊接缺陷检测中，传统的手动检测方法已不再适应工业生产的发展。手动检测效率低、评估不统一、成本高且缺乏实时数据。
计算机视觉是计算机硬件和软件的结合，与工业相机和光源一起捕捉图像。它在各种工业场景中得到应用，用于自动化制造并提高产品质量。基于计算机视觉的焊接缺陷检测系统具有实时、连续和无接触的特点。这种方法可以取代手动检测并提高结果的准确性。目前，计算机视觉在缺陷检测中已得到广泛应用。因此，使用计算机视觉检测焊接缺陷已成为主流趋势。近年来，深度学习技术作为计算机视觉的一个分支得到了迅速发展。正在开发的自动化焊接缺陷检测方法还比较缺乏。焊接缺陷检测方法可以分为三个主要组，即基于特征的方法，统计方法和深度学习方法。
深度学习方法由于其卷积神经网络（CNN）结构，可以从焊接接头图像中学习有效信息和规则，解决人工设计规则难以提取有效特征的问题。深度学习神经网络（DNN）的结构可以分为单阶段和两阶段网络。尽管两阶段DNN比单阶段更准确，但浅层特征需要谨慎利用，以避免在特征提取阶段丢失信息，导致检测率降低。此外，单阶段方法在实时性能方面表现良好，但检测效果对小缺陷区域和低分辨率图像不佳。在缺陷检测的特征提取模块中，目标特征信息丢失过多，导致小缺陷检测率不理想，从而造成严重的漏检问题。深度学习方法使用深度神经网络提取特征，但随着深度神经网络层数的加深，一些浅层信息容易丢失，导致小尺寸目标的漏检。为解决这一问题，采用多尺度特征融合方法在特征提取过程中融合深层和浅层特征，增强不同网络层之间的信息传输。因此，优化特征融合方法可以提高小尺寸目标的检测准确性。
Feature Pyramid Network（FPN）通过多次上采样输入图像，获取不同尺度的特征图像。它将高 Level 的抽象语义信息与特征提取过程中的低级细节，如从上到下提取的轮廓纹理信息相结合，以实现特征提取增强的目标。然而，尽管FPN系统地提取了低级和高级特征，但其特征融合能力仍然无法满足需求，使得浅层特征信息难以保留。
为了在高层和低层特征之间解决缺失信息的问题，刘等人设计了一种Path Aggregation Network（PANet），在特征金字塔的底部连接自下而上的增强路径。这个过程是为了缩短信息融合的传输路径，以增加特征金字塔架构的检测能力。双向特征金字塔网络（BiFPN）是在PANet的基础上构建的，其中只有一个输入的节点被删除，以减少参数计算的数量。通过额外的跳跃传输路径，直接将输入和输出层特征连接，以增强浅层特征的融合能力。BiFPN为每个层赋予自适应学习的权重，并通过权重分配使网络感知不同层的重要性。
多尺度特征融合在小型目标检测中得到广泛应用，通过结合高层语义信息和低层详细信息，显著提高了小型物体的检测性能。然而，FPN的构建主要分为跨层连接和并行分支。虽然这种机制提高了性能，但增加了额外的参数计算和存储空间。因此，需要研究设计一种能够增强缺陷检测器特征融合能力的金字塔特征网络架构。作者提出了一种混合注意力机制来提高特征金字塔网络的特征融合能力。作者将增强的FPN应用到YOLOv5检测模型中。本文设计了比较实验和消融实验，以验证所提出方法在焊接缺陷数据集上的有效性。本文的整体流程图如图2所示。
本文的主要工作和创新点如下。
提出了一种新颖的增强多头自注意力机制（EMSA），以增强网络感知上下文信息的能力，扩大网络特征利用率范围，并使网络具有更强的非线性表达能力。
者将坐标注意力机制（CA）与EMSA相结合，设计了一种混合注意力机制（HAM）网络，以解决特征金字塔网络中浅层特征损失问题，增加网络感知远程位置信息和学习局部特征的能力。
混合注意力机制改进了FPN，并提高了其将功能和网络通道之间的信息传递进行融合的能力。
改进的FPN被应用到YOLOv5检测模型中，这提高了YOLOv5的焊接缺陷检测能力，显著解决了小缺陷的低检测率问题，同时增强了缺陷检测模型的通用适用性。
2 Related Work 2.1 Feature Pyramid Network Feature Pyramid Network（FPN）是一种常用的特征融合方法，用于目标检测，它是一种提取金字塔特征表示的网络模型。通常在目标检测的特征融合阶段使用。在对 Backbone 网络进行底向上特征提取操作后，将FPN连接到相应层的前后相邻特征图，从上到下、横向依次结合 Backbone 网络特征层次中的两个相邻层，构建一个特征金字塔。尽管FPN简单且有效，但仍有某些方面的缺陷。在每一层的特征融合之前，不同层之间存在语义鸿沟，直接融合将对多尺度特征表示能力产生负面影响。在特征融合过程中，金字塔网络高级特征信息在缩放过程中可能会丢失。
基于FPN结构的Path Aggregation Network（PANet）在YOLO目标检测框架及其变体中得到了广泛应用。该网络具有两条特征融合路径，即自上而下和自下而上。这种方法减少了深层和浅层特征之间的融合距离，优化了FPN网络的特征融合方法，提高了目标检测效果。然而，由于添加了自下而上的路径，低级特征信息可能会在网络层加深时丢失，额外的路径增加了计算复杂性和网络参数，降低了网络模型的检测速度。双向特征金字塔网络（BIFPN）引入了跳跃连接，利用跳跃连接在特征输入和输出层之间传递信息。因为操作在同一层，这种方法可以与较少的参数结合更多的特征。为了实现更多的特征融合，BIFPN计算同一层参数多次，将每条双向路径视为一个特征网络层。
自适应空间特征融合（ASFF） 是在2019年提出的一种具有自适应能力的特征融合算法。它可以通过权重选择自适应地获取重要信息，从而提高特征融合的有效性。通过学习不同特征图之间的连接，ASFF可以解决特征金字塔中不同大小的特征之间的不一致问题。它具有易实现、低成本和广泛应用的优点。钱等人[1]提出了一种中心化特征金字塔（CFP），它基于全局显式中心化特征规则，可以在目标检测模型中使用。这种方案提出了一种通用的内层特征调整方法，使用轻量级多层感知机（MLP）捕获全长度距离相关性，并强调使用内层特征规则，可以有效地获取全面但差异化的特征表示。CFP网络可以有效提高YOLOv5和YOLOX的目标检测能力。它在公共数据集MS-COCO上提高了mAP值1.4%，但计算复杂性相对较高。
FPN在多个涉及缺陷检测的实例中得到了应用。Chen等人[14]使用YOLOv3进行SMD LED芯片缺陷检测，使用基本FPN作为特征融合模块。它对缺失组件、缺失线和反向极性缺陷的检测率合理，但对表面缺陷的检测率较低。原因是表面缺陷的大小相对较小且分布位置不确定，因此难以检测。Yang等人[17]使用YOLOv5进行钢材表面缺陷检测，使用Path Aggregation Feature Pyramid Network（PAFPN）作为特征融合模块检测钢材表面六种缺陷，实现了良好的实时检测结果，但对小型缺陷目标的检测率较低。Du等人[15]使用增强的YOLOv5进行PCB缺陷检测，使用BiFPN作为特征融合模块检测PCB表面缺陷。mAP50指数达到95.3%，但对任务孔和开路缺陷的小型缺陷的mAP值较低。任务孔缺陷是指由于PCB上的焊盘插座中缺乏焊料而形成的孔效应。开路缺陷指的是PCB上的电路断开。
Han等人[10]设计了一种YOLO改进方案，用BiFPN代替原始PAFPN，并在BiFPN中使用自注意力机制将上采样和下采样处理模块嵌入，以提高表面缺陷检测任务中模型的检测率。然而，检测较小缺陷的能力较弱。因此，为了提高缺陷检测网络的检测性能，有必要设计一种增强的注意力机制来提高FPN的特征融合能力，从而减少对小尺寸缺陷的漏检率。近年来，许多研究利用注意力机制来增强缺陷检测框架的检测能力。注意力机制是一种使神经网络能够专注于特定目标的功能。
2.2 Attention Mechanism 众多的输入信息包括任务所需的关键和无关信息。注意力机制可以关注这些关键信息，同时过滤无关信息。注意力机制的灵感来源于人类视觉系统，它可以快速浏览图像，定位感兴趣的目标区域，并增强对目标区域的关注，从而获取该区域的重要信息并抑制来自其他无关区域的干扰。胡等人提出了一个名为Squeeze and Stimulation（SE）的注意力模块。这个注意力模块通过挖掘特征通道之间的互依赖关系来自适应地修正每个通道的权重参数，使网络能够关注更多的关键特征信息。吴等人[17]扩展了空间维度，并设计了卷积块注意力模块（CBAM）。
通过顺序构建通道注意力模块（CAM）和空间注意力模块（SAM），增强了网络分离和增强特征信息的能力。有效通道注意力（ECA）模块[18]使用一维卷积操作来提取通道之间的依赖关系，实现跨通道交互。它解决了SE由于压缩维度减少而无法有效提取通道之间依赖关系的问题。ECA具有较低的计算复杂性，对网络速度的影响较小。
张等人[19]将ECA嵌入YOLOv5的特征融合网络中，用于太阳能电池表面缺陷检测，增强了PAFPN融合太阳能电池表面缺陷特征的能力，从而进一步提高缺陷检测率。在数据集上的mAP50值为84.23%。然而，ECA对较小特征图的计算开销较大。
为了更好地检测钢表面的表面缺陷，钱等人[18]将CA机制引入检测网络。mAP值为79.23%，而召回值为62.4%。CA机制需要计算整个特征图的注意力权重，因此无法捕捉长程依赖关系。为了解决小面积检测中的长程依赖关系，收集语义信息至关重要。另一方面，视觉Transformer（ViT）完全依赖自注意力来捕捉长程全局关系，其准确性优于卷积神经网络（CNN）。ViT在2020年被引入计算机视觉领域，并在视觉领域取得了良好的性能。
2.3 Vision Transformer 视觉Transformer在计算机视觉领域取得了良好的性能，因为它使用了多头自注意力（MSA）机制。MSA机制是一种与CNN不同的特征提取方法，可以建立全局依赖关系并扩展图像的感知场。与CNN相比，ViT的感知面积更大，可以收集更多的上下文信息。
然而，由于过滤器效率低下，一些对检测至关重要的信息被移除。ViT没有利用特征定位、翻译不变性和图像尺度的先验知识。ViT捕获充分信息的能力比CNN弱，且不能利用图像本身特征定位、翻译不变性和图像尺度的先验知识。ViT模型设计采用缩放点积注意力机制。ViT首先将图像分成非重叠、固定大小的图像块，并将图像块 flatten 成一维向量进行线性投影，以实现特征提取。
Swin Transformer是另一种Transformer类型。Swin Transformer利用局部注意力和位移窗口多头自注意力机制（SW-MSA）实现局部和全局特征之间的交互，在各种视觉任务中取得良好结果，并解决了ViT局部信息易受损害的问题。
自注意力机制和注意力机制之间的区别在于， Query 和键来自不同的来源，而自注意力机制的 Query 和键来自同一组元素。朱等人设计了一个用于无人机图像中微小目标检测的Transformer预测头YOLOv5（TPH-YOLOv5）模型。该模型使用Transformer检测低分辨率特征图，增强网络提取不同局部信息的能力，并实现高密度目标更好的性能。然而，将Transformer模块分布在模型的多个部分导致了显著的计算工作量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dd79944704fa541c3efef4d9c90174a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11e0485c715cf487f45c43bddee89092/" rel="bookmark">
			谈谈我的三次考研经历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿七经历过三次考研。
第一次，大四毕业那年，大三开始有紧迫感，因为大学几年什么也没学会，毕业考试成绩从第二个学期开始就一路下滑，每次都是考前一周突击，最后擦着及格线通过。
大三就开始和几个同学组队准备考研，在准备了一年之后步入考场，考完之后。
也进入了毕业季，懵懵懂懂地也不知道干嘛，社会上有什么岗位，连秋招、春招是什么都不知道，想想那个时候真像个傻逼。
由于那个时候沉迷于小说，这一次刚过国家线，与研究生无缘。
第二次，毕业之后第一年，因为不知道干什么，考研小伙伴让我再战一年，他们刚好在北京读研，还能支援一下。
这样，我在目标院校门口的小区花了 1200 每个月的租金，租下了一个阳台，阳台上有一个上下铺，和另外一个同学一起再次备战考研，结果双双落榜。
之后幡然醒悟，开始找工作。
刚开始看到一个外汇交易的工作，我很有兴趣，因为我的毕业论文写的就是外汇交易。
外汇交易，还是源自于我的一个表哥，大学没毕业就开始各种创业，进入一个外汇交易工作室，知道我要做毕设，就把我拉进去研究，顺便干干苦力活～
这个外汇交易的工作的流程是，经过一天的简单培训，让自己付钱（找人借的）开一个外汇交易账户，自己进行交易，如果一个月之后，你的收益率能达到要求的水平（记得好像是 20% 还是 30%），就会招聘你当外汇交易员。
因为这是一个不需要办公场所的工作，只需要一台电脑，我就在回龙观附近租了一个床位，有空的时候看看外汇大盘，定点交易。
同时，因为这并不是一个确定性强的工作，因为我也不知道自己是否能够达到要求的收益率。所以，同时在各个招聘网站上找工作。
之后，就和一篇旧文所说，经过贷款培训成功进入了 IT 行业，成为了一名程序员。
在工作的第二个年头，国家对于研究生改革，出了非全日制研究生，需要参加全国统考，颁发学历证书和学位证书双学位。
第一年，因为知道的较晚错过了，但是第二年，女朋友（现在是媳妇了）鼓励我考一个 985 的非全日制研究生。
改革第二年，我开始了我的第三次考研之旅。
这一次不同于以往，我在社会上摸爬滚打了差不多 2 年多了，深刻的知道自己作为程序员对比于科班程序员有太多的不足，基本功太差。
也没有自己的程序员圈子，迫切的想要破圈。
我的目标院校，北航，又是一个 IT 行业认可度非常高的一个学校（找猎头确认过）。
所以，我斗志十足，最后的两个月，我主业 995，但是我每天早上 5 点起床，学习 2-3 个小时，最后一个月，每天早上做一套真题。之后，再去上班。
晚上下班回来之后，继续学习到 12 点。
最后准备的两个月，我每天把自己的精力消耗的一点不剩。
依靠着打死都要的决心、精密的时间管理、不断优化的计划、强计划执行力，我终于，在这次考上了北航软件学研的研究生！
有意思的是，这里面，还有两个插曲。
第一个插曲，最后报名阶段，我觉得自己准备的并不充分，害怕考不上北航，还想报考北交的研究生，幸运的被媳妇劝退了～
第二个插曲，考试阶段，这个全国统考，没有北京户口是需要回户籍地考试的，我在公司同事都不知道的情况下，请了周五一天假飞机往返 3600 公里，成功完成考试。
考数学的时候，没想到这一年，数学特别难，看一题不会，下一题还是不会，心态都崩了，考完感觉自己肯定不及格。一度想要放弃后续的考试（最后发现，真的有三分之一的最后的专业课没来考试）。
但是，相当自己千里迢迢来到这，怎么也要完成考试，但是又提不起劲。中午在饭店，点了最贵的一道辣椒排骨，吃得满身出汗，去宾馆睡了一觉，鼓足勇气参加了下午的专业课考试。
最后成绩出来，虽然我的数学是不及格，但是我的其他几门课程成绩都很好，最后成功拿到北航的录取通知书！
最后，我想说说
做什么事情，一定要明确自己的需求，找到自己的痛点。当一件事情，你真的非常想要的时候，你才会付出 100 分的努力去做成它。
考研本身，没有对错。但是，只有这件事情你的很想要的时候、对你非常有用的时候，你再去做它。
之于我自己，前两次的失败，其实都是因为我自己并没有考虑清楚自己想要什么，只是随大流。这样，很容易就被其他事情所干扰，我就是被小说里的世界吸引走了。
当然，有些人因为运气或者其他因素，没有被干扰，最终考上了，那其实大概率也不是适合你的路。
我前两次考研，考的都是经济学硕士（学硕），现在我很庆幸，没让我考上，让我入行了 IT。
我很喜欢现在的工作，我也能看到考上金融专硕的同学的工作状态，我知道自己并不适合。
因为喜欢，我干的很快乐，它也让我成功从一个山里娃在北京最难落户的城市落地生根（有房有车、有妻有娃）。
愿大家都能找到最适合自己的道路！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c7a4818b908206bcaf9330e52c9f54f/" rel="bookmark">
			深度学习｜4.1 深L层神经网络 4.2 深层网络的正向传播
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4.1 深L层神经网络 对于某些问题来说，深层神经网络相对于浅层神经网络解决该问题的效果会较好。所以问题就变成了神经网络层数的设置。
其中 n [ i ] n^{[i]} n[i]表示第i层神经节点的个数， w [ l ] w^{[l]} w[l]代表计算第l层所采用的权重系数， b [ l ] b^{[l]} b[l]代表计算第l层所用的偏移量， g [ i ] g^[i] g[i]表示第i层所配置的激活函数，常见的激活函数有sigmoid，tanh、relu和leaky-relu等。 b [ i ] b^[i] b[i]表示第i层配置的参数/偏移量
4.2 深层网络中的正向传播 为了统一格式，可以将输入向量x改写成 a [ 0 ] a^{[0]} a[0]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/819497935ba26890889a2a1a91aa6388/" rel="bookmark">
			神经网络-搭建小实战和Sequential的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CIFAR-10 model structure 通过已知参数（高、宽、dilation=1、kernel_size）推断stride和padding的大小 网络 import torch from torch import nn class Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() self.conv1 = nn.Conv2d(in_channels=3, out_channels=32, kernel_size=5, stride=1, padding=2) self.maxpool1 = nn.MaxPool2d(kernel_size=2) self.conv2 = nn.Conv2d(in_channels=32, out_channels=32, kernel_size=5, stride=1, padding=2) self.maxpool2 = nn.MaxPool2d(2) self.conv3 = nn.Conv2d(32, 64, 5,padding=2) self.maxpool3 = nn.MaxPool2d(2) self.flatten = nn.Flatten() self.linear1 = nn.Linear(1024, 64) self.linear2 = nn.Linear(64, 10) def forward(self, x): x = self.conv1(x) x = self.maxpool1(x) x = self.conv2(x) x = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/819497935ba26890889a2a1a91aa6388/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ff0ec07a18c3f67cc8833b5dfaf70ae/" rel="bookmark">
			数据结构：树详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建二叉树 给出了完整的先序遍历序列，子树为空用’#’表示，所以这样我们在通过先序遍历序列创建二叉树时我们直到先序遍历序列是先进行根结点，然后左子树最后右子树的顺序进行遍历的，所以对于完整的先序遍历序列我们可以直到先序遍历序列中第一个元素是二叉树的根结点，如果第二个元素不为’#’，那么这个代表二叉树有左孩子，而且左孩子的值为先序遍历序列的第二个元素的值，依次类推，根据二叉树的完整先序遍历序列我们可以直到每一个结点是否为空，这样我们就能够采取递归形式进行二叉树的创建：
创建过程的图示为如下：
最终我们得到的树如下图所示：
有了上面的思路我们可以写出如下代码：
void InitBinaryTree(char *p, int *length, struct BinaryTreeNode **root){ if(p[*length]!=0){ if(p[*length]!='#'){ *root = (struct BinaryTreeNode *)malloc(sizeof(struct BinaryTreeNode)); (*root)-&gt;val = p[*length]; (*root)-&gt;left = NULL; (*root)-&gt;right = NULL; (*length)++; InitBinaryTree(p, length, &amp;(*root)-&gt;left); InitBinaryTree(p, length, &amp;(*root)-&gt;right);	}else{ (*length)++; } } } 这就是通过树的完整前序遍历序列创建二叉树的过程。
下面我们来进行实现二叉树的前序遍历、中序遍历与后序遍历，前序遍历是指先根结点再左子树最后右子树，中序遍历是先左子树然后根结点最后右子树，后序遍历是先左子树然后右子树最后根结点，这种遍历可以通过递归进行实现，在每次递归中所在结点不为NULL就说明结点有值，我们需要遍历这一个结点的左子树与右子树，也就是递归截至的条件是root==NULL;有了这样的思路前序遍历与中序遍历，与后序遍历就只是根结点的访问顺序发生改变，我们可以写出下面的三种遍历的代码：
前序遍历：
//本函数实现二叉树的前序遍历功能 void preOrderTraversal(struct BinaryTreeNode *root){ if(root!=NULL){ printf("%c ", root-&gt;val); preOrderTraversal(root-&gt;left); preOrderTraversal(root-&gt;right);	} } 中序遍历：
//本函数实现二叉树的中序遍历功能 void inOrderTraversal(struct BinaryTreeNode *root){ if(root!=NULL){ inOrderTraversal(root-&gt;left); printf("%c ", root-&gt;val); inOrderTraversal(root-&gt;right);	} } 后序遍历：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ff0ec07a18c3f67cc8833b5dfaf70ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a5b5ed25ea6429618e95bba996ef528/" rel="bookmark">
			嵌入式（五）通信协议 | 串行异步同步 UART SPI I2C 全解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 串口通信协议1 通用异步收发传输器 UART1.1 串口配置1.2 串口初始化1.3 串口发送和接收方式1.3.1 轮询方式发送1.3.2 中断方式发送1.3.3 查询方式接收1.3.4 中断方式接收 2 串行外设接口 SPI2.1 标准的四线SPI接口2.2 SPI的四种模式2.3 配置2.4 发送和接收Master向Slave传输数据Slave向Master传输数据液晶屏接口 3 I2C总线接口 I2C3.1 通信时序解析3.2 寻址及其示例3 3通信速率3.4 传送和接收 读写数据 这节我们讲串行通信方式UART，SPI，I2C 先来看一下常见的通信方式分类方法
串行or并行？
​ 串行通信 一次只能发送一位，要发送8次才能发送一个字节。
​ 并行通信 通信时数据的各个位同时传送，可以实现字节为单位通信，但是通信线多占用资源多，成本高。
**同步or异步？ **
​ 同步通信：所有设备使用一个共同的时钟信号，发送和接收双方严格按照该时钟信号处理数据的发送和接收。同步通信的优点是数据传输速率高，缺点是要求发送时钟和接收时钟保持严格同步。 SPI和I2C属于同步通信。
​ 异步通信：异步通信中，每个设备都有自己的时钟信号，通信双方的时钟频率保持一致。异步通信以字符为单位进行数据传送，每一个字符均按照固定的格式传送，被称为帧，即串行异步通信一次传送一个帧。UART属于串行异步通信
​
0 串口通信协议 串口通信
​ 串口通信，顾名思义也就是利用串行接口进行通信。串口通信和串行通信的区别在于：串行通信是一种概念，串口通信是一种是实现串行通信的具体的通信手段。
​ 串口通信连接包括两根线，发送和接受双方交叉连接
​ 一个RXD（Receive Data，RXD），表示接收数据
​ 一个TXD（Transmit Data，RXD），表示发送数据
1 通用异步收发传输器 UART 串行通信，异步通信，既可以半双工也可以全双工
那么实际传输过程中，串口通信是一帧一帧组成的。每一帧数据由起始位（低电平）、数据位、奇偶校验位（可选）、停止位（高电平）组成
1.1 串口配置 而通信前，需要进行配置协商，需要配置的量有
​ 串口号
​ 波特率：波特率必须一致，是传输速率，每秒传多少码元
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a5b5ed25ea6429618e95bba996ef528/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/544fa59f5dc17cb3a0af7925c2c820c7/" rel="bookmark">
			【c语言】程序环境和预处理（内功更上一层）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇重点 程序的翻译环境
程序的执行环境
详解：C语言程序的编译+链接
预定义符号介绍
预处理指令 #define
宏和函数的对比
预处理操作符#和##的介绍
命令定义
预处理指令 #include
预处理指令 #undef
条件编译
1.程序的翻译环境和执行环境 在ANSI C中的任何一种实现中，存在两个不同的环境
第一种是翻译环境，在这个环境中源代码被转换成机器可以执行的机器代码
第二种是执行环境，它用于实际执行代码
2.详解编译加链接 2.1 编译环境 组成一个程序的每个源文件通过编译过程转换成目标文件的代码。每个目标文件通过链接器捆绑在一起，形成一个单一而完整的可执行的程序。链接器同时也会引入标准C函数库中任何被该程序所用到的函数，而且它可以搜索程序员个人
的程序库，将其需要的函数也链接到程序中。 2.2 编译本身也分为几个阶段： sum.c文件
int g_val = 2016; void print(const char *str) { printf("%s\n", str); } #include &lt;stdio.h&gt; int main() { extern void print(char *str); extern int g_val; printf("%d\n", g_val); print("hello bit.\n"); return 0; } test.c文件
#include &lt;stdio.h&gt; int main() { extern void print(char *str); extern int g_val; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/544fa59f5dc17cb3a0af7925c2c820c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad1c4ed7d8f05441402539cb39936028/" rel="bookmark">
			【数据结构】栈和队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、栈 1.栈的概念与结构 栈是一种特殊的线性表，即栈也是线性表，可见栈的特性，栈只运行在特定的一端进行插入和删除操作，这一端我们就叫为栈顶，另一端我们称为栈底，所以栈有一个很重要的性质，即所有入栈的元素都遵循后进先出LIFO（last in first out）的原则。
2.栈的具体实现 栈的实现有两种实现方式，一种是链表，一种是顺序表，如果是链表的话也是可以实现的，我们知道单链表的尾插是需要遍历链表找到尾才可以尾插，故代价比较大，而顺序表的数组就相对代价小了很多，所以我们的栈是用顺序表实现的。
下面贴上栈的具体实现代码：
Stack.h --- 实现栈的函数的声明，类型的定义等等
#define _CRT_SECURE_NO_WARNINGS 1 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;assert.h&gt; #include&lt;stdbool.h&gt; // 支持动态增长的栈 typedef int STDataType; typedef struct Stack { STDataType* a; int top;	// 栈顶 int capacity; // 容量 }ST; // 初始化栈 void STInit(ST* ps); // 入栈 void STPush(ST* ps, STDataType data); // 出栈 void STPop(ST* ps); // 获取栈顶元素 STDataType STTop(ST* ps); // 获取栈中有效元素个数 int STSize(ST* ps); // 检测栈是否为空，如果为空返回非零结果，如果不为空返回0 bool STEmpty(ST* ps); // 销毁栈 void STDestroy(ST* ps); Stack.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad1c4ed7d8f05441402539cb39936028/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/914e883938704683137a5229c462c677/" rel="bookmark">
			Springboot整合RocketMQ 基本消息处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 同步消息
2. 异步消息
3. 单向消息
4. 延迟消息
5. 批量消息
6. 顺序消息
7. Tag过滤
8. 广播消息
导入依赖
&lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; YAML配置
rocketmq: name-server: localhost:9876 producer: group: test-group-producer #生产者必须配备生产者组 1. 同步消息 同步消息是发送消息后等待Broker的响应，确保消息被成功接收。
生产者：
@Autowired RocketMQTemplate rocketMQTemplate; @Test void contextLoads() { SendResult result = rocketMQTemplate.syncSend("test", MessageBuilder.withPayload("同步消息").build()); // SendResult result = rocketMQTemplate.syncSend("test", "同步消息"); System.out.println("发送状态：" + result.getSendStatus() + " 消息id：" + result.getMsgId()); } 2. 异步消息 异步消息是发送消息后不等待Broker响应，通过回调函数处理发送结果。
@Autowired RocketMQTemplate rocketMQTemplate; @Test void contextLoads() { rocketMQTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/914e883938704683137a5229c462c677/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cd0ff9ada9015aeffd5fcf11f0be688/" rel="bookmark">
			【数据结构】二叉树的概念及堆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我们已经学过了顺序表、链表、栈和队列这些属于线性结构的数据结构，那么下面我们就要学习我们第一个非线性结构，非线性结构又有哪些值得我们使用的呢？那么接下来我们就将谈谈树的概念了。
1.树的概念与结构 1.1树的概念 树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
有一个特殊的结点，称为根结点，根节点没有前驱结点。除根节点外，其余结点被分成M(M&gt;0)个互不相交的集合T1、T2、……、Tm，其中每一个集合Ti(1&lt;= i &lt;= m)又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱，可以有0个或多个后继。树是递归定义的。 注意：树形结构中，子树之间不能有交集，否则就不是树形结构，那样可能是图了，后续还会学习。
1.2树的相关概念 节点的度：一个节点含有的子树的个数称为该节点的度； 如上图：A的为6
叶节点或终端节点：度为0的节点称为叶节点； 如上图：B、C、H、I...等节点为叶节点
非终端节点或分支节点：度不为0的节点； 如上图：D、E、F、G...等节点为分支节点
双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B的父节点孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 如上图：B是A的孩子节点
兄弟节点：具有相同父节点的节点互称为兄弟节点； 如上图：B、C是兄弟节点
树的度：一棵树中，最大的节点的度称为树的度； 如上图：树的度为6
节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
树的高度或深度：树中节点的最大层次； 如上图：树的高度为4
堂兄弟节点：双亲在同一层的节点互为堂兄弟；如上图：H、I互为兄弟节点
节点的祖先：从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先
子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙
森林：由m（m&gt;0）棵互不相交的树的集合称为森林；
1.3树的表示 树结构相对线性表就比较复杂了，要存储表示起来就比较麻烦了，既要保存值域，也要保存结点和结点之间的关系，实际中树有很多种表示方式如：双亲表示法，孩子表示法、孩子双亲表示法以及孩子兄弟表示法等。我们这里就简单的了解其中最常用的孩子兄弟表示法。
typedef int DataType;
struct Node
{
struct Node* firstchild; //第一个孩子节点
struct Node* pnextbrother; //指向其下一个兄弟节点
DataType data; //结点中的数据域
};
1.4树在实际中的运用（表示文件系统的目录树结构） Linux中的文件目录就是按照一种树形结构来实现的。
2.二叉树的概念与结构 2.1概念 一棵二叉树是结点的一个有限集合，该集合:
或者为空由一个根节点加上两棵别称为左子树和右子树的二叉树组成 从上图可以明显看出：
二叉树不存在度大于2的结点 二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树注意：对于任意的二叉树都是由以下几种情况复合而成的： 2.2现实中的二叉树 简直是大自然的奇迹，相信当我们程序员看到这样一颗树，呼之欲出的就是二叉树啦。 2.3特殊的二叉树 满二叉树：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是 2^k-1，则它就是满二叉树。完全二叉树：完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 要注意的是满二叉树是一种特殊的完全二叉树。 2.4二叉树的性质 1. 若规定根节点的层数为1，则一棵非空二叉树的第i层上最多有 2^（i-1）个结点.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cd0ff9ada9015aeffd5fcf11f0be688/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f808f7992fba781f2d73d9b3c7e74bd8/" rel="bookmark">
			小家电type-c接口PD诱骗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小家电Type-C接口PD诱骗：未来充电的便捷与安全
随着科技的不断发展，Type-C接口已经成为了许多小家电产品的标配。而PD（Power Delivery）诱骗技术，作为一种新兴的充电技术，更是为小家电产品的充电带来了前所未有的便捷与安全。
一、Type-C接口的普及
Type-C接口，作为一种新型的USB接口，具有正反插、传输速度快、支持多种功率传输等特点。正因为这些优点，越来越多的厂商开始在小家电产品上采用Type-C接口。消费者在使用时，只需要一根Type-C线缆，就可以轻松实现充电或数据传输，大大提高了使用体验。
二、PD诱骗技术的崛起
PD诱骗技术，是一种基于Type-C接口的充电技术。它能够自动识别接入设备的功率需求，并自动调整输出电压和电流，以满足设备的充电需求。与此同时，PD诱骗技术还能够实现快速充电，大大缩短了充电时间，为消费者带来了实实在在的便利。
三、便捷与安全并存
与传统充电方式相比，采用Type-C接口和PD诱骗技术的小家电产品，不仅在充电速度和便捷性上有着明显的优势，更是在安全性上有着可靠的保障。这种技术可以有效地避免因电压或电流不稳定而引起的设备损坏或安全隐患。
面对更多的应用场景，市场对于PD协议芯片的要求也越来越高。乐得瑞针对设备取电场景推出了LDR6328Q多协议取电芯片，支持PD+QC+AFC协议，可以从PD/QC/AFC协议适配器上取到需要电压，并且可以自行配置诱骗电压，有9V,12V,15V,20V可以选。
LDR6328Q从适配器诱骗电压到后端用电器使用，比如一些品牌蓝牙音箱更新为Type-C接口是12V快充，那么充电效率是会比传统的5V充电快很多倍，那么体验感比之前充电几小时好。
LDR6328Q封装小巧，价格低廉，非常适合消费类产品，采用Type-C接口供电，厂商也能少配一个专用适配器，节约了不少成本，用户也更方便，携带设备出门只需带一个适配器即可，不用再像从前一样准备多种不同适配器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5777e796c06b915c189cd8d73208d4e/" rel="bookmark">
			【100条mysql常用命令】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当然，这里是一些常用的 MySQL 命令列表，用于管理数据库和执行各种查询操作：
SHOW DATABASES; - 显示所有数据库CREATE DATABASE database_name; - 创建新数据库USE database_name; - 选择要操作的数据库DROP DATABASE database_name; - 删除数据库SHOW TABLES; - 显示所有的表SHOW COLUMNS FROM table_name; - 显示表的字段DESCRIBE table_name; - 显示表的结构SELECT * FROM table_name; - 显示表中的所有数据SELECT column1, column2, … FROM table_name; - 显示指定列的数据SHOW INDEX FROM table_name; - 显示表的索引信息SHOW CREATE TABLE table_name; - 显示表的创建语句CREATE TABLE table_name (column1 datatype, column2 datatype, …); - 创建新表ALTER TABLE table_name ADD column_name datatype; - 在表中添加新列ALTER TABLE table_name DROP column_name; - 从表中删除列ALTER TABLE table_name MODIFY column_name datatype; - 修改列的数据类型DROP TABLE table_name; - 删除表INSERT INTO table_name (column1, column2, …) VALUES (value1, value2, …); - 向表中插入新行UPDATE table_name SET column1 = value1, column2 = value2, … WHERE condition; - 更新表中的数据DELETE FROM table_name WHERE condition; - 从表中删除数据TRUNCATE TABLE table_name; - 清空表中的数据CREATE INDEX index_name ON table_name (column1, column2, …); - 创建新索引DROP INDEX index_name ON table_name; - 删除索引SELECT COUNT(*) FROM table_name; - 检索表中的记录数量SELECT MAX(column_name) FROM table_name; - 检索表中某列的最大值SELECT MIN(column_name) FROM table_name; - 检索表中某列的最小值SELECT AVG(column_name) FROM table_name; - 计算表中某列的平均值SELECT SUM(column_name) FROM table_name; - 计算表中某列的总和SELECT DISTINCT column_name FROM table_name; - 检索表中列的唯一值SELECT * FROM table_name WHERE condition; - 检索满足条件的记录SELECT * FROM table1 JOIN table2 ON table1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5777e796c06b915c189cd8d73208d4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62e15cbbb0f3dde9d53e9ef002854496/" rel="bookmark">
			虚析构函数（C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4.3 虚析构函数 4.3 虚析构函数 C++允许将析构函数定义为虚函数，为什么？
#include &lt;iostream&gt; using namespace std; class Base{ public: Base(){ cout &lt;&lt; "Base 通过 new 申请100个字节内存空间" &lt;&lt; endl; } ~Base(){ cout &lt;&lt; "~Base 通过 delete 释放100个字节内存空间" &lt;&lt; endl; } }; class Derived:public Base{ public: Derived(){ cout &lt;&lt; "Derived 通过 new 申请200个字节内存空间" &lt;&lt; endl; } ~Derived(){ cout &lt;&lt; "~Derived 通过 delete 释放200个字节内存空间" &lt;&lt; endl; } }; int main(void) { Base *pb = new Derived; delete pb; //只调用了基类的析构函数 造成内存泄漏 return 0; } //输出结果 myubuntu@ubuntu:~/lv19/cplusplus/dy05$ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62e15cbbb0f3dde9d53e9ef002854496/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d40111b954a94b5b73d246a12512ebd1/" rel="bookmark">
			React 实现拖放功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 本篇文章将会使用react实现简单拖放功能。
样例 布局拖放 LayoutResize.js import React, {useState} from "react"; import { Button } from "antd"; import "./LayoutResize.css"; export const LayoutResize = () =&gt; { const [state,setState] = useState({ dragging: false, startPageX: 0, siderWidth: 150, }) // 鼠标点击事件 const handleMouseDown = evt =&gt; { setState({ ...state, dragging: true, startPageX: evt.pageX, }); }; // 鼠标抬起事件 const handleMouseUp = () =&gt; { setState({ ...state, dragging: false, }); }; // 鼠标移动事件 const handleMouseMove = evt =&gt; { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d40111b954a94b5b73d246a12512ebd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/370372e41d3ad2eacccdc1938de6ca05/" rel="bookmark">
			c语言版：数据结构（时间复杂度，空间复杂度，练习）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间复杂度 概念 时间复杂度是用来衡量算法执行时间的一个指标。它表示随着输入规模的增加，算法执行时间的增长率。时间复杂度通常用大O符号表示。
在计算时间复杂度时，通常会忽略常数项、低阶项和系数项，只关注随着输入规模增长而导致的主要影响。这是因为在实际应用中，常数项、低阶项和系数项的影响往往可以忽略不计。
常见的时间复杂度有以下几种：
常数时间复杂度（O(1)）：无论输入规模的大小，算法的执行时间都是恒定的。
线性时间复杂度（O(n)）：算法的执行时间与输入规模成正比。
对数时间复杂度（O(log n)）：算法的执行时间与输入规模的对数成正比。
平方时间复杂度（O(n^2)）：算法的执行时间与输入规模的平方成正比。
指数时间复杂度（O(2^n)）：算法的执行时间与输入规模的指数成正比。
练习 // 请计算一下Func1基本操作执行了多少次？ void Func1(int N) { int count = 0; for (int i = 0; i &lt; N ; ++ i) { for (int j = 0; j &lt; N ; ++ j) { ++count; } } for (int k = 0; k &lt; 2 * N ; ++ k) { ++count; } int M = 10; while (M--) { ++count; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/370372e41d3ad2eacccdc1938de6ca05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3db0e9fb8cf262ef8802386a3162474/" rel="bookmark">
			libexif库介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		libexif是一个用于解析、编辑和保存EXIF数据的库。它支持EXIF 2.1标准(以及2.2中的大多数)中描述的所有EXIF标签。它是用纯C语言编写的，不需要任何额外的库。源码地址：https://github.com/libexif/libexif ，最新发布版本为0.6.24，它的license为LGPL-2.1。
EXIF全称为Exchangeable Image File format，可交换图像文件格式，是专门为数码相机的照片设定的文件格式，可以记录数码照片的属性信息和拍摄数据。EXIF可以附加于JPEG、TIFF、RIFF等文件之中，为其增加有关数码相机拍摄信息的内容和索引图或图像处理软件的版本信息。EXIF信息是可以被任意编辑的，因此只有参考的功能。
EXIF信息以0xFFE1作为开头标记，后两个字节表示EXIF信息的长度。所以EXIF信息最大为64kB，而内部采用TIFF格式。
libexif在Windows和Linux上编译过程：
从https://github.com/libexif/libexif.git clone源码，然后切换到tag v0.6.24,执行：git checkout v0.6.24
1.Linux上编译：
(1).需要先安装依赖，执行如下命令：
sudo apt install autoconf autopoint libtool (2).编译源码，依次执行如下命令：
autoreconf -i ./configure --prefix=${PWD}/install --disable-docs make make install 编译完成后在install目录下，会生成include、lib、share三个目录。
2.Windows上编译：
(1).新建libexif工程，参考Linux下生成的libexif.a中的文件，将相关文件添加到工程中；
(2).将Linux下生成的config.h文件做调整并添加到libexif工程中，调整后的config.h内容如下：
/* config.h. Generated from config.h.in by configure. */ /* config.h.in. Generated from configure.ac by autoheader. */ /* Define to 1 if translation of program messages to the user's native language is requested. */ /* #undef ENABLE_NLS */ #define GETTEXT_PACKAGE "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3db0e9fb8cf262ef8802386a3162474/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe1930fae533c788eaf25d1cf029baea/" rel="bookmark">
			2024 IRIS CTF-PWN-【insanity-check】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 __attribute__((section(".flag")))insanity-check源码exp attribute((section(“.flag”))) attribute相关知识
attribute相关知识
insanity-check 源码 发现溢出后字符串末尾的.com和四个空字符就是函数win（）的地址，溢出即可
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; void rstrip(char* buf, const size_t len) { for (int i = len - 1; i &gt;= 0; i--) if (buf[i] == '\n') { buf[i] = '\0'; break; } } const char suffix[] = "! Welcome to IrisCTF2024. If you have any questions you can contact us at test@example.com\0\0\0\0"; int main() { char message[128]; char name[64]; fgets(name, 64, stdin); rstrip(name, 64); strcpy(message, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe1930fae533c788eaf25d1cf029baea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/894a478e4f12b0ce216dc6914b9b7039/" rel="bookmark">
			【LeetCode每日一题】2807. 在链表中插入最大公约数（模拟&#43;求最大公约数的6中写法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024-1-6
文章目录 [2807. 在链表中插入最大公约数](https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/)思路：模拟求最大公约数的几种方法： 1.暴力枚举法2.辗转相除法3.辗转相除法 ---递归调用4.辗转相除法 ---递归调用---简化写法5.调用函数递归 更相减损法6.调用函数递归 更相减损法--简化 2807. 在链表中插入最大公约数 思路：模拟 1.调用函数求出要插入的最大公约数
2.插入到cur的后面
3.因为插了一位，所以移动两个位置
public ListNode insertGreatestCommonDivisors(ListNode head) { ListNode cur = head; while (cur.next!=null){ int gcdVal = gcd(cur.val,cur.next.val); //调用函数求出要插入的最大公约数 cur.next = new ListNode(gcdVal,cur.next); //插入到cur的后面 cur = cur.next.next; //因为插了一位，所以移动两个位置 } return head; } /** * 求两个结点值的最大公约数 * @param a * @param b * @return */ private int gcd(int a,int b){ //求最大公约数有多种写法 while (a!=0){ int temp = a; a = b % a; b = temp; } return b; } 求最大公约数的几种方法： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/894a478e4f12b0ce216dc6914b9b7039/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/580132cd4d1f042582879e427152da6b/" rel="bookmark">
			Docker nginx容器代理播放m3u8视频文件（HLS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Docker Nginx容器代理播放M3U8文件教程获取Nginx Docker镜像设置Nginx配置文件用 ffmpeg 将 MP4 文件转换成 m3u8 文件运行Docker容器测试M3U8流其他问题我用vlc都能播放http://192.168.121.50/forest4kTest.m3u8和http://192.168.121.50/forest4kTest.mp4，那还要m3u8做什么，直接播放视频文件不就行了吗？ Docker Nginx容器代理播放M3U8文件教程 本教程将介绍如何在Docker中使用Nginx作为反向代理，以播放M3U8文件。我们会通过步骤详细解释每个过程，并提供命令和代码示例。
获取Nginx Docker镜像 我们用dockerfile构建镜像：
（Dockerfile）
FROM nginx:1.18 然后用脚本构建镜像：
（build_docker_image.sh）
#!/bin/bash # 打印所有，包括注释 # set -v # 打印执行命令 # set -x # 命令出错退出 set -e # 使用未初始化变量退出 set -u # 设置变量 IMAGE_NAME="kyai_nginx_x86" IMAGE_TAG="v1.18_20230724" # 检查依赖 if ! [ -x "$(command -v docker)" ]; then echo 'Error: Docker is not installed.' &gt;&amp;2 exit 1 fi # 构建 Docker 镜像 docker build -t "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/580132cd4d1f042582879e427152da6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef8bc995b738226efd428a74f6c5714/" rel="bookmark">
			【无标题】finalshell 上传php文件，出现500错误的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 finalshell 上传php文件，运行时出现500错误的问题
多方查找发现是因为上传后文件的权限不够
上传后的权限
rz -y ls -ll -rw------- 1 root root 6 17:38 b.php 修改文件权限就可以正常执行了
chmod +r b.php 或者 chmod +w b.php finalshell 没有找到如何在上传修改文件权限的设置。
使用xshell上传d.php文件后的权限
rz -y ls -ll -rw-r--r-- 1 root root 6 17:39 d.php 可以正常执行
b.php d.php的内容
&lt;?php phpinfo(); ?&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4f3361165f8be6f496f57878c2f939b/" rel="bookmark">
			android apk文件的签名问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android的APK文件实际上是一个jar文件。jar的意思是瓶、罐，那就意味着jar文件是一个用来存放android应用相关文件的容器。事实上，它也确实如此，它只是一个带或不带压缩的zip文件，当你把.apk后缀改成.zip后，就能对此进行解压了。用java写的不同类型应用都会使用jar来存储它们的文件。jar有一些特殊的结构。
参考：KeyStore文件
1. 编译一个未签名的apk文件 P2PIM % gradlew :app:assembleRelease 我们将在下面的路径找到未签名的apk文件app-release-unsigned.apk：
app/build/outputs/apk/release/app-release-unsigned.apk 2.用.jks对apk进行签名 // --ks 从初始化好的KeyStore加载私钥和证书链，KeyStore的初始化是基于指定的.jks文件的 % ./apksigner sign --ks kyunban.jks --out app-release-signed.apk app-release-unsigned.apk Keystore password for signer #1: 输入.jks的保护密码，就可以完成签名:
% ls app-release-signed.apk apksigner apksigner对给定的apk文件进行签名，它会剥离任何先前存在的签名。
换句话说，当将要进行签名的apk已经签过名了，那么apksigner会把已存在的签名先删除掉，再进行重新签名。
使用一个或多个签名者执行，每个签名者由一个非对称密钥表示
Pair和对应的证书。通常，APK只由一个人签名
签名者。对于每个签名者，需要提供签名者的私钥和
证书。
签名是由一个或多个签名者来完成的，就像一份重要的文件一样，可能是由一个重要的人来签名即可，也可能需要好几个重要的人来共同签名才能有效。在计算机里的签名也是一样的，首先是选择非对称密钥对和相应的证书来完成。私钥是掌握在签名者自己手中，另人是没有的。证书是用来传输对应的公钥。 因为私钥加密的内容只能用其公钥来解密，又因私钥只掌握在签名者自己手中，因此就构成了签名者无法抵赖签名的事实。因此签名者都是要用各自的私钥来进行签名的。
在Android领域，要对apk文件进行签名时，只能用一个签名者的私钥来签名，它不能够联名签名。所以对已签名的apk文件进行重新签名时，它会先把先前的签名剥离掉先，再签名。
所以要对apk签名，签名者必须提供私钥和证书，证书中有私钥对应的公钥。
.jks只是一份存放了相应的私钥、公钥和证书的地方，其实，也可以用类似.jks文件来对apk文件进行签名，apksigner支持的就行，这里列举一些签名的例子：
只用keystore文件kyunban.jks中的私钥进行签名： // 如果不通过--out指定新的文件名，签名的文件也就是app.apk，覆盖掉原先未签名的文件 $ apksigner sign --ks kyunban.jks app.apk 只用keystore文件kyunban.jks中的私钥进行签名，签名的文件不覆盖原来未签名的文件 $ apksigner sign --ks kyunban.jks --in app.apk --out app-signed.apk 通过.pk8文件中的私钥和证书文件中的证书链一起签名，注意这里要求证书文件格式必须是X.509 PEM 或 DER 格式: $ apksigner sign --key release.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4f3361165f8be6f496f57878c2f939b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b28f976f56976d8fcde4c1227eefda71/" rel="bookmark">
			华为面经总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了帮助大家更好的应对面试，我整理了往年华为校招面试的题目，供大家参考~
面经1 技术一面 自我介绍说下项目中的难点volatile和synchronized的区别， 问的比较细大顶堆小顶堆怎么删除根节点CSRF攻击是什么，怎么预防线程通信方式。Volitate关键字。Java 高效拷贝数组。算法题 跳跃游戏 leetcode 55。 技术二面 上来就手撕代码 ，奇偶链表，leetcode原题，先说思路，然后打开ide共享屏幕撕代码手写单例模式，并说为什么这样写，会不会有什么问题，涉及到volatile原理mysql常用的数据类型Java集合框架的主类是什么，HashSet有没有继承Collection软件工程学过哪些课程软件工程学过哪些课程进程和线程的区别知道哪些排序算法，快排的时间复杂度是多少，是稳定的排序算法吗编程题/算法
题目大概：请输出两个字符串a和b相减的结果（a&gt;b,a和b的字符串长度介于1~50之间）。
例：输入a:“99999”,b=“99998”
输出：“1” 面经2 华为一面 项目、论文。String能否被继承。Java内存泄露和排查。Hash方式和Hash冲突解决。静态代理和动态代理。spring boot常用的注解有哪些spring boot的配置文件redis集群的几种方式详细说一下redis缓存雪崩，缓存击穿，缓存穿透是什么，怎么解决mysql索引相关，为什么用B+树手撕代码，链表求和，leetcode原题：https://leetcode-cn.com/problems/sum-lists-lcci/ 华为二面 是否用过Java、Python做系统的项目平时熟练使用哪种语言HashMap、HashSet、HashTable、StringBuffer、StringBuilder哪些是线程安全，哪些是线程不安全HashSet数据结构，跟HashMap有什么区别char和varchar的区别mysql建索引的原则，索引是不是越多越好，为什么spring boot用到了哪些设计模式，从源码层面说说你熟悉的以及实现jvm调优你用什么工具，具体怎么做的，怎么调优 最后分享一份大彬精心整理的大厂面试手册，包含计算机基础、Java基础、多线程、JVM、数据库、Redis、Spring、Mybatis、SpringMVC、SpringBoot、分布式、微服务、设计模式、架构、校招社招分享等高频面试题，非常实用，有小伙伴靠着这份手册拿过字节offer~
需要的小伙伴可以自行下载：
链接：https://pan.xunlei.com/s/VNgU60NQQNSDaEy9z955oufbA1?pwd=y9fy#
备用链接：https://pan.quark.cn/s/cbbb681e7c19
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ee32eea3347ae00d81a0e643116eec8/" rel="bookmark">
			并发（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
6.通常线程有哪几种使用方式？
7.基础线程机制有哪些？
8.线程的中断方式有哪些？
9.线程的互斥同步方式有哪些？如何比较和选择？
10.Synchronized可以作用在哪里？
6.通常线程有哪几种使用方式？ 有三种使用线程的方法：
实现Runnable接口；
实现Callable接口;
集成Thread类。
实现Runnable和Callable接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过Thread来调用。可以说任务是通过线程驱动从而执行的。
7.基础线程机制有哪些？ Executor管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。
主要有三种Excutor:
1.CachedThreadPool:一个任务创建一个线程；
2.FixedThreadPool:所有任务只能使用固定大小的线程。
3.SingleThreadExecutor:相当于大小为1的FixedThreadPool。
Daemon
守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。
当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。
main()属于非守护线程。使用setDaemon()方法将一个线程设置为守护线程。
sleep（）
Thread.sleep(millisec)方法会休眠当前正在执行的线程，Millisec单位为毫秒。
sleep()可能会抛出InterruptedException，因为异常不能跨线程传播回main()中，因此必须在本地进行处理。线程中抛出的其他异常也同样需要在本地进行处理。
yield()
对静态方法Thread.yield()调用声明了当前线程已经完成了声明周期中最重要的部分，可以切换给其他线程来执行。该方法只是对县城调度器的一个建议，而且也只是建议具有相同优先级的其他线程可以运行。
8.线程的中断方式有哪些？ 一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。
InterruptedException
通过调用一个线程的interrupt()来中断该线程，如果该线程处于阻塞，限期等待或者无限期等待状态，那么就会抛出InterruptedException,从而提前结束该线程。但是不能中断I/O阻塞和synchronized锁阻塞。
对于以下代码，在main()中启动一个线程之后再中断他，由于线程中调用了Thread.sleep()方法，因此会抛出InterruptedException,从而提前结束线程，不执行之后的语句。
interrupted()
如果一个线程的run()方法执行一盒无限循环，并且没有执行sleep()等会抛出InterruptedException的操作，那么调用线程的interrupt()方法就无法使线程提前结束。
但是调用interrupt()方法会设置线程的中断标记，此时调用Interrupt（）方法会返回true。因此可以在循环体中使用interrupted()方法来判断线程是否处于中断状态，从而提前结束线程。
Excutor的中断操作
调用Excutor的shutdown（）方法会等待线程都执行完毕后再关闭，但是如果调用的是shutdownNow（）方法，则相当于调用每个线程的interrupt()方法。
9.线程的互斥同步方式有哪些？如何比较和选择？ Java提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是JVM实现的synchronized，而另一个是JDK实现的ReentrantLock。
1.锁的实现
synchronized时JVM实现的，而ReentrantLock是JDK实现的。
2.性能
新版本Java对Synchronized进行了很多优化，例如自旋锁等，synchronized与ReentrantLock大致相同。
3.等待可中断
当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock可中断，而synchronized不行。
4.公平锁
公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来一次获得锁。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但是也可以是公平的。
5.锁绑定多个条件
一个ReentrantLock可以同时绑定多个Condition对象。
10.Synchronized可以作用在哪里？ 对象锁
方法锁
类锁
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93d26b1338c924a574373bc656dd7def/" rel="bookmark">
			C&#43;&#43; set用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		std::set 是 C++ 标准库中的关联容器之一，它实现了一种有序的、不包含重复元素的集合。以下是 std::set 的用法总结：
包含头文件： #include &lt;set&gt; 创建 std::set 对象： std::set&lt;ElementType&gt; mySet; ElementType 是集合中元素的类型。 插入元素： mySet.insert(element); 删除元素： mySet.erase(element); 查找元素： auto it = mySet.find(element); if (it != mySet.end()) { // 元素找到 } else { // 元素未找到 // 处理不存在的情况 } 遍历 std::set： for (const auto&amp; element : mySet) { // 处理每个元素 } 获取大小： size_t size = mySet.size(); 检查是否为空： bool isEmpty = mySet.empty(); 注意事项： std::set 中的元素是按升序排序的，且不允许重复元素。std::set 的底层实现是基于红黑树的。 示例： #include &lt;iostream&gt; #include &lt;set&gt; int main() { std::set&lt;int&gt; mySet; // 插入元素 mySet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93d26b1338c924a574373bc656dd7def/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0d8bda05dadb0e086da6fd3d3ff1223/" rel="bookmark">
			案例097:基于微信小程序&#43;PHP的家具购物商城系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
系统展示
管理员模块的实现
用户管理
家具分类管理
家具新品管理
家具广告管理
小程序用户模块的实现
首页
家具信息
我的
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 随着信息技术在管理上越来越深入而广泛的应用，管理信息系统的实施在技术上已逐步成熟。本文介绍了基于微信小程序的家具购物小程序的设计与实现的开发全过程。通过分析基于微信小程序的家具购物小程序的设计与实现管理的不足，创建了一个计算机管理基于微信小程序的家具购物小程序的设计与实现的方案。文章介绍了基于微信小程序的家具购物小程序的设计与实现的系统分析部分，包括可行性分析等，系统设计部分主要介绍了系统功能设计和数据库设计。
本基于微信小程序的家具购物小程序有管理员和用户两个角色。管理员功能主要在后台浏览器操作，有个人中心，用户管理，家具分类管理，家具新品管理，订单管理和系统管理。用户主要在微信小程序注册与登录，可以查看管理员发布的家具信息并且可以购买操作。因而具有一定的实用性。
本站后台采用PHP的TP5框架进行后台管理开发，可以在浏览器上登录进行后台数据方面的管理，MySQL作为本地数据库，微信小程序用到了微信开发者工具，充分保证系统的稳定性。系统具有界面清晰、操作简单，功能齐全的特点，使得基于微信小程序的家具购物小程序的设计与实现管理工作系统化、规范化。
系统展示 管理员模块的实现 用户管理 管理员可以管理用户信息，可以查看用户信息，删除用户信息。
家具分类管理 管理员可以对家具分类进行添加，修改，查询或删除操作。
家具新品管理 管理员可以对家具新品信息进行添加，修改，删除，查询操作。界面如下图所示：
家具广告管理 管理员可以对家具广告信息进行添加，修改，删除，查询操作。界面如下图所示：
小程序用户模块的实现 首页 小程序用户可以在首页查看家具新品信息，下面是导航栏。界面如下图所示：
家具信息 用户可以查看家具信息，可以对家具信息进行添加到购物车，收藏，立即订购操作。
我的 用户在我的界面可以充值，查看自己的购物车和订单信息。界面如下图所示：
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.selectOne(new EntityWrapper&lt;UserEntity&gt;().eq("username", username)); if(user==null || !user.getPassword().equals(password)) { return R.error("账号或密码不正确"); } String token = tokenService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0d8bda05dadb0e086da6fd3d3ff1223/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65e628a9fbb6be0d82a94cdb28daf810/" rel="bookmark">
			【单片机】延迟程序＆延迟子程序的设计（入门）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言
大家好吖，欢迎来到 YY 滴小小知识点系列 ，热烈欢迎！ 本章主要内容面向接触过单片机知识点的老铁
主要内容含：
欢迎订阅 YY滴C++专栏！更多干货持续更新！以下是传送门！
YY的《C++》专栏YY的《C++11》专栏YY的《Linux》专栏YY的《数据结构》专栏YY的《C语言基础》专栏YY的《初学者易错点》专栏YY的《小小知识点》专栏 目录 一.认识基本的空操作指令NOP指令二.认识循环指令DJNZ三.一个1秒延时子程序的编写过程四.理解设计思路：嵌套结构的方法来实现延时程序 一.认识基本的空操作指令NOP指令 该指令是延迟系统种比较基础的一环，为一个机器周期
二.认识循环指令DJNZ 认识该指令只需要顾名思义即可JZ：JUMP WHEN ZERO（当值为0时跳转）JNZ：JUMP WHEN NO ZERO（当值不为0时跳转）DJNZ：DELETE 1,JUMP WHEN NO ZERO（值减1，当值不为0时跳转） 三.一个1秒延时子程序的编写过程 先用DJNZ（减1循环），实现了一个500微妙的的延时因为循环体内会执行2个机器周期
我们再利用NOP，在循环体内加两个NOP空指令（延长循环体内机器周期），即实现
四.理解设计思路：嵌套结构的方法来实现延时程序 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dad528bb035e71263e88276dc54528e/" rel="bookmark">
			C&#43;&#43; unordered_map用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		std::unordered_map 是 C++ 标准库中的一个哈希表实现的关联容器，用于存储键-值对，提供了快速的查找、插入和删除操作。以下是 std::unordered_map 的详细用法总结：
包含头文件： #include &lt;unordered_map&gt; 创建 std::unordered_map 对象： std::unordered_map&lt;KeyType, ValueType&gt; myMap; KeyType 是键的类型，可以是基本数据类型或自定义类型。ValueType 是值的类型，可以是基本数据类型或自定义类型。 插入元素： myMap[key] = value; myMap.insert(std::make_pair(key, value)); 访问元素： value = myMap[key]; 查找元素： auto it = myMap.find(key); if (it != myMap.end()) { // 元素找到 value = it-&gt;second; } else { // 元素未找到 // 处理不存在的情况 } 删除元素： myMap.erase(key); 遍历 std::unordered_map： for (auto&amp; pair : myMap) { // pair.first 是键 // pair.second 是值 std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dad528bb035e71263e88276dc54528e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8799e864efdbcec9f3753ad364b0dbf5/" rel="bookmark">
			C语言程序设计——输入输出函数(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		补充 在上一篇文中简单介绍了输入输出函数printf和scanf，其中它还有一些家族函数，在这里再浅浅补充一下。如下代码框所示
sprintf() fprintf() sscanf() fscanf() 可以看到与我们常使用的函数中只是再前面加了f 或 s，我们在creference上查看也会发现他们的功能是相同的。
s代表的是string，所以sprintf()和sscanf()这一组输入输出函数代表的是字符数组的输入输出
f代表的是file，所以fprintf()和fscanf()这一组输入输出函数代表的是文件的输入输出
字符数组的输入输出 先用代码来演示一下使用情况
#include&lt;stdio.h&gt; int main(){ char temp[100]; char res[100]; //创建两个字符数组 sprintf(temp, "asdasd\n"); // 向temp字符数组中打印一段字符串 printf("%s", temp); // 输出temp字符数组内容 sscanf(temp,"%s", res);	// 在temp字符数组中提取字符串，输入到res中 printf("%s", res);	// 打印res字符数组内容 } ==================================================== &gt;&gt; asdad asdasd 可以看到该组函数的输入输出函数主要是针对字符串进行操作的，而且对于函数使用上，只是多加了一个字符串地址的参数，其他均与printf()和scanf()函数情况一致。那么只针对字符串进行操作，我们不难想出他们的作用就是主要针对于字符串的分割与拼接。那么我们在以IP地址为例，再深入了解一下该组函数对于文本的拼接与切割。
文件的输入输出 在这里需要使用c语言来操作文件读写，那么关于如何操作等，不进行过多的赘述，只针对于输入输出函数讲解
#include&lt;stdio.h&gt; int main(){ FILE *fp = fopen("./output.txt", "w"); // 打开文件 fprintf(fp, "this is a test");	// 向文件打印字符串 fclose(fp);	// 关闭文件 } 可以看到，我们对于文件的输入输出已经完成了，但是在向文件提取文本的时候出现了问题，我们提取的内容只有一个this。这个问题我们在上一篇文章中已经接触到了，在使用%s时，系统会把空格和换行符作为终止符。在我们输入的文本中是有空格存在的，所以在fscanf()读到空格的时候就会结束读取，导致我们的结果残缺。要解决的话，也很简单，就是用我们接触过的字符匹配集。
新的问题 正如上面所说我们使用字符匹配集可以解决空格的问题，那么如果我们想要读入多行的，本身就带有换行符，我们可以很容易想到使用循环读入。如果使用循环读入的话，那么就要使用二维的字符数组来接收才可，同样要记得使用一个getchar()来吸收缓冲区里的换行符，否则会陷入死循环，但是在这里需要强调的是，文件流中会有稍稍的不一样，需要把getchar换成fgetc()。其它内容完全一样可以参考上一篇的循环读入。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8799e864efdbcec9f3753ad364b0dbf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93e477bff07e396609f781f89a08e09b/" rel="bookmark">
			网盘项目话术（0.5w字精选）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能结构图 数据库设计总结 该项目主要就是对文件的操作，file表，file_share表。
file表主要字段：id，用户id，父级目录id，文件的地址，文件的封面图片地址，创建和修改时间。
file_share表主要字段：id，文件id，用户id，有效类型，创建和失效时间（用于定时任务）。
基于RDAB的五张表：用户信息表，角色表，权限表，用户角色关联表（多对多关系），角色权限关联表（多对多关系）。
基础设置表：id，邮箱标题，邮箱内容前缀，默认初始化空间大小。
登录模块总结 单点登录-&gt;双token三认证（迭代方案）
版本1.0时我们采用单点登录的方式做校验的，其问题就是我们无法控制token的有效时间。并且token是存放在session中。
在版本2.0中我们使用双token三认证模型，主要就是基于长短token来实现的。长短token存放在cookie中。
在用户登录完成之后，就会通过JWT及我们配置的私钥来生成对应的长短token，并且会将加密后的长token作为key，value为1存储到redis中，请求会携带这两个token。短token用来校验，长token用来生成新的长短token。
在执行业务的时候就会去判断短token是否有效，通过公钥进行验证。此时就是第一次验证。
当发现短token无效，就会去判断长token是否有效，也是通过公钥进行验证的。此时就会第二次验证。
如果长token有效，就会去redis中查询长token是否存在，此时就是第三次验证。
通过三次验证后，就会去刷新token生成新的长短token。
权限隔离（迭代方案）
权限隔离，项目中主要分为普通用户和管理员，刚开始使用特殊字段作为权限标识，权限扩展起来就非常的麻烦，涉及修改表字段。因此就使用RDAB模型来实现权限隔离，可扩展性高。主要分为用户表，角色表，权限表，用户关联角色表（多对多的关系），角色关联权限表（多对多的关系），并配合springSecurity实现的。
文件列表总结 文件查询 文件列表为用户操作的主要模块，特别是在查询接口上存在高并发的场景，因此通过做缓存来优化查询接口，及使用布隆过滤器解决缓存穿透的问题。
缓存优化：通过springCache来实现缓存的，保证双写一致性。（主要就是使用@Cacheable，@CachePut，@CacheEvit实现的）
解决缓存穿透问题：通过使用redisson创建布隆过滤器，在数据做插入时也在布隆过滤器进行中标记，在进行查询的时候先到布隆布隆过滤器中做判断，防止缓存穿透的安全问题。
其实只要是对应暴露的如何数据库的curd方法都存在缓存穿透的问题。
文件转移
通过递归的形式来生成一个树形结构，选择对应的文件作为其新的父文件。当然在树形结构中只有文件夹类型的文件。
文件上传
在上传文件使用ffmpeg会分段生多个文件，并配合redis记录文件的总大小，保证文件的大小不会超过用户的总空间。此时会生成多个临时文件，在最终合并的时候使用io的形式将临时文件的数据全部存储到目标文件中（并完成对目标文件的记录），最终完成文件的分段上传。
优点就是在网络不佳时，可以只上传失败的数据即可。在分段完成之后会通过IO流的形式在服务器对应的地址上生成目标文件。
文件的分享模块 分享链接验证码校验
分享链接是会生成指定或随机的6为验证码，我们可以自定义该验证码的有效时间，将文件id作为key，加密（MD5）后的验证码作为value，并设置对应的ttl。校验时直接将输入的验证码加密后到redis中去匹配校验。
用户支持时获取的邮箱验证码也是基于此方法实现的。
分享残留数据清除
此时数据库会有分享记录残留的问题。我们就会使用xxl-job做定时任务来清除残留的分享记录。
通过在xxl-job中创建执行器和对应的定时任务，此时分享残留数据清除每隔4小时执行一次，设置定时任务的时间。采用默认的轮询路由策略。定时的调用查询过期的发现链接并删除。
配置对应的xxl-job参数
# xxl-job executor配置 xxl.job.admin.addresses=http://127.0.0.1:8080/xxl-job-admin xxl.job.executor.appname=my-executor-app xxl.job.executor.ip= xxl.job.executor.port=9999 xxl.job.accessToken= xxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler xxl.job.executor.logretentiondays=30 创建JobHander指定其名字
import com.xxl.job.core.handler.annotation.XxlJob; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Component; @Component public class MyJobHandler { private static final Logger logger = LoggerFactory.getLogger(MyJobHandler.class); @XxlJob("myJobHandler") public void execute() throws Exception { // 任务逻辑 logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93e477bff07e396609f781f89a08e09b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/710453a88d10bcdf99ede24b54e57e60/" rel="bookmark">
			李宏毅机器学习第二十四周周报 Self-attention ConvLSTM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 week 24 Self-attention ConvLSTM for Spatiotemporal Prediction摘要Abstract一、机器学习二、文献阅读1. 题目2. abstract3. 网络架构3.1基础模型3.2自注意力记忆模块3.3Self-Attention ConvLSTM 4. 文献解读4.1 Introduction4.2 创新点4.3 实验过程4.3.1实现4.3.2数据集4.3.3消融实验4.3.5注意力可视化 4.4 结论 三、使用GRU和LSTM进行时间预测1.库的导入&amp;数据集2.数据预处理3.模型定义4.训练过程5.模型训练小结参考文献 week 24 Self-attention ConvLSTM for Spatiotemporal Prediction 摘要 本文主要讨论SA ConvLSTM的模型。本文简要介绍了LSTM的结构以及运行逻辑，并展示了ConvLSTM。其次本文展示了题为Self-Attention ConvLSTM for Spatiotemporal Prediction的论文主要内容。这篇论文提出了Self-attention ConvLSTM模型，该模型将自注意力机制引入到 ConvLSTM 中。具体来说，提出了一种新颖的自注意力记忆（SAM）来记忆在空间和时间域方面具有远程依赖性的特征。该文在多个数据集上进行实验，从数据角度证明了该网络的优越性。最后，本文基于pytorch实现了GRU和LSTM模型并用于预测时序数据集的后续结果。
Abstract This article focuses on SA ConvLSTM. This article briefly describes the structure and operation logic of LSTM, and shows the ConvLSTM. Secondly, this paper presents the main content of the paper entitled Self-Attention ConvLSTM for Spatiotemporal Prediction.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/710453a88d10bcdf99ede24b54e57e60/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<span class="pagination__item pagination__item--current">1/279</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/2/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>