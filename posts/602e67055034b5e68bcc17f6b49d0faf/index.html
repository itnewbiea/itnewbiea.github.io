<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>react黑马前端学习笔记 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="react黑马前端学习笔记" />
<meta property="og:description" content="React 一、React概述 1.1简介 react是一个用于构建用户界面的js库
用户界面：HTML页面
React主要用来写HTML页面或者构建Web应用
如果从MVC的角度来看，React仅仅是视图层，也就是只负责视图的渲染，而并非提供了完整的M和C的功能。
React起源于Facebook的内部项目，后来又用来架设Instagram的网站，并于2013年5月开源
1.2React特点 1、声明式 只需要描述UI（html）看起来是什么样，就跟写HTMl一样（JSX）
React负责渲染UI，并在数据变化时更新UI
const jsx=&lt;div className=&#39;app&#39;&gt; &lt;h1&gt;hello react! 动态变化数据:{count}&lt;/h1&gt; &lt;/div&gt; 2、基于组件 组件是react最重要的内容
组件表示页面中的部分内容
组合、复用多个组件，可以实现完整的页面功能
3、应用广 web移动端vr应用 ​ …
1.3React的安装 vscode中在终端选项中新建终端
cd命令选择在当前文件夹中安装，命令：npm i react react-dom
来创建两个包
react 包是核心，提供创建元素、组件等功能react-dom包提供DOM相关功能 二、React的基本使用 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-J34I2z2P-1677566304596)(C:\Users\ZYJ\AppData\Roaming\Typora\typora-user-images\image-20230215185607422.png)]
&lt;!DOCTYPE html&gt; &lt;html lang=&#34;en&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;meta http-equiv=&#34;X-UA-Compatible&#34; content=&#34;IE=edge&#34;&gt; &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&#34;root&#34;&gt;&lt;/div&gt; &lt;!-- 1、引入js文件 --&gt; &lt;script src=&#34;./node_modules/react/umd/react.development.js&#34;&gt;&lt;/script&gt; &lt;script src=&#34;./node_modules/react-dom/umd/react-dom.development.js&#34;&gt;&lt;/script&gt; &lt;script&gt; // 2、创建react元素 //参数一、元素名称 // 参数二、元素属性 // 参数三、元素子节点 const title = React." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/602e67055034b5e68bcc17f6b49d0faf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-28T14:39:42+08:00" />
<meta property="article:modified_time" content="2023-02-28T14:39:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">react黑马前端学习笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="React_0"></a>React</h2> 
<h2><a id="React_2"></a>一、React概述</h2> 
<h3><a id="11_4"></a>1.1简介</h3> 
<p>react是一个用于构建用户界面的js库</p> 
<p>用户界面：HTML页面</p> 
<p>React主要用来写HTML页面或者构建Web应用</p> 
<p>如果从MVC的角度来看，React仅仅是视图层，也就是只负责视图的渲染，而并非提供了完整的M和C的功能。</p> 
<p>React起源于Facebook的内部项目，后来又用来架设Instagram的网站，并于2013年5月开源</p> 
<h3><a id="12React_16"></a>1.2React特点</h3> 
<h4><a id="1_18"></a>1、声明式</h4> 
<p>只需要描述UI（html）看起来是什么样，就跟写HTMl一样（JSX）</p> 
<p>React负责渲染UI，并在数据变化时更新UI</p> 
<pre><code class="prism language-react">const jsx=&lt;div className='app'&gt;
			&lt;h1&gt;hello react! 动态变化数据:{count}&lt;/h1&gt;
		  &lt;/div&gt;
</code></pre> 
<h4><a id="2_30"></a>2、基于组件</h4> 
<ul><li> <p>组件是react最重要的内容</p> </li><li> <p>组件表示页面中的部分内容</p> </li><li> <p>组合、复用多个组件，可以实现完整的页面功能</p> </li></ul> 
<h4><a id="3_38"></a>3、应用广</h4> 
<ul><li>web</li><li>移动端</li><li>vr应用</li></ul> 
<p>​ …</p> 
<h3><a id="13React_48"></a>1.3React的安装</h3> 
<p>vscode中在终端选项中新建终端</p> 
<p>cd命令选择在<strong>当前文件夹</strong>中安装，命令：npm i react react-dom</p> 
<p>来创建两个包</p> 
<ul><li>react 包是核心，提供创建元素、组件等功能</li><li>react-dom包提供DOM相关功能</li></ul> 
<h2><a id="React_59"></a>二、React的基本使用</h2> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-J34I2z2P-1677566304596)(C:\Users\ZYJ\AppData\Roaming\Typora\typora-user-images\image-20230215185607422.png)]</p> 
<pre><code class="prism language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 1、引入js文件 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./node_modules/react/umd/react.development.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./node_modules/react-dom/umd/react-dom.development.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
        <span class="token comment">// 2、创建react元素</span>
        <span class="token comment">//参数一、元素名称</span>
        <span class="token comment">// 参数二、元素属性</span>
        <span class="token comment">// 参数三、元素子节点</span>
        <span class="token keyword">const</span> title <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'hello React'</span><span class="token punctuation">)</span>
            <span class="token comment">// 3、渲染react元素</span>
            <span class="token comment">// 参数一、要渲染的react元素</span>
            <span class="token comment">// 参数二、挂载点</span>
        ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>注意：ReactDOM中DOM全大写</p> 
<p>总结：</p> 
<h3><a id="1react_99"></a>1、引入react文件</h3> 
<pre><code class="prism language-html">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./node_modules/react/umd/react.development.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./node_modules/react-dom/umd/react-dom.development.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>之后导入react脚手架后会有更加简便的写法</p> 
<h3><a id="2reactReactcreateElement_110"></a>2、创建react元素React.createElement（）——了解</h3> 
<pre><code class="prism language-js"><span class="token keyword">const</span> element <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span>props<span class="token punctuation">,</span> children1<span class="token punctuation">,</span><span class="token punctuation">[</span>childrenN<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li> <p>type:元素类型 如：h1 div p等</p> <p>可以是字符串如：div p h1</p> <p>也可以是自定义组件：react原生组件等</p> </li><li> <p>props表示改元素上的属性，使用对象的方式表示</p> <p>{<!-- --></p> <p>className:‘greeting’</p> <p>}</p> </li><li> <p>children:表示元素内部的内容，可有多个children，可以是文字，也可以是另一个react元素</p> </li></ul> 
<p><strong>了解JSX后会有更加简便的写法，这里只需了解不需要记忆</strong></p> 
<h3><a id="3ReactDOMrenderreact_134"></a>3、ReactDOM.render()渲染react元素——重要</h3> 
<pre><code class="prism language-js"> ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>Reactele<span class="token punctuation">,</span> DOMele<span class="token punctuation">)</span>
</code></pre> 
<p>Reactele：要渲染的react元素</p> 
<p>DOMele：DOM对象，用于指定渲染到页面的DOM元素</p> 
<h2><a id="React_146"></a>三、React脚手架</h2> 
<p>进入正题</p> 
<h3><a id="31_150"></a>3.1意义</h3> 
<p>1、脚手架是开发现代Web应用的必备</p> 
<p>2、充分利用Webpack\Babel\ESlint等工具辅助项目开发</p> 
<p>3、零配置。无需手动配置繁琐的工具即可使用,方便更专注与项目</p> 
<h3><a id="32React_158"></a>3.2使用React脚手架初始化项目</h3> 
<p>1、初始化项目，命令：npx create-react-app 项目名。</p> 
<ul><li> <p>为<strong>加快初始化速度</strong>可以将npm的源进行更换，使用以下命令：</p> <p>npm config set registry https://registry.npm.taobao.org</p> <p>– 配置后可通过下面方式来验证是否成功</p> <p>npm config get registry</p> <p>– 显示出上述地址的话就是更换成功</p> </li><li> <p>可以在cmd中全局安装react脚手架，npm install -g create-react-app</p> </li></ul> 
<p>​ 之后便可直接用create-react-app 项目名 来构建react脚手架项目</p> 
<p>2、使用cd命令转到刚刚创建的文件夹</p> 
<p>3、启动项目，在<strong>项目根目录</strong>执行命令：npm start</p> 
<p>4、测试，打开终端提供的网址出现启动页面则证明成功</p> 
<h3><a id="33React_182"></a>3.3在脚手架中使用React</h3> 
<p>初始化的文件夹中public文件夹中的index.html以及src中的index.js是首页也就是之前测试用的网页可以删除或者更改</p> 
<p>1、导入react和react-dom两个包</p> 
<pre><code class="prism language-js"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span>
<span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">'react-dom'</span>
</code></pre> 
<p>2、调用React.createElement()方法创建react元素（以后会用JSX创建）</p> 
<p>3、调用ReactDOM.render()方法渲染react元素到页面中</p> 
<p>注意：在html页面中使用alt+b显示的页面不会显示调整的内容，也就是不能直接在浏览器中打开html页面，而是需要打开npm start命令打开的页面即 http://localhost:3000</p> 
<h2><a id="JSX_199"></a>JSX</h2> 
<p>JSX不是标准的ES语法，他是ES的语法扩展</p> 
<p>需要用babel编译处理后，才能在浏览器中使用，而脚手架中已经给了babel环境</p> 
<p>create-react-app脚手架中已经有默认的配置，无需手动配置</p> 
<p>编译JSX语法的包是@babel/preset-react包</p> 
<h2><a id="JSX_209"></a>四、JSX的基本使用</h2> 
<h3><a id="41_createElement_211"></a>4.1 createElement()的问题</h3> 
<ul><li>繁琐不简洁</li><li>不直观，无法一眼看出结构</li><li>不优雅，体验感差</li></ul> 
<h3><a id="42JSX_217"></a>4.2JSX简介</h3> 
<ul><li> <p>JSX是JavaScript XML的简写 表示在JavaScript代码中写入XML格式（HTML）的代码</p> </li><li> <p>优势：声明式语法更加直观，与HTML结构相同，降低了学习成本提升了开发效率</p> </li><li> <p>JSX是React的核心内容</p> </li></ul> 
<h3><a id="43_JSX_225"></a>4.3 JSX使用步骤</h3> 
<p>1、使用JSX语法创建React元素</p> 
<pre><code class="prism language-react">const title=&lt;h1&gt;Hello JSX&lt;/h1&gt;//创建react元素
</code></pre> 
<p>react元素实则就是标签及其属性内容</p> 
<p>2、使用ReactDOM.render()方法渲染react元素到页面中</p> 
<pre><code class="prism language-react">ReactDOM.render(title,root)//渲染创建好的react元素
</code></pre> 
<p>ReactDOM.render是 React 的最基本方法用于将模板转为 HTML 语言，并插入指定的 DOM 节点。一个节点只能插入一个title元素，后来插入的title元素会将其覆盖</p> 
<h3><a id="44_243"></a>4.4注意点</h3> 
<ul><li> <p>react元素属性名使用<strong>驼峰命名</strong></p> </li><li> <p><strong>特殊属性名</strong>：</p> <p>class-&gt;className</p> <p>for-&gt;htmlFor</p> <p>tabindex-&gt;tabIndex</p> </li></ul> 
<pre><code class="prism language-react">const title=&lt;h1 className="title"&gt;Hello JSX&lt;/h1&gt;
</code></pre> 
<ul><li>没有子节点的标签可以用/&gt;结束，也就是双标签可以变成单标签</li></ul> 
<pre><code class="prism language-react">&lt;span/&gt;
</code></pre> 
<ul><li><strong>最好用小括号包裹JSX，从而避免JS中的自动插入分号陷阱</strong></li></ul> 
<pre><code class="prism language-react">const dv=(&lt;div&gt;hello JSX&lt;/div&gt;)
</code></pre> 
<ul><li><strong><mark>vscode中若有JS-CSS-HTML自动格式化插件容易导致JSX的缩进错误导致IDE报错所以要卸载禁用</mark></strong></li></ul> 
<h3><a id="45_JSXJS_273"></a>4.5 JSX中使用JS表达式</h3> 
<h4><a id="JS_275"></a>嵌入JS表达式</h4> 
<ul><li>js表达式的数据存储在JS中</li><li>语法：{Js表达式}</li></ul> 
<pre><code class="prism language-react">const name='Jack'
const dv=(
	&lt;div&gt;你好，我叫：{name}&lt;/div&gt;
)
ReactDOM.render(dv,root)
</code></pre> 
<p><strong>注意：</strong></p> 
<ul><li> <p>{1}，{‘a’},{1+4}等都是合法的</p> </li><li> <p>函数调用表达式也可以 {fn()}</p> </li><li> <p>JSX自身也是JS表达式</p> </li><li> <p><strong>JS对象不能直接在{}中使用</strong></p> </li><li> <p>语句不能在{}中出现比如for循环</p> </li></ul> 
<pre><code class="prism language-react">const h1=&lt;h1&gt;我是h1&lt;/h1&gt;
const dv=&lt;div&gt;嵌入表达式{h1}&lt;/div&gt;

</code></pre> 
<h3><a id="46_JSX_303"></a>4.6 JSX的条件渲染</h3> 
<ul><li>条件渲染：根据条件来渲染特定的JSX结构</li></ul> 
<pre><code class="prism language-react">const loadData=()=&gt;{
if(isLoading){
	return &lt;div&gt;loading...&lt;/div&gt;
}
return &lt;div&gt;数据加载完成&lt;/div&gt;
}
const title=(
&lt;h1&gt;条件渲染:{loadData()}&lt;/h1&gt;	
)
ReactDOM.render(title,document.getElementById('root'))
</code></pre> 
<ul><li>可以使用三元运算符来实现条件渲染</li></ul> 
<pre><code class="prism language-react">const title=(
&lt;h1&gt;条件渲染:{isloading?(&lt;div&gt;loading...&lt;/div&gt;):(&lt;div&gt;数据加载完成&lt;/div&gt;)}&lt;/h1&gt;	
)
ReactDOM.render(title,document.getElementById('root'))
</code></pre> 
<ul><li> <p>逻辑与运算符&amp;&amp;</p> <p>&amp;&amp;运算符若为true则会返回最后一个表达式值</p> </li></ul> 
<pre><code>const title=(
&lt;h1&gt;条件渲染:{isloading&amp;&amp;&lt;div&gt;loading...&lt;/div&gt;}&lt;/h1&gt;	
)
ReactDOM.render(title,document.getElementById('root'))
</code></pre> 
<h3><a id="47JSX_342"></a>4.7JSX列表渲染</h3> 
<ul><li>如果要渲染一组数据，需要使用数组的map()方法</li><li>map:将数组每个元素进行（）中函数运算后加入新数组并返回该数组</li><li>注意：渲染列表时应该添加key属性，key属性的值要保证唯一</li><li>原则：map遍历谁就给谁添加key属性</li><li>避免使用索引号作为key</li></ul> 
<pre><code class="prism language-react">const songs=[
{id:1,name:'痴心绝对'},
{id:2,name:'向我这样的'}
]
const list={
	&lt;ul&gt;
		{songs.map(item=&gt;&lt;li key={item.id}&gt;{item.name}&lt;/li&gt;)}
	&lt;/ul&gt;
}
</code></pre> 
<h3><a id="48JSX_362"></a>4.8JSX样式处理</h3> 
<p>1、行内样式–style</p> 
<pre><code class="prism language-react">const title=&lt;h1 style={<!-- -->{color:'red',backgroundColor:'skyblue'}}&gt;&lt;/h1&gt;
</code></pre> 
<p>2、类名–className （推荐）</p> 
<pre><code class="prism language-react">const title=&lt;h1 className="title"&gt;&lt;/h1&gt;
</code></pre> 
<h2><a id="_376"></a>组件</h2> 
<h2><a id="React_378"></a>五、React组件</h2> 
<h3><a id="51_380"></a>5.1组件介绍</h3> 
<ul><li>组件是React的一等公民，使用react就是使用组件</li><li>组件表示页面中的部分功能</li><li>组合多个组件实现完整的页面功能</li><li>特点：可复用、独立、可组合</li></ul> 
<h3><a id="52React_387"></a>5.2React组件的两种创建方式</h3> 
<h4><a id="1_389"></a>1、使用函数创建组件</h4> 
<ul><li>函数组件：使用JS的函数（或箭头函数）创建的组件</li><li>约定1：函数名称<strong>必须以大写字母开头</strong></li><li>约定2：函数组件<strong>必须有返回值</strong>，表示组件的结构</li></ul> 
<pre><code class="prism language-react">function Hello(){
return{&lt;div&gt;我的第一个组件&lt;/div&gt;}
}
//const Hello=()=&gt;&lt;div&gt;我的第一个组件&lt;/div&gt;
</code></pre> 
<ul><li>渲染函数组件：直接用函数名作为组件标签名</li><li>组件标签可以是单标签也可以是双标签</li></ul> 
<pre><code class="prism language-react">ReactDOM.render(&lt;Hello/&gt;,document.getElementById('root')
</code></pre> 
<h4><a id="2_409"></a>2、使用类创建组件</h4> 
<ul><li>类组件：使用ES6的class创建的组件</li><li>约定1：类名称必须以<strong>大写字母</strong>开头</li><li>约定2：类组件应该继承<strong>React.Component</strong>父类，从而可以使用父类中提供的方法或者属性</li><li>约定3：类组件必须提供render()方法</li><li>约定4：render()方法必须有返回值，表示该组件的结构</li></ul> 
<pre><code class="prism language-react">class Hello extends React.Component{//创建类组件
    render(){
        return &lt;div&gt;Hello!&lt;/div&gt;
    }
}
ReactDOM.render(&lt;Hello/&gt;,root)//渲染组件
</code></pre> 
<h4><a id="3js_426"></a>3、将组件抽离为独立js文件</h4> 
<p>将组件单独放入一个js文件中</p> 
<p>1、创建js文件</p> 
<p>2、导入React</p> 
<p>3、创建组件</p> 
<p>4、导出该组件</p> 
<p>5、在需要使用该组件的js文件中导入该组件</p> 
<p>6、渲染组件</p> 
<pre><code class="prism language-react">//hello.js
import React from 'react'
class Hello extends React.Component{
    render(){
        return &lt;div&gt;Hello!&lt;/div&gt;
    }
}
//导出Hello组件
export default Hello

</code></pre> 
<pre><code class="prism language-react">//index.js
import Hello from './Hello'
//渲染导入的Hello组件
ReactDOM.render(&lt;Hello/&gt;,root)
</code></pre> 
<h2><a id="React_464"></a>六、React事件处理</h2> 
<h3><a id="61_466"></a>6.1事件绑定</h3> 
<ul><li>React事件绑定语法和DOM事件语法类似</li><li>语法：on+事件名称={事件处理程序},比如: onClick={()=&gt;{}}</li><li>react事件采用驼峰命名</li></ul> 
<pre><code class="prism language-react">class App extends React.Component{//类组件
    handleClick(){
        console.log('单击事件')
    }
    render(){
        return (
            &lt;button οnclick={this.handleClick}&gt;点我&lt;/button&gt;
    }
    )
}

</code></pre> 
<pre><code class="prism language-react">function App(){//函数组件
    function handleClick(){
        console.log('单击事件')
    }
    return (
    &lt;button οnclick={handleClick}&gt;点我&lt;/button&gt;
    )
}
</code></pre> 
<h3><a id="62_497"></a>6.2事件对象</h3> 
<ul><li>可以通过事件处理程序的参数获取到事件对象</li><li>react中的事件对象叫做：合成事件（对象）</li><li>合成事件：兼容所有浏览器，无需担心跨浏览器兼容性问题</li></ul> 
<pre><code class="prism language-react">function handleClick(e){
	e.preventDefault()
	console.log('事件对象',e)
}

</code></pre> 
<h2><a id="_511"></a>七、有状态组件和无状态组件</h2> 
<ul><li>函数组件称为无状态组件</li><li>类组件称为有状态组件</li><li>状态：即数据（state中的数据）</li><li><strong>函数组件</strong>没有自己的状态，只<strong>负责数据的展示（静态）</strong></li><li><strong>类组件</strong>有自己的状态，<strong>负责更新UI</strong>，让页面“动”起来</li></ul> 
<h2><a id="statesetState_519"></a>八、组件中的state和setState</h2> 
<h3><a id="81state_521"></a>8.1state的基本使用</h3> 
<ul><li>状态（state）即数据，是组件内部的<strong>私有数据</strong>，只能在组件内部使用</li><li>state的值是对象，表示一个组件中可以有多个数据</li></ul> 
<pre><code class="prism language-react">class Hello extends React.Component{
    //初始化
    construct(){//构造函数
        super()//es6中的要求用于继承父类构造函数的函数
        //初始化state
        this.state={
            count:0
        }
    }
    //初始化简化语法（推荐）
    /*
    	state={
    		count:0
    	}
    */
    render(){
        return (
        	&lt;div&gt;有状态的组件,{this.state.count}&lt;/div&gt;
        )
    }
    
}
</code></pre> 
<ul><li>class中获取状态：this.state</li></ul> 
<h3><a id="82_setState_553"></a>8.2 setState()修改状态</h3> 
<ul><li>状态可变</li><li>语法：this.setState({要修改的数据})</li><li>注意：不要直接修改state中的值</li><li>setState的作用：1、修改state2、更新UI</li><li>思想：数据驱动视图</li></ul> 
<pre><code class="prism language-react">&lt;button onClick={()=&gt;{
        this.setState({
           count:this.state.count+1
        })
    }}&gt;
点我+1&lt;/button&gt;
</code></pre> 
<h2><a id="JSX_572"></a>九、从JSX中抽离出事件处理程序</h2> 
<pre><code class="prism language-react">class Hello extends React.Component{
    state={
    	count:0
    }
    
    onIncrement(){
    	//this为undifined 此程序出错
		this.setState({
			count:this.state.count+1
		})
	}
    render(){
		return(
			&lt;div&gt;
    		&lt;h1&gt;计数器:{this.state.count}&lt;/h1&gt;
        	&lt;button οnclick={this.onIncrement}&gt;点我+1&lt;/button&gt;
    		&lt;/div&gt;
		)
	}
    
}




</code></pre> 
<p>上面的代码发生了错误原因如下：</p> 
<ul><li>抽离后的this值为undefined需要重新指向</li></ul> 
<p>解决方法：</p> 
<ul><li>事件绑定this指向的修改</li></ul> 
<p>​ 1、箭头函数绑定事件</p> 
<p>​ 利用箭头函数自身不绑定this的特点</p> 
<pre><code class="prism language-react">class Hello extends React.Component{
    state={
    	count:0
    }
    
    onIncrement(){
		this.setState({
			count:this.state.count+1
		})
	}
    render(){//利用箭头函数更改调用时的this指向
		return(
			&lt;div&gt;
    		&lt;h1&gt;计数器:{this.state.count}&lt;/h1&gt;
        	&lt;button οnclick={()=&gt;this.onIncrement()}&gt;点我+1&lt;/button&gt;
    		&lt;/div&gt;react
		)
	}
    
}
</code></pre> 
<p>​ 2、Function.prototyoe.bind()</p> 
<p>利用ES5中的bind方法，将事件处理程序中的this与组件实例绑定到一起</p> 
<pre><code class="prism language-react">class Hello extends React.Component{
    constructor(){
        super()
        this.onIncrement=this.onIncrement.bind(this)//将this绑定到constructor的this
        state={
    	count:0
    	}
    }
   
    
    onIncrement(){
		this.setState({
			count:this.state.count+1
		})
	}
    render(){
		return(
			&lt;div&gt;
    		&lt;h1&gt;计数器:{this.state.count}&lt;/h1&gt;
        	&lt;button οnclick={this.onIncrement}&gt;点我+1&lt;/button&gt;
    		&lt;/div&gt;
		)
	}
    
}
</code></pre> 
<p>3、class的实例方法</p> 
<ul><li>利用箭头函数形式的class实例方法</li></ul> 
<pre><code class="prism language-react">class Hello extends React.Component{
    state={
    	count:0
    }
    
    onIncrement=()=&gt;{//利用箭头函数将this指向当前实例
		this.setState({
			count:this.state.count+1
		})
	}
    render(){
		return(
			&lt;div&gt;
    		&lt;h1&gt;计数器:{this.state.count}&lt;/h1&gt;
        	&lt;button οnclick={this.onIncrement}&gt;点我+1&lt;/button&gt;
    		&lt;/div&gt;
		)
	}
    
}
</code></pre> 
<h2><a id="_700"></a>十、表单处理</h2> 
<h3><a id="101_702"></a>10.1受控组件–重点</h3> 
<ul><li>HTML中的表单元素是可输入的，也就是有自己的可变状态</li><li>而React中可变状态通常保存在state中，并且只能通过setState()改变</li><li>React将state与表单元素值value绑定到一起，由state的值来控制表单元素的值</li><li>受控组件：值受到React控制的表单组件</li><li>总的来说就是要使组件的值能随state相应值的改变而改变，state的值也要随组件值的改变而改变，两者相互同步</li></ul> 
<p>绑定步骤：</p> 
<p>1、在state中添加一个状态，作为表单元素的value值(表单绑定state)</p> 
<p>​ state值的改变会使value值改变</p> 
<pre><code class="prism language-react">state={txt:''}
</code></pre> 
<pre><code class="prism language-react">&lt;input type="text" value={this.state.txt}/&gt;
</code></pre> 
<p>2、给表单元素绑定change事件，将表单元素的值设置为state的值（state绑定表单）</p> 
<p>​ 当表单中的value值通过输入改变时同时也会改变state中的值</p> 
<pre><code class="prism language-react">&lt;input type="text" value={this.state.txt} onChange={e=&gt;this.setState({txt:e.target.value})}/&gt;
</code></pre> 
<h3><a id="102_732"></a>10.2多表单元素优化</h3> 
<p>优化：使用一个事件处理程序同时处理多个表单元素</p> 
<p>步骤：</p> 
<p>1、给表单元素添加name属性，名称与state相同（便于分辨和更改state同名的值）</p> 
<pre><code class="prism language-react">&lt;input type="text" name="txt" value={this.state.txt} onChange={this.handleForm}/&gt;
</code></pre> 
<p>这里名称为txt</p> 
<p>name的一个作用是分辨表单标签，而另一个重要作用就是其命名与state中相应变量同名，以便于用标签name名与[]组合来锁定变量以更方便的改变变量的数据，也就是相当于对state中相应变量的一个索引</p> 
<p>2、根据表单元素类型获取相应的值</p> 
<p>3、在change事件处理程序中通过[name]来修改对应的state值</p> 
<pre><code>//根据表单元素类型获取值
const value=(target.type==='checkbox'?target.checked:target.value)
//根据name设置对应的state
this.setState({
	[name]:value//当创建对象并将该对象的键包装在数组括号[]中时，可以动态改变其键名
})
</code></pre> 
<pre><code class="prism language-react">import React from'react'
class FormHandle extends React.Component{
    constructor(){
        super()
        this.state={
            txt:'',
            txtarea:''
        }
    }
    handleForm=e=&gt;{
        //获取当前事件的Dom对象
        const target=e.target;
        //根据类型获取值
        const value=target.type==="checkbox"
        ?target.checked:target.value
        //获取name
        const name=target.name
        //设置state值
        this.setState({
            [name]:value//当创建对象并将该对象的键包装在数组括号[]中时，可以动态改变其键名
        })

    }
    render(){
        return (
            &lt;form&gt;
                &lt;input type="text" name="txt" value={this.state.txt}
                onChange={this.handleForm} &gt;&lt;/input&gt;
                &lt;textarea name="txtarea" 
                value={this.state.txtarea}
                onChange={this.handleForm}&gt;&lt;/textarea&gt;
            &lt;/form&gt;
        )
    }
}

export default FormHandle
</code></pre> 
<h3><a id="103_801"></a>10.3非受控组件–了解</h3> 
<p>借助于ref，使用原生DOM方式来获取表单元素值</p> 
<p>ref:用于获取DOM或组件</p> 
<p>步骤：</p> 
<p>1、调用React.createRef()方法创建一个ref对象</p> 
<pre><code>constructor(){
	super()
	this.txtRef=React.createRef()
}
</code></pre> 
<p>2、将创建好的ref对象添加到文本框中</p> 
<pre><code>&lt;input type="text" ref={this.txtRef}/&gt;
</code></pre> 
<p>3、通过ref对象获取到文本框的值</p> 
<pre><code>console.log(this.txtRef.current.value)
</code></pre> 
<h2><a id="React_830"></a>React组件基础——案例</h2> 
<h2><a id="_832"></a>案例一、评论列表</h2> 
<p>Pinlun.js</p> 
<pre><code class="prism language-react">import React from 'react'
class Pinlun extends React.Component{
    //初始化状态
    state={
        comments:[
            {id:1,name:'jack',content:'沙发！！！'},
            {id:2,name:'rose',content:'板凳'},
            {id:3,name:'tom',content:'楼主好人'}
        ],
        userName:'',
        usercontent:''
    }
    handleForm=(e)=&gt;{
        const target=e.target;
        const {name,value}=target;
        this.setState({
            [name]:value
        })
    }
    renderList=()=&gt;{
       return this.state.comments.length===0
        ?(&lt;div className="no-comment"&gt;暂无评论&lt;/div&gt;)
        :(&lt;ul&gt;
            {this.state.comments.map(item=&gt;(
                &lt;li key={item.id}&gt;
                    &lt;h3&gt;评论者：{item.name}&lt;/h3&gt;
                    &lt;p&gt;{item.content}&lt;/p&gt;
                &lt;/li&gt;
            ))}
        &lt;/ul&gt;)
    }
    addComent=(e)=&gt;{
        const {comments,userName,userContent}=this.state
        const newComments=[...comments,{
            id:Math.random(),
            name:userName,
            content:userContent}]
        this.setState({
            comments:newComments
        })
    }
    render(){
        return (
            &lt;div className="app"&gt;
                &lt;div&gt;
                    &lt;input className="user" type="text"
                    placeholder="请输入评论人" name="userName"value={this.state.userName} onChange={this.handleForm}&gt;&lt;/input&gt;
                    &lt;br/&gt;
                    &lt;textarea className="content"
                    cols='30'
                    rows='10'
                    placeholder="请输入评论" name="userContent"value={this.state.userContent} onChange={this.handleForm}&gt;&lt;/textarea&gt;
                    &lt;br/&gt;
                    &lt;button onClick={this.addComent}&gt;发表评论&lt;/button&gt;
                &lt;/div&gt;
                {this.renderList()}
               
            &lt;/div&gt;
        )
    }


}
export default Pinlun
</code></pre> 
<p>index.js</p> 
<pre><code class="prism language-react">import React from'react'
import ReactDom from'react-dom'
import Pinlun from './component/Pinlun'
  
ReactDom.render(&lt;Pinlun/&gt;,document.getElementById('root'));
</code></pre> 
<p>index.html</p> 
<pre><code class="prism language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<h2><a id="_930"></a>组件进阶</h2> 
<ul><li>能够使用prop接受数据</li><li>实现父子组件通讯</li><li>实现兄弟组件通讯</li><li>给组件添加props校验</li><li>生命周期常用的够自函数</li><li>高阶组件的作用</li></ul> 
<h2><a id="_939"></a>十一、组件通讯</h2> 
<h3><a id="111_941"></a>11.1介绍</h3> 
<p>组件是独立且封闭的单元，默认情况下，只能使用组件自己的数据，在组件化的过程中，我们将一个完整的功能拆分为多个组件，以更好的完成整个应用的功能。而在这个过程中，多个组件之间不可避免的要共享某些数据，为了实现这些功能，就需要打破组件的独立封闭性，让其与外界沟通，这个过程就是组件通讯</p> 
<h3><a id="112props_945"></a>11.2组件的props</h3> 
<p>props:接受传递给组件的数据</p> 
<p>步骤：</p> 
<p>1、传递数据：给组件标签添加属性并赋值</p> 
<pre><code class="prism language-react">&lt;Hello name="jack" age={19}/&gt;
</code></pre> 
<p>2、接收数据：</p> 
<p>​ 函数组件通过参数props接收数据，</p> 
<p>​ 类组件通过this.props接收数据（类要额外加一个this）</p> 
<pre><code class="prism language-react">function Hello(props){
	console.log(props)
	return (
		&lt;div&gt;接收数据：{props.name}&lt;/div&gt;
	)
}
</code></pre> 
<pre><code class="prism language-react">class Hello extends react.Component{
    render(){
        return {
            &lt;div&gt;接收的数据：{this.props.age}&lt;/div&gt;
        }
    }
}
</code></pre> 
<ul><li>特点：可以传递任意类型的数据</li></ul> 
<p>字符串、数字、数组、函数、jsx等都可以</p> 
<ul><li>props里的<strong>值不能修改，只能读取</strong></li><li>在 使用类组件时，如果写了构造函数，**应该将props传递给super（）**否则无法在构造函数中获取props</li></ul> 
<pre><code>constructor(props){//将props传递给构造函数
	super(props)
}
</code></pre> 
<h4><a id="1121_995"></a>11.2.1组件通讯的三种方式</h4> 
<p>1、父组件-》子组件</p> 
<p>2、子组件-》父组件</p> 
<p>3、兄弟组件之间通讯</p> 
<ul><li>父组件传递数据给子组件</li></ul> 
<p>1、父组件提供要传递的state数据</p> 
<p>2、给子组件标签添加属性，值为state中的数据</p> 
<p>3、子组件中通过props接收父组件中传递的数据</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-li0UekvF-1677566304597)(C:\Users\ZYJ\AppData\Roaming\Typora\typora-user-images\image-20230225173721916.png)]</p> 
<ul><li>子组件传递数据给父组件</li></ul> 
<p>思路：利用回调函数，父组件提供回调，子组件调用和，将要传递的数据作为回调函数的参数</p> 
<p>1、父组件提供一个回调函数（用于接收数据）</p> 
<p>2、将该函数作为属性的值，传递给子组件</p> 
<p>3、子组件通过props调用回调函数</p> 
<p>4、将子组件的数据作为参数传递给回调函数</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LYYjJta3-1677566304598)(C:\Users\ZYJ\AppData\Roaming\Typora\typora-user-images\image-20230225221423309.png)]</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-P8DlHDAZ-1677566304599)(C:\Users\ZYJ\AppData\Roaming\Typora\typora-user-images\image-20230225221407010.png)]</p> 
<ul><li>兄弟组件通讯</li></ul> 
<p>①需要将他们的共享状态提升到最近的公共父组件中，由公共父组件管理这个状态，即状态提升</p> 
<p>②公共父组件职责：1、提供共享状态2、提供操作共享状态的方法</p> 
<p>③要通讯的子组件只需要通过props接收状态或操作状态的方法</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Xbmb2CSb-1677566304599)(C:\Users\ZYJ\AppData\Roaming\Typora\typora-user-images\image-20230225175109607.png)]</p> 
<p><strong>总结就是子组件b传递数据给父组件，父组件再传递数据给子组件a</strong></p> 
<h3><a id="113_Context_1051"></a>11.3 Context</h3> 
<p>作用：跨组件传递数据</p> 
<p>Context 设计目的是为了共享那些对于一个<strong>组件树</strong>而言是“全局”的数据，例如当前认证的用户、主题或首选语言。</p> 
<p>步骤：</p> 
<p>1、调用React.createContext()来创建Provider(提供数据)和Consumer(消费数据)两个组件</p> 
<pre><code class="prism language-react">const {Provider,Consumer}=React.createContext()
</code></pre> 
<p>2、使用Provider组件作为父节点</p> 
<pre><code class="prism language-react">&lt;Provider&gt;
	&lt;div className="App"&gt;
    	&lt;Child1/&gt;
    &lt;/div&gt;
&lt;/Provider&gt;
</code></pre> 
<p>3、设置value属性，表示要传递的数据，值可以是字符串、对象等，当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。</p> 
<pre><code class="prism language-react">&lt;Provider value="pink"&gt;
</code></pre> 
<p>4、调用Comsumer组件接收数据</p> 
<pre><code class="prism language-react">&lt;Consumer&gt;
	{data=&gt;&lt;span&gt;接收的数据是:{data}&lt;/span&gt;}
&lt;/Consumer&gt;

</code></pre> 
<p>总结：父节点用Provider提供数据，要接收数据的子节点用Consumer接收</p> 
<p>例子：</p> 
<pre><code class="prism language-react">const {Provider,Consumer}=React.createContext()
class App extends React.Component{
    render(){
        return(
        	&lt;Provider value="pink"&gt;
            	&lt;div className="app"&gt;
                    &lt;Node/&gt;
                &lt;/div&gt;
            &lt;/Provider&gt;
        )
    }
}
const Node=props=&gt;{
    return (
    	&lt;div className="node"&gt;
            &lt;SubNode/&gt;
        &lt;/div&gt;
    )
}
const SubNode=props=&gt;{
    return(
    &lt;div className="subnode"&gt;
            &lt;Child/&gt;
        &lt;/div&gt;
    )
}
const Child=props=&gt;{
    return (
    &lt;div className="child"&gt;
        &lt;Consumer&gt;
        {
                data=&gt;&lt;span&gt;我是子节点--{data}&lt;/span&gt;
            }
        &lt;/Consumer&gt;
     &lt;/div&gt;
     )
}
</code></pre> 
<h2><a id="props_1136"></a>十二、props深入</h2> 
<h3><a id="121_children_1138"></a>12.1 children属性</h3> 
<ul><li>children属性：表示组件标签的子节点。当组件标签有子节点时，props就会有该属性。</li><li>也就是说当组件为双标签时渲染时标签中间的那部分元素会被渲染到props.children的位置</li></ul> 
<pre><code class="prism language-react">function Hello(props){
	return (
    	&lt;div&gt;
        组件的子节点:{props.children}
        &lt;/div&gt;
    )
}
ReactDOM.render(&lt;Hello&gt;我是文本子节点&lt;/Hello&gt;,root)
</code></pre> 
<p>渲染结果为：</p> 
<p>组件的子节点:我是文本子节点</p> 
<ul><li>总结：props.children的值就是组件双标签中嵌套的元素，且children的值可以是任意值（文本、React元素、组件、甚至函数）</li></ul> 
<h3><a id="122_props_1162"></a>12.2 props校验</h3> 
<ul><li> <p>对于组件来说，props是外来的，无法保证组件使用者传入什么格式的数据</p> </li><li> <p>若传入数据格式不对，可能会导致组件内部错误</p> </li><li> <p>关键是使用者并不明确错误原因</p> </li><li> <p>因此需要有props校验</p> </li><li> <p>props校验：允许在创建组件的时候，就指定props的类型、格式等</p> </li><li> <p>作用：捕获使用组件时因为props导致的错误，给出明确的错误提示，增加组件的健壮性</p> </li></ul> 
<p>步骤：</p> 
<p>1、安装prop-types命令为：npm i props-types</p> 
<p>2、导入prop-types包</p> 
<pre><code class="prism language-react">import PropTypes from 'prop-types'
</code></pre> 
<p>3、使用 <mark>组件名.propTypes={}</mark> 来给props添加校验规则</p> 
<p>4、校验规则通过PropTypes对象来指定</p> 
<pre><code class="prism language-react">import PropTypes from 'prop-types'
function App(props){
    return(
    &lt;h1&gt;hi,{props.colors}&lt;/h1&gt;
    )
}
App.propTypes={
    //约定colors属性为array类型
    //若类型不对则会报明确错误
    colors:PropTypes.array
}
</code></pre> 
<h3><a id="123props_1204"></a>12.3props校验-约束规则</h3> 
<p>1、常见类型：array,bool,func,number,object,string,symbol等</p> 
<p>2、React元素类型:element</p> 
<p>3、必填项:isRequired</p> 
<p>4、特定结构的对象：shape({ })</p> 
<p>更多类型可以查看相关文档</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-t9c1G7dN-1677566304600)(C:\Users\ZYJ\AppData\Roaming\Typora\typora-user-images\image-20230226111853234.png)]</p> 
<h3><a id="124props_1218"></a>12.4props的默认值</h3> 
<p>defaultProps={}</p> 
<p>场景：分页组件-&gt;每页显示条数</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-MM1u1VmF-1677566304600)(C:\Users\ZYJ\AppData\Roaming\Typora\typora-user-images\image-20230226115618139.png)]</p> 
<p>当props的一个值没有被传入则会使用默认值</p> 
<h2><a id="_1228"></a>十三、组件的生命周期</h2> 
<h3><a id="131__1230"></a>13.1 介绍</h3> 
<ul><li> <p>理解组件的生命周期有助于来理解组件的运行方式、完成更复杂的组件功能、分析组件错误原因等</p> </li><li> <p><strong>组件的生命周期：组件从被创建到挂载到页面中运行，再到组件不用时卸载的过程</strong></p> </li><li> <p>生命周期的每个阶段总是伴随着一些方法调用，这些方法就是生命周期的<strong>钩子函数</strong></p> </li><li> <p><strong>钩子函数</strong>的作用：为开发人员在不同阶段操作组件提供时机</p> </li><li> <p><strong>只有类组件才有生命周期</strong></p> </li></ul> 
<h3><a id="132_1241"></a>13.2生命周期的三个阶段</h3> 
<ul><li>每个阶段的执行时机</li><li>每个阶段钩子函数的执行顺序</li><li>每个阶段钩子的作用</li></ul> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RQVqcB7A-1677566304601)(C:\Users\ZYJ\AppData\Roaming\Typora\typora-user-images\image-20230226120513006.png)]</p> 
<p>1、创建时（挂载阶段）</p> 
<ul><li>执行时机：组件创建时（页面加载时）</li><li>执行顺序</li></ul> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SLAXtdFB-1677566304601)(C:\Users\ZYJ\AppData\Roaming\Typora\typora-user-images\image-20230226120715489.png)]</p> 
<table><thead><tr><th>钩子函数</th><th>触发时机</th><th>作用</th></tr></thead><tbody><tr><td>constructor</td><td>创建组件时，最先执行</td><td>1、初始化state<br>2、为事件处理程序绑定this</td></tr><tr><td>render</td><td>每次组件渲染时触发</td><td>渲染UI，不能在render调用setState（）</td></tr><tr><td>componentDidMount</td><td>组件挂载（完成DOM渲染）后</td><td>1、发送网络请求<br>2、DOM操作</td></tr></tbody></table> 
<p>2、更新时</p> 
<p>更新触发条件：接收新的 props,setState(),foceUpdate()</p> 
<p>执行顺序：</p> 
<p>render=》componentDidUpdate</p> 
<table><thead><tr><th>钩子函数</th><th>触发时机</th><th>作用</th></tr></thead><tbody><tr><td>render</td><td>每次组件渲染</td><td>渲染UI</td></tr><tr><td>componentDidUpdate</td><td>组件更新后</td><td>1、发送网络请求<br>2、DOM操作<br>注意：如果要setState必须要放在一个if中，因为setState会导致组件更新导致循环递归</td></tr></tbody></table> 
<pre><code class="prism language-react">componentDidUpdate(preProps){
    //比较更新前后的props中的值是否相同来决定是否重新渲染组件，前一个props可以通过prevProps来获取
	if(prevProps.count!==this.props.count){
	this.setState({
	
	})
	}
}
</code></pre> 
<p>3、卸载时</p> 
<p>执行时机：组件从页面中消失</p> 
<table><thead><tr><th>钩子函数</th><th>触发时机</th><th>作用</th></tr></thead><tbody><tr><td>componentWillUnmount</td><td>组件卸载</td><td>执行清理工作，比如清理定时器等</td></tr></tbody></table> 
<ul><li><strong>不常用的钩子函数</strong>–了解</li></ul> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-MMI1DFud-1677566304602)(C:\Users\ZYJ\AppData\Roaming\Typora\typora-user-images\image-20230226153624068.png)]</p> 
<h2><a id="render_props_1300"></a>十四、render props</h2> 
<h3><a id="141React_1302"></a>14.1React组件复用概述</h3> 
<ul><li> <p>复用相似的功能（联想函数封装）</p> </li><li> <p>复用什么？ <strong>1、state2、操作state的方法</strong></p> <p>（即复用组件的状态逻辑）</p> </li><li> <p>两种方式：1、render props模式 2、高阶组件HOC</p> </li><li> <p>这两种方式不是新的API，而是利用React自身特点的编码技巧，演化而成的固定模式（写法）</p> </li><li> <p>我的理解：可以说是这个组件提供了一个接口让其它组件来共用state数据和方法</p> </li></ul> 
<h3><a id="142render_props_1316"></a>14.2render props模式</h3> 
<p>思路：将要复用的state和操作state的方法封装到一个组件中</p> 
<ul><li> <p>如何拿到该组件中复用的state?</p> <p>在使用组件时，添加一个值为函数的prop，通过函数参数来获取（需要组件内部实现）</p> </li></ul> 
<pre><code class="prism language-react">&lt;Mouse render={(mouse)=&gt;{}}&gt;
</code></pre> 
<ul><li> <p>如何渲染任意UI？</p> <p>使用该<strong>函数的返回值</strong>作为要渲染的UI内容（jsx）</p> </li></ul> 
<pre><code class="prism language-react">&lt;Mouse render={(mouse)=&gt;{&lt;p&gt;鼠标当前位置{mouse.x},{mouse.y}&lt;/p&gt;}}/&gt;
</code></pre> 
<ul><li>使用步骤</li></ul> 
<p>1、创建Mouse组件，在组件中提供复用的状态逻辑代码（1、状态，2、操作状态的方法）</p> 
<p>2、将要复用的状态作为props.render(state)方法的参数，暴露到组件外部（把state的值通过参数传给组件的函数render，render函数名可以更改）</p> 
<p>3、使用props.render()的返回值作为要渲染的内容</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UzHc7h0J-1677566304602)(C:\Users\ZYJ\AppData\Roaming\Typora\typora-user-images\image-20230226160505338.png)]</p> 
<p>总结：1、也就是由组件本身来提供state数据和操作state数据的方法，2、再用this.props.function(this.state)将state数据暴露给组件外部，3、然后由组件标签属性来提供JSX结构负责如何渲染这个数据。</p> 
<p>简单来说就是再组件的render（）函数中的return处调用组件的属性中的自定义的返回JSX的方法来渲染该自定义的jsx，</p> 
<p>其实就是Mouze组件提供了一个接口render使得render{}中的组件/函数能够使用其state和state方法</p> 
<p>Mouse.js</p> 
<pre><code class="prism language-react">import React from 'react'

//创建Mouse组件
class Mouse extends React.Component{
    //鼠标位置state
    state={
        x:0,
        y:0
    }
    handleMouseMove=e=&gt;{
        this.setState({
            x:e.clientX,
            y:e.clientY
        })
    }
    //监听鼠标移动事件
    componentDidMount(){
        window.addEventListener('mousemove',this.handleMouseMove)
    }
    render(){
        return this.props.Mrender(this.state)
    }
}
export default Mouse
</code></pre> 
<p>index.js</p> 
<pre><code class="prism language-react">import React from'react'
import ReactDOM from'react-dom'
import Mouse from './component/Mouse'

const jsx=(
    &lt;Mouse Mrender={(state)=&gt;{
       return( &lt;p&gt;鼠标位置:{state.x},{state.y}&lt;/p&gt;)
    }}/&gt;
)
ReactDOM.render(jsx,document.getElementById('root'));

</code></pre> 
<p>总的来看如果不需要复用，按正常写则index.js中的jsx应该之间写在Mouse.js中的render函数中，让其渲染。但考虑到复用，render只将组件渲染需要用到的state数据通过函数的方式传给了组件，让组件在外部渲染时使用组件数据，且让组件属性Mrender的return来决定如何渲染，渲染怎样的jsx结构</p> 
<h3><a id="143childrenrender_1407"></a>14.3children代替render属性</h3> 
<p>并不是该模式叫做render props就必须使用名为render的prop，实际上，可以用任意名称的prop</p> 
<p>仅仅是把prop是一个函数，并且告诉组件要渲染什么内容的技术叫做：render prop模式</p> 
<ul><li>推荐children代替render属性</li></ul> 
<pre><code class="prism language-react">&lt;Mouse&gt;
{({x,y})=&gt;&lt;p&gt;鼠标的位置是{x},{y}&lt;/p&gt;}
&lt;/Mouse&gt;
//组件内部
this.props.children(this.state)
</code></pre> 
<p>其实就是把render函数写在了组件标签之间由children来传递参数</p> 
<h3><a id="144_1425"></a>14.4代码优化</h3> 
<p>1、推荐给render props模式添加props校验</p> 
<pre><code class="prism language-react">Mouse.propTypes={
	render:propTypes.func.isRequired
}
</code></pre> 
<p>2、应该在组件卸载时解除mousemove事件绑定</p> 
<pre><code class="prism language-react">componentWillUnmount(){
	window.removeEventListener('mousemove',this.handleMouseMove)
}
</code></pre> 
<h2><a id="_1443"></a>十五、高阶组件</h2> 
<h3><a id="151_1445"></a>15.1介绍</h3> 
<p>目的：实现状态逻辑复用</p> 
<ul><li> <p>采用包装模式实现复用（函数包装组件）</p> </li><li> <p>高阶组件（HOC）是一个函数，接收要包装的组件，返回增强后的组件，也就是他的参数是一个组件而且返回值也是一个组件</p> </li><li> <p>在高阶组件内部创建一个类组件，在这个类组件中提供复用的状态逻辑代码，通过props将复用的状态传递给作为参数的组件</p> </li></ul> 
<h3><a id="152_1454"></a>15.2使用步骤：</h3> 
<p>1、创建一个函数，名称约定<strong>以with开头</strong></p> 
<pre><code class="prism language-react">function withMouse(){}
</code></pre> 
<p>2、指定函数参数，<strong>参数应该以大写字母开头</strong>（作为要渲染的组件）</p> 
<pre><code class="prism language-react">function withMouse(WrappedComponent){}
</code></pre> 
<p>3、在函数内部创建一个类组件，提供复用的状态逻辑代码，并返回</p> 
<pre><code class="prism language-react">function withMouse(WrappedComponent){
	class Mouse extends React.Component{}
	return Mouse
}
</code></pre> 
<p>4、在该组件中，渲染参数组件，同时将状态通过props传递给参数组件</p> 
<pre><code class="prism language-react">function withMouse(WrappedComponent){
	class Mouse extends React.Component{//复用组件，用于负责复用的state数据和方法
        state={
            .......
        }
        //这里省略操作state的方法
        render{
            //不同的jsx结构渲染
            return &lt;WrappedComponent {...this.state}/&gt;//这里可以通过扩展运算符...来把state的数据依次转为props属性
        }
    }
	return Mouse
}


</code></pre> 
<p>5、调用该高阶组件，传入要增强的组件，通过返回值拿到增强后的组件，并将其渲染到页面中</p> 
<pre><code>//调用组件
const MousePosition=widthMouse(Position)
//渲染组件
&lt;MousePosition/&gt;
</code></pre> 
<p>所以高阶组件复用实质上是将组件中render函数中的jsx结构分离出来成为一个单独的组件，再利用函数的方式将这个组件作为参数与函数中的组件融合并返回一个新的组件实现复用，简单来说实质上就是两个组件的一次嵌套或者说融合</p> 
<p>例子</p> 
<p>Mouse.js</p> 
<pre><code class="prism language-react">import React from 'react'

//创建高阶组件
function withMouse(WrappedComponent){
    //创建提供复用的组件
    class Mouse extends React.Component{
        //鼠标位置state
        state={
            x:0,
            y:0
        }
        handleMouseMove=e=&gt;{
            this.setState({
                x:e.clientX,
                y:e.clientY
            })
        }
        //监听鼠标移动事件
        componentDidMount(){
            window.addEventListener('mousemove',this.handleMouseMove)
        }
        componentWillUnmount(){
            window.removeEventListener('mousemove',this.handleMouseMove)
        }
        render(){
            return &lt;WrappedComponent {...this.state}/&gt;//这里利用扩展运算符将state的数据依次转为props属性
        }
    }
    return Mouse
}

export default withMouse
</code></pre> 
<p>index.js</p> 
<pre><code class="prism language-react">import React from'react'
import ReactDOM from'react-dom'
import withMouse from './component/Mouse'

const Position=props=&gt;{//用于测试高阶组件
  return (&lt;p&gt;
    鼠标当前位置:(x:{props.x},y:{props.y})
&lt;/p&gt;)  
}
const MousePosition=withMouse(Position)//调用高阶组件（函数）

ReactDOM.render(&lt;MousePosition/&gt;,document.getElementById('root'));//渲染

</code></pre> 
<p>自我总结：通过对高阶组件和render props模式的学习可以发现，组件的复用关键点都是在render函数的renturn处也就是要渲染的jsx结构，它都是被分离了出来形成了单独的可以在外部自定义的组件或者函数，而复用的部分都是state或者操作state的部分</p> 
<h3><a id="153_displayName_1567"></a>15.3 设置displayName</h3> 
<ul><li>使用高阶组件得到的不同组件的标签名相同这是一个问题</li><li>原因：默认情况下，Reac使用组件名称作为displayName</li><li>解决：为高阶组件设置displayName便于调试时区分不同组件</li><li>displayName：用于设置调试信息</li><li>方式：</li></ul> 
<pre><code class="prism language-react">Mouse.displayName = `WithMouse${getDisplayName(WrappedComponent)}`

function getDisplayName(WrappedComponent) {
	return WrappedComponent.displayName || WrappedComponent.name || 'Component'
}

</code></pre> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-NLzcQFd0-1677566304603)(C:\Users\ZYJ\AppData\Roaming\Typora\typora-user-images\image-20230227094023715.png)]</p> 
<h3><a id="154props_1588"></a>15.4传递props</h3> 
<ul><li>问题：props丢失</li><li>原因：高阶组件没有往下传递props</li><li>解决方式：渲染 WrappedComponent 时，将 state 和 this.props 一起传递给组件</li><li>传递方式：</li></ul> 
<pre><code class="prism language-react">&lt;WrappedComponent {...this.state} {...this.props} /&gt;
</code></pre> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3ZCdd77i-1677566304603)(C:\Users\ZYJ\AppData\Roaming\Typora\typora-user-images\image-20230227094519911.png)]</p> 
<h2><a id="React_1601"></a>十六、React原理揭秘</h2> 
<p>学习目标：</p> 
<ul><li>能知道setSate()更新数据是异步的</li><li>能知道JSX语法的转化过程</li><li>能说出React组件的更新机制</li><li>能对组件进行性能优化</li><li>能说出虚拟DOM和Diff算法</li></ul> 
<h3><a id="1setState_1611"></a>1、setState()说明</h3> 
<h4><a id="11_1613"></a>1.1更新数据</h4> 
<ul><li> <p>setState()更新数据是<strong>异步</strong>的</p> </li><li> <p>在setState更新之后立即用console输出可以发现数据是之前的</p> </li><li> <p>所以注意：使用该语法时后面的setState不能依赖于前面的setState</p> </li><li> <p>可以调用多次setState但只会在最后一次调用时render更新UI，这是为了性能</p> </li></ul> 
<h4><a id="12_1622"></a>1.2推荐语法</h4> 
<ul><li> <p>setState((state,props)=&gt;{ })</p> </li><li> <p>参数</p> 
  <ul><li>state:表示最新的state</li><li>props:表示最新的props</li></ul> </li></ul> 
<pre><code class="prism language-react">this.setState((state,props)=&gt;{//与setState一样也是异步更新
	return {
		count:state.count+1
	}
})
console.log(this.state.count)
</code></pre> 
<ul><li>使用该语法可以连续使用setState</li><li>推荐使用该方式替代之前的setState</li></ul> 
<h4><a id="13setState_1642"></a>1.3setState第二参数</h4> 
<ul><li>场景：在状态更新后立即执行某个操作</li><li>语法：setState(update[,callback])</li><li>第二个参数是一个回调函数，函数会在状态更新完成且页面渲染之后立即执行，比如函数中console输出的是更新后的数据，可以操作dom</li></ul> 
<pre><code class="prism language-react">this.setState(
	(state,props)=&gt;{},
	()=&gt;{console.log('这个回调函数会在状态更新完成后立即执行')}
)
</code></pre> 
<h3><a id="2JSX_1655"></a>2、JSX语法转化过程</h3> 
<ul><li> <p>JSX仅仅是createElement()方法的语法糖（简化语法）</p> </li><li> <p>JSX语法被@babel/preset-react插件编译为createElement()方法</p> </li><li> <p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZH57YaD3-1677566304604)(C:\Users\ZYJ\AppData\Roaming\Typora\typora-user-images\image-20230227102228380.png)]</p> </li><li> <p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rAm3v2C0-1677566304604)(C:\Users\ZYJ\AppData\Roaming\Typora\typora-user-images\image-20230227102309634.png)]</p> </li></ul> 
<h3><a id="3_1669"></a>3、组件更新机制</h3> 
<ul><li>setState的两个作用:1、修改state 2、更新组件（UI）</li><li>父组件重新渲染时，也会重新渲染子组件，但只会渲染当前组件子树（当前组件及其所有子组件）</li></ul> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dsPaFjE2-1677566304604)(C:\Users\ZYJ\AppData\Roaming\Typora\typora-user-images\image-20230227103108005.png)]</p> 
<h3><a id="4_1676"></a>4、组件性能优化</h3> 
<h4><a id="41state_1678"></a>4.1减轻state</h4> 
<ul><li>减轻state：只存储跟组件渲染相关的数据（比如:相关变量/列表数据/loding等）</li><li>不用在渲染的数据不要放在state中，比如定时器id等</li><li>对于这种需要在多个方法中用到的数据，应该放在对象的this中</li></ul> 
<h4><a id="42_1684"></a>4.2避免不必要的重新渲染</h4> 
<ul><li>组件更新机制：父组件更新会引起子组件也被更新，这种思路很清晰</li><li>但子组件没有任何变化时也会重新渲染</li><li>如何避免不必要的重新渲染？</li></ul> 
<p>解决方法：使用钩子函数 shouldComponentUpdate(nextProps,nextState)</p> 
<p>作用：通过返回值决定该组件是否重新渲染，返回true表示重新渲染，false表示不重新渲染</p> 
<p>触发时机:更新阶段的钩子函数，组件重新渲染前执行(shouldComponentUpdate-&gt;render)</p> 
<pre><code class="prism language-react">souldComponentUpdate(nexntProps,nextState){
	console.log("最新的state",nextState)
	console.log("更新前的state",this.state)
	
}
</code></pre> 
<h4><a id="43_1704"></a>4.3纯组件</h4> 
<ul><li> <p>纯组件:React.PureComponent 与 React.Component功能相似</p> </li><li> <p>区别：PureComponent内部自动实现了shouldComponentUpdate钩子，不需要手动比较</p> </li><li> <p>原理:纯组件内部通过比较前后两次的props和state的值来决定是否重新渲染组件</p> </li></ul> 
<pre><code class="prism language-react">class Hello extends React.PureComponent{
	render(){
		return()
	}
}
</code></pre> 
<ul><li> <p>说明：纯组件内部的对比是shallow compare （浅层对比）</p> </li><li> <p>浅层对比对于<strong>值类型</strong>来说：比较两个值是否相同（直接赋值即可，没有坑）</p> </li><li> <p>浅层对比对于<strong>引用类型</strong>来说，只比较对象的引用地址是否相同（里面可能值不同，有坑）</p> </li></ul> 
<h3><a id="5DOMDiff_1725"></a>5、虚拟DOM和Diff算法</h3> 
<ul><li>React更新视图的思想是：只要state变化就重新渲染视图</li><li>特点：思路清晰</li><li>问题：组件中只有一个DOM元素需要更新时，也得把整个组件的内容重新渲染到页面中</li><li>理想状态：部分更新，只更新变化的地方</li><li>如何实现部分更新？</li><li>虚拟DOM配合Diff算法</li></ul> 
<p>虚拟DOM：本质上是一个JS对象，用来描述你希望在屏幕上看到的内容（UI）</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eTz8agzh-1677566304605)(C:\Users\ZYJ\AppData\Roaming\Typora\typora-user-images\image-20230227112441297.png)]</p> 
<p>执行过程：</p> 
<p>1、初次渲染时，react会根据初始state创建一个虚拟DOM对象（树）</p> 
<p>2、根据虚拟DOM生成正真的DOM，渲染到页面中</p> 
<p>3、当数据变化后，重新根据新数据，创建新的虚拟DOM对象</p> 
<p>4、与上一次得到的DOM对象使用Diff算法对比，得到需要更新的内容</p> 
<p>5、最终，React只将变化的内容更新到DOM中，重新渲染到页面</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-YJs2gD30-1677566304606)(C:\Users\ZYJ\AppData\Roaming\Typora\typora-user-images\image-20230227112604567.png)]</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jhGtppkM-1677566304606)(C:\Users\ZYJ\AppData\Roaming\Typora\typora-user-images\image-20230227142733414.png)]</p> 
<h2><a id="React_1758"></a>十七、React路由</h2> 
<h3><a id="1_1760"></a>1、介绍</h3> 
<p>现在前端应用大多是SPA（单页应用程序），也就是只有一个HTML页面的应用程序，因为它的用户体验更好，对服务器的压力更小，所以更受欢迎。为了有效的使用单个页面来管理原来多页面的功能，前端路由应运而生</p> 
<ul><li>前端路由的功能：让用户从一个视图（页面）导航到另一个视图</li><li>前端路由是一套映射规则，在React中，是URL路径与组件的对应关系</li><li>使用React路由简单来说，就是配置路径和组件（配对）</li></ul> 
<h3><a id="2_1768"></a>2、路由的基本使用</h3> 
<h4><a id="21_1770"></a>2.1使用步骤</h4> 
<p>步骤：</p> 
<ul><li> <p>安装npm install react-router-dom</p> </li><li> <p>导入路由的三个核心组件:Router/Route/Link</p> <pre><code class="prism language-react">import {BrowserRouter as Router,Route,Link} from 'react-router-dom'
</code></pre> </li><li> <p>使用Router组件包裹整个应用</p> </li></ul> 
<pre><code class="prism language-react">&lt;Router&gt;
	&lt;div className="App"&gt;
	//...省略页面内容
	&lt;/div&gt;
&lt;/Router&gt;
</code></pre> 
<ul><li>使用Link组件作为导航菜单（路由入口）(类似超链接)</li></ul> 
<pre><code class="prism language-react">//to属性：url的pathname
&lt;Link to="/first"&gt;页面&lt;/Link&gt;
</code></pre> 
<ul><li>使用Route组件配置路由规则和要展示的组件（路由出口）（类似点击超链接后展示的相应页面）</li></ul> 
<pre><code class="prism language-react">const First=()=&gt;(&lt;p&gt;页面一的内容&lt;/p&gt;)
&lt;Router&gt;
      &lt;div className="App"&gt;
      	&lt;Link to="/first"&gt;页面一&lt;/Link&gt;
        &lt;Route path="/first" component={First}&gt;&lt;/Route&gt;
      &lt;/div&gt;
&lt;/Router&gt;
</code></pre> 
<h4><a id="22_1811"></a>2.2、常用组件说明</h4> 
<ul><li> <p>Router组件：包裹整个应用，一个React应用只需要使用一次</p> </li><li> <p>两种常用Router:HashRouter和BrowserRouter</p> </li><li> <p>HashRouter：使用URL的哈希值实现（不推荐）</p> </li><li> <p>(推荐)BrowserRouter:使用H5的history API实现</p> </li><li> <p>Link组件：用于指定导航标签，最终会被编译成一个a标签，to属性表示浏览器地址栏中的pathname</p> </li><li> <p>Route组件：指定路由展示组件相关信息</p> </li></ul> 
<pre><code class="prism language-react">//path属性：路由规则
//component属性：展示的组件
//Route组件写在哪，渲染出的组件就展示在哪
&lt;Route path="/first" component={First}&gt;&lt;/Route&gt;
</code></pre> 
<h3><a id="3_1828"></a>3、路由执行过程</h3> 
<p>1、点击Link标签，修改了里卢兰其地址栏中的URL</p> 
<p>2、React路由监听到地址栏URL的变化</p> 
<p>3、React路由内部遍历所有Route组件，使用路由规则（path）与pathname进行匹配</p> 
<p>4、当路由规则path能够匹配地址栏中的pathname时就展示该Route组件的内容（每一个route都会去匹配）</p> 
<h3><a id="4_1838"></a>4、编程式导航</h3> 
<ul><li> <p>场景：点击登录按钮，登陆成功后，通过代码跳转到后台首页</p> </li><li> <p>编程式导航：通过JS代码来实现页面跳转</p> </li><li> <p>history是React路由提供的，用于获取浏览器历史记录的相关信息</p> </li><li> <p>push(path):跳转到某个页面，参数path表示要跳转的路径</p> </li></ul> 
<pre><code class="prism language-react">class Login extends Component{
	handleLogin=()=&gt;{//编程式导航实现路由跳转
		//...
		this.props.history.push('/home')
	}
	render(){
		//...
	}
}
</code></pre> 
<h3><a id="5_1858"></a>5、默认路由</h3> 
<ul><li>在进入页面的时候就展示默认的组件</li><li>默认路由：表示进入页面时就会匹配的路由</li><li>默认路由path为：/</li></ul> 
<pre><code class="prism language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Route</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/<span class="token punctuation">"</span></span> <span class="token attr-name">component</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>{Home}</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Route</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<h3><a id="6_1868"></a>6、匹配模式</h3> 
<h4><a id="61_1870"></a>6.1模糊匹配</h4> 
<ul><li> <p>问题：在link中用/login依然能够匹配到默认路由/</p> </li><li> <p>原因：默认情况下，React路由是模糊匹配模式</p> </li><li> <p>模糊匹配规则：只要link中的pathname（link的to属性/地址栏url的pathname）以route中path值开头，这两个就会匹配成功</p> <p>比如：route中的path为/能匹配所有的pathname，/first能匹配/first，/first/a/b等</p> </li></ul> 
<h4><a id="62_1880"></a>6.2精确匹配</h4> 
<ul><li> <p>如何避免默认路由在任何情况下展示</p> </li><li> <p>给Route组件添加exact属性，让其变成精确匹配模式</p> </li><li> <p>精确匹配：只要path和pathname完全匹配时才会展示该路由</p> </li></ul> 
<pre><code class="prism language-react">&lt;Route excat path="/" component...&gt;
</code></pre> 
<p>推荐：给默认路由添加exact属性<br> om’</p> 
<pre><code>
+ 使用Router组件包裹整个应用

```react
&lt;Router&gt;
  &lt;div className="App"&gt;
  //...省略页面内容
  &lt;/div&gt;
&lt;/Router&gt;
</code></pre> 
<ul><li>使用Link组件作为导航菜单（路由入口）(类似超链接)</li></ul> 
<pre><code class="prism language-react">//to属性：url的pathname
&lt;Link to="/first"&gt;页面&lt;/Link&gt;
</code></pre> 
<ul><li>使用Route组件配置路由规则和要展示的组件（路由出口）（类似点击超链接后展示的相应页面）</li></ul> 
<pre><code class="prism language-react">const First=()=&gt;(&lt;p&gt;页面一的内容&lt;/p&gt;)
&lt;Router&gt;
      &lt;div className="App"&gt;
      	&lt;Link to="/first"&gt;页面一&lt;/Link&gt;
        &lt;Route path="/first" component={First}&gt;&lt;/Route&gt;
      &lt;/div&gt;
&lt;/Router&gt;
</code></pre> 
<h4><a id="22_1924"></a>2.2、常用组件说明</h4> 
<ul><li> <p>Router组件：包裹整个应用，一个React应用只需要使用一次</p> </li><li> <p>两种常用Router:HashRouter和BrowserRouter</p> </li><li> <p>HashRouter：使用URL的哈希值实现（不推荐）</p> </li><li> <p>(推荐)BrowserRouter:使用H5的history API实现</p> </li><li> <p>Link组件：用于指定导航标签，最终会被编译成一个a标签，to属性表示浏览器地址栏中的pathname</p> </li><li> <p>Route组件：指定路由展示组件相关信息</p> </li></ul> 
<pre><code class="prism language-react">//path属性：路由规则
//component属性：展示的组件
//Route组件写在哪，渲染出的组件就展示在哪
&lt;Route path="/first" component={First}&gt;&lt;/Route&gt;
</code></pre> 
<h3><a id="3_1941"></a>3、路由执行过程</h3> 
<p>1、点击Link标签，修改了里卢兰其地址栏中的URL</p> 
<p>2、React路由监听到地址栏URL的变化</p> 
<p>3、React路由内部遍历所有Route组件，使用路由规则（path）与pathname进行匹配</p> 
<p>4、当路由规则path能够匹配地址栏中的pathname时就展示该Route组件的内容（每一个route都会去匹配）</p> 
<h3><a id="4_1951"></a>4、编程式导航</h3> 
<ul><li> <p>场景：点击登录按钮，登陆成功后，通过代码跳转到后台首页</p> </li><li> <p>编程式导航：通过JS代码来实现页面跳转</p> </li><li> <p>history是React路由提供的，用于获取浏览器历史记录的相关信息</p> </li><li> <p>push(path):跳转到某个页面，参数path表示要跳转的路径</p> </li></ul> 
<pre><code class="prism language-react">class Login extends Component{
	handleLogin=()=&gt;{//编程式导航实现路由跳转
		//...
		this.props.history.push('/home')
	}
	render(){
		//...
	}
}
</code></pre> 
<h3><a id="5_1971"></a>5、默认路由</h3> 
<ul><li>在进入页面的时候就展示默认的组件</li><li>默认路由：表示进入页面时就会匹配的路由</li><li>默认路由path为：/</li></ul> 
<pre><code class="prism language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Route</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/<span class="token punctuation">"</span></span> <span class="token attr-name">component</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>{Home}</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Route</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<h3><a id="6_1981"></a>6、匹配模式</h3> 
<h4><a id="61_1983"></a>6.1模糊匹配</h4> 
<ul><li> <p>问题：在link中用/login依然能够匹配到默认路由/</p> </li><li> <p>原因：默认情况下，React路由是模糊匹配模式</p> </li><li> <p>模糊匹配规则：只要link中的pathname（link的to属性/地址栏url的pathname）以route中path值开头，这两个就会匹配成功</p> <p>比如：route中的path为/能匹配所有的pathname，/first能匹配/first，/first/a/b等</p> </li></ul> 
<h4><a id="62_1993"></a>6.2精确匹配</h4> 
<ul><li> <p>如何避免默认路由在任何情况下展示</p> </li><li> <p>给Route组件添加exact属性，让其变成精确匹配模式</p> </li><li> <p>精确匹配：只要path和pathname完全匹配时才会展示该路由</p> </li></ul> 
<pre><code class="prism language-react">&lt;Route excat path="/" component...&gt;
</code></pre> 
<p>推荐：给默认路由添加exact属性</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b1f85375828c0b60c406e96fd10a301f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用Java实现高效的字符串匹配算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fd10afd948706bd8111779f7a3fbea8f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js获取对象数组中的id集合</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>