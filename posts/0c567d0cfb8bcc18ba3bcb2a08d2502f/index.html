<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>leetcode350--- 两个数组的交集 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="leetcode350--- 两个数组的交集" />
<meta property="og:description" content="leetcode350— 两个数组的交集 关键字：哈希表，双指针
题目 给定两个数组，编写一个函数来计算它们的交集。
示例 1：
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
示例 2:
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
说明：
输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。
我们可以不考虑输出结果的顺序。
进阶：
如果给定的数组已经排好序呢？你将如何优化你的算法？如果 nums1 的大小比 nums2 小很多，哪种方法更优？如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii
方法 1.哈希表 新建一个列表用于储存交集的元素。对数组1遍历建立字典，字典的键为数组的元素值，对应的值为该元素在字典中出现的次数。遍历数组2，查找数组2的值是否在字典的键中出现且对应次数是否大于0，如果出现则加入列表并且将对应次数减1。返回列表 代码如下：
class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: hashmap = {} result = [] for d in nums1: if d in hashmap.keys(): hashmap[d] &#43;= 1 else: hashmap[d] = 1 for j in nums2: if j in hashmap." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0c567d0cfb8bcc18ba3bcb2a08d2502f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-03T18:32:49+08:00" />
<meta property="article:modified_time" content="2021-05-03T18:32:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">leetcode350--- 两个数组的交集</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="leetcode350__1"></a>leetcode350— 两个数组的交集</h2> 
<p><font color="#999AAA">关键字：哈希表，双指针<br> </font></p> 
<hr color="#000000" size='1"'> 
<h3><a id="_10"></a>题目</h3> 
<p>给定两个数组，编写一个函数来计算它们的交集。</p> 
<p>示例 1：</p> 
<p>输入：nums1 = [1,2,2,1], nums2 = [2,2]<br> 输出：[2,2]<br> 示例 2:</p> 
<p>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br> 输出：[4,9]</p> 
<p>说明：</p> 
<p>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。<br> 我们可以不考虑输出结果的顺序。</p> 
<p>进阶：</p> 
<ul><li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li><li>如果 nums1 的大小比 nums2 小很多，哪种方法更优？</li><li>如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li></ul> 
<p>来源：力扣（LeetCode）<br> 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii</p> 
<hr color="#000000" size='1"'> 
<h3><a id="_43"></a>方法</h3> 
<h4><a id="1_44"></a>1.哈希表</h4> 
<ol><li>新建一个列表用于储存交集的元素。</li><li>对数组1遍历建立字典，字典的键为数组的元素值，对应的值为该元素在字典中出现的次数。</li><li>遍历数组2，查找数组2的值是否在字典的键中出现且对应次数是否大于0，如果出现则加入列表并且将对应次数减1。</li><li>返回列表</li></ol> 
<p><font color="#999AAA">代码如下：</font></p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">intersect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        hashmap <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> d <span class="token keyword">in</span> nums1<span class="token punctuation">:</span>
            <span class="token keyword">if</span> d <span class="token keyword">in</span> hashmap<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                hashmap<span class="token punctuation">[</span>d<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                hashmap<span class="token punctuation">[</span>d<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> nums2<span class="token punctuation">:</span>
            <span class="token keyword">if</span> j <span class="token keyword">in</span> hashmap<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">and</span> hashmap<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">:</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>j<span class="token punctuation">)</span>
                hashmap<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>
        <span class="token keyword">return</span> result
</code></pre> 
<p>复杂度分析</p> 
<ul><li>时间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          m 
         
        
          + 
         
        
          n 
         
        
          ) 
         
        
       
         O(m+n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>，需要遍历两个数组并进行操作。</li><li>空间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          min 
         
        
          ⁡ 
         
        
          ( 
         
        
          m 
         
        
          , 
         
        
          n 
         
        
          ) 
         
        
          ) 
         
        
       
         O(\min(m,n)) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span>， 对较短的数组进行哈希表的操作(后续改进后)，哈希表的大小不会超过较短的数组的长度， 并且生成了储存结果的列表。</li></ul> 
<p>官方答案哈希表计数写法：</p> 
<pre><code class="prism language-python">m <span class="token operator">=</span> collections<span class="token punctuation">.</span>Counter<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> num <span class="token keyword">in</span> nums1<span class="token punctuation">:</span>
	m<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
</code></pre> 
<p>collections是Python内建的一个集合模块，提供了许多有用的集合类。以提供Python标准内建容器 dict , list , set , 和 tuple 的替代选择。</p> 
<p>一个 Counter 是一个 dict 的子类，用于计数可哈希对象。它是一个集合，元素像字典键(key)一样存储，它们的计数存储为值。计数可以是任何整数值，包括0和负数。</p> 
<p><img src="https://images2.imgbox.com/1f/77/ekjaGXMt_o.png" alt="在这里插入图片描述"><br> 所以使用这个Counter生成的对象可以使代码更简洁，提高一点速度。</p> 
<pre><code class="prism language-python">hashmap <span class="token operator">=</span> collections<span class="token punctuation">.</span>Counter<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> num <span class="token keyword">in</span> nums1<span class="token punctuation">:</span>
	hashmap<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
</code></pre> 
<p>并且判断时更方便：</p> 
<pre><code class="prism language-python"><span class="token keyword">for</span> j <span class="token keyword">in</span> nums2<span class="token punctuation">:</span>
	<span class="token keyword">if</span> hashmap<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
    	result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>j<span class="token punctuation">)</span>
        hashmap<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>
</code></pre> 
<p>再改进：<br> 针对数组1，数组2中较短的一个建立哈希表可以更节省空间，因此在开头加入对两个数组长度的判断。</p> 
<pre><code class="prism language-python"><span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums1<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">return</span> self<span class="token punctuation">.</span>intersect<span class="token punctuation">(</span>nums2<span class="token punctuation">,</span> nums1<span class="token punctuation">)</span>
</code></pre> 
<p>改进后代码：</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">intersect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums1<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>intersect<span class="token punctuation">(</span>nums2<span class="token punctuation">,</span> nums1<span class="token punctuation">)</span>
        hashmap <span class="token operator">=</span> collections<span class="token punctuation">.</span>Counter<span class="token punctuation">(</span><span class="token punctuation">)</span>
        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums1<span class="token punctuation">:</span>
            hashmap<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> nums2<span class="token punctuation">:</span>
            <span class="token keyword">if</span> hashmap<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>j<span class="token punctuation">)</span>
                hashmap<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>
        <span class="token keyword">return</span> result
</code></pre> 
<hr color="#000000" size='1"'> 
<h4><a id="2_132"></a>2.双指针法</h4> 
<ol><li> <p>对数组1，2先进行排序，从小到大排列，生成一个列表储存结果。</p> </li><li> <p>对于排序好的数组利用双指针进行比较。<br> 初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，将该数字添加到列表，并将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。</p> </li></ol> 
<p><font color="#999AAA">代码如下：</font></p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">intersect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        nums1 <span class="token operator">=</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>nums1<span class="token punctuation">)</span>
        nums2 <span class="token operator">=</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>nums2<span class="token punctuation">)</span>
        i <span class="token operator">=</span> <span class="token number">0</span>
        j <span class="token operator">=</span> <span class="token number">0</span>
        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        n1 <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums1<span class="token punctuation">)</span>
        n2 <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums2<span class="token punctuation">)</span>
        <span class="token keyword">while</span> i <span class="token operator">&lt;</span> n1 <span class="token operator">and</span> j <span class="token operator">&lt;</span> n2<span class="token punctuation">:</span>
            <span class="token keyword">if</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                i <span class="token operator">+=</span> <span class="token number">1</span>
                j <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">elif</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
                j <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                i <span class="token operator">+=</span> <span class="token number">1</span>
        
        <span class="token keyword">return</span> result 
</code></pre> 
<p>复杂度分析</p> 
<ul><li>时间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          m 
         
        
          log 
         
        
          ⁡ 
         
        
          m 
         
        
          + 
         
        
          n 
         
        
          log 
         
        
          ⁡ 
         
        
          n 
         
        
          ) 
         
        
       
         O(m\log m+n\log n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>，其中 m 和 n 分别是两个数组的长度。对两个数组进行排序的时间复杂度是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          m 
         
        
          log 
         
        
          ⁡ 
         
        
          m 
         
        
          + 
         
        
          n 
         
        
          log 
         
        
          ⁡ 
         
        
          n 
         
        
          ) 
         
        
       
         O(m \log m+n \log n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>，遍历两个数组的时间复杂度是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          m 
         
        
          + 
         
        
          n 
         
        
          ) 
         
        
       
         O(m+n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>，因此总时间复杂度是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          m 
         
        
          log 
         
        
          ⁡ 
         
        
          m 
         
        
          + 
         
        
          n 
         
        
          log 
         
        
          ⁡ 
         
        
          n 
         
        
          ) 
         
        
       
         O(m \log m+n \log n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>。</li><li>空间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          min 
         
        
          ⁡ 
         
        
          ( 
         
        
          m 
         
        
          , 
         
        
          n 
         
        
          ) 
         
        
          ) 
         
        
       
         O(\min(m,n)) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span>，储存交集的列表长度最大为两者中最小值。</li></ul> 
<hr color="#000000" size='1"'> 
<h2><a id="_171"></a>总结</h2> 
<p>对于进阶部分的问题：</p> 
<ul><li>当两个数组有序时，采取方法2可以省去排序时间，并与方法比较起来更节省空间。少一个哈希表的存储空间。</li><li>当内存有限，无法一次加载数组2时，就无法高效地对数组2进行排序，使用方法1更好，并且方法1的查询操作可以每次访问部分元素并处理即可。</li><li>同理，当两个数组大小相差过大时，使用改进后的方法1更节省时间。</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d7ebeb217e023c1ca18b81918a55ad73/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux将用户加入多个组,Linux 用命令把同一个用户加入多个组</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d2d656a85d3c58dd21ab35a90af990e3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">distribute by、group by、sort by、order by的相关释义</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>