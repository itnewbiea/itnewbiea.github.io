<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java回收算法学习 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java回收算法学习" />
<meta property="og:description" content="stop the word 暂停所有用户线程 判断垃圾对象 对象是否被引用 引用计数 可达性分析 原理 GC root对象向下搜索引用链,对象跟gcroot不存在引用链相连则作为垃圾对象 GCroot的范围 方法区中的静态变量，常量 本地方法引用的对象 java虚拟机栈的一些引用，如基本数据类型的class对象 同步锁的对象 反应虚拟机内部情况的对象 动态加入的GCROOT,如跨代引用的对象 引用 强引用 软引用 内存溢出时候回收，如果回收内存还不够，就会直接回收这些对象 弱引用 虚引用 虚拟机实现细节（加快垃圾收集，保证垃圾收集的正确） 根节点枚举 根节点枚举查找引用链是非常耗时的 在虚拟机加载运行过程中维护根节点枚举引用链集合oopmap,这样在回收的时候减少stop the world时间，也不需药每次都从方法区等根节点查找引用链 安全点 oopmap记录内容变化的特定位置 垃圾回收确定了引用关系，不会在回收完之后尽量少的又增加新增的垃圾数据， 抢断中断，主动中断 安全区域 被拉伸的安全点，理解为，在这个区域内OOPmap不会变化，程序不执行的时候，未给程序分配处理器时间 记忆集合 缩小gcroot的范围，非手机区域指向手机区域 不需要整个遍历老年代来确定引用链关系 记录跨代用用的内存块关系 特殊标识脏页，级存在快带引用的内存集合 写屏障 记忆集合变脏发生在赋值的那一刻 aop确立写屏障 伪共享 不采用无条件写屏障 当已经变脏就不去维护变化了 并发的可达性 缩短标记时间，并发的时候可以标记 三色：未被垃圾收集器方位，访问，且存在引用，访问，但还有被引用的的对象没进过垃圾收集器范文 回收算法 标记-清除 缺点：执行效率不稳定，当存在大量的数据对象时候，需要花费大量的时间进行标记跟清除 需要清除的对象内存地址并不是连续的物理内存地址，所以经过标记清楚算法之后，会产生大量的空间碎片，大量的空间碎片会导致后续在分配大对象时候，由于找不到连续的足够欧的内存来分配，而不得已进行fullgc CMS专属老年代算法 标记-复制 将存货的对象复制到内存的一边，然后直接清楚另外的内存 缺点;存在大量对象的时候，会复制大量的对象，所以适合亲声带 8：2，eden跟surrvivor，from to。 新生代算法，在标记复制期间都会暂停整个用户线程 有哪些算法 serwn new 穿行手机 praleel 收集器，并行 并行收集器 标记整理 将存活的对象整理到内存的一端，然后直接清楚另外一端的内存 有哪些算法 serwn old 穿行手机 rarallel old，并行 在整理过程中会暂停用户线程 stop the word 暂停所有用户线程 判断垃圾对象 对象是否被引用 引用计数 可达性分析 原理 GC root对象向下搜索引用链,对象跟gcroot不存在引用链相连则作为垃圾对象 GCroot的范围 方法区中的静态变量，常量 本地方法引用的对象 java虚拟机栈的一些引用，如基本数据类型的class对象 同步锁的对象 反应虚拟机内部情况的对象 动态加入的GCROOT,如跨代引用的对象 引用 强引用 软引用 内存溢出时候回收，如果回收内存还不够，就会直接回收这些对象 弱引用 虚引用 虚拟机实现细节（加快垃圾收集，保证垃圾收集的正确） 根节点枚举 根节点枚举查找引用链是非常耗时的 在虚拟机加载运行过程中维护根节点枚举引用链集合oopmap,这样在回收的时候减少stop the world时间，也不需药每次都从方法区等根节点查找引用链 安全点 oopmap记录内容变化的特定位置 垃圾回收确定了引用关系，不会在回收完之后尽量少的又增加新增的垃圾数据， 抢断中断，主动中断 安全区域 被拉伸的安全点，理解为，在这个区域内OOPmap不会变化，程序不执行的时候，未给程序分配处理器时间 记忆集合 缩小gcroot的范围，非手机区域指向手机区域 不需要整个遍历老年代来确定引用链关系 记录跨代用用的内存块关系 特殊标识脏页，级存在快带引用的内存集合 写屏障 记忆集合变脏发生在赋值的那一刻 aop确立写屏障 伪共享 不采用无条件写屏障 当已经变脏就不去维护变化了 并发的可达性 缩短标记时间，并发的时候可以标记 三色：未被垃圾收集器方位，访问，且存在引用，访问，但还有被引用的的对象没进过垃圾收集器范文 回收区域 minor GC（新生带) eden区不满 major Gc (老年代) 老年代不满 full GC(整个堆) system." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b38faaf80cee03248fcd32ec3da5767a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-04T15:06:28+08:00" />
<meta property="article:modified_time" content="2022-07-04T15:06:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java回收算法学习</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <pre><code>stop the word
	暂停所有用户线程
</code></pre> 
<pre><code>判断垃圾对象
	对象是否被引用
		引用计数
		可达性分析
			原理
				GC root对象向下搜索引用链,对象跟gcroot不存在引用链相连则作为垃圾对象
				GCroot的范围
					方法区中的静态变量，常量
					本地方法引用的对象
					java虚拟机栈的一些引用，如基本数据类型的class对象
					同步锁的对象
					反应虚拟机内部情况的对象
					动态加入的GCROOT,如跨代引用的对象
				引用
					强引用
					软引用
						内存溢出时候回收，如果回收内存还不够，就会直接回收这些对象
					弱引用
					虚引用
</code></pre> 
<pre><code>虚拟机实现细节（加快垃圾收集，保证垃圾收集的正确）
	根节点枚举
		根节点枚举查找引用链是非常耗时的
		在虚拟机加载运行过程中维护根节点枚举引用链集合oopmap,这样在回收的时候减少stop the world时间，也不需药每次都从方法区等根节点查找引用链
	安全点
		oopmap记录内容变化的特定位置
		垃圾回收确定了引用关系，不会在回收完之后尽量少的又增加新增的垃圾数据，
		抢断中断，主动中断
	安全区域
		被拉伸的安全点，理解为，在这个区域内OOPmap不会变化，程序不执行的时候，未给程序分配处理器时间
	记忆集合
		缩小gcroot的范围，非手机区域指向手机区域
		不需要整个遍历老年代来确定引用链关系
		记录跨代用用的内存块关系
		特殊标识脏页，级存在快带引用的内存集合
	写屏障
		记忆集合变脏发生在赋值的那一刻
		aop确立写屏障
		伪共享
			不采用无条件写屏障
				当已经变脏就不去维护变化了
	并发的可达性
		缩短标记时间，并发的时候可以标记
		三色：未被垃圾收集器方位，访问，且存在引用，访问，但还有被引用的的对象没进过垃圾收集器范文
</code></pre> 
<pre><code>回收算法
	标记-清除
		缺点：执行效率不稳定，当存在大量的数据对象时候，需要花费大量的时间进行标记跟清除
		需要清除的对象内存地址并不是连续的物理内存地址，所以经过标记清楚算法之后，会产生大量的空间碎片，大量的空间碎片会导致后续在分配大对象时候，由于找不到连续的足够欧的内存来分配，而不得已进行fullgc
		CMS专属老年代算法
	标记-复制
		将存货的对象复制到内存的一边，然后直接清楚另外的内存
		缺点;存在大量对象的时候，会复制大量的对象，所以适合亲声带
		8：2，eden跟surrvivor，from to。
		新生代算法，在标记复制期间都会暂停整个用户线程
		有哪些算法
			serwn new 穿行手机
			praleel 收集器，并行
			并行收集器
	标记整理
		将存活的对象整理到内存的一端，然后直接清楚另外一端的内存
		
			有哪些算法
				serwn old 穿行手机
				rarallel old，并行
		在整理过程中会暂停用户线程
	stop the word
		暂停所有用户线程
	判断垃圾对象
		对象是否被引用
			引用计数
			可达性分析
				原理
					GC root对象向下搜索引用链,对象跟gcroot不存在引用链相连则作为垃圾对象
					GCroot的范围
						方法区中的静态变量，常量
						本地方法引用的对象
						java虚拟机栈的一些引用，如基本数据类型的class对象
						同步锁的对象
						反应虚拟机内部情况的对象
						动态加入的GCROOT,如跨代引用的对象
					引用
						强引用
						软引用
							内存溢出时候回收，如果回收内存还不够，就会直接回收这些对象
						弱引用
						虚引用
	虚拟机实现细节（加快垃圾收集，保证垃圾收集的正确）
		根节点枚举
			根节点枚举查找引用链是非常耗时的
			在虚拟机加载运行过程中维护根节点枚举引用链集合oopmap,这样在回收的时候减少stop the world时间，也不需药每次都从方法区等根节点查找引用链
		安全点
			oopmap记录内容变化的特定位置
			垃圾回收确定了引用关系，不会在回收完之后尽量少的又增加新增的垃圾数据，
			抢断中断，主动中断
		安全区域
			被拉伸的安全点，理解为，在这个区域内OOPmap不会变化，程序不执行的时候，未给程序分配处理器时间
		记忆集合
			缩小gcroot的范围，非手机区域指向手机区域
			不需要整个遍历老年代来确定引用链关系
			记录跨代用用的内存块关系
			特殊标识脏页，级存在快带引用的内存集合
		写屏障
			记忆集合变脏发生在赋值的那一刻
			aop确立写屏障
			伪共享
				不采用无条件写屏障
					当已经变脏就不去维护变化了
		并发的可达性
			缩短标记时间，并发的时候可以标记
			三色：未被垃圾收集器方位，访问，且存在引用，访问，但还有被引用的的对象没进过垃圾收集器范文
	回收区域
		minor GC（新生带)
			eden区不满
		major Gc (老年代)
			老年代不满
		full GC(整个堆)
			system.gc
			大对象优先分配到老年代，如果不足，maoir gc，还是租fullgc
			新生代历次晋升的平均大小大于老年代的可用空间代销，fullgc(，空间分配担保为false)
				空间分配担保，如果是吐热《如果新生代的总内存，大于老年的连续可用内存，则fullgc
			方法区不足
	G1收集器
		java堆划分为连续多个大小相等的regoin
		根据每次回收region的大小以及时间维护统计信息
		根据用户设定的最大时间，通过统计信息分析，回收哪些regoin效益最大，时间成本最接近，
		过程
			初始标记
			鬓发标记
			重新标记
			筛选回收
</code></pre> 
<pre><code>回收区域
	minor GC（新生带)
		eden区不满
	major Gc (老年代)
		老年代不满
	full GC(整个堆)
		system.gc
		大对象优先分配到老年代，如果不足，maoir gc，还是租fullgc
		新生代历次晋升的平均大小大于老年代的可用空间代销，fullgc(，空间分配担保为false)
			空间分配担保，如果是吐热《如果新生代的总内存，大于老年的连续可用内存，则fullgc
		方法区不足
</code></pre> 
<pre><code>G1收集器
	java堆划分为连续多个大小相等的regoin
	根据每次回收region的大小以及时间维护统计信息
	根据用户设定的最大时间，通过统计信息分析，回收哪些regoin效益最大，时间成本最接近，
	过程
		初始标记
		鬓发标记
		重新标记
		筛选回收
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0057daeba757334e364452df8130268c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">机器学习分类问题指标评估内容详解（准确率、精准率、召回率、F1、ROC、AUC等）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/687fed8bf019eaeca54c38c7a6a13673/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">生成二维码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>