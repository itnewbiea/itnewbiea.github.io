<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>高级前端理解的CommonJS模块和ESM模块 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="高级前端理解的CommonJS模块和ESM模块" />
<meta property="og:description" content="阮一峰在 ES6 入门 中提到 ES6 模块与 CommonJS 模块有一些重大的差异：
CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
大厂技术 高级前端 Node进阶 点击上方 程序员成长指北，关注公众号 回复1，加入高级Node交流群 再细读上面阮老师提到的差异，会产生诸多疑问：
为什么 CommonJS 模块输出的是一个值的拷贝？其具体细节是什么样子的？
什么叫 运行时加载?
什么叫 编译时输出接口？
为什么 ES6 模块输出的是值的引用？
于是就有了这篇文章，力求把 ESM 模块 和 CommonJS 模块 讨论清楚。
CommonJS 产生的历史背景 CommonJS 由 Mozilla 工程师 Kevin Dangoor 于 2009 年 1 月创立，最初命名为ServerJS。2009 年 8 月，该项目更名为CommonJS。旨在解决 Javascript 中缺少模块化标准的问题。
Node.js 后来也采用了 CommonJS 的模块规范。
由于 CommonJS 并不是 ECMAScript 标准的一部分，所以 类似 module 和 require 并不是 JS 的关键字，仅仅是对象或者函数而已，意识到这一点很重要。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/df3ad383ba38540d415b935330c04a23/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-18T08:47:48+08:00" />
<meta property="article:modified_time" content="2023-04-18T08:47:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">高级前端理解的CommonJS模块和ESM模块</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p>阮一峰在 ES6 入门 中提到 ES6 模块与 CommonJS 模块有一些重大的差异：</p> 
 <ul><li><p>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</p></li><li><p>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</p></li></ul> 
 <pre class="has"><code class="language-go">大厂技术  高级前端  Node进阶
点击上方 程序员成长指北，关注公众号
回复1，加入高级Node交流群</code></pre> 
 <p>再细读上面阮老师提到的差异，会产生诸多疑问：</p> 
 <ul><li><p>为什么 CommonJS 模块输出的是一个值的拷贝？其具体细节是什么样子的？</p></li><li><p>什么叫 <code>运行时加载</code>?</p></li><li><p>什么叫 <code>编译时输出接口</code>？</p></li><li><p>为什么 ES6 模块输出的是值的引用？</p></li></ul> 
 <p>于是就有了这篇文章，力求把 <strong>ESM 模块</strong> 和 <strong>CommonJS 模块</strong> 讨论清楚。</p> 
 <h4>CommonJS 产生的历史背景</h4> 
 <p>CommonJS 由 Mozilla 工程师 Kevin Dangoor 于 2009 年 1 月创立，最初命名为ServerJS。2009 年 8 月，该项目更名为CommonJS。旨在解决 Javascript 中缺少模块化标准的问题。</p> 
 <p>Node.js 后来也采用了 CommonJS 的模块规范。</p> 
 <p>由于 CommonJS 并不是 ECMAScript 标准的一部分，所以 <strong>类似 <code>module</code> 和 <code>require</code> 并不是 JS 的关键字，仅仅是对象或者函数而已</strong>，意识到这一点很重要。</p> 
 <p>我们可以在打印 <code>module</code>、<code>require</code> 查看细节：</p> 
 <pre class="has"><code class="language-go">console.log(module);
console.log(require);

// out:
Module {
  id: '.',
  path: '/Users/xxx/Desktop/esm_commonjs/commonJS',
  exports: {},
  filename: '/Users/xxx/Desktop/esm_commonjs/commonJS/c.js',
  loaded: false,
  children: [],
  paths: [
    '/Users/xxx/Desktop/esm_commonjs/commonJS/node_modules',
    '/Users/xxx/Desktop/esm_commonjs/node_modules',
    '/Users/xxx/Desktop/node_modules',
    '/Users/xxx/node_modules',
    '/Users/node_modules',
    '/node_modules'
  ]
}

[Function: require] {
  resolve: [Function: resolve] { paths: [Function: paths] },
  main: Module {
    id: '.',
    path: '/Users/xxx/Desktop/esm_commonjs/commonJS',
    exports: {},
    filename: '/Users/xxx/Desktop/esm_commonjs/commonJS/c.js',
    loaded: false,
    children: [],
    paths: [
      '/Users/xxx/Desktop/esm_commonjs/commonJS/node_modules',
      '/Users/xxx/Desktop/esm_commonjs/node_modules',
      '/Users/xxx/Desktop/node_modules',
      '/Users/xxx/node_modules',
      '/Users/node_modules',
      '/node_modules'
    ]
  },
  extensions: [Object: null prototype] {
    '.js': [Function (anonymous)],
    '.json': [Function (anonymous)],
    '.node': [Function (anonymous)]
  },
  cache: [Object: null prototype] {
    '/Users/xxx/Desktop/esm_commonjs/commonJS/c.js': Module {
      id: '.',
      path: '/Users/xxx/Desktop/esm_commonjs/commonJS',
      exports: {},
      filename: '/Users/xxx/Desktop/esm_commonjs/commonJS/c.js',
      loaded: false,
      children: [],
      paths: [Array]
    }
  }
}</code></pre> 
 <p>可以看到 <code>module</code> 是一个对象， <code>require</code> 是一个函数，仅此而已。</p> 
 <p>我们来重点介绍下 <code>module</code> 中的一些属性：</p> 
 <ul><li><p><code>exports</code>：这就是 <code>module.exports</code> 对应的值，由于还没有赋任何值给它，它目前是一个空对象。</p></li><li><p><code>loaded</code>：表示当前的模块是否加载完成。</p></li><li><p><code>paths</code>：node 模块的加载路径，这块不展开讲，感兴趣可以看node 文档</p></li></ul> 
 <p><code>require</code> 函数中也有一些值得注意的属性：</p> 
 <ul><li><p><code>main</code> 指向当前当前引用自己的模块，所以类似 python 的 <code>__name__ == '__main__'</code>, node 也可以用 <code>require.main === module</code> 来确定是否是以当前模块来启动程序的。</p></li><li><p><code>extensions</code> 表示目前 node 支持的几种加载模块的方式。</p></li><li><p><code>cache</code> 表示 node 中模块加载的缓存，也就是说，当一个模块加载一次后，之后 <code>require</code> 不会再加载一次，而是从缓存中读取。</p></li></ul> 
 <p>前面提到，CommonJS 中 <code>module</code> 是一个对象， <code>require</code> 是一个函数。而与此相对应的 <strong>ESM 中的 <code>import</code> 和 <code>export</code> 则是关键字，是 ECMAScript 标准的一部分</strong>。理解这两者的区别非常关键。</p> 
 <h4>先看几个 CommonJS 例子</h4> 
 <p>大家看看下面几个 CommonJS 例子，看看能不能准确预测结果：</p> 
 <p>例一，在模块外为简单类型赋值：</p> 
 <pre class="has"><code class="language-go">// a.js
let val = 1;

const setVal = (newVal) =&gt; {
  val = newVal
}

module.exports = {
  val,
  setVal
}

// b.js
const { val, setVal } = require('./a.js')

console.log(val);

setVal(101);

console.log(val);</code></pre> 
 <p>运行 <code>b.js</code>，输出结果为：</p> 
 <pre class="has"><code class="language-go">1
1</code></pre> 
 <p>例二，在模块外为引用类型赋值：</p> 
 <pre class="has"><code class="language-go">// a.js
let obj = {
  val: 1
};

const setVal = (newVal) =&gt; {
  obj.val = newVal
}

module.exports = {
  obj,
  setVal
}

// b.js
const { obj, setVal } = require('./a.js')

console.log(obj);

setVal(101);

console.log(obj);</code></pre> 
 <p>运行 <code>b.js</code>，输出结果为：</p> 
 <pre class="has"><code class="language-go">{ val: 1 }
{ val: 101 }</code></pre> 
 <p>例三，在模块内导出后改变简单类型：</p> 
 <pre class="has"><code class="language-go">// a.js
let val = 1;

setTimeout(() =&gt; {
  val = 101;
}, 100)

module.exports = {
  val
}

// b.js
const { val } = require('./a.js')

console.log(val);

setTimeout(() =&gt; {
  console.log(val);
}, 200)</code></pre> 
 <p>运行 <code>b.js</code>，输出结果为：</p> 
 <pre class="has"><code class="language-go">1
1</code></pre> 
 <p>例四，在模块内导出后用 <code>module.exports</code> 再导出一次：</p> 
 <pre class="has"><code class="language-go">// a.js
setTimeout(() =&gt; {
  module.exports = {
    val: 101
  }
}, 100)

module.exports = {
  val: 1
}

// b.js
const a = require('./a.js')

console.log(a);

setTimeout(() =&gt; {
  console.log(a);
}, 200)</code></pre> 
 <p>运行 <code>b.js</code>，输出结果为：</p> 
 <pre class="has"><code class="language-go">{ val: 1 }
{ val: 1 }</code></pre> 
 <p>例五，在模块内导出后用 <code>exports</code> 再导出一次：</p> 
 <pre class="has"><code class="language-go">// a.js
setTimeout(() =&gt; {
  module.exports.val = 101;
}, 100)

module.exports.val = 1

// b.js
const a = require('./a.js')

console.log(a);

setTimeout(() =&gt; {
  console.log(a);
}, 200)</code></pre> 
 <p>运行 <code>b.js</code>,输出结果为：</p> 
 <pre class="has"><code class="language-go">{ val: 1 }
{ val: 101 }</code></pre> 
 <h4>如何解释上面的例子？没有魔法！一言道破 CommonJS 值拷贝的细节</h4> 
 <p>拿出 JS 最朴素的思维，来分析上面例子的种种现象。</p> 
 <p>例一中，代码可以简化为：</p> 
 <pre class="has"><code class="language-go">const myModule = {
  exports: {}
}

let val = 1;

const setVal = (newVal) =&gt; {
  val = newVal
}

myModule.exports = {
  val,
  setVal
}

const { val: useVal, setVal: useSetVal } = myModule.exports

console.log(useVal);

useSetVal(101)

console.log(useVal);</code></pre> 
 <p>例二中，代码可以简化为：</p> 
 <pre class="has"><code class="language-go">const myModule = {
  exports: {}
}

let obj = {
  val: 1
};

const setVal = (newVal) =&gt; {
  obj.val = newVal
}

myModule.exports = {
  obj,
  setVal
}

const { obj: useObj, setVal: useSetVal } = myModule.exports

console.log(useObj);

useSetVal(101)

console.log(useObj);</code></pre> 
 <p>例三中，代码可以简化为：</p> 
 <pre class="has"><code class="language-go">const myModule = {
  exports: {}
}

let val = 1;

setTimeout(() =&gt; {
  val = 101;
}, 100)

myModule.exports = {
  val
}

const { val: useVal } = myModule.exports

console.log(useVal);

setTimeout(() =&gt; {
  console.log(useVal);
}, 200)</code></pre> 
 <p>例四中，代码可以简化为：</p> 
 <pre class="has"><code class="language-go">const myModule = {
  exports: {}
}

setTimeout(() =&gt; {
  myModule.exports = {
    val: 101
  }
}, 100)


myModule.exports = {
  val: 1
}

const useA = myModule.exports

console.log(useA);

setTimeout(() =&gt; {
  console.log(useA);
}, 200)</code></pre> 
 <p>例五中，代码可以简化为：</p> 
 <pre class="has"><code class="language-go">const myModule = {
  exports: {}
}

setTimeout(() =&gt; {
  myModule.exports.val = 101;
}, 100)

myModule.exports.val = 1;

const useA = myModule.exports

console.log(useA);

setTimeout(() =&gt; {
  console.log(useA);
}, 200)</code></pre> 
 <p>尝试运行上面的代码，可以发现和 CommonJS 输出的效果一致。所以 CommonJS 不是什么魔法，仅仅是日常写的最简简单单的 JS 代码。</p> 
 <p>其值拷贝发生在给 <code>module.exports</code> 赋值的那一刻，例如：</p> 
 <pre class="has"><code class="language-go">let val = 1;
module.exports = {
  val
}</code></pre> 
 <p>做的事情仅仅是给 <code>module.exports</code> 赋予了一个新的对象，在这个对象里有一个key叫做 <code>val</code>，这个 <code>val</code> 的值是当前模块中 <code>val</code> 的值，仅此而已。</p> 
 <h4>CommonJS 的具体实现</h4> 
 <p>为了更透彻的了解 CommonJS，我们来写一个简单的模块加载器，主要参考了 nodejs 源码；</p> 
 <p>在 node v16.x 中 module 主要实现在 <code>lib/internal/modules/cjs/loader.js</code> 文件下。</p> 
 <p>在 node v4.x 中 module 主要实现在 <code>lib/module.js</code> 文件下。</p> 
 <p>下面的实现主要参考了 node v4.x 中的实现，因为老版本相对更“干净”一些，更容易抓住细节。</p> 
 <p>另外 深入Node.js的模块加载机制，手写require函数 这篇文章写的也很不错，下面的实现很多也参考了这篇文章。</p> 
 <p>为了跟官方Module名字区分开，我们自己的类命名为MyModule：</p> 
 <pre class="has"><code class="language-go">function MyModule(id = '') {
  this.id = id;             // 模块路径
  this.exports = {};        // 导出的东西放这里，初始化为空对象
  this.loaded = false;      // 用来标识当前模块是否已经加载
}</code></pre> 
 <h5>require方法</h5> 
 <p>我们一直用的 <code>require</code> 其实是 Module 类的一个实例方法，内容很简单，先做一些参数检查，然后调用 Module._load 方法，源码在这里，本示例为了简洁，去掉了一些判断：</p> 
 <pre class="has"><code class="language-go">MyModule.prototype.require = function (id) {
  return MyModule._load(id);
}</code></pre> 
 <p><code>require</code> 是一个很简单函数，主要是包装了 <code>_load</code> 函数，这个函数主要做了如下事情：</p> 
 <ul><li><p>先检查请求的模块在缓存中是否已经存在了，如果存在了直接返回缓存模块的 <code>exports</code></p></li><li><p>如果不在缓存中，就创建一个 <code>Module</code> 实例，将该实例放到缓存中，用这个实例加载对应的模块，并返回模块的 <code>exports</code></p></li></ul> 
 <pre class="has"><code class="language-go">MyModule._load = function (request) {    // request是传入的路径
  const filename = MyModule._resolveFilename(request);

  // 先检查缓存，如果缓存存在且已经加载，直接返回缓存
  const cachedModule = MyModule._cache[filename];
  if (cachedModule) {
    return cachedModule.exports;
  }

  // 如果缓存不存在，我们就加载这个模块
  const module = new MyModule(filename);

  // load之前就将这个模块缓存下来，这样如果有循环引用就会拿到这个缓存，但是这个缓存里面的exports可能还没有或者不完整
  MyModule._cache[filename] = module;

  // 如果 load 失败，需要将 _cache 中相应的缓存删掉。这里简单起见，不做这个处理
  module.load(filename);

  return module.exports;
}</code></pre> 
 <p>可以看到上述源码还调用了两个方法：<code>MyModule._resolveFilename</code> 和 <code>MyModule.prototype.load</code>，下面我们来实现下这两个方法。</p> 
 <h5>MyModule._resolveFilename</h5> 
 <p>这个函数的作用是通过用户传入的 require 参数来解析到真正的文件地址，源码中这个方法比较复杂，因为他要支持多种参数：内置模块，相对路径，绝对路径，文件夹和第三方模块等等。</p> 
 <p>本示例为了简洁，只实现相对文件的导入：</p> 
 <pre class="has"><code class="language-go">MyModule._resolveFilename = function (request) {
  return path.resolve(request);
}</code></pre> 
 <h5>MyModule.prototype.load</h5> 
 <p><code>MyModule.prototype.load</code> 是一个实例方法，源代码在这里，这个方法就是真正用来加载模块的方法，这其实也是不同类型文件加载的一个入口，不同类型的文件会对应 <code>MyModule._extensions</code> 里面的一个方法：</p> 
 <pre class="has"><code class="language-go">MyModule.prototype.load = function (filename) {
  // 获取文件后缀名
  const extname = path.extname(filename);

  // 调用后缀名对应的处理函数来处理，当前实现只支持 JS
  MyModule._extensions[extname](this, filename);

  this.loaded = true;
}</code></pre> 
 <h5>加载文件: MyModule._extensions['X']</h5> 
 <p>前面提到不同文件类型的处理方法都挂载在 <code>MyModule._extensions</code> 上，事实上 <code>node</code> 的加载器不仅仅可以加载 <code>.js</code> 模块，也可以加载 <code>.json</code> 和 <code>.node</code> 模块。本示例简单起见仅实现 <code>.js</code> 类型文件的加载：</p> 
 <pre class="has"><code class="language-go">MyModule._extensions['.js'] = function (module, filename) {
  const content = fs.readFileSync(filename, 'utf8');
  module._compile(content, filename);
}</code></pre> 
 <p>可以看到js的加载方法很简单，只是把文件内容读出来，然后调了另外一个实例方法 <code>_compile</code> 来执行他。对应的源码在这里。</p> 
 <h5>_compile 实现</h5> 
 <p><code>MyModule.prototype._compile</code> 是加载JS文件的核心所在，这个方法需要将目标文件拿出来执行一遍。对应的源码在这里。</p> 
 <p><code>_compile</code> 主要做了如下事情：</p> 
 <p>1、执行之前需要将它整个代码包裹一层，以便注入 <code>exports</code>, <code>require</code>, <code>module</code>, <code>__dirname</code>, <code>__filename</code>，这也是我们能在JS文件里面直接使用这几个变量的原因。要实现这种注入也不难，假如我们 require 的文件是一个简单的 <code>Hello World</code>，长这样：</p> 
 <pre class="has"><code class="language-go">module.exports = "hello world";</code></pre> 
 <p>那我们怎么来给他注入 <code>module</code> 这个变量呢？答案是执行的时候在他外面再加一层函数，使他变成这样：</p> 
 <pre class="has"><code class="language-go">function (module) { // 注入module变量，其实几个变量同理
  module.exports = "hello world";
}</code></pre> 
 <p>nodeJS 也是这样实现的，在node源码里，会有这样的代码：</p> 
 <pre class="has"><code class="language-go">NativeModule.wrap = function(script) {
  return NativeModule.wrapper[0] + script + NativeModule.wrapper[1];
};

NativeModule.wrapper = [
  '(function (exports, require, module, __filename, __dirname) { ',
  '\n});'
];</code></pre> 
 <p>这样通过MyModule.wrap包装的代码就可以获取到 <code>exports</code>, <code>require</code>, <code>module</code>, <code>__filename</code>, <code>__dirname</code> 这几个变量了。</p> 
 <p>2、放入沙盒里执行包装好的代码，并返回模块的 export。沙盒执行使用了 node 的 <code>vm</code> 模块。</p> 
 <p>在本实现中，<code>_compile</code> 实现如下：</p> 
 <pre class="has"><code class="language-go">MyModule.prototype._compile = function (content, filename) {
  var self = this;
  // 获取包装后函数体
  const wrapper = MyModule.wrap(content);

  // vm是nodejs的虚拟机沙盒模块，runInThisContext方法可以接受一个字符串并将它转化为一个函数
  // 返回值就是转化后的函数，所以compiledWrapper是一个函数
  const compiledWrapper = vm.runInThisContext(wrapper, {
    filename
  });
  const dirname = path.dirname(filename);

  const args = [self.exports, self.require, self, filename, dirname];
  return compiledWrapper.apply(self.exports, args);
}</code></pre> 
 <p><code>wrapper</code> 和 <code>warp</code> 的实现如下：</p> 
 <pre class="has"><code class="language-go">MyModule.wrapper = [
  '(function (myExports, myRequire, myModule, __filename, __dirname) { ',
  '\n});'
];

MyModule.wrap = function (script) {
  return MyModule.wrapper[0] + script + MyModule.wrapper[1];
};</code></pre> 
 <blockquote> 
  <p>注意上面的 <code>wrapper</code> 中我们使用了 <code>myRequire</code> 和 <code>myModule</code> 来区分原生的 <code>require</code> 和 <code>module</code>, 下面的例子中我们会使用自己实现的函数来加载文件。</p> 
 </blockquote> 
 <h5>最后生成一个实例并导出</h5> 
 <p>最后我们 new 一个 <code>MyModule</code> 的实理并导出，方便外面使用：</p> 
 <pre class="has"><code class="language-go">const myModuleInstance = new MyModule();
const MyRequire = (id) =&gt; {
  return myModuleInstance.require(id);
}

module.exports = {
  MyModule,
  MyRequire
}</code></pre> 
 <h5>完整代码</h5> 
 <p>最后的完整代码如下：</p> 
 <pre class="has"><code class="language-go">const path = require('path');
const vm = require('vm');
const fs = require('fs');

function MyModule(id = '') {
  this.id = id;             // 模块路径
  this.exports = {};        // 导出的东西放这里，初始化为空对象
  this.loaded = false;      // 用来标识当前模块是否已经加载
}

MyModule._cache = {};
MyModule._extensions = {};

MyModule.wrapper = [
  '(function (myExports, myRequire, myModule, __filename, __dirname) { ',
  '\n});'
];

MyModule.wrap = function (script) {
  return MyModule.wrapper[0] + script + MyModule.wrapper[1];
};

MyModule.prototype.require = function (id) {
  return MyModule._load(id);
}

MyModule._load = function (request) {    // request是传入的路径
  const filename = MyModule._resolveFilename(request);

  // 先检查缓存，如果缓存存在且已经加载，直接返回缓存
  const cachedModule = MyModule._cache[filename];
  if (cachedModule) {
    return cachedModule.exports;
  }

  // 如果缓存不存在，我们就加载这个模块
  // 加载前先new一个MyModule实例，然后调用实例方法load来加载
  // 加载完成直接返回module.exports
  const module = new MyModule(filename);

  // load之前就将这个模块缓存下来，这样如果有循环引用就会拿到这个缓存，但是这个缓存里面的exports可能还没有或者不完整
  MyModule._cache[filename] = module;

  // 如果 load 失败，需要将 _cache 中相应的缓存删掉。这里简单起见，不做这个处理
  module.load(filename);

  return module.exports;
}

MyModule._resolveFilename = function (request) {
  return path.resolve(request);
}

MyModule.prototype.load = function (filename) {
  // 获取文件后缀名
  const extname = path.extname(filename);

  // 调用后缀名对应的处理函数来处理，当前实现只支持 JS
  MyModule._extensions[extname](this, filename);

  this.loaded = true;
}


MyModule._extensions['.js'] = function (module, filename) {
  var content = fs.readFileSync(filename, 'utf8');
  module._compile(content, filename);
};

MyModule.prototype._compile = function (content, filename) {
  var self = this;
  // 获取包装后函数体
  const wrapper = MyModule.wrap(content);    

  // vm是nodejs的虚拟机沙盒模块，runInThisContext方法可以接受一个字符串并将它转化为一个函数
  // 返回值就是转化后的函数，所以compiledWrapper是一个函数
  const compiledWrapper = vm.runInThisContext(wrapper, {
    filename
  });
  const dirname = path.dirname(filename);

  const args = [self.exports, self.require, self, filename, dirname];
  return compiledWrapper.apply(self.exports, args);
}

const myModuleInstance = new MyModule();
const MyRequire = (id) =&gt; {
  return myModuleInstance.require(id);
}

module.exports = {
  MyModule,
  MyRequire
}</code></pre> 
 <h5>题外话：源代码中的 require 是如何实现的?</h5> 
 <p>细心的读者会发现： nodejs v4.x 源码中实现 <code>require</code> 的文件 <code>lib/module.js</code> 中，也使用到了 <code>require</code> 函数。</p> 
 <p>这似乎产生是先有鸡还是先有蛋的悖论，我还没把你造出来，你怎么就用起来了？</p> 
 <p>事实上，源码中的 <code>require</code> 有另外简单的实现，它被定义在 <code>src/node.js</code> 中，源码在这里。</p> 
 <h4>用自定义的 MyModule 来加载文件</h4> 
 <p>刚刚我们实现了一个简单的 Module，但是能不能正常用还存疑。是骡子是马拉出来遛遛，我们用自己的 <code>MyModule</code> 来加载文件，看看能不能正常运行。</p> 
 <p>可以查看 <code>demos/01</code>，代码的入口为 <code>app.js</code>:</p> 
 <pre class="has"><code class="language-go">const { MyRequire } = require('./myModule.js');

MyRequire('./b.js');</code></pre> 
 <p><code>b.js</code> 的代码如下：</p> 
 <pre class="has"><code class="language-go">const { obj, setVal } = myRequire('./a.js')

console.log(obj);

setVal(101);

console.log(obj);</code></pre> 
 <p>可以看到现在我们用 <code>myRequire</code> 取代 <code>require</code> 来加载 <code>./a.js</code> 模块。</p> 
 <p>再看看 <code>./a.js</code> 的代码：</p> 
 <pre class="has"><code class="language-go">let obj = {
  val: 1
};

const setVal = (newVal) =&gt; {
  obj.val = newVal
}

myModule.exports = {
  obj,
  setVal
}</code></pre> 
 <p>可以看到现在我们用 <code>myModule</code> 取代 <code>module</code> 来导出模块。</p> 
 <p>最后执行 <code>node app.js</code> 查看运行结果：</p> 
 <pre class="has"><code class="language-go">{ val: 1 }
{ val: 101 }</code></pre> 
 <p>可以看到最终效果和使用原生的 module 模块一致。</p> 
 <h4>用自定义的 MyModule 来测试循环引用</h4> 
 <p>在这之前，我们先看看原生的 module 模块的循环引用会发生什么异常。可以查看 <code>demos/02</code>，代码的入口为 <code>app.js</code>：</p> 
 <pre class="has"><code class="language-go">require('./a.js')</code></pre> 
 <p>看看 <code>./a.js</code> 的代码：</p> 
 <pre class="has"><code class="language-go">const { b, setB } = require('./b.js');

console.log('running a.js');

console.log('b val', b);

console.log('setB to bb');

setB('bb')

let a = 'a';

const setA = (newA) =&gt; {
  a = newA;
}

module.exports = {
  a,
  setA
}</code></pre> 
 <p>再看看 <code>./b.js</code> 的代码：</p> 
 <pre class="has"><code class="language-go">const { a, setA } = require('./a.js');

console.log('running b.js');

console.log('a val', a);

console.log('setA to aa');

setA('aa')

let b = 'b';

const setB = (newB) =&gt; {
  b = newB;
}

module.exports = {
  b,
  setB
}</code></pre> 
 <p>可以看到 <code>./a.js</code> 和 <code>./b.js</code> 在文件的开头都相互引用了对方。</p> 
 <p>执行 <code>node app.js</code> 查看运行结果：</p> 
 <pre class="has"><code class="language-go">running b.js
a val undefined
setA to aa
/Users/xxx/Desktop/esm_commonjs/demos/02/b.js:9
setA('aa')
^

TypeError: setA is not a function
    at Object.&lt;anonymous&gt; (/Users/xxx/Desktop/esm_commonjs/demos/02/b.js:9:1)
    at xxx</code></pre> 
 <p>我们会发现一个 TypeError 的异常报错，提示 <code>setA is not a function</code>。这样的异常在预期之内，我们再试试自己实现的 <code>myModule</code> 的异常是否和原生 <code>module</code> 的行为一致。</p> 
 <p>我们查看 <code>demos/03</code>，这里我们用自己的 <code>myModule</code> 来复现上面的循环引用，代码的入口为 <code>app.js</code>：</p> 
 <pre class="has"><code class="language-go">const { MyRequire } = require('./myModule.js');

MyRequire('./a.js');</code></pre> 
 <p><code>a.js</code> 的代码如下：</p> 
 <pre class="has"><code class="language-go">const { b, setB } = myRequire('./b.js');

console.log('running a.js');

console.log('b val', b);

console.log('setB to bb');

setB('bb')

let a = 'a';

const setA = (newA) =&gt; {
  a = newA;
}

myModule.exports = {
  a,
  setA
}</code></pre> 
 <p>再看看 <code>./b.js</code> 的代码：</p> 
 <pre class="has"><code class="language-go">const { a, setA } = myRequire('./a.js');

console.log('running b.js');

console.log('a val', a);

console.log('setA to aa');

setA('aa')

let b = 'b';

const setB = (newB) =&gt; {
  b = newB;
}

myModule.exports = {
  b,
  setB
}</code></pre> 
 <p>可以看到现在我们用 <code>myRequire</code> 取代了 <code>require</code>，用 <code>myModule</code> 取代了 <code>module</code>。</p> 
 <p>最后执行 <code>node app.js</code> 查看运行结果：</p> 
 <pre class="has"><code class="language-go">running b.js
a val undefined
setA to aa
/Users/xxx/Desktop/esm_commonjs/demos/03/b.js:9
setA('aa')
^

TypeError: setA is not a function
    at Object.&lt;anonymous&gt; (/Users/xxx/Desktop/esm_commonjs/demos/03/b.js:9:1)
    at xxx</code></pre> 
 <p>可以看到，<code>myModule</code> 的行为和原生 <code>Module</code> 处理循环引用的异常是一致的。</p> 
 <h5>疑问：为什么 CommonJS 相互引用没有产生类似“死锁”的问题？</h5> 
 <p>我们可以发现 CommonJS 模块相互引用时，没有产生类似死锁的问题。关键在 <code>Module._load</code> 函数里，具体源代码在这里。<code>Module._load</code> 函数主要做了下面这些事情：</p> 
 <ol><li><p>检查缓存，如果缓存存在且已经加载，直接返回缓存，不做下面的处理</p></li><li><p>如果缓存不存在，新建一个 Module 实例</p></li><li><p>将这个 Module 实例放到缓存中</p></li><li><p>通过这个 Module 实例来加载文件</p></li><li><p>返回这个 Module 实例的 exports</p></li></ol> 
 <p>其中的关键在 <strong>放到缓存中</strong> 与 <strong>加载文件</strong> 的顺序，在我们的 <code>MyModule</code> 中，也就是这两行代码：</p> 
 <pre class="has"><code class="language-go">MyModule._cache[filename] = module;
module.load(filename);</code></pre> 
 <p>回到上面循环加载的例子中，解释一下到底发生了什么：</p> 
 <p>当 <code>app.js</code> 加载 <code>a.js</code> 时，Module 会检查缓存中有没有 <code>a.js</code>，发现没有，于是 new 一个 <code>a.js</code> 模块，并将这个模块放到缓存中，再去加载 <code>a.js</code> 文件本身。</p> 
 <p>在加载 <code>a.js</code> 文件时，Module 发现第一行是加载 <code>b.js</code>，它会检查缓存中有没有 <code>b.js</code>，发现没有，于是 new 一个 <code>b.js</code> 模块，并将这个模块放到缓存中，再去加载 <code>b.js</code> 文件本身。</p> 
 <p>在加载 <code>b.js</code> 文件时，Module 发现第一行是加载 <code>a.js</code>，它会检查缓存中有没有 <code>a.js</code>，发现存在，于是 <code>require</code> 函数返回了缓存中的 <code>a.js</code>。</p> 
 <p>但是其实这个时候 <code>a.js</code> 根本还没有执行完，还没走到 <code>module.exports</code> 那一步，所以 <code>b.js</code> 中 <code>require('./a.js')</code> 返回的只是一个默认的空对象。所以最终会报 <code>setA is not a function</code> 的异常。</p> 
 <p>说到这里，那如何设计会导致“死锁”呢？其实也很简单 —— 将 <strong>放到缓存中</strong> 与 <strong>加载文件</strong> 的执行顺序互换，在我们的 <code>MyModule</code> 代码中，也就是这样写：</p> 
 <pre class="has"><code class="language-go">module.load(filename);
MyModule._cache[filename] = module;</code></pre> 
 <p>这样互换一下，再执行 demo03，我们发现异常如下：</p> 
 <pre class="has"><code class="language-go">RangeError: Maximum call stack size exceeded
    at console.value (node:internal/console/constructor:290:13)
    at console.log (node:internal/console/constructor:360:26)</code></pre> 
 <p>我们发现这样写会死锁，最终导致 JS 报栈溢出异常。</p> 
 <h4>JavaScript 的执行过程</h4> 
 <p>接下来我们要讲解 ESM 的模块导入，为了方便理解 ESM 的模块导入，这里需要补充一个知识点 —— <strong>JavaScript 的执行过程</strong>。</p> 
 <p>JavaScript 执行过程分为两个阶段:</p> 
 <ul><li><p>编译阶段</p></li><li><p>执行阶段</p></li></ul> 
 <h5>编译阶段</h5> 
 <p>在编译阶段 JS 引擎主要做了三件事：</p> 
 <ul><li><p>词法分析</p></li><li><p>语法分析</p></li><li><p>字节码生成</p></li></ul> 
 <p>这里不详情讲这三件事的具体细节，感兴趣的读者可以阅读 the-super-tiny-compiler 这个仓库，它通过几百行的代码实现了一个微形编译器，并详细讲了这三个过程的具体细节。</p> 
 <h5>执行阶段</h5> 
 <p>在执行阶段，会分情况创建各种类型的执行上下文，例如：<strong>全局执行上下文</strong> (只有一个)、<strong>函数执行上下文</strong>。而执行上下文的创建分为两个阶段：</p> 
 <ul><li><p>创建阶段</p></li><li><p>执行阶段</p></li></ul> 
 <p>在创建阶段会做如下事情：</p> 
 <ul><li><p>绑定 this</p></li><li><p>为函数和变量分配内存空间</p></li><li><p>初始化相关变量为 undefined</p></li></ul> 
 <p>我们日常提到的 变量提升 和 函数提升 就是在 <strong>创建阶段</strong> 做的，所以下面的写法并不会报错：</p> 
 <pre class="has"><code class="language-go">console.log(msg);
add(1,2)

var msg = 'hello'
function add(a,b){
  return a + b;
}</code></pre> 
 <p>因为在执行之前的创建阶段，已经分配好了 <code>msg</code> 和 <code>add</code> 的内存空间。</p> 
 <h4>JavaScript 的常见报错类型</h4> 
 <p>为了更容易理解 ESM 的模块导入，这里再补充一个知识点 —— <strong>JavaScript 的常见报错类型</strong>。</p> 
 <h5>1、RangeError</h5> 
 <p>这类错误很常见，例如栈溢出就是 <code>RangeError</code>；</p> 
 <pre class="has"><code class="language-go">function a () {
  b()
}
function b () {
  a()
}
a()

// out: 
// RangeError: Maximum call stack size exceeded</code></pre> 
 <h5>2、ReferenceError</h5> 
 <p><code>ReferenceError</code> 也很常见，打印一个不存在的值就是 <code>ReferenceError</code>：</p> 
 <pre class="has"><code class="language-go">hello

// out: 
// ReferenceError: hello is not defined</code></pre> 
 <h5>3、SyntaxError</h5> 
 <p><code>SyntaxError</code> 也很常见，当语法不符合 JS 规范时，就会报这种错误：</p> 
 <pre class="has"><code class="language-go">console.log(1));

// out:
// console.log(1));
//               ^
// SyntaxError: Unexpected token ')'</code></pre> 
 <h5>4、TypeError</h5> 
 <p><code>TypeError</code> 也很常见，当一个基础类型当作函数来用时，就会报这个错误：</p> 
 <pre class="has"><code class="language-go">var a = 1;
a()

// out:
// TypeError: a is not a function</code></pre> 
 <p>上面的各种 Error 类型中，<code>SyntaxError</code> 最为特殊，因为它是 <strong>编译阶段</strong> 抛出来的错误，如果发生语法错误，JS 代码一行都不会执行。而其他类型的异常都是 <strong>执行阶段</strong> 的错误，就算报错，也会执行异常之前的脚本。</p> 
 <h4>什么叫 编译时输出接口? 什么叫 运行时加载?</h4> 
 <p>ESM 之所以被称为 <code>编译时输出接口</code>，是因为它的模块解析是发生在 <strong>编译阶段</strong>。</p> 
 <p>也就是说，<code>import</code> 和 <code>export</code> 这些关键字是在编译阶段就做了模块解析，这些关键字的使用如果不符合语法规范，在编译阶段就会抛出语法错误。</p> 
 <p>例如，根据 ES6 规范，<code>import</code> 只能在模块顶层声明，所以下面的写法会直接报语法错误，不会有 log 打印，因为它压根就没有进入 <strong>执行阶段</strong>：</p> 
 <pre class="has"><code class="language-go">console.log('hello world');

if (true) {
  import { resolve } from 'path';
}

// out:
//   import { resolve } from 'path';
//          ^
// SyntaxError: Unexpected token '{'</code></pre> 
 <p>与此对应的 CommonJS，它的模块解析发生在 <strong>执行阶段</strong>，因为 <code>require</code> 和 <code>module</code> 本质上就是个函数或者对象，只有在 <strong>执行阶段</strong> 运行时，这些函数或者对象才会被实例化。因此被称为 <code>运行时加载</code>。</p> 
 <p>这里要特别强调，<strong>与CommonJS 不同，ESM 中 <code>import</code> 的不是对象， <code>export</code> 的也不是对象</strong>。例如，下面的写法会提示语法错误：</p> 
 <pre class="has"><code class="language-go">// 语法错误！这不是解构！！！
import { a: myA } from './a.mjs'

// 语法错误！
export {
  a: "a"
}</code></pre> 
 <p><code>import</code> 和 <code>export</code> 的用法很像导入一个对象或者导出一个对象，但这和对象完全没有关系。他们的用法是 ECMAScript 语言层面的设计的，并且“恰巧”的对象的使用类似。</p> 
 <p>所以在编译阶段，<code>import</code> 模块中引入的值就指向了 <code>export</code> 中导出的值。如果读者了解 linux，这就有点像 linux 中的硬链接，指向同一个 inode。或者拿栈和堆来比喻，这就像两个指针指向了同一个栈。</p> 
 <h4>ESM 的加载细节</h4> 
 <p>在讲解ESM 的加载细节之前，我们要了解 ESM 中也存在 <strong>变量提升</strong> 和 <strong>函数提升</strong> ，意识到这一点非常重要。</p> 
 <p>拿前面 <code>demos/02</code> 中提到的循环引用举例子，将其改造为 ESM 版的循环引用，查看 <code>demos/04</code>，代码的入口为 <code>app.js</code>：</p> 
 <pre class="has"><code class="language-go">import './a.mjs';</code></pre> 
 <p>看看 <code>./a.mjs</code> 的代码：</p> 
 <pre class="has"><code class="language-go">import { b, setB } from './b.mjs';

console.log('running a.mjs');

console.log('b val', b);

console.log('setB to bb');

setB('bb')

let a = 'a';

const setA = (newA) =&gt; {
  a = newA;
}

export {
  a,
  setA
}</code></pre> 
 <p>再看看 <code>./b.mjs</code> 的代码：</p> 
 <pre class="has"><code class="language-go">import { a, setA } from './a.mjs';

console.log('running b.mjs');

console.log('a val', a);

console.log('setA to aa');

setA('aa')

let b = 'b';

const setB = (newB) =&gt; {
  b = newB;
}

export {
  b,
  setB
}</code></pre> 
 <p>可以看到 <code>./a.mjs</code> 和 <code>./b.mjs</code> 在文件的开头都相互引用了对方。</p> 
 <p>执行 <code>node app.mjs</code> 查看运行结果：</p> 
 <pre class="has"><code class="language-go">running b.mjs
file:///Users/xxx/Desktop/esm_commonjs/demos/04/b.mjs:5
console.log('a val', a);
                     ^

ReferenceError: Cannot access 'a' before initialization
    at file:///Users/xxx/Desktop/esm_commonjs/demos/04/b.mjs:5:22</code></pre> 
 <p>我们会发现一个 ReferenceError 的异常报错，提示不能在初始化之前使用变量。这是因为我们使用了 <code>let</code> 定义变量，使用了 <code>const</code> 定义函数，导致无法做变量和函数提升。</p> 
 <p>怎么修改才能正常运行呢？其实很简单：用 <code>var</code> 代替 <code>let</code>，使用 function 来定义函数，我们查看 <code>demos/05</code> 来看效果：</p> 
 <p>看看 <code>./a.mjs</code> 的代码：</p> 
 <pre class="has"><code class="language-go">console.log('b val', b);

console.log('setB to bb');

setB('bb')

var a = 'a';

function setA(newA) {
  a = newA;
}

export {
  a,
  setA
}</code></pre> 
 <p>再看看 <code>./b.mjs</code> 的代码：</p> 
 <pre class="has"><code class="language-go">import { a, setA } from './a.mjs';

console.log('running b.mjs');

console.log('a val', a);

console.log('setA to aa');

setA('aa')

var b = 'b';

function setB(newB) {
  b = newB;
}

export {
  b,
  setB
}</code></pre> 
 <p>执行 <code>node app.mjs</code> 查看运行结果：</p> 
 <pre class="has"><code class="language-go">running b.mjs
a val undefined
setA to aa
running a.mjs
b val b
setB to bb</code></pre> 
 <p>可以发现这样修改后可以正常执行，没有出现异常报错。</p> 
 <p>写到这里我们可以详细谈谈 ESM 的加载细节了，它其实和前面提到的 CommonJS 的 <code>Module._load</code> 函数做的事情有些类似：</p> 
 <ol><li><p>检查缓存，如果缓存存在且已经加载，则直接从缓存模块中提取相应的值，不做下面的处理</p></li><li><p>如果缓存不存在，新建一个 Module 实例</p></li><li><p>将这个 Module 实例放到缓存中</p></li><li><p>通过这个 Module 实例来加载文件</p></li><li><p>加载文件后到<strong>全局执行上下文</strong>时，会有创建阶段和执行阶段，在创建阶段做函数和变量提升，接着执行代码。</p></li><li><p>返回这个 Module 实例的 exports</p></li></ol> 
 <p>结合 <code>demos/05</code> 的循环加载，我们再做一个详细的解释：</p> 
 <p>当 <code>app.mjs</code> 加载 <code>a.mjs</code> 时，Module 会检查缓存中有没有 <code>a.mjs</code>，发现没有，于是 new 一个 <code>a.mjs</code> 模块，并将这个模块放到缓存中，再去加载 <code>a.mjs</code> 文件本身。</p> 
 <p>在加载 <code>a.mjs</code> 文件时，在 <strong>创建阶段</strong> 会为全局上下文中的函数 <code>setA</code> 和 变量 <code>a</code> 分配内存空间，并初始化变量 <code>a</code> 为 <code>undefined</code>。在执行阶段，发现第一行是加载 <code>b.mjs</code>，它会检查缓存中有没有 <code>b.mjs</code>，发现没有，于是 new 一个 <code>b.mjs</code> 模块，并将这个模块放到缓存中，再去加载 <code>b.mjs</code> 文件本身。</p> 
 <p>在加载 <code>b.mjs</code> 文件时，在 <strong>创建阶段</strong> 会为全局上下文中的函数 <code>setB</code> 和 变量 <code>b</code> 分配内存空间，并初始化变量 <code>b</code> 为 <code>undefined</code>。在执行阶段,发现第一行是加载 <code>a.mjs</code>，它会检查缓存中有没有 <code>a.mjs</code>，发现存在，于是 <code>import</code> 返回了缓存中 <code>a.mjs</code> 导出的相应的值。</p> 
 <p>虽然这个时候 <code>a.mjs</code> 根本还没有执行过，但是它的 <strong>创建阶段</strong> 已经完成了，即在内存中也已经存在了 <code>setA</code> 函数和值为 <code>undefined</code> 的变量 <code>a</code>。所以这时候在 <code>b.mjs</code> 里可以正常打印 <code>a</code> 并使用 <code>setA</code> 函数而没有异常抛错。</p> 
 <h4>再谈 ESM 和 CommonJS 的区别</h4> 
 <h5>不同点：this 的指向不同</h5> 
 <p>CommonJS 的 this 指向可以查看源码：</p> 
 <pre class="has"><code class="language-go">var args = [self.exports, require, self, filename, dirname];
return compiledWrapper.apply(self.exports, args);</code></pre> 
 <p>很清楚的可以看到 <code>this</code> 指向的是当前 <code>module</code> 的默认 <code>exports</code>；</p> 
 <p>而 ESM 由于语言层面的设计指向的是 <code>undefined</code>。</p> 
 <h5>不同点：__filename，__dirname 在 CommonJS 中存在，在 ESM 中不存在</h5> 
 <p>在 CommonJS 中，模块的执行需要用函数包起来，并指定一些常用的值，可以查看[源码](segmentfault.com/a/[node%E6%…</p> 
 <pre class="has"><code class="language-go">NativeModule.wrapper = [
  '(function (exports, require, module, __filename, __dirname) { ',
  '\n});'
];</code></pre> 
 <p>所以我们全局才可以直接用 <code>__filename</code>、<code>__dirname</code>。而 ESM 没有这方面的设计，所以在 ESM 中不能直接使用 <code>__filename</code> 和 <code>__dirname</code>。</p> 
 <h5>相同点：ESM 和 CommonJS 都有缓存</h5> 
 <p>这一点两种模块方案一致，都会缓存模块，模块加载一次后会缓存起来，后续再次加载会用缓存里的模块。</p> 
 <h4>参考文档</h4> 
 <ul><li><p>阮一峰：Module 的加载实现</p></li><li><p>深入Node.js的模块加载机制，手写require函数</p></li><li><p>commonjs 与 esm 的区别</p></li><li><p>The Node.js Way - How <code>require()</code> Actually Works</p></li><li><p>stackoverflow:How does require() in node.js work?</p></li><li><p>Node模块加载机制：展示了一些魔改 require 的场景</p></li><li><p>docs: ES 模块和 CommonJS 之间的差异</p></li><li><p>Requiring modules in Node.js: Everything you need to know</p></li><li><p>JavaScript Execution Context and Hoisting Explained with Code Examples</p></li><li><p>深入了解JavaScript执行过程（JS系列之一）</p></li><li><p>JS执行过程详解</p></li><li><p>7 Types of Native Errors in JavaScript You Should Know</p></li></ul> 
 <p>作者：FLY</p> 
 <p>https://mp.weixin.qq.com/s/cBqbsHGhEW6N8deiMKMFOQ</p> 
 <pre class="has"><code class="language-go">Node 社群



我组建了一个氛围特别好的 Node.js 社群，里面有很多 Node.js小伙伴，如果你对Node.js学习感兴趣的话（后续有计划也可以），我们可以一起进行Node.js相关的交流、学习、共建。下方加 考拉 好友回复「Node」即可。

   “分享、点赞、在看” 支持一波👍</code></pre> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/42342e7bd7afd36307ef0262c94ff3ae/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">GDOUCTF web部分题解 2023</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8f71af14940d0a9a725c5b190a76fb43/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">触发pam_tally2模块机制导致登录失败</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>