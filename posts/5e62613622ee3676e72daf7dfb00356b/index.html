<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Synchronized、ReentrantLock、ReadWriteLock 介绍 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Synchronized、ReentrantLock、ReadWriteLock 介绍" />
<meta property="og:description" content="Synchronized 关键字 介绍 synchronized 是 Java 中的关键字，用于控制对共享资源的并发访问，提供了一种锁机制来保证共享资源在同一时刻只能被一个线程访问。
优点 简单易用：作为语言的内置特性，使用方便。自动释放锁：当同步块执行完成后，锁会自动被释放，不需要手动操作。 缺点 不够灵活：不支持公平锁，不能中断正在等待锁的线程。无法尝试获取锁：线程尝试获取锁时，如果锁被占用，会一直等待，无法设置超时。锁粒度较粗：锁的是整个类、对象或方法，可能会导致不必要的等待。 使用场景 适用于代码简单、竞争不激烈的同步场景。
ReentrantLock 介绍 ReentrantLock 是 java.util.concurrent.locks 包中的一个类，它提供了比 synchronized 更多的功能。
优点 高度灵活：支持尝试非阻塞地获取锁、可中断的锁获取等。支持条件变量：可以绑定多个 Condition 对象，实现复杂的线程同步。可选择公平锁：支持公平锁，按照线程等待的先后顺序分配锁。 缺点 需要手动释放锁：必须在 finally 块中释放锁，增加了编程复杂性。性能开销：相比于 synchronized，ReentrantLock 在某些情况下可能有更多的性能开销。 使用场景 适用于需要高度并发控制、锁定时间长、条件同步等复杂场景。
ReadWriteLock 介绍 ReadWriteLock 是一个接口，它包含一对锁，一个读锁和一个写锁，通过分离读和写操作来提高并发性能。
优点 读写分离：允许多个线程同时读，但只允许一个线程写，提高了并发性。适应读多写少场景：在读操作远远高于写操作的场景下，性能优于 synchronized。ReentrantLock 允许锁的续租，即一个线程可以重复获取已经持有的锁 缺点 复杂性：编程相对复杂，需要正确管理读锁和写锁。锁升级问题：读锁无法直接升级为写锁，可能会导致死锁。 使用场景 适用于读多写少的并发场景，如缓存系统。
选择依据 在选择同步机制时，应考虑以下因素：
简单性：如果同步逻辑简单，可以优先考虑使用 synchronized。灵活性和功能需求：如果需要高度的灵活性和附加功能（如定时锁等待、公平性选择、条件变量等），应选择 ReentrantLock。读写操作的频率：如果系统是读多写少的，使用 ReadWriteLock 可以提高并发性，但需要注意避免写锁导致的读锁饥饿。性能：如果对性能有极高要求，可以通过基准测试来选择适合的锁。可维护性：更复杂的同步机制可能导致代码难以理解和维护，需要根据团队的熟悉程度和偏好来选择。 在实际应用中，通常需要根据具体的业务场景和性能要求来选择最合适的同步机制。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5e62613622ee3676e72daf7dfb00356b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-27T13:09:47+08:00" />
<meta property="article:modified_time" content="2023-12-27T13:09:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Synchronized、ReentrantLock、ReadWriteLock 介绍</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>Synchronized 关键字</h2> 
<h3> 介绍</h3> 
<p><code> synchronized</code> 是 Java 中的关键字，用于控制对共享资源的并发访问，提供了一种锁机制来保证共享资源在同一时刻只能被一个线程访问。</p> 
<h3>优点</h3> 
<ul><li><strong>简单易用</strong>：作为语言的内置特性，使用方便。</li><li><strong>自动释放锁</strong>：当同步块执行完成后，锁会自动被释放，不需要手动操作。</li></ul> 
<h3>缺点</h3> 
<ul><li><strong>不够灵活</strong>：不支持公平锁，不能中断正在等待锁的线程。</li><li><strong>无法尝试获取锁</strong>：线程尝试获取锁时，如果锁被占用，会一直等待，无法设置超时。</li><li><strong>锁粒度较粗</strong>：锁的是整个类、对象或方法，可能会导致不必要的等待。</li></ul> 
<h3>使用场景</h3> 
<p>  适用于代码简单、竞争不激烈的同步场景。</p> 
<h2>ReentrantLock</h2> 
<h3> 介绍</h3> 
<p><code>ReentrantLock</code> 是 <code>java.util.concurrent.locks</code> 包中的一个类，它提供了比 synchronized 更多的功能。</p> 
<h3> 优点</h3> 
<ul><li><strong>高度灵活</strong>：支持尝试非阻塞地获取锁、可中断的锁获取等。</li><li><strong>支持条件变量</strong>：可以绑定多个 Condition 对象，实现复杂的线程同步。</li><li><strong>可选择公平锁</strong>：支持公平锁，按照线程等待的先后顺序分配锁。</li></ul> 
<h3> 缺点</h3> 
<ul><li><strong>需要手动释放锁</strong>：必须在 finally 块中释放锁，增加了编程复杂性。</li><li><strong>性能开销</strong>：相比于 synchronized，ReentrantLock 在某些情况下可能有更多的性能开销。</li></ul> 
<h3> 使用场景</h3> 
<p>适用于需要高度并发控制、锁定时间长、条件同步等复杂场景。</p> 
<h2>ReadWriteLock</h2> 
<h3> 介绍</h3> 
<p><code>ReadWriteLock</code> 是一个接口，它包含一对锁，一个读锁和一个写锁，通过分离读和写操作来提高并发性能。</p> 
<h3> 优点</h3> 
<ul><li><strong>读写分离</strong>：允许多个线程同时读，但只允许一个线程写，提高了并发性。</li><li><strong>适应读多写少场景</strong>：在读操作远远高于写操作的场景下，性能优于 synchronized。</li><li>ReentrantLock 允许锁的续租，即一个线程可以重复获取已经持有的锁</li></ul> 
<h3> 缺点</h3> 
<ul><li><strong>复杂性</strong>：编程相对复杂，需要正确管理读锁和写锁。</li><li><strong>锁升级问题</strong>：读锁无法直接升级为写锁，可能会导致死锁。</li></ul> 
<h3> 使用场景</h3> 
<p>适用于读多写少的并发场景，如缓存系统。</p> 
<h3> 选择依据</h3> 
<p> 在选择同步机制时，应考虑以下因素：</p> 
<ul><li><strong>简单性</strong>：如果同步逻辑简单，可以优先考虑使用 synchronized。</li><li><strong>灵活性和功能需求</strong>：如果需要高度的灵活性和附加功能（如定时锁等待、公平性选择、条件变量等），应选择 ReentrantLock。</li><li><strong>读写操作的频率</strong>：如果系统是读多写少的，使用 ReadWriteLock 可以提高并发性，但需要注意避免写锁导致的读锁饥饿。</li><li><strong>性能</strong>：如果对性能有极高要求，可以通过基准测试来选择适合的锁。</li><li><strong>可维护性</strong>：更复杂的同步机制可能导致代码难以理解和维护，需要根据团队的熟悉程度和偏好来选择。</li></ul> 
<p>在实际应用中，通常需要根据具体的业务场景和性能要求来选择最合适的同步机制。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e09dadba541c9041b6a1f5f4808a324a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MD5--加密原理及代码示例(C#)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d5040bf56b403fe0bade21b17c19f97d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">excel数据使用xlsx读取转换成JSON</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>