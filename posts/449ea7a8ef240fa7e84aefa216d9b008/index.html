<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【面试】java后端面试问题收集1 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【面试】java后端面试问题收集1" />
<meta property="og:description" content="分布式id唯一性如何保证 分布式系统中生成唯一ID（如订单号、用户ID等）是一项常见的需求。在保证唯一性的基础上，分布式ID生成应能够满足高并发、可扩展和性能要求。下面介绍几种常用的分布式ID生成方案，它们都以不同的方式保证了唯一性：
UUID（Universally Unique Identifier）：UUID是一种128位的全局唯一标识符，采用随机算法生成。UUID的唯一性非常高，几乎可以忽略重复的概率。UUID在生成时不依赖于任何中央注册机构，因此可以在分布式系统中生成唯一ID。然而，由于其较长的长度对于存储和索引来说可能不够高效，同时也不具备可排序性。
数据库自增ID：使用数据库自增ID的方式是常见且简单的方案。数据库通过设置自增主键，每次插入新记录时会自动递增生成唯一ID。优点是数据库提供了高并发和事务的支持，不需要考虑冲突问题。但是，数据库的性能可能成为瓶颈，并且在分库分表的情况下，需要额外的管理和访问多个数据库。
Snowflake算法：Snowflake是Twitter开源的一种分布式ID生成算法。Snowflake算法将64位的ID划分成多个部分，包括时间戳、工作节点ID和序列号。通过对时间戳、节点ID和序列号的组合，可以生成一个全局唯一的ID。Snowflake算法在分布式环境下具备高性能和可扩展性，同时也保留了可排序性的特点。
全局唯一ID生成器（如Redis、ZooKeeper）：使用全局唯一ID生成器可以避免单点故障。例如，借助于Redis或ZooKeeper这样的分布式数据存储服务，可以实现一个全局唯一ID的生成器。每次需要生成ID时，客户端向全局唯一ID生成器请求一个唯一ID，通过原子操作保证了ID的唯一性和可靠性。
在实际应用中，根据系统的需求和规模选择合适的分布式ID生成方案。而且需要注意的是，保证ID的唯一性只是第一步，如何高效地生成和使用ID、如何处理ID的有序性以及如何在分布式系统中保障ID的一致性等问题也是需要考虑的。
了解GC吗，java的GC怎么做？ 深入了解JVM垃圾回收的8种算法
GC（垃圾收集）是一种自动管理内存的机制，它通过自动扫描和回收程序中不再使用的内存，以减少内存泄漏和提高应用程序的性能。
Java的GC机制是指Java虚拟机（JVM）中负责自动回收垃圾对象的一套算法。Java程序在运行时会动态地分配和释放内存，但由于Java语言本身并没有提供手动管理内存的机制，所以需要依靠GC进行自动管理。
Java的GC机制主要基于以下几个原则：
引用计数法（Reference Counting）：在每个对象中维护一个计数器，记录有多少个引用指向该对象。每当有一个引用指向该对象时，计数器加一；当引用指向该对象失效时，计数器减一。当计数器为零时，表示该对象不再被使用，可以释放内存。但这种方法无法解决循环引用的情况，因此Java不采用引用计数法。
可达性分析（Reachability Analysis）：Java的GC机制基于可达性分析，即判断某个对象是否可达，若不可达则表明该对象不再被使用。从GC Roots（包括栈中的局部变量、静态变量、常量等）开始，通过对象引用链追踪，标记所有可达的对象，并将剩余的对象（即不可达对象）判定为垃圾，待回收。
标记-清除算法（Mark and Sweep）：当Java的GC判定某个对象为垃圾时，它并不直接释放该对象所占的内存空间，而是将其标记为可回收状态。在Java虚拟机判断需要进行垃圾回收时，会先暂停应用程序运行，通过标记所有可达对象，然后清除所有不可达对象所占的内存空间，最后压缩内存，使其连续起来，以便后续分配。
分代回收（Generational Collection）：为了提高回收效率，JVM将内存分为不同的代（Generation），一般分为年轻代（Young Generation）和老年代（Old Generation）。年轻代中的对象生命周期较短，回收频率高，采用复制算法（Copying）回收；老年代中的对象生命周期较长，采用标记-清除算法回收。
总的来说，Java的GC机制通过判断对象的可达性和分代回收的方式对内存进行自动管理和回收，减少了开发者手动释放内存的工作，并提高了应用程序的性能和稳定性。不同的GC算法和配置可根据实际需求进行选择和调整。、
访问一个网站后发生了什么：
用户在浏览器中输入网址，请求访问网站。浏览器首先进行DNS查询，将域名转换为对应的IP地址。 如果DNS缓存中有对应的IP地址，直接使用缓存。如果没有，则进行DNS解析，向DNS服务器发送查询请求获取对应的IP地址。 用户计算机与目标服务器之间建立网络连接。 如果目标服务器在同一局域网内，使用ARP协议查询目标设备的MAC地址，直接建立连接。否则，通过默认网关路由器建立连接。 在传输层使用TCP协议进行连接的建立和数据传输。 进行TCP三次握手来建立连接。 客户端发送一个带有SYN标志的数据包给服务器。服务器接收到请求后，回复一个带有SYN/ACK标志的数据包。客户端再回复一个带有ACK标志的数据包，确认连接建立成功。 客户端向服务器发送HTTP请求。 服务器接收到请求后，进行处理和响应。 根据请求的方法和路径，进行相应的处理操作。生成HTTP响应，包括状态码、响应头和响应内容。 服务器将HTTP响应发送回客户端。 HTTP响应经过网络传输到达客户端。 客户端接收到HTTP响应。 数据经过TCP传输层进行处理和接收。 浏览器解析HTTP响应并渲染页面。 解析HTML、CSS、JavaScript等内容。根据解析结果渲染页面显示给用户。 数据传输完毕后，关闭TCP连接。 客户端和服务器进行TCP四次挥手来关闭连接。 客户端发送一个带有FIN标志的数据包给服务器。服务器接收到请求后，回复一个带有ACK标志的数据包。服务器发送一个带有FIN标志的数据包给客户端。客户端接收到请求后，回复一个带有ACK标志的数据包，最终连接关闭。 mq 消息不丢失详细再讲讲
本服务依赖哪些外部服务，外部服务异常了怎么办
数据在线迁移方案，什么时候可以把源库下掉，数据丢失怎么办，怎么保证一致性
Linux更改文件权限命令，为什么是三个数字
谈谈对动态规划的理解，01背包问题怎么解决
进程间 ipc 机制
tcp 如何保证可靠
四层负载均衡和七层负载均衡，四层了解吗？（答不太了解，于是扯了一下七层，提到了反向代理）
ngnix分发请求后，响应是响应给client还是给ngnix （回答不知道，猜的是ngnix，根本没用过啊哈哈哈）
操作系统最多可以建立多少长链接
http3了解吗？（不太了解，只知道底层是quic）
mysql索引原理，b&#43;树为什么要在最底层把叶子结点串成双向链表？
事务隔离级别，每个级别分别会发生什么问题
java11和8区别？（不太了解，谈了一些可有可无的特性，面试官提醒垃圾收集器，回答更换了默认的垃圾收集器为g1，面试官这时候问了解zgc吗，回答不了解）
深度拷贝怎么做
synchronized 可重入吗？公平吗？怎么实现一个公平锁？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/449ea7a8ef240fa7e84aefa216d9b008/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-16T02:30:47+08:00" />
<meta property="article:modified_time" content="2023-06-16T02:30:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【面试】java后端面试问题收集1</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="id_1"></a>分布式id唯一性如何保证</h3> 
<p>分布式系统中生成唯一ID（如订单号、用户ID等）是一项常见的需求。在保证唯一性的基础上，分布式ID生成应能够满足高并发、可扩展和性能要求。下面介绍几种常用的分布式ID生成方案，它们都以不同的方式保证了唯一性：</p> 
<p><strong>UUID</strong>（Universally Unique Identifier）：UUID是一种128位的全局唯一标识符，采用随机算法生成。UUID的唯一性非常高，几乎可以忽略重复的概率。UUID在生成时不依赖于任何中央注册机构，因此可以在分布式系统中生成唯一ID。然而，由于其较长的长度对于存储和索引来说可能不够高效，同时也不具备可排序性。</p> 
<p>数据库自增ID：使用数据库自增ID的方式是常见且简单的方案。数据库通过设置自增主键，每次插入新记录时会自动递增生成唯一ID。优点是数据库提供了高并发和事务的支持，不需要考虑冲突问题。但是，数据库的性能可能成为瓶颈，并且在分库分表的情况下，需要额外的管理和访问多个数据库。</p> 
<p><strong>Snowflake算法</strong>：Snowflake是Twitter开源的一种分布式ID生成算法。<strong>Snowflake算法将64位的ID划分成多个部分，包括时间戳、工作节点ID和序列号</strong>。通过对时间戳、节点ID和序列号的组合，可以生成一个全局唯一的ID。Snowflake算法在分布式环境下具备高性能和可扩展性，同时也保留了可排序性的特点。</p> 
<p>全局唯一ID生成器（如Redis、ZooKeeper）：使用全局唯一ID生成器可以避免单点故障。例如，借助于Redis或ZooKeeper这样的分布式数据存储服务，可以实现一个全局唯一ID的生成器。每次需要生成ID时，客户端向全局唯一ID生成器请求一个唯一ID，通过原子操作保证了ID的唯一性和可靠性。</p> 
<p>在实际应用中，根据系统的需求和规模选择合适的分布式ID生成方案。而且需要注意的是，保证ID的唯一性只是第一步，如何高效地生成和使用ID、如何处理ID的有序性以及如何在分布式系统中保障ID的一致性等问题也是需要考虑的。</p> 
<h3><a id="GCjavaGC_16"></a>了解GC吗，java的GC怎么做？</h3> 
<p><a href="https://zhuanlan.zhihu.com/p/163582405" rel="nofollow">深入了解JVM垃圾回收的8种算法</a></p> 
<p>GC（垃圾收集）是一种自动管理内存的机制，它通过自动扫描和回收程序中不再使用的内存，以减少内存泄漏和提高应用程序的性能。</p> 
<p>Java的GC机制是指Java虚拟机（JVM）中负责自动回收垃圾对象的一套算法。Java程序在运行时会动态地分配和释放内存，但由于Java语言本身并没有提供手动管理内存的机制，所以需要依靠GC进行自动管理。</p> 
<p>Java的GC机制主要基于以下几个原则：</p> 
<p>引用计数法（Reference Counting）：在每个对象中维护一个计数器，记录有多少个引用指向该对象。每当有一个引用指向该对象时，计数器加一；当引用指向该对象失效时，计数器减一。当计数器为零时，表示该对象不再被使用，可以释放内存。但这种方法无法<strong>解决循环引用</strong>的情况，因此Java不采用引用计数法。</p> 
<p><strong>可达性分析（Reachability Analysis）：Java的GC机制基于可达性分析</strong>，即判断某个对象是否可达，若不可达则表明该对象不再被使用。从GC Roots（包括栈中的局部变量、静态变量、常量等）开始，通过对象引用链追踪，标记所有可达的对象，并将剩余的对象（即不可达对象）判定为垃圾，待回收。</p> 
<p>标记-清除算法（Mark and Sweep）：当Java的GC判定某个对象为垃圾时，它并不直接释放该对象所占的内存空间，而是将其<strong>标记为可回收状态</strong>。在Java虚拟机判断需要进行垃圾回收时，会先<strong>暂停应用程序运行</strong>，通过标记所有可达对象，然后<strong>清除所有不可达对象所占的内存空间</strong>，最后压缩内存，使其连续起来，以便后续分配。</p> 
<p>分代回收（Generational Collection）：为了提高回收效率，JVM将内存分为不同的代（Generation），一般分为年轻代（Young Generation）和老年代（Old Generation）。年轻代中的对象生命周期较短，回收频率高，采用复制算法（Copying）回收；老年代中的对象生命周期较长，采用标记-清除算法回收。</p> 
<p>总的来说，Java的GC机制通过判断对象的可达性和分代回收的方式对内存进行自动管理和回收，减少了开发者手动释放内存的工作，并提高了应用程序的性能和稳定性。不同的GC算法和配置可根据实际需求进行选择和调整。、</p> 
<p>访问一个网站后发生了什么：</p> 
<ol><li>用户在浏览器中输入网址，请求访问网站。</li><li>浏览器首先进行<strong>DNS查询</strong>，将域名转换为对应的IP地址。 
  <ul><li>如果<strong>DNS缓存</strong>中有对应的IP地址，直接使用缓存。</li><li>如果没有，则进行<strong>DNS解析</strong>，向DNS服务器发送查询请求获取对应的IP地址。</li></ul> </li><li>用户计算机与目标服务器之间建立网络连接。 
  <ul><li>如果目标服务器在同一局域网内，使用<strong>ARP协议</strong>查询目标设备的<strong>MAC地址</strong>，直接建立连接。</li><li>否则，通过<strong>默认网关路由器</strong>建立连接。</li></ul> </li><li>在传输层使用TCP协议进行连接的建立和数据传输。 
  <ul><li>进行<strong>TCP三次握手</strong>来建立连接。 
    <ol><li>客户端发送一个带有SYN标志的数据包给服务器。</li><li>服务器接收到请求后，回复一个带有SYN/ACK标志的数据包。</li><li>客户端再回复一个带有ACK标志的数据包，确认连接建立成功。</li></ol> </li><li>客户端向服务器发送HTTP请求。</li></ul> </li><li>服务器接收到请求后，进行处理和响应。 
  <ul><li>根据请求的方法和路径，进行相应的处理操作。</li><li>生成HTTP响应，包括状态码、响应头和响应内容。</li></ul> </li><li>服务器将HTTP响应发送回客户端。 
  <ul><li>HTTP响应经过网络传输到达客户端。</li></ul> </li><li>客户端接收到HTTP响应。 
  <ul><li>数据经过TCP传输层进行处理和接收。</li></ul> </li><li>浏览器<strong>解析HTTP响应</strong>并渲染页面。 
  <ul><li>解析HTML、CSS、JavaScript等内容。</li><li>根据解析结果渲染页面显示给用户。</li></ul> </li><li>数据传输完毕后，关闭TCP连接。 
  <ul><li>客户端和服务器进行TCP四次挥手来关闭连接。 
    <ol><li>客户端发送一个带有FIN标志的数据包给服务器。</li><li>服务器接收到请求后，回复一个带有ACK标志的数据包。</li><li>服务器发送一个带有FIN标志的数据包给客户端。</li><li>客户端接收到请求后，回复一个带有ACK标志的数据包，最终连接关闭。</li></ol> </li></ul> </li></ol> 
<p>mq 消息不丢失详细再讲讲<br> 本服务依赖哪些外部服务，外部服务异常了怎么办<br> 数据在线迁移方案，什么时候可以把源库下掉，数据丢失怎么办，怎么保证一致性<br> Linux更改文件权限命令，为什么是三个数字<br> 谈谈对动态规划的理解，01背包问题怎么解决<br> 进程间 ipc 机制<br> tcp 如何保证可靠<br> 四层负载均衡和七层负载均衡，四层了解吗？（答不太了解，于是扯了一下七层，提到了反向代理）<br> ngnix分发请求后，响应是响应给client还是给ngnix （回答不知道，猜的是ngnix，根本没用过啊哈哈哈）<br> 操作系统最多可以建立多少长链接<br> http3了解吗？（不太了解，只知道底层是quic）<br> mysql索引原理，b+树为什么要在最底层把叶子结点串成双向链表？<br> 事务隔离级别，每个级别分别会发生什么问题<br> java11和8区别？（不太了解，谈了一些可有可无的特性，面试官提醒垃圾收集器，回答更换了默认的垃圾收集器为g1，面试官这时候问了解zgc吗，回答不了解）<br> 深度拷贝怎么做<br> synchronized 可重入吗？公平吗？怎么实现一个公平锁？<br> 乐观锁和悲观锁的使用场景？<br> 接口出现性能问题如何排查？</p> 
<p>3、大数量表的查询规则是什么？<br> 4、项目的索引是如何建立的？<br> 5、如果查询参数少了一个怎么办？<br> 7、说一下 Bean 的生命周期？<br> 8、单例Bean的好处？<br> 9、如何实现线程安全？<br> 10、Redis 的分布式？<br> 11、Redis 分布式的实现？<br> 12、Redis 阻塞优化方案？<br> 13、线程进程协程的概念？<br> 14、双向链表怎么增加元素、删除元素？<br> 15、说一下冒泡排序？<br> 16、说一下二分查找？<br> 17、说一下设计模式？<br> 18、说一下单例模式？</p> 
<p>TCP和UDP的区别</p> 
<p>TCP可靠性是如何实现的</p> 
<p>设计一个可靠的UDP</p> 
<p>三次握手和四次挥手的原因</p> 
<p>四次挥手为什么最后要等2MSL</p> 
<p>什么是红黑树、B树、B+树</p> 
<p>红黑树和B树的比较</p> 
<p>B树和B+树的比较</p> 
<p>聚簇索引和非聚簇索引</p> 
<p>找二叉搜索树的第k大数</p> 
<p>缓存了解吗</p> 
<p>用B+树当索引的好处：哈希索引、B+树索引的比较</p> 
<p>事务的四大特征</p> 
<p>事务的隔离级别</p> 
<p>Java的基本数据类型，double精度丢失，BigDecimal的原理</p> 
<p>计算时，先成于10的N次方，先把小数都变成整数，整数存储是没有精度问题的，做完了相应的运算之后，再除以10的N次方。</p> 
<p>手写一个String类，能否被类加载器加载；双亲委派机制，如何打破；String类可以被继承吗</p> 
<p>hashmap的常规八股</p> 
<p>浏览器发送url后，域名怎么转换为ip地址；域名对应的不止一个ip（负载均衡），了解哪些负载均衡的算法</p> 
<p>http和https的区别，对称加密算法和非对称加密算法的区别</p> 
<p>mysql的qps从1到10000，性能的变化情况</p> 
<p>大量请求执行update语句，有什么方法优化；引入redis的数据一致性问题</p> 
<p>mysql索引的底层实现，为什么用b+树，模糊查询命中索引的条件</p> 
<p>mysql的事务隔离，MVCC如何实现</p> 
<p>Spring bean的生命周期和作用域，BeanFactory和FactoryBean的区别</p> 
<p>Spring aop的底层实现，动态代理的实现方式，在哪些实际业务中应用过</p> 
<p>线程池参数，执行原理；工作队列有哪些，有什么区别</p> 
<p>微服务的设计原则</p> 
<p>Dubbo有过了解吗，rpc和http调用的区别，rpc框架需要哪些模块，负载均衡应该设计在客户端还是服务端</p> 
<p>了解微服务的网关路由吗，Spring Cloud Gateway可以用作哪些功能</p> 
<p>单机限流的算法，需要集群限流的话应该怎么实现，计数法的弊端是什么</p> 
<p>领域驱动有了解吗</p> 
<p>Java面向对象的设计原则</p> 
<p>最左匹配原则是什么，给了几个例子问查找对不对</p> 
<p>二叉树的后序遍历口述思路</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/97543161a5a282ad2e8209b66210f60c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python中pandas如何过滤输出</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/01ca483e46a0dda7e1f23df6feb4f997/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue-汉字转拼音</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>