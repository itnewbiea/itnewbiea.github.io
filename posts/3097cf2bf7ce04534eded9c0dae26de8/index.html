<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>冒泡排序算法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="冒泡排序算法" />
<meta property="og:description" content="冒泡排序，也称为Bubble Sort，是一种简单的计算机科学排序算法。该算法重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序错误就把他们交换过来。这个过程会不断重复，直到没有再需要交换的相邻元素为止，也就是说该数列已经排序完成。
冒泡排序的名字来源于越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。
冒泡排序的基本思想是通过对待排序序列从前向后（从下标较小的元素开始），依次对相邻两个元素的值进行两两比较，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒出。例如，对于一个待排序数组：3，9，-1，10，20，第一轮排序后，将最大的元素20固定到了最后的位置；然后在第二轮排序时，因为20的位置已经固定，所以只对前4个进行排序即可。
优化：
因为排序的过程中，个元素不断接近自己的位置，如果一次比较下来没有进行交换过，说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行交换过。从而减少不必要的比较。
推敲冒泡排序中： public class Sort { public static void main(String[] args) { //原始的冒泡排序 int arr[] = {3, 9, -1, 10, -2}; System.out.println(&#34;====排序前====&#34;); System.out.println(&#34;第0轮：&#34; &#43; Arrays.toString(arr)); System.out.println(&#34;===开始排序===&#34;); int temp; for (int j = 0; j &lt; arr.length - 1; j&#43;&#43;) { if (arr[j] &gt; arr[j &#43; 1]) { temp = arr[j]; arr[j] = arr[j &#43; 1]; arr[j &#43; 1] = temp; } } System.out.println(&#34;第1轮：&#34; &#43; Arrays." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/3097cf2bf7ce04534eded9c0dae26de8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-02T14:56:37+08:00" />
<meta property="article:modified_time" content="2024-01-02T14:56:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">冒泡排序算法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        冒泡排序，也称为Bubble Sort，是一种简单的计算机科学排序算法。该算法重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序错误就把他们交换过来。这个过程会不断重复，直到没有再需要交换的相邻元素为止，也就是说该数列已经排序完成。</p> 
<p>        冒泡排序的名字来源于越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</p> 
<p>        冒泡排序的基本思想是<strong>通过对待排序序列从前向后（从下标较小的元素开始），依次对相邻两个元素的值进行两两比较，若发现逆序则交换</strong>，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒出。例如，对于一个待排序数组：3，9，-1，10，20，第一轮排序后，将最大的元素20固定到了最后的位置；然后在第二轮排序时，因为20的位置已经固定，所以只对前4个进行排序即可。</p> 
<p>优化：</p> 
<p>        因为排序的过程中，个元素不断接近自己的位置，如果一次比较下来没有进行交换过，说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行交换过。从而减少不必要的比较。</p> 
<h5>推敲冒泡排序中： </h5> 
<pre><code class="language-java">public class Sort {
    public static void main(String[] args) {
        //原始的冒泡排序
        int arr[] = {3, 9, -1, 10, -2};
        System.out.println("====排序前====");
        System.out.println("第0轮：" + Arrays.toString(arr));

        System.out.println("===开始排序===");
        int temp;
        for (int j = 0; j &lt; arr.length - 1; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
        System.out.println("第1轮：" + Arrays.toString(arr));

        for (int j = 0; j &lt; arr.length - 1 - 1; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
        System.out.println("第2轮：" + Arrays.toString(arr));

        for (int j = 0; j &lt; arr.length - 1 - 2; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
        System.out.println("第3轮：" + Arrays.toString(arr));

        for (int j = 0; j &lt; arr.length - 1 - 3; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
        System.out.println("第4轮：" + Arrays.toString(arr));
    }
}</code></pre> 
<p><img alt="" height="276" src="https://images2.imgbox.com/16/46/CRrnIrF9_o.png" width="325"> </p> 
<h5> 传统的冒泡排序：</h5> 
<pre><code class="language-java">public class BubbleSort {
    public static void main(String[] args) {
        int[] arrays = {12, 5, 8, 9, 4, 2};
        System.out.println("===排序之前的数据===");
        for (int i = 0; i &lt; arrays.length; i++) {
            System.out.print(arrays[i] + "\t");
        }
        System.out.println();

        //排序操作
        int temp = 0;
        for (int i = 0; i &lt; arrays.length - 1; i++) {
            for (int j = 0; j &lt; arrays.length - i - 1; j++) {
                if (arrays[j + 1] &lt; arrays[j]) {
                    temp = arrays[j];
                    arrays[j] = arrays[j + 1];
                    arrays[j + 1] = temp;
                }
            }
        }
        System.out.println("===排序之后的数据===");
        for (int i = 0; i &lt; arrays.length; i++) {
            System.out.print(arrays[i] + "\t");
        }
        System.out.println();
    }
}
</code></pre> 
<p><img alt="" height="165" src="https://images2.imgbox.com/6c/9f/g9CWbBoU_o.png" width="343"></p> 
<h5>优化之后的冒泡排序：</h5> 
<p>优化的内容，只是检验该数组是否具备提前结束的必要，如果数组在每次排序后都需要进行交换，其运行的时间效率并不能提高。</p> 
<pre><code class="language-java">public class BubbleSortUpdate {
    public static void main(String[] args) {
        int[] arrays = {5, 2, 8, 9, 4, 12};
        System.out.println("排序前：" + Arrays.toString(arrays));
        boolean flag = false;
        int temp = 0;
        for (int i = 0; i &lt; arrays.length - 1; i++) {
            for (int j = 0; j &lt; arrays.length - i - 1; j++) {
                if (arrays[j] &gt; arrays[j + 1]) {
                    flag = true;
                    //代表在一次排序中，进行交换过，如果交换过，说明排序还未结束，下次接着进行排序
                    temp = arrays[j];
                    arrays[j] = arrays[j + 1];
                    arrays[j + 1] = temp;
                }
            }
            if (!flag) { //在一次排序中，一次都没有进行交换
                break;
            } else {
                flag = false; //重置flag，进行下次判断
            }
            System.out.println("轮数" + (i + 1) + " :" + Arrays.toString(arrays));
        }
        System.out.println("排序后：" + Arrays.toString(arrays));
    }
}</code></pre> 
<p> <img alt="" height="240" src="https://images2.imgbox.com/40/81/XuMkghST_o.png" width="310"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ced38d8dde83a9f87d5fb0fa7cf3d06f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决linux系统时间与网络时间不一致，linux同步网络时间，未找到匹配的参数: ntpdate，错误：没有任何匹配: ntpdate</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2be9f1f7cc5747f19c32fe7bf22dd275/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">git更改.ignore文件之后如何生效</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>