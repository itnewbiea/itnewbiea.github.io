<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python数据类型之“集合(Sets)与映射(Mapping)” - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python数据类型之“集合(Sets)与映射(Mapping)”" />
<meta property="og:description" content="一、集合类型(Sets) 集合对象是不同的(不可重复)hashable对象的无序集合。常见用法包括：成员关系测试、移除序列中的重复、以及科学计算，例如交集、并集、差分和对称差分。通俗点来说，集合是一个无序不重复元素的数据集，其基本功能是进行成员关系测试和消除重复元素。
目前有两种内置的集合类型：set 和 frozenset。set类型是可变的--可以使用add() 和 remove()等方法更改其内容。由于它是可变的，它没有hash值，因此它不能被当做字典的键值或另一集合的元素。frozenset类型是不可变的 和 hashable的，它的内容不能再创建后改变，因此它可以用作字典的键值或作为另一个集合的元素。
set类构建函数 class set([iterable]) class frozenset([iterable]) set的构建方式 将一个用逗号分割的元素列表放在一堆花括号内可以创建一个非空set集合，如{&#39;Tom&#39;, &#39;Jerry&#39;, &#39;Peter&#39;}给set的构建函数传递一个空值将会创建一个空set集合(注意：{}表示的是一个空字典而不是空set集合)给set的构架你函数传一个非空iterable参数将会创建一个非空set集合 注意：
再次强调，一个set集合内的元素必须是hashable的（不可变的）。要想表示一个set的set，那么内部的set必须是frozenset对象，因为frozenset是不可变的，是hashable的。
set构建示例 &gt;&gt;&gt; {&#39;Tom&#39;, &#39;Jerry&#39;, &#39;Peter&#39;} # 使用花括号创建非空set集合 {&#39;Jerry&#39;, &#39;Tom&#39;, &#39;Peter&#39;} &gt;&gt;&gt; set() # 使用set构建函数创建空set集合 set() &gt;&gt;&gt; set((1, 2, 3 ,4)) # 使用set构建函数创建非空set集合 {1, 2, 3, 4} &gt;&gt;&gt; set((1, 2, 3 ,[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])) # set集合中的元素必须是不可变的、可哈希的 Traceback (most recent call last): File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt; TypeError: unhashable type: &#39;list&#39; set 和 frozenset都支持的操作 作为无序集合，set不记录元素位置或插入顺序。因此set不支持索引、切片或其他类序列行为。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6b98f3661fbe4ab09bae543ed9a311c1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-12-01T22:46:00+08:00" />
<meta property="article:modified_time" content="2016-12-01T22:46:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python数据类型之“集合(Sets)与映射(Mapping)”</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown"> 
 <h3 id="一集合类型sets">一、集合类型(Sets)</h3> 
 <hr> 
 <p>集合对象是不同的(不可重复)hashable对象的无序集合。常见用法包括：成员关系测试、移除序列中的重复、以及科学计算，例如交集、并集、差分和对称差分。通俗点来说，集合是一个无序不重复元素的数据集，其基本功能是进行成员关系测试和消除重复元素。</p> 
 <p>目前有两种内置的集合类型：set 和 frozenset。set类型是可变的--可以使用add() 和 remove()等方法更改其内容。由于它是可变的，它没有hash值，因此它不能被当做字典的键值或另一集合的元素。frozenset类型是不可变的 和 hashable的，它的内容不能再创建后改变，因此它可以用作字典的键值或作为另一个集合的元素。</p> 
 <h4 id="set类构建函数">set类构建函数</h4> 
 <pre><code>class set([iterable])
class frozenset([iterable])</code></pre> 
 <h4 id="set的构建方式">set的构建方式</h4> 
 <ul><li>将一个用逗号分割的元素列表放在一堆花括号内可以创建一个非空set集合，如{'Tom', 'Jerry', 'Peter'}</li><li>给set的构建函数传递一个空值将会创建一个空set集合(注意：{}表示的是一个空字典而不是空set集合)</li><li>给set的构架你函数传一个非空iterable参数将会创建一个非空set集合</li></ul> 
 <blockquote> 
  <p><strong><em>注意：</em></strong></p> 
  <p>再次强调，一个set集合内的元素必须是hashable的（不可变的）。要想表示一个set的set，那么内部的set必须是frozenset对象，因为frozenset是不可变的，是hashable的。</p> 
 </blockquote> 
 <h4 id="set构建示例">set构建示例</h4> 
 <pre><code>&gt;&gt;&gt; {'Tom', 'Jerry', 'Peter'}  # 使用花括号创建非空set集合
{'Jerry', 'Tom', 'Peter'}
&gt;&gt;&gt; set()  # 使用set构建函数创建空set集合
set()
&gt;&gt;&gt; set((1, 2, 3 ,4))  # 使用set构建函数创建非空set集合
{1, 2, 3, 4}
&gt;&gt;&gt; set((1, 2, 3 ,['a', 'b', 'c']))  # set集合中的元素必须是不可变的、可哈希的
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'</code></pre> 
 <h4 id="set-和-frozenset都支持的操作">set 和 frozenset都支持的操作</h4> 
 <p>作为无序集合，set不记录元素位置或插入顺序。因此set不支持索引、切片或其他类序列行为。</p> 
 <pre><code>len(set)  # 获取集合中的条目个数
x in set  # 成员关系测试--包含
x not in set # 成员关系测试--不包含
for x in set  # 循环遍历集合中的条目
isdisjoint(other)  # 判断该集合是否与另外一个集合不相交(当且仅当交集为空)，不相交则返回True
issubset(other) 或 set &lt;= other  # 判断该集合是否是另外一个集合的子集
set &lt; other  # 判断该集合是否是另外一个集合的真子集
issuperset(other) 或 set &gt;= other  # 判断该集合是否是另外一个集合的父集
set &gt; other  # 判断该集合是否是另外一个集合的真父集
union(other,...) 或 set | other | ...  # 求该集合与另外一个或多个集合的并集
intersection(other,...) 或 set &amp; other &amp; ...  # 求该集合与另外一个或多个集合的交集
difference(other,...) 或 set - other - ...  # 求该集合与另外一个或多个集合的差集(该集合中存在但其它集合中不存在的元素集合)
symmetric_difference(other) 或 set ^ other  # 求该集合与另外一个集合的对称差集(该集合中存在但另一集合中不存在，或另一集合中存在但该集合中不存在的元素集合)
copy()  # 返回一个新的浅拷贝集合</code></pre> 
 <p><strong>说明：</strong></p> 
 <p>a) union()、intersection()、differnce()、symmetric_difference()、issubset() 和 issuperset()方法的可接受任何可迭对象作为参数。相比之下，它们的基于运算符的相应操作需要它们的参数是set。这避免了像set('abc') &amp; 'cbs'这样易出错的结构，有利于更易读的结构，如set('abc').intersection('cbs')。</p> 
 <pre><code>&gt;&gt;&gt; set('abc')
{'c', 'a', 'b'}
&gt;&gt;&gt; set('abc') &amp; 'cbs'  # 使用操作符进行相关操作，操作符两边都必须是set类型
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for &amp;: 'set' and 'str'
&gt;&gt;&gt; set('abc') &amp; set('cbs')
{'c', 'b'}
&gt;&gt;&gt; set('abc').intersection('cbs')  # 调用方法进行相关操作，参数可以是任意可迭代对象
{'c', 'b'}
&gt;&gt;&gt; set('abc').intersection(['c','s', 'b'])
{'c', 'b'}</code></pre> 
 <p>b) set和frozenset支持 集合与集合进行比较操作。</p> 
 <ul><li>当且仅当每个集合的每个元素都包含在另一个(每个集合都是另一个的子集)时，两个集合是相等的；</li><li>当且仅当第一集合是第二集合的真子集(是子集，但不相等)时，集合小于另一集合；</li><li>当且仅当第一集合是第二集合的真父集(是父集，但不相等)时，集合大于另一集合；</li></ul> 
 <p>c) set和frozenset之间是基于它们的成员进行比较的。比如set('abc') == frozenset('abc')返回True，因此set('abc') in set([frozenset('abc')])</p> 
 <pre><code>&gt;&gt;&gt; set('abc') == frozenset('abc')
True
&gt;&gt;&gt; set('abc') in frozenset('abc')
False
&gt;&gt;&gt; set('abc') in set(frozenset('abc'))
False
&gt;&gt;&gt; set('abc') in set([frozenset('abc')])
True</code></pre> 
 <p>d) 子集和相等的比较不推广到总排序函数。例如，任何两个非空且不相交的集合是不相等的，并且不是彼此的子集。因此，它们对应的以下操作都返回False: a&lt;b, a==b, a&gt;b。</p> 
 <p>e) 因为set之定义了部分排序(子集关系)，因此灭有为set的list定义list.sort()方法。</p> 
 <p>f) set集合的元素像dict的键一样，必须是可哈希的。</p> 
 <p>g) set实例与frozenset实例混合进行二进制操作将会返回第一个操作数的类型。例如：frozenset('ab')<br> | set('bc')会返回一个frozenset实例。</p> 
 <h4 id="set支持但frozenset不支持的操作">set支持但frozenset不支持的操作</h4> 
 <p>set是可变集合，而frozenset是不可变集合，因此set的有些修改操作是frozenset不支持的。</p> 
 <pre><code>add(elem)  # 向集合中添加一个元素
remove(elem)  # 从集合中删除一个元素，如果集合中不包含该元素会抛出KeyError错误
discard(elem)  # 如果集合中包含该元素则删除它，这个方法明显比remove()好用
pop()  # 由于set集合是无序的，因此该方法会移除并返回一个随机元素，而不是像list.pop()移除并返回最后一个元素
clear()  # 清除set集合中的所有元素
update(other,...) 或 set |= other | ...  # 更新set集合，将其它集合中的元素添加进来；简单点来说就是与其它一个或多个集合求并集并将结果赋值给自己
intersection_update(other,...) 或 set &amp;= other &amp; ...  # 更新set集合，只保留所有集合中都存在的元素；简单点来说就是与其它一个或多个集合求交集并将结果赋值为自己
difference_update(other,...) 或 set -= other | ...  # 与其它一个或多个集合求差集并将结果赋值给自己
symmetric_difference_update(other) 或 set ^= other  # 与另外一个集合求对称差集并将结果赋值给自己；对称差集就是A-B 与 B-A 的并集</code></pre> 
 <blockquote> 
  <p><strong><em>说明:</em></strong></p> 
  <p>上面这些update方法也是可以接受任何可迭代对象作为参数。另外，remove(elem)和discard(elem)等方法中参数elem可以是一个set集合。为了支持搜索等效的frozenset，elem集合会在搜索期间被暂时修改，然后恢复。在搜索期间，elem不应该被读取或改动，因为它没有有意义的值。</p> 
 </blockquote> 
 <h3 id="二映射类型mapping">二、映射类型(mapping)</h3> 
 <hr> 
 <p>一个mapping对象将可哈希的值映射为任意对象。映射是可变对象。目前Python中只有一种标准映射类型，就是字典(dict)。dcit和Set集合一样也是用花括号表示，但是花括号中的每个元素都是一个键值对(key:value)。字典中的键值对也是无序的，且key必须是可哈希的不可变类型，如字符串、数字、布尔值和不包含可变类型的tuple。而list和包含可变类型的tuple是不能做字典的key的。另外，同一个字典中，key不能重复，否则会覆盖之前的值。、</p> 
 <p>用于键的数字类型遵守数字比较的正常规则：如果两个数字比较相等（比如1和1.0），则它们可以互相使用以索引相同的字典条目。但是需要注意，由于计算机存储浮点数作为近似值，因此使用它们作为字典的键通常是不明智的。</p> 
 <h4 id="dict类构建函数">dict类构建函数</h4> 
 <pre><code>class dict(**kwarg)
class dict(mapping, **kwarg)
class dict(iterable, **kwarg)</code></pre> 
 <p>上面的dict构建函数会返回一个新的字典，这个新的字典是从一个可选的位置参数和一组可能为空关键字参数初始化的。</p> 
 <h4 id="dict的构建方式">dict的构建方式</h4> 
 <ul><li>将以逗号分隔的 key:value （键值对)列表放置在一对花括号中：{},{'Tom':1, 'Jerry':2, 'Peter':3}</li><li>使用不传递位置参数的构建函数，创建空字典：dict(),等同于{}</li><li>如果给定了位置参数，并且它是映射对象，则使用与该映射对象相同的键值对创建字典；否则，位置参数必须是可迭代对象。可迭代对象中的每个条目本身必须是具有两个对象的可迭代对象。每个条目的第一个对象将会成为新字典中的键，第二个对象将会成为对应的值。如果键多次出现，则该键的最后一个值将成为新字典中的相应值。</li><li>如果给出了关键字参数，则将关键字参数及其值添加到从位置参数创建的字典中。如果要添加的键已经存在，则来自关键字参数的值将替换位置参数中的值。</li></ul> 
 <h4 id="dict构建示例">dict构建示例</h4> 
 <p>空字典</p> 
 <pre><code>&gt;&gt;&gt; a = {}
&gt;&gt;&gt; a
{}
&gt;&gt;&gt; b = dict()
&gt;&gt;&gt; b
{}
&gt;&gt;&gt; a == b
True</code></pre> 
 <p>非空字典</p> 
 <pre><code>&gt;&gt;&gt; a = {'one': 1, 'two': 2, 'three': 3}  # 将以逗号分隔的键值对列表放置在一对花括号中
&gt;&gt;&gt; b = dict(one=1, two=2, three=3)  # 使用dict构建函数，并传递关键字参数
&gt;&gt;&gt; c = dict([('two', 2), ('one', 1), ('three', 3)])  # 使用dict构建函数，并传递可迭代对象为位置参数
&gt;&gt;&gt; d = dict({'three': 3, 'two': 2, 'one': 1})  # 使用dict构建函数，并传递可迭代对象作为位置参数
&gt;&gt;&gt; e = dict({'three': 3, 'two': 2, 'one': 1}, four=4, five=5)  # 使用dict构建函数，同时传递可迭代位置参数和关键字参数
&gt;&gt;&gt; e
{'five': 5, 'two': 2, 'three': 3, 'one': 1, 'four': 4}
&gt;&gt;&gt; a == b == c == d
True</code></pre> 
 <p>关于<code>[('one', 1), ('two', 2), ('three', 3)]</code>这种格式的列表我们可以通过zip类来创建(zip在Python 2.x中是一个内建函数，而在Python 3.x中是一个类)，zip类的构建函数如下：</p> 
 <pre><code>zip(iter1 [,iter2 [...]])</code></pre> 
 <p>为了方便查看效果，我们使用Python 2.x来做下实验：</p> 
 <pre><code>&gt;&gt;&gt; zip(['one', 'two', 'three'], [1, 2, 3])
[('one', 1), ('two', 2), ('three', 3)]
&gt;&gt;&gt; zip(['one', 'two', 'three'], [1, 2, 3], ('I', 'II', 'III'))
[('one', 1, 'I'), ('two', 2, 'II'), ('three', 3, 'III')]
&gt;&gt;&gt; zip(['one', 'two', 'three', 'four'], [1, 2, 3, 4], ('I', 'II', 'III'))  # 结果中的条目数与此处条目数最少的可迭代对象一致
[('one', 1, 'I'), ('two', 2, 'II'), ('three', 3, 'III')]</code></pre> 
 <h4 id="dict支持的操作">dict支持的操作</h4> 
 <pre><code>len(d)  # 返回字典d中的条目数
key in d  # 如果字典d中包含key这个键则返回True, 否则返回False
key not in d  # 与上面刚好相反

d[key]  # 返回key对应的条目的值，如果key不存在会抛出KeyError异常
get(key[, default])  # 如果key存在则返回其对应的值，否则返回default参数指定的值。如果default没有被指定，则default取None，因此该方法永远不会抛出KeyError异常。
setdefault(key[,default])  # 如果key存在则返回这个key对应的值，如果key不存在则插入一个键值对key:default并返回default的值。default默认值为None。
classmethod fromkeys(seq[,value]) # 这是个类方法，用于创建一个新的字典。seq序列中的元素将作为新字典中的key，而value将会是这些key共同的值，value默认为None。

copy()  # 返回该dict的一个浅拷贝

keys()  # 返回一个字典键的新视图
values()  # 返回一个字典值的新视图
items()  # 返回一个字典条目的新视图：(key, value)
iter(d)  # 返回字典键的一个迭代器，这是iter(d.keys())的简写方式

d[key] = value # 如果key不存在则表示新增一个条目，如果key已经存在则表示修改该条目的值
update([other])  # 用other中的键值对更新字典的内容，覆盖现有的key。other可以是一个字典对象或键/值对(比如长度为2的元组或其它可迭代对象)。如果指定了关键字参数，字典将会使用关键字参数对字典的键/值对更新，如：d.update(红色=1, 蓝色=2)

del d[key]  # 删除key对应的表木，如果key不存在会抛出KeyError异常
popitem()  # 从字典中删除并返回一个任意(key, value)对，如果字典为空会抛出KeyError异常。该方法对于破坏性的遍历字典很有用，常用于集合算法。
pop(key[,default])  # 如果key存在就删除它并返回它的值，否则返回default的值。如果default没有被给出并且key不存在，则抛出KeyError异常。
clear()  # 清空dict中的所有条目</code></pre> 
 <p>操作示例</p> 
 <pre><code>&gt;&gt;&gt; d = {'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt; len(d)
3
&gt;&gt;&gt; 'two' in d
True
&gt;&gt;&gt; 'two' not in d
False
&gt;&gt;&gt;
&gt;&gt;&gt; d['three']
3
&gt;&gt;&gt; d['four']
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 'four'
&gt;&gt;&gt; d.get('three')
3
&gt;&gt;&gt; d.get('four', 'default')
'default'
&gt;&gt;&gt; d
{'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt; d.setdefault('three', 'default')
3
&gt;&gt;&gt; d
{'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt; d.setdefault('four', 'default')
'default'
&gt;&gt;&gt; d
{'one': 1, 'two': 2, 'four': 'default', 'three': 3}
&gt;&gt;&gt; dict.fromkeys(['one', 'two', 'three'])
{'one': None, 'two': None, 'three': None}
&gt;&gt;&gt; dict.fromkeys(['one', 'two', 'three'], 'default')
{'one': 'default', 'two': 'default', 'three': 'default'}
&gt;&gt;&gt;
&gt;&gt;&gt; d.copy()
{'one': 1, 'two': 2, 'four': 'default', 'three': 3}
&gt;&gt;&gt; d['four'] = 4
&gt;&gt;&gt; d
{'one': 1, 'two': 2, 'four': 4, 'three': 3}
&gt;&gt;&gt; d['five'] = 5
&gt;&gt;&gt; d
{'one': 1, 'two': 2, 'five': 5, 'four': 4, 'three': 3}
&gt;&gt;&gt; d.update({'two': 'II', 'six': 6})
&gt;&gt;&gt; d
{'one': 1, 'two': 'II', 'four': 4, 'five': 5, 'six': 6, 'three': 3}
&gt;&gt;&gt; d.update(two=2, seven=7)
&gt;&gt;&gt; d
{'one': 1, 'two': 2, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'three': 3}
&gt;&gt;&gt; d.update([('three', 'III'), ('eight', 8)])
&gt;&gt;&gt; d
{'one': 1, 'two': 2, 'four': 4, 'five': 5, 'eight': 8, 'six': 6, 'seven': 7, 'three': 'III'}
&gt;&gt;&gt;
&gt;&gt;&gt; d.keys()
dict_keys(['one', 'two', 'four', 'five', 'eight', 'six', 'seven', 'three'])
&gt;&gt;&gt; d.values()
dict_values([1, 2, 4, 5, 8, 6, 7, 'III'])
&gt;&gt;&gt; d.items()
dict_items([('one', 1), ('two', 2), ('four', 4), ('five', 5), ('eight', 8), ('six', 6), ('seven', 7), ('three', 'III')])
&gt;&gt;&gt; iter(d)
&lt;dict_keyiterator object at 0x000001EA21A179A8&gt;
&gt;&gt;&gt; iter(d.keys())
&lt;dict_keyiterator object at 0x000001EA21A175E8&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; del d['eight']
&gt;&gt;&gt; d
{'one': 1, 'two': 2, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'three': 'III'}
&gt;&gt;&gt; d.popitem()
('one', 1)
&gt;&gt;&gt; d
{'two': 2, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'three': 'III'}
&gt;&gt;&gt; d.pop('three')
'III'
&gt;&gt;&gt; d
{'two': 2, 'four': 4, 'five': 5, 'six': 6, 'seven': 7}
&gt;&gt;&gt; d.pop('three')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 'three'
&gt;&gt;&gt; d.pop('three',None)
&gt;&gt;&gt; d.pop('three','default')
'default'
&gt;&gt;&gt; d.clear()
&gt;&gt;&gt; d.popitem()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 'popitem(): dictionary is empty'</code></pre> 
 <h4 id="字典视图对象dictionary-view-objects">字典视图对象(Dictionary view objects)</h4> 
 <p>对于dict.keys()、dict.values()和dict.items()这些函数，在Python 2.x中返回的是list对象，而在Python 3.x中返回的是一个叫做字典视图的对象。</p> 
 <p>python 2.x</p> 
 <pre><code>&gt;&gt;&gt; d = {'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt; d.keys()
['three', 'two', 'one']
&gt;&gt;&gt; d.values()
[3, 2, 1]
&gt;&gt;&gt; d.items()
[('three', 3), ('two', 2), ('one', 1)]</code></pre> 
 <p>python 3.x</p> 
 <pre><code>&gt;&gt;&gt; d = {'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt; dkeys = d.keys()
&gt;&gt;&gt; dkeys
dict_keys(['one', 'three', 'two'])
&gt;&gt;&gt; dvalues = d.values()
&gt;&gt;&gt; dvalues
dict_values([1, 3, 2])
&gt;&gt;&gt; ditems = d.items()
&gt;&gt;&gt; ditems
dict_items([('one', 1), ('three', 3), ('two', 2)])</code></pre> 
 <p>字典视图在字典条目上提供了一个动态视图，这意味着当字典发生变化时，相应的视图也会发生变化。要保存固定的值需要将字典视图强制转换为其他类型的对象进行保存，通常保存为list类型。</p> 
 <pre><code>&gt;&gt;&gt; d['four'] = 4
&gt;&gt;&gt; d
{'one': 1, 'three': 3, 'two': 2, 'four': 4}
&gt;&gt;&gt; dkeys
dict_keys(['one', 'three', 'two', 'four'])
&gt;&gt;&gt; dvalues
dict_values([1, 3, 2, 4])
&gt;&gt;&gt; ditems
dict_items([('one', 1), ('three', 3), ('two', 2), ('four', 4)])</code></pre> 
</div> 
<p>转载于:https://www.cnblogs.com/yyds/p/6123917.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4438c65a0284b2d63be96d2dd1264690/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CAS集群部署基于Redis缓存配置详细方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/835ace583796490e5bf78aad8926bf58/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">es6 javascript的Reflect 对象的方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>