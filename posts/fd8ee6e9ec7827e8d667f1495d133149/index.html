<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SHELL常用语法详细说明 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SHELL常用语法详细说明" />
<meta property="og:description" content="SHELL常用语法详细说明 1.获取从1970-01-01 00:00:00 UTC到现在的秒数（用于计算程序执行的时间）
cur_sec=`date &#39;&#43;%s&#39;` 2.单双引号的区别:
单引号：当shell碰到第一个单引号时，它忽略掉其后直到右引号的所有特殊字符，所以echo &#39;$X&#39;输出的是 $X 双引号：双引号作用与单引号类似，区别在于它没有那么严格。单引号告诉shell忽略所有特殊字符，而双引号只要求忽略大多数， 具体说，括在双引号中的三种特殊字符不被忽略：$,\,`, 即双引号会解释字符串的特别意思,而单引号直接使用字符串.如果使用双引号将字符串赋给变量并反馈它， 实际上与直接反馈变量并无差别。如果要查询包含空 格的字符串，经常会用到双引号 如：echo &#34;$X&#34; 会输出变量X的值，而不是$X 3.echo * 可以输出当前路径下的所有文件名
示例： x=*;echo $x shell扫描命令行，把x的值设为星号＊； shell再次扫描命令行，碰到星号＊，把它替换成当前目录下的文件清单； shell启动执行echo命令，把文件清单作为参数传递给echo. 这个赋值的先后次序非常重要：shell先作变量替换，然后作文件名替换，最后把这行处理为参数 4. 反引号(``)
命令替换是指shell能够将一个命令的标准输出插在一个命令行中任何位置。 shell中有两种方法作命令替换：把shell命令用反引号或者$(...)结构括起来，其中，$(...)格式受到POSIX标准支持，也利于嵌套 反引号和$()的功能是命令替换，将反引号或$()中的字符串做为命令来执行， 我们在用shell编程时经常用的到　将系统命令的执行结果赋给一个变量 但反引号内不能再引用反引号，而$()中可以引用反引号 如 echo date 输出的是date字符串 echo `date` 输出的就是日期字符串 将``内的字符串作为命令执行，然后再echo输出 $()同理 5.反斜杠 backslash-escaped( \ )
反斜杠一般用作转义字符,或称逃脱字符,linux如果echo要让转义字符发生作用,就要使用-e选项,且转义字符要使用双引号 echo -e &#34;\n&#34; 反斜杠的另一种作用,就是当反斜杠用于一行的最后一个字符时，shell把行尾的反斜杠作为续行，这种结构在分几行输入长命令时经常使用 6.给变量赋值时，不要在“=”两边留空格；最好是使用单引号或者双引号
name=xxxx; name=&#34;xxxxx&#34; name=&#39;xxxxxxxx&#39; 注意单双引号的区别 7.if-else语法：
if condition1 then statement1 elif condition2 then statement2 elif condition3 then statement3 …… else statementn fi （简单说就是只要出现if，不管是if还是elif都算，都必须跟一个then,涉及到有elif的，后续必须跟一个else,然后才能fi） 8." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/fd8ee6e9ec7827e8d667f1495d133149/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-06T14:21:29+08:00" />
<meta property="article:modified_time" content="2022-04-06T14:21:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SHELL常用语法详细说明</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="SHELL_0"></a>SHELL常用语法详细说明</h3> 
<p><strong>1.获取从1970-01-01 00:00:00 UTC到现在的秒数（用于计算程序执行的时间）</strong></p> 
<pre><code class="prism language-bash"><span class="token assign-left variable">cur_sec</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">date</span> <span class="token string">'+%s'</span><span class="token variable">`</span></span>
</code></pre> 
<p><strong>2.单双引号的区别:</strong></p> 
<pre><code class="prism language-bash">单引号：当shell碰到第一个单引号时，它忽略掉其后直到右引号的所有特殊字符，所以echo <span class="token string">'$X'</span>输出的是 <span class="token variable">$X</span>
双引号：双引号作用与单引号类似，区别在于它没有那么严格。单引号告诉shell忽略所有特殊字符，而双引号只要求忽略大多数，
				具体说，括在双引号中的三种特殊字符不被忽略：$,<span class="token punctuation">\</span>,`,
				即双引号会解释字符串的特别意思,而单引号直接使用字符串.如果使用双引号将字符串赋给变量并反馈它，
				实际上与直接反馈变量并无差别。如果要查询包含空 格的字符串，经常会用到双引号
				如：echo <span class="token string">"<span class="token variable">$X</span>"</span>  会输出变量X的值，而不是<span class="token variable">$X</span>
</code></pre> 
<p><strong>3.echo * 可以输出当前路径下的所有文件名</strong></p> 
<pre><code class="prism language-bash">  示例：
  <span class="token assign-left variable">x</span><span class="token operator">=</span>*<span class="token punctuation">;</span><span class="token builtin class-name">echo</span> <span class="token variable">$x</span>
  shell扫描命令行，把x的值设为星号＊；
	shell再次扫描命令行，碰到星号＊，把它替换成当前目录下的文件清单；
	shell启动执行echo命令，把文件清单作为参数传递给echo.
	这个赋值的先后次序非常重要：shell先作变量替换，然后作文件名替换，最后把这行处理为参数
</code></pre> 
<p><strong>4. 反引号(``)</strong></p> 
<pre><code class="prism language-bash">命令替换是指shell能够将一个命令的标准输出插在一个命令行中任何位置。
shell中有两种方法作命令替换：把shell命令用反引号或者<span class="token variable"><span class="token variable">$(</span><span class="token punctuation">..</span>.<span class="token variable">)</span></span>结构括起来，其中，<span class="token variable"><span class="token variable">$(</span><span class="token punctuation">..</span>.<span class="token variable">)</span></span>格式受到POSIX标准支持，也利于嵌套
反引号和<span class="token punctuation">$(</span><span class="token punctuation">)</span>的功能是命令替换，将反引号或<span class="token punctuation">$(</span><span class="token punctuation">)</span>中的字符串做为命令来执行，
我们在用shell编程时经常用的到　将系统命令的执行结果赋给一个变量 但反引号内不能再引用反引号，而<span class="token punctuation">$(</span><span class="token punctuation">)</span>中可以引用反引号
如 <span class="token builtin class-name">echo</span> <span class="token function">date</span>   输出的是date字符串
<span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">date</span><span class="token variable">`</span></span>    输出的就是日期字符串   将``内的字符串作为命令执行，然后再echo输出
<span class="token punctuation">$(</span><span class="token punctuation">)</span>同理
</code></pre> 
<p><strong>5.反斜杠 backslash-escaped( \ )</strong></p> 
<pre><code class="prism language-bash">反斜杠一般用作转义字符,或称逃脱字符,linux如果echo要让转义字符发生作用,就要使用-e选项,且转义字符要使用双引号
<span class="token builtin class-name">echo</span> -e <span class="token string">"<span class="token entity" title="\n">\n</span>"</span>
反斜杠的另一种作用,就是当反斜杠用于一行的最后一个字符时，shell把行尾的反斜杠作为续行，这种结构在分几行输入长命令时经常使用
</code></pre> 
<p><strong>6.给变量赋值时，不要在“=”两边留空格；最好是使用单引号或者双引号</strong></p> 
<pre><code class="prism language-bash"><span class="token assign-left variable">name</span><span class="token operator">=</span>xxxx<span class="token punctuation">;</span>   <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">"xxxxx"</span>    <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">'xxxxxxxx'</span>    注意单双引号的区别
</code></pre> 
<p><strong>7.if-else语法：</strong></p> 
<pre><code class="prism language-bash">	<span class="token keyword">if</span>  condition1
	<span class="token keyword">then</span>
 	  statement1
	<span class="token keyword">elif</span> condition2
	<span class="token keyword">then</span>
 	   statement2
	<span class="token keyword">elif</span> condition3
	<span class="token keyword">then</span>
	    statement3
	……
	<span class="token keyword">else</span>
	   statementn
	<span class="token keyword">fi</span>
（简单说就是只要出现if，不管是if还是elif都算，都必须跟一个then,涉及到有elif的，后续必须跟一个else,然后才能fi）

</code></pre> 
<p><strong>8.判断文件属性等：</strong></p> 
<pre><code class="prism language-bash"><span class="token shebang important">#!/bin/sh</span>
<span class="token comment"># 判断文件是否存在</span>
 
<span class="token assign-left variable">myPath</span><span class="token operator">=</span><span class="token string">"/var/log/httpd/"</span>
<span class="token assign-left variable">myFile</span><span class="token operator">=</span><span class="token string">"/var /log/httpd/access.log"</span>
 
<span class="token comment"># 这里的-x 参数判断$myPath是否存在并且是否具有可执行权限</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -x <span class="token string">"<span class="token variable">$myPath</span>"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
<span class="token function">mkdir</span> <span class="token string">"<span class="token variable">$myPath</span>"</span>
<span class="token keyword">fi</span>
<span class="token comment"># 这里的-d 参数判断$myPath是否存在</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -d <span class="token string">"<span class="token variable">$myPath</span>"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
<span class="token function">mkdir</span> <span class="token string">"<span class="token variable">$myPath</span>"</span>
<span class="token keyword">fi</span>
 
<span class="token comment"># 这里的-f参数判断$myFile是否存在</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -f <span class="token string">"<span class="token variable">$myFile</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
<span class="token function">touch</span> <span class="token string">"<span class="token variable">$myFile</span>"</span>
<span class="token keyword">fi</span>
<span class="token comment"># 其他参数还有-n,-n是判断一个变量是否是否有值</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -n <span class="token string">"<span class="token variable">$myVar</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
<span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$myVar</span> is empty"</span>
<span class="token builtin class-name">exit</span> <span class="token number">0</span>
<span class="token keyword">fi</span>
 
<span class="token comment"># 两个变量判断是否相等</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$var1</span>"</span> <span class="token operator">=</span> <span class="token string">"<span class="token variable">$var2</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
<span class="token builtin class-name">echo</span> <span class="token string">'$var1 eq $var2'</span>
<span class="token keyword">else</span>
<span class="token builtin class-name">echo</span> <span class="token string">'$var1 not eq $var2'</span>
<span class="token keyword">fi</span>

<span class="token comment">#shell判断文件夹是否存在</span>
 
<span class="token comment">#如果文件夹不存在，创建文件夹</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -d <span class="token string">"/myfolder"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
<span class="token function">mkdir</span> /myfolder
<span class="token keyword">fi</span>
 
<span class="token comment">#shell判断文件,目录是否存在或者具有权限</span>
 
<span class="token assign-left variable">folder</span><span class="token operator">=</span><span class="token string">"/var/www/"</span>
<span class="token assign-left variable">file</span><span class="token operator">=</span><span class="token string">"/var/www/log"</span>
 
<span class="token comment"># -x 参数判断 $folder 是否存在并且是否具有可执行权限</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -x <span class="token string">"<span class="token variable">$folder</span>"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
<span class="token function">mkdir</span> <span class="token string">"<span class="token variable">$folder</span>"</span>
<span class="token keyword">fi</span>
 
<span class="token comment"># -d 参数判断 $folder 是否存在</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -d <span class="token string">"<span class="token variable">$folder</span>"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
<span class="token function">mkdir</span> <span class="token string">"<span class="token variable">$folder</span>"</span>
<span class="token keyword">fi</span>
 
<span class="token comment"># -f 参数判断 $file 是否存在</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -f <span class="token string">"<span class="token variable">$file</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
<span class="token function">touch</span> <span class="token string">"<span class="token variable">$file</span>"</span>
<span class="token keyword">fi</span>
 
<span class="token comment"># -n 判断一个变量是否有值</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -n <span class="token string">"<span class="token variable">$var</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
<span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$var</span> is empty"</span>
<span class="token builtin class-name">exit</span> <span class="token number">0</span>
<span class="token keyword">fi</span>
 
<span class="token comment"># 判断两个变量是否相等</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$var1</span>"</span> <span class="token operator">=</span> <span class="token string">"<span class="token variable">$var2</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
<span class="token builtin class-name">echo</span> <span class="token string">'$var1 eq $var2'</span>
<span class="token keyword">else</span>
<span class="token builtin class-name">echo</span> <span class="token string">'$var1 not eq $var2'</span>
<span class="token keyword">fi</span>

<span class="token comment"># 判断两个字符串是否相同</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$var1</span>"</span>X <span class="token operator">=</span> <span class="token string">"<span class="token variable">$var2</span>"</span>X <span class="token punctuation">]</span>
<span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"相等"</span>
<span class="token keyword">fi</span>

<span class="token comment">#if - elif - else -fi</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$var</span>"</span>X <span class="token operator">=</span> <span class="token string">"yes"</span>X <span class="token punctuation">]</span>
<span class="token keyword">then</span>
   <span class="token builtin class-name">echo</span> <span class="token string">"yes"</span>
<span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$var</span>"</span>X <span class="token operator">=</span> <span class="token string">"no"</span>X <span class="token punctuation">]</span>
<span class="token keyword">then</span>
   <span class="token builtin class-name">echo</span> <span class="token string">"no"</span>
<span class="token keyword">else</span>
   <span class="token builtin class-name">echo</span> <span class="token string">"非法"</span>
<span class="token keyword">fi</span>

<span class="token comment">#数字判断大小</span>
<span class="token comment">#-gt是大于</span>
<span class="token comment">#-lt是小于</span>
<span class="token comment">#-eq是等于</span>
<span class="token comment">#-ne是不等于</span>
<span class="token comment">#-ge是大于等于</span>
<span class="token comment">#le是小于等于</span>
<span class="token comment">#且字符数字可以直接用来和数字进行比较大小，不需要进行转化为数字</span>
<span class="token assign-left variable">var</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">echo</span> <span class="token string">"55"</span><span class="token variable">`</span></span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$var</span> -eq <span class="token number">55</span> <span class="token punctuation">]</span>
<span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"等于55"</span>
<span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"不等于55"</span>
<span class="token keyword">fi</span>
</code></pre> 
<p><strong>9.shell中引用函数问题(注意定义要在引用前，且函数名和大括号之间有空格)</strong></p> 
<pre><code class="prism language-bash"><span class="token comment">#1.函数的定义</span>
   <span class="token keyword">function</span> <span class="token function-name function">func1</span> <span class="token punctuation">{<!-- --></span>
   
   <span class="token punctuation">}</span>
<span class="token comment">#2.无参函数调用：函数名</span>
func1

<span class="token comment">#3.函数的输入参数</span>
<span class="token keyword">function</span> <span class="token function-name function">func2</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">#定义变量avr1获取函数第一个参数</span>
    <span class="token assign-left variable">var1</span><span class="token operator">=</span><span class="token variable">$1</span>
    <span class="token comment">#var2获取函数第二个参数</span>
    <span class="token assign-left variable">var2</span><span class="token operator">=</span><span class="token variable">$2</span>
  
     代码处理

<span class="token punctuation">}</span>
<span class="token comment">#4.有参函数调用：函数名 参数</span>
<span class="token comment">#g_var1和g_var2是外部变量，也可以是固定的值</span>
func2 <span class="token variable">$g_var1</span> <span class="token variable">$g_var2</span>

<span class="token comment">#5.函数返回值，有两种：</span>
<span class="token comment">#5.1.通过return 数值；然后使用$?来获取</span>
<span class="token comment">#	说明：$?是接收上一条函数的执行结果，$?接收函数的执行结果，执行结果其实就是其返回值，就是return 传出来的数值（return只能是数字，不能是字符串之类的），如果函数中没有显式调用return返回出来状态，那么系统会使用函数中最后一条shell指令的执行结果作为返回值，如果函数A最后一条指令调用其他函数B，如：那么A的返回值就是B的返回值。</span>
<span class="token comment">#	用$?来接收函数的执行状态，但是$?要紧跟在函数调用处的后面</span>
<span class="token comment">#示例：</span>
    <span class="token comment">#函数定义，需在调用之前</span>
<span class="token keyword">function</span> <span class="token function-name function">test</span> <span class="token punctuation">{<!-- --></span>
    代码处理
    <span class="token keyword">if</span> <span class="token punctuation">[</span> contidion <span class="token punctuation">]</span>
    <span class="token keyword">then</span>
        <span class="token builtin class-name">return</span> <span class="token number">2</span>
    <span class="token keyword">else</span>
        <span class="token builtin class-name">return</span> <span class="token number">1</span>
    <span class="token keyword">fi</span>
<span class="token punctuation">}</span>
<span class="token comment">#函数调用</span>
<span class="token builtin class-name">test</span>
<span class="token comment">#函数调用后，立即使用$?来获取返回值，并保存在变量RESULT中</span>
<span class="token assign-left variable">RESULT</span><span class="token operator">=</span><span class="token variable">$?</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$RESULT</span>

<span class="token comment">#5.2.通过标准输出流，输出信息，使用变量和命令替换符``来获取</span>
<span class="token comment">#用变量接收函数返回值，函数用echo等标准输出将要返回的东西打印出来。</span>
<span class="token keyword">function</span> <span class="token function-name function">test</span> <span class="token punctuation">{<!-- --></span>
    代码处理
    <span class="token keyword">if</span> <span class="token punctuation">[</span> contidion <span class="token punctuation">]</span>
    <span class="token keyword">then</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"2"</span>
    <span class="token keyword">else</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"1"</span>
    <span class="token keyword">fi</span>
<span class="token punctuation">}</span>
<span class="token comment">#函数执行结果标准输出的数字存在RESULT中。由于echo是数字字符，作用类似于return</span>
<span class="token comment">#它几乎就是return和echo不一样，但是有一点一定要注意，不能向标准输出一些不是结果的d数据</span>
<span class="token comment">#比如调试信息，这些信息可以重定向到一个文件中解决，特别要注意的是，脚本中用到其它类似grep这样的命令的时候，一定要记得1&gt;/dev/null 2&gt;&amp;1来空这些输出信息输出到空设备，避免这些命令的输出，后续17做解释</span>
<span class="token assign-left variable">RESULT</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">test</span><span class="token variable">`</span></span>

<span class="token comment">#5.3 echo + return 同时使用</span>
<span class="token keyword">function</span> <span class="token function-name function">test</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">#代码处理</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"hello"</span>
    <span class="token builtin class-name">return</span> <span class="token number">100</span>
<span class="token punctuation">}</span>
<span class="token assign-left variable">RESULT</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">test</span><span class="token variable">`</span></span>
<span class="token comment"># $?需要在函数执行后，立即获取，中间不能有其他命令执行</span>
<span class="token assign-left variable">VAL</span><span class="token operator">=</span><span class="token variable">$?</span>
<span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$RESULT</span>"</span>
<span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$VAL</span>"</span>

<span class="token comment">#运行结果是：</span>
hello
<span class="token number">100</span>
</code></pre> 
<p><strong>10.使用expr 计算时，注意空格</strong></p> 
<pre><code class="prism language-bash"><span class="token assign-left variable">var1</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $var1 + <span class="token number">1</span><span class="token variable">`</span></span> <span class="token punctuation">(</span>注意加号左右两边的空格<span class="token punctuation">)</span>
</code></pre> 
<p><strong>11.tail命令</strong></p> 
<pre><code class="prism language-bash">   <span class="token function">tail</span> -n filename <span class="token punctuation">(</span>打印filename文件的后n行<span class="token punctuation">)</span>
   <span class="token function">tail</span> -f filename  <span class="token punctuation">(</span>实时更新文件最后多少行，应该是新出现多少就更新多少<span class="token punctuation">)</span>
</code></pre> 
<p><strong>12.head命令</strong></p> 
<pre><code class="prism language-bash"><span class="token function">head</span> -n filename <span class="token punctuation">(</span>打印文件前n行<span class="token punctuation">)</span>
</code></pre> 
<p><strong>13. awk命令</strong></p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"xxx,yy,zz,ddd"</span><span class="token operator">|</span><span class="token function">awk</span> -F , <span class="token string">'{print $1}'</span>   <span class="token punctuation">(</span>使用逗号作为分隔符，进行字段划分，且打印分隔后的第1个字段<span class="token punctuation">)</span>
</code></pre> 
<p><strong>14.sed命令</strong></p> 
<pre><code class="prism language-bash"><span class="token comment">#将filename文件中的xx替换为yyy（一行出现多个xx时，只替换第一个）</span>
<span class="token function">sed</span> s/xx/yyy  filename
<span class="token comment">#全部替换</span>
<span class="token function">sed</span> s/xx/yyy/g filename
<span class="token comment">#打印filename的第count行</span>
<span class="token function">sed</span> -n <span class="token string">"<span class="token variable">$count</span>"</span>p filename    
<span class="token comment">#a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)</span>
<span class="token function">sed</span> <span class="token string">'2a drink tea'</span>  <span class="token comment">#在第二行后(亦即是加在第三行)加上『drink tea?』字样</span>
</code></pre> 
<p><strong>15.while循环 实现for循环（递增）</strong></p> 
<pre><code class="prism language-bash">	 <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">1</span>
	 <span class="token assign-left variable">total</span><span class="token operator">=</span><span class="token number">100</span>
   <span class="token keyword">while</span> <span class="token punctuation">[</span> count -le <span class="token variable">$total</span> <span class="token punctuation">]</span>
   <span class="token keyword">do</span>
       <span class="token builtin class-name">echo</span> <span class="token variable">$count</span>
       <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $count + <span class="token number">1</span><span class="token variable">`</span></span>
       <span class="token comment">#此处引申一下，字符串也可以如此拼接：str=$str"val",将原来str的值加上val作为新的字符串，赋值给str变量</span>
   <span class="token keyword">done</span>
</code></pre> 
<pre><code class="prism language-bash"><span class="token comment">#死循环:每10s判断condition是否成立，成立则退出while循环，不成立则sleep 10继续判断</span>
<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token number">1</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
	<span class="token keyword">if</span> <span class="token punctuation">[</span> condition <span class="token punctuation">]</span>
	<span class="token keyword">then</span>
	    <span class="token comment">#达到条件退出</span>
	    <span class="token builtin class-name">break</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
	    <span class="token function">sleep</span> <span class="token number">10</span>
	<span class="token keyword">fi</span>
<span class="token keyword">done</span>
</code></pre> 
<p><strong>16.shell中的if条件判断 且 或</strong></p> 
<pre><code class="prism language-bash"><span class="token comment">#且：</span>
<span class="token comment">#	方法1：</span>
	<span class="token keyword">if</span> <span class="token punctuation">[</span> c1 -a c2 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
	…
	<span class="token keyword">fi</span>
<span class="token comment">#	方法2：</span>
	<span class="token keyword">if</span> <span class="token punctuation">[</span> c1 <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">[</span> c2 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
	…
	<span class="token keyword">fi</span>
</code></pre> 
<pre><code class="prism language-bash"><span class="token comment">#或：</span>
<span class="token comment">#	方法1：</span>
	<span class="token keyword">if</span> <span class="token punctuation">[</span> c1 -o c2 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
	…
	<span class="token keyword">fi</span>
<span class="token comment">#	方法2：</span>
	<span class="token keyword">if</span> <span class="token punctuation">[</span> c1 <span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span>  c2 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
	…
	<span class="token keyword">fi</span>
</code></pre> 
<p><strong>17.输出重定向到空设备文件1＞/dev/null 2＞&amp;1</strong></p> 
<pre><code class="prism language-bash"><span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>/dev/null <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span>
<span class="token comment">#命令解释：</span>
<span class="token comment">#1.标准输入stdin文件描述符为0，标准输出stdout文件描述符为1，标准错误stderr文件描述符为2</span>
<span class="token comment">#2./dev/null 空设备文件，相当于垃圾桶</span>
<span class="token comment">#3.重定向符号：&gt;</span>
<span class="token comment">#故：将stdout标准输出重定向到空设备文件/dev/null ，同时将stderr标准错误输出的重定向跟stdout标准输出重定向一致，也输出到空设备文件/dev/null。</span>
示例：
<span class="token comment">#抛弃grep的结果</span>
<span class="token function">grep</span> <span class="token string">"xxxx"</span> filename <span class="token operator">|</span> <span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>/dev/null <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span>
<span class="token comment">#丢弃filename的显示内容</span>
<span class="token function">cat</span> filename <span class="token operator">&gt;</span> /dev/null

</code></pre> 
<p><strong>18.shel常用特殊变量</strong></p> 
<pre><code class="prism language-bash"><span class="token variable">$#</span> 代表传入参数的个数
<span class="token variable">$@</span> 代表传入参数的列表
<span class="token variable">$0</span> 代表脚本本身
<span class="token variable">$1</span> 代表传入的第一个参数，<span class="token variable">$2</span>，<span class="token variable">$3</span><span class="token punctuation">..</span>.以此类推
<span class="token variable">$*</span> 以字符串方式显示所有传入的参数
<span class="token variable">$$</span> 脚本运行的进程ID
<span class="token variable">$?</span> 显示最后命令的退出状况，0表示没有错误
<span class="token variable">${<!-- --><span class="token operator">#</span>str}</span> 获取str字符变量的长度
<span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">10</span><span class="token operator">*</span><span class="token number">10</span><span class="token variable">))</span></span>  进行算术运算；linux系统下，随时进行计算，不需要打开计算器。
</code></pre> 
<p><strong>19./dev/null</strong><br> /dev/null：在类Unix系统中，/dev/null，或称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF。<br> 在程序员行话，尤其是Unix行话中，/dev/null 被称为位桶(bit bucket)或者黑洞(black hole)。空设备通常被用于丢弃不需要的输出流，或作为用于输入流的空文件。这些操作通常由重定向完成。<br> /dev/null 的日常使用:把/dev/null看作"黑洞"。它等价于一个只写文件，并且所有写入它的内容都会永远丢失，而尝试从它那儿读取内容则什么也读不到。然而, /dev/null对命令行和脚本都非常的有用。<br> 我们都知道 <code>cat $filename</code> 会输出filename对应的文件内容（输出到标准输出）<br> 而使用<code>cat $filename &gt;/dev/null</code> 则不会得到任何信息，因为我们将本来该通过标准输出显示的文件信息重定向到了 /dev/null;使用 <code>cat $filename 1&gt;/dev/null</code> 也会得到同样的效果,因为默认重定向的 1 就是标准输出<br> 使用 <code>cat $filename</code> 时如果filename对应的文件不存在，系统肯定会报错： “ cat: filename: 没有那个文件或目录 ” 。<br> 如果我们不想看到错误输出呢？我们可以禁止标准错误: cat $badname 2&gt;/dev/null<br> 有些时候，我并不想看道任何输出，我只想看到这条命令运行是不是正常，那么我们可以同时禁止标准输出和标准错误的输出:</p> 
<pre><code>   cat $filename &gt;/dev/null 2&gt;&amp;1
   #解释:1. &gt;/dev/null	这条命令的作用是将标准输出1重定向到/dev/null中。
   	     2. 2&gt;&amp;1   这条命令用到了重定向绑定，采用&amp;可以将两个输出绑定在一起。这条命令的作用是错误输出将和标准输出同用一个文件描述符，就是错误输出将会和标准输出输出到同一个地方。
</code></pre> 
<p>linux在执行shell命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令，所以&gt;/dev/null 2&gt;&amp;1的作用就是让标准输出重定向到/dev/null中（丢弃标准输出），然后错误输出由于重用了标准输出的描述符，所以错误输出也被定向到了/dev/null中，错误输出同样也被丢弃了。执行了这条命令之后，该条shell命令将不会输出任何信息到控制台，也不会有任何信息输出到文件中。</p> 
<pre><code class="prism language-c"><span class="token operator">&gt;</span><span class="token operator">/</span>dev<span class="token operator">/</span>null <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span> 与 <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span> <span class="token operator">&gt;</span><span class="token operator">/</span>dev<span class="token operator">/</span>null的区别
</code></pre> 
<p>乍眼看这两条命令貌似是等同的，但其实大为不同。<br> inux在执行shell命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令。那么我们同样从左到右地来分析<code>2&gt;&amp;1 &gt;/dev/null：</code></p> 
<pre><code class="prism language-bash"><span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span>：将错误输出绑定到标准输出上。由于此时的标准输出是默认值，也就是输出到屏幕，所以错误输出会输出到屏幕。
<span class="token operator">&gt;</span>/dev/null：将标准输出1重定向到/dev/null中。
<span class="token operator">&gt;</span>
</code></pre> 
<p>我们用一个表格来更好地说明这两条命令的区别：</p> 
<table><thead><tr><th>命令</th><th>标准输出</th><th>错误输出</th></tr></thead><tbody><tr><td>&gt;/dev/null 2&gt;&amp;1</td><td>丢弃</td><td>丢弃</td></tr><tr><td>2&gt;&amp;1 &gt;/dev/null</td><td>丢弃</td><td>屏幕</td></tr></tbody></table> 
<pre><code class="prism language-bash"><span class="token operator">&gt;</span>/dev/null <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span> 与 <span class="token operator">&gt;</span>/dev/null <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>/dev/null区别
</code></pre> 
<p>那么可能会有些同学会疑问，为什么要用重定向绑定，而不是像&gt;/dev/null 2&gt;/dev/null这样子重复一遍呢。</p> 
<p>为了回答这个问题，我们回到刚才介绍输出重定向的场景。我们尝试将标准输出和错误输出都定向到out文件中：</p> 
<pre><code class="prism language-bash"><span class="token comment"># ls a.txt b.txt &gt;out 2&gt;out</span>
<span class="token comment"># cat out</span>
a.txt
�法访问b.txt: 没有那个文件或目录
</code></pre> 
<p>竟然出现了乱码，这是为啥呢？这是因为采用这种写法，标准输出和错误输出会抢占往out文件的管道，所以可能会导致输出内容的时候出现缺失、覆盖等情况。现在是出现了乱码，有时候也有可能出现只有error信息或者只有正常信息的情况。不管怎么说，采用这种写法，最后的情况是无法预估的。</p> 
<p>而且，由于out文件被打开了两次，两个文件描述符会抢占性的往文件中输出内容，所以整体IO效率不如&gt;/dev/null 2&gt;&amp;1来得高。</p> 
<p><strong>nohup结合</strong><br> 我们经常使用nohup command &amp;命令形式来启动一些后台程序，比如一些java服务：</p> 
<pre><code class="prism language-bash"><span class="token function">nohup</span> java -jar xxxx.jar <span class="token operator">&amp;</span>
<span class="token comment">#输出信息会输出到nohup.out文件中</span>
</code></pre> 
<p>为了不让一些执行信息输出，我们还会加上刚才提到的&gt;/dev/null 2&gt;&amp;1命令来丢弃所有的输出：</p> 
<pre><code class="prism language-bash"><span class="token function">nohup</span> java -jar xxxx.jar <span class="token operator">&gt;</span>/dev/null <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">&amp;</span>
</code></pre> 
<p><strong>20.uniq与sort -u 两种去重的区别</strong><br> <code>uniq</code>所谓的重复是连续出现的相同记录会被去掉<br> <code>sort -u</code> 是所有记录中，相同的记录都会被去掉</p> 
<p><strong>21.grep 命令</strong><br> Linux grep 命令用于查找文件里符合条件的字符串。<br> grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。</p> 
<pre><code class="prism language-bash">-a 或 --text <span class="token builtin class-name">:</span> 不要忽略二进制的数据。
-A<span class="token operator">&lt;</span>显示行数<span class="token operator">&gt;</span> 或 --after-context<span class="token operator">=</span><span class="token operator">&lt;</span>显示行数<span class="token operator">&gt;</span> <span class="token builtin class-name">:</span> 除了显示符合范本样式的那一列之外，并显示该行之后的内容。
-b 或 --byte-offset <span class="token builtin class-name">:</span> 在显示符合样式的那一行之前，标示出该行第一个字符的编号。
-B<span class="token operator">&lt;</span>显示行数<span class="token operator">&gt;</span> 或 --before-context<span class="token operator">=</span><span class="token operator">&lt;</span>显示行数<span class="token operator">&gt;</span> <span class="token builtin class-name">:</span> 除了显示符合样式的那一行之外，并显示该行之前的内容。
-c 或 --count <span class="token builtin class-name">:</span> 计算符合样式的列数。
-C<span class="token operator">&lt;</span>显示行数<span class="token operator">&gt;</span> 或 --context<span class="token operator">=</span><span class="token operator">&lt;</span>显示行数<span class="token operator">&gt;</span>或-<span class="token operator">&lt;</span>显示行数<span class="token operator">&gt;</span> <span class="token builtin class-name">:</span> 除了显示符合样式的那一行之外，并显示该行之前后的内容。
-d <span class="token operator">&lt;</span>动作<span class="token operator">&gt;</span> 或 --directories<span class="token operator">=</span><span class="token operator">&lt;</span>动作<span class="token operator">&gt;</span> <span class="token builtin class-name">:</span> 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。
-e<span class="token operator">&lt;</span>范本样式<span class="token operator">&gt;</span> 或 --regexp<span class="token operator">=</span><span class="token operator">&lt;</span>范本样式<span class="token operator">&gt;</span> <span class="token builtin class-name">:</span> 指定字符串做为查找文件内容的样式。
-E 或 --extended-regexp <span class="token builtin class-name">:</span> 将样式为延伸的正则表达式来使用。
-f<span class="token operator">&lt;</span>规则文件<span class="token operator">&gt;</span> 或 --file<span class="token operator">=</span><span class="token operator">&lt;</span>规则文件<span class="token operator">&gt;</span> <span class="token builtin class-name">:</span> 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。
-F 或 --fixed-regexp <span class="token builtin class-name">:</span> 将样式视为固定字符串的列表。
-G 或 --basic-regexp <span class="token builtin class-name">:</span> 将样式视为普通的表示法来使用。
-h 或 --no-filename <span class="token builtin class-name">:</span> 在显示符合样式的那一行之前，不标示该行所属的文件名称。
-H 或 --with-filename <span class="token builtin class-name">:</span> 在显示符合样式的那一行之前，表示该行所属的文件名称。
-i 或 --ignore-case <span class="token builtin class-name">:</span> 忽略字符大小写的差别。
-l 或 --file-with-matches <span class="token builtin class-name">:</span> 列出文件内容符合指定的样式的文件名称。
-L 或 --files-without-match <span class="token builtin class-name">:</span> 列出文件内容不符合指定的样式的文件名称。
-n 或 --line-number <span class="token builtin class-name">:</span> 在显示符合样式的那一行之前，标示出该行的列数编号。
-o 或 --only-matching <span class="token builtin class-name">:</span> 只显示匹配PATTERN 部分。
-q 或 --quiet或--silent <span class="token builtin class-name">:</span> 不显示任何信息。
-r 或 --recursive <span class="token builtin class-name">:</span> 此参数的效果和指定<span class="token string">"-d recurse"</span>参数相同。
-s 或 --no-messages <span class="token builtin class-name">:</span> 不显示错误信息。
-v 或 --invert-match <span class="token builtin class-name">:</span> 显示不包含匹配文本的所有行。
-V 或 --version <span class="token builtin class-name">:</span> 显示版本信息。
-w 或 --word-regexp <span class="token builtin class-name">:</span> 只显示全字符合的列。
-x --line-regexp <span class="token builtin class-name">:</span> 只显示全列符合的列。
-y <span class="token builtin class-name">:</span> 此参数的效果和指定<span class="token string">"-i"</span>参数相同。
</code></pre> 
<p>–未完待续–</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/747aca7a8ee0a7b2e97a9c7131ebba64/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据安全--KMS</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/34bf92a66691fc46ee346af649c38d8a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux安装matlabRuntime</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>