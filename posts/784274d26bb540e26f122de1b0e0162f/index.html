<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>React详解(CDN引入、JSX、脚手架、类组件、函数组件、事件、Hooks、生命周期方法、Ref使用、注意点) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="React详解(CDN引入、JSX、脚手架、类组件、函数组件、事件、Hooks、生命周期方法、Ref使用、注意点)" />
<meta property="og:description" content="目录
React
CDN引入
开发版本
压缩版本（生产环境） React.createElement(str,obj,innerHTML)
ReactDOM.render(h3,ele)
JSX
使用
注释
数组
内联渲染样式
脚手架
创建项目包
安装VScode插件 JSX 提示
​编辑
类组件
接收参数
state状态
setState(state,callback)
defaultProps this.forceUpdate(callback)
函数组件
接收参数 defaultProps props.children
注意点 事件
绑定this
bind绑定this
箭头函数绑定this
事件池
Hooks
Ref使用详解
React生命周期和错误处理方法
注意点 img标签
React react项目是SPA（Single web Page Application单页网页应用）项目，整个网站只有一个页面，通过路由切换页面中局部的内容，实现页面的变更。
CDN引入 注意下面引入的2个文件，React负责创建元素，ReactDom负责渲染元素到其它元素中。
开发版本 &lt;script crossorigin src=&#34;https://unpkg.com/react@17/umd/react.development.js&#34;&gt;&lt;/script&gt; &lt;script crossorigin src=&#34;https://unpkg.com/react-dom@17/umd/react-dom.development.js&#34;&gt;&lt;/script&gt; 压缩版本（生产环境） &lt;script crossorigin src=&#34;https://unpkg.com/react@17/umd/react.production.min.js&#34;&gt;&lt;/script&gt; &lt;script crossorigin src=&#34;https://unpkg.com/react-dom@17/umd/react-dom.production.min.js&#34;&gt;&lt;/script&gt; React.createElement(str,obj,innerHTML) 利用React创建元素，其中str为标签的名，obj对象上的属性为该标签上挂载的属性，innerHTML为标签内的文本内容。
let h3 = React.createElement(&#39;h3&#39;,{id:&#39;time&#39;,className:&#39;danger&#39;},&#39;时间&#39;) ReactDOM.render(h3,ele) 其中h3为上面React.createElement的返回变量，ele为dom节点。
下面利用ReactDOM渲染h3元素到id为‘yf’的节点上。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/784274d26bb540e26f122de1b0e0162f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-28T19:16:43+08:00" />
<meta property="article:modified_time" content="2022-11-28T19:16:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">React详解(CDN引入、JSX、脚手架、类组件、函数组件、事件、Hooks、生命周期方法、Ref使用、注意点)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="React-toc" style="margin-left:0px;"><a href="#React" rel="nofollow">React</a></p> 
<p id="CDN%E5%BC%95%E5%85%A5-toc" style="margin-left:0px;"><a href="#CDN%E5%BC%95%E5%85%A5" rel="nofollow">CDN引入</a></p> 
<p id="%E5%BC%80%E5%8F%91%E7%89%88%E6%9C%AC-toc" style="margin-left:40px;"><a href="#%E5%BC%80%E5%8F%91%E7%89%88%E6%9C%AC" rel="nofollow">开发版本</a></p> 
<p id="%E5%8E%8B%E7%BC%A9%E7%89%88%E6%9C%AC%EF%BC%88%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%EF%BC%89%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%8E%8B%E7%BC%A9%E7%89%88%E6%9C%AC%EF%BC%88%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%EF%BC%89%C2%A0" rel="nofollow">压缩版本（生产环境） </a></p> 
<p id="React.createElement(str%2Cobj%2CinnerHTML)-toc" style="margin-left:0px;"><a href="#React.createElement%28str%2Cobj%2CinnerHTML%29" rel="nofollow">React.createElement(str,obj,innerHTML)</a></p> 
<p id="ReactDOM.render(h3%2Cele)-toc" style="margin-left:0px;"><a href="#ReactDOM.render%28h3%2Cele%29" rel="nofollow">ReactDOM.render(h3,ele)</a></p> 
<p id="JSX-toc" style="margin-left:0px;"><a href="#JSX" rel="nofollow">JSX</a></p> 
<p id="%C2%A0%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%BD%BF%E7%94%A8" rel="nofollow"> 使用</a></p> 
<p id="%E6%B3%A8%E9%87%8A-toc" style="margin-left:40px;"><a href="#%E6%B3%A8%E9%87%8A" rel="nofollow">注释</a></p> 
<p id="%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#%E6%95%B0%E7%BB%84" rel="nofollow">数组</a></p> 
<p id="%E5%86%85%E8%81%94%E6%B8%B2%E6%9F%93%E6%A0%B7%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E5%86%85%E8%81%94%E6%B8%B2%E6%9F%93%E6%A0%B7%E5%BC%8F" rel="nofollow">内联渲染样式</a></p> 
<p id="%E8%84%9A%E6%89%8B%E6%9E%B6-toc" style="margin-left:0px;"><a href="#%E8%84%9A%E6%89%8B%E6%9E%B6" rel="nofollow">脚手架</a></p> 
<p id="%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%8C%85-toc" style="margin-left:40px;"><a href="#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%8C%85" rel="nofollow">创建项目包</a></p> 
<p id="%E5%AE%89%E8%A3%85VScode%E6%8F%92%E4%BB%B6%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%AE%89%E8%A3%85VScode%E6%8F%92%E4%BB%B6%C2%A0" rel="nofollow">安装VScode插件 </a></p> 
<p id="JSX%C2%A0%E6%8F%90%E7%A4%BA-toc" style="margin-left:40px;"><a href="#JSX%C2%A0%E6%8F%90%E7%A4%BA" rel="nofollow">JSX 提示</a></p> 
<p id="%E2%80%8B-toc" style="margin-left:40px;"><a href="#%E2%80%8B" rel="nofollow">​编辑</a></p> 
<p id="%E7%B1%BB%E7%BB%84%E4%BB%B6-toc" style="margin-left:0px;"><a href="#%E7%B1%BB%E7%BB%84%E4%BB%B6" rel="nofollow">类组件</a></p> 
<p id="%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0" rel="nofollow">接收参数</a></p> 
<p id="state%E7%8A%B6%E6%80%81-toc" style="margin-left:40px;"><a href="#state%E7%8A%B6%E6%80%81" rel="nofollow">state状态</a></p> 
<p id="setState(state%2Ccallback)-toc" style="margin-left:80px;"><a href="#setState%28state%2Ccallback%29" rel="nofollow">setState(state,callback)</a></p> 
<p id="defaultProps%C2%A0-toc" style="margin-left:40px;"><a href="#defaultProps%C2%A0" rel="nofollow">defaultProps </a></p> 
<p id="props.children-toc" style="margin-left:40px;"><a href="#props.children" rel="nofollow">this.forceUpdate(callback)</a></p> 
<p id="%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6-toc" style="margin-left:0px;"><a href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6" rel="nofollow">函数组件</a></p> 
<p id="%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%C2%A0-toc" style="margin-left:40px;"><a href="#%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%C2%A0" rel="nofollow">接收参数 </a></p> 
<p id="defaultProps%C2%A0-toc" style="margin-left:40px;"><a href="#defaultProps%C2%A0" rel="nofollow">defaultProps </a></p> 
<p id="props.children-toc" style="margin-left:40px;"><a href="#props.children" rel="nofollow">props.children</a></p> 
<p id="%E6%B3%A8%E6%84%8F%E7%82%B9%C2%A0-toc" style="margin-left:40px;"><a href="#%E6%B3%A8%E6%84%8F%E7%82%B9%C2%A0" rel="nofollow">注意点 </a></p> 
<p id="%E4%BA%8B%E4%BB%B6-toc" style="margin-left:0px;"><a href="#%E4%BA%8B%E4%BB%B6" rel="nofollow">事件</a></p> 
<p id="%E7%BB%91%E5%AE%9Athis-toc" style="margin-left:40px;"><a href="#%E7%BB%91%E5%AE%9Athis" rel="nofollow">绑定this</a></p> 
<p id="bind%E7%BB%91%E5%AE%9Athis-toc" style="margin-left:80px;"><a href="#bind%E7%BB%91%E5%AE%9Athis" rel="nofollow">bind绑定this</a></p> 
<p id="%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9Athis-toc" style="margin-left:80px;"><a href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9Athis" rel="nofollow">箭头函数绑定this</a></p> 
<p id="%E4%BA%8B%E4%BB%B6%E6%B1%A0-toc" style="margin-left:40px;"><a href="#%E4%BA%8B%E4%BB%B6%E6%B1%A0" rel="nofollow">事件池</a></p> 
<p id="Hooks-toc" style="margin-left:0px;"><a href="#Hooks" rel="nofollow">Hooks</a></p> 
<p id="Ref%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3-toc" style="margin-left:0px;"><a href="#Ref%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3" rel="nofollow">Ref使用详解</a></p> 
<p id="React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95" rel="nofollow">React生命周期和错误处理方法</a></p> 
<p id="%E6%B3%A8%E6%84%8F%E7%82%B9%C2%A0-toc" style="margin-left:0px;"><a href="#%E6%B3%A8%E6%84%8F%E7%82%B9%C2%A0" rel="nofollow">注意点 </a></p> 
<p id="img%E6%A0%87%E7%AD%BE-toc" style="margin-left:40px;"><a href="#img%E6%A0%87%E7%AD%BE" rel="nofollow">img标签</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="React">React</h2> 
<p>react项目是SPA（Single web Page Application单页网页应用）项目，整个网站只有一个页面，通过路由切换页面中局部的内容，实现页面的变更。</p> 
<h2 id="CDN%E5%BC%95%E5%85%A5">CDN引入</h2> 
<p>注意下面引入的2个文件，<span style="color:#fe2c24;"><strong>React负责创建元素</strong>，</span><strong><span style="color:#fe2c24;">ReactDom负责渲染元素到其它元素中</span>。</strong></p> 
<h3 id="%E5%BC%80%E5%8F%91%E7%89%88%E6%9C%AC">开发版本</h3> 
<pre><code class="language-html">&lt;script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"&gt;&lt;/script&gt;
&lt;script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"&gt;&lt;/script&gt;</code></pre> 
<h3 id="%E5%8E%8B%E7%BC%A9%E7%89%88%E6%9C%AC%EF%BC%88%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%EF%BC%89%C2%A0">压缩版本（生产环境） </h3> 
<pre><code class="language-html">&lt;script crossorigin src="https://unpkg.com/react@17/umd/react.production.min.js"&gt;&lt;/script&gt;
&lt;script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"&gt;&lt;/script&gt;</code></pre> 
<p></p> 
<h2 id="React.createElement(str%2Cobj%2CinnerHTML)">React.createElement(str,obj,innerHTML)</h2> 
<p>利用React创建元素，其中str为标签的名，obj对象上的属性为该标签上挂载的属性，innerHTML为标签内的文本内容。</p> 
<pre><code class="language-TypeScript">let h3 = React.createElement('h3',{id:'time',className:'danger'},'时间')</code></pre> 
<p></p> 
<h2 id="ReactDOM.render(h3%2Cele)">ReactDOM.render(h3,ele)</h2> 
<p>其中h3为上面React.createElement的返回变量，ele为dom节点。</p> 
<p>下面利用ReactDOM渲染h3元素到id为‘yf’的节点上。</p> 
<pre><code class="language-TypeScript">let ele = document.getElementById('yf')
ReactDOM.render(h3,ele)</code></pre> 
<p></p> 
<h2 id="JSX">JSX</h2> 
<p>使用前需要引入babel（使用脚手架创建会都生成好）。</p> 
<pre><code class="language-html">&lt;script src="https://unpkg.com/@babel/standalone/babel.min.js"&gt;&lt;/script&gt;</code></pre> 
<p> 再添加babel编译（使用脚手架创建会都生成好）。</p> 
<pre><code class="language-html">&lt;script type="text/babel"&gt;</code></pre> 
<h3 id="%C2%A0%E4%BD%BF%E7%94%A8"> 使用</h3> 
<p>可以<strong>理解为用于简化React.createElements函数</strong>。</p> 
<pre><code class="language-TypeScript">const element = &lt;h1 className = {'hello'}&gt;Hello, world!&lt;/h1&gt;;</code></pre> 
<p> 相当于，<strong>注意jsx中使用className给元素添加类名</strong>。</p> 
<pre><code class="language-TypeScript">let element = React.createElement('h1',{className:'hello'},'Hello, world!')</code></pre> 
<p> 注意<span style="color:#fe2c24;"><strong>在JSX中一层大括号相当于引用js的环境，和vue中的双重大括号相同</strong></span>。</p> 
<h3 id="%E6%B3%A8%E9%87%8A">注释</h3> 
<p>通过一对大括号加/* */注释。</p> 
<pre><code class="language-TypeScript">{/* 注释 */}</code></pre> 
<h3 id="%E6%95%B0%E7%BB%84">数组</h3> 
<p>jsx中会自动展开数组，并可以直接渲染数组。</p> 
<p>注意<strong>数组中的JSX元素必须带唯一标识key。</strong></p> 
<pre><code class="language-TypeScript">let ele = [&lt;li&gt;1&lt;/li&gt;,&lt;li&gt;2&lt;/li&gt;,&lt;li&gt;3&lt;/li&gt;]
ele.forEach((v,i)=&gt;{v.key=i})//每个元素添加唯一的key
class list extends React.Component {
  render() {
    return (
      &lt;ul&gt;{ele}&lt;/ul&gt;
    )
  }
}
// 渲染为
//  &lt;ul&gt;
//     &lt;li&gt;1&lt;/li&gt;
//     &lt;li&gt;2&lt;/li&gt;
//     &lt;li&gt;3&lt;/li&gt;
// &lt;/ul&gt;</code></pre> 
<h3 id="%E5%86%85%E8%81%94%E6%B8%B2%E6%9F%93%E6%A0%B7%E5%BC%8F">内联渲染样式</h3> 
<p>相当于直接给style赋值一个对象，对象中的属性为css样式，小驼峰形式不加横线。</p> 
<pre><code class="language-TypeScript">&lt;div style={<!-- -->{ color: 'red', fontSize: '16px' }}&gt;&lt;/div&gt;</code></pre> 
<p></p> 
<h2 id="%E8%84%9A%E6%89%8B%E6%9E%B6">脚手架</h2> 
<p>要求Node&gt;=8.1和npm&gt;=5.6。</p> 
<pre><code class="language-bash">npm i -g create-react-app</code></pre> 
<h3 id="%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%8C%85">创建项目包</h3> 
<p> 注意<strong>项目名需要小写</strong>，下面react-app为项目名。</p> 
<pre><code class="language-bash">create-react-app react-app</code></pre> 
<h3 id="%E5%AE%89%E8%A3%85VScode%E6%8F%92%E4%BB%B6%C2%A0">安装VScode插件 </h3> 
<p><img alt="" height="129" src="https://images2.imgbox.com/f9/60/thgHr44r_o.png" width="567"></p> 
<p>安装后输入rcc可以自动生成类组件。</p> 
<h3 id="JSX%C2%A0%E6%8F%90%E7%A4%BA">JSX 提示</h3> 
<p>js文件默认是只有js文件提示，想要有JSX文件提示需要像下方一样选中。</p> 
<h3 id="%E2%80%8B"><img alt="" height="1040" src="https://images2.imgbox.com/99/7b/BS2h9TQG_o.png" width="1200"></h3> 
<p></p> 
<h2 id="%E7%B1%BB%E7%BB%84%E4%BB%B6">类组件</h2> 
<p><span style="color:#fe2c24;"><strong>类名需要是大驼峰。类组件要求必须继承父类React.Component。</strong></span></p> 
<pre><code class="language-TypeScript">class HelloWorld extends React.Component {
    render(){
        return &lt;h1&gt;Hello World!&lt;/h1&gt; //React.createDOM('h1',{},Hello World!')  也行
    }
}
&lt;HelloWorld /&gt; //使用方式</code></pre> 
<h3 id="%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0">接收参数</h3> 
<pre><code class="language-TypeScript">class HelloWorld extends React.Component {
    constructor(props){
        this.props = props //可以不用写，在父类中实现了
    }
    render(){
        return &lt;h1&gt;Hello World!&lt;/h1&gt; //React.createDOM('h1',{},Hello World!')  也行
    }
}
new HelloWorld({name:'yf'}) //等同于&lt;HellorWorl name='yf' /&gt; 
</code></pre> 
<p>则类中this.props.name等于'yf' 。</p> 
<h3 id="state%E7%8A%B6%E6%80%81">state状态</h3> 
<p>React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。React 里只需更新组件的 state，然后<strong>根据新的 state 重新渲染用户界面（不要操作 DOM）</strong>。</p> 
<p> 注意状态的修改和vue中的不同（vue中会自动重新渲染），react只有通过<strong>setState函数设置状态才会<span style="color:#fe2c24;">重新渲染</span>。因为是重新渲染，故可以通过setState传入空对象，让之前直接通过this.state更改的状态生效。</strong></p> 
<h4 id="setState(state%2Ccallback)">setState(state,callback)</h4> 
<p>对组件 state 的更改排入队列，并通知 React 需要使用更新后的 state 重新渲染此组件及其子组件。state是需要<strong>合并的对象</strong>（注意相当于Object.assign，不是替换)，callback是state更新完后的回调函数（建议使用 <code>componentDidUpdate替代）</code>。当需要使用到props和state时，state可以为一个函数例如下面，函数的返回对象为需要合并的对象。</p> 
<pre><code class="language-TypeScript">this.setState((state, props) =&gt; {
  return {counter: state.counter + props.step};
});</code></pre> 
<p>注意<strong>在调用 <code>setState()</code> 后立即读取 <code>this.state的值不一定会改变。</code></strong> 例如下面state.counter的值始终是不会变的。</p> 
<pre><code class="language-TypeScript">this.setState({counter: state.counter++});</code></pre> 
<p>相当于 this.setState({counter: state.counter})先执行，再执行this.counter=this.counter+1两行代码，由于this.setState是异步的，所以每次都会将值重置。</p> 
<h3 id="defaultProps%C2%A0">defaultProps </h3> 
<p><code>defaultProps</code> 可以为 Class 组件添加默认 props。这一般用于 props 未赋值，但又不能为 <code>null</code> 的情况。例如：</p> 
<pre><code class="language-TypeScript">class CustomButton extends React.Component {
  // 定义方法一
  static defaultProps = {
    color: 'blue'
  }
  // ...
}
}
// 定义方法二
CustomButton.defaultProps = {
  color: 'blue'
};</code></pre> 
<p>如果未提供 <code>props.color</code>，则默认设置为 <code>'blue'</code></p> 
<pre><code class="language-TypeScript">  render() {
    return &lt;CustomButton /&gt; ; // props.color 将设置为 'blue'
  }</code></pre> 
<p>如果 <code>props.color</code> 被设置为 <code>null</code>，则它将保持为 <code>null</code></p> 
<pre><code class="language-TypeScript">  render() {
    return &lt;CustomButton color={null} /&gt; ; // props.color 将保持是 null
  }</code></pre> 
<h3 id="props.children">this.forceUpdate(callback)</h3> 
<p>强制让组件重新渲染，callback为重新渲染后的回调函数。</p> 
<p></p> 
<h2 id="%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6">函数组件</h2> 
<p><span style="color:#fe2c24;"><strong>函数名要大驼峰写法</strong></span>。返回React.createElements生成的对象。</p> 
<pre><code class="language-TypeScript">function HelloWorld(){
    return  &lt;h1&gt;Hello World!&lt;/h1&gt; //React.createDOM('h1',{},Hello World!')  也行
}
&lt;HelloWorld /&gt; //使用方式</code></pre> 
<h3 id="%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%C2%A0">接收参数 </h3> 
<p>函数组件中可以接收一个参数，该参数为一个对象，属性为组件使用时上面的属性。</p> 
<pre><code class="language-TypeScript">function HelloWorld(props){
    return  &lt;h1&gt;Hello World!&lt;/h1&gt; //React.createDOM('h1',{},Hello World!')  也行
}
HelloName({name:'yf'})  //等同于&lt;HellorWorl name='yf' /&gt;
</code></pre> 
<p> 则props.name等于'yf'。</p> 
<h3>defaultProps </h3> 
<pre><code class="language-TypeScript">function CustomButton(){
  // ...
}
CustomButton.defaultProps = {
  color: 'blue'
};</code></pre> 
<h3>props.children</h3> 
<p>获取调用组件时填充到组件标签内部的内容，类似于vue中的slot插槽。</p> 
<pre><code class="language-TypeScript">&lt;Person&gt;组件内部的内容&lt;/Person&gt;
const Person = (props) =&gt; {
    return ( &lt;div&gt;(props.children)&lt;/div&gt; );
}</code></pre> 
<h3 id="%E6%B3%A8%E6%84%8F%E7%82%B9%C2%A0">注意点 </h3> 
<p>函数组件里面<strong>不要直接写setInterval和useState中设置state值的函数，这会导致定时器越来越多，和组件不停被重新渲染。</strong></p> 
<p>例如下面会产生setIterval(()=&gt;{setCount(1)})、setIterval(()=&gt;{setCount(2)})、3、4、5...等越来越多定时器。</p> 
<pre><code class="language-TypeScript">    function Counter() {
        const [count, setCount] = useState(0);
        setInterval(() =&gt; {
            setCount(count + 1);
        }, 1000);
        // 造成的后果就是能一直更新count，但是每一轮循环都会执行上面这行代码，
        //定时器越来越多，然后，就卡死啦，而且每个定时器都会执行一遍，
        //那么屏幕上的数字每秒都会在跳，可以试试看
        return &lt;h1&gt;{count}&lt;/h1&gt;;
    }</code></pre> 
<p></p> 
<h2 id="%E4%BA%8B%E4%BB%B6">事件</h2> 
<p>标签上添加on事件名=‘方法名’来绑定事件。</p> 
<p>注意事<strong>件名大写，绑定时不能在函数后加括号，加了会在创建时执行，触发指定事件时不会被执行。</strong></p> 
<h3 id="%E7%BB%91%E5%AE%9Athis">绑定this</h3> 
<p>类组件中使用this需要注意this的指向，因为<strong>事件的触发都是window</strong>，this指向的是事件的调用者，故为window，所以使用时需要绑定this指向。</p> 
<h4 id="bind%E7%BB%91%E5%AE%9Athis">bind绑定this</h4> 
<p>下面可以在constructor中绑定this也可以在render中绑定this。</p> 
<pre><code class="language-TypeScript">class Demo extends React.Component {
    constructor(){
        //super(props);
        //this.show = this.show.bind(this);
    }
    show(){
        console.log('点击')
    }
    render(){
        return &lt;button onClick={ this.show.bind(this) }&gt;点击事件&lt;/button&gt;
    }
}</code></pre> 
<h4 id="%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9Athis">箭头函数绑定this</h4> 
<pre><code class="language-TypeScript">class Demo extends React.Component {
    show(){
        console.log('点击')
    }
    render(){
        return &lt;button onClick={ ()=&gt;{ this.show() }}&gt;点击事件&lt;/button&gt;
    }
}</code></pre> 
<h3 id="%E4%BA%8B%E4%BB%B6%E6%B1%A0">事件池</h3> 
<p>React对事件对象进行了包装，对象会被放入池中统一管理。这意味着包装的事件对象可以被复用，当所有事件处理函数被调用之后，其<strong>所有属性都会被置空</strong>。<span style="color:#fe2c24;"><strong>React17开始移除了该特性</strong></span>。</p> 
<p>例如下面代码e为undefined，会报错</p> 
<pre><code class="language-TypeScript">function handleChange(e) {
  // This won't work because the event object gets reused.
  setTimeout(() =&gt; {
    console.log(e.target.value); // Too late!
  }, 100);
}</code></pre> 
<p>如果你需要在事件处理函数运行之后获取事件对象的属性，你需要调用<span style="color:#fe2c24;"><strong> <code>e.persist()</code></strong></span>：</p> 
<pre><code class="language-TypeScript">function handleChange(e) {
  // Prevents React from resetting its properties:
  e.persist();

  setTimeout(() =&gt; {
    console.log(e.target.value); // Works
  }, 100);
}</code></pre> 
<p></p> 
<h2 id="Hooks">Hooks</h2> 
<p><a href="https://blog.csdn.net/AIWWY/article/details/123402881" title="React中Hooks详解（useState、useEffect、useContext、useRef详解）_AIWWY的博客-CSDN博客">React中Hooks详解（useState、useEffect、useContext、useRef详解）_AIWWY的博客-CSDN博客</a></p> 
<p></p> 
<h2 id="Ref%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3">Ref使用详解</h2> 
<p><a href="https://blog.csdn.net/AIWWY/article/details/123404928" title="https://blog.csdn.net/AIWWY/article/details/123404928">https://blog.csdn.net/AIWWY/article/details/123404928</a></p> 
<p id=""></p> 
<h2 id="React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95">React生命周期和错误处理方法</h2> 
<p><a href="https://blog.csdn.net/AIWWY/article/details/123338490" title="https://blog.csdn.net/AIWWY/article/details/123338490">https://blog.csdn.net/AIWWY/article/details/123338490</a></p> 
<p></p> 
<h2>注意点 </h2> 
<h3 id="img%E6%A0%87%E7%AD%BE">img标签</h3> 
<p>注意<span style="color:#fe2c24;"><strong>webpack打包工具要求本地图片使用require来引入</strong></span>，vue会自动生成，而react没有做处理，所以需要使用require引入。</p> 
<pre><code class="language-html">&lt;img src={ require(url) }&gt;</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/30f2bff374541b29a4231dce3ac148a9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">快手资讯|快手推出多档世界杯相关节目</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/96d84aad70e3888af9ee519d8f5dfd1f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何用binlog日志恢复MySQL误删数据</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>