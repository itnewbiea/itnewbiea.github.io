<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>抽象工厂模式 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="抽象工厂模式" />
<meta property="og:description" content="概述 工厂方法模式 | 偷掉月亮 (moonshuo.cn)
原文链接：抽象工厂模式 | 偷掉月亮 (moonshuo.cn)
抽象工厂模式：提供一个创建一系列相关或者相互依赖的对象的接口，而无需指定他们的类
工厂三兄弟之抽象工厂模式（二）_LoveLion的博客-CSDN博客
对于上述的产品构造，如果我们采用工厂方法模式，那么我们需要实现15个工厂方法，但是我们可以发现对于这个来说，我们可以合并一个产品族，即一个工厂内部可以生产一次性生产深色的方形，圆形，椭圆，那么我们现在只需要有5个工厂方法
实例 对于下面的产品来说，海尔家族是一个产品组，海信是一个产品组，康佳是一个产品组，每一家都可以生产空调，电视，冰箱
这里就不适用反射进行操作了，如果想要看反射的操作（类似spring操作），看工厂方法模式 | 偷掉月亮 (moonshuo.cn)
首先两种产品
电视：
package 设计模式.抽象工厂模式.产品; /** * @author zss * @date 2022-08-02 14:21:41 * @description 电视的抽象类 */ public interface Television { /**生产产品的方法*/ void manufacturePro(); } 海尔电视：
package 设计模式.抽象工厂模式.产品.海尔家族; import 设计模式.抽象工厂模式.产品.Television; /** * @author zss * @date 2022-08-02 14:23:21 * @description 海尔电视生产方式 */ public class HaierTV implements Television { @Override public void manufacturePro() { System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/630a00877fe15ae55304ecac6fbf0b48/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-02T15:19:35+08:00" />
<meta property="article:modified_time" content="2022-08-02T15:19:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">抽象工厂模式</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>概述</h2> 
<p><a href="https://moonshuo.cn/posts/31150.html" rel="nofollow">工厂方法模式 | 偷掉月亮 (moonshuo.cn)</a><br> 原文链接：<a href="https://moonshuo.cn/posts/56455.html" rel="nofollow">抽象工厂模式 | 偷掉月亮 (moonshuo.cn)</a><br> 抽象工厂模式：提供一个创建一系列相关或者相互依赖的对象的接口，而无需指定他们的类</p> 
<p><a href="https://blog.csdn.net/lovelion/article/details/9319323">工厂三兄弟之抽象工厂模式（二）_LoveLion的博客-CSDN博客</a></p> 
<p><img src="https://images2.imgbox.com/0a/fe/QkPYKZyV_o.jpg" alt="img"></p> 
<p>对于上述的产品构造，如果我们采用工厂方法模式，那么我们需要实现15个工厂方法，但是我们可以发现对于这个来说，我们可以合并一个产品族，即一个工厂内部可以生产一次性生产深色的方形，圆形，椭圆，那么我们现在只需要有5个工厂方法</p> 
<h3><a id="_12"></a>实例</h3> 
<p>对于下面的产品来说，海尔家族是一个产品组，海信是一个产品组，康佳是一个产品组，每一家都可以生产空调，电视，冰箱</p> 
<p><font color="red">这里就不适用反射进行操作了，如果想要看反射的操作（类似spring操作），看<a href="https://moonshuo.cn/posts/31150.html" rel="nofollow">工厂方法模式 | 偷掉月亮 (moonshuo.cn)</a></font></p> 
<p>首先两种产品</p> 
<p>电视：</p> 
<pre><code class="prism language-Java">package 设计模式.抽象工厂模式.产品;

/**
 * @author zss
 * @date 2022-08-02 14:21:41
 * @description 电视的抽象类
 */
public interface Television {
    /**生产产品的方法*/
    void manufacturePro();
}
</code></pre> 
<p>海尔电视：</p> 
<pre><code class="prism language-Java">package 设计模式.抽象工厂模式.产品.海尔家族;

import 设计模式.抽象工厂模式.产品.Television;

/**
 * @author zss
 * @date 2022-08-02 14:23:21
 * @description 海尔电视生产方式
 */
public class HaierTV implements Television {
    @Override
    public void manufacturePro() {
        System.out.println("海尔电视生产，贴上海尔的标签");
    }
}
</code></pre> 
<p>海信电视</p> 
<pre><code class="prism language-Java">package 设计模式.抽象工厂模式.产品.海信家族;

import 设计模式.抽象工厂模式.产品.Television;

/**
 * @author zss
 * @date 2022-08-02 14:24:48
 * @description 海信电视的生产
 */
public class HisenseTV implements Television {
    @Override
    public void manufacturePro() {
        System.out.println("生产海信电视，贴上海信的标签");
    }
}
</code></pre> 
<p>康佳电视</p> 
<pre><code class="prism language-Java">package 设计模式.抽象工厂模式.产品.康佳家族;

import 设计模式.抽象工厂模式.产品.Television;

/**
 * @author zss
 * @date 2022-08-02 14:25:57
 * @description 康佳电视生产
 */
public class KonkaTV implements Television {
    @Override
    public void manufacturePro() {
        System.out.println("康佳电视生产，贴上康佳标签");
    }
}
</code></pre> 
<p>空调：</p> 
<pre><code class="prism language-Java">package 设计模式.抽象工厂模式.产品;

/**
 * @author zss
 * @date 2022-08-02 14:27:26
 * @description 空调生产
 */
public interface AirConditioner {
    /**生产空调的方法*/
    void manufactureProAc();
}
</code></pre> 
<p>海尔空调</p> 
<pre><code class="prism language-Java">package 设计模式.抽象工厂模式.产品.海尔家族;

import 设计模式.抽象工厂模式.产品.AirConditioner;

/**
 * @author zss
 * @date 2022-08-02 14:28:37
 * @description
 */
public class HaierAC implements AirConditioner {
    @Override
    public void manufactureProAc() {
        System.out.println("生产海尔空调，贴上海尔标签");
    }
}
</code></pre> 
<p>海信空调</p> 
<pre><code class="prism language-Java">package 设计模式.抽象工厂模式.产品.海信家族;

import 设计模式.抽象工厂模式.产品.AirConditioner;

/**
 * @author zss
 * @date 2022-08-02 14:30:19
 * @description
 */
public class HisenseAC implements AirConditioner {
    @Override
    public void manufactureProAc() {
        System.out.println("生产海信冰箱，贴上标签");
    }
}
</code></pre> 
<p>康佳空调</p> 
<pre><code class="prism language-Java">package 设计模式.抽象工厂模式.产品.康佳家族;

import 设计模式.抽象工厂模式.产品.AirConditioner;

/**
 * @author zss
 * @date 2022-08-02 14:31:11
 * @description
 */
public class KonkaAC implements AirConditioner {
    @Override
    public void manufactureProAc() {
        System.out.println("生产康佳冰箱，贴上康佳标签");
    }
}
</code></pre> 
<p>工厂</p> 
<pre><code class="prism language-Java">package 设计模式.抽象工厂模式.工厂;

import 设计模式.抽象工厂模式.产品.AirConditioner;
import 设计模式.抽象工厂模式.产品.Television;

/**
 * @author zss
 * @date 2022-08-02 14:32:27
 * @description
 */
public interface Factory {
    Television createTV();
    AirConditioner createAC();
}
</code></pre> 
<p>海尔工厂</p> 
<pre><code class="prism language-Java">package 设计模式.抽象工厂模式.工厂;

import 设计模式.抽象工厂模式.产品.AirConditioner;
import 设计模式.抽象工厂模式.产品.Television;
import 设计模式.抽象工厂模式.产品.海尔家族.HaierAC;
import 设计模式.抽象工厂模式.产品.海尔家族.HaierTV;

/**
 * @author zss
 * @date 2022-08-02 14:33:37
 * @description
 */
public class HaierFactory implements Factory {
    @Override
    public Television createTV() {
        return new HaierTV();
    }

    @Override
    public AirConditioner createAC() {
        return new HaierAC();
    }
}
</code></pre> 
<p>海信工厂</p> 
<pre><code class="prism language-Java">package 设计模式.抽象工厂模式.工厂;

import 设计模式.抽象工厂模式.产品.AirConditioner;
import 设计模式.抽象工厂模式.产品.海信家族.HisenseAC;
import 设计模式.抽象工厂模式.产品.海信家族.HisenseTV;
import 设计模式.抽象工厂模式.产品.Television;

/**
 * @author zss
 * @date 2022-08-02 14:34:43
 * @description
 */
public class HisenseFactory implements Factory {
    @Override
    public Television createTV() {
        return new HisenseTV();
    }

    @Override
    public AirConditioner createAC() {
        return new HisenseAC();
    }
}
</code></pre> 
<p>康佳工厂</p> 
<pre><code class="prism language-Java">package 设计模式.抽象工厂模式.工厂;

import 设计模式.抽象工厂模式.产品.AirConditioner;
import 设计模式.抽象工厂模式.产品.康佳家族.KonkaAC;
import 设计模式.抽象工厂模式.产品.康佳家族.KonkaTV;
import 设计模式.抽象工厂模式.产品.Television;

/**
 * @author zss
 * @date 2022-08-02 14:35:40
 * @description
 */
public class KonkaFactory implements Factory {
    @Override
    public Television createTV() {
        return new KonkaTV();
    }

    @Override
    public AirConditioner createAC() {
        return new KonkaAC();
    }
}
</code></pre> 
<p>客户</p> 
<pre><code class="prism language-Java">package 设计模式.抽象工厂模式;

import 设计模式.抽象工厂模式.产品.AirConditioner;
import 设计模式.抽象工厂模式.产品.Television;
import 设计模式.抽象工厂模式.工厂.Factory;
import 设计模式.抽象工厂模式.工厂.HaierFactory;


/**
 * @author zss
 * @date 2022-08-02 14:39:33
 * @description
 */
public class Client {

    public static void main(String[] args) {
        //加入说现在客户来请求生产一种产品
        Factory factory;
        Television television;
        AirConditioner airConditioner;
        //现在海尔厂家来了，请求我们帮助生产
        factory=new HaierFactory();
        television= factory.createTV();
        airConditioner= factory.createAC();
        television.manufacturePro();
        airConditioner.manufactureProAc();
    }
}
</code></pre> 
<p><img src="https://images2.imgbox.com/b3/bf/qGbmEjlB_o.png" alt="image-20220802145121334"></p> 
<h4><a id="_310"></a>思考</h4> 
<p>我们可以看出来这个抽象工厂模式比较适合生产同一个家族的产品，<font color="red">比如我们现在需要生产海信，海尔，康佳的电视，冰箱，没有其他的产品，那么我们可以使用抽象工厂模式，因为无论如何都避免不了建立三个工厂，但是如果为了扩展性考虑，假如现在这三家工厂需要我们生产新的产品，那么也不得不更改工厂的方法，这样影响了代码的开闭性</font>，但是如果此时松下需要我们生产相同的产品，那么我们的只需要增加一个工厂，和产品的实现就好。也就是说我们想要增加产品组非常方便，但是如果增加一个产品的等级结构，那么会很麻烦。</p> 
<p><font color="cornflowerblue">仔细观看上面的代码，我们发现当代码中存在我们想要添加类的抽象的时候，这样非常简单，但是如果写好的代码中没有想要添加类的抽象，那么我们势必会影响开闭性，简单工厂模式，工厂方式模式还有本节的抽象工厂模式都是这样的弊端</font></p> 
<h3><a id="_316"></a>总结</h3> 
<p>Java语言中的AWT中使用了抽象工厂模式，比如window操作系统的包含的元素是窗口，按钮等等，而在linux下面也包含窗口，按钮等，他们产品相同，而所属的标志不同</p> 
<p>适用环境：</p> 
<ol><li>用户不需要知道这个产品怎么被创建的，只需要知道这个产品可以被正确创建就好，这也是所有工厂方法的基石</li><li>系统中有多个产品族，并且可以动态改变产品族</li><li>不会有新的产品等级被加入，同一个产品族的产品将在一起使用，不一定要有必然的联系</li></ol>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a3d5d669612d91ee3a97927f8259d715/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Office更新了那么多代，哪个版本好看呢？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dca2147e979c32e09fe28ff8a8ebbac0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【volatile关键字和CAS总结】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>