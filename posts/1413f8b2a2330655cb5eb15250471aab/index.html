<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《三十一》开发模式构建工具 Vite - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《三十一》开发模式构建工具 Vite" />
<meta property="og:description" content="基于 Vite4。
在实际开发中，编写的代码往往是不能被浏览器直接识别的，例如 ES6&#43;、React、Vue、TypeScript 等，必须通过构建工具来对代码进行转换、编译，例如 Webpack、Rolluop、Vite 等。
Vite：下一代前端开发与构建工具，能够显著地提升前端开发体验。
Vite 的构成： Vite 主要由两部分构成：
一个开发服务器：基于原生的 ESModule 提供了丰富的內建功能，HMR 的速度非常快。一套构建指令：基于 Rollup 打包代码，可以打包输出优化过的静态资源。 可以对已有项目单独安装并使用 Vite；也可以直接使用 npm init vite 命令来创建一个基于 Vite 的项目。
Vite 启动本地服务为什么快速？ Vite 利用浏览器已经原生支持 ESModule，遇到 import 就发送一个 HTTP 请求去按需加载加载文件，而不需要加载整个项目。
Vite 会启动一个 Connect 服务器拦截这些请求，使用 ESBuild 构建工具动态生成转换后的 ESModule 代码返回给浏览器，而不需要提前解析依赖、打包构建后再启动开发服务器。
Vite2 之前是使用 koa 来搭建服务器；Vite2 及之后是使用 Connect 来搭建服务器。
Webpack 是先解析依赖、打包构建再启动开发服务器，因此启动时间更长。
// src/utils/index.ts export const dateFormat = (date: string) =&gt; { return `日期为：${date}` } 在首次启动 Vite 时，Vite 会预构建项目的第三方依赖。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/1413f8b2a2330655cb5eb15250471aab/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-18T17:38:13+08:00" />
<meta property="article:modified_time" content="2023-12-18T17:38:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《三十一》开发模式构建工具 Vite</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>基于 Vite4。</p> 
</blockquote> 
<p>在实际开发中，编写的代码往往是不能被浏览器直接识别的，例如 ES6+、React、Vue、TypeScript 等，必须通过构建工具来对代码进行转换、编译，例如 Webpack、Rolluop、Vite 等。</p> 
<p>Vite：下一代前端开发与构建工具，能够显著地提升前端开发体验。</p> 
<h2><a id="Vite__5"></a>Vite 的构成：</h2> 
<p>Vite 主要由两部分构成：</p> 
<ol><li>一个开发服务器：基于原生的 ESModule 提供了丰富的內建功能，HMR 的速度非常快。</li><li>一套构建指令：基于 Rollup 打包代码，可以打包输出优化过的静态资源。 
  <blockquote> 
   <p>可以对已有项目单独安装并使用 Vite；也可以直接使用 <code>npm init vite</code> 命令来创建一个基于 Vite 的项目。</p> 
  </blockquote> </li></ol> 
<h2><a id="Vite__10"></a>Vite 启动本地服务为什么快速？</h2> 
<ol><li> <p>Vite 利用浏览器已经原生支持 ESModule，遇到 import 就发送一个 HTTP 请求去按需加载加载文件，而不需要加载整个项目。</p> </li><li> <p>Vite 会启动一个 Connect 服务器拦截这些请求，使用 ESBuild 构建工具动态生成转换后的 ESModule 代码返回给浏览器，而不需要提前解析依赖、打包构建后再启动开发服务器。</p> 
  <blockquote> 
   <p>Vite2 之前是使用 koa 来搭建服务器；Vite2 及之后是使用 Connect 来搭建服务器。<br> Webpack 是先解析依赖、打包构建再启动开发服务器，因此启动时间更长。</p> 
  </blockquote> <pre><code>// src/utils/index.ts
export const dateFormat = (date: string) =&gt; {
  return `日期为：${date}`
}
</code></pre> <p><img src="https://images2.imgbox.com/72/09/sy3bv03q_o.png" alt="在这里插入图片描述"></p> </li><li> <p>在首次启动 Vite 时，Vite 会预构建项目的第三方依赖。</p> 
  <blockquote> 
   <p>这么做的目的是：</p> 
   <ol><li>CommonJS 和 UMD 兼容性: 在开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将以 CommonJS 或 UMD 形式提供的依赖项转换为 ES 模块。</li><li>性能： Vite 将那些具有许多内部模块的 ESM 依赖项转换为单个模块。有些包将它们的 ES 模块构建为许多单独的文件，彼此导入，例如，<code>lodash-es</code> 有超过 600 个内置模块，当执行 <code>import { debounce } from 'lodash-es'</code> 时，浏览器会同时发出 600 多个 HTTP 请求，即使服务器能够轻松处理它们，但大量请求会导致浏览器端的网络拥塞，使页面加载变得明显缓慢，通过将 <code>lodash-es</code> 预构建成单个模块，现在我们只需要一个HTTP请求。</li></ol> 
  </blockquote> <p><img src="https://images2.imgbox.com/0f/df/fwmgz46h_o.png" alt="在这里插入图片描述"></p> <p><img src="https://images2.imgbox.com/bd/82/6ERviEBY_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/52/70/xeHHTVkB_o.png" alt="在这里插入图片描述"></p> </li></ol> 
<h4><a id="ESBuild__33"></a>ESBuild 构建工具：</h4> 
<p>Vite 使用 ESBuild 作为默认的构建工具。 ESBuild 主要用于将现代 JavaScript、TypeScript、CSS 等浏览器不理解的或需要转换的代码，转换成浏览器能够理解的、向后兼容的代码。</p> 
<blockquote> 
 <p>Vite 和 Webpack 是一类工具，ESBuild 和 Babal 是一类工具。</p> 
</blockquote> 
<h6><a id="ESBuild__36"></a>ESBuild 的特点：</h6> 
<ol><li>超快的构建速度，并且不需要缓存。</li><li>支持 ESModule 和 CommonJS 的模块化。</li><li>支持 ES6 的 TreeShaking。</li><li>支持 Go、JavaScript 的 API。</li><li>支持 TypeScript、JSX 等语法编译。</li><li>支持 SourceMap。</li><li>支持代码压缩。</li><li>支持扩展其他插件。</li></ol> 
<h6><a id="_ESBuild__45"></a>为什么 ESBuild 构建速度超快？</h6> 
<ol><li>ESBuild 是使用 Go 语言编写的，可以直接转换成机器代码，而无需经过字节码。</li><li>ESBuild 可以充分利用 CPU 的多内核，尽可能让它们饱和运行。 
  <blockquote> 
   <p>ESBuild 会单独开一个进程，在这个进程中会尽可能地多开线程，多个线程是可以跑在多个 CPU 内核中，因此就可以并行执行。</p> 
  </blockquote> </li><li>ESBuild 的所有内容都是从零开始编写的，没有使用第三方库，所以从一开始就考虑了各种性能问题。</li></ol> 
<h2><a id="Vite__50"></a>Vite 的构建指令：</h2> 
<h4><a id="_Vite__51"></a>使用 Vite 开启本地服务：</h4> 
<ol><li> <p>新建 <code>vite-demo</code> 文件夹，并且运行 <code>npm init -y</code> 命令初始化项目。</p> </li><li> <p>安装 Vite：<code>npm install vite -D</code>。</p> </li><li> <p>新建 <code>src/index.js</code> 文件，并编写代码。</p> <pre><code>console.log('index')
</code></pre> </li><li> <p>新建 <code>index.html</code> 文件，并编写代码。</p> <pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script src="./src/index.js" type="module"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> </li><li> <p>安装 Vite：<code>npm install vite -D</code>。</p> </li><li> <p>运行 <code>npx vite</code> 命令，Vite 会将当前根目录下的 <code>index.html</code> 文件作为入口文件，开启一个本地服务器，并且支持热替换。</p> 
  <blockquote> 
   <p>Vite 开启本地服务会比 Webpack 快很多。</p> 
  </blockquote> <p><img src="https://images2.imgbox.com/2e/23/7G1pXchH_o.png" alt="请添加图片描述"><br> <img src="https://images2.imgbox.com/ca/89/kpm7T7T9_o.png" alt="在这里插入图片描述"></p> </li></ol> 
<h4><a id="_Vite__78"></a>使用 Vite 打包代码：</h4> 
<ol><li>运行 <code>npx vite build</code> 命令打包上面的代码，会发现，打包输出到了 dist 文件夹下。<br> <img src="https://images2.imgbox.com/7b/95/SEPooV2G_o.png" alt="请添加图片描述"></li></ol> 
<h4><a id="_Vite__81"></a>使用 Vite 预览打包后的代码：</h4> 
<p>如果想要预览打包后的代码的效果，可以运行 <code>npx vite preview</code> 命令，将会开启一个本地服务并运行打包后的文件。</p> 
<blockquote> 
 <p>必须先运行 <code>npx vite build</code> 命令打包代码，才可以使用 <code>npx vite preview</code> 命令进行预览。</p> 
</blockquote> 
<h2><a id="_Vite__84"></a>使用 Vite 处理各种类型的文件：</h2> 
<h4><a id="_Vite__CSS__85"></a>使用 Vite 处理 CSS 样式：</h4> 
<p>Vite 原生支持 CSS、CSS 预处理，还有 PostCSS 的转换，不需要额外做什么配置。</p> 
<h6><a id="CSS_87"></a>CSS：</h6> 
<ol><li>新建 <code>src/css/index.css</code> 文件，并编写代码。<pre><code>body {
  background-color: red;
}
</code></pre> </li><li>在 <code>src/index.js</code> 文件中将其引入。<pre><code>import './css/index.css'
console.log('index')
</code></pre> </li><li>运行 <code>npx vite</code> 命令，会发现使用 Vite 进行的话，不需要针对 CSS 文件做什么配置，直接编译成功了，Vite 会创建一个 <code>&lt;style&gt;&lt;/style&gt;</code> 标签将 CSS 内联到 HTML 文件中。 <img src="https://images2.imgbox.com/26/ec/GwqikEs8_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/02/48/qbrjfNmT_o.png" alt="在这里插入图片描述"></li></ol> 
<h6><a id="Less_102"></a>Less：</h6> 
<ol><li>安装 Less：<code>npm install less -D</code>。</li><li>新建 <code>src/css/index.less</code> 文件，并编写代码。<pre><code>@bg: blue;
body {
  background-color: @bg;
}
</code></pre> </li><li>在 <code>src/index.js</code> 文件中将其引入。<pre><code>import './css/index.less'
console.log('index')
</code></pre> </li><li>运行 <code>npx vite</code> 命令，会发现使用 Vite 进行的话，不需要针对 Less 文件做什么配置，直接编译成功了。<br> <img src="https://images2.imgbox.com/d5/81/qdULW0cZ_o.png" alt="在这里插入图片描述"></li></ol> 
<h6><a id="PostCSS_118"></a>PostCSS：</h6> 
<ol><li>安装 PostCSS 和 PostCSS 的预设：<code>npm install postcss postcss-preset-env -D</code>。</li><li>新建 <code>postcss.config.js</code> 文件，并编写配置信息。<pre><code>module.exports = {
  plugins: [
    require('postcss-preset-env')
  ]
}
</code></pre> </li><li>新建 <code>src/css/index.css</code> 文件，并编写代码。<pre><code>body {
  user-select: none;
}
</code></pre> </li><li>在 <code>src/index.js</code> 文件中将其引入。<pre><code>import './css/index.css'
console.log('index')
</code></pre> </li><li>运行 <code>npx vite</code> 命令，会发现使用 Vite 进行的话，不需要针对 PostCSS 做什么配置，PostCSS 就已经生效了。<br> <img src="https://images2.imgbox.com/0a/c5/7526Opaf_o.png" alt="在这里插入图片描述"></li></ol> 
<h4><a id="_Vite__TypeScript__141"></a>使用 Vite 处理 TypeScript 代码：</h4> 
<p>Vite 原生支持 TypeScript，不需要额外做什么配置。</p> 
<ol><li>新建 <code>src/utils.ts</code> 文件，并编写代码。<pre><code>export const dateFormat = (date: string) =&gt; {
  return `日期为：${date}`
}
</code></pre> </li><li>在 <code>src/index.js</code> 中将其引入。<pre><code>import {dateFormat} from './utils/index.ts'
console.log(dateFormat('1999-10-10'))
</code></pre> </li><li>运行 <code>npx vite</code> 命令，会发现编译成功了。<br> <img src="https://images2.imgbox.com/23/46/8vEFkD8Q_o.png" alt="在这里插入图片描述"></li></ol> 
<h4><a id="_Vite__156"></a>使用 Vite 处理图片：</h4> 
<p>Vite 原生支持对图片的处理，不需要额外做什么配置。</p> 
<ol><li>在 <code>src/images/</code> 文件夹下放入一张图片。</li><li>在 <code>src/index.js</code> 文件中将其引入。<pre><code>import likeImg from './images/like.jpg'
const img = document.createElement('img')
img.src = likeImg
document.body.appendChild(img)
</code></pre> </li><li>运行 <code>npx vite</code> 命令，会发现编译成功了。<br> <img src="https://images2.imgbox.com/b8/d3/5YshmB24_o.png" alt="在这里插入图片描述"></li></ol> 
<h2><a id="_Vite__Vue__168"></a>使用 Vite 处理 Vue 文件：</h2> 
<p>Vite 对 Vue 提供了第一优先级的之处：通过 <code>@vitejs/plugin-vue</code> 插件实现 Vue3 单文件组件的支持；通过 <code>@vitejs/plugin-vue-jsx</code> 插件实现对 Vue3 JSX 的支持；通过 <code>vite-plugin-vue2</code> 插件实现对 Vue2 的支持。</p> 
<ol><li>安装 Vue2：<code>npm install vue@2</code>。</li><li>新建 <code>src/js/App.vue</code> 文件并编写代码。<pre><code>// src/js/App.vue
&lt;template&gt;
	&lt;div&gt;{<!-- -->{title}}&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        title: 'Hello Vue'
      }
    }
  }
&lt;/script&gt;

&lt;style scoped&gt;&lt;/style&gt;
</code></pre> </li><li>新建 <code>src/index.js</code> 文件，并编写代码。<pre><code>// src/index.js
import Vue from 'vue'
import App from './js/App.vue'

new Vue({
  render: h =&gt; h(App)
}).$mount('#app')
</code></pre> </li><li>新建 <code>index.html</code> 文件，并编写代码。<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="app"&gt;&lt;/div&gt;
  &lt;script src="./src/index.js" type="module"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> </li><li>运行 <code>npx vite</code> 命令进行打包，会发现报错了，Vite 无法转换 Vue 文件。<br> <img src="https://images2.imgbox.com/ff/03/c8HN9BwT_o.png" alt="在这里插入图片描述"></li><li>安装 <code>vite-plugin-vue2</code> 插件用来处理 Vue 文件：<code>npm install vite-plugin-vue2 -D</code>。</li><li>新建 <code>vue.config.js</code> 文件，并编写配置。<pre><code>import {createVuePlugin} from 'vite-plugin-vue2'

export default {
  plugins: [
    createVuePlugin(),
  ]
}
</code></pre> </li><li>运行 <code>npx vite</code> 命令进行打包，会发现打包成功了。<br> <img src="https://images2.imgbox.com/4d/90/bpIlKLfm_o.png" alt="在这里插入图片描述"></li></ol> 
<h4><a id="_Vite__React__230"></a>使用 Vite 处理 React 文件：</h4> 
<p>Vite 原生支持 JSX 语法，不需要额外做什么配置。但是文件必须以 <code>.jsx</code> 为后缀，否则 Vite 不知道需要处理的是 JSX 语法。</p> 
<ol><li>安装 React 和 ReactDOM：<code>npm install react react-dom</code>。</li><li>新建 <code>src/index.jsx</code> 文件，并编写代码。<pre><code>// src/index.jsx
import React from 'react'
import ReactDOM from 'react-dom'

class App extends React.Component {
    state = {
        title: 'Hello World',
    }
    render() {
        return (
            &lt;div&gt;{this.state.title}&lt;/div&gt;
        )
    }
}

ReactDOM.render(&lt;App/&gt;, document.getElementById('app'))
</code></pre> </li><li>新建 <code>index.html</code> 文件，并编写代码。<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="app"&gt;&lt;/div&gt;
  &lt;script src="./src/index.jsx" type="module"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> </li><li>运行 <code>npx vite</code> 命令，会发现打包成功了。<br> <img src="https://images2.imgbox.com/67/b3/C2XfWqyx_o.png" alt="在这里插入图片描述"></li></ol>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/475bdd9410094bdfb695608c5e4f7a0e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">操作无法完成错误0x00000bc4的修复方法，以及出现0x00000bc4的原因</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2522f1b00fd1cfea62f9ab4b748382e3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;】智能指针</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>