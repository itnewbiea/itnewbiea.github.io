<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法题--二叉树（二叉树的最近公共祖先、重建二叉树、二叉搜索树的后序遍历序列） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法题--二叉树（二叉树的最近公共祖先、重建二叉树、二叉搜索树的后序遍历序列）" />
<meta property="og:description" content="目录
二叉树
题目
二叉树的最近公共祖先
原题链接
解析
二叉搜索树的最近公共节点
核心思想
答案
重建二叉树
题目链接
解析
核心思想
答案
二叉搜索树的后序遍历序列
原题链接
解析
核心思想
答案
二叉树 该类题目的解决一般是通过节点的遍历去实现，一般是分两种。
一是递归（深度优先），该方法通常代码比较简单，难懂。首先需要确定入参和返回的内容，然后确定层级之间的关系，最后去找递归的出口。
二是广度优先（该方法一般只有可以分层次处理的才能用），该方法代码量多，易懂。首先借助数组存储第一层的节点，然后每次将数组中的节点分批从数组头部取出（当对比2个节点时就一次取2个），处理完后将对应的子节点分批再从数组尾部存入数组（注意需要对比的子节点相邻存入，这样取出正好配对）。递归上述步骤直到数组为空。
注意特殊的二叉树会满足一些条件。
题目 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]
​
示例 1:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/877b011b1c51789fc52cdf13023c4da9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-01T21:22:11+08:00" />
<meta property="article:modified_time" content="2023-08-01T21:22:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法题--二叉树（二叉树的最近公共祖先、重建二叉树、二叉搜索树的后序遍历序列）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">二叉树</a></p> 
<p id="%E9%A2%98%E7%9B%AE-toc" style="margin-left:0px;"><a href="#%E9%A2%98%E7%9B%AE" rel="nofollow">题目</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88" rel="nofollow">二叉树的最近公共祖先</a></p> 
<p id="%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5-toc" style="margin-left:80px;"><a href="#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5" rel="nofollow">原题链接</a></p> 
<p id="%E8%A7%A3%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E6%9E%90" rel="nofollow">解析</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9" rel="nofollow">二叉搜索树的最近公共节点</a></p> 
<p id="%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3" rel="nofollow">核心思想</a></p> 
<p id="%E7%AD%94%E6%A1%88-toc" style="margin-left:80px;"><a href="#%E7%AD%94%E6%A1%88" rel="nofollow">答案</a></p> 
<p id="%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:40px;"><a href="#%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">重建二叉树</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5-toc" style="margin-left:80px;"><a href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5" rel="nofollow">题目链接</a></p> 
<p id="%E8%A7%A3%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E6%9E%90" rel="nofollow">解析</a></p> 
<p id="%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3" rel="nofollow">核心思想</a></p> 
<p id="%E7%AD%94%E6%A1%88-toc" style="margin-left:80px;"><a href="#%E7%AD%94%E6%A1%88" rel="nofollow">答案</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97" rel="nofollow">二叉搜索树的后序遍历序列</a></p> 
<p id="%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5-toc" style="margin-left:80px;"><a href="#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5" rel="nofollow">原题链接</a></p> 
<p id="%E8%A7%A3%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E6%9E%90" rel="nofollow">解析</a></p> 
<p id="%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3" rel="nofollow">核心思想</a></p> 
<p id="%E7%AD%94%E6%A1%88-toc" style="margin-left:80px;"><a href="#%E7%AD%94%E6%A1%88" rel="nofollow">答案</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</h2> 
<p>该类题目的解决一般是通过节点的遍历去实现，一般是分两种。</p> 
<p>一是递归（深度优先），该方法通常代码比较简单，难懂。首先需要确定入参和返回的内容，然后确定层级之间的关系，最后去找递归的出口。</p> 
<p>二是广度优先（该方法一般只有可以分层次处理的才能用），该方法代码量多，易懂。首先借助数组存储第一层的节点，然后每次将数组中的节点分批从数组头部取出（当对比2个节点时就一次取2个），处理完后将对应的子节点分批再从数组尾部存入数组（注意需要对比的子节点相邻存入，这样取出正好配对）。递归上述步骤直到数组为空。<br> 注意特殊的二叉树会满足一些条件。</p> 
<h2 id="%E9%A2%98%E7%9B%AE">题目</h2> 
<h3 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">二叉树的最近公共祖先</h3> 
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p> 
<p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin" rel="nofollow" title="百度百科">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p> 
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p> 
<div> 
 <p><img alt="" height="190" src="https://images2.imgbox.com/43/3c/yiIf0hGf_o.png" width="200">​</p> 
</div> 
<p><strong>示例 1:</strong></p> 
<pre><strong>输入:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
<strong>输出:</strong> 3
<strong>解释: </strong>节点 <code>5 </code>和节点 <code>1 </code>的最近公共祖先是节点 <code>3。</code></pre> 
<p><strong>示例 2:</strong></p> 
<pre><strong>输入:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
<strong>输出:</strong> 5
<strong>解释: </strong>节点 <code>5 </code>和节点 <code>4 </code>的最近公共祖先是节点 <code>5。</code>因为根据定义最近公共祖先节点可以为节点本身。
</pre> 
<p><strong>说明:</strong></p> 
<ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul> 
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
var lowestCommonAncestor = function(root, p, q) {
    
};</code></pre> 
<h4 id="%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5">原题链接</h4> 
<p><a href="https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/description/?envType=study-plan-v2&amp;envId=coding-interviews" rel="nofollow" title="力扣">力扣</a></p> 
<h3 id="%E8%A7%A3%E6%9E%90">解析</h3> 
<p>注意一些树的节点之间会有大小关系，更方便于解题，例如二叉搜索树，二叉搜索树的左节点（包括其子节点上的值）小于根节点，右节点（包括其子节点上的值）大于根节点。</p> 
<p>例如类似题目</p> 
<h4 id="%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9">二叉搜索树的最近公共节点</h4> 
<p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/description/?envType=study-plan-v2&amp;envId=coding-interviews" rel="nofollow" title="力扣">力扣</a></p> 
<h4 id="%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3">核心思想</h4> 
<p>方法一（递归）</p> 
<p>1.确定入参和出参，入参：1需要检索当前节点root，2需要检索当前的节点下是否有目标节点p、q；出参：返回的目标节点或最近公共节点。</p> 
<p>2.确定上下层关系，当root的左右两边节点出现p和q时，当前节点为公共的父节点。当只有一个左右节点中只有一个节点为目标节点时，返回目标节点。</p> 
<p>3.找出口，当root不存在、或者root为目标节点时，返回root。</p> 
<p>方法二（广度优先+哈希表存储父节点）：</p> 
<p>1.首先用广度优先算法遍历每个接地那，构建一个哈希表存储子节点对应父节点的关系。</p> 
<p>2.求出p的所有父节点放入集合中。</p> 
<p>3.从q节点往上取所有父节点，直到有父节点在p的父节点集合中存在。</p> 
<h4 id="%E7%AD%94%E6%A1%88">答案</h4> 
<p>方法一（递归）</p> 
<pre><code class="language-javascript">var lowestCommonAncestor = function (root, p, q) {
  if (!root || root === p || root === q) return root;
  const left = lowestCommonAncestor(root.left, p, q);
  const right = lowestCommonAncestor(root.right, p, q);
  if(left &amp;&amp; right){
      return root
  }else{
      return left||right
  }
};</code></pre> 
<p>方法二（广度优先+哈希表存储父节点）</p> 
<pre><code class="language-javascript">var lowestCommonAncestor = function(root, p, q) {
    let queue = [root],parent = new Map();
    while(queue.length &amp;&amp; (!parent.has(p) || !parent.has(q))){
        const node = queue.shift();
        node.left &amp;&amp; queue.push(node.left);
        node.right &amp;&amp; queue.push(node.right);
        node.left &amp;&amp; parent.set(node.left, node);
        node.right &amp;&amp; parent.set(node.right,node);
    }
    let pSet = new Set(),node = p;
    pSet.add(node);
    while(parent.has(node)){
        pSet.add(parent.get(node));
        node = parent.get(node);
    }
    node = q;
    if(pSet.has(node)) return node;
    while(parent.has(node)){
        node = parent.get(node);
        if(pSet.has(node)) return node;
    }
    return null;    
};</code></pre> 
<h3 id="%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91">重建二叉树<br>  </h3> 
<p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p> 
<p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p> 
<p><strong>示例 1:</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="302" src="https://images2.imgbox.com/7d/b5/KqEwWih1_o.jpg" width="277"></p> 
<pre><strong>Input:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
<strong>Output:</strong> [3,9,20,null,null,15,7]
</pre> 
<p><strong>示例 2:</strong></p> 
<pre><strong>Input:</strong> preorder = [-1], inorder = [-1]
<strong>Output:</strong> [-1]
</pre> 
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
var buildTree = function(preorder, inorder) {

};</code></pre> 
<h4 id="%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5">题目链接</h4> 
<p><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/?envType=study-plan-v2&amp;envId=coding-interviews" rel="nofollow" title="力扣">力扣</a></p> 
<h3>解析</h3> 
<p>前序遍历的顺序是根左右，中序遍历的顺序为左根右。</p> 
<p>以示例1解释，[3,9,20,15,7]前序遍历的第一个值3一定为根的值，我们将它取出，前序遍历剩余[9,20,15,7]。<br> 3在中序遍历[9,3,15,20,7]中的位置，可以分割出[9]，[15,20,7]，我们知道[9]一定是根3的左子树的中序遍历，[15,20,7]一定是根3的右子树的中序遍历。</p> 
<h4>核心思想</h4> 
<p>递归</p> 
<p>1.确定入参和出参，入参：前序遍历的后续遍历的序列。出参：根据遍历返回的当前根节点。</p> 
<p>2.确定上下层关系，每次根据前序找到根节点，根据根节点在中序中划分属于左右节点的部分。</p> 
<p>f(p,q)={ val:xxx,left:f(pl,ql),right:f(pr,qr)}。</p> 
<p>3.找出口，当preorder不存在时。</p> 
<h4>答案</h4> 
<p>递归</p> 
<pre><code class="language-javascript">var buildTree = function(preorder, inorder) {
    if (!preorder.length) {
        return;
    }
    const val = preorder.shift()
    const index = inorder.findIndex(item =&gt; item === val)
    const left = inorder.slice(0, index)
    const right = inorder.slice(index + 1)
    return {
        val,
        left: buildTree(preorder.slice(0, index), left),
        right: buildTree(preorder.slice(index), right)
    }
};
</code></pre> 
<h3 id="%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97">二叉搜索树的后序遍历序列</h3> 
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p> 
<p>参考以下这颗二叉搜索树：</p> 
<pre>     5
    / \
   2   6
  / \
 1   3</pre> 
<p><strong>示例 1：</strong></p> 
<pre><strong>输入: </strong>[1,6,3,2,5]
<strong>输出: </strong>false</pre> 
<p><strong>示例 2：</strong></p> 
<pre><strong>输入: </strong>[1,3,2,6,5]
<strong>输出: </strong>true</pre> 
<pre><code class="language-javascript">/**
 * @param {number[]} postorder
 * @return {boolean}
 */
var verifyPostorder = function(postorder) {

};</code></pre> 
<h4>原题链接</h4> 
<p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/description/?envType=study-plan-v2&amp;envId=coding-interviews" rel="nofollow" title="力扣">力扣</a></p> 
<h3>解析</h3> 
<p>二叉搜索树的左节点（包括其子节点上的值）小于根节点，右节点（包括其子节点上的值）大于根节点。故二叉搜索树可以只根据一个顺序的序列结果就可以构造树。</p> 
<h4>核心思想</h4> 
<p>递归</p> 
<p>1.确定入参和出参，入参：当前序列。</p> 
<p>2.确定上下层关系，取序列最后一个节点为根节点，每次根据当前序列，找到第一个大于根节点的，该元素的左边应该全部小于根节点，右边应该全部大于根节点，满足的话对左右两边的序列进行递归，f(x)=f(x.left)&amp;&amp;f(x.right)。</p> 
<p>3.找出口，当preorder不存在时结束。</p> 
<h4>答案</h4> 
<p>递归</p> 
<pre><code class="language-javascript">var verifyPostorder = function(postorder) {
    if (postorder.length &lt;= 2) {
        return true
    }
    const root = postorder.pop()
    let index = postorder.findIndex(num =&gt; num &gt; root)
    index = index === -1 ? postorder.length : index
    const left = postorder.slice(0, index)
    const right = postorder.slice(index)
    if(!(left.every(num =&gt; num &lt; root) &amp;&amp; right.every(num =&gt; num &gt; root))){
        return false
    }
    return  verifyPostorder(left) &amp;&amp; verifyPostorder(right)
};</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1711f0750fee43d2975e9ddc005d9104/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">小程序van-popup组件实现模糊搜索，后选择功能</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/714376523bdc78092ffdc0ce32a3def0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue3中pinia用法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>