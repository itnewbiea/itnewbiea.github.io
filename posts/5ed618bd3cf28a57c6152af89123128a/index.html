<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Yolov5（6.1）学习历险记 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Yolov5（6.1）学习历险记" />
<meta property="og:description" content="目录
YOLO系列总体构架：
CBS模块
torch.nn.Conv2d:对由多个输入平面组成的输入信号进行二维卷积。
Batch Normalization 归一化处理
SiLu（Swish）激活函数
C3模块
Bottleneck：瓶颈层
SPPF（快速空间金字塔池化）
SPP：
nn.MaxPool2d:最大池化操作 SPPF ：
YOLO系列总体构架： 对应到YOLOV5中，具体backbone构架如下：
CBS模块 首先CBS模块在common.py中定义为Class Conv：
class Conv(nn.Module): # Standard convolution def __init__(self, c1, c2, k=1, s=1, p=None, g=1, act=True): # ch_in, ch_out, kernel, stride, padding, groups super().__init__() self.conv = nn.Conv2d(c1, c2, k, s, autopad(k, p), groups=g, bias=False) self.bn = nn.BatchNorm2d(c2) self.act = nn.SiLU() if act is True else (act if isinstance(act, nn.Module) else nn.Identity()) def forward(self, x): return self." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5ed618bd3cf28a57c6152af89123128a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-06T18:37:53+08:00" />
<meta property="article:modified_time" content="2022-11-06T18:37:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Yolov5（6.1）学习历险记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="YOLO%E7%B3%BB%E5%88%97%E6%80%BB%E4%BD%93%E6%9E%84%E6%9E%B6%EF%BC%9A-toc" style="margin-left:0px;"><a href="#YOLO%E7%B3%BB%E5%88%97%E6%80%BB%E4%BD%93%E6%9E%84%E6%9E%B6%EF%BC%9A" rel="nofollow">YOLO系列总体构架：</a></p> 
<p id="CBS%E6%A8%A1%E5%9D%97-toc" style="margin-left:0px;"><a href="#CBS%E6%A8%A1%E5%9D%97" rel="nofollow">CBS模块</a></p> 
<p id="torch.nn.Conv2d%3A%E5%AF%B9%E7%94%B1%E5%A4%9A%E4%B8%AA%E8%BE%93%E5%85%A5%E5%B9%B3%E9%9D%A2%E7%BB%84%E6%88%90%E7%9A%84%E8%BE%93%E5%85%A5%E4%BF%A1%E5%8F%B7%E8%BF%9B%E8%A1%8C%E4%BA%8C%E7%BB%B4%E5%8D%B7%E7%A7%AF%E3%80%82-toc" style="margin-left:40px;"><a href="#torch.nn.Conv2d%3A%E5%AF%B9%E7%94%B1%E5%A4%9A%E4%B8%AA%E8%BE%93%E5%85%A5%E5%B9%B3%E9%9D%A2%E7%BB%84%E6%88%90%E7%9A%84%E8%BE%93%E5%85%A5%E4%BF%A1%E5%8F%B7%E8%BF%9B%E8%A1%8C%E4%BA%8C%E7%BB%B4%E5%8D%B7%E7%A7%AF%E3%80%82" rel="nofollow">torch.nn.Conv2d:对由多个输入平面组成的输入信号进行二维卷积。</a></p> 
<p id="Batch%20Normalization%20%E5%BD%92%E4%B8%80%E5%8C%96%E5%A4%84%E7%90%86-toc" style="margin-left:40px;"><a href="#Batch%20Normalization%20%E5%BD%92%E4%B8%80%E5%8C%96%E5%A4%84%E7%90%86" rel="nofollow">Batch Normalization 归一化处理</a></p> 
<p id="SiLu%EF%BC%88Swish%EF%BC%89%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#SiLu%EF%BC%88Swish%EF%BC%89%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0" rel="nofollow">SiLu（Swish）激活函数</a></p> 
<p id="C3%E6%A8%A1%E5%9D%97-toc" style="margin-left:0px;"><a href="#C3%E6%A8%A1%E5%9D%97" rel="nofollow">C3模块</a></p> 
<p id="Bottleneck%EF%BC%9A%E7%93%B6%E9%A2%88%E5%B1%82-toc" style="margin-left:40px;"><a href="#Bottleneck%EF%BC%9A%E7%93%B6%E9%A2%88%E5%B1%82" rel="nofollow">Bottleneck：瓶颈层</a></p> 
<p id="SPPF%EF%BC%88%E5%BF%AB%E9%80%9F%E7%A9%BA%E9%97%B4%E9%87%91%E5%AD%97%E5%A1%94%E6%B1%A0%E5%8C%96%EF%BC%89-toc" style="margin-left:0px;"><a href="#SPPF%EF%BC%88%E5%BF%AB%E9%80%9F%E7%A9%BA%E9%97%B4%E9%87%91%E5%AD%97%E5%A1%94%E6%B1%A0%E5%8C%96%EF%BC%89" rel="nofollow">SPPF（快速空间金字塔池化）</a></p> 
<p id="SPP%EF%BC%9A-toc" style="margin-left:40px;"><a href="#SPP%EF%BC%9A" rel="nofollow">SPP：</a></p> 
<p id="%C2%A0nn.MaxPool2d%3A%E6%9C%80%E5%A4%A7%E6%B1%A0%E5%8C%96%E6%93%8D%E4%BD%9C%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0nn.MaxPool2d%3A%E6%9C%80%E5%A4%A7%E6%B1%A0%E5%8C%96%E6%93%8D%E4%BD%9C%C2%A0" rel="nofollow"> nn.MaxPool2d:最大池化操作 </a></p> 
<p id="SPPF%20%EF%BC%9A-toc" style="margin-left:40px;"><a href="#SPPF%20%EF%BC%9A" rel="nofollow">SPPF ：</a></p> 
<h2 id="YOLO%E7%B3%BB%E5%88%97%E6%80%BB%E4%BD%93%E6%9E%84%E6%9E%B6%EF%BC%9A">YOLO系列总体构架：</h2> 
<p><img alt="" height="327" src="https://images2.imgbox.com/1c/fd/buNJcq6e_o.png" width="1200"></p> 
<p> 对应到YOLOV5中，具体backbone构架如下：</p> 
<p style="text-align:center;"><img alt="" height="407" src="https://images2.imgbox.com/ca/a5/2orT2pPF_o.png" width="153"></p> 
<h2 id="CBS%E6%A8%A1%E5%9D%97">CBS模块</h2> 
<p>首先CBS模块在common.py中定义为Class Conv：</p> 
<pre><code class="language-python">class Conv(nn.Module):
    # Standard convolution
    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, act=True):  # ch_in, ch_out, kernel, stride, padding, groups
        super().__init__()
        self.conv = nn.Conv2d(c1, c2, k, s, autopad(k, p), groups=g, bias=False)
        self.bn = nn.BatchNorm2d(c2)
        self.act = nn.SiLU() if act is True else (act if isinstance(act, nn.Module) else nn.Identity())

    def forward(self, x):
        return self.act(self.bn(self.conv(x)))

    def forward_fuse(self, x):
        return self.act(self.conv(x))</code></pre> 
<p> CBS这个名字就很容易理解啦（C代表Conv，B代表BatchNorm2d，S代表SiLu激活函数）。          运算顺序由前向传播def forward来定义：首先对输入信号进行二维卷积（Conv2d）然后到BN层进行归一化处理，将结果传到激活函数部分。之前版本用的是Leaky Relu激活函数，6.X版本换成了SiLu激活函数。</p> 
<h3 id="torch.nn.Conv2d%3A%E5%AF%B9%E7%94%B1%E5%A4%9A%E4%B8%AA%E8%BE%93%E5%85%A5%E5%B9%B3%E9%9D%A2%E7%BB%84%E6%88%90%E7%9A%84%E8%BE%93%E5%85%A5%E4%BF%A1%E5%8F%B7%E8%BF%9B%E8%A1%8C%E4%BA%8C%E7%BB%B4%E5%8D%B7%E7%A7%AF%E3%80%82"><span style="color:#956fe7;"><strong>torch.nn.Conv2d:对由多个输入平面组成的输入信号进行二维卷积。</strong></span></h3> 
<blockquote> 
 <p>一维卷积卷积核只能在长度方向上进行滑窗操作，二维卷积可以在长和宽方向上进行滑窗操作，三维卷积可以在长、宽以及channel方向上进行滑窗操作。一个<a href="https://so.csdn.net/so/search?q=%E5%8D%B7%E7%A7%AF%E6%A0%B8&amp;spm=1001.2101.3001.7020" title="卷积核">卷积核</a>运算一次得到一个值，output channel取决于卷积核的个数。</p> 
</blockquote> 
<blockquote> 
 <p>self.Conv=nn.Conv2d(c1,c2,k,s,autopad(k,p),groups=g,bias=False)                               </p> 
 <p>c1:输入通道数      c2:输出通道数     </p> 
 <p>k:卷积核大小        s:步长</p> 
 <p></p> 
 <p>autopad:表示需不需要对特征图进行填充。当指定p值时按照p值进行填充，当p值为默认时则通过autopad函数进行填充。                                                                                               </p> 
 <p></p> 
 <p>groups：表示分组卷积，g=1时默认使用正常的卷积，大于1则使用分组卷积；                 </p> 
 <p></p> 
 <p>dilation：表示是否使用空洞卷积（v5中默认为1不使用）。                                                     </p> 
 <p></p> 
 <p>那么！空洞卷积（扩张卷积）可以增加感受野，分组卷积可以减少计算量做到模型轻量化（原理上是这样），具体实践效果可以根据不同的应用场景进行修改。</p> 
</blockquote> 
<h3 id="Batch%20Normalization%20%E5%BD%92%E4%B8%80%E5%8C%96%E5%A4%84%E7%90%86"><span style="color:#956fe7;"><strong>Batch Normalization 归一化处理</strong></span></h3> 
<blockquote> 
 <p>在卷积神经网络的卷积层后一般会添加BatchNorm2d进行数据归一化处理，使数据在进行激活函数非线性处理单元之前不会因为数据过大而导致网络性能不稳定。</p> 
 <p>目的：使特征图满足均值为0，方差为1的分布规律。对输入batch的每一个特征通道进行Normalize。</p> 
</blockquote> 
<blockquote> 
 <p>nn.BatchNorm2d(num, eps=1e-05, momentum=0.1, affine=True,track_running_stats=True) </p> 
 <p>num_features：一般输入参数的shape为batch_size*num_features*height*width，即为其中特征的数量，即为输入BN层的通道数；     </p> 
 <p>eps：一个辅助计算值，避免计算时出现分母为0的情况；                                                        momentum：用于运算过程中均值和方差的一个估计参数                                                    </p> 
 <p>affine：当设置为True时，会给定可以学习的系数矩阵gamma和beta。</p> 
</blockquote> 
<h3 id="SiLu%EF%BC%88Swish%EF%BC%89%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0"><span style="color:#956fe7;"><strong>SiLu（Swish）激活函数</strong></span></h3> 
<blockquote> 
 <p>激活函数定义：在多层神经网络中，上层节点的输出和下层节点的输入之间具有一个函数关系，这个函数称为激活函数。</p> 
 <p>激活函数使神经网络具有非线性，决定感知机是否激发。这种非线性赋予了深度网络学习复杂函数的能力。如果不使用激活函数，则相当于f（x）=x，这也就是最原始的感知机，即每一层节点的输入都是上层输出的线性函数，使得网络的逼近能力有限。YOLOv5中激活函数实现的相关代码在utils/activations.py中</p> 
</blockquote> 
<table border="1" cellpadding="1" cellspacing="1" style="width:617px;"><tbody><tr><td style="width:69px;">名称</td><td style="width:175px;">图像</td><td style="width:135px;">用途</td><td style="width:235px;">缺点</td></tr><tr><td style="width:69px;">Sigmoid</td><td style="width:175px;"><img alt="" height="736" src="https://images2.imgbox.com/7b/17/2H5z2ffK_o.png" width="1064"></td><td style="width:135px;">将输入映射（0,1）区间，用来做二分类。对于一个极大的负值输入，它输出的值接近于0；对于一个极大的正值输入，它输出的值接近于1。</td><td style="width:235px;">反向传播时会存在梯度爆炸和梯度消失现象；且输出不是以0为中心，会降低学习效率。</td></tr><tr><td style="width:69px;">tanh</td><td style="width:175px;"><img alt="" height="591" src="https://images2.imgbox.com/1e/81/d4lvAMCx_o.png" width="828"></td><td style="width:135px;">tanh可以将输入映射到（-1,1）区间，解决Sigmoid不是以0为中心输出的问题</td><td style="width:235px;">梯度消失问题和幂运算导致训练时间长</td></tr><tr><td style="width:69px;">ReLU</td><td style="width:175px;"><img alt="" height="592" src="https://images2.imgbox.com/0a/88/brXA9DfX_o.png" width="833"></td><td style="width:135px;">ReLU将所有负值取作0，正值保持不变</td><td style="width:235px;">解决梯度消失问题且收敛速度快。但输出不是以0为中心，且可能某些神经单元永远不会被激活，导致相应参数不能被更新</td></tr><tr><td style="width:69px;">Leaky ReLU</td><td style="width:175px;"><img alt="" height="591" src="https://images2.imgbox.com/bd/32/2bKS02DV_o.png" width="847"></td><td style="width:135px;">Leaky ReLU与ReLU很相似，仅在输入小于0的部分，值为负，且有微小的梯度</td><td style="width:235px;">解决ReLU无效神经元的部分，但效果不一定总是好于ReLU</td></tr><tr><td style="width:69px;">SiLU</td><td style="width:175px;"><img alt="" height="425" src="https://images2.imgbox.com/15/82/Vjrt0k3Z_o.png" width="609"></td><td style="width:135px;">对于较大的值，SiLU 的激活大约等于ReLU的激活。<br> 与 ReLU最大的不同，SiLU 的激活不是单调递增的。</td><td style="width:235px;"> <p>优点：无上界，有下界，平滑</p> <p>无上界：避免过拟合</p> <p>有下届：正则化效果更强</p> <p>平滑：处处可导，容易训练</p> </td></tr><tr><td style="width:69px;">Mish</td><td style="width:175px;"><img alt="" height="537" src="https://images2.imgbox.com/c4/a2/K6cdCI2e_o.png" width="723"></td><td style="width:135px;">在ImageNet上效果比ReLU和Swish都更好</td><td style="width:235px;">优点：无上界、无下界、光滑、非单调（自身就有正则化效果，使函数更加平滑，更容易泛化）。</td></tr></tbody></table> 
<p> CBS模块结构图：</p> 
<p class="img-center"><img alt="" height="255" src="https://images2.imgbox.com/58/43/7mZpKsGm_o.png" width="149"></p> 
<p></p> 
<h2 id="C3%E6%A8%A1%E5%9D%97">C3模块</h2> 
<pre><code class="language-python">class C3(nn.Module):
    # CSP Bottleneck with 3 convolutions
    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):  # ch_in, ch_out, number, shortcut, groups, expansion
        super().__init__()
        c_ = int(c2 * e)  # hidden channels
        self.cv1 = Conv(c1, c_, 1, 1)
        self.cv2 = Conv(c1, c_, 1, 1)
        self.cv3 = Conv(2 * c_, c2, 1)  # act=FReLU(c2)
        self.m = nn.Sequential(*(Bottleneck(c_, c_, shortcut, g, e=1.0) for _ in range(n)))
        # self.m = nn.Sequential(*[CrossConv(c_, c_, 3, 1, g, 1.0, shortcut) for _ in range(n)])

    def forward(self, x):
        return self.cv3(torch.cat((self.m(self.cv1(x)), self.cv2(x)), dim=1))</code></pre> 
<p>从代码可以看出，输入分成了俩部分，一部分先经过Cv1在经过self.m定义的Bottleneck操作，另一部分直接经过Cv2，俩部分最后汇总拼接后一起经过Cv3得到输出！其中定义了隐藏通道C_(我的理解就是在最终输出前的那些输出~）self.m操作使用nn.Sequential将n个Bottleneck串接到网络中（具体几个要结合配置文件里的参数计算!即number×depth_multiple个）</p> 
<h3 id="Bottleneck%EF%BC%9A%E7%93%B6%E9%A2%88%E5%B1%82"><span style="color:#956fe7;">Bottleneck：瓶颈层</span></h3> 
<pre><code class="language-python">class Bottleneck(nn.Module):
    # Standard bottleneck
    def __init__(self, c1, c2, shortcut=True, g=1, e=0.5):  # ch_in, ch_out, shortcut, groups, expansion
        super().__init__()
        c_ = int(c2 * e)  # hidden channels
        self.cv1 = Conv(c1, c_, 1, 1)
        self.cv2 = Conv(c_, c2, 3, 1, g=g)
        self.add = shortcut and c1 == c2

    def forward(self, x):
        return x + self.cv2(self.cv1(x)) if self.add else self.cv2(self.cv1(x))
</code></pre> 
<p>bottleneck layery又叫瓶颈层，在残差网络中提出这个概念。一般在较深的网络中，如resnet101中使用。（可以达到模型轻量化的一个效果）</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/45/66/40ulgeL3_o.png"></p> 
<p style="text-align:center;"> a 无Bottleneck                                                    b有Bottleneck</p> 
<p>Bottleneck结构就是为了降低参数量，Bottleneck先进行PW（Pointwise Convolution点卷积，即1x1卷积）对数据进行降维，再进行常规卷积核的卷积，最后PW对数据进行升维。</p> 
<blockquote> 
 <p>举个例子：直接使用3x3的卷积核。256维的输入直接经过一个3x3x256的卷积层，输出一个256维的特征图，那么参数量为：256（输入）x3x3x256（卷积核） =  589824                      Compare：先经过1x1的卷积核，再经过3x3的卷积核，最后经过一个1x1的卷积核。256维的输入先经过一个1x1x64的卷积层，再经过一个3x3x64的卷积层，最后经过一个1x1x256的卷积层，则总参数量为：256（输入）x1x1x64（卷积核） + 64（输入）x3x3x64（卷积核） + 64（输入）x1x1x256（卷积核） =  69632。</p> 
</blockquote> 
<p>那么在YOLOv5中呢先是1x1的卷积层（CBS)，然后再是3x3的卷积层（CBS），最后通过残差结构与初始输入相加。（add操作通道数不变，concat操作通道数相加）比起原始的Bottleneck结构少了一个1*1卷积的升维操作，因为我们用了Concat！</p> 
<p>另外在neck部分的C3操作是没有残差连接的，（shortcut=False，执行self.cv2(self.cv1(x))）</p> 
<p class="img-center"><img alt="" height="278" src="https://images2.imgbox.com/4a/1b/pBPicggZ_o.png" width="286"></p> 
<h2 id="SPPF%EF%BC%88%E5%BF%AB%E9%80%9F%E7%A9%BA%E9%97%B4%E9%87%91%E5%AD%97%E5%A1%94%E6%B1%A0%E5%8C%96%EF%BC%89">SPPF（快速空间金字塔池化）</h2> 
<h3 id="SPP%EF%BC%9A">SPP：</h3> 
<p> 在介绍SPPF之前先说SPP（5.X版本用的还是SPP,6.X 版本后作者对其作了改进）</p> 
<blockquote> 
 <p>SPP模块是何凯明2015年提出的。主要是为了解决对图像区域裁剪、缩放操作导致的图像失真等问题以及卷积神经网络对图相关重复特征提取的问题。通过此操作可以提高计算效率，节省计算时间。</p> 
</blockquote> 
<pre><code class="language-python">class SPP(nn.Module):
    # Spatial Pyramid Pooling (SPP) layer https://arxiv.org/abs/1406.4729
    def __init__(self, c1, c2, k=(5, 9, 13)):
        super().__init__()
        c_ = c1 // 2  # hidden channels
        self.cv1 = Conv(c1, c_, 1, 1)
        self.cv2 = Conv(c_ * (len(k) + 1), c2, 1, 1)
        self.m = nn.ModuleList([nn.MaxPool2d(kernel_size=x, stride=1, padding=x // 2) for x in k])

    def forward(self, x):
        x = self.cv1(x)
        with warnings.catch_warnings():
            warnings.simplefilter('ignore')  # suppress torch 1.9.0 max_pool2d() warning
            return self.cv2(torch.cat([x] + [m(x) for m in self.m], 1))
</code></pre> 
<p class="img-center"><img alt="" height="239" src="https://images2.imgbox.com/61/97/7y8PRaQs_o.png" width="286"></p> 
<h3 id="%C2%A0nn.MaxPool2d%3A%E6%9C%80%E5%A4%A7%E6%B1%A0%E5%8C%96%E6%93%8D%E4%BD%9C%C2%A0"><span style="color:#956fe7;"> nn.MaxPool2d:最大池化操作</span> </h3> 
<p>卷积操作中池化层提取重要信息的操作，可以去掉不重要的信息，减少计算开销。最大池化操作相当于核在图像上移动的时候，筛选出被核覆盖区域的最大值。目的就是为了保留输入的特征，但是同时把数据量减少，对于整个网路来说，进行计算的参数就变少了，就会训练的更快。</p> 
<blockquote> 
 <p>#class _MaxPoolNd(Module):<br>     __constants__ = ['kernel_size', 'stride', 'padding', 'dilation',<br>                      'return_indices', 'ceil_mode']<br>     return_indices: bool<br>     ceil_mode: bool</p> 
 <p>#  kernel_size ：表示做最大池化的窗口大小（卷积核大小）            stride ：步长<br>     padding ：填充        dilation ：控制窗口中元素步幅，扩张操作（空洞卷积）<br>     return_indices ：布尔类型，返回最大值位置索引<br>     ceil_mode ：布尔类型，为True，用向上取整的方法，计算输出形状；默认是向下取整。</p> 
</blockquote> 
<h3 id="SPPF%20%EF%BC%9A">SPPF ：</h3> 
<p>这个是YOLOv5作者在SPP基础上进行改进，速度比SPP要快很多所以叫SPPF。</p> 
<pre><code class="language-python">class SPPF(nn.Module):
    # Spatial Pyramid Pooling - Fast (SPPF) layer for YOLOv5 by Glenn Jocher
    def __init__(self, c1, c2, k=5):  # equivalent to SPP(k=(5, 9, 13))
        super().__init__()
        c_ = c1 // 2  # hidden channels
        self.cv1 = Conv(c1, c_, 1, 1)
        self.cv2 = Conv(c_ * 4, c2, 1, 1)
        self.m = nn.MaxPool2d(kernel_size=k, stride=1, padding=k // 2)

    def forward(self, x):
        x = self.cv1(x)
        with warnings.catch_warnings():
            warnings.simplefilter('ignore')  # suppress torch 1.9.0 max_pool2d() warning
            y1 = self.m(x)
            y2 = self.m(y1)
            return self.cv2(torch.cat([x, y1, y2, self.m(y2)], 1))</code></pre> 
<p class="img-center"><img alt="" height="292" src="https://images2.imgbox.com/d0/5f/Ax29FNtp_o.png" width="225"></p> 
<p> 在这里呢作者首先把最大池化操作的卷积核全部换成了5*5大小，能够达到同样的效果且计算速度更快。其次作者这里借鉴了残差结构，之前SPP模块中在CBS操作后有四个通道而这里通道数减半只有俩个，达到减少计算量的目的。（PS：可以针对这个点对网络结构进行改进~）</p> 
<p>那么总体上来说Yolov5 6.1版本backbone构架就是这个样子嘞，改进点当然很多~但是不建议把C3模块全部换掉，一般来说把C3全部改掉多半是会起到负作用的，可以针对Conv卷积进行改进，比如空洞卷积，分组卷积等去达到一个轻量化的效果；在backbone中加入注意力机制模块（一般放在深层比浅层要好，对浅层特征作用不大，并且与模块融合比单独加在某一层效果要好~但具体位置数量还是要根据应用场景进行调整）；针对空间金字塔部分也可以参考资料看看怎么改，去增强对浅层信息和深层信息的一个有机结合！最后祝我有多点tricks！能够早日写出小论文！</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4835ecfe732ad0bd830535e333a7dea5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">bootstrap5</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1fda460725d8c491968827b983ea692a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Openstack云平台脚本部署之计算节点服务配置（十五）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>