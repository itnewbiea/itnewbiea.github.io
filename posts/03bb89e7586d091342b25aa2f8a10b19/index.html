<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言中“##“的用法介绍 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言中“##“的用法介绍" />
<meta property="og:description" content="市面上有很多比较火的编程语言，比如Python、 JAVA、 Go等，你可能觉得C语言很古老、很落后。如果你有这种想法，那可能你只是一个初学的菜鸟。之前给大家分享《C语言中几种特殊标准定义和用法》忘记了C语言中一个重要的内容，就是 ## 的用法，可能绝大部分 C 程序员都不知道&#34;##&#34;隐藏用法，下面微点阅读小编就来给大家讲讲。
一、##的“表”用法
想必很多人都知道&#34;##&#34;的用法——它本质上是一个“胶水运算”（连接字符串的作用），用于把参数宏中的“形参”与其它没有天然分割的内容粘连在一起，例如：
#define def_u32_array(__name, __size) uint32_t array_##__name[__size];
实际中，我们可以这样使用：
def_u32_array(sample_buffer, 64)
宏展开的效果是：
uint32_t array_sample_buffer[64];
可以看到，&#34;array__&#34;与形参“__name”是没有天然分割的，因此要想将&#34;array_&#34;与&#34;__name&#34;所代表的内容（而不是__name本身）粘连在一起，就需要“##”运算的帮助。
另一方面，&#34;__name&#34;与&#34;[&#34;是具有天然分隔的——编译器不会认为&#34;__name&#34;与&#34;[&#34;是连接在一起的，因此这里并不需要画蛇添足的使用&#34;##&#34;运算——如果你这么做了，预编译器会毫不犹豫的告诉你语法错误。——这是&#34;##&#34;运算的普通用法，在过去转载的文章《C语言#和##连接符在项目中的应用(漂亮)》中也有详细介绍，这里就不再赘述。
二、## 的官方“里”用法
“##”还有一个很少为人所知的“里”用法，在介绍它之前，不得不首先说说由ANSI-C99标准引入的另外一个参数宏扩展——可变参数宏。举个例子：
#define safe_atom_code(...) \
{ \
uint32_t int_flag = __disable_irq(); \
__VA_ARGS__ \
__set_PRIMASK(int_flag); \
}
这里定义了一个宏&#34;safe_atom_code()&#34;，在括号内，无论你填写任何内容，都会被无条件的放置到“__VA_ARGS__”所在的位置，你可以认为括号里的“...”实际上就是对应&#34;__VA_ARGS__&#34;。比如，我们可以写下这样的代码：
/**
\fn void wr_dat (uint16_t dat)
\brief Write data to the LCD controller
\param[in] dat Data to write
*/
static __inline void wr_dat (uint_fast16_t dat) {
safe_atom_code(
LCD_CS(0);" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/03bb89e7586d091342b25aa2f8a10b19/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-04T10:35:18+08:00" />
<meta property="article:modified_time" content="2023-03-04T10:35:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言中“##“的用法介绍</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <p style="">市面上有很多比较火的编程语言，比如Python、 JAVA、 Go等，你可能觉得C语言很古老、很落后。如果你有这种想法，那可能你只是一个初学的菜鸟。之前给大家分享《C语言中几种特殊标准定义和用法》忘记了C语言中一个重要的内容，就是 ## 的用法，可能绝大部分 C 程序员都不知道"##"隐藏用法，下面微点阅读小编就来给大家讲讲。</p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">一、##的“表”用法</span></p> 
 <p style="">想必很多人都知道"##"的用法——它本质上是一个“胶水运算”（连接字符串的作用），用于把参数宏中的“形参”与其它没有天然分割的内容粘连在一起，例如：</p> 
 <p style="">#define def_u32_array(__name, __size) uint32_t array_##__name[__size];</p> 
 <p style="">实际中，我们可以这样使用：</p> 
 <p style="">def_u32_array(sample_buffer, 64)</p> 
 <p style="">宏展开的效果是：</p> 
 <p style="">uint32_t array_sample_buffer[64];</p> 
 <p style="">可以看到，"array__"与形参“__name”是没有天然分割的，因此要想将"array_"与"__name"所代表的内容（而不是__name本身）粘连在一起，就需要“##”运算的帮助。</p> 
 <p style="">另一方面，"__name"与"["是具有天然分隔的——编译器不会认为"__name"与"["是连接在一起的，因此这里并不需要画蛇添足的使用"##"运算——如果你这么做了，预编译器会毫不犹豫的告诉你语法错误。——这是"##"运算的普通用法，在过去转载的文章《C语言#和##连接符在项目中的应用(漂亮)》中也有详细介绍，这里就不再赘述。</p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">二、## 的官方“里”用法</span></p> 
 <p style="">“##”还有一个很少为人所知的“里”用法，在介绍它之前，不得不首先说说由ANSI-C99标准引入的另外一个参数宏扩展——可变参数宏。举个例子：</p> 
 <p style="">#define safe_atom_code(...) \</p> 
 <p style=""> { \</p> 
 <p style=""> uint32_t int_flag = __disable_irq(); \</p> 
 <p style=""> __VA_ARGS__ \</p> 
 <p style=""> __set_PRIMASK(int_flag); \</p> 
 <p style=""> }</p> 
 <p style="">这里定义了一个宏"safe_atom_code()"，在括号内，无论你填写任何内容，都会被无条件的放置到“__VA_ARGS__”所在的位置，你可以认为括号里的“...”实际上就是对应"__VA_ARGS__"。比如，我们可以写下这样的代码：</p> 
 <p style="">/**</p> 
 <p style=""> \fn void wr_dat (uint16_t dat)</p> 
 <p style=""> \brief Write data to the LCD controller</p> 
 <p style=""> \param[in] dat Data to write</p> 
 <p style="">*/</p> 
 <p style="">static __inline void wr_dat (uint_fast16_t dat) </p> 
 <p style="">{<!-- --></p> 
 <p style=""> safe_atom_code(</p> 
 <p style=""> LCD_CS(0);</p> 
 <p style=""> GLCD_PORT-&gt;DAT = (dat &gt;&gt; 8); /* Write D8..D15 */</p> 
 <p style=""> GLCD_PORT-&gt;DAT = (dat &amp; 0xFF); /* Write D0..D7 */</p> 
 <p style=""> LCD_CS(1);</p> 
 <p style=""> )</p> 
 <p style="">}</p> 
 <p style="">这个代码确保在向寄存器GCLD_PORT-&gt;DAT写入数据时不会被其它中断打断。</p> 
 <p style="">聪明的你也许很快就会提出这样的问题，上述宏跟下面的写法有什么区别呢？</p> 
 <p style="">#define safe_atom_code(__CODE) \</p> 
 <p style=""> { \</p> 
 <p style=""> uint32_t int_flag = __disable_irq(); \</p> 
 <p style=""> __CODE \</p> 
 <p style=""> __set_PRIMASK(int_flag); \</p> 
 <p style=""> }</p> 
 <p style="">你不仅提出了问题，甚至还实际测试了下，似乎完全等效，“根本没差别嘛！”——你惊呼道。然而，事实上并没有那么简单：</p> 
 <p style="">1.参数宏是通过“,”来作为分隔符来计算用户实际产传入了几个参数的，或者换句话说，在使用参数宏的时候，预编译器是看不懂C语法的——在它眼中，除了它所认识的少数符号外，其它东西都是无意义的字符串——由于在处理括号内部的内容时，它只认识","和"..."，因此当括号中的内容每增加一个","，与编译器就认为多了一个参数。</p> 
 <p style="">2.当你使用参数宏的时候，传入参数的个数（已“,”分开）必须与定义参数宏时候形参的数量完全一致；当不一致的时候，预编译器可能不会报错，而是直接无视了你的参数宏——把它传递到编译的下一阶段，因而往往会被认作是一个函数——事实上这个函数是不存在的，因此在链接阶段会报告某某函数未定义的错误。这时候你就会纳闷了，为啥我明明定义的是一个宏，编译器却把它当作函数呢？</p> 
 <p style="">可变参数宏的引入就解决了这个问题：</p> 
 <p style="">"..."只能放在参数宏形参列表的最后；</p> 
 <p style="">当用户的参数个数超过了规定的参数个数时，所有多出来的内容会一股脑的由“__VA_ARGS__”所背负；</p> 
 <p style="">当用户的参数个数正好等于形参的个数时，"__VA_ARGS__"就等效于一个空字符串</p> 
 <p style="">回头再来看前面的问题：</p> 
 <p style="">#define safe_atom_code(...)</p> 
 <p style="">与 </p> 
 <p style="">#define safe_atom_code(__CODE)</p> 
 <p style="">的差别在于，前者括号里可以放包括","在内的几乎任意内容；而后者则完全不能容忍逗号的存在——比如你调用了一个函数，函数的参数要用到都好隔开吧？再比如，你用到了逗号表达式……——想想都很酸爽。</p> 
 <p style="">其实，可变参数列表最初诞生的原因之一是为了解决与C函数的可变参数（va_args）配合使用的问题，例如：</p> 
 <p style="">#define log_info(__STRING, ...) printf(__STRING, __VA_ARGS__)</p> 
 <p style="">因此，使用的时候，我们可以这样写：</p> 
 <p style="">log_info("------------------------------------\r\n");</p> 
 <p style="">log_info(" Cycle Count : %d", total_cycle_cnt);</p> 
 <p style="">宏展开后实际上对应于：</p> 
 <p style="">printf("------------------------------------\r\n",);</p> 
 <p style="">printf(" Cycle Count : %d", total_cycle_cnt);</p> 
 <p style="">看似没有问题，注意到一个细节没有？在第一个printf()的最后多了一个","。虽然有些编译器，例如GCC并不会计较（也许就是一个warning），但对于广大洁癖严重的处女座程序员来说，这怎么能忍，于是在ANSI-C99标准引入可变参数宏的时候，又贴心了加了一个不那么起眼的语法：当下面的组合出现时 ",##__VA_ARGS__"，如果__VA_ARGS__是一个空字符串，则前面的","会一并被删除掉。因此，上面的宏可以改写为：</p> 
 <p style="">#define log_info(__STRING, ...) printf(__STRING,##__VA_ARGS__)</p> 
 <p style="">此时，前面的代码会被展开为：</p> 
 <p style="">printf("------------------------------------\r\n");</p> 
 <p style="">printf(" Cycle Count : %d", total_cycle_cnt);</p> 
 <p style="">处女座表示，这次可以安心睡觉了。</p> 
 <p style="">如果说这就是99%的C程序员都不知道的"##"隐藏用法，未免太对不起观众了，实际上本文的正片才刚刚开始。</p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">三、 ## 的骚操作</span></p> 
 <p style="">逗号表达式，一直关注公众号的朋友们想必都很熟悉——之前转载的文章《【C进阶】听说用 “ 逗号表达式 ” 仅仅为了秀技？》已经说的非常详细了，这里就不再赘述。简单说，就是逗号表达式中，逗号的最右边将作为表达式真正的返回值。 </p> 
 <p style="">结合前面关于",##__VA_ARGS__"用法的介绍，你们有没有意识到，其实这里的逗号不光可以是参数列表的分隔符，还可以是逗号表达式的运算符。结合__VA_ARGS__的特性，我们可以写出类似这样的宏：</p> 
 <p style="">#define EXAMPLE(...) ( 默认值 ,##__VA_ARGS__)</p> 
 <p style="">它有两种使用情况：</p> 
 <p style="">1.当我们使用参数宏的时候在括号里不填写任何内容，最终会展开为仅有默认值的情况：</p> 
 <p style="">EXAMPLE();</p> 
 <p style="">被展开为：</p> 
 <p style="">( 默认值 )</p> 
 <p style="">2.当我们提供了任意的有效值时，则会被展开成逗号表达式：</p> 
 <p style="">EXAMPLE(我们提供的值);</p> 
 <p style="">被展开为：</p> 
 <p style="">( 默认值, 我们提供的值 )</p> 
 <p style="">根据逗号表达式的特性，此时，默认值会被丢弃掉（有些编译器会报告表达式无效的warning，这是正常的，因为编译器注意到“默认值”所代表的表达式实际上被丢弃了，它觉得我们写了一个无用的表达式）。</p> 
 <p style="">这个技巧其实对API的封装特别有效：它允许我们简化函数API的使用，比如在用户忽略的情况下，自动给函数填充某些默认值，而在用户主动提供参数的情况下，替代那些默认值。这里我举两个现实中的例子：</p> 
 <p style="">(1)为函数提供默认的参数</p> 
 <p style="">假设我们有一个初始化函数，初始化函数允许用户通过结构体来配置一些参数：</p> 
 <p style="">typedef struct xxxx_cfg_t {<!-- --></p> 
 <p style=""> ...</p> 
 <p style="">} xxxx_cfg_t;</p> 
 <p style="">int xxxx_init(xxxx_cfg_t *cfg_ptr);</p> 
 <p style="">为了简化用户的配置过程，初始化函数会检查指针cfg_ptr是否为NULL，如果为NULL则自动使用默认配置，反之将使用用户定义的配置。此时，我们可以通过宏来提供默认值NULL：</p> 
 <p style="">#define XXXX_INIT(...) xxxx_init((NULL,##__VA_ARGS__))</p> 
 <p style="">(2)为消息处理提供默认的掩码配置</p> 
 <p style="">有些消息处理函数可以批量的处理某一类消息，而具体选中了哪些消息类别，则通常由二进制掩码来表示，例如：</p> 
 <p style="">typedef struct msg_t msg_t;</p> 
 <p style="">struct {<!-- --></p> 
 <p style=""> uint16_t msg;</p> 
 <p style=""> uint16_t mask;</p> 
 <p style=""> int (*handler)(msg_t *msg_ptr);</p> 
 <p style="">} msg_t;</p> 
 <p style="">此时我们完全可以借助宏来构建一套语法糖：</p> 
 <p style="">#define def_msg_map(__name, ...) \</p> 
 <p style=""> const msg_t __name[] = {__VA_ARGS__};</p> 
 <p style=""> </p> 
 <p style="">#define add_msg(__msg, __handler, ...) \</p> 
 <p style=""> { \</p> 
 <p style=""> .msg = (__msg), \</p> 
 <p style=""> .handler = &amp;(__handler), \</p> 
 <p style=""> .msk = (0xFFFF, ##__VA_ARGS__), \</p> 
 <p style=""> }</p> 
 <p style="">通过宏 add_msg 我们注意到，当用户刻意省略设置msk时，我们就给出默认值 0xFFFF——这很可能表示，在进行消息处理的时候，消息必须严格匹配才能交给对应的处理函数；当用户指定 msk 时，则可能表示某一类消息都交给同一个消息处理函数来处理。例如：</p> 
 <p style="">/*! \note 高字节表示操作的类别:</p> 
 <p style=""> 比如0x00表示控制类，0x01表示WRITE，0x02表示READ</p> 
 <p style=""> */</p> 
 <p style="">enum {<!-- --></p> 
 <p style=""> SIGN_UP = 0x0001,</p> 
 <p style=""> WRITE_MEM = 0x0100,</p> 
 <p style=""> WRITE_SRAM = 0x0101,</p> 
 <p style=""> WRITE_FLASH = 0x0102,</p> 
 <p style=""> WRITE_EEPROM = 0x0103,</p> 
 <p style=""> </p> 
 <p style=""> READ_MEM = 0x0200,</p> 
 <p style=""> READ_SRAM = 0x0201,</p> 
 <p style=""> READ_FLASH = 0x0202,</p> 
 <p style=""> READ_EEPROM = 0x0203,</p> 
 <p style="">};</p> 
 <p style="">extern int iap_sign_up_handler(msg_t *msg_ptr);</p> 
 <p style="">extern int iap_write_mem(msg_t *msg_ptr);</p> 
 <p style="">extern int iap_read_mem(msg_t *msg_ptr);</p> 
 <p style="">def_msg_map( iap_message_map</p> 
 <p style=""> /* 严格的将 SIGN_UP 映射到 对应的处理函数中 */</p> 
 <p style=""> add_msg( SIGN_UP, iap_sign_up_handler ),</p> 
 <p style=""> /* 批量处理所有的WRITE操作，使用掩码进行过滤*/</p> 
 <p style=""> add_msg( WRITE_MEM, iap_write_mem, 0xFF00 ), </p> 
 <p style=""> /* 批量处理所有的READ操作，使用掩码进行过滤 */</p> 
 <p style=""> add_msg( READ_MEM, iap_read_mem, 0xFF00 ),</p> 
 <p style="">)</p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">四、结语</span></p> 
 <p style="">宏不是阻碍代码开发和可读性的魔鬼，对自己不熟悉知识的傲慢才是。</p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style="">来源：<a class="kdocs-link" style="color:#0A6CFF;" href="https://www.weidianyuedu.com" rel="nofollow noopener noreferrer" target="_blank">https://www.weidianyuedu.com</a></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0a0558f24fcd6e2059558def59562369/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">sql-labs靶场练习</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ff086142b59ae62cea13b3636bf08e4d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言 找第一个只出现一次的字符</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>