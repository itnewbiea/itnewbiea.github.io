<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【论文学习】Adversarial Examples on Graph Data: Deep Insights into Attack and Defense论文学习 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【论文学习】Adversarial Examples on Graph Data: Deep Insights into Attack and Defense论文学习" />
<meta property="og:description" content="摘要 类似GCN这样的图深度学习模型近几年咋一些图数据任务上取得了很好的效果。与其他的深度学习模型类似，图深度学习模型通常也会遭受到对抗攻击。但是，跟非图数据相比，图数据中的离散特征，图连接以及对于扰动的不可感知的不同定义给图对抗攻击带来了许多挑战。在这篇文章中，作者提出了攻击和防御的方法。在攻击的时候，作者发现图数据的这些离散特性可以通过引入积分梯度来解决。这个积分梯度可以反映出对图中的某一条边或者某一个特征做干扰带来的影响（注意，这里的特征也必须是离散的）。在做防御的时候，作者发现通过对抗攻击得到的图跟正常的图在数据上不同的。基于这种观察，作者提出了一个防御方案，可以对图做检查，并且恢复潜在的对抗扰动。作者使用了好几个数据集证明了自己的方法的有效性。
Introduction 图被广泛用用于许多现实关系任务中，诸如社交网络，引文网络，交易网络以及控制流任务。在图数据中最广泛的一个任务是结点分类任务：对于一个图，已知其中一部分结点的标签，目的是对于其他未标注结点做预测。该任务可以应用在许多任务中，例如对于引文网络中论文的主题做预测，对推荐系统中的消费者的类型做预测。
深度学习方法因为缺乏鲁棒性而一直被大家所讨论。这些图神经网络模型在被实施了对抗攻击的时候表现出来的脆弱性使得它很难被应用在一些safety-critical场景中。在图神经网络中，结点可以是社交网络中的一个用户，也可以是一个商业网站。一个恶意用户可以修改自己的profile或者是跟目标用户之间建立联系从而误导系统的分类。同样的，通过对特定的商品添加虚假评论也可以欺骗到推荐系统。
不能将已有的非图数据中的对抗攻击方法应用在图神经网络中，原因在于图数据的输入是离散的。具体而言，图结点的特征通常都是离散的；图数据中的边，尤其是非权重图中的边通常也都是离散的。为了解决这个问题，许多人提出了贪婪算法来攻击图深度学习系统（Nettack）。贪婪算法是不断的迭代，来扰动特征或者边。在这篇文章中，作者指出来，就算是离散数据，也可以通过引入积分梯度来计算它的梯度。积分梯度（Integrated gradient）第一次被提出来是用于解决Shapely value，将部分梯度（partial gradient）和输入特征联系到一起。相比较贪婪选择算法，积分梯度可以大大提高结点选择和边选择的效率。
跟对抗攻击相比，在图模型上对于对抗攻击的防御还没有怎么被研究。在这篇文章中，作者指出来，图神经网络模型之所以有脆弱性，是因为这些模型是基于图结构，来不断的聚合结点周围的其他节点的特征。也就是说，在对某个结点做预测的时候，模型会依赖于周围最邻近结点的特征。作者在对现有的攻击产生的扰动做分析的时候，发现，将一个结点周围的特征不同的其他结点与当前结点建立连边会带来很大的影响。在这篇文章中，作者发现，只要对一个图的邻接矩阵做预处理就可以确定这类边。对于拥有词袋特征（BOW，bag-of-words）的结点而言，Jaccard系数可以有效的衡量结点之间的相似性。通过把不相似的两个结点之间的连边去除，可以有效的防御住有目标的对抗攻击，并且可以保证GCN模型上的准确率不会下降。作者通过使用许多真实世界的数据集，发现提出的攻击和防御是十分有效的。
Preliminaries（基本定义） 1）图卷积网络（GCN） GCN是在半监督结点分类领域被广泛使用的方法。
GCN通常使用如下公式对于邻居节点的特征做聚合（其中的D代表的是对角阵）：
一个2层的GCN就可以很好的解决半监督结点分类任务了。这个模型可以被描述如下：
其中的A是一个对称矩阵，如下所示，其中的D是对角阵。
2）基于梯度的对抗攻击 梯度被广泛使用来攻击深度学习模型。攻击者可以使用损失函数的梯度或者是模型的梯度来实施攻击。有两个典型的例子就是FGSM和JSMA攻击。FGSM是朝着损失函数的梯度方向做梯度上升。这个生成扰动的过程可以描述如下：
JSMA攻击是利用DNN模型的前向偏差（forward derivative）。给定一个前向推理的神经网络F和样本X，计算Jacabian的过程如下所示：
如果攻击者的目标是使得结点被分类成t类别，那就应该使得 F t ( x ) F_t(x) Ft​(x)上升，使得 F j ( x ) F_j(x) Fj​(x)下降。JSMA的对抗显著图可以定义如下：
已知一个正常的样本，攻击者可以得到显著图（saliency map）并且每次以一个很小扰动迭代的生成扰动，直到目标节点的标签被翻转。对于无目标攻击而言，攻击者的目的是最小化真实标签类别的预测分数。
3）对抗攻击的防御 尽管图上的对抗攻击是一个相对很新的问题，已经有一些工作研究对于卷积神经网络的对抗攻击。对于图像而言，由于特征空间是连续的，使用一点点扰动就可以实现对抗攻击。因此，在很多情况下，对图像添加一些随机化操作就可以防御住攻击。其他对于输入的预处理方法，诸如本地平滑（local smoothing）以及图像压缩都可以用于防御住攻击。这些预处理方法基于的前提假设是，一个像素周围的其他像素应该是相似的。也可以使用对抗训练来增强模型的鲁棒性。
基于积分梯度的攻击 尽管FGSM和JSMA并不是最复杂的攻击方法，它们也没有被很好的应用在图问题中。对于图像数据而言，FGSM和JSMA的成功源于特征在像素空间上的连续性。但是最近的研究表明，这些方法直接应用在图领域不能带来很好的攻击效果。就有一些研究者使用贪婪算法或者是强化学习方法来解决图数据这类离散数据，但是贪婪算法和强化学习通常都是很昂贵并且费时的。
图中的结点特征通常都是词袋类型的数据，也就是要么是0，要么是1。不带权重的边也通常是离散的，要么是0，要么是1。使用Vanilla FGSM和JSMA的问题在于梯度是不准确的。给定一个目标节点t，对于FGSM攻击而言，
可以衡量节点中每个特征针对于损失函数的重要性。对于结点n的特定特征i而言，这个梯度越大说明将这个特征修改为1就会带来比较大的影响。但是如果这样这样做就会带来两个问题：（1）特征值可能本来就是1，那就不能再对它做修改了。（2）就算特征本来就是0，GCN模型可能学不到0和1的线性函数，所以这个扰动是不可预测的。JSMA同样会有这样的问题。换句话说，vinilla梯度会有本地梯度问题（local gradient）。以一个简单的RELU为例，当x从0增加到1的时候，Relu的值也从0增加到1。但是在x=0的时候计算梯度还是0，所以无法准确的捕捉到模型的行为。为了解决这个问题，作者提出了积分梯度，而不是直接使用攻击的vanilla偏差。积分梯度在2017年的时候被提出来，可以获得特征属性的偏差。
积分梯度的定义如下：
给定一个模型F，x’是一个baseline input（基准输入），x是真实的输入。考虑从x’到输入x之间的一条直线路径，积分梯度就是对这条路径上的所有梯度进行累加。例如，对于输入x的第i个特征而言，积分梯度IG可以定义如下：
如果是有目标攻击，就是应该要最大化F值，所以当图中的特征或者边是1时，可以选择有最低的负值IG分数的特征或者边，将其修改成0。如果是无目标攻击，就是应该要最小化真实标签的预测分数，所以需要选择有最高IG分数的维度，将其修改成0。 （这里没有理解，可以看看原文）
但是不像图像一样，我们可以将一个全黑的图像（black image）设置成baseline input。作者使用了一个全0或者是全1的特征/邻接矩阵来表示1-&gt;0的扰动或者是0-&gt;1的扰动。当去除一条特定边或者是将一个特定的特征从1改成0后，作者是将邻接矩阵A和特征矩阵X设置成全0，然后逐渐的在当前全0的矩阵上添加边或者特征，然后观察F的整体变化。相反的，当添加一条特定边或者将一个特定的特征从0改成1后，首先将A和X都设置成全1，然后逐渐的移除某条边或者某个特征，然后观察F的整体变化。对于边攻击（edge attack）的IG分数计算如下所示：
算法1展示了无目标的IG-JSMA的伪代码。
可以看到，对于无目标攻击而言，要做的是选择IG最大的边或者特征。
图对抗攻击的防御 为了防御GCN上的对抗攻击，作者首先提出一个假设，那就是，GCN模型之所以很容易被攻击，是因为它极强的依赖于图结构和邻居节点特征的聚合。在被攻击图上训练得到的模型就容易受到这个攻击边界的影响。目前公认的一点是，在一个模型上训练得到的对抗样本可以迁移到其他模型中。目前对于GCN模型的对抗攻击是很成功的，原因在于这些被攻击的图可以直接被用于训练一个新模型。基于这种攻击方式，一个可行的防御方法是让邻接矩阵变得可训练（trainable）。
作者之后开始验证这种防御方法，也就是使得边权重在GCN模型中变得可训练。在没有添加任何防御方法的时候，在被攻击后，目标节点以0.998的置信度被误分类。作者的防御方法是首先对于边的权重做初始化，不修改其他东西，然后再对GCN模型做训练。作者发现，这样的一个简单的防御方法就可以使得目标节点以高置信度0.912被正确分类。为了解释为什么这个防御方法奏效，作者观察了攻击的特点。首先，对边做扰动比直接修改特征要更有效。 在现有的所有攻击方法（FGSM，JSMA和IG-JSMA）中，这一点都是奏效的。只对特征做干扰是很难修改目标节点的预测结果的。而且，很多攻击方法都是倾向于添加边而不是删除边，这样带来的攻击效果要更好。 第二，有着更多邻居节点的结点更难被攻击。这是在之前的工作中就被提到过的。之前就有学者发现，有着更高degree的结点在干净图和攻击图中都有着更好的分类准确率。最后，在攻击的时候，倾向于将目标节点和有着不同特征feature或者不同标签label的结点之间建立连接。在发现了这一点之后，可以借用这点特性来实施攻击。作者使用了CORA-ML数据集来验证这些假设。为了评估结点之间的特征的相似性，作者使用了Jaccard相似性分数，因为CORA-ML数据集中的结点特征是0/1离散的，bag-of-word词袋特征。但是对于那些其他类型的特征，诸如数字特征，作者使用了其他的相似性度量方式。
对于binary离散特征，作者使用了如下的相似性计算公式：
其中的 M 11 M_{11} M11​表示结点u中特征为1，结点v中特征也为1; M 10 M_{10} M10​表示结点u中特征为1，结点v中特征为0； M 01 M_{01} M01​表示结点u中特征为0，结点v中特征为1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/3972f4e0f718ef358eed6c0483224357/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-05T16:41:56+08:00" />
<meta property="article:modified_time" content="2022-01-05T16:41:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【论文学习】Adversarial Examples on Graph Data: Deep Insights into Attack and Defense论文学习</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>摘要</h3> 
<p>类似GCN这样的图深度学习模型近几年咋一些图数据任务上取得了很好的效果。与其他的深度学习模型类似，图深度学习模型通常也会遭受到对抗攻击。但是，跟非图数据相比，图数据中的离散特征，图连接以及对于扰动的不可感知的不同定义给图对抗攻击带来了许多挑战。在这篇文章中，作者提出了攻击和防御的方法。在攻击的时候，作者发现图数据的这些离散特性可以通过引入积分梯度来解决。这个积分梯度可以反映出对图中的某一条边或者某一个特征做干扰带来的影响（注意，这里的特征也必须是离散的）。在做防御的时候，作者发现通过对抗攻击得到的图跟正常的图在数据上不同的。基于这种观察，作者提出了一个防御方案，可以对图做检查，并且恢复潜在的对抗扰动。作者使用了好几个数据集证明了自己的方法的有效性。</p> 
<h3><a id="Introduction_2"></a>Introduction</h3> 
<p>图被广泛用用于许多现实关系任务中，诸如社交网络，引文网络，交易网络以及控制流任务。在图数据中最广泛的一个任务是结点分类任务：对于一个图，已知其中一部分结点的标签，目的是对于其他未标注结点做预测。该任务可以应用在许多任务中，例如对于引文网络中论文的主题做预测，对推荐系统中的消费者的类型做预测。<br> 深度学习方法因为缺乏鲁棒性而一直被大家所讨论。这些图神经网络模型在被实施了对抗攻击的时候表现出来的脆弱性使得它很难被应用在一些safety-critical场景中。在图神经网络中，结点可以是社交网络中的一个用户，也可以是一个商业网站。一个恶意用户可以修改自己的profile或者是跟目标用户之间建立联系从而误导系统的分类。同样的，通过对特定的商品添加虚假评论也可以欺骗到推荐系统。<br> 不能将已有的非图数据中的对抗攻击方法应用在图神经网络中，原因在于图数据的输入是离散的。具体而言，图结点的特征通常都是离散的；图数据中的边，尤其是非权重图中的边通常也都是离散的。为了解决这个问题，许多人提出了贪婪算法来攻击图深度学习系统（Nettack）。贪婪算法是不断的迭代，来扰动特征或者边。在这篇文章中，作者指出来，就算是离散数据，也可以通过引入积分梯度来计算它的梯度。积分梯度（Integrated gradient）第一次被提出来是用于解决Shapely value，将部分梯度（partial gradient）和输入特征联系到一起。相比较贪婪选择算法，积分梯度可以大大提高结点选择和边选择的效率。<br> 跟对抗攻击相比，在图模型上对于对抗攻击的防御还没有怎么被研究。在这篇文章中，作者指出来，图神经网络模型之所以有脆弱性，是因为这些模型是基于图结构，来不断的聚合结点周围的其他节点的特征。也就是说，在对某个结点做预测的时候，模型会依赖于周围最邻近结点的特征。作者在对现有的攻击产生的扰动做分析的时候，发现，将一个结点周围的特征不同的其他结点与当前结点建立连边会带来很大的影响。在这篇文章中，作者发现，只要对一个图的邻接矩阵做预处理就可以确定这类边。对于拥有词袋特征（BOW，bag-of-words）的结点而言，Jaccard系数可以有效的衡量结点之间的相似性。通过把不相似的两个结点之间的连边去除，可以有效的防御住有目标的对抗攻击，并且可以保证GCN模型上的准确率不会下降。作者通过使用许多真实世界的数据集，发现提出的攻击和防御是十分有效的。</p> 
<h3><a id="Preliminaries_7"></a>Preliminaries（基本定义）</h3> 
<h4><a id="1GCN_8"></a>1）图卷积网络（GCN）</h4> 
<p>GCN是在半监督结点分类领域被广泛使用的方法。<br> GCN通常使用如下公式对于邻居节点的特征做聚合（其中的D代表的是对角阵）：<br> <img src="https://images2.imgbox.com/4d/2b/qbjHmYEq_o.png" alt="在这里插入图片描述"><br> 一个2层的GCN就可以很好的解决半监督结点分类任务了。这个模型可以被描述如下：<br> <img src="https://images2.imgbox.com/90/c4/2xoOONgG_o.png" alt="在这里插入图片描述"><br> 其中的A是一个对称矩阵，如下所示，其中的D是对角阵。</p> 
<p><img src="https://images2.imgbox.com/99/a2/7D3GNTFU_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_17"></a>2）基于梯度的对抗攻击</h4> 
<p>梯度被广泛使用来攻击深度学习模型。攻击者可以使用损失函数的梯度或者是模型的梯度来实施攻击。有两个典型的例子就是FGSM和JSMA攻击。FGSM是朝着损失函数的梯度方向做梯度上升。这个生成扰动的过程可以描述如下：<br> <img src="https://images2.imgbox.com/30/1b/0DQzHUZ9_o.png" alt="在这里插入图片描述"><br> JSMA攻击是利用DNN模型的前向偏差（forward derivative）。给定一个前向推理的神经网络F和样本X，计算Jacabian的过程如下所示：<br> <img src="https://images2.imgbox.com/7a/4c/NXqJCeFE_o.png" alt="在这里插入图片描述"><br> 如果攻击者的目标是使得结点被分类成t类别，那就应该使得<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          F 
         
        
          t 
         
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
      
        F_t(x) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span>上升，使得<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          F 
         
        
          j 
         
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
      
        F_j(x) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.03611em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span>下降。JSMA的对抗显著图可以定义如下：<br> <img src="https://images2.imgbox.com/5d/be/Xw9CQ57u_o.png" alt="在这里插入图片描述"><br> 已知一个正常的样本，攻击者可以得到显著图（saliency map）并且每次以一个很小扰动迭代的生成扰动，直到目标节点的标签被翻转。对于无目标攻击而言，攻击者的目的是最小化真实标签类别的预测分数。</p> 
<h4><a id="3_25"></a>3）对抗攻击的防御</h4> 
<p>尽管图上的对抗攻击是一个相对很新的问题，已经有一些工作研究对于卷积神经网络的对抗攻击。对于图像而言，由于特征空间是连续的，使用一点点扰动就可以实现对抗攻击。因此，在很多情况下，对图像添加一些随机化操作就可以防御住攻击。其他对于输入的预处理方法，诸如本地平滑（local smoothing）以及图像压缩都可以用于防御住攻击。这些预处理方法基于的前提假设是，一个像素周围的其他像素应该是相似的。也可以使用对抗训练来增强模型的鲁棒性。</p> 
<h3><a id="_27"></a>基于积分梯度的攻击</h3> 
<p>尽管FGSM和JSMA并不是最复杂的攻击方法，它们也没有被很好的应用在图问题中。对于图像数据而言，FGSM和JSMA的成功源于特征在像素空间上的连续性。但是最近的研究表明，这些方法直接应用在图领域不能带来很好的攻击效果。就有一些研究者使用贪婪算法或者是强化学习方法来解决图数据这类离散数据，但是贪婪算法和强化学习通常都是很昂贵并且费时的。<br> 图中的结点特征通常都是词袋类型的数据，也就是要么是0，要么是1。不带权重的边也通常是离散的，要么是0，要么是1。使用Vanilla FGSM和JSMA的问题在于梯度是不准确的。给定一个目标节点t，对于FGSM攻击而言，<img src="https://images2.imgbox.com/a4/a0/TUE0UP4T_o.png" alt="在这里插入图片描述"><br> 可以衡量节点中每个特征针对于损失函数的重要性。对于结点n的特定特征i而言，这个梯度越大说明将这个特征修改为1就会带来比较大的影响。但是如果这样这样做就会带来两个问题：（1）特征值可能本来就是1，那就不能再对它做修改了。（2）就算特征本来就是0，GCN模型可能学不到0和1的线性函数，所以这个扰动是不可预测的。JSMA同样会有这样的问题。换句话说，vinilla梯度会有本地梯度问题（local gradient）。以一个简单的RELU为例，当x从0增加到1的时候，Relu的值也从0增加到1。但是在x=0的时候计算梯度还是0，所以无法准确的捕捉到模型的行为。为了解决这个问题，作者提出了积分梯度，而不是直接使用攻击的vanilla偏差。积分梯度在2017年的时候被提出来，可以获得特征属性的偏差。<br> 积分梯度的定义如下：<br> 给定一个模型F，x’是一个baseline input（基准输入），x是真实的输入。考虑从x’到输入x之间的一条直线路径，积分梯度就是对这条路径上的所有梯度进行累加。例如，对于输入x的第i个特征而言，积分梯度IG可以定义如下：<br> <img src="https://images2.imgbox.com/96/5e/QlRiSJl4_o.png" alt="在这里插入图片描述"><br> <strong>如果是有目标攻击，就是应该要最大化F值，所以当图中的特征或者边是1时，可以选择有最低的负值IG分数的特征或者边，将其修改成0。如果是无目标攻击，就是应该要最小化真实标签的预测分数，所以需要选择有最高IG分数的维度，将其修改成0。</strong> （这里没有理解，可以看看原文）<br> <img src="https://images2.imgbox.com/12/27/V2lzRCog_o.png" alt="在这里插入图片描述"><br> 但是不像图像一样，我们可以将一个全黑的图像（black image）设置成baseline input。作者使用了一个全0或者是全1的特征/邻接矩阵来表示1-&gt;0的扰动或者是0-&gt;1的扰动。当去除一条特定边或者是将一个特定的特征从1改成0后，作者是将邻接矩阵A和特征矩阵X设置成全0，然后逐渐的在当前全0的矩阵上添加边或者特征，然后观察F的整体变化。相反的，当添加一条特定边或者将一个特定的特征从0改成1后，首先将A和X都设置成全1，然后逐渐的移除某条边或者某个特征，然后观察F的整体变化。对于边攻击（edge attack）的IG分数计算如下所示：<br> <img src="https://images2.imgbox.com/31/37/tTNyV8X3_o.png" alt="在这里插入图片描述"><br> 算法1展示了无目标的IG-JSMA的伪代码。<br> <img src="https://images2.imgbox.com/7d/f5/LHMsQLDe_o.png" alt="在这里插入图片描述"><br> 可以看到，对于无目标攻击而言，要做的是选择IG最大的边或者特征。</p> 
<h3><a id="_41"></a>图对抗攻击的防御</h3> 
<p>为了防御GCN上的对抗攻击，作者首先提出一个假设，那就是，GCN模型之所以很容易被攻击，是因为它极强的依赖于图结构和邻居节点特征的聚合。在被攻击图上训练得到的模型就容易受到这个攻击边界的影响。目前公认的一点是，在一个模型上训练得到的对抗样本可以迁移到其他模型中。目前对于GCN模型的对抗攻击是很成功的，原因在于这些被攻击的图可以直接被用于训练一个新模型。基于这种攻击方式，一个可行的防御方法是让邻接矩阵变得可训练（trainable）。<br> 作者之后开始验证这种防御方法，也就是使得边权重在GCN模型中变得可训练。在没有添加任何防御方法的时候，在被攻击后，目标节点以0.998的置信度被误分类。作者的防御方法是首先对于边的权重做初始化，不修改其他东西，然后再对GCN模型做训练。作者发现，这样的一个简单的防御方法就可以使得目标节点以高置信度0.912被正确分类。为了解释为什么这个防御方法奏效，作者观察了攻击的特点。首先，<strong>对边做扰动比直接修改特征要更有效。</strong> 在现有的所有攻击方法（FGSM，JSMA和IG-JSMA）中，这一点都是奏效的。只对特征做干扰是很难修改目标节点的预测结果的。而且，<strong>很多攻击方法都是倾向于添加边而不是删除边，这样带来的攻击效果要更好。</strong> 第二，有着更多邻居节点的结点更难被攻击。这是在之前的工作中就被提到过的。之前就有学者发现，有着更高degree的结点在干净图和攻击图中都有着更好的分类准确率。最后，在攻击的时候，倾向于将目标节点和有着不同特征feature或者不同标签label的结点之间建立连接。在发现了这一点之后，可以借用这点特性来实施攻击。作者使用了CORA-ML数据集来验证这些假设。为了评估结点之间的特征的相似性，作者使用了Jaccard相似性分数，因为CORA-ML数据集中的结点特征是0/1离散的，bag-of-word词袋特征。但是对于那些其他类型的特征，诸如数字特征，作者使用了其他的相似性度量方式。<br> 对于binary离散特征，作者使用了如下的相似性计算公式：<br> <img src="https://images2.imgbox.com/7b/af/JSzbsqaU_o.png" alt="在这里插入图片描述"><br> 其中的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          M 
         
        
          11 
         
        
       
      
        M_{11} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.10903em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>表示结点u中特征为1，结点v中特征也为1;<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          M 
         
        
          10 
         
        
       
      
        M_{10} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.10903em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>表示结点u中特征为1，结点v中特征为0；<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          M 
         
        
          01 
         
        
       
      
        M_{01} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.10903em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>表示结点u中特征为0，结点v中特征为1.<br> 作者在做实验的时候，在CORA-ML数据集上训练了一个2层的GCN网络，并且研究了那些高置信度（置信度大于等于0.8）并且被正确分类的结点。对于这部分结点，作者计算了连接节点在实施FGSM攻击前后的Jaccard相似性。通过实验发现，在实施了对抗攻击之后，目标节点周围与它的相似性分数很低的邻居节点的数目变多了。<br> 在攻击的时候，作者指出来，实施边攻击比实施特征攻击要更有效，原因在于如果对特征中的某个维度做修改，这个结点周围会有很多其他的邻居节点，那么邻居节点的特征就会在聚合的过程中对目标节点产生影响，从而使得对单个维度特征的修改无法造成理想的攻击效果。<br> 基于以上对攻击的观察，作者提出一个假设，那就是提出来的防御方法之所以有效，是因为GCN模型会对那些与当前结点特征相差很大的结点之间的边赋予更小的权重。实验结果如下，发现确实是，Jaccard相似性分数更高的结点与当前结点的连边的权重更高，越低的权重越低。<br> <img src="https://images2.imgbox.com/c4/19/SnUUYdBG_o.png" alt="在这里插入图片描述"><br> 为了使得防御方法更有效，作者表示，其实可以不需要去学习边的权重。因为如果要学习边的权重的话，不可避免的就会带来额外的参数。所以可以直接基于如下几点做防御：1）正常结点通常不会与许多相似性不高的结点之间建立连接。2）在学习的过程中，就会自动的将两个不相似的结点之间建立连接。作者之后提出了一个简单并且有效的方法。<br> 需要注意的是，文章中提出来的防御方法是发生在预处理阶段。在训练阶段之前，直接就对图的邻接矩阵做检查，并且对边做inspect。所有的那些与目标节点的相似性分数很低，但是却建立了连接的边会被移除。虽然在干净图中也会有这些边，但是作者发现，移除了所有的这些边之后，对目标节点的预测不会带来负向的影响。</p> 
<h3><a id="Evaluation_54"></a>Evaluation</h3> 
<p>作者使用了被广泛使用的数据集CORA-ML，CiteSeer和Polblogs。三个数据集的介绍如下所示：<br> <img src="https://images2.imgbox.com/e7/61/vEK7tyEc_o.png" alt="在这里插入图片描述"><br> 作者在实验的过程中，将整张图划分成为20%的带标签结点和80%的不带标签结点。在带标签结点中，一半用作训练，一半用作验证。对于Polblogs数据集而言，是没有特征属性的，所以直接将它的特征矩阵设置成单位矩阵。</p> 
<h4><a id="1Transductive_Attack_58"></a>（1）Transductive Attack</h4> 
<p>由于transductive任务本身的特点，模型在攻击的过程中不应该是被完全固定的。在对特征或者边做了干扰之后，需要对模型做重训练从而评估它的攻击有效性。为了对攻击的有效性做验证，作者选择了不同预测分数的结点做实验。具体来说，作者选择了40个结点，其中10个结点有最高的预测分数，10个结点有最低的预测分数，另外20个结点是随机选择的。作者将自己提出的IG-JSMA方法和几个baseline方法做了对比。这些baseline包括随机攻击，FGSM以及nettack。在执行baseline攻击的时候，作者执行的是direct attack（直接攻击），也就是说直接修改目标节点的特征以及与目标节点周围的邻边。direct attack可以取得更好的攻击效果，所以可以代表一个最强的baseline。<br> **为了评估攻击是有效的，作者使用了classification margin作为一个评价指标（我是不是也可以把这个指标作为我的评价指标）。**对于一个目标节点v来说，它的classification margin是这样的：<br> <img src="https://images2.imgbox.com/c2/58/V8a0bv8C_o.png" alt="在这里插入图片描述"><br> 其中的c代表的是结点v的真实类别，Z表示类别对应的置信度分数。所以classification margin的值越小，说明真实标签c对应的置信度分数比较低，其他类别的置信度分数比较高，那么就说明攻击的效果是很好的。IG-JSMA以及三个baseline的实验结果如下图所示（<strong>这里没有跟JSMA做对比，是因为JSMA本来效果就不错，所以作者不做对比了？？</strong>）：</p> 
<p><img src="https://images2.imgbox.com/f8/e3/NbqUXeZF_o.png" alt="在这里插入图片描述"><br> 就IG-JSMA与三个baseline的对比来看，IG-JSMA的结果是很稳定的，没有太大的偏差variance（直接看图上矩形的高度，IG-JSMA是最低的）。所以可以总结出来一点，那就是基于vanilla gradient的方法（例如FGSM等）不能捕捉到离散数据的损失值的变化。而在JSMA中，这个梯度也不能很好的描述显著图。<br> 为了展示IG-JSMA方法的有效性，作者也将它跟JSMA直接作对比（<strong>为什么要把和JSMA的对比单独拿出来</strong>）。通过实验结果可以发现，IG-JSMA的攻击效果是要优于JSMA的。<br> <img src="https://images2.imgbox.com/4c/ff/Iv6ashOc_o.png" alt="在这里插入图片描述"><br> 作者还做了一个更加直观的实验，那就是首先定义特征或者边的重要性的计算。在计算某个结点或者某条边相对于目标节点的重要性的时候，作者是直接在图中一次性移除一个结点或者一条边，然后观察目标节点的预测分数的变化。如果变化大，说明移除的这个结点或者边是很重要的。（<strong>为什么感觉，作者提出来的IG-FGSM和IG-JSMA方法就是这样做的，那这里的评估肯定效果好吧</strong>）这里举个例子，将邻接矩阵中的某个位置的值从1变成0，那么相应的目标节点的分数从<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          c 
         
        
       
      
        p_c 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>变成<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          c 
         
        
          ′ 
         
        
       
      
        p_c' 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.998892em; vertical-align: -0.247em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -2.453em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.247em;"><span class=""></span></span></span></span></span></span></span></span></span></span>。这里的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          c 
         
        
          ′ 
         
        
       
         − 
        
        
        
          p 
         
        
          c 
         
        
       
      
        p_c'-p_c 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.998892em; vertical-align: -0.247em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -2.453em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.247em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>就可以反映这个边的移除带来的影响。那么这里的这个<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          c 
         
        
          ′ 
         
        
       
         − 
        
        
        
          p 
         
        
          c 
         
        
       
      
        p_c'-p_c 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.998892em; vertical-align: -0.247em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -2.453em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.247em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>就可以反映某个结点或者特征的梯度ground truth。而vanilla gradient和积分梯度就是对于这个ground truth的一种估计。<br> 对于这个验证的结果如下图所示。其中结点颜色表示结点的类别。圆形的点表示正向的重要性分数，而有棱角的点表示的是负向的重要性分数。结点大小（size）表示重要性分数的绝对值大小。结点越大表明越重要。红色的边表示对目标节点有正向的重要性，蓝色的边表示对目标节点有负向的重要性。边越粗表示这个边越重要（<strong>没有理解，这里的正向和负向影响是什么意思？？</strong>）。五角星的位置就是目标节点了。<br> <img src="https://images2.imgbox.com/e5/d0/1t0uq8gW_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2defense_71"></a>（2）defense</h4> 
<p>接下来对于作者提出来的防御方案做验证。作者使用了CORA-ML数据集和Citeseer数据集来验证防御方案。<br> 首先，验证一下提出的防御方案是否会影响到干净模型的表现。可以看到，加了防御方案后，干净模型的acc准确率并没有被影响太多。<br> <img src="https://images2.imgbox.com/ef/5a/LYf6gvVF_o.png" alt="在这里插入图片描述"><br> 对于论文提出的攻击以及三个baseline攻击方法，作者之后分别评估添加了防御方案以及没有添加防御方案对应的classification margin指标、实验结果如下：<br> <img src="https://images2.imgbox.com/69/2e/7gEPUNG8_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Conclusion_77"></a>Conclusion</h3> 
<p>这篇文章研究了GCN的鲁棒性（所以是只做了GCN，没有做GAT和GraphSage，不知道GAT和GraphSage应该怎么评估鲁棒性呢）。作者提出了积分梯度integrated gradient的概念，比现有的梯度方法效果都要好。作则还分析了GCN之所以会不鲁棒，就在于它会不断的聚合周围邻居节点的特征。最后给出了相应可行的防御方案。</p> 
<h3><a id="_80"></a>补充</h3> 
<p>Integrated gradient的概念在2017年就被Google提出来了。积分梯度算作是一种解释深度学习模型输出结果的方法。Integrated gradient将输入的第i个特征的归因定义为：从baseline到输入之间的直线路径的路径积分。<br> <img src="https://images2.imgbox.com/59/b5/Y37UJrqG_o.png" alt="在这里插入图片描述"><br> 这里的baseline一般都是选择全0的矩阵或者向量。这里的baseline之所以选择全0，是因为当我们把一件事情的发生归结于某个原因的时候，没有该原因的情况就是一个baseline基线值。这里的基线值表示的就是无状态。<br> 积分梯度之所以被提出来，是因为研究者发现，对于下面的f(x)这个函数，当x=1时，f(1)=1，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          f 
         
        
          ′ 
         
        
       
         ( 
        
       
         1 
        
       
         ) 
        
       
         = 
        
       
         0 
        
       
      
        f'(1)=0 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.00189em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>。但是梯度应该是处处都存在的，不应该存在梯度为0的情况，所以要使用其他的梯度计算方法来得到梯度。<br> <img src="https://images2.imgbox.com/f8/b0/7a4rFCBo_o.png" alt="在这里插入图片描述"><br> 积分梯度和传统的梯度的差别其实是在于，传统的梯度只选取了当前点计算梯度，但是如果当前点的特征正好处在梯度饱和阶段，计算得到的归因就很小。但是积分梯度相当于是选择了当前输入到基线值之间的无限多个积分点进行加和，可以解决梯度饱和的问题。<br> 应用积分梯度的关键是选择一个好的baseline基准值，这样的基准值应该要不包含任何的信号，这样才能把归因结果归结于输入值。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/685243b674dcedd4ff868a81b201c79e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Open-Vocabulary Object Detection Using Captions(2021 CVPR)----论文解读</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4e0b8e18a6cf3fbe7dd858d097d9d7df/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python的期末考核——学生管理系统（5）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>