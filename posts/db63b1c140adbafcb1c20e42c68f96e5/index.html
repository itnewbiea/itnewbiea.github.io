<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MyBatis-Plus框架学习笔记 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MyBatis-Plus框架学习笔记" />
<meta property="og:description" content="先赞后看，养成习惯！！！❤️ ❤️ ❤️
文章码字不易，如果喜欢可以关注我哦！
​如果本篇内容对你有所启发，欢迎访问我的个人博客了解更多内容：链接地址
MyBatisPlus （简称MP）是基于MyBatis框架基础上开发的增强型工具，旨在==简化开发、提高效率==
MP的特性:
无侵入：只做增强不做改变，不会对现有工程产生影响强大的 CRUD 操作：内置通用 Mapper，少量配置即可实现单表CRUD 操作支持 Lambda：编写查询条件无需担心字段写错支持主键自动生成内置分页插件 标准增删查改 分页功能 基础的增删改查就已经学习完了，刚才我们在分析基础开发的时候，有一个分页功能还没有实现，在MP中如何实现分页功能，就是咱们接下来要学习的内容。
分页查询使用的方法是:
IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper) IPage:用来构建分页查询条件Wrapper：用来构建条件查询的条件，目前我们没有可直接传为NullIPage:返回值，你会发现构建分页条件和方法的返回值都是IPage IPage是一个接口，我们需要找到它的实现类来构建它，具体的实现类，可以进入到IPage类中按ctrl&#43;h,会找到其有一个实现类为Page。
@Test void testSelectPage(){ //1 创建IPage分页对象,设置分页参数,1为当前页码，3为每页显示的记录数 IPage&lt;User&gt; page=new Page&lt;&gt;(1,3); //2 执行分页查询 userDao.selectPage(page,null); //3 获取分页结果 System.out.println(&#34;当前页码值：&#34;&#43;page.getCurrent()); System.out.println(&#34;每页显示数：&#34;&#43;page.getSize()); System.out.println(&#34;一共多少页：&#34;&#43;page.getPages()); System.out.println(&#34;一共多少条数据：&#34;&#43;page.getTotal()); System.out.println(&#34;数据：&#34;&#43;page.getRecords()); DQL编程控制 查询相关的操作
增删改查四个操作中，查询是非常重要的也是非常复杂的操作，这块需要我们重点学习下，这节我们主要学习的内容有:
条件查询方式查询投影查询条件设定字段映射与表名映射 条件查询 lt: 小于(
gt：大于(&gt;)
第一种:==QueryWrapper==
第二种:==QueryWrapper的基础上使用lambda==
第三种:==LambdaQueryWrapper==
多条件查询 构建多条件的时候，可以支持链式编程 LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;(); lqw.lt(User::getAge, 30).gt(User::getAge, 10); List&lt;User&gt; userList = userDao.selectList(lqw); System.out.println(userList); 查询数据库表中，年龄小于10或年龄大于30的数据" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/db63b1c140adbafcb1c20e42c68f96e5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-05T17:17:14+08:00" />
<meta property="article:modified_time" content="2024-01-05T17:17:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MyBatis-Plus框架学习笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>先赞后看，养成习惯！！！❤️ ❤️ ❤️<br> 文章码字不易，如果喜欢可以关注我哦！<br> ​如果本篇内容对你有所启发，欢迎访问我的个人博客了解更多内容：<a href="https://kamiasuka.top" rel="nofollow" title="链接地址">链接地址</a></strong></p> 
</blockquote> 
<h2 id="MyBatisPlus">MyBatisPlus</h2> 
<p>（简称MP）是基于MyBatis框架基础上开发的增强型工具，旨在==简化开发、提高效率==</p> 
<p>MP的特性:</p> 
<ul><li>无侵入：只做增强不做改变，不会对现有工程产生影响</li><li>强大的 CRUD 操作：内置通用 Mapper，少量配置即可实现单表CRUD 操作</li><li>支持 Lambda：编写查询条件无需担心字段写错</li><li>支持主键自动生成</li><li>内置分页插件</li></ul> 
<h2 id="%E6%A0%87%E5%87%86%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9">标准增删查改</h2> 
<p><img alt="" height="564" src="https://images2.imgbox.com/11/b0/70AWg3wu_o.png" width="1200"></p> 
<h3 id="%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD">分页功能</h3> 
<p>基础的增删改查就已经学习完了，刚才我们在分析基础开发的时候，有一个分页功能还没有实现，在MP中如何实现分页功能，就是咱们接下来要学习的内容。</p> 
<p>分页查询使用的方法是:</p> 
<pre><code class="language-java">IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</code></pre> 
<ul><li>IPage:用来构建分页查询条件</li><li>Wrapper：用来构建条件查询的条件，目前我们没有可直接传为Null</li><li>IPage:返回值，你会发现构建分页条件和方法的返回值都是IPage</li></ul> 
<p>IPage是一个接口，我们需要找到它的实现类来构建它，具体的实现类，可以进入到IPage类中按ctrl+h,会找到其有一个实现类为Page。</p> 
<pre><code class="language-java">@Test
void testSelectPage(){
    //1 创建IPage分页对象,设置分页参数,1为当前页码，3为每页显示的记录数
    IPage&lt;User&gt; page=new Page&lt;&gt;(1,3);
    //2 执行分页查询
    userDao.selectPage(page,null);
    //3 获取分页结果
    System.out.println("当前页码值："+page.getCurrent());
    System.out.println("每页显示数："+page.getSize());
    System.out.println("一共多少页："+page.getPages());
    System.out.println("一共多少条数据："+page.getTotal());
    System.out.println("数据："+page.getRecords());</code></pre> 
<h2 id="DQL%E7%BC%96%E7%A8%8B%E6%8E%A7%E5%88%B6">DQL编程控制</h2> 
<p><strong>查询相关的操作</strong></p> 
<p>增删改查四个操作中，查询是非常重要的也是非常复杂的操作，这块需要我们重点学习下，这节我们主要学习的内容有:</p> 
<ul><li>条件查询方式</li><li>查询投影</li><li>查询条件设定</li><li>字段映射与表名映射</li></ul> 
<h3 id="%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2">条件查询</h3> 
<p><strong>lt: 小于(</strong></p> 
<p><strong>gt：大于(&gt;)</strong></p> 
<p>第一种:==QueryWrapper==</p> 
<p>第二种:==QueryWrapper的基础上使用lambda==</p> 
<p>第三种:==LambdaQueryWrapper==</p> 
<h4 id="%E5%A4%9A%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2">多条件查询</h4> 
<ul><li>构建多条件的时候，可以支持链式编程</li></ul> 
<pre><code class="language-java">LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;();
lqw.lt(User::getAge, 30).gt(User::getAge, 10);
List&lt;User&gt; userList = userDao.selectList(lqw);
System.out.println(userList);</code></pre> 
<p>查询数据库表中，年龄小于10或年龄大于30的数据</p> 
<pre><code class="language-java">    @Autowired
    private UserDao userDao;
    
    @Test
    void testGetAll(){
        LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;();
        lqw.lt(User::getAge, 10).or().gt(User::getAge, 30);
        List&lt;User&gt; userList = userDao.selectList(lqw);
        System.out.println(userList);
    }</code></pre> 
<h4 id="null%E5%88%A4%E5%AE%9A">null判定</h4> 
<p>&gt; 需求:查询数据库表中，根据输入年龄范围来查询符合条件的记录。用户在输入值的时候，</p> 
<p>&gt; ​ 如果只输入第一个框，说明要查询大于该年龄的用户</p> 
<p>&gt; ​ 如果只输入第二个框，说明要查询小于该年龄的用户</p> 
<p>&gt; ​ 如果两个框都输入了，说明要查询年龄在两个范围之间的用户</p> 
<p>思考第一个问题：后台如果想接收前端的两个数据，该如何接收?</p> 
<p>新建一个模型类,让其继承User类，并在其中添加age2属性，UserQuery在拥有User属性后同时添加了age2属性。</p> 
<pre><code class="language-java">@Data
public class User {
    private Long id;
    private String name;
    private String password;
    private Integer age;
    private String tel;
}
​
@Data
public class UserQuery extends User {
    private Integer age2;
}</code></pre> 
<pre><code class="language-java">@Test
void testGetAll(){
    //模拟页面传递过来的查询数据
    UserQuery uq = new UserQuery();
    uq.setAge(10);
    uq.setAge2(30);
    LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;();
    lqw.lt(null!=uq.getAge2(),User::getAge, uq.getAge2());
    lqw.gt(null!=uq.getAge(),User::getAge, uq.getAge());
    List&lt;User&gt; userList = userDao.selectList(lqw);
    System.out.println(userList);
}</code></pre> 
<h3 id="%E6%9F%A5%E8%AF%A2%E6%8A%95%E5%BD%B1">查询投影</h3> 
<h4 id="%E6%9F%A5%E8%AF%A2%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5">查询指定字段</h4> 
<pre><code class="language-java">@Test
void getWord() {
    LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;&gt;();
    lqw.select(User::getId, User::getName);
    List&lt;User&gt; list = userDao.selectList(lqw);
    System.out.println(list);
}</code></pre> 
<p>select(...)方法用来设置查询的字段列，可以设置多个</p> 
<h4 id="%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2">聚合查询</h4> 
<ul><li>聚合与分组查询，无法使用lambda表达式来完成</li></ul> 
<p>需求:聚合函数查询，完成count、max、min、avg、sum的使用</p> 
<p>count:总记录数</p> 
<p>max:最大值</p> 
<p>min:最小值</p> 
<p>avg:平均值</p> 
<p>sum:求和</p> 
<h4 id="%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2">分组查询</h4> 
<p>groupBy为分组</p> 
<ul><li>聚合与分组查询，无法使用lambda表达式来完成</li><li>MP只是对MyBatis的增强，如果MP实现不了，我们可以直接在DAO接口中使用MyBatis的方式实现</li></ul> 
<pre><code class="language-java">@Test
void GroupBy(){
    QueryWrapper&lt;User&gt; lqw = new QueryWrapper&lt;User&gt;();
    lqw.select("count(*) as count,age");
    lqw.groupBy("age");
    List&lt;Map&lt;String, Object&gt;&gt; list = userDao.selectMaps(lqw);
    System.out.println(list);
}</code></pre> 
<p>[{count=1, age=55}, {count=1, age=45}, {count=1, age=38}, {count=1, age=42}, {count=1, age=37}]</p> 
<h3 id="%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6">查询条件</h3> 
<p>MP的查询条件有很多:</p> 
<ul><li>范围匹配（&gt; 、 = 、between）</li><li>模糊匹配（like）</li><li>空判定（null）</li><li>包含性匹配（in）</li><li>分组（group）</li><li>排序（order</li></ul> 
<h4 id="%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2">等值查询</h4> 
<p>eq()： 相当于 =</p> 
<h4 id="%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2">范围查询</h4> 
<ul><li>gt():大于(&gt;)</li><li>ge():大于等于(&gt;=)</li><li>lt():小于(</li><li>lte():小于等于(</li><li>between():between ? and ?</li></ul> 
<h4 id="%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2">模糊查询</h4> 
<ul><li>like():前后加百分号,如 %J%</li><li>likeLeft():前面加百分号,如 %J</li><li>likeRight():后面加百分号,如 J%</li></ul> 
<h4 id="%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2">排序查询</h4> 
<pre><code class="language-java">@Test
void testGetAll(){
    LambdaQueryWrapper&lt;User&gt; lwq = new LambdaQueryWrapper&lt;&gt;();
    /**
     * condition ：条件，返回boolean，
     当condition为true，进行排序，如果为false，则不排序
     * isAsc:是否为升序，true为升序，false为降序
     * columns：需要操作的列
     */
    lwq.orderBy(true,false, User::getId);

    List&lt;User&gt; list = userDao.selectList(lwq);
    System.out.println(list);
}</code></pre> 
<h3 id="%E6%98%A0%E5%B0%84%E5%8C%B9%E9%85%8D%E5%85%BC%E5%AE%B9%E6%80%A7">映射匹配兼容性</h3> 
<h4 id="%E9%97%AE%E9%A2%981%3A%E8%A1%A8%E5%AD%97%E6%AE%B5%E4%B8%8E%E7%BC%96%E7%A0%81%E5%B1%9E%E6%80%A7%E8%AE%BE%E8%AE%A1%E4%B8%8D%E5%90%8C%E6%AD%A5">问题1:表字段与编码属性设计不同步</h4> 
<p>当表的列名和模型类的属性名发生不一致，就会导致数据封装不到模型对象，这个时候就需要其中一方做出修改，那如果前提是两边都不能改又该如何解决?</p> 
<p>MP给我们提供了一个注解@TableField,使用该注解可以实现模型类属性名和表的列名之间的映射关系</p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/5b/bc/lTntkAX2_o.png" width="1200"></p> 
<h4 id="%E9%97%AE%E9%A2%982%3A%E7%BC%96%E7%A0%81%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BA%86%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B1%9E%E6%80%A7">问题2:编码中添加了数据库中未定义的属性</h4> 
<p>当模型类中多了一个数据库表不存在的字段，就会导致生成的sql语句中在select的时候查询了数据库不存在的字段，程序运行就会报错，错误信息为:</p> 
<p>==Unknown column '多出来的字段名称' in 'field list'==</p> 
<p>具体的解决方案用到的还是@TableField注解，它有一个属性叫exist，设置该字段是否在数据库表中存在，如果设置为false则不存在，生成sql语句查询的时候，就不会再查询该字段了。</p> 
<p><img alt="" height="448" src="https://images2.imgbox.com/51/88/GBHCCmbb_o.png" width="1200"></p> 
<h4 id="%E9%97%AE%E9%A2%983%EF%BC%9A%E9%87%87%E7%94%A8%E9%BB%98%E8%AE%A4%E6%9F%A5%E8%AF%A2%E5%BC%80%E6%94%BE%E4%BA%86%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%AD%97%E6%AE%B5%E6%9F%A5%E7%9C%8B%E6%9D%83%E9%99%90">问题3：采用默认查询开放了更多的字段查看权限</h4> 
<p>查询表中所有的列的数据，就可能把一些敏感数据查询到返回给前端，这个时候我们就需要限制哪些字段默认不要进行查询。解决方案是@TableField注解的一个属性叫select，该属性设置默认是否需要查询该字段的值，true(默认值)表示默认查询该字段，false表示默认不查询该字段。</p> 
<p><img alt="" height="580" src="https://images2.imgbox.com/43/b5/UnZLkohz_o.png" width="1200"></p> 
<h4 id="%40TableField">@TableField</h4> 
<table><tbody><tr><td> <p>名称</p> </td><td> <p>@TableField</p> </td></tr><tr><td> <p>类型</p> </td><td> <p>==属性注解==</p> </td></tr><tr><td> <p>位置</p> </td><td> <p>模型类属性定义上方</p> </td></tr><tr><td> <p>作用</p> </td><td> <p>设置当前属性对应的数据库表中的字段关系</p> </td></tr><tr><td> <p>相关属性</p> </td><td> <p>value(默认)：设置数据库表字段名称 exist:设置属性在数据库表字段中是否存在，默认为true，此属性不能与value合并使用 select:设置属性是否参与查询，此属性与select()映射配置不冲突</p> </td></tr></tbody></table> 
<h4 id="%E9%97%AE%E9%A2%984%3A%E8%A1%A8%E5%90%8D%E4%B8%8E%E7%BC%96%E7%A0%81%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1%E4%B8%8D%E5%90%8C%E6%AD%A5">问题4:表名与编码开发设计不同步</h4> 
<p>该问题主要是表的名称和模型类的名称不一致，导致查询失败，这个时候通常会报如下错误信息:</p> 
<p>==Table 'databaseName.tableNaem' doesn't exist==,翻译过来就是数据库中的表不存在。</p> 
<p>解决方案是使用MP提供的另外一个注解@TableName来设置表与模型类之间的对应关系。</p> 
<h4 id="%40TableName">@TableName</h4> 
<p><img alt="" height="535" src="https://images2.imgbox.com/70/47/EeguCugS_o.png" width="1200"></p> 
<h4>@TableName</h4> 
<table><tbody><tr><td> <p>名称</p> </td><td> <p>@TableName</p> </td></tr><tr><td> <p>类型</p> </td><td> <p>==类注解==</p> </td></tr><tr><td> <p>位置</p> </td><td> <p>模型类定义上方</p> </td></tr><tr><td> <p>作用</p> </td><td> <p>设置当前类对应于数据库表关系</p> </td></tr><tr><td> <p>相关属性</p> </td><td> <p>value(默认)：设置数据库表名称</p> </td></tr></tbody></table> 
<h2 id="DML%E7%BC%96%E7%A8%8B%E6%8E%A7%E5%88%B6">DML编程控制</h2> 
<p>对增删改三个内容的讲解。</p> 
<h3 id="id%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5%E6%8E%A7%E5%88%B6">id生成策略控制</h3> 
<p>* 不同的表应用不同的id生成策略</p> 
<p>* 日志：自增（1,2,3,4，……）</p> 
<p>* 购物订单：特殊规则（FQ23948AK3843）</p> 
<p>* 外卖单：关联地区日期等信息（10 04 20200314 34 91）</p> 
<p>* 关系表：可省略id</p> 
<p>* ……</p> 
<p>不同的业务采用的ID生成方式应该是不一样的，MP中都提供这些主键生成策略</p> 
<h4 id="%40TableId">@TableId</h4> 
<table><tbody><tr><td> <p>名称</p> </td><td> <p>@TableId</p> </td></tr><tr><td> <p>类型</p> </td><td> <p>==属性注解==</p> </td></tr><tr><td> <p>位置</p> </td><td> <p>模型类中用于表示主键的属性定义上方</p> </td></tr><tr><td> <p>作用</p> </td><td> <p>设置当前类中主键属性的生成策略</p> </td></tr><tr><td> <p>相关属性</p> </td><td> <p>value(默认)：设置数据库表主键名称 type:设置主键属性的生成策略，值查照IdType的枚举值</p> </td></tr></tbody></table> 
<p>AUTO策略</p> 
<pre><code class="language-java">@TableId(type = IdType.AUTO)</code></pre> 
<p>`AUTO`的作用是==使用数据库ID自增==，在使用该策略的时候一定要确保对应的数据库表设置了ID主键自增，否则无效。</p> 
<ul><li>NONE: 不设置id生成策略</li><li>INPUT:用户手工输入id @TableId(type = IdType.INPUT)</li><li>ASSIGN_ID:雪花算法生成id(可兼容数值型与字符串型) @TableId(type = IdType.ASSIGN_ID)</li><li>ASSIGN_UUID:以UUID生成算法作为id生成策略 @TableId(type = IdType.ASSIGN_UUID)</li><li>其他的几个策略均已过时，都将被ASSIGN_ID和ASSIGN_UUID代替掉。</li></ul> 
<p>分布式ID是什么?</p> 
<ul><li>当数据量足够大的时候，一台数据库服务器存储不下，这个时候就需要多台数据库服务器进行存储</li><li>比如订单表就有可能被存储在不同的服务器上</li><li>如果用数据库表的自增主键，因为在两台服务器上所以会出现冲突</li><li>这个时候就需要一个全局唯一ID,这个ID就是分布式ID。</li></ul> 
<h4 id="ID%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5%E5%AF%B9%E6%AF%94">ID生成策略对比</h4> 
<ul><li>NONE: 不设置id生成策略，MP不自动生成，约等于INPUT,所以这两种方式都需要用户手动设置，但是手动设置第一个问题是容易出现相同的ID造成主键冲突，为了保证主键不冲突就需要做很多判定，实现起来比较复杂</li><li>AUTO:数据库ID自增,这种策略适合在数据库服务器只有1台的情况下使用,不可作为分布式ID使用</li><li>ASSIGN_UUID:可以在分布式的情况下使用，而且能够保证唯一，但是生成的主键是32位的字符串，长度过长占用空间而且还不能排序，查询性能也慢</li><li>ASSIGN_ID:可以在分布式的情况下使用，生成的是Long类型的数字，可以排序性能也高，但是生成的策略和服务器时间有关，如果修改了系统时间就有可能导致出现重复主键</li><li>综上所述，每一种主键策略都有自己的优缺点，根据自己项目业务的实际情况来选择使用才是最明智的选择。</li></ul> 
<h4 id="%E7%AE%80%E5%8C%96%E9%85%8D%E7%BD%AE">简化配置</h4> 
<p>只需要在配置文件中添加如下内容:</p> 
<pre><code class="language-java">mybatis-plus:
  global-config:
    db-config:
        id-type: assign_id</code></pre> 
<p>配置完成后，每个模型类的主键ID策略都将成为assign_id.</p> 
<h3 id="%E5%A4%9A%E8%AE%B0%E5%BD%95%E6%93%8D%E4%BD%9C">多记录操作</h3> 
<p>例子：批量删除的操作</p> 
<p>对应的API方法</p> 
<pre><code class="language-java">int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);
</code></pre> 
<p>翻译方法的字面意思为:删除（根据ID 批量删除）,参数是一个集合，可以存放多个id值。</p> 
<p>除了按照id集合进行批量删除，也可以按照id集合进行批量查询，还是先来看下API</p> 
<pre><code class="language-java">List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);
</code></pre> 
<p>方法名称翻译为:查询（根据ID 批量查询），参数是一个集合，可以存放多个id值。</p> 
<h3 id="%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4">逻辑删除</h3> 
<p>标识新增的字段为逻辑删除字段，使用@TableLogic</p> 
<h4 id="%40TableLogic">@TableLogic</h4> 
<table><tbody><tr><td> <p>名称</p> </td><td> <p>@TableLogic</p> </td></tr><tr><td> <p>类型</p> </td><td> <p>==属性注解==</p> </td></tr><tr><td> <p>位置</p> </td><td> <p>模型类中用于表示删除字段的属性定义上方</p> </td></tr><tr><td> <p>作用</p> </td><td> <p>标识该字段为进行逻辑删除的字段</p> </td></tr><tr><td> <p>相关属性</p> </td><td> <p>value：逻辑未删除值 delval:逻辑删除值</p> </td></tr></tbody></table> 
<pre><code class="language-java">@TableLogic(value="0",delval="1")
//value为正常数据的值，delval为删除数据的值</code></pre> 
<ul><li>如果每个表都要有逻辑删除，那么就需要在每个模型类的属性上添加</li></ul> 
<p>@TableLogic注解，如何优化?</p> 
<p>在配置文件中添加全局配置，如下:</p> 
<pre><code class="language-java">mybatis-plus:
  global-config:
    db-config:
      # 逻辑删除字段名
      logic-delete-field: deleted
      # 逻辑删除字面值：未删除为0
      logic-not-delete-value: 0
      # 逻辑删除字面值：删除为1
      logic-delete-value: 1</code></pre> 
<p>介绍完逻辑删除，逻辑删除的本质为:</p> 
<p>逻辑删除的本质其实是修改操作。如果加了逻辑删除字段，查询数据时也会自动带上逻辑删除字段。</p> 
<h2 id="%E4%B9%90%E8%A7%82%E9%94%81">乐观锁</h2> 
<h3 id="%E6%A6%82%E5%BF%B5">概念</h3> 
<p>在讲解乐观锁之前，我们还是先来分析下问题:</p> 
<p>业务并发现象带来的问题:==秒杀==</p> 
<ul><li>假如有100个商品或者票在出售，为了能保证每个商品或者票只能被一个人购买，如何保证不会出现超买或者重复卖</li><li>对于这一类问题，其实有很多的解决方案可以使用</li><li>第一个最先想到的就是锁，锁在一台服务器中是可以解决的，但是如果在多台服务器下锁就没有办法控制，比如12306有两台服务器在进行卖票，在两台服务器上都添加锁的话，那也有可能会导致在同一时刻有两个线程在进行卖票，还是会出现并发问题</li><li>我们接下来介绍的这种方式是针对于小型企业的解决方案，因为数据库本身的性能就是个瓶颈，如果对其并发量超过2000以上的就需要考虑其他的解决方案了。</li></ul> 
<p>简单来说，乐观锁主要解决的问题是当要更新一条记录的时候，希望这条记录没有被别人更新。</p> 
<h3 id="%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">实现思路</h3> 
<ol><li>在模型类中添加对应的属性@Version</li><li>添加乐观锁的拦截器</li><li>执行更新操作</li></ol> 
<h2 id="MP%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8">MP快速开发-代码生成器</h2> 
<h3 id="%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90">代码生成器原理分析</h3> 
<p>观察我们之前写的代码，会发现其中也会有很多重复内容，比如:</p> 
<p><img alt="" height="448" src="https://images2.imgbox.com/f5/d7/XUUPjYMJ_o.png" width="1200"></p> 
<p>那我们就想，如果我想做一个Book模块的开发，是不是只需要将红色部分的内容全部更换成Book即可，如：</p> 
<p><img alt="" height="448" src="https://images2.imgbox.com/fa/f6/OaId2M4P_o.png" width="1200"></p> 
<p>所以我们会发现，做任何模块的开发，对于这段代码，基本上都是对红色部分的调整，所以我们把去掉红色内容的东西称之为==模板==，红色部分称之为==参数==，以后只需要传入不同的参数，就可以根据模板创建出不同模块的dao代码。</p> 
<p>除了Dao可以抽取模块，其实我们常见的类都可以进行抽取，只要他们有公共部分即可。再来看下模型类的模板：</p> 
<p><img alt="" height="709" src="https://images2.imgbox.com/0c/6f/sBwfN2rI_o.png" width="1200"></p> 
<ul><li>① 可以根据数据库表的表名来填充</li><li>② 可以根据用户的配置来生成ID生成策略</li><li>③到⑨可以根据数据库表字段名称来填充</li></ul> 
<p>所以只要我们知道是对哪张表进行代码生成，这些内容我们都可以进行填充。</p> 
<p>分析完后，我们会发现，要想完成代码自动生成，我们需要有以下内容:</p> 
<ul><li>模板: MyBatisPlus提供，可以自己提供，但是麻烦，不建议</li><li>数据库相关配置:读取数据库获取表和字段信息</li><li>开发者自定义配置:手工配置，比如ID生成策略</li></ul> 
<h3 id="%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%E5%AE%9E%E7%8E%B0">代码生成器实现</h3> 
<h4 id="%E6%AD%A5%E9%AA%A41%3A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAMaven%E9%A1%B9%E7%9B%AE">步骤1:创建一个Maven项目</h4> 
<h4 id="%E4%BB%A3%E7%A0%812%3A%E5%AF%BC%E5%85%A5%E5%AF%B9%E5%BA%94%E7%9A%84jar%E5%8C%85">代码2:导入对应的jar包</h4> 
<h4 id="%E6%AD%A5%E9%AA%A43%3A%E7%BC%96%E5%86%99%E5%BC%95%E5%AF%BC%E7%B1%BB">步骤3:编写引导类</h4> 
<pre><code class="language-java">码2:导入对应的jar包
步骤3:编写引导类
@SpringBootApplication
public class Mybatisplus04GeneratorApplication {
​
    public static void main(String[] args) {
        SpringApplication.run(Mybatisplus04GeneratorApplication.class, args);
    }
​
}</code></pre> 
<h4 id="%E6%AD%A5%E9%AA%A44%3A%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E7%B1%BB">步骤4:创建代码生成类</h4> 
<pre><code class="language-java">public class CodeGenerator {
    public static void main(String[] args) {
        //1.获取代码生成器的对象
        AutoGenerator autoGenerator = new AutoGenerator();
​
        //设置数据库相关配置
        DataSourceConfig dataSource = new DataSourceConfig();
        dataSource.setDriverName("com.mysql.cj.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC");
        dataSource.setUsername("root");
        dataSource.setPassword("root");
        autoGenerator.setDataSource(dataSource);
​
        //设置全局配置
        GlobalConfig globalConfig = new GlobalConfig();
        globalConfig.setOutputDir(System.getProperty("user.dir")+"/mybatisplus_04_generator/src/main/java");    //设置代码生成位置
        globalConfig.setOpen(false);    //设置生成完毕后是否打开生成代码所在的目录
        globalConfig.setAuthor("黑马程序员");    //设置作者
        globalConfig.setFileOverride(true);     //设置是否覆盖原始生成的文件
        globalConfig.setMapperName("%sDao");    //设置数据层接口名，%s为占位符，指代模块名称
        globalConfig.setIdType(IdType.ASSIGN_ID);   //设置Id生成策略
        autoGenerator.setGlobalConfig(globalConfig);
​
        //设置包名相关配置
        PackageConfig packageInfo = new PackageConfig();
        packageInfo.setParent("com.aaa");   //设置生成的包名，与代码所在位置不冲突，二者叠加组成完整路径
        packageInfo.setEntity("domain");    //设置实体类包名
        packageInfo.setMapper("dao");   //设置数据层包名
        autoGenerator.setPackageInfo(packageInfo);
​
        //策略设置
        StrategyConfig strategyConfig = new StrategyConfig();
        strategyConfig.setInclude("tbl_user");  //设置当前参与生成的表名，参数为可变参数
        strategyConfig.setTablePrefix("tbl_");  //设置数据库表的前缀名称，模块名 = 数据库表名 - 前缀名  例如： User = tbl_user - tbl_
        strategyConfig.setRestControllerStyle(true);    //设置是否启用Rest风格
        strategyConfig.setVersionFieldName("version");  //设置乐观锁字段名
        strategyConfig.setLogicDeleteFieldName("deleted");  //设置逻辑删除字段名
        strategyConfig.setEntityLombokModel(true);  //设置是否启用lombok
        autoGenerator.setStrategy(strategyConfig);
        //2.执行生成操作
        autoGenerator.execute();
    }
}</code></pre> 
<p>对于代码生成器中的代码内容，我们可以直接从官方文档中获取代码进行修改，</p> 
<p><a href="https://mp.baomidou.com/guide/generator.html" rel="nofollow" title="https://mp.baomidou.com/guide/generator.html">https://mp.baomidou.com/guide/generator.html</a></p> 
<h4 id="%E6%AD%A5%E9%AA%A45%3A%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F">步骤5:运行程序</h4> 
<p>运行成功后，会在当前项目中生成很多代码，代码包含controller,service，mapper和entity</p> 
<h3 id="MP%E4%B8%ADService%E7%9A%84CRUD">MP中Service的CRUD</h3> 
<p>回顾我们之前业务层代码的编写，编写接口和对应的实现类:</p> 
<pre><code class="language-java">public interface UserService{
    
}
​
@Service
public class UserServiceImpl implements UserService{
}</code></pre> 
<p>接口和实现类有了以后，需要在接口和实现类中声明方法</p> 
<pre><code class="language-java">public interface UserService{
    public List&lt;User&gt; findAll();
}
​
@Service
public class UserServiceImpl implements UserService{
    @Autowired
    private UserDao userDao;
    
    public List&lt;User&gt; findAll(){
        return userDao.selectList(null);
    }
}</code></pre> 
<p>MP看到上面的代码以后就说这些方法也是比较固定和通用的，那我来帮你抽取下，所以MP提供了一个Service接口和实现类，分别是:IService和ServiceImpl,后者是对前者的一个具体实现。</p> 
<p>以后我们自己写的Service就可以进行如下修改:</p> 
<pre><code class="language-java">public interface UserService extends IService&lt;User&gt;{
    
}
​
@Service
public class UserServiceImpl extends ServiceImpl&lt;UserDao, User&gt; implements UserService{
​
}</code></pre> 
<p>修改以后的好处是，MP已经帮我们把业务层的一些基础的增删改查都已经实现了，可以直接进行使用。</p> 
<p>编写测试类进行测试:</p> 
<pre><code class="language-java">@SpringBootTest
class Mybatisplus04GeneratorApplicationTests {
​
    private IUserService userService;
​
    @Test
    void testFindAll() {
        List&lt;User&gt; list = userService.list();
        System.out.println(list);
    }
}</code></pre> 
<p>注意:mybatisplus_04_generator项目中对于MyBatis的环境是没有进行配置，如果想要运行，需要提取将配置文件中的内容进行完善后在运行。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fab387380ec67cab5eb172c12b5c586e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">51单片机四位数码管计算器 Proteus仿真程序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6423e7900a0602d7dd876014dc13fd81/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">第二章 HTTP请求方法、状态码详解与缓存机制解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>