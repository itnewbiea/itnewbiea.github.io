<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python3 学习笔记 多进程 multiprocessing 模块 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python3 学习笔记 多进程 multiprocessing 模块" />
<meta property="og:description" content="多进程 Multiprocessing 模块 multiprocessing 模块官方说明文档
Process 类 Process 类用来描述一个进程对象。创建子进程的时候，只需要传入一个执行函数和函数的参数即可完成 Process 示例的创建。
star() 方法启动进程，join() 方法实现进程间的同步，等待所有进程退出。close() 用来阻止多余的进程涌入进程池 Pool 造成进程阻塞。 multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None) target 是函数名字，需要调用的函数args 函数需要的参数，以 tuple 的形式传入 示例：
import multiprocessing import os def run_proc(name): print(&#39;Child process {0} {1} Running &#39;.format(name, os.getpid())) if __name__ == &#39;__main__&#39;: print(&#39;Parent process {0} is Running&#39;.format(os.getpid())) for i in range(5): p = multiprocessing.Process(target=run_proc, args=(str(i),)) print(&#39;process start&#39;) p.start() p.join() print(&#39;Process close&#39;) 结果：
Parent process 809 is Running process start process start process start process start process start Child process 0 810 Running Child process 1 811 Running Child process 2 812 Running Child process 3 813 Running Child process 4 814 Running Process close Pool Pool 可以提供指定数量的进程供用户使用，默认是 CPU 核数。当有新的请求提交到 Poll 的时候，如果池子没有满，会创建一个进程来执行，否则就会让该请求等待。 - Pool 对象调用 join 方法会等待所有的子进程执行完毕 - 调用 join 方法之前，必须调用 close - 调用 close 之后就不能继续添加新的 Process 了" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c0f75ead997ca95589d9bbfe4be7d5b1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-11-20T17:14:56+08:00" />
<meta property="article:modified_time" content="2017-11-20T17:14:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python3 学习笔记 多进程 multiprocessing 模块</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="多进程-multiprocessing-模块">多进程 Multiprocessing 模块</h2> 
<p><a href="https://docs.python.org/3.5/library/multiprocessing.html" rel="nofollow noopener noreferrer" target="_blank">multiprocessing 模块官方说明文档</a></p> 
<h3 id="process-类">Process 类</h3> 
<p>Process 类用来描述一个进程对象。创建子进程的时候，只需要传入一个执行函数和函数的参数即可完成 Process 示例的创建。</p> 
<ul><li>star() 方法启动进程，</li><li><code>join() 方法实现进程间的同步，</code>等待所有进程退出。</li><li>close() 用来阻止多余的进程涌入进程池 Pool 造成进程阻塞。</li></ul> 
<pre class="prettyprint"><code class=" hljs mathematica">multiprocessing.Process(group=<span class="hljs-keyword">None</span>, target=<span class="hljs-keyword">None</span>, name=<span class="hljs-keyword">None</span>, args=(), kwargs=<span class="hljs-list">{}</span>, *, daemon=<span class="hljs-keyword">None</span>)</code></pre> 
<ul><li>target 是函数名字，需要调用的函数</li><li>args 函数需要的参数，<code>以 tuple 的形式传入</code></li></ul> 
<p>示例：</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">import</span> multiprocessing
<span class="hljs-keyword">import</span> os

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_proc</span><span class="hljs-params">(name)</span>:</span>
    print(<span class="hljs-string">'Child process {0} {1} Running '</span>.format(name, os.getpid()))

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    print(<span class="hljs-string">'Parent process {0} is Running'</span>.format(os.getpid()))
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):
        p = multiprocessing.Process(target=run_proc, args=(str(i),))
        print(<span class="hljs-string">'process start'</span>)
        p.start()
    p.join()
    print(<span class="hljs-string">'Process close'</span>)</code></pre> 
<p>结果：</p> 
<pre class="prettyprint"><code class=" hljs vhdl">Parent <span class="hljs-keyword">process</span> <span class="hljs-number">809</span> <span class="hljs-keyword">is</span> Running
<span class="hljs-keyword">process</span> start
<span class="hljs-keyword">process</span> start
<span class="hljs-keyword">process</span> start
<span class="hljs-keyword">process</span> start
<span class="hljs-keyword">process</span> start
Child <span class="hljs-keyword">process</span> <span class="hljs-number">0</span> <span class="hljs-number">810</span> Running 
Child <span class="hljs-keyword">process</span> <span class="hljs-number">1</span> <span class="hljs-number">811</span> Running 
Child <span class="hljs-keyword">process</span> <span class="hljs-number">2</span> <span class="hljs-number">812</span> Running 
Child <span class="hljs-keyword">process</span> <span class="hljs-number">3</span> <span class="hljs-number">813</span> Running 
Child <span class="hljs-keyword">process</span> <span class="hljs-number">4</span> <span class="hljs-number">814</span> Running 
<span class="hljs-keyword">Process</span> close</code></pre> 
<h3 id="pool">Pool</h3> 
<p>Pool 可以提供指定数量的进程供用户使用，默认是 CPU 核数。当有新的请求提交到 Poll 的时候，如果池子没有满，会创建一个进程来执行，否则就会让该请求等待。 <br> - Pool 对象调用 join 方法会等待所有的子进程执行完毕 <br> - 调用 join 方法之前，必须调用 close <br> - 调用 close 之后就不能继续添加新的 Process 了</p> 
<h4 id="poolapplyasync">pool.apply_async</h4> 
<p>apply_async 方法用来同步执行进程，允许多个进程同时进入池子。</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">import</span> multiprocessing
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> time

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_task</span><span class="hljs-params">(name)</span>:</span>
    print(<span class="hljs-string">'Task {0} pid {1} is running, parent id is {2}'</span>.format(name, os.getpid(), os.getppid()))
    time.sleep(<span class="hljs-number">1</span>)
    print(<span class="hljs-string">'Task {0} end.'</span>.format(name))

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    print(<span class="hljs-string">'current process {0}'</span>.format(os.getpid()))
    p = multiprocessing.Pool(processes=<span class="hljs-number">3</span>)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">6</span>):
        p.apply_async(run_task, args=(i,))
    print(<span class="hljs-string">'Waiting for all subprocesses done...'</span>)
    p.close()
    p.join()
    print(<span class="hljs-string">'All processes done!'</span>)</code></pre> 
<p>结果：</p> 
<pre class="prettyprint"><code class=" hljs applescript">current process <span class="hljs-number">921</span>
Waiting <span class="hljs-keyword">for</span> all subprocesses done...
Task <span class="hljs-number">0</span> pid <span class="hljs-number">922</span> <span class="hljs-keyword">is</span> <span class="hljs-property">running</span>, parent <span class="hljs-property">id</span> <span class="hljs-keyword">is</span> <span class="hljs-number">921</span>
Task <span class="hljs-number">1</span> pid <span class="hljs-number">923</span> <span class="hljs-keyword">is</span> <span class="hljs-property">running</span>, parent <span class="hljs-property">id</span> <span class="hljs-keyword">is</span> <span class="hljs-number">921</span>
Task <span class="hljs-number">2</span> pid <span class="hljs-number">924</span> <span class="hljs-keyword">is</span> <span class="hljs-property">running</span>, parent <span class="hljs-property">id</span> <span class="hljs-keyword">is</span> <span class="hljs-number">921</span>
Task <span class="hljs-number">0</span> <span class="hljs-keyword">end</span>.
Task <span class="hljs-number">3</span> pid <span class="hljs-number">922</span> <span class="hljs-keyword">is</span> <span class="hljs-property">running</span>, parent <span class="hljs-property">id</span> <span class="hljs-keyword">is</span> <span class="hljs-number">921</span>
Task <span class="hljs-number">1</span> <span class="hljs-keyword">end</span>.
Task <span class="hljs-number">4</span> pid <span class="hljs-number">923</span> <span class="hljs-keyword">is</span> <span class="hljs-property">running</span>, parent <span class="hljs-property">id</span> <span class="hljs-keyword">is</span> <span class="hljs-number">921</span>
Task <span class="hljs-number">2</span> <span class="hljs-keyword">end</span>.
Task <span class="hljs-number">5</span> pid <span class="hljs-number">924</span> <span class="hljs-keyword">is</span> <span class="hljs-property">running</span>, parent <span class="hljs-property">id</span> <span class="hljs-keyword">is</span> <span class="hljs-number">921</span>
Task <span class="hljs-number">3</span> <span class="hljs-keyword">end</span>.
Task <span class="hljs-number">4</span> <span class="hljs-keyword">end</span>.
Task <span class="hljs-number">5</span> <span class="hljs-keyword">end</span>.
All processes done!</code></pre> 
<h4 id="poolapply">pool.apply</h4> 
<pre class="prettyprint"><code class=" hljs erlang"><span class="hljs-function"><span class="hljs-title">apply</span><span class="hljs-params">(func[, args[, kwds]])</span></span></code></pre> 
<p>该方法只能允许一个进程进入池子，在一个进程结束之后，另外一个进程才可以进入池子。</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">import</span> multiprocessing
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> time

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_task</span><span class="hljs-params">(name)</span>:</span>
    print(<span class="hljs-string">'Task {0} pid {1} is running, parent id is {2}'</span>.format(name, os.getpid(), os.getppid()))
    time.sleep(<span class="hljs-number">1</span>)
    print(<span class="hljs-string">'Task {0} end.'</span>.format(name))

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    print(<span class="hljs-string">'current process {0}'</span>.format(os.getpid()))
    p = multiprocessing.Pool(processes=<span class="hljs-number">3</span>)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">6</span>):
        p.apply(run_task, args=(i,))
    print(<span class="hljs-string">'Waiting for all subprocesses done...'</span>)
    p.close()
    p.join()
    print(<span class="hljs-string">'All processes done!'</span>)</code></pre> 
<p>结果：</p> 
<pre class="prettyprint"><code class=" hljs applescript">Task <span class="hljs-number">0</span> pid <span class="hljs-number">928</span> <span class="hljs-keyword">is</span> <span class="hljs-property">running</span>, parent <span class="hljs-property">id</span> <span class="hljs-keyword">is</span> <span class="hljs-number">927</span>
Task <span class="hljs-number">0</span> <span class="hljs-keyword">end</span>.
Task <span class="hljs-number">1</span> pid <span class="hljs-number">929</span> <span class="hljs-keyword">is</span> <span class="hljs-property">running</span>, parent <span class="hljs-property">id</span> <span class="hljs-keyword">is</span> <span class="hljs-number">927</span>
Task <span class="hljs-number">1</span> <span class="hljs-keyword">end</span>.
Task <span class="hljs-number">2</span> pid <span class="hljs-number">930</span> <span class="hljs-keyword">is</span> <span class="hljs-property">running</span>, parent <span class="hljs-property">id</span> <span class="hljs-keyword">is</span> <span class="hljs-number">927</span>
Task <span class="hljs-number">2</span> <span class="hljs-keyword">end</span>.
Task <span class="hljs-number">3</span> pid <span class="hljs-number">928</span> <span class="hljs-keyword">is</span> <span class="hljs-property">running</span>, parent <span class="hljs-property">id</span> <span class="hljs-keyword">is</span> <span class="hljs-number">927</span>
Task <span class="hljs-number">3</span> <span class="hljs-keyword">end</span>.
Task <span class="hljs-number">4</span> pid <span class="hljs-number">929</span> <span class="hljs-keyword">is</span> <span class="hljs-property">running</span>, parent <span class="hljs-property">id</span> <span class="hljs-keyword">is</span> <span class="hljs-number">927</span>
Task <span class="hljs-number">4</span> <span class="hljs-keyword">end</span>.
Task <span class="hljs-number">5</span> pid <span class="hljs-number">930</span> <span class="hljs-keyword">is</span> <span class="hljs-property">running</span>, parent <span class="hljs-property">id</span> <span class="hljs-keyword">is</span> <span class="hljs-number">927</span>
Task <span class="hljs-number">5</span> <span class="hljs-keyword">end</span>.
Waiting <span class="hljs-keyword">for</span> all subprocesses done...
All processes done!</code></pre> 
<h3 id="queue-进程间通信">Queue 进程间通信</h3> 
<p>Queue 用来在多个进程间通信。Queue 有两个方法，get 和 put。</p> 
<h4 id="put-方法">put 方法</h4> 
<p>Put 方法用来插入数据到队列中，有两个可选参数，blocked 和 timeout。 <br> - blocked = True（默认值），timeout 为正</p> 
<blockquote> 
 <p>该方法会阻塞 timeout 指定的时间，直到该队列有剩余空间。如果超时，抛出 Queue.Full 异常。</p> 
</blockquote> 
<p></p> 
<ul><li><br> 
 </li><li>blocked = False <br></li></ul> 
<p></p> 
<blockquote>
  如果 Queue 已满， 
 <code>立刻</code>抛出 Queue.Full 异常 
</blockquote> 
<h4 id="get-方法">get 方法</h4> 
<p>get 方法用来从队列中读取<code>并删除</code>一个元素。有两个参数可选，blocked 和 timeout <br> - blocked = False （默认），timeout 正值</p> 
<blockquote> 
 <p>等待时间内，没有取到任何元素，会抛出 Queue.Empty 异常。</p> 
</blockquote> 
<p></p> 
<ul><li><br> 
 </li><li>blocked = True <br></li></ul> 
<p></p> 
<blockquote>
  Queue 有一个值可用，立刻返回改值；Queue 没有任何元素， 
</blockquote> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Queue
<span class="hljs-keyword">import</span> os, time, random
<span class="hljs-comment"># 写数据进程执行的代码:</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">proc_write</span><span class="hljs-params">(q,urls)</span>:</span>
    print(<span class="hljs-string">'Process(%s) is writing...'</span> % os.getpid())
    <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls:
        q.put(url)
        print(<span class="hljs-string">'Put %s to queue...'</span> % url)
        time.sleep(random.random())
<span class="hljs-comment"># 读数据进程执行的代码:</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">proc_read</span><span class="hljs-params">(q)</span>:</span>
    print(<span class="hljs-string">'Process(%s) is reading...'</span> % os.getpid())
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
        url = q.get(<span class="hljs-keyword">True</span>)
        print(<span class="hljs-string">'Get %s from queue.'</span> % url)
<span class="hljs-keyword">if</span> __name__==<span class="hljs-string">'__main__'</span>:
    <span class="hljs-comment"># 父进程创建Queue，并传给各个子进程：</span>
    q = Queue()
    proc_writer1 = Process(target=proc_write, args=(q,[<span class="hljs-string">'url_1'</span>, <span class="hljs-string">'url_2'</span>, <span class="hljs-string">'url_3'</span>]))
    proc_writer2 = Process(target=proc_write, args=(q,[<span class="hljs-string">'url_4'</span>,<span class="hljs-string">'url_5'</span>,<span class="hljs-string">'url_6'</span>]))
    proc_reader = Process(target=proc_read, args=(q,))
    <span class="hljs-comment"># 启动子进程proc_writer，写入:</span>
    proc_writer1.start()
    proc_writer2.start()
    <span class="hljs-comment"># 启动子进程proc_reader，读取:</span>
    proc_reader.start()
    <span class="hljs-comment"># 等待proc_writer结束:</span>
    proc_writer1.join()
    proc_writer2.join()
    <span class="hljs-comment"># proc_reader进程里是死循环，无法等待其结束，只能强行终止:</span>
    proc_reader.terminate()</code></pre> 
<p>结果:</p> 
<pre class="prettyprint"><code class=" hljs lasso">Process(<span class="hljs-number">1083</span>) is writing<span class="hljs-attribute">...</span>
Put url_1 <span class="hljs-keyword">to</span> <span class="hljs-built_in">queue</span><span class="hljs-attribute">...</span>
Process(<span class="hljs-number">1084</span>) is writing<span class="hljs-attribute">...</span>
Put url_4 <span class="hljs-keyword">to</span> <span class="hljs-built_in">queue</span><span class="hljs-attribute">...</span>
Process(<span class="hljs-number">1085</span>) is reading<span class="hljs-attribute">...</span>
Get url_1 from <span class="hljs-built_in">queue</span><span class="hljs-built_in">.</span>
Get url_4 from <span class="hljs-built_in">queue</span><span class="hljs-built_in">.</span>
Put url_5 <span class="hljs-keyword">to</span> <span class="hljs-built_in">queue</span><span class="hljs-attribute">...</span>
Get url_5 from <span class="hljs-built_in">queue</span><span class="hljs-built_in">.</span>
Put url_2 <span class="hljs-keyword">to</span> <span class="hljs-built_in">queue</span><span class="hljs-attribute">...</span>
Get url_2 from <span class="hljs-built_in">queue</span><span class="hljs-built_in">.</span>
Put url_6 <span class="hljs-keyword">to</span> <span class="hljs-built_in">queue</span><span class="hljs-attribute">...</span>
Get url_6 from <span class="hljs-built_in">queue</span><span class="hljs-built_in">.</span>
Put url_3 <span class="hljs-keyword">to</span> <span class="hljs-built_in">queue</span><span class="hljs-attribute">...</span>
Get url_3 from <span class="hljs-built_in">queue</span><span class="hljs-built_in">.</span></code></pre> 
<h3 id="pipe-进程间通信">Pipe 进程间通信</h3> 
<p>常用来在两个进程间通信，两个进程分别位于管道的两端。</p> 
<pre class="prettyprint"><code class=" hljs css"><span class="hljs-tag">multiprocessing</span><span class="hljs-class">.Pipe</span>(<span class="hljs-attr_selector">[duplex]</span>)</code></pre> 
<blockquote> 
 <p>示例一和示例二，也是网上找的别人的例子，尝试理解并增加了注释而已。网上的例子，大多是例子一和例子二在一起的，这里分开来看，比较容易理解。</p> 
</blockquote> 
<p>示例一：</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Pipe

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send</span><span class="hljs-params">(pipe)</span>:</span>
    pipe.send([<span class="hljs-string">'spam'</span>] + [<span class="hljs-number">42</span>, <span class="hljs-string">'egg'</span>])   <span class="hljs-comment"># send 传输一个列表</span>
    pipe.close()

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    (con1, con2) = Pipe()                            <span class="hljs-comment"># 创建两个 Pipe 实例</span>
    sender = Process(target=send, args=(con1, ))     <span class="hljs-comment"># 函数的参数，args 一定是实例化之后的 Pip 变量，不能直接写 args=(Pip(),)</span>
    sender.start()                                   <span class="hljs-comment"># Process 类启动进程</span>
    print(<span class="hljs-string">"con2 got: %s"</span> % con2.recv())              <span class="hljs-comment"># 管道的另一端 con2 从send收到消息</span>
    con2.close()                                     <span class="hljs-comment"># 关闭管道</span></code></pre> 
<p>结果：</p> 
<pre class="prettyprint"><code class=" hljs bash">con2 got: [<span class="hljs-string">'spam'</span>, <span class="hljs-number">42</span>, <span class="hljs-string">'egg'</span>]</code></pre> 
<p>示例二：</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Pipe

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span><span class="hljs-params">(pipe)</span>:</span>
    pipe.send(dict(name=<span class="hljs-string">'Bob'</span>, spam=<span class="hljs-number">42</span>))            <span class="hljs-comment"># 传输一个字典</span>
    reply = pipe.recv()                             <span class="hljs-comment"># 接收传输的数据</span>
    print(<span class="hljs-string">'talker got:'</span>, reply)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    (parentEnd, childEnd) = Pipe()                  <span class="hljs-comment"># 创建两个 Pipe() 实例，也可以改成 conf1， conf2</span>
    child = Process(target=talk, args=(childEnd,))  <span class="hljs-comment"># 创建一个 Process 进程，名称为 child</span>
    child.start()                                   <span class="hljs-comment"># 启动进程</span>
    print(<span class="hljs-string">'parent got:'</span>, parentEnd.recv())          <span class="hljs-comment"># parentEnd 是一个 Pip() 管道，可以接收 child Process 进程传输的数据</span>
    parentEnd.send({x * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-string">'spam'</span>})         <span class="hljs-comment"># parentEnd 是一个 Pip() 管道，可以使用 send 方法来传输数据</span>
    child.join()                                    <span class="hljs-comment"># 传输的数据被 talk 函数内的 pip 管道接收，并赋值给 reply</span>
    print(<span class="hljs-string">'parent exit'</span>)</code></pre> 
<p>结果:</p> 
<pre class="prettyprint"><code class=" hljs php"><span class="hljs-keyword">parent</span> got: {<!-- --><span class="hljs-string">'name'</span>: <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'spam'</span>: <span class="hljs-number">42</span>}
talker got: {<!-- --><span class="hljs-string">'ss'</span>, <span class="hljs-string">'aa'</span>, <span class="hljs-string">'pp'</span>, <span class="hljs-string">'mm'</span>}
<span class="hljs-keyword">parent</span> <span class="hljs-keyword">exit</span></code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1a7bb89ecc059d81d884e81e95230c71/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java.lang.NoClassDefFoundError: org/apache/commons/collections/map/MultiKeyMap</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f7a910dcbcc93fd604940b482dfd2bb8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">屏幕自适应的values-sw720dp的疑问</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>