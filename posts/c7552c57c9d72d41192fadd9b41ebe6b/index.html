<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>less webpack 热更新_使用babel和webpack优化项目 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="less webpack 热更新_使用babel和webpack优化项目" />
<meta property="og:description" content="前言 组件化、模块化、自动化、工程化是现在考核一前端项目是否为一个优秀项目的标准之一，从而应运而生了一些列前端模块化、工程化的工具库。babel和webpack就是其中的优秀代表，那你了解他们么？你知道如何通过babel和webpack来优化前端项目么？
正文 webpack webpack是一款前端构建工具，他的主要作用就是将各个具有依赖的模块打包整合在一起生成静态资源。就像官网展示的图片：
module chunk bundle的区别 module: 各个源码文件，webpack中一切皆模块chunk: 多个模块拼接合成的文件，使用entry，import()，splitChunk可以生成chunkbundle: 最终输出的文件称为bundle loader和plugin的区别 loader: 模块转换器。less=&gt;cssplugin: 扩展插件 webpack性能优化 基本分为两个方面：
优化打包构建速度优化产出代码 优化打包构建速度 优化babel-loader 启用缓存use:[&#39;babel-loader?cacheDirectory]合理使用include和exclude IgnorePlugin: 忽略本地化内容 new Webpack.IgnorePlugin(/\.\/locale/,/moment/),//moment这个库中，如果引用了./locale/目录的内容，就忽略掉，不会打包进去
// index.js 在文件中需要手动引入当前包内自己所需要的部分
import moment from &#39;moment&#39;
//手动引入所需要的语言包
import &#39;moment/locale/zh-cn&#39;;
moment.locale(&#39;zh-cn&#39;);
noParse: 打包时不去解析相关模块中是否还依赖其他包,而这些三方库里面没有其他依赖 module:{
noParse:/jquery|lodash/,//不去解析jquery、lodash中的依赖库
}
happyPack: 开启多进程打包，提高构建速度。 // loader
{
text:/\.js$/,
use:[&#39;happypack/loader?id=babel&#39;],
}
// plugins
new HappyPack({
id:&#39;babel&#39;,
loaders:[{
loader: &#39;babel-loader&#39;,
options:{
cacheDirectory: true,
}
}]
})
parallelUglifyPlugin webpack内置了一款Uglify工具压缩js，但是不能开启多进程项目比较大。构建速度缓慢才需要使用多进程，项目简单开启多进程开销太大，可能拖慢打包进程 new ParallelUglifyPlugin({
uglifyJS:{" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c7552c57c9d72d41192fadd9b41ebe6b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-30T22:04:01+08:00" />
<meta property="article:modified_time" content="2020-12-30T22:04:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">less webpack 热更新_使用babel和webpack优化项目</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="._5ce-wx-style" style="font-size:16px;"> 
 <div class="rich_media_content" id="js_content"> 
  <h2><span style="font-weight:bold;"></span><span style="font-weight:bold;">前言</span><span style="font-weight:bold;"></span></h2> 
  <p>组件化、模块化、自动化、工程化是现在考核一前端项目是否为一个优秀项目的标准之一，从而应运而生了一些列前端模块化、工程化的工具库。babel和webpack就是其中的优秀代表，那你了解他们么？你知道如何通过babel和webpack来优化前端项目么？</p> 
  <h2><span style="font-weight:bold;"></span><span style="font-weight:bold;">正文</span><span style="font-weight:bold;"></span></h2> 
  <h3><span style="font-weight:bold;"></span><span style="font-weight:bold;">webpack</span><span style="font-weight:bold;"></span></h3> 
  <p>webpack是一款前端构建工具，他的主要作用就是将各个具有依赖的模块打包整合在一起生成静态资源。就像官网展示的图片：<img src="https://images2.imgbox.com/d9/9a/cj6VWfPO_o.png" alt="cd640c6b392b67277efce6f5b0ab2b45.png"></p> 
  <h3><span style="font-weight:bold;"></span><span style="font-weight:bold;">module chunk bundle的区别</span><span style="font-weight:bold;"></span></h3> 
  <ul><li>module: 各个源码文件，webpack中一切皆模块</li><li>chunk: 多个模块拼接合成的文件，使用entry，import()，splitChunk可以生成chunk</li><li>bundle: 最终输出的文件称为bundle</li></ul> 
  <h3><span style="font-weight:bold;"></span><span style="font-weight:bold;">loader和plugin的区别</span><span style="font-weight:bold;"></span></h3> 
  <ul><li>loader: 模块转换器。less=&gt;css</li><li>plugin: 扩展插件</li></ul> 
  <h3><span style="font-weight:bold;"></span><span style="font-weight:bold;">webpack性能优化</span><span style="font-weight:bold;"></span></h3> 
  <p>基本分为两个方面：</p> 
  <ul><li>优化打包构建速度</li><li>优化产出代码</li></ul> 
  <h4><span style="font-weight:bold;"></span><span style="font-weight:bold;">优化打包构建速度</span><span style="font-weight:bold;"></span></h4> 
  <h5><span style="font-weight:bold;"></span><span style="font-weight:bold;">优化babel-loader</span><span style="font-weight:bold;"></span></h5> 
  <ul><li>启用缓存<code>use:['babel-loader?cacheDirectory]</code></li><li>合理使用include和exclude</li></ul> 
  <h5><span style="font-weight:bold;"></span><span style="font-weight:bold;">IgnorePlugin: 忽略本地化内容</span><span style="font-weight:bold;"></span></h5> 
  <pre><code><code>new Webpack.IgnorePlugin(/\.\/locale/,/moment/),//moment这个库中，如果引用了./locale/目录的内容，就忽略掉，不会打包进去<br><br>// index.js 在文件中需要手动引入当前包内自己所需要的部分<br>import moment from 'moment'<br>//手动引入所需要的语言包<br>import 'moment/locale/zh-cn';<br>moment.locale('zh-cn');<br></code></code></pre> 
  <h5><span style="font-weight:bold;"></span><span style="font-weight:bold;">noParse: 打包时不去解析相关模块中是否还依赖其他包,而这些三方库里面没有其他依赖</span><span style="font-weight:bold;"></span></h5> 
  <pre><code><code>module:{<!-- --><br>  noParse:/jquery|lodash/,//不去解析jquery、lodash中的依赖库<br>}<br></code></code></pre> 
  <h5><span style="font-weight:bold;"></span><span style="font-weight:bold;">happyPack: 开启多进程打包，提高构建速度。</span><span style="font-weight:bold;"></span></h5> 
  <pre><code><code>  // loader<br>{<!-- --><br>  text:/\.js$/,<br>  use:['happypack/loader?id=babel'],<br>}<br>// plugins<br>new HappyPack({<!-- --><br>    id:'babel',<br>    loaders:[{<!-- --><br>      loader: 'babel-loader',<br>      options:{<!-- --><br>        cacheDirectory: true,<br>      }<br>    }]<br>})<br></code></code></pre> 
  <h5><span style="font-weight:bold;"></span><span style="font-weight:bold;">parallelUglifyPlugin</span><span style="font-weight:bold;"></span></h5> 
  <ul><li>webpack内置了一款Uglify工具压缩js，但是不能开启多进程</li><li>项目比较大。构建速度缓慢才需要使用多进程，项目简单开启多进程开销太大，可能拖慢打包进程</li></ul> 
  <pre><code><code>new ParallelUglifyPlugin({<!-- --><br>  uglifyJS:{<!-- --><br>    output: {<!-- --><br>      beautify: false,  // 紧凑输出<br>      comments:false, // 删除注释<br>    },<br>    compress:{<!-- --><br>      drop_console: true,<br>      collapse_vars: true,  // 内嵌定义了但是只用到一次的变量<br>      reduce_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值<br>    }<br>  }<br>}),<br></code></code></pre> 
  <h5><span style="font-weight:bold;"></span><span style="font-weight:bold;">自动刷新：<code>watch: true</code></span><span style="font-weight:bold;"></span></h5> 
  <h5><span style="font-weight:bold;"></span><span style="font-weight:bold;">热更新: <code>HotModuleReplacementPlugin</code></span><span style="font-weight:bold;"></span></h5> 
  <p>对于js文件需要手动配置实现热更新。css更改自动实现热更新。</p> 
  <h5><span style="font-weight:bold;"></span><span style="font-weight:bold;">DllPlugin: 动态链接库</span><span style="font-weight:bold;"></span></h5> 
  <ul><li>首先使用webpack.DllPlugin打包出dll.js文件和mainfest.json</li></ul> 
  <pre><code><code>entry:{<!-- --><br>  vendors:['lodash'],<br>  react:['react','react-dom'],<br>},<br>output:{<!-- --><br>  filename:'[name].dll.js',<br>  path: path.resolve(__dirname,'../dll'),<br>  library: '[name]',<br>},<br>plugins: [<br>  new webpack.DllPlugin({<!-- --><br>    name: '[name]',<br>    path: path.resolve(__dirname,'../dll/[name].manifest.json')<br>  })<br>]<br></code></code></pre> 
  <ul><li>接着在npm run dev 时使用webpack.DllReferencePlugin关联文件、使用AddAssetHtmlWebpackPlugin在html添加对dll.js文件的引用</li></ul> 
  <pre><code><code>const files = fs.readdirSync(path.resolve(__dirname,'../dll'))<br>files.forEach(file =&gt; {<!-- --><br>  if(/.*\.dll.js/.test(file)){<!-- --><br>    plugins.push(<br>      new AddAssetHtmlWebpackPlugin({<!-- --><br>        filepath: path.resolve(__dirname, '../dll', file)<br>      }),<br>    )<br>  }<br>  if(/.*\.manifest.json/.test(file)){<!-- --><br>    new webpack.DllReferencePlugin({<!-- --><br>      manifest: path.resolve(__dirname, '../dll', file)<br>    })<br>  }<br>})<br></code></code></pre> 
  <ul><li>不推荐使用在生产环境中</li></ul> 
  <h4><span style="font-weight:bold;"></span><span style="font-weight:bold;">优化产出代码</span><span style="font-weight:bold;"></span></h4> 
  <h5><span style="font-weight:bold;"></span><span style="font-weight:bold;">代码体积更小</span><span style="font-weight:bold;"></span></h5> 
  <ul><li>url-loader 产出base64格式的图片</li><li>Tree-Shaking: <code>mode: 'production'</code> 
    <ul><li>只有使用ES Module引用才能实现Tree-Shaking</li></ul></li><li>Scope Hosting：代码体积更小，创建函数作用域更少，代码可读性更高<pre><code><code>// 针对npm中第三方模块优先采用jsnext:main中指向的ES6 模块化语法的文件<br>resolve: ['jsnext:main', 'browser', 'main'],<br><br>plugin:{<!-- --><br>  // 开启Scope Hosting<br>  new webpack.optimize.ModuleConcatenationPlugin()<br>}<br></code></code></pre></li></ul> 
  <h5><span style="font-weight:bold;"></span><span style="font-weight:bold;">合理分包，不重复加载</span><span style="font-weight:bold;"></span></h5> 
  <ul><li>打包出的bundle加Hash，未改变的文件使其能命中缓存</li><li>提取公共代码：</li></ul> 
  <pre><code><code>optimizatoin:{<!-- --><br>  splitChunks:{<!-- --><br>    chunks: 'all',<br>    minSize: 20000,<br>    // minRemainingSize: 0,<br>    maxSize: 0,<br>    minChunks: 1,       // 代码被引入了多少次才会代码分隔<br>    maxAsyncRequests: 6,      // 最多同时 请求数<br>    maxInitialRequests: 4,      // 最多入口分隔的 请求数<br>    automaticNameDelimiter: '~',<br>    cacheGroups: {<!-- --><br>      vendors: {<!-- --><br>        test: /[\\/]node_modules[\\/]/,<br>        priority: -10,<br>      },<br>      default: {<!-- --><br>        minChunks: 2,<br>        priority: -20,<br>        reuseExistingChunk: true<br>      }<br>    }<br>  },<br>}<br></code></code></pre> 
  <h5><span style="font-weight:bold;"></span><span style="font-weight:bold;">速度更快，内存使用少</span><span style="font-weight:bold;"></span></h5> 
  <ul><li>使用懒加载<code>import()</code></li><li>使用CDN加速: <code>publicPath:'http://cnd.com'</code></li></ul> 
  <h3><span style="font-weight:bold;"></span><span style="font-weight:bold;">babel</span><span style="font-weight:bold;"></span></h3> 
  <p>babel是一款JavaScript的编译器。他负责</p> 
  <ul><li>检查语法是否符合es5语法规范。不符合就转换</li><li>不处理模块化(webpack处理)</li></ul> 
  <h4><span style="font-weight:bold;"></span><span style="font-weight:bold;">presets</span><span style="font-weight:bold;"></span></h4> 
  <p>presets是babel中的预设组件。相当于一堆plugin的集合。常见的有</p> 
  <ul><li><code>@babel/preset-env</code></li><li><code>@babel/preset-flow</code></li><li><code>@babel/preset-react</code></li><li><code>@babel/preset-typescript</code></li></ul> 
  <h4><span style="font-weight:bold;"></span><span style="font-weight:bold;">babel-polyfill</span><span style="font-weight:bold;"></span></h4> 
  <ul><li><code>core-js</code>: 将ES6、ES7等代码转换整ES5代码的工具库</li><li><code>regenerator</code>: 将<code>generator</code>函数转换为ES5代码的工具库</li></ul> 
  <p>babel-polyfill就是两者的集合。babel在7.4版本放弃了babel-polyfill推荐用户直接使用<code>core-js</code>或<code>regenerator</code></p> 
  <p>如何实现按需引用，在.babelrc文件下</p> 
  <pre><code><code>{<!-- --><br>  "presets":[<br>    [<br>      "@babel/preset-env",<br>      {<!-- --><br>        "useBuiltIns": "usage", // 按需引用<br>        "corejs": 3 //core-js 版本<br>      }<br>    ]<br>  ]<br>}<br></code></code></pre> 
  <h4><span style="font-weight:bold;"></span><span style="font-weight:bold;">babel-runtime</span><span style="font-weight:bold;"></span></h4> 
  <p>babel-polyfill会造成全局污染，runtime就是为了防止全局污染。写第三方库时可以使用。</p> 
  <p>.babelrc</p> 
  <pre><code><code>{<!-- --><br>  "plugins":[<br>    [<br>      "@babel/plugin-transform-runtime",<br>      {<!-- --><br>        "absoluteRuntime": false,<br>        "corejs": false,<br>        "helpers": true,<br>        "regenerator": true,<br>        "useESModules": false,<br>      }<br>    ]<br>  ]<br>}<br></code></code></pre> 
  <h3><span style="font-weight:bold;"></span><span style="font-weight:bold;">前端为何要进行打包和构建？</span><span style="font-weight:bold;"></span></h3> 
  <ul><li>体积更小(Tree-Shaking、压缩、合并)，加载更快</li><li>编译高级语言和语法(TS、ES6+、模块化、sass、less)</li><li>兼容性和语法检查(polyfill、postcss、eslint)</li><li>统一高校的开发环境</li><li>统一的构建流程和产出标准</li><li>集成公司构建规范(提测、上线)</li></ul> 
 </div> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/22731d32f99d85cfa971edd823dfc5c1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">距离函数的等价性</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8487e398c16d3eff2f5260add3942e06/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大于3小于4的整数bleem_比三大，比四小的整数是存在的吗？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>