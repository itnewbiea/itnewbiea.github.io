<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linunx的sleep,usleep,select,nonasleep对比与应用 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linunx的sleep,usleep,select,nonasleep对比与应用" />
<meta property="og:description" content="前言 时钟换算:
1秒(s) = 1000 毫秒(ms) = 1,000,000 微秒(μs) = 1,000,000,000 纳秒(ns) = 1,000,000,000,000 皮秒(ps)
程序挂起主要有以下几种:
sleep, usleep, select, pselect, nanosleep;
它们的精度不同，在不同的应用场景下需要不同的函数；
一、用法 1.1 函数名: sleep 头文件:
#include &lt;unistd.h&gt; // 在gcc编译器中，使用的头文件因gcc版本的不同而不同
功 能: 执行挂起指定的秒数
语 法: unsigned sleep(unsigned seconds);
示例:
#include&lt;stdio.h&gt;
int main()
{
int a;
a=1;
printf(&#34;hello&#34;);
sleep(a); printf(&#34;world&#34;); return 0;
}
1.2 函数名: usleep 功 能: usleep功能把进程挂起一段时间， 单位是微秒（百万分之一秒）；
头文件: #include &lt;unistd.h&gt;
语 法:
void usleep(int micro_seconds);
返回值: 无" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/15517b9620b515ffa20d67a021d83306/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-03-08T17:18:00+08:00" />
<meta property="article:modified_time" content="2013-03-08T17:18:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linunx的sleep,usleep,select,nonasleep对比与应用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言</h2> 
<p>时钟换算:</p> 
<p>1秒(s) = 1000 毫秒(ms) = 1,000,000 微秒(μs) = 1,000,000,000 纳秒(ns) = 1,000,000,000,000 皮秒(ps)</p> 
<p>程序挂起主要有以下几种:</p> 
<p>sleep, usleep, select, pselect, nanosleep;</p> 
<p>它们的精度不同，在不同的应用场景下需要不同的函数；</p> 
<p> </p> 
<h2>一、用法</h2> 
<h3>1.1 函数名: sleep</h3> 
<p>头文件:</p> 
<p>#include &lt;unistd.h&gt;  // 在gcc编译器中，使用的头文件因gcc版本的不同而不同</p> 
<p>功  能: 执行挂起指定的秒数</p> 
<p>语  法: unsigned sleep(unsigned seconds);</p> 
<p> </p> 
<p>示例:</p> 
<p>#include&lt;stdio.h&gt;</p> 
<p>int main()</p> 
<p>{<!-- --></p> 
<p>  int a;</p> 
<p>  a=1;</p> 
<p>  printf("hello");</p> 
<p>  sleep(a);      </p> 
<p>  printf("world"); </p> 
<p>  return 0;</p> 
<p>}</p> 
<p> </p> 
<h3>1.2 函数名: usleep</h3> 
<p>功  能: usleep功能把进程挂起一段时间， 单位是微秒（百万分之一秒）；</p> 
<p>头文件: #include &lt;unistd.h&gt;</p> 
<p>语  法:</p> 
<p>void usleep(int micro_seconds);</p> 
<p>返回值: 无</p> 
<p>内容说明：本函数可暂时使程序停止执行。参数 micro_seconds 为要暂停的微秒数(us)。</p> 
<p>注 意：</p> 
<p>用在Linux的测试环境下面。</p> 
<p>参 见:usleep() 与sleep()类似，用于延迟挂起进程。进程被挂起放到reday queue。</p> 
<p>是一般情况下，延迟时间数量级是秒的时候，尽可能使用sleep()函数。</p> 
<p>如果延迟时间为几十毫秒（1ms = 1000us），或者更小，尽可能使用usleep()函数。这样才能最佳的利用CPU时间.</p> 
<p> </p> 
<h3>1.3 函数名：select</h3> 
<p>功能：I/O多工机制</p> 
<p>用来等待文件描述符状态的改变。</p> 
<p>头文件：</p> 
<p>#include &lt;sys/time.h&gt;</p> 
<p>#include &lt;sys/types.h&gt;</p> 
<p>#include &lt;unistd.h&gt;</p> 
<p>语法：</p> 
<p>int select(int maxfdp, <a href="https://www.baidu.com/s?wd=fd_set&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" rel="nofollow">fd_set</a> *readfds, <a href="https://www.baidu.com/s?wd=fd_set&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" rel="nofollow">fd_set</a> *writefds, <a href="https://www.baidu.com/s?wd=fd_set&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" rel="nofollow">fd_set</a> *errorfds, struct timeval*timeout);</p> 
<p>参数说明：</p> 
<p>maxfdp： 最大的文件描述符加1,如果我有三个文件节点1、4、6,那第一个参数就为7（6+1）</p> 
<p>readfds： 可读文件节点集，类型为fd_set。</p> 
<p>通过FD_ZERO(&amp;readfd);初始化节点集；</p> 
<p>然后通过FD_SET(fd, &amp;readfd);把需要监听是否可读的节点加入节点集</p> 
<p>readfds： 可写文件节点集中，类型为fd_set。操作方法和第二个参数一样。</p> 
<p>errorfds： 检查节点错误集。</p> 
<p>timeout： 超时参数，类型为struct timeval，用于设置超时时间，</p> 
<p>分别可设置秒timeout.tv_sec和微秒timeout.tv_usec。</p> 
<p>返回值：</p> 
<p>执行成功则返回文件描述符状态已经改变的个数，</p> 
<p>如果返回0，则表示在描述符在状态改变前已经超过了timeout时间。</p> 
<p>当有错误发生时，返回-1， 且错误原因保存在errno中。</p> 
<p> </p> 
<p>定时器用法:</p> 
<p>//test</p> 
<p>select tv.tv_sec = 0;</p> 
<p>tv.tv_usec = 500000;</p> 
<p>ret = select(0, NULL, NULL, NULL, &amp;tv);</p> 
<p>if (-1 == ret){<!-- --></p> 
<p>    fprintf(stderr, "select error. errno = %d [%s]\n", errno, strerror(errno));</p> 
<p>}</p> 
<p> </p> 
<h3>1.4 函数名：pselect</h3> 
<p>功能：I/O多工机制</p> 
<p>头文件：</p> 
<p>#include &lt;sys/time.h&gt;</p> 
<p>#include &lt;sys/types.h&gt;</p> 
<p>#include &lt;unistd.h&gt;</p> 
<p>#include &lt;sys/select.h&gt;</p> 
<p>语法：</p> 
<p>int pselect(int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, const struct timespec* timeout,</p> 
<p>const sigset_t *sigmask);</p> 
<p>说明：</p> 
<p>pselect()和select()作用几乎一样，都是用来等待文件描述符状态的改变，</p> 
<p>不过pselect() 还可以判断是否有信号(signal)发生。</p> 
<p> </p> 
<p>定时器用法:</p> 
<p>req.tv_sec = nDelay/1000000;</p> 
<p>req.tv_nsec = (nDelay%1000000) * 1000;</p> 
<p>ret = pselect(0, NULL, NULL, NULL, &amp;req, NULL);</p> 
<p>if (-1 == ret){<!-- --></p> 
<p>fprintf(stderr, "select error. errno = %d [%s]\n", errno, strerror(errno));</p> 
<p>}</p> 
<p> </p> 
<h3>1.5 函数名：nonasleep</h3> 
<p>功能：</p> 
<p>nanosleep()函数会导致当前的线程将暂停执行,直到rqtp参数所指定的时间间隔。</p> 
<p>或者在指定时间间隔内有信号传递到当前线程，将引起当前线程调用信号捕获函数或终止该线程。</p> 
<p> </p> 
<p>头文件：</p> 
<p>#include&lt;time.h&gt;</p> 
<p>#include&lt;sys/time.h&gt;</p> 
<p>#include&lt;unistd.h&gt;</p> 
<p>#include&lt;sys/types.h&gt;</p> 
<p>#include&lt;sys/select.h&gt;</p> 
<p> </p> 
<p>语法：</p> 
<p>　　int nanosleep(const struct timespec *rqtp, struct timespec *rmtp);</p> 
<p> </p> 
<p>描述：</p> 
<p>nanosleep()函数会导致当前的线程将暂停执行,直到rqtp参数所指定的时间间隔。</p> 
<p>或者在指定时间间隔内有信号传递到当前线程，将引起当前线程调用信号捕获函数或终止该线程。</p> 
<p>　　暂停时间可能超过请求时间,因为参数值是sleep粒度的整数倍数或者因为其他活动的系统调度。</p> 
<p>　　但是,除了被信号中断的情况下,暂停时间不会少于rqtp指定的时间,由系统时钟CLOCK_REALTIME测量。</p> 
<p>　　使用nanosleep()函数对其他行为没有影响，不堵塞任何信号。</p> 
<p> </p> 
<p>返回值：</p> 
<p>0 ：请示的时间间隔结束。</p> 
<p>-1：信号中断或失败，并设置errno。</p> 
<p>如果rmtp参数不为空，它所引用的timespec结构更新为包含剩余时间的间隔量（请求的时间减去实际睡眠时间）。</p> 
<p>如果rmtp参数为NULL，不返回的剩余时间。</p> 
<p> </p> 
<p>示例：</p> 
<p>req.tv_sec = 0;</p> 
<p>req.tv_nsec = 1000;</p> 
<p>ret = nanosleep(&amp;req, NULL);</p> 
<p>if (-1 == ret) {<!-- --></p> 
<p>fprintf (stderr, "\t nanousleep %8u not support\n", nDelay);</p> 
<p>}</p> 
<p> </p> 
<h2>二、精确度对比</h2> 
<p>如果用于一些 C/S 数据交互等 100ms级以上精度的程序挂起，用sleep, usleep都可以。</p> 
<p>如果是在多线程应用场景中，如用于音视频数据的同步，需要100ms以下的精度的程序挂起，则只能用select, 和 nanosleep.</p> 
<p> </p> 
<p>这是因为，虽然sleep()和nanosleep()都是使进程睡眠一段时间后被唤醒，但是二者的实现完全不同。</p> 
<p>Linux中并没有提供系统调用sleep()，</p> 
<p>sleep()是在库函数中实现的，它是通过调用alarm()来设定报警时间，</p> 
<p>调用sigsuspend()将进程挂起在信号SIGALARM上。</p> 
<p> </p> 
<p>nanosleep()则是Linux中的系统调用，它是使用定时器来实现的，</p> 
<p>该调用使调用进程睡眠，并往定时器队列上加入一个timer_list型定时器，time_list结构里包括唤醒时间以及唤醒后执行的函数，</p> 
<p>通过nanosleep()加入的定时器的执行函数仅仅完成唤醒当前进程的功能。</p> 
<p>系统通过一定的机制定时检查这些队列（比如通过系统调用陷入核心后，从核心返回用户态前，</p> 
<p>要检查当前进程的时间片是否已经耗尽，如果是则调用schedule()函数重新调度，该函数中就会检查定时器队列，另外慢中断返回前也会做此检查），</p> 
<p>如果定时时间已超过，则执行定时器指定的函数唤醒调用进程。</p> 
<p> </p> 
<p> </p> 
<h2>三、工程应用</h2> 
<p>这是FFmpeg的程序挂起，</p> 
<p>int av_usleep(unsigned usec)</p> 
<p>{<!-- --></p> 
<p>#if HAVE_NANOSLEEP</p> 
<p>struct timespec ts = { usec / 1000000, usec % 1000000 * 1000 };</p> 
<p>while (nanosleep(&amp;ts, &amp;ts) &lt; 0 &amp;&amp; errno == EINTR);</p> 
<p>return 0;</p> 
<p>#elif HAVE_USLEEP</p> 
<p>return usleep(usec);</p> 
<p>#elif HAVE_SLEEP</p> 
<p>Sleep(usec / 1000);</p> 
<p>return 0;</p> 
<p>#else</p> 
<p>return AVERROR(ENOSYS);</p> 
<p>#endif</p> 
<p>}</p> 
<p> </p> 
<p>附：</p> 
<p>初六   谦谦君子，用涉大川，吉。</p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aad7dd8e4ad55587fd7d3eb6fbd0fc15/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">rsyslog - filter by program name</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c749da8138ec62b7b747bec3f215cb9e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何设置npm包管理工具的下载代理？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>