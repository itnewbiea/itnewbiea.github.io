<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中Map接口的默认方法computerIfAbsent、computeIfPresent、getOrDefault、merge、putIfAbsent、replaceAll以及常用示例 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java中Map接口的默认方法computerIfAbsent、computeIfPresent、getOrDefault、merge、putIfAbsent、replaceAll以及常用示例" />
<meta property="og:description" content="场景 Java8新特性-Stream对集合进行操作的常用API：
Java8新特性-Stream对集合进行操作的常用API_霸道流氓气质的博客-CSDN博客_streamapi对集合修改
如果 Map 中包含元素，用户希望替换元素；如果 Map 中没有元素，用户希望添加元素；
此外，用户还希望执行其他相关操作。
Java 8 为 Map 接口引入了不少新方法，某些方法能为开发提供极大的便利。
注：
博客：
霸道流氓气质的博客_CSDN博客-C#,架构之路,SpringBoot领域博主
实现 1、computerIfAbsent
如果键存在，返回对应的值，否则通过提供的函数计算新的值并保存
V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt;mappingFunction)
以经典的斐波那契数递归计算为例进行讨论。
//效率极低的算法 int fib(int n){ if (n&lt;2) { return n; } else { return fib(n-1) &#43; fib(n-2); } } 代码的问题在于需要进行大量重复的计算，（如 fib(5) =fib(4) &#43; fib(3) = fib(3) &#43; fib(2) &#43; fib(2)&#43;fib(1) = ...），
导致程序效率极低。可以利用缓存解决这个问题，函数式编程将这种技术称为记忆化。
BigInteger fibCache(long i){ if(i == 0) return BigInteger." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d5c791bcef76ee9e0640cfd11d9ea635/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-06T17:47:37+08:00" />
<meta property="article:modified_time" content="2023-01-06T17:47:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中Map接口的默认方法computerIfAbsent、computeIfPresent、getOrDefault、merge、putIfAbsent、replaceAll以及常用示例</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>场景</h2> 
<p>Java8新特性-Stream对集合进行操作的常用API：</p> 
<p><a href="https://blog.csdn.net/BADAO_LIUMANG_QIZHI/article/details/126070657" title="Java8新特性-Stream对集合进行操作的常用API_霸道流氓气质的博客-CSDN博客_streamapi对集合修改">Java8新特性-Stream对集合进行操作的常用API_霸道流氓气质的博客-CSDN博客_streamapi对集合修改</a></p> 
<p>如果 Map 中包含元素，用户希望替换元素；如果 Map 中没有元素，用户希望添加元素；</p> 
<p>此外，用户还希望执行其他相关操作。</p> 
<p>Java 8 为 Map 接口引入了不少新方法，某些方法能为开发提供极大的便利。</p> 
<p>注：</p> 
<p>博客：<br><a href="https://blog.csdn.net/badao_liumang_qizhi" title="霸道流氓气质的博客_CSDN博客-C#,架构之路,SpringBoot领域博主">霸道流氓气质的博客_CSDN博客-C#,架构之路,SpringBoot领域博主</a></p> 
<h2>实现</h2> 
<p>1、computerIfAbsent</p> 
<p>如果键存在，返回对应的值，否则通过提供的函数计算新的值并保存</p> 
<p>V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt;mappingFunction)</p> 
<p>以经典的斐波那契数递归计算为例进行讨论。</p> 
<pre><code class="hljs">    //效率极低的算法
    int fib(int n){
        if (n&lt;2) {
            return n;
        } else {
            return fib(n-1) + fib(n-2);
        }
    }</code></pre> 
<p>代码的问题在于需要进行大量重复的计算，（如 fib(5) =fib(4) + fib(3) = fib(3) + fib(2) + fib(2)+fib(1) = ...），</p> 
<p>导致程序效率极低。可以利用缓存解决这个问题，函数式编程将这种技术称为记忆化。</p> 
<pre><code class="hljs">    BigInteger fibCache(long i){
        if(i == 0) return  BigInteger.ZERO;
        if(i == 1) return  BigInteger.ONE;
        return cache.computeIfAbsent(i,n -&gt;fibCache(n-2).add(fibCache(n-1)));
    }</code></pre> 
<p>computeIfAbsent 方法在缓存中搜索给定的数字，存在则返回对应的值，</p> 
<p>否则使用提供的 Function 计算新的值，将其保存在缓存中并返回。</p> 
<p>2、computeIfPresent</p> 
<p>仅当与某个值关联的键在 Map 中存在时，computeIfPresent才会更新该值</p> 
<p>V computeIfPresent(K key,    BiFunction&lt;? super K, ? super V, ? extends V&gt;remappingFunction)</p> 
<p>统计一段文本中特定单次的出现次数</p> 
<pre><code class="hljs">    public Map&lt;String,Integer&gt; countWords(String passage,String... strings){
        Map&lt;String,Integer&gt; wordCounts = new HashMap&lt;&gt;();
        //将特定单词置于映射中，并将计数器设置为 0
        Arrays.stream(strings).forEach(s-&gt;wordCounts.put(s,0));
        //读取文本，仅更新特定单词的出现次数
        Arrays.stream(passage.split(" ")).forEach(word -&gt; wordCounts.computeIfPresent(word,(key,value)-&gt;value+1));
        return wordCounts;
    }</code></pre> 
<p>方法调用</p> 
<pre><code class="hljs">        String passage = "gong zhonghao badao de cheng xv yuan, badao de cheng xv yuan, badao de cheng xv yuan";
        Map&lt;String, Integer&gt; stringIntegerMap = countWords(passage, "badao", "de");
        System.out.println(stringIntegerMap);//{badao=3, de= 3}</code></pre> 
<p>3、replace</p> 
<p>将现有键的值替换为新的值 前提是键已经存在。如果键不存在，replace 不会执行任何操作</p> 
<pre><code class="hljs">        Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();
        map.put("a",1);
        System.out.println(map);//{a=1}
        map.replace("b",2);
        System.out.println(map);//{a=1}
        map.replace("a",3);
        System.out.println(map);//{a= 3}</code></pre> 
<p>4、getOrDefault</p> 
<p>如果键在 Map 中存在，返回对应的值，否则返回默认值 但不会将这个键添加到映射中。</p> 
<pre><code class="hljs">        System.out.println(map);//{a=3}
        System.out.println(map.getOrDefault("c",0));//0
        System.out.println(map);//{a= 3}</code></pre> 
<p>5、merge</p> 
<p>如果键在 Map 中不存在，返回提供的值，否则计算新的值</p> 
<pre><code class="hljs">        System.out.println(map);//{a=3}
        //a存在，对a的值进行累加
        map.merge("a",1,(old,new_)-&gt;old+new_);
        System.out.println(map);//{a=4}
        //b不存在，返回默认值1，并put
        map.merge("b",1,(old,new_)-&gt;old+new_);
        System.out.println(map);//{a=4, b=1}
        //b已经存在，按照function 此时为乘法
        map.merge("b",2,(old,new_)-&gt;old*new_);
        System.out.println(map);//{a=4, b= 2}</code></pre> 
<p>给定一段文本，统计所有单次的出现次数</p> 
<pre><code class="hljs">    public Map&lt;String,Integer&gt; fullWordCounts(String passage){
        Map&lt;String,Integer&gt; wordCounts = new HashMap&lt;&gt;();
        //将逗号替换成空格
        String testString = passage.toLowerCase().replaceAll("\\W"," ");
        //split("\\s+")  \\s表示空格 +表示一个或多个
        Arrays.stream(testString.split("\\s+")).forEach(word -&gt;wordCounts.merge(word,1,Integer::sum));
        return wordCounts;
    }</code></pre> 
<p>首先将逗号替换成空格，然后按照一个或者多个空格进行spilit。</p> 
<p>方法调用：</p> 
<pre><code class="hljs">        String passage1 = "gong zhonghao badao de cheng xv yuan, badao de cheng xv yuan, badao de cheng xv yuan";
        Map&lt;String, Integer&gt; stringIntegerMap1 = fullWordCounts(passage1);
        System.out.println(stringIntegerMap1);//{yuan=3, de=3, badao=3, gong=1, zhonghao=1, cheng=3, xv=3}</code></pre> 
<p> 6、Compute</p> 
<p>根据现有的键和值计算新的值</p> 
<pre><code class="hljs">        System.out.println(map);//{a=4, b=2}
        map.compute("a",(key,value)-&gt;value + 2);
        System.out.println(map);//{a=6, b=2}</code></pre> 
<p>7、putIfAbsent</p> 
<p>如果键在 Map 中不存在，将其关联到给定的值</p> 
<pre><code class="hljs">        System.out.println(map);//{a=6, b=2}
        map.putIfAbsent("b",3);
        map.putIfAbsent("c",8);
        System.out.println(map);//{a=6, b=2, c=8}</code></pre> 
<p>8、replaceAll</p> 
<p>将 Map 中每个条目的值替换为对当前条目调用给定函数后的结果</p> 
<pre><code class="hljs">        System.out.println(map);//{a=6, b=2, c=8}
        map.replaceAll((key,value)-&gt; value +1);
        System.out.println(map);//{a=7, b=3, c=9}</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/734223c5e60187d21b760d1c6bc8e872/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">二叉搜索树详解--实现插入和删除</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5423fcb2dee1a3f0954969e00317c69e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">20.04安装carla0.9.13记录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>