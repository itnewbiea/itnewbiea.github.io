<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>观察者模式 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="观察者模式" />
<meta property="og:description" content="观察者模式适用于在一个一对多模型中，一者状态变化，多者需要根据变化做出相应调整的情况，下面我们通过一个简单的例子简单说明观察者模式的设计方法
注：本利旨在说明观察者模式的设计思想，例子中存在一定的内存泄露没有处理
假设我们有一台电脑主机，这台电脑主机不干别的事，只是向屏幕发送一个数字。
同时有多台显示器连接到这台主机上，并根据发送来的数字做自己的逻辑处理再显示出来
首先我们做一个只有一个显示器的情况
class Display { public: void update(int num) { m_num = num; show(); } void show() { std::cout &lt;&lt; m_num &lt;&lt; std::endl; } private: int m_num; }; class Computer { public: void setNum(int num) { m_num = num; numChange(); } int getNum() { return m_num; } void numChange() { m_display-&gt;update(m_num); } void setDisplay(Display *display) { m_display = display; } private: int m_num; Display *m_display; }; int main(int argc, char **argv) { Display *display = new Display; Computer *computer = new Computer; computer-&gt;setDisplay(display); computer-&gt;setNum(10); computer-&gt;setNum(100); return 0; } 在上面代码中，我们首先定义了一个显示器和一个主机，并为主机绑定了显示器。当主机的数字变化时，会自动调用显示器的更新方法，将新的数字显示出来。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ed69b1ebfd1c60c731c99be83683c89a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-27T20:30:48+08:00" />
<meta property="article:modified_time" content="2023-11-27T20:30:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">观察者模式</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>观察者模式适用于在一个一对多模型中，一者状态变化，多者需要根据变化做出相应调整的情况，下面我们通过一个简单的例子简单说明观察者模式的设计方法<br> 注：本利旨在说明观察者模式的设计思想，例子中存在一定的内存泄露没有处理</p> 
<p>假设我们有一台电脑主机，这台电脑主机不干别的事，只是向屏幕发送一个数字。<br> 同时有多台显示器连接到这台主机上，并根据发送来的数字做自己的逻辑处理再显示出来<br> 首先我们做一个只有一个显示器的情况</p> 
<pre><code class="prism language-c++">class Display
{
public:
	void update(int num)
	{
		m_num = num;
		show();
	}

	void show()
	{
		std::cout &lt;&lt; m_num &lt;&lt; std::endl;
	}
private:
	int m_num;
};

class Computer
{
public:
	void setNum(int num)
	{
		m_num = num;
		numChange();
	}
	int getNum()
	{
		return m_num;
	}
	
	void numChange()
	{
		m_display-&gt;update(m_num);
	}

	void setDisplay(Display *display)
	{
		m_display = display;
	}

private:
	int m_num;
	Display *m_display;
};

int main(int argc, char **argv)
{
	Display *display = new Display;

	Computer *computer = new Computer;
	computer-&gt;setDisplay(display);

	computer-&gt;setNum(10);

	computer-&gt;setNum(100);

	return 0;
}
</code></pre> 
<p>在上面代码中，我们首先定义了一个显示器和一个主机，并为主机绑定了显示器。当主机的数字变化时，会自动调用显示器的更新方法，将新的数字显示出来。</p> 
<p>现在，我们将情景变的复杂一些，如果我们需要有两台显示器，一台显示器用来显示主机发送的原始数据，另一台需要将主机发送的数据加1后再显示出来。<br> 可见，在上面的代码中，想实现这个功能非常麻烦，不但要添加一个显示器类的定义，还要修改主机类的定义，而且每次需要添加或删除显示器，都要修改主机类。而观察者模式就是解决类似情况的，我们只需要添加一个显示器类就可以了，而不需要修改主机类，下面是代码</p> 
<pre><code class="prism language-c++">class Observer
{
public:
	virtual void update(int num)
	{
		m_num = num;
		show();
	}
	virtual void show() = 0;

protected:
	int m_num;
};

class Subject
{
public:
	virtual void registerObserver(Observer *observer) = 0;
	virtual void removeObserver(Observer *observer) = 0;
	virtual void notifyObserver() = 0;
};

class Display1 : public Observer
{
public:
	void show() override
	{
		std::cout &lt;&lt; m_num &lt;&lt; std::endl;
	}
};

class Display2 : public Observer
{
public:
	void show() override
	{
		std::cout &lt;&lt; m_num + 1 &lt;&lt; std::endl;
	}
};

class Computer : public Subject
{
public:
	void setNum(int num)
	{
		m_num = num;
		numChange();
	}
	int getNum()
	{
		return m_num;
	}
	
	void numChange()
	{
		notifyObserver();
	}

	void registerObserver(Observer *observer) override {
		m_observerList.push_back(observer);
	}

	void removeObserver(Observer *observer) override {
		for (std::vector&lt;Observer*&gt;::iterator iter = m_observerList.begin(); iter != m_observerList.end();)
		{
			if (*iter == observer)
				iter = m_observerList.erase(iter);
			else
				iter++;
		}
	}

	void notifyObserver() override {
		for (int i = 0; i &lt; m_observerList.size(); i++) {
			m_observerList.at(i)-&gt;update(m_num);
		}
	}

private:
	int m_num;
	std::vector&lt;Observer*&gt; m_observerList;
};

int main(int argc, char **argv)
{
	Display1 *display1 = new Display1();
	Display2 *display2 = new Display2();

	Computer *computer = new Computer();


	computer-&gt;registerObserver(display1);
	computer-&gt;registerObserver(display2);
	computer-&gt;setNum(10);
	std::cout &lt;&lt; "========================================\n";
	computer-&gt;removeObserver(display1);
	computer-&gt;setNum(100);

	return 0;
}
</code></pre> 
<p>这里，我们添加了两个虚基类<br> Subject：就是“被观察”的角色，它将所有观察者对象的引用保存在一个集合中。<br> Observer：是抽象的“观察”角色，它定义了一个更新接口，使得在被观察者状态发生改变时通知自己。<br> 在本例中，我们创建了一个被观察者主机，和两个观察者显示器1和2，对象创建完成后，将显示器1和2添加到被观察者主机的观察者集合中<br> 每当被观察者的数据变化时，就向观察者集合中的所有观察者发送数据变化事件，观察者接收到被观察者发送的变化事件并接收到变化后的数据后，根据自己的逻辑进行显示，本例中1是原样显示，2是加1后显示<br> 被观察者还可以将某个观察者从自己的观察者集合中删除，这样数据变化时就不会向已删除的观察者发送变化事件了。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/edb7421722a217c2ac1d9dfb23aaa648/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Selenium 连接到现有的 Firefox 示例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f5c8e8ca138bbb0ea08e28f284678b81/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】堆（C语言）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>