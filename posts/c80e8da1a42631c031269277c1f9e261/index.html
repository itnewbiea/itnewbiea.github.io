<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue中ref()和 reactive() 的区别 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue中ref()和 reactive() 的区别" />
<meta property="og:description" content="前言 你一定知道Vue中的响应式编程，它提供了在数据变化时自动更新UI的能力，摒弃了传统的数据更新时手动更新UI的方式。在Vue 3.0之前，我们定义在data函数中的数据会被自动转换为响应式。而在 Composition API 中，还有两种方式让我们定义响应式对象：ref() 和reactive()。 但是，他们有什么不同之处呢？
ref和reactive的区别 对比之前先看一下如何使用，它们的使用方法都很简单，也很类似：
&lt;template&gt; &lt;div&gt;{{user.first_name}} {{user.last_name}}&lt;/div&gt; &lt;div&gt;{{ age }}&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { reactive } from &#39;vue&#39; export default { setup() { const age = ref(18) const user = reactive({ first_name: &#34;Karl&#34;, last_name: &#34;Max&#34;, }) return { user , age} } } &lt;/script&gt; 复制代码 接下来我们就来分析一下它们的不同点：
可接受的原始数据类型不同
ref() 和reactive()都是接收一个普通的原始数据，再将其转换为响应式对象，例如上面代码中的user和age。却别在于：ref可以同时处理基本数据类型和对象，而reactive只能处理处理对象而支持基本数据类型。
const numberRef = ref(0); // OK const objectRef = ref({ count: 0 }) // OK //TS2345: Argument of type &#39;number&#39; is not assignable to parameter of type &#39;object&#39;." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c80e8da1a42631c031269277c1f9e261/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-17T09:51:18+08:00" />
<meta property="article:modified_time" content="2023-03-17T09:51:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue中ref()和 reactive() 的区别</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>前言</h4> 
<p>你一定知道Vue中的响应式编程，它提供了在数据变化时自动更新UI的能力，摒弃了传统的数据更新时手动更新UI的方式。在Vue 3.0之前，我们定义在data函数中的数据会被自动转换为响应式。而在 Composition API 中，还有两种方式让我们定义响应式对象：<code>ref() </code>和<code>reactive()</code>。 但是，他们有什么不同之处呢？</p> 
<h4>ref和reactive的区别</h4> 
<p>对比之前先看一下如何使用，它们的使用方法都很简单，也很类似：</p> 
<pre><code>&lt;template&gt;
  &lt;div&gt;{<!-- -->{user.first_name}} {<!-- -->{user.last_name}}&lt;/div&gt;
  &lt;div&gt;{<!-- -->{ age }}&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import { reactive } from 'vue'
export default {
  setup() {
    const age = ref(18)
    const user = reactive({
      first_name: "Karl",
      last_name: "Max",
    })
    return { user , age}
  }
}
&lt;/script&gt;
复制代码</code></pre> 
<p>接下来我们就来分析一下它们的不同点：</p> 
<p>可接受的原始数据类型不同</p> 
<p><code>ref() </code>和<code>reactive()</code>都是接收一个普通的原始数据，再将其转换为响应式对象，例如上面代码中的<code>user</code>和<code>age</code>。却别在于：<em><strong><code>ref</code>可以同时处理基本数据类型和对象，而<code>reactive</code>只能处理处理对象而支持基本数据类型。</strong></em></p> 
<pre><code>const numberRef = ref(0);           // OK
const objectRef = ref({ count: 0 }) // OK

//TS2345: Argument of type 'number' is not assignable to parameter of type 'object'.
const numberReactive = reactive(0);
const objectReactive = reactive({ count: 0}); // OK
复制代码</code></pre> 
<p>这是因为二者响应式数据实现的方式不同：</p> 
<ul><li><code>ref</code>是通过一个中间对象<code>RefImpl</code>持有数据，并通过重写它的set和get方法实现数据劫持的，本质上依旧是通过<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FObject%2FdefineProperty" rel="nofollow" title="Object.defineProperty ">Object.defineProperty </a>对<code>RefImpl</code>的<code>value</code>属性进行劫持。</li><li><code>reactive</code>则是通过<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FProxy" rel="nofollow" title="Proxy">Proxy</a>进行劫持的。Proxy无法对基本数据类型进行操作，进而导致<code>reactive</code>在面对基本数据类型时的束手无策。</li></ul> 
<p>ref对应的源码如下：</p> 
<pre><code>export function ref&lt;T&gt;(value: T): Ref&lt;UnwrapRef&lt;T&gt;&gt;
export function ref&lt;T = any&gt;(): Ref&lt;T | undefined&gt;
export function ref(value?: unknown) {
  return createRef(value, false)
}

function createRef(rawValue: unknown, shallow: boolean) {
  if (isRef(rawValue)) {
    return rawValue
  }
  return new RefImpl(rawValue, shallow)
}

class RefImpl&lt;T&gt; {
  private _value: T
  private _rawValue: T


  constructor(value: T, public readonly __v_isShallow: boolean) {
    this._rawValue = __v_isShallow ? value : toRaw(value)
    this._value = __v_isShallow ? value : toReactive(value)
  }

 /**
   * 重写get和set方法，
   * 本质上是通过Object.defineProperty 
   * 对属性value进行劫持*/
  get value() {
    //收集依赖
    track()
    return this._value
  }

  set value(newVal) {
    if (hasChanged(newVal, this._rawValue)) {
      this._value = newVal
      //触发依赖
      trigger()
    }
  }
}
复制代码</code></pre> 
<p>删减整合后的reactive代码如下：</p> 
<pre><code>export function reactive(target: object) {
  return createReactiveObject(
    target,
    false
  )
}

function createReactiveObject(
  target: Target,
  isReadonly: boolean
) {
  const proxy = new Proxy(
    target,
    {
      get(target, key) {
	  //收集依赖
        track()
        return target[propKey]
      },
      set(target, key,value) {
        target[propKey] = value
        //触发依赖
        trigger()
      }
    }
  )
  return proxy
}
复制代码</code></pre> 
<p>Object.defineProperty、Proxy和数据劫持的相关内容详情可见：<a href="https://juejin.cn/post/7208082990810153021#heading-6" rel="nofollow" title="Vue3数据劫持优化">Vue3数据劫持优化</a>。</p> 
<p>总结：<strong>ref可以存储基本数据类型而reactive则不能</strong></p> 
<p>返回值类型不同</p> 
<p>运行如下代码：</p> 
<pre><code>const count1 = ref(0)
const count2 = reactive({count:0})
console.log(count1)
console.log(count2)
复制代码</code></pre> 
<p>输出结果为：</p> 
<pre><code>RefImpl {__v_isShallow: false, dep: undefined, __v_isRef: true, _rawValue: 0, _value: 0}
Proxy(Object) {count: 0}
复制代码</code></pre> 
<p><code>ref()</code>返回的是一个持有原始数据的<code>RefImpl</code>实例。而<code>reactive()</code>返回的类型则是原始数据的代理<code>Proxy</code>实例</p> 
<p>因此，在定义数据类型时，有些许差别：</p> 
<pre><code>interface Count {
  num:number
}
const countRef:Ref&lt;number&gt; = ref(0)
const countReactive: Count = reactive({num:1})
复制代码</code></pre> 
<p>另外如果<code>reactive</code>中有响应式对象，它会被自动展开，所以下面代码是正确的：</p> 
<pre><code>const countReactiveRef: Count = reactive({num:ref(2)})
复制代码</code></pre> 
<p>结论：<strong><code>ref(value: T)</code>返回的Ref 类型，而<code>reactive(object: T)</code>返回的T 类型的代理</strong></p> 
<p>访问数据的方式不同</p> 
<p>返回值的类型不同，就会导致数据的访问方式不同。通过上文的可知：</p> 
<ul><li><code>ref()</code>返回的是<code>RefImpl</code>的一个实例对象，该对象通过_value私有变量持有原始数据，并重写了<code>value</code>的get方法。因此，当想要访问原始对象的时候，需要通过<code>xxx.value</code>的方式触发get函数获取数据。同样的，在修改数据时，也要通过<code>xxx.value = yyy</code>的方式触发set函数。</li><li><code>reactive() </code>返回的是原始对象的代理，代理对象具有和原始对象相同的属性，因此我们可以直接通过<code>.xxx</code>的方式访问数据</li></ul> 
<p>反应在代码中如下：</p> 
<pre><code>const objectRef = ref({ count: 0 });
const refCount = objectRef.value.count;

const objectReactive = reactive({ count: 0}); 
const reactiveCount = objectReactive.count;
复制代码</code></pre> 
<p>总结：<strong>ref需要通过<code>value</code>属性间接的访问数据（在templates中vue做了自动展开，可以省略.value），而<code>reactive</code>可以直接访问。</strong></p> 
<p>原始对象的可变性不同</p> 
<p><code>ref</code>通过一个<code>RefImpl</code>实例持有原始数据，进而使用<code>.value</code>属性访问和更新。而对于一个实例而言，其属性值是可以修改的。因此可以通过<code>.value</code>的方式为ref重新分配数据，无需担心<code>RefImpl</code>实例被改变进而破坏响应式：</p> 
<pre><code>const count = ref({count:1})
console.log(count.value.count)
//修改原始值
count.value = {count:3}
console.log(count.value.count)
//修改原始值
count.value = {name:"Karl"}
console.log(count.value.count)
console.log(count.value.name)

//输出如下：
//1
//3
//undefined
//karl
复制代码</code></pre> 
<p>而 <code>reactive</code>返回的是原始对象的代理，因此不能对其重新分配对象，只能通过属性访问修改属性值，否则会破坏掉响应式：</p> 
<pre><code>let objectReactive = reactive({ count: 0})
effect(() =&gt; {
  console.log(`数据变化了：${objectReactive.count}`)
})
//可以正常修改值
objectReactive.count = 1
objectReactive.count = 2
//修改objectReactive之后effect不再会接收到数据变化的通知
objectReactive = {count:3}
objectReactive.count = 4
console.log("结束了")
//输出如下：
//数据变化了：0
//数据变化了：1
//数据变化了：2
//结束了
复制代码</code></pre> 
<p>原因很简单：<code>effect</code>函数监听的是原始值<code>{ count: 0}</code>的代理<code>objectReactive</code>，此时当通过该代理修改数据时，可以触发回调。但是当程序运行到<code>objectReactive = {count:3}</code>之后，<code>objectReactive </code>的指向不再是<code>{ count: 0}</code>的代理了，而是指向了新的对象<code>{count:3}</code>。这时<code>objectReactive.count = 4</code>修改的不再是<code>effect </code>所监听的代理对象，而是新的普通的不具备响应式能力的对象<code>{count:3}</code>。<code>effect</code>就无法监听到数据的变化了，<code>objectReactive</code>响应式能力也因此而被破坏了。</p> 
<p>如果你直接修改ref的指向，ref的响应式也会失效：</p> 
<pre><code>let count = ref(0)
effect(() =&gt; {
  console.log(`数据变化了：${count.value}`)
})
count.value = 1
count = ref(0)
//effect不会监听到此处的变化
count.value = 2
console.log("结束了")
复制代码</code></pre> 
<p>结论：<strong>可以给ref的值重新分配给一个新对象，而reactive只能修改当前代理的属性</strong></p> 
<p>ref借助reactive实现对Object类型数据的深度监听</p> 
<p>结合上文的<code>RefImpl</code>的源码：</p> 
<pre><code>constructor(value: T, public readonly __v_isShallow: boolean) {
    this._rawValue = __v_isShallow ? value : toRaw(value)
    this._value = __v_isShallow ? value : toReactive(value)
}

export const toReactive = &lt;T extends unknown&gt;(value: T): T =&gt;
  isObject(value) ? reactive(value) : value
复制代码</code></pre> 
<p><code>ref</code>在发现被监听的原始对象是Object类形时，会将原始对象转换成<code>reactive</code>并赋值给<code>_value</code>属性。而此时<code>ref.value</code>返回的并不是原始对象，而是它的代理。</p> 
<p>通过如下代码验证：</p> 
<pre><code>const refCount = ref({count:0})
console.log(refCount.value)
//输出结果：
//Proxy(Object) {count: 0}
复制代码</code></pre> 
<p>结论：``ref()<code>在原始数据位Object类形时，会通过</code>reactive<code>包装原始数据后再赋值给_value。</code></p> 
<p>对侦听属性的影响不同</p> 
<p>执行如下代码：</p> 
<pre><code>let refCount = ref({count:0})
watch(refCount,() =&gt; {
     console.log(`refCount数据变化了`)
})
refCount.value = {count:1}
//输出结果：
//refCount数据变化了
复制代码</code></pre> 
<p><code>watch()</code>可以检测到<code>ref.value</code>的变化。然而，继续执行如下代码</p> 
<pre><code>let refCount = ref({count:0})
watch(refCount,() =&gt; {
    console.log(`refCount数据变化了`)
})
refCount.value.count = 1

let reactiveCount = reactive({count:0})
watch(reactiveCount,() =&gt; {
    console.log(`reactiveCount数据变化了`)
})
reactiveCount.count = 1
//输出结果
//reactiveCount数据变化了
复制代码</code></pre> 
<p>这次<code>watch()</code>没有监听到<code>refCount</code>的数据变化——<code>watch()</code>默认情况下不会深入观察 ref。若要<code>watch</code>深入观察ref，则需要修改参数如下：</p> 
<pre><code>watch(refCount, () =&gt; { 
  console.log('reactiveCount数据变化了!')
}, { deep: true })
复制代码</code></pre> 
<p>而对于<code>reactive</code>而言，无论你是否声明<code>deep: true</code>，<code>watch</code>都会深入观察。</p> 
<p>结论：<strong><code>watch()</code>默认情况下只监听<code>ref.value</code>的更改，而对<code>reactive</code>执行深度监听。</strong></p> 
<h4>总结和用法</h4> 
<ol><li><code>ref</code>可以存储原始类型，而<code>reactive</code>不能。</li><li><code>ref</code>需要通过<code>&lt;ref&gt;.value</code>访问数据，而<code>reactive()</code>可以直接用作常规对象。</li><li>可以重新分配一个全新的对象给<code>ref</code>的<code>value</code>属性，而<code>reactive()</code>不能。</li><li><code>ref</code>类型为<code>Ref&lt;T&gt;</code>，而<code>reactive</code>返回的反应类型为原始类型本身。</li><li><code>watch</code>默认只观察<code>ref</code>的<code>value</code>，而对<code>reactive</code>则执行深度监听。</li><li><code>ref</code>默认会用<code>reactive </code>对象类型的原始值进行深层响应转换。</li></ol> 
<p>使用习惯：虽然没有规则规定要在何时使用<code>ref</code>或者<code>reactive</code>，亦或是混合使用。这些完全取决于开发者的编程习惯。但是为了保持代码的一致性和可读性，我倾向于使用<code>ref</code>而非<code>reactive</code>。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e7d35a17e12165daa7e52af47463d7e1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">针对 性解决npm ERR! cb() never called! 问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6857aff341fb5d7fcecfe2f161e5eba3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">playwright--iframe操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>