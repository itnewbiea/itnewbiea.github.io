<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>如何使用java语言下载https的网络文件 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="如何使用java语言下载https的网络文件" />
<meta property="og:description" content="import java.io.BufferedInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.net.URL; import javax.net.ssl.HttpsURLConnection; public class HttpsDownloader { public static void main(String[] args) { String fileURL = &#34;https://example.com/file.txt&#34;; // 要下载的文件URL String savePath = &#34;downloaded_file.txt&#34;; // 下载后保存的文件路径 try { URL url = new URL(fileURL); HttpsURLConnection connection = (HttpsURLConnection) url.openConnection(); connection.connect(); int responseCode = connection.getResponseCode(); if (responseCode == HttpsURLConnection.HTTP_OK) { InputStream inputStream = new BufferedInputStream(connection.getInputStream()); FileOutputStream outputStream = new FileOutputStream(savePath); byte[] buffer = new byte[1024]; int bytesRead; while ((bytesRead = inputStream." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c4e306dd39778dc898ebf18ef768fe4e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-15T17:25:27+08:00" />
<meta property="article:modified_time" content="2023-11-15T17:25:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何使用java语言下载https的网络文件</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="80" src="https://images2.imgbox.com/36/f9/ANqFIbzP_o.png" width="1138"></p> 
<pre><code class="language-java">import java.io.BufferedInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import javax.net.ssl.HttpsURLConnection;

public class HttpsDownloader {
    public static void main(String[] args) {
        String fileURL = "https://example.com/file.txt"; // 要下载的文件URL
        String savePath = "downloaded_file.txt"; // 下载后保存的文件路径

        try {
            URL url = new URL(fileURL);
            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
            connection.connect();

            int responseCode = connection.getResponseCode();
            if (responseCode == HttpsURLConnection.HTTP_OK) {
                InputStream inputStream = new BufferedInputStream(connection.getInputStream());
                FileOutputStream outputStream = new FileOutputStream(savePath);

                byte[] buffer = new byte[1024];
                int bytesRead;
                while ((bytesRead = inputStream.read(buffer)) != -1) {
                    outputStream.write(buffer, 0, bytesRead);
                }

                outputStream.close();
                inputStream.close();
                System.out.println("文件下载完成！");
            } else {
                System.out.println("无法连接到文件URL。响应代码：" + responseCode);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre> 
<p>上述代码首先创建一个URL对象，然后使用<code>openConnection()</code>方法获取到<code>HttpsURLConnection</code>对象。接下来，通过调用<code>connect()</code>方法建立与服务器的连接。</p> 
<p>如果连接成功（HTTP响应码为200），则可以从输入流中读取数据，并将其写入指定的文件输出流中。最后，关闭输入流和输出流，并打印出下载完成的消息。</p> 
<p>请将<code>fileURL</code>替换为您要下载的文件的真实URL，将<code>savePath</code>替换为下载文件的保存路径。运行代码后，您将在指定位置找到下载的文件。</p> 
<p><span style="color:#fe2c24;"><strong>上面代码报错，javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</strong></span></p> 
<p>这个错误通常发生在尝试通过HTTPS下载文件时，因为服务器的证书无法验证或未被信任。解决方法是将服务器的证书添加到Java的信任存储库中。以下是一种简单的方法：</p> 
<ol><li> <p>首先，从浏览器中导出服务器的证书（例如Chrome浏览器）：</p> 
  <ul><li>在浏览器中打开目标URL。</li><li>单击地址栏旁边的锁图标，并选择"证书"或"证书详细信息"。</li><li>在证书详细信息窗口中，导航到"详细信息"选项卡。</li><li>单击"复制到文件"按钮，并按照指示保存证书，选择DER格式。</li></ul></li><li> <p>使用<code>keytool</code>工具将证书添加到Java的信任存储库：</p> 
  <ul><li> <p>打开命令提示符或终端。</p> </li><li> <p>导航到Java的安装目录的<code>bin</code>目录下（例如：<code>C:\Program Files\Java\jdk1.8.0_271\bin</code>）。</p> </li><li> <p>运行以下命令，将证书添加到信任存储库中（替换<code>path/to/certificate.der</code>为导出的证书路径和名称）：</p> </li></ul></li></ol> 
<blockquote> 
 <p>keytool -importcert -alias mycert -keystore cacerts -file path/to/certificate.der</p> 
</blockquote> 
<p>您将被要求输入Java信任存储库的密码，默认情况下是<code>changeit</code>。</p> 
<p>3.运行代码时，Java将能够验证服务器的证书并建立安全的HTTPS连接。</p> 
<p>如果您仍然遇到问题，请确保您的Java运行时环境是最新版本，并尝试使用更可靠的证书进行测试。</p> 
<p><span style="color:#fe2c24;"><strong>如果不添加证书，如何绕过证书？</strong></span></p> 
<p><img alt="" height="77" src="https://images2.imgbox.com/78/a6/bNjzbnSG_o.png" width="964"></p> 
<pre><code class="language-java">import java.io.BufferedInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

public class HttpsDownloader {
    public static void main(String[] args) {
        String fileURL = "https://example.com/file.txt"; // 要下载的文件URL
        String savePath = "downloaded_file.txt"; // 下载后保存的文件路径

        try {
            // 创建信任所有证书的 TrustManager
            TrustManager[] trustAllCerts = new TrustManager[]{
                    new X509TrustManager() {
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return null;
                        }

                        public void checkClientTrusted(X509Certificate[] certs, String authType) {
                        }

                        public void checkServerTrusted(X509Certificate[] certs, String authType) {
                        }
                    }
            };

            // 设置 SSL 上下文
            SSLContext sslContext = SSLContext.getInstance("TLS");
            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());

            URL url = new URL(fileURL);
            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
            connection.connect();

            int responseCode = connection.getResponseCode();
            if (responseCode == HttpsURLConnection.HTTP_OK) {
                InputStream inputStream = new BufferedInputStream(connection.getInputStream());
                FileOutputStream outputStream = new FileOutputStream(savePath);

                byte[] buffer = new byte[1024];
                int bytesRead;
                while ((bytesRead = inputStream.read(buffer)) != -1) {
                    outputStream.write(buffer, 0, bytesRead);
                }

                outputStream.close();
                inputStream.close();
                System.out.println("文件下载完成！");
            } else {
                System.out.println("无法连接到文件URL。响应代码：" + responseCode);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre> 
<p>这段代码创建了一个自定义的<code>TrustManager</code>，其中实现了<code>checkClientTrusted()</code>和<code>checkServerTrusted()</code>方法，并且不会抛出异常或进行任何验证。然后，通过调用<code>SSLContext.getInstance("TLS")</code>得到一个<code>SSLContext</code>实例，并使用自定义的<code>TrustManager</code>初始化它。最后，调用<code>HttpsURLConnection.setDefaultSSLSocketFactory()</code>将自定义的SSL上下文设置为默认的SSLSocketFactory。</p> 
<p>请注意，这种绕过证书验证的方法会降低安全性，因为它允许信任所有证书，包括不受信任或伪造的证书。仅在测试环境中使用此方法，并确保在生产环境中使用有效且受信任的证书来确保安全性。</p> 
<p><span style="color:#fe2c24;"><strong>上面的代码提示：javax.net.ssl.SSLHandshakeException: java.security.cert.CertificateException: No subject alternative names present</strong></span></p> 
<p>如果您在绕过证书验证时遇到<code>javax.net.ssl.SSLHandshakeException: java.security.cert.CertificateException: No subject alternative names present</code>错误，这表示服务器的证书中缺少主体备用名称（Subject Alternative Names）。</p> 
<p>为了解决这个问题，您可以使用一个自定义的HostnameVerifier来跳过主体备用名称的验证。以下是修改后的示例代码：</p> 
<pre><code class="language-java">import java.io.BufferedInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSession;

public class HttpsDownloader {
    public static void main(String[] args) {
        String fileURL = "https://example.com/file.txt"; // 要下载的文件URL
        String savePath = "downloaded_file.txt"; // 下载后保存的文件路径

        try {
            // 创建信任所有证书的 TrustManager
            TrustManager[] trustAllCerts = new TrustManager[]{
                    new X509TrustManager() {
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return null;
                        }

                        public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {
                        }

                        public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {
                        }
                    }
            };

            // 设置 SSL 上下文
            SSLContext sslContext = SSLContext.getInstance("TLS");
            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());

            // 创建自定义 HostnameVerifier
            HostnameVerifier allHostsValid = new HostnameVerifier() {
                public boolean verify(String hostname, SSLSession session) {
                    return true;
                }
            };
            HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);

            URL url = new URL(fileURL);
            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
            connection.connect();

            int responseCode = connection.getResponseCode();
            if (responseCode == HttpsURLConnection.HTTP_OK) {
                InputStream inputStream = new BufferedInputStream(connection.getInputStream());
                FileOutputStream outputStream = new FileOutputStream(savePath);

                byte[] buffer = new byte[1024];
                int bytesRead;
                while ((bytesRead = inputStream.read(buffer)) != -1) {
                    outputStream.write(buffer, 0, bytesRead);
                }

                outputStream.close();
                inputStream.close();
                System.out.println("文件下载完成！");
            } else {
                System.out.println("无法连接到文件URL。响应代码：" + responseCode);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre> 
<p>以上代码除了添加自定义的<code>HostnameVerifier</code>外，其他部分与之前的代码相同。使用这个自定义的<code>HostnameVerifier</code>，将绕过对主体备用名称的验证，并允许连接到没有主体备用名称的服务器。</p> 
<p>请注意，绕过主体备用名称的验证也会降低安全性，因为它可能容易受到中间人攻击。仅在测试环境中使用此方法，并在生产环境中使用正确配置的证书和合适的验证机制以确保安全性。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aea0af22fc2408fe9318366cbf6186f5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python_pycharm安装与jihuo</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b1ea78c312ef7c5c652f6353fb6894e3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Wireshark抓包工具配置以及MQTT抓包分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>