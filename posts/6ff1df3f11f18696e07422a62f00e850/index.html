<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据类型及深拷贝、浅拷贝 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据类型及深拷贝、浅拷贝" />
<meta property="og:description" content="数据与变量 数据类型 类型分类 简单数据类型（基本类型）
1）布尔值Boolean: true / false
2）数值型Number: 所有数字
3）字符串String: 带引号
4）Undefined
5）Null
复杂数据类型（引用类型）
对象 Object
数组 Array
函数 Function
数据类型检测 typeOf 返回相关数据类型的字符串
可以检测 Boolean Number String Undefined Function
不能检测 Null ,返回Object
instanceOf 返回布尔值
用来检测Object的具体类型
全等号=== 要检测的数据必须具有唯一性
可以检测 undefined 和 null
Object.prototype.toString.call(数据） 可以检测所有的数据类型
深拷贝与浅拷贝 深拷贝
简单数据类型存在栈中，将一个存着简单数据类型的变量赋值给另一个变量时，会复制一份值，且在内存中重新开辟一个空间，将值保存；两者相互独立，修改一个，另外一个不会跟着变；
浅拷贝
复杂数据类型的变量名存在栈中，值存在堆中，栈中的变量名通过引用地址指堆中的值；将一个存着复杂数据类型的变量赋值给另一个变量时，会赋值一份引用地址，新的变量就会指向变量，修改一个变量，就修改了堆中的值，由于都是同一个地址，指向同一个值，所以另一个也会随之变化；
复杂数据的深拷贝与浅拷贝对比 （1）浅拷贝：浅拷贝一个变化另外一个也会随着变化， 将原对象或原数组的引用直接赋给新对象，新数组，新对象／数组只是原对象的一个引用，
（2）深拷贝：相互独立，深拷贝一个变化另外一个不会变； 创建一个新的对象或数组，将原对象的各项属性和属性值（数组的所有元素）拷贝过来，是“值”而不是“引用”
深拷贝的实现 1 JSON序列化与反序列化
JSON.parse(JSON.string(变量))，
这也是我用得最多的
JSON.stringfy 将数据转化为简单数据类型—JSON字符串，然后通过 JSON.parse() 将它转化为普通的对象或数组
2 jQuery的extend
$.extend( [deep ], target, object )" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6ff1df3f11f18696e07422a62f00e850/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-10T21:32:56+08:00" />
<meta property="article:modified_time" content="2021-06-10T21:32:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据类型及深拷贝、浅拷贝</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>数据与变量</h2> 
<h3><a id="_2"></a>数据类型</h3> 
<h5><a id="_4"></a>类型分类</h5> 
<p><strong>简单数据类型（基本类型）</strong></p> 
<p>1）布尔值Boolean: true / false</p> 
<p>2）数值型Number: 所有数字</p> 
<p>3）字符串String: 带引号</p> 
<p>4）Undefined</p> 
<p>5）Null</p> 
<p><strong>复杂数据类型（引用类型）</strong></p> 
<p>对象 Object</p> 
<p>数组 Array</p> 
<p>函数 Function</p> 
<h5><a id="_26"></a>数据类型检测</h5> 
<h5><a id="typeOf_28"></a>typeOf</h5> 
<p>返回相关数据类型的字符串</p> 
<p>可以检测 Boolean Number String Undefined Function</p> 
<p>不能检测 Null ,返回Object</p> 
<h5><a id="instanceOf_36"></a>instanceOf</h5> 
<p>返回布尔值</p> 
<p>用来检测Object的具体类型</p> 
<h5><a id="_42"></a>全等号===</h5> 
<p>要检测的数据必须具有唯一性</p> 
<p>可以检测 undefined 和 null</p> 
<h5><a id="ObjectprototypetoStringcall_48"></a>Object.prototype.toString.call(数据）</h5> 
<p>可以检测所有的数据类型</p> 
<h5><a id="_52"></a>深拷贝与浅拷贝</h5> 
<p><strong>深拷贝</strong></p> 
<p>简单数据类型存在栈中，将一个存着简单数据类型的变量赋值给另一个变量时，会复制一份值，且在内存中重新开辟一个空间，将值保存；两者相互独立，修改一个，另外一个不会跟着变；</p> 
<p><strong>浅拷贝</strong></p> 
<p>复杂数据类型的变量名存在栈中，值存在堆中，栈中的变量名通过引用地址指堆中的值；将一个存着复杂数据类型的变量赋值给另一个变量时，会赋值一份引用地址，新的变量就会指向变量，修改一个变量，就修改了堆中的值，由于都是同一个地址，指向同一个值，所以另一个也会随之变化；</p> 
<h5><a id="_62"></a>复杂数据的深拷贝与浅拷贝对比</h5> 
<p>（1）浅拷贝：浅拷贝一个变化另外一个也会随着变化， 将原对象或原数组的引用直接赋给新对象，新数组，新对象／数组只是原对象的一个引用，</p> 
<p>（2）深拷贝：相互独立，深拷贝一个变化另外一个不会变； 创建一个新的对象或数组，将原对象的各项属性和属性值（数组的所有元素）拷贝过来，是“值”而不是“引用”</p> 
<h5><a id="_68"></a>深拷贝的实现</h5> 
<p><strong>1 JSON序列化与反序列化</strong></p> 
<p>JSON.parse(JSON.string(变量))，</p> 
<p>这也是我用得最多的</p> 
<p>JSON.stringfy 将数据转化为简单数据类型—JSON字符串，然后通过 JSON.parse() 将它转化为普通的对象或数组</p> 
<p><strong>2 jQuery的extend</strong></p> 
<p>$.extend( [deep ], target, object )</p> 
<p>deep: true / false，true为深拷贝，false为浅拷贝</p> 
<p>target: 目标对象，需要被赋值的对象</p> 
<p>object: 拷贝的数据源</p> 
<p>这两种可以将所有复杂数据类型进行深拷贝，使用方便，尤其是 JSON</p> 
<p><em><strong>数组的深拷贝</strong></em>：</p> 
<p>1拼接一个空数组</p> 
<p>Array.concat()</p> 
<p>2 从开始截取到最后</p> 
<p>Array.slice()</p> 
<p>3 展开运算符</p> 
<p>let […newArray] = oldArray</p> 
<p>缺点：只能拷贝一级数据</p> 
<h5><a id="_106"></a>经验总结</h5> 
<p>我们经常会使用到push修改数组，经常我们会遇到重新渲染页面，初始化的情况，这个时候就要考虑到数组的置空或初始化处理；不然很容易出现问题<br> 将一个变量赋值给另一个变量是，一定要考虑到数据类型，如果是复杂数据类型，要不要深拷贝，大部分时候都需要进行深拷贝处理，不然也容易出bug</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5667791b477ff521d035ea4c35e95e00/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;对象指针-指向对象的指针</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0c270a4d63e059841819f0e8d0874ebb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Markdown快速学习、入门</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>