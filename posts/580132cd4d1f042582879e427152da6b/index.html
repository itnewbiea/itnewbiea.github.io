<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker nginx容器代理播放m3u8视频文件（HLS） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker nginx容器代理播放m3u8视频文件（HLS）" />
<meta property="og:description" content="文章目录 Docker Nginx容器代理播放M3U8文件教程获取Nginx Docker镜像设置Nginx配置文件用 ffmpeg 将 MP4 文件转换成 m3u8 文件运行Docker容器测试M3U8流其他问题我用vlc都能播放http://192.168.121.50/forest4kTest.m3u8和http://192.168.121.50/forest4kTest.mp4，那还要m3u8做什么，直接播放视频文件不就行了吗？ Docker Nginx容器代理播放M3U8文件教程 本教程将介绍如何在Docker中使用Nginx作为反向代理，以播放M3U8文件。我们会通过步骤详细解释每个过程，并提供命令和代码示例。
获取Nginx Docker镜像 我们用dockerfile构建镜像：
（Dockerfile）
FROM nginx:1.18 然后用脚本构建镜像：
（build_docker_image.sh）
#!/bin/bash # 打印所有，包括注释 # set -v # 打印执行命令 # set -x # 命令出错退出 set -e # 使用未初始化变量退出 set -u # 设置变量 IMAGE_NAME=&#34;kyai_nginx_x86&#34; IMAGE_TAG=&#34;v1.18_20230724&#34; # 检查依赖 if ! [ -x &#34;$(command -v docker)&#34; ]; then echo &#39;Error: Docker is not installed.&#39; &gt;&amp;2 exit 1 fi # 构建 Docker 镜像 docker build -t &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/580132cd4d1f042582879e427152da6b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-06T18:14:05+08:00" />
<meta property="article:modified_time" content="2024-01-06T18:14:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker nginx容器代理播放m3u8视频文件（HLS）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Docker_NginxM3U8_1" rel="nofollow">Docker Nginx容器代理播放M3U8文件教程</a></li><li><ul><li><a href="#Nginx_Docker_6" rel="nofollow">获取Nginx Docker镜像</a></li><li><a href="#Nginx_84" rel="nofollow">设置Nginx配置文件</a></li><li><a href="#_ffmpeg__MP4__m3u8__143" rel="nofollow">用 ffmpeg 将 MP4 文件转换成 m3u8 文件</a></li><li><a href="#Docker_206" rel="nofollow">运行Docker容器</a></li><li><a href="#M3U8_387" rel="nofollow">测试M3U8流</a></li><li><a href="#_399" rel="nofollow">其他问题</a></li><li><ul><li><a href="#vlchttp19216812150forest4kTestm3u8http19216812150forest4kTestmp4m3u8_400" rel="nofollow">我用vlc都能播放http://192.168.121.50/forest4kTest.m3u8和http://192.168.121.50/forest4kTest.mp4，那还要m3u8做什么，直接播放视频文件不就行了吗？</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="Docker_NginxM3U8_1"></a>Docker Nginx容器代理播放M3U8文件教程</h2> 
<p>本教程将介绍如何在Docker中使用Nginx作为反向代理，以播放M3U8文件。我们会通过步骤详细解释每个过程，并提供命令和代码示例。</p> 
<h3><a id="Nginx_Docker_6"></a>获取Nginx Docker镜像</h3> 
<p>我们用dockerfile构建镜像：</p> 
<p>（Dockerfile）</p> 
<pre><code class="prism language-python">FROM nginx<span class="token punctuation">:</span><span class="token number">1.18</span>
</code></pre> 
<p>然后用脚本构建镜像：</p> 
<p>（build_docker_image.sh）</p> 
<pre><code class="prism language-python"><span class="token comment">#!/bin/bash</span>

<span class="token comment"># 打印所有，包括注释</span>
<span class="token comment"># set -v</span>
<span class="token comment"># 打印执行命令</span>
<span class="token comment"># set -x</span>
<span class="token comment"># 命令出错退出</span>
<span class="token builtin">set</span> <span class="token operator">-</span>e
<span class="token comment"># 使用未初始化变量退出</span>
<span class="token builtin">set</span> <span class="token operator">-</span>u

<span class="token comment"># 设置变量</span>
IMAGE_NAME<span class="token operator">=</span><span class="token string">"kyai_nginx_x86"</span>
IMAGE_TAG<span class="token operator">=</span><span class="token string">"v1.18_20230724"</span>

<span class="token comment"># 检查依赖</span>
<span class="token keyword">if</span> ! <span class="token punctuation">[</span> <span class="token operator">-</span>x <span class="token string">"$(command -v docker)"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> then
  echo <span class="token string">'Error: Docker is not installed.'</span> <span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">2</span>
  exit <span class="token number">1</span>
fi

<span class="token comment"># 构建 Docker 镜像</span>
docker build <span class="token operator">-</span>t <span class="token string">"${IMAGE_NAME}:${IMAGE_TAG}"</span> <span class="token punctuation">.</span>

<span class="token comment"># 查看 Docker 镜像</span>
docker images
</code></pre> 
<p>然后可以用脚本把镜像导出为离线包：</p> 
<p>（docker_tar.sh）</p> 
<pre><code class="prism language-python"><span class="token comment">#!/bin/bash</span>

<span class="token comment"># 打印所有，包括注释</span>
<span class="token comment"># set -v</span>
<span class="token comment"># 打印执行命令</span>
<span class="token comment"># set -x</span>
<span class="token comment"># 命令出错退出</span>
<span class="token builtin">set</span> <span class="token operator">-</span>e
<span class="token comment"># 使用未初始化变量退出</span>
<span class="token builtin">set</span> <span class="token operator">-</span>u

REPOSITORY<span class="token operator">=</span><span class="token string">"kyai_nginx_x86"</span>
REP_TAG<span class="token operator">=</span><span class="token string">"v1.18_20230724"</span>

DOCKER_TAR<span class="token operator">=</span><span class="token string">"${REPOSITORY}-${REP_TAG}.tar"</span>
USER<span class="token operator">=</span>root
<span class="token comment">################################################################################</span>
WHO<span class="token operator">=</span>$<span class="token punctuation">(</span>whoami <span class="token operator">|</span> grep <span class="token string">"${USER}$"</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">-</span>z $<span class="token punctuation">{<!-- --></span>WHO<span class="token punctuation">}</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> then
    echo
    echo <span class="token string">"Please change to \"${USER}\" user mode first!"</span>
    echo
    exit <span class="token number">1</span>
fi

echo <span class="token string">"REPOSITORY: ${REPOSITORY}"</span>
echo <span class="token string">"REP_TAG: ${REP_TAG}"</span>
echo <span class="token string">"docker save -o ${DOCKER_TAR}..."</span>
docker save <span class="token operator">-</span>o $<span class="token punctuation">{<!-- --></span>DOCKER_TAR<span class="token punctuation">}</span> $<span class="token punctuation">{<!-- --></span>REPOSITORY<span class="token punctuation">}</span><span class="token punctuation">:</span>$<span class="token punctuation">{<!-- --></span>REP_TAG<span class="token punctuation">}</span>
chmod <span class="token number">777</span> $DOCKER_TAR
</code></pre> 
<p><img src="https://images2.imgbox.com/22/09/aa54BFYD_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Nginx_84"></a>设置Nginx配置文件</h3> 
<p>在运行Nginx Docker容器之前，我们需要设置一个Nginx配置文件。此文件将定义如何处理传入的HTTP请求。</p> 
<p>创建一个新的文件<code>nginx.conf</code>并输入以下内容：</p> 
<pre><code class="prism language-python">worker_processes <span class="token number">1</span><span class="token punctuation">;</span>

events <span class="token punctuation">{<!-- --></span>
    worker_connections <span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

http <span class="token punctuation">{<!-- --></span>

    sendfile on<span class="token punctuation">;</span>

    server <span class="token punctuation">{<!-- --></span>
        listen <span class="token number">80</span><span class="token punctuation">;</span>

        location <span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>
            root <span class="token operator">/</span>usr<span class="token operator">/</span>share<span class="token operator">/</span>nginx<span class="token operator">/</span>html<span class="token punctuation">;</span>
            types <span class="token punctuation">{<!-- --></span>
                application<span class="token operator">/</span>vnd<span class="token punctuation">.</span>apple<span class="token punctuation">.</span>mpegurl m3u8<span class="token punctuation">;</span>
                video<span class="token operator">/</span>mp2t ts<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            add_header Cache<span class="token operator">-</span>Control no<span class="token operator">-</span>cache<span class="token punctuation">;</span>
            add_header Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin <span class="token operator">*</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这个文件是一个Nginx服务器的配置文件，以下是对它的逐行解释：</p> 
<ul><li> <p><code>worker_processes 1;</code>：设置Nginx应使用的工作进程数。在大多数情况下，建议将此值设置为可用的CPU核心数。</p> </li><li> <p><code>events { worker_connections 1024; }</code>：在<code>events</code>块中定义了每个工作进程允许的最大连接数。在这个例子中，每个工作进程允许最多1024个并发连接。</p> </li><li> <p><code>http { ... }</code>：<code>http</code>块包含了所有的HTTP相关的配置。</p> 
  <ul><li> <p><code>sendfile on;</code>：启用高效的文件传输模式。当启用时，Nginx可以直接从磁盘到TCP套接字进行数据传输，而无需在用户空间复制数据。</p> </li><li> <p><code>server { ... }</code>：定义了一个服务器（或虚拟主机）的配置。</p> 
    <ul><li> <p><code>listen 80;</code>：该服务器监听80端口，这通常是HTTP的默认端口。</p> </li><li> <p><code>location / { ... }</code>：定义了对根路径(<code>/</code>)的请求的处理方式。所有URL路径都匹配此位置。</p> 
      <ul><li> <p><code>root /usr/share/nginx/html;</code>：定义了服务器的根目录，即所有相对URL路径的基础路径。</p> </li><li> <p><code>types { ... }</code>：定义了不同文件扩展名的MIME类型。在这个例子中，<code>.m3u8</code>文件被标记为<code>application/vnd.apple.mpegurl</code>，<code>.ts</code>文件被标记为<code>video/mp2t</code>。</p> </li><li> <p><code>add_header Cache-Control no-cache;</code>：添加一个HTTP响应头，指示客户端不要缓存响应。</p> </li><li> <p><code>add_header Access-Control-Allow-Origin *;</code>：添加一个HTTP响应头，允许任何来源的跨域请求（CORS）。</p> </li></ul> </li></ul> </li></ul> </li></ul> 
<p>这个配置文件将Nginx配置为一个简单的HTTP服务器，它可以为.m3u8和.ts文件提供服务，并禁用了响应缓存。</p> 
<h3><a id="_ffmpeg__MP4__m3u8__143"></a>用 ffmpeg 将 MP4 文件转换成 m3u8 文件</h3> 
<p>假设我们有一个forest4kTest.mp4文件：</p> 
<p><img src="https://images2.imgbox.com/71/fb/yI0F8zEK_o.png" alt="在这里插入图片描述"></p> 
<p>我们用下面命令将其转换为 m3u8 文件（我的ffmpeg版本是<code>4.2.7-0ubuntu0.1</code>）：</p> 
<pre><code class="prism language-python">ffmpeg <span class="token operator">-</span>i forest4kTest<span class="token punctuation">.</span>mp4 <span class="token operator">-</span>codec<span class="token punctuation">:</span> copy <span class="token operator">-</span>bsf<span class="token punctuation">:</span>v h264_mp4toannexb <span class="token operator">-</span><span class="token builtin">map</span> <span class="token number">0</span> <span class="token operator">-</span>f segment <span class="token operator">-</span>segment_list forest4kTest<span class="token punctuation">.</span>m3u8 <span class="token operator">-</span>segment_time <span class="token number">10</span> forest4kTest<span class="token operator">%</span>03d<span class="token punctuation">.</span>ts
</code></pre> 
<p>在这个命令中：</p> 
<ul><li><code>-i forest4kTest.mp4</code>指定输入文件。</li><li><code>-codec: copy</code>表示不对视频进行重新编码，只是复制原始数据。</li><li><code>-bsf:v h264_mp4toannexb</code>是一个比特流过滤器，用于将H264视频从MP4格式转换为MPEG2 TS格式，这是必需的，因为M3U8是基于TS的。</li><li><code>-map 0</code>表示选择所有的流（例如，如果你的视频有音频和字幕）。</li><li><code>-f segment</code>表示输出应该被分割成多个文件。</li><li><code>-segment_list output.m3u8</code>指定输出的播放列表文件。</li><li><code>-segment_time 10</code>表示每个TS段的最大长度（以秒为单位）。</li><li><code>forest4kTest%03d.ts</code>是输出TS文件的名称模式。<code>%03d</code>将被替换为三位数的序号。</li></ul> 
<p>运行这个命令后，我们会得到一个名为<code>forest4kTest.m3u8</code>的播放列表文件，以及一系列的<code>.ts</code>文件。</p> 
<p><img src="https://images2.imgbox.com/2a/7e/aXCY2WJs_o.png" alt="在这里插入图片描述"></p> 
<p>我们可以用文本编辑器打开<code>forest4kTest.m3u8</code>看一下它里面内容：</p> 
<pre><code class="prism language-python"><span class="token comment">#EXTM3U</span>
<span class="token comment">#EXT-X-VERSION:3</span>
<span class="token comment">#EXT-X-MEDIA-SEQUENCE:0</span>
<span class="token comment">#EXT-X-ALLOW-CACHE:YES</span>
<span class="token comment">#EXT-X-TARGETDURATION:11</span>
<span class="token comment">#EXTINF:10.100311,</span>
forest4kTest000<span class="token punctuation">.</span>ts
<span class="token comment">#EXTINF:10.000311,</span>
forest4kTest001<span class="token punctuation">.</span>ts
<span class="token comment">#EXTINF:10.000311,</span>
forest4kTest002<span class="token punctuation">.</span>ts
<span class="token comment">#EXTINF:10.000311,</span>
forest4kTest003<span class="token punctuation">.</span>ts
<span class="token comment">#EXTINF:10.000311,</span>
forest4kTest004<span class="token punctuation">.</span>ts
<span class="token comment">#EXTINF:10.000311,</span>
forest4kTest005<span class="token punctuation">.</span>ts
<span class="token comment">#EXTINF:10.000311,</span>
forest4kTest006<span class="token punctuation">.</span>ts
<span class="token comment">#EXTINF:10.000311,</span>
forest4kTest007<span class="token punctuation">.</span>ts
<span class="token comment">#EXTINF:10.000311,</span>
forest4kTest008<span class="token punctuation">.</span>ts
<span class="token comment">#EXTINF:10.000311,</span>
forest4kTest009<span class="token punctuation">.</span>ts
<span class="token comment">#EXTINF:0.633311,</span>
forest4kTest010<span class="token punctuation">.</span>ts
<span class="token comment">#EXT-X-ENDLIST</span>

</code></pre> 
<p><a href="https://dontla.blog.csdn.net/article/details/135352694" rel="nofollow">关于里面内容的解释，可以参考我另外一篇文章：M3u8播放列表文件（索引格式文件）、HLS（HTTP Live Streaming）协议介绍</a></p> 
<h3><a id="Docker_206"></a>运行Docker容器</h3> 
<p>我们需要写一个 run 容器的脚本，首先看看我的文件结构：</p> 
<p><img src="https://images2.imgbox.com/70/76/DqQIQQks_o.png" alt="在这里插入图片描述"></p> 
<p>再看看我的run容器脚本：</p> 
<p>（install.sh）</p> 
<pre><code class="prism language-python"><span class="token comment">#!/bin/bash</span>

<span class="token comment"># 打印所有，包括注释</span>
<span class="token comment"># set -v</span>
<span class="token comment"># 打印执行命令</span>
<span class="token comment"># set -x</span>
<span class="token comment"># 命令出错退出</span>
<span class="token builtin">set</span> <span class="token operator">-</span>e
<span class="token comment"># 使用未初始化变量退出</span>
<span class="token builtin">set</span> <span class="token operator">-</span>u

echo <span class="token operator">-</span>e <span class="token string">"\033[1;33m"</span>
echo <span class="token string">" _           _        _ _               _            "</span>
echo <span class="token string">"(_)_ __  ___| |_ __ _| | |  _ __   __ _(_)_ __ __  __"</span>
echo <span class="token string">"| | '_ \/ __| __/ _' | | | | '_ \ / _' | | '_ \\\\ \/ /"</span>
echo <span class="token string">"| | | | \__ \ || (_| | | | | | | | (_| | | | | |&gt;  &lt; "</span>
echo <span class="token string">"|_|_| |_|___/\__\__,_|_|_| |_| |_|\__, |_|_| |_/_/\_\\"</span>
echo <span class="token string">"                                  |___/              "</span>
echo <span class="token operator">-</span>e <span class="token string">"\033[0m"</span>

USER<span class="token operator">=</span>root
<span class="token comment"># USER_HOME=/root</span>

<span class="token comment"># --------------------------------------------------------------------------</span>

CONTAINER_NAME_NGINX<span class="token operator">=</span><span class="token string">"kyai_nginx"</span>
TAR_NGINX<span class="token operator">=</span><span class="token string">"kyai_nginx_x86-v1.18_20230724.tar"</span>
IMAGE_NAME_NGINX<span class="token operator">=</span><span class="token string">"kyai_nginx_x86"</span>
TAG_NGINX<span class="token operator">=</span><span class="token string">"v1.18_20230724"</span>
R_DEPLOY_PATH_NGINX<span class="token operator">=</span><span class="token string">"."</span>


<span class="token comment"># 检查是否是root</span>
WHO<span class="token operator">=</span>$<span class="token punctuation">(</span>whoami <span class="token operator">|</span> grep <span class="token string">"${USER}$"</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">-</span>z <span class="token string">"${WHO}"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> then
    echo
    echo <span class="token string">"Please change to \"${USER}\" user mode first!"</span>
    echo
    exit <span class="token number">1</span>
fi

<span class="token comment"># --------------------------------------------------------------------------</span>

<span class="token comment"># 获取脚本所在路径</span>
SCRIPT_LOCATION<span class="token operator">=</span>$<span class="token punctuation">(</span>
    cd <span class="token string">"$(dirname "</span>$<span class="token number">0</span><span class="token string">")"</span> <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">{<!-- --></span>
        echo <span class="token string">"cd Failure"</span>
        exit <span class="token number">1</span>
    <span class="token punctuation">}</span>
    pwd
<span class="token punctuation">)</span>
<span class="token comment"># echo "SCRIPT_LOCATION = $SCRIPT_LOCATION"</span>
chmod <span class="token number">777</span> $<span class="token punctuation">{<!-- --></span>SCRIPT_LOCATION<span class="token punctuation">}</span> <span class="token operator">-</span>R

<span class="token comment"># --------------------------------------------------------------------------</span>

<span class="token comment"># Function to create container</span>
<span class="token comment"># Arguments: $1 - Container name</span>
<span class="token comment">#            $2 - Docker TAR filename</span>
<span class="token comment">#            $3 - Image name</span>
<span class="token comment">#            $4 - Image tag</span>
<span class="token comment">#            $5 - Deploy path</span>
<span class="token comment">#            $6 - The function to run container</span>
function create_container <span class="token punctuation">{<!-- --></span>
    local CONTAINER_NAME<span class="token operator">=</span><span class="token string">"$1"</span>
    local DOCKER_TAR<span class="token operator">=</span><span class="token string">"$2"</span>
    local IMAGE_NAME<span class="token operator">=</span><span class="token string">"$3"</span>
    local IMAGE_TAG<span class="token operator">=</span><span class="token string">"$4"</span>
    local DEPLOY_PATH<span class="token operator">=</span><span class="token string">"$5"</span>

    local docker_run<span class="token operator">=</span><span class="token string">"$6"</span>

    <span class="token comment"># Check if container already exists</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">"$(docker ps -aqf "</span>name<span class="token operator">=</span><span class="token operator">^</span>$CONTAINER_NAME$<span class="token string">")"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> then
        echo <span class="token string">"Container $CONTAINER_NAME already exists."</span>
        read <span class="token operator">-</span>p <span class="token string">"Do you want to delete it? (y/n)"</span> answer
        <span class="token keyword">case</span> $<span class="token punctuation">{<!-- --></span>answer<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span> <span class="token keyword">in</span>
        y <span class="token operator">|</span> Y<span class="token punctuation">)</span>
            <span class="token comment"># Stop and remove container</span>
            docker stop $CONTAINER_NAME <span class="token operator">&amp;</span><span class="token operator">&amp;</span> docker rm $CONTAINER_NAME
            <span class="token comment"># Check command result</span>
            <span class="token keyword">if</span> <span class="token punctuation">[</span> $? <span class="token operator">-</span>ne <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> then
                echo <span class="token string">"Failed to stop or remove container $CONTAINER_NAME."</span>
                exit <span class="token number">1</span>
            fi
            echo <span class="token string">"Container $CONTAINER_NAME stopped and removed successfully."</span>
            <span class="token punctuation">;</span><span class="token punctuation">;</span>
        <span class="token operator">*</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
            <span class="token punctuation">;</span><span class="token punctuation">;</span>
        esac
    fi

    <span class="token comment"># Check if image already exists</span>
    <span class="token keyword">if</span> ! docker images <span class="token operator">|</span> awk <span class="token string">'{print $1":"$2}'</span> <span class="token operator">|</span> grep <span class="token operator">-</span>q <span class="token string">"^${IMAGE_NAME}:${IMAGE_TAG}$"</span><span class="token punctuation">;</span> then
        <span class="token comment"># Check if Docker TAR file exists</span>
        <span class="token keyword">if</span> <span class="token punctuation">[</span> ! <span class="token operator">-</span>e <span class="token string">"${DEPLOY_PATH}/${DOCKER_TAR}"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> then
            echo <span class="token string">"${DEPLOY_PATH}/${DOCKER_TAR} does not exist!"</span>
            exit <span class="token number">1</span>
        fi
        echo <span class="token string">"Loading Docker image from ${DOCKER_TAR}..."</span>
        docker load <span class="token operator">-</span>i <span class="token string">"${DEPLOY_PATH}/${DOCKER_TAR}"</span>
        <span class="token keyword">if</span> <span class="token punctuation">[</span> $? <span class="token operator">-</span>ne <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> then
            echo <span class="token string">"Failed to load Docker image from ${DOCKER_TAR}!"</span>
            exit <span class="token number">1</span>
        fi
    fi
    echo <span class="token string">"Docker image ${IMAGE_NAME}:${IMAGE_TAG} already exists."</span>

    <span class="token comment"># run container</span>
    $docker_run <span class="token string">"$CONTAINER_NAME"</span> <span class="token string">"$DOCKER_TAR"</span> <span class="token string">"$IMAGE_NAME"</span> <span class="token string">"$IMAGE_TAG"</span> <span class="token string">"$DEPLOY_PATH"</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> $? <span class="token operator">-</span>ne <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> then
        echo <span class="token string">"$docker_run error!"</span>
        exit <span class="token number">1</span>
    fi
<span class="token punctuation">}</span>

<span class="token comment"># --------------------------------------------------------------------------</span>

<span class="token comment"># 部署 nginx 服务</span>

<span class="token comment"># The function to run container of nginx</span>
<span class="token comment"># Arguments: $1 - Container name</span>
<span class="token comment">#            $2 - Docker TAR filename</span>
<span class="token comment">#            $3 - Image name</span>
<span class="token comment">#            $4 - Image tag</span>
<span class="token comment">#            $5 - Deploy path</span>
function docker_run_nginx <span class="token punctuation">{<!-- --></span>
    local CONTAINER_NAME<span class="token operator">=</span><span class="token string">"$1"</span>
    local DOCKER_TAR<span class="token operator">=</span><span class="token string">"$2"</span>
    local IMAGE_NAME<span class="token operator">=</span><span class="token string">"$3"</span>
    local IMAGE_TAG<span class="token operator">=</span><span class="token string">"$4"</span>
    local DEPLOY_PATH<span class="token operator">=</span><span class="token string">"$5"</span>

    docker run <span class="token operator">-</span>d \
        <span class="token operator">-</span><span class="token operator">-</span>restart<span class="token operator">=</span>always \
        <span class="token operator">-</span>p <span class="token number">80</span><span class="token punctuation">:</span><span class="token number">80</span> \
        <span class="token operator">-</span>v $SCRIPT_LOCATION<span class="token operator">/</span>$R_DEPLOY_PATH_NGINX<span class="token operator">/</span>mount<span class="token operator">/</span>m3u8<span class="token operator">/</span>files<span class="token punctuation">:</span><span class="token operator">/</span>usr<span class="token operator">/</span>share<span class="token operator">/</span>nginx<span class="token operator">/</span>html \
        <span class="token operator">-</span>v $SCRIPT_LOCATION<span class="token operator">/</span>$R_DEPLOY_PATH_NGINX<span class="token operator">/</span>mount<span class="token operator">/</span>conf<span class="token operator">/</span>nginx<span class="token punctuation">.</span>conf<span class="token punctuation">:</span><span class="token operator">/</span>etc<span class="token operator">/</span>nginx<span class="token operator">/</span>nginx<span class="token punctuation">.</span>conf \
        <span class="token operator">-</span><span class="token operator">-</span>name $CONTAINER_NAME \
        $IMAGE_NAME<span class="token punctuation">:</span>$IMAGE_TAG

    <span class="token comment"># -v $SCRIPT_LOCATION/$R_DEPLOY_PATH_NGINX/../web/html/web:/ky/java/nginx/html/web \</span>

    <span class="token keyword">if</span> <span class="token punctuation">[</span> $? <span class="token operator">-</span>ne <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> then
        echo <span class="token string">"docker run $CONTAINER_NAME error!"</span>
        exit <span class="token number">1</span>
    fi
    echo <span class="token string">"docker run $CONTAINER_NAME [$IMAGE_NAME:$IMAGE_TAG] successfully."</span>
<span class="token punctuation">}</span>

create_container <span class="token string">"$CONTAINER_NAME_NGINX"</span> <span class="token string">"$TAR_NGINX"</span> <span class="token string">"$IMAGE_NAME_NGINX"</span> <span class="token string">"$TAG_NGINX"</span> <span class="token string">"$SCRIPT_LOCATION/$R_DEPLOY_PATH_NGINX"</span> docker_run_nginx
<span class="token keyword">if</span> <span class="token punctuation">[</span> $? <span class="token operator">-</span>ne <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> then
    echo <span class="token string">"Container $CONTAINER_NAME_NGINX create failed."</span>
    exit <span class="token number">1</span>
fi

echo
echo <span class="token string">"$CONTAINER_NAME_NGINX deploy successfully"</span>
echo

</code></pre> 
<p>这个脚本将启动一个新的Docker容器，并映射主机的80端口到容器的80端口。</p> 
<p>运行脚本后，我们可以看到如下结果：</p> 
<p><img src="https://images2.imgbox.com/21/f0/Xa7xkF4X_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="M3U8_387"></a>测试M3U8流</h3> 
<p>可以通过访问<code>http://localhost:80/yourfile.m3u8</code>或<code>http://ipaddress:80/yourfile.m3u8</code>来播放m3u8文件（80端口也可以省略掉）。</p> 
<p>比如，我在windows上用VLC打开<code>http://192.168.121.50/forest4kTest.m3u8</code>（其中<code>192.168.121.50</code>是我Net模式虚拟机的ip地址）：</p> 
<p><img src="https://images2.imgbox.com/d8/f9/IvmuFQ2G_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6d/f9/qFwNsDt5_o.png" alt="在这里插入图片描述"></p> 
<p>m3u8视频流能被播放出来。</p> 
<h3><a id="_399"></a>其他问题</h3> 
<h4><a id="vlchttp19216812150forest4kTestm3u8http19216812150forest4kTestmp4m3u8_400"></a>我用vlc都能播放http://192.168.121.50/forest4kTest.m3u8和http://192.168.121.50/forest4kTest.mp4，那还要m3u8做什么，直接播放视频文件不就行了吗？</h4> 
<p>确实，使用直接的视频链接（如.mp4文件）可以在许多情况下播放视频。然而，M3U8作为HTTP Live Streaming（HLS）协议的一部分，提供了许多其他优势和高级功能，包括：</p> 
<ol><li> <p><strong>自适应流媒体</strong>：M3U8允许提供不同质量和分辨率的视频流，以适应各种网络条件和设备能力。客户端可以在播放过程中无缝切换不同质量的流，以优化用户体验。</p> </li><li> <p><strong>实时或点播流</strong>：M3U8可以用于实时的流媒体广播，也可以用于点播内容。</p> </li><li> <p><strong>容错性</strong>：由于M3U8将媒体内容分割成多个小段，所以即使在下载过程中出现问题，也只会影响到当前的段，而不是整个视频。</p> </li><li> <p><strong>加密</strong>：M3U8支持对媒体段进行AES-128或SAMPLE-AES加密，以保护内容安全。</p> </li><li> <p><strong>跨平台和广泛支持</strong>：M3U8和HLS协议被广泛地支持，在各种设备和平台上都可以播放，包括iOS、Android、Windows、macOS等。</p> </li></ol> 
<p>因此，虽然在某些情况下，直接链接到视频文件可能更简单，但使用M3U8和HLS协议可以提供更强大和灵活的流媒体解决方案。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bef8bc995b738226efd428a74f6c5714/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【无标题】finalshell 上传php文件，出现500错误的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/894a478e4f12b0ce216dc6914b9b7039/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【LeetCode每日一题】2807. 在链表中插入最大公约数（模拟&#43;求最大公约数的6中写法）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>