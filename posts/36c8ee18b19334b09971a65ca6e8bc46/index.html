<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>序列化基础 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="序列化基础" />
<meta property="og:description" content="1、简介 对象序列化的目标是将对象保存到磁盘中，或允许在网络中直接传输对象。它允许把内存中的 Java 对象转换成平台无关的二进制流（序列化，也称编码），并持久地保存在磁盘上或通过网络把这种二进制流传输到另一个网络节点，其它程序获得这种二进制流也可以把它恢复成原来的 Java 对象（反序列化，也称解码）。这样就使得对象可以脱离程序的运行而独立存在。
序列化的使用场景有：
本地存储：将对象数据永久的保存在文件或者磁盘中。网络传输：将对象数据在网络上进行传输。由于网络传输是以字节流的方式对数据进行传输的，因此序列化的目的是将对象数据转换成字节流的形式。进程间通信：在 Android 中，对象数据在进程之间传递（如 Activity 之间传递数据），或者 Intent 之间传递复杂的数据类型时（基本数据类型直接传不用序列化）。 Android 中常用的序列化方案：Serializable，Parcelable，Json，Xml，Protocol buffer。
合理的选择序列化方案，可以从以下方面考虑：
通用性：是否跨平台、跨语言。流行程度（很少人使用的协议往往意味着昂贵的学习成本）。健壮性：bug 要少。可调试性/可读性：Xml 可读性高。性能：时间、空间成本。可扩展性/兼容性安全性/访问限制：Android 的 Parcelable 曾有安全漏洞：漏洞预警 | Android系统序列化、反序列化不匹配漏洞 2、Serializable &amp; Externalizable 接口 Serializable 是 Java 提供的一个标记接口，它只是表明该类的实例可以序列化，无须实现任何方法。Externalizable 接口是 Serializable 的子接口，其内部定义了 writeExternal(ObjectOutput) 和 readExternal(ObjectInput) 两个方法：
public interface Serializable { } public interface Externalizable extends java.io.Serializable { void writeExternal(ObjectOutput out) throws IOException; void readExternal(ObjectInput in) throws IOException, ClassNotFoundException; } 我们先关注 Serializable 接口。
2.1 Serializable 基本使用 序列化时需要用 ObjectOutputStream 的 writeObject(OutputStream)，反序列化时用 ObjectInputStream 的 readObject()：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/36c8ee18b19334b09971a65ca6e8bc46/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-26T22:42:07+08:00" />
<meta property="article:modified_time" content="2023-11-26T22:42:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">序列化基础</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_0"></a>1、简介</h2> 
<p>对象序列化的目标是将对象保存到磁盘中，或允许在网络中直接传输对象。它允许把内存中的 Java 对象转换成平台无关的二进制流（序列化，也称编码），并持久地保存在磁盘上或通过网络把这种二进制流传输到另一个网络节点，其它程序获得这种二进制流也可以把它恢复成原来的 Java 对象（反序列化，也称解码）。这样就使得对象可以脱离程序的运行而独立存在。</p> 
<p>序列化的使用场景有：</p> 
<ul><li>本地存储：将对象数据永久的保存在文件或者磁盘中。</li><li>网络传输：将对象数据在网络上进行传输。由于网络传输是以字节流的方式对数据进行传输的，因此序列化的目的是将对象数据转换成字节流的形式。</li><li>进程间通信：在 Android 中，对象数据在进程之间传递（如 Activity 之间传递数据），或者 Intent 之间传递复杂的数据类型时（基本数据类型直接传不用序列化）。</li></ul> 
<p>Android 中常用的序列化方案：Serializable，Parcelable，Json，Xml，Protocol buffer。</p> 
<p>合理的选择序列化方案，可以从以下方面考虑：</p> 
<ul><li>通用性：是否跨平台、跨语言。流行程度（很少人使用的协议往往意味着昂贵的学习成本）。</li><li>健壮性：bug 要少。</li><li>可调试性/可读性：Xml 可读性高。</li><li>性能：时间、空间成本。</li><li>可扩展性/兼容性</li><li>安全性/访问限制：Android 的 Parcelable 曾有安全漏洞：<a href="https://www.anquanke.com/post/id/103570" rel="nofollow">漏洞预警 | Android系统序列化、反序列化不匹配漏洞</a></li></ul> 
<h2><a id="2Serializable__Externalizable__21"></a>2、Serializable &amp; Externalizable 接口</h2> 
<p>Serializable 是 Java 提供的一个标记接口，它只是表明该类的实例可以序列化，无须实现任何方法。Externalizable 接口是 Serializable 的子接口，其内部定义了 writeExternal(ObjectOutput) 和 readExternal(ObjectInput) 两个方法：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{<!-- --></span> 
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Externalizable</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{<!-- --></span>
    
    <span class="token keyword">void</span> <span class="token function">writeExternal</span><span class="token punctuation">(</span><span class="token class-name">ObjectOutput</span> out<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">readExternal</span><span class="token punctuation">(</span><span class="token class-name">ObjectInput</span> in<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们先关注 Serializable 接口。</p> 
<h3><a id="21_Serializable__39"></a>2.1 Serializable 基本使用</h3> 
<p>序列化时需要用 ObjectOutputStream 的 writeObject(OutputStream)，反序列化时用 ObjectInputStream 的 readObject()：</p> 
<pre><code class="prism language-java">    <span class="token comment">// 将 object 的序列化数据写入 path 表示的文件中</span>
	<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">saveObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> object<span class="token punctuation">,</span> <span class="token class-name">String</span> path<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">ObjectOutputStream</span> oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

	<span class="token comment">// 从指定文件中读取数据进行反序列化</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">readObject</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">ObjectInputStream</span> ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> <span class="token operator">|</span> <span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>序列化时可以在构造 ObjectOutputStream 时传入不同的输出流实现不同的效果。如传入 ByteArrayOutputStream，可以直接得到序列化的二进制数据：</p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getSerializedObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> object<span class="token punctuation">,</span> <span class="token class-name">String</span> path<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">ByteArrayOutputStream</span> baos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token class-name">ObjectOutputStream</span> oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>baos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> baos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h3><a id="22_Serializable__87"></a>2.2 Serializable 实现类的创建</h3> 
<p>以实现了 Serializable 接口的 Person 类为例：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// serialVersionUID 唯一标识了一个可序列化的类</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">1L</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token comment">// Food 也需要实现 Serializable 接口</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Food</span><span class="token punctuation">&gt;</span></span> foods<span class="token punctuation">;</span>
    <span class="token comment">/*
    用transient关键字标记的成员变量不参与序列化。
    在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象则为 null。
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Date</span> createTime<span class="token punctuation">;</span>
    <span class="token comment">/*
    静态成员变量属于类不属于对象，所以不会参与序列化。
    对象序列化保存的是对象的“状态”，也就是它的成员变量，因此序列化不会关注静态变量。
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">SimpleDateFormat</span> simpleDateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
        foods <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        createTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// getters and setters...</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>下面关注创建 Serializable 的实现类时需要注意的问题。</p> 
<h4><a id="serialVersionUID_125"></a>serialVersionUID</h4> 
<p>作用是表明类的不同版本间的兼容性，保证序列化类在其对象已经序列化之后做了修改，该对象依然可以被正确反序列化。举个例子，对于上面的 Person 类，先序列化一个对象保存到文件中。然后，假设业务需求变更需要把 age 字段修改成 String 类型的，那么在修改 age 字段的同时，也要修改 serialVersionUID：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{<!-- --></span>
    
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">2L</span><span class="token punctuation">;</span>
    
    <span class="token keyword">private</span> <span class="token class-name">String</span> age<span class="token punctuation">;</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这样的话，反序列化时根据 serialVersionUID 的值是可以正确执行的。倘若没有声明 serialVersionUID，修改前的已经被序列化的 Person 对象就会按照修改后的 Person 类进行反序列化，由于字段不匹配而抛出异常：</p> 
<pre><code>java.io.InvalidClassException: com.frank.serializable.Person; local class incompatible: stream classdesc serialVersionUID = -8357684236211496111, local class serialVersionUID = -657709351248511155
	at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699)
	at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1885)
	at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1751)
	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2042)
	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573)
	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431)
	......
</code></pre> 
<p>如果不显式定义 serialVersionUID，那么这个值会由 JVM 根据类的相关信息进行计算，通常修改后的计算结果与修改前不同，使得类版本不兼容，进而造成反序列化失败。说的直白一点，对象序列化数据中的 serialVersionUID 和反序列化时使用的 class 文件中的 serialVersionUID 不同，反序列化就会失败。</p> 
<p>为了保证反序列化的正常执行，需要显式声明 serialVersionUID，最好是 private final 的，也可以使用 JDK bin 目录下的工具 serialver.exe 工具生成 serialVersionUID，当然 Android Studio 中的 GenerateSerialVersionUID 插件也可以帮我们生成。</p> 
<p>不显式指定 serialVersionUID 的另一个坏处就是，即便类没有发生变化，但是两端使用不同的 JVM 时，由于编译器不同，计算策略不同，也可能会造成计算出来的 serialVersionUID 不同，导致反序列化失败。</p> 
<p>那修改哪些程序单元时要更新 serialVersionUID 呢？需要看情况：</p> 
<ul><li>修改方法、静态变量、瞬态实例变量（transient 修饰的变量），不需要修改 serialVersionUID（因为以上元素不会被序列化）。</li><li>修改了非瞬态实例变量，可能会导致序列化版本不兼容。修改了变量类型（对象流中的对象和新类中包含同名实例变量，但实例变量类型不同）需要更新；删除了某个变量（流中的对象比新类中包含更多的实例变量，多出的被忽略），可以不更新；增加了某个变量（新类中包含的对象比流中包含的实例变量多），版本可以兼容，serialVersionUID 也可以不更新，但是反序列化时新对象中多出的实例变量值都是 null 或 0。</li></ul> 
<h4><a id="transient__163"></a>transient 关键字</h4> 
<p>transient 作用：非静态数据如不想被序列化，可以使用这个关键字修饰使之成为瞬态变量。</p> 
<p>ObjectOutputStream 的 writeObject() 会将 Serializable 的实现类中非瞬态、非静态的成员变量都序列化，如果有非静态成员变量不想被序列化的话，就可以用 transient 修饰这个成员变量。例如 Person 类中的 Date 类型对象 createTime 被 transient 修饰，反序列化后该字段仍然存在，但是为 null。</p> 
<p>具有类似情况的还有 static 修饰的静态变量，也不会被序列化。因为序列化的操作对象是实例对象，而 static 修饰的变量属于类，并不是序列化关注的内容。</p> 
<blockquote> 
 <p>transient 修饰的变量、static 修饰的变量和方法不会参与序列化。反序列化时这些变量的值为 0（基本数据类型）或者 null（引用数据类型）。</p> 
</blockquote> 
<p>此外，Kotlin 中的 transient 不是一个关键字，而是一个注解 @Transient。</p> 
<h4><a id="_175"></a>序列化的传递性</h4> 
<p>序列化具有一定的传递性：</p> 
<pre><code>1. 一个实现了序列化的类，它的子类也是可序列化的。
2. 要序列化的类中除了 transient、static 修饰的变量外，其它变量类型也要实现 Serializable 接口。
</code></pre> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// Course 要实现 Serializable 接口</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Course</span><span class="token punctuation">&gt;</span></span> courses<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> age<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
        courses <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>Student 继承 Person，由于 Person 实现了序列化，那么 Student 也要实现序列化，这就要求 Course 类必须要实现 Serializable 接口，否则在序列化过程中会抛出 NotSerializableException。</p> 
<p>此外，如果父类没有实现 Serializable，而子类实现了，需要父类中提供一个子类可访问到的空参构造方法，否则在反序列化调用 readObject() 时会抛出异常：</p> 
<pre><code>java.io.InvalidClassException: com.frank.serializable.Son; no valid constructor
	at java.io.ObjectStreamClass$ExceptionInfo.newInvalidClassException(ObjectStreamClass.java:169)
	at java.io.ObjectStreamClass.checkDeserialize(ObjectStreamClass.java:874)
</code></pre> 
<p>示例代码：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token comment">// 应该打开，否则抛异常</span>
    <span class="token comment">/*public Father() {
    }*/</span>

    <span class="token keyword">public</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="23__234"></a>2.3 序列化步骤与数据格式</h3> 
<p>序列化步骤：</p> 
<ol><li>将对象实例相关的类元数据输出。</li><li>递归地输出类的超类描述直到不再有超类。</li><li>类元数据输出完毕以后，从最顶层的超类开始输出对象实例的实际数据值。</li><li>从上至下递归输出实例的数据。</li></ol> 
<p>比如说对于一个 Person 对象，序列化到文件后，查看其十六进制数据（使用 Notepad++ -&gt; 插件 -&gt; HEX Editor -&gt; View in Hex 查看）：</p> 
<p><img src="https://images2.imgbox.com/80/89/CqHzillB_o.png" alt="序列化后16进制数据"></p> 
<p>这些十六进制数据的含义：</p> 
<ul><li>AC ED: STREAM_MAGIC 声明使用了序列化协议。</li><li>00 05: STREAM_VERSION 序列化协议版本。</li><li>0x73: TC_OBJECT 声明这是一个新的对象。</li><li>0x72: TC_CLASSDESC 声明这里开始一个新的 Class。</li><li>00 1d: Class 名字的长度。</li></ul> 
<h3><a id="24__257"></a>2.4 源码流程</h3> 
<p>从 ObjectOutputStream 的 writeObject() 方法开始：</p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>enableOverride<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">writeObjectOverride</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">writeObject0</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">writeFatalException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>根据 enableOverride 的值决定调用 writeObjectOverride() 或 writeObject0()。enableOverride 仅在 ObjectOutputStream 的构造方法被赋值，如果调用的是空参构造方法，enableOverride 为 true，如果调用的是 ObjectOutputStream(OutputStream)，则 enableOverride 为 false。</p> 
<p>走一般流程，看 writeObject0() 的源码：</p> 
<pre><code class="prism language-java">	<span class="token comment">/**
	* 写对象数据是一个递归流程。判断 obj 的类型是否可以直接写二进制数据，如 String、Array 或者
	* 枚举类型。如果不是，就调用 writeOrdinaryObject()，再去写入这个“复合”对象中的每个属性，
	* 此时会再调用到 writeObject0() 形成递归，直到 obj 的所有属性都可以直接写成二进制数据为止。
	*/</span>
	<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeObject0</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token keyword">boolean</span> unshared<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">IOException</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// ......</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">writeString</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> obj<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cl<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">writeArray</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Enum</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">writeEnum</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Enum</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> obj<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Serializable</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 写对象，最终会递归拆分成直接可写的数据类型</span>
                <span class="token function">writeOrdinaryObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 如果没有实现 Serializable 接口，抛出 NotSerializableException</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>extendedDebugInfo<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NotSerializableException</span><span class="token punctuation">(</span>
                        cl<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span> <span class="token operator">+</span> debugInfoStack<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NotSerializableException</span><span class="token punctuation">(</span>cl<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// ......</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>根据 obj 的类型，调用相应的写入数据的方法。如果 obj 不是 String、数组或枚举类型，并且还实现了 Serializable，就会调用 writeOrdinaryObject()：</p> 
<pre><code class="prism language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeOrdinaryObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span>
                                     <span class="token class-name">ObjectStreamClass</span> desc<span class="token punctuation">,</span>
                                     <span class="token keyword">boolean</span> unshared<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">IOException</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            desc<span class="token punctuation">.</span><span class="token function">checkSerialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            bout<span class="token punctuation">.</span><span class="token function">writeByte</span><span class="token punctuation">(</span><span class="token constant">TC_OBJECT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">writeClassDesc</span><span class="token punctuation">(</span>desc<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            handles<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>unshared <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 写 Externalizable 或者 Serializable 数据</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>desc<span class="token punctuation">.</span><span class="token function">isExternalizable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>desc<span class="token punctuation">.</span><span class="token function">isProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">writeExternalData</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Externalizable</span><span class="token punctuation">)</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">writeSerialData</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> desc<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>如果实现的是 Serializable，会调用 writeSerialData() 写数据：</p> 
<pre><code class="prism language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeSerialData</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">ObjectStreamClass</span> desc<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">IOException</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ObjectStreamClass<span class="token punctuation">.</span>ClassDataSlot</span><span class="token punctuation">[</span><span class="token punctuation">]</span> slots <span class="token operator">=</span> desc<span class="token punctuation">.</span><span class="token function">getClassDataLayout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> slots<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">ObjectStreamClass</span> slotDesc <span class="token operator">=</span> slots<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>desc<span class="token punctuation">;</span>
            <span class="token comment">// 如果 Serializable 的实现类自定义了 writeObject() 就走 if，否则走 else。</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>slotDesc<span class="token punctuation">.</span><span class="token function">hasWriteObjectMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">PutFieldImpl</span> oldPut <span class="token operator">=</span> curPut<span class="token punctuation">;</span>
                curPut <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token class-name">SerialCallbackContext</span> oldContext <span class="token operator">=</span> curContext<span class="token punctuation">;</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span>extendedDebugInfo<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    debugInfoStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>
                        <span class="token string">"custom writeObject data (class \""</span> <span class="token operator">+</span>
                        slotDesc<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                    curContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SerialCallbackContext</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> slotDesc<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    bout<span class="token punctuation">.</span><span class="token function">setBlockDataMode</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// 调用自定义 writeObject()</span>
                    slotDesc<span class="token punctuation">.</span><span class="token function">invokeWriteObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    bout<span class="token punctuation">.</span><span class="token function">setBlockDataMode</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    bout<span class="token punctuation">.</span><span class="token function">writeByte</span><span class="token punctuation">(</span><span class="token constant">TC_ENDBLOCKDATA</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
                    curContext<span class="token punctuation">.</span><span class="token function">setUsed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    curContext <span class="token operator">=</span> oldContext<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>extendedDebugInfo<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        debugInfoStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>

                curPut <span class="token operator">=</span> oldPut<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">defaultWriteFields</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> slotDesc<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>看默认流程，走 defaultWriteFields():</p> 
<pre><code class="prism language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">defaultWriteFields</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">ObjectStreamClass</span> desc<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">IOException</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> cl <span class="token operator">=</span> desc<span class="token punctuation">.</span><span class="token function">forClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cl <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> obj <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>cl<span class="token punctuation">.</span><span class="token function">isInstance</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassCastException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        desc<span class="token punctuation">.</span><span class="token function">checkDefaultSerialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> primDataSize <span class="token operator">=</span> desc<span class="token punctuation">.</span><span class="token function">getPrimDataSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>primVals <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> primVals<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> primDataSize<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            primVals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>primDataSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        desc<span class="token punctuation">.</span><span class="token function">getPrimFieldValues</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> primVals<span class="token punctuation">)</span><span class="token punctuation">;</span>
        bout<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>primVals<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> primDataSize<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 获取类中所有属性</span>
        <span class="token class-name">ObjectStreamField</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fields <span class="token operator">=</span> desc<span class="token punctuation">.</span><span class="token function">getFields</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> objVals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>desc<span class="token punctuation">.</span><span class="token function">getNumObjFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> numPrimFields <span class="token operator">=</span> fields<span class="token punctuation">.</span>length <span class="token operator">-</span> objVals<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        desc<span class="token punctuation">.</span><span class="token function">getObjFieldValues</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> objVals<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> objVals<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 又调用到 writeObject0() 写属性数据，形成递归。</span>
                <span class="token function">writeObject0</span><span class="token punctuation">(</span>objVals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>
                             fields<span class="token punctuation">[</span>numPrimFields <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">isUnshared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>递归直到要写入的是基本数据类型为止，整个流程图如下：</p> 
<p><img src="https://images2.imgbox.com/74/9d/8jkxrwwI_o.png" alt="序列化方法调用流程图"></p> 
<h3><a id="25__431"></a>2.5 自定义序列化</h3> 
<h4><a id="writeObjectreadObject_433"></a>writeObject()、readObject()</h4> 
<p>源码流程中提到，在 writeSerialData() 中，如果 Serializable 的实现类自定义了 writeObject()，那么就通过反射调用到这个 writeObject()，否则就调用 defaultWriteFields() 执行一般的序列化过程。因此，重写 writeObject()、readObject() 可以实现自定义序列化。</p> 
<p>自定义序列化机制可以让程序控制如何序列化实例变量，甚至完全不序列化。在要进行序列化的类中要提供以下方法：</p> 
<p><img src="https://images2.imgbox.com/c9/6f/dvLvg9Ya_o.png" alt="自定义序列化方法"></p> 
<p>三个方法的用途：</p> 
<ul><li>writeObject(out) 默认调用 out.defaultWriteObject 来保存各个实例变量，我们可以在方法内自己决定如何对实例变量进行序列化。</li><li>readObject(in) 默认调用 in.defaultReadObject 来恢复对象的非瞬态实例变量。在这个方法内做与 writeObject(out) 操作相反的操作即可正确恢复该对象。</li><li>当序列化流不完整时，readObjectNoData() 可以用来正确地初始化反序列化的对象。例如两端使用的序列化的类版本不同，或者序列化流被篡改，系统都会调用这个方法来初始化反序列化对象。</li></ul> 
<p>示例代码：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// getters...</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token class-name">ObjectOutputStream</span> outputStream<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{<!-- --></span>
        outputStream<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        outputStream<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span><span class="token class-name">ObjectInputStream</span> inputStream<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{<!-- --></span>
        name <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">StringBuffer</span><span class="token punctuation">)</span> inputStream<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        age <span class="token operator">=</span> inputStream<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在 writeObject() 将 name 属性封装到 StringBuffer 中并倒序，在 readObject() 中将 StringBuffer 倒序转换成 String 类型实现还原。</p> 
<blockquote> 
 <p>writeObject() 和 readObject() 处理变量的顺序应该一致，否则不能正常恢复该对象。</p> 
</blockquote> 
<h4><a id="writeReplacereadResolve_478"></a>writeReplace()、readResolve()</h4> 
<p>还有一种更彻底的自定义机制，它甚至可以在序列化对象时将该对象替换成其它对象。如果需要实现序列化某个对象时替换该对象，则应为序列化类提供如下方法：</p> 
<pre><code class="prism language-java">    <span class="token constant">ANY</span><span class="token operator">-</span><span class="token constant">ACCESS</span><span class="token operator">-</span><span class="token constant">MODIFIER</span> <span class="token class-name">Object</span> <span class="token function">writeReplace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ObjectStreamException</span><span class="token punctuation">;</span>
</code></pre> 
<p>仍以 Person 类为例：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/*private void writeObject(ObjectOutputStream outputStream) throws IOException {
        outputStream.writeObject(new StringBuffer(name).reverse());
        outputStream.writeInt(age);
    }

    private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {
        name = ((StringBuffer) inputStream.readObject()).reverse().toString();
        age = inputStream.readInt();
    }*/</span>

    <span class="token keyword">private</span> <span class="token class-name">Object</span> <span class="token function">writeReplace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ObjectStreamException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> arrayList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> arrayList<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>writeReplace() 把 Person 需要序列化的成员变量都封装在 ArrayList 中，并返回这个 ArrayList 对象，那么在反序列化时，我们拿到的就是一个 ArrayList 对象而不是原来的 Person 对象了：</p> 
<pre><code class="prism language-java">	<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">ObjectOutputStream</span> objectOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token class-name">ObjectInputStream</span> objectInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 序列化</span>
            <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            objectOutputStream<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 反序列化，这里拿到的不是 Person 而是 ArrayList。</span>
            <span class="token comment">//Person p = (Person) objectInputStream.readObject();</span>
            <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> arrayList <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> objectInputStream<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">","</span> <span class="token operator">+</span>arrayList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> <span class="token operator">|</span> <span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>执行序列化过程时，系统先调用 writeReplace()，如果它返回另一个对象，则系统会再去调用另一个对象的 writeReplace()，直到该方法不再返回另一个对象为止。最后再调用 writeObject() 保存该对象。</p> 
<p>与 writeReplace() 对应的方法是：</p> 
<pre><code class="prism language-java">    <span class="token constant">ANY</span><span class="token operator">-</span><span class="token constant">ACCESS</span><span class="token operator">-</span><span class="token constant">MODIFIER</span> <span class="token class-name">Object</span> <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ObjectStreamException</span><span class="token punctuation">;</span>
</code></pre> 
<p>readResolve() 会紧跟在 readObject() 之后被调用，其返回值会替代原来反序列化的对象，而 readObject() 反序列化的对象会被立即丢弃。</p> 
<h4><a id="readResolve__548"></a>readResolve() 的特殊用途</h4> 
<p>readResolve() 在序列化单例类、枚举类时尤其有用。这么说是因为在 Java5 的 enum 出现之前，老式定义枚举类的方法不使用 readResolve() 会有问题。看代码示例：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Orientation</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Orientation</span> <span class="token constant">HORIZONTAL</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Orientation</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Orientation</span> <span class="token constant">VERTICAL</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Orientation</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Orientation</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这个 Orientation 是 enum 出现之前的枚举类定义方式，先序列化然后再反序列化：</p> 
<pre><code class="prism language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">ObjectOutputStream</span> objectOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"orientation.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token class-name">ObjectInputStream</span> objectInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"orientation.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            objectOutputStream<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token class-name">Orientation</span><span class="token punctuation">.</span><span class="token constant">HORIZONTAL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Orientation</span> orientation <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Orientation</span><span class="token punctuation">)</span> objectInputStream<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>orientation <span class="token operator">==</span> <span class="token class-name">Orientation</span><span class="token punctuation">.</span><span class="token constant">HORIZONTAL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> <span class="token operator">|</span> <span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>发现反序列化得到的对象并不是枚举类中定义的枚举对象。为了解决这个问题，就要用 readResolve() 对反序列化的结果做进一步处理：</p> 
<pre><code class="prism language-java">    <span class="token keyword">private</span> <span class="token class-name">Object</span> <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ObjectStreamException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token constant">HORIZONTAL</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token constant">VERTICAL</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>在序列化类中加入这个方法后，再测试发现结果就为 true 了。</p> 
<p>但是这个问题在使用 enum 定义的枚举类中是没有的：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Orientation</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token constant">HORIZONTAL</span><span class="token punctuation">,</span><span class="token constant">VERTICAL</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>测试反序列化的对象是否为枚举类中的枚举对象：</p> 
<pre><code class="prism language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">ObjectOutputStream</span> objectOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"orientation.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token class-name">ObjectInputStream</span> objectInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"orientation.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            objectOutputStream<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token class-name">Orientation</span><span class="token punctuation">.</span><span class="token constant">HORIZONTAL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Orientation</span> orientation <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Orientation</span><span class="token punctuation">)</span> objectInputStream<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>orientation <span class="token operator">==</span> <span class="token class-name">Orientation</span><span class="token punctuation">.</span><span class="token constant">HORIZONTAL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> <span class="token operator">|</span> <span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>类似的，在序列化单例类时，也会发生反序列化得到的对象与原对象不是同一个对象的问题：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Single</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingleHolder</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Single</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Single</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token class-name">SingleHolder</span><span class="token punctuation">.</span>instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{<!-- --></span>
    
        <span class="token class-name">Single</span> single <span class="token operator">=</span> <span class="token class-name">Single</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">ByteArrayOutputStream</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ObjectOutputStream</span> objectOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>
        objectOutputStream<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>single<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> out<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">ObjectInputStream</span> objectInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Single</span> single1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Single</span><span class="token punctuation">)</span> objectInputStream<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>single <span class="token operator">==</span> single1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>这时就需要使用 readResolve() 进行处理了，在 Single 类中添加：</p> 
<pre><code class="prism language-java">    <span class="token keyword">private</span> <span class="token class-name">Object</span> <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token class-name">SingleHolder</span><span class="token punctuation">.</span>instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="writeReplace__readResolve__660"></a>writeReplace() 和 readResolve() 的隐患</h4> 
<p>writeReplace() 和 readResolve() 也有一些隐患。它们都可以被 public、protected 和 private 修饰，因此子类就可能会继承这些方法。对 readResolve() 来说，如果子类没有重写这个方法，反序列化时就会得到一个父类对象，这是一种不易发现的错误。但如果总让子类重写这个方法，又是一种负担。通常的建议是，对于 final 类重写 readResolve() 不会有任何问题，否则重写 readResolve() 时应尽量使用 private 修饰。</p> 
<h3><a id="26__664"></a>2.6 要注意的问题</h3> 
<h4><a id="_666"></a>对象变化</h4> 
<p>反序列化得到的对象不是序列化前的对象，测试代码：</p> 
<pre><code class="prism language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Test"</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">ByteArrayOutputStream</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ObjectOutputStream</span> objectOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>
        objectOutputStream<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> out<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">ObjectInputStream</span> ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Person</span> person1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person <span class="token operator">==</span> person1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_685"></a>序列化编号</h4> 
<p>这里的序列化编号不是之前说的那个 serialVersionUID，而是用来检查某个对象是否已经被序列化过的编号：</p> 
<p><img src="https://images2.imgbox.com/72/7b/AZTpNRmU_o.png" alt="序列化算法内容"></p> 
<p>之所以要使用这个序列化编号，是为了避免多个对象对同一个对象引用进行重复序列化。比如说：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Teacher</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Person</span> student<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>已知 Person 类是可以序列化的，假设有如下特殊情形：</p> 
<pre><code class="prism language-java">    <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Teacher</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span><span class="token string">"teacher1"</span><span class="token punctuation">,</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Teacher</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span><span class="token string">"teacher2"</span><span class="token punctuation">,</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>t1 和 t2 在进行序列化的时候都需要对它们内部持有的 person 对象进行序列化。假如没有序列化编号，那么 t1 和 t2 就会分别对 person 各进行一次序列化，产生两个 person 对象。而另一端从输入流中反序列化出来也是两个 person 对象了，而不是一个。这违背了 Java 序列化机制的初衷。</p> 
<p>采用了序列化编号之后，只有第一次使用 writeObject() 时才会将该对象转换成字节序列并输出，后面再重复调用时输出的是序列化编号，这样可以避免一个对象被多次序列化的问题。但是这样做会有<strong>另一个隐患</strong>，就是如果一个对象在第一次调用 writeObject() 之后发生了改变，那么后面再调用 writeObject() 也仍然会输出序列化编号。</p> 
<blockquote> 
 <p>序列化可变对象时一定要注意，只有第一次调用 writeObject() 输出对象时才会将对象转换成字节序列，并写入到 ObjectOutputStream。后面如果对象实例发生了改变，再次调用 writeObject() 输出该对象时，实例变量也不会被输出，而是输出序列化编号。</p> 
</blockquote> 
<h4><a id="_714"></a>多引用写入</h4> 
<p>在序列化输出过一次之后，对序列化对象进行了修改再输出一次，要注意，第二次输出要特殊处理：</p> 
<pre><code class="prism language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Test"</span><span class="token punctuation">,</span> <span class="token string">"13"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ByteArrayOutputStream</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ObjectOutputStream</span> objectOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 序列化输出一次</span>
        objectOutputStream<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 修改序列化对象</span>
        person<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token string">"14"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 将修改后的对象再输出一次</span>
        <span class="token function">writeObjectAgain</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> objectOutputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 反序列化，观察 person1 和 person2 的结果</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> out<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ObjectInputStream</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Person</span> person1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Person</span> person2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>如果还跟第一次一样只使用 objectOutputStream.writeObject(person)，会发现反序列化得到的都是第一个对象（猜测原因就是上一节讲的序列化编号）：</p> 
<pre><code class="prism language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">writeObjectAgain1</span><span class="token punctuation">(</span><span class="token class-name">Person</span> person<span class="token punctuation">,</span> <span class="token class-name">ObjectOutputStream</span> objectOutputStream<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{<!-- --></span>
        objectOutputStream<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {name='Test', age=13},Person{name='Test', age=13}</span>
    <span class="token punctuation">}</span>

	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">writeObjectAgain2</span><span class="token punctuation">(</span><span class="token class-name">Person</span> person<span class="token punctuation">,</span> <span class="token class-name">ObjectOutputStream</span> objectOutputStream<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{<!-- --></span>
        objectOutputStream<span class="token punctuation">.</span><span class="token function">writeUnshared</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {name='Test', age=13},Person{name='Test', age=14}</span>
    <span class="token punctuation">}</span>

	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">writeObjectAgain3</span><span class="token punctuation">(</span><span class="token class-name">Person</span> person<span class="token punctuation">,</span> <span class="token class-name">ObjectOutputStream</span> objectOutputStream<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{<!-- --></span>
        objectOutputStream<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        objectOutputStream<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {name='Test', age=13},Person{name='Test', age=14}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>第二种和第三种是正确的处理方法，使用 writeUnshared() 或者在调用 writeObject() 之前先调用一次 reset()。</p> 
<h3><a id="27_Externalizable_760"></a>2.7 Externalizable</h3> 
<p>如果需要序列化的类实现的不是 Serializable 接口而其子接口是 Externalizable，自定义序列化方法也是和前者类似的。只不过 Externalizable 是要求强制自义定的，必须要实现 writeExternal() 和 readExternal() 两个方法，其作用和 Serializable 的 writeReplace() 和 readResolve() 非常相似，不再赘述。执行序列化和反序列化的方式与 Serializable 相同，都是调用 readObject() 和 writeObject()：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Course</span> <span class="token keyword">implements</span> <span class="token class-name">Externalizable</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">1L</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">float</span> score<span class="token punctuation">;</span>

    <span class="token comment">/**
     * 序列化类型必须提供一个可访问的空参构造方法，否则反序列化时会抛出
     * InvalidClassException，原因是 no valid constructor
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">Course</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Course</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">float</span> score<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>score <span class="token operator">=</span> score<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * @param out ObjectOutput 接口的实现类之一是 ObjectOutputStream，相当于
     *            还是调用的输出流去做序列化，只不过你可以自定义序列化的内容了。
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeExternal</span><span class="token punctuation">(</span><span class="token class-name">ObjectOutput</span> out<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"writeExternal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">writeFloat</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * @param in ObjectInput 接口的实现类之一是 ObjectInputStream，可以
     *           根据序列化的过程调整反序列化属性的顺序。
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readExternal</span><span class="token punctuation">(</span><span class="token class-name">ObjectInput</span> in<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"readExternal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        name <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        score <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Course</span> course <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Course</span><span class="token punctuation">(</span><span class="token string">"English"</span><span class="token punctuation">,</span> <span class="token number">85</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 还是用 ObjectOutputStream 和 ObjectInputStream 做序列化与反序列化</span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">ByteArrayOutputStream</span> baos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token class-name">ObjectOutputStream</span> oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>baos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>course<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> baos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token class-name">ObjectInputStream</span> ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Course</span> resultCourse <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Course</span><span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>resultCourse<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> resultCourse<span class="token punctuation">.</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> <span class="token operator">|</span> <span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>虽然实现 Externalizable 接口能带来一定的性能提升，但是由于必须要实现 writeExternal() 和 readExternal() 两个方法导致编程复杂度增加，所以大部分时候采用实现 Serializable 接口来实现序列化。</p> 
<h3><a id="28__826"></a>2.8 总结</h3> 
<ol><li>对象的类名、实例变量（包括基本类型、数组、对其它对象的引用）都会被序列化；方法、类变量、transient 实例变量（也称为瞬态实例变量）都不会被序列化。</li><li>实现 Serializable 接口的类如果需要让某个实例变量不被序列化，在该变量前加 transient 即可。虽然 static 也能达到这个效果，但是不能这样用。</li><li>可序列化类 A 需要保证所有实例变量类型也是可序列化的，如果有实例变量不可序列化可用 transient 修饰。否则，类 A 不可被序列化。</li><li>反序列化对象时必须有序列化对象的 class 文件。</li><li>通过文件、网络读取序列化后的对象时，必须按实际写入的顺序读取。</li></ol> 
<h2><a id="3Parcelable_834"></a>3、Parcelable</h2> 
<p>Parcelable 是 Android 为我们提供的序列化的接口，Parcelable 相对于 Serializable 的使用要复杂一些，但 Parcelable 的效率相对 Serializable 也高很多。Parcelable 是 Android SDK 提供的，它是基于内存的，由于内存读写速度高于硬盘，因此 Android 中的<br> 跨进程对象的传递一般使用 Parcelable。</p> 
<h3><a id="31__839"></a>3.1 基本使用</h3> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Course</span> <span class="token keyword">implements</span> <span class="token class-name">Parcelable</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">float</span> score<span class="token punctuation">;</span>

    <span class="token comment">/**
    * 反序列化创建对象时会用这个构造方法，读取属性，需要与 writeToParcel() 
    * 中写属性的顺序保持一致
    */</span>
    <span class="token keyword">protected</span> <span class="token class-name">Course</span><span class="token punctuation">(</span><span class="token class-name">Parcel</span> in<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        name <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        score <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 实现类必须有一个 Creator 属性，用于反序列化，将 Parcel 对象转换为 Parcelable
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Creator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Course</span><span class="token punctuation">&gt;</span></span> <span class="token constant">CREATOR</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Creator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Course</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 从序列化对象中，获取原始的对象；</span>
        <span class="token comment">// 反序列化的方法，将Parcel还原成Java对象</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">Course</span> <span class="token function">createFromParcel</span><span class="token punctuation">(</span><span class="token class-name">Parcel</span> in<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Course</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 创建指定长度的原始对象数组，提供给外部类反序列化这个数组使用。</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">Course</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">newArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Course</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 描述，返回的是内容的描述信息，只针对一些特殊的需要描述信息的对象,需要返回1,其他情况返回0就可以
     * 描述当前 Parcelable 实例的对象类型
     * 比如说，如果对象中有文件描述符，这个方法就会返回上面的 CONTENTS_FILE_DESCRIPTOR
     * 其他情况会返回一个位掩码
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">describeContents</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 将对象转换成一个 Parcel 对象
     *
     * @param dest  表示要写入的 Parcel 对象
     * @param flags 表示这个对象将如何写入
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeToParcel</span><span class="token punctuation">(</span><span class="token class-name">Parcel</span> dest<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        dest<span class="token punctuation">.</span><span class="token function">writeString</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        dest<span class="token punctuation">.</span><span class="token function">writeFloat</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>Kotlin 实现 Parcelable 借口的方式更简洁，可以通过 Generator 中的插件自动生成，也可以通过 @Parcelize 注解生成：</p> 
<pre><code class="prism language-kotlin"><span class="token annotation builtin">@Parcelize</span>
<span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">CourseTest</span><span class="token punctuation">(</span><span class="token keyword">var</span> name<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">var</span> score<span class="token operator">:</span> Float<span class="token punctuation">)</span> <span class="token operator">:</span> Parcelable
</code></pre> 
<h3><a id="32__906"></a>3.2 理论知识</h3> 
<p>底层是通过 Parcel 先包装要传输的数据，然后在 Binder 中传输，也就是用于跨进程传输数据<br> 简单来说，Parcel 提供了一套机制，可以将序列化之后的数据写入到一个共享内存中，其他进程通过 Parcel 可以从这块共享内存中读出字节流，并反序列化成对象，下图是这个过程的模型：</p> 
<p><img src="https://images2.imgbox.com/d5/22/MBm12rR7_o.png" alt=""></p> 
<p>Parcel 可以包含原始数据类型（用各种对应的方法写入，比如 writeInt()、writeFloat() 等），可以包含 Parcelable 对象，它还包含了一个活动的 IBinder 对象的引用，这个引用导致另一端接收到一个指向这个 IBinder 的代理 IBinder。Parcelable 通过 Parcel 实现了 read 和 write 的方法，从而实现序列化和反序列化。</p> 
<p>一个简单的 Parcel 的使用示例：</p> 
<pre><code class="prism language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token comment">// 通过对象池拿到一个 Parcel 对象</span>
        <span class="token class-name">Parcel</span> writeParcel <span class="token operator">=</span> <span class="token class-name">Parcel</span><span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 填充数据</span>
        writeParcel<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        writeParcel<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 序列化，得到一个字节数组，IPC 操作就围绕这个数组</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> writeParcel<span class="token punctuation">.</span><span class="token function">marshall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Log</span><span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"Frank"</span><span class="token punctuation">,</span> <span class="token string">"byteArray = "</span> <span class="token operator">+</span> bytes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 8</span>

        <span class="token comment">// 数据写入完成之后，需要将指针调整到最初的位置</span>
        writeParcel<span class="token punctuation">.</span><span class="token function">setDataPosition</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 释放 writeParcel</span>
        writeParcel<span class="token punctuation">.</span><span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Parcel</span> readParcel <span class="token operator">=</span> <span class="token class-name">Parcel</span><span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 反序列化操作</span>
        readParcel<span class="token punctuation">.</span><span class="token function">unmarshall</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> bytes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> dataSize <span class="token operator">=</span> readParcel<span class="token punctuation">.</span><span class="token function">dataSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Log</span><span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"Frank"</span><span class="token punctuation">,</span> <span class="token string">"readParcel size = "</span> <span class="token operator">+</span> dataSize<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 8</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dataSize<span class="token punctuation">;</span> i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            readParcel<span class="token punctuation">.</span><span class="token function">setDataPosition</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Log</span><span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"Frank"</span><span class="token punctuation">,</span> <span class="token string">"value = "</span> <span class="token operator">+</span> readParcel<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 12 19</span>
        <span class="token punctuation">}</span>

        readParcel<span class="token punctuation">.</span><span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h3><a id="33_Parcelable__Serializable__950"></a>3.3 Parcelable 与 Serializable 比较</h3> 
<ol><li>在内存使用上，Serializable 在序列化过程中使用了反射机制会产生大量的临时变量导致频繁的 GC，而 Parcelable 以 IBinder 为信息载体，内存开销较小。</li><li>在读写数据上，Serializable 通过 IO 流的形式将数据写入到硬盘或者传输到网络上，而 Parcelable 是在内存中直接进行读写，所以速度较快。但是如果需要做数据持久化，还是要用 Serializable。（Parcelable 能转成 byte[]，那么实际上也就是能持久化。但是 Parcelable 主要还是在内存中用作客户端通信用。）</li></ol> 
<p>参考：<br> <a href="https://blog.csdn.net/jdsjlzx/article/details/109064067">Android中Parcelable的原理和使用方法</a><br> <a href="https://blog.csdn.net/rainbowchou/article/details/54294394">Android Parcel对象详解</a><br> <a href="https://segmentfault.com/a/1190000012440795" rel="nofollow">Kotlin 一个好用的新功能：Parcelize</a><br> <a href="https://www.bejson.com/json2javapojo/new" rel="nofollow">实用工具-JSON生成Java实体类</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1defc0b26bb04265732087f6a5764f1a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JVM 内存管理深度剖析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4c4b7930c5fc738c072c17bd82be6580/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深入理解对象与垃圾回收机制</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>