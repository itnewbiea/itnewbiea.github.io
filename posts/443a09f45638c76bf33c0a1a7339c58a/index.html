<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>hive学习笔记 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="hive学习笔记" />
<meta property="og:description" content="一、Hive基本概念 1.1 hive是什么 hive是基于hadoop的一个数仓分析工具，hive可以将hdfs上存储的结构化的数据，映射成一张表，然后让用户写HQL(类SQL)来分析数据
tel up down 1383838438 1345 1567 1383838439 5345 1567 1383838440 1241 16577 1383838441 3453 15757 1383838434 35355 1567567 按照手机号 分组，统计每个手机号的总流量
select tel,up&#43;down from test; hive的本质其实就是hadoop的一个客户端，hive底层不存储任何数据，hive表的数据存在hdfs上，hive表的元数据存在关系型数据库中
默认是derby，我们不一般不用默认的derby来存，一般都会修改为mysql。
元数据：描述数据的数据
Hive其实就是将用户写的HQL，给翻译成对应的mr模板，然后执行这些mr程序
hive底层执行引擎其实就是MapReduce，mr运行在yarn上
1.2 hive的优缺点 优点：操作简单，采用类sql的语法分析数据，门槛低，大大的降低了大数据分析的难度，通用性高
缺点：不够灵活，机翻粒度比较粗，调优困难。因为底层执行引擎还是mr，所以延迟较高，不能像关系型数据库那样，立马返回结果
并且底层存储是hdfs，不支持随机写，只能追加，所以hive不支持行级别的更新和删除（delete 和 update）
1.3 hive的架构原理 客户端：命令行客户端，jdbc客户端
数据存储：hdfs
底层执行引擎：mr
元数据库：hive将元数据默认存在derby中，我们一般在安装hive的时候，会修改成mysql
dirver四个器
解析器：将hql语句转换成AST抽象语法树，解析sql是否有误
编译器：将解析后的hql编译成逻辑执行计划，暂时不执行
优化器：对逻辑计划进行优化，调优
执行器：将优化后的逻辑计划执行，其实就是翻译成对应的mr程序，在yarn上运行
1.4 hive和关系型数据库对比 hive不是数据库，不是数据库，不是数据库
hive除了查询语言HQL跟SQL很像之外，别的跟数据库再也没有半点相似可言
数据更新 数据规模 执行延迟 底层引擎 数据存储
二、Hive安装 2.1 hive访问 1）通过hive自带的beeline客户端访问
beeline -u jdbc:hive2://hadoop102:10000 -n logcat hive脚本访问" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/443a09f45638c76bf33c0a1a7339c58a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-17T16:15:36+08:00" />
<meta property="article:modified_time" content="2023-02-17T16:15:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">hive学习笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h2 style="text-align:left;">一、Hive基本概念</h2> 
 <h3 style="text-align:left;">1.1 hive是什么</h3> 
 <p style="">hive是基于hadoop的一个数仓分析工具，hive可以将hdfs上存储的结构化的数据，映射成一张表，然后让用户写HQL(类SQL)来分析数据</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">   tel              up           down
1383838438         1345         1567
1383838439         5345         1567
1383838440         1241         16577
1383838441         3453         15757
1383838434         35355        1567567</code></pre> 
 <p style="">按照手机号 分组，统计每个手机号的总流量</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">select  tel,up+down from test; </code></pre> 
 <p style="">hive的本质其实就是hadoop的一个客户端，hive底层不存储任何数据，hive表的数据存在hdfs上，hive表的元数据存在关系型数据库中</p> 
 <p style="">默认是derby，我们不一般不用默认的derby来存，一般都会修改为mysql。</p> 
 <p style="">元数据：描述数据的数据</p> 
 <p style="">Hive其实就是将用户写的HQL，给翻译成对应的mr模板，然后执行这些mr程序</p> 
 <p style="">hive底层执行引擎其实就是MapReduce，mr运行在yarn上</p> 
 <h3 style="text-align:left;">1.2 hive的优缺点</h3> 
 <p style="">优点：操作简单，采用类sql的语法分析数据，门槛低，大大的降低了大数据分析的难度，通用性高</p> 
 <p style="">缺点：不够灵活，机翻粒度比较粗，调优困难。因为底层执行引擎还是mr，所以延迟较高，不能像关系型数据库那样，立马返回结果</p> 
 <p style="">并且底层存储是hdfs，不支持随机写，只能追加，所以hive不支持行级别的更新和删除（delete 和 update）</p> 
 <h3 style="text-align:left;">1.3 hive的架构原理</h3> 
 <p style="">客户端：命令行客户端，jdbc客户端</p> 
 <p style="">数据存储：hdfs</p> 
 <p style="">底层执行引擎：mr</p> 
 <p style="">元数据库：hive将元数据默认存在derby中，我们一般在安装hive的时候，会修改成mysql</p> 
 <p style="">dirver四个器</p> 
 <p style="">解析器：将hql语句转换成AST抽象语法树，解析sql是否有误</p> 
 <p style="">编译器：将解析后的hql编译成逻辑执行计划，暂时不执行</p> 
 <p style="">优化器：对逻辑计划进行优化，调优</p> 
 <p style="">执行器：将优化后的逻辑计划执行，其实就是翻译成对应的mr程序，在yarn上运行</p> 
 <h3 style="text-align:left;">1.4 hive和关系型数据库对比</h3> 
 <p style="">hive不是数据库，不是数据库，不是数据库</p> 
 <p style="">hive除了查询语言HQL跟SQL很像之外，别的跟数据库再也没有半点相似可言</p> 
 <p style="">数据更新 数据规模 执行延迟 底层引擎 数据存储</p> 
 <h2 style="text-align:left;">二、Hive安装</h2> 
 <h3 style="text-align:left;">2.1 hive访问</h3> 
 <p style="">1）通过hive自带的beeline客户端访问</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">beeline -u jdbc:hive2://hadoop102:10000 -n logcat</code></pre> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>hive脚本访问</p></li></ol> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">hive</code></pre> 
 <h3 style="text-align:left;">2.2 hive交互命令</h3> 
 <p style="">交互命令使用场景：在shell脚本里面不能人为的进入hive客户端交互写sql，所以要通过hive -e或者-f两个交互参数进行写入</p> 
 <p style="">1）hive -e</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">hive -e "select * from student"</code></pre> 
 <p style="">2）hive -f</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">hive -f stu.sql</code></pre> 
 <h3 style="text-align:left;">2.3 hive参数设置方式</h3> 
 <h4 style="text-align:left;">1 通过配置文件设置 （永久生效）</h4> 
 <p style="">在hive的家目录下面的conf文件夹下的hive-site.xml hive-env.sh hive-log4j2.properties</p> 
 <h4 style="text-align:left;">2 通过命令行参数来设置 （临时生效，只针对当前客户端连接）</h4> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">hive -hiveconf 参数名=参数值</code></pre> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">beeline -u jdbc:hive2://hadoop102:10000 -n logcat -hiveconf 参数名=参数值</code></pre> 
 <h4 style="text-align:left;">3 通过set命令设置（临时生效，只针对当前客户端连接）</h4> 
 <p style="">我们连接到hive的客户端以后，可以通过set语句来设置参数</p> 
 <p style="">查看所有参数设置</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">set;</code></pre> 
 <p style="">查看单个参数的值</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">set 参数名;</code></pre> 
 <p style="">设置单个参数的值</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">set 参数名=参数值;</code></pre> 
 <p style="">参数设置优先级：</p> 
 <p style="">hive-default.xml &lt; hive-site.xml &lt; -hiveconf 参数名=参数值 &lt; set 参数名=参数值</p> 
 <h2 style="text-align:left;">三、数据类型</h2> 
 <h3 style="text-align:left;">3.1 基本数据类型</h3> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:276px;vertical-align:top;height:52px;"><p style=""><span class="kdocs-bold" style="font-weight:bold;">HIVE</span></p></td><td class="kdocs-tableCell" style="width:245px;vertical-align:top;height:52px;"><p style=""><span class="kdocs-bold" style="font-weight:bold;">MySQL</span></p></td><td class="kdocs-tableCell" style="width:184px;vertical-align:top;height:52px;"><p style=""><span class="kdocs-bold" style="font-weight:bold;">JAVA</span></p></td><td class="kdocs-tableCell" style="width:175px;vertical-align:top;height:52px;"><p style=""><span class="kdocs-bold" style="font-weight:bold;">长度</span></p></td><td class="kdocs-tableCell" style="width:127px;vertical-align:top;height:52px;"><p style=""><span class="kdocs-bold" style="font-weight:bold;">例子</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:316px;vertical-align:top;height:52px;"><p style="">TINYINT</p></td><td class="kdocs-tableCell" style="width:270px;vertical-align:top;height:52px;"><p style="">TINYINT</p></td><td class="kdocs-tableCell" style="width:149px;vertical-align:top;height:52px;"><p style="">byte</p></td><td class="kdocs-tableCell" style="width:260px;vertical-align:top;height:52px;"><p style="">1byte有符号整数</p></td><td class="kdocs-tableCell" style="width:107px;vertical-align:top;height:52px;"><p style="">2</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:316px;vertical-align:top;height:52px;"><p style="">SMALINT</p></td><td class="kdocs-tableCell" style="width:270px;vertical-align:top;height:52px;"><p style="">SMALINT</p></td><td class="kdocs-tableCell" style="width:164px;vertical-align:top;height:52px;"><p style="">short</p></td><td class="kdocs-tableCell" style="width:260px;vertical-align:top;height:52px;"><p style="">2byte有符号整数</p></td><td class="kdocs-tableCell" style="width:107px;vertical-align:top;height:52px;"><p style="">20</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:256px;vertical-align:top;height:52px;"><p style="">INT</p></td><td class="kdocs-tableCell" style="width:210px;vertical-align:top;height:52px;"><p style="">INT</p></td><td class="kdocs-tableCell" style="width:149px;vertical-align:top;height:52px;"><p style="">int</p></td><td class="kdocs-tableCell" style="width:260px;vertical-align:top;height:52px;"><p style="">4byte有符号整数</p></td><td class="kdocs-tableCell" style="width:107px;vertical-align:top;height:52px;"><p style="">20</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:301px;vertical-align:top;height:52px;"><p style="">BIGINT</p></td><td class="kdocs-tableCell" style="width:255px;vertical-align:top;height:52px;"><p style="">BIGINT</p></td><td class="kdocs-tableCell" style="width:149px;vertical-align:top;height:52px;"><p style="">long</p></td><td class="kdocs-tableCell" style="width:260px;vertical-align:top;height:52px;"><p style="">8byte有符号整数</p></td><td class="kdocs-tableCell" style="width:107px;vertical-align:top;height:52px;"><p style="">20</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:316px;vertical-align:top;height:52px;"><p style="">BOOLEAN</p></td><td class="kdocs-tableCell" style="width:180px;vertical-align:top;height:52px;"><p style="">无</p></td><td class="kdocs-tableCell" style="width:179px;vertical-align:top;height:52px;"><p style="">boolean</p></td><td class="kdocs-tableCell" style="width:320px;vertical-align:top;height:52px;"><p style="">布尔类型，true或者false</p></td><td class="kdocs-tableCell" style="width:242px;vertical-align:top;height:52px;"><p style="">TRUE FALSE</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:286px;vertical-align:top;height:52px;"><p style="">FLOAT</p></td><td class="kdocs-tableCell" style="width:240px;vertical-align:top;height:52px;"><p style="">FLOAT</p></td><td class="kdocs-tableCell" style="width:164px;vertical-align:top;height:52px;"><p style="">float</p></td><td class="kdocs-tableCell" style="width:230px;vertical-align:top;height:52px;"><p style="">单精度浮点数</p></td><td class="kdocs-tableCell" style="width:152px;vertical-align:top;height:52px;"><p style="">3.14159</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:301px;vertical-align:top;height:52px;"><p style="">DOUBLE</p></td><td class="kdocs-tableCell" style="width:255px;vertical-align:top;height:52px;"><p style="">DOUBLE</p></td><td class="kdocs-tableCell" style="width:164px;vertical-align:top;height:52px;"><p style="">double</p></td><td class="kdocs-tableCell" style="width:230px;vertical-align:top;height:52px;"><p style="">双精度浮点数</p></td><td class="kdocs-tableCell" style="width:152px;vertical-align:top;height:52px;"><p style="">3.14159</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:301px;vertical-align:top;height:52px;"><p style="">STRING</p></td><td class="kdocs-tableCell" style="width:270px;vertical-align:top;height:52px;"><p style="">VARCHAR</p></td><td class="kdocs-tableCell" style="width:164px;vertical-align:top;height:52px;"><p style="">string</p></td><td class="kdocs-tableCell" style="width:530px;vertical-align:top;height:52px;"><p style="">字符系列。可以指定字符集。可以使用单引号或者双引号。</p></td><td class="kdocs-tableCell" style="width:482px;vertical-align:top;height:52px;"><p style="">‘now is the time’ “for all good men”</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:346px;vertical-align:top;height:52px;"><p style="">TIMESTAMP</p></td><td class="kdocs-tableCell" style="width:300px;vertical-align:top;height:52px;"><p style="">TIMESTAMP</p></td><td class="kdocs-tableCell" style="width:144px;vertical-align:top;height:52px;"><p style=""></p></td><td class="kdocs-tableCell" style="width:200px;vertical-align:top;height:52px;"><p style="">时间类型</p></td><td class="kdocs-tableCell" style="width:117px;vertical-align:top;height:52px;"><p style=""></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:301px;vertical-align:top;height:52px;"><p style="">BINARY</p></td><td class="kdocs-tableCell" style="width:255px;vertical-align:top;height:52px;"><p style="">BINARY</p></td><td class="kdocs-tableCell" style="width:144px;vertical-align:top;height:52px;"><p style=""></p></td><td class="kdocs-tableCell" style="width:200px;vertical-align:top;height:52px;"><p style="">字节数组</p></td><td class="kdocs-tableCell" style="width:117px;vertical-align:top;height:52px;"><p style=""></p></td></tr></tbody></table> 
 </div> 
 <p style="">利用基本数据类型建表测试</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">create table test(id int,weight double,name string,money bigint);</code></pre> 
 <p style="">利用insert语句按照指定的数据类型插入一条数据</p> 
 <pre class="kdocs-sql"><code class="language-sql">insert into test values(1001,75,"zhangsan",1000000000000);</code></pre> 
 <h3 style="text-align:left;">3.2 集合数据类型</h3> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:180px;vertical-align:top;height:52px;"><p style=""><span class="kdocs-bold" style="font-weight:bold;">数据类型</span></p></td><td class="kdocs-tableCell" style="width:401px;vertical-align:top;height:52px;"><p style=""><span class="kdocs-bold" style="font-weight:bold;">描述</span></p></td><td class="kdocs-tableCell" style="width:413px;vertical-align:top;height:52px;"><p style=""><span class="kdocs-bold" style="font-weight:bold;">语法示例</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:205px;vertical-align:top;height:52px;"><p style="">STRUCT</p></td><td class="kdocs-tableCell" style="width:1776px;vertical-align:top;height:52px;"><p style="">和c语言中的struct类似，都可以通过“点”符号访问元素内容。例如，如果某个列的数据类型是STRUCT{first STRING, last STRING},那么第1个元素可以通过字段.first来引用。2</p></td><td class="kdocs-tableCell" style="width:828px;vertical-align:top;height:52px;"><p style="">struct() 例如 struct&lt;street:string, city:string&gt;</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:160px;vertical-align:top;height:52px;"><p style="">MAP</p></td><td class="kdocs-tableCell" style="width:1881px;vertical-align:top;height:52px;"><p style="">MAP是一组键-值对元组集合，使用数组表示法可以访问数据。例如，如果某个列的数据类型是MAP，其中键-&gt;值对是’first’-&gt;’John’和’last’-&gt;’Doe’，那么可以通过字段名[‘last’]获取最后一个元素</p></td><td class="kdocs-tableCell" style="width:618px;vertical-align:top;height:52px;"><p style="">map() 例如map&lt;string, int&gt;</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:190px;vertical-align:top;height:52px;"><p style="">ARRAY</p></td><td class="kdocs-tableCell" style="width:1791px;vertical-align:top;height:52px;"><p style="">数组是一组具有相同类型和名称的变量的集合。这些变量称为数组的元素，每个数组元素都有一个编号，编号从零开始。例如，数组值为[‘John’, ‘Doe’]，那么第2个元素可以通过数组名[1]进行引用。</p></td><td class="kdocs-tableCell" style="width:603px;vertical-align:top;height:52px;"><p style="">Array() 例如array</p></td></tr></tbody></table> 
 </div> 
 <p style="">测试数据</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">songsong,bingbing_lili,xiao song:18_xiaoxiao song:19,hui long guan_beijing_10010
yangyang,caicai_susu,xiao yang:18_xiaoxiao yang:19,chao yang_beijing_10011</code></pre> 
 <p style="">在hive中建表描述上述数据</p> 
 <pre class="kdocs-sql"><code class="language-sql">create table person(
name string,
friends array&lt;string&gt;,
children map&lt;string,int&gt;,
address struct&lt;street:string,city:string,email:int&gt;
)
row format delimited fields terminated by ','
collection items terminated by '_'
map keys terminated by ':'
lines terminated by '\n';</code></pre> 
 <p style="">加载数据</p> 
 <pre class="kdocs-sql"><code class="language-sql">load data local inpath '/opt/module/hive/datas/person.txt' into table person;</code></pre> 
 <p style="">查询数据</p> 
 <pre class="kdocs-sql"><code class="language-sql">select * from person;</code></pre> 
 <p style="">查出来songsong 这个人的姓名，第一个朋友，孩子xiaoxiao song的年龄，和他的邮编</p> 
 <pre class="kdocs-sql"><code class="language-sql">select name, friends[0],children['xiaoxiao song'],address.email from person where name = "songsong";</code></pre> 
 <pre class="kdocs-sql"><code class="language-sql">select name, friends[1],children['xiao song'],address.street from person;</code></pre> 
 <h3 style="text-align:left;">3.3 类型转换</h3> 
 <p style="">1）隐式（自动）类型转换</p> 
 <p style="">（1）任何整数类型都可以隐式地转换为一个范围更广的类型，如TINYINT可以转换成INT，INT可以转换成BIGINT。</p> 
 <p style="">（2）所有整数类型、FLOAT和STRING类型都可以隐式地转换成DOUBLE。</p> 
 <p style="">（3）TINYINT、SMALLINT、INT都可以转换为FLOAT。</p> 
 <p style="">（4）BOOLEAN类型不可以转换为任何其它的类型。</p> 
 <p style="">2）显示（强制）类型转换</p> 
 <p style=""> CAST( vlaue AS type)</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">例如：select * from cast('1' as int) + 2;</code></pre> 
 <h2 style="text-align:left;">四、DDL数据定义语言</h2> 
 <h3 style="text-align:left;">4.1 库的DDL</h3> 
 <h4 style="text-align:left;">1 创建数据库</h4> 
 <pre class="kdocs-sql"><code class="language-sql">CREATE DATABASE [IF NOT EXISTS] database_name        --指定数据库名称
[COMMENT database_comment]                           --指定数据库描述
[LOCATION hdfs_path]                                 --指定创建的数据库在hdfs上存储的路径
[WITH DBPROPERTIES (property_name=property_value, ...)];   --指定库的一些属性</code></pre> 
 <p style="">案例实操</p> 
 <pre class="kdocs-sql"><code class="language-sql">create database if not exists db_hive
comment "this is my first db"
with dbproperties ("name"="db_hive","owner"="logcat");

create database if not exists db_hive;

--创建数据库，并指定在hdfs上的路径
create database if not exists db_hive2
location '/db_hive2';
</code></pre> 
 <h4 style="text-align:left;">2 查询数据库</h4> 
 <pre class="kdocs-sql"><code class="language-sql">show databases；</code></pre> 
 <h4 style="text-align:left;">3 查看数据库详情</h4> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">--简单查看
desc database 数据库名;
--详细查看 （详细查看可以看到库的属性信息，简单查看看不到）
desc database extended 数据库名;</code></pre> 
 <h4 style="text-align:left;">4 切换数据库</h4> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">use 数据库名;</code></pre> 
 <h4 style="text-align:left;">5修改数据库</h4> 
 <p style="">只能修改数据库的属性信息，别的都无法更改。例如：库名，库的存储位置等元数据信息无法更改</p> 
 <pre class="kdocs-sql"><code class="language-sql">alter database db_hive set dbproperties('createtime'='20200624');</code></pre> 
 <h4 style="text-align:left;">6删除数据库</h4> 
 <p style="">注意：删除掉数据库以后，hdfs上对应的目录也会删除，谨慎操作。</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">drop database 数据库名 cascade;

--如果数据库不为空，可以在最后加上cascade强制删除
drop database 数据库名 cascade;

--为了更严谨，我们可以在删除之前判断数据库是否存在
drop database if exists 数据库名 cascade;</code></pre> 
 <h3 style="text-align:left;">4.2表的DDL</h3> 
 <h4 style="text-align:left;">1创建表</h4> 
 <pre class="kdocs-sql"><code class="language-sql">CREATE [EXTERNAL] TABLE [IF NOT EXISTS] table_name          --指定表名  【external 外部表/内部表】
[(col_name data_type [COMMENT col_comment], ...)]           --指定表的列名，列类型 【列描述】
[COMMENT table_comment]                                     --指定表的描述
[PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)]  --指定分区表的分区字段（分区字段可以是多个）
[CLUSTERED BY (col_name, col_name, ...)     --指定分桶表的分桶字段  
[SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS]  --指定分桶表桶内排序字段   指定分桶的个数
[ROW FORMAT DELIMITED      --指定hive表在hdfs上存储的原始数据的格式
 [FIELDS TERMINATED BY char]     --每行数据中字段的分隔符  ascII码表的第一个字符  ^A 
 [COLLECTION ITEMS TERMINATED BY char]   --集合元素分隔符  ascII码表的第二个字符  ^B
 [MAP KEYS TERMINATED BY char]  --map集合中 key 和 value 的分隔符    ascII码表的第三个字符  ^C
 [LINES TERMINATED BY char]      --每行数据的分隔符     默认值：'\n'
]  
[STORED AS file_format]         --指定hive的数据在hdfs上存储的格式
[LOCATION hdfs_path]            --指定hive数据在hdfs上存储的路径  默认值 /user/hive/warehouse/数据库名
[TBLPROPERTIES (property_name=property_value, ...)]    --指定表的属性
[AS select_statement]    --按照as后面的查询语句的结果来创建表，复制表结构以及表数据
[LIKE table_name]     --按照like后面的表结构来创建表，只复制表结构，不复制表数据</code></pre> 
 <h4 style="text-align:left;">2 管理表和外部表</h4> 
 <p style="">管理表（内部表）：hive掌控者这个数据的生命周期，如果删除一个管理表，hdfs上存储的数据也跟着一起删除。所以一般我们创建管理表时，一般不会再location表的存储路径，就默认放在/user/hive/warehouse下</p> 
 <p style="">外部表：hive不完全掌控外部表的数据的生命周期，删除外部表，只删除hive表的元数据，不会删除掉hdfs上存储的数据</p> 
 <p style="">一般外部表都是先有的hdfs上的数据，然后我们创建一个外部表，手动指定这个外部表的存储路径</p> 
 <h4 style="text-align:left;">3 创建管理表</h4> 
 <pre class="kdocs-sql"><code class="language-sql">create table student(
id int,name string
)
row format delimited fields terminated by '\t';

create table student2(
id int,name string
);
--根据AS select语句查询结构创建表,复制表结构，复制表数据
create table student3 as select * from student;

--根据like 创建表，只复制表结构，不复制表数据
create table student4 like student;
</code></pre> 
 <p style="">查看表信息</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">--简单查看表信息
desc 表名;

--详细查看表信息
desc formatted 表名;</code></pre> 
 <p style="">删除管理表</p> 
 <p style="">注意：删除管理表同时会删除hdfs上对应目录的数据，谨慎操作，数据无价</p> 
 <pre class="kdocs-sql"><code class="language-sql">drop table student3;</code></pre> 
 <h4 style="text-align:left;">4 创建外部表</h4> 
 <p style="">注意：外部表创建时要加external，外部表的好处就是，删除表的时候，只删除表的元数据信息，不删hdfs上存储的数据，更安全。</p> 
 <p style="">建表语句</p> 
 <pre class="kdocs-sql"><code class="language-sql">create external table if not exists dept(
deptno int,
dname string,
loc int
)
row format delimited fields terminated by '\t'
location '/company/dept';

create external table if not exists emp(
empno int,
ename string,
job string,
mgr int,
hiredate string, 
sal double, 
comm double,
deptno int)
row format delimited fields terminated by '\t'
location '/company/emp';

</code></pre> 
 <h4 style="text-align:left;">5 外部表和内部表的转换</h4> 
 <p style="">通过设置表属性“EXTERNAL”来控制表是外部表还是内部表</p> 
 <p style="">TRUE 是 外部表 FALSE 是内部表</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">alter table student set tblproperties('EXTERNAL'='TRUE/FALSE');</code></pre> 
 <h4 style="text-align:left;">6修改表</h4> 
 <p style="">重名表 注意：重命名表会一起修改hdfs上对应的目录名，前提这个表必须是管理表，并且创建这个管理表时没有自定义location</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">ALTER TABLE table_name RENAME TO new_table_name</code></pre> 
 <p style="">更新列</p> 
 <p style="">更新列，列名可以随意修改，列的类型只能小改大，不能大改小（遵循自动转换规则）</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">ALTER TABLE table_name CHANGE [COLUMN] col_old_name col_new_name column_type [COMMENT col_comment] [FIRST|AFTER column_name]</code></pre> 
 <p style="">增加列</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">ALTER TABLE table_name ADD COLUMNS (col_name data_type [COMMENT col_comment], ...) </code></pre> 
 <p style="">替换列</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">ALTER TABLE table_name REPLACE COLUMNS (col_name data_type [COMMENT col_comment], ...) </code></pre> 
 <h4 style="text-align:left;">7清空表</h4> 
 <p style="">注意：只能truncate 管理表，外部表不能truncate。truncate的本质其实就是删除hdfs上对应路径的数据。</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">truncate table 表名;</code></pre> 
 <h3 style="text-align:left;">五 DML数据操作</h3> 
 <h4 style="text-align:left;">5.1 导入</h4> 
 <h4 style="text-align:left;">5.1.1 load</h4> 
 <h4 style="text-align:left;">1 通过load命令加载数据</h4> 
 <pre class="kdocs-sql"><code class="language-sql">load data [local] inpath '数据的path' [overwrite] into table student [partition (partcol1=val1,…)];</code></pre> 
 <h4 style="text-align:left;">2 通过本地方式导入</h4> 
 <p style="">注意：通过本地路径load，本质上其实就是将本地的文件put到hdfs对应的表目录</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">load data local inpath '/opt/module/hive/datas/student.txt' overwrite into table student;</code></pre> 
 <h4 style="text-align:left;">3通过hdfs路径导入</h4> 
 <p style="">注意：通过hdfs路径导入，本质是将hdfs上路径的数据剪切到对应的表的hdfs路径</p> 
 <pre class="kdocs-sql"><code class="language-sql">load data inpath '/student.txt' into table student;</code></pre> 
 <h4 style="text-align:left;">4 覆盖导入</h4> 
 <p style="">注意:加上关键字overwrite 就是覆盖导入，不加的话，默认是追加导入</p> 
 <pre class="kdocs-sql"><code class="language-sql">load data local inpath '/opt/module/hive/datas/student.txt' overwrite into table student;</code></pre> 
 <h4 style="text-align:left;">5.1.2 insert</h4> 
 <h5 style="text-align:left;">1) 基本模式插入</h5> 
 <p style="">into是追加插入，overwrite是覆盖插入，此方式一般没人用</p> 
 <pre class="kdocs-sql"><code class="language-sql">insert into/overwrite table student values(1018,'ss18'),(1019,'ss19');</code></pre> 
 <h5 style="text-align:left;">2）通过查询结果插入</h5> 
 <p style="">此方式用的比较多，一般都是查询原始表的数据到临时表，注意select之前不能加as，跟创建表时as select区分开</p> 
 <pre class="kdocs-sql"><code class="language-sql">insert into table student2  select * from student where id &lt; 1006;
insert overwrite table student2  select * from student where id &lt; 1006;</code></pre> 
 <p style="">注意：通过inset插入数据，数据格式和列的数量要一致才可以。</p> 
 <h4 style="text-align:left;">5.1.3 建表语句后+ as select</h4> 
 <p style="">注意：建表语句后跟select语句时，as不能省略，跟上面的insert into刚好相反</p> 
 <pre class="kdocs-sql"><code class="language-sql">create table student3 as  select * from student;</code></pre> 
 <h5 style="text-align:left;">5.1.4 建表指定location位置</h5> 
 <p style="">提前把数据传到hdfs上，然后创建表的时候，指定表的位置为数据的路径</p> 
 <p style="">注意 location后面一定要给一个目录，不能直接给文件路径。</p> 
 <pre class="kdocs-sql"><code class="language-sql">create table student5(
id int,name string
)
row format delimited fields terminated by '\t'
location '/student';</code></pre> 
 <h5 style="text-align:left;">5.1.5 import导入</h5> 
 <p style="">注意：使用import导入之前，得使用export导出数据，并且因为export会把数据和元数据一起导出，所以我们使用import导入的时候，表不能存在，否则会元数据冲突，报错。</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">import table student6  from '/stu';</code></pre> 
 <h3 style="text-align:left;">5.2 数据导出</h3> 
 <h4 style="text-align:left;">5.2.1 insert 导出</h4> 
 <p style="">无格式导出</p> 
 <pre class="kdocs-sql"><code class="language-sql">insert overwrite local directory '/opt/module/hive/datas/export/student'
select * from student;</code></pre> 
 <p style="">格式化导出</p> 
 <pre class="kdocs-sql"><code class="language-sql">insert overwrite local directory '/opt/module/hive/datas/export/student2'
ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t'
select * from student;</code></pre> 
 <p style="">注意：因为insert导出，后面只能跟overwrite，所以我们给路径的时候，一定要具体，防止hive误删重要文件、</p> 
 <p style="">这个导出路径可以不存在，hive会帮我们创建路径</p> 
 <h5 style="text-align:left;">5.2.2hadoop命令导出</h5> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">hadoop dfs -get /user/hive/warehouse/student/student.txt
/opt/module/hive/datas/export/student3.txt;</code></pre> 
 <h5 style="text-align:left;">5.2.3hive shell 命令导出</h5> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">hive -e 'select * from db_hive.student' &gt; /opt/module/hive/datas/stu.txt</code></pre> 
 <h5 style="text-align:left;">5.2.4 export 导出</h5> 
 <p style="">注意;export导出只能导出到hdfs上，并且会将元数据和数据一起导出。</p> 
 <pre class="kdocs-sql"><code class="language-sql">export table db_hive.student to '/stu';</code></pre> 
 <h2 style="text-align:left;">六 查询DQL</h2> 
 <pre class="kdocs-sql"><code class="language-sql">SELECT [ALL | DISTINCT] select_expr, select_expr, ...     --指定查询字段
  FROM table_reference                                    --从哪个表查询
  [WHERE where_condition]                                --指定where过滤条件
  [GROUP BY col_list]                                   --指定分组条件
  [ORDER BY col_list]                                 --指定排序条件
  [CLUSTER BY col_list    
    | [DISTRIBUTE BY col_list] [SORT BY col_list]        --hive排序四个by
  ]
 [LIMIT number]                      --限制输出结果条数</code></pre> 
 <h3 style="text-align:left;">6.1 基本查询</h3> 
 <h3 style="text-align:left;">6.2 分组查询</h3> 
 <h3 style="text-align:left;">6.3 join关联查询</h3> 
 <h3 style="text-align:left;">6.4 排序</h3> 
 <h3 style="text-align:left;">1 全局排序 order by</h3> 
 <p style="">Order By：全局排序，只有一个Reducer，把所有数据都放在一个分区里面进行排序，这样才能保证输出的结果集是全局有序的。</p> 
 <p style="">ASC（ascend）: 升序（默认）</p> 
 <p style="">DESC（descend）: 降序</p> 
 <p style="">按照多个列，双重排序</p> 
 <pre class="kdocs-sql"><code class="language-sql">--按照部门降序和工资升序排序
select deptno,sal,empno,ename,job from emp order by deptno DESC ,sal asc ;</code></pre> 
 <h3 style="text-align:left;">2 单个reducer排序 sort by</h3> 
 <p style="">注意：因为单独使用sort by的话，只能给每个分区内的数据排序，但是不能指定分区内的数据都有哪些，属于随机给数据分配分区</p> 
 <p style="">因此没人会单独使用sort by来排序，因为出来的结果集没有意义</p> 
 <h3 style="text-align:left;">3 分区 distribute by</h3> 
 <p style="">指定分区字段，一般在sort by之前都会加上 distribute by</p> 
 <h3 style="text-align:left;">4 分区排序 Cluster by</h3> 
 <p style="">cluster by属于 distribute by + sort by的结合，但是前提是 分区字段和排序字段是同一个的时候，才可以替换。并且排序只能升序排，不能再指定desc和asc</p> 
 <pre class="kdocs-sql"><code class="language-sql">select * from emp distribute by deptno sort by deptno;
--上面的sql可以简写成下面的
select * from emp cluster by deptno;</code></pre> 
 <h2 style="text-align:left;">七 分区表 分桶表</h2> 
 <h3 style="text-align:left;">7.1分区表</h3> 
 <p style="">hive存在问题：hive里面没有索引机制，每次查询的时候，hive会暴力扫描整张表。</p> 
 <p style="">分区表的本质就是分目录，按照业务需求，把数据分成多个目录存储，然后查询的时候就可以通过where条件指定对应的分区</p> 
 <h4 style="text-align:left;">创建分区表语法</h4> 
 <pre class="kdocs-sql"><code class="language-sql">create table dept_partition(
deptno int, dname string, loc string
)
partitioned by (day string)
row format delimited fields terminated by '\t';</code></pre> 
 <p style="">分区字段属于分区表的一个伪列，数据里面并没有记录这列的值，分区字段的值体现在分区目录名上面。</p> 
 <h4 style="text-align:left;">往分区表里正常load数据，一定要指定分区</h4> 
 <pre class="kdocs-sql"><code class="language-sql">load data local inpath '/opt/module/hive/datas/dept_20200401.log' into table dept_partition partition(day='20200401');</code></pre> 
 <h4 style="text-align:left;">分区表查询数据</h4> 
 <pre class="kdocs-sql"><code class="language-sql">select * from dept_partition where day = '20200401';


select * from dept_partition where day='20200401'
union
select * from dept_partition where day='20200402'
union
select * from dept_partition where day='20200403';

select * from dept_partition where day = '20200401' or day = '20200402';</code></pre> 
 <h4 style="text-align:left;">查看分区表有多少分区</h4> 
 <pre class="kdocs-sql"><code class="language-sql">show partitions dept_partition;</code></pre> 
 <h4 style="text-align:left;">删除分区</h4> 
 <p style="">注意：删除分区会一起删除掉分区内的数据</p> 
 <pre class="kdocs-sql"><code class="language-sql">alter table dept_partition drop partition (day='__HIVE_DEFAULT_PARTITION__');
--删除多个分区  注意：多个分区间必须有逗号，没有会报错
alter table dept_partition drop partition(day='20200405'),partition(day='20200406');</code></pre> 
 <h4 style="text-align:left;">增加分区</h4> 
 <pre class="kdocs-sql"><code class="language-sql"> alter table dept_partition add partition(day='20200404') ;
 --增加多个分区  注意：多个分区间不能逗号，有会报错
 alter table dept_partition add partition(day='20200405') partition(day='20200406');</code></pre> 
 <h4 style="text-align:left;">查看分区表信息</h4> 
 <pre class="kdocs-sql"><code class="language-sql">desc formatted dept_partition;</code></pre> 
 <h3 style="text-align:left;">7.2 二级分区表</h3> 
 <h4 style="text-align:left;">创建二级分区表</h4> 
 <pre class="kdocs-sql"><code class="language-sql">create table dept_partition2(
deptno int, dname string, loc string
)
partitioned by (day string, hour string)
row format delimited fields terminated by '\t';</code></pre> 
 <h4 style="text-align:left;">给二级分区正常加载数据</h4> 
 <pre class="kdocs-sql"><code class="language-sql">load data local inpath '/opt/module/hive/datas/dept_20200401.log' 
into table dept_partition2 
partition(day='20200401',hour='12');</code></pre> 
 <h4 style="text-align:left;">给二级分区增加分区</h4> 
 <pre class="kdocs-sql"><code class="language-sql">alter table dept_partition2 add partition(day='20200403',hour='01') partition(day='20200403',hour = '02');</code></pre> 
 <h4 style="text-align:left;">给二级分区删除分区</h4> 
 <pre class="kdocs-sql"><code class="language-sql">alter table dept_partition2 drop partition(day='20200403',hour='01'),partition(day='20200403',hour = '02');</code></pre> 
 <h4 style="text-align:left;">分区表和元数据对应三种方式</h4> 
 <h5 style="text-align:left;">1 先上传 再修复表</h5> 
 <pre class="kdocs-sql"><code class="language-sql">msck repair table dept_partition2;</code></pre> 
 <h5 style="text-align:left;">2 先上传数据，然后手动添加分区</h5> 
 <h5 style="text-align:left;">3 直接load load数据的时候直接指定分区字段的值，这个时候不仅会上传数据，还会创建对应的分区</h5> 
 <h3 style="text-align:left;">7.3 分桶表</h3> 
 <h4 style="text-align:left;">创建分桶表</h4> 
 <pre class="kdocs-sql"><code class="language-sql">create table stu_buck(id int, name string)
clustered by(id) 
into 4 buckets
row format delimited fields terminated by '\t';</code></pre> 
 <h4 style="text-align:left;">查看分桶表信息</h4> 
 <pre class="kdocs-sql"><code class="language-sql">desc formatted stu_buck;</code></pre> 
 <h3 style="text-align:left;">八 函数</h3> 
 <p style="">查看系统自带函数</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">show functions;</code></pre> 
 <p style="">查看函数具体用法</p> 
 <pre class="kdocs-sql"><code class="language-sql">desc function extended upper;</code></pre> 
 <h4 style="text-align:left;">1 空字段赋值 NVL</h4> 
 <p style="">将null值转换成我们想要的值</p> 
 <pre class="kdocs-sql"><code class="language-sql">select sal,comm,sal+ NVL(comm,0) money from emp;

select ename,job,sal,mgr,comm,NVL(comm,mgr) from emp;</code></pre> 
 <h4 style="text-align:left;">2 CASE WHEN</h4> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:55px;vertical-align:top;height:52px;"><p style=""><span class="kdocs-bold" style="font-weight:bold;">name</span></p></td><td class="kdocs-tableCell" style="width:85px;vertical-align:top;height:52px;"><p style=""><span class="kdocs-bold" style="font-weight:bold;">dept_id</span></p></td><td class="kdocs-tableCell" style="width:55px;vertical-align:top;height:52px;"><p style=""><span class="kdocs-bold" style="font-weight:bold;">sex</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:50px;vertical-align:top;height:52px;"><p style="">悟空</p></td><td class="kdocs-tableCell" style="width:35px;vertical-align:top;height:52px;"><p style="">A</p></td><td class="kdocs-tableCell" style="width:35px;vertical-align:top;height:52px;"><p style="">男</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:50px;vertical-align:top;height:52px;"><p style="">大海</p></td><td class="kdocs-tableCell" style="width:35px;vertical-align:top;height:52px;"><p style="">A</p></td><td class="kdocs-tableCell" style="width:35px;vertical-align:top;height:52px;"><p style="">男</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:50px;vertical-align:top;height:52px;"><p style="">宋宋</p></td><td class="kdocs-tableCell" style="width:35px;vertical-align:top;height:52px;"><p style="">B</p></td><td class="kdocs-tableCell" style="width:35px;vertical-align:top;height:52px;"><p style="">男</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:50px;vertical-align:top;height:52px;"><p style="">凤姐</p></td><td class="kdocs-tableCell" style="width:35px;vertical-align:top;height:52px;"><p style="">A</p></td><td class="kdocs-tableCell" style="width:35px;vertical-align:top;height:52px;"><p style="">女</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:50px;vertical-align:top;height:52px;"><p style="">婷姐</p></td><td class="kdocs-tableCell" style="width:35px;vertical-align:top;height:52px;"><p style="">B</p></td><td class="kdocs-tableCell" style="width:35px;vertical-align:top;height:52px;"><p style="">女</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:50px;vertical-align:top;height:52px;"><p style="">婷婷</p></td><td class="kdocs-tableCell" style="width:35px;vertical-align:top;height:52px;"><p style="">B</p></td><td class="kdocs-tableCell" style="width:35px;vertical-align:top;height:52px;"><p style="">女</p></td></tr></tbody></table> 
 </div> 
 <p style="">期望结果 求出不同部门男女各多少人</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">dept_Id     男       女
A     		2       1
B     		1       2</code></pre> 
 <p style="">分析过程</p> 
 <p style="">第一步：先求出每个部门有多少人</p> 
 <pre class="kdocs-sql"><code class="language-sql">select
	dept_id,
	sum(1)
from  emp_sex
group by   dept_id ;</code></pre> 
 <p style="">第二步：求出每个部门男女各多少人</p> 
 <pre class="kdocs-sql"><code class="language-sql">select
	dept_id,
	sum(case sex when '男' then 1 else 0 end) man,
	sum(case sex when '女' then 1 else 0 end) woman
from  emp_sex
group by   dept_id ;</code></pre> 
 <h4 style="text-align:left;">3 行转列 多行转一列</h4> 
 <h5 style="text-align:left;">相关函数</h5> 
 <p style="">CONCAT(string A/col, string B/col…)：返回输入字符串连接后的结果，支持任意个输入字符串;</p> 
 <p style="">CONCAT_WS(separator, str1, str2,...)：它是一个特殊形式的 CONCAT()。第一个参数剩余参数间的分隔符。分隔符可以是与剩余参数一样的字符串。如果分隔符是 NULL，返回值也将为 NULL。这个函数会跳过分隔符参数后的任何 NULL 和空字符串。分隔符将被加到被连接的字符串之间;</p> 
 <p style="">注意：CONCAT_WS must be "string or array "</p> 
 <p style="">COLLECT_SET(col)：函数只接受基本数据类型，它的主要作用是将某字段的值进行去重汇总，产生array类型字段。</p> 
 <p style="">COLLECT_LIST(col)：函数只接受基本数据类型，它的主要作用是将某字段的值进行不去重汇总，产生array类型字段。</p> 
 <p style="">原始数据</p> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:295px;vertical-align:top;height:52px;"><p style=""><span class="kdocs-bold" style="font-weight:bold;">name</span></p></td><td class="kdocs-tableCell" style="width:130px;vertical-align:top;height:52px;"><p style=""><span class="kdocs-bold" style="font-weight:bold;">constellation</span></p></td><td class="kdocs-tableCell" style="width:371px;vertical-align:top;height:52px;"><p style=""><span class="kdocs-bold" style="font-weight:bold;">blood_type</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:305px;vertical-align:top;height:52px;"><p style="">孙悟空</p></td><td class="kdocs-tableCell" style="width:65px;vertical-align:top;height:52px;"><p style="">白羊座</p></td><td class="kdocs-tableCell" style="width:291px;vertical-align:top;height:52px;"><p style="">A</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:290px;vertical-align:top;height:52px;"><p style="">大海</p></td><td class="kdocs-tableCell" style="width:65px;vertical-align:top;height:52px;"><p style="">射手座</p></td><td class="kdocs-tableCell" style="width:291px;vertical-align:top;height:52px;"><p style="">A</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:290px;vertical-align:top;height:52px;"><p style="">宋宋</p></td><td class="kdocs-tableCell" style="width:65px;vertical-align:top;height:52px;"><p style="">白羊座</p></td><td class="kdocs-tableCell" style="width:291px;vertical-align:top;height:52px;"><p style="">B</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:305px;vertical-align:top;height:52px;"><p style="">猪八戒</p></td><td class="kdocs-tableCell" style="width:65px;vertical-align:top;height:52px;"><p style="">白羊座</p></td><td class="kdocs-tableCell" style="width:291px;vertical-align:top;height:52px;"><p style="">A</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:290px;vertical-align:top;height:52px;"><p style="">凤姐</p></td><td class="kdocs-tableCell" style="width:65px;vertical-align:top;height:52px;"><p style="">射手座</p></td><td class="kdocs-tableCell" style="width:291px;vertical-align:top;height:52px;"><p style="">A</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:305px;vertical-align:top;height:52px;"><p style="">苍老师</p></td><td class="kdocs-tableCell" style="width:65px;vertical-align:top;height:52px;"><p style="">白羊座</p></td><td class="kdocs-tableCell" style="width:291px;vertical-align:top;height:52px;"><p style="">B</p></td></tr></tbody></table> 
 </div> 
 <p style="">需求 把星座和血型一样的人归类到一起</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">射手座,A            大海|凤姐
白羊座,A            孙悟空|猪八戒
白羊座,B            宋宋|苍老师</code></pre> 
 <p style="">实现：</p> 
 <pre class="kdocs-sql"><code class="language-sql">SELECT 
	t1.c_b,
	concat_ws('|',COLLECT_LIST(t1.name))
FROM 
(
	select 
		name,
		concat_ws(',',constellation,blood_type) c_b 
	from person_info
) t1
group by t1.c_b;</code></pre> 
 <h4 style="text-align:left;">4 列转行 一列转多行</h4> 
 <h5 style="text-align:left;">相关函数</h5> 
 <p style="">Split(str, separator)：将字符串按照后面的分隔符切割，转换成字符array。</p> 
 <p style="">EXPLODE(col)：将hive一列中复杂的array或者map结构拆分成多行。</p> 
 <p style="">LATERAL VIEW</p> 
 <p style="">用法：LATERAL VIEW udtf(expression) tableAlias AS columnAlias</p> 
 <p style="">解释：lateral view用于和split, explode等UDTF一起使用，它能够将一行数据拆成多行数据，在此基础上可以对拆分后的数据进行聚合。</p> 
 <p style="">lateral view首先为原始表的每行调用UDTF，UTDF会把一行拆分成一或者多行，lateral view再把结果组合，产生一个支持别名表的虚拟表。</p> 
 <p style="">原始数据</p> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:205px;vertical-align:top;height:52px;"><p style=""><span class="kdocs-bold" style="font-weight:bold;">movie</span></p></td><td class="kdocs-tableCell" style="width:346px;vertical-align:top;height:52px;"><p style=""><span class="kdocs-bold" style="font-weight:bold;">category</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:245px;vertical-align:top;height:52px;"><p style="">《疑犯追踪》</p></td><td class="kdocs-tableCell" style="width:446px;vertical-align:top;height:52px;"><p style="">悬疑,动作,科幻,剧情</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:275px;vertical-align:top;height:52px;"><p style="">《Lie to me》</p></td><td class="kdocs-tableCell" style="width:491px;vertical-align:top;height:52px;"><p style="">悬疑,警匪,动作,心理,剧情</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:230px;vertical-align:top;height:52px;"><p style="">《战狼2》</p></td><td class="kdocs-tableCell" style="width:401px;vertical-align:top;height:52px;"><p style="">战争,动作,灾难</p></td></tr></tbody></table> 
 </div> 
 <p style="">需求</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">《疑犯追踪》      悬疑
《疑犯追踪》      动作
《疑犯追踪》      科幻
《疑犯追踪》      剧情
《Lie to me》   悬疑
《Lie to me》   警匪
《Lie to me》   动作
《Lie to me》   心理
《Lie to me》   剧情
《战狼2》        战争
《战狼2》        动作
《战狼2》        灾难</code></pre> 
 <p style="">实现 第一步，炸开类型</p> 
 <pre class="kdocs-sql"><code class="language-sql">select
	explode(split(category,','))
from movie_info;</code></pre> 
 <p style="">实现第二步：尝试使用join进行连接，但是不行，没有办法写join条件，造成了笛卡尔积</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">
SELECT 
	t1.movie,
	t2.category_name
from
(
	select movie from  movie_info
) t1
left join
(
	select
		explode(split(category,',')) category_name
	from movie_info
) t2;</code></pre> 
 <p style="">实现第三步：</p> 
 <p style="">我们的需求是·想让炸开后的临时表和炸开之前表所在行的其他字段进行join</p> 
 <p style="">hive帮我们实现了这个需求 lateral view （侧写视图）</p> 
 <pre class="kdocs-sql"><code class="language-sql">select
	movie,
	category_name
from movie_info
LATERAL VIEW explode(split(category,',')) tmp as category_name;</code></pre> 
 <h4 style="text-align:left;">5 窗口函数</h4> 
 <h5 style="text-align:left;">1）定义</h5> 
 <p style="">窗口函数属于sql中比较高级的函数</p> 
 <p style="">mysql从8.0版本才支持窗口函数，我们学的5.6,5.7都有窗口函数</p> 
 <p style="">oracle 里面一直支持窗口函数</p> 
 <p style="">hive也支持窗口函数</p> 
 <p style="">以下函数才是窗口函数</p> 
 <p style="">窗口函数：</p> 
 <p style="">LEAD LEAD(col,n, default_val)：往后第n行数据 col 列名 n 往后第几行 默认为1 默认值 默认null</p> 
 <p style="">LAG LAG(col,n,default_val)：往前第n行数据 col 列名 n 往前第几行 默认为1 默认值 默认null</p> 
 <p style="">FIRST_VALUE 在当前窗口下的第一个值 FIRST_VALUE （col,true/false） 如果设置为true，则跳过空值。</p> 
 <p style="">LAST_VALUE 在当前窗口下的最后一个值 LAST_VALUE （col,true/false）如果设置为true，则跳过空值。</p> 
 <p style="">标准聚合函数：</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>COUNT</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>SUM</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>MIN</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>MAX</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>AVG</p></li></ul> 
 <p style="">分析排名函数</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>RANK</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>ROW_NUMBER</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>DENSE_RANK</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>NTILE</p></li></ul> 
 <p style="">窗口函数=函数+窗口</p> 
 <p style="">窗口：函数在运算时，我们可以指定函数运算的数据范围</p> 
 <h5 style="text-align:left;">2）语法</h5> 
 <h5 style="text-align:left;">窗口函数 over([partition by 字段] [order by 字段] [ 窗口语句])</h5> 
 <p style="">partition by 给查出来的结果集按照某个字段分区，分区以后，开窗的大小最大不会超过分区数据的大小</p> 
 <p style="">一旦分区之后，我们必须在单个分区内指定窗口。</p> 
 <p style="">order by 给分区内的数据按照某个字段排序</p> 
 <h5 style="text-align:left;">3) 窗口语句</h5> 
 <pre class="kdocs-sql"><code class="language-sql">(ROWS | RANGE) BETWEEN (UNBOUNDED | [num]) PRECEDING AND ([num] PRECEDING | CURRENT ROW | (UNBOUNDED | [num]) FOLLOWING)
(ROWS | RANGE) BETWEEN CURRENT ROW AND (CURRENT ROW | (UNBOUNDED | [num]) FOLLOWING)
(ROWS | RANGE) BETWEEN [num] FOLLOWING AND (UNBOUNDED | [num]) FOLLOWING</code></pre> 
 <p style="">两种特殊情况</p> 
 <p style="">当指定ORDER BY缺少WINDOW子句时，WINDOW规范默认为RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW。</p> 
 <p style="">如果同时缺少ORDER BY和WINDOW子句，则WINDOW规范默认为ROW BETWEENUND UNBOUNDED PRECEDING和UNBOUNDED FOLLOWING。</p> 
 <p style="">以下函数在over（）里面只能分区和排序，不能自定义窗口大小了，也就是不能再写window字句</p> 
 <p style="">排序分析函数 都不能写 例如： Rank, NTile, DenseRank, CumeDist, PercentRank.</p> 
 <p style="">Lead 和 Lag不能写</p> 
 <h4 style="text-align:left;">窗口需求</h4> 
 <p style="">需求1 查询在2017年4月份购买过的顾客及总人数</p> 
 <pre class="kdocs-sql"><code class="language-sql">select  
	name,
	count(1) over(rows between UNBOUNDED  PRECEDING and UNBOUNDED FOLLOWING)
from business
where month(orderdate) =4
group by name;</code></pre> 
 <p style="">由于窗口语句有两种特殊情况，我们这种刚好符合第二种，因此可以省略掉窗口语句</p> 
 <pre class="kdocs-sql"><code class="language-sql">select  
	name,
	count(1) over()
from business
where month(orderdate) =4
group by name;</code></pre> 
 <p style="">需求2 查询顾客的购买明细及月购买总额</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">SELECT 
	name,
	orderdate,
	cost,
	sum(cost ) over(partition by name,month(orderdate) )
from business;</code></pre> 
 <p style="">需求3 上述的场景, 将每个顾客的cost按照日期进行累加</p> 
 <pre class="kdocs-sql"><code class="language-sql">SELECT 
	name,
	orderdate,
	cost,
	sum(cost) over(partition by name order by orderdate rows between UNBOUNDED  PRECEDING and CURRENT ROW) cost1,
	sum(cost) over(partition by name order by orderdate) cost2
from business;</code></pre> 
 <p style="">需求4 查询顾客购买明细以及上次的购买时间和下次购买时间</p> 
 <pre class="kdocs-sql"><code class="language-sql">select
	name,
	orderdate,
	cost,
	LAG(orderdate,1,'无') over(partition by name order by orderdate) prev_time,
	LEAD(orderdate,1,'无') over(partition by name order by orderdate) next_time
from business;</code></pre> 
 <p style="">需求5 查询顾客每个月第一次的购买时间 和 每个月的最后一次购买时间</p> 
 <p style="">注意：LAST_VALUE和FIRST_VALUE 需要自定义windows字句，否则出现错误</p> 
 <pre class="kdocs-sql"><code class="language-sql">select
	name,
	orderdate,
	cost,
	FIRST_VALUE(orderdate) 
	over(partition by name,month(orderdate) order by orderdate rows between UNBOUNDED  PRECEDING and UNBOUNDED FOLLOWING) first_time,
	LAST_VALUE(orderdate) 
	over(partition by name,month(orderdate) order by orderdate rows between UNBOUNDED  PRECEDING and UNBOUNDED FOLLOWING) last_time
from business;</code></pre> 
 <p style="">需求6 查询前20%时间的订单信息</p> 
 <pre class="kdocs-sql"><code class="language-sql">select
	t1.*
FROM 
(
	select
		name,
		orderdate,
		cost,
		ntile(5) over(order by orderdate ) nsort
	from business
) t1
where t1.nsort = 1;</code></pre> 
 <h4 style="text-align:left;">6 排名行数</h4> 
 <p style="">RANK() 排序相同时会重复，会跳号</p> 
 <p style="">DENSE_RANK() 排序相同时会重复，不会跳号</p> 
 <p style="">ROW_NUMBER() 会根据顺序计算</p> 
 <pre class="kdocs-sql"><code class="language-sql">SELECT 
	name,
	subject,
	score,
	rank() over(PARTITION by subject order by score desc) rp,
	DENSE_RANK() over(PARTITION by subject order by score desc) drp,
	ROW_NUMBER() over(PARTITION by subject order by score desc) rowp
from score;</code></pre> 
 <h3 style="text-align:left;">几个关键字总结</h3> 
 <h3 style="text-align:left;">1 建表 ：PARTITIONED BY(分区表) CLUSTERED BY（分桶表）</h3> 
 <h3 style="text-align:left;">2 查询：ORDER BY(全局排序) SORT BY(区内排序)</h3> 
 <h3 style="text-align:left;">DITRIBUTE BY（分区） CLUSTER BY（分区排序）</h3> 
 <h3 style="text-align:left;">3 窗口函数：PARTITION BY(对数据分区) ORDER BY（排序）</h3> 
 <h4 style="text-align:left;">7自定义udf</h4> 
 <h5 style="text-align:left;">1 编写代码继承genericUDF类。实现里面的三个方法</h5> 
 <h5 style="text-align:left;">2 创建临时函数</h5> 
 <p style="">添加jar包的类路径给hive，注意是临时生效</p> 
 <pre class="kdocs-sql"><code class="language-sql">add jar /opt/module/hive/datas/myudf.jar;</code></pre> 
 <p style="">创建临时函数</p> 
 <pre class="kdocs-sql"><code class="language-sql">create  temporary function my_len as "com.logcat.hive.udf.MyStringLength";</code></pre> 
 <p style="">删除临时函数</p> 
 <pre class="kdocs-sql"><code class="language-sql">drop  temporary function my_len;</code></pre> 
 <p style="">注意：临时函数只跟会话有关系，只要会话不断，在当前会话下，任意一个库都可以使用。其他会话全都不能使用。</p> 
 <h5 style="text-align:left;">3 创建永久函数</h5> 
 <p style="">注意：因为永久函数是永久生效的，我们推出当前会话以后，其他会话也要使用永久函数，因此我们就不能简单的使用add jar来添加hive的类路径了</p> 
 <p style="">创建永久函数</p> 
 <p style="">注意：此时要使用USING JAR的方式来添加函数的jar包类路径，并且这个路径必须是hdfs路径</p> 
 <pre class="kdocs-sql"><code class="language-sql">create function my_len2 as "com.logcat.hive.udf.MyStringLength" USING JAR 'hdfs://hadoop102:9820/hivejar/myudf.jar';</code></pre> 
 <p style="">删除永久函数</p> 
 <pre class="kdocs-sql"><code class="language-sql">drop function my_len2;</code></pre> 
 <p style="">注意：永久函数创建的时候，在函数名之前需要自己加上库名，如果不指定库名的话，会默认把当前库的库名给加上。</p> 
 <p style="">然后使用永久函数的时候，需要在指定的库里面操作,或者在其他库里面使用的话得加上 库名.函数名</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6ba95e93ed6c186a1c893d70c5a851d9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue 前端导出xlsx文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ba3077dccfb2478ba1d57ee9dedc99f1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IDEA国际化资源Key无法全局重命名的解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>