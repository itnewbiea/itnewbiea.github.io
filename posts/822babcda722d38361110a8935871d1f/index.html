<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java常用工具类 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java常用工具类" />
<meta property="og:description" content="Java常用工具类 Object类 Object类是类层次结构的根。每个类都有 Object作为超类。所有对象，包括数组，实现这个类的方法。
getClass()方法 返回该 Object运行时类。返回的 类对象是由类的代表 static synchronized方法锁定对象。
hashCode()方法 public int hashCode() 返回一个对象的哈希代码值。这种方法对于hash表，如所提供的 HashMap利益支持
//基本数据类型没有hashCode()
public static void main(String[] args) { //每new一个对象hashcode都不同 Student s1 = new Student(); Student s2 = new Student(); int a=10; int ai = new Integer(10); System.out.println(a==ai);//true System.out.println(&#34;===================&#34;); /** * 基本类型使用==，是比较基本类型的本身是否相等 * 引用类型==，是比较变量存放的地址值 */ System.out.println(s1==s2);//false //引用类 System.out.println(s1.hashCode()==s2.hashCode());//false Student s3=s2; System.out.println(s3==s2);//true System.out.println(s3.hashCode()==s2.hashCode());//true System.out.println(&#34;=========================&#34;); String t1=&#34;y1&#34;; String y=&#34;y&#34;,s=&#34;1&#34;; String ys=y&#43;s;//y1 String yi = new String(&#34;y2&#34;); System.out.println(t1.hashCode()==yi.hashCode());//false //基本数据类型没有hashCode() System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/822babcda722d38361110a8935871d1f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-18T10:20:16+08:00" />
<meta property="article:modified_time" content="2023-03-18T10:20:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java常用工具类</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h3 style="text-align:left;">Java常用工具类</h3> 
 <h4 style="text-align:left;">Object类</h4> 
 <p style="">Object类是类层次结构的根。每个类都有 Object作为超类。所有对象，包括数组，实现这个类的方法。</p> 
 <h5 style="text-align:left;">getClass()方法</h5> 
 <p style="">返回该 Object运行时类。返回的 类对象是由类的代表 static synchronized方法锁定对象。</p> 
 <h5 style="text-align:left;">hashCode()方法</h5> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">public int hashCode()</code></pre> 
 <p style="">返回一个对象的哈希代码值。这种方法对于hash表，如所提供的 <a class="kdocs-link" style="color:#0A6CFF;" href="../../java/util/HashMap.html" rel="nofollow noopener noreferrer" target="_blank">HashMap</a>利益支持</p> 
 <p style="">//基本数据类型没有hashCode()</p> 
 <pre class="kdocs-java"><code class="language-java">public static void main(String[] args) {
        //每new一个对象hashcode都不同
        Student s1 = new Student();
        Student s2 = new Student();

        int a=10;
        int ai = new Integer(10);
        System.out.println(a==ai);//true
        System.out.println("===================");
        /**
         * 基本类型使用==，是比较基本类型的本身是否相等
         * 引用类型==，是比较变量存放的地址值
         */
        System.out.println(s1==s2);//false
        //引用类
        System.out.println(s1.hashCode()==s2.hashCode());//false

        Student s3=s2;
        System.out.println(s3==s2);//true
        System.out.println(s3.hashCode()==s2.hashCode());//true

        System.out.println("=========================");
        String t1="y1";
        String y="y",s="1";
        String ys=y+s;//y1
        String yi = new String("y2");
        System.out.println(t1.hashCode()==yi.hashCode());//false
        //基本数据类型没有hashCode()
        System.out.println(t1.hashCode()==ys.hashCode());//true

        System.out.println(t1==yi);//false
        System.out.println(t1.equals(yi));//true
        String t2=t1+"er";
        System.out.println(t1.hashCode()==t2.hashCode());//false

    }
}

class Student{

}</code></pre> 
 <h5 style="text-align:left;">equals()方法</h5> 
 <p style="">public boolean equals(Object obj)</p> 
 <p style="">指示是否有其他对象“等于”这一个。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">==</span>:</p> 
 <p style=""> <span class="kdocs-bold" style="font-weight:bold;">基本数据类型</span>比较：比较的是值</p> 
 <p style=""> <span class="kdocs-bold" style="font-weight:bold;">引用数据类型</span>比较：比较的是内存地址（hashcode）</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">equals</span>:</p> 
 <p style=""> 基本数据类型比较：无法使用</p> 
 <p style=""> 引用数据类型比较：源码为==，所以还是比较的是内存地址</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">对象</span>equals源码</p> 
 <pre class="kdocs-java"><code class="language-java">public boolean equals(Object obj) {
    return (this == obj);
}</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">String</span>类型equals源码，也是重写了equals方法,将String转换为基本数据类型char，然后来进行比较</p> 
 <pre class="kdocs-java"><code class="language-java">public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            //
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">类</span>中重写equals方法</p> 
 <pre class="kdocs-java"><code class="language-java">public class Test02 {

    public static void main(String[] args) {

        String name = "张三";
        String name1 = "张三";
        System.out.println(name.equals(name1));//true
        System.out.println(name==name1);//true

        A1 a1 = new A1("张三",10);
        A1 a2 = new A1("张三",10);
   //因为在a1类中重写了equals方法，判断（String，int）是相同即为true，若不重写则比较的是内存为false
        System.out.println(a1.equals(a2));//true
        System.out.println(a1==a2);//false
    }
}

class A1{
    String name;
    int age;
    public A1() {
    }
    public A1(String name, int age) {
        this.name = name;
        this.age = age;
    }

    //重写父类equals方法
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        A1 a1 = (A1) o;
        return age == a1.age &amp;&amp; Objects.equals(name, a1.name);
    }
}</code></pre> 
 <h5 style="text-align:left;">toString()方法</h5> 
 <p style="">public String toString()</p> 
 <p style="">返回对象的字符串表示形式。总的来说，这 toString方法返回一个字符串，“以文本方式表示”这个对象。其结果应该是一个简洁，但翔实的代表性，是一个容易阅读的人。建议所有子类都重写此方法。</p> 
 <p style="">Object类的toString方法返回一个包含该类的对象是一个实例的名称字符串的符号 @` '，和符号进制表示的对象的哈希码。换句话说，此方法返回一个等于值的字符串：</p> 
 <blockquote class="kdocs-blockquote" style="text-align:left;">
   getClass().getName() + '@' + Integer.toHexString(hashCode()) 
 </blockquote> 
 <pre class="kdocs-java"><code class="language-java">// Class类重写了Object toString()
System.out.println(A1.class.toString());//class com.xiaoming.objectClass.A1 
System.out.println(a1.toString());//com.xiaoming.objectClass.A1@4554617c</code></pre> 
 <p style="">Object类toString()源码</p> 
 <pre class="kdocs-java"><code class="language-java">public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}</code></pre> 
 <p style="">Class类重写toString()源码</p> 
 <pre class="kdocs-java"><code class="language-java">public String toString() {
    return (isInterface() ? "interface " : (isPrimitive() ? "" : "class "))
        + getName();
}</code></pre> 
 <h5 style="text-align:left;">clone()方法</h5> 
 <p style="">创建并返回此对象的副本。“复制”的确切含义可能取决于对象的类。</p> 
 <pre class="kdocs-java"><code class="language-java">protected native Object clone() throws CloneNotSupportedException;</code></pre> 
 <p style="">clone()object类必须先实现Cloneable接口，然后在重写clone方法。如果不实现Cloneable接口则会报CloneNotSupportedException错误，</p> 
 <p style="">clone出来的对象和原来对象是两个<span class="kdocs-bold" style="font-weight:bold;">完全不同内存地址</span>的对象</p> 
 <pre class="kdocs-java"><code class="language-java">public class Test03 {
    public static void main(String[] args) throws CloneNotSupportedException {
        A2 a2 = new A2();//a2:1163157884
        A2 a4 = (A2) a2.clone();
        System.out.println(a2==a4);//false

        Object clone = a2.clone(); //clone:1956725890
        //强制转换不会改变hashcode值
        A2 a3= (A2) clone;//a3:1956725890
        System.out.println(a2==clone);//false
        System.out.println(a2==a3);//false
        System.out.println(clone==a3);//true

    }
}

class A2 implements Cloneable{
    String name;
    int age;

    public A2(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public A2() {
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}</code></pre> 
 <p style="">深克隆和浅克隆：</p> 
 <p style=""> 深克隆：克隆该对象的所有子父关系。除了对象本身被复制外，对象包含的引用也被复制，也就是其中的成员 对象也被复制</p> 
 <p style=""> 浅克隆：只克隆该对象。浅克隆仅仅复制所考虑的对象，不会复制它所引用的成员对象</p> 
 <p style="">JAVA语言中，**序列化（Serialization）**就是将对象写到流的过程，写到流中的对象是原有的对象的一个拷贝，而原对象仍存在内存中。通过序列化实现的拷贝不仅可以复制对象本身，而且也可以复制其引用的成员对象，因此通过序列化将对象写入一个流中，再从流中将其读出来，从而实现深克隆。</p> 
 <h5 style="text-align:left;">finaliaz()方法</h5> 
 <p style="">当垃圾收集确定没有对对象的引用时，由对象上的垃圾收集器调用。子类重写 finalize方法配置系统资源或执行其他清理。</p> 
 <pre class="kdocs-java"><code class="language-java">protected void finalize() throws Throwable { }</code></pre> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>该方法是finalize最多只调用一次java虚拟机在任何给定的对象。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>任何异常的原因finalize方法抛出这个对象最终被叫停，但被忽视。</p></li></ul> 
 <p style="">final：修饰符，作用在属性上该属性为常量，不能被修改，作用在方法上该方法不能被继承</p> 
 <p style="">finaly:异常中用于出现异常最后会执行的代码，常见的是关闭I/O流关闭资源</p> 
 <h5 style="text-align:left;">notify()方法</h5> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>唤醒一个在这个对象的监视器上等待的<span class="kdocs-bold" style="font-weight:bold;">单个线程</span>。如果任何线程都在等待这个对象，其中一个被选择被唤醒。选择是任意的，发生在执行的自由裁量权。一个线程等待一个对象的监控通过调用其中的 wait方法。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>此方法只应被一个线程的所有者，该线程是这个对象的监视器的所有者。</p></li></ul> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">异常</span>：于IllegalMonitorStateException -如果当前线程不拥有此对象监视器。</p> 
 <pre class="kdocs-java"><code class="language-java">public final native void notifyAll();</code></pre> 
 <h5 style="text-align:left;">notifyAll()方法</h5> 
 <p style="">唤醒正在等待此对象监视器上的<span class="kdocs-bold" style="font-weight:bold;">所有线程</span>。一个线程等待一个对象的监控通过调用其中的 wait方法。</p> 
 <pre class="kdocs-java"><code class="language-java">public final void notifyAll();</code></pre> 
 <h5 style="text-align:left;">wait()方法</h5> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>使当前线程等待另一个线程调用此对象的方法或notify() notifyAll()方法。换句话说，这个方法的行为就好像它仅执行呼叫 wait(0)。</p></li></ul> 
 <pre class="kdocs-java"><code class="language-java">public final native void wait(long timeout) throws InterruptedException;</code></pre> 
 <p style="">这种方法应该只被<span class="kdocs-bold" style="font-weight:bold;">一个线程</span>是拥有此对象监视器。看到一个描述的方式，一个线程可以成为监视器所有者的 notify方法。</p> 
 <h5 style="text-align:left;">wait(long timeout)</h5> 
 <p style="">使当前线程等待另一个线程调用此对象的方法或 notify() notifyAll()方法，或一个指定的时间流逝。</p> 
 <pre class="kdocs-java"><code class="language-java">public final native void wait(long timeout) throws InterruptedException;</code></pre> 
 <h5 style="text-align:left;">wait(long timeout, int nanos)</h5> 
 <p style="">使当前线程等待另一个线程调用此对象的方法或notify() notifyAll()方法，或者其他某个线程中断当前线程，或一定量的实际时间已经过去了。</p> 
 <pre class="kdocs-java"><code class="language-java">public final void wait(long timeout, int nanos) throws InterruptedException {
    if (timeout &lt; 0) {
        throw new IllegalArgumentException("timeout value is negative");
    }

    if (nanos &lt; 0 || nanos &gt; 999999) {
        throw new IllegalArgumentException(
                            "nanosecond timeout value out of range");
    }

    if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; timeout == 0)) {
        timeout++;
    }

    wait(timeout);
}</code></pre> 
 <h4 style="text-align:left;">String类</h4> 
 <p style="">String类表示的字符串。java程序中的所有字符串，如 "abc"，实现这个类的实例。</p> 
 <pre class="kdocs-java"><code class="language-java">public final class String
extends Object
implements Serializable, Comparable&lt;String&gt;, CharSequence</code></pre> 
 <p style="">由final修饰：String字符串是常量，它们的值不能被创建后改变。支持可变字符串字符串缓冲区。因为字符串对象是不可改变的，所以它们可以被共享。</p> 
 <p style="">继承了Object类可以重写equals()等方法</p> 
 <h5 style="text-align:left;">String类型内存分析</h5> 
 <pre class="kdocs-java"><code class="language-java">//在方法区中的常量池添加一个"zhansan"并在栈区生成一个name指向"zhangsan"
String name="zhansan";
//在常量池中查找无果后生成一个666的常量，并且将name（zhangsan）拼接成一个新的常量"zhangsan666",此时的栈区会生成一个name指向拼接的常量
name=name+"6666";
//在常量池中无果后生成一个"name:"的常量，并且将name（zhangsan666）拼接成一个新的常量"name:zhangsan666"
sout("name:"+name)</code></pre> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:71.21622%;height:0;"> 
    <img src="https://images2.imgbox.com/7a/13/1XOYnCPS_o.png" style="margin-left:;display:block;width:740px;margin-top:-71.21622%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <pre class="kdocs-java"><code class="language-java">//在常量池中查找到有相同的String常量，所以在栈中name2指向的是常量池中已经创建好的"zhangsan"
String name2="zhangsan";</code></pre> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:68.10811%;height:0;"> 
    <img src="https://images2.imgbox.com/14/4f/4EtT8j95_o.png" style="margin-left:;display:block;width:740px;margin-top:-68.10811%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <pre class="kdocs-java"><code class="language-java">String a = "abc";
char[] data= {'a','b','c'};
String b = new String(data);
System.out.println(a==b);//false
//equals被string类重写，比较的是值
System.out.println(a.equals(b));//true
//string每次改变都会创建一个新的常量
System.out.println(a.hashCode());//96354
a += "d";
System.out.println(a.hashCode());//2987074

//因为字符串对象是不可改变的，所以它们可以被共享。
String c = "efg";
String d = "efg";
System.out.println(d==c);//true
System.out.println("d:"+d.hashCode()+"c:"+c.hashCode());//d:100326    c:100326</code></pre> 
 <p style="">内存分析：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:80.540535%;height:0;"> 
    <img src="https://images2.imgbox.com/d3/95/25t9URNw_o.png" style="margin-left:;display:block;width:740px;margin-top:-80.540535%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <h5 style="text-align:left;">String类型的特点:</h5> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>如果发现在方法区中没有对应的字符串，会自动<span class="kdocs-bold" style="font-weight:bold;">开辟内存</span>存储新的字符串</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>字符串一旦创建了，是<span class="kdocs-bold" style="font-weight:bold;">不能够被修改</span>的</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>字符串虽然不能够被修改，但是可以<span class="kdocs-bold" style="font-weight:bold;">共享</span></p></li></ol> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>如果字符串频繁的拼接字符串，都会在方法区开辟空间，这样是非常消耗内存空间的，所有如果字符串拼接比较频繁不建议使用String类型，这时我们可以改用StringBuffer或者StringBuilder</p></li></ol> 
 <h5 style="text-align:left;">String中的构造方法</h5> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:62.56757%;height:0;"> 
    <img src="https://images2.imgbox.com/e1/9e/SxD0cy6A_o.png" style="margin-left:;display:block;width:740px;margin-top:-62.56757%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>String() 初始化新创建的 String对象，它代表了一个空字符序列。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>String(byte[] bytes) 通过使用平台的默认字符集解码指定的字节数组构造了一个新的 String。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>String(char[] value) 分配一个新的 String，它代表了目前包含在字符数组参数字符序列。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>String(char[] value, int offset, int count) 分配一个包含字符与字符数组数组参数的新 String。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>用法：分配一个包含字符与字符数组数组参数的新 String。的说法是 offset的子阵列的第一个字符的索引和 count参数指定的数组的长度。的子阵列的内容复制的字符数组；随后的修改不影响新创建的字符串。</p></li></ul> 
 <ul><li style="margin-left:4.2em;list-style-type:square;text-indent:0;"><p>Parameters:</p></li></ul> 
 <p style="">value阵列是字源</p> 
 <p style="">offset -初始偏移</p> 
 <p style="">count -长度</p> 
 <pre class="kdocs-java"><code class="language-java">char[] chars={'a','b','c','d'};

//从char[]中第1位开始取出2个字符
String c = new String(chars, 1, 2);
System.out.println(c);//bc</code></pre> 
 <h5 style="text-align:left;">String常用方法</h5> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:47.027027%;height:0;"> 
    <img src="https://images2.imgbox.com/ed/1e/tW1U3MdJ_o.jpg" style="margin-left:;display:block;width:740px;margin-top:-47.027027%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:710px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:55.070423%;height:0;"> 
    <img src="https://images2.imgbox.com/96/14/1WnQIga1_o.jpg" style="margin-left:;display:block;width:710px;margin-top:-55.070423%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">注意事项：</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>字符串 str 中字符的索引从0开始，范围为 0 到 str.length()-1</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>使用 indexOf 进行字符或字符串查找时，如果匹配返回位置索引；如果没有匹配结果，返回 -1</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>使用 substring(beginIndex , endIndex) 进行字符串截取时，包括 beginIndex 位置的字符，不包括 endIndex 位置的字符【[左闭，右开)左包含，右不包含】</p></li></ul> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">length，length(),size()的区别</span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>length:是数组的一个属性，获取数组的长度</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>length():是字符串或者其他类的方法，获取字符长度</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>size():是集合类或者其他类的方法，获取集合中的数据量（个数）</p></li></ul> 
 <pre class="kdocs-java"><code class="language-java">int[] i={1,2,3,4};
System.out.println(i.length);//4

String s = "xiaoming";
System.out.println(s.length());//8

List list = new ArrayList();
list.add("1");
System.out.println(list.size());//1

Map map=new HashMap();
map.put(0,"map");
System.out.println(map.size());//1</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">返回结果为boolean类型的方法</span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>boolean isEmpty()：判断字符串是否为空。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>boolean equals(Object obj)：将此字符串的内容与指定的对象比较,区分大小写。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>boolean equalsIgnoreCase(String str)：将此String 与另一个String 比较,<span class="kdocs-bold" style="font-weight:bold;">忽略大小写</span>。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>boolean contains(String str)：判断字符串中是否<span class="kdocs-bold" style="font-weight:bold;">包含</span>方法传入的字符串。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>boolean startsWith(String str)：判断字符串是否以某个指定的字符串<span class="kdocs-bold" style="font-weight:bold;">开头</span>。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>boolean endsWith(String str)：判断字符串是否以某个指定的字符串<span class="kdocs-bold" style="font-weight:bold;">结尾</span>。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>boolean isEmpty()：判断字符串是否<span class="kdocs-bold" style="font-weight:bold;">为空</span>。</p></li></ul> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">String xx=""与Sting xx=null的内存分析</span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:61.486485%;height:0;"> 
    <img src="https://images2.imgbox.com/6d/41/m0dHdfC5_o.png" style="margin-left:;display:block;width:740px;margin-top:-61.486485%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>String replace(char old,char new) : 替换功能。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>String replace(String old,String new).替换功能。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>String trim()：去除字符串<span class="kdocs-bold" style="font-weight:bold;">空格</span>。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>int compareTo(String str) : 按<span class="kdocs-bold" style="font-weight:bold;">字典顺序</span>比较两个字符串。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>int compareToIgnoreCase(String str)：按字典顺序比较两个字符串，<span class="kdocs-bold" style="font-weight:bold;">忽略大小写</span>。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>public String[] split(String regex)：<span class="kdocs-bold" style="font-weight:bold;">分隔字符串成字符数组</span>。</p></li></ul> 
 <h4 style="text-align:left;">StringBuffer和StringBuilder</h4> 
 <p style="">String在频繁拼接的场景是不推荐使用，因为这种情况下会在方法区中开辟很多空间，浪费资源，面对这种情况我可以使用StringBuffer或者StringBuilder来解决这种问题</p> 
 <h5 style="text-align:left;">StringBuffer</h5> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>一个线程安全的，字符的可变序列。一个字符串缓冲区就像一 String，但是可以修改。在任何一个时间点，它包含一些特定的字符序列，但该序列的长度和内容可以通过某些方法调用。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>通过null争论这类构造函数或方法会导致一个NullPointerException异常</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>StringBuilder。的StringBuilder类一般应优先使用StringBuilder，因为它支持所有相同的操作，但它的速度更快，因为它不进行同步。</p></li></ul> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">构造方法</span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>StringBuffer() 构造一个没有字符的字符串缓冲区，并构造了<span class="kdocs-bold" style="font-weight:bold;">16个字符</span>的初始容量。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>StringBuffer(CharSequence seq) 构建一个包含指定的 CharSequence相同字符的字符串缓冲区。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>StringBuffer(int capacity) 构造一个没有字符的字符串缓冲区，并构造指定的初始容量。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>StringBuffer(String str) 构造一个初始化为指定字符串内容的字符串缓冲区。</p></li></ul> 
 <pre class="kdocs-java"><code class="language-java">//StringBuffer无参构造创建了一个默认容量为16的字符数组
StringBuffer s1 = new StringBuffer();
//capacity() 获取StringBuffer容量
System.out.println(s1.capacity());//16

//构建一个包含指定的 `CharSequence`相同字符的字符串缓冲区
StringBuffer s2 = new StringBuffer('a');
System.out.println(s2.capacity()+":"+s2.toString());//97:

//构造一个初始化为指定字符串内容的字符串缓冲区。
StringBuffer s3 = new StringBuffer("hello");
System.out.println(s3.capacity()+":"+s3.toString());//21:hello

//构造一个没有字符的字符串缓冲区，并构造指定的初始容量
StringBuffer s4 = new StringBuffer(50);
System.out.println(s4.capacity()+":"+s4.toString());//50:</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">常用方法</span></p> 
 <pre class="kdocs-java"><code class="language-java">String str="abc";
StringBuffer buffer = new StringBuffer();
buffer.append(str);
System.out.println(buffer);//abc
System.out.println(buffer.hashCode());//1163157884

//链式写法
buffer.append(1).append('a').append(new char[]{'a','b','d'});
System.out.println(buffer);//abc1aabd
//改变字符串不会开辟新的内存
System.out.println(buffer.hashCode());//1163157884

//从下标处插入字符，数组，字符串
buffer.insert(3, "insert插入");//abcinsert插入1aabd
System.out.println(buffer);

//移除指定一段下标数据(开始下标，结束下标）
buffer.delete(3,8);
System.out.println(buffer);//abct插入1aabd
//移除某一个下标的值
buffer.deleteCharAt(3);
System.out.println(buffer);//abc插入1aabd

//替换字符（开始下标，替换几个字符，替换值）
buffer.replace(0,3,"ABC");
System.out.println(buffer);//ABC插入1aabd

//颠倒字符
buffer.reverse();
System.out.println(buffer);//dbaa1入插CBA</code></pre> 
 <h5 style="text-align:left;">StringBuilder</h5> 
 <p style="">一个可变的字符序列。这个类提供了一个API兼容 StringBuffer，<span class="kdocs-bold" style="font-weight:bold;">但无法保证同步</span>。本课程是专为使用作为一个<span class="kdocs-bold" style="font-weight:bold;">下降的替代</span>（简易替换） StringBuffer在地方的字符串缓冲区被一个线程使用（一般情况下）。在可能的情况下，建议优先使用这StringBuilder， 它比StringBuffer更快。</p> 
 <p style="">StringBuffer和StringBuilder中的API都是相同的</p> 
 <p style="">String、StringBuffer、StringBuilder的区别</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>String:<span class="kdocs-bold" style="font-weight:bold;">线程不安全</span>，一旦在方法区创建就不能被更改，可以被多个引用共享，在做大量字符拼接时效率很低</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>StringBuffer、StringBuilder：<span class="kdocs-bold" style="font-weight:bold;">可以改变字符内容</span>，是一个字符串缓冲区，在拼接字符时不会开辟新的空间</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>StringBuffer:1.0开始 <span class="kdocs-bold" style="font-weight:bold;">线程安全</span>，效率低（Buffer:缓冲）</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>StringBuilder:1.5开始 <span class="kdocs-bold" style="font-weight:bold;">线程不安全</span>，效率高（单线程的话<span class="kdocs-bold" style="font-weight:bold;">建议使用</span>）（Builder:建造者）</p></li></ul> 
 <h4 style="text-align:left;">包装类</h4> 
 <p style="">每一个基本数据类型，都对应一个包装类，包装类都在 java.lang 包中，包装类提供了不同类型间进行转换的方法</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:362px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:61.325966%;height:0;"> 
    <img src="https://images2.imgbox.com/c0/c1/cXAWip9t_o.jpg" style="margin-left:;display:block;width:362px;margin-top:-61.325966%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <h5 style="text-align:left;">Integer解析</h5> 
 <pre class="kdocs-java"><code class="language-java">//静态属性
//最大值 :2147483647
System.out.println(Integer.MAX_VALUE);
//最小值:-2147483648
System.out.println(Integer.MIN_VALUE);
//类代表原始类型的实例 int。
System.out.println(Integer.TYPE);

//构造方法
Integer integer = new Integer(6);
//传入非数字的字符串会报 NumberFormatException错误
Integer integer1 = new Integer("7");</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">类型转换</span></p> 
 <pre class="kdocs-java"><code class="language-java">//String类型转为int
String s="3";
int i = Integer.parseInt(s);
int i1 = Integer.valueOf(s).intValue();
int i2 = new Integer(s).intValue();

//int类型转为String
int num=3;
String s1 = "" + 3;
String s2 = String.valueOf(num);
String s3 = Integer.toString(num);</code></pre> 
 <h5 style="text-align:left;">装箱与拆箱</h5> 
 <p style="">JDK1.5之后的特性</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">装箱</span>：把基本类型转换成包装类，使其具有对象的性质，又可分为手动装箱和自动装箱</p> 
 <pre class="kdocs-java"><code class="language-java">int j=10;//定义一个int基本类型值
Integer x=new Integer(j);//手动装箱
Integer y=j;//自动装箱</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">拆箱</span>：和装箱相反，把包装类对象转换成基本类型的值，又可分为手动拆箱和自动拆箱</p> 
 <pre class="kdocs-java"><code class="language-java">Integer j=new Integer(8);
int m=j.intValue();//手动拆箱为int类型
int n=j;//自动拆箱为int类型</code></pre> 
 <h4 style="text-align:left;">Math类</h4> 
 <p style="">这类 Math包含用于执行基本的<span class="kdocs-bold" style="font-weight:bold;">数字运算</span>等基本指数、对数、平方根法、三角函数。</p> 
 <p style="">Math方法</p> 
 <pre class="kdocs-java"><code class="language-java">public static int abs(int a)//求绝对值
public static double sqrt(double a) // 开根号
public static double cceil(double a)//向上取整
public static double floor(double a)//向下取整
public static int max(int a,int b)//求最大值
public static int min(int a,int b)// 求最小值
public static double pow (double a,double b)//求a的b次幂
public static double random() //生成随机数
public static int round(float a)//四舍五入
    
 //取0-99随机数
        int v = (int) (Math.random() * 99);
        System.out.println(v);

 //获取20-30之间的随整数
        int random = random(20, 30);
        System.out.println(random);

    public static   int random(int start,int end){
        return (int)(Math.random()*(end-start+1)+start);</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">Random工具类</span></p> 
 <p style="">此类用于生成随机数流在Java.utill包下面实现了 Serializable接口。</p> 
 <p style="">Serializable：Java给你提供一种应该比你自己的好的<span class="kdocs-bold" style="font-weight:bold;">保存对象状态的机制</span>，那就是序列化。<span class="kdocs-bold" style="font-weight:bold;">序列化</span>给我们提供了一种技术，用于保存对象的变量。以便于传输。</p> 
 <pre class="kdocs-java"><code class="language-java">Random r=new Random();
System.out.println(r.nextDouble());//获取的是0.1-1.0之间的随机数
System.out.println(r.nextInt());//获取的是int最大值与最小值之间的随机数
System.out.println(r.nextLong());
System.out.println(r.nextInt(10));//获取的是0-10之间的随机数</code></pre> 
 <h4 style="text-align:left;">System类</h4> 
 <p style="">System类包含一些有用的类的字段和方法。它不能被实例化。</p> 
 <p style="">由System类提供的设施包括<span class="kdocs-bold" style="font-weight:bold;">标准输入</span>、<span class="kdocs-bold" style="font-weight:bold;">标准输出</span>和<span class="kdocs-bold" style="font-weight:bold;">错误输出流</span>；访问<span class="kdocs-bold" style="font-weight:bold;">外部定义</span>的属性和环境变量；加载文件和库的方法；和一种快速复制数组的一部分的实用方法。</p> 
 <pre class="kdocs-java"><code class="language-java">//currentTimeMillis()返回当前时间以毫秒为单位。
long l = System.currentTimeMillis();//1640512311035
System.out.println(l);
Date date = new Date(l);
System.out.println(date);//Sun Dec 26 17:51:51 CST 2021

//终止当前正在运行的java虚拟机。后面代码将不再运行
System.exit(1);

//getProperties()确定当前系统属性。
Properties properties = System.getProperties();
System.out.println(properties.getProperty("java.version"));//1.8.0_31
// getProperties("java.version")获取指定键的系统属性
System.out.println(System.getProperty("java.version"));//1.8.0_31

//getSecurityManager()获取系统安全接口。
System.out.println(System.getSecurityManager());</code></pre> 
 <h4 style="text-align:left;">BigInteger类</h4> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">用于超出int存储范围值的计算</span></p> 
 <pre class="kdocs-java"><code class="language-java">//最大值+30超出了int存储范围，打印出来为负数
Integer a=Integer.MAX_VALUE+30;
System.out.println(String.valueOf(a));//-2147483619

BigInteger bigInteger = new BigInteger(Integer.toString(Integer.MAX_VALUE));
System.out.println(bigInteger);//2147483647
//BigInteger调用add()将最大值加1
BigInteger bigIntegers = bigInteger.add(new BigInteger("1"));
System.out.println(bigIntegers);//2147483648
System.out.println(bigIntegers.longValue());//2147483648
System.out.println(bigIntegers.intValue());//-2147483648
System.out.println(bigIntegers.toString());//2147483648</code></pre> 
 <h4 style="text-align:left;">BigDecimal类</h4> 
 <p style="">double和float计算的是<span class="kdocs-bold" style="font-weight:bold;">容易丢失精度</span>，所以使用BigDecimal类来处理。</p> 
 <pre class="kdocs-java"><code class="language-java">BigDecimal bigDecimal1 = new BigDecimal("0.08");
BigDecimal bigDecimal2 = new BigDecimal("0.01");
System.out.println(bigDecimal1.add(bigDecimal2));//加 0.09
System.out.println(bigDecimal1.multiply(bigDecimal2));//乘 0.0008
//注意：如果除不尽程序会报错。需要做四舍五入模式（RoundingMode HALF_UP）操作
System.out.println(bigDecimal1.divide(bigDecimal2));//除 8
System.out.println(bigDecimal1.subtract(bigDecimal2));//减 0.07</code></pre> 
 <h4 style="text-align:left;">Date类</h4> 
 <p style="">在<span class="kdocs-bold" style="font-weight:bold;">java.util</span>包下，表示时间，精确到毫秒</p> 
 <pre class="kdocs-java"><code class="language-java">System.out.println(new Date());//Sun Dec 26 18:39:06 CST 2021
System.out.println(new Date(1231223423l));//Thu Jan 15 14:00:23 CST 1970</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">java.util.Date</span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>就是在除了SQL语句的情况下面使用</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>表示<span class="kdocs-bold" style="font-weight:bold;">时间的类</span>，我们通常格式化或者得到当前时间</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>一般的环境下都行！</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>util.Date是sql.Date的父类</p></li></ul> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">java.sql.Date</span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>是针对SQL语句使用的，它只包含日期而没有时间部分</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p><span class="kdocs-bold" style="font-weight:bold;">读写数据库时间</span>字段的使用</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>主要是用于sql中的！</p></li></ul> 
 <p style="">它都有getTime方法返回毫秒数，自然就可以直接构建</p> 
 <p style="">java.util.Date d = new java.util.Date(sqlDate.getTime());</p> 
 <h4 style="text-align:left;">SimpleDateFormat类</h4> 
 <p style="">在java.text.SimpleDateFormat下<span class="kdocs-bold" style="font-weight:bold;">继承了DateFormat类</span>。是格式和语言环境敏感的方式解析一个类的具体日期。可以格式化（日期→文本），分析（文本→日期），和归一化。</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>使用 <span class="kdocs-bold" style="font-weight:bold;">format()</span> 方法将日期转换为指定格式的文本</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>使用 <span class="kdocs-bold" style="font-weight:bold;">parse()</span> 方法将文本转换为日期</p></li></ul> 
 <pre class="kdocs-java"><code class="language-java">Date date = new Date();
SimpleDateFormat simpleDateFormat = new SimpleDateFormat();
//指定格式输出日期
System.out.println(simpleDateFormat.format(date));//21-12-26 下午6:47 默认
SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
System.out.println(dateFormat.format(date));//2021-12-26 18:55:19
SimpleDateFormat dateFormat1 = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
System.out.println(dateFormat1.format(date));//2021/12/26 18:55:50

//字符串转Date
String dateStr="2021-12-26 18:55:19";
Date parseDate = dateFormat.parse(dateStr);
System.out.println(parseDate);//Sun Dec 26 18:55:19 CST 2021</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">Date类与SimpleDateFormat区别</span></p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>调用 SimpleDateFormat 对象的 parse() 方法时可能会出现转换异常，即 ParseException ，因此需要进行<span class="kdocs-bold" style="font-weight:bold;">异常处理</span></p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>使用 Date 类时需要导入 <span class="kdocs-bold" style="font-weight:bold;">java.util 包</span>，使用 SimpleDateFormat 时需要导入 <span class="kdocs-bold" style="font-weight:bold;">java.text 包</span></p></li></ol> 
 <h4 style="text-align:left;">Calendar类</h4> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">仅推荐使用 Calendar 类进行时间和日期加减周的处理。</span></p> 
 <p style="">java.util.Calendar 类是一个抽象类（不能被实例化new），可以通过调用 getInstance() 静态方法获取一个 Calendar 对象，此对象已由当前日期时间初始化，即默认代表当前时间，如 Calendar c = Calendar.getInstance();</p> 
 <pre class="kdocs-java"><code class="language-java">//调用 Calendar 类的 getInstance() 方法获取一个实例，然后通过调用 get() 方法获取日期时间信息，参数为需要获得的字段的值， Calendar.Year 等为 Calendar 类中定义的静态常量。
Calendar c = Calendar.getInstance();//创建对象
int year=c.get(Calendar.YEAR);//年
int month=c.get(Calendar.MONTH)+1;//0表示1月。所以加1
int day=c.get(Calendar.DATE);//日
int hour=c.get(Calendar.HOUR_OF_DAY );//小时
int minute=c.get(Calendar.MINUTE);//分钟
int second=c.get(Calendar.SECOND);//秒
int dayOfWeek = c.get(Calendar.DAY_OF_WEEK);//这周第几天
int hourOfDay = c.get(Calendar.HOUR_OF_DAY);//今天的第几个小时</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">Calendar 和 Date 的转换</span></p> 
 <p style="">Calendar 类提供了 getTime() 方法，用来获取 Date 对象，完成 Calendar 和 Date 的转换，还可通过 getTimeInMillis() 方法，获取此 Calendar 的时间值，以毫秒为单位。</p> 
 <pre class="kdocs-java"><code class="language-java">Calendar c = Calendar.getInstance();//创建对象
Date date=c.getTime();//转化为Date()对象
Long time=c.getTimeInMillis();//获取当前毫秒数</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">Calendar Date SimpleDateFormat 综合使用</span></p> 
 <pre class="kdocs-java"><code class="language-java">// 创建Calendar对象
Calendar c = Calendar.getInstance();
int today=c.get(Calendar.DATE);
System.out.println("当前日期todate：" + today);//当前日期todate：26
// 将Calendar对象转换为Date对象
Date date = c.getTime();
System.out.println("当前时间date：" + date);//当前时间date：Sun Dec 26 19:16:45 CST 2021
// 创建SimpleDateFormat对象，指定目标格式
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
// 将日期转换为指定格式的字符串
String now = sdf.format(date);
System.out.println("当前时间now：" + now);//当前时间now：2021-12-26 19:16:45</code></pre> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c455527dcffdf63482e3a59a3dc76930/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot&#43;Mybatis实例（图文教程）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/896cda4155379db7c1537a31ec7afe66/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">正则替换replace中$1的用法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>