<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>dirent--文件以及文件夹相关操作(跨平台) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="dirent--文件以及文件夹相关操作(跨平台)" />
<meta property="og:description" content="windows客户端开发–文件以及文件夹相关操作(windows api) 一文中，主要使用了一些windows api实现文件以及文件夹的相关操作。
c&#43;&#43;语言本身不提供文件相关操作，我们也可以使用boost库完成我们想要的功能。
但是为了仅仅一个小功能，引入boost库，似乎有点小题大做吧，那今天就介绍一种“跨平台”的文件操作，dirent。
这里所谓的“跨平台”其实是个伪命题，不是真正意义上的。
let us go!!!
初识dirent
是POSIX.1标准定义的unix类目录操作的头文件，包含了许多UNIX系统服务的函数原型，例如opendir函数、readdir函数.
看到上面的描述，你会理解我所说的用引号引起来的“跨平台”了。
在windows平台上同样可以使用： https://github.com/tronkko/dirent/blob/master/include/dirent.h
只是简单的包含这个头文件dirent.h就可以了，因为这个文件只有八百多行，在博客的最后面，我将会贴上这个源码。
熟悉dirent
dirent结构体：
struct dirent { long d_ino; /* Always zero */ unsigned short d_reclen; /* Structure size */ size_t d_namlen; /* Length of name without \0 */ int d_type; /* File type */ char d_name[PATH_MAX]; /* File name */ }; typedef struct dirent dirent; DIR： A type representing a directory stream.
struct DIR { struct dirent ent; struct _WDIR *wdirp; }; typedef struct DIR DIR; 一些函数：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/38794b1704484b42ec68c3a6658c7762/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-11-01T11:35:23+08:00" />
<meta property="article:modified_time" content="2016-11-01T11:35:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">dirent--文件以及文件夹相关操作(跨平台)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><a href="http://blog.csdn.net/wangshubo1989/article/details/52993466">windows客户端开发–文件以及文件夹相关操作(windows api)</a> <br> 一文中，主要使用了一些windows api实现文件以及文件夹的相关操作。</p> 
<p>c++语言本身不提供文件相关操作，我们也可以使用boost库完成我们想要的功能。</p> 
<p>但是为了仅仅一个小功能，引入boost库，似乎有点小题大做吧，那今天就介绍一种“跨平台”的文件操作，dirent。</p> 
<p>这里所谓的“跨平台”其实是个伪命题，不是真正意义上的。</p> 
<p>let us go!!!</p> 
<p><strong>初识dirent</strong></p> 
<p>是POSIX.1标准定义的unix类目录操作的头文件，包含了许多UNIX系统服务的函数原型，例如opendir函数、readdir函数.</p> 
<p>看到上面的描述，你会理解我所说的用引号引起来的“跨平台”了。</p> 
<p>在windows平台上同样可以使用： <br> <a href="https://github.com/tronkko/dirent/blob/master/include/dirent.h">https://github.com/tronkko/dirent/blob/master/include/dirent.h</a></p> 
<p>只是简单的包含这个头文件dirent.h就可以了，因为这个文件只有八百多行，在博客的最后面，我将会贴上这个源码。</p> 
<p><strong>熟悉dirent</strong></p> 
<p>dirent结构体：</p> 
<pre class="prettyprint"><code class=" hljs objectivec">    <span class="hljs-keyword">struct</span> dirent {
        <span class="hljs-keyword">long</span> d_ino;     <span class="hljs-comment">/* Always zero */</span>
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> d_reclen;  <span class="hljs-comment">/* Structure size */</span>
        size_t d_namlen;    <span class="hljs-comment">/* Length of name without \0 */</span>
        <span class="hljs-keyword">int</span> d_type;   <span class="hljs-comment">/* File type */</span>
        <span class="hljs-keyword">char</span> d_name[PATH_MAX];     <span class="hljs-comment">/* File name */</span>
    };
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> dirent dirent;</code></pre> 
<p>DIR： <br> A type representing a directory stream.</p> 
<pre class="prettyprint"><code class=" hljs d"><span class="hljs-keyword">struct</span> DIR {
        <span class="hljs-keyword">struct</span> dirent ent;
        <span class="hljs-keyword">struct</span> _WDIR *wdirp;
    };
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> DIR DIR;
</code></pre> 
<p>一些函数：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">int</span> closedir(DIR *);
DIR *opendir(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *);
<span class="hljs-keyword">struct</span> dirent *readdir(DIR *);
<span class="hljs-keyword">int</span> readdir_r(DIR *, <span class="hljs-keyword">struct</span> dirent *, <span class="hljs-keyword">struct</span> dirent **);
<span class="hljs-keyword">void</span> rewinddir(DIR *);
<span class="hljs-keyword">void</span> seekdir(DIR *, <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span>);
<span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> telldir(DIR *);</code></pre> 
<p><strong>使用dirent</strong></p> 
<p>删除文件夹下所有文件：</p> 
<pre class="prettyprint"><code class=" hljs perl">DIR <span class="hljs-variable">*foder</span> = <span class="hljs-keyword">opendir</span>(file_path_to_delete.c_str());
    struct dirent <span class="hljs-variable">*next_file</span>;
    char filepath[<span class="hljs-number">256</span>];

    <span class="hljs-keyword">while</span> ((next_file = <span class="hljs-keyword">readdir</span>(foder)) != NULL)
    {
        <span class="hljs-regexp">//</span> build the path <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> file in the folder
        <span class="hljs-keyword">sprintf</span>(filepath, <span class="hljs-string">"<span class="hljs-variable">%s</span>/<span class="hljs-variable">%s</span>"</span>, course_path.c_str(), next_file-&gt;d_name);
        remove(filepath);
    }</code></pre> 
<p><strong>注意：</strong> <br> 路径要以’/’结尾：</p> 
<pre class="prettyprint"><code class=" hljs bash">file_path_to_delete += <span class="hljs-string">"\/"</span>;
</code></pre> 
<p>判断目录是否存在：</p> 
<pre class="prettyprint"><code class=" hljs rust"> DIR *mydir = NULL;  
    <span class="hljs-keyword">if</span>((mydir= opendir(<span class="hljs-keyword">dir</span>))==NULL)<span class="hljs-comment">//判断目录   </span>
    {  
      <span class="hljs-keyword">int</span> ret = mkdir(<span class="hljs-keyword">dir</span>, MODE);<span class="hljs-comment">//创建目录  </span>
      <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>)  
      {  
          <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  
      }  
      printf(<span class="hljs-string">"%s created sucess!/n"</span>, <span class="hljs-keyword">dir</span>);  
    }  </code></pre> 
<p>判断是文件夹还是文件：</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> isFile =<span class="hljs-number">0x8</span>;
DIR Dir;
<span class="hljs-keyword">struct</span> dirent *DirEntry;
Dir = opendir(<span class="hljs-string">"c:/test/"</span>)

<span class="hljs-keyword">while</span>(Dir=readdir(Dir))
{
   <span class="hljs-keyword">if</span> ( DirEntry-&gt;d_type == isFile)
   {
    <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"Found a File : "</span> &lt;&lt; DirEntry-&gt;d_name &lt;&lt; endl;
   }
}</code></pre> 
<p>==========================================================华丽的分割线============================================================</p> 
<p>//dirent.h</p> 
<pre class="prettyprint"><code class=" hljs applescript">/*
* dirent.h - dirent API <span class="hljs-keyword">for</span> Microsoft Visual Studio
*
* Copyright (C) <span class="hljs-number">2006</span>-<span class="hljs-number">2012</span> Toni Ronkko
*
* Permission <span class="hljs-keyword">is</span> hereby granted, free <span class="hljs-keyword">of</span> charge, <span class="hljs-keyword">to</span> any person obtaining
* a <span class="hljs-keyword">copy</span> <span class="hljs-keyword">of</span> this software <span class="hljs-keyword">and</span> associated documentation files (<span class="hljs-keyword">the</span>
* ``Software''), <span class="hljs-keyword">to</span> deal <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> Software <span class="hljs-keyword">without</span> restriction, including
* <span class="hljs-keyword">without</span> limitation <span class="hljs-keyword">the</span> rights <span class="hljs-keyword">to</span> use, <span class="hljs-keyword">copy</span>, modify, merge, publish,
* distribute, sublicense, <span class="hljs-keyword">and</span>/<span class="hljs-keyword">or</span> sell copies <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> Software, <span class="hljs-keyword">and</span> <span class="hljs-keyword">to</span>
* permit persons <span class="hljs-keyword">to</span> whom <span class="hljs-keyword">the</span> Software <span class="hljs-keyword">is</span> furnished <span class="hljs-keyword">to</span> do so, subject <span class="hljs-keyword">to</span>
* <span class="hljs-keyword">the</span> following conditions:
*
* The <span class="hljs-keyword">above</span> copyright notice <span class="hljs-keyword">and</span> this permission notice shall be included
* <span class="hljs-keyword">in</span> all copies <span class="hljs-keyword">or</span> substantial portions <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> Software.
*
* THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL TONI RONKKO BE LIABLE FOR ANY CLAIM, DAMAGES OR
* OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*
* $Id: dirent.h,v <span class="hljs-number">1.20</span> <span class="hljs-number">2014</span>/<span class="hljs-number">03</span>/<span class="hljs-number">19</span> <span class="hljs-number">17</span>:<span class="hljs-number">52</span>:<span class="hljs-number">23</span> tronkko Exp $
*/
<span class="hljs-comment">#ifndef DIRENT_H</span>
<span class="hljs-comment">#define DIRENT_H</span>

/*
* Define architecture flags so we don't need <span class="hljs-keyword">to</span> include windows.h.
* Avoiding windows.h makes <span class="hljs-keyword">it</span> simpler <span class="hljs-keyword">to</span> use windows sockets <span class="hljs-keyword">in</span> conjunction
* <span class="hljs-keyword">with</span> dirent.h.
*/
<span class="hljs-comment">#if !defined(_68K_) &amp;&amp; !defined(_MPPC_) &amp;&amp; !defined(_X86_) &amp;&amp; !defined(_IA64_) &amp;&amp; !defined(_AMD64_) &amp;&amp; defined(_M_IX86)</span>
<span class="hljs-comment">#   define _X86_</span>
<span class="hljs-comment">#endif</span>
<span class="hljs-comment">#if !defined(_68K_) &amp;&amp; !defined(_MPPC_) &amp;&amp; !defined(_X86_) &amp;&amp; !defined(_IA64_) &amp;&amp; !defined(_AMD64_) &amp;&amp; defined(_M_AMD64)</span>
<span class="hljs-comment">#define _AMD64_</span>
<span class="hljs-comment">#endif</span>

<span class="hljs-comment">#include &lt;stdio.h&gt;</span>
<span class="hljs-comment">#include &lt;stdarg.h&gt;</span>
<span class="hljs-comment">#include &lt;windef.h&gt;</span>
<span class="hljs-comment">#include &lt;winbase.h&gt;</span>
<span class="hljs-comment">#include &lt;wchar.h&gt;</span>
<span class="hljs-comment">#include &lt;string.h&gt;</span>
<span class="hljs-comment">#include &lt;stdlib.h&gt;</span>
<span class="hljs-comment">#include &lt;malloc.h&gt;</span>
<span class="hljs-comment">#include &lt;sys/types.h&gt;</span>
<span class="hljs-comment">#include &lt;sys/stat.h&gt;</span>
<span class="hljs-comment">#include &lt;errno.h&gt;</span>

/* Indicates <span class="hljs-keyword">that</span> d_type field <span class="hljs-keyword">is</span> available <span class="hljs-keyword">in</span> dirent structure */
<span class="hljs-comment">#define _DIRENT_HAVE_D_TYPE</span>

/* Indicates <span class="hljs-keyword">that</span> d_namlen field <span class="hljs-keyword">is</span> available <span class="hljs-keyword">in</span> dirent structure */
<span class="hljs-comment">#define _DIRENT_HAVE_D_NAMLEN</span>

/* Entries missing <span class="hljs-keyword">from</span> MSVC <span class="hljs-number">6.0</span> */
<span class="hljs-comment">#if !defined(FILE_ATTRIBUTE_DEVICE)</span>
<span class="hljs-comment">#   define FILE_ATTRIBUTE_DEVICE 0x40</span>
<span class="hljs-comment">#endif</span>

/* File type <span class="hljs-keyword">and</span> permission flags <span class="hljs-keyword">for</span> stat() */
<span class="hljs-comment">#if !defined(S_IFMT)</span>
<span class="hljs-comment">#   define S_IFMT   _S_IFMT                     /* File type mask */</span>
<span class="hljs-comment">#endif</span>
<span class="hljs-comment">#if !defined(S_IFDIR)</span>
<span class="hljs-comment">#   define S_IFDIR  _S_IFDIR                    /* Directory */</span>
<span class="hljs-comment">#endif</span>
<span class="hljs-comment">#if !defined(S_IFCHR)</span>
<span class="hljs-comment">#   define S_IFCHR  _S_IFCHR                    /* Character device */</span>
<span class="hljs-comment">#endif</span>
<span class="hljs-comment">#if !defined(S_IFFIFO)</span>
<span class="hljs-comment">#   define S_IFFIFO _S_IFFIFO                   /* Pipe */</span>
<span class="hljs-comment">#endif</span>
<span class="hljs-comment">#if !defined(S_IFREG)</span>
<span class="hljs-comment">#   define S_IFREG  _S_IFREG                    /* Regular file */</span>
<span class="hljs-comment">#endif</span>
<span class="hljs-comment">#if !defined(S_IREAD)</span>
<span class="hljs-comment">#   define S_IREAD  _S_IREAD                    /* Read permission */</span>
<span class="hljs-comment">#endif</span>
<span class="hljs-comment">#if !defined(S_IWRITE)</span>
<span class="hljs-comment">#   define S_IWRITE _S_IWRITE                   /* Write permission */</span>
<span class="hljs-comment">#endif</span>
<span class="hljs-comment">#if !defined(S_IEXEC)</span>
<span class="hljs-comment">#   define S_IEXEC  _S_IEXEC                    /* Execute permission */</span>
<span class="hljs-comment">#endif</span>
<span class="hljs-comment">#if !defined(S_IFIFO)</span>
<span class="hljs-comment">#   define S_IFIFO _S_IFIFO                     /* Pipe */</span>
<span class="hljs-comment">#endif</span>
<span class="hljs-comment">#if !defined(S_IFBLK)</span>
<span class="hljs-comment">#   define S_IFBLK   0                          /* Block device */</span>
<span class="hljs-comment">#endif</span>
<span class="hljs-comment">#if !defined(S_IFLNK)</span>
<span class="hljs-comment">#   define S_IFLNK   0                          /* Link */</span>
<span class="hljs-comment">#endif</span>
<span class="hljs-comment">#if !defined(S_IFSOCK)</span>
<span class="hljs-comment">#   define S_IFSOCK  0                          /* Socket */</span>
<span class="hljs-comment">#endif</span>

<span class="hljs-comment">#if defined(_MSC_VER)</span>
<span class="hljs-comment">#   define S_IRUSR  S_IREAD                     /* Read user */</span>
<span class="hljs-comment">#   define S_IWUSR  S_IWRITE                    /* Write user */</span>
<span class="hljs-comment">#   define S_IXUSR  0                           /* Execute user */</span>
<span class="hljs-comment">#   define S_IRGRP  0                           /* Read group */</span>
<span class="hljs-comment">#   define S_IWGRP  0                           /* Write group */</span>
<span class="hljs-comment">#   define S_IXGRP  0                           /* Execute group */</span>
<span class="hljs-comment">#   define S_IROTH  0                           /* Read others */</span>
<span class="hljs-comment">#   define S_IWOTH  0                           /* Write others */</span>
<span class="hljs-comment">#   define S_IXOTH  0                           /* Execute others */</span>
<span class="hljs-comment">#endif</span>

/* Maximum <span class="hljs-property">length</span> <span class="hljs-keyword">of</span> <span class="hljs-type">file</span> <span class="hljs-property">name</span> */
<span class="hljs-comment">#if !defined(PATH_MAX)</span>
<span class="hljs-comment">#   define PATH_MAX MAX_PATH</span>
<span class="hljs-comment">#endif</span>
<span class="hljs-comment">#if !defined(FILENAME_MAX)</span>
<span class="hljs-comment">#   define FILENAME_MAX MAX_PATH</span>
<span class="hljs-comment">#endif</span>
<span class="hljs-comment">#if !defined(NAME_MAX)</span>
<span class="hljs-comment">#   define NAME_MAX FILENAME_MAX</span>
<span class="hljs-comment">#endif</span>

/* File type flags <span class="hljs-keyword">for</span> d_type */
<span class="hljs-comment">#define DT_UNKNOWN  0</span>
<span class="hljs-comment">#define DT_REG      S_IFREG</span>
<span class="hljs-comment">#define DT_DIR      S_IFDIR</span>
<span class="hljs-comment">#define DT_FIFO     S_IFIFO</span>
<span class="hljs-comment">#define DT_SOCK     S_IFSOCK</span>
<span class="hljs-comment">#define DT_CHR      S_IFCHR</span>
<span class="hljs-comment">#define DT_BLK      S_IFBLK</span>
<span class="hljs-comment">#define DT_LNK      S_IFLNK</span>

/* Macros <span class="hljs-keyword">for</span> converting <span class="hljs-keyword">between</span> st_mode <span class="hljs-keyword">and</span> d_type */
<span class="hljs-comment">#define IFTODT(mode) ((mode) &amp; S_IFMT)</span>
<span class="hljs-comment">#define DTTOIF(type) (type)</span>

/*
* File type macros.  Note <span class="hljs-keyword">that</span> block devices, sockets <span class="hljs-keyword">and</span> links cannot be
* distinguished <span class="hljs-function_start"><span class="hljs-keyword">on</span></span> Windows <span class="hljs-keyword">and</span> <span class="hljs-keyword">the</span> macros S_ISBLK, S_ISSOCK <span class="hljs-keyword">and</span> S_ISLNK are
* only defined <span class="hljs-keyword">for</span> compatibility.  These macros should always <span class="hljs-constant">return</span> <span class="hljs-constant">false</span>
* <span class="hljs-function_start"><span class="hljs-keyword">on</span></span> Windows.
*/
<span class="hljs-comment">#define S_ISFIFO(mode) (((mode) &amp; S_IFMT) == S_IFIFO)</span>
<span class="hljs-comment">#define S_ISDIR(mode)  (((mode) &amp; S_IFMT) == S_IFDIR)</span>
<span class="hljs-comment">#define S_ISREG(mode)  (((mode) &amp; S_IFMT) == S_IFREG)</span>
<span class="hljs-comment">#define S_ISLNK(mode)  (((mode) &amp; S_IFMT) == S_IFLNK)</span>
<span class="hljs-comment">#define S_ISSOCK(mode) (((mode) &amp; S_IFMT) == S_IFSOCK)</span>
<span class="hljs-comment">#define S_ISCHR(mode)  (((mode) &amp; S_IFMT) == S_IFCHR)</span>
<span class="hljs-comment">#define S_ISBLK(mode)  (((mode) &amp; S_IFMT) == S_IFBLK)</span>

/* Return <span class="hljs-keyword">the</span> exact <span class="hljs-property">length</span> <span class="hljs-keyword">of</span> d_namlen <span class="hljs-keyword">without</span> zero terminator */
<span class="hljs-comment">#define _D_EXACT_NAMLEN(p) ((p)-&gt;d_namlen)</span>

/* Return <span class="hljs-type">number</span> <span class="hljs-keyword">of</span> bytes needed <span class="hljs-keyword">to</span> store d_namlen */
<span class="hljs-comment">#define _D_ALLOC_NAMLEN(p) (PATH_MAX)</span>


<span class="hljs-comment">#ifdef __cplusplus</span>
extern <span class="hljs-string">"C"</span> {
<span class="hljs-comment">#endif</span>


    /* Wide-<span class="hljs-property">character</span> <span class="hljs-property">version</span> */
    struct _wdirent {
        long d_ino;                                 /* Always zero */
        unsigned short d_reclen;                    /* Structure size */
        size_t d_namlen;                            /* Length <span class="hljs-keyword">of</span> <span class="hljs-property">name</span> <span class="hljs-keyword">without</span> \<span class="hljs-number">0</span> */
        int d_type;                                 /* File type */
        wchar_t d_name[PATH_MAX];                   /* File <span class="hljs-property">name</span> */
    };
    typedef struct _wdirent _wdirent;

    struct _WDIR {
        struct _wdirent ent;                        /* Current directory entry */
        WIN32_FIND_DATAW data;                      /* Private <span class="hljs-type">file</span> data */
        int cached;                                 /* True <span class="hljs-keyword">if</span> data <span class="hljs-keyword">is</span> valid */
        HANDLE handle;                              /* Win32 search handle */
        wchar_t *patt;                              /* Initial directory <span class="hljs-property">name</span> */
    };
    typedef struct _WDIR _WDIR;

    static _WDIR *_wopendir(const wchar_t *dirname);
    static struct _wdirent *_wreaddir(_WDIR *dirp);
    static int _wclosedir(_WDIR *dirp);
    static void _wrewinddir(_WDIR* dirp);


    /* For compatibility <span class="hljs-keyword">with</span> Symbian */
<span class="hljs-comment">#define wdirent _wdirent</span>
<span class="hljs-comment">#define WDIR _WDIR</span>
<span class="hljs-comment">#define wopendir _wopendir</span>
<span class="hljs-comment">#define wreaddir _wreaddir</span>
<span class="hljs-comment">#define wclosedir _wclosedir</span>
<span class="hljs-comment">#define wrewinddir _wrewinddir</span>


    /* Multi-byte <span class="hljs-property">character</span> versions */
    struct dirent {
        long d_ino;                                 /* Always zero */
        unsigned short d_reclen;                    /* Structure size */
        size_t d_namlen;                            /* Length <span class="hljs-keyword">of</span> <span class="hljs-property">name</span> <span class="hljs-keyword">without</span> \<span class="hljs-number">0</span> */
        int d_type;                                 /* File type */
        char d_name[PATH_MAX];                      /* File <span class="hljs-property">name</span> */
    };
    typedef struct dirent dirent;

    struct DIR {
        struct dirent ent;
        struct _WDIR *wdirp;
    };
    typedef struct DIR DIR;

    static DIR *opendir(const char *dirname);
    static struct dirent *readdir(DIR *dirp);
    static int closedir(DIR *dirp);
    static void rewinddir(DIR* dirp);


    /* Internal utility functions */
    static WIN32_FIND_DATAW *dirent_first(_WDIR *dirp);
    static WIN32_FIND_DATAW *dirent_next(_WDIR *dirp);

    static int dirent_mbstowcs_s(
        size_t *pReturnValue,
        wchar_t *wcstr,
        size_t sizeInWords,
        const char *mbstr,
        size_t <span class="hljs-command">count</span>);

    static int dirent_wcstombs_s(
        size_t *pReturnValue,
        char *mbstr,
        size_t sizeInBytes,
        const wchar_t *wcstr,
        size_t <span class="hljs-command">count</span>);

    static void dirent_set_errno(int <span class="hljs-keyword">error</span>);

    /*
    * Open directory stream DIRNAME <span class="hljs-keyword">for</span> <span class="hljs-command">read</span> <span class="hljs-keyword">and</span> <span class="hljs-constant">return</span> a pointer <span class="hljs-keyword">to</span> <span class="hljs-keyword">the</span>
    * internal working area <span class="hljs-keyword">that</span> <span class="hljs-keyword">is</span> used <span class="hljs-keyword">to</span> retrieve individual directory
    * entries.
    */
    static _WDIR*
        _wopendir(
        const wchar_t *dirname)
    {
        _WDIR *dirp = NULL;
        int <span class="hljs-keyword">error</span>;

        /* Must have directory <span class="hljs-property">name</span> */
        <span class="hljs-keyword">if</span> (dirname == NULL || dirname[<span class="hljs-number">0</span>] == '\<span class="hljs-number">0</span>') {
            dirent_set_errno(ENOENT);
<span class="hljs-command">            return</span> NULL;
        }

        /* Allocate new _WDIR structure */
        dirp = (_WDIR*)malloc(sizeof(struct _WDIR));
        <span class="hljs-keyword">if</span> (dirp != NULL) {
            DWORD n;

            /* Reset _WDIR structure */
            dirp-&gt;handle = INVALID_HANDLE_VALUE;
            dirp-&gt;patt = NULL;
            dirp-&gt;cached = <span class="hljs-number">0</span>;

            /* Compute <span class="hljs-keyword">the</span> <span class="hljs-property">length</span> <span class="hljs-keyword">of</span> full path plus zero terminator */
            n = GetFullPathNameW(dirname, <span class="hljs-number">0</span>, NULL, NULL);

            /* Allocate room <span class="hljs-keyword">for</span> absolute directory <span class="hljs-property">name</span> <span class="hljs-keyword">and</span> search pattern */
            dirp-&gt;patt = (wchar_t*)malloc(sizeof(wchar_t) * n + <span class="hljs-number">16</span>);
            <span class="hljs-keyword">if</span> (dirp-&gt;patt) {

                /*
                * Convert relative directory <span class="hljs-property">name</span> <span class="hljs-keyword">to</span> an absolute one.  This
                * allows rewinddir() <span class="hljs-keyword">to</span> function correctly even when current
                * working directory <span class="hljs-keyword">is</span> changed <span class="hljs-keyword">between</span> opendir() <span class="hljs-keyword">and</span> rewinddir().
                */
                n = GetFullPathNameW(dirname, n, dirp-&gt;patt, NULL);
                <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) {
                    wchar_t *p;

                    /* Append search pattern \* <span class="hljs-keyword">to</span> <span class="hljs-keyword">the</span> directory <span class="hljs-property">name</span> */
                    p = dirp-&gt;patt + n;
                    <span class="hljs-keyword">if</span> (dirp-&gt;patt &lt; p) {
                        switch (p[-<span class="hljs-number">1</span>]) {
                        case '\\':
                        case '/':
                        case ':':
                            /* Directory ends <span class="hljs-keyword">in</span> path separator, e.g. c:\temp\ */
                            /*NOP*/;
                            break;

                        default:
                            /* Directory <span class="hljs-property">name</span> doesn't <span class="hljs-keyword">end</span> <span class="hljs-keyword">in</span> path separator */
                            *p++ = '\\';
                        }
                    }
                    *p++ = '*';
                    *p = '\<span class="hljs-number">0</span>';

                    /* Open directory stream <span class="hljs-keyword">and</span> retrieve <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> entry */
                    <span class="hljs-keyword">if</span> (dirent_first(dirp)) {
                        /* Directory stream opened successfully */
                        <span class="hljs-keyword">error</span> = <span class="hljs-number">0</span>;
                    }
                    <span class="hljs-keyword">else</span> {
                        /* Cannot retrieve <span class="hljs-keyword">first</span> entry */
                        <span class="hljs-keyword">error</span> = <span class="hljs-number">1</span>;
                        dirent_set_errno(ENOENT);
                    }

                }
                <span class="hljs-keyword">else</span> {
                    /* Cannot retrieve full path <span class="hljs-property">name</span> */
                    dirent_set_errno(ENOENT);
                    <span class="hljs-keyword">error</span> = <span class="hljs-number">1</span>;
                }

            }
            <span class="hljs-keyword">else</span> {
                /* Cannot allocate memory <span class="hljs-keyword">for</span> search pattern */
                <span class="hljs-keyword">error</span> = <span class="hljs-number">1</span>;
            }

        }
        <span class="hljs-keyword">else</span> {
            /* Cannot allocate _WDIR structure */
            <span class="hljs-keyword">error</span> = <span class="hljs-number">1</span>;
        }

        /* Clean up <span class="hljs-keyword">in</span> case <span class="hljs-keyword">of</span> <span class="hljs-keyword">error</span> */
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">error</span>  &amp;&amp;  dirp) {
            _wclosedir(dirp);
            dirp = NULL;
        }
<span class="hljs-command">
        return</span> dirp;
    }

    /*
    * Read next directory entry.  The directory entry <span class="hljs-keyword">is</span> returned <span class="hljs-keyword">in</span> dirent
    * structure <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> d_name field.  Individual directory entries returned <span class="hljs-keyword">by</span>
    * this function include regular files, sub-directories, pseudo-directories
    * <span class="hljs-string">"."</span> <span class="hljs-keyword">and</span> <span class="hljs-string">".."</span> <span class="hljs-keyword">as</span> well <span class="hljs-keyword">as</span> volume labels, hidden files <span class="hljs-keyword">and</span> system files.
    */
    static struct _wdirent*
        _wreaddir(
        _WDIR *dirp)
    {
        WIN32_FIND_DATAW *datap;
        struct _wdirent *entp;

        /* Read next directory entry */
        datap = dirent_next(dirp);
        <span class="hljs-keyword">if</span> (datap) {
            size_t n;
            DWORD attr;

            /* Pointer <span class="hljs-keyword">to</span> directory entry <span class="hljs-keyword">to</span> <span class="hljs-constant">return</span> */
            entp = &amp;dirp-&gt;ent;

            /*
            * Copy <span class="hljs-type">file</span> <span class="hljs-property">name</span> <span class="hljs-keyword">as</span> wide-<span class="hljs-property">character</span> <span class="hljs-type">string</span>.  If <span class="hljs-keyword">the</span> <span class="hljs-type">file</span> <span class="hljs-property">name</span> <span class="hljs-keyword">is</span> too
            * long <span class="hljs-keyword">to</span> fit <span class="hljs-keyword">in</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">the</span> destination buffer, <span class="hljs-keyword">then</span> truncate <span class="hljs-type">file</span> <span class="hljs-property">name</span>
            * <span class="hljs-keyword">to</span> PATH_MAX <span class="hljs-property">characters</span> <span class="hljs-keyword">and</span> zero-terminate <span class="hljs-keyword">the</span> buffer.
            */
            n = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span> (n + <span class="hljs-number">1</span> &lt; PATH_MAX  &amp;&amp;  datap-&gt;cFileName[n] != <span class="hljs-number">0</span>) {
                entp-&gt;d_name[n] = datap-&gt;cFileName[n];
                n++;
            }
            dirp-&gt;ent.d_name[n] = <span class="hljs-number">0</span>;

            /* Length <span class="hljs-keyword">of</span> <span class="hljs-type">file</span> <span class="hljs-property">name</span> excluding zero terminator */
            entp-&gt;d_namlen = n;

            /* File type */
            attr = datap-&gt;dwFileAttributes;
            <span class="hljs-keyword">if</span> ((attr &amp; FILE_ATTRIBUTE_DEVICE) != <span class="hljs-number">0</span>) {
                entp-&gt;d_type = DT_CHR;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((attr &amp; FILE_ATTRIBUTE_DIRECTORY) != <span class="hljs-number">0</span>) {
                entp-&gt;d_type = DT_DIR;
            }
            <span class="hljs-keyword">else</span> {
                entp-&gt;d_type = DT_REG;
            }

            /* Reset dummy fields */
            entp-&gt;d_ino = <span class="hljs-number">0</span>;
            entp-&gt;d_reclen = sizeof(struct _wdirent);

        }
        <span class="hljs-keyword">else</span> {

            /* Last directory entry <span class="hljs-command">read</span> */
            entp = NULL;

        }
<span class="hljs-command">
        return</span> entp;
    }

    /*
    * Close directory stream opened <span class="hljs-keyword">by</span> opendir() function.  This invalidates <span class="hljs-keyword">the</span>
    * DIR structure <span class="hljs-keyword">as</span> well <span class="hljs-keyword">as</span> any directory entry <span class="hljs-command">read</span> previously <span class="hljs-keyword">by</span>
    * _wreaddir().
    */
    static int
        _wclosedir(
        _WDIR *dirp)
    {
        int ok;
        <span class="hljs-keyword">if</span> (dirp) {

            /* Release search handle */
            <span class="hljs-keyword">if</span> (dirp-&gt;handle != INVALID_HANDLE_VALUE) {
                FindClose(dirp-&gt;handle);
                dirp-&gt;handle = INVALID_HANDLE_VALUE;
            }

            /* Release search pattern */
            <span class="hljs-keyword">if</span> (dirp-&gt;patt) {
                free(dirp-&gt;patt);
                dirp-&gt;patt = NULL;
            }

            /* Release directory structure */
            free(dirp);
            ok = /*success*/<span class="hljs-number">0</span>;

        }
        <span class="hljs-keyword">else</span> {
            /* Invalid directory stream */
            dirent_set_errno(EBADF);
            ok = /*failure*/-<span class="hljs-number">1</span>;
        }
<span class="hljs-command">        return</span> ok;
    }

    /*
    * Rewind directory stream such <span class="hljs-keyword">that</span> _wreaddir() returns <span class="hljs-keyword">the</span> very <span class="hljs-keyword">first</span>
    * <span class="hljs-type">file</span> <span class="hljs-property">name</span> again.
    */
    static void
        _wrewinddir(
        _WDIR* dirp)
    {
        <span class="hljs-keyword">if</span> (dirp) {
            /* Release existing search handle */
            <span class="hljs-keyword">if</span> (dirp-&gt;handle != INVALID_HANDLE_VALUE) {
                FindClose(dirp-&gt;handle);
            }

            /* Open new search handle */
            dirent_first(dirp);
        }
    }

    /* Get <span class="hljs-keyword">first</span> directory entry (internal) */
    static WIN32_FIND_DATAW*
        dirent_first(
        _WDIR *dirp)
    {
        WIN32_FIND_DATAW *datap;

        /* Open directory <span class="hljs-keyword">and</span> retrieve <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> entry */
        dirp-&gt;handle = FindFirstFileW(dirp-&gt;patt, &amp;dirp-&gt;data);
        <span class="hljs-keyword">if</span> (dirp-&gt;handle != INVALID_HANDLE_VALUE) {

            /* a directory entry <span class="hljs-keyword">is</span> now waiting <span class="hljs-keyword">in</span> memory */
            datap = &amp;dirp-&gt;data;
            dirp-&gt;cached = <span class="hljs-number">1</span>;

        }
        <span class="hljs-keyword">else</span> {

            /* Failed <span class="hljs-keyword">to</span> re-open directory: no directory entry <span class="hljs-keyword">in</span> memory */
            dirp-&gt;cached = <span class="hljs-number">0</span>;
            datap = NULL;

        }
<span class="hljs-command">        return</span> datap;
    }

    /* Get next directory entry (internal) */
    static WIN32_FIND_DATAW*
        dirent_next(
        _WDIR *dirp)
    {
        WIN32_FIND_DATAW *p;

        /* Get next directory entry */
        <span class="hljs-keyword">if</span> (dirp-&gt;cached != <span class="hljs-number">0</span>) {

            /* A valid directory entry already <span class="hljs-keyword">in</span> memory */
            p = &amp;dirp-&gt;data;
            dirp-&gt;cached = <span class="hljs-number">0</span>;

        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dirp-&gt;handle != INVALID_HANDLE_VALUE) {

            /* Get <span class="hljs-keyword">the</span> next directory entry <span class="hljs-keyword">from</span> stream */
            <span class="hljs-keyword">if</span> (FindNextFileW(dirp-&gt;handle, &amp;dirp-&gt;data) != FALSE) {
                /* Got a <span class="hljs-type">file</span> */
                p = &amp;dirp-&gt;data;
            }
            <span class="hljs-keyword">else</span> {
                /* The very <span class="hljs-keyword">last</span> entry has been processed <span class="hljs-keyword">or</span> an <span class="hljs-keyword">error</span> occured */
                FindClose(dirp-&gt;handle);
                dirp-&gt;handle = INVALID_HANDLE_VALUE;
                p = NULL;
            }

        }
        <span class="hljs-keyword">else</span> {

            /* End <span class="hljs-keyword">of</span> directory stream reached */
            p = NULL;

        }
<span class="hljs-command">
        return</span> p;
    }

    /*
    * Open directory stream using plain old C-<span class="hljs-type">string</span>.
    */
    static DIR*
        opendir(
        const char *dirname)
    {
        struct DIR *dirp;
        int <span class="hljs-keyword">error</span>;

        /* Must have directory <span class="hljs-property">name</span> */
        <span class="hljs-keyword">if</span> (dirname == NULL || dirname[<span class="hljs-number">0</span>] == '\<span class="hljs-number">0</span>') {
            dirent_set_errno(ENOENT);
<span class="hljs-command">            return</span> NULL;
        }

        /* Allocate memory <span class="hljs-keyword">for</span> DIR structure */
        dirp = (DIR*)malloc(sizeof(struct DIR));
        <span class="hljs-keyword">if</span> (dirp) {
            wchar_t wname[PATH_MAX];
            size_t n;

            /* Convert directory <span class="hljs-property">name</span> <span class="hljs-keyword">to</span> wide-<span class="hljs-property">character</span> <span class="hljs-type">string</span> */
            <span class="hljs-keyword">error</span> = dirent_mbstowcs_s(&amp;n, wname, PATH_MAX, dirname, PATH_MAX);
            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">error</span>) {

                /* Open directory stream using wide-<span class="hljs-property">character</span> <span class="hljs-property">name</span> */
                dirp-&gt;wdirp = _wopendir(wname);
                <span class="hljs-keyword">if</span> (dirp-&gt;wdirp) {
                    /* Directory stream opened */
                    <span class="hljs-keyword">error</span> = <span class="hljs-number">0</span>;
                }
                <span class="hljs-keyword">else</span> {
                    /* Failed <span class="hljs-keyword">to</span> open directory stream */
                    <span class="hljs-keyword">error</span> = <span class="hljs-number">1</span>;
                }

            }
            <span class="hljs-keyword">else</span> {
                /*
                * Cannot convert <span class="hljs-type">file</span> <span class="hljs-property">name</span> <span class="hljs-keyword">to</span> wide-<span class="hljs-property">character</span> <span class="hljs-type">string</span>.  This
                * occurs <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> <span class="hljs-type">string</span> <span class="hljs-keyword">contains</span> invalid multi-byte sequences <span class="hljs-keyword">or</span>
                * <span class="hljs-keyword">the</span> output buffer <span class="hljs-keyword">is</span> too small <span class="hljs-keyword">to</span> <span class="hljs-keyword">contain</span> <span class="hljs-keyword">the</span> resulting
                * <span class="hljs-type">string</span>.
                */
                <span class="hljs-keyword">error</span> = <span class="hljs-number">1</span>;
            }

        }
        <span class="hljs-keyword">else</span> {
            /* Cannot allocate DIR structure */
            <span class="hljs-keyword">error</span> = <span class="hljs-number">1</span>;
        }

        /* Clean up <span class="hljs-keyword">in</span> case <span class="hljs-keyword">of</span> <span class="hljs-keyword">error</span> */
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">error</span>  &amp;&amp;  dirp) {
            free(dirp);
            dirp = NULL;
        }
<span class="hljs-command">
        return</span> dirp;
    }

    /*
    * Read next directory entry.
    *
    * When working <span class="hljs-keyword">with</span> <span class="hljs-type">text</span> consoles, please note <span class="hljs-keyword">that</span> <span class="hljs-type">file</span> names returned <span class="hljs-keyword">by</span>
    * readdir() are represented <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> default ANSI code page <span class="hljs-keyword">while</span> any output <span class="hljs-keyword">to</span>
    * console <span class="hljs-keyword">is</span> typically formatted <span class="hljs-function_start"><span class="hljs-keyword">on</span></span> another code page.  Thus, non-ASCII
    * <span class="hljs-property">characters</span> <span class="hljs-keyword">in</span> <span class="hljs-type">file</span> names will <span class="hljs-keyword">not</span> usually display correctly <span class="hljs-function_start"><span class="hljs-keyword">on</span></span> console.  The
    * problem can be fixed <span class="hljs-keyword">in</span> two ways: (<span class="hljs-number">1</span>) change <span class="hljs-keyword">the</span> <span class="hljs-property">character</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">of</span> console
    * <span class="hljs-keyword">to</span> <span class="hljs-number">1252</span> using chcp utility <span class="hljs-keyword">and</span> use Lucida Console font, <span class="hljs-keyword">or</span> (<span class="hljs-number">2</span>) use
    * _cprintf function when writing <span class="hljs-keyword">to</span> console.  The _cprinf() will re-encode
    * ANSI strings <span class="hljs-keyword">to</span> <span class="hljs-keyword">the</span> console code page so many non-ASCII <span class="hljs-property">characters</span> will
    * display correcly.
    */
    static struct dirent*
        readdir(
        DIR *dirp)
    {
        WIN32_FIND_DATAW *datap;
        struct dirent *entp;

        /* Read next directory entry */
        datap = dirent_next(dirp-&gt;wdirp);
        <span class="hljs-keyword">if</span> (datap) {
            size_t n;
            int <span class="hljs-keyword">error</span>;

            /* Attempt <span class="hljs-keyword">to</span> convert <span class="hljs-type">file</span> <span class="hljs-property">name</span> <span class="hljs-keyword">to</span> multi-byte <span class="hljs-type">string</span> */
            <span class="hljs-keyword">error</span> = dirent_wcstombs_s(
                &amp;n, dirp-&gt;ent.d_name, PATH_MAX, datap-&gt;cFileName, PATH_MAX);

            /*
            * If <span class="hljs-keyword">the</span> <span class="hljs-type">file</span> <span class="hljs-property">name</span> cannot be represented <span class="hljs-keyword">by</span> a multi-byte <span class="hljs-type">string</span>,
            * <span class="hljs-keyword">then</span> attempt <span class="hljs-keyword">to</span> use old <span class="hljs-number">8</span>+<span class="hljs-number">3</span> <span class="hljs-type">file</span> <span class="hljs-property">name</span>.  This allows traditional
            * Unix-code <span class="hljs-keyword">to</span> access <span class="hljs-keyword">some</span> <span class="hljs-type">file</span> names despite <span class="hljs-keyword">of</span> unicode
            * <span class="hljs-property">characters</span>, although <span class="hljs-type">file</span> names may seem unfamiliar <span class="hljs-keyword">to</span> <span class="hljs-keyword">the</span> user.
            *
            * Be ware <span class="hljs-keyword">that</span> <span class="hljs-keyword">the</span> code <span class="hljs-keyword">below</span> cannot come up <span class="hljs-keyword">with</span> a short <span class="hljs-type">file</span>
            * <span class="hljs-property">name</span> unless <span class="hljs-keyword">the</span> <span class="hljs-type">file</span> system provides one.  At least
            * VirtualBox shared folders fail <span class="hljs-keyword">to</span> do this.
            */
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">error</span>  &amp;&amp;  datap-&gt;cAlternateFileName[<span class="hljs-number">0</span>] != '\<span class="hljs-number">0</span>') {
                <span class="hljs-keyword">error</span> = dirent_wcstombs_s(
                    &amp;n, dirp-&gt;ent.d_name, PATH_MAX,
                    datap-&gt;cAlternateFileName, PATH_MAX);
            }

            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">error</span>) {
                DWORD attr;

                /* Initialize directory entry <span class="hljs-keyword">for</span> <span class="hljs-constant">return</span> */
                entp = &amp;dirp-&gt;ent;

                /* Length <span class="hljs-keyword">of</span> <span class="hljs-type">file</span> <span class="hljs-property">name</span> excluding zero terminator */
                entp-&gt;d_namlen = n - <span class="hljs-number">1</span>;

                /* File attributes */
                attr = datap-&gt;dwFileAttributes;
                <span class="hljs-keyword">if</span> ((attr &amp; FILE_ATTRIBUTE_DEVICE) != <span class="hljs-number">0</span>) {
                    entp-&gt;d_type = DT_CHR;
                }
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((attr &amp; FILE_ATTRIBUTE_DIRECTORY) != <span class="hljs-number">0</span>) {
                    entp-&gt;d_type = DT_DIR;
                }
                <span class="hljs-keyword">else</span> {
                    entp-&gt;d_type = DT_REG;
                }

                /* Reset dummy fields */
                entp-&gt;d_ino = <span class="hljs-number">0</span>;
                entp-&gt;d_reclen = sizeof(struct dirent);

            }
            <span class="hljs-keyword">else</span> {
                /*
                * Cannot convert <span class="hljs-type">file</span> <span class="hljs-property">name</span> <span class="hljs-keyword">to</span> multi-byte <span class="hljs-type">string</span> so construct
                * an errornous directory entry <span class="hljs-keyword">and</span> <span class="hljs-constant">return</span> <span class="hljs-keyword">that</span>.  Note <span class="hljs-keyword">that</span>
                * we cannot <span class="hljs-constant">return</span> NULL <span class="hljs-keyword">as</span> <span class="hljs-keyword">that</span> would stop <span class="hljs-keyword">the</span> processing
                * <span class="hljs-keyword">of</span> directory entries completely.
                */
                entp = &amp;dirp-&gt;ent;
                entp-&gt;d_name[<span class="hljs-number">0</span>] = '?';
                entp-&gt;d_name[<span class="hljs-number">1</span>] = '\<span class="hljs-number">0</span>';
                entp-&gt;d_namlen = <span class="hljs-number">1</span>;
                entp-&gt;d_type = DT_UNKNOWN;
                entp-&gt;d_ino = <span class="hljs-number">0</span>;
                entp-&gt;d_reclen = <span class="hljs-number">0</span>;
            }

        }
        <span class="hljs-keyword">else</span> {
            /* No more directory entries */
            entp = NULL;
        }
<span class="hljs-command">
        return</span> entp;
    }

    /*
    * Close directory stream.
    */
    static int
        closedir(
        DIR *dirp)
    {
        int ok;
        <span class="hljs-keyword">if</span> (dirp) {

            /* Close wide-<span class="hljs-property">character</span> directory stream */
            ok = _wclosedir(dirp-&gt;wdirp);
            dirp-&gt;wdirp = NULL;

            /* Release multi-byte <span class="hljs-property">character</span> <span class="hljs-property">version</span> */
            free(dirp);

        }
        <span class="hljs-keyword">else</span> {

            /* Invalid directory stream */
            dirent_set_errno(EBADF);
            ok = /*failure*/-<span class="hljs-number">1</span>;

        }
<span class="hljs-command">        return</span> ok;
    }

    /*
    * Rewind directory stream <span class="hljs-keyword">to</span> <span class="hljs-keyword">beginning</span>.
    */
    static void
        rewinddir(
        DIR* dirp)
    {
        /* Rewind wide-<span class="hljs-property">character</span> <span class="hljs-type">string</span> directory stream */
        _wrewinddir(dirp-&gt;wdirp);
    }

    /* Convert multi-byte <span class="hljs-type">string</span> <span class="hljs-keyword">to</span> wide <span class="hljs-property">character</span> <span class="hljs-type">string</span> */
    static int
        dirent_mbstowcs_s(
        size_t *pReturnValue,
        wchar_t *wcstr,
        size_t sizeInWords,
        const char *mbstr,
        size_t <span class="hljs-command">count</span>)
    {
        int <span class="hljs-keyword">error</span>;

<span class="hljs-comment">#if defined(_MSC_VER)  &amp;&amp;  _MSC_VER &gt;= 1400</span>

        /* Microsoft Visual Studio <span class="hljs-number">2005</span> <span class="hljs-keyword">or</span> later */
        <span class="hljs-keyword">error</span> = mbstowcs_s(pReturnValue, wcstr, sizeInWords, mbstr, <span class="hljs-command">count</span>);

<span class="hljs-comment">#else</span>

        /* Older Visual Studio <span class="hljs-keyword">or</span> non-Microsoft compiler */
        size_t n;

        /* Convert <span class="hljs-keyword">to</span> wide-<span class="hljs-property">character</span> <span class="hljs-type">string</span> (<span class="hljs-keyword">or</span> <span class="hljs-command">count</span> <span class="hljs-property">characters</span>) */
        n = mbstowcs(wcstr, mbstr, sizeInWords);
        <span class="hljs-keyword">if</span> (!wcstr || n &lt; <span class="hljs-command">count</span>) {

            /* Zero-terminate output buffer */
            <span class="hljs-keyword">if</span> (wcstr  &amp;&amp;  sizeInWords) {
                <span class="hljs-keyword">if</span> (n &gt;= sizeInWords) {
                    n = sizeInWords - <span class="hljs-number">1</span>;
                }
                wcstr[n] = <span class="hljs-number">0</span>;
            }

            /* Length <span class="hljs-keyword">of</span> resuting multi-byte <span class="hljs-type">string</span> WITH zero terminator */
            <span class="hljs-keyword">if</span> (pReturnValue) {
                *pReturnValue = n + <span class="hljs-number">1</span>;
            }

            /* Success */
            <span class="hljs-keyword">error</span> = <span class="hljs-number">0</span>;

        }
        <span class="hljs-keyword">else</span> {

            /* Could <span class="hljs-keyword">not</span> convert <span class="hljs-type">string</span> */
            <span class="hljs-keyword">error</span> = <span class="hljs-number">1</span>;

        }

<span class="hljs-comment">#endif</span>
<span class="hljs-command">
        return</span> <span class="hljs-keyword">error</span>;
    }

    /* Convert wide-<span class="hljs-property">character</span> <span class="hljs-type">string</span> <span class="hljs-keyword">to</span> multi-byte <span class="hljs-type">string</span> */
    static int
        dirent_wcstombs_s(
        size_t *pReturnValue,
        char *mbstr,
        size_t sizeInBytes, /* max size <span class="hljs-keyword">of</span> mbstr */
        const wchar_t *wcstr,
        size_t <span class="hljs-command">count</span>)
    {
        int <span class="hljs-keyword">error</span>;

<span class="hljs-comment">#if defined(_MSC_VER)  &amp;&amp;  _MSC_VER &gt;= 1400</span>

        /* Microsoft Visual Studio <span class="hljs-number">2005</span> <span class="hljs-keyword">or</span> later */
        <span class="hljs-keyword">error</span> = wcstombs_s(pReturnValue, mbstr, sizeInBytes, wcstr, <span class="hljs-command">count</span>);

<span class="hljs-comment">#else</span>

        /* Older Visual Studio <span class="hljs-keyword">or</span> non-Microsoft compiler */
        size_t n;

        /* Convert <span class="hljs-keyword">to</span> multi-byte <span class="hljs-type">string</span> (<span class="hljs-keyword">or</span> <span class="hljs-command">count</span> <span class="hljs-keyword">the</span> <span class="hljs-type">number</span> <span class="hljs-keyword">of</span> bytes needed) */
        n = wcstombs(mbstr, wcstr, sizeInBytes);
        <span class="hljs-keyword">if</span> (!mbstr || n &lt; <span class="hljs-command">count</span>) {

            /* Zero-terminate output buffer */
            <span class="hljs-keyword">if</span> (mbstr  &amp;&amp;  sizeInBytes) {
                <span class="hljs-keyword">if</span> (n &gt;= sizeInBytes) {
                    n = sizeInBytes - <span class="hljs-number">1</span>;
                }
                mbstr[n] = '\<span class="hljs-number">0</span>';
            }

            /* Lenght <span class="hljs-keyword">of</span> resulting multi-bytes <span class="hljs-type">string</span> WITH zero-terminator */
            <span class="hljs-keyword">if</span> (pReturnValue) {
                *pReturnValue = n + <span class="hljs-number">1</span>;
            }

            /* Success */
            <span class="hljs-keyword">error</span> = <span class="hljs-number">0</span>;

        }
        <span class="hljs-keyword">else</span> {

            /* Cannot convert <span class="hljs-type">string</span> */
            <span class="hljs-keyword">error</span> = <span class="hljs-number">1</span>;

        }

<span class="hljs-comment">#endif</span>
<span class="hljs-command">
        return</span> <span class="hljs-keyword">error</span>;
    }

    /* Set errno variable */
    static void
        dirent_set_errno(
        int <span class="hljs-keyword">error</span>)
    {
<span class="hljs-comment">#if defined(_MSC_VER)  &amp;&amp;  _MSC_VER &gt;= 1400</span>

        /* Microsoft Visual Studio <span class="hljs-number">2005</span> <span class="hljs-keyword">and</span> later */
        _set_errno(<span class="hljs-keyword">error</span>);

<span class="hljs-comment">#else</span>

        /* Non-Microsoft compiler <span class="hljs-keyword">or</span> older Microsoft compiler */
        errno = <span class="hljs-keyword">error</span>;

<span class="hljs-comment">#endif</span>
    }


<span class="hljs-comment">#ifdef __cplusplus</span>
}
<span class="hljs-comment">#endif</span>
<span class="hljs-comment">#endif /*DIRENT_H*/</span>

</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3da5b833e630396c45bd0a7a1927e84f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">jquery动态修改表单select的option值,从而间接修改option的选中状态</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f165e74e3f27106464f573665b1c6a0b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微信小程序里没有类似 js的 getElementById 方法。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>