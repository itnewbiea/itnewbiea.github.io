<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>4.原子操作类：AtomicLong、LongAdderLong、Accumulator - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="4.原子操作类：AtomicLong、LongAdderLong、Accumulator" />
<meta property="og:description" content="JUC包中有AtomicInteger、AtomicLong和AtomicBoolean等原子性操作类，它们原理类似，下面以AtomicLong为例进行讲解。
AtomicLong 底层的操作自增自减都用Unsafe类中的getAndAddLong方法（获取本类内存偏移值）实现的，getAndAddLong底层用Unsafe类中的CAS方法，大量线程竞争只有一个线程成功，会导致大量的自旋尝试。
public class AtomicLong extends Number implements java.io.Serializable { private static final long serialVersionUID = 1927816293512124184L; // 获取Unsafe实例:AtomicLong类是通过BootStarp类加载器加载的所以可以拿到Unsafe类的实例 private static final Unsafe unsafe = Unsafe.getUnsafe(); // 存放变量value的偏移量 private static final long valueOffset; // 判断JVM是否支持Long类型的无锁CAS static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8(); private static native boolean VMSupportsCS8(); static { try { // 获取value在AtomicLong类中的偏移量 valueOffset = unsafe.objectFieldOffset (AtomicLong.class.getDeclaredField(&#34;value&#34;)); } catch (Exception ex) { throw new Error(ex); } } // 实际变量值 volatile是为了多线程下保证内存的可见性 private volatile long value; public AtomicLong(long initialValue) { value = initialValue; } ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/1a88425d0e695f1da0ac966bf32f0296/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-30T14:44:45+08:00" />
<meta property="article:modified_time" content="2023-06-30T14:44:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">4.原子操作类：AtomicLong、LongAdderLong、Accumulator</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>JUC包中有AtomicInteger、AtomicLong和AtomicBoolean等原子性操作类，它们原理类似，下面以AtomicLong为例进行讲解。</p> 
<h2><a id="AtomicLong_3"></a>AtomicLong</h2> 
<blockquote> 
 <p>底层的操作自增自减都用<code>Unsafe</code>类中的<code>getAndAddLong</code>方法（获取本类内存偏移值）实现的，<code>getAndAddLong</code>底层用<strong>Unsafe类中的CAS方法</strong>，大量线程竞争只有一个线程成功，会导致大量的<code>自旋尝试</code>。</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicLong</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">1927816293512124184L</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取Unsafe实例:AtomicLong类是通过BootStarp类加载器加载的所以可以拿到Unsafe类的实例</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Unsafe</span> unsafe <span class="token operator">=</span> <span class="token class-name">Unsafe</span><span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 存放变量value的偏移量</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> valueOffset<span class="token punctuation">;</span>
	<span class="token comment">// 判断JVM是否支持Long类型的无锁CAS</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> VM_SUPPORTS_LONG_CAS <span class="token operator">=</span> <span class="token class-name">VMSupportsCS8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token class-name">VMSupportsCS8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 获取value在AtomicLong类中的偏移量</span>
            valueOffset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span>objectFieldOffset
                <span class="token punctuation">(</span><span class="token class-name">AtomicLong</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 实际变量值 volatile是为了多线程下保证内存的可见性 </span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> value<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token keyword">long</span> initialValue<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        value <span class="token operator">=</span> initialValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_33"></a>递增和递减操作代码</h3> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1L</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1L</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">decrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1L</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1L</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// Unsafe类中的getAndAddLong方法  </span>
<span class="token comment">// 参数1: AtomicLong实例的引用</span>
<span class="token comment">// 参数2: value变量在AtomicLong中的偏移值</span>
<span class="token comment">// 参数3: 要设置的第二个变量的值</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">getAndAddLong</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">long</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">long</span> var6<span class="token punctuation">;</span>
    <span class="token comment">//CAS操作设置var1对象偏移为var2处的值增加var4</span>
    <span class="token keyword">do</span> <span class="token punctuation">{<!-- --></span>
        var6 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getLongVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var6<span class="token punctuation">,</span> var6 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> var6<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上述代码中，valueOffset为AtomicLong在static语句块中进行初始化时通过<code>Unsafe类获得的本类中value属性的内存偏移值</code>。</p> 
<p>可以看到，上述四个方法都是<code>基于Unsafe类中的getAndAddLong方法</code>（原子性操作）实现的。</p> 
<h3><a id="compareAndSet_66"></a>compareAndSet方法</h3> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">long</span> expect<span class="token punctuation">,</span> <span class="token keyword">long</span> update<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>内部还是调用了<strong>Unsafe类中的CAS方法</strong>。如果原子变量中的value值等于expect，则使用update值更新该值并返回true，否则false。</p> 
</blockquote> 
<h3><a id="AtomicLong_76"></a>AtomicLong使用示例</h3> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicLongDemo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">AtomicLong</span> al <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">addNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> al<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token annotation punctuation">@Override</span>
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token class-name">AtomicLongDemo</span><span class="token punctuation">.</span><span class="token function">addNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 等待线程运行完</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"final result is "</span> <span class="token operator">+</span> <span class="token class-name">AtomicLongDemo</span><span class="token punctuation">.</span><span class="token function">addNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>AtomicLong使用CAS非阻塞算法，性能比使用synchronized等的阻塞算法实现同步好很多。但在高并发下，大量线程会同时去竞争<strong>更新同一个原子变量</strong>，由于同时只有一个线程的CAS会成功，会造成大量的<code>自旋尝试</code>，十分浪费CPU资源。因此，JDK8中新增了原子操作类LongAdder。</p> 
<h2><a id="LongAdder_108"></a>LongAdder</h2> 
<p>JDK8中新增的原子操作类LongAdder。</p> 
<p>问题：</p> 
<ol><li> <p>LongAdder结构是怎样的</p> 
  <blockquote> 
   <p>将一个原子性变量分解成多个原子性变量。内部维护多个Cell（初始值为0的long类型变量），如果在一个Cell原子变量失败了会尝试在其他Cell变量上进行CAS尝试。</p> 
   <p>在获取LongAdder当前值时，是把所有的Cell变量值的value值累加再加上base返回的。</p> 
   <p>延迟初始化原子更新数组（Cell数组默认为null），Cells占用内存比较大，在需要时创建，惰性加载，Cell数组null并且并发线程较少时，所有的累加都是对base变量进行的。</p> 
  </blockquote> </li><li> <p>当前线程应该访问Cell数组里面的哪一个Cell元素</p> 
  <blockquote> 
   <p><strong>getProbe() &amp; m</strong></p> 
   <p>m是当前cells数组元素个数-1</p> 
   <p>getProbe()用于获取当前线程中变量threadLocalRandomProbe的值</p> 
  </blockquote> </li><li> <p>如何初始化Cell数组</p> 
  <blockquote> 
   <p>cellsBusy是一个标识，0：当前cells数组没有在被初始化或扩容也没有新建Cell元素;1:cells数组在被初始化或扩容或在新建Cell元素。通过CAS操作进行0、1状态切换使用casCellsBusy函数。</p> 
   <p>初始化cells元素个数为2，h &amp; 1 计算当前线程应该访问cells数组的哪个位置,即当前线程的threadLocalRandomProbe变量值 &amp; （cells数组元素个数-1）</p> 
   <p>标识cells数组已被初始化。</p> 
   <p>最后对cellsBusy重置标记 线程安全因为cellsBusy是volatile保证了内存可见性，且没有其他地方修改cellsBusy的值。</p> 
   <pre><code class="prism language-java">    <span class="token comment">// 初始化cells数组(重点)</span>
    <span class="token comment">// cellsBusy是一个标识，0：当前cells数组没有在被初始化或扩容也没有新建Cell元素;1:cells数组在被初始化或扩容或在新建Cell元素</span>
    <span class="token comment">// 通过CAS操作进行0、1状态切换使用casCellsBusy函数。</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> cells <span class="token operator">==</span> as <span class="token operator">&amp;&amp;</span> <span class="token function">casCellsBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">boolean</span> init <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>                           
            <span class="token keyword">if</span> <span class="token punctuation">(</span>cells <span class="token operator">==</span> as<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 初始化cells元素个数为2</span>
                <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token comment">// h &amp; 1 计算当前线程应该访问cells数组的哪个位置,即当前线程的threadLocalRandomProbe变量值 &amp; （cells数组元素个数-1）</span>
                rs<span class="token punctuation">[</span>h <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
                cells <span class="token operator">=</span> rs<span class="token punctuation">;</span>
                <span class="token comment">// 标识cells数组已被初始化</span>
                init <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 对cellsBusy重置标记 线程安全因为cellsBusy是volatile保证了内存可见性，且没有其他地方修改cellsBusy的值</span>
            cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre> 
  </blockquote> </li><li> <p>Cell数组如何扩容</p> 
  <blockquote> 
   <p>扩容条件：当前cells元素个数小于CPU个数且有冲突（当前多个线程cells访问了cells中同一个元素）使其中一个线程CAS失败才会进行扩容。</p> 
   <p>注意：每个CPU都运行一个线程时，也就是每个cell都使用一个CPU处理时性能才是最高的。</p> 
   <p>扩容操作：</p> 
   <ol><li> <p>先通过CAS设置cellBusy为1（casCellsBusy），然后才能进行扩容</p> </li><li> <p>将容量扩充到之前的2倍，并复制Cell元素到扩容后的数组，扩容后的数组里除了包含复制过来的元素之外还包含其他新元素，新元素为null</p> <pre><code class="prism language-java"><span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
   rs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> as<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
cells <span class="token operator">=</span> rs<span class="token punctuation">;</span>
</code></pre> </li></ol> 
   <p>整个扩充逻辑：</p> 
   <pre><code class="prism language-java">		 <span class="token comment">// 如果当前cells长度大于CPU个数，则不进行扩容。如果当前cells已经过时（其他线程对cells执行了扩容操作，改变了cells指向），也不会扩容。因为每个CPU都运行一个线程时，也就是每个cell都使用一个CPU处理时性能才是最高的。</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> NCPU <span class="token operator">||</span> cells <span class="token operator">!=</span> as<span class="token punctuation">)</span>
                collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> 
           <span class="token comment">// 是否有冲突，执行到此处说明a.cas()执行失败，即有冲突，将collide置为true，跳过扩容阶段，重新获取probe，到cells不同位置尝试cas，再次失败则扩容</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>collide<span class="token punctuation">)</span>
                collide <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
            <span class="token comment">// 扩容（重点）</span>
            <span class="token comment">// 如果当前元素个数没有达到CPU个数并且有冲突(当前多个线程访问了cells中的同一个元素,从而导致冲突使其中一个线程CAS失败)则扩容。</span>
            <span class="token comment">// 通过CAS设置cellBusy为1</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">casCellsBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>cells <span class="token operator">==</span> as<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        <span class="token comment">// 将容量扩充到之前的2倍,并复制Cell元素到扩容后的数组,扩容后的数组里除了包含复制过来的元素之外还包含其他新元素，新元素为null</span>
                        <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
                            rs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> as<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                        cells <span class="token operator">=</span> rs<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
                    cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 扩容后再次尝试（扩容后cells长度改变，</span>
                          <span class="token comment">// 根据(n - 1) &amp; h计算当前线程在cells中对应元素下标会变化，减少再次冲突的可能性）</span>
            <span class="token punctuation">}</span>
            h <span class="token operator">=</span> <span class="token function">advanceProbe</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重新计算线程probe，减小下次访问cells元素时的冲突机会</span>
        <span class="token punctuation">}</span>
</code></pre> 
  </blockquote> </li><li> <p>线程访问分配的Cell元素有冲突后如何处理</p> 
  <blockquote> 
   <p>对CAS失败的线程重新计算当前线程的随机值threadLocalRandomProbe，以减少下次访问cells元素冲突的机会</p> 
   <pre><code class="prism language-java"><span class="token comment">// 重新计算线程probe，减小下次访问cells元素时的冲突机会</span>
            h <span class="token operator">=</span> <span class="token function">advanceProbe</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> 
  </blockquote> </li><li> <p>如何保证线程操作被分配的Cell元素的原子性</p> 
  <blockquote> 
   <p>当前线程通过分配的Cell元素的cas函数来保证对Cell元素value值更新的原子性。</p> 
   <p>a.cas(v = a.value, v + x)</p> 
  </blockquote> </li></ol> 
<p>由上可知，AtomicLong的性能瓶颈是多个线程同时去竞争一个变量的更新权导致的。而<strong>LongAdder通过将一个变量分解成多个变量</strong>，让同样多的线程去竞争多个资源解决了此问题。</p> 
<h3><a id="_232"></a>原理</h3> 
<p><img src="https://images2.imgbox.com/0a/1a/Jx34wpVG_o.png" alt=""></p> 
<p>如图，LongAdder内部维护了多个<code>Cell</code>，每个Cell内部有一个<code>初始值为0的long类型</code>变量，这样，在同等并发下，对单个变量的争夺会变少。此外，<code>多个线程争夺同一个变量失败时，会到另一个Cell上去尝试</code>，增加了重试成功的可能性。<code>当LongAdder要获取当前值时，将所有Cell的值于base相加返回即可</code>。</p> 
<p>LongAdder维护了一个<code>初始值为null的Cell数组和一个基值变量base</code>。当一开始<code>Cell数组为空且并发线程较少时，仅使用base进行累加</code>。<code>当并发增大时，会动态地增加Cell数组的容量</code>。</p> 
<p>Cell类中使用了**@sun.misc.Contented注解进行了字节填充**，解决了由于连续分布于数组中且被多个线程操作可能造成的<strong>伪共享</strong>问题(关于伪共享，可查看<a href="https://www.cnblogs.com/cyfonly/p/5800758.html" rel="nofollow">《伪共享（false sharing），并发编程无声的性能杀手》</a>这篇文章)。</p> 
<h3><a id="LongAdder_242"></a>LongAdder</h3> 
<p>先看<strong>LongAdder</strong>的定义</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LongAdder</span> <span class="token keyword">extends</span> <span class="token class-name">Striped64</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span>
</code></pre> 
<p><strong>Striped64类</strong>中有如下三个变量：</p> 
<pre><code class="prism language-java"><span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cells<span class="token punctuation">;</span>

<span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> base<span class="token punctuation">;</span>
<span class="token comment">// 实现CAS自旋锁，状态只有0、1</span>
<span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> cellsBusy<span class="token punctuation">;</span>
</code></pre> 
<p><code>cellsBusy用于实现自旋锁</code>，状态值只有0和1，当创建Cell元素、扩容Cell数组或初始化Cell数组时，使用CAS操作该变量来保证同时只有一个变量可以进行其中之一的操作。</p> 
<h3><a id="Cell_262"></a>Cell</h3> 
<p>下面看<strong>Cell的定义</strong>：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@sun.misc.Contended</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Cell</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">volatile</span> <span class="token keyword">long</span> value<span class="token punctuation">;</span> <span class="token comment">// volatile确保内存可见性</span>
    <span class="token class-name">Cell</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> value <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">cas</span><span class="token punctuation">(</span><span class="token keyword">long</span> cmp<span class="token punctuation">,</span> <span class="token keyword">long</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> cmp<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// CAS操作保证value原子性</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Unsafe mechanics</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Unsafe</span> UNSAFE<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> valueOffset<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            UNSAFE <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Unsafe</span><span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> ak <span class="token operator">=</span> <span class="token class-name">Cell</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
            valueOffset <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span>objectFieldOffset
                <span class="token punctuation">(</span>ak<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>将value声明为volatile确保了内存可见性，CAS操作保证了value值的原子性，@sun.misc.Contented注解的使用解决了伪共享问题。</p> 
</blockquote> 
<h3><a id="LongAdder_292"></a>LongAdder方法</h3> 
<p>下面来看LongAdder中的几个方法：</p> 
<ul><li><strong>long Sum()</strong>：返回当前的值，内部操作是累加所有Cell内部的value值后再累加base。sum的结果并非一个精确值，因为计算总和时并没有对Cell数组加锁，累加过程中Cell的值可能被更改。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> as <span class="token operator">=</span> cells<span class="token punctuation">;</span> 
    <span class="token class-name">Cell</span> a<span class="token punctuation">;</span>
    <span class="token keyword">long</span> sum <span class="token operator">=</span> base<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>as <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> as<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                sum <span class="token operator">+=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>void reset()</strong>：将base和Cell数组中非空元素的值置为0。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> as <span class="token operator">=</span> cells<span class="token punctuation">;</span> <span class="token class-name">Cell</span> a<span class="token punctuation">;</span>
    base <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>as <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> as<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                a<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>long sumThenRest()</strong>：sum的改造版本。使用sum累加对应的Cell值后，把当前Cell的值重置为0，base重置为0。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">sumThenReset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> as <span class="token operator">=</span> cells<span class="token punctuation">;</span> <span class="token class-name">Cell</span> a<span class="token punctuation">;</span>
    <span class="token keyword">long</span> sum <span class="token operator">=</span> base<span class="token punctuation">;</span>
    base <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>as <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> as<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                sum <span class="token operator">+=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                a<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>void add(long x)</strong>：判断cells数组是否为空，非空则进入内层，否则尝试直接通过CAS操作在base上进行add。内层代码中，声明了一个uncontented变量来记录调用longAccumulate方法前在相应cell上是否进行了失败的CAS操作。当前线程通过分配Cell元素的cas函数来保证对Cell元素value值更新的原子性。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> as<span class="token punctuation">;</span> <span class="token keyword">long</span> b<span class="token punctuation">,</span> v<span class="token punctuation">;</span> <span class="token keyword">int</span> m<span class="token punctuation">;</span> <span class="token class-name">Cell</span> a<span class="token punctuation">;</span>
    <span class="token comment">// 判断cells是否为空，如果不为空则直接进入内层判断，</span>
    <span class="token comment">// 否则尝试通过CAS在base上进行add操作，若CAS成功则结束，否则进入内层</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>as <span class="token operator">=</span> cells<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">casBase</span><span class="token punctuation">(</span>b <span class="token operator">=</span> base<span class="token punctuation">,</span> b <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 记录cell上的CAS操作是否失败</span>
        <span class="token keyword">boolean</span> uncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>as <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>m <span class="token operator">=</span> as<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>
            <span class="token comment">// 计算当前线程应该访问cells数组的哪个元素：getProbe() &amp; m (m是当前cells数组元素个数-1,getProbe()用于获取当前线程中变量threadLocalRandomProbe的值,这个值一开始为0)</span>
            <span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span><span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> m<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span>
            <span class="token comment">// 尝试通过CAS操作在对应cell上add</span>
            <span class="token operator">!</span><span class="token punctuation">(</span>uncontended <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">cas</span><span class="token punctuation">(</span>v <span class="token operator">=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">,</span> v <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">longAccumulate</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> uncontended<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前线程中变量threadLocalRandomProbe的值,这个值一开始为0,如果是0就要初始化</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="longAccumelate_367"></a>longAccumelate方法</h3> 
<p>longAccumulate时<strong>Striped64类</strong>中定义的，其中<strong>包含了初始化cells数组，改变cells数组长度，新建cell等逻辑。</strong></p> 
<blockquote> 
 <p>判断cells是否为空或者长度为0：</p> 
 <ul><li> <p>如果<strong>空或者长度为0</strong>则尝试进行<strong>cells数组初始化</strong>，初始化失败的话则尝试通过<strong>CAS操作在base上进行add</strong>，仍然失败则重走一次流程；</p> </li><li> <p>如果<strong>cells不为空且长度大于0</strong>，则<strong>获取当前线程对应于cells中的元素，如果该元素为null则尝试创建</strong>，否则尝试<strong>通过CAS操作在上面进行add</strong>，<strong>仍失败则扩容</strong>。</p> </li></ul> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">longAccumulate</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token class-name">LongBinaryOperator</span> fn<span class="token punctuation">,</span>
                              <span class="token keyword">boolean</span> wasUncontended<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 初始化当前线程的变量threadLocalRandomProbe的值</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">=</span> <span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        h <span class="token operator">=</span> <span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 标记执行longAccumulate前对相应cell的CAS操作是否失败，失败为false</span>
        wasUncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
    <span class="token comment">// 是否冲突，如果当前线程尝试访问的cell元素与其他线程冲突，则为true</span>
    <span class="token keyword">boolean</span> collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> 
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> as<span class="token punctuation">;</span> <span class="token class-name">Cell</span> a<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token keyword">long</span> v<span class="token punctuation">;</span>
        <span class="token comment">// 当前cells不为空且元素个数大于0则进入内层，否则尝试初始化</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>as <span class="token operator">=</span> cells<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> as<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 当前线程调用add方法并根据当前线程的随机数threadLocalRandomProbe和cells元素个数计算要访问的Cell元素下标 如果发现下标元素的值为null</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//</span>
                <span class="token comment">// 尝试添加新的cell</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>   
                    <span class="token comment">// 新增一个Cell元素到cells数组，并且将其添加到cells数组之前要竞争 设置cellsBusy为1</span>
                    <span class="token class-name">Cell</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">casCellsBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        <span class="token keyword">boolean</span> created <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>               <span class="token comment">// Recheck under lock</span>
                            <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rs<span class="token punctuation">;</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rs <span class="token operator">=</span> cells<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
                                <span class="token punctuation">(</span>m <span class="token operator">=</span> rs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
                                rs<span class="token punctuation">[</span>j <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                                rs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">;</span>
                                created <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
                            cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>created<span class="token punctuation">)</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token keyword">continue</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
             <span class="token comment">// 如果已经进行了失败的CAS操作</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>wasUncontended<span class="token punctuation">)</span> 
                <span class="token comment">// 则不调用下面的a.cas()函数（反正肯定是失败的）,而是重新计算probe值来尝试</span>
                wasUncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 
            <span class="token comment">// 当前Cell存在,则执行CAS设置</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">cas</span><span class="token punctuation">(</span>v <span class="token operator">=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fn <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> v <span class="token operator">+</span> x <span class="token operator">:</span>fn<span class="token punctuation">.</span><span class="token function">applyAsLong</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
           <span class="token comment">// 如果当前cells长度大于CPU个数，则不进行扩容。如果当前cells已经过时（其他线程对cells执行了扩容操作，改变了cells指向），也不会扩容</span>
           <span class="token comment">// 因为每个CPU都运行一个线程时，也就是每个cell都使用一个CPU处理时性能才是最高的。</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> NCPU <span class="token operator">||</span> cells <span class="token operator">!=</span> as<span class="token punctuation">)</span>
                collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> 
           <span class="token comment">// 是否有冲突，执行到此处说明a.cas()执行失败，即有冲突，将collide置为true，跳过扩容阶段，重新获取probe，到cells不同位置尝试cas，再次失败则扩容</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>collide<span class="token punctuation">)</span>
                collide <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
            <span class="token comment">// 扩容（重点）</span>
            <span class="token comment">// 如果当前元素个数没有达到CPU个数并且有冲突(当前多个线程访问了cells中的同一个元素,从而导致冲突使其中一个线程CAS失败)则扩容。</span>
            <span class="token comment">// 通过CAS设置cellBusy为1</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">casCellsBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>cells <span class="token operator">==</span> as<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        <span class="token comment">// 将容量扩充到之前的2倍,并复制Cell元素到扩容后的数组,扩容后的数组里除了包含复制过来的元素之外还包含其他新元素，新元素为null</span>
                        <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
                            rs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> as<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                        cells <span class="token operator">=</span> rs<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
                    cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 扩容后再次尝试（扩容后cells长度改变，</span>
                          <span class="token comment">// 根据(n - 1) &amp; h计算当前线程在cells中对应元素下标会变化，减少再次冲突的可能性）</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 重新计算线程probe，减小下次访问cells元素时的冲突机会</span>
            h <span class="token operator">=</span> <span class="token function">advanceProbe</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>
        <span class="token comment">// 初始化cells数组(重点)</span>
        <span class="token comment">// cellsBusy是一个标识，0：当前cells数组没有在被初始化或扩容也没有新建Cell元素;1:cells数组在被初始化或扩容或在新建Cell元素</span>
        <span class="token comment">// 通过CAS操作进行0、1状态切换使用casCellsBusy函数。</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> cells <span class="token operator">==</span> as <span class="token operator">&amp;&amp;</span> <span class="token function">casCellsBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">boolean</span> init <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>                           
                <span class="token keyword">if</span> <span class="token punctuation">(</span>cells <span class="token operator">==</span> as<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// 初始化cells元素个数为2</span>
                    <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    <span class="token comment">// h &amp; 1 计算当前线程应该访问cells数组的哪个位置,即当前线程的threadLocalRandomProbe变量值 &amp; （cells数组元素个数-1）</span>
                    rs<span class="token punctuation">[</span>h <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    cells <span class="token operator">=</span> rs<span class="token punctuation">;</span>
                    <span class="token comment">// 标识cells数组已被初始化</span>
                    init <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 对cellsBusy重置标记 线程安全因为cellsBusy是volatile保证了内存可见性，且没有其他地方修改cellsBusy的值</span>
                cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>init<span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 尝试通过base的CAS操作进行add，成功则结束当前函数，否则再次循环</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casBase</span><span class="token punctuation">(</span>v <span class="token operator">=</span> base<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fn <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> v <span class="token operator">+</span> x <span class="token operator">:</span>fn<span class="token punctuation">.</span><span class="token function">applyAsLong</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h2><a id="LongAccumulator_486"></a>LongAccumulator</h2> 
<p>LongAdder是LongAccumulator的特例，两者都继承自Striped64。</p> 
<p>看如下代码：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">LongAccumulator</span><span class="token punctuation">(</span><span class="token class-name">LongBinaryOperator</span> accumulatorFunction<span class="token punctuation">,</span>
                        <span class="token keyword">long</span> identity<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>function <span class="token operator">=</span> accumulatorFunction<span class="token punctuation">;</span>
    base <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>identity <span class="token operator">=</span> identity<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">LongBinaryOperator</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">long</span> <span class="token function">applyAsLong</span><span class="token punctuation">(</span><span class="token keyword">long</span> left<span class="token punctuation">,</span> <span class="token keyword">long</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>LongAccumulator构造器允许传入一个双目运算符接口用于自定义加法规则，还允许传入一个初始值。</p> 
<p>自定义的加法函数是如何被应用的呢？以上提到的longAccumulate()方法中有如下代码：</p> 
<pre><code class="prism language-java">a<span class="token punctuation">.</span><span class="token function">cas</span><span class="token punctuation">(</span>v <span class="token operator">=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fn <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> v <span class="token operator">+</span> x <span class="token operator">:</span>fn<span class="token punctuation">.</span><span class="token function">applyAsLong</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>LongAdder的add()方法中调用longAccumulate()方法时传入的是null，而LongAccumulator的accumulate()方法传入的是this.function，即自定义的加法函数。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ed359c3a9ccf0d2968ba4f5bea4bf622/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ChatGPT 有什么新奇的使用方式？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/545f626079a8a4f52445c2974720abfe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;】模板进阶</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>