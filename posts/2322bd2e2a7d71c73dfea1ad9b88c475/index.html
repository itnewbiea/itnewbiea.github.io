<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;单元测试Gtest&#43;Stub攻略 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;单元测试Gtest&#43;Stub攻略" />
<meta property="og:description" content="C&#43;&#43;单元测试Gtest&#43;Stub攻略 前言环境搭建编写单元测试gtest的使用Stub/StubExt的使用 前言 笔者环境为linux环境(deepin),以下均在此环境进行
环境搭建 Gtest源码链接
Stub源码链接
StubExt源码链接
Stub的使用方法在cpp-stub/README_zh.md中有讲解
StubExt的使用方法在 cpp-stub-ext/ README.md中有讲解
StubExt可支持Lambda表达式进行打桩写Gtest时如果想获取一个固定的返回值或者出参十分好用
搭建环境时如果不想下载Gtest源码可以直接使用Stub中提供的Gtest库
仔细阅读README中说明,查看Stub源码提供的Demo
stubext.h中需要引用stub.h,并且需要将stub.h中的private改为protected
写Gtest时只要引用
#include “gtest/gtest.h”
#include “stubext.h”
#include “addr_pri.h”
编写单元测试 gtest的使用 Gtest提供了几个不同case方法进行测试不同的用例。主要常见的有TEST/TEST_F及TEST_P宏的使用。在每个TestCase中可以通过断言提供的方法进行控制检查程序的预期走向是否是期望的结果，从而以此来判定程序的正确性。
TEST的第一个参数一般情况下使用类名或者文件名,第二个参数一般情况下写要测试的函数名,如果一个函数需要写多个测试用例第二个参数增加一些后缀区分
TEST(test_case_name, test_name){ //编写你的TestCase //使用EXPECT_EQ,ASSERT_EQ等去判断TestCase的值是否和期望值一致 } 这里说下EXPECT_*和ASSERT_*的区别,EXPECT_*如果当前不成立会继续执行当前TestCase而ASSERT_*如果不成立会直接结束当前TestCase
TEST_F的第一个参数为TestBase第二个参数一般情况下写要测试的函数名,如果一个函数需要写多个测试用例第二个参数增加一些后缀区分
class TestTmp{ public: void setA(int a){ this-&gt;a=a; } int getA(){ return a; } private: int a; }; class TestBase : public ::testing::Test { protected: // 为测试准备数据对象 void SetUp() override { t.setA(10); } // 清除资源 void TearDown() override { } TestTmp t; }; TEST_F(TestBase,test1){ int b =t." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2322bd2e2a7d71c73dfea1ad9b88c475/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-25T16:05:07+08:00" />
<meta property="article:modified_time" content="2023-05-25T16:05:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;单元测试Gtest&#43;Stub攻略</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>C++单元测试Gtest+Stub攻略</h4> 
 <ul><li><a href="#_1" rel="nofollow">前言</a></li><li><a href="#_3" rel="nofollow">环境搭建</a></li><li><a href="#_24" rel="nofollow">编写单元测试</a></li><li><ul><li><a href="#gtest_25" rel="nofollow">gtest的使用</a></li><li><a href="#StubStubExt_130" rel="nofollow">Stub/StubExt的使用</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>前言</h2> 
<p>笔者环境为linux环境(deepin),以下均在此环境进行</p> 
<h2><a id="_3"></a>环境搭建</h2> 
<p><a href="https://gitcode.net/mirrors/google/googletest" rel="nofollow">Gtest源码链接</a><br> <a href="https://gitee.com/coolxv/cpp-stub" rel="nofollow">Stub源码链接</a><br> <a href="https://gitee.com/clauszy/cpp-stub-ext/" rel="nofollow">StubExt源码链接</a></p> 
<p>Stub的使用方法在cpp-stub/README_zh.md中有讲解<br> StubExt的使用方法在 cpp-stub-ext/ README.md中有讲解</p> 
<p>StubExt可支持Lambda表达式进行打桩写Gtest时如果想获取一个固定的返回值或者出参十分好用</p> 
<p>搭建环境时如果不想下载Gtest源码可以直接使用Stub中提供的Gtest库<br> 仔细阅读README中说明,查看Stub源码提供的Demo</p> 
<p><img src="https://images2.imgbox.com/31/64/3WGeYTwm_o.png" alt="在这里插入图片描述"><br> stubext.h中需要引用stub.h,并且需要将stub.h中的private改为protected</p> 
<p>写Gtest时只要引用<br> #include “gtest/gtest.h”<br> #include “stubext.h”<br> #include “addr_pri.h”</p> 
<h2><a id="_24"></a>编写单元测试</h2> 
<h3><a id="gtest_25"></a>gtest的使用</h3> 
<p>Gtest提供了几个不同case方法进行测试不同的用例。主要常见的有TEST/TEST_F及TEST_P宏的使用。在每个TestCase中可以通过断言提供的方法进行控制检查程序的预期走向是否是期望的结果，从而以此来判定程序的正确性。</p> 
<p>TEST的第一个参数一般情况下使用类名或者文件名,第二个参数一般情况下写要测试的函数名,如果一个函数需要写多个测试用例第二个参数增加一些后缀区分</p> 
<pre><code>TEST(test_case_name, test_name){
	//编写你的TestCase
	//使用EXPECT_EQ,ASSERT_EQ等去判断TestCase的值是否和期望值一致
}
</code></pre> 
<p>这里说下EXPECT_*和ASSERT_*的区别,EXPECT_*如果当前不成立会继续执行当前TestCase而ASSERT_*如果不成立会直接结束当前TestCase</p> 
<p>TEST_F的第一个参数为TestBase第二个参数一般情况下写要测试的函数名,如果一个函数需要写多个测试用例第二个参数增加一些后缀区分</p> 
<pre><code>class TestTmp{
    public:
    void setA(int a){
        this-&gt;a=a;
    }
    int getA(){
        return a;
    }
    private:
    int a;    
};
class TestBase : public ::testing::Test
{
  protected:
    // 为测试准备数据对象
    void SetUp() override
    {
    	t.setA(10);
    }
    // 清除资源
    void TearDown() override
    {
    }
	TestTmp t;
};
TEST_F(TestBase,test1){
    int b =t.getA();
    EXPECT_EQ(10,b);
    t.setA(99);
    int c = t.getA();
    EXPECT_EQ(99,c);
}
TEST_F(TestBase,test2){
    int b =t.getA();
    EXPECT_EQ(10,b);
}
</code></pre> 
<p>输出如下:<br> <img src="https://images2.imgbox.com/3c/23/CQbvwSk3_o.png" alt="在这里插入图片描述"><br> 通过输出可以看出在test1中调用的t.setA(99);在test2中并未生效,所以TEST_F只是通过自定义一个类实现了一些资源的准备,在各个TEST_F中都可以使用准备好的资源,如果在TEST_F中修改了准备好的资源也只对当前这个TEST_F有效.</p> 
<p>TEST_P的参数和TEST_F类似</p> 
<pre><code>class TestTmp{
    public:
        void setA(std::string a){
            this-&gt;a=a;
        }
        std::string getA(){
            return a;
        }
    private:
    std::string a;
};
class StringsFixture : public ::testing::TestWithParam&lt;std::string&gt;
{
    public:
        virtual void SetUp()
        {
            t.setA("test");
        }
        virtual void TearDown()
        {
            // Do some tear down
        }
        TestTmp t;
};


INSTANTIATE_TEST_SUITE_P(
    aValue,  // Instantiation name
    StringsFixture,  // Fixture controller
    ::testing::Values(  // Parameters
        "qwe",
        "asd",
        "zxc",
        "bnm",
        "tyu",
        "iop"
    )
);
TEST_P(StringsFixture,test1){
    auto test_str = this-&gt;GetParam();
    EXPECT_STREQ(t.getA().c_str(),"test");
    t.setA(test_str);
    EXPECT_STREQ(t.getA().c_str(),test_str.c_str());
}

</code></pre> 
<p>TEST_P相当于对这个案例做了一个循环调用,参数值设置几个就会调用几次,每次调用可以通过this-&gt;GetParam();获取之前预制的参数值.如果有案例需要重复输入不同的参数去测试就可以使用这种方式来减少代码量.</p> 
<h3><a id="StubStubExt_130"></a>Stub/StubExt的使用</h3> 
<p>Stub是通过改变运行是调用进程内存页,将原本调用的函数地址改为打桩函数的地址从而去满足打桩需求.</p> 
<pre><code>int fun()
{
    int a=10;
    LOGD("--------------------------------------------fun");
    return a;
}
int fun_stub()
{
    int a=99;
    LOGD("--------------------------------------------stub");
    return a;
}
TEST(test_case_name, test_name)
{
    Stub stub;
    stub.set(fun, fun_stub);
    int ret = fun(); //调用fun就去执行fun_stub中的代码
    EXPECT_EQ(ret, 99);
    stub.reset(fun);
    ret = fun(); //此时调用fun就执行fun中的代码
    EXPECT_EQ(ret, 10);
}
TEST(test_case_name, test_name1)
{
    StubExt stub;
    int dd = 0;
    stub.set_lamda(fun, [&amp;dd](){
        dd = 55;
        return dd;
    });
    int ret = fun(); //调用fun就去执行fun_stub中的代码
    EXPECT_EQ(ret, 55);
}
</code></pre> 
<p>Stub只可以通过桩函数fun_stub实现打桩,StubExt可以通过set设置桩函数也可以通过set_lamda设置lambda表达式并且如果你不关注返回值和参数可以统统都不设置让设置的函数执行个空相当于被打桩函数被跳过.更加详细的使用方式请参考README和doc_zh.md<br> 注意事项:<br> Stub::set()和Stub::reset()一定要成对出现除非你想在后面执行的程序都走到桩函数中去<br> addr_pri.h中定义了获取私有成员私有方法的宏这里简单列举,具体的可以到README和doc_zh.md中通过下面的关键字搜索</p> 
<pre><code>Declaration:
    ACCESS_PRIVATE_FIELD(ClassName, TypeName, FieldName)
    ACCESS_PRIVATE_FUN(ClassName, TypeName, FunName)
    ACCESS_PRIVATE_STATIC_FIELD(ClassName, TypeName, FieldName)
    ACCESS_PRIVATE_STATIC_FUN(ClassName, TypeName, FunName)

Use:
    access_private_field::ClassNameFieldName(object);
    access_private_static_field::ClassName::ClassNameFieldName();
    call_private_fun::ClassNameFunName(object,parameters...);
    call_private_static_fun::ClassName::ClassNameFunName(parameters...);
    get_private_fun::ClassNameFunName();
    get_private_static_fun::ClassName::ClassNameFunName();
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/026d87fff7d2383faad8e3381423e74d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">WebApi&#43;EFcore 项目链接</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/38b7519747f5d57abc3269f0798e5173/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python计算某字符出现次数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>