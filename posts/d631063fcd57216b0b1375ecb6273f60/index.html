<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>R语言游戏之旅 游戏2048 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="R语言游戏之旅 游戏2048" />
<meta property="og:description" content="R的极客理想系列文章，涵盖了R的思想，使用，工具，创新等的一系列要点，以我个人的学习和体验去诠释R的强大。 R语言作为统计学一门语言，一直在小众领域闪耀着光芒。直到大数据的爆发，R语言变成了一门炙手可热的数据分析的利器。随着越来越多的工程背景的人的加入，R语言的社区在迅速扩大成长。现在已不仅仅是统计领域，教育，银行，电商，互联网….都在使用R语言。 要成为有理想的极客，我们不能停留在语法上，要掌握牢固的数学，概率，统计知识，同时还要有创新精神，把R语言发挥到各个领域。让我们一起动起来吧，开始R的极客理想。 关于作者：
张丹(Conan), 程序员Java,R,PHP,Javascriptweibo：@Conan_Zblog: http://blog.fens.meemail: bsspirit@gmail.com 转载请注明出处：
http://blog.fens.me/r-game-2048/
前言
150行代码写出游戏2048，哪种语言能实现？答案是R语言。虽然R语言并不适合做游戏开发，但是R语言中的向量计算，能极大地简化矩阵算法代码实现的复杂度，可以高效的完成计算任务。如果我们把游戏问题变成数学问题，那么R就是绝佳的工具。
目录
2048游戏介绍场景设计程序设计R语言实现 1. 2048游戏介绍 2048是一款单人在线和移动端游戏，由19岁的意大利人Gabriele Cirulli于2014年3月开发。游戏任务是在一个网格上滑动小方块来进行组合，直到形成一个带有有数字2048的方块，它是滑块类游戏的一种电脑变体。作者开发这个游戏是为了测试自己是否有能力从零开始创造一款游戏，但游戏飙升的人气（不到1周内有400万访客）完全出乎他的预料。事实上，它已被称为网络上「最上瘾的东西」，华尔街日报将其评价为「属于数学极客的 Candy Crush」。
该游戏为开源软件，这导致它衍生出许多改进版和变种，包括积分排行榜和提升的触屏可玩性等。2048是基于HTML5的Javascript应用，源代码的地址：https://github.com/gabrielecirulli/2048，免费的在线版本：http://gabrielecirulli.github.io/2048/。当然本文中R语言的程序现实，完全是我的想法，与游戏作者的JS源代码无关。
游戏玩法
该游戏使用方向键让方块上下左右移动。如果两个带有相同数字的方块在移动中碰撞，则它们会合并为一个数字，为两者之和。每次移动时，会有一个值为2或者4的新方块出现。当值为2048的方块出现时，游戏即胜利，该游戏因此得名。
2. 场景设计 接下来，就回了游戏设计环节，如同上篇文章 R语言游戏之旅 贪食蛇入门 一样。要开发这款游戏，我们应该如何动手呢？我们需要从软件开发的角度，对这款游戏进行需求分析，列出游戏的规则，并设计业务流程，给出游戏的原型，验证是否可行。
2.1 需求分析
2048游戏，应该有3个场景：开机场景，游戏场景，结束场景。
开机场景：运行程序，在游戏前，给用户做准备，并提示如何操作游戏。游戏场景：游戏运行中的场景。结束场景：当用户胜利、失败或退出时的场景，并提示用户在游戏中的得分。 开机场景和结束场景比较简单，不再解释。游戏场景，包括一块4*4的画布，画面中每个格子对应一个数字，数字大于0的格子有背景颜色填充。
2.2 游戏规则
游戏进行时的规则：
1. 开始游戏后，用户可以通过上(up)下(down)左(left)右(right)键，来控制数字的移动。2. 如果两个相同的数字在移动中碰撞，则它们会合并为一个方块，且所带数字变为两者之和。3. 每次移动时，会有一个值为2或者4的新数字出现。4. 当用户按键操作，数字的顺序未发生变化时，则不会生成新数字，视为无效的按键操作。5. 当画布格子被数字填满时，而在上下左边方向，无可合并的数字时，则游戏失败。 2.3 业务流程
场景切换的流程：
打开程序时，用户首先看到开机场景，按任意键后进入游戏场景。在游戏场景，当游戏失败，进入结束场景；按q键，则直接游戏失败。在结束场景，按空格回到开机场景；按q键，则直接能出软件。 业务流程，同贪食蛇游戏的业务流程。
2.4 游戏原型
我们画出3个场景的界面。左边为开机场景，中间是游戏场景，右边是结束场景。
我们根据游戏原型的图，用程序画出游戏的场景。
3. 程序设计 通过上面的功能需求分析，我们已经非常清楚地了解 2048游戏 的各种规则和功能。接下来，我们要把需求分析中的业务语言，通过技术语言重新描述，并考虑非功能需求，以及R语言相关的技术细节。
3.1 游戏场景
我们让每个场景对应于一块画布，及每个场景对应一个内存结构。
开机场景，是静态的，我们可以提前生成好这块画布存储起来，也可以当用户切换时再临时生成，性能开销不大。游戏场景，是动态的，每进行一次用户的交互行为或按时间刷新时，都需要求重新绘制画布，让游戏场景通过绑定事件来生成画布。结束场景，是动态的，在结束场景会显示当次游戏的得分，需要在切换时临时生成。 3.2 游戏对象
在游戏进行中，会产生很多的对象，如上文中提到的。这些对象都需要在内存中进行定义，匹配到对应程序语言的数据类型。
比起贪食蛇游戏，2048游戏要简单的多，我只需要定义一个画布对象就行了。
画布对象：用矩阵来描述。画布中的数字：用矩阵中的数字值来表示。画布的背景色：用矩阵中的数字值来表示。 通过矩阵来描述游戏画布和对象：
矩阵结构：
[,1] [,2] [,3] [,4] [1,] 4 32 4 32 [2,] 32 16 2 4 [3,] 4 2 8 2 [4,] 2 8 2 0 对应该的游戏画布：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d631063fcd57216b0b1375ecb6273f60/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-07-22T16:31:22+08:00" />
<meta property="article:modified_time" content="2014-07-22T16:31:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">R语言游戏之旅 游戏2048</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="entry"> 
 <p><a title="R的极客理想系列文章" href="http://blog.fens.me/series-r/" rel="nofollow">R的极客理想系列文章</a>，涵盖了R的思想，使用，工具，创新等的一系列要点，以我个人的学习和体验去诠释R的强大。 </p> 
 <p>R语言作为统计学一门语言，一直在小众领域闪耀着光芒。直到大数据的爆发，R语言变成了一门炙手可热的数据分析的利器。随着越来越多的工程背景的人的加入，R语言的社区在迅速扩大成长。现在已不仅仅是统计领域，教育，银行，电商，互联网….都在使用R语言。 </p> 
 <p>要成为有理想的极客，我们不能停留在语法上，要掌握牢固的数学，概率，统计知识，同时还要有创新精神，把R语言发挥到各个领域。让我们一起动起来吧，开始R的极客理想。 </p> 
 <p><strong>关于作者：</strong></p> 
 <ul><li>张丹(Conan), 程序员Java,R,PHP,Javascript</li><li>weibo：@Conan_Z</li><li>blog: <a title="粉丝日志|跨界的IT博客" href="http://blog.fens.me/" rel="nofollow">http://blog.fens.me</a></li><li>email: bsspirit@gmail.com</li></ul> 
 <p><strong>转载请注明出处：</strong><br><a title="R语言游戏之旅 游戏2048" href="http://blog.fens.me/r-game-2048/" rel="nofollow">http://blog.fens.me/r-game-2048/</a></p> 
 <p><a href="http://blog.fens.me/wp-content/uploads/2014/07/game-2048.png" rel="nofollow"><img src="https://images2.imgbox.com/11/32/jHhWwadv_o.png" alt="game-2048" width="600" height="400" class="alignnone size-full wp-image-6918"></a></p> 
 <p><strong>前言</strong></p> 
 <p>150行代码写出游戏2048，哪种语言能实现？答案是R语言。虽然R语言并不适合做游戏开发，但是R语言中的向量计算，能极大地简化矩阵算法代码实现的复杂度，可以高效的完成计算任务。如果我们把游戏问题变成数学问题，那么R就是绝佳的工具。</p> 
 <p><strong>目录</strong></p> 
 <ol><li>2048游戏介绍</li><li>场景设计</li><li>程序设计</li><li>R语言实现</li></ol> 
 <h3>1. 2048游戏介绍</h3> 
 <p>2048是一款单人在线和移动端游戏，由19岁的意大利人Gabriele Cirulli于2014年3月开发。游戏任务是在一个网格上滑动小方块来进行组合，直到形成一个带有有数字2048的方块，它是滑块类游戏的一种电脑变体。作者开发这个游戏是为了测试自己是否有能力从零开始创造一款游戏，但游戏飙升的人气（不到1周内有400万访客）完全出乎他的预料。事实上，它已被称为网络上「最上瘾的东西」，华尔街日报将其评价为「属于数学极客的 Candy Crush」。</p> 
 <p><a href="http://blog.fens.me/wp-content/uploads/2014/07/2048_game1.png" rel="nofollow"><img src="https://images2.imgbox.com/84/13/n2702HBe_o.png" alt="2048_game1" width="432" height="274" class="alignnone size-full wp-image-6900"></a></p> 
 <p>该游戏为开源软件，这导致它衍生出许多改进版和变种，包括积分排行榜和提升的触屏可玩性等。2048是基于HTML5的Javascript应用，源代码的地址：<a href="https://github.com/gabrielecirulli/2048">https://github.com/gabrielecirulli/2048</a>，免费的在线版本：<a href="http://gabrielecirulli.github.io/2048/" rel="nofollow">http://gabrielecirulli.github.io/2048/</a>。当然本文中R语言的程序现实，完全是我的想法，与游戏作者的JS源代码无关。</p> 
 <p><strong>游戏玩法</strong></p> 
 <p>该游戏使用方向键让方块上下左右移动。如果两个带有相同数字的方块在移动中碰撞，则它们会合并为一个数字，为两者之和。每次移动时，会有一个值为2或者4的新方块出现。当值为2048的方块出现时，游戏即胜利，该游戏因此得名。</p> 
 <h3>2. 场景设计</h3> 
 <p>接下来，就回了游戏设计环节，如同上篇文章 <a title="R语言游戏之旅 贪食蛇入门" href="http://blog.fens.me/r-game-snake/" rel="nofollow">R语言游戏之旅 贪食蛇入门</a> 一样。要开发这款游戏，我们应该如何动手呢？我们需要从软件开发的角度，对这款游戏进行需求分析，列出游戏的规则，并设计业务流程，给出游戏的原型，验证是否可行。</p> 
 <p><strong>2.1 需求分析</strong></p> 
 <p>2048游戏，应该有3个场景：开机场景，游戏场景，结束场景。</p> 
 <ul><li>开机场景：运行程序，在游戏前，给用户做准备，并提示如何操作游戏。</li><li>游戏场景：游戏运行中的场景。</li><li>结束场景：当用户胜利、失败或退出时的场景，并提示用户在游戏中的得分。</li></ul> 
 <p>开机场景和结束场景比较简单，不再解释。游戏场景，包括一块4*4的画布，画面中每个格子对应一个数字，数字大于0的格子有背景颜色填充。</p> 
 <p><strong>2.2 游戏规则</strong></p> 
 <p>游戏进行时的规则：</p> 
 <ul><li>1. 开始游戏后，用户可以通过上(up)下(down)左(left)右(right)键，来控制数字的移动。</li><li>2. 如果两个相同的数字在移动中碰撞，则它们会合并为一个方块，且所带数字变为两者之和。</li><li>3. 每次移动时，会有一个值为2或者4的新数字出现。</li><li>4. 当用户按键操作，数字的顺序未发生变化时，则不会生成新数字，视为无效的按键操作。</li><li>5. 当画布格子被数字填满时，而在上下左边方向，无可合并的数字时，则游戏失败。</li></ul> 
 <p><strong>2.3 业务流程</strong></p> 
 <p>场景切换的流程：</p> 
 <ul><li>打开程序时，用户首先看到开机场景，按任意键后进入游戏场景。</li><li>在游戏场景，当游戏失败，进入结束场景；按q键，则直接游戏失败。</li><li>在结束场景，按空格回到开机场景；按q键，则直接能出软件。</li></ul> 
 <p><a href="http://blog.fens.me/wp-content/uploads/2014/06/snake-process.png" rel="nofollow"><img src="https://images2.imgbox.com/c7/c9/Z8LRyyvE_o.png" alt="snake-process" width="236" height="616" class="alignnone size-full wp-image-6605"></a></p> 
 <p>业务流程，同贪食蛇游戏的业务流程。</p> 
 <p><strong>2.4 游戏原型</strong></p> 
 <p>我们画出3个场景的界面。左边为开机场景，中间是游戏场景，右边是结束场景。</p> 
 <p><a href="http://blog.fens.me/wp-content/uploads/2014/07/game-2048-2.png" rel="nofollow"><img src="https://images2.imgbox.com/63/69/vC7ga5TQ_o.png" alt="game-2048-2" width="802" height="282" class="alignnone size-full wp-image-6906"></a></p> 
 <p>我们根据游戏原型的图，用程序画出游戏的场景。</p> 
 <h3>3. 程序设计</h3> 
 <p>通过上面的功能需求分析，我们已经非常清楚地了解 2048游戏 的各种规则和功能。接下来，我们要把需求分析中的业务语言，通过技术语言重新描述，并考虑非功能需求，以及R语言相关的技术细节。</p> 
 <p><strong>3.1 游戏场景</strong></p> 
 <p>我们让每个场景对应于一块画布，及每个场景对应一个内存结构。</p> 
 <ul><li>开机场景，是静态的，我们可以提前生成好这块画布存储起来，也可以当用户切换时再临时生成，性能开销不大。</li><li>游戏场景，是动态的，每进行一次用户的交互行为或按时间刷新时，都需要求重新绘制画布，让游戏场景通过绑定事件来生成画布。</li><li>结束场景，是动态的，在结束场景会显示当次游戏的得分，需要在切换时临时生成。</li></ul> 
 <p><strong>3.2 游戏对象</strong></p> 
 <p>在游戏进行中，会产生很多的对象，如上文中提到的。这些对象都需要在内存中进行定义，匹配到对应程序语言的数据类型。</p> 
 <p>比起贪食蛇游戏，2048游戏要简单的多，我只需要定义一个画布对象就行了。</p> 
 <ul><li>画布对象：用矩阵来描述。</li><li>画布中的数字：用矩阵中的数字值来表示。</li><li>画布的背景色：用矩阵中的数字值来表示。</li></ul> 
 <p>通过矩阵来描述游戏画布和对象：</p> 
 <p>矩阵结构：</p> 
 <pre><code>
     [,1] [,2] [,3] [,4]
[1,]    4   32    4   32
[2,]   32   16    2    4
[3,]    4    2    8    2
[4,]    2    8    2    0
</code></pre> 
 <p>对应该的游戏画布：<br><a href="http://blog.fens.me/wp-content/uploads/2014/07/game-2048-3.png" rel="nofollow"><img src="https://images2.imgbox.com/6f/50/4ZWHaL7S_o.png" alt="game-2048-3" width="265" height="282" class="alignnone size-full wp-image-6909"></a></p> 
 <p><strong>3.3 游戏事件</strong></p> 
 <p>游戏过程中，会有2种事件，键盘事件和碰撞事件。</p> 
 <ul><li>键盘事件：全局事件，用户通过键盘输入，而触发的事件，比如，上下左右控制蛇的移动方向。</li><li>碰撞事件：如果两个相同的数字在移动中碰撞，则它们会合并为一个数字。</li></ul> 
 <p>全局监听键盘事件，用键盘事件触发碰撞事件，检查游戏状态。</p> 
 <p><strong>3.4 游戏控制</strong></p> 
 <p>在游戏进行中，每个状态我们都需要进行控制的。比如，什么生成新的数字，什么合并相同的数字，什么时候游戏结束等。通过定义控制函数，可以方便我们管理游戏运行中的各种游戏状态。</p> 
 <p><a href="http://blog.fens.me/wp-content/uploads/2014/07/game-2048-process.png" rel="nofollow"><img src="https://images2.imgbox.com/77/b5/68hOZZrf_o.png" alt="game-2048-process" width="937" height="724" class="alignnone size-full wp-image-6911"></a></p> 
 <p>上图中每个方块代表一个R语言函数定义：</p> 
 <ul><li>run():启动程序。</li><li>keydown():监听键盘事件，锁定线程。</li><li>stage0():创建开机场景，可视化输出。</li><li>stage1():创建游戏场景，可视化输出。</li><li>stage2():创建结束场景，可视化输出。</li><li>init():打开游戏场景时，初始化游戏变量。</li><li>create():判断并生成数字。</li><li>move():移动数字。</li><li>lose():失败查询，判断当画布格子是否被被数字填满时，且不能合并的数字时，进行结束场景。</li><li>drawTable():绘制游戏背景。</li><li>drawMatrix():绘制游戏矩阵。</li></ul> 
 <p>通过程序设计过程，我们就把需求分析中的业务语言描述，变成了程序开发中的技术语言描述。经过完整的设计后，最后就剩下写代码了。</p> 
 <h3>4. R语言实现</h3> 
 <p>按照上面的函数定义，我们把代码像填空一样地写进去就行了。由于我们之前已经做好了一个游戏框架，场景函数及功能函数定义已在框架中现实了一部分，就可以更方便地填入游戏代码了。关于R语言游戏框架介绍，请参考文章：<a title="R语言游戏框架设计" href="http://blog.fens.me/r-game-framework/" rel="nofollow">R语言游戏框架设计</a></p> 
 <p><strong>4.1 数字移动函数 move()</strong></p> 
 <p>2048游戏算法上最复杂的操作，就是数字移动。在4*4的矩阵中，数字会按上下左右四个方向移动，相同的数字在移动中碰撞时会进行合并。这个算法是2048游戏的核心算法，我们的程序要保证数字合并正确性。</p> 
 <p>我们先把这个函数从框架中抽出来，单独进行实现和单元测试。</p> 
 <p>构建函数moveFun()，这里简化移动过程，只考虑左右移动，再通过倒序的算法，让左右移动的核心算法共用一套代码。</p> 
 <pre><code>
&gt; moveFun0)] #去掉0
+   pos10)] #去掉0
+   x1</code></pre> 
 <p>接下来，为了检验函数moveFun()的正确性，我们使用单元测试工具包testthat，来检验算法是否正确。关于testthat包的介绍，请参考文章 <a title="在巨人的肩膀前行 催化R包开发" href="http://blog.fens.me/r-package-faster/" rel="nofollow">在巨人的肩膀前行 催化R包开发</a>。</p> 
 <p>按游戏规则我们模拟数字左右移动，验证计算结果是否与我们给出的目标值相同。</p> 
 <p><a href="http://blog.fens.me/wp-content/uploads/2014/07/game-2048-move.png" rel="nofollow"><img src="https://images2.imgbox.com/a0/23/DQH7U7ln_o.png" alt="game-2048-move" width="548" height="700" class="alignnone size-full wp-image-6923"></a></p> 
 <p>单元测试的代码</p> 
 <pre><code>
&gt; library(testthat)
&gt; x expect_that(moveFun(x,'left'), equals(c(4,4,2,0)))
&gt; expect_that(moveFun(x,'right'), equals(c(0,4,2,4)))
 
&gt; x expect_that(moveFun(x,'left'), equals(c(8,2,4,0)))
&gt; expect_that(moveFun(x,'right'), equals(c(0,8,2,4)))
 
&gt; x expect_that(moveFun(x,'left'), equals(c(4,2,0,0)))
&gt; expect_that(moveFun(x,'right'), equals(c(0,0,2,4)))
 
&gt; x expect_that(moveFun(x,'left'), equals(c(2,4,2,4)))
&gt; expect_that(moveFun(x,'right'), equals(c(2,4,2,4)))
 
&gt; x expect_that(moveFun(x,'left'), equals(c(8,4,0,0)))
&gt; expect_that(moveFun(x,'right'), equals(c(0,0,8,4)))
 
&gt; x expect_that(moveFun(x,'left'), equals(c(4,8,0,0)))
&gt; expect_that(moveFun(x,'right'), equals(c(0,0,4,8)))
 
&gt; x expect_that(moveFun(x,'left'), equals(c(8,4,0,0)))
&gt; expect_that(moveFun(x,'right'), equals(c(0,0,4,8)))
 
&gt; x expect_that(moveFun(x,'left'), equals(c(8,4,0,0)))
&gt; expect_that(moveFun(x,'right'), equals(c(0,0,4,8)))
 
&gt; x expect_that(moveFun(x,'left'), equals(c(8,2,0,0)))
&gt; expect_that(moveFun(x,'right'), equals(c(0,0,8,2)))
 
&gt; x expect_that(moveFun(x,'left'), equals(c(4,4,0,0)))
&gt; expect_that(moveFun(x,'right'), equals(c(0,0,4,4)))
 
&gt; x expect_that(moveFun(x,'left'), equals(c(4,2,0,0)))
&gt; expect_that(moveFun(x,'right'), equals(c(0,0,2,4)))
</code></pre> 
 <p>当然，我们还可以写更多的测试用例，来检验函数的正确性。这样就实现了，数字移动的核心算法了。</p> 
 <p><strong>4.2 其他函数实现</strong></p> 
 <p>开机场景函数stage0()</p> 
 <pre><code>
 # 开机画图
 stage0=function(){
   callSuper()
   plot(0,0,xlim=c(0,1),ylim=c(0,1),type='n',xaxs="i", yaxs="i")
   text(0.5,0.7,label=name,cex=5)
   text(0.5,0.4,label="Any keyboard to start",cex=2,col=4)
   text(0.5,0.3,label="Up,Down,Left,Rigth to control direction",cex=2,col=2)
   text(0.2,0.05,label="Author:DanZhang",cex=1)
   text(0.5,0.05,label="http://blog.fens.me",cex=1)
 }
</code></pre> 
 <p>结束场景函数stage2()</p> 
 <pre><code>
 # 结束画图
 stage2=function(){
   callSuper()
   info</code></pre> 
 <p>键盘事件，控制场景切换</p> 
 <pre><code>
 # 键盘事件，控制场景切换
 keydown=function(K){
   callSuper(K)
   
   if(stage==1){ #游戏中
	 if(K == "q") stage2()
	 else {
	   if(tolower(K) %in% c("up","down","left","right")){
		 e$dir&lt;</code></pre> 
 <p>游戏场景初始化函数init()</p> 
 <pre><code>
 # 初始化变量
 init = function(){
   callSuper()  # 调父类
   
   e$max&lt;</code></pre> 
 <p>随机产生一个新数字函数create()</p> 
 <pre><code>
 # 随机产生一个新数字
 create=function(){
   if(length(index(0))&gt;0 &amp; !e$stop){
	 e$stop&lt;</code></pre> 
 <p>失败条件函数lose()</p> 
 <pre><code>
 #失败条件
 lose=function(){
   
   # 判断是否有相邻的有重复值
   near0))==0 &amp; length(which(v&gt;0))==0){
	   fail("No free grid.")
	   return(NULL)
	 }
   }
 }
</code></pre> 
 <p>游戏画布函数drawTable()</p> 
 <pre><code>
 # 画布背景
 drawTable=function(){
   if(isFail) return(NULL)
   plot(0,0,xlim=c(0,1),ylim=c(0,1),type='n',xaxs="i", yaxs="i")
   abline(h=seq(0,1,e$step),col="gray60") # 水平线
   abline(v=seq(0,1,e$step),col="gray60") # 垂直线
 }
</code></pre> 
 <p>游戏矩阵函数drawMatrix()</p> 
 <pre><code>
 # 根据矩阵画数据
 drawMatrix=function(){
   if(isFail) return(NULL)
   a0),]
   points(df$x+e$step/2,df$y+e$step/2,col=e$colors[log(df$lab,2)],pch=15,cex=23)
   text(df$x+e$step/2,df$y+e$step/2,label=df$lab,cex=2)
 }
</code></pre> 
 <p>游戏场景函数stage1()</p> 
 <pre><code>
 # 游戏场景
 stage1=function(){
   callSuper()
   
   move()
   lose()
   create()
   
   drawTable()
   drawMatrix()  
 }
</code></pre> 
 <p>完整的程序代码</p> 
 <pre><code>
source(file="game.r") #加载游戏框架

# Snake类，继承Game类
G20480 &amp; !e$stop){
         e$stop&lt;0))==0 &amp; length(which(v&gt;0))==0){
           fail("No free grid.")
           return(NULL)
         }
       }
     },
     
     # 方向移动
     move=function(){
       
       # 方向移动函数
       moveFun=function(x){
         if(e$dir %in% c('right','down')) x0)] #去掉0
         pos10)] #去掉0
         x10),]
       points(df$x+e$step/2,df$y+e$step/2,col=e$colors[log(df$lab,2)],pch=15,cex=23)
       text(df$x+e$step/2,df$y+e$step/2,label=df$lab,cex=2)
     },
     
     # 游戏场景
     stage1=function(){
       callSuper()
       
       move()
       lose()
       create()
       
       drawTable()
       drawMatrix()  
     },
     
     # 开机画图
     stage0=function(){
       callSuper()
       plot(0,0,xlim=c(0,1),ylim=c(0,1),type='n',xaxs="i", yaxs="i")
       text(0.5,0.7,label=name,cex=5)
       text(0.5,0.4,label="Any keyboard to start",cex=2,col=4)
       text(0.5,0.3,label="Up,Down,Left,Rigth to control direction",cex=2,col=2)
       text(0.2,0.05,label="Author:DanZhang",cex=1)
       text(0.5,0.05,label="http://blog.fens.me",cex=1)
     },
     
     # 结束画图
     stage2=function(){
       callSuper()
       info</code></pre> 
 <p>游戏截图：<br><a href="http://blog.fens.me/wp-content/uploads/2014/07/2048.gif" rel="nofollow"><img src="https://images2.imgbox.com/71/ca/IoboAwXi_o.gif" alt="2048" width="500" height="500" class="alignnone size-full wp-image-6914"></a></p> 
 <p>全部代码仅仅190行，有效代码行只有150行左右，我们就实现了2048游戏。用R语言处理矩阵的向量计算，还是很方便的，另外我们又用面向对象的方法，对游戏程序进行了统一的封装，标准化了函数定义和接口，让我们能更专注于游戏算法本身，提高开发的效率。下一步，就可以把游戏这个框架项目打包发布到CRAN了。</p> 
 <p><strong>转载请注明出处：</strong><br><a title="R语言游戏之旅 游戏2048" href="http://blog.fens.me/r-game-2048/" rel="nofollow">http://blog.fens.me/r-game-2048/</a></p> 
 <p><img src="https://images2.imgbox.com/e9/c5/RdoR3rCD_o.png" alt="打赏作者" width="600" height="400" class="alignnone size-full wp-image-8388"></p> 
 <div class="clear"></div> 
 <p class="inner-meta">This entry was posted in <a href="http://blog.fens.me/category/r-lang/" rel="nofollow">R语言实践</a>, <a href="http://blog.fens.me/category/%E6%B8%B8%E6%88%8F/" rel="nofollow">游戏</a></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3932a4752455656822946c1c54192507/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java.lang.NoClassDefFoundError: org/hibernate/service/jta/platform/spi/JtaPlatform</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6e61cf4e702cc6a414a999ca4d766e3e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ie js实现打开另存为对话框，</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>