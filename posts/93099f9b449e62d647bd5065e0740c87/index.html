<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>WebSocket的基本使用 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="WebSocket的基本使用" />
<meta property="og:description" content="目录
为何使用websocket
1.后端搭建
2.搭建webSocket前后分离
1.配置跨域过滤器与初始化websocket
2.定义websocket服务
3.定义控制器进行测试webSocket向前端发送消息
2.前端准备
3.进行测试
向后端发送消息测试
后端向前端发送消息测试
为何使用websocket 在浏览器与服务器通信间，传统的 HTTP 请求在某些场景下并不理想，比如实时聊天、实时性的小游戏等等，
其面临主要两个缺点：
无法做到消息的「实时性」；服务端无法主动推送信息； 其基于 HTTP 的主要解决方案有：
基于 ajax 的轮询：客户端定时或者动态相隔短时间内不断向服务端请求接口，询问服务端是否有新信息；其缺点也很明显：多余的空请求（浪费资源）、数据获取有延时；Long Poll：其采用的是阻塞性的方案，客户端向服务端发起 ajax 请求，服务端挂起该请求不返回数据直到有新的数据，客户端接收到数据之后再次执行 Long Poll；该方案中每个请求都挂起了服务器资源，在大量连接的场景下是不可接受的； 可以看到，基于 HTTP 协议的方案都包含一个本质缺陷 —— 「被动性」，服务端无法下推消息，仅能由客户端发起请求不断询问是否有新的消息，同时对于客户端与服务端都存在性能消耗。
WebSocket 是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。 WebSocket 通信协议于2011年被IETF定为标准RFC 6455，WebSocketAPI 被 W3C 定为标准。 在 WebSocket API 中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。
WebSocket 是 HTML5 中提出的新的网络协议标准，其包含几个特点：
建立于 TCP 协议之上的应用层；一旦建立连接（直到断开或者出错），服务端与客户端握手后则一直保持连接状态，是持久化连接；服务端可通过实时通道主动下发消息；数据接收的「实时性（相对）」与「时序性」；较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部。支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等） 实践
1.后端搭建 准配工作
所需要架包 注意：springboot环境 版本2.7.7
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/93099f9b449e62d647bd5065e0740c87/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-29T14:05:42+08:00" />
<meta property="article:modified_time" content="2022-12-29T14:05:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">WebSocket的基本使用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8websocket-toc" style="margin-left:0px;"><a href="#%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8websocket" rel="nofollow">为何使用websocket</a></p> 
<p id="1.%E5%90%8E%E7%AB%AF%E6%90%AD%E5%BB%BA-toc" style="margin-left:40px;"><a href="#1.%E5%90%8E%E7%AB%AF%E6%90%AD%E5%BB%BA" rel="nofollow">1.后端搭建</a></p> 
<p id="2.%E6%90%AD%E5%BB%BAwebSocket%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB-toc" style="margin-left:0px;"><a href="#2.%E6%90%AD%E5%BB%BAwebSocket%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB" rel="nofollow">2.搭建webSocket前后分离</a></p> 
<p id="1.%E9%85%8D%E7%BD%AE%E8%B7%A8%E5%9F%9F%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96websocket-toc" style="margin-left:40px;"><a href="#1.%E9%85%8D%E7%BD%AE%E8%B7%A8%E5%9F%9F%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96websocket" rel="nofollow">1.配置跨域过滤器与初始化websocket</a></p> 
<p id="2.%E5%AE%9A%E4%B9%89websocket%E6%9C%8D%E5%8A%A1-toc" style="margin-left:40px;"><a href="#2.%E5%AE%9A%E4%B9%89websocket%E6%9C%8D%E5%8A%A1" rel="nofollow">2.定义websocket服务</a></p> 
<p id="3.%E5%AE%9A%E4%B9%89%E6%8E%A7%E5%88%B6%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95webSocket%E5%90%91%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF-toc" style="margin-left:40px;"><a href="#3.%E5%AE%9A%E4%B9%89%E6%8E%A7%E5%88%B6%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95webSocket%E5%90%91%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF" rel="nofollow">3.定义控制器进行测试webSocket向前端发送消息</a></p> 
<p id="2.%E5%89%8D%E7%AB%AF%E5%87%86%E5%A4%87-toc" style="margin-left:40px;"><a href="#2.%E5%89%8D%E7%AB%AF%E5%87%86%E5%A4%87" rel="nofollow">2.前端准备</a></p> 
<p id="3.%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95-toc" style="margin-left:0px;"><a href="#3.%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95" rel="nofollow">3.进行测试</a></p> 
<p id="%E5%90%91%E5%90%8E%E7%AB%AF%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#%E5%90%91%E5%90%8E%E7%AB%AF%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E6%B5%8B%E8%AF%95" rel="nofollow">向后端发送消息测试</a></p> 
<p id="%E5%90%8E%E7%AB%AF%E5%90%91%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#%E5%90%8E%E7%AB%AF%E5%90%91%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E6%B5%8B%E8%AF%95" rel="nofollow">后端向前端发送消息测试</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2>为何使用websocket</h2> 
<p>在浏览器与服务器通信间，传统的 HTTP 请求在某些场景下并不理想，比如实时聊天、实时性的小游戏等等，</p> 
<p>其面临主要两个缺点：</p> 
<ul><li>无法做到消息的「实时性」；</li><li>服务端无法主动推送信息；</li></ul> 
<p>其基于 HTTP 的主要解决方案有：</p> 
<ul><li>基于 ajax 的轮询：客户端定时或者动态相隔短时间内不断向服务端请求接口，询问服务端是否有新信息；其缺点也很明显：多余的空请求（浪费资源）、数据获取有延时；</li><li>Long Poll：其采用的是阻塞性的方案，客户端向服务端发起 ajax 请求，服务端挂起该请求不返回数据直到有新的数据，客户端接收到数据之后再次执行 Long Poll；该方案中每个请求都挂起了服务器资源，在大量连接的场景下是不可接受的；</li></ul> 
<p>可以看到，基于 HTTP 协议的方案都包含一个本质缺陷 —— 「被动性」，服务端无法下推消息，仅能由客户端发起请求不断询问是否有新的消息，同时对于客户端与服务端都存在性能消耗。</p> 
<p>WebSocket 是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。 WebSocket 通信协议于2011年被IETF定为标准RFC 6455，WebSocketAPI 被 W3C 定为标准。 在 WebSocket API 中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p> 
<p>WebSocket 是 HTML5 中提出的新的网络协议标准，其包含几个特点：</p> 
<ul><li>建立于 TCP 协议之上的应用层；</li><li>一旦建立连接（直到断开或者出错），服务端与客户端握手后则一直保持连接状态，是持久化连接；</li><li>服务端可通过实时通道主动下发消息；</li><li>数据接收的「实时性（相对）」与「时序性」；</li><li>较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部。</li><li>支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）</li></ul> 
<hr> 
<p>实践</p> 
<h3 id="1.%E5%90%8E%E7%AB%AF%E6%90%AD%E5%BB%BA">1.后端搭建</h3> 
<p>准配工作</p> 
<p>所需要架包 注意：springboot环境 版本2.7.7</p> 
<pre><code>  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;
  &lt;/dependency&gt;

  &lt;dependency&gt;
      &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
      &lt;artifactId&gt;lombok&lt;/artifactId&gt;
      &lt;optional&gt;true&lt;/optional&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
      &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;
&lt;!--  &lt;dependency&gt;
      &lt;groupId&gt;cn.hutool&lt;/groupId&gt;
      &lt;artifactId&gt;hutool-json&lt;/artifactId&gt;
      &lt;version&gt;5.8.9&lt;/version&gt;
  &lt;/dependency&gt;--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
      &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
      &lt;version&gt;2.0.21&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
      &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
      &lt;version&gt;3.7&lt;/version&gt;
  &lt;/dependency&gt;
</code></pre> 
<p>application配置</p> 
<pre><code>server.port=8080
server.servlet.context-path=/</code></pre> 
<h2 id="2.%E6%90%AD%E5%BB%BAwebSocket%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB">2.搭建webSocket前后分离</h2> 
<p><img alt="" height="992" src="https://images2.imgbox.com/ab/b8/nSnkLGyd_o.png" width="1200"></p> 
<h3 id="1.%E9%85%8D%E7%BD%AE%E8%B7%A8%E5%9F%9F%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96websocket">1.配置跨域过滤器与初始化websocket</h3> 
<p></p> 
<pre><code>package com.zking.web.websocketdemo.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import org.springframework.web.socket.server.standard.ServerEndpointExporter;


/**
 * Spring MVC 配置
 */
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    private final Logger logger = LoggerFactory.getLogger(WebMvcConfig.class);

    //服务器支持跨域
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("*")
                .allowedMethods("GET", "POST","OPTIONS")
                .allowedHeaders("*")
                .exposedHeaders("Access-Control-Allow-Headers",
                        "Access-Control-Allow-Methods",
                        "Access-Control-Allow-Origin",
                        "Access-Control-Max-Age",
                        "X-Frame-Options")
                .allowCredentials(false)
                .maxAge(3600);
    }

    
    /**
     * The bean shown in the preceding example registers any @ServerEndpoint
     * annotated beans with the underlying WebSocket container. When deployed to a
     * standalone servlet container, this role is performed by a servlet container
     * initializer, and the ServerEndpointExporter bean is not required.
     * 
     * @return
     * 在Spring中可以直接使用Java WebSocket API来提供服务，如果使用内置的web容器，需要做的仅仅是需要在下面添加
     */
    /** 注入ServerEndpointExporter，这个bean会自动注册使用了@ServerEndpoint注解声明的Websocket endpoint 。
     * 要注意，如果使用独立的servlet容器，而不是直接使用springboot的内置容器，就不要注入ServerEndpointExporter，因为它将由容器自己提供和管理。*/
    @Bean
    public ServerEndpointExporter serverEndpointExporter() {
        return new ServerEndpointExporter();
    }
    
}</code></pre> 
<h3 id="2.%E5%AE%9A%E4%B9%89websocket%E6%9C%8D%E5%8A%A1">2.定义websocket服务</h3> 
<p>websocket 是 javax.websocket下面的，不需要任何依赖，直接就可以使用</p> 
<p>　　@ServerEndpoint 标记声明一个websocket 服务 ，configurator 属性指定 鉴权 配置类,@ServerEndpoint 标记的类 为每个链接会创建一个该对象实例，也就是成员变量这个链接内私有。</p> 
<p>　　@OnOpen ， @OnClose ， @OnMessage ， @OnError 4个事件方法，对应事件触发的时候调用 （除了@PathParam("path") 标记的参数以外，最多只能有 String message, Session session 两个参数）</p> 
<pre><code>package com.zking.web.websocketdemo.component;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.websocket.OnClose;
import javax.websocket.OnError;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.PathParam;
import javax.websocket.server.ServerEndpoint;


import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.concurrent.ConcurrentHashMap;

@ServerEndpoint("/ws/{sid}")
@Component
public class WebSocketServer {

    private final static Logger log = LoggerFactory.getLogger(WebSocketServer.class);
    //静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。
    private static int onlineCount = 0;
    //与某个客户端的连接会话，需要通过它来给客户端发送数据
    private Session session;
    //旧：concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。由于遍历set费时，改用map优化
    //private static CopyOnWriteArraySet&lt;WebSocketServer&gt; webSocketSet = new CopyOnWriteArraySet&lt;WebSocketServer&gt;();
    //新：使用map对象优化，便于根据sid来获取对应的WebSocket
    private static ConcurrentHashMap&lt;String,WebSocketServer&gt; websocketMap = new ConcurrentHashMap&lt;&gt;();
    //接收用户的sid，指定需要推送的用户
    private String sid;

    /**
     * 连接成功后调用的方法
     */
    @OnOpen
    public void onOpen(Session session,@PathParam("sid") String sid) {
        this.session = session;
        //webSocketSet.add(this);     //加入set中
        websocketMap.put(sid,this); //加入map中
        addOnlineCount();           //在线数加1
        log.info("有新窗口开始监听:"+sid+",当前在线人数为" + getOnlineCount());
        this.sid=sid;
        try {
            sendMessage("连接成功");
        } catch (IOException e) {
            log.error("websocket IO异常");
        }
    }

    /**
     * 连接关闭调用的方法
     */
    @OnClose
    public void onClose() {
        if(websocketMap.get(this.sid)!=null){
            //webSocketSet.remove(this);  //从set中删除
            websocketMap.remove(this.sid);  //从map中删除
            subOnlineCount();           //在线数减1
            log.info("有一连接关闭！当前在线人数为" + getOnlineCount());
        }
    }

    /**
     * 收到客户端消息后调用的方法，根据业务要求进行处理，这里就简单地将收到的消息直接群发推送出去
     * @param message 客户端发送过来的消息
     */
    @OnMessage
    public void onMessage(String message, Session session) {
        log.info("收到来自窗口"+sid+"的信息:"+message);
        if(StringUtils.isNotBlank(message)){
            for(WebSocketServer server:websocketMap.values()) {
                try {
                    server.sendMessage(message);
                } catch (IOException e) {
                    e.printStackTrace();
                    continue;
                }
            }
        }
    }

    /**
     * 发生错误时的回调函数
     * @param session
     * @param error
     */
    @OnError
    public void onError(Session session, Throwable error) {
        log.error("发生错误");
        error.printStackTrace();
    }

    /**
     * 实现服务器主动推送消息
     */
    public void sendMessage(String message) throws IOException {
        this.session.getBasicRemote().sendText(message);
    }


    /**
     * 群发自定义消息（用set会方便些）
     * */
    public static void sendInfo(@PathParam("message")  String message,@PathParam("sid") String sid) throws IOException {
        log.info("推送消息到窗口"+sid+"，推送内容:"+message);
        /*for (WebSocketServer item : webSocketSet) {
            try {
                //这里可以设定只推送给这个sid的，为null则全部推送
                if(sid==null) {
                    item.sendMessage(message);
                }else if(item.sid.equals(sid)){
                    item.sendMessage(message);
                }
            } catch (IOException e) {
                continue;
            }
        }*/
        if(StringUtils.isNotBlank(message)){
            for(WebSocketServer server:websocketMap.values()) {
                try {
                    // sid为null时群发，不为null则只发一个
                    if (sid == null) {
                        server.sendMessage(message);
                    } else if (server.sid.equals(sid)) {
                        server.sendMessage(message);
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                    continue;
                }
            }
        }
    }

    public static synchronized int getOnlineCount() {
        return onlineCount;
    }
    public static synchronized void addOnlineCount() {
        WebSocketServer.onlineCount++;
    }
    public static synchronized void subOnlineCount() {
        WebSocketServer.onlineCount--;
    }
}
</code></pre> 
<h3 id="3.%E5%AE%9A%E4%B9%89%E6%8E%A7%E5%88%B6%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95webSocket%E5%90%91%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF">3.定义控制器进行测试webSocket向前端发送消息</h3> 
<pre><code>package com.zking.web.websocketdemo.controller;

import com.zking.web.websocketdemo.component.WebSocketServer;
import com.zking.web.websocketdemo.config.WebSocketConfig;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Controller
@RequestMapping("/websocket")
public class WebSocketController {

    //页面请求
    @GetMapping("/socket/{cid}")
    public ModelAndView socket(@PathVariable String cid) {
        ModelAndView mav=new ModelAndView("/socket");
        mav.addObject("cid", cid);
        return mav;
    }
    //推送数据接口
    @ResponseBody
    @RequestMapping("/socket/push/{cid}")
    public Map&lt;String,Object&gt; pushToWeb(@PathVariable String cid, String message) {
        Map&lt;String,Object&gt; result = new HashMap&lt;&gt;();
        try {
            WebSocketServer.sendInfo(message,cid);
            result.put("status","success");
        } catch (IOException e) {
            e.printStackTrace();
            result.put("status","fail");
            result.put("errMsg",e.getMessage());
        }
        return result;
    }

}
</code></pre> 
<p>后端准配完毕</p> 
<h3 id="2.%E5%89%8D%E7%AB%AF%E5%87%86%E5%A4%87">2.前端准备</h3> 
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;websocket通讯&lt;/title&gt;
&lt;/head&gt;
&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"&gt;&lt;/script&gt;
&lt;script&gt;
    var socket;
    function openSocket() {
        if(typeof(WebSocket) == "undefined") {
            console.log("您的浏览器不支持WebSocket");
        }else{
            console.log("您的浏览器支持WebSocket");
            //实现化WebSocket对象，指定要连接的服务器地址与端口  建立连接
            //等同于socket = new WebSocket("ws://localhost:8888/xxxx/im/25");
            //var socketUrl="${request.contextPath}/im/"+$("#userId").val();
            var socketUrl="http://localhost:8080/ws/"+$("#userId").val();
            socketUrl=socketUrl.replace("https","ws").replace("http","ws");
            console.log(socketUrl);
            if(socket!=null){
                socket.close();
                socket=null;
            }
            socket = new WebSocket(socketUrl);
            //打开事件
            socket.onopen = function() {
                console.log("websocket已打开");
                //socket.send("这是来自客户端的消息" + location.href + new Date());
            };
            //获得消息事件
            socket.onmessage = function(msg) {
                console.log(msg.data);
                //发现消息进入    开始处理前端触发逻辑
            };
            //关闭事件
            socket.onclose = function() {
                console.log("websocket已关闭");
            };
            //发生了错误事件
            socket.onerror = function() {
                console.log("websocket发生了错误");
            }
        }
    }
    function sendMessage() {
        if(typeof(WebSocket) == "undefined") {
            console.log("您的浏览器不支持WebSocket");
        }else {
            console.log("您的浏览器支持WebSocket");
            console.log('{"toUserId":"'+$("#toUserId").val()+'","contentText":"'+$("#contentText").val()+'"}');
            socket.send('{"toUserId":"'+$("#toUserId").val()+'","contentText":"'+$("#contentText").val()+'"}');
        }
    }
&lt;/script&gt;
&lt;body&gt;
&lt;p&gt;【userId】：&lt;div&gt;&lt;input id="userId" name="userId" type="text" value="10"&gt;&lt;/div&gt;
&lt;p&gt;【toUserId】：&lt;div&gt;&lt;input id="toUserId" name="toUserId" type="text" value="20"&gt;&lt;/div&gt;
&lt;p&gt;【toUserId】：&lt;div&gt;&lt;input id="contentText" name="contentText" type="text" value="hello websocket"&gt;&lt;/div&gt;
&lt;p&gt;【操作】：&lt;div&gt;&lt;a onclick="openSocket()"&gt;开启socket&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;【操作】：&lt;div&gt;&lt;a onclick="sendMessage()"&gt;发送消息&lt;/a&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;




</code></pre> 
<p>运行前端与后端</p> 
<h2 id="3.%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95">3.进行测试</h2> 
<p><img alt="" height="1080" src="https://images2.imgbox.com/f3/d2/iTNjParg_o.png" width="1200"></p> 
<h4 id="%E5%90%91%E5%90%8E%E7%AB%AF%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E6%B5%8B%E8%AF%95">向后端发送消息测试</h4> 
<p><img alt="" height="1001" src="https://images2.imgbox.com/d0/2a/k5a3W6L7_o.png" width="1200"></p> 
<h4 id="%E5%90%8E%E7%AB%AF%E5%90%91%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E6%B5%8B%E8%AF%95">后端向前端发送消息测试</h4> 
<p><img alt="" height="1032" src="https://images2.imgbox.com/54/28/agol1oOV_o.png" width="1200"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9b89f769ced0b6fb9b3e12ce7407ed91/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Shell脚本练习</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6df612ed5ffd9b2cbc5b34cd4033637f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【OpenStack实战—keystone04】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>