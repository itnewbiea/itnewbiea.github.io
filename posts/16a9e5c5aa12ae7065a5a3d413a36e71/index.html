<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>怎样理解 Java 注解和运用注解编程？（大佬的文章） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="怎样理解 Java 注解和运用注解编程？（大佬的文章）" />
<meta property="og:description" content="在制作上一篇文章之前，完成之后又去找了一下相关的文章，看到其中一个大佬的文章，我收获颇丰，创作就是需要这样的人，故秉承学习知识：海纳百川，厚着脸的将大佬的帖子转过来了
转载自（大家可以多去看看大佬的文章）：怎样理解 Java 注解和运用注解编程？ - bravo1988的回答 - 知乎 https://www.zhihu.com/question/47449512/answer/658228092
注解，和反射一样，是Java中最重要却最容易被人遗忘的知识点。哪怕Spring、SpringMVC、SpringBoot等框架中充满了注解，我们还是选择性地忽视它。很多人不明白它是怎么起作用的，甚至有人把它和注释混淆...工作中也只是机械性地在Controller上加@RequestMapping。是的，我们太习以为常了，以至于觉得它应该就是如此。
内容介绍：
两件小事注解的作用注解的本质反射注解信息元注解属性的数据类型及特别的属性：value和数组 两件小事 去年工作中，我遇到的两件事让注解重新走进我的视野。
第一，18年6月我去了北京，参与开发了某中国五百强企业的一个加密系统，第一次接触到了SpringBoot。当我发现一个demo项目只要简单地写个启动类并加上 @SpringBootApplication就可以直接访问Controller时，感到非常震撼。整个demo没有一个配置文件，连web.xml也没有。
由于开发进度很赶，当时没时间去研究它是如何做到的，但这件事让我意识到自己对注解还是了解得太少。
第二，来到杭州后我又参与开发了一个金融借贷系统，那阵子对接了很多第三方的风控接口：
对签名验签不了解的朋友，可以百度一下。总之，每对接一个接口，都要在开头进行数据校验。一两个接口也就算了，但每次对接风控，基本上都要写10&#43;多个方法。每个方法开头都写一份签名验签的代码，显然太冗余了。我当时的做法是将验签代码抽取成方法，方便复用，自以为算是一种改良了，直到我看到同事用了切面...40米的大刀拦腰砍去，给每个方法都做了签名验签：
注意，实际上切面的作用是在方法前后，而不是方法内部的前后。上面这样画，仅仅为了更形象
这两件事，让我知道，是时候重新学习一下注解了。
注解的作用 格式
public @interface 注解名称{ 属性列表; } 格式有点奇怪，我们稍后再研究。
分类
大致分为三类：自定义注解、JDK内置注解、还有第三方框架提供的注解。
自定义注解就是我们自己写的注解。JDK内置注解，比如@Override检验方法重载，@Deprecated标识方法过期等。第三方框架定义的注解比如SpringMVC的@Controller等。
使用位置
实际开发中，注解常常出现在类、方法、成员变量、形参位置。当然还有其他位置，这里不提及。
作用
如果说注释是写给人看的，那么注解就是写给程序看的。它更像一个标签，贴在一个类、一个方法或者字段上。它的目的是为当前读取该注解的程序提供判断依据。比如程序只要读到加了@Test的方法，就知道该方法是待测试方法，又比如@Before注解，程序看到这个注解，就知道该方法要放在@Test方法之前执行。
级别
注解和类、接口、枚举是同一级别的。
注解的本质 @interface和interface这么相似，我猜注解的本质是一个接口。
为了验证这个猜测，我们做个实验。先按上面的格式写一个注解
属性先不写
编译后得到字节码文件
通过XJad工具反编译MyAnnotation.class
我们发现，@interface变成了interface，而且自动继承了Annotation
既然确实是个接口，那么我们自然可以在里面写方法
得到class文件后反编译
由于接口默认方法的修饰符就是public abstract，所以可以省略，直接写成：
虽说注解的本质是接口，但是仍然有很多怪异的地方，比如使用注解时，我们竟然可以给getValue赋值：
你见过给方法赋值的操作吗？（别闹了，你脑中想到的是给方法传参）。虽然这里的getValue可能不是指getValue()，底层或许是getValue()返回的一个同名变量。但不管怎么说，还是太怪异了。所以在注解里，类似于String getValue()这种，被称为“属性”。给属性赋值显然听起来好接受多了。
另外，我们还可以为属性指定默认值：
当没有赋值时，属性将使用默认值，比如上面的defaultMethod()，它的getValue就是“no description&#34;。
基于以上差异，以后还是把注解单独归为一类，不要当成接口使用。
反射注解信息 上文已经说过，注解就像一个标签，是贴在程序代码上供另一个程序读取的。所以三者关系是：
要牢记，只要用到注解，必然有三角关系：定义注解，使用注解，读取注解。仅仅完成前两步，是没什么卵用的。就好比你写了一本武林秘籍却没人去学，那么这门武功还不如一把菜刀。
所以，接下来我们写一个程序读取注解。读取注解的思路是：
反射获取注解信息：
我们发现，Class、Method、Field对象都有个getAnnotation()，可以获取各自位置的注解信息。
但是控制台提示“空指针异常”，IDEA提示我们：Annotation &#39;MyAnnotation.class&#39; is not retained for reflective。直译的话就是：注解MyAnnotation并没有为反射保留。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/16a9e5c5aa12ae7065a5a3d413a36e71/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-20T12:00:32+08:00" />
<meta property="article:modified_time" content="2023-10-20T12:00:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">怎样理解 Java 注解和运用注解编程？（大佬的文章）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        在制作上一篇文章之前，完成之后又去找了一下相关的文章，看到其中一个大佬的文章，我收获颇丰，创作就是需要这样的人，<strong>故秉承学习知识：海纳百川，</strong>厚着脸的将大佬的帖子转过来了</p> 
<p><strong>转载自（大家可以多去看看大佬的文章）：</strong>怎样理解 Java 注解和运用注解编程？ - bravo1988的回答 - 知乎 https://www.zhihu.com/question/47449512/answer/658228092</p> 
<p>注解，和反射一样，是Java中最重要却最容易被人遗忘的知识点。哪怕Spring、SpringMVC、SpringBoot等框架中充满了注解，我们还是选择性地忽视它。很多人不明白它是怎么起作用的，甚至有人把它和注释混淆...工作中也只是机械性地在Controller上加@RequestMapping。是的，我们太习以为常了，以至于觉得它应该就是如此。</p> 
<p>内容介绍：</p> 
<ul><li>两件小事</li><li>注解的作用</li><li>注解的本质</li><li>反射注解信息</li><li><a href="https://www.zhihu.com/search?q=%E5%85%83%E6%B3%A8%E8%A7%A3&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="元注解">元注解</a></li><li>属性的数据类型及特别的属性：value和数组</li></ul> 
<hr> 
<h3 style="background-color:transparent;">两件小事</h3> 
<p>去年工作中，我遇到的两件事让注解重新走进我的视野。</p> 
<p>第一，18年6月我去了北京，参与开发了某中国五百强企业的一个加密系统，第一次接触到了SpringBoot。当我发现一个demo项目只要简单地写个启动类并加上 @SpringBootApplication就可以<a href="https://www.zhihu.com/search?q=%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="直接访问">直接访问</a>Controller时，感到非常震撼。整个demo没有一个<a href="https://www.zhihu.com/search?q=%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="配置文件">配置文件</a>，连web.xml也没有。</p> 
<p></p> 
<p class="img-center"><img alt="" height="111" src="https://images2.imgbox.com/92/b9/G3nGHkUW_o.png" width="479"></p> 
<p>由于开发进度很赶，当时没时间去研究它是如何做到的，但这件事让我意识到自己对注解还是了解得太少。</p> 
<p></p> 
<p>第二，来到杭州后我又参与开发了一个金融借贷系统，那阵子对接了很多第三方的风控接口：</p> 
<p></p> 
<p class="img-center"><img alt="" height="312" src="https://images2.imgbox.com/e9/4e/oCUiqtNy_o.png" width="823"></p> 
<p>对签名验签不了解的朋友，可以百度一下。总之，每对接一个接口，都要在开头进行<a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="数据校验">数据校验</a>。一两个接口也就算了，但每次对接风控，基本上都要写10+多个方法。每个方法开头都写一份签名验签的代码，显然太冗余了。我当时的做法是将<a href="https://www.zhihu.com/search?q=%E9%AA%8C%E7%AD%BE%E4%BB%A3%E7%A0%81&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="验签代码">验签代码</a>抽取成方法，方便复用，自以为算是一种改良了，直到我看到同事用了切面...40米的大刀拦腰砍去，给每个方法都做了<a href="https://www.zhihu.com/search?q=%E7%AD%BE%E5%90%8D%E9%AA%8C%E7%AD%BE&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="签名验签">签名验签</a>：</p> 
<p></p> 
<p class="img-center"><img alt="" height="317" src="https://images2.imgbox.com/08/1a/x8tGFlpr_o.png" width="932"></p> 
<p>注意，实际上切面的作用是在方法前后，而不是方法内部的前后。上面这样画，仅仅为了更形象</p> 
<p>这两件事，让我知道，是时候重新学习一下注解了。</p> 
<hr> 
<h3><strong>注解的作用</strong></h3> 
<p><strong>格式</strong></p> 
<pre><code>public @interface 注解名称{
    <a href="https://www.zhihu.com/search?q=%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="属性列表">属性列表</a>;
}</code></pre> 
<p>格式有点奇怪，我们稍后再研究。</p> 
<p></p> 
<p><strong>分类</strong></p> 
<p>大致分为三类：<a href="https://www.zhihu.com/search?q=%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="自定义注解">自定义注解</a>、JDK内置注解、还有第三方框架提供的注解。</p> 
<p>自定义注解就是我们自己写的注解。JDK内置注解，比如@Override检验方法重载，@Deprecated标识方法过期等。第三方框架定义的注解比如SpringMVC的@Controller等。</p> 
<p></p> 
<p><strong>使用位置</strong></p> 
<p>实际开发中，注解常常出现在类、方法、<a href="https://www.zhihu.com/search?q=%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="成员变量">成员变量</a>、形参位置。当然还有其他位置，这里不提及。</p> 
<p></p> 
<p><strong>作用</strong></p> 
<p>如果说注释是写给人看的，那么注解就是写给程序看的。它更像一个标签，贴在一个类、一个方法或者字段上。它的目的是为当前读取该注解的程序提供判断依据。比如程序只要读到加了@Test的方法，就知道该方法是待测试方法，又比如@Before注解，程序看到这个注解，就知道该方法要放在@Test方法之前执行。</p> 
<p></p> 
<p><strong>级别</strong></p> 
<p>注解和类、接口、枚举是同一级别的。</p> 
<p></p> 
<hr> 
<h3><strong>注解的本质</strong></h3> 
<p>@<a href="https://www.zhihu.com/search?q=interface&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="interface">interface</a>和interface这么相似，我猜注解的本质是一个接口。</p> 
<p>为了验证这个猜测，我们做个实验。先按上面的格式写一个注解</p> 
<p></p> 
<p class="img-center"><img alt="" height="83" src="https://images2.imgbox.com/25/0f/Ls6e9z0J_o.png" width="400"></p> 
<p>属性先不写</p> 
<p>编译后得到字节码文件</p> 
<p></p> 
<p class="img-center"><img alt="" height="43" src="https://images2.imgbox.com/9b/2c/oqGNH0Vz_o.png" width="434"></p> 
<p>通过XJad工具反编译MyAnnotation.class</p> 
<p></p> 
<p class="img-center"><img alt="" height="186" src="https://images2.imgbox.com/ab/a9/ABDTjZ5S_o.png" width="535"></p> 
<p>我们发现，@interface变成了interface，而且自动继承了Annotation</p> 
<p></p> 
<p class="img-center"><img alt="" height="282" src="https://images2.imgbox.com/b6/8f/eY57hu6F_o.png" width="720"></p> 
<p>既然确实是个接口，那么我们自然可以在里面写方法</p> 
<p></p> 
<p class="img-center"><img alt="" height="99" src="https://images2.imgbox.com/a4/3a/slNhDQkn_o.png" width="455"></p> 
<p>得到<a href="https://www.zhihu.com/search?q=class%E6%96%87%E4%BB%B6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="class文件">class文件</a>后<a href="https://www.zhihu.com/search?q=%E5%8F%8D%E7%BC%96%E8%AF%91&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="反编译">反编译</a></p> 
<p></p> 
<p class="img-center"><img alt="" height="235" src="https://images2.imgbox.com/52/28/6BifBz04_o.png" width="533"></p> 
<p>由于接口默认方法的修饰符就是<a href="https://www.zhihu.com/search?q=public%20abstract&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="public abstract">public abstract</a>，所以可以省略，直接写成：</p> 
<p></p> 
<p class="img-center"><img alt="" height="136" src="https://images2.imgbox.com/8d/7a/o8LqrNQt_o.png" width="428"></p> 
<p>虽说注解的本质是接口，但是仍然有很多怪异的地方，比如使用注解时，我们竟然可以给getValue赋值：</p> 
<p></p> 
<p class="img-center"><img alt="" height="292" src="https://images2.imgbox.com/28/b7/tDzOIltT_o.png" width="599"></p> 
<p>你见过给方法赋值的操作吗？（别闹了，你脑中想到的是给方法传参）。虽然这里的getValue可能不是指getValue()，底层或许是getValue()返回的一个同名变量。但不管怎么说，还是太怪异了。所以在注解里，类似于String getValue()这种，被称为“属性”。给属性赋值显然听起来好接受多了。</p> 
<p>另外，我们还可以为属性指定默认值：</p> 
<p></p> 
<p class="img-center"><img alt="" height="135" src="https://images2.imgbox.com/46/ae/EUKxXAWh_o.png" width="530"></p> 
<p></p> 
<p class="img-center"><img alt="" height="354" src="https://images2.imgbox.com/4d/93/VXWxcswf_o.png" width="616"></p> 
<p>当没有赋值时，属性将使用默认值，比如上面的defaultMethod()，它的getValue就是“<a href="https://www.zhihu.com/search?q=no%20description&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="no description">no description</a>"。</p> 
<p>基于以上差异，以后还是把注解单独归为一类，不要当成接口使用。</p> 
<hr> 
<h3><strong>反射注解信息</strong></h3> 
<p>上文已经说过，注解就像一个标签，是贴在<a href="https://www.zhihu.com/search?q=%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="程序代码">程序代码</a>上供另一个程序读取的。所以三者关系是：</p> 
<p></p> 
<p class="img-center"><img alt="" height="349" src="https://images2.imgbox.com/f3/7a/cULHTJEC_o.png" width="465"></p> 
<p><strong>要牢记，只要用到注解，必然有<a href="https://www.zhihu.com/search?q=%E4%B8%89%E8%A7%92%E5%85%B3%E7%B3%BB&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="三角关系">三角关系</a>：定义注解，使用注解，读取注解。</strong>仅仅完成前两步，是没什么卵用的。就好比你写了一本<a href="https://www.zhihu.com/search?q=%E6%AD%A6%E6%9E%97%E7%A7%98%E7%B1%8D&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="武林秘籍">武林秘籍</a>却没人去学，那么这门武功还不如一把菜刀。</p> 
<p></p> 
<p>所以，接下来我们写一个程序读取注解。读取注解的思路是：</p> 
<p></p> 
<p class="img-center"><img alt="" height="365" src="https://images2.imgbox.com/17/80/PzSDnvGk_o.png" width="460"></p> 
<p>反射获取注解信息：</p> 
<p></p> 
<p class="img-center"><img alt="" height="360" src="https://images2.imgbox.com/48/1e/CKLuqiDL_o.png" width="720"></p> 
<p>我们发现，Class、Method、Field对象都有个getAnnotation()，可以获取各自位置的注解信息。</p> 
<p>但是控制台提示“<a href="https://www.zhihu.com/search?q=%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="空指针异常">空指针异常</a>”，IDEA提示我们：Annotation 'MyAnnotation.class' is not retained for reflective。直译的话就是：注解MyAnnotation并没有为反射保留。</p> 
<p>这是因为注解其实有所谓“保留策略”的说法。大家学习JSP时，应该学过&lt;!-- --&gt;和&lt;%-- --&gt;的区别：前者可以在浏览器检查网页<a href="https://www.zhihu.com/search?q=%E6%BA%90%E4%BB%A3%E7%A0%81&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="源代码">源代码</a>时看到，而另一个在服务器端输出时就被抹去了。同样的，注解通过保留策略，控制自己可以保留到哪个阶段。保留策略也是通过注解实现，它属于元注解，也叫<a href="https://www.zhihu.com/search?q=%E5%85%83%E6%95%B0%E6%8D%AE&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="元数据">元数据</a>。</p> 
<hr> 
<h3><strong>元注解</strong></h3> 
<p>所谓元注解，就是加在注解上的注解。作为普通程序员，常用的就是：</p> 
<ul><li>@Documented</li></ul> 
<p>用于制作文档，不是很重要，忽略便是</p> 
<p></p> 
<ul><li>@Target</li></ul> 
<p>加在注解上，限定该注解的使用位置。不写的话，好像默认各个位置都是可以的。如果需要限定注解的使用位置，可以在自定义的注解上使用该注解。我们本次默认即可，不特别限定。</p> 
<p></p> 
<p class="img-center"><img alt="" height="248" src="https://images2.imgbox.com/e3/55/55I4kT1I_o.png" width="720"></p> 
<p></p> 
<ul><li>@Retention（注解的保留策略）</li></ul> 
<p></p> 
<p class="img-center"><img alt="" height="157" src="https://images2.imgbox.com/b4/b9/XIKk1Shh_o.png" width="684"></p> 
<p>注解的保留策略有三种：SOURCE/ClASS/RUNTIME</p> 
<p></p> 
<p class="img-center"><img alt="" height="190" src="https://images2.imgbox.com/88/40/glqLjLv8_o.png" width="679"></p> 
<ul><li>注解主要被反射读取</li><li>反射只能读取内存中的字节码信息</li><li>RetentionPolicy.CLASS指的是保留到字节码文件，它在磁盘内，而不是内存中。虚拟机将<a href="https://www.zhihu.com/search?q=%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="字节码文件">字节码文件</a>加载进内存后注解会消失</li><li>要想被反射读取，保留策略只能用RUNTIME，即<a href="https://www.zhihu.com/search?q=%E8%BF%90%E8%A1%8C%E6%97%B6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="运行时">运行时</a>仍可读取</li></ul> 
<p></p> 
<p class="img-center"><img alt="" height="217" src="https://images2.imgbox.com/22/ea/elV6VJ71_o.png" width="500"></p> 
<p></p> 
<p class="img-center"><img alt="" height="383" src="https://images2.imgbox.com/de/3c/MkaO2hal_o.png" width="605"></p> 
<p>重新运行程序，成功读取注解信息：</p> 
<p></p> 
<p class="img-center"><img alt="" height="369" src="https://images2.imgbox.com/d2/95/dkVGQLyC_o.png" width="720"></p> 
<p>注意，<a href="https://www.zhihu.com/search?q=defaultMethod&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="defaultMethod">defaultMethod</a>()反射得到的注解信息是：no description。就是MyAnnotion中getValue的默认值。</p> 
<p></p> 
<hr> 
<h3><strong>属性的数据类型及特别的属性：value和数组</strong></h3> 
<p><strong>属性的数据类型</strong></p> 
<ul><li>八种基本数据类型</li><li>String</li><li>枚举</li><li>Class</li><li>注解类型</li><li>以上类型的<a href="https://www.zhihu.com/search?q=%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A658228092%7D" rel="nofollow" title="一维数组">一维数组</a></li></ul> 
<p></p> 
<p class="img-center"><img alt="" height="590" src="https://images2.imgbox.com/18/d4/TjsLSCNE_o.png" width="357"></p> 
<p></p> 
<p class="img-center"><img alt="" height="450" src="https://images2.imgbox.com/08/66/OfjapOMx_o.png" width="364"></p> 
<p></p> 
<p><strong>value属性</strong></p> 
<p>如果注解的属性只有一个，且叫value，那么使用该注解时，可以不用指定属性名，因为默认就是给value赋值：</p> 
<p></p> 
<p class="img-center"><img alt="" height="249" src="https://images2.imgbox.com/dd/a3/E07VlXNC_o.png" width="536"></p> 
<p></p> 
<p class="img-center"><img alt="" height="271" src="https://images2.imgbox.com/aa/5e/icgqaeTk_o.png" width="503"></p> 
<p></p> 
<p class="img-center"><img alt="" height="398" src="https://images2.imgbox.com/03/3e/s9jlojt2_o.png" width="720"></p> 
<p>但是注解的属性如果有多个，无论是否叫value，都必须写明属性的对应关系：</p> 
<p></p> 
<p class="img-center"><img alt="" height="116" src="https://images2.imgbox.com/76/b2/KLQWzGL2_o.png" width="371"></p> 
<p></p> 
<p class="img-center"><img alt="" height="269" src="https://images2.imgbox.com/01/a1/8t316nOU_o.png" width="671"></p> 
<p></p> 
<p><strong>数组属性</strong></p> 
<p>如果数组的元素只有一个，可以省略{}：</p> 
<p></p> 
<p class="img-center"><img alt="" height="447" src="https://images2.imgbox.com/55/1c/dmmqWixS_o.png" width="365"></p> 
<p></p> 
<p></p> 
<p><strong>原文链接：</strong>怎样理解 Java 注解和运用注解编程？ - bravo1988的回答 - 知乎 https://www.zhihu.com/question/47449512/answer/658228092</p> 
<hr> 
<p>小结</p> 
<ul><li>注解就像标签，是程序判断执行的依据。比如，程序读到@Test就知道这个方法是待测试方法，而@Before的方法要在测试方法之前执行</li><li>注解需要三要素：定义、使用、读取并执行</li><li>注解分为自定义注解、JDK内置注解和第三方注解（框架）。自定义注解一般要我们自己定义、使用、并写程序读取，而JDK内置注解和第三方注解我们只要使用，定义和读取都交给它们</li><li>大多数情况下，三角关系中我们只负责使用注解，无需定义和执行，框架会将<strong>注解类</strong>和<strong>读取注解的程序</strong>隐藏起来，除非阅读源码，否则根本看不到。<strong>平时见不到定义和读取的过程，光顾着使用注解，久而久之很多人就忘了注解如何起作用了！</strong></li></ul> 
<p></p> 
<p class="img-center"><img alt="" height="373" src="https://images2.imgbox.com/e4/50/vUBw9jBe_o.png" width="598"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/37b3f256567123ffdfe6d1b2ab01ebd8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">怎样理解 Java 注解和运用注解编程？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/070565b274db3d7cf0e3ba2b556572e9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">echarts legend不显示问题解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>