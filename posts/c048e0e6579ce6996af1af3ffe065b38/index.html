<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于Opencv&#43;python的车流量检测项目 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于Opencv&#43;python的车流量检测项目" />
<meta property="og:description" content="目录
项目介绍
整体流程
调试环境
项目流程
1.预处理
2.汽车识别——去背景算法（KNN/MOG2）
3.统计车流量数目
结尾
源代码
测试视频资料
流程图
项目介绍 本次项目主要采用了传统视觉的方法，对车道车流实现检测，能较为准确的识别出来车道上的车辆数目。由于传统视觉算法本身的局限性，因此也会有识别不准的地方。
整体流程 话不多说，先讲思路，直接上流程图
这里把所有预先设定的参数和变量统一称为了“宏”，然后对识别到的每一帧图像进行处理，最后得到理想的效果图。
效果图如下：
调试环境 Jupyter Notebook(Anaconda)Python 3.9.12OpenCv 4.5.5 项目流程 1.预处理 #灰度 cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY) #高斯去噪 blur=cv2.GaussianBlur(frame,(5,5),5) mask=removebg.apply(blur) #腐蚀 erode=cv2.erode(mask,kernel,iterations=2))#iteration=n 迭代n次 #膨胀 dilate=cv2.dilate(erode,kernel,iterations=2 #cv2.imshow(&#34;x&#34;,dilate) dst=cv2.morphologyEx(dilate,cv2.MORPH_CLOSE,kernel) 2.汽车识别——去背景算法（KNN/MOG2） 先介绍KNN算法（因为本次采用的算法为KNN）
KNN最邻近分类算法的实现原理：为了判断未知样本的类别，以所有已知类别的样本作为参照，计算未知样本与所有已知样本的距离，从中选取与未知样本距离最近的K个已知样本，根据少数服从多数的投票法则（majority-voting），将未知样本与K个最邻近样本中所属类别占比较多的归为一类。
在Opencv中，KNN算法已经被封装好了，所以我们直接调用就可以。
#KNN算法去背景 removebg=cv2.createBackgroundSubtractorKNN() MOG2是一个以混合高斯模型为基础的前景/背景分割算法。使用 K(K=3 或 5)个高斯分布混合对背景像素进行建模。使用这些颜色(在整个视频中)存在时间的长短作为混合的权重。背景的颜色一般持续的时间最长，而且更加静止。这个函数有些可选参数，比如要进行建模场景的时间长度，高斯混合成分的数量，阈值等。将他们全部设置为默认值。然后在整个视频中我们是需要使用backgroundsubtractor.apply() 就可以得到前景的掩模了。移动的物体会被标记为白色，背景会被标记为黑色的。使用方法同上，在此不过多赘述。
3.统计车流量数目 本次统计采用的方法为：找到矩形框的中心点经，当该点经过提前所设定好的直线时，车辆数&#43;1
计算中心点的函数:
def center(x,y,w,h): x1=int(w/2) y1=int(h/2) cx=x&#43;x1 cy=y&#43;y1 统计车流量的代码部分：
cpoint=center(x,y,w,h) cars.append(cpoint)#将中心点储存到cars数组中 for (x,y) in cars: if(y&gt;lineHeight-7 and y&lt;lineHeight&#43;7): Car_nums &#43;=1 cars." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c048e0e6579ce6996af1af3ffe065b38/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-21T21:19:48+08:00" />
<meta property="article:modified_time" content="2023-10-21T21:19:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于Opencv&#43;python的车流量检测项目</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p style="margin-left:0px;"><a href="#%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D" rel="nofollow">项目介绍</a></p> 
<p style="margin-left:0px;"><a href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B" rel="nofollow">整体流程</a></p> 
<p style="margin-left:0px;"><a href="#%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83" rel="nofollow">调试环境</a></p> 
<p style="margin-left:0px;"><a href="#%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B" rel="nofollow">项目流程</a></p> 
<p style="margin-left:40px;"><a href="#1.%E9%A2%84%E5%A4%84%E7%90%86" rel="nofollow">1.预处理</a></p> 
<p style="margin-left:40px;"><a href="#2.%E6%B1%BD%E8%BD%A6%E8%AF%86%E5%88%AB%E2%80%94%E2%80%94%E5%8E%BB%E8%83%8C%E6%99%AF%E7%AE%97%E6%B3%95%EF%BC%88KNN%2FMOG2%EF%BC%89" rel="nofollow">2.汽车识别——去背景算法（KNN/MOG2）</a></p> 
<p style="margin-left:40px;"><a href="#3.%E7%BB%9F%E8%AE%A1%E8%BD%A6%E6%B5%81%E9%87%8F%E6%95%B0%E7%9B%AE" rel="nofollow">3.统计车流量数目</a></p> 
<p style="margin-left:0px;"><a href="#%E7%BB%93%E5%B0%BE" rel="nofollow">结尾</a></p> 
<p style="margin-left:40px;"><a href="#%E9%99%84%E6%BA%90%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">源代码</a></p> 
<p style="margin-left:40px;"><a href="#%E9%99%84%E4%B8%8A%E6%B5%8B%E8%AF%95%E8%A7%86%E9%A2%91%E8%B5%84%E6%96%99%EF%BC%9A" rel="nofollow">测试视频资料</a></p> 
<p style="margin-left:40px;"><a href="#%E8%BE%83%E4%B8%BA%E5%BD%A2%E8%B1%A1%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%9A%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">流程图</a></p> 
<hr> 
<p></p> 
<h2>项目介绍</h2> 
<p>本次项目主要采用了传统视觉的方法，对车道车流实现检测，能较为准确的识别出来车道上的车辆数目。由于传统视觉算法本身的局限性，因此也会有识别不准的地方。</p> 
<h2>整体流程</h2> 
<p>话不多说，先讲思路，直接上流程图</p> 
<p style="text-align:center;"><img alt="8dee5f37debe4e85ae1d9040dd51e48e.png" src="https://images2.imgbox.com/9f/f7/qtgVUDR8_o.png"></p> 
<p>这里把所有预先设定的参数和变量统一称为了“宏”，然后对识别到的每一帧图像进行处理，最后得到理想的效果图。</p> 
<p>效果图如下：</p> 
<p style="text-align:center;"><img alt="c03ec719b3954a3f9a97773acb5922e7.png" src="https://images2.imgbox.com/c4/dc/sTaYaohY_o.png"></p> 
<p></p> 
<h2>调试环境</h2> 
<ul><li>Jupyter Notebook(Anaconda)</li><li>Python    3.9.12</li><li>OpenCv  4.5.5</li></ul> 
<h2>项目流程</h2> 
<h3>1.预处理</h3> 
<pre><code class="language-python">        #灰度
        cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)
        #高斯去噪
        blur=cv2.GaussianBlur(frame,(5,5),5)
        mask=removebg.apply(blur)
        
        #腐蚀
        erode=cv2.erode(mask,kernel,iterations=2))#iteration=n 迭代n次
        #膨胀
        dilate=cv2.dilate(erode,kernel,iterations=2
        #cv2.imshow("x",dilate)
        dst=cv2.morphologyEx(dilate,cv2.MORPH_CLOSE,kernel)</code></pre> 
<h3>2.汽车识别——去背景算法（KNN/MOG2）</h3> 
<p>        先介绍KNN算法（因为本次采用的算法为KNN）</p> 
<p>        KNN最邻近分类算法的实现原理：为了判断未知样本的类别，以所有已知类别的样本作为参照，计算未知样本与所有已知样本的距离，从中选取与未知样本距离最近的K个已知样本，根据少数服从多数的投票法则（majority-voting），将未知样本与K个最邻近样本中所属类别占比较多的归为一类。</p> 
<p>  在Opencv中，KNN算法已经被封装好了，所以我们直接调用就可以。</p> 
<pre><code class="language-python">#KNN算法去背景
removebg=cv2.createBackgroundSubtractorKNN()</code></pre> 
<p>        MOG2是一个以混合高斯模型为基础的前景/背景分割算法。使用 K(K=3 或 5)个高斯分布混合对背景像素进行建模。使用这些颜色(在整个视频中)存在时间的长短作为混合的权重。背景的颜色一般持续的时间最长，而且更加静止。这个函数有些可选参数，比如要进行建模场景的时间长度，高斯混合成分的数量，阈值等。将他们全部设置为默认值。然后在整个视频中我们是需要使用backgroundsubtractor.apply() 就可以得到前景的掩模了。移动的物体会被标记为白色，背景会被标记为黑色的。使用方法同上，在此不过多赘述。</p> 
<h3>3.统计车流量数目</h3> 
<p>本次统计采用的方法为：找到矩形框的中心点经，当该点经过提前所设定好的直线时，车辆数+1</p> 
<p>计算中心点的函数:</p> 
<pre><code class="language-python">def center(x,y,w,h):
    x1=int(w/2)
    y1=int(h/2)
    cx=x+x1
    cy=y+y1</code></pre> 
<p>统计车流量的代码部分：</p> 
<pre><code class="language-python"> cpoint=center(x,y,w,h)
            cars.append(cpoint)#将中心点储存到cars数组中
            
            for (x,y) in cars:
                if(y&gt;lineHeight-7 and y&lt;lineHeight+7):
                    Car_nums +=1
                    cars.remove((x,y))
                    print(Car_nums)</code></pre> 
<p>最后在经过一些简单的处理，该项目就实现了。</p> 
<h2>结尾</h2> 
<h3>附源代码：</h3> 
<pre><code class="language-python">import cv2
import numpy as np
lineHeight=550
#穿过直线的车的数量
Car_nums=0
#储存中心坐标的数组
cars=[]
#KNN算法去背景
removebg=cv2.createBackgroundSubtractorKNN()
def center(x,y,w,h):
    x1=int(w/2)
    y1=int(h/2)
    cx=x+x1
    cy=y+y1
    
    return cx,cy

video=cv2.VideoCapture('D://video.mp4')

kernel=cv2.getStructuringElement(cv2.MORPH_RECT,(5,5))

while True:
    ret,frame=video.read()
    if(ret!=0):
        #灰度
        cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)
        #高斯去噪
        blur=cv2.GaussianBlur(frame,(5,5),5)
        mask=removebg.apply(blur)
        
        #腐蚀
        erode=cv2.erode(mask,kernel,iterations=2)#iteration=n 迭代n次
        #膨胀
        dilate=cv2.dilate(erode,kernel,iterations=2)
        #cv2.imshow("x",dilate)
        dst=cv2.morphologyEx(dilate,cv2.MORPH_CLOSE,kernel)
        #cv2.imshow("x1",dst)
                          
        #画出检测线
        cv2.line(frame,(10,lineHeight),(1400,lineHeight),(255,0,0),2)
        counts,h=cv2.findContours(dst,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)
        #遍历所有轮廓
        for(i,c) in enumerate(counts):
            (x,y,w,h)=cv2.boundingRect(c)
            
            if((w&lt;=90) and (h&lt;=90)):
                continue
            if(y&lt;66):
                continue
            #将有效的车绘制出来
            cv2.rectangle(frame,(x,y),(x+w,y+h),(0,0,255),2)
            cpoint=center(x,y,w,h)
            cars.append(cpoint)#将中心点储存到cars数组中
            
            for (x,y) in cars:
                if(y&gt;lineHeight-7 and y&lt;lineHeight+7):
                    Car_nums +=1
                    cars.remove((x,y))
                    print(Car_nums)
        
        cv2.putText(frame,"Cars nums:"+str(Car_nums),(500,60),cv2.FONT_HERSHEY_DUPLEX,1,(255,0,0))
        cv2.imshow("video",frame)
        
    key=cv2.waitKey(1)
    if(key==27):
        break

video.release()
cv2.destroyAllWindows()        </code></pre> 
<h3>附上测试视频资料：</h3> 
<blockquote> 
 <p>链接：<a class="link-info" href="http://xn--https-bl8js66z7n7i//pan.baidu.com/s/1u_hjCtL3FR6FzeEVQar7wg?pwd=2Y1p" rel="nofollow" title="https://pan.baidu.com/s/1u_hjCtL3FR6FzeEVQar7wg?pwd=2Y1p ">https://pan.baidu.com/s/1u_hjCtL3FR6FzeEVQar7wg?pwd=2Y1p </a><br> 提取码：2Y1p</p> 
</blockquote> 
<h3>较为形象的流程图：<img alt="9c13a7945a6447f58a477ed753dd077d.png" src="https://images2.imgbox.com/3c/05/d45Ls6KZ_o.png"></h3> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7565e618c126b2616bd885a4b1cd7726/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【网络】‘‘三层交换机‘‘配置详解，看一遍就会！！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d6898e1661a3bb72bf567493ac879820/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">STM32驱动RGB LED彩灯模块闪烁GPIO_Write（）函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>