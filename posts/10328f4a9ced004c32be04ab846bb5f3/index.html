<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>微信小程序框架 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="微信小程序框架" />
<meta property="og:description" content="框架 小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。
整个小程序框架系统分为两部分：逻辑层（App Service）和 视图层（View）。小程序提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。
响应的数据绑定 框架的核心是一个响应的数据绑定系统，可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。
通过这个简单的例子来看：
在开发者工具中预览效果
&lt;!-- This is our View --&gt; &lt;view&gt; Hello {{name}}! &lt;/view&gt; &lt;button bindtap=&#34;changeName&#34;&gt; Click me! &lt;/button&gt; // This is our App Service. // This is our data. var helloData = { name: &#39;Weixin&#39; } ​ // Register a Page. Page({ data: helloData, changeName: function(e) { // sent data change to view this.setData({ name: &#39;MINA&#39; }) } }) 开发者通过框架将逻辑层数据中的 name 与视图层的 name 进行了绑定，所以在页面一打开的时候会显示 Hello Weixin!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/10328f4a9ced004c32be04ab846bb5f3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-01T17:14:36+08:00" />
<meta property="article:modified_time" content="2023-01-01T17:14:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">微信小程序框架</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>框架</h2> 
<p>小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。</p> 
<p>整个小程序框架系统分为两部分：<strong><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/" rel="nofollow" title="逻辑层">逻辑层</a></strong>（App Service）和 <strong><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/" rel="nofollow" title="视图层">视图层</a></strong>（View）。小程序提供了自己的视图层描述语言 <code>WXML</code> 和 <code>WXSS</code>，以及基于 <code>JavaScript</code> 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。</p> 
<h3>响应的数据绑定</h3> 
<p>框架的核心是一个响应的数据绑定系统，可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。</p> 
<p>通过这个简单的例子来看：</p> 
<p><a href="https://developers.weixin.qq.com/s/l0gLEKmv6gZa" rel="nofollow" title="在开发者工具中预览效果">在开发者工具中预览效果</a></p> 
<pre><code class="hljs">&lt;!-- This is our View --&gt;
&lt;view&gt; Hello {<!-- -->{name}}! &lt;/view&gt;
&lt;button bindtap="changeName"&gt; Click me! &lt;/button&gt;
// This is our App Service.
// This is our data.
var helloData = {
  name: 'Weixin'
}
​
// Register a Page.
Page({
  data: helloData,
  changeName: function(e) {
    // sent data change to view
    this.setData({
      name: 'MINA'
    })
  }
})</code></pre> 
<ul><li> <p>开发者通过框架将逻辑层数据中的 <code>name</code> 与视图层的 <code>name</code> 进行了绑定，所以在页面一打开的时候会显示 <code>Hello Weixin!</code>；</p> </li><li> <p>当点击按钮的时候，视图层会发送 <code>changeName</code> 的事件给逻辑层，逻辑层找到并执行对应的事件处理函数；</p> </li><li> <p>回调函数触发后，逻辑层执行 <code>setData</code> 的操作，将 <code>data</code> 中的 <code>name</code> 从 <code>Weixin</code> 变为 <code>MINA</code>，因为该数据和视图层已经绑定了，从而视图层会自动改变为 <code>Hello MINA!</code>。</p> </li></ul> 
<h3>页面管理</h3> 
<p>框架 管理了整个<strong>小程序</strong>的页面路由，可以做到页面间的无缝切换，并给以页面完整的生命周期。开发者需要做的只是将页面的数据、方法、生命周期函数注册到 框架 中，其他的一切复杂的操作都交由 框架 处理。</p> 
<h3>基础组件</h3> 
<p>框架 提供了一套基础的组件，这些组件自带微信风格的样式以及特殊的逻辑，开发者可以通过组合基础组件，创建出强大的<strong>微信小程序</strong> 。</p> 
<h3>丰富的 API</h3> 
<p>框架 提供丰富的微信原生 API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。</p> 
<h2>逻辑层 App Service</h2> 
<p>小程序开发框架的逻辑层使用 <code>JavaScript</code> 引擎为小程序提供开发者 <code>JavaScript</code> 代码的运行环境以及微信小程序的特有功能。</p> 
<p>逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。</p> 
<p>开发者写的所有代码最终将会打包成一份 <code>JavaScript</code> 文件，并在小程序启动的时候运行，直到小程序销毁。这一行为类似 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" rel="nofollow" title="ServiceWorker">ServiceWorker</a>，所以逻辑层也称之为 App Service。</p> 
<p>在 <code>JavaScript</code> 的基础上，我们增加了一些功能，以方便小程序的开发：</p> 
<ul><li> <p>增加 <code>App</code> 和 <code>Page</code> 方法，进行<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html" rel="nofollow" title="程序注册">程序注册</a>和<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html" rel="nofollow" title="页面注册">页面注册</a>。</p> </li><li> <p>增加 <code>getApp</code> 和 <code>getCurrentPages</code> 方法，分别用来获取 <code>App</code> 实例和当前页面栈。</p> </li><li> <p>提供丰富的 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html" rel="nofollow" title="API">API</a>，如微信用户数据，扫一扫，支付等微信特有能力。</p> </li><li> <p>提供<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/module.html#%E6%A8%A1%E5%9D%97%E5%8C%96" rel="nofollow" title="模块化">模块化</a>能力，每个页面有独立的<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/module.html#%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8%E5%9F%9F" rel="nofollow" title="作用域">作用域</a>。</p> </li></ul> 
<p><strong>注意：小程序框架的逻辑层并非运行在浏览器中，因此 <code>JavaScript</code> 在 web 中一些能力都无法使用，如 <code>window</code>，<code>document</code> 等。</strong></p> 
<h3>小程序的生命周期</h3> 
<p>每个小程序都需要在 <code>app.js</code> 中调用 <code>App</code> 方法注册小程序实例，绑定生命周期回调函数、错误监听和页面不存在监听函数等。</p> 
<p>详细的参数含义和使用请参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html" rel="nofollow" title="App 参考文档">App 参考文档</a> 。</p> 
<pre><code class="hljs">// app.js
App({
  onLaunch (options) {
    // Do something initial when launch.
  },
  onShow (options) {
    // Do something when show.
  },
  onHide () {
    // Do something when hide.
  },
  onError (msg) {
    console.log(msg)
  },
  globalData: 'I am global data'
})</code></pre> 
<p>整个小程序只有一个 App 实例，是全部页面共享的。开发者可以通过 <code>getApp</code> 方法获取到全局唯一的 App 实例，获取 App 上的数据或调用开发者注册在 <code>App</code> 上的函数。</p> 
<pre><code class="hljs">// xxx.js
const appInstance = getApp()
console.log(appInstance.globalData) // I am global data</code></pre> 
<blockquote> 
 <p>前台、后台定义： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。</p> 
 <p>只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。</p> 
 <p><strong>注意：</strong></p> 
 <p>1.不要在定义于 App() 内的函数中调用 getApp() ，使用 this 就可以拿到 app 实例。</p> 
 <p>2.不要在 onLaunch 的时候调用 getCurrentPage()，此时 page 还没有生成。</p> 
 <p>3.通过 getApp() 获取实例之后，不要私自调用生命周期函数。</p> 
</blockquote> 
<h3>注册页面</h3> 
<p>对于小程序中的每个页面，都需要在页面对应的 <code>js</code> 文件中进行注册，指定页面的初始数据、生命周期回调、事件处理函数等。</p> 
<h4>使用 Page 构造器注册页面</h4> 
<p>简单的页面可以使用 <code>Page()</code> 进行构造。</p> 
<p><strong>代码示例：</strong></p> 
<pre><code class="hljs">//index.js
Page({
  data: {
    text: "This is page data."
  },
  onLoad: function(options) {
    // 页面创建时执行
  },
  onShow: function() {
    // 页面出现在前台时执行
  },
  onReady: function() {
    // 页面首次渲染完毕时执行
  },
  onHide: function() {
    // 页面从前台变为后台时执行
  },
  onUnload: function() {
    // 页面销毁时执行
  },
  onPullDownRefresh: function() {
    // 触发下拉刷新时执行
  },
  onReachBottom: function() {
    // 页面触底时执行
  },
  onShareAppMessage: function () {
    // 页面被用户分享时执行
  },
  onPageScroll: function() {
    // 页面滚动时执行
  },
  onResize: function() {
    // 页面尺寸变化时执行
  },
  onTabItemTap(item) {
    // tab 点击时执行
    console.log(item.index)
    console.log(item.pagePath)
    console.log(item.text)
  },
  // 事件响应函数
  viewTap: function() {
    this.setData({
      text: 'Set some data for updating view.'
    }, function() {
      // this is setData callback
    })
  },
  // 自由数据
  customData: {
    hi: 'MINA'
  }
})</code></pre> 
<p>详细的参数含义和使用请参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html" rel="nofollow" title="Page 参考文档">Page 参考文档</a> 。</p> 
<h4>在页面中使用 behaviors</h4> 
<blockquote> 
 <p>基础库 2.9.2 开始支持，低版本需做<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" rel="nofollow" title="兼容处理">兼容处理</a>。</p> 
</blockquote> 
<p>页面可以引用 behaviors 。 behaviors 可以用来让多个页面有相同的数据字段和方法。</p> 
<pre><code class="hljs">// my-behavior.js
module.exports = Behavior({
  data: {
    sharedText: 'This is a piece of data shared between pages.'
  },
  methods: {
    sharedMethod: function() {
      this.data.sharedText === 'This is a piece of data shared between pages.'
    }
  }
})
// page-a.js
var myBehavior = require('./my-behavior.js')
Page({
  behaviors: [myBehavior],
  onLoad: function() {
    this.data.sharedText === 'This is a piece of data shared between pages.'
  }
})</code></pre> 
<p>具体用法参见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html" rel="nofollow" title="behaviors">behaviors</a> 。</p> 
<h4>使用 Component 构造器构造页面</h4> 
<blockquote> 
 <p>基础库 1.6.3 开始支持，低版本需做<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" rel="nofollow" title="兼容处理">兼容处理</a>。</p> 
</blockquote> 
<p><code>Page</code> 构造器适用于简单的页面。但对于复杂的页面， <code>Page</code> 构造器可能并不好用。</p> 
<p>此时，可以使用 <code>Component</code> 构造器来构造页面。 <code>Component</code> 构造器的主要区别是：方法需要放在 <code>methods: { }</code> 里面。</p> 
<p><strong>代码示例：</strong></p> 
<pre><code class="hljs">Component({
  data: {
    text: "This is page data."
  },
  methods: {
    onLoad: function(options) {
      // 页面创建时执行
    },
    onPullDownRefresh: function() {
      // 下拉刷新时执行
    },
    // 事件响应函数
    viewTap: function() {
      // ...
    }
  }
})</code></pre> 
<p>这种创建方式非常类似于 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/" rel="nofollow" title="自定义组件">自定义组件</a> ，可以像自定义组件一样使用 <code>behaviors</code> 等高级特性。</p> 
<p>具体细节请阅读 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/component.html" rel="nofollow" title="Component 构造器">Component 构造器</a> 章节。</p> 
<h3>页面的生命周期</h3> 
<p>下图说明了页面 <code>Page</code> 实例的生命周期。</p> 
<p><img alt="" height="1014" src="https://images2.imgbox.com/40/31/jYXfUA8w_o.png" width="662"></p> 
<p> </p> 
<blockquote> 
 <p>写微信小程序，他的生命周期不能不知道，不知道小程序就会出现各种bug而无法解决。</p> 
 <p>小程序由两大线程组成：负责界面的线程（view thread）和服务线程（appservice thread），各司其职由互相配合</p> 
</blockquote> 
<h3>页面路由</h3> 
<p>在小程序中所有页面的路由全部由框架进行管理。</p> 
<h4>页面栈</h4> 
<p>框架以栈的形式维护了当前的所有页面。 当发生路由切换的时候，页面栈的表现如下：</p> 
<table><thead><tr><th>路由方式</th><th>页面栈表现</th></tr></thead><tbody><tr><td>初始化</td><td>新页面入栈</td></tr><tr><td>打开新页面</td><td>新页面入栈</td></tr><tr><td>页面重定向</td><td>当前页面出栈，新页面入栈</td></tr><tr><td>页面返回</td><td>页面不断出栈，直到目标返回页</td></tr><tr><td>Tab 切换</td><td>页面全部出栈，只留下新的 Tab 页面</td></tr><tr><td>重加载</td><td>页面全部出栈，只留下新的页面</td></tr></tbody></table> 
<p>开发者可以使用 <code>getCurrentPages()</code> 函数获取当前页面栈。</p> 
<h4>路由方式</h4> 
<p>对于路由的触发方式以及页面生命周期函数如下：</p> 
<table><thead><tr><th>路由方式</th><th>触发时机</th><th>路由前页面</th><th>路由后页面</th></tr></thead><tbody><tr><td>初始化</td><td>小程序打开的第一个页面</td><td></td><td>onLoad, onShow</td></tr><tr><td>打开新页面</td><td>调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html" rel="nofollow" title="wx.navigateTo">wx.navigateTo</a> 使用组件 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html" rel="nofollow" title="``  ">``</a></td><td>onHide</td><td>onLoad, onShow</td></tr><tr><td>页面重定向</td><td>调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.redirectTo.html" rel="nofollow" title="wx.redirectTo">wx.redirectTo</a> 使用组件 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html" rel="nofollow" title="``  ">``</a></td><td>onUnload</td><td>onLoad, onShow</td></tr><tr><td>页面返回</td><td>调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html" rel="nofollow" title="wx.navigateBack">wx.navigateBack</a> 使用组件<a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html" rel="nofollow" title="``  ">``</a> 用户按左上角返回按钮</td><td>onUnload</td><td>onShow</td></tr><tr><td>Tab 切换</td><td>调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.switchTab.html" rel="nofollow" title="wx.switchTab">wx.switchTab</a> 使用组件 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html" rel="nofollow" title="``  ">``</a> 用户切换 Tab</td><td></td><td>各种情况请参考下表</td></tr><tr><td>重启动</td><td>调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.reLaunch.html" rel="nofollow" title="wx.reLaunch">wx.reLaunch</a> 使用组件 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html" rel="nofollow" title="``  ">``</a></td><td>onUnload</td><td>onLoad, onShow</td></tr></tbody></table> 
<p>Tab 切换对应的生命周期（以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例）：</p> 
<table><thead><tr><th>当前页面</th><th>路由后页面</th><th>触发的生命周期（按顺序）</th></tr></thead><tbody><tr><td>A</td><td>A</td><td>Nothing happend</td></tr><tr><td>A</td><td>B</td><td>A.onHide(), B.onLoad(), B.onShow()</td></tr><tr><td>A</td><td>B（再次打开）</td><td>A.onHide(), B.onShow()</td></tr><tr><td>C</td><td>A</td><td>C.onUnload(), A.onShow()</td></tr><tr><td>C</td><td>B</td><td>C.onUnload(), B.onLoad(), B.onShow()</td></tr><tr><td>D</td><td>B</td><td>D.onUnload(), C.onUnload(), B.onLoad(), B.onShow()</td></tr><tr><td>D（从转发进入）</td><td>A</td><td>D.onUnload(), A.onLoad(), A.onShow()</td></tr><tr><td>D（从转发进入）</td><td>B</td><td>D.onUnload(), B.onLoad(), B.onShow()</td></tr></tbody></table> 
<h4>注意事项</h4> 
<ul><li> <p><code>navigateTo</code>, <code>redirectTo</code> 只能打开非 tabBar 页面。</p> 
  <ul><li> <p>a--navigateTo--c, c--&gt;redirectTo--&gt;d</p> </li></ul></li><li> <p><code>switchTab</code> 只能打开 tabBar 页面。</p> </li><li> <p><code>reLaunch</code> 可以打开任意页面。</p> </li><li> <p>页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。</p> </li><li> <p>调用页面路由带的参数可以在目标页面的<code>onLoad</code>中获取。</p> </li></ul> 
<h4>模块化</h4> 
<h4>模块化</h4> 
<p>可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/module.html" rel="nofollow" title="module.exports">module.exports</a> 或者 <code>exports</code> 才能对外暴露接口。</p> 
<p>注意：</p> 
<ul><li> <p><code>exports</code> 是 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/module.html" rel="nofollow" title="module.exports">module.exports</a> 的一个引用，因此在模块里边随意更改 <code>exports</code> 的指向会造成未知的错误。所以更推荐开发者采用 <code>module.exports</code> 来暴露模块接口，除非你已经清晰知道这两者的关系。</p> </li><li> <p>小程序目前不支持直接引入 <code>node_modules</code> , 开发者需要使用到 <code>node_modules</code> 时候建议拷贝出相关的代码到小程序的目录中，或者使用小程序支持的 <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/npm.html" rel="nofollow" title="npm">npm</a> 功能。</p> </li></ul> 
<pre><code class="hljs">// common.js
function sayHello(name) {
  console.log(`Hello ${name} !`)
}
function sayGoodbye(name) {
  console.log(`Goodbye ${name} !`)
}
​
module.exports.sayHello = sayHello
exports.sayGoodbye = sayGoodbye
在需要使用这些模块的文件中，使用 require 将公共代码引入;也可以使用import导入

var common = require('common.js')
Page({
  helloMINA: function() {
    common.sayHello('MINA')
  },
  goodbyeMINA: function() {
    common.sayGoodbye('MINA')
  }
})</code></pre> 
<h4>文件作用域</h4> 
<p>在 JavaScript 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。</p> 
<p>通过全局函数 <code>getApp</code> 可以获取全局的应用实例，如果需要全局的数据可以在 <code>App()</code> 中设置，如：</p> 
<pre><code class="hljs">// app.js
App({
  globalData: 1
})
// a.js
// The localValue can only be used in file a.js.
var localValue = 'a'
// Get the app instance.
var app = getApp()
// Get the global data and change it.
app.globalData++
// b.js
// You can redefine localValue in file b.js, without interference with the localValue in a.js.
var localValue = 'b'
// If a.js it run before b.js, now the globalData shoule be 2.
console.log(getApp().globalData)</code></pre> 
<h3>API</h3> 
<p>小程序开发框架提供丰富的微信原生 API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。详细介绍请参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/index.html" rel="nofollow" title="API 文档">API 文档</a>。</p> 
<p>通常，在小程序 API 有以下几种类型：</p> 
<h4>事件监听 API</h4> 
<p>我们约定，以 <code>on</code> 开头的 API 用来监听某个事件是否触发，如：<a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/websocket/wx.onSocketOpen.html" rel="nofollow" title="wx.onSocketOpen">wx.onSocketOpen</a>，<a href="https://developers.weixin.qq.com/miniprogram/dev/api/device/compass/wx.onCompassChange.html" rel="nofollow" title="wx.onCompassChange">wx.onCompassChange</a> 等。</p> 
<p>这类 API 接受一个回调函数作为参数，当事件触发时会调用这个回调函数，并将相关数据以参数形式传入。</p> 
<p><strong>代码示例</strong></p> 
<pre><code class="hljs">wx.onCompassChange(function (res) {
  console.log(res.direction)
})</code></pre> 
<h4>同步 API</h4> 
<p>我们约定，以 <code>Sync</code> 结尾的 API 都是同步 API， 如 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.setStorageSync.html" rel="nofollow" title="wx.setStorageSync">wx.setStorageSync</a>，<a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/system/wx.getSystemInfoSync.html" rel="nofollow" title="wx.getSystemInfoSync">wx.getSystemInfoSync</a> 等。此外，也有一些其他的同步 API，如 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/worker/wx.createWorker.html" rel="nofollow" title="wx.createWorker">wx.createWorker</a>，<a href="https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.getBackgroundAudioManager.html" rel="nofollow" title="wx.getBackgroundAudioManager">wx.getBackgroundAudioManager</a> 等，详情参见 API 文档中的说明。</p> 
<p>同步 API 的执行结果可以通过函数返回值直接获取，如果执行出错会抛出异常。</p> 
<p><strong>代码示例</strong></p> 
<pre><code class="hljs">try {
  wx.setStorageSync('key', 'value')
} catch (e) {
  console.error(e)
}</code></pre> 
<h4>异步 API</h4> 
<p>大多数 API 都是异步 API，如 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html" rel="nofollow" title="wx.request">wx.request</a>，<a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html" rel="nofollow" title="wx.login">wx.login</a> 等。这类 API 接口通常都接受一个 <code>Object</code> 类型的参数，这个参数都支持按需指定以下字段来接收接口调用结果：</p> 
<p><strong>Object 参数说明</strong></p> 
<table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>说明</th></tr></thead><tbody><tr><td>success</td><td>function</td><td>否</td><td>接口调用成功的回调函数</td></tr><tr><td>fail</td><td>function</td><td>否</td><td>接口调用失败的回调函数</td></tr><tr><td>complete</td><td>function</td><td>否</td><td>接口调用结束的回调函数（调用成功、失败都会执行）</td></tr><tr><td>其他</td><td>Any</td><td>-</td><td>接口定义的其他参数</td></tr></tbody></table> 
<p><strong>回调函数的参数</strong></p> 
<p><code>success</code>，<code>fail</code>，<code>complete</code> 函数调用时会传入一个 <code>Object</code> 类型参数，包含以下字段：</p> 
<table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>errMsg</td><td>string</td><td>错误信息，如果调用成功返回 <code>${apiName}:ok</code></td></tr><tr><td>errCode</td><td>number</td><td>错误码，仅部分 API 支持，具体含义请参考对应 API 文档，成功时为 <code>0</code>。</td></tr><tr><td>其他</td><td>Any</td><td>接口返回的其他数据</td></tr></tbody></table> 
<p>异步 API 的执行结果需要通过 <code>Object</code> 类型的参数中传入的对应回调函数获取。部分异步 API 也会有返回值，可以用来实现更丰富的功能，如 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html" rel="nofollow" title="wx.request">wx.request</a>，<a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/websocket/wx.connectSocket.html" rel="nofollow" title="wx.connectSocket">wx.connectSocket</a> 等。</p> 
<p><strong>代码示例</strong></p> 
<pre><code class="hljs">wx.login({
  success(res) {
    console.log(res.code)
  }
})</code></pre> 
<h4>异步 API 返回 Promise</h4> 
<p>基础库 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" rel="nofollow" title="2.10.2">2.10.2</a> 版本起，异步 API 支持 callback &amp; promise 两种调用方式。当接口参数 Object 对象中不包含 success/fail/complete 时将默认返回 promise，否则仍按回调方式执行，无返回值。</p> 
<p>注意事项</p> 
<ol><li> <p>部分接口如 <code>downloadFile</code>, <code>request</code>, <code>uploadFile</code>, <code>connectSocket</code>, <code>createCamera</code>（小游戏）本身就有返回值， 它们的 promisify 需要开发者自行封装。</p> </li><li> <p>当没有回调参数时，异步接口返回 promise。此时若函数调用失败进入 fail 逻辑， 会报错提示 <code>Uncaught (in promise)</code>，开发者可通过 catch 来进行捕获。</p> </li><li> <p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onUnhandledRejection.html" rel="nofollow" title="wx.onUnhandledRejection">wx.onUnhandledRejection</a> 可以监听未处理的 Promise 拒绝事件。</p> </li></ol> 
<p><strong>代码示例</strong></p> 
<pre><code class="hljs">// callback 形式调用
wx.chooseImage({
  success(res) {
    console.log('res:', res)
  }
})
​
// promise 形式调用
wx.chooseImage().then(res =&gt; console.log('res: ', res))</code></pre> 
<h2>视图层 View</h2> 
<p>框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示。</p> 
<p>将逻辑层的数据反映成视图，同时将视图层的事件发送给逻辑层。</p> 
<p>WXML(WeiXin Markup language) 用于描述页面的结构。</p> 
<p>WXS(WeiXin Script) 是小程序的一套脚本语言，结合 <code>WXML</code>，可以构建出页面的结构。</p> 
<p>WXSS(WeiXin Style Sheet) 用于描述页面的样式。</p> 
<p>组件(Component)是视图的基本组成单元。</p> 
<h3>WXML</h3> 
<p>WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合<a href="https://developers.weixin.qq.com/miniprogram/dev/component/" rel="nofollow" title="基础组件">基础组件</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html" rel="nofollow" title="事件系统">事件系统</a>，可以构建出页面的结构。</p> 
<p>要完整了解 WXML 语法，请参考<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/" rel="nofollow" title="WXML 语法参考">WXML 语法参考</a>。</p> 
<p>用以下一些简单的例子来看看 WXML 具有什么能力：</p> 
<h4>数据绑定</h4> 
<pre><code class="hljs">&lt;!--wxml--&gt;
&lt;view&gt; {<!-- -->{message}} &lt;/view&gt;
// page.js
Page({
  data: {
    message: 'Hello MINA!'
  }
})</code></pre> 
<h4>列表渲染</h4> 
<pre><code class="hljs">&lt;!--wxml--&gt;
&lt;view wx:for="{<!-- -->{array}}"&gt; {<!-- -->{item}} &lt;/view&gt;
// page.js
Page({
  data: {
    array: [1, 2, 3, 4, 5]
  }
})</code></pre> 
<h4>条件渲染</h4> 
<pre><code class="hljs">&lt;!--wxml--&gt;
&lt;view wx:if="{<!-- -->{view == 'WEBVIEW'}}"&gt; WEBVIEW &lt;/view&gt;
&lt;view wx:elif="{<!-- -->{view == 'APP'}}"&gt; APP &lt;/view&gt;
&lt;view wx:else="{<!-- -->{view == 'MINA'}}"&gt; MINA &lt;/view&gt;
// page.js
Page({
  data: {
    view: 'MINA'
  }
})</code></pre> 
<h4>模板</h4> 
<pre><code class="hljs">&lt;!--wxml--&gt;
&lt;template name="staffName"&gt;
  &lt;view&gt;
    FirstName: {<!-- -->{firstName}}, LastName: {<!-- -->{lastName}}
  &lt;/view&gt;
&lt;/template&gt;
​
&lt;template is="staffName" data="{<!-- -->{...staffA}}"&gt;&lt;/template&gt;
&lt;template is="staffName" data="{<!-- -->{...staffB}}"&gt;&lt;/template&gt;
&lt;template is="staffName" data="{<!-- -->{...staffC}}"&gt;&lt;/template&gt;
// page.js
Page({
  data: {
    staffA: {firstName: 'Hulk', lastName: 'Hu'},
    staffB: {firstName: 'Shang', lastName: 'You'},
    staffC: {firstName: 'Gideon', lastName: 'Lin'}
  }
})</code></pre> 
<p>具体的能力以及使用方式在以下章节查看：</p> 
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/data.html" rel="nofollow" title="数据绑定">数据绑定</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/list.html" rel="nofollow" title="列表渲染">列表渲染</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/conditional.html" rel="nofollow" title="条件渲染">条件渲染</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/template.html" rel="nofollow" title="模板">模板</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/import.html" rel="nofollow" title="引用">引用</a></p> 
<h3>WXSS</h3> 
<p>WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。</p> 
<p>WXSS 用来决定 WXML 的组件应该怎么显示。</p> 
<p>为了适应广大的前端开发者，WXSS 具有 CSS 大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。</p> 
<p>与 CSS 相比，WXSS 扩展的特性有：</p> 
<ul><li> <p>尺寸单位</p> </li><li> <p>样式导入</p> </li></ul> 
<h4>尺寸单位</h4> 
<ul><li> <p>rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</p> </li></ul> 
<table><thead><tr><th>设备</th><th>rpx换算px (屏幕宽度/750)</th><th>px换算rpx (750/屏幕宽度)</th></tr></thead><tbody><tr><td>iPhone5</td><td>1rpx = 0.42px</td><td>1px = 2.34rpx</td></tr><tr><td>iPhone6</td><td>1rpx = 0.5px</td><td>1px = 2rpx</td></tr><tr><td>iPhone6 Plus</td><td>1rpx = 0.552px</td><td>1px = 1.81rpx</td></tr></tbody></table> 
<p><strong>建议：</strong> 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。</p> 
<p><strong>注意：</strong> 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。</p> 
<h4>样式导入</h4> 
<p>使用<code>@import</code>语句可以导入外联样式表，<code>@import</code>后跟需要导入的外联样式表的相对路径，用<code>;</code>表示语句结束。</p> 
<p><strong>示例代码：</strong></p> 
<pre><code class="hljs">/** common.wxss **/
.small-p {
  padding:5px;
}
/** app.wxss **/
@import "common.wxss";
.middle-p {
  padding:15px;
}</code></pre> 
<h4>内联样式</h4> 
<p>框架组件上支持使用 style、class 属性来控制组件的样式。</p> 
<ul><li> <p>style：静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度。</p> </li></ul> 
<pre><code class="hljs">&lt;view style="color:{<!-- -->{color}};" /&gt;</code></pre> 
<ul><li> <p>class：用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上<code>.</code>，样式类名之间用空格分隔。</p> </li></ul> 
<pre><code class="hljs">&lt;view class="normal_view" /&gt;</code></pre> 
<h4>选择器</h4> 
<p>目前支持的选择器有：</p> 
<table><thead><tr><th>选择器</th><th>样例</th><th>样例描述</th></tr></thead><tbody><tr><td>.class</td><td><code>.intro</code></td><td>选择所有拥有 class="intro" 的组件</td></tr><tr><td>#id</td><td><code>#firstname</code></td><td>选择拥有 id="firstname" 的组件</td></tr><tr><td>element</td><td><code>view</code></td><td>选择所有 view 组件</td></tr><tr><td>element, element</td><td><code>view, checkbox</code></td><td>选择所有文档的 view 组件和所有的 checkbox 组件</td></tr><tr><td>::after</td><td><code>view::after</code></td><td>在 view 组件后边插入内容</td></tr><tr><td>::before</td><td><code>view::before</code></td><td>在 view 组件前边插入内容</td></tr></tbody></table> 
<h4>全局样式与局部样式</h4> 
<p>定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。</p> 
<h3>WXS</h3> 
<p>WXS（WeiXin Script）是小程序的一套脚本语言，结合 <code>WXML</code>，可以构建出页面的结构。</p> 
<h4>示例</h4> 
<ul><li> <p>新建一个wxs文件</p> </li></ul> 
<pre><code class="hljs">var toDecimal2 = function (x) {
    var f = parseFloat(x);
    if (isNaN(f)) {
      return '0.00'
    }
    var f = Math.round(x * 100) / 100;
    var s = f.toString();
    var rs = s.indexOf('.');
    if (rs &lt; 0) {
      rs = s.length;
      s += '.';
    }
    while (s.length &lt;= rs + 2) {
      s += '0';
    }
    return s;
  }
  //module.exports = toDecimal2
module.exports = {
    toDecimal2:toDecimal2
}</code></pre> 
<pre>  </pre> 
<ul><li> <p>在wxml中使用</p> </li></ul> 
<pre><code class="hljs">&lt;!--pages/c/c.wxml--&gt;
&lt;wxs src="../../wxs/PageUtils.wxs" module="PageUtils"&gt;&lt;/wxs&gt;
&lt;wxs module="m1"&gt;
var msg = "hello world";
​
module.exports.message = msg;
&lt;/wxs&gt;
&lt;view&gt;
    &lt;text&gt;pages/c/c.wxml,&lt;/text&gt;
    &lt;text&gt;{<!-- -->{m1.message}}&lt;/text&gt;
    &lt;view&gt;
        &lt;text&gt;{<!-- -->{PageUtils.toDecimal2(123.453)}}&lt;/text&gt;
    &lt;/view&gt;
    &lt;view&gt;
        &lt;button type="primary" bindtap="jump"&gt;跳转到D页面&lt;/button&gt;
    &lt;/view&gt;
&lt;/view&gt;</code></pre> 
<h4>注意事项</h4> 
<ol><li> <p>WXS 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。</p> </li><li> <p>WXS 与 JavaScript 是不同的语言，有自己的语法，并不和 JavaScript 一致。</p> </li><li> <p>WXS 的运行环境和其他 JavaScript 代码是隔离的，WXS 中不能调用其他 JavaScript 文件中定义的函数，也不能调用小程序提供的API。</p> </li><li> <p>WXS 函数不能作为组件的事件回调。</p> </li><li> <p>由于运行环境的差异，在 iOS 设备上小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。</p> </li></ol> 
<p>以下是一些使用 WXS 的简单示例，要完整了解 WXS 语法，请参考<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/" rel="nofollow" title="WXS 语法参考">WXS 语法参考</a>。</p> 
<h4>页面渲染</h4> 
<pre><code class="hljs">&lt;!--wxml--&gt;
&lt;wxs module="m1"&gt;
var msg = "hello world";
​
module.exports.message = msg;
&lt;/wxs&gt;
​
&lt;view&gt; {<!-- -->{m1.message}} &lt;/view&gt;</code></pre> 
<p>页面输出：</p> 
<pre>hello world</pre> 
<h4>数据处理</h4> 
<pre><code class="hljs">// page.js
Page({
  data: {
    array: [1, 2, 3, 4, 5, 1, 2, 3, 4]
  }
})
&lt;!--wxml--&gt;
&lt;!-- 下面的 getMax 函数，接受一个数组，且返回数组中最大的元素的值 --&gt;
&lt;wxs module="m1"&gt;
var getMax = function(array) {
  var max = undefined;
  for (var i = 0; i &lt; array.length; ++i) {
    max = max === undefined ?
      array[i] :
      (max &gt;= array[i] ? max : array[i]);
  }
  return max;
}
​
module.exports.getMax = getMax;
&lt;/wxs&gt;
​
&lt;!-- 调用 wxs 里面的 getMax 函数，参数为 page.js 里面的 array --&gt;
&lt;view&gt; {<!-- -->{m1.getMax(array)}} &lt;/view&gt;</code></pre> 
<pre></pre> 
<p>页面输出：</p> 
<pre>5</pre> 
<h2>事件</h2> 
<h3>什么是事件</h3> 
<ul><li> <p>事件是视图层到逻辑层的通讯方式。</p> </li><li> <p>事件可以将用户的行为反馈到逻辑层进行处理。</p> </li><li> <p>事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。</p> </li><li> <p>事件对象可以携带额外信息，如 id, dataset, touches。</p> </li></ul> 
<h3>事件的使用方式</h3> 
<ul><li> <pre><code class="hljs">Page({
  tapName: function(event) {
    console.log(event)
  }
})</code></pre> <p>在组件中绑定一个事件处理函数。</p> </li></ul> 
<p>如<code>bindtap</code>，当用户点击该组件的时候会在该页面对应的 Page 中找到相应的事件处理函数。</p> 
<pre><code class="hljs">&lt;view id="tapTest" data-hi="Weixin" bindtap="tapName"&gt; Click me! &lt;/view&gt;</code></pre> 
<ul><li> <p>在相应的 Page 定义中写上相应的事件处理函数，参数是event。</p> <pre><code class="hljs">Page({
  tapName: function(event) {
    console.log(event)
  }
})</code></pre> <p></p> </li><li> <p>可以看到 log 出来的信息大致如下：</p> </li></ul> 
<pre><code class="hljs">{
  "type":"tap",
  "timeStamp":895,
  "target": {
    "id": "tapTest",
    "dataset":  {
      "hi":"Weixin"
    }
  },
  "currentTarget":  {
    "id": "tapTest",
    "dataset": {
      "hi":"Weixin"
    }
  },
  "detail": {
    "x":53,
    "y":14
  },
  "touches":[{
    "identifier":0,
    "pageX":53,
    "pageY":14,
    "clientX":53,
    "clientY":14
  }],
  "changedTouches":[{
    "identifier":0,
    "pageX":53,
    "pageY":14,
    "clientX":53,
    "clientY":14
  }]
}</code></pre> 
<h3>使用 WXS 函数响应事件</h3> 
<blockquote> 
 <p>基础库 2.4.4 开始支持，低版本需做<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" rel="nofollow" title="兼容处理">兼容处理</a>。</p> 
</blockquote> 
<p>从基础库版本<code>2.4.4</code>开始，支持使用 WXS 函数绑定事件，WXS函数接受2个参数，第一个是event，在原有的 event 的基础上加了<code>event.instance</code>对象，第二个参数是<code>ownerInstance</code>，和<code>event.instance</code>一样是一个<code>ComponentDescriptor</code>对象。具体使用如下：</p> 
<ul><li> <p>在组件中绑定和注册事件处理的 WXS 函数。</p> </li></ul> 
<pre><code class="hljs">&lt;wxs module="wxs" src="./test.wxs"&gt;&lt;/wxs&gt;
&lt;view id="tapTest" data-hi="Weixin" bindtap="{<!-- -->{wxs.tapName}}"&gt; Click me! &lt;/view&gt;
**注：绑定的 WXS 函数必须用{<!-- -->{}}括起来**
test.wxs文件实现 tapName 函数

function tapName(event, ownerInstance) {
  console.log('tap Weixin', JSON.stringify(event))
}
module.exports = {
  tapName: tapName
}</code></pre> 
<p><code>ownerInstance</code>包含了一些方法，可以设置组件的样式和class，具体包含的方法以及为什么要用 WXS 函数响应事件，请<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/interactive-animation.html" rel="nofollow" title="点击查看详情">点击查看详情</a>。</p> 
<h3>事件详解</h3> 
<h4>事件分类</h4> 
<p>事件分为冒泡事件和非冒泡事件：</p> 
<ol><li> <p>冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。</p> </li><li> <p>非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。</p> </li></ol> 
<p>WXML的冒泡事件列表：</p> 
<table><thead><tr><th>类型</th><th>触发条件</th><th>最低版本</th></tr></thead><tbody><tr><td>touchstart</td><td>手指触摸动作开始</td><td></td></tr><tr><td>touchmove</td><td>手指触摸后移动</td><td></td></tr><tr><td>touchcancel</td><td>手指触摸动作被打断，如来电提醒，弹窗</td><td></td></tr><tr><td>touchend</td><td>手指触摸动作结束</td><td></td></tr><tr><td>tap</td><td>手指触摸后马上离开</td><td></td></tr><tr><td>longpress</td><td>手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发</td><td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" rel="nofollow" title="1.5.0">1.5.0</a></td></tr><tr><td>longtap</td><td>手指触摸后，超过350ms再离开（推荐使用 longpress 事件代替）</td><td></td></tr><tr><td>transitionend</td><td>会在 WXSS transition 或 wx.createAnimation 动画结束后触发</td><td></td></tr><tr><td>animationstart</td><td>会在一个 WXSS animation 动画开始时触发</td><td></td></tr><tr><td>animationiteration</td><td>会在一个 WXSS animation 一次迭代结束时触发</td><td></td></tr><tr><td>animationend</td><td>会在一个 WXSS animation 动画完成时触发</td><td></td></tr><tr><td>touchforcechange</td><td>在支持 3D Touch 的 iPhone 设备，重按时会触发</td><td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" rel="nofollow" title="1.9.90">1.9.90</a></td></tr></tbody></table> 
<p><strong>注：除上表之外的其他组件自定义事件如无特殊声明都是非冒泡事件，如 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/form.html" rel="nofollow" title="form">form</a> 的<code>submit</code>事件，<a href="https://developers.weixin.qq.com/miniprogram/dev/component/input.html" rel="nofollow" title="input">input</a> 的<code>input</code>事件，<a href="https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html" rel="nofollow" title="scroll-view">scroll-view</a> 的<code>scroll</code>事件，(详见各个<a href="https://developers.weixin.qq.com/miniprogram/dev/component/" rel="nofollow" title="组件">组件</a>)</strong></p> 
<h4>普通事件绑定</h4> 
<p>事件绑定的写法类似于组件的属性，如：</p> 
<pre>&lt;view bindtap="handleTap"&gt;
    Click here!
&lt;/view&gt;</pre> 
<p>如果用户点击这个 view ，则页面的 <code>handleTap</code> 会被调用。</p> 
<p>事件绑定函数可以是一个数据绑定，如：</p> 
<pre>&lt;view bindtap="{<!-- -->{ handlerName }}"&gt;
    Click here!
&lt;/view&gt;</pre> 
<p>此时，页面的 <code>this.data.handlerName</code> 必须是一个字符串，指定事件处理函数名；如果它是个空字符串，则这个绑定会失效（可以利用这个特性来暂时禁用一些事件）。</p> 
<p>自基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" rel="nofollow" title="1.5.0">1.5.0</a> 起，在大多数组件和自定义组件中， <code>bind</code> 后可以紧跟一个冒号，其含义不变，如 <code>bind:tap</code> 。基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" rel="nofollow" title="2.8.1">2.8.1</a> 起，在所有组件中开始提供这个支持。</p> 
<h4>绑定并阻止事件冒泡</h4> 
<p>除 <code>bind</code> 外，也可以用 <code>catch</code> 来绑定事件。与 <code>bind</code> 不同， <code>catch</code> 会阻止事件向上冒泡。</p> 
<p>例如在下边这个例子中，点击 inner view 会先后调用<code>handleTap3</code>和<code>handleTap2</code>(因为 tap 事件会冒泡到 middle view，而 middle view 阻止了 tap 事件冒泡，不再向父节点传递)，点击 middle view 会触发<code>handleTap2</code>，点击 outer view 会触发<code>handleTap1</code>。</p> 
<pre>&lt;view id="outer" bindtap="handleTap1"&gt;
  outer view
  &lt;view id="middle" catchtap="handleTap2"&gt;
    middle view
    &lt;view id="inner" bindtap="handleTap3"&gt;
      inner view
    &lt;/view&gt;
  &lt;/view&gt;
&lt;/view&gt;</pre> 
<h4>互斥事件绑定</h4> 
<p>自基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" rel="nofollow" title="2.8.2">2.8.2</a> 起，除 <code>bind</code> 和 <code>catch</code> 外，还可以使用 <code>mut-bind</code> 来绑定事件。一个 <code>mut-bind</code> 触发后，如果事件冒泡到其他节点上，其他节点上的 <code>mut-bind</code> 绑定函数不会被触发，但 <code>bind</code> 绑定函数和 <code>catch</code> 绑定函数依旧会被触发。</p> 
<p>换而言之，所有 <code>mut-bind</code> 是“互斥”的，只会有其中一个绑定函数被触发。同时，它完全不影响 <code>bind</code> 和 <code>catch</code> 的绑定效果。</p> 
<p>例如在下边这个例子中，点击 inner view 会先后调用 <code>handleTap3</code> 和 <code>handleTap2</code> ，点击 middle view 会调用 <code>handleTap2</code> 和 <code>handleTap1</code> 。</p> 
<pre><code class="hljs">&lt;view id="outer" mut-bind:tap="handleTap1"&gt;
  outer view
  &lt;view id="middle" bindtap="handleTap2"&gt;
    middle view
    &lt;view id="inner" mut-bind:tap="handleTap3"&gt;
      inner view
    &lt;/view&gt;
  &lt;/view&gt;
&lt;/view&gt;</code></pre> 
<h4>事件的捕获阶段</h4> 
<p>自基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" rel="nofollow" title="1.5.0">1.5.0</a> 起，触摸类事件支持捕获阶段。捕获阶段位于冒泡阶段之前，且在捕获阶段中，事件到达节点的顺序与冒泡阶段恰好相反。需要在捕获阶段监听事件时，可以采用<code>capture-bind</code>、<code>capture-catch</code>关键字，后者将中断捕获阶段和取消冒泡阶段。</p> 
<p>在下面的代码中，点击 inner view 会先后调用<code>handleTap2</code>、<code>handleTap4</code>、<code>handleTap3</code>、<code>handleTap1</code>。</p> 
<pre><code class="hljs">&lt;view id="outer" bind:touchstart="handleTap1" capture-bind:touchstart="handleTap2"&gt;
  outer view
  &lt;view id="inner" bind:touchstart="handleTap3" capture-bind:touchstart="handleTap4"&gt;
    inner view
  &lt;/view&gt;
&lt;/view&gt;</code></pre> 
<p>如果将上面代码中的第一个<code>capture-bind</code>改为<code>capture-catch</code>，将只触发<code>handleTap2</code>。</p> 
<pre><code class="hljs">&lt;view id="outer" bind:touchstart="handleTap1" capture-catch:touchstart="handleTap2"&gt;
  outer view
  &lt;view id="inner" bind:touchstart="handleTap3" capture-bind:touchstart="handleTap4"&gt;
    inner view
  &lt;/view&gt;
&lt;/view&gt;</code></pre> 
<h4>事件对象</h4> 
<p>如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。</p> 
<p><strong>BaseEvent 基础事件对象属性列表：</strong></p> 
<table><thead><tr><th>属性</th><th>类型</th><th>说明</th><th>基础库版本</th></tr></thead><tbody><tr><td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#type" rel="nofollow" title="type">type</a></td><td>String</td><td>事件类型</td><td></td></tr><tr><td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#timeStamp" rel="nofollow" title="timeStamp">timeStamp</a></td><td>Integer</td><td>事件生成时的时间戳</td><td></td></tr><tr><td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#target" rel="nofollow" title="target">target</a></td><td>Object</td><td>触发事件的组件的一些属性值集合</td><td></td></tr><tr><td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#currenttarget" rel="nofollow" title="currentTarget">currentTarget</a></td><td>Object</td><td>当前组件的一些属性值集合</td><td></td></tr><tr><td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#mark" rel="nofollow" title="mark">mark</a></td><td>Object</td><td>事件标记数据</td><td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" rel="nofollow" title="2.7.1">2.7.1</a></td></tr></tbody></table> 
<p><strong>CustomEvent 自定义事件对象属性列表（继承 BaseEvent）：</strong></p> 
<table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#detail" rel="nofollow" title="detail">detail</a></td><td>Object</td><td>额外的信息</td></tr></tbody></table> 
<p><strong>TouchEvent 触摸事件对象属性列表（继承 BaseEvent）：</strong></p> 
<table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#touches" rel="nofollow" title="touches">touches</a></td><td>Array</td><td>触摸事件，当前停留在屏幕中的触摸点信息的数组</td></tr><tr><td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#changedTouches" rel="nofollow" title="changedTouches">changedTouches</a></td><td>Array</td><td>触摸事件，当前变化的触摸点信息的数组</td></tr></tbody></table> 
<p><strong>特殊事件： <a href="https://developers.weixin.qq.com/miniprogram/dev/component/canvas.html" rel="nofollow" title="canvas">canvas</a> 中的触摸事件不可冒泡，所以没有 currentTarget。</strong></p> 
<h4>type</h4> 
<p>代表事件的类型。</p> 
<h4>timeStamp</h4> 
<p>页面打开到触发事件所经过的毫秒数。</p> 
<h4>target</h4> 
<p>触发事件的源组件。</p> 
<table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>String</td><td>事件源组件的id</td></tr><tr><td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#dataset" rel="nofollow" title="dataset">dataset</a></td><td>Object</td><td>事件源组件上由<code>data-</code>开头的自定义属性组成的集合</td></tr></tbody></table> 
<h4>currentTarget</h4> 
<p>事件绑定的当前组件。</p> 
<table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>String</td><td>当前组件的id</td></tr><tr><td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#dataset" rel="nofollow" title="dataset">dataset</a></td><td>Object</td><td>当前组件上由<code>data-</code>开头的自定义属性组成的集合</td></tr></tbody></table> 
<p><strong>说明： target 和 currentTarget 可以参考上例中，点击 inner view 时，<code>handleTap3</code> 收到的事件对象 target 和 currentTarget 都是 inner，而 <code>handleTap2</code> 收到的事件对象 target 就是 inner，currentTarget 就是 middle。</strong></p> 
<h4>dataset</h4> 
<p>在组件节点中可以附加一些自定义数据。这样，在事件中可以获取这些自定义的节点数据，用于事件的逻辑处理。</p> 
<p>在 WXML 中，这些自定义数据以 <code>data-</code> 开头，多个单词由连字符 <code>-</code> 连接。这种写法中，连字符写法会转换成驼峰写法，而大写字符会自动转成小写字符。如：</p> 
<ul><li> <p><code>data-element-type</code> ，最终会呈现为 <code>event.currentTarget.dataset.elementType</code> ；</p> </li><li> <p><code>data-elementType</code> ，最终会呈现为 <code>event.currentTarget.dataset.elementtype</code> 。</p> </li></ul> 
<p><strong>示例：</strong></p> 
<pre><code class="hljs">&lt;view data-alpha-beta="1" data-alphaBeta="2" bindtap="bindViewTap"&gt; DataSet Test &lt;/view&gt;
Page({
  bindViewTap:function(event){
    event.currentTarget.dataset.alphaBeta === 1 // - 会转为驼峰写法
    event.currentTarget.dataset.alphabeta === 2 // 大写会转为小写
  }
})</code></pre> 
<h4>mark</h4> 
<p>在基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" rel="nofollow" title="2.7.1">2.7.1</a> 以上，可以使用 <code>mark</code> 来识别具体触发事件的 target 节点。此外， <code>mark</code> 还可以用于承载一些自定义数据（类似于 <code>dataset</code> ）。</p> 
<p>当事件触发时，事件冒泡路径上所有的 <code>mark</code> 会被合并，并返回给事件回调函数。（即使事件不是冒泡事件，也会 <code>mark</code> 。）</p> 
<p><strong>代码示例：</strong></p> 
<p><a href="https://developers.weixin.qq.com/s/7LwTKvmi7woT" rel="nofollow" title="在开发者工具中预览效果">在开发者工具中预览效果</a></p> 
<pre><code class="hljs">&lt;view mark:myMark="last" bindtap="bindViewTap"&gt;
  &lt;button mark:anotherMark="leaf" bindtap="bindButtonTap"&gt;按钮&lt;/button&gt;
&lt;/view&gt;</code></pre> 
<p>在上述 WXML 中，如果按钮被点击，将触发 <code>bindViewTap</code> 和 <code>bindButtonTap</code> 两个事件，事件携带的 <code>event.mark</code> 将包含 <code>myMark</code> 和 <code>anotherMark</code> 两项。</p> 
<pre><code class="hljs">Page({
  bindViewTap: function(e) {
    e.mark.myMark === "last" // true
    e.mark.anotherMark === "leaf" // true
  }
})</code></pre> 
<p><code>mark</code> 和 <code>dataset</code> 很相似，主要区别在于： <code>mark</code> 会包含从触发事件的节点到根节点上所有的 <code>mark:</code> 属性值；而 <code>dataset</code> 仅包含一个节点的 <code>data-</code> 属性值。</p> 
<p>细节注意事项：</p> 
<ul><li> <p>如果存在同名的 <code>mark</code> ，父节点的 <code>mark</code> 会被子节点覆盖。</p> </li><li> <p>在自定义组件中接收事件时， <code>mark</code> 不包含自定义组件外的节点的 <code>mark</code> 。</p> </li><li> <p>不同于 <code>dataset</code> ，节点的 <code>mark</code> 不会做连字符和大小写转换。</p> </li></ul> 
<h4>touches</h4> 
<p>touches 是一个数组，每个元素为一个 Touch 对象（canvas 触摸事件中携带的 touches 是 CanvasTouch 数组）。 表示当前停留在屏幕上的触摸点。</p> 
<p>Touch 对象</p> 
<table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>identifier</td><td>Number</td><td>触摸点的标识符</td></tr><tr><td>pageX, pageY</td><td>Number</td><td>距离文档左上角的距离，文档的左上角为原点 ，横向为 X 轴，纵向为 Y 轴</td></tr><tr><td>clientX, clientY</td><td>Number</td><td>距离页面可显示区域（屏幕除去导航条）左上角距离，横向为 X 轴，纵向为 Y 轴</td></tr></tbody></table> 
<p>CanvasTouch 对象</p> 
<table><thead><tr><th>属性</th><th>类型</th><th>说明</th><th>特殊说明</th></tr></thead><tbody><tr><td>identifier</td><td>Number</td><td>触摸点的标识符</td><td></td></tr><tr><td>x, y</td><td>Number</td><td>距离 Canvas 左上角的距离，Canvas 的左上角为原点 ，横向为 X 轴，纵向为 Y 轴</td><td></td></tr></tbody></table> 
<h4>changedTouches</h4> 
<p>changedTouches 数据格式同 touches。 表示有变化的触摸点，如从无变有（touchstart），位置变化（touchmove），从有变无（touchend、touchcancel）。</p> 
<h4>detail</h4> 
<p>自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息，详见<a href="https://developers.weixin.qq.com/miniprogram/dev/component" rel="nofollow" title="组件">组件</a>定义中各个事件的定义。</p> 
<p>点击事件的<code>detail</code> 带有的 x, y 同 pageX, pageY 代表距离文档左上角的距离。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c8df595e66686e0bccbfb0deeb747609/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RabbitMQ延迟列队的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7e763c1a67735a77f9c6c5786a57e19b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">毕业设计-基于机器车辆行人闯红灯检测系统 -YOLO</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>