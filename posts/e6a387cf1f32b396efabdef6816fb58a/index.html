<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>理解flannel的三种容器网络方案原理 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="理解flannel的三种容器网络方案原理" />
<meta property="og:description" content="0. 前言 本文主要介绍flannel在k8s网络中作为网络插件通过UDP、VXLAN、HOST-GATEWAY三种模式来解决容器跨主机网络通信的，并通过手动实现这三种模式深入理解其原理。
1. flannel全局网络地址分配机制 每台节点上容器的IP地址是由所属节点自动分配的，那么会存在一个问题是，不同节点上的容器所分配的IP地址则可能会有重复的情况。
flannel设计了一种全局的网络地址分配机制，flannel会为每台节点申请一个独一无二的网段，并存储在etcd中，flannel会将该网段配置到各个节点上的Docker(或者其他容器工具)，当前节点上的容器
只从分配的网段里中获取IP地址。
修改docker启动参数–bip来限制节点容器获得的IP范围。
2. UDP模式 2.1 简介 在Flannel的UDP模式中，每个节点都会启动一个UDP服务器，用于监听来自其他节点的数据包。当一个容器向另一个容器发送数据包时，它会将数据包发送到目标容器的IP地址和端口号。Flannel会将该数据包封装在一个UDP数据包中，并将其发送到目标节点的UDP服务器。目标节点的UDP服务器会解析该数据包，并将其传递给目标容器。
2.2 flannel实现UDP流程 flanneld启动后会通过打开/dev/net/tun的方式创建tun设备，名称为flannel0，该设备是用户空间与内核空间的数据包交互的通道。然后再将从tun设备获取的IP数据包封装到UDP数据包中通过物理网卡发送到其他节点中，内核通过UDP端口转发给flanneld然后解包，得到其中的IP数据包，然后再通过tun设备进入内核空间中，通过路由到达网桥，然后再到目的容器中。
flanneld在其中主要做了：
开启了udp服务，并对udp数据包封包和解包节点上路由表的动态更新，也就是从网桥出来的数据包目的IP为其他节点容器IP时，需要路由到flanneld中进行封包，并且在flanneld接收UDP包后解封出来的IP包需要通过路由到网桥docker0中 缺点很明显，仅一次网络传输的数据包经历了2次用户态与内核态的切换，而切换的效率是不高的，每一次的切换都是一次数据的复制。
2.3 手动模拟flannel实现udp实验 首先创建Network Namesapce net1用来模拟容器
ip netns add net1 然后创建一对veth pair网卡veth0和veth1，并将veth0放到net1中，拉起并设置veth0的ip地址为172.19.1.2/24
ip link add veth0 type veth peer name veth1 ip link set dev veth0 netns net1 ip netns exec net1 ip addr add 172.19.1.2/24 dev veth0 ip netns exec net1 ip link set veth0 up 创建网桥设备，拉起并设置ip地址为172.19.1.1/24，将veth1拉起并绑定到网桥bridge0中
# 添加网桥 ip link add bridge0 type bridge ip link set bridge0 up ip a add 172." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e6a387cf1f32b396efabdef6816fb58a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-05T08:00:00+08:00" />
<meta property="article:modified_time" content="2023-06-05T08:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">理解flannel的三种容器网络方案原理</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="0__0"></a>0. 前言</h3> 
<p>本文主要介绍flannel在k8s网络中作为网络插件通过UDP、VXLAN、HOST-GATEWAY三种模式来解决容器跨主机网络通信的，并通过手动实现这三种模式深入理解其原理。</p> 
<h3><a id="1_flannel_4"></a>1. flannel全局网络地址分配机制</h3> 
<p>每台节点上容器的IP地址是由所属节点自动分配的，那么会存在一个问题是，不同节点上的容器所分配的IP地址则可能会有重复的情况。</p> 
<p>flannel设计了一种全局的网络地址分配机制，flannel会为每台节点申请一个独一无二的网段，并存储在etcd中，flannel会将该网段配置到各个节点上的Docker(或者其他容器工具)，当前节点上的容器<br> 只从分配的网段里中获取IP地址。</p> 
<blockquote> 
 <p>修改docker启动参数–bip来限制节点容器获得的IP范围。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/e2/74/gZCZ8o6d_o.png" alt=""></p> 
<h3><a id="2_UDP_15"></a>2. UDP模式</h3> 
<h4><a id="21__17"></a>2.1 简介</h4> 
<p>在Flannel的UDP模式中，每个节点都会启动一个UDP服务器，用于监听来自其他节点的数据包。当一个容器向另一个容器发送数据包时，它会将数据包发送到目标容器的IP地址和端口号。Flannel会将该数据包封装在一个UDP数据包中，并将其发送到目标节点的UDP服务器。目标节点的UDP服务器会解析该数据包，并将其传递给目标容器。</p> 
<h4><a id="22_flannelUDP_21"></a>2.2 flannel实现UDP流程</h4> 
<p><img src="https://images2.imgbox.com/f0/07/DwqYyJNR_o.png" alt=""></p> 
<p>flanneld启动后会通过打开/dev/net/tun的方式创建<a href="https://www.zhengwenfeng.com/pages/143447" rel="nofollow">tun设备</a>，名称为flannel0，该设备是用户空间与内核空间的数据包交互的通道。然后再将从tun设备获取的IP数据包封装到UDP数据包中通过物理网卡发送到其他节点中，内核通过UDP端口转发给flanneld然后解包，得到其中的IP数据包，然后再通过tun设备进入内核空间中，通过路由到达网桥，然后再到目的容器中。</p> 
<p>flanneld在其中主要做了：</p> 
<ol><li>开启了udp服务，并对udp数据包封包和解包</li><li>节点上路由表的动态更新，也就是从网桥出来的数据包目的IP为其他节点容器IP时，需要路由到flanneld中进行封包，并且在flanneld接收UDP包后解封出来的IP包需要通过路由到网桥docker0中</li></ol> 
<p>缺点很明显，仅一次网络传输的数据包经历了2次用户态与内核态的切换，而切换的效率是不高的，每一次的切换都是一次数据的复制。</p> 
<p><img src="https://images2.imgbox.com/d2/44/WjXOXghy_o.png" alt=""></p> 
<h4><a id="23_flanneludp_37"></a>2.3 手动模拟flannel实现udp实验</h4> 
<p>首先创建Network Namesapce net1用来模拟容器</p> 
<pre><code class="prism language-shell"><span class="token function">ip</span> netns <span class="token function">add</span> net1
</code></pre> 
<p>然后创建一对veth pair网卡veth0和veth1，并将veth0放到net1中，拉起并设置veth0的ip地址为172.19.1.2/24</p> 
<pre><code class="prism language-shell"><span class="token function">ip</span> <span class="token function">link</span> <span class="token function">add</span> veth0 <span class="token builtin class-name">type</span> veth peer name veth1

<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth0 netns net1
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> net1 <span class="token function">ip</span> addr <span class="token function">add</span> <span class="token number">172.19</span>.1.2/24 dev veth0
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> net1 <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> veth0 up
</code></pre> 
<p>创建网桥设备，拉起并设置ip地址为172.19.1.1/24，将veth1拉起并绑定到网桥bridge0中</p> 
<pre><code class="prism language-shell"><span class="token comment"># 添加网桥</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token function">add</span> bridge0 <span class="token builtin class-name">type</span> bridge
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> bridge0 up
<span class="token function">ip</span> a <span class="token function">add</span> <span class="token number">172.19</span>.1.1/24 dev bridge0

<span class="token comment"># 将另一端绑定在网桥上</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth1 up
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth1 master bridge0
</code></pre> 
<p>在net1中添加默认路由，设置下一条地址为网桥bridge0的IP地址，从网桥进入到宿主机的网络协议栈中。</p> 
<pre><code class="prism language-shell"><span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> net1 <span class="token function">ip</span> r <span class="token function">add</span> default via <span class="token number">172.19</span>.1.1 dev veth0
</code></pre> 
<p>再运行以下代码，该代码是用来模拟flanneld程序，主要作用是创建了tun设备flannel0，开启了UDP服务收发UDP包，然后就是对容器IP包的封装与解封。</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> os
<span class="token keyword">import</span> socket
<span class="token keyword">import</span> struct
<span class="token keyword">import</span> threading
<span class="token keyword">from</span> fcntl <span class="token keyword">import</span> ioctl
<span class="token keyword">import</span> click

BIND_ADDRESS <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span> <span class="token number">8285</span><span class="token punctuation">)</span>
BUFFER_SIZE <span class="token operator">=</span> <span class="token number">4096</span>

TUNSETIFF <span class="token operator">=</span> <span class="token number">0x400454ca</span>
IFF_TUN <span class="token operator">=</span> <span class="token number">0x0001</span>
IFF_TAP <span class="token operator">=</span> <span class="token number">0x0002</span>


<span class="token keyword">def</span> <span class="token function">create_tunnel</span><span class="token punctuation">(</span>tun_name<span class="token operator">=</span><span class="token string">'flannel%d'</span><span class="token punctuation">,</span> tun_mode<span class="token operator">=</span>IFF_TUN<span class="token punctuation">)</span><span class="token punctuation">:</span>
    tun_fd <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"/dev/net/tun"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_RDWR<span class="token punctuation">)</span>
    ifn <span class="token operator">=</span> ioctl<span class="token punctuation">(</span>tun_fd<span class="token punctuation">,</span> TUNSETIFF<span class="token punctuation">,</span> struct<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">b"16sH"</span><span class="token punctuation">,</span> tun_name<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tun_mode<span class="token punctuation">)</span><span class="token punctuation">)</span>
    tun_name <span class="token operator">=</span> ifn<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token string">"\x00"</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> tun_fd<span class="token punctuation">,</span> tun_name


<span class="token keyword">def</span> <span class="token function">start_tunnel</span><span class="token punctuation">(</span>tun_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    os<span class="token punctuation">.</span>popen<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"ip link set </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>tun_name<span class="token punctuation">}</span></span><span class="token string"> up"</span></span><span class="token punctuation">)</span>


<span class="token keyword">def</span> <span class="token function">udp_server</span><span class="token punctuation">(</span>udp_socket<span class="token punctuation">,</span> tun_fd<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        data<span class="token punctuation">,</span> addr <span class="token operator">=</span> udp_socket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"get data from udp."</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> data<span class="token punctuation">:</span>
            <span class="token keyword">break</span>

        os<span class="token punctuation">.</span>write<span class="token punctuation">(</span>tun_fd<span class="token punctuation">,</span> data<span class="token punctuation">)</span>


<span class="token decorator annotation punctuation">@click<span class="token punctuation">.</span>command</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token decorator annotation punctuation">@click<span class="token punctuation">.</span>option</span><span class="token punctuation">(</span><span class="token string">"--peer_node_ip"</span><span class="token punctuation">,</span> <span class="token string">"-p"</span><span class="token punctuation">,</span> required<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">"对端节点IP"</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>peer_node_ip<span class="token punctuation">)</span><span class="token punctuation">:</span>
    peer_node_addr <span class="token operator">=</span> <span class="token punctuation">(</span>peer_node_ip<span class="token punctuation">,</span> <span class="token number">7000</span><span class="token punctuation">)</span>

    tun_fd<span class="token punctuation">,</span> tun_name <span class="token operator">=</span> create_tunnel<span class="token punctuation">(</span><span class="token punctuation">)</span>
    start_tunnel<span class="token punctuation">(</span>tun_name<span class="token punctuation">)</span>

    udp_socket <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_DGRAM<span class="token punctuation">)</span>
    udp_socket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span>BIND_ADDRESS<span class="token punctuation">)</span>

    t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>udp_server<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>udp_socket<span class="token punctuation">,</span> tun_fd<span class="token punctuation">)</span><span class="token punctuation">)</span>
    t<span class="token punctuation">.</span>daemon <span class="token operator">=</span> <span class="token boolean">True</span>
    t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        data <span class="token operator">=</span> os<span class="token punctuation">.</span>read<span class="token punctuation">(</span>tun_fd<span class="token punctuation">,</span> BUFFER_SIZE<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"get data from tun. data size = </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
        udp_socket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>data<span class="token punctuation">,</span> peer_node_addr<span class="token punctuation">)</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>在Node1中运行该程序，设置Node2 IP</p> 
<pre><code class="prism language-shell">python3 tun_app.py -p <span class="token number">10.65</span>.132.188
</code></pre> 
<p>可以看到已经创建了tun设备</p> 
<pre><code class="prism language-shell"><span class="token comment"># ip link show flannel0</span>
<span class="token punctuation">..</span>.
<span class="token number">109</span>: tun0: <span class="token operator">&lt;</span>POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc pfifo_fast state UNKNOWN group default qlen <span class="token number">500</span>
    link/none 
    inet6 fe80::8e98:91a4:6537:d77a/64 scope <span class="token function">link</span> flags <span class="token number">800</span> 
       valid_lft forever preferred_lft forever
<span class="token punctuation">..</span>.
</code></pre> 
<p>在设置宿主机的路由，将所有到Node2容器的IP包，都转发到flannel0设备中。</p> 
<pre><code class="prism language-shell"><span class="token function">ip</span> r <span class="token function">add</span> <span class="token number">172.19</span>.2.0/24 dev flannel0
</code></pre> 
<p>最后重复Node1的操作配置Node2</p> 
<pre><code class="prism language-shell"><span class="token comment"># 创建net3</span>
<span class="token function">ip</span> netns <span class="token function">add</span> net3

<span class="token comment"># 创建veth pair</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token function">add</span> veth0 <span class="token builtin class-name">type</span> veth peer name veth1

<span class="token comment"># 设置net1网络</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth0 netns net3
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> net3 <span class="token function">ip</span> addr <span class="token function">add</span> <span class="token number">172.19</span>.2.2/24 dev veth0
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> net3 <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> veth0 up

<span class="token comment"># 添加网桥</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token function">add</span> bridge0 <span class="token builtin class-name">type</span> bridge
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> bridge0 up
<span class="token function">ip</span> a <span class="token function">add</span> <span class="token number">172.19</span>.2.1/24 dev bridge0

<span class="token comment"># 将另一端绑定在网桥上</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth1 up
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth1 master bridge0

<span class="token comment"># 配置net3路由</span>
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> net3 <span class="token function">ip</span> r <span class="token function">add</span> default via <span class="token number">172.19</span>.2.1 dev veth0

<span class="token comment"># 创建flannel0</span>
python3 flanneld.py -p <span class="token number">10.65</span>.132.187

<span class="token comment"># 配置到flannel0的路由</span>
<span class="token function">ip</span> r <span class="token function">add</span> <span class="token number">172.19</span>.1.0/24 dev flannel0
</code></pre> 
<h4><a id="24__186"></a>2.4 分析</h4> 
<p>在Node1的net1中ping Node2的net2的ip 172.19.2.2，可以看到是可以ping通的</p> 
<pre><code class="prism language-shell"><span class="token comment"># ping 172.19.2.2 -c 1</span>
PING <span class="token number">172.19</span>.2.2 <span class="token punctuation">(</span><span class="token number">172.19</span>.2.2<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.
<span class="token number">64</span> bytes from <span class="token number">172.19</span>.2.2: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">63</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.641</span> ms

--- <span class="token number">172.19</span>.2.2 <span class="token function">ping</span> statistics ---
<span class="token number">1</span> packets transmitted, <span class="token number">1</span> received, <span class="token number">0</span>% packet loss, <span class="token function">time</span> 0ms
rtt min/avg/max/mdev <span class="token operator">=</span> <span class="token number">0.641</span>/0.641/0.641/0.000 ms
</code></pre> 
<p>在Node1的flanneld.py中看到日志，从tun中收到了来自容器的IP数据包</p> 
<pre><code class="prism language-shell"><span class="token comment"># python3 flanneld.py -p 10.65.132.188</span>
get data from tun. data size <span class="token operator">=</span> <span class="token number">88</span>
</code></pre> 
<p>在Node2的flanneld.py中看到日志，接收到了Node1发送过来的udp数据包。</p> 
<pre><code class="prism language-shell"><span class="token comment"># python3 flanneld.py -p 10.65.132.187</span>
get data from udp.
</code></pre> 
<h3><a id="3_VXLAN_213"></a>3. VXLAN模式</h3> 
<h4><a id="31__215"></a>3.1 简介</h4> 
<p>在Flannel的<a href="https://www.zhengwenfeng.com/pages/8a4b28/" rel="nofollow">VXLAN</a>模式中，每个节点都会启动一个VXLAN隧道，用于将容器之间的数据包封装在VXLAN协议中进行传输。当一个容器向另一个容器发送数据包时，它会将数据包发送到目标容器的IP地址和虚拟网络ID。Flannel会将该数据包封装在一个VXLAN数据包中，并将其发送到目标节点的VXLAN隧道。目标节点的VXLAN隧道会解析该数据包，并将其传递给目标容器。</p> 
<p><strong>vxlan模式也是通过封包与解包的形式来实现隧道达到容器的跨主机访问，那和UDP模式有什么区别呢？</strong><br> 区别在于，VXLAN的封包与解包都是在内核态完成的，对比UDP模式用户态与内核态的切换来说，效率大大的提升了。</p> 
<h4><a id="33_flannelvxlan_222"></a>3.3 flannel实现vxlan模式流程</h4> 
<p><img src="https://images2.imgbox.com/f3/ca/1DzdusCY_o.png" alt=""></p> 
<p>在Node1的net1中ping Node2的net3，数据流如下：</p> 
<ol><li>bridge作为net1的下一跳网关，所以会先发送ARP获取bridge的mac地址</li><li>获取到后，然后发送ICMP数据包通过bridge进入到宿主机的网络协议栈中，通过路由表，会进入到flannel.1中，下一跳地址为Node2的flannel.1的地址</li><li>本来是要发送ARP来获取Node2的flannel.1的地址，因为已经手动配置了ARP表，可以直接获取到到MAC地址，然后将其填充内层二层头中。</li><li>再通过查询FDB表，找到外层UDP包中目的IP地址，也就是Node2的IP地址，填充到外部IP头中。最终通过物理网卡ens18走外部网络达到Node2中。</li><li>达到Node2后，通过端口8472，将包转发给VTEP设备flannel.1进行解包，解封后的IP包经过路由表达到bridge中，最终转发到net3中。</li></ol> 
<h4><a id="34_flanneldVTEP_234"></a>3.4 手动模拟flanneld维护VTEP组实践</h4> 
<p>创建VTEP设备命名为flannel.1，然后flannel.1配置ip地址为172.19.1.0/32</p> 
<pre><code class="prism language-shell"><span class="token comment"># 添加VTEP设备</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token function">add</span> flannel.1 <span class="token builtin class-name">type</span> vxlan <span class="token function">id</span> <span class="token number">42</span> dstport <span class="token number">8472</span> <span class="token builtin class-name">local</span> <span class="token number">10.65</span>.132.187 dev ens18 nolearning proxy

<span class="token comment"># 配置flannel.1</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> flannel.1 up
<span class="token function">ip</span> a <span class="token function">add</span> <span class="token number">172.19</span>.1.0/32 dev flannel.1
</code></pre> 
<ul><li>只需要填写local地址</li><li>nolearning，VTEP不要通过收到的报文学习FDB表项的内容，减少广播风暴，提高效率。</li><li>proxy，VTEP承担ARP代理功能，收到ARP请求时，如果有缓存则直接应答，减少广播风暴，提高效率。</li></ul> 
<p>添加network namespace net1，创建veth pair，将其中一端放进net1中，并配置好ip地址，再添加默认路由都走veth0</p> 
<pre><code class="prism language-shell"><span class="token function">ip</span> netns <span class="token function">add</span> net1
<span class="token function">ip</span> <span class="token function">link</span> <span class="token function">add</span> veth0 <span class="token builtin class-name">type</span> veth peer name veth1
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth0 up

<span class="token comment"># 设置net1中网络配置</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth0 netns net1
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> net1 <span class="token function">ip</span> addr <span class="token function">add</span> <span class="token number">172.19</span>.1.2/24 dev veth0
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> net1 <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> veth0 up

<span class="token comment"># 默认路由</span>
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> net1 <span class="token function">ip</span> r <span class="token function">add</span> default via <span class="token number">172.19</span>.1.1 dev veth0
</code></pre> 
<p>创建网桥设备命名为bridge0，并将veth1插到其上</p> 
<pre><code class="prism language-shell"><span class="token comment"># 添加网桥</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token function">add</span> bridge0 <span class="token builtin class-name">type</span> bridge
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> bridge0 up
<span class="token function">ip</span> a <span class="token function">add</span> <span class="token number">172.19</span>.1.1/24 dev bridge0

<span class="token comment"># 将另一端绑定在网桥上</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth1 up
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth1 master bridge0
</code></pre> 
<p>到达net3的数据包下一跳为Node2的VTEP设备IP通过flannel.1设备，需要添加onlink，因为下一跳网关不和本地地址在同一网段，路由添加时输出路由不可达的错误，onlink的意义在于协议栈虽然找不到链路层直连路由，但是还是会发布针对via网关的arp请求的.</p> 
<pre><code class="prism language-shell"><span class="token function">ip</span> r <span class="token function">add</span> <span class="token number">172.19</span>.2.0/24 via <span class="token number">172.19</span>.2.0 dev flannel.1 onlink
</code></pre> 
<p>在Node2节点中重复上面操作创建VETP设备和相关网络配置</p> 
<pre><code class="prism language-shell"><span class="token comment"># 添加VTEP设备</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token function">add</span> flannel.1 <span class="token builtin class-name">type</span> vxlan <span class="token function">id</span> <span class="token number">42</span> dstport <span class="token number">8472</span> <span class="token builtin class-name">local</span> <span class="token number">10.65</span>.132.188 dev ens18
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> flannel.1 up
<span class="token function">ip</span> a <span class="token function">add</span> <span class="token number">172.19</span>.2.0/32 dev flannel.1
<span class="token function">ip</span> r <span class="token function">add</span> <span class="token number">172.19</span>.1.0/24 via <span class="token number">172.19</span>.1.0 dev flannel.1 onlink


<span class="token comment"># 添加net3模拟容器</span>
<span class="token function">ip</span> netns <span class="token function">add</span> net3
<span class="token function">ip</span> <span class="token function">link</span> <span class="token function">add</span> veth0 <span class="token builtin class-name">type</span> veth peer name veth1

<span class="token comment"># 设置net3中网络配置</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth0 netns net3
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> net3 <span class="token function">ip</span> addr <span class="token function">add</span> <span class="token number">172.19</span>.2.2/24 dev veth0
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> net3 <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> veth0 up
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> net3 <span class="token function">ip</span> r <span class="token function">add</span> default dev veth0
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> net3 <span class="token function">ip</span> r <span class="token function">add</span> default via <span class="token number">172.19</span>.2.1 dev veth0

<span class="token comment"># 添加网桥</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token function">add</span> bridge0 <span class="token builtin class-name">type</span> bridge
<span class="token function">ip</span> a <span class="token function">add</span> <span class="token number">172.19</span>.2.1/24 dev bridge0
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> bridge0 up

<span class="token comment"># 将另一端绑定在网桥上</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth1 up
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth1 master bridge0
</code></pre> 
<p>在Node1节点中需要再新增ARP缓存，Node1中添加路由的下一跳地址是Node2的VTEP设备，所以需要在arp添加VTEP IP和MAC地址的缓存。</p> 
<pre><code class="prism language-shell">arp -s <span class="token number">172.19</span>.2.0 8a:8b:4d:10:82:56 dev flannel.1
</code></pre> 
<p>再在节点FDB表中添加对端VETP MAC地址和对外IP（物理网卡IP）的映射关系表项</p> 
<pre><code class="prism language-shell">bridge fdb <span class="token function">add</span> 8a:8b:4d:10:82:56 dev flannel.1 dst <span class="token number">10.65</span>.132.188
</code></pre> 
<p>重复Node1操作，配置Node2的ARP缓存和FDB表。</p> 
<pre><code class="prism language-shell">arp -s <span class="token number">172.19</span>.1.0 1e:b7:5e:19:ab:90 dev flannel.1
bridge fdb <span class="token function">add</span> 1e:b7:5e:19:ab:90 dev flannel.1 dst <span class="token number">10.65</span>.132.187
</code></pre> 
<p>通过以上操作完成了环境的搭建，接下来，我们在Node1的net1中进行ping Node2的net3，可以发现是可以ping通的</p> 
<pre><code class="prism language-shell"><span class="token comment"># ip netns exec net1 ping 172.19.2.2 -c 2</span>
PING <span class="token number">172.19</span>.2.2 <span class="token punctuation">(</span><span class="token number">172.19</span>.2.2<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.
<span class="token number">64</span> bytes from <span class="token number">172.19</span>.2.2: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">62</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.547</span> ms
<span class="token number">64</span> bytes from <span class="token number">172.19</span>.2.2: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">62</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.560</span> ms
</code></pre> 
<h3><a id="4_Host_Gateway_345"></a>4. Host Gateway模式</h3> 
<h4><a id="41__347"></a>4.1 简介</h4> 
<p>通过把主机当作网关实现跨节点网络通信的。因此通信双方的宿主机要求能够直接路由，必须在同一个网络，这个限制使得host-gw模式无法适用于集群规模较大且需要对节点进行网段划分的场景。host-gw的另外一个限制则是随着集群中节点规模的增大，flanneld维护主机上成千上万条路由表的动态更新也是一个不小的压力。</p> 
<p>flanneld的唯一作用就是负责主机上路由表的动态，但因为只能修改主机的路由，所以各个主机必须二层网络互通。</p> 
<p>跟VXLAN模式和UDP模式比较，优点主要是没有封包与解包的操作，大大的提高了性能。</p> 
<h4><a id="43_flannelHost_Gateway_355"></a>4.3 flannel实现Host Gateway模式流程</h4> 
<p><img src="https://images2.imgbox.com/d3/e1/w7ZIBST8_o.png" alt=""></p> 
<p>在Node1的net1中ping Node2的net3，数据流如下：</p> 
<ol><li>数据包从容器进入到宿主机网络协议栈逻辑与VXLAN模式一致</li><li>通过路由表可知，该数据包通过ens18网卡到达下一跳网关Node2的ens18</li><li>通过物理网络，达到Node2并进入网络协议栈，通过路由达到bridge进入到net3中</li></ol> 
<h4><a id="44_flannelHost_Gateway_367"></a>4.4 手动模拟flannel实现Host Gateway模式实验</h4> 
<p>在Node1中创建Network Namesapce net1、vethpair和网桥，并配置好其网络。</p> 
<pre><code class="prism language-shell"><span class="token function">ip</span> netns <span class="token function">add</span> net1
<span class="token function">ip</span> <span class="token function">link</span> <span class="token function">add</span> veth0 <span class="token builtin class-name">type</span> veth peer name veth1
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth0 up

<span class="token comment"># 设置net1中网络配置</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth0 netns net1
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> net1 <span class="token function">ip</span> addr <span class="token function">add</span> <span class="token number">172.19</span>.1.2/24 dev veth0
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> net1 <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> veth0 up

<span class="token comment"># 默认路由</span>
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> net1 <span class="token function">ip</span> r <span class="token function">add</span> default via <span class="token number">172.19</span>.1.1 dev veth0

<span class="token comment"># 添加网桥</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token function">add</span> bridge0 <span class="token builtin class-name">type</span> bridge
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> bridge0 up
<span class="token function">ip</span> a <span class="token function">add</span> <span class="token number">172.19</span>.1.1/24 dev bridge0

<span class="token comment"># 将另一端绑定在网桥上</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth1 up
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth1 master bridge0

</code></pre> 
<p>再添加路由，将Node2所分配到的容器网段为目的数据包都将Node2作为下一跳网关。</p> 
<pre><code class="prism language-shell"><span class="token function">ip</span> r <span class="token function">add</span> <span class="token number">172.19</span>.2.0/24 via <span class="token number">10.65</span>.132.188 dev ens18
</code></pre> 
<p>重复Node1的配置，并添加将Node1所分配到的容器网段为目的数据包都将Node1作为下一跳网关。</p> 
<pre><code class="prism language-shell"><span class="token comment"># 添加net3模拟容器</span>
<span class="token function">ip</span> netns <span class="token function">add</span> net3
<span class="token function">ip</span> <span class="token function">link</span> <span class="token function">add</span> veth0 <span class="token builtin class-name">type</span> veth peer name veth1

<span class="token comment"># 设置net3中网络配置</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth0 netns net3
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> net3 <span class="token function">ip</span> addr <span class="token function">add</span> <span class="token number">172.19</span>.2.2/24 dev veth0
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> net3 <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> veth0 up
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> net3 <span class="token function">ip</span> r <span class="token function">add</span> default via <span class="token number">172.19</span>.2.1 dev veth0

<span class="token comment"># 添加网桥</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token function">add</span> bridge0 <span class="token builtin class-name">type</span> bridge
<span class="token function">ip</span> a <span class="token function">add</span> <span class="token number">172.19</span>.2.1/24 dev bridge0
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> bridge0 up

<span class="token comment"># 将另一端绑定在网桥上</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth1 up
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth1 master bridge0

<span class="token comment"># 路由</span>
<span class="token function">ip</span> r <span class="token function">add</span> <span class="token number">172.19</span>.1.0/24 via <span class="token number">10.65</span>.132.187 dev ens18
</code></pre> 
<p>在Node1的net1中ping Node2的net2，是可以ping通的，说明网络互通了。</p> 
<p>在通过tcpdump抓取Node2 ens18网卡的包，可以看到ICMP数据包到了Node2节点。</p> 
<pre><code class="prism language-shell"><span class="token comment"># tcpdump -i ens18 host 172.19.2.2</span>
dropped privs to tcpdump
tcpdump: verbose output suppressed, use -v or -vv <span class="token keyword">for</span> full protocol decode
listening on ens18, link-type EN10MB <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>, capture size <span class="token number">262144</span> bytes
<span class="token number">15</span>:07:00.072677 IP <span class="token number">172.19</span>.1.2 <span class="token operator">&gt;</span> <span class="token number">172.19</span>.2.2: ICMP <span class="token builtin class-name">echo</span> request, <span class="token function">id</span> <span class="token number">52240</span>, <span class="token function">seq</span> <span class="token number">8</span>, length <span class="token number">64</span>
<span class="token number">15</span>:07:00.072782 IP <span class="token number">172.19</span>.2.2 <span class="token operator">&gt;</span> <span class="token number">172.19</span>.1.2: ICMP <span class="token builtin class-name">echo</span> reply, <span class="token function">id</span> <span class="token number">52240</span>, <span class="token function">seq</span> <span class="token number">8</span>, length <span class="token number">64</span>
</code></pre> 
<h3><a id="5__437"></a>5. 巨人的肩膀</h3> 
<ul><li><a href="https://izsk.me/2022/03/25/Kubernetes-Flannel-Vxlan/" rel="nofollow">Flannel Vxlan封包原理剖析</a></li><li>《kubernetes网络权威指南》</li><li>《极客时间-深入剖析Kubernetes》</li></ul> 
<h3><a id="_442"></a>欢迎关注，互相学习，共同进步~</h3> 
<p>我的<a href="https://www.zhengwenfeng.com/" rel="nofollow">个人博客</a><br> 公众号：编程黑洞</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5838f8445c594e5a833f3eb06fdc9e19/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">javascript基础二十七：说说 JavaScript 数字精度丢失的问题，解决方案？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b64eff9b87ae152357506816ef54d75a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">设计模式之不一样的责任链模式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>