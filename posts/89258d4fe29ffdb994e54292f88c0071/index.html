<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>单例模式详细总结（8种实现方式，看完就会） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="单例模式详细总结（8种实现方式，看完就会）" />
<meta property="og:description" content="单例模式 实现单例模式的8种方式： 饿汉式(静态变量) 优点：类装载时完成实例化，避免线程同步
缺点：没有达到Lazy Loading的效果，如果从始至终未使用过这个实例，会造成内存浪费
public class SingletonTest01 { public static void main(String[] args) { // 测试 Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true System.out.println(instance.hashCode()); // 356573597 System.out.println(instance2.hashCode()); // 356573597 } } // 单例模式 // 饿汉式(静态变量) class Singleton { // 1. 构造器私有化 private Singleton() {} // 2. 本类内部创建对象实例 private final static Singleton instance = new Singleton(); // 静态变量 // 3. 提供一个公有的静态方法，返回实例对象 public static Singleton getInstance() { return instance; } } jdk源码中的 Runtime 就使用了这种方式实现单例模式" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/89258d4fe29ffdb994e54292f88c0071/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-09T21:45:38+08:00" />
<meta property="article:modified_time" content="2023-04-09T21:45:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">单例模式详细总结（8种实现方式，看完就会）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h2 style="">单例模式</h2> 
 <h4 style="text-align:left;">实现单例模式的8种方式：</h4> 
 <h6 style="text-align:left;"><span class="kdocs-color" style="color:#C21C13;">饿汉式(静态变量)</span></h6> 
 <p style="">优点：类装载时完成实例化，避免线程同步</p> 
 <p style="">缺点：没有达到Lazy Loading的效果，如果从始至终未使用过这个实例，会造成内存浪费</p> 
 <pre class="kdocs-java"><code class="language-java">public class SingletonTest01 {
    public static void main(String[] args) {
        // 测试
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance == instance2); // true
        System.out.println(instance.hashCode()); // 356573597
        System.out.println(instance2.hashCode()); // 356573597
    }

}
// 单例模式
// 饿汉式(静态变量)
class Singleton {
    // 1. 构造器私有化
    private Singleton() {}
    // 2. 本类内部创建对象实例
    private final static Singleton instance = new Singleton(); // 静态变量
    // 3. 提供一个公有的静态方法，返回实例对象
    public static Singleton getInstance() {
        return instance;
    }
}</code></pre> 
 <p style="">jdk源码中的 Runtime 就使用了这种方式实现单例模式</p> 
 <h6 style="text-align:left;"><span class="kdocs-color" style="color:#C21C13;">饿汉式(静态代码块)</span></h6> 
 <p style="">优缺点同上</p> 
 <pre class="kdocs-java"><code class="language-java">public class SingletonTest02 {
    public static void main(String[] args) {
        // 测试
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance == instance2); // true
        System.out.println(instance.hashCode()); // 356573597
        System.out.println(instance2.hashCode()); // 356573597
    }

}
// 单例模式
// 饿汉式(静态代码块)
class Singleton {
    // 1. 构造器私有化
    private Singleton() {}
    // 2. 本类内部创建对象实例
    private static Singleton instance;
    // 3. 静态代码块
    static {
        instance = new Singleton();
    }
    // 4. 提供一个公有的静态方法，返回实例对象
    public static Singleton getInstance() {
        return instance;
    }
}</code></pre> 
 <h6 style="text-align:left;">懒汉式(线程不安全)</h6> 
 <p style="">优点：Lazy loading(懒加载)</p> 
 <p style="">缺点：只能在单线程下使用。</p> 
 <p style=""> 如果在多线程下，一个线程进入了 if(instance == null) 判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例，故，在多线程环境下，不可使用这种方式。</p> 
 <p style="">结论：实际开发中，不使用这种方式。</p> 
 <pre class="kdocs-java"><code class="language-java">public class SingletonTest3 {
    public static void main(String[] args) {
        // 测试
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance == instance2); // true
        System.out.println(instance.hashCode()); // 356573597
        System.out.println(instance2.hashCode()); // 356573597
    }
}
// 懒汉式单例模式
class Singleton {
    private static Singleton instance;

    private Singleton() {}
    // 提供一个静态的公有方法，当使用到该方法时，才去创建instance
    // 即懒汉式
    public static Singleton getInstance() {
        if (instance == null) { // 线程不安全
            instance = new Singleton();
        }
        return instance;
    }
}</code></pre> 
 <h6 style="text-align:left;">懒汉式(线程安全)</h6> 
 <p style="">优点：解决了线程不安全问题</p> 
 <p style="">缺点：效率太低了，每个线程在想获得类的实例时，执行 getInstance()方法 都要</p> 
 <p style="">进行同步。而其实这个方法只执行一次实例化代码就够了，后面想获得直接 return 就行了。方法进行同步效率太低</p> 
 <p style="">结论：在实际开发中，不推荐。</p> 
 <pre class="kdocs-java"><code class="language-java">public class SingletonTest4 {
    public static void main(String[] args) {
        // 测试
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance == instance2); // true
        System.out.println(instance.hashCode()); // 356573597
        System.out.println(instance2.hashCode()); // 356573597
    }
}
// 懒汉式单例模式(线程安全)
class Singleton {
    private static Singleton instance;

    private Singleton() {}
    // 提供一个静态的公有方法，并对该方法进行加synchronized进行线程同步，当使用到该方法时，才去创建instance
    public static synchronized Singleton getInstance() {// 线程安全
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}</code></pre> 
 <h6 style="text-align:left;">懒汉式(线程并不安全，同步代码块)</h6> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>本意是想对第四种方式的改进，因而，从同步方法该为了同步产生实例化的代码块。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>其实并没有起到线程同步的作用，假如一个线程进入了 if(instance == null) 判断语句块，还未来得及往下执行，另一个线程也通过了这个 判断语句块，这时便会产生多个实例。</p></li></ol> 
 <p style="">结论：在实际开发中，不能使用这种方式。</p> 
 <pre class="kdocs-java"><code class="language-java">public class SingletonTest5 {
    public static void main(String[] args) {
        // 测试
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance == instance2); // true
        System.out.println(instance.hashCode());
        System.out.println(instance2.hashCode());
    }
}
// 懒汉式单例模式(其实线程并不安全)
class Singleton {
    private static Singleton instance;

    private Singleton() {}
    // 提供一个静态的公有方法，当使用到该方法时，才去创建instance
    // 即懒汉式
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) { // 其实并不能保证线程安全
                instance = new Singleton();
            }
        }
        return instance;
    }
}</code></pre> 
 <h6 style="text-align:left;"><span class="kdocs-color" style="color:#C21C13;">双重检查(DoubleCheck)</span></h6> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>多线程开发中经常使用，进行两次 if(instance == null) 检查，保证线程安全。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>实例化代码只会执行一次，之后再次访问时，直接return实例化对象，也避免了反复进行方法同步。</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>线程安全、lazy loading(延迟加载)、效率高。</p></li></ol> 
 <p style="">结论：实际开发中，推荐这种单例设计模式。</p> 
 <pre class="kdocs-java"><code class="language-java">public class SingletonTest6 {
    public static void main(String[] args) {
        // 测试
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance == instance2); // true
        System.out.println(instance.hashCode()); // 356573597
        System.out.println(instance2.hashCode()); // 356573597
    }
}
// 懒汉式单例模式(线程安全)
class Singleton {
    // 1. volattle 保证 可见性，当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值
    private static volatile Singleton instance;
	// 2. 构造器私有化
    private Singleton() {}
    // 3. 提供一个静态的公有方法，加入双重检查代码，解决线程安全问题，同时解决懒加载问题。
    // 还保证了效率，推荐使用。
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) { //
                if (instance == null) { // 双重检查
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}</code></pre> 
 <h6 style="text-align:left;"><span class="kdocs-color" style="color:#C21C13;">静态内部类</span></h6> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>采用类装载的机制来保证初始化实例时只有一个线程。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>静态内部类在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingleInstance类，从而实现Singleton的实例化。</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</p></li></ol> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>优点：避免线程不安全、利用静态内部类的特点实现延迟加载，效率高。推荐使用</p></li></ol> 
 <pre class="kdocs-java"><code class="language-java">public class SingletonTest7 {
    public static void main(String[] args) {
        // 测试
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance == instance2); // true
        System.out.println(instance.hashCode()); // 356573597
        System.out.println(instance2.hashCode()); // 356573597
    }
}

// 静态内部类实现
class Singleton {
    // 构造器私有化
    private Singleton() {}
    // 写一个静态内部类，含一个静态属性Singleton
    private static class SingletonInstance {
        private static final Singleton INSTANCE = new Singleton();
    }
    // 提供一个静态的公有方法，直接返回SingleInstance.INSTANCE
    public static Singleton getInstance() {
        return SingletonInstance.INSTANCE;
    }
}</code></pre> 
 <h6 style="text-align:left;"><span class="kdocs-color" style="color:#C21C13;">枚举</span></h6> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>借助了 JDK1.5 中添加的枚举来实现单例模式，不仅避免了多线程同步问题，而且还防止反序列化重新创建新的对象。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>推荐使用</p></li></ol> 
 <pre class="kdocs-java"><code class="language-java">public class SingletonTest8 {
    public static void main(String[] args) {
        Singleton instance = Singleton.INSTANCE;
        Singleton instance2 = Singleton.INSTANCE;
        System.out.println(instance == instance2); //true
        System.out.println(instance.hashCode()); // 356573597
        System.out.println(instance2.hashCode()); // 356573597

    }
}
// 枚举实现单例
enum Singleton {
    INSTANCE; // 属性
    public void sayOk() {
        System.out.println("ok~");
    }
}</code></pre> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ca31236791670ff528ba776171589ea1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【个人学习】使用torch实现xml文件返回的图片</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7e21399b06852a11450222e8c9a3a710/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">onnxruntime.capi.onnxruntime_pybind11_state.InvalidProtobuf: [ONNXRuntimeError] : 7 : INVALID_PROTOB</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>