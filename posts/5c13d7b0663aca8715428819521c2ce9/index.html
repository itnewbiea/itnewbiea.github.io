<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>论文阅读：ImageNet - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="论文阅读：ImageNet" />
<meta property="og:description" content="原文：ImageNet Classification with Deep Convolutional Neural Networks
基于深度卷积神经网络的ImageNet分类
开始阅读： 摘要： 我们训练了一个大型的深度卷积神经网络，将ImageNet LSVRC-2010竞赛中的120万张高分辨率图像分为1000个不同的类别。在测试数据上，我们实现了前1和前5的错误率分别为37.5%和17.0%，大大优于之前的先进技术。这个神经网络有6000万个参数和65万个神经元，由5个卷积层组成，其中一些是最大池化层，还有3个完全连接的层，最后是1000路softmax。为了使训练更快，我们使用了非饱和神经元和一个非常高效的GPU实现卷积操作。为了减少全连接层的过拟合，我们采用了最近开发的一种称为“dropout”的正则化方法，该方法被证明非常有效。我们还在ILSVRC-2012比赛中输入了该模型的一个变体，并获得了前5名的15.3%的测试错误率，而第二名的错误率为26.2%。
介绍： 当前的目标识别方法基本使用了机器学习方法。为了提高它们的性能，我们可以收集更大的数据集，学习更强大的模型，并使用更好的技术来防止过拟合。直到最近，标记图像的数据集相对较小，大约为数万张图像。使用这种大小的数据集可以很好地解决简单的识别任务，特别是如果它们使用保持标签的转换进行增强。例如，目前MNIST数字识别任务的最佳错误率(&lt;0.3%)接近人类的表现。使用这种大小的数据集可以很好地解决简单的识别任务，特别是如果它们使用保持标签的转换进行增强。例如，目前MNIST数字识别任务的最佳错误率(&lt;0.3%)接近人类的表现。
但现实环境中的物体表现出相当大的可变性，因此要学会识别它们，有必要使用更大的训练集。事实上，小型图像数据集的缺点已经被广泛认识到(例如，Pinto等[21])，但直到最近才有可能收集具有数百万图像的标记数据集。新的更大的数据集包括LabelMe[23]，它由数十万张完全分割的图像组成，以及ImageNet[6]，它由超过22,000个类别的超过1500万张标记的高分辨率图像组成。
为了从数百万张图像中学习数千个对象，我们需要一个具有大学习能力的模型。然而，物体识别任务的巨大复杂性意味着即使是像ImageNet这样大的数据集也不能指定这个问题，因此我们的模型还应该有大量的先验知识来弥补我们没有的所有数据。卷积神经网络(cnn)就是这样一类模型。它们的能力可以通过改变它们的深度和广度来控制，并且它们还对图像的性质(即统计数据的平稳性和像素依赖性的局部性)做出强有力且大多数正确的假设。
因此，与具有类似大小层的标准前馈神经网络相比，cnn的连接和参数要少得多，因此更容易训练，而它们的理论最佳性能可能只会稍微差一点。
本文的具体贡献如下:我们在ILSVRC-2010和ILSVRC-2012比赛中使用的ImageNet子集上训练了迄今为止最大的卷积神经网络之一[2]，并取得了迄今为止在这些数据集上报道的最佳结果。我们编写了一个高度优化的GPU实现，用于2D卷积和训练卷积神经网络中固有的所有其他操作，我们将其公开。我们的网络包含了许多新的和不寻常的特征，这些特征可以提高其性能并减少其训练时间，具体内容见第3节。我们的网络的规模使得过拟合成为一个重要的问题，即使有120万个标记的训练样例，所以我们使用了几种有效的技术来防止过拟合，这些技术将在第4节中描述。我们最终的网络包含五个卷积层和三个全连接层，这个深度似乎很重要:我们发现删除任何卷积层(每个层包含不超过模型参数的1%)都会导致性能下降。
数据集 在ImageNet上，习惯上报告两个错误率:top-1和top-5，其中top-5错误率是正确标签不在模型认为最可能的五个标签中的测试图像的比例。
体系结构 我们的网络架构如图2所示。它包含八个学习层——五个卷积层和三个全连接层。下面，我们将描述我们的网络架构的一些新颖或不寻常的特性。3.1-3.4节按照我们对其重要性的估计进行排序，最重要的放在前面。
ReLU非线性 将神经元的输出f作为其输入x的函数建模的标准方法是f(x) = tanh(x)或f(x) = (1 &#43; e - x)−1。就梯度下降的训练时间而言，这些饱和非线性比非饱和非线性f(x) = max(0;x)慢很多。根据Nair和Hinton[20]，我们将具有这种非线性的神经元称为整流线性单元(relu)。使用relu的深度卷积神经网络（非饱和）的训练速度比使用tanh单元的深度卷积神经网络（饱和）快几倍。图1演示了这一点，图1显示了特定四层卷积网络在CIFAR-10数据集上达到25%训练误差所需的迭代次数。这张图表明，如果我们使用传统的饱和神经元模型，我们将无法对如此大的神经网络进行实验。
图1:具有relu(实线)的四层卷积神经网络在CIFAR-10上的训练错误率为25%，比具有tanh神经元(虚线)的等效网络快6倍。每个网络的学习率是独立选择的，以使训练尽可能快。没有采用任何形式的正规化。这里所展示的效果的大小随网络结构的不同而不同，但具有relu的网络始终比具有饱和神经元的网络学习速度快几倍
在多个gpu上进行训练 单个GTX 580 GPU只有3GB的内存，这限制了可以在其上训练的网络的最大大小。事实证明，120万个训练样本足以训练一个GPU无法容纳的网络。因此，我们将网络分散到两个gpu上。当前的gpu特别适合跨gpu并行化，因为它们能够直接从彼此的内存中读取和写入，而无需通过主机内存。我们采用的并行化方案实际上是将一半的内核(或神经元)放在每个GPU上，还有一个额外的技巧:GPU只在某些层进行通信。这意味着，例如，第3层的内核从第2层的所有内核映射中获取输入。然而，第4层的内核只从位于同一GPU上的第3层的内核映射中获取输入。选择连接模式是交叉验证的一个问题，但这允许我们精确地调整通信量，直到它是计算量的一个可接受的部分。
与在一个GPU上训练每个卷积层的核数减半的网络相比，该方案将我们的前1和前5错误率分别降低了1.7%和1.2%。双gpu网络比单gpu网络的训练时间稍短。
局部响应归一化 relu具有理想的特性，即它们不需要输入归一化来防止它们饱和。如果至少有一些训练样例对ReLU产生了正输入，则学习将在该神经元中发生。然而，我们仍然发现下面的局部归一化方案有助于泛化。
重叠的池化 cnn中的池化层对同一核映射中相邻神经元组的输出进行汇总。传统上，相邻池化单元所概括的邻域不重叠。更精确地说，池化层可以被认为是由间隔为5个像素的池化单元网格组成，每个池化单元以池化单元的位置为中心，总结了一个大小为z × z的邻域。如果我们设s = z，我们就得到了cnn中常用的传统的局部池化。如果我们设s &lt; z，我们得到重叠池化。这是我们在整个网络中使用的，s = 2, z = 3。与不重叠方案s = 2相比，该方案将前1和前5的错误率分别降低了0.4%和0.3%;Z = 2，产生同等尺寸的输出。我们通常在训练过程中观察到，有重叠池化的模型发现过拟合稍微困难一些
总体架构 现在我们准备描述CNN的整体架构。如图2所示，网络包含8层权重;前五个是卷积的，其余三个是完全连接的。最后一个完全连接层的输出被馈送到一个1000路softmax，它产生1000个类标签的分布。我们的网络最大化多项逻辑回归目标，这相当于最大化正确标签在预测分布下的对数概率的跨训练案例的平均值。
第二层、第四层和第五层卷积层的内核只连接到位于同一GPU上的前一层的内核映射(见图2)。第三层卷积层的内核连接到第二层的所有内核映射。全连接层中的神经元与前一层中的所有神经元相连。响应归一化层遵循第一层和第二层卷积层。第3.4节中描述的最大池化层遵循响应归一化层和第五个卷积层。将ReLU非线性应用于每个卷积层和全连接层的输出
ps“有关全连接层 卷积层这些的概念GitHub (zhihu.com)
我们的CNN架构的插图，明确地显示了两个gpu之间的职责划分。一个GPU运行图顶部的层部件，而另一个运行图底部的层部件。gpu只在某些层通信。网络的输入是150,528维，网络剩余层的神经元数量由253,440-186,624-64,896-64,896-43,264 - 4096-4096-1000给出
减少过度拟合 我们的神经网络架构有6000万个参数。尽管ILSVRC的1000个类使每个训练样例对从图像到标签的映射施加10位约束，但事实证明，这不足以在没有相当大的过拟合的情况下学习如此多的参数。下面，我们将描述两种对抗过拟合的主要方法。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5c13d7b0663aca8715428819521c2ce9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-04T16:47:12+08:00" />
<meta property="article:modified_time" content="2023-08-04T16:47:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">论文阅读：ImageNet</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>原文：<a class="link-info" href="https://proceedings.neurips.cc/paper_files/paper/2012/file/c399862d3b9d6b76c8436e924a68c45b-Paper.pdf" rel="nofollow" title="ImageNet Classification with Deep Convolutional Neural Networks">ImageNet Classification with Deep Convolutional Neural Networks</a></p> 
<p>基于深度卷积神经网络的ImageNet分类</p> 
<hr> 
<h2>开始阅读：</h2> 
<h3>摘要：</h3> 
<p>我们训练了一个大型的深度卷积神经网络，将ImageNet LSVRC-2010竞赛中的120万张高分辨率图像分为1000个不同的类别。在测试数据上，我们实现了前1和前5的错误率分别为37.5%和17.0%，大大优于之前的先进技术。这个神经网络有6000万个参数和65万个神经元，由5个卷积层组成，其中一些是最大池化层，还有3个完全连接的层，最后是1000路softmax。为了使训练更快，我们使用了非饱和神经元和一个非常高效的GPU实现卷积操作。为了减少全连接层的过拟合，我们采用了最近开发的一种称为“dropout”的正则化方法，该方法被证明非常有效。我们还在ILSVRC-2012比赛中输入了该模型的一个变体，并获得了前5名的15.3%的测试错误率，而第二名的错误率为26.2%。</p> 
<h3>介绍：</h3> 
<p>当前的目标识别方法基本使用了机器学习方法。为了提高它们的性能，我们可以收集更大的数据集，学习更强大的模型，并使用更好的技术来防止过拟合。直到最近，标记图像的数据集相对较小，大约为数万张图像。使用这种大小的数据集可以很好地解决简单的识别任务，特别是如果它们使用保持标签的转换进行增强。例如，目前MNIST数字识别任务的最佳错误率(&lt;0.3%)接近人类的表现。使用这种大小的数据集可以很好地解决简单的识别任务，特别是如果它们使用保持标签的转换进行增强。例如，目前MNIST数字识别任务的最佳错误率(&lt;0.3%)接近人类的表现。</p> 
<p>但现实环境中的物体表现出相当大的可变性，因此要学会识别它们，有必要使用更大的训练集。事实上，小型图像数据集的缺点已经被广泛认识到(例如，Pinto等[21])，但直到最近才有可能收集具有数百万图像的标记数据集。新的更大的数据集包括LabelMe[23]，它由数十万张完全分割的图像组成，以及ImageNet[6]，它由超过22,000个类别的超过1500万张标记的高分辨率图像组成。</p> 
<p>为了从数百万张图像中学习数千个对象，我们需要一个具有大学习能力的模型。然而，物体识别任务的巨大复杂性意味着即使是像ImageNet这样大的数据集也不能指定这个问题，因此我们的模型还应该有大量的先验知识来弥补我们没有的所有数据。卷积神经网络(cnn)就是这样一类模型。它们的能力可以通过改变它们的深度和广度来控制，并且它们还对图像的性质(即统计数据的平稳性和像素依赖性的局部性)做出强有力且大多数正确的假设。</p> 
<p>因此，与具有类似大小层的标准前馈神经网络相比，cnn的连接和参数要少得多，因此更容易训练，而它们的理论最佳性能可能只会稍微差一点。</p> 
<p>本文的具体贡献如下:<strong>我们在ILSVRC-2010和ILSVRC-2012比赛中使用的ImageNet子集上训练了迄今为止最大的卷积神经网络之一[2]，并取得了迄今为止在这些数据集上报道的最佳结果。我们编写了一个高度优化的GPU实现，用于2D卷积和训练卷积神经网络中固有的所有其他操作，我们将其公开。我们的网络包含了许多新的和不寻常的特征，这些特征可以提高其性能并减少其训练时间，具体内容见第3节。我们的网络的规模使得过拟合成为一个重要的问题，即使有120万个标记的训练样例，所以我们使用了几种有效的技术来防止过拟合，这些技术将在第4节中描述。我们最终的网络包含五个卷积层和三个全连接层，这个深度似乎很重要:我们发现删除任何卷积层(每个层包含不超过模型参数的1%)都会导致性能下降。</strong></p> 
<h3>数据集</h3> 
<p>在ImageNet上，习惯上报告两个错误率:top-1和top-5，其中top-5错误率是正确标签不在模型认为最可能的五个标签中的测试图像的比例。</p> 
<h3>体系结构</h3> 
<p>我们的网络架构如图2所示。它包含八个学习层——五个卷积层和三个全连接层。下面，我们将描述我们的网络架构的一些新颖或不寻常的特性。3.1-3.4节按照我们对其重要性的估计进行排序，最重要的放在前面。</p> 
<h4>ReLU非线性</h4> 
<p>将神经元的输出f作为其输入x的函数建模的标准方法是f(x) = tanh(x)或f(x) = (1 + e - x)−1。<strong>就梯度下降的训练时间而言，这些饱和非线性比非饱和非线性f(x) = max(0;x)慢很多</strong>。根据Nair和Hinton[20]，我们将具有这种非线性的神经元称为整流线性单元(relu)。<strong>使用relu的深度卷积神经网络（非饱和）的训练速度比使用tanh单元的深度卷积神经网络（饱和）快几倍</strong>。图1演示了这一点，图1显示了特定四层卷积网络在CIFAR-10数据集上达到25%训练误差所需的迭代次数。这张图表明，如果我们使用传统的饱和神经元模型，我们将无法对如此大的神经网络进行实验。</p> 
<p></p> 
<blockquote> 
 <p><img alt="" height="439" src="https://images2.imgbox.com/a9/7b/KEk0VlGn_o.png" width="486"> </p> 
 <p> 图1:具有relu(实线)的四层卷积神经网络在CIFAR-10上的训练错误率为25%，比具有tanh神经元(虚线)的等效网络快6倍。每个网络的学习率是独立选择的，以使训练尽可能快。没有采用任何形式的正规化。这里所展示的效果的大小随网络结构的不同而不同，但具有relu的网络始终比具有饱和神经元的网络学习速度快几倍</p> 
</blockquote> 
<h4 style="background-color:transparent;"> 在多个gpu上进行训练</h4> 
<p>单个GTX 580 GPU只有3GB的内存，这限制了可以在其上训练的网络的最大大小。事实证明，120万个训练样本足以训练一个GPU无法容纳的网络<strong>。因此，我们将网络分散到两个gpu上。当前的gpu特别适合跨gpu并行化，因为它们能够直接从彼此的内存中读取和写入，而无需通过主机内存。我们采用的并行化方案实际上是将一半的内核(或神经元)放在每个GPU上，还有一个额外的技巧:GPU只在某些层进行通信</strong>。这意味着，例如，第3层的内核从第2层的所有内核映射中获取输入。然而，第4层的内核只从位于同一GPU上的第3层的内核映射中获取输入。选择连接模式是交叉验证的一个问题，但这允许我们精确地调整通信量，直到它是计算量的一个可接受的部分。</p> 
<p>与在一个GPU上训练每个卷积层的核数减半的网络相比，该方案将我们的前1和前5错误率分别降低了1.7%和1.2%。双gpu网络比单gpu网络的训练时间稍短。</p> 
<h4 style="background-color:transparent;">局部响应归一化</h4> 
<p>relu具有理想的特性，即它们不需要输入归一化来防止它们饱和。如果至少有一些训练样例对ReLU产生了正输入，则学习将在该神经元中发生。然而，我们仍然发现下面的局部归一化方案有助于泛化。</p> 
<h4 style="background-color:transparent;">重叠的池化</h4> 
<p>cnn中的池化层对同一核映射中相邻神经元组的输出进行汇总。传统上，<strong>相邻池化单元所概括的邻域不重叠</strong>。更精确地说，池化层可以被认为是由间隔为5个像素的池化单元网格组成，每个池化单元以池化单元的位置为中心，总结了一个大小为z × z的邻域。如果我们设s = z，我们就得到了cnn中常用的传统的局部池化。如果我们设s &lt; z，我们得到重叠池化。这是我们在整个网络中使用的，s = 2, z = 3。<strong>与不重叠方案s = 2相比，该方案将前1和前5的错误率分别降低了0.4%和0.3%;Z = 2，产生同等尺寸的输出</strong>。我们通常在训练过程中观察到，有重叠池化的模型发现过拟合稍微困难一些</p> 
<h4 style="background-color:transparent;">总体架构</h4> 
<p>现在我们准备描述CNN的整体架构。如图2所示，<strong>网络包含8层权重;前五个是卷积的，其余三个是完全连接的。最后一个完全连接层的输出被馈送到一个1000路softmax，它产生1000个类标签的分布</strong>。我们的网络最大化多项逻辑回归目标，这相当于最大化正确标签在预测分布下的对数概率的跨训练案例的平均值。</p> 
<p>第二层、第四层和第五层卷积层的内核只连接到位于同一GPU上的前一层的内核映射(见图2)。第三层卷积层的内核连接到第二层的所有内核映射。全连接层中的神经元与前一层中的所有神经元相连。响应归一化层遵循第一层和第二层卷积层。第3.4节中描述的最大池化层遵循响应归一化层和第五个卷积层。将ReLU非线性应用于每个卷积层和全连接层的输出</p> 
<p>ps“有关全连接层 卷积层这些的概念<a href="https://zhuanlan.zhihu.com/p/31158737" rel="nofollow" title="GitHub (zhihu.com)">GitHub (zhihu.com)</a></p> 
<blockquote> 
 <p><img alt="" height="372" src="https://images2.imgbox.com/d1/12/msIlS4dN_o.png" width="1093"></p> 
 <p> 我们的CNN架构的插图，明确地显示了两个gpu之间的职责划分。一个GPU运行图顶部的层部件，而另一个运行图底部的层部件。gpu只在某些层通信。网络的输入是150,528维，网络剩余层的神经元数量由253,440-186,624-64,896-64,896-43,264 - 4096-4096-1000给出</p> 
</blockquote> 
<h3>减少过度拟合 </h3> 
<p>我们的神经网络架构有6000万个参数。尽管ILSVRC的1000个类使每个训练样例对从图像到标签的映射施加10位约束，但事实证明，这不足以在没有相当大的过拟合的情况下学习如此多的参数。下面，我们将描述两种对抗过拟合的主要方法。</p> 
<h4>数据增加</h4> 
<p>减少图像数据过拟合的最简单和最常用的方法是使用<strong>标签保持变换人为地扩大数据集</strong>(例如，[25,4,5])。我们采用了两种不同形式的数据增强，这两种方式都允许用很少的计算从原始图像生成转换后的图像，因此转换后的图像不需要存储在磁盘上。</p> 
<p>在我们的实现中，转换后的图像是在CPU上用Python代码生成的，而GPU在前一批图像上进行训练。所以这些数据增强方案实际上是不需要计算的。</p> 
<p>第一种形式的数据增强包括生成图像平移和水平反射。我们通过从256×256图像中提取随机的224 × 224块补丁(及其水平反射)并在这些提取的补丁上训练我们的网络4来做到这一点。这将我们的训练集的大小增加了2048倍，尽管最终的训练示例当然是高度相互依赖的。如果没有这种方案，我们的网络将遭受严重的过拟合，这将迫使我们使用更小的网络。在测试时，网络通过提取5个224 × 224的补丁(四个角补丁和中心补丁)以及它们的水平反射(总共10个补丁)进行预测，并对网络的softmax层在这10个补丁上的预测进行平均。</p> 
<h4>Dropout</h4> 
<p>结合许多不同模型的预测是一种非常成功的减少测试误差的方法[1,3]，但对于已经需要几天时间来训练的大型神经网络来说，这种方法似乎过于昂贵。然而，有一种非常有效的模型组合版本，在训练期间只需花费大约两倍的成本。最近引入的技术称为“dropout”[10]，<strong>它包括以0.5的概率将每个隐藏神经元的输出设置为零。以这种方式“退出”的神经元不参与正向传递，也不参与反向传播。所以每次输入时，神经网络都会对不同的体系结构进行采样，但所有这些体系结构都共享权重。这种技术减少了神经元复杂的共同适应，因为一个神经元不能依赖于特定的其他神经元的存在。</strong>因此，它被迫学习更多的鲁棒特征，这些特征在与其他神经元的许多不同的随机子集结合时是有用的。在测试时，我们使用所有的神经元，但将它们的输出乘以0.5，这是一个合理的近似值，取由指数多dropout网络产生的预测分布的几何平均值。</p> 
<h3>学习细节</h3> 
<p>我们使用随机梯度下降训练我们的模型，批量大小为128个样本，动量为0.9，权重衰减为0.0005。我们发现这少量的权重衰减对模型的学习很重要。换句话说，这里的权重衰减不仅仅是一个正则化器:它减少了模型的训练误差。</p> 
<p>我们从标准差为0.01的零均值高斯分布初始化每层的权重。我们初始化了第二层、第四层和第五层卷积层以及完全连接的隐藏层中的神经元偏差，其常数为1。这个初始化通过为relu提供正输入来加速学习的早期阶段。我们用常数0初始化其余层中的神经元偏差</p> 
<h3> 结果</h3> 
<h4>定性评估</h4> 
<p><img alt="" height="449" src="https://images2.imgbox.com/97/0d/dd3sxDVn_o.png" width="1103"></p> 
<p> </p> 
<p>在图4的左面板中，我们通过计算其对8个测试图像的前5个预测来定性地评估网络已经学习了什么。请注意，即使是偏离中心的物体，比如左上角的螨虫，也可以被网识别出来。前5个标签中的大多数看起来都是合理的。例如，只有其他种类的猫才被认为是豹的合理标签。在某些情况下(格栅、樱桃)，照片的预期焦点确实存在模糊性。</p> 
<p>探测网络视觉知识的另一种方法是考虑由最后4096维隐藏层的图像引起的特征激活。如果两幅图像产生的特征激活向量具有较小的欧几里得分离，我们可以说神经网络的高层认为它们是相似的。图4显示了来自测试集的5张图像和来自训练集的6张图像，根据这个度量，它们与每一张图像最相似。注意，在像素级别上，检索到的训练图像通常在L2上与第一列中的查询图像不接近。例如，检索到的狗和大象以各种姿势出现。我们在补充材料中给出了更多测试图像的结果</p> 
<h3>讨论</h3> 
<p>我们的研究结果表明，一个大型的深度卷积神经网络能够在一个高度具有挑战性的数据集上使用纯监督学习取得破纪录的结果。值得注意的是，如果移除单个卷积层，我们的网络性能会下降。例如，删除任何中间层都会导致网络的前1性能损失约2%。所以深度对于实现我们的结果非常重要。</p> 
<p>为了简化我们的实验，我们没有使用任何无监督的预训练，即使我们期望它会有所帮助，特别是如果我们获得足够的计算能力来显着增加网络的大小，而不获得相应的标记数据量的增加。到目前为止，我们的结果已经有所改善，因为我们使我们的网络更大，训练的时间更长，但我们仍然有很多数量级的工作要做，以匹配人类视觉系统的下颞通道。最终，我们希望在视频序列上使用非常大且深度的卷积网络，其中时间结构提供了非常有用的信息，而这些信息在静态图像中是缺失的或不太明显的。</p> 
<hr> 
<h3>自己的想法</h3> 
<p>主要贡献：Relu的出现，5个卷积层和3个全连接层的使用，dropout防止过拟合</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/02bcbc1f5298621f2d9c3768f5705bdb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Unity WebGL&#43;jslib实现与js通信（例.图片下载）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/37e1aadb16b801d13aa09951f6a7867b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python入门自学进阶-Web框架——38、redis、rabbitmq、git</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>