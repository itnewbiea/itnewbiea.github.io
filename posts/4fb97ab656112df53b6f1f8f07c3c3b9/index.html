<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>面试官：SPA（单页应用）首屏加载速度慢怎么解决？ - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="面试官：SPA（单页应用）首屏加载速度慢怎么解决？" />
<meta property="og:description" content="一、什么是首屏加载
首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容
首屏加载可以说是用户体验中最重要的环节
关于计算首屏时间 利用performance.timing提供的数据：
通过DOMContentLoad或者performance来计算出首屏时间
// 方案一： document.addEventListener(&#39;DOMContentLoaded&#39;, (event) =&gt; { console.log(&#39;first contentful painting&#39;); }); // 方案二： performance.getEntriesByName(&#34;first-contentful-paint&#34;)[0].startTime // performance.getEntriesByName(&#34;first-contentful-paint&#34;)[0] // 会返回一个 PerformancePaintTiming的实例，结构如下： { name: &#34;first-contentful-paint&#34;, entryType: &#34;paint&#34;, startTime: 507.80000002123415, duration: 0, }; 二、加载慢的原因 在页面渲染的过程，导致加载速度慢的因素可能如下：
网络延时问题
资源文件体积是否过大
资源是否重复发送请求去加载了
加载脚本的时候，渲染内容堵塞了
三、解决方案 常见的几种SPA首屏优化方式
减小入口文件积
静态资源本地缓存
UI框架按需加载
图片资源的压缩
组件重复打包
开启GZip压缩
使用SSR
减小入口文件体积 常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加
在vue-router配置路由的时候，采用动态加载路由的形式
routes:[ path: &#39;Blogs&#39;, name: &#39;ShowBlogs&#39;, component: () =&gt; import(&#39;./components/ShowBlogs.vue&#39;) ] 以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件
静态资源本地缓存 后端返回资源问题：
采用HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头
采用Service Worker离线缓存" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4fb97ab656112df53b6f1f8f07c3c3b9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-04T08:41:00+08:00" />
<meta property="article:modified_time" content="2020-12-04T08:41:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">面试官：SPA（单页应用）首屏加载速度慢怎么解决？</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align: left"><img src="https://images2.imgbox.com/c6/31/OHMGKbeP_o.png"></p> 
 <h3>一、什么是首屏加载<br></h3> 
 <p>首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容</p> 
 <p>首屏加载可以说是用户体验中<strong>最重要</strong>的环节</p> 
 <h4>关于计算首屏时间</h4> 
 <p>利用<code>performance.timing</code>提供的数据：</p> 
 <img src="https://images2.imgbox.com/62/5f/uNdihiYy_o.png"> 
 <p>通过<code>DOMContentLoad</code>或者<code>performance</code>来计算出首屏时间</p> 
 <pre class="has"><code class="language-go">// 方案一：
document.addEventListener('DOMContentLoaded', (event) =&gt; {
    console.log('first contentful painting');
});
// 方案二：
performance.getEntriesByName("first-contentful-paint")[0].startTime

// performance.getEntriesByName("first-contentful-paint")[0]
// 会返回一个 PerformancePaintTiming的实例，结构如下：
{
  name: "first-contentful-paint",
  entryType: "paint",
  startTime: 507.80000002123415,
  duration: 0,
};
</code></pre> 
 <h3>二、加载慢的原因</h3> 
 <p>在页面渲染的过程，导致加载速度慢的因素可能如下：</p> 
 <ul><li><p>网络延时问题</p></li><li><p>资源文件体积是否过大</p></li><li><p>资源是否重复发送请求去加载了</p></li><li><p>加载脚本的时候，渲染内容堵塞了</p></li></ul> 
 <h3>三、解决方案</h3> 
 <p>常见的几种SPA首屏优化方式</p> 
 <ul><li><p>减小入口文件积</p></li><li><p>静态资源本地缓存</p></li><li><p>UI框架按需加载</p></li><li><p>图片资源的压缩</p></li><li><p>组件重复打包</p></li><li><p>开启GZip压缩</p></li><li><p>使用SSR</p></li></ul> 
 <h4>减小入口文件体积</h4> 
 <p>常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加</p> 
 <img src="https://images2.imgbox.com/da/d9/6HNzU9r2_o.png"> 
 <p>在<code>vue-router</code>配置路由的时候，采用动态加载路由的形式</p> 
 <pre class="has"><code class="language-go">routes:[ 
    path: 'Blogs',
    name: 'ShowBlogs',
    component: () =&gt; import('./components/ShowBlogs.vue')
]
</code></pre> 
 <p>以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件</p> 
 <h4>静态资源本地缓存</h4> 
 <p>后端返回资源问题：</p> 
 <ul><li><p>采用<code>HTTP</code>缓存，设置<code>Cache-Control</code>，<code>Last-Modified</code>，<code>Etag</code>等响应头</p></li><li><p>采用<code>Service Worker</code>离线缓存</p></li></ul> 
 <p>前端合理利用<code>localStorage</code></p> 
 <h4>UI框架按需加载</h4> 
 <p>在日常使用<code>UI</code>框架，例如<code>element-UI</code>、或者<code>antd</code>，我们经常性直接饮用整个<code>UI</code>库</p> 
 <pre class="has"><code class="language-go">import ElementUI from 'element-ui'
Vue.use(ElementUI)
</code></pre> 
 <p>但实际上我用到的组件只有按钮，分页，表格，输入与警告 所以我们要按需引用</p> 
 <pre class="has"><code class="language-go">import { Button, Input, Pagination, Table, TableColumn, MessageBox } from 'element-ui';
Vue.use(Button)
Vue.use(Input)
Vue.use(Pagination)
</code></pre> 
 <h4>组件重复打包</h4> 
 <p>假设<code>A.js</code>文件是一个常用的库，现在有多个路由使用了<code>A.js</code>文件，这就造成了重复下载</p> 
 <p>解决方案：在<code>webpack</code>的<code>config</code>文件中，修改<code>CommonsChunkPlugin</code>的配置</p> 
 <pre class="has"><code class="language-go">minChunks: 3
</code></pre> 
 <p><code>minChunks</code>为3表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件</p> 
 <h4>图片资源的压缩</h4> 
 <p>图片资源虽然不在编码过程中，但它却是对页面性能影响最大的因素</p> 
 <p>对于所有的图片资源，我们可以进行适当的压缩</p> 
 <p>对页面上使用到的<code>icon</code>，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻<code>http</code>请求压力。</p> 
 <h4>开启GZip压缩</h4> 
 <p>拆完包之后，我们再用<code>gzip</code>做一下压缩 安装<code>compression-webpack-plugin</code></p> 
 <pre class="has"><code class="language-go">cnmp i compression-webpack-plugin -D
</code></pre> 
 <p>在<code>vue.congig.js</code>中引入并修改<code>webpack</code>配置</p> 
 <pre class="has"><code class="language-go">const CompressionPlugin = require('compression-webpack-plugin')

configureWebpack: (config) =&gt; {
        if (process.env.NODE_ENV === 'production') {
            // 为生产环境修改配置...
            config.mode = 'production'
            return {
                plugins: [new CompressionPlugin({
                    test: /\.js$|\.html$|\.css/, //匹配文件名
                    threshold: 10240, //对超过10k的数据进行压缩
                    deleteOriginalAssets: false //是否删除原文件
                })]
            }
        }
</code></pre> 
 <p>在服务器我们也要做相应的配置 如果发送请求的浏览器支持<code>gzip</code>，就发送给它<code>gzip</code>格式的文件 我的服务器是用<code>express</code>框架搭建的 只要安装一下<code>compression</code>就能使用</p> 
 <pre class="has"><code class="language-go">const compression = require('compression')
app.use(compression())  // 在其他中间件使用之前调用
</code></pre> 
 <h4>使用SSR</h4> 
 <p>SSR（Server side ），也就是服务端渲染，组件或页面通过服务器生成html字符串，再发送到浏览器</p> 
 <p>从头搭建一个服务端渲染是很复杂的，<code>vue</code>应用建议使用<code>Nuxt.js</code>实现服务端渲染</p> 
 <h4>小结：</h4> 
 <p>减少首屏渲染时间的方法有很多，总的来讲可以分成两大部分 ：资源加载优化 和 页面渲染优化</p> 
 <p>下图是更为全面的首屏优化的方案</p> 
 <img src="https://images2.imgbox.com/f3/21/jMatlP2T_o.png"> 
 <p>大家可以根据自己项目的情况选择各种方式进行首屏渲染的优化</p> 
 <h3>参考文献</h3> 
 <ul><li><p>https://zhuanlan.zhihu.com/p/88639980?utm_source=wechat_session</p></li><li><p>https://www.chengrang.com/how-browsers-work.html</p></li><li><p>https://juejin.cn/post/6844904185264095246</p></li><li><p>https://vue3js.cn/docs/zh</p></li></ul> 
 <p style="text-align: left">面试官VUE系列总进度：8／33</p> 
 <p style="text-align: left"><a href="http://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw%3D%3D&amp;chksm=fc10c093cb674985ef3bd2966f66fc28c5eb70b0037e4be1af4bf54fb6fa9571985abd31d52f&amp;idx=1&amp;mid=2247484101&amp;scene=21&amp;sn=83b0983f0fca7d7c556e4cb0bff8c9b8#wechat_redirect" rel="nofollow">面试官：说说你对vue的理解?</a><br></p> 
 <p style="text-align: left"><a href="http://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw%3D%3D&amp;chksm=fc10c081cb6749976814aaeda6a6433db418223cec57edda7e15b9e5a0ca69ad549655639c61&amp;idx=1&amp;mid=2247484119&amp;scene=21&amp;sn=d171b28a00d42549d279498944a98519#wechat_redirect" rel="nofollow">面试官：说说你对SPA（单页应用）的理解?</a></p> 
 <p style="text-align: left"><a href="http://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw%3D%3D&amp;chksm=fc10c151cb6748476008dab2f4e6c6264f5d19678305955c85cec1b619e56e8f7457b7357fb9&amp;idx=1&amp;mid=2247484167&amp;scene=21&amp;sn=7b00b4333ab2722f25f12586b70667ca#wechat_redirect" rel="nofollow">面试官：说说你对双向绑定的理解?</a><br></p> 
 <p style="text-align: left"><a href="http://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw%3D%3D&amp;chksm=fc10c146cb67485015f24f7e9f5862c4c685fc33485fe30e1b375a534b4031978439c554e0c0&amp;idx=1&amp;mid=2247484176&amp;scene=21&amp;sn=5623421ed2678046ed9e438aadf6e26f#wechat_redirect" rel="nofollow">面试官：说说你对Vue生命周期的理解?</a><br></p> 
 <p style="text-align: left"><a href="http://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw%3D%3D&amp;chksm=fc10c116cb674800b2757be9eb27fe20709de0e511b834d8bb6b23171218fa4a1cfd5f87596c&amp;idx=1&amp;mid=2247484224&amp;scene=21&amp;sn=3043891f60d99afcf74dffd6b9b51ff7#wechat_redirect" rel="nofollow">面试官：Vue组件间通信方式都有哪些?</a><br></p> 
 <p style="text-align: left"><a href="http://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw%3D%3D&amp;chksm=fc10c113cb674805626c614b617491b5e6f7b0050f83106a8a9cd1e640eb8526d43eee01c716&amp;idx=1&amp;mid=2247484229&amp;scene=21&amp;sn=538d5c37cd91c3a2f9431f8fd120fc90#wechat_redirect" rel="nofollow">面试官：Vue中的v-show和v-if怎么理解？</a><br></p> 
 <p style="text-align: left"><a href="http://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw%3D%3D&amp;chksm=fc10c130cb674826510f82810856ca589c5b73b8e1385f179b9ba2bc8bab89bb1db3ff6e53ed&amp;idx=1&amp;mid=2247484262&amp;scene=21&amp;sn=cf0928603e7cf14189b4328366f70836#wechat_redirect" rel="nofollow">面试官：为什么Vue中的v-if和v-for不建议一起用?</a><br></p> 
 <img src="https://images2.imgbox.com/e2/65/ZWGuxQQA_o.png"> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/be331be0022ca369998cb87cb2afccb5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python集合中的元素是否可以重复_python中集合中的元素是否可以重复</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9aa560993763b175edf0ff2f5f8540fe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">适合 JS 新手学习的开源项目——在 GitHub 学编程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>