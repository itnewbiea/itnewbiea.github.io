<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Langchain-Chatchat开源库使用的随笔记（一） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Langchain-Chatchat开源库使用的随笔记（一）" />
<meta property="og:description" content="CSDN越来越不好用了，
降低CSDN发文，本篇后续持续更新会在：
Langchain-Chatchat开源库使用的随笔记
https://zhuanlan.zhihu.com/p/676061269
笔者最近在研究Langchain-Chatchat，所以本篇作为随笔记进行记录。
最近核心探索的是知识库的使用，其中关于文档如何进行分块的详细，可以参考笔者的另几篇文章：
大模型RAG 场景、数据、应用难点与解决（四）RAG 分块Chunk技术优劣、技巧、方法汇总（五） 原项目地址：
Langchain-ChatchatWIKI教程（有点简单） 1 Chatchat项目结构 整个结构是server 启动API，然后项目内自行调用API。
API详情可见：http://xxx:7861/docs ，整个代码架构还是蛮适合深入学习
2 Chatchat一些代码学习 2.1 12个分块函数统一使用 截止 20231231 笔者看到chatchat一共有12个分chunk的函数
这12个函数如何使用、大致点评可以参考笔者的另外文章（RAG 分块Chunk技术优劣、技巧、方法汇总（五））：
CharacterTextSplitter LatexTextSplitter MarkdownHeaderTextSplitter MarkdownTextSplitter NLTKTextSplitter PythonCodeTextSplitter RecursiveCharacterTextSplitter SentenceTransformersTokenTextSplitter SpacyTextSplitter AliTextSplitter ChineseRecursiveTextSplitter ChineseTextSplitter 借用chatchat项目中的test/custom_splitter/test_different_splitter.py来看看一起调用make_text_splitter函数：
from langchain import document_loaders from server.knowledge_base.utils import make_text_splitter # 使用DocumentLoader读取文件 filepath = &#34;knowledge_base/samples/content/test_files/test.txt&#34; loader = document_loaders.UnstructuredFileLoader(filepath, autodetect_encoding=True) docs = loader.load() CHUNK_SIZE = 250 OVERLAP_SIZE = 50 splitter_name = &#39;AliTextSplitter&#39; text_splitter = make_text_splitter(splitter_name, CHUNK_SIZE, OVERLAP_SIZE) if splitter_name == &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ed710a3879923a1b969f0376c6cbd1ef/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-04T16:34:05+08:00" />
<meta property="article:modified_time" content="2024-01-04T16:34:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Langchain-Chatchat开源库使用的随笔记（一）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>CSDN越来越不好用了，<br> 降低CSDN发文，本篇后续持续更新会在：<br> Langchain-Chatchat开源库使用的随笔记<br> https://zhuanlan.zhihu.com/p/676061269</p> 
</blockquote> 
<p>笔者最近在研究Langchain-Chatchat，所以本篇作为随笔记进行记录。<br> 最近核心探索的是知识库的使用，其中关于文档如何进行分块的详细，可以参考笔者的另几篇文章：</p> 
<ul><li><a href="https://zhuanlan.zhihu.com/p/673465732" rel="nofollow">大模型RAG 场景、数据、应用难点与解决（四）</a></li><li><a href="https://zhuanlan.zhihu.com/p/673906072" rel="nofollow">RAG 分块Chunk技术优劣、技巧、方法汇总（五）</a></li></ul> 
<p>原项目地址：</p> 
<ul><li><a href="https://github.com/chatchat-space/Langchain-Chatchat">Langchain-Chatchat</a></li><li><a href="https://github.com/chatchat-space/Langchain-Chatchat/wiki/">WIKI教程（有点简单）</a></li></ul> 
<p><img src="https://images2.imgbox.com/0f/59/a5kz3aSH_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="1_Chatchat_20"></a>1 Chatchat项目结构</h2> 
<p>整个结构是<code>server</code> 启动API，然后项目内自行调用API。<br> API详情可见：<code>http://xxx:7861/docs</code> ，整个代码架构还是蛮适合深入学习</p> 
<p><img src="https://images2.imgbox.com/ed/44/jznqaFeH_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="2_Chatchat_28"></a>2 Chatchat一些代码学习</h2> 
<h3><a id="21_12_29"></a>2.1 12个分块函数统一使用</h3> 
<p>截止 20231231 笔者看到chatchat一共有12个分chunk的函数<br> 这12个函数如何使用、大致点评可以参考笔者的另外文章（<a href="https://zhuanlan.zhihu.com/p/673906072" rel="nofollow">RAG 分块Chunk技术优劣、技巧、方法汇总（五）</a>）：</p> 
<pre><code>CharacterTextSplitter
LatexTextSplitter
MarkdownHeaderTextSplitter
MarkdownTextSplitter
NLTKTextSplitter
PythonCodeTextSplitter
RecursiveCharacterTextSplitter
SentenceTransformersTokenTextSplitter
SpacyTextSplitter

AliTextSplitter
ChineseRecursiveTextSplitter
ChineseTextSplitter
</code></pre> 
<p>借用chatchat项目中的<code>test/custom_splitter/test_different_splitter.py</code>来看看一起调用<code>make_text_splitter</code>函数：</p> 
<pre><code>
from langchain import document_loaders
from server.knowledge_base.utils import make_text_splitter

# 使用DocumentLoader读取文件
filepath = "knowledge_base/samples/content/test_files/test.txt"
loader = document_loaders.UnstructuredFileLoader(filepath, autodetect_encoding=True)
docs = loader.load()

CHUNK_SIZE = 250
OVERLAP_SIZE = 50

splitter_name = 'AliTextSplitter'
text_splitter = make_text_splitter(splitter_name, CHUNK_SIZE, OVERLAP_SIZE)
if splitter_name == "MarkdownHeaderTextSplitter":
    docs = text_splitter.split_text(docs[0].page_content)
    for doc in docs:
        if doc.metadata:
            doc.metadata["source"] = os.path.basename(filepath)
else:
    docs = text_splitter.split_documents(docs)
for doc in docs:
    print(doc)

</code></pre> 
<h3><a id="22_Chat_77"></a>2.2 知识库问答Chat的使用</h3> 
<p>本节参考chatchat开源项目的<code>tests\api\test_stream_chat_api_thread.py</code> 以及 <code>tests\api\test_stream_chat_api.py</code><br> 来探索一下知识库问答调用，包括：</p> 
<ul><li>流式调用</li><li>单次调用</li><li>多线程并发调用</li></ul> 
<h4><a id="221__84"></a>2.2.1 流式调用</h4> 
<pre><code>import requests
import json
import sys

api_base_url = 'http://0.0.0.0:7861'

api="/chat/knowledge_base_chat"
url = f"{api_base_url}{api}"


headers = {
    'accept': 'application/json',
    'Content-Type': 'application/json',
}


data = {
    "query": "如何提问以获得高质量答案",
    "knowledge_base_name": "ZWY_V2_m3e-large",
    "history": [
        {
            "role": "user",
            "content": "你好"
        },
        {
            "role": "assistant",
            "content": "你好，我是 ChatGLM"
        }
    ],
    "stream": True
}
# dump_input(data, api)
response = requests.post(url, headers=headers, json=data, stream=True)
print("\n")
print("=" * 30 + api + "  output" + "="*30)
for line in response.iter_content(None, decode_unicode=True):
    data = json.loads(line)
    if "answer" in data:
        print(data["answer"], end="", flush=True)
pprint(data)
assert "docs" in data and len(data["docs"]) &gt; 0
assert response.status_code == 200

&gt;&gt;&gt;==============================/chat/knowledge_base_chat  output==============================
 你好！提问以获得高质量答案，以下是一些建议：

1. 尽可能清晰明确地表达问题：确保你的问题表述清晰、简洁、明确，以便我能够准确理解你的问题并给出恰当的回答。
2. 提供足够的上下文信息：提供相关的背景信息和上下文，以便我能够更好地理解你的问题，并给出更准确的回答。
3. 使用简洁的语言：尽量使用简单、明了的语言，以便我能够快速理解你的问题。
4. 避免使用缩写和俚语：避免使用缩写和俚语，以便我能够准确理解你的问题。
5. 分步提问：如果问题比较复杂，可以分步提问，这样我可以逐步帮助你解决问题。
6. 检查你的问题：在提问之前，请检查你的问题是否完整、清晰且准确。
7. 提供反馈：如果你对我的回答不满意，请提供反馈，以便我改进我的回答。

希望这些建议能帮助你更好地提问，获得高质量的答案。

</code></pre> 
<p>结构也比较简单，call 知识库问答的URL，然后返回，通过<code>response.iter_content</code>来进行流式反馈。</p> 
<h4><a id="222___146"></a>2.2.2 正常调用以及处理并发</h4> 
<pre><code>import requests
import json
import sys

api_base_url = 'http://0.0.0.0:7861'

api="/chat/knowledge_base_chat"
url = f"{api_base_url}{api}"


headers = {
    'accept': 'application/json',
    'Content-Type': 'application/json',
}


data = {
    "query": "如何提问以获得高质量答案",
    "knowledge_base_name": "ZWY_V2_m3e-large",
    "history": [
        {
            "role": "user",
            "content": "你好"
        },
        {
            "role": "assistant",
            "content": "你好，我是 ChatGLM"
        }
    ],
    "stream": True
}

# 正常调用并存储结果
result = []
response = requests.post(url, headers=headers, json=data, stream=True)

for line in response.iter_content(None, decode_unicode=True):
    data = json.loads(line)
    result.append(data)

answer = ''.join([r['answer'] for r in result[:-1]]) # 正常的结果
&gt;&gt;&gt; ' 你好，很高兴为您提供帮助。以下是一些提问技巧，可以帮助您获得高质量的答案：\n\n1. 尽可能清晰明确地表达问题：确保您的问题准确、简洁、明确，以便我可以更好地理解您的问题并为您提供最佳答案。\n2. 提供足够的上下文信息：提供相关的背景信息和上下文，以便我更好地了解您的问题，并能够更准确地回答您的问题。\n3. 使用简洁的语言：尽量使用简单、明了的语言，以便我能够更好地理解您的问题。\n4. 避免使用缩写和俚语：尽量使用标准语言，以确保我能够正确理解您的问题。\n5. 分步提问：如果您有一个复杂的问题，可以将其拆分成几个简单的子问题，这样我可以更好地回答每个子问题。\n6. 检查您的拼写和语法：拼写错误和语法错误可能会使我难以理解您的问题，因此请检查您的提问，以确保它们是正确的。\n7. 指定问题类型：如果您需要特定类型的答案，请告诉我，例如数字、列表或步骤等。\n\n希望这些技巧能帮助您获得高质量的答案。如果您有其他问题，请随时问我。'

refer_doc = result[-1] # 参考文献
&gt;&gt;&gt; {'docs': ["&lt;span style='color:red'&gt;未找到相关文档,该回答为大模型自身能力解答！&lt;/span&gt;"]}

</code></pre> 
<p>然后来看一下并发：</p> 
<pre><code>
# 并发调用
def knowledge_chat(api="/chat/knowledge_base_chat"):
    url = f"{api_base_url}{api}"
    data = {
        "query": "如何提问以获得高质量答案",
        "knowledge_base_name": "samples",
        "history": [
            {
                "role": "user",
                "content": "你好"
            },
            {
                "role": "assistant",
                "content": "你好，我是 ChatGLM"
            }
        ],
        "stream": True
    }
    result = []
    response = requests.post(url, headers=headers, json=data, stream=True)

    for line in response.iter_content(None, decode_unicode=True):
        data = json.loads(line)
        result.append(data)
    
    return result

from concurrent.futures import ThreadPoolExecutor, as_completed
import time

threads = []
times = []
pool = ThreadPoolExecutor()
start = time.time()
for i in range(10):
    t = pool.submit(knowledge_chat)
    threads.append(t)

for r in as_completed(threads):
    end = time.time()
    times.append(end - start)
    print("\nResult:\n")
    pprint(r.result())

print("\nTime used:\n")
for x in times:
    print(f"{x}")

</code></pre> 
<p>通过concurrent的<code>ThreadPoolExecutor</code>, <code> as_completed</code>进行反馈</p> 
<hr> 
<h2><a id="3__253"></a>3 知识库相关实践问题</h2> 
<h3><a id="31_md__254"></a>3.1 .md格式的文件 支持非常差</h3> 
<p>我们在<code>configs/kb_config.py</code>可以看到：</p> 
<pre><code># TextSplitter配置项，如果你不明白其中的含义，就不要修改。
text_splitter_dict = {
    "ChineseRecursiveTextSplitter": {
        "source": "huggingface",   # 选择tiktoken则使用openai的方法
        "tokenizer_name_or_path": "",
    },
    "SpacyTextSplitter": {
        "source": "huggingface",
        "tokenizer_name_or_path": "gpt2",
    },
    "RecursiveCharacterTextSplitter": {
        "source": "tiktoken",
        "tokenizer_name_or_path": "cl100k_base",
    },
    "MarkdownHeaderTextSplitter": {
        "headers_to_split_on":
            [
                ("#", "head1"),
                ("##", "head2"),
                ("###", "head3"),
                ("####", "head4"),
            ]
    },
}

# TEXT_SPLITTER 名称
TEXT_SPLITTER_NAME = "ChineseRecursiveTextSplitter"
</code></pre> 
<p>chatchat看上去创建新知识库的时候，仅支持一个知识库一个<code>TEXT_SPLITTER_NAME</code> 的方法，并不能做到不同的文件，使用不同的切块模型。<br> 所以如果要一个知识库内，不同文件使用不同的切分方式，需要自己改整个结构代码；然后重启项目</p> 
<p>同时，chatchat项目对markdown的源文件，支持非常差，我们来看看：</p> 
<pre><code>from langchain import document_loaders
from server.knowledge_base.utils import make_text_splitter

# 载入
filepath = "matt/智能XXX.md"
loader = document_loaders.UnstructuredFileLoader(filepath,autodetect_encoding=True)
docs = loader.load()

# 切分
splitter_name = 'ChineseRecursiveTextSplitter'
text_splitter = make_text_splitter(splitter_name, CHUNK_SIZE, OVERLAP_SIZE)
if splitter_name == "MarkdownHeaderTextSplitter":
    docs = text_splitter.split_text(docs[0].page_content)
    for doc in docs:
        if doc.metadata:
            doc.metadata["source"] = os.path.basename(filepath)
else:
    docs = text_splitter.split_documents(docs)
for doc in docs:
    print(doc)


</code></pre> 
<p>首先chatchat对.md文件读入使用的是<code>UnstructuredFileLoader</code>，但是没有加<code>mode="elements"</code>（参考：<a href="https://zhuanlan.zhihu.com/p/624812261" rel="nofollow">LangChain:万能的非结构化文档载入详解（一）</a>）<br> 所以，你可以认为，读入后，<code>#</code>会出现丢失，于是你即使选择了<code>MarkdownHeaderTextSplitter</code>，也还是无法使用。<br> 目前来看，不建议上传<code>.md</code>格式的文档，比较好的方法是：</p> 
<ul><li>文件改成 doc，可以带<code>#</code> / <code>##</code> / <code>###</code></li><li>更改<code>configs/kb_config.py</code>当中的<code>TEXT_SPLITTER_NAME = "MarkdownHeaderTextSplitter"</code></li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e949c7662d1ce4c624ec9ea3fa600bd1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【大数据（一）】hadoop2.4.1集群搭建(重点)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4a49425c3265cc6f074eb15fbcec9e66/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">msvcr120.dll丢失怎样修复，教你msvcr120.dll丢失的解决办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>