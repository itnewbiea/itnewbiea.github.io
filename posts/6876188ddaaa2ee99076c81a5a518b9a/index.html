<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一文聊聊Node.js中的EventEmitter模块 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一文聊聊Node.js中的EventEmitter模块" />
<meta property="og:description" content="EventEmitter是 Node.js 的内置模块，为我们提供了事件订阅机制。下面本篇文章就来带大家了解一下Node.js中的EventEmitter模块，介绍一下它的用法，希望对大家有所帮助！
EventEmitter 的使用 EventEmitter 为我们提供了事件订阅机制，通过引入 events 模块来使用它。
const {EventEmitter} = require(&#34;events&#34;); const eventEmitter = new EventEmitter(); // 监听 data 事件 eventEmitter.on(&#34;data&#34;, () =&gt; { console.log(&#34;data&#34;); }); // 触发 data 事件 eventEmitter.emit(&#34;data&#34;); 上述代码我们使用 on 方法来为事件绑定回调函数，使用 emit 方法来触发一个事件。
on、addListener 我们可以通过 on 和 addListener 方法来为某事件添加一个监听器，二者的使用是一样
eventEmitter.on(&#34;data&#34;, () =&gt; { console.log(&#34;data&#34;); }); eventEmitter.addListener(&#34;data&#34;, () =&gt; { console.log(&#34;data&#34;); }); 第一个参数为事件名，第二个参数为对应的回调函数，当 EventEmitter 实例对象调用 emit 触发相应的事件时便会调用该回调函数，如
const {EventEmitter} = require(&#34;events&#34;); const eventEmitter = new EventEmitter(); eventEmitter." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6876188ddaaa2ee99076c81a5a518b9a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-28T10:19:43+08:00" />
<meta property="article:modified_time" content="2022-07-28T10:19:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一文聊聊Node.js中的EventEmitter模块</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>EventEmitter是 <a href="https://www.php.cn/course/list/24.html" rel="nofollow" title="Node.js">Node.js</a> 的内置模块，为我们提供了事件订阅机制。下面本篇文章就来带大家了解一下Node.js中的EventEmitter模块，介绍一下它的用法，希望对大家有所帮助！</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4a/ef/iJMYAhEh_o.jpg"></p> 
<h3>EventEmitter 的使用</h3> 
<p>EventEmitter 为我们提供了事件订阅机制，通过引入 <code>events</code> 模块来使用它。</p> 
<pre><code>const {EventEmitter} = require("events");
const eventEmitter = new EventEmitter();

// 监听 data 事件
eventEmitter.on("data", () =&gt; {
    console.log("data");
});

// 触发 data 事件
eventEmitter.emit("data");</code></pre> 
<p>上述代码我们使用 <code>on</code> 方法来为事件绑定回调函数，使用 <code>emit</code> 方法来触发一个事件。</p> 
<h4>on、addListener</h4> 
<p>我们可以通过 <code>on</code> 和 <code>addListener</code> 方法来为某事件添加一个监听器，二者的使用是一样</p> 
<pre><code>eventEmitter.on("data", () =&gt; {
    console.log("data");
});

eventEmitter.addListener("data", () =&gt; {
    console.log("data");
});</code></pre> 
<p>第一个参数为事件名，第二个参数为对应的回调函数，当 EventEmitter 实例对象调用 <code>emit</code> 触发相应的事件时便会调用该回调函数，如</p> 
<pre><code>const {EventEmitter} = require("events");
const eventEmitter = new EventEmitter();

eventEmitter.on("data", () =&gt; {
    console.log("data");
});

eventEmitter.addListener("data", () =&gt; {
    console.log("data");
});

eventEmitter.emit("data");</code></pre> 
<p>在控制台会打印出两次 <code>data</code></p> 
<pre><code>data
data</code></pre> 
<blockquote> 
 <p>从上面的例子也可以看出，可以为同一事件绑定多个回调函数。</p> 
</blockquote> 
<p>执行顺序</p> 
<p>当使用 <code>on</code> 或 <code>addListener</code> 绑定多个回调函数时，触发的顺序就是添加的顺序，如</p> 
<pre><code>const {EventEmitter} = require("events");
const eventEmitter = new EventEmitter();

eventEmitter.on("data", () =&gt; {
    console.log("data 1");
});

eventEmitter.on("data", () =&gt; {
    console.log("data 2");
});

eventEmitter.on("data", () =&gt; {
    console.log("data 3");
});

eventEmitter.emit("data");</code></pre> 
<p>会在控制台依次打印出</p> 
<pre><code>data 1
data 2
data 3</code></pre> 
<p>重复添加</p> 
<p>并且使用 <code>on</code> 方法绑定事件时，并不会做去重检查</p> 
<pre><code>const {EventEmitter} = require('events');
const eventEmitter = new EventEmitter();

const listener = () =&gt; {
    console.log("lsitener");
}

eventEmitter.on("data", listener);
eventEmitter.on("data", listener);
eventEmitter.emit("data");</code></pre> 
<p>控制台的打印结果为</p> 
<pre><code>lsitener
lsitener</code></pre> 
<p>上面的程序为事件绑定了两次 <code>listener</code> 这个函数，但是内部并不会检查是否已经添加过这个回调函数，然后去重，所以上面在控制台打印出了两次 listener。</p> 
<p>传递参数</p> 
<p>另外回调函数还可以接收参数，参数通过 <code>emit</code> 触发事件时传入，如</p> 
<pre><code>const {EventEmitter} = require("events");
const eventEmitter = new EventEmitter();

eventEmitter.on("data", data =&gt; {
    console.log(data);
});

// 为回调函数传入参数 HelloWorld!
eventEmitter.emit("data", "HelloWorld!");</code></pre> 
<p>上面我们使用 <code>emit</code> 触发事件时，还传递了额外的参数，这个参数会被传递给回调函数。</p> 
<p>同步执行</p> 
<p>另外一个比较关心的问题，事件的触发是同步的还是异步的，我们做一个实验</p> 
<pre><code>const {EventEmitter} = require("events");
const eventEmitter = new EventEmitter();

eventEmitter.on("data", () =&gt; {
    console.log("触发了 data 事件！");
});

console.log("start");
eventEmitter.emit("data");
console.log("end");</code></pre> 
<p>上面我们我们在触发事件前后都向控制台打印了信息，如果触发事件后是异步执行的，那么后面的打印语句就会先执行，否则如果是同步的话，就会先执行事件绑定的回调函数。执行结果如下</p> 
<pre><code>start
触发了 data 事件！
end</code></pre> 
<p>可见事件触发是同步执行的。</p> 
<h4>off、removeListener</h4> 
<p><code>off</code> 与 <code>removeListener</code> 方法的作用同 <code>on</code> 和 <code>addLsitener</code> 的作用是相反的，它们的作用是为某个事件删除对应的回调函数</p> 
<pre><code>const {EventEmitter} = require('events');
const eventEmitter = new EventEmitter();

let listener1 = () =&gt; {
    console.log("listener1");
}
let listener2 = () =&gt; {
    console.log("listener2");
}

eventEmitter.on("data", listener1);
eventEmitter.on("data", listener2);

// 第一次触发，两个回调函数否会执行
eventEmitter.emit("data");

eventEmitter.off("data", listener1);
// 第二次触发，只会执行 listener2
eventEmitter.emit("data");</code></pre> 
<p>控制台打印结果为</p> 
<pre><code>listener1
listener2
listener2</code></pre> 
<p>第一次触发事件时，两个事件都会触发，然后我们为事件删除了 listener1 这个回调函数，所以第二次触发时，只会触发 listener2。</p> 
<blockquote> 
 <p>注意：如果我们使用 <code>on</code> 或者 <code>addListener</code> 绑定的是一个匿名函数，那么便无法通过 <code>off</code> 和 <code>removeListener</code> 去解绑一个回调函数，因为它会通过比较两个函数的引用是否相同来解绑函数的。</p> 
</blockquote> 
<h4>once</h4> 
<p>使用 <code>once</code> 可以绑定一个只执行一次的回调函数，当触发一次之后，该回调函数便自动会被解绑</p> 
<pre><code>const {EventEmitter} = require("events");
const eventEmitter = new EventEmitter();

eventEmitter.once("data", () =&gt; {
    console.log("data");
});

eventEmitter.emit("data");
eventEmitter.emit("data");</code></pre> 
<p>上述代码我们使用 <code>once</code> 为 <code>data</code> 事件绑定了一个回调函数，然后使用 <code>emit</code> 方法触发了两次，因为使用 <code>once</code> 绑定的回调函数只会被触发一次，所以第二次触发，回调函数不会执行，所以在控制台只打印了一次 data。</p> 
<p>另外同 <code>on</code> 绑定的回调函数一样，我们同样可以通过 <code>emit</code> 方法向回调函数传递参数</p> 
<pre><code>const {EventEmitter} = require("events");
const eventEmitter = new EventEmitter();

eventEmitter.once("data", data =&gt; {
    console.log(data);
});

eventEmitter.emit("data", "Hello");</code></pre> 
<p>控制台打印结果</p> 
<pre><code>Hello</code></pre> 
<h4>prependListener、prependOnceListener</h4> 
<p>使用 <code>on</code> 或者 <code>addListener</code> 为事件绑定的回调函数会被根据添加的顺序执行，而使用 <code>prependLsitener</code> 绑定的事件回调函数会在其他回调函数之前执行</p> 
<pre><code>const {EventEmitter} = require('events');
const eventEmitter = new EventEmitter();

eventEmitter.on("data", () =&gt; {
    console.log("on");
});

eventEmitter.prependListener("data", () =&gt; {
    console.log("prepend");
});

eventEmitter.emit("data");</code></pre> 
<p>上述代打我们先用控制台的打印结果为</p> 
<pre><code>prepend
on</code></pre> 
<p><code>prependOnceListener</code> 同 <code>prependListener</code>，不过它绑定的回调函数只会被执行一次</p> 
<pre><code>const {EventEmitter} = require('events');
const eventEmitter = new EventEmitter();

eventEmitter.on("data", () =&gt; {
    console.log("on");
});

eventEmitter.prependOnceListener("data", () =&gt; {
    console.log("prepend once");
});

eventEmitter.emit("data");
eventEmitter.emit("data");</code></pre> 
<p>上面我们使用 <code>prependOnceListener</code> 绑定了一个回调函数，当触发事件时，该回调函数会在其他函数之前执行，并且只会执行一次，所以当第二次我们触发函数时，该回调函数不会执行，控制台打印结果为</p> 
<pre><code>prepend once
on
on</code></pre> 
<h4>removeAllListeners</h4> 
<p><code>removeAllListeners([event])</code> 方法可以删除事件 <code>event</code> 绑定的所有回调函数，如果没有传入 <code>event</code> 参数的话，那么该方法就会删除所有事件绑定的回调函数</p> 
<pre><code>const {EventEmitter} = require('events');
const eventEmitter = new EventEmitter();

eventEmitter.on("data", () =&gt; {
    console.log("data 1");
});

eventEmitter.on("data", () =&gt; {
    console.log("data 2");
});

eventEmitter.emit("data");
eventEmitter.removeAllListeners("data");
eventEmitter.emit("data");</code></pre> 
<p>上面程序为 <code>data</code> 事件绑定了两个回调函数，并且在调用 <code>removeAllListeners</code> 方法之前分别触发了一次 <code>data</code> 事件，第二次触发 <code>data</code> 事件时，不会有任何的回调函数被执行，<code>removeAllListeners</code> 删除了 <code>data</code> 事件绑定的所有回调函数。控制台的打印结果为：</p> 
<pre><code>data 1
data 2</code></pre> 
<h4>eventNames</h4> 
<p>通过 <code>eventNames</code> 方法我们可以知道为哪些事件绑定了回调函数，它返回一个数组</p> 
<pre><code>const {EventEmitter} = require("events");
const eventEmitter = new EventEmitter();

eventEmitter.on("start", () =&gt; {
    console.log("start");
});
eventEmitter.on("end", () =&gt; {
    console.log("end");
});
eventEmitter.on("error", () =&gt; {
    console.log("error");
});

console.log(eventEmitter.eventNames()); // [ 'start', 'end', 'error' ]</code></pre> 
<p>如果我们将某事件的所有回调函数删除后，此时 <code>eventNames</code> 便不会返回该事件了</p> 
<pre><code>eventEmitter.removeAllListeners("error");
console.log(eventEmitter.eventNames()); // [ 'start', 'end' ]</code></pre> 
<h4>listenerCount</h4> 
<p><code>listenerCount</code> 方法可以得到某个事件绑定了多少个回调函数</p> 
<pre><code>const {EventEmitter} = require("events");
const eventEmitter = new EventEmitter();

eventEmitter.on("data", () =&gt; {

});
eventEmitter.on("data", () =&gt; {

});

console.log(eventEmitter.listenerCount("data")); // 2</code></pre> 
<h4>setMaxLsiteners、getMaxListeners</h4> 
<p><code>setMaxListeners</code> 是用来设置最多为每个事件绑定多少个回调函数，但是实际上是可以绑定超过设置的数目的回调函数的，不过当你绑定超过指定数目的回调函数时，会在控制台给出一个警告</p> 
<pre><code>const {EventEmitter} = require("events");
const eventEmitter = new EventEmitter();

// 设置只能为每个回调函数绑定 1 个回调函数
eventEmitter.setMaxListeners(1);

// 为 data 事件绑定了三个回调函数
eventEmitter.on("data", () =&gt; {
    console.log("data 1");
});
eventEmitter.on("data", () =&gt; {
    console.log("data 2");
});
eventEmitter.on("data", () =&gt; {
    console.log("data 3");
});</code></pre> 
<p>运行上述程序，控制台打印结果为</p> 
<pre><code>data 1
data 2
data 3
(node:36928) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. 2 data listeners added to [EventEmitter]. Use emitter.setMaxListeners() to increase limit</code></pre> 
<p>可见事件绑定的三个回调函数都可以被触发，并且在控制台打印出了一条警告信息。</p> 
<p><code>getMaxListeners</code> 是获得能为每个事件绑定多少个回调函数的方法，使用 <code>setMaxListeners</code> 设置的值时多少，返回的值就是多少</p> 
<pre><code>const {EventEmitter} = require("events");
const eventEmitter = new EventEmitter();

eventEmitter.setMaxListeners(1);

console.log(eventEmitter.getMaxListeners()); // 1</code></pre> 
<p>如果没有使用 <code>setMaxLsiteners</code> 进行设置，那么默认能够为每个事件最多绑定 <code>10</code> 个回调函数，可以通过 <code>EventEmitter</code> 的 <code>defaultMaxListeners</code> 属性获得该值</p> 
<pre><code>const {EventEmitter} = require("events");

console.log(EventEmitter.defaultMaxListeners); // 10</code></pre> 
<h4>listeners、rawListeners</h4> 
<p>当我们使用 <code>once</code> 绑定一个回调函数时，不会直接为该事件绑定该函数，而是会使用一个函数包装该函数，这个包装函数称为 <code>wrapper</code>，然后为该事件绑定 <code>wrapper</code> 函数，在 <code>wrapper</code> 函数内部，设定了当执行一次之后将自己解绑的逻辑。</p> 
<p><code>listeners</code> 返回指定事件绑定的回调函数组成的数组，而 <code>rawListeners</code> 也是返回指定事件绑定的回调函数组成的数组，与 <code>listeners</code> 不同的是，对于 <code>once</code> 绑定的回调函数返回的是 <code>wrapper</code>，而不是原生绑定的函数。</p> 
<pre><code>const {EventEmitter} = require("events");
const eventEmitter = new EventEmitter();

eventEmitter.once("data", () =&gt; {
    console.log("once");
})

let fns = eventEmitter.listeners("data");
// once 绑定的函数，不是 wrapper，内部没有解绑的逻辑，所以后面触发 data 事件时还会执行 once 绑定的函数
fns[0]()
eventEmitter.emit("data");</code></pre> 
<p>控制台打印结果为</p> 
<pre><code>once
once</code></pre> 
<p>下面将上面的 <code>listeners</code> 替换为 <code>rawListeners</code></p> 
<pre><code>const {EventEmitter} = require("events");
const eventEmitter = new EventEmitter();

eventEmitter.once("data", () =&gt; {
    console.log("once");
})


let fns = eventEmitter.rawListeners("data");
// 因为返回的是 once 绑定函数的 wrapper，其内部有执行一次后解绑的逻辑
// 所以后面触发事件时 once 绑定的函数不会再执行
fns[0]()
eventEmitter.emit("data");</code></pre> 
<p>控制台的打印结果为</p> 
<pre><code>once</code></pre> 
<h3>实现一个 EventEmitter</h3> 
<p>在这个小节将从零实现一个 EventEmitter，来加深对该模块的理解。首先我们需要准备一个 <code>listeners</code> 来存储所有绑定的回调函数，它是一个 <code>Map</code> 对象，键是事件名，而值是一个数组，数组中保存的是该事件绑定的回调函数。</p> 
<pre><code>class EventEmitter {
    constructor() {
        this.listeners = new Map();
    }
}</code></pre> 
<h4>on、addListener</h4> 
<p>使用 <code>on</code> 绑定回调函数时，我们先判断 <code>Map</code> 集合中是否有为该事件绑定回调函数，如果有取出对应数组，并添加该回调函数进数组，没有则新建一个数组，添加该回调函数，并添加进 <code>Map</code> 集合</p> 
<pre><code>on(event, callback) {
    if(!this.listeners.has(event)) {
        this.listeners.set(event, []);
    }
    let fns = this.listeners.get(event);
    fns.push(callback);
}</code></pre> 
<p><code>addListener</code> 的功能与 <code>on</code> 是一样的，我们直接调用 <code>on</code> 方法即可</p> 
<pre><code>addListener(event, callback) {
    this.on(event, callback);
}</code></pre> 
<h4>emit</h4> 
<p>当我们使用 <code>emit</code> 触发事件时，我们从 <code>Map</code> 取出对应的回调函数组成的数组，然后依次取出函数执行。另外我们还可以通过 <code>emit</code> 传递参数</p> 
<pre><code>emit(event, ...args) {
    if(!this.listeners.has(event)) {
        return;
    }
    let fns = this.listeners.get(event);
    let values = [];
    for(let fn of fns) {
        values.push(fn);
    }
    for (let fn of values) {
        fn(...args);
    }
}</code></pre> 
<blockquote> 
 <p>这里你可能会觉得我写的有点复杂，所以你会觉得直接这么写更好</p> 
 <pre><code>emit(event, ...args) {
    if(!this.listeners.has(event)) {
        return;
    }
    for (let fn of fns) {
        fn(...args);
    }
}</code></pre> 
 <p>一开始我也是这么写的，但是因为 <code>once</code> 绑定的函数它在执行完毕后将自己从数组中移除，并且是同步的，所以在执行循环的时候，数组是在不断变化的，使用上述的方式会使得一些回调函数会被漏掉，所以我才会先将数组中的函数复制到另一个数组，然后遍历这个新的数组，因为 <code>once</code> 绑定的函数它只会删除原数组中的函数，而不会删除新的这个数组，所以新数组的长度在遍历的过程不会改变，也就不会发生漏掉函数未执行的情况。</p> 
</blockquote> 
<h4>prependListener</h4> 
<p>实现 <code>prependListener</code> 的逻辑同 <code>on</code> 一样，不过我们是往数组的最前方添加回调函数</p> 
<pre><code>prependListener(event, callback) {
    if(!this.listeners.has(event)) {
        this.listeners.set(event, []);
    }
    let fns = this.listeners.get(event);
    fns.unshift(callback);
}</code></pre> 
<h4>off、removeListener</h4> 
<p>使用 <code>off</code> 方法是用来解绑事件的，在数组中找到指定的函数，然后删除即可</p> 
<pre><code>off(event, callback) {
    if(!this.listeners.has(event)) {
        return;
    }
    let fns = this.listeners.get(event);
    // 找出数组中的回调函数，然后删除
    for (let i = 0; i &lt; fns.length; i++) {
        if(fns[i] === callback) {
            fns.splice(i, 1);
            break;
        }
    }
    // 如果删除回调函数后，数组为空，则删除该事件
    if (fns.length === 0) {
        this.listeners.delete(event);
    }
}</code></pre> 
<p><code>removeListener</code> 同 <code>off</code> 的作用一样，我们在内部直接调用 <code>off</code> 方法即可</p> 
<pre><code>removeListener(event, callback) {
    this.off(event, callback);
}</code></pre> 
<h4>once、prependOnceListener</h4> 
<p>使用 <code>once</code> 绑定一个只执行一次的函数，所以我们需要将绑定的回调函数使用一个函数包装一下，然后添加进数组中，这个包装函数我们称之为 <code>wrapper</code>。在包装函数中，当执行一遍后会将自己从数组中删除</p> 
<pre><code>once(event, callback) {
    let wrapper = (...args) =&gt; {
        callback(...args);
        this.off(event, wrapper);
    }
    if(!this.listeners.has(event)) {
        this.listeners.set(event, []);
    }
    let fns = this.listeners.get(event);
    fns.push(wrapper);
}</code></pre> 
<p><code>prependOnceListener</code> 的实现同 <code>once</code>，只是向数组的开头插入函数，将上面代码中的 <code>push</code> 换为 <code>unshift</code> 即可</p> 
<pre><code>prependOnceListener(event, callback) {
    let wrapper = (...args) =&gt; {
        callback(...args);
        this.off(event, wrapper);
    }
    if(!this.listeners.has(event)) {
        this.listeners.set(event, []);
    }
    let fns = this.listeners.get(event);
    fns.unshift(wrapper);
}</code></pre> 
<h4>removeAllListeners</h4> 
<p>直接从删除对应的事件，如果没有传入具体事件的话，则需要删除所有的事件</p> 
<pre><code>removeAllListeners(event) {
    // 如果没有传入 event，则删除所有事件
    if (event === undefined) {
        this.listeners = new Map();
        return;
    }
    this.listeners.delete(event);
}</code></pre> 
<h4>eventNames</h4> 
<p>获得已经绑定了哪些事件</p> 
<pre><code>eventNames() {
    return [...this.listeners.keys()];
}</code></pre> 
<h4>listenerCount</h4> 
<p>获得某事件绑定可多少个回调函数</p> 
<pre><code>listenerCount(event) {
    return this.listeners.get(event).length;
}</code></pre> 
<blockquote> 
 <p>上述的实现有一个 bug，那就是无法删除使用 <code>once</code> 绑定的函数，我的想法是使用一个 <code>Map</code> 将 <code>once</code> 绑定的函数同对应的 <code>wrapper</code> 对应，删除时即可根据 <code>once</code> 的回调函数找到对应的 <code>wrapper</code> 然后删除</p> 
 <pre><code>constructor() {
    this.listeners = new Map();
    // 保存 once 的回调函数与对应的 wrapper 
    this.onceToWrapper = new Map();
}

once(event, callback) {
    let wrapper = (...args) =&gt; {
        callback(...args);
        // 删除之前，删除 callback 和 wrapper 的关系
        this.onceToWrapper.delete(callback);
        this.off(event, wrapper);
    }
    if(!this.listeners.has(event)) {
        this.listeners.set(event, []);
    }
    let fns = this.listeners.get(event);
    // 添加之前，绑定 callback 和 wrapper 的关系
    this.onceToWrapper.set(callback, wrapper);
    fns.push(wrapper);
}

prependOnceListener(event, callback) {
    let wrapper = (...args) =&gt; {
        callback(...args);
        // 同上
        this.onceToWrapper.delete(callback);
        this.off(event, wrapper);
    }
    if(!this.listeners.has(event)) {
        this.listeners.set(event, []);
    }
    let fns = this.listeners.get(event);
    // 同上
    this.onceToWrapper.set(callback, wrapper);
    fns.unshift(wrapper);
}

off(event, callback) {
    if(!this.listeners.has(event)) {
        return;
    }
    let fns = this.listeners.get(event);
    // 先从 onceToWrapper 中查找是否有对应的 wrapper，如果有说明是 once 绑定的
    callback = this.onceToWrapper.get(callback) || callback;
    for (let i = 0; i &lt; fns.length; i++) {
        if(fns[i] === callback) {
            fns.splice(i, 1);
            break;
        }
    }
    if (fns.length === 0) {
        this.listeners.delete(event);
    }
}</code></pre> 
 <p></p> 
</blockquote> 
<p>全部代码如下</p> 
<pre><code>class EventEmitter {
    constructor() {
        this.listeners = new Map();
        this.onceToWrapper = new Map();
    }

    on(event, callback) {
        if(!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        let fns = this.listeners.get(event);
        fns.push(callback);
    }

    addListener(event, callback) {
        this.on(event, callback);
    }

    emit(event, ...args) {
        if(!this.listeners.has(event)) {
            return;
        }
        let fns = this.listeners.get(event);
        let values = [];
        for(let fn of fns) {
            values.push(fn);
        }
        for (let fn of values) {
            fn(...args);
        }
    }

    prependListener(event, callback) {
        if(!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        let fns = this.listeners.get(event);
        fns.unshift(callback);
        
    }

    off(event, callback) {
        if(!this.listeners.has(event)) {
            return;
        }
        let fns = this.listeners.get(event);
        callback = this.onceToWrapper.get(callback) || callback;
        for (let i = 0; i &lt; fns.length; i++) {
            if(fns[i] === callback) {
                fns.splice(i, 1);
                break;
            }
        }
        if (fns.length === 0) {
            this.listeners.delete(event);
        }
    }

    removeListener(event, callback) {
        this.off(event, callback);
    }

    once(event, callback) {
        let wrapper = (...args) =&gt; {
            callback(...args);
            this.onceToWrapper.delete(callback);
            this.off(event, wrapper);   
        }
        if(!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        let fns = this.listeners.get(event);
        this.onceToWrapper.set(callback, wrapper);
        fns.push(wrapper);
    }

    prependOnceListener(event, callback) {
        let wrapper = (...args) =&gt; {
            callback(...args);
            this.onceToWrapper.delete(callback);
            this.off(event, wrapper);
        }
        if(!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        let fns = this.listeners.get(event);
        this.onceToWrapper.set(callback, wrapper);
        
        fns.unshift(wrapper);
    }

    removeAllListeners(event) {
        if (event === undefined) {
            this.listeners = new Map();
            return;
        }
        this.listeners.delete(event);
    }

    eventNames() {
        return [...this.listeners.keys()];
    }

    listenerCount(event) {
        return this.listeners.get(event).length;
    }
}</code></pre> 
<p>更多node相关知识，请访问：<a href="https://www.php.cn/course/list/24.html" rel="nofollow" title="nodejs 教程">nodejs 教程</a>！！</p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/33d2c279b3a59691a6a2958c0d89c8a3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">错误 C2733: 不允许重载函数的第二个 C 链接</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d1117c82733eacd6eae71c18c86fbd29/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">导入sql文件到数据库</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>