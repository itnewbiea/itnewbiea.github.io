<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;中volatile的作用 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;中volatile的作用" />
<meta property="og:description" content="代码编译环境：Windows7 32bits&#43;VS2012。
volatile是“易变的”、“不稳定”的意思。volatile是C的一个较为少用的关键字，它用来解决变量在“共享”环境下容易出现读取错误的问题。
1.volatile的作用 定义为volatile的变量是说这变量可能会被意想不到地改变，即在你程序运行过程中一直会变，你希望这个值被正确的处理，每次从内存中去读这个值，而不是因编译器优化从缓存的地方读取，比如读取缓存在寄存器中的数值，从而保证volatile变量被正确的读取。
在单任务的环境中，一个函数体内部，如果在两次读取变量的值之间的语句没有对变量的值进行修改，那么编译器就会设法对可执行代码进行优化。由于访问寄存器的速度要快过RAM（从RAM中读取变量的值到寄存器），以后只要变量的值没有改变，就一直从寄存器中读取变量的值，而不对RAM进行访问。
而在多任务环境中，虽然在一个函数体内部，在两次读取变量之间没有对变量的值进行修改，但是该变量仍然有可能被其他的程序（如中断程序、另外的线程等）所修改。如果这时还是从寄存器而不是从RAM中读取，就会出现被修改了的变量值不能得到及时反应的问题。如下程序对这一现象进行了模拟。
#include &lt;iostream&gt; using namespace std; int main(int argc,char* argv[]) { int i=10; int a=i; cout&lt;&lt;a&lt;&lt;endl; _asm { mov dword ptr [ebp-4],80 } int b=i; cout&lt;&lt;b&lt;&lt;endl; } 123456789101112131415 程序在VS2012环境下生成Release版本，输出结果是：
10 10 12 阅读以上程序，注意以下几个要点： （1）以上代码必须在Release模式下考查，因为只有Release模式下才会对程序代码进行优化，而这种优化在变量共享的环境下容易引发问题。
（2）在语句b=i；之前，已经通过内联汇编代码修改了i的值，但是i的变化却没有反映到b中，如果i是一个被多个任务共享的变量，这种优化带来的错误很可能是致命的。
（3）汇编代码[ebp-4]表示变量i的存储单元，因为ebp是扩展基址指针寄存器，存放函数所属栈的栈底地址，先入栈，占用4个字节。随着函数内申明的局部变量的增多，esp（栈顶指针寄存器）就会相应的减小，因为栈的生长方向由高地址向低地址生长。i为第一个变量，栈空间已被ebp入栈占用了4个字节，所以i的地址为ebp-i，[ebp-i]则表示变量i的存储单元。
那如何抑制编译器对读取变量的这种优化，来防止错误读取呢？volatile可以轻松胜任，将上面的程序稍作修改，将变量i前申明为volatile即可，观察如下程序：
#include &lt;iostream&gt; using namespace std; int main(int argc,char* argv[]) { volatile int i=10; int a=i; cout&lt;&lt;a&lt;&lt;endl; _asm { mov dword ptr [ebp-4],80 } int b=i; cout&lt;&lt;b&lt;&lt;endl; getchar(); } 12345678910111213141516 程序输出结果为： 10 80 也就是说，第二次读取变量i的值的时候，已经获得了变化之后的值。跟踪汇编代码可知，凡是申明为volatile的变量，每次都是从内存中读取变量的值，而不是在某些情况下直接从寄存器中取值。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/038322ccafed7dd0e3d626eb55839614/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-08T14:09:40+08:00" />
<meta property="article:modified_time" content="2018-07-08T14:09:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;中volatile的作用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>代码编译环境：Windows7 32bits+VS2012。</p> 
<p>volatile是“易变的”、“不稳定”的意思。volatile是C的一个较为少用的关键字，它用来解决变量在“共享”环境下容易出现读取错误的问题。</p> 
<h2 id="1volatile的作用">1.volatile的作用</h2> 
<p>定义为volatile的变量是说这变量可能会被意想不到地改变，即在你程序运行过程中一直会变，你希望这个值被正确的处理，每次从内存中去读这个值，而不是因编译器优化从缓存的地方读取，比如读取缓存在寄存器中的数值，从而保证volatile变量被正确的读取。</p> 
<p>在单任务的环境中，一个函数体内部，如果在两次读取变量的值之间的语句没有对变量的值进行修改，那么编译器就会设法对可执行代码进行优化。由于访问寄存器的速度要快过RAM（从RAM中读取变量的值到寄存器），以后只要变量的值没有改变，就一直从寄存器中读取变量的值，而不对RAM进行访问。</p> 
<p>而在多任务环境中，虽然在一个函数体内部，在两次读取变量之间没有对变量的值进行修改，但是该变量仍然有可能被其他的程序（如中断程序、另外的线程等）所修改。如果这时还是从寄存器而不是从RAM中读取，就会出现被修改了的变量值不能得到及时反应的问题。如下程序对这一现象进行了模拟。</p> 
<pre class="prettyprint"><code class="hljs cpp has-numbering"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span>* argv[])
{
    <span class="hljs-keyword">int</span> i=<span class="hljs-number">10</span>;
    <span class="hljs-keyword">int</span> a=i;
    <span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;endl;
    _asm
    {
        mov dword ptr [ebp-<span class="hljs-number">4</span>],<span class="hljs-number">80</span>
    }
    <span class="hljs-keyword">int</span> b=i;
    <span class="hljs-built_in">cout</span>&lt;&lt;b&lt;&lt;endl;
}</code>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li></ul> 
<p>程序在VS2012环境下生成Release版本，输出结果是：</p> 
<pre class="prettyprint"><code class="hljs  has-numbering">10
10</code>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li></ul> 
<p>阅读以上程序，注意以下几个要点： <br> （1）以上代码必须在Release模式下考查，因为只有Release模式下才会对程序代码进行优化，而这种优化在变量共享的环境下容易引发问题。</p> 
<p>（2）在语句b=i；之前，已经通过内联汇编代码修改了i的值，但是i的变化却没有反映到b中，如果i是一个被多个任务共享的变量，这种优化带来的错误很可能是致命的。</p> 
<p>（3）汇编代码[ebp-4]表示变量i的存储单元，因为ebp是扩展基址指针寄存器，存放函数所属栈的栈底地址，先入栈，占用4个字节。随着函数内申明的局部变量的增多，esp（栈顶指针寄存器）就会相应的减小，因为栈的生长方向由高地址向低地址生长。i为第一个变量，栈空间已被ebp入栈占用了4个字节，所以i的地址为ebp-i，[ebp-i]则表示变量i的存储单元。</p> 
<p>那如何抑制编译器对读取变量的这种优化，来防止错误读取呢？volatile可以轻松胜任，将上面的程序稍作修改，将变量i前申明为volatile即可，观察如下程序：</p> 
<pre class="prettyprint"><code class="hljs cpp has-numbering"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span>* argv[])
{
    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">10</span>;
    <span class="hljs-keyword">int</span> a=i;
    <span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;endl;
    _asm
    {
        mov dword ptr [ebp-<span class="hljs-number">4</span>],<span class="hljs-number">80</span>
    }
    <span class="hljs-keyword">int</span> b=i;
    <span class="hljs-built_in">cout</span>&lt;&lt;b&lt;&lt;endl;
    getchar();
}</code>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li></ul> 
<p>程序输出结果为： <br> 10 <br> 80 <br> 也就是说，第二次读取变量i的值的时候，已经获得了变化之后的值。跟踪汇编代码可知，凡是申明为volatile的变量，每次都是从内存中读取变量的值，而不是在某些情况下直接从寄存器中取值。</p> 
<h2 id="2volatile应用场景">2.volatile应用场景</h2> 
<p>（1）并行设备的硬件寄存器（如状态寄存器）。 <br> 假设要对一个设备进行初始化，此设备的某一个寄存器为0xff800000。</p> 
<pre class="prettyprint"><code class="hljs objectivec has-numbering"><span class="hljs-keyword">int</span>  *output = (<span class="hljs-keyword">unsigned</span>  <span class="hljs-keyword">int</span> *)<span class="hljs-number">0xff800000</span>; <span class="hljs-comment">//定义一个IO端口；  </span>
<span class="hljs-keyword">int</span>   init(<span class="hljs-keyword">void</span>)  
{  
      <span class="hljs-keyword">int</span> i;  
      <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt; <span class="hljs-number">10</span>;i++)
      {  
         *output = i;  
      }  
}</code>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li></ul> 
<p>经过编译器优化后，编译器认为前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将output这个指针赋值为 9，所以编译器最后给你编译编译的代码结果相当于：</p> 
<pre class="prettyprint"><code class="hljs cs has-numbering"><span class="hljs-keyword">int</span>  init(<span class="hljs-keyword">void</span>)  
{  
      *output = <span class="hljs-number">9</span>;  
}</code>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li></ul> 
<p>如果你对此外部设备进行初始化的过程是必须是像上面代码一样顺序的对其赋值，显然优化过程并不能达到目的。反之如果你不是对此端口反复写操作，而是反复读操作，其结果是一样的，编译器在优化后，也许你的代码对此地址的读操作只做了一次。然而从代码角度看是没有任何问题的。这时候就该使用volatile通知编译器这个变量是一个不稳定的，在遇到此变量时候不要优化。</p> 
<p>（2）一个中断服务子程序中访问到的变量；</p> 
<pre class="prettyprint"><code class="hljs cs has-numbering"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;

<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
    {
        <span class="hljs-keyword">if</span>(i) dosomething();
    }
}

<span class="hljs-comment">/* Interrupt service routine */</span>
<span class="hljs-keyword">void</span> IRS()
{
    i=<span class="hljs-number">1</span>;
}</code>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li></ul> 
<p>上面示例程序的本意是产生中断时，由中断服务子程序IRS响应中断，变更程序变量i，使在main函数中调用dosomething函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远不会被调用。如果将变量i加上volatile修饰，则编译器保证对变量i的读写操作都不会被优化，从而保证了变量i被外部程序更改后能及时在原程序中得到感知。</p> 
<p>（3）多线程应用中被多个任务共享的变量。 <br> 当多个线程共享某一个变量时，该变量的值会被某一个线程更改，应该用 volatile 声明。作用是防止编译器优化把变量从内存装入CPU寄存器中，当一个线程更改变量后，未及时同步到其它线程中导致程序出错。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。示例如下：</p> 
<pre class="prettyprint"><code class="hljs r has-numbering">volatile  bool bStop=false;  //bStop 为共享全局变量  
//第一个线程
void threadFunc1()
{
    <span class="hljs-keyword">...</span>
    <span class="hljs-keyword">while</span>(!bStop){<!-- --><span class="hljs-keyword">...</span>}
}

//第二个线程终止上面的线程循环
void threadFunc2()
{
    <span class="hljs-keyword">...</span>
    bStop = true;
}</code>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li></ul> 
<p>要想通过第二个线程终止第一个线程循环，如果bStop不使用volatile定义，那么这个循环将是一个死循环，因为bStop已经读取到了寄存器中，寄存器中bStop的值永远不会变成true，加上volatile，程序在执行时，每次均从内存中读出bStop的值，就不会死循环了。</p> 
<p>是否了解volatile的应用场景是区分C/C++程序员和嵌入式开发程序员的有效办法，搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，这些都要求用到volatile变量，不懂得volatile将会带来程序设计的灾难。</p> 
<h2 id="3volatile常见问题">3.volatile常见问题</h2> 
<p>下面的问题可以看一下面试者是不是直正了解volatile。 <br> （1）一个参数既可以是const还可以是volatile吗？为什么？ <br> 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。 </p> 
<p>（2）一个指针可以是volatile吗？为什么？ <br> 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。 </p> 
<p>（3）下面的函数有什么错误？</p> 
<pre class="prettyprint"><code class="hljs perl has-numbering"><span class="hljs-keyword">int</span> square(volatile <span class="hljs-keyword">int</span> <span class="hljs-variable">*ptr</span>) 
{ 
    <span class="hljs-keyword">return</span> <span class="hljs-variable">*ptr</span> * <span class="hljs-variable">*ptr</span>; 
} </code>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li></ul> 
<p>这段代码有点变态，其目的是用来返回指针ptr指向值的平方，但是，由于ptr指向一个volatile型参数，编译器将产生类似下面的代码： </p> 
<pre class="prettyprint"><code class="hljs perl has-numbering"><span class="hljs-keyword">int</span> square(volatile <span class="hljs-keyword">int</span> <span class="hljs-variable">*ptr</span>) 
{ 
    <span class="hljs-keyword">int</span> a,b; 
    a = <span class="hljs-variable">*ptr</span>; 
    b = <span class="hljs-variable">*ptr</span>; 
    <span class="hljs-keyword">return</span> a * b; 
} </code>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li></ul> 
<p>由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返回的不是你所期望的平方值！正确的代码如下： </p> 
<pre class="prettyprint"><code class="hljs livecodeserver has-numbering"><span class="hljs-keyword">long</span> square(volatile int *ptr) 
{ 
    int <span class="hljs-operator">a</span>; 
    <span class="hljs-operator">a</span> = *ptr; 
    <span class="hljs-constant">return</span> <span class="hljs-operator">a</span> * <span class="hljs-operator">a</span>; 
} </code>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li></ul> 
<h2 id="4嵌入式编程中volatile的作用">4.嵌入式编程中volatile的作用</h2> 
<p>嵌入式编程中经常用到 volatile这个关键字，常见用法可以归结为以下两点：</p> 
<p>（1）告诉compiler不能做任何优化。比如要往某一地址送两指令。</p> 
<pre class="prettyprint"><code class="hljs r has-numbering"> int *ip =<span class="hljs-keyword">...</span>;  //设备地址 
 *ip = <span class="hljs-number">1</span>;       //第一个指令 
 *ip = <span class="hljs-number">2</span>;       //第二个指令 </code>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li></ul> 
<p>以上程序compiler可能做优化而成： </p> 
<pre class="prettyprint"><code class="hljs r has-numbering">int *ip = <span class="hljs-keyword">...</span>; 
*ip = <span class="hljs-number">2</span>; </code>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li></ul> 
<p>结果第一个指令丢失。如果用volatile, compiler就不允许做任何的优化，从而保证程序的原意： </p> 
<pre class="prettyprint"><code class="hljs r has-numbering">volatile int *ip = <span class="hljs-keyword">...</span>; 
*ip = <span class="hljs-number">1</span>; 
*ip = <span class="hljs-number">2</span>; </code>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li></ul> 
<p>（2）volatile定义的变量如果在程序外被改变，每次都必须从内存中读取，而不能把他放在cache或寄存器中重复使用。如：</p> 
<pre class="prettyprint"><code class="hljs livecodeserver has-numbering">volatile <span class="hljs-keyword">char</span> <span class="hljs-operator">a</span>;   
<span class="hljs-operator">a</span>=<span class="hljs-number">0</span>; 
<span class="hljs-keyword">while</span>(!<span class="hljs-operator">a</span>)
{ 
     <span class="hljs-comment"> //do some things;   </span>
}   
doother(); </code>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li></ul> 
<p>如果没有 volatile，doother()不会被执行。</p> 
<p>volatile能够避免编译器优化带来的错误，但使用volatile的同时，也需要注意频繁地使用volatile很可能会增加代码尺寸和降低性能，因此要合理的使用volatile。</p> 
<hr> 
<h2 id="参考文献">参考文献：</h2> 
<p>[1] ]陈刚.C++高级进阶教程[M].武汉：武汉大学出版社，2008. <br> [2]<a href="http://www.cnblogs.com/chio/archive/2007/11/24/970632.html" rel="nofollow noopener noreferrer" target="_blank">C中的volatile用法</a> <br> [3]<a href="http://www.360doc.com/content/13/0309/22/9290626_270468335.shtml" rel="nofollow noopener noreferrer" target="_blank">ebp与esp讲解</a> <br> [4]<a href="https://blog.csdn.net/qq_29350001/article/details/54024070" rel="nofollow noopener noreferrer" target="_blank">C语言再学习 – 关键字volatile</a> <br> [5]<a href="https://blog.csdn.net/tigerjibo/article/details/7427366" rel="nofollow noopener noreferrer" target="_blank">C语言中volatile关键字的作用</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d784f4aeef8690c8bb2e999095f5098c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">KD-Tree 初学（模板&#43;HDU 4347）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9241fb53f1452a8019406571d9bf4e6d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pycharm社区版和专业版的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>