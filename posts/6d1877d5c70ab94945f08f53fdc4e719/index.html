<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JavaScript 面向对象详解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JavaScript 面向对象详解" />
<meta property="og:description" content="首先，我肯定是需要你告诉我，什么是面向对象，面向对象有哪些特点，以及这些特点的解释。
JavaScript 如何实现这些特点，比如封装、继承、多态。如果关于上述三点，你能够解释到有多少种实现方式、优缺点是什么。以及近几年流行的解决方案是什么。这就是「加分」 ，比如对于继承吧。类式继承、构造函数继承、组合继承、原型继承、寄生组合继承等等，说出大概的实现思路和优缺点，再介绍下 extends 或者 mixin 的实现甚至你可以衍生到 JavaScript 的模块化发展甚至到为什么现在 TS 如此流行。那么可以说到这一环节解答的就非常棒了。
回答完 JavaScript 的面向对象，是不是可以从此衍生下为什么需要面向对象。以及当先对于软件设计的高内聚、低耦合的思考？来个对此题一个提纲挈领的总结？
综上所述，其实不难看出，越是这种基础且开放的题目，可以是一个陷阱，更可以是一个机会。因为一道题真的可以全方面的感受到应聘的基础是否扎实。
JavaScript 面向对象详解(一) ES6 之前的 JavaScript 面向对象比较不好理解，涉及到很多知识和思想。
ES6 增加了 class 和 extends 来实现类的封装和继承，但是通过 babel 转换成 ES5 之后还是之前的一套逻辑。
这里，我打算用四篇文章，来讲解一下关于 ES5 中面向对象的知识体系，一起学习一下吧！
一. JavaScript 的对象 1.1. 传统对象 vs JavaScript 对象 传统的面向对象
面向对象语言的一个标志就是类类是所有对象的统称, 是更高意义上的一种抽象. 对象是类的实例.通过类我们可以创建任意多个具体的对象.在学习 C&#43;&#43;/OC/Java/Python 等编程语言的时候, 都可以按照这种方式去创建类和对象. JavaScript 的面向对象
JavaScript 中没有类的概念（ES6 之前），因此我们通常称为基于对象，而不是面向对象.虽然 JavaScript 中的基于对象也可以实现类似于类的封装、继承、甚至是多态。但是和传统意义的面向对象还是稍微有一些差异(后面我们会讲解它是如何实现的)ECMA 中定义对象是这样: 无序属性的集合, 属性可以包含基本值, 对象或者函数.也就是对象是一组没有顺序的值组成的集合而已.对象的每个属性或者方法都有一个名字, 而名字对应一个值. 有没有觉得非常熟悉?没错, 其实就是我们经常看到和使用的映射(或者有些语言称为字典, 通常会使用哈希表来实现). 1.2. 简单的方式创建对象 创建自定义对象最简单的方式就是创建一个 Object 实例, 然后添加属性和方法" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6d1877d5c70ab94945f08f53fdc4e719/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-09T15:00:06+08:00" />
<meta property="article:modified_time" content="2022-08-09T15:00:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaScript 面向对象详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>首先，我肯定是需要你告诉我，什么是面向对象，面向对象有哪些特点，以及这些特点的解释。<br> JavaScript 如何实现这些特点，比如封装、继承、多态。如果关于上述三点，你能够解释到有多少种实现方式、优缺点是什么。以及近几年流行的解决方案是什么。这就是「加分」 ，比如对于继承吧。类式继承、构造函数继承、组合继承、原型继承、寄生组合继承等等，说出大概的实现思路和优缺点，再介绍下 extends 或者 mixin 的实现甚至你可以衍生到 JavaScript 的模块化发展甚至到为什么现在 TS 如此流行。那么可以说到这一环节解答的就非常棒了。<br> 回答完 JavaScript 的面向对象，是不是可以从此衍生下为什么需要面向对象。以及当先对于软件设计的高内聚、低耦合的思考？来个对此题一个提纲挈领的总结？<br> 综上所述，其实不难看出，越是这种基础且开放的题目，可以是一个陷阱，更可以是一个机会。因为一道题真的可以全方面的感受到应聘的基础是否扎实。</p> 
</blockquote> 
<h2><a id="JavaScript__5"></a>JavaScript 面向对象详解(一)</h2> 
<p>ES6 之前的 JavaScript 面向对象比较不好理解，涉及到很多知识和思想。</p> 
<p>ES6 增加了 class 和 extends 来实现类的封装和继承，但是通过 babel 转换成 ES5 之后还是之前的一套逻辑。</p> 
<p>这里，我打算用四篇文章，来讲解一下关于 ES5 中面向对象的知识体系，一起学习一下吧！</p> 
<h3><a id="_JavaScript__13"></a>一. JavaScript 的对象</h3> 
<h4><a id="11__vs_JavaScript__15"></a>1.1. 传统对象 vs JavaScript 对象</h4> 
<p>传统的面向对象</p> 
<ul><li>面向对象语言的一个标志就是类</li><li>类是所有对象的统称, 是更高意义上的一种抽象. 对象是类的实例.</li><li>通过类我们可以创建任意多个具体的对象.</li><li>在学习 C++/OC/Java/Python 等编程语言的时候, 都可以按照这种方式去创建类和对象.</li></ul> 
<p>JavaScript 的面向对象</p> 
<ul><li>JavaScript 中没有类的概念（ES6 之前），因此我们通常称为基于对象，而不是面向对象.</li><li>虽然 JavaScript 中的基于对象也可以实现类似于类的封装、继承、甚至是多态。但是和传统意义的面向对象还是稍微有一些差异(后面我们会讲解它是如何实现的)</li><li>ECMA 中定义对象是这样: 无序属性的集合, 属性可以包含基本值, 对象或者函数.</li><li>也就是对象是一组没有顺序的值组成的集合而已.</li><li>对象的每个属性或者方法都有一个名字, 而名字对应一个值. 有没有觉得非常熟悉?</li><li>没错, 其实就是我们经常看到和使用的映射(或者有些语言称为字典, 通常会使用哈希表来实现).</li></ul> 
<h4><a id="12__33"></a>1.2. 简单的方式创建对象</h4> 
<p>创建自定义对象最简单的方式就是创建一个 Object 实例, 然后添加属性和方法</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 1.创建person的对象</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2.给person对象赋值了一些动态的属性和方法</span>
person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'LBJ辉'</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token number">1.88</span><span class="token punctuation">;</span>

person<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Hello, My name is '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 3.调用方法, 查看结果</span>
person<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>代码解析:</p> 
<ul><li>步骤一: 创建一个名为 person 的对象.</li><li>步骤二: 给对象动态的赋值了一些属性包括一个方法</li><li>步骤三: 调用 sayHello()方法, 主要看一下 this.name 会获取到谁呢? LBJ 辉</li></ul> 
<p>插播一个信息: 函数和方法的关系</p> 
<ul><li> <p>很多人在学习编程的时候, 会分不清楚什么是函数, 什么又是方法. 或者在什么情景下称为函数, 什么情景下称为方法.</p> </li><li> <p>首先, 如果你看的是英文文档, 会有明显的区分: Function 被称为函数, Method 被称为方法.</p> </li><li> <p>但是英文中, 为什么需要有这两个称呼呢?</p> </li><li> 
  <ul><li>在早期的编程语言中, 只有函数(类似于数学中函数的称呼)</li><li>后来有了面向对象语言, 面向对象语言中, 类中也可以定义函数. 但是人们为了区分在类中定义的函数, 通常称类中的函数为方法.</li><li>还有一个非常重要的原因是, 通常方法中会携带一个调用者的当前对象(会将调用者作为参数一起传递进去), 也就是说 this(有些语言中是 self. 比如 OC/Swift/Python 等)</li><li>当然, 你从这个角度来说, JavaScript 中就没有函数了, 因为函数中都有 this 这样的参数. 但是通常来说, 我们还是会将封装到类中的函数称为方法, 而全局定义的函数称为函数.</li></ul> </li><li> <p>如果接触过 Java 的同学可能会知道 Java 中只有方法的程序, 没有函数的称呼. 学习过 C 语言的同学可能知道, C 语言中只有函数的称呼, 没有方法的称呼.</p> </li><li> <p>这就是因为 Java 中通常不定义全局函数, 但是在类中定义的. 而 C 语言不支持面向对象的编程.</p> </li></ul> 
<p>OK, 我们继续 JavaScript 面向对象之旅.</p> 
<ul><li>前面创建对象的方式, 被早期的 JavaScript 程序员经常使用</li></ul> 
<p>后来, 对象字面量称为创建这种对象的首选方式</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 1.创建对象的字面量</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Coderwhy'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
    <span class="token literal-property property">height</span><span class="token operator">:</span> <span class="token number">1.88</span><span class="token punctuation">,</span>

    <span class="token function-variable function">sayHello</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'My name is '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 2.调用对象的方法</span>
person<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="13_JavaScript__99"></a>1.3. JavaScript 中属性的特性</h4> 
<p>JavaScript 中关于属性有一个比较重要的概念: 属性描述符</p> 
<ul><li>虽然我们开发中, 大多数情况不去可以的使用这些属性描述符</li><li>但是某些情况下, 也确实会用到.</li><li>建议大家先了解一下这些属性描述符, 以及它们的作用, 在以后用到时会非常有帮助.</li></ul> 
<p>JavaScript 中开始拥有了一种描述属性特征的特性（即属性描述符）。</p> 
<ul><li>根据特性的不同，可以把属性分成两种类型：数据属性和访问器属性。</li></ul> 
<p>常见的属性特性有哪些呢?</p> 
<ul><li> <p>[[Configurable]] // true or false</p> </li><li> 
  <ul><li>表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。</li></ul> </li><li> <p>[[Writable]] // true or false</p> </li><li> 
  <ul><li>表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。</li></ul> </li><li> <p>[[Enumerable]] // true or false</p> </li><li> 
  <ul><li>表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。</li></ul> </li><li> <p>[[Value]] // everty thing</p> </li><li> 
  <ul><li>包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 undefined。</li></ul> </li><li> <p>[[set]] // function or undefined</p> </li><li> 
  <ul><li>在写入属性时调用的函数。默认值为 undefined。</li></ul> </li><li> <p>[[get]] // function or undefined</p> </li><li> 
  <ul><li>在读取属性时调用的函数。默认值为 undefined。</li></ul> </li></ul> 
<p>这些属性特性是什么东西呢?</p> 
<ul><li> <p>从上面, 我们对这些特定的解释, 你会发现, 每个特定都会有自己特定的用途.</p> </li><li> <p>比如 Configurable 当我们配置为 false 时, 就无法使用 delete 来删除该属性.</p> </li><li> <p>设置属性特定</p> </li><li> 
  <ul><li>obj: 将要被添加属性或修改属性的对象</li><li>prop: 对象的属性</li><li>descriptor: 对象属性的特性</li><li>要想修改属性的特性，必须通过两个 Object 方法，即 Object.defineProperty 和 Object.defineProperties</li><li>正如其字面意思，这两个方法都是用来定义（修改）属性的，前者一次只能定义一个属性，后者则可以多个。</li><li>defineProperty(obj, prop, descriptor)</li></ul> </li></ul> 
<p>案例练习:</p> 
<pre><code class="prism language-javascript"><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'birth'</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">2000</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>birth<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2000</span>
person<span class="token punctuation">.</span>birth <span class="token operator">=</span> <span class="token number">1999</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>birth<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2000</span>
</code></pre> 
<p>注意：在使用 defineProperty 方法定义新属性时（非修改旧属性），如果不指定，configurable, enumerable 和 writable 特性的默认值都是 false。</p> 
<p>也就是上面的代码等同于:</p> 
<pre><code class="prism language-javascript"><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'birth'</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">2000</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>数据属性:</p> 
<ul><li>数据属性包含一个数值的位置，在这个位置可以读取和写入值。</li><li>数据属性拥有 4 个特性: [[Configurable]]/[[Enumerable]]/[[Writable]]/[[Value]]</li><li>按照上面的方式, 我们定义的属性就是数据属性</li></ul> 
<p>访问器属性:</p> 
<ul><li>访问器属性不包含数据值，它们包含一对 getter 和 setter 函数。</li><li>访问器属性不能直接定义，需要使用后面提到的 Object.defineProperty 函数定义。</li><li>访问器属性也拥有 4 个特性: [[Configurable]]/[[Enumerable]]/[[Get]]/[[Set]]</li></ul> 
<p>定义一个访问器属性:</p> 
<pre><code class="prism language-javascript"><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">birth</span><span class="token operator">:</span> <span class="token number">2000</span><span class="token punctuation">,</span>
    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">17</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'year'</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>birth <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> newValue <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>birth<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

person<span class="token punctuation">.</span>year <span class="token operator">=</span> <span class="token number">2088</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 88</span>
person<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>year<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2030</span>
</code></pre> 
<p>注意: getter 和 setter 都是可选的，在非严格模式下，只指定了 getter 却进行了写入操作，写入的值会被忽略; 只指定了 setter 却进行了读取操作，读取到的属性值为 undefined。在严格模式下，则都会报错。</p> 
<h3><a id="_JavaScript__216"></a>二. JavaScript 创建对象</h3> 
<p>虽然 Object 构造函数或对象字面量可以用来创建单个对象</p> 
<p>但是这些方式有个明显的缺点: 使用同一个接口创建很多对象, 会产生大量的重复代码.</p> 
<p>我们会有一些列的方式来解决这个问题, 最终得到我们最佳理想的方式来创建对象.</p> 
<h4><a id="21__224"></a>2.1. 使用工厂模式</h4> 
<p>工厂模式是一种非常常见的设计模式, 这种模式抽象了创建具体对象的过程.</p> 
<p>因为 JavaScript 中没法创建类, 开发人员就发明了一种函数, 用函数来封装以特定接口创建对象的细节.</p> 
<p>工厂模式创建对象:</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 创建工厂函数</span>
<span class="token keyword">function</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> height</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    o<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    o<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    o<span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span>

    o<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Hello, My name is '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> o<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 创建两个对象</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">'LBJ辉'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">1.88</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">'LBJ'</span><span class="token punctuation">,</span> <span class="token number">38</span><span class="token punctuation">,</span> <span class="token number">2.03</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person1<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello, My name is LBJ辉</span>
person2<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello, My name is LBJ</span>
</code></pre> 
<p>代码解析:</p> 
<ul><li>函数 createPerson()能够根据接受的参数来构建一个包含所有必要信息的 Person 对象</li><li>可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。</li><li>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。</li><li>随着 JavaScript 的发展，又一个新模式出现了。</li></ul> 
<h4><a id="22__260"></a>2.2. 构造函数模式</h4> 
<p>JavaScript 中的构造函数可用来创建特定类型的对象。</p> 
<ul><li>像 Object 和 Array 这样的原生构造函数，在运行时会自动出现在执行环境中。</li><li>此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。</li></ul> 
<p>使用构造函数模式创建对象:</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 构造函数</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> height</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用构造函数创建对象</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'LBJ辉'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">1.88</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'LBJ'</span><span class="token punctuation">,</span> <span class="token number">38</span><span class="token punctuation">,</span> <span class="token number">2.03</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person1<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LBJ辉</span>
person2<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LBJ</span>
</code></pre> 
<p>代码解析:</p> 
<ul><li> <p>在这个例子中，Person()函数取代了 createPerson()函数。</p> </li><li> <p>我们会发现这个函数有一些不太一样的地方:</p> </li><li> 
  <ul><li>没有显式地创建对象；(比如创建一个 Object 对象)</li><li>直接将属性和方法赋给了 this 对象；</li><li>没有 return 语句</li></ul> </li><li> <p>另外, 我们还注意到函数名 Person 使用的是大写字母 P。</p> </li><li> 
  <ul><li>按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头；</li><li>这个做法借鉴自其他面向对象语言，主要是为了区别于 ECMAScript 中的其他函数；</li><li>因为构造函数本身也是函数，只不过可以用来创建对象而已；</li></ul> </li><li> <p>还有, 我们在调用函数时, 不再只是简单的函数+(), 而是使用了 new 关键字</p> </li><li> <p>这种方式调用构造函数实际上会经历以下 4 个步骤：</p> </li><li> 
  <ul><li>创建一个新对象, 这个新的对象类型其实就是 Person 类型.</li><li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象，也就是 this 绑定）；</li><li>执行构造函数中的代码（为这个新对象添加属性和方法）；</li><li>返回新对象, 但是是默认返回的, 不需要使用 return 语句；</li></ul> </li></ul> 
<p>在前面例子的最后，person1 和 person2 分别保存着 Person 的一个不同的实例。</p> 
<ul><li>这两个对象都有一个 constructor（构造函数）属性，该属性指向 Person.</li><li>后面我们会详细说道 constructor 到底从何而来, 所以你需要特别知道一下这里有这个属性.</li></ul> 
<pre><code class="prism language-javascript"><span class="token comment">// constructor属性</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre> 
<p>我们也可以通过 instanceof 来查看它的类型</p> 
<ul><li>注意: 我们会发现 person1 和 person2 既是 Person 类型, 也是 Object 类型.</li><li>这是因为默认所有的对象都继承自 Object.(关于继承, 后续详细讨论)</li></ul> 
<pre><code class="prism language-javascript"><span class="token comment">// 使用instanceof查看是否是person或者Object类型</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1 <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1 <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2 <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2 <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre> 
<h4><a id="23__337"></a>2.3. 关于构造函数</h4> 
<p>关于构造函数</p> 
<ul><li>我们知道, 构造函数也是一个函数, 只是使用的方式和别的函数不太一样.(使用 new)</li><li>但是, 构造函数毕竟也是函数, 因此也可以像普通的函数一样去使用.</li><li>而且, 其他任何的函数, 也可以通过 new 关键字来调用, 这个时候这个函数也可以被称为构造函数.</li></ul> 
<p>把构造函数当做普通的函数去调用</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 当做构造函数使用</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'LBJ辉'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">1.88</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// person对象</span>
person<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 作为普通的函数调用</span>
<span class="token function">Person</span><span class="token punctuation">(</span><span class="token string">'LBJ'</span><span class="token punctuation">,</span> <span class="token number">38</span><span class="token punctuation">,</span> <span class="token number">2.03</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// window对象</span>
window<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 在另外一个对象的作用域调用</span>
<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token string">'Wade'</span><span class="token punctuation">,</span> <span class="token number">39</span><span class="token punctuation">,</span> <span class="token number">1.93</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// o对象</span>
o<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>构造函数来创建对象的缺陷:</p> 
<ul><li>构造函数模式虽然好用，但也并非没有缺点。</li><li>使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。</li><li>在前面的例子中，personl 和 person2 都有一个名为 sayName()的方法，但那两个方法不是同一个 Function 的实例。</li><li>JavaScript 中的函数也是对象，因此每定义一个函数，也就是实例化了一个对象</li></ul> 
<p>构造函数的换一种形式:</p> 
<ul><li>也就是上面的代码类似于下面的写法</li></ul> 
<pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> height</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>sayHello <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">'alert(this.name)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>有什么问题呢?</p> 
<ul><li>从这个角度上来看构造函数，更容易明白每个 Person 实例都包含一个不同的 Function 实例.</li><li>但是, 有必要创建多个 Function 实例吗? 它们执行的代码完全相同.</li><li>你也许会考虑, 它们需要区分不同的对象, 不过, 在调用函数时, 我们传入的 this 就可以区分了. 没有必要创建出多个 Function 的实例.</li></ul> 
<p>我们可以验证一下这是两个不同的函数:</p> 
<pre><code class="prism language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>sayHello <span class="token operator">===</span> person2<span class="token punctuation">.</span>sayHello<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre> 
<p>有没有办法让它们是同一个函数呢? 使用全局函数即可</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 定义全局和函数</span>
<span class="token keyword">function</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 构造函数</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> height</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>sayHello <span class="token operator">=</span> sayHello<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用构造函数创建对象</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'LBJ辉'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">1.88</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'LBJ'</span><span class="token punctuation">,</span> <span class="token number">38</span><span class="token punctuation">,</span> <span class="token number">2.03</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>sayHello <span class="token operator">===</span> person2<span class="token punctuation">.</span>sayHello<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre> 
<p>新的问题:</p> 
<ul><li>这样做确实解决了两个函数做同一件事的问题，可是新问题又来了: 在全局作用域中定义的函数我们的目的却是只能被某个对象调用，这让全局作用域有点名不副实。</li><li>而且我们进一步思考: 如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。</li></ul> 
<p>有没有新的解决方案呢？使用原型模式.</p> 
<h2><a id="JavaScript__426"></a>JavaScript 面向对象详解(二)</h2> 
<p>前面, 我们讨论了很多种场景对象的方式: 从 Object 到字面量, 再到工厂模式, 再到构造函数.</p> 
<p>最终我们发现, 构造函数是比较理想的一种方式, 但是它也存在问题.</p> 
<p>为了最终解决这个问题, 我们需要学习一个新的知识: 原型(prototype).</p> 
<h3><a id="__434"></a>一. 理解原型模式</h3> 
<h4><a id="11__436"></a>1.1. 什么是原型呢?</h4> 
<p>你需要先知道一个事实:</p> 
<ul><li>我们创建的每个函数都有一个 prototype（原型）属性</li><li>这个属性是一个指针，指向一个对象</li><li>而这个对象的作用是存放这个类型创建的所有实例共享的属性和方法。</li><li>指向的这个对象, 就是我们的所谓的原型对象.</li></ul> 
<p>原型对象的作用:</p> 
<ul><li>使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。</li><li>换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。</li></ul> 
<p>我们来看看原型对象的使用:</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 创建对象的构造函数</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token comment">// 通过原型对象来设置一些属性和值</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'LBJ辉'</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token number">1.88</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 创建两个对象, 并且调用方法</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

person1<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LBJ辉</span>
person2<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LBJ辉</span>
</code></pre> 
<p>代码解析:</p> 
<ul><li>在上面的代码中, 我们没有给实例对象单独设置属性和方法, 而是直接设置给了原型对象.</li><li>而原型对象的作用是可以让所有的对象来共享这些属性和方法.</li><li>因此, 我们调用 sayHello()方法时, 它们打印的结果是一样的, 它们是共享的.</li></ul> 
<h4><a id="12__478"></a>1.2. 深入原型对象</h4> 
<p>原型对象的创建:</p> 
<ul><li>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。</li></ul> 
<p>原型上的 constructor 属性：</p> 
<ul><li>默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。</li><li>用我们上面的例子来说, Person.prototype.constructor 指向 Person。</li><li>也就是原型对象自身来说, 只有一个 constructor 属性, 而其他属性可以由我们添加或者从 Object 中继承.</li></ul> 
<p>新的实例创建时, 原型对象在哪里呢?</p> 
<ul><li>当调用构造函数创建一个新实例后，该实例的内部将包含一个内部属性，该属性的指针, 指向构造函数的原型对象。</li><li>这个属性是 <em>proto</em></li><li>简单说, 每个实例中, 其实也会有一个属性, 该属性是指向原型对象的.</li></ul> 
<pre><code class="prism language-javascript"><span class="token comment">// 原型对象中有一个属性: constructor属性</span>
<span class="token comment">// 属性指向Person函数</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Person函数</span>

<span class="token comment">// 对象实例也有一个属性指向原型</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 原型对象</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 原型对象</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre> 
<p>我们通过一个图来解释上面的概念:<br> <img src="https://images2.imgbox.com/dd/b2/K0iZZ3wV_o.png" alt="1"></p> 
<p>解析:</p> 
<ul><li>上面的图解析了 Person 构造函数、Person 的原型属性以及 Person 现有的两个实例之间的关系</li><li>Person.prototype 指向原型对象, 而 Person.prototype.constructor 又指回了 Person.</li><li>原型对象中除了包含 constructor 属性之外，还包括后来添加的其他属性。</li><li>Person 的每个实例——personl 和 person2 都包含一个内部属性* <em>proto</em> *，该属性也指向原型对象；</li></ul> 
<p>对象搜索属性和方法的过程:</p> 
<ul><li> <p>每当代码读取某个对象的某个属性时，都会执行一次搜索，也就是要找到给定名称的属性。</p> </li><li> <p>搜索首先从 <code>对象实例本身</code> 开始</p> 
  <ul><li>如果在实例中找到了具有给定名字的属性，则返回该属性的值；</li></ul> </li><li> <p>如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性</p> 
  <ul><li>如果在原型对象中找到了这个属性，则返回该属性的值。</li></ul> </li><li> <p>也就是说，在我们调用 personl.sayHello()的时候，会先后执行两次搜索。</p> </li><li> <p>现在我们也能理解, 为什么所有的实例中都包含一个 constructor 属性, 这是因为默认所有的原型对象中都包含了该属性.</p> </li></ul> 
<p>可以通过<strong>proto</strong>来修改原型的值(通常不会这样修改, 知道即可)</p> 
<ul><li>你可以理解为什么 person1 修改了 name 后, person2 也会修改吗?</li><li>通过上面的图, 自己再来理解一下吧.</li></ul> 
<pre><code class="prism language-javascript">person1<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LBJ辉</span>
person2<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LBJ辉</span>

person1<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'LBJ'</span><span class="token punctuation">;</span>

person1<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LBJ</span>
person2<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LBJ</span>
</code></pre> 
<p>但是要注意下面的情况:</p> 
<ul><li>当我们给 person1.name 进行赋值时, 其实在给 person1 实例添加一个 name 属性.</li><li>这个时候再次访问时, 就不会访问原型中的 name 属性了.</li></ul> 
<pre><code class="prism language-javascript"><span class="token comment">// 创建两个对象, 并且调用方法</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

person1<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LBJ辉</span>
person2<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LBJ辉</span>

<span class="token comment">// 给person1实例添加属性</span>
person1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'LBJ'</span><span class="token punctuation">;</span>
person1<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LBJ, 来自实例</span>
person2<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LBJ辉, 来自原型</span>
</code></pre> 
<p>通过 hasOwnProperty 判断属性属于实例还是原型.</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 判断属性属于谁</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre> 
<h4><a id="13__576"></a>1.3. 简洁的原型语法</h4> 
<p>简洁语法概述:</p> 
<ul><li>如果按照前面的做法, 每添加一个原型属性和方法, 都要敲一遍 Person.prototype.</li><li>为了减少不必要的输入, 另外也为了更好的封装性, 更常用的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象.</li></ul> 
<p>字面量重写原型对象:</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 定义Person构造函数</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token comment">// 重写Person的原型属性</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'LBJ辉'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
    <span class="token literal-property property">height</span><span class="token operator">:</span> <span class="token number">1.88</span><span class="token punctuation">,</span>

    <span class="token function-variable function">sayHello</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>注意:</p> 
<ul><li>我们将 Person.prototype 赋值了一个新的对象字面量, 最终结果和原来是一样的；</li><li>但是: constructor 属性不再指向 Person 了；</li><li>前面我们说过, 每创建一个函数, 就会同时创建它的 prototype 对象, 这个对象也会自动获取 constructor 属性；</li><li>而我们这里相当于给 prototype 重新赋值了一个对象, 那么这个新对象的 constructor 属性, 会指向 Object 构造函数, 而不是 Person 构造函数了；</li></ul> 
<pre><code class="prism language-javascript"><span class="token comment">// 创建Person对象</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre> 
<p>如果在某些情况下, 我们确实需要用到 constructor 的值, 可以手动的给 constructor 赋值即可</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 定义Person构造函数</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token comment">// 重写Person的原型属性</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">constructor</span><span class="token operator">:</span> Person<span class="token punctuation">,</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'LBJ辉'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
    <span class="token literal-property property">height</span><span class="token operator">:</span> <span class="token number">1.88</span><span class="token punctuation">,</span>

    <span class="token function-variable function">sayHello</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 创建Person对象</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre> 
<p>上面的方式虽然可以, 但是也会造成 constructor 的[[Enumerable]]特性被设置了 true.</p> 
<ul><li>默认情况下, 原生的 constructor 属性是不可枚举的.</li><li>如果希望解决这个问题, 就可以使用我们前面介绍的 Object.defineProperty()函数了.</li></ul> 
<pre><code class="prism language-javascript"><span class="token comment">// 定义Person构造函数</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token comment">// 重写Person的原型属性</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'LBJ辉'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
    <span class="token literal-property property">height</span><span class="token operator">:</span> <span class="token number">1.88</span><span class="token punctuation">,</span>

    <span class="token function-variable function">sayHello</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">'constructor'</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span> Person<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="14__671"></a>1.4. 修改原型属性</h4> 
<p>考虑下面的代码执行是否会有问题:</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 定义Person构造函数</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token comment">// 创建Person的对象</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 给Person的原型添加方法</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Hello JavaScript'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 调用方法</span>
person<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>代码解析:</p> 
<ul><li>我们发现代码的执行没有任何问题.</li><li>因为在创建 person 的时候, person 的<strong>proto</strong>也是指向的 Person.prototype.</li><li>所以, 当动态的修改了 Person.prototype 中的 sayHello 属性时, person 中也可以获取到该属性</li></ul> 
<p>我们再来看下面的代码会不会有问题:</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 定义Person构造函数</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token comment">// 创建Person的对象</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 给Person的原型添加方法</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">constructor</span><span class="token operator">:</span> Person<span class="token punctuation">,</span>
    <span class="token function-variable function">sayHello</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Hello JavaScript'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 调用方法</span>
person<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>代码解析:</p> 
<ul><li>代码是不能正常运行的. 因为 Person 的 prototype 指向了一个新的对象.</li><li>而最初我们创建的 person 依然指向原来的原型对象, 原来的原型对象没有 sayHello()函数.</li><li>当然, 如果再次之后, 再创建的 Person 对象, 是可以调用 sayHello()的, 但是再次之前创建的, 没有该方法.</li></ul> 
<h4><a id="15__723"></a>1.5. 原型对象问题</h4> 
<p>原型对象也有一些缺点:</p> 
<ul><li>首先, 它不再有为构造函数传递参数的环节, 所有实例在默认情况下都将有相同的属性值.</li><li>另外, 原型中所有的属性是被很多实例共享的, 这种共享对于函数来说非常适合, 对于基本属性通常情况下也不会有问题. (因为通过 person.name 直接修改时, 会在实例上重新创建该属性名, 不会在原型上修改. 除非使用 person.<strong>proto</strong>.name 修改).</li><li>但是, 对于引用类型的实例, 就必然会存在问题.</li></ul> 
<p>考虑下面代码的问题:</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 定义Person构造函数</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token comment">// 设置Person原型</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">constructor</span><span class="token operator">:</span> Person<span class="token punctuation">,</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'LBJ辉'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
    <span class="token literal-property property">height</span><span class="token operator">:</span> <span class="token number">1.88</span><span class="token punctuation">,</span>
    <span class="token literal-property property">hobby</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'Basketball'</span><span class="token punctuation">,</span> <span class="token string">'Football'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>

    <span class="token function-variable function">sayHello</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Hello JavaScript'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 创建两个person对象</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>hobby<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Basketball,Football</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>hobby<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Basketball,Football</span>

person1<span class="token punctuation">.</span>hobby<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'tennis'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>hobby<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Basketball,Football,tennis</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>hobby<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Basketball,Football,tennis</span>
</code></pre> 
<p>OK, 我们会发现, 我们明明给 person1 添加了一个爱好, 但是 person2 也被添加到一个爱好.</p> 
<ul><li>因为它们是共享的同一个数组.</li><li>但是, 我们希望每个人有属于自己的爱好, 而不是所有的 Person 爱好都相同.</li></ul> 
<h3><a id="__768"></a>二. 组合构造函数和原型模式</h3> 
<p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。</p> 
<p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。</p> 
<p>结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。</p> 
<p>另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。</p> 
<p>组合构造函数和原型模式的代码</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 创建Person构造函数</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> height</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>hobby <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Basketball'</span><span class="token punctuation">,</span> <span class="token string">'Football'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 重新Peron的原型对象</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">constructor</span><span class="token operator">:</span> Person<span class="token punctuation">,</span>
    <span class="token function-variable function">sayHello</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Hello JavaScript'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 创建对象</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'LBJ辉'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">1.88</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'LBJ'</span><span class="token punctuation">,</span> <span class="token number">38</span><span class="token punctuation">,</span> <span class="token number">2.03</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 测试是否共享了函数</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>sayHello <span class="token operator">==</span> person2<span class="token punctuation">.</span>sayHello<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token comment">// 测试引用类型是否存在问题</span>
person1<span class="token punctuation">.</span>hobby<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'tennis'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>hobby<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>hobby<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>如果理解了原型, 上面的代码非常好理解.</p> 
<ul><li>person1 和 person2 各有一份自己的属性, 但是方法是共享的.</li></ul> 
<p>事实上, 还有一些其他的变种模式来实现基于对象的封装. 但是这种方式是最常用的, 因此我们这里不再展开讨论其他的模式. 后续需要我们再深入讨论。</p> 
<h2><a id="JavaScript__816"></a>JavaScript 面向对象详解（三）</h2> 
<p>继承是面向对象中非常重要的特性.</p> 
<p>ES5 中和类的实现一样, 不能直接实现继承. 实现继承主要是依靠原型链来实现的。</p> 
<h3><a id="__822"></a>一. 原型链</h3> 
<p>原型链是 ES5 中实现继承的主要手段, 因此相对比较重要, 我们需要深入理解原型链.</p> 
<h4><a id="11__826"></a>1.1. 深入理解原型链</h4> 
<p>先来回顾一下构造函数、原型和实例的关系：</p> 
<ul><li>每个构造函数都有一个原型对象, 通过 prototype 指针指向该原型对象.</li><li>原型对象都包含一个指向构造函数的指针, 通过 constructor 指针, 指向构造函数</li><li>而实例都包含一个指向原型对象的内部指针, 该内部指针我们通常使用<strong>proto</strong>来描述.</li></ul> 
<p>思考如下情况:</p> 
<ul><li>我们知道, 可以通过 Person.prototype = {}的方式来重写原型对象.</li><li>假如, 我们后面赋值的不是一个{}, 而是另外一个类型的实例, 结果会是怎么样呢?</li><li>显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。</li><li>假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。</li></ul> 
<p>有些抽象, 我们通过代码来理解:</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 创建Person构造函数</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token comment">// 设置Animal的原型</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>我们将代码修改成原型链的形式:</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 1.创建Animal的构造函数</span>
<span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>animalProperty <span class="token operator">=</span> <span class="token string">'Animal'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 2.给Animal的原型中添加一个方法</span>
<span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">animalFunction</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>animalProperty<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 3.创建Person的构造函数</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>personProperty <span class="token operator">=</span> <span class="token string">'Person'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 4.给Person的原型对象重新赋值</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 5.给Person添加属于自己的方法</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">personFunction</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>personProperty<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 6.创建Person的实例</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span><span class="token function">animalFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Animal</span>
person<span class="token punctuation">.</span><span class="token function">personFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Person</span>
</code></pre> 
<p>代码解析:</p> 
<ul><li> <p>代码有一些复杂, 但是如果你希望学习好原型链, 必须耐心去看一看上面的代码, 你会发现其实都是我们学习过的.</p> </li><li> <p>重点我们来看第 4 步代码: 给 Person.prototype 赋值了一个 Animal 的实例. 也就是 Person 的原型变成了 Animal 的实例.</p> </li><li> <p>Animal 实例本身有一个<strong>proto</strong>可以指向 Animal 的原型.</p> </li><li> <p>那么, 我们来思考一个问题: 如果现在搜索一个属性或者方法, 这个时候会按照什么顺序搜索呢?</p> 
  <ul><li>第一步, 在 person 实例中搜索, 搜索到直接返回或者调用函数. 如果没有执行第二步.</li><li>第二步, 在 Person 的原型中搜索, Person 的原型是谁? Animal 的实例. 所以会在 Animal 的实例中搜索, 无论是属性还是方法, 如果搜索到则直接返回或者执行. 如果没有, 执行第三步.</li><li>第三步, 在 Animal 的原型中搜索, 搜索到返回或者执行, 如果没有, 搜索结束. (当然其实还有 Object, 但是先不考虑)</li></ul> </li></ul> 
<p>画图解析可能更加清晰:</p> 
<p>当代码执行到第 3 步(上面代码的序号)的时候, 如图所示:</p> 
<p><img src="https://images2.imgbox.com/26/d2/Pa0QcUzd_o.png" alt="2"></p> 
<p>当代码执行第 4 步(上面代码的序号)时, 发生了如图所示的变化</p> 
<ul><li>注意图片中的红色线, 原来指向的是谁, 现在指向的是谁.</li></ul> 
<p><img src="https://images2.imgbox.com/a7/cd/CGUSIKpY_o.png" alt="3"></p> 
<p>代码继续执行</p> 
<ul><li>Person.prototype.personFunction = function (){}</li><li>当执行第 5 步, 也就是给 Person 的原型赋值了一个函数时, 事实上在给 new Animal(Animal 的实例)赋值了一个新的方法.<br> <img src="https://images2.imgbox.com/c6/b7/HSqTi3HV_o.png" alt="在这里插入图片描述"></li></ul> 
<p>代码继续执行, 我们创建了一个 Person 对象</p> 
<ul><li>创建 Person 对象, person 对象会有自己的属性, personProperty.</li><li>另外, person 对象有一个<strong>prototype</strong>指向 Person 的原型.</li><li>Person 的原型是谁呢? 就是我们之前的 new Animal(Animal 的一个实例), 所以会指向它.</li></ul> 
<p>原型链简单总结:</p> 
<ul><li>通过实现原型链，本质上扩展了本章前面介绍的原型搜索机制。</li><li>当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。</li><li>在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。</li></ul> 
<h4><a id="12__928"></a>1.2. 原型和实例的关系</h4> 
<p>如果我们希望确定原型和实例之间的关系, 有两种方式:</p> 
<ul><li>第一种方式是使用 instanceof 操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回 true。</li><li>第二种方式是使用 isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此 isPrototypeOf()方法也会返回 true</li></ul> 
<p>instanceof 操作符</p> 
<pre><code class="prism language-javascript"><span class="token comment">// instanceof</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Animal</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre> 
<p>isPrototypeOf()函数</p> 
<pre><code class="prism language-javascript"><span class="token comment">// isPrototypeOf函数</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'isPrototypeOf函数函数'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre> 
<h4><a id="13__954"></a>1.3. 添加新的方法</h4> 
<p>添加新的方法</p> 
<ul><li>在第 5 步操作中, 我们为子类型添加了一个新的方法. 但是这里有一个注意点.</li><li>无论是子类中添加新的方法, 还是对父类中方法进行重写. 都一定要将添加方法的代码, 放在替换原型语句之后.</li><li>否则, 我们添加的方法将会无效.</li></ul> 
<p>错误代码引起的代码:</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 1.定义Animal的构造函数</span>
<span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>animalProperty <span class="token operator">=</span> <span class="token string">'Animal'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 2.给Animal添加方法</span>
<span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">animalFunction</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>animalProperty<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 3.定义Person的构造函数</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>personProperty <span class="token operator">=</span> <span class="token string">'Person'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 4.给Person添加方法</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">personFunction</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>personProperty<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 5.给Person赋值新的原型对象</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 6.创建Person对象, 并且调用方法</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span><span class="token function">personFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不会有任何弹窗, 因为找不到该方法</span>
</code></pre> 
<p>代码解析:</p> 
<ul><li>执行上面的代码不会出现任何的弹窗, 因为我们添加的方法是无效的, 被赋值的新的原型覆盖了.</li><li>正确的办法是将第 4 步和第 5 步操作换一下位置即可.</li></ul> 
<p>总结</p> 
<ul><li>其实这个问题没什么好说的, 只要你理解了原型链(好好看看我上面画的图, 或者自己画一下图)</li><li>但是, 切记在看图的过程中一样扫过, 因为这会让你错过很多细节, 对原型链的理解就会出现问题.</li></ul> 
<h4><a id="14__1003"></a>1.4. 原型链的问题</h4> 
<p>原型链对于继承来说:</p> 
<ul><li>原型链似乎对初学 JavaScript 原型的人来说, 已经算是比较高明的设计技巧了, 有些人理解起来都稍微有些麻烦.</li><li>但是, 这种设计还存在一些缺陷, 不是最理性的解决方案. (但是后续的解决方案也是依赖原型链, 无论如何都需要先理解它)</li></ul> 
<p>原型链存在的问题:</p> 
<ul><li>原型链存在最大的问题是关于引用类型的属性.</li><li>通过上面的原型实现了继承后, 子类的 person 对象继承了(可以访问)Animal 实例中的属性(animalProperty).</li><li>但是如果这个属性是一个引用类型(比如数组或者其他引用类型), 就会出现问题.</li></ul> 
<p>引用类型的问题代码:</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 1.定义Animal的构造函数</span>
<span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 2.给Animal添加方法</span>
<span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">animalFunction</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 3.定义Person的构造函数</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>personProperty <span class="token operator">=</span> <span class="token string">'Person'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 4.给Person赋值新的原型对象</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 5.给Person添加方法</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">personFunction</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>personProperty<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 6.创建Person对象, 并且调用方法</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// red,green</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// red,green</span>

person1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// red,green,blue</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// red,green,blue</span>
</code></pre> 
<p>代码解析:</p> 
<ul><li>我们查看第 6 步的操作</li><li>创建了两个对象, 并且查看了它们的 colors 属性</li><li>修改了 person1 中的 colors 属性, 添加了一个新的颜色 blue</li><li>再次查看两个对象的 colors 属性, 会发现 person2 的 colors 属性也发生了变化</li><li>两个实例应该是相互独立的, 这样的变化如果我们不制止将会在代码中引发一些列问题.</li></ul> 
<p>原型链的其他问题:</p> 
<ul><li>在创建子类型的实例时，不能向父类型的构造函数中传递参数。</li><li>实际上，应该说是没有办法在不影响所有对象实例的情况下，给父类型的构造函数传递参数。</li><li>从而可以修改父类型中属性的值, 在创建构造函数的时候就确定一个值.</li></ul> 
<h3><a id="__1069"></a>二. 经典继承</h3> 
<p>为了解决原型链继承中存在的问题, 开发人员提供了一种新的技术: constructor stealing(有很多名称: 借用构造函数或经典继承或伪造对象), steal 是偷窃的意思, 但是这里可以翻译成借用.</p> 
<h4><a id="21__1073"></a>2.1. 经典继承的思想</h4> 
<p>经典继承的做法非常简单: 在子类型构造函数的内部调用父类型构造函数.</p> 
<ul><li>因为函数可以在任意的时刻被调用</li><li>因此通过 apply()和 call()方法也可以在新创建的对象上执行构造函数.</li></ul> 
<p>经典继承代码如下:</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 创建Animal的构造函数</span>
<span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 创建Person的构造函数</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 继承Animal的属性</span>
    <span class="token function">Animal</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 给自己的属性赋值</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'LBJ辉'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 创建Person对象</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// red,green</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// red,green</span>
person1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// red,green,blue</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// red,green</span>
</code></pre> 
<p>代码解析:</p> 
<ul><li>我们通过在 Person 构造函数中, 使用 call 函数, 将 this 传递进去.</li><li>这个时候, 当 Animal 中有相关属性初始化时, 就会在 this 对象上进行初始化操作.</li><li>这样就实现了类似于继承 Animal 属性的效果.</li></ul> 
<p>这个时候, 我们也可以传递参数, 修改上面的代码:</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 创建Animal构造函数</span>
<span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 创建Person构造函数</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">Animal</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 创建Person对象</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'LBJ辉'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="22__1134"></a>2.2. 经典继承的问题</h4> 
<p>经典继承的问题:</p> 
<ul><li>对于经典继承理解比较深入, 你已经能发现: 经典继承只有属性的继承, 无法实现方法的继承.</li><li>因为调用 call 函数, 将 this 传递进去, 只能将父构造函数中的属性初始化到 this 中.</li><li>但是如果函数存在于父构造函数的原型对象中, this 中是不会有对应的方法的.</li></ul> 
<p>回顾原型链和经典继承:</p> 
<ul><li>原型链存在的问题是引用类型问题和无法传递参数, 但是方法可以被继承</li><li>经典继承是引用类型没有问题, 也可以传递参数, 但是方法无法被继承.</li><li>怎么办呢? 将两者结合起来怎么样?</li></ul> 
<h3><a id="__1148"></a>三. 组合继承</h3> 
<p>如果你认识清楚了上面两种实现继承的方式存在的问题, 就可以很好的理解组合继承了.</p> 
<p>组合继承(combination inheritance, 有时候也称为伪经典继承), 就是将原型链和经典继承组合在一起, 从而发挥各自的优点.</p> 
<h4><a id="31__1154"></a>3.1. 组合继承的思想</h4> 
<p>组合继承:</p> 
<ul><li>组合继承就是发挥原型链和经典继承各自的优点来完成继承的实现.</li><li>使用原型链实现对原型属性和方法的继承.</li><li>通过经典继承实现对实例属性的继承, 以及可以在构造函数中传递参数.</li></ul> 
<p>组合继承的代码:</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 1.创建构造函数的阶段</span>
<span class="token comment">// 1.1.创建Animal的构造函数</span>
<span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 1.2.给Animal添加方法</span>
<span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">animalFunction</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Hello Animal'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 1.3.创建Person的构造函数</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">Animal</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 1.4.给Person的原型对象重新赋值</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 1.5.给Person添加方法</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">personFunction</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Hello Person'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 2.验证和使用的代码</span>
<span class="token comment">// 2.1.创建Person对象</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'LBJ辉'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'LBJ'</span><span class="token punctuation">,</span> <span class="token number">38</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2.2.验证属性</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">'-'</span> <span class="token operator">+</span> person1<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LBJ辉,18</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">'-'</span> <span class="token operator">+</span> person2<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LBJ,38</span>

<span class="token comment">// 2.3.验证方法的调用</span>
person1<span class="token punctuation">.</span><span class="token function">animalFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello Animal</span>
person1<span class="token punctuation">.</span><span class="token function">personFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello Person</span>

<span class="token comment">// 2.4.验证引用属性的问题</span>
person1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// red,green,blue</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// red,green</span>
</code></pre> 
<p>代码解析:</p> 
<ul><li>根据前面学习的知识, 结合当前的代码, 大家应该可以理解上述代码的含义.</li><li>但是我还是建议大家一定要多手动自己来敲代码, 来理解其中每一个步骤.</li><li>记住: 看懂, 听懂不一定真的懂, 自己可以写出来, 才是真的懂了.</li></ul> 
<h4><a id="32__1216"></a>3.2. 组合继承的分析</h4> 
<p>组合继承是 JavaScript 最常用的继承模式之一.</p> 
<ul><li>如果你理解到这里, 点到为止, 那么组合来实现继承只能说问题不大.</li><li>但是它依然不是很完美, 存在一些问题不大的问题.(不成问题的问题, 基本一词基本可用, 但基本不用)</li></ul> 
<p>组合继承存在什么问题呢?</p> 
<ul><li>组合继承最大的问题就是无论在什么情况下, 都会调用两次父类构造函数.</li><li>一次在创建子类原型的时候</li><li>另一次在子类构造函数内部(也就是每次创建子类实例的时候).</li><li>另外, 如果你仔细按照我的流程走了上面的每一个步骤, 你会发现: 所有的子类实例事实上会拥有两份父类的属性</li><li>一份在当前的实例自己里面(也就是 person 本身的), 另一份在子类对应的原型对象中(也就是 person.<strong>proto</strong>里面)</li><li>当然, 这两份属性我们无需担心访问出现问题, 因为默认一定是访问实例本身这一部分的.</li></ul> 
<p>怎么解决呢?</p> 
<ul><li>看起来组合继承也不是非常完美的解决方案, 虽然也可以应用.</li><li>有没有终极的解决方案呢? 预知后事如何, 且听下回分解.</li></ul> 
<h2><a id="JavaScript__1237"></a>JavaScript 面向对象详解（四）</h2> 
<p>在上一篇中, 我们讨论了 ES5 中, 实现继承的一些方式.</p> 
<p>在最后, 我们说了组合继承是相对完美的解决方案, 但是它也存在一些问题.</p> 
<p>这篇文章, 我们就通过某种新的模式, 给出一种目前使用最多, 也是我们最终的解决方案.</p> 
<h3><a id="__1245"></a>一. 原型式继承</h3> 
<h4><a id="11__1247"></a>1.1. 原型式继承的思想</h4> 
<p>原型式继承的渊源</p> 
<ul><li>这种模式要从道格拉斯·克罗克福德（Douglas Crockford, 著名的前端大师, JSON 的创立者）在 2006 年写的一篇文章说起: Prototypal Inheritance in JavaScript(在 JS 中使用原型式继承)</li><li>在这篇文章中, 它介绍了一种继承方法, 而且这种继承方法不是通过构造函数来实现的.</li><li>为了理解这种方式, 我们先再次回顾一下 JavaScript 想实现继承的目的: 重复利用另外一个对象的属性和方法.</li></ul> 
<p>原型式继承的核心函数:</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 封装object()函数</span>
<span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>代码解析:</p> 
<ul><li>在 object()函数内部, 先创建一个临时的构造函数.</li><li>然后将传递的对象作为这个构造函数的原型</li><li>最后返回了这个临时类型的一个新的实例.</li><li>事实上, object()对传入的对象执行了一次浅复制.</li></ul> 
<h4><a id="12__1273"></a>1.2. 原型式继承的使用</h4> 
<p>使用原型式继承:</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 使用原生式继承</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'LBJ辉'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">colors</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 通过person去创建另外一个对象</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
person1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'LBJ'</span><span class="token punctuation">;</span>
person1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LBJ</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// red,green,blue</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LBJ辉</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// red,green,blue</span>
</code></pre> 
<p>代码解析:</p> 
<ul><li>这种方式和我们传统意义上理解的继承有些不同. 它做的事情是通过一个对象去创建另外一个对象.(利用 person 去创建 person1)</li><li>当然, person1 中继承过来的属性是放在了自己的原型对象中的.</li><li>也可以给 person1 自己再次添加 name 属性, 这个时候 name 才是在实例本身中.</li><li>但是如果是修改或者添加引用类型的内容, 还是会引起连锁反应.</li><li>可能暂时你看不到这些代码的意义, 但是这些代码是我们后续终极方案的前提思想, 所以先看看和练习一下这些代码.</li></ul> 
<p>针对这种思想, ES5 中新增了 Object.create()方法来规范化了原型式继承.</p> 
<ul><li>也就是上面的代码可以修改成这样.(只是将 object 函数修改成了 Object.create)</li></ul> 
<pre><code class="prism language-javascript"><span class="token comment">// 使用原生式继承</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'LBJ辉'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">colors</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 通过person去创建另外一个对象</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
person1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'LBJ'</span><span class="token punctuation">;</span>
person1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LBJ</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// red,green,blue</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LBJ辉</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// red,green,blue</span>
</code></pre> 
<p>Object.create()还可以传入第二个参数:</p> 
<ul><li>第二个参数用于每个属性的自定义描述.</li><li>比如 person1 的 name 我们希望修改成"LBJ", 就可以这样来做</li></ul> 
<pre><code class="prism language-javascript"><span class="token comment">// 使用原型式继承</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'LBJ辉'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">colors</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 通过person去创建另外一个对象</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">'LBJ'</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LBJ</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// red,green,blue</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LBJ辉</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// red,green,blue</span>
</code></pre> 
<h4><a id="13__1354"></a>1.3. 原型式继承的问题</h4> 
<ul><li> <p>原型式继承的的优点和缺点:</p> </li><li> 
  <ul><li>如果我们只是希望一个对象和另一个对象保持类似的情况下, 原型式继承完全可以胜任, 这是它的优势.</li><li>但是, 原型式继承依然存在属性共享的问题, 就像使用原型链一样.</li></ul> </li></ul> 
<h3><a id="__1361"></a>二. 寄生式继承</h3> 
<h4><a id="21__1363"></a>2.1. 寄生式继承的思想</h4> 
<p>寄生式(Parasitic)继承</p> 
<ul><li>寄生式(Parasitic)继承是与原型式继承紧密相关的一种思想, 并且同样由道格拉斯·克罗克福德(Douglas Crockford)提出和推广的</li><li>寄生式继承的思路是结合原型类继承和工厂模式的一种方式.</li><li>即创建一个封装继承过程的函数, 该函数在内部以某种方式来增强对象, 最后再将这个对象返回.</li></ul> 
<p>寄生式函数多增加了一个核心函数:</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 封装object函数</span>
<span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 封装创建新对象的函数</span>
<span class="token keyword">function</span> <span class="token function">createAnother</span><span class="token punctuation">(</span><span class="token parameter">original</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> clone <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span>
    clone<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Hello JavaScript'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> clone<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="22__1391"></a>2.2. 寄生式继承的应用</h4> 
<p>我们来使用一下寄生式继承</p> 
<pre><code class="prism language-javascript"><span class="token comment">// person对象</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'LBJ辉'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">colors</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 新的对象</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token function">createAnother</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
person1<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>代码解读:</p> 
<ul><li>我们基于 person 对象, 创建了另外一个对象 person1.</li><li>在最新的 person1 对象中, 不仅会拥有 person 的属性和方法, 而且还有自己定义的方法.</li></ul> 
<h4><a id="23__1412"></a>2.3. 寄生式继承的问题</h4> 
<p>寄生式继承存在的问题:</p> 
<ul><li>寄生式继承和原型式继承存在一样的问题, 引用类型会共享. (因为是在原型式继承基础上的一种封装)</li><li>另外寄生式继承还存在函数无法复用的问题, 因为每次 createAnother 一个新的对象, 都需要重新定义新的函数.</li></ul> 
<h3><a id="__1419"></a>三. 寄生组合式继承</h3> 
<h4><a id="31__1421"></a>3.1. 寄生组合式继承的思想</h4> 
<p>寄生组合式继承</p> 
<ul><li> <p>现在我们来回顾一下之前提出的比较理想的组合继承</p> </li><li> 
  <ul><li>组合继承是比较理想的继承方式, 但是存在两个问题:</li><li>问题一: 构造函数会被调用两次: 一次在创建子类型原型对象的时候, 一次在创建子类型实例的时候.</li><li>问题二: 父类型中的属性会有两份: 一份在原型对象中, 一份在子类型实例中.</li></ul> </li><li> <p>事实上, 我们现在可以利用寄生式继承将这两个问题给解决掉.</p> </li><li> 
  <ul><li>你需要先明确一点: 当我们在子类型的构造函数中调用父类型.call(this, 参数)这个函数的时候, 就会将父类型中的属性和方法复制一份到了子类型中. 所以父类型本身里面的内容, 我们不再需要.</li><li>这个时候, 我们还需要获取到一份父类型的原型对象中的属性和方法.</li><li>能不能直接让子类型的原型对象 = 父类型的原型对象呢?</li><li>不要这么做, 因为这么做意味着以后修改了子类型原型对象的某个引用类型的时候, 父类型原生对象的引用类型也会被修改.</li><li>我们使用前面的寄生式思想就可以了.</li></ul> </li></ul> 
<p>寄生组合式的核心代码:</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 定义object函数</span>
<span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 定义寄生式核心函数</span>
<span class="token keyword">function</span> <span class="token function">inhreitPrototype</span><span class="token punctuation">(</span><span class="token parameter">subType<span class="token punctuation">,</span> superType</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> prototype <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>superType<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
    prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> subType<span class="token punctuation">;</span>
    subType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="32__1457"></a>3.2. 寄生组合式继承的应用</h4> 
<p>直接给出使用的代码, 也是我们以后使用继承的终极方式</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 定义Animal构造函数</span>
<span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 给Animal添加方法</span>
<span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">animalFunction</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Hello Animal'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 定义Person构造函数</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">Animal</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用寄生组合式核心函数</span>
<span class="token function">inhreitPrototype</span><span class="token punctuation">(</span>Person<span class="token punctuation">,</span> Animal<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 给Person添加方法</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">personFunction</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Hello Person'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>代码的优点:</p> 
<ul><li>这种方式的高效体现在现在它只调用了一次 Animal 的构造函数.</li><li>并且也避免了在原型上面多出的多余属性, 而且原型之间不会产生任何的干扰(子类型原型和父类型原型之间).</li><li>在 ES5 中, 普遍认为寄生组合式继承是最理想的继承范式.</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f26214c65b525ccfbdaf9435c0639448/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【JavaSE】继承</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f311abeecfdeda96a41c9ee7ecef3c25/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">u盘格式化后数据能恢复吗</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>