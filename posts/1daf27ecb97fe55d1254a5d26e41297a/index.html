<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>进阶JAVA篇-深入了解 List 系列集合 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="进阶JAVA篇-深入了解 List 系列集合" />
<meta property="og:description" content="目录
1.0 List 类的说明
1.1 List 类的常用方法
1.2 List 集合的遍历方式
2.0 ArrayList 集合的底层原理
2.1 从 ArrayList 集合的底层原理来了解具有该特性的原因：
2.2 ArrayList 集合的优缺点
3.0 LinkedList 集合的底层原理
3.1 从 LinkedList 集合的底层原理来了解具有该特性的原因：
3.2 LinkedList 集合的优缺点
3.3 LinkedList 集合的特有方法
1.0 List 类的说明 在 Java 中，List 类是 Java 集合框架中的一种接口，它是一种有序的、可重复的集合，用于存储多个元素。List 接口是 Collection 接口的子接口，它定义了一系列方法来操作和访问列表中的元素，所以 List 接口继承了 Collection 接口的方法。
有关的 Collection 接口的常用 API 介绍在以下链接：
进阶JAVA篇- Collection 类的常用的API与 Collection 集合的遍历方式-CSDN博客
1.1 List 类的常用方法 以代码的形式来介绍这些方法：
import java.util.ArrayList; import java.util.List; public class Text_List { public static void main(String[] args) { //由于 List 是一个接口，不能直接去创建对象， //所以用 List 的实现类来创建一个对象，比如 ArrayList List&lt;String&gt; list = new ArrayList&lt;&gt;();//这是一行经典的代码！！！ list." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/1daf27ecb97fe55d1254a5d26e41297a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-21T14:43:47+08:00" />
<meta property="article:modified_time" content="2023-10-21T14:43:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">进阶JAVA篇-深入了解 List 系列集合</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20List%20%E7%B1%BB%E7%9A%84%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20List%20%E7%B1%BB%E7%9A%84%E8%AF%B4%E6%98%8E" rel="nofollow">        <strong>1.0 List 类的说明</strong></a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A01.1%20List%20%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A01.1%20List%20%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95" rel="nofollow">         1.1 List 类的常用方法</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.2%20List%20%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.2%20List%20%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F" rel="nofollow">        1.2 List 集合的遍历方式</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20ArrayList%20%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20ArrayList%20%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86" rel="nofollow">        2.0 ArrayList 集合的底层原理</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A02.1%20%E4%BB%8E%C2%A0ArrayList%20%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%9D%A5%E4%BA%86%E8%A7%A3%E5%85%B7%E6%9C%89%E8%AF%A5%E7%89%B9%E6%80%A7%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A02.1%20%E4%BB%8E%C2%A0ArrayList%20%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%9D%A5%E4%BA%86%E8%A7%A3%E5%85%B7%E6%9C%89%E8%AF%A5%E7%89%B9%E6%80%A7%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A" rel="nofollow">       2.1 从 ArrayList 集合的底层原理来了解具有该特性的原因：</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A02.2%20ArrayList%20%E9%9B%86%E5%90%88%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A02.2%20ArrayList%20%E9%9B%86%E5%90%88%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" rel="nofollow">         2.2 ArrayList 集合的优缺点</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20LinkedList%20%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20LinkedList%20%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86" rel="nofollow">        3.0 LinkedList 集合的底层原理</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%C2%A0%E4%BB%8E%20LinkedList%C2%A0%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%9D%A5%E4%BA%86%E8%A7%A3%E5%85%B7%E6%9C%89%E8%AF%A5%E7%89%B9%E6%80%A7%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%C2%A0%E4%BB%8E%20LinkedList%C2%A0%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%9D%A5%E4%BA%86%E8%A7%A3%E5%85%B7%E6%9C%89%E8%AF%A5%E7%89%B9%E6%80%A7%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A" rel="nofollow">        3.1 从 LinkedList 集合的底层原理来了解具有该特性的原因：</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%20LinkedList%C2%A0%E9%9B%86%E5%90%88%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%20LinkedList%C2%A0%E9%9B%86%E5%90%88%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" rel="nofollow">        3.2 LinkedList 集合的优缺点</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.3%20LinkedList%20%E9%9B%86%E5%90%88%E7%9A%84%E7%89%B9%E6%9C%89%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.3%20LinkedList%20%E9%9B%86%E5%90%88%E7%9A%84%E7%89%B9%E6%9C%89%E6%96%B9%E6%B3%95" rel="nofollow">        3.3 LinkedList 集合的特有方法</a></strong></p> 
<hr> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20List%20%E7%B1%BB%E7%9A%84%E8%AF%B4%E6%98%8E">        1.0 List 类的说明</h2> 
<p>        <strong>在 Java 中，<span style="color:#fe2c24;">List 类</span>是 Java 集合框架中的一种<span style="color:#ffd900;">接口</span>，它是一种<span style="color:#fe2c24;">有序的</span>、<span style="color:#fe2c24;">可重复</span>的集合，用于存储多个元素。<span style="color:#fe2c24;">List 接口</span>是 <span style="color:#fe2c24;">Collection 接口</span>的<span style="color:#fe2c24;">子接口</span><span style="color:#494949;">，</span>它定义了一系列方法来操作和访问列表中的元素，所以<span style="color:#fe2c24;"> List 接口</span>继承了 <span style="color:#fe2c24;">Collection 接口</span>的方法。</strong></p> 
<blockquote> 
 <p><strong>有关的 Collection 接口的常用 API 介绍在以下链接：</strong></p> 
 <p><strong><a href="https://blog.csdn.net/Tingfeng__/article/details/133929877?spm=1001.2014.3001.5501" title="进阶JAVA篇- Collection 类的常用的API与 Collection 集合的遍历方式-CSDN博客">进阶JAVA篇- Collection 类的常用的API与 Collection 集合的遍历方式-CSDN博客</a></strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A01.1%20List%20%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">         1.1 List 类的常用方法</h3> 
<p><strong>以代码的形式来介绍这些方法：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import java.util.ArrayList;
import java.util.List;

public class Text_List {
    public static void main(String[] args) {

        //由于 List 是一个接口，不能直接去创建对象，
        //所以用 List 的实现类来创建一个对象，比如 ArrayList
        List&lt;String&gt; list = new ArrayList&lt;&gt;();//这是一行经典的代码！！！
        list.add("张三");
        list.add("李四");
        list.add("王五");
        System.out.println(list);
        //输出结果为：[张三, 李四, 王五]

        //1. add(index, element)：在指定位置插入一个元素。
        list.add(1,"张麻子");
        System.out.println(list);
        //输出结果为：[张三, 张麻子, 李四, 王五]

        //2. remove(index)：移除并返回指定位置的元素。
        list.remove(1);
        System.out.println(list);
        //输出结果为：[张三, 李四, 王五]

        //3. set(index, element)：将指定位置的元素替换为新的元素。
        list.set(1,"张麻子");
        System.out.println(list);
        //输出结果为：[张三, 张麻子, 王五]

        //4. get(index)：返回指定位置的元素。
        String a = list.get(1);
        System.out.println(a);
        //输出结果为：张麻子
        
    }
}</code></pre> 
 <p><strong>运行结果为：</strong></p> 
 <p><img alt="" class="left" height="217" src="https://images2.imgbox.com/c9/8e/QWZrQLGi_o.png" width="335"></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.2%20List%20%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F">        1.2 List 集合的遍历方式</h3> 
<p>        <strong>除了 List 系列集合继承 Collcetion类的三个遍历方式之外，还支持普通的带索引的<span style="color:#fe2c24;"> for </span>循环。</strong></p> 
<blockquote> 
 <p> <strong>有关的 Collection 类的三个遍历方式的介绍在以下链接：</strong></p> 
 <p><strong><a href="https://blog.csdn.net/Tingfeng__/article/details/133929877?spm=1001.2014.3001.5501" title="进阶JAVA篇- Collection 类的常用的API与 Collection 集合的遍历方式-CSDN博客">进阶JAVA篇- Collection 类的常用的API与 Collection 集合的遍历方式-CSDN博客</a></strong></p> 
</blockquote> 
<p>        <strong>由于 List 系列集合支持支持有序的，所以可以使用普通带索引的 <span style="color:#fe2c24;">for </span>循环。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import java.util.ArrayList;
import java.util.List;

public class Text_List {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();//这是一行经典的代码！！！！
        list.add("张三");
        list.add("李四");
        list.add("王五");
        System.out.println(list);

        //用普通的 for 循环来遍历以上集合
        for (int i = 0; i &lt; list.size(); i++) {
            String a = list.get(i);
            System.out.println(a);
        }
    }
}</code></pre> 
 <p><strong>运行结果如下：</strong></p> 
 <p><img alt="" class="left" height="190" src="https://images2.imgbox.com/dc/99/uSXC0v7u_o.png" width="317"></p> 
</blockquote> 
<p>        </p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20ArrayList%20%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86">        2.0 ArrayList 集合的底层原理</h2> 
<p>        <strong>由于<span style="color:#fe2c24;"> ArrayList</span> 是 <span style="color:#fe2c24;">List</span> 的实现类，所以 <span style="color:#fe2c24;">ArrayList </span>特性与<span style="color:#fe2c24;"> List </span>接口是一致的，有序、可重复、有索引的特性。</strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A02.1%20%E4%BB%8E%C2%A0ArrayList%20%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%9D%A5%E4%BA%86%E8%A7%A3%E5%85%B7%E6%9C%89%E8%AF%A5%E7%89%B9%E6%80%A7%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A">       2.1 从 ArrayList 集合的底层原理来了解具有该特性的原因：</h3> 
<p>        <strong><span style="color:#fe2c24;">ArrayList</span> 集合是基于<span style="color:#ffd900;">数组</span>实现的，简单来说，<span style="color:#fe2c24;">ArrayList </span>集合就是一个可变长度的数组。因此可以解释为什么 <span style="color:#fe2c24;">ArrayList</span> 集合具有<span style="color:#fe2c24;">有序、可重复、有索引</span>的特性，是因为数组都具备这些特性。</strong></p> 
<p><strong>        创建的 <span style="color:#fe2c24;">ArrayList </span>集合的对象在底层的过程：</strong></p> 
<blockquote> 
 <p>        </p> 
 <pre><code class="language-java">import java.util.ArrayList;
import java.util.List;

public class Text_List {
    public static void main(String[] args) {

        //首先，利用无参构造器创建的集合，会在底层创建一个默认长度为0的数组
        List&lt;String&gt; list = new ArrayList&lt;&gt;();//这是一行经典的代码！！！！

        //当添加第一个元素的时候，会创建一个新的默认长度为10的数组
        list.add("a");
    }
}</code></pre> 
 <p>        <strong>需要注意的是：</strong></p> 
 <p><strong>        1. 假如数组存满的时候会创建一个新的已扩容1.5倍的数组，然后将原来旧的数组里面的数据，迁移到新的已扩容的数组中来。</strong></p> 
 <p><strong>        2. 如果一次添加多个元素，1.5倍还是放不下，则新创建数组的长度以实际为准。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A02.2%20ArrayList%20%E9%9B%86%E5%90%88%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">         2.2 ArrayList 集合的优缺点</h3> 
<p>        <strong>因为 <span style="color:#fe2c24;">ArrayList </span>是基于数组实现的，所以可以根据数组的特性来了解该集合的优缺点，由于数组是支持索引查找元素的，所以该集合的优点是很明显，查找元素特别的快。但是对于增添、删除、修改的操作来说是很慢的。</strong></p> 
<p><strong>        所以 <span style="color:#fe2c24;">ArrayList</span> 适合：根据索引查询数据。不适合：频繁对元素进行操作。</strong></p> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20LinkedList%20%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86">        3.0 LinkedList 集合的底层原理</h2> 
<p>        <strong>由于<span style="color:#fe2c24;"> LinkedList</span> 是 <span style="color:#fe2c24;">List</span> 的实现类，所以 <span style="color:#fe2c24;">LinkedList</span> 特性与 <span style="color:#fe2c24;">List </span>接口是一致的，有序、可重复、有索引的特性，但是与 <span style="color:#fe2c24;">ArrayList</span> 在底层的原理是不一样的。</strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%C2%A0%E4%BB%8E%20LinkedList%C2%A0%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%9D%A5%E4%BA%86%E8%A7%A3%E5%85%B7%E6%9C%89%E8%AF%A5%E7%89%B9%E6%80%A7%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A">        3.1 从 LinkedList 集合的底层原理来了解具有该特性的原因：</h3> 
<p>       <span style="color:#fe2c24;"> </span><strong><span style="color:#fe2c24;">LinkedList </span>集合是基于<span style="color:#ffd900;">双链表</span>实现的。</strong></p> 
<blockquote> 
 <p><strong>简答介绍以下双链表：</strong></p> 
 <p><strong>        链表中的每一个节点都是独立的对象，也就是说内存不是连续的，每一个节点都包含记录上一个节点的地址还有下一个节点的地址、数值。</strong></p> 
 <p><img alt="" class="left" height="209" src="https://images2.imgbox.com/e5/ff/hofD3tci_o.png" width="1200"></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%20LinkedList%C2%A0%E9%9B%86%E5%90%88%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">        3.2 LinkedList 集合的优缺点</h3> 
<p>        <strong>根据该集合的数据结构为双链表，每查询一个元素是从头或者尾一步一步地去查询的，而不能直接去找到其中的元素，所以查询是很慢的。对于增加、删除、修改元素的速度相对来说是快的。但是有两个节点很特殊，对于头、尾节点无论查询还是增加、删除、修改元素速度都很快的。</strong></p> 
<p><strong>        所以 <span style="color:#fe2c24;">LinkedList</span> 集合适合：频繁对元素操作的。不合适：大量的查找元素。</strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.3%20LinkedList%20%E9%9B%86%E5%90%88%E7%9A%84%E7%89%B9%E6%9C%89%E6%96%B9%E6%B3%95">        3.3 LinkedList 集合的特有方法</h3> 
<p><strong>以代码的形式来介绍：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import java.util.LinkedList;
public class Text_LinkedList {

    public static void main(String[] args) {
        LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();
        list.add("张三");
        list.add("李四");
        list.add("王五");
        System.out.println(list);
        //输出结果为：[张三, 李四, 王五]

        //1. addFirst() :在该列表开头插入指定的元素
        list.addFirst("王麻子");
        System.out.println(list);
        //输出结果为：[王麻子, 张三, 李四, 王五]

        //2. addLast() :将指定的元素追加到此列表的末尾
        list.addLast("张麻子");
        System.out.println(list);
        //输出结果为：[王麻子, 张三, 李四, 王五, 张麻子]

        //3. getFirst() :返回此列表中的第一个元素
        String a = list.getFirst();
        System.out.println(a);
        //输出结果为:王麻子

        //4. getLast() :返回此列表中的最后一个元素
        String b = list.getLast();
        System.out.println(b);
        //输出结果为：张麻子

        //5. removeFirst() :从此列表中删除并返回第一个元素
        list.removeFirst();
        System.out.println(list);
        //输出结果为：[张三, 李四, 王五, 张麻子]

        //6. removeLast() :从此列表中删除并返回最后一个元素
        list.removeLast();
        System.out.println(list);
        //输出结果为：[张三, 李四, 王五]
    }
}</code></pre> 
 <p><strong>运行结果如下：</strong></p> 
 <p><img alt="" class="left" height="272" src="https://images2.imgbox.com/b9/82/QpSlQtbz_o.png" width="311"></p> 
</blockquote> 
<p>        <strong>根据 <span style="color:#fe2c24;">LinkedList</span> 集合的数据结构的特性，其应用场景可以是用设计<span style="color:#fe2c24;">队列</span>（先进先出，后进后出），还可以用来设计<span style="color:#fe2c24;">栈</span>（先进后出，后进先出）。</strong></p> 
<hr> 
<hr> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/afc823106f5a28b83a30d4c6dfe38646/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">实现vue项目和springboot项目前后端数据交互</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7565e618c126b2616bd885a4b1cd7726/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【网络】‘‘三层交换机‘‘配置详解，看一遍就会！！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>