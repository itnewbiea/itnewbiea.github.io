<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Activity的生命周期和启动模式详解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Activity的生命周期和启动模式详解" />
<meta property="og:description" content="一、Activity生命周期 1.正常情况： (1) onCreate:
表示 Activty 正在被创建，这是 Activity 生命周期的第一个方法，可以做一些初始化的工作，比如：加载布局，绑定控件，初始化数据等等。
(2) onRestart:
表示 Activity 正在重新启动，通常由 Activty 由不可见变为可见时被调用。
触发场景：按 Home 键进入桌面，或者启动一个新的 Activity，这时当前 Activity 被暂停，然后又回到了该 Activity ，此时会触发 onRestart。
(3) onStart:
表示当前 Activity 正在被启动，此时 Activity 已经可见了，但是还未出现在前台，无法与用户交互，用户是看不到的。
(4) onResume:
当前 Activity 已经可见，出现在前台并且开始活动，onStart 和 onResume 都表示 Activity 可见，onStart 时候 Activity 还在后台，onResume 的时候 Activity 才显示到前台。
(5) onPause:
表示当前 Activity 正在停止，此时还是可见，正常情况下，接着就会调用 onStop 方法。
可以做一些数据存储，动画停止等轻量级回收工作，不能太耗时。因为这会影响到新 Activity 的显示，只有 onPause 执行完，新 Activity 的 onResume 方法才会执行。
注意例如弹出一个非全屏 Dialog 或者启动一个透明的 Activty，那么当前 onStop 方法不会调用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/41afdd8f01f87c2e23f59e566a1e7481/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-30T20:45:51+08:00" />
<meta property="article:modified_time" content="2022-06-30T20:45:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Activity的生命周期和启动模式详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Activity_0"></a>一、Activity生命周期</h3> 
<h4><a id="1_1"></a>1.正常情况：</h4> 
<p><strong>(1) onCreate:</strong></p> 
<blockquote> 
 <p>表示 <code>Activty</code> 正在被创建，这是 <code>Activity</code> 生命周期的第一个方法，可以做一些初始化的工作，比如：加载布局，绑定控件，初始化数据等等。</p> 
</blockquote> 
<p><strong>(2) onRestart:</strong></p> 
<blockquote> 
 <p>表示 Activity 正在<strong>重新</strong>启动，通常由 Activty 由不可见变为可见时被调用。</p> 
 <p>触发场景：按 Home 键进入桌面，或者启动一个新的 Activity，这时当前 Activity 被暂停，然后又回到了该 Activity ，此时会触发 onRestart。</p> 
</blockquote> 
<p><strong>(3) onStart:</strong></p> 
<blockquote> 
 <p>表示当前 Activity 正在被启动，此时 Activity 已经可见了，但是还未出现在<strong>前台</strong>，无法与用户交互，用户是看不到的。</p> 
</blockquote> 
<p><strong>(4) onResume:</strong></p> 
<blockquote> 
 <p>当前 Activity 已经可见，<strong>出现在前台</strong>并且开始活动，onStart 和 onResume 都表示 Activity 可见，onStart 时候 Activity 还在后台，onResume 的时候 Activity 才显示到前台。</p> 
</blockquote> 
<p><strong>(5) onPause:</strong></p> 
<blockquote> 
 <p>表示当前 Activity 正在停止，此时还是可见，正常情况下，接着就会调用 onStop 方法。</p> 
 <p>可以做一些数据存储，动画停止等轻量级回收工作，不能太耗时。因为这会影响到新 Activity 的显示，<strong>只有 onPause 执行完，新 Activity 的 onResume 方法才会执行</strong>。</p> 
 <p><strong>注意</strong>例如弹出一个非全屏 Dialog 或者启动一个透明的 Activty，那么当前 onStop 方法不会调用。</p> 
</blockquote> 
<p><strong>(6) onStop:</strong></p> 
<blockquote> 
 <p>表示 Activity 即将停止，不可见，可以做一些稍微重量级的会后工作，同样不能太耗时。</p> 
</blockquote> 
<p><strong>(7) onDestroy:</strong></p> 
<blockquote> 
 <p>表示 Activity 即将被销毁，这是 Activity 生命周期的最后一个回调，可以做一些回收工作和最终的资源释放。</p> 
</blockquote> 
<p><strong>生命周期流程图</strong></p> 
<p><img src="https://images2.imgbox.com/b5/21/Z2PfjCH6_o.png" alt=""></p> 
<h5><a id="_40"></a>拓展问题：</h5> 
<h6><a id="1onStartonResumeonPauseonStop_42"></a>1.onStart和onResume，onPause和onStop有什么实质上的不同？</h6> 
<blockquote> 
 <p>onStart 和 onStop 是从 Activity 是否可见角度来回调的，而 onResume 和 onPause 是从Activity是否位于前台来回调的。</p> 
</blockquote> 
<h6><a id="2A__B_B__onResume__A__onPause__46"></a>2.A 启动 B，那么 B 的 onResume 和 A 的 onPause 哪个先执行？</h6> 
<blockquote> 
 <p><strong>结论</strong>：A 先执行 <code>onPause()</code> 方法，紧接着 B 执行 <code>onCreate() -&gt; onSatar() -&gt; onResume()</code> 方法，接着执行 A的 <code>onStop()</code></p> 
</blockquote> 
<p><strong>原因：</strong></p> 
<blockquote> 
 <p>启动 Activity 的请求有 <code>Instrumentation</code> 通过 Binder 接口向 AMS 发送请求，AMS 内部维护着一个 ActivityStack 并负责栈内 Activity 的状态同步，接着 <code>AMS</code> 通过 <code>IApplicationThread</code>( 位于当前应用进程内) 的 Binder 接口去同步 Activity 的状态从而完成生命周期方法的调用。</p> 
 <p>调用 ApplicationThread.scheduleLaunchActivity 通过 handle.sendMessage 通知 ActivityThread 完成新Activity 的 onCreate，onStart，onResume的调用过程。</p> 
</blockquote> 
<pre><code>ActivtyStack.resumeTopActivityInnerLocked();//
---TaskDisplayArea.pauseBackStacks();//暂停所有堆栈或仅后堆栈中的所有活动
----ActivtyStack.startPausingLocked();//开始暂停当前处于 resumed 的活动
------ActivityStackSupervisor.realStartActivityLocked();

.... app 进程
ActivtyThread.handleLaunchActivity(){
----ActivtyThread.performLaunchActivity();
----1.ContextImpl appContext = createBaseContextForActivity(r);//创建该 context实现类
----2.mInstrumentation.newActivity();//通过appContext类加载器反射创建Activity
----3.LoadedApk.makeApplication();//创建application
----4.appContext与activity相关联
----5.执行activity.attach()方法。
----6.mInstrumentation.callActivityOnCreate();//执行oncreate方法 
</code></pre> 
<h4><a id="2__73"></a>2. 异常情况下的生命周期：</h4> 
<p><strong>1.系统配置发生改变导致Activity被杀死并重新创建</strong></p> 
<blockquote> 
 <p><strong>异常终止</strong>：点击了返回键 ，锁屏 ，点击 Home 键 ，有其它 APP 进入前台（比如接听电话） ，启动了新的Activity ，屏幕方向发生旋转 ，APP被杀死。</p> 
 <p><strong>总之</strong>：系统只在 Acitivity 被异常终止的时候才会触发 <code>onSaveInstanceState</code> 和 <code>onRestoreInstanceState</code></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/24/5d/xDjbCarP_o.png" alt=""></p> 
<p><strong>当系统配置变更，Activity 被销毁重建后的生命周期流程:</strong></p> 
<p><img src="https://images2.imgbox.com/bc/1e/brD5bwXp_o.png" alt=""></p> 
<blockquote> 
 <p>可以在 <code>onSaveInstanceState</code> 的 <code>Bundle</code> 中保存数据，在 <code>onRestoreInstanceState</code> 中恢复数据。系统自动为我们做了一定的恢复工作。当 Activity 重建时，系统会为我们保存当前 Activity 的视图结构，并在 Activity 重启后恢复数据。</p> 
</blockquote> 
<p><strong>View视图数据恢复：</strong></p> 
<blockquote> 
 <p>每个 <code>View</code> 都有 <code>onSaveInstanceState</code> 和 <code>onRestoreInstanceState</code> 方法。</p> 
 <p><code>Activity</code> 被恶意终止时，Activity 会调用 <code>onSaveInstanceState</code> 去保存数据，然后 <code>Activity</code> 会委托 <code>Window</code> 去保存数据，接着 <code>Window</code> 再委托它上面的顶级容器去保存数据，通常顶级容器是一个 <code>ViewGroup</code>，一般来说很可能是 <code>DecorVew</code>。最后底层容器再去一一通知它的子View来保存数据，即调用 <code>ViewGroup</code>的<code>dispatchSaveInstanceState()</code> 最终调用具体的View 的 <code>onSaveInstanceState</code> 去保存数据。</p> 
 <p><strong>注意</strong>：View的数据恢复必须要在当前xml中为其设置 ID，否则是无法恢复的。</p> 
 <p>具体保存的数据可以看View子类的具体实现。</p> 
 <p>Activity中的状态保存与恢复</p> 
</blockquote> 
<p><strong>2.资源内存不足导致Activty被杀死</strong></p> 
<p><strong>Acitivty的优先级：</strong></p> 
<blockquote> 
 <p>1.前台 Activity，正在与用户交互，优先级最高。</p> 
 <p>2.可见但非前台，比如弹窗，透明Activity启动。</p> 
 <p>3.后台Activity，已经被暂停的 Activity，优先级最低。</p> 
</blockquote> 
<p>后台工作不适合脱离四大组件而独立运行，这样的进程很容易被杀死，可以提供进程的优先级来降低被杀死的风险。</p> 
<p><strong>3.如何避免 Activity 重建</strong></p> 
<blockquote> 
 <p>在 <code>AndroidManifest</code> 中为 Activity 配置 configChanges 配置来避免因配置变更导致 Acitivty 被销毁重建。</p> 
 <p>这样只会走 Activity 的 <code>onConfigurationChanged</code> 方法。</p> 
 <pre><code>android:configChanges="screenSize|orientation|keyboardHidden|screenLayout" 
</code></pre> 
</blockquote> 
<h2><a id="2Activity_124"></a>2.Activity的启动模式</h2> 
<h3><a id="1LaunchMode_127"></a>1.LaunchMode</h3> 
<h4><a id="standard_130"></a>standard：标准模式</h4> 
<blockquote> 
 <p>系统默认的模式，每次启动一个 <code>Activity</code> 都会<strong>重新创建一个新的实例</strong>，不管这个实例是否存在。一个任务栈可以有多个该 <code>Activity</code> 的实例，每个实例也可以在不同的任务栈。</p> 
 <p>在该模式下，谁启动了该 <code>Acitivty</code>，当前 <code>Activity</code> 就运行在启动它的那个 <code>Activity</code> 的任务栈中。</p> 
 <p><strong>注意</strong>：在 <code>standard</code> 模式下，如果通过 <code>ApplicationContext</code> 去启动 <code>Activity</code>，会报异常，因为 <code>ApplicationContext</code> 启动的 <code>Activity</code> 没有所谓的任务栈。解决方法是为待启动的 <code>Activity</code> 指定 <code>FLAG_ACTIVITY_NEW_TASK</code> 标记位，这样启动的时候就会为它创建一个新的任务栈，这个时候待启动的 <code>Activity</code> 实际是以 <code>singleTask</code> 模式启动的。</p> 
 <p><strong>应用场景：</strong> 大多数 Activity 适用的场景。</p> 
</blockquote> 
<h4><a id="singleTop_140"></a>singleTop：栈顶复用模式</h4> 
<blockquote> 
 <p>如果要新创建的 <code>Activity</code> 已经位于任务栈的栈顶，那么次 <code>Activity</code> 不会被重新创建，同时它的 <code>onNewIntent</code> 方法会被调用，对应的 <code>onCreate</code> 和 <code>onStart</code> 方法不会被调用。</p> 
 <p>如果新创建的 <code>Activity</code> 实例已存在，<strong>但不位于栈顶</strong>，那么新 <code>Activity</code> 仍然会被重新创建。</p> 
 <p><strong>应用场景</strong>：通知栏点击收到的通知，需要启动一个Activity，就可以用singleTop，否则每次点击都会新建一个Activity</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/23/ee/pLMfaJWt_o.png" alt=""><br> <img src="https://images2.imgbox.com/fc/39/m1BGbcM8_o.png" alt=""></p> 
<h4><a id="singleTask_150"></a>singleTask：栈内复用模式</h4> 
<blockquote> 
 <p>一种单例模式，只要 Activity 在一个栈中存在，那么<strong>多次启动此 Activity 都不会重新创建实例</strong>，系统会调用其 <code>onNewIntent</code> 方法。当启动一个模式为 <code>singleTask</code> 的 <code>Acitivity</code> A 的时候，系统首先寻找是否有 A 想要的任务栈，如果不存在，则重启创建一个任务栈，将 A 放进去。如果存在该任务栈，检查该任务栈中是否有 A 的实例，如果没有，创建放入。如果存在A的实例，则系统会把 A 上方的其他 <code>Activity</code> 移除，让 A 位于栈顶，并调用 <code>onNewIntent</code> 方法。</p> 
 <p><strong>应用场景</strong> ：大多数App的主页。对于大部分应用，当我们在主界面点击回退按钮的时候都是退出应用那么当我们第一次进入主界面之后，主界面位于栈底，以后不管我们打开了多少个Activity，只要我们再次回到主界面，都应该使用将主界面Activity上所有的Activity移除的方式来让主界面Activity处于栈顶，而不是往栈顶新加一个主界面Activity的实例，通过这种方式能够保证退出应用时所有的Activity都能报销毁。</p> 
</blockquote> 
<p><strong>通过命令查看Activity任务栈情况</strong>：<code>adb shell dumpsys activity</code></p> 
<p><strong>场景一</strong>：A-&gt;B-&gt;C，B为 <code>singleTask</code> 模式，当前任务栈如下：</p> 
<p><img src="https://images2.imgbox.com/43/e3/4PnhnYRL_o.png" alt=""><br> 在【A,B,C】 中启动 B，任务栈如下：</p> 
<p><img src="https://images2.imgbox.com/74/89/6Vy43BG6_o.png" alt=""><br> <img src="https://images2.imgbox.com/1d/32/ERFyVM1z_o.png" alt=""><br> <strong>场景二：</strong> 当前任务栈为：A-&gt;B-&gt;C，接着以 <code>singTask</code> + <code>taskAffinity</code> = “com.ubtech.taskS2” 启动 <code>ActivityD</code></p> 
<p><img src="https://images2.imgbox.com/7c/e5/RB1YIqEt_o.png" alt=""><br> <img src="https://images2.imgbox.com/68/60/yMQ2c1PE_o.png" alt=""><br> <img src="https://images2.imgbox.com/64/3a/HQEbR9er_o.png" alt=""></p> 
<p><strong>直接按Back键回退情况：</strong></p> 
<blockquote> 
 <p>D -&gt; C -&gt; B -&gt; A -&gt; 桌面</p> 
</blockquote> 
<p><strong>查看手机的后台任务窗口如下</strong>：</p> 
<p>1.此时如果打开任务栈S2，则回退栈变为: D -&gt; 桌面</p> 
<p>2.此时如果打开任务栈S1，则回退栈变为：C-&gt;B-&gt;A-&gt;桌面<br> <img src="https://images2.imgbox.com/9c/00/oHcaP8kh_o.png" alt=""></p> 
<p><strong>Uniapp开发遇到问题</strong>：</p> 
<p><code>uniapp</code> 的主Activity的任务栈名称居然是打包的应用唯一标识码<br> <img src="https://images2.imgbox.com/d5/fe/xzfAaxoz_o.png" alt=""></p> 
<h4><a id="singleInstance_187"></a>singleInstance：单实例模式</h4> 
<blockquote> 
 <p>加强的 <code>singleTask</code>，具有此模式的 <code>Activity</code> 只能单独的位于一个任务栈中，整个系统只有一个实例。</p> 
 <p>**应用场景：**系统界面，如来电界面等。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/6b/61/wbhebbwj_o.png" alt=""><br> <img src="https://images2.imgbox.com/25/6b/2wmCaXVg_o.png" alt=""></p> 
<h4><a id="TaskAffinity_195"></a>TaskAffinity</h4> 
<blockquote> 
 <ul><li> <p>该参数标识了一个 Activity 所需要的任务栈的名称，默认情况下，所有的 Activity 的任务栈的名字都为应用的包名。</p> </li><li> <p>任务栈分为前台任务栈，后台任务栈，可以将后台任务栈切换到前台。</p> </li></ul> 
</blockquote> 
<h3><a id="2Activity__Flags__202"></a>2.Activity 中 Flags 含义</h3> 
<blockquote> 
 <p><code>FLAG_ACTIVITY_NEW_TASK</code></p> 
 <ul><li>这个标记位的作用就是为 Activity 指定 “singleTask” 模式，效果和在 xml 中指定该模式相同</li></ul> 
 <p><code>FLAT_ACTIVITY_SINGLE_TOP</code></p> 
 <ul><li>这个标记位的作用就是为 Activity 指定 “singleTop” 模式，效果和在 xml 中指定该模式相同</li></ul> 
 <p><code>FLAG_ACTIVITY_CLEAR_TOP</code></p> 
 <ul><li>具有此标记位的 Activity，当它启动时，在同一个任务栈中所有位于它上面的 Activity 都要出栈，需要和 <code>FLAG_ACTIVITY_NEW_TASK</code>配合使用，如果实例存在，会调用 <code>onNewIntent</code> 方法。</li></ul> 
 <p>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</p> 
 <ul><li>具有此标记位的 Activity 不会出现在历史 Acitivity 的列表中，如果不希望用户通过历史列表回到该 Activity的时候使用该标记位置，等同于在 xml 中指定 android:excludeFromRecents=“true”。不等同于回退栈中没有它。</li></ul> 
</blockquote> 
<h2><a id="3_IntentFilter_221"></a>3. IntentFilter匹配规则</h2> 
<h3><a id="1_224"></a>1.显示/隐式调用</h3> 
<h4><a id="1_227"></a>1.显示调用</h4> 
<pre><code>//1.显示调用方式一
Intent intent1 = new Intent(this,ActivityB.class);
startActivity(intent1);

//2.显示调用方式二
ComponentName component = new ComponentName(this,ActivityB.class);
Intent intent2 = new Intent();
intent2.setComponent(component);
startActivity(intent2);

//3.显示调用方式三
Intent intent3 = new Intent();
intent3.setClass(this,ActivityB.class);
startActivity(intent3); 
</code></pre> 
<h4><a id="2_246"></a>2.隐式调用</h4> 
<p>注意：必须在添加默认的<br> <img src="https://images2.imgbox.com/ae/ef/TxCGanTz_o.png" alt=""><br> <img src="https://images2.imgbox.com/b0/0c/TjQZcghF_o.png" alt=""></p> 
<h3><a id="2_252"></a>2.匹配规则</h3> 
<blockquote> 
 <ul><li> <p>IntentFilter 中的过滤信息有 action，category，data。</p> </li><li> <p>一个 IntentFilter 可以有多个 action，category，data。同一类别的信息共同约束当前类别的匹配过程。只有一个 Intent 同时匹配 action类别，category类别，data类别才算完全匹配。</p> </li><li> <p>一个 Activity 可以有多个 IntentFilter，一个 Intent 只要能匹配任何一组 intent-filter 即可。</p> </li></ul> 
</blockquote> 
<h4><a id="1_action_262"></a>1. action匹配规则</h4> 
<p><img src="https://images2.imgbox.com/ef/fd/WxkiJeEO_o.png" alt=""></p> 
<blockquote> 
 <p>Intent 中的 action 必须能后和 intent-filter 中的 action 匹配，一个 intent-filter 中有多个 action，Intent 中的 action 只要和其中的一个匹配就可。如果 Intent 中没有指定 action，则匹配失败。action 区分大小写。</p> 
</blockquote> 
<h4><a id="2category_266"></a>2.category匹配规则</h4> 
<p><img src="https://images2.imgbox.com/2c/55/6v9GBsw0_o.png" alt=""></p> 
<blockquote> 
 <ul><li><code>Intent</code> 中如果有 <code>category</code>，所有的 <code>category</code> 都必须和 <code>intent-filter</code> 中的其中一个匹配，如果 <code>Intent</code> 中 出现的 <code>category</code> 必须是 <code>intent-filter</code> 中已经定义的。</li><li><code>Intent</code> 中<strong>可以没有 category</strong>，仍可以匹配成功。系统在调用 <code>startActivity</code> 时候默认会为 <code>Intent</code> 添加 <code>"android.intent.category.DEFAULT"</code> 这个 <code>category</code>。</li><li>为了 <code>activity</code> 能够接受隐式调用，必须在 <code>intent-filter</code> 中指定 <code>"android.intent.category.DEFAULT"</code> 这个 <code>category</code>。</li></ul> 
</blockquote> 
<h4><a id="3_data_272"></a>3. data匹配规则</h4> 
<p><img src="https://images2.imgbox.com/84/c9/U5DiQRmZ_o.png" alt=""></p> 
<blockquote> 
 <ul><li>如果 intent-filter 中定义了 data，则 Intent中必须也要定义可匹配的 data。</li><li>data 分为两部分组成： mimeType 和 URI</li><li>mimeType 指媒体类型，比如 imgage/jpeg，audo/* 和 video/* 等，可以表示图片，文本，视频等不同的媒体格式。</li><li>URI 的每个部分都是一个单独的属性：<code>scheme</code>、<code>host</code>、<code>port</code> 和 <code>path</code></li><li>:: 
   <path>
     ，eg:content://com.example.project:200/folder/subfolder/etc 
   </path></li><li>Scheme: URI 模式，比如 http，file，content 等，如果 URI 未指定，则无效</li><li>Host: URI的主机名，未指定则整个 URI 则无效。</li><li>Port：URI中的端口号，仅当 URI 中指定 scheme 和 host参数时候该 port 才有效。</li><li>path：路径信息</li></ul> 
</blockquote> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ej9R78kJ-1656589436740)(https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1716c6edcb746569d91a6a419aa2f57~tplv-k3u1fbpfcp-zoom-in-crop-mark:1956:0:0:0.image?)]</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mP7vMxsb-1656589436740)(https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3b60e7009a1497d8371eb26bf848802~tplv-k3u1fbpfcp-zoom-in-crop-mark:1956:0:0:0.image?)]</p> 
<h3><a id="3Activity_289"></a>3.隐式Activity是否存在判断</h3> 
<blockquote> 
 <ul><li>通过 PackageManager.resolveActivity 判断</li><li>通过 PackageManager.queryIntentActivities() 判断，该方法返回一个集合列表。</li></ul> 
</blockquote> 
<h3><a id="4_295"></a>4.拓展问题</h3> 
<h4><a id="1ActivityFragment_296"></a>1.Activity和Fragment的区别</h4> 
<blockquote> 
 <ul><li> <p>Activity是系统的四大组件之一，由 <code>ActivityManager</code>管理，生命周期由系统控制。</p> </li><li> <p><code>Fragment</code>是在3.0后引入的组件，由<code>FragmentManager</code>管理，可以由<code>Activity</code>自由控制，引入或者删除，更方便。</p> </li><li> <p>由于<code>Fragment</code>是Activity管理，所以在使用的时候，要格外注意，创建之前需要<code>getFragmentByTag</code>或者<code>ById</code>查看一下是否已经有存在的，<code>FragmentManager</code>也跟<code>ActivityManager</code>一样有一个缓存机制。同一个TAG的<code>fragment</code>如果多次被添加到activity中，那么通过<code>getFragmentBytag</code>获取Fragment的时候返回的是最后一次被添加的Fragment</p> </li><li> <p><code>fragment</code>在显示到销毁的过程中会执行自己的生命周期。<code>onAttach</code> -&gt; <code>onCreate</code> -&gt;<code>onCreateView</code> -&gt; <code>onActivityCreate</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code> -&gt; <code>onPause</code> -&gt; <code>onStop</code> -&gt; <code>onDestroyView</code> -&gt; <code>onDestroy</code> -&gt; <code>onDetach</code></p> </li><li> <p>同时也受到activity生命周期的影响，activity onPause Fragment也会执行相应的onPause</p> </li></ul> 
</blockquote> 
<h3><a id="2setArgument_307"></a>2.为什么用setArgument传参，而不是使用带有参数的构造器？</h3> 
<blockquote> 
 <ul><li>可以通过构造函数和<code>setArgument</code>方式传递参数，一但写有参构造函数，就必要构建无参构造函数</li><li>通过构造函数传递参数隐患：当<code>Fragment</code>被重新创建，系统会调用<code>Fragment</code>中的默认构造函数，从而导致之前传递的参数不见了，官方推荐<code>setArgument</code>，<code>fragment</code>被销毁重建后，最终会通过反射无参构造实例化一个新的<code>Fragment</code>，并且给<code>mArgments</code>初始化为原先的值，而原来的<code>Fragment</code>实例的数据都丢失了，并重新进行了初始化</li><li>Activity重新创建时，会重新构建它所管理的Fragment，原先的Fragment的字段值将会全部丢失，但是通过Fragment.setArguments(Bundle bundle)方法设置的bundle会保留下来，并在重建时恢复。</li></ul> 
</blockquote> 
<h3><a id="3windowview__Activity__312"></a>3.window、view 和 Activity 的关系?</h3> 
<blockquote> 
 <p>Window 是 Android 中窗口的宏观定义，主要是管理 View 的创建，以及与 ViewRootImpl 的交互，将 Activity 与 View 解耦。<br> <strong>Activity 与 PhoneWindow 与 DecorView 之间什么关系？</strong><br> 一个 Activity 对应一个 Window 也就是 PhoneWindow，一个 PhoneWindow 持有一个 DecorView 的实例，DecorView 本身是一个 FrameLayout。</p> 
</blockquote> 
<h3><a id="4finish__onDestroy__318"></a>4.finish 方法后如何走到 onDestroy 的?</h3> 
<blockquote> 
 <p><strong>在Activity中调用finish()方法，会走哪些生命周期方法?</strong></p> 
 <p>如果<code>FirstActivt</code>中启动<code>SecondActivity</code>，则会先走<code>FisrtActivity</code>的<code>onPause</code>方法，然后走<code>SecondActivity</code>的<code>onCreate</code>-&gt;<code>onStart</code>-&gt;<code>onResume</code>-&gt;再到<code>FirstActivity</code>的<code>onStop</code>-&gt;<code>onDestory</code></p> 
</blockquote> 
<p><strong>面试官：为什么 Activity.finish() 之后 10s 才 onDestroy ？</strong></p> 
<blockquote> 
 <p>Activity 的 <code>onStop/onDestroy</code> 是依赖 <code>IdleHandler</code> 来回调的。正常情况下当主线程空闲时会调用。但是由于某些特殊场景下的问题，导致主线程迟迟无法空闲，onStop/onDestroy 也会迟迟得不到调用。但这并不意味着 Activity 永远得不到回收，系统提供了一个兜底机制，当 onResume 回调 10s 之后，如果仍然没有得到调用，会主动触发。</p> 
</blockquote> 
<h3><a id="5dialogActivity_328"></a>5.dialog会不会影响Activity生命周期，为什么?</h3> 
<blockquote> 
 <p>不会影响，Activity 生命周期回调都是 <code>AMS</code> 通过 <code>Binder</code> 通知应用进程调用的；而弹出 <code>Dialog</code>、<code>Toast</code>、<code>PopupWindow</code> 本质上都直接是通过 <code>WindowManager.addView</code> 显示的（没有经过 <code>AMS</code>），所以不会对生命周期有任何影响。</p> 
 <p>除非启动的是Theme为Dialog的Activity</p> 
</blockquote> 
<p>Destroy 也会迟迟得不到调用。但这并不意味着 Activity 永远得不到回收，系统提供了一个兜底机制，当 onResume 回调 10s 之后，如果仍然没有得到调用，会主动触发。</p> 
<h3><a id="5dialogActivity_335"></a>5.dialog会不会影响Activity生命周期，为什么?</h3> 
<blockquote> 
 <p>不会影响，Activity 生命周期回调都是 <code>AMS</code> 通过 <code>Binder</code> 通知应用进程调用的；而弹出 <code>Dialog</code>、<code>Toast</code>、<code>PopupWindow</code> 本质上都直接是通过 <code>WindowManager.addView</code> 显示的（没有经过 <code>AMS</code>），所以不会对生命周期有任何影响。</p> 
 <p>除非启动的是Theme为Dialog的Activity</p> 
</blockquote> 
<h3><a id="_340"></a>最后</h3> 
<p>如果大伙有什么好的学习方法或建议欢迎大家在评论中积极留言哈，希望大家能够共同学习、共同努力、共同进步。</p> 
<p><strong>小编在这里祝小伙伴们在未来的日子里都可以 升职加薪，当上总经理，出任CEO，迎娶白富美，走上人生巅峰！！</strong></p> 
<blockquote> 
 <p>不论遇到什么困难，都不应该成为我们放弃的理由！</p> 
</blockquote> 
<p>很多人在刚接触这个行业的时候或者是在遇到瓶颈期的时候，总会遇到一些问题，比如学了一段时间感觉没有方向感，不知道该从那里入手去学习，需要一份小编整理出来的学习资料的<strong>关注我主页或者点击扫描下方二维码免费领取~</strong><br> <img src="https://images2.imgbox.com/31/fb/UwmoCe8N_o.png" alt=""><br> 这里是关于<strong>我自己的Android 学习，面试文档，视频收集大整理</strong>，有兴趣的伙伴们可以看看~</p> 
<p>如果你看到了这里，觉得文章写得不错就给个赞呗？如果你觉得那里值得改进的，请给我留言，一定会认真查询，修正不足，谢谢。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8d2324161433f3271b6e47870c7ab018/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C#】二值化处理以及高斯模糊减轻毛刺效果</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/18f038fc1e945e3081e2abb64666f884/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Idea Maven项目打包工其他项目进行外部引用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>