<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>简单易懂的隐马尔可夫模型（HMM）讲解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="简单易懂的隐马尔可夫模型（HMM）讲解" />
<meta property="og:description" content="学习目标：
了解什么是马尔科夫链知道什么是HMM模型知道前向后向算法评估观察序列概率知道维特比算法解码隐藏状态序列了解鲍姆-韦尔奇算法知道HMM模型API的使用 一、马尔科夫链 在机器学习算法中，马尔可夫链(Markov chain)是个很重要的概念。马尔可夫链（Markov chain），又称离散时间马尔可夫链（discrete-time Markov chain），因俄国数学家安德烈·马尔可夫（俄语：Андрей Андреевич Марков）得名。
1.1 简介 马尔科夫链即为状态空间中从一个状态到另一个状态转换的随机过程。
该过程要求具备“无记忆”的性质：
下一状态的概率分布只能由当前状态决定，在时间序列中它前面的事件均与之无关。这种特定类型的“无记忆”称作马尔可夫性质。 马尔科夫链作为实际过程的统计模型具有许多应用。
在马尔可夫链的每一步，系统根据概率分布，可以从个状态变到另一个状态，也可以保持当前状一态。
状态的改变叫做转移，与不同的状态改变相关的概率叫做转移概率。
马尔可夫链的数学表示为：
既然某一时刻状态转移的概率只依赖前一个状态，那么只要求出系统中任意两个状态之间的转移概率，这个马尔科夫链的模型就定了。
1.2 经典举例 下图中的马尔科夫链是用来表示股市模型，共有三种状态：牛市（Bull market）, 熊市（Bear market）和横盘 （Stagnant market）。
每一个状态都以一定的概率转化到下一个状态。如，牛市以0.025的概率转化到横盘的状态。
这个状态概率转化图可以以矩阵的形式表示。如果我们定义矩阵阵P某一位置P(i, j)的值为P(j|i)，即从状态i变为状态j的概率。另外定义牛市、熊市、横盘的状态分别为0、1、2，这样我们得到了马尔科夫链模型的状态转移矩阵为： 当这个状态转移矩阵P确定以后，整个股市模型就已经确定！
二、HMM简介 隐马尔可夫模型（Hidden Markov Model，HMM）是统计模型，它用来描述一个含有隐含未知参数的马尔可夫过程。
其难点是从可观察的参数中确定该过程的隐含参数。然后利用这些参数来作进一步的分析，例如模式识别。
2.1 简单案例 下面我们一起用一个简单的例子来阐述：
假设我手里有三个不同的骰子
第一个骰子是我们平常见的骰子（称这个骰子为D6），6个面，每个面（1，2，3，4，5，6）出现的概率是1/6。第二个骰字是个四面体（称这个骰子为D4），每个面（1，2，3，4）出现的概率是1/4。第三个骰子有八个面（称这个骰子为D8），每个子（1，2，3，4，5，6，7，8）出现的概率是1/8。 我们开始掷骰子，我们先从三个骰子里挑一个，挑到每一个骰子的概率都是1/3。然后我们掷骰子，得到一个数字，1，2，3，4，5，6，7，8中的一个。不停的重复上述过程，我们会得到一串数字，每个数字都是1，2，3，4，5，6，7，8中的一个。例如我们可能得到这么一串数字（掷骰子10次）：1 6 3 5 2 7 3 5 2 4这串数字叫做可见状态链。 但是在隐马尔可夫模型中，我们不仅仅有这么一串可见状态链，还有一串隐含状态链。
在这个例子里，这串隐含状态链就是你用的骰子的序列。
比如，隐含状态链有可能是：D6 D8 D8 D6 D4 D8 D6 D6 D4 D8 一般来说，HMM中说到的马尔可夫链其实是指隐含状态链，因为隐含状态（骰子）之间存在转换概率（transition probability）。
在我们这个例子里，D6的下一个状态是D4，D6，D8的概率都是1/3。D4，D8的下一个状态是D4，D6，D8的转换
概率也都一样是1/3。
这样设定是为了最开始容易说清楚，但是我们其实是可以随意设定转换概率的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/44b2974d840edeb556fc1cdad28fedc3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-05T15:04:24+08:00" />
<meta property="article:modified_time" content="2023-01-05T15:04:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">简单易懂的隐马尔可夫模型（HMM）讲解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>学习目标：</strong></p> 
<ul><li>了解什么是马尔科夫链</li><li>知道什么是HMM模型</li><li>知道前向后向算法评估观察序列概率</li><li>知道维特比算法解码隐藏状态序列</li><li>了解鲍姆-韦尔奇算法</li><li>知道HMM模型API的使用</li></ul> 
<h3>一、<strong>马尔科夫链</strong></h3> 
<p>在机器学习算法中，马尔可夫链(Markov chain)是个很重要的概念。马尔可夫链（Markov chain），又称离散时间马尔可夫链（discrete-time Markov chain），因俄国数学家安德烈·马尔可夫（俄语：Андрей Андреевич Марков）得名。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6e/43/Y97wGZxO_o.png"></p> 
<h4>1.1 简介</h4> 
<p>马尔科夫链即为状态空间中从一个状态到另一个状态转换的随机过程。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/28/f8/FQ4a1Npa_o.png"></p> 
<p>该过程要求具备“无记忆”的性质：</p> 
<ul><li>下一状态的概率分布只能由当前状态决定，在时间序列中它前面的事件均与之无关。这种特定类型的“无记忆”称作马尔可夫性质。</li></ul> 
<p>马尔科夫链作为实际过程的统计模型具有许多应用。</p> 
<p>在马尔可夫链的每一步，系统根据概率分布，可以从个状态变到另一个状态，也可以保持当前状一态。</p> 
<p>状态的改变叫做转移，与不同的状态改变相关的概率叫做转移概率。</p> 
<p>马尔可夫链的数学表示为：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a9/0c/YwQuHvxk_o.png"></p> 
<p>既然某一时刻状态转移的概率只依赖前一个状态，那么只要求出系统中任意两个状态之间的转移概率，这个马尔科夫链的模型就定了。</p> 
<h4>1.2 <strong>经典举例</strong></h4> 
<p>下图中的马尔科夫链是用来表示股市模型，共有三种状态：牛市（Bull market）, 熊市（Bear market）和横盘 （Stagnant market）。</p> 
<p>每一个状态都以一定的概率转化到下一个状态。如，牛市以0.025的概率转化到横盘的状态。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9b/55/gLINVXqM_o.png"></p> 
<ul><li>这个状态概率转化图可以以矩阵的形式表示。</li><li>如果我们定义矩阵阵P某一位置P(i, j)的值为P(j|i)，即从状态i变为状态j的概率。</li><li>另外定义牛市、熊市、横盘的状态分别为0、1、2，这样我们得到了马尔科夫链模型的状态转移矩阵为：</li></ul> 
<p>当这个状态转移矩阵P确定以后，整个股市模型就已经确定！</p> 
<h3>二、<strong>HMM简介</strong></h3> 
<p>隐马尔可夫模型（Hidden Markov Model，HMM）是统计模型，它用来描述一个含有隐含未知参数的马尔可夫过程。</p> 
<p>其难点是从可观察的参数中确定该过程的隐含参数。然后利用这些参数来作进一步的分析，例如模式识别。</p> 
<h4>2.1 简单案例</h4> 
<p>下面我们一起用一个简单的例子来阐述：</p> 
<p>假设我手里有三个不同的骰子</p> 
<ul><li>第一个骰子是我们平常见的骰子（称这个骰子为D6），6个面，每个面（1，2，3，4，5，6）出现的概率是</li><li>1/6。</li><li>第二个骰字是个四面体（称这个骰子为D4），每个面（1，2，3，4）出现的概率是1/4。</li><li>第三个骰子有八个面（称这个骰子为D8），每个子（1，2，3，4，5，6，7，8）出现的概率是1/8。</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/42/39/YKID7wUO_o.png"></p> 
<ul><li>我们开始掷骰子，我们先从三个骰子里挑一个，挑到每一个骰子的概率都是1/3。</li><li>然后我们掷骰子，得到一个数字，1，2，3，4，5，6，7，8中的一个。不停的重复上述过程，我们会得到一串数</li><li>字，每个数字都是1，2，3，4，5，6，7，8中的一个。</li><li>例如我们可能得到这么一串数字（掷骰子10次）：1 6 3 5 2 7 3 5 2 4这串数字叫做可见状态链。</li></ul> 
<p>但是在隐马尔可夫模型中，我们不仅仅有这么一串可见状态链，还有一串隐含状态链。</p> 
<p>在这个例子里，这串隐含状态链就是你用的骰子的序列。</p> 
<ul><li>比如，隐含状态链有可能是：D6 D8 D8 D6 D4 D8 D6 D6 D4 D8</li></ul> 
<p>一般来说，HMM中说到的马尔可夫链其实是指隐含状态链，因为隐含状态（骰子）之间存在转换概率（transition probability）。</p> 
<p>在我们这个例子里，D6的下一个状态是D4，D6，D8的概率都是1/3。D4，D8的下一个状态是D4，D6，D8的转换</p> 
<p>概率也都一样是1/3。</p> 
<p>这样设定是为了最开始容易说清楚，但是我们其实是可以随意设定转换概率的。</p> 
<ul><li>比如，我们可以这样定义，D6后面不能接D4，D6后面是D6的概率是0.9，是D8的概率是0.1。</li><li>这样就是一个新的HMM。</li></ul> 
<p>同样的，尽管可见状态之间没有转换概率，但是隐含状态和可见状态之间有一个概率叫做输出概率（emission probability）。</p> 
<ul><li>就我们的例子来说，六面骰（D6）产生1的输出概率是1/6。产生2，3，4，5，6的概率也都是1/6。</li><li>我们同样可以对输出概率进行其他定义。比如，我有一个被赌场动过手脚的六面骰子，掷出来是1的概率更大，是1/2，掷出来是2，3，4，5，6的概率是1/10</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f2/f5/avIhlNTU_o.png"></p> 
<p>其实对于HMM来说，如果提前知道所有隐含状态之间的转换概率和所有隐含状态到所有可见状态之间的输出概率，做模拟是相当容易的。但是应用HMM模型时候呢，往往是缺失了一部分信息的。</p> 
<ul><li>有时候你知道骰子有几种，每种骰子是什么，但是不知道掷出来的骰子序列；</li><li>有时候你只是看到了很多次掷骰子的结果，剩下的什么都不知道。</li></ul> 
<p>如果应用算法去估计这些缺失的信息，就成了一个很重要的问题。这些算法我会在后面详细讲。</p> 
<h4>2.2 <strong>案例进阶</strong></h4> 
<p><strong>2.2.1 问题阐述</strong></p> 
<p>和HMM模型相关的算法主要分为三类，分别解决三种问题：</p> 
<p><strong>1）知道骰子有一种（隐含状态数量），每种骰子是什么（转换概率），根据掷骰子掷出的结果（可见状态链），我想</strong></p> 
<p>知道每次掷出来的都是哪种骰子（隐含状态链）。</p> 
<ul><li>这个问题呢，在语音识别领域呢，叫做解码问题。</li><li>这个问题其实有两种解法，会给出两个不同的答案。每个答案都对，只不过这些答案的意义不一样。</li></ul> 
<p>第一种解法求最大似然状态路径，说通俗点呢，就是我求一串骰子序列，这串骰子序列产生观测结果的概率最大。</p> 
<p>第二种解法呢，就不是求一组骰子序列了，而是求每次掷出的骰子分别是某种骰子的概率。比如说我看到结果</p> 
<p>后，我可以求得第一次掷骰子是D4的概率是0.5，D6的概率是0.3，D8的概率是0.2。</p> 
<p><strong>2）还是知道骰子有几种（隐含状态数量），每种骰子是什么（转换概率），根据掷骰⼦掷出的结果（可见状态链）。</strong></p> 
<ul><li>我想知道掷出这个结果的概率。</li><li>看似这个问题意义不大，因为你掷出来的结果很多时候都对应了一个比较大的概率。</li><li>问这个问题的目的呢，其实是检测观察到的结果和已知的模型是否吻合。</li><li>如果很多次结果都对应了比较小的概率，那么就说明我们已知的模型很有可能是错的，有人偷偷把我们的骰子給换了。</li></ul> 
<p><strong>3）知道骰子有几种（隐含状态数量），不知道每种骰子是什么（转换概率），观测到很多次掷骰子的结果（可见状态链），我想反推出每种骰子是什么（转换概率）。</strong></p> 
<ul><li>这个问题很重要，因为这是最常见的情况。</li><li>很多时候我们只有可见结果，不知道HMM模型里的参数，我们需要从可见结果估计出这些参数，这是建模的一个必要步骤。</li></ul> 
<p><strong>2.2.2 问题解决</strong></p> 
<p><strong>一个简单问题【对应问题二】</strong></p> 
<p>其实这个问题实用价值不高。由于对下面较难的问题有帮助，所以先在这里提一下。</p> 
<ul><li>知道骰子有几种，每种骰子是什么，每次掷的都是什么骰子，根据掷骰子掷出的结果，求产生这个结果的概率</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/03/32/OFmm7FQC_o.png"></p> 
<p>解法无非就是概率相乘：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/54/01/Ra0l6GfA_o.png"></p> 
<p><strong>看见不可见的，破解骰子序列【对应问题一】</strong></p> 
<p>这里我说的是第一种解法，解最大似然路径问题。</p> 
<p>举例来说，我知道我有三个骰子，六面骰，四面骰，八面骰。我也知道我掷了十次的结果</p> 
<p>（1 6 3 5 2 7 3 5 2 4），我不知道每次用了那种骰子，我想知道最有可能的骰子序列。</p> 
<p>其实最简单而暴力的方法就是穷举所有可能的骰子序列，然后依照上一个问题的解法把每个序列对应的概率算出来。然</p> 
<p>后我们从里面把对应最大概率的序列挑出来就行了。</p> 
<p>如果马尔可夫链不长，当然可行。如果长的话，穷举的数量太大，就很难完成了。</p> 
<p>另外一种很有名的算法叫做维特比算法（Viterbi algorithm）. 要理解这个算法，我们先看几个简单的列子。 首先，如果我们只掷一次骰子：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f7/37/z7POO4RW_o.png"></p> 
<p>看到结果为1.对应的最大概率骰子序列就是D4，因为D4产生1的概率是1/4，高于1/6和1/8.</p> 
<p>把这个情况拓展，我们掷两次骰子：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e8/39/SgXEwO4M_o.png"></p> 
<p>结果为1，6.这时问题变得复杂起来，我们要计算三个值，分别是第二个骰子是D6，D4，D8的最大概率。显然，要取到</p> 
<p>最大概率，第一个骰子必须为D4。这时，第二个骰子取到D6的最大概率是：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/94/51/0LN3aiF3_o.png"></p> 
<p>同样的，我们可以计算第二个骰子是D4或D8时的最大概率。我们发现，第个骰二取到D6的概率最大。而使这个概率最大时，第一个骰⼦为D4。所以最大概率骰子序列就是D4 D6。 继续拓展，我们掷三次骰子：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/00/a1/D8NUXnzv_o.png"></p> 
<p>同样，我们计算第三个骰子分别是D6，D4，D8的最大概率。我们再次发现，要取到最大概率，第二个骰子必须为D6。</p> 
<p>这时，第三个骰子取到D4的最大概率是：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c2/2f/ZYJbVqJy_o.png"></p> 
<p>同上，我们可以计算第三个骰子是D6或D8时的最大概率。我们发现，第三个骰子取到D4的概率最大。而使这个概率最大时，第二个骰子为D6，第一个骰子为D4。所以最大概率骰子序列就是D4 D6 D4。</p> 
<p>写到这里，大家应该看出点规律了。既然掷骰子一、二、三次可以算，掷多少次都可以以此类推。</p> 
<p>我们发现，我们要求最大概率骰子序列时要做这么几件事情。</p> 
<ul><li>首先，不管序列多长，要从序列长度为1算起，算序列长度为1时取到每个骰子的最大概率。</li><li>然后，逐渐增加长度，每增加一次长度，重新算一遍在这个长度下最后一个位置取到每个骰子的最大概率。因为上一个长度下的取到每个骰子的最大概率都算过了，重新计算的话其实不难。</li><li>当我们算到最后一位时，就知道最后一位是哪个骰子的概率最大了。然后，我们要把对应这个最大概率的序列从后往前推出来。</li></ul> 
<p><strong>谁动了我的骰子？【对应问题三】</strong></p> 
<p>比如说你怀疑自己的六面骰被赌场动过手脚了，有可能被换成另一种六面骰，这种六面骰掷出来是1的概率更大，是1/2，掷出来是2，3，4，5，6的概率是1/10。你怎么办么？</p> 
<p>答案很简单，算一算正常的三个骰子掷出一段序列的概率，再算一算不正常的六面骰和另外两个正常骰子掷出这段</p> 
<p>序列的概率。如果前者比后者小，你就要小心了。</p> 
<p>比如说掷骰子的结果是：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c1/36/mHif5kDo_o.png"></p> 
<p>要算用正常的三个骰子掷出这个结果的概率，其实就是将所有可能情况的概率进行加和计算。</p> 
<p>同样，简单而暴力的方法就是把穷举所有的骰子序列，还是计算每个骰子序列对应的概率，但是这回，我们不挑最大值了，而是把所有算出来的概率相加，得到的总概率就是我们要求的结果。这个方法依然不能应用于太长的骰子序列（马尔可夫链）。 我们会应应用个和前一个问题类似的解法，只不过前一个问题关心的是概率最大值，这个问题关心的是概率之和。解决这个问题的算法叫做前向算法（forward algorithm）。</p> 
<p>首先，如果我们只掷一次骰子：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1f/ac/4RLD4YVW_o.png"></p> 
<p>看到结果为1.产生这个结果的总概率可以按照如下计算，总概率为0.18：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/75/d0/LPxFWlW0_o.png"></p> 
<p>把这个情况拓展，我们掷两次骰子：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/25/fd/SGqaEhP2_o.png"></p> 
<p>看到结果为1，6.产生这个结果的总概率可以按照如下计算，总概率为0.05：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d8/4b/tGZGkU44_o.png"></p> 
<p>继续拓展，我们掷三次骰子：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/52/67/6nfpTYXt_o.png"></p> 
<p>看到结果为1，6，3.产生这个结果的总概率可以按照如下计算，总概率为0.03：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c1/b3/sMCzRDqI_o.png"></p> 
<p>同样的，我们一步一步的算，有多长算多长，再长的马尔可夫链总能算出来的。</p> 
<p>同同样的方法，也可以算出不正常的六面骰和另外两个正常骰子掷出这段序列的概率，然后我们比较一下这两个概率大小，就能知道你的骰子是不是被人换了。</p> 
<h3>三、<strong>HMM模型基础</strong></h3> 
<h4><strong>3.1 </strong><strong>什么样的问题需要HMM模型</strong></h4> 
<p>首先我们来看看什么样的问题解决可以用HMM模型。使用HMM模型时我们的问题一般有这两个特征：</p> 
<p>１）我们的问题是基于序列的，比如时间序列，或者状态序列。</p> 
<p>２）我们的问题中有两类数据，</p> 
<p>一类序列数据是可以观测到的，即观测序列；</p> 
<p>而另一类数据是不能观察到的，即隐藏状态序列，简称状态序列。</p> 
<p>有了这两个特征，那么这个问题一般可以用HMM模型来尝试解决。这样的问题在实际生活中是很多的。</p> 
<ul><li>比如：我现在给大家写课件，我在键盘上敲出来的一系列字符就是观测序列，而我实际想写的一段话就是隐藏状态序列，输入法的任务就是从敲入的一系列字符尽可能的猜测我要写的一段话，并把最可能的词语放在最前面让我选择，这就可以看做一个HMM模型了。</li><li>再举一个，假如我上课讲课，我发出的一串连续的声音就是观测序列，而我实际要表达的一段话就是隐藏状态序列，你大脑的任务，就是从这一串连续的声音中判断出我最可能要表达的话的内容。</li></ul> 
<p>从这些例子中，我们可以发现，HMM模型可以无处不在。但是上面的描述还不精确，下面我们用精确的数学符号来表述我们的HMM模型。</p> 
<h4>3.2 <strong>HMM模型的定义</strong></h4> 
<p>对于HMM模型，首先我们假设Q是所有可能的隐藏状态的集合，V是所有可能的观测状态的集合，即：</p> 
<ul><li><em>Q </em>= <em>q</em>1, <em>q</em>2, ..., <em>qN</em></li><li><em>V </em>= <em>v</em>1, <em>v</em>2, ...<em>vM</em></li></ul> 
<p>其中，N是可能的隐藏状态数，M是所有的可能的观察状态数。</p> 
<p>对于一个长度为T的序列，i是对应的状态序列, O是对应的观察序列，即：</p> 
<ul><li><em>i </em>= <em>i</em>1,<em>i</em>2, ...,<em>iT</em></li><li><em>O </em>= <em>o</em>1, <em>o</em>2, ...<em>oT</em></li></ul> 
<p>其中，任意一个隐藏状态<em>it </em>∈ <em>Q</em>, 任意一个观察状态<em>ot </em>∈ <em>V</em></p> 
<p>HMM模型做了两个很重要的假设如下：</p> 
<p><strong>1） 其次马尔科夫链假设</strong></p> 
<p><strong>即任意时刻的隐藏状态只依赖于它前一个隐藏状态。</strong></p> 
<p>当然这样假设有点极端，因为很多时候我们的某一个隐藏状态不仅仅只依赖于前一个隐藏状态，可能是前两个</p> 
<p>或者是前三个。</p> 
<p>但是这样假设的好处就是模型简单，便于求解。</p> 
<p>如果在时刻t的隐藏状态是i = q ,在时刻t + 1的隐藏状态是i = q , 则从时刻t到时刻t+1的HMM状态转移概率</p> 
<p><em>a </em>= <em>P</em>(<em>i </em>= <em>q </em>∣<em>i </em>= <em>q </em>)</p> 
<p>这样<em>a </em>可以组成⻢尔科夫链的状态转移矩阵A:</p> 
<p><em>A=[aij]N×N</em></p> 
<p><strong>2） 观测独立性假设。</strong></p> 
<p>即任意时刻的观察状态只仅仅依赖于当前时刻的隐藏状态，这也是一个为了简化模型的假设。</p> 
<ul><li>如果在时刻t的隐藏状态是i = q , 而对应的观察状态为o = v , 则该时刻观察状态v 在隐藏状态q 下生成的概率为b (k),满足：</li></ul> 
<p><em>b </em>(<em>k</em>) = <em>P</em>(<em>o </em>= <em>v </em>∣<em>i </em>= <em>q </em>)</p> 
<p>这样<em>b </em>(<em>k</em>)可以组成观测状态生成的概率矩阵B:</p> 
<p><em>B </em>= [<em>b </em>(<em>k</em>)<em>N×M</em></p> 
<p>除此之外，我们需要一组在时刻t=1的隐藏状态概率分布Π :</p> 
<p>Π = [Π ]<em>N</em></p> 
<p>其中Π = <em>P</em>(<em>i </em>= <em>q </em>)</p> 
<p>一个HMM模型，可以由隐藏状态初始概率分布Π , 状态转移概率矩阵A和观测状态概率矩阵B决定。</p> 
<p>Π ,A决定状态序列，B决定观测序列。</p> 
<p>因此，HMM模型可以由一个三元组λ 表示如下：</p> 
<p>λ = (A, B, Π) = (状态序列，观测序列，初始状态概率分布)</p> 
<h4>3.3 一<strong>个HMM模型实例</strong></h4> 
<p>下面我们用一个简单的实例来描述上面抽象出的HMM模型。这是一个盒子与球的模型。</p> 
<p>例子来源于李航的《统计学习方法》。</p> 
<p>假设我们有3个盒子，每个盒子里都有红色和白色两种球，这三个盒子里球的数量分别是：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/78/56/C4xQDZEc_o.png"></p> 
<p>按照下面的方法从盒子里抽球，开始的时候，</p> 
<ul><li>从第一个盒子抽球的概率是0.2，</li><li>从第二个盒子抽球的概率是0.4，</li></ul> 
<p>以这个概率抽一次球后，将球放回。</p> 
<p>然后从当前盒子转移到下面个盒子进行抽球。规则是：</p> 
<ul><li>如果当前抽球的盒子是第一个盒子，则以0.5的概率仍然留在第一个盒子继续抽球，以0.2的概率去第二个盒子抽球，以0.3的概率去第三个盒子抽球。</li><li>如果当前抽球的盒子是第二个盒子，则以0.5的概率仍然留在第二个盒子继续抽球，以0.3的概率去第三个盒子抽球，以0.2的概率去第三个盒子抽球。</li><li>如果当前抽球的盒子是第三个盒子，则以0.5的概率仍然留在第三个盒子继续抽球，以0.2的概率去第二个盒子抽球，以0.3的概率去第二个盒子抽球。</li></ul> 
<p>如此下去，直到重复三次，得到一个球的颜色的观测序列:</p> 
<p>O={红，⽩，红}</p> 
<p>注意在这个过程中，<strong>观察者只能看到球的颜色序列，却不能看到球是从哪个盒子里取出的。</strong></p> 
<p>那么按照我们前面HMM模型的定义，我们的观察状态集合是:</p> 
<ul><li>V={红，⽩}，M=2</li></ul> 
<p>我们的隐藏状态集合是：</p> 
<p>Q={盒⼦1，盒⼦2，盒⼦3}，N=3</p> 
<p>而观察序列和状态序列的长度为3. 初始状态分布Π为：</p> 
<ul><li>Π = (0.2, 0.4, 0.4) <em>T</em></li></ul> 
<p>状态转移概率分布A矩阵为：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1e/d1/WhiBRgt3_o.png"></p> 
<p>观测状态概率B矩阵为：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a8/82/ibXa0YqQ_o.png"></p> 
<h4>3.4 <strong>HMM观测序列的生成</strong></h4> 
<p>从上面的例子，我们也可以抽象出HMM观测序列生成的过程。</p> 
<ul><li>输入的是HMM的模型λ = (A, B, Π),观测序列的长度T</li><li>输出是观测序列O = o , o , ...o</li></ul> 
<p>生成的过程如下：</p> 
<p>1）根据初始状态概率分布Π生隐藏状态i</p> 
<p>2) for t from 1 to T</p> 
<ul><li>a. 按照隐藏状态i 的观测状态分布b (k)生成观察状态o</li><li>b. 按照隐藏状态i 的状态转移概率分布ai ,i 产生隐藏状态it+1</li></ul> 
<p>所有的o 一起形成观测序列O = o , o , ...or</p> 
<h4>3.5 <strong>HMM模型的三个基本问题</strong></h4> 
<p>HMM模型一共有三个经典的问题需要解决：</p> 
<p>1）评估观察序列概率 —— 前向后向的概率计算</p> 
<ul><li>即给定模型λ = (A, B, Π)和观测序列O = {o , o , ...o }，计算在模型 λ 下某一个观测序列O出现的概率P(O|λ )。</li><li>这个问题的求解需要用到前向后向算法，是HMM模型三个问题中最简单的。</li></ul> 
<p>2）预测问题，也称为解码问题 ——维特比（Viterbi）算法</p> 
<ul><li>即给定模型<em>λ </em>= (<em>A</em>, <em>B</em>, Π)和观测序列<em>O </em>= {<!-- --><em>o </em>, <em>o </em>, ...<em>o </em>}，求给定观测序列条件下，最可能出现的对应的状态序列。</li><li>这个问题的求解需要用到基于动态规划的维特比算法，是HMM模型三个问题中复杂度居中的算法。</li></ul> 
<p>3）模型参数学习问题 —— 鲍姆-韦尔奇（Baum-Welch）算法(状态未知) ，这是一个学习问题</p> 
<ul><li>即给定观测序列O = {o , o , ...o }，估计模型λ = (A, B, Π)的参数，使该模型下观测序列的条件概率P(O∣λ)最大。</li><li>这个问题的求解需要用到基于EM算法的鲍姆-韦尔奇算法，是HMM模型三个问题中最复杂的。</li></ul> 
<p>接下来的三节，我们将基于这个三个问题展开讨论</p> 
<h3>四、<strong>前向后向算法评估观察序列概率</strong></h3> 
<h4><strong>4.1 回顾HMM问题一：求观测序列的概率</strong></h4> 
<p>首先我们回顾下HMM模型的问题一。这个问题是这样的。</p> 
<p>我们已知HMM模型的参数λ = (A, B, Π)。</p> 
<blockquote>
  其中A是隐藏状态转移概率的矩阵， 
 <br> B是观测状态生成概率的矩阵， 
 <br> Π 是隐藏状态的初始概率分布。 
</blockquote> 
<p>同时我们也已经得到了观测序列O = {o1, o2, ...oT },</p> 
<p>现在我们要求观测序列O在模型λ 下出现的条件概率P(O∣λ)。</p> 
<p>乍一看，这个问题很简单。因为我们知道所有的隐藏状态之间的转移概率和所有从隐藏状态到观测状态生成概率，那么我们是可以暴力求解的。</p> 
<p>我们可以列举出所有可能出现的长度为T的隐藏序列<em>i </em>= {<!-- --><em>i</em>1,<em>i</em>2, ...,<em>iT </em>},分别求出这些隐藏序列与观测序列</p> 
<p>O = {o1, o2, ...oT }的联合概率分布P(O,i∣λ)，这样我们就可以很容易的求出边缘分布P(O∣λ)了。</p> 
<p>具体暴力求解的求解法是这样的：</p> 
<p>首先，任意隐藏序列<em>i </em>= <em>i</em>1,<em>i</em>2, ...,<em>iT</em>出现的概率是：</p> 
<p>P(i∣λ) = Πi1ai1,i2ai2,i3...aiT−1,iT</p> 
<p>对于固定的状态序列i = i1,i2, ...,iT，我们要求的观察序列O = o1, o2, ...oT 出现的概率是：</p> 
<p>P(O∣i, λ) = bi1(o1)bi2(o2)...biT (oT )</p> 
<p>则O和i联合出现的概率是：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/64/df/bSQxqsxT_o.png"></p> 
<p>然后求边缘概率分布，即可得到观测序列O在模型λ 下出现的条件概率P(O|λ )P(O|λ )：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/32/7a/Jy6AWQxJ_o.png"></p> 
<p>虽然上述方法有效，但是如果我们的隐藏状态数N非常多的那就麻烦了，此时我们预测状态有N 种组合，算法的时间复杂度是O(T N )阶的。</p> 
<p>因此对于一些隐藏状态数极少的模型，我们可以用暴力求解法来得到观测序列出现的概率，但是如果隐藏状态多，则上述算法太耗时，我们需要寻找其他简洁的算法。</p> 
<p>前向后向算法就是来帮助我们在较低的时间复杂度情况下求解这个问题的。</p> 
<h4>4.2 用<strong>前向算法求HMM观测序列的概率</strong></h4> 
<p>前向后向算法是前向算法和后向算法的统称，这两个算法都可以用来求HMM观测序列的概率。我们先来看看前向算法是如何求解这个问题的。</p> 
<p><strong>4.2.1 流程梳理</strong></p> 
<p>前向算法本质上属于动态规划的算法，也就是我们要通过找到局部状态递推的公式，这样一步步的从子问题的最优解拓展到整个问题的最优解。</p> 
<ul><li>在前向算法中，通过定义“前向概率”来定义动态规划的这个局部状态。</li><li>什么是前向概率呢, 其实定义很简单：定义时刻t时隐藏状态为q , 观测状态的序列为o , o , ...o 的概率为前向概率。记为：</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/48/e0/a7sY4FBg_o.png"></p> 
<ul><li>既然是动态规划，我们就要递推了，现在假设我们已经找到了在时刻t时各个隐藏状态的前向概率，现在我们需要递推出时刻t+1时各个隐藏状态的前向概率。</li><li>我们可以基于时刻t时各个隐藏状态的前向概率，再乘以对应的状态转移概率，即α (j)a 就是在时刻t观测到o , o , ...o ，并且时刻t隐藏状态q , 时刻t+1隐藏状态q 的概率。</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/27/51/ghCos96P_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9a/5d/KZULFTCo_o.png"></p> 
<p><strong>4.2.2 算法总结</strong></p> 
<ul><li>输入：HMM模型λ = (A, B, Π)，观测序列O = (o , o , ...o )</li><li>输出：观测序列概率P(O∣λ)</li></ul> 
<p>1) 计算时刻1的各个隐藏状态前向概率</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4f/de/AHVn7s5K_o.png"></p> 
<p>2) 递推时刻2,3,... ...T时刻的前向概率：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/29/42/f0vWKVIW_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f2/1c/Rr9rhERq_o.png"></p> 
<p>从递推公式可以看出，我们的算法时间复杂度是O(T N2)，比暴力解法的时间复杂度O(T NT)少了几个数量级。</p> 
<h4>4.3 <strong>HMM前向算法求解实例</strong></h4> 
<p>这里我们用前面盒子与球的例子来显示前向概率的计算。 我们的观察集合是：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/7f/bf/qgf27LKF_o.png"></p> 
<p>我们的状态集合是：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/49/95/x18uMGpJ_o.png"></p> 
<p>而观察序列和状态序列的长度为3.</p> 
<p>初始状态分布为：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/76/e4/Hh9A59sl_o.png"></p> 
<p>状态转移概率分布矩阵为：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/7a/fa/daKmBwE6_o.png"></p> 
<p>观测状态概率矩阵为：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e7/80/FSIUe8t1_o.png"></p> 
<p>球的颜色的观测序列:</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c2/9f/aCHR4BBb_o.png"></p> 
<p>按照我们上一节的前向算法。首先计算时刻1三个状态的前向概率：</p> 
<p>时刻1是红色球，</p> 
<p>隐藏状态是盒子1的概率为：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/95/5d/FW1eac01_o.png"></p> 
<p>隐藏状态是盒子2的概率为：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f1/4d/WxkurKEH_o.png"></p> 
<p>隐藏状态是盒子3的概率为：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/bb/48/RAtJdN4o_o.png"></p> 
<p>现在我们可以开始递推了，首先递推时刻2三个状态的前向概率：</p> 
<p>时刻2是白色球，</p> 
<p>隐藏状态是盒子1的概率为：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d1/68/XjH85Ive_o.png"></p> 
<p>隐藏状态是盒子2的概率为：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1b/e9/6ZjmcQTr_o.png"></p> 
<p>隐藏状态是盒子3的概率为：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b3/57/2cgEfoLW_o.png"></p> 
<p>继续递推，现在我们递推时刻3三个状态的前向概率：</p> 
<p>时刻3是红色球，</p> 
<p>隐藏状态是盒子1的概率为：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f8/9c/1IQy1NxZ_o.png"></p> 
<p>隐藏状态是盒子2的概率为：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/aa/92/wQ5QHLkJ_o.png"></p> 
<p>隐藏状态是盒子3的概率为：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/13/19/zzRUuADG_o.png"></p> 
<p>最终我们求出观测序列:O=红，白，红的概率为：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b0/00/7yB2DD21_o.png"></p> 
<h4>4.4 用后向算法求HMM观测序列的概率</h4> 
<p><strong>4.4.1 流程梳理</strong></p> 
<p>熟悉了用前向算法求HMM观测序列的概率，现在我们再来看看怎么用后向算法求HMM观测序列的概率。</p> 
<p>后向算法和前向算法非常类似，都是用的动态规划，唯一的区别是选择的局部状态不同，后向算法用的是“后向概率”。</p> 
<p><strong>4.4.2 后向算法流程</strong></p> 
<p>以下是后向算法的流程,注意下和前向算法的相同点和不同点：</p> 
<ul><li>输入：HMM模型λ = (A, B, Π)，观测序列O = (o1, o2, ...oT)</li><li>输出：观测序列概率P(O∣λ)</li></ul> 
<p>初始化时刻T的各个隐藏状态后向概率：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c4/64/aOFkQH5H_o.png"></p> 
<p>递推时刻T−1,T−2,...1时刻的后向概率：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/db/b9/CTohIGO5_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/cb/e8/WHVVg2uC_o.png"></p> 
<p>此时我们的算法时间复杂度仍然是<em>O</em>(<em>T N </em>2 )</p> 
<h3>五、<strong>维特比算法解码隐藏状态序列</strong></h3> 
<p>在本篇我们会讨论维特比算法解码隐藏状态序列，即给定模型和观测序列，求给定观测序列条件下，最可能出现的对应的隐藏状态序列。</p> 
<p>HMM模型的解码问题最常用的算法是维特比算法，当然也有其他的算法可以求解这个问题。</p> 
<p>同时维特比算法是一个通用的求序列最短路径的动态规划算法，也可以用于很多其他问题。</p> 
<h4>5.1 HMM最可能隐藏状态序列求解概述</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ec/b3/YsB9oiI6_o.png"></p> 
<p>近似算法很简单，但是却不能保证预测的状态序列整体是最可能的状态序列，因为预测的状态序列中某些相邻的隐藏状态可能存在转移概率为0的情况。</p> 
<p>而维特比算法可以将HMM的状态序列作为一个整体来考虑，避免近似算法的问题，下面我们来看看维特比算法进行HMM解码的方法。</p> 
<h4>5.2 <strong>维特比算法概述</strong></h4> 
<p>维特比算法是一个通用的解码算法，是基于动态规划的求序列最短路径的方法。</p> 
<p>既然是动态规划算法，那么就需要找到合适的局部状态，以及局部状态的递推公式。在HMM中，维特比算法定义了两个局部状态用于递推。</p> 
<p>1) 第1个局部状态是在时刻t隐藏状态为i所有可能的状态转移路径i ,i , ...i 中的概率最大值。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c7/1e/aTepwGCZ_o.png"></p> 
<p>2) 第二个局部状态由第一个局部状态递推得到。</p> 
<ul><li>我们定义在时刻t隐藏状态为i的所有单个状态转移路径(i ,i , ...,i ,i)中概率最大的转移路径中第t-1个节点的隐藏状态为ψ (i),</li><li>其递推表达式可以表示为：</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b1/ff/zosS2vTs_o.png"></p> 
<p>有了这两个局部状态，我们就可以从时刻0一直递推到时刻T，然后利用ψ (i)记录的前一个最可能的状态节点回溯，直到找到最优的隐藏状态序列。</p> 
<h4>5.3 <strong>维特比算法流程总结</strong></h4> 
<p>现在我们来总结下维特比算法的流程：</p> 
<ul><li>输入：HMM模型λ = (A, B, Π)，观测序列O = (o , o , ...o )</li><li>输出：最有可能的隐藏状态序列I = i ,i , ...i</li></ul> 
<p>流程如下：</p> 
<p>1）初始化局部状态：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9a/fe/eeFoCGNP_o.png"></p> 
<p>2) 进行动态规划递推时刻t = 2, 3, ...T时刻的局部状态：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2e/26/F8Or1hdr_o.png"></p> 
<p>3) 计算时刻T最大的δ (i),即为最可能隐藏状态序列出现的概率。计算时刻T最大的ψ (i),即为时刻T最可能的隐藏状态。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/10/37/ho51KdER_o.png"></p> 
<p>4) 利用局部状态ψ (i)开始回溯。对于t = T − 1, T − 2, ..., 1:</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c7/0b/fBMqzqwS_o.png"></p> 
<p>最终得到最有可能的隐藏状态序列I = i ,i , ...i</p> 
<h4>5.4 HMM维特比算法求解实例</h4> 
<p>下面我们仍然用盒子与球的例子来看看HMM维特比算法求解。 我们的观察集合是：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/cc/62/StjqHDZb_o.png"></p> 
<p>我们的状态集合是：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f6/8b/tFjL7RUx_o.png"></p> 
<p>而观察序列和状态序列的长度为3.</p> 
<p>初始状态分布为：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/93/19/KQ2qZdN0_o.png"></p> 
<p>状态转移概率分布矩阵为：</p> 
<p class="img-center"><img alt="" height="188" src="https://images2.imgbox.com/00/16/1v3phCLl_o.jpg" width="428"></p> 
<p> 观测状态概率矩阵为：</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/21/59/qievIQRs_o.png"></p> 
<p>球的颜色的观测序列:</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/62/09/56hQw87D_o.png"></p> 
<p></p> 
<p>按照我们前面的维特比算法，首先需要得到三个隐藏状态在时刻1时对应的各自两个局部状态，此时观测状态为1：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/47/8c/Px6kG2xJ_o.png"></p> 
<p>现在开始递推三个隐藏状态在时刻2时对应的各自两个局部状态，此时观测状态为2：</p> 
<p>δ (1) = max [δ (j)a ]b (o ) = max [0.1 × 0.5, 0.16 × 0.3, 0.28 × 0.2] × 0.5 = 0.028</p> 
<p>Ψ (1) = 3</p> 
<p>δ (2) = max [δ (j)a ]b (o ) = max [0.1 × 0.2, 0.16 × 0.5, 0.28 × 0.3] × 0.6 = 0.0504</p> 
<p>Ψ (2) = 3</p> 
<p>δ (3) = max [δ (j)a ]b (o ) = max [0.1 × 0.3, 0.16 × 0.2, 0.28 × 0.5] × 0.3 = 0.042</p> 
<p>Ψ (3) = 3</p> 
<p>继续递推三个隐藏状态在时刻3时对应的各自两个局部状态，此时观测状态为1：</p> 
<p>δ (1) = max [δ (j)a ]b (o ) = max [0.028 × 0.5, 0.0504 × 0.3, 0.042 × 0.2] × 0.5 = 0.00756</p> 
<p>Ψ (1) = 2</p> 
<p>δ (2) = max [δ (j)a ]b (o ) = max [0.028 × 0.2, 0.0504 × 0.5, 0.042 × 0.3] × 0.4 = 0.01008</p> 
<p>Ψ (2) = 2</p> 
<p>δ (3) = max [δ (j)a ]b (o ) = max [0.028 × 0.3, 0.0504 × 0.2, 0.042 × 0.5] × 0.7 = 0.0147</p> 
<p>Ψ (3) = 3</p> 
<p>此时已经到最后的时刻，我们开始准备回溯。此时最大概率为δ (3),从而得到i = 3</p> 
<p>由于ψ (3) = 3,所以i = 3, 而又由于ψ (3) = 3,所以i = 3。从而得到最终的最可能的隐藏状态序列为：(3,3,3)。</p> 
<h4>六、鲍姆-韦尔奇算法简介</h4> 
<p>模型参数学习问题 —— 鲍姆-韦尔奇（Baum-Welch）算法(状态未知)</p> 
<ul><li>即给定观测序列O = {o1, o2, ...oT }，估计模型λ = (A, B, Π)的参数，使该模型下观测序列的条件概率P(O∣λ)最大。</li><li>它的解法最常用的是鲍姆-韦尔奇算法，其实就是基于EM算法的求解，只不过鲍姆-韦尔奇算法现的时代，EM算法还没有被抽象出来，所以被叫为鲍姆-韦尔奇算法。</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e6/94/yljtbdni_o.png"></p> 
<h4>鲍姆-韦尔奇算法原理</h4> 
<p>鲍姆-韦尔奇算法原理既然使用的就是EM算法的原理，</p> 
<ul><li>那么我们需要在E步求出联合分布P(O,I|λ)基于条件概率P(I∣O,λ)的期望，其中λ为当前的模型参数，</li><li>然后在M步最大化这个期望，得到更新的模型参数λ。</li></ul> 
<p>接着不停的进行EM迭代，直到模型参数的值收敛为止。</p> 
<p>首先来看看E步，当前模型参数为λ, 联合分布P(O, I∣λ)基于条件概率P(I∣O,λ)的期望表达式为：</p> 
<p><em>L</em>(<em>λ</em>, <em>λ</em>) = ∑<em>P</em>(<em>I</em>∣<em>O</em>, <em>λ</em>)<em>logP</em>(<em>O</em>, <em>I</em>∣<em>λ</em>)</p> 
<p>在M步，我们极大化上式，然后得到更新后的模型参数如下：</p> 
<p><em>λ </em>= <em>arg </em>max<em>λ </em>∑<em>P</em>(<em>I</em>∣<em>O</em>, <em>λ</em>)<em>logP</em>(<em>O</em>, <em>I</em>∣<em>λ</em>)</p> 
<p>通过不断的E步和M步的迭代，直到<em>λ</em>收敛。</p> 
<h3>七、<strong>HMM模型API介绍</strong></h3> 
<h4><strong>7.1 API的安装：</strong></h4> 
<p>官网链接：<a href="https://link.zhihu.com/?target=https%3A//hmmlearn.readthedocs.io/en/latest/" rel="nofollow" title="hmmlearn 0.2.8.post18+g29072a4 documentation">hmmlearn 0.2.8.post18+g29072a4 documentation</a></p> 
<pre><code>pip3 install hmmlearn</code></pre> 
<h4>7.2 hmmlearn介绍</h4> 
<p>hmmlearn实现了三种HMM模型类，按照观测状态是连续状态还是离散状态，可以分为两类。</p> 
<p>GaussianHMM和GMMHMM是连续观测状态的HMM模型，而MultinomialHMM是离散观测状态的模型，也是我们在HMM原理系列篇里面使用的模型。</p> 
<p>在这里主要介绍我们前面一直讲的关于离散状态的MultinomialHMM模型。</p> 
<p>对于MultinomialHMM的模型，使用比较简单，里面有几个常用的参数：</p> 
<ul><li>"startprob_"参数对应我们的隐藏状态初始分布Π,</li><li>"transmat_"对应我们的状态转移矩阵A,</li><li>"emissionprob_"对应我们的观测状态概率矩阵B。</li></ul> 
<h4>7.3 <strong>MultinomialHMM实例</strong></h4> 
<p>下面我们用我们在前面讲的关于球的那个例子使用MultinomialHMM跑一遍。</p> 
<pre><code>import numpy as np 
from hmmlearn import hmm</code></pre> 
<pre><code class="hljs"># 设定隐藏状态的集合
states = ["box 1", "box 2", "box3"]
n_states = len(states)
# 设定观察状态的集合
observations = ["red", "white"]
n_observations = len(observations)
# 设定初始状态分布
start_probability = np.array([0.2, 0.4, 0.4])
# 设定状态转移概率分布矩阵
transition_probability = np.array([
[0.5, 0.2, 0.3],
[0.3, 0.5, 0.2],
[0.2, 0.3, 0.5]
])
# 设定观测状态概率矩阵
emission_probability = np.array([
[0.5, 0.5],
[0.4, 0.6],
[0.7, 0.3]
])</code></pre> 
<pre><code># 设定模型参数
model = hmm.MultinomialHMM(n_components=n_states)
model.startprob_=start_probability # 初始状态分布
model.transmat_=transition_probability # 状态转移概率分布矩阵
model.emissionprob_=emission_probability # 观测状态概率矩阵</code></pre> 
<p>现在我们来跑一跑HMM问题三维特比算法的解码过程，使用和之前一样的观测序列来解码，代码如下：</p> 
<pre><code>seen = np.array([[0,1,0]]).T # 设定观测序列
box = model.predict(seen)
print("球的观测顺序为：\n", ", ".join(map(lambda x: observations[x], seen.flatten())))
# 注意：需要使⽤flatten⽅法，把seen从⼆维变成⼀维
print("最可能的隐藏状态序列为:\n"， ", ".join(map(lambda x: states[x], box)))</code></pre> 
<p>我们再来看看求HMM问题一的观测序列的概率的问题，代码如下：</p> 
<pre><code>print(model.score(seen))
# 输出结果是：-2.03854530992</code></pre> 
<p>要注意的是score函数返回的是以自然对数为底的对数概率值，我们在HMM问题一中手动计算的结果是未取对数的原始概率是0.13022。对比一下：</p> 
<pre><code>import math
math.exp(-2.038545309915233)
# ln0.13022≈−2.0385
# 输出结果是：0.13021800000000003</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/479585cb2981d2aac4aa3c07abf41409/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一个 Qml MenuBar 的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/91e67a18db0c9dcc28e5831e5b0beb1c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VMware之windows 2016安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>