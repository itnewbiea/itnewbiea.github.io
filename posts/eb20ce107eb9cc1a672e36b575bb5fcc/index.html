<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>DRM应用程序进阶 （Property） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="DRM应用程序进阶 （Property）" />
<meta property="og:description" content="前言 通过前面几篇《最简单的DRM应用程序》系列文章，我们学习了如何编写一个最基本的DRM应用程序。但是，这些程序所使用的接口，在如今的DRM架构中其实早已经被标记为 Legacy（过时的） 接口了，而目前DRM主要推荐使用的是 Atomic（原子的） 接口。Atomic接口我会在下篇文章中重点介绍，本篇主要介绍Atomic操作必须依赖的基本元素，Property（属性）。
Property 所谓Property，其实就是把前几篇的legacy接口传入的参数单独抽出来，做成一个个独立的全局属性。通过设置这些属性参数，即可完成对显示参数的设置。
Property的结构简单概括主要由3部分组成：name、id 和 value。其中id为该property在DRM框架中全局唯一的标识符。
采用property机制的好处是：
减少上层应用接口的维护工作量。当开发者有新的功能需要添加时，无需增加新的函数名和IOCTL，只需在底层驱动中新增一个property，然后在自己的应用程序中获取/操作该property的值即可。增强了参数设置的灵活性。一次IOCTL可以同时设置多个property，减少了user space与kernel space切换的次数，同时最大限度的满足了不同硬件对于参数设置的要求，提高了软件效率。 DRM中的property大多以功能进行划分，并且还定义了一组 Standard Properties，这些标准properties在任何平台上都会被创建。
下表列出了应用程序开发中，常用的property：
CRTC namedesctriptionACTIVECRTC当前的使能状态，一般用于控制CRTC上下电MODE_IDCRTC当前所使用的display mode ID，通过该ID可以找到具体的display mode配置参数OUT_FENCE_PTR输出fence指针，指向当前正在显示的buffer所对应的fence fd，该fence由DRM驱动创建，供上层应用程序使用，用来表示当前buffer CRTC是否还在占用 (optional)
namedesctriptionDEGAMMA_LUTde-gamma查找表参数DEGAMMA_LUT_SIZEde-gamma查找表参数长度CTMColor Transformation Matrix，颜色矩阵转换参数，3x3的矩阵GAMMA_LUTgamma查找表参数GAMMA_LUT_SIZEgamma查找表参数长度 PLANE namedesctriptiontypeplane的类型，CURSOR、PRIMARY或者OVERLAYFB_ID与当前plane绑定的framebuffer object IDIN_FENCE_FD与当前plane相关联的input fence fd，由buffer的生产者创建，供DRM底层驱动使用，用来标识当前传下来的buffer是否可以开始访问CRTC_ID当前plane所关联的CRTC object ID，与CONNECTOR中的CRTC_ID属性是同一个propertySRC_X当前framebuffer crop区域的起始偏移x坐标SRC_Y当前framebuffer crop区域的起始偏移y坐标SRC_W当前framebuffer crop区域的宽度SRC_H当前framebuffer crop区域的高度CRTC_X屏幕显示区域的起始偏移x坐标CRTC_Y屏幕显示区域的起始偏移y坐标CRTC_W屏幕显示区域的宽度CRTC_H屏幕显示区域的高度 (optional)
namedesctriptionIN_FORMATS用于标识特殊的颜色存储格式，如AFBC、IFBC存储格式，该属性为只读rotation当前图层的旋转角度zposition当前图层在所有图层中的Z轴顺序alpha当前图层的global alpha（非pixel alpha），用于多层合成pixel blend mode当前图层的合成方式，如Pre-multiplied/Coverage等 CONNECTOR namedesctriptionEDIDExtended Display Identification Data，标识显示器的参数信息，是一种VESA标准数据格式DPMSDisplay Power Management Signaling，用于控制显示器的电源状态，如休眠唤醒。也是一种VESA标准link-status用于标识当前connector的连接状态，如Good/BadCRTC_ID当前connector所连接的CRTC object ID，与PLANE中CRTC_ID属性是同一个property (optional)
namedesctriptionPATHDisplayPort专用的属性，主要用于Multi-Stream Transport (MST) 功能，即多路显示应用场景TILE用于标识当前connector是否应用于多屏拼接场景，如平时随处可见的多屏拼接显示的广告大屏幕 Property Type Property的类型分为如下几种：
enumbitmaskrangesigned rangeobjectblob 以上类型中需要着重介绍的是object和blob类型，其它类型看名字就知道什么意思，所以就不做介绍了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/eb20ce107eb9cc1a672e36b575bb5fcc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-02-13T22:42:32+08:00" />
<meta property="article:modified_time" content="2019-02-13T22:42:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">DRM应用程序进阶 （Property）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>前言</h3> 
<p>通过前面几篇<a href="https://blog.csdn.net/hexiaolong2009/article/details/84934294">《最简单的DRM应用程序》</a>系列文章，我们学习了如何编写一个最基本的DRM应用程序。但是，这些程序所使用的接口，在如今的DRM架构中其实早已经被标记为 <strong>Legacy（过时的）</strong> 接口了，而目前DRM主要推荐使用的是 <strong>Atomic（原子的）</strong> 接口。Atomic接口我会在下篇文章中重点介绍，本篇主要介绍Atomic操作必须依赖的基本元素，<strong>Property（属性）</strong>。</p> 
<h3><a id="Property_3"></a>Property</h3> 
<p>所谓Property，其实就是把前几篇的legacy接口传入的参数单独抽出来，做成一个个独立的全局属性。通过设置这些属性参数，即可完成对显示参数的设置。</p> 
<p>Property的结构简单概括主要由3部分组成：<code>name</code>、<code>id</code> 和 <code>value</code>。其中<code>id</code>为该property在DRM框架中全局唯一的标识符。</p> 
<p>采用property机制的好处是：</p> 
<blockquote> 
 <ol><li>减少上层应用接口的维护工作量。当开发者有新的功能需要添加时，无需增加新的函数名和IOCTL，只需在底层驱动中新增一个property，然后在自己的应用程序中获取/操作该property的值即可。</li><li>增强了参数设置的灵活性。一次IOCTL可以同时设置多个property，减少了user space与kernel space切换的次数，同时最大限度的满足了不同硬件对于参数设置的要求，提高了软件效率。</li></ol> 
</blockquote> 
<p>DRM中的property大多以功能进行划分，并且还定义了一组 <em><strong>Standard Properties</strong></em>，这些标准properties在任何平台上都会被创建。</p> 
<p>下表列出了应用程序开发中，常用的property：</p> 
<hr> 
<h4><a id="CRTC_18"></a>CRTC</h4> 
<table><thead><tr><th align="left">name</th><th align="left">desctription</th></tr></thead><tbody><tr><td align="left">ACTIVE</td><td align="left">CRTC当前的使能状态，一般用于控制CRTC上下电</td></tr><tr><td align="left">MODE_ID</td><td align="left">CRTC当前所使用的display mode ID，通过该ID可以找到具体的display mode配置参数</td></tr><tr><td align="left">OUT_FENCE_PTR</td><td align="left">输出fence指针，指向当前正在显示的buffer所对应的fence fd，该fence由DRM驱动创建，供上层应用程序使用，用来表示当前buffer CRTC是否还在占用</td></tr></tbody></table> 
<p>(optional)</p> 
<table><thead><tr><th align="left">name</th><th align="left">desctription</th></tr></thead><tbody><tr><td align="left">DEGAMMA_LUT</td><td align="left">de-gamma查找表参数</td></tr><tr><td align="left">DEGAMMA_LUT_SIZE</td><td align="left">de-gamma查找表参数长度</td></tr><tr><td align="left">CTM</td><td align="left">Color Transformation Matrix，颜色矩阵转换参数，3x3的矩阵</td></tr><tr><td align="left">GAMMA_LUT</td><td align="left">gamma查找表参数</td></tr><tr><td align="left">GAMMA_LUT_SIZE</td><td align="left">gamma查找表参数长度</td></tr></tbody></table> 
<hr> 
<h4><a id="PLANE_37"></a>PLANE</h4> 
<table><thead><tr><th align="left">name</th><th align="left">desctription</th></tr></thead><tbody><tr><td align="left">type</td><td align="left">plane的类型，CURSOR、PRIMARY或者OVERLAY</td></tr><tr><td align="left">FB_ID</td><td align="left">与当前plane绑定的framebuffer object ID</td></tr><tr><td align="left">IN_FENCE_FD</td><td align="left">与当前plane相关联的input fence fd，由buffer的生产者创建，供DRM底层驱动使用，用来标识当前传下来的buffer是否可以开始访问</td></tr><tr><td align="left">CRTC_ID</td><td align="left">当前plane所关联的CRTC object ID，与CONNECTOR中的CRTC_ID属性是同一个property</td></tr><tr><td align="left">SRC_X</td><td align="left">当前framebuffer crop区域的起始偏移x坐标</td></tr><tr><td align="left">SRC_Y</td><td align="left">当前framebuffer crop区域的起始偏移y坐标</td></tr><tr><td align="left">SRC_W</td><td align="left">当前framebuffer crop区域的宽度</td></tr><tr><td align="left">SRC_H</td><td align="left">当前framebuffer crop区域的高度</td></tr><tr><td align="left">CRTC_X</td><td align="left">屏幕显示区域的起始偏移x坐标</td></tr><tr><td align="left">CRTC_Y</td><td align="left">屏幕显示区域的起始偏移y坐标</td></tr><tr><td align="left">CRTC_W</td><td align="left">屏幕显示区域的宽度</td></tr><tr><td align="left">CRTC_H</td><td align="left">屏幕显示区域的高度</td></tr></tbody></table> 
<p>(optional)</p> 
<table><thead><tr><th align="left">name</th><th align="left">desctription</th></tr></thead><tbody><tr><td align="left">IN_FORMATS</td><td align="left">用于标识特殊的颜色存储格式，如AFBC、IFBC存储格式，该属性为只读</td></tr><tr><td align="left">rotation</td><td align="left">当前图层的旋转角度</td></tr><tr><td align="left">zposition</td><td align="left">当前图层在所有图层中的Z轴顺序</td></tr><tr><td align="left">alpha</td><td align="left">当前图层的global alpha（非pixel alpha），用于多层合成</td></tr><tr><td align="left">pixel blend mode</td><td align="left">当前图层的合成方式，如Pre-multiplied/Coverage等</td></tr></tbody></table> 
<hr> 
<h4><a id="CONNECTOR_65"></a>CONNECTOR</h4> 
<table><thead><tr><th align="left">name</th><th align="left">desctription</th></tr></thead><tbody><tr><td align="left">EDID</td><td align="left">Extended Display Identification Data，标识显示器的参数信息，是一种VESA标准数据格式</td></tr><tr><td align="left">DPMS</td><td align="left">Display Power Management Signaling，用于控制显示器的电源状态，如休眠唤醒。也是一种VESA标准</td></tr><tr><td align="left">link-status</td><td align="left">用于标识当前connector的连接状态，如Good/Bad</td></tr><tr><td align="left">CRTC_ID</td><td align="left">当前connector所连接的CRTC object ID，与PLANE中CRTC_ID属性是同一个property</td></tr></tbody></table> 
<p>(optional)</p> 
<table><thead><tr><th align="left">name</th><th align="left">desctription</th></tr></thead><tbody><tr><td align="left">PATH</td><td align="left">DisplayPort专用的属性，主要用于Multi-Stream Transport (MST) 功能，即多路显示应用场景</td></tr><tr><td align="left">TILE</td><td align="left">用于标识当前connector是否应用于多屏拼接场景，如平时随处可见的多屏拼接显示的广告大屏幕</td></tr></tbody></table> 
<hr> 
<h3><a id="Property_Type_82"></a>Property Type</h3> 
<p>Property的类型分为如下几种：</p> 
<blockquote> 
 <ul><li>enum</li><li>bitmask</li><li>range</li><li>signed range</li><li>object</li><li>blob</li></ul> 
</blockquote> 
<p>以上类型中需要着重介绍的是object和blob类型，其它类型看名字就知道什么意思，所以就不做介绍了。</p> 
<h4><a id="Object_Property_93"></a>Object Property</h4> 
<p>Object类型的property，它的值用 <em>drm_mode_object</em> ID来表示。目前的DRM架构中仅用到2个Object Property，它们分别是 <em><strong>"FB_ID"</strong></em> 和 <em><strong>"CRTC_ID"</strong></em> ，它们的property值分别表示framebuffer object ID和crtc object ID。</p> 
<h4><a id="Blob_Property_96"></a>Blob Property</h4> 
<p>Blob类型的property，它的值用blob object ID来表示。所谓blob，说白了就是一个自定义长度的内存块，用来存放自定义的结构体数据。典型的Blob Property，如 <em><strong>"MODE_ID"</strong></em> ，它的值为blob object ID，drm驱动可以根据该ID找到对应的<em>drm_property_blob</em>结构体，该结构体中存放着modeinfo的相关信息。</p> 
<blockquote> 
 <p>在DRM的property type中，还有2种特殊的type，它们分别是 <code>IMMUTABLE TYPE</code> 和 <code>ATOMIC TYPE</code>。这两种type的特殊性在于，它们可以和上面任意一种property进行组合使用，用来修饰上面的property。</p> 
 <ul><li>IMMUTABLE TYPE：表示该property为只读，应用程序无法修改它的值，如"IN_FORMATS"。</li><li>ATOMIC TYPE：表示该property只有在drm应用程序（drm client）支持ATOMIC操作时才可见。</li></ul> 
</blockquote> 
<h3><a id="_103"></a>概念图</h3> 
<p>还是习惯性的上一张图吧：</p> 
<p><img src="https://images2.imgbox.com/c3/93/z0SYMkFc_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_108"></a>总结</h3> 
<p>DRM的Property，其实有点类似于kernel中的sysfs属性节点。DRM驱动将kernel层的重要参数通过property机制导出给上层，使得上层应用可以采用统一的接口形式来修改property的值，从而实现参数的传递，而无需新增额外的IOCTL接口。</p> 
<p>通过本篇的学习，我们了解了DRM Property的基本概念，这有助于我们学习后面的Atomic编程。在下一篇文章中，我们将一起来学习如何使用libdrm的Atomic接口进行编程，敬请期待！</p> 
<h3><a id="_113"></a>参考资料</h3> 
<p>Linux GPU Driver Developer’s Guide: <a href="https://www.kernel.org/doc/html/latest/gpu/drm-kms.html#kms-properties" rel="nofollow">KMS Properties</a></p> 
<p><strong>文章汇总：</strong> <a href="https://blog.csdn.net/hexiaolong2009/article/details/83720940"><em><strong>DRM (Direct Rendering Manager) 学习简介</strong></em></a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a5460b5859c6e471cee36ab0fc78e68e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">强大的代码保护软件.NET Reactor使用教程（五）——.NET Reactor工具</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c9f0af13344c0a042ff6751ed5e18754/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">golang 声明结构体和声明接口的疑点</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>