<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringBoot参数校验--List类型 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringBoot参数校验--List类型" />
<meta property="og:description" content="我们在写后台接口的时候，通常会定义DTO来接收参数，在DTO中使用注解书写验证的规则；然后在Controller层使用@validated注解来验证自己制定的校验规则。但当我们的接口接收的参数为List&lt;E&gt;时，可以使用本文的方法进行校验。注：工具类部分代码在最后 包含验证规则的实体类：
import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; import lombok.Data; import javax.validation.constraints.NotBlank; import javax.validation.constraints.Pattern; @Data public class SingleDTO { @ApiModelProperty(value = &#34;主键ID&#34;, required = true) @NotBlank(message = &#34;缺少参数：主键ID&#34;) @Pattern(regexp = &#34;[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}&#34;,message = &#34;主键ID格式有误：UUID格式&#34;) private String pkId; } 参数校验：
import com.wingconn.aeocustoms.domain.dto.SingleDTO; import org.junit.Test; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import javax.validation.*; import java.util.ArrayList; import java.util.List; import java.util.Set; public class ValidatorUtilsTest { private static final Logger LOGGER = LoggerFactory.getLogger(ValidatorUtilsTest.class); private static Validator createValidator() { Configuration&lt;?&gt; config = Validation." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8ed6c73eb1f13e998b4d75df7b9c3251/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-16T11:49:52+08:00" />
<meta property="article:modified_time" content="2018-11-16T11:49:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringBoot参数校验--List类型</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4><em>    我们在写后台接口的时候，通常会定义DTO来接收参数，在DTO中使用注解书写验证的规则；然后在Controller层使用@validated注解来验证自己制定的校验规则。</em>但当我们的<span style="color:#3399ea;"><strong>接口接收的参数为List&lt;E&gt;</strong></span>时，可以使用本文的方法进行校验。注：工具类部分代码在最后</h4> 
<blockquote> 
 <p>包含验证规则的实体类：</p> 
</blockquote> 
<pre class="has"><code class="language-html">import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Pattern;
@Data
public class SingleDTO {
    @ApiModelProperty(value = "主键ID", required = true)
    @NotBlank(message = "缺少参数：主键ID")
    @Pattern(regexp = "[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}",message = "主键ID格式有误：UUID格式")
    private String pkId;
}</code></pre> 
<p> </p> 
<blockquote> 
 <p>参数校验：</p> 
</blockquote> 
<pre class="has"><code class="language-html">import com.wingconn.aeocustoms.domain.dto.SingleDTO;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.validation.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public class ValidatorUtilsTest {
    private static final Logger LOGGER = LoggerFactory.getLogger(ValidatorUtilsTest.class);

    private static Validator createValidator() {
        Configuration&lt;?&gt; config = Validation.byDefaultProvider().configure();
        ValidatorFactory factory = config.buildValidatorFactory();
        Validator validator = factory.getValidator();
        factory.close();
        return validator;
    }

    /**
     * Controller层验证List类型的参数
     */
    @Test
    public void validate() {
        List&lt;SingleDTO&gt; dtos = new ArrayList&lt;&gt;();
        SingleDTO singleDTO =  new SingleDTO();
        singleDTO.setPkId("12345678990");
        dtos.add(singleDTO);
        Validator validator = createValidator();
        for(SingleDTO dto : dtos) {
            Set&lt;ConstraintViolation&lt;SingleDTO&gt;&gt; violations  = validator.validate(dto);
            if (violations.size() == 0) {
                LOGGER.debug("No violations.");
                System.out.println("success");
            }else {
                LOGGER.error("%s violations:%n", violations.size());
                for(ConstraintViolation&lt;SingleDTO&gt; violation :violations){
                    LOGGER.error("参数："+violation.getPropertyPath() + "  " + violation.getMessage());
                }
            }
        }
    }

}</code></pre> 
<p>用参数“1234567890”进行单元测试，结果为：</p> 
<p> <img alt="" class="has" height="138" src="https://images2.imgbox.com/6f/e2/fyJcEdxN_o.png" width="470"></p> 
<p>用参数“c076de6c-aeb3-4882-ba6c-a886942c53c4”进行单元测试，结果为：</p> 
<p><img alt="" class="has" height="69" src="https://images2.imgbox.com/2b/e8/7Semp135_o.png" width="305"></p> 
<blockquote> 
 <p>单元测试表明该工具类可以使用。实际使用时，直接在Controller层使用该工具类，即可进行参数的校验。</p> 
</blockquote> 
<p>工具类部分代码（缺少了返回值的实体类）： </p> 
<pre class="has"><code class="language-html">package com.XXX.aasmgt.util;

import com.XXX.to.resultTo.ResultTO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.validation.*;
import java.util.List;
import java.util.Set;

/**
 * @author fusc
 * @date 2018/10/9 17:23
 */
public class ValidatorUtils {

    private static final Logger LOGGER = LoggerFactory.getLogger(ValidatorUtils.class);

    private static Validator createValidator() {
        Configuration&lt;?&gt; config = Validation.byDefaultProvider().configure();
        ValidatorFactory factory = config.buildValidatorFactory();
        Validator validator = factory.getValidator();
        factory.close();
        return validator;
    }

    /**
     * Controller层验证List类型的参数
     *
     * @return
     */
    public static &lt;T&gt; ResultTO validate(List&lt;T&gt; list) {
        Validator validator = createValidator();
        for (T dto : list) {
            Set&lt;ConstraintViolation&lt;T&gt;&gt; violations = validator.validate(dto);
            if (violations.size() == 0) {
                LOGGER.debug("No violations.");
                return ResultTO.operateSuccess();
            } else {
                LOGGER.error("%s violations:%n", violations.size());
                for (ConstraintViolation&lt;T&gt; violation : violations) {
                    LOGGER.error("参数：" + violation.getPropertyPath() + "  " + violation.getMessage());
                    return ResultTO.errorByInvalidParams(violation.getMessage());
                }
            }
        }
        return ResultTO.errorByInvalidParams("参数有误：参数列表为空！");
    }
}
</code></pre> 
<p>************************************************************************************************************************************************* </p> 
<h2> 另外一种方式（ 摘抄自公众号“<a id="js_name">Java技术栈</a>”）</h2> 
<p><em>为了能够进行嵌套验证，必须手动在Item实体的props字段上明确指出这个字段里面的实体也要进行验证。由于<strong>@Validated不能用在成员属性（字段）上，但是@Valid能加在成员属性（字段）上</strong>，而且@Valid类注解上也说明了它支持嵌套验证功能，那么我们能够推断出：@Valid加在方法参数时并不能够自动进行嵌套验证，而是用在需要嵌套验证类的相应字段上，来配合方法参数上@Validated或@Valid来进行嵌套验证。</em></p> 
<p><em>我们修改Item类如下所示：</em></p> 
<pre class="has"><code>public class Item {

    @NotNull(message = "id不能为空")
    @Min(value = 1, message = "id必须为正整数")
    private Long id;

    @Valid // 嵌套验证必须用@Valid
    @NotNull(message = "props不能为空")
    @Size(min = 1, message = "props至少要有一个自定义属性")
    private List&lt;Prop&gt; props;
}</code></pre> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7d6778b368d6810a06890341d9fcd9c7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">sqlite可替代top的方法。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/53c8f73b6216d767c5fa54981608475f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">工业相机和镜头主要参数解释</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>