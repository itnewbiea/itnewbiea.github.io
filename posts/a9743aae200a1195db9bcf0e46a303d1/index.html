<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Flutter完整开发实战详解(一、Dart语言和Flutter基础) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Flutter完整开发实战详解(一、Dart语言和Flutter基础)" />
<meta property="og:description" content="前言 在如今的 Fultter 大潮下，本系列是让你看完会安心的文章。本系列将完整讲述：如何快速从0开发一个完整的 Flutter APP，配套高完成度 Flutter 开源项目 GSYGithubAppFlutter。同时也会提供一些Flutter的开发细节技巧，并针对开发过程中可能遇到的问题进行填坑。
一、基础篇 本篇主要涉及：环境搭建、Dart语言、Flutter的基础。
1、环境搭建 Flutter 的环境搭建十分省心，特别对应 Android 开发者而言，只是在 Android Stuido
上安装插件，并下载flutter Sdk到本地，配置在环境变量即可。其实中文网的搭建Futter开发环境 已经很贴心详细，从平台指引开始安装基本都不会遇到问题。
这里主要是需要注意，因为某些不可抗力的原因，国内的用户需要配置 Flutter 的代理，并且国内用户在搜索 Flutter 第三方包时，也是在 https://pub.flutter-io.cn 内查找，下方是需要配置到环境变量的地址。（ps Android Studio下运行 IOS 也是蛮有意思的(◐‿◑)﻿）
///win直接配置到环境编辑即可，mac配置到bash_profile export PUB_HOSTED_URL=https://pub.flutter-io.cn //国内用户需要设置 export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn //国内用户需要设置 2、Dart语言下的Flutter 在跨平台开领域被 JS 一统天下的今天，Dart 语言的出现无疑是一股清流。作为后来者，Dart语言有着不少Java、kotlin 和 JS 的影子，所以对于 Android 原生开发者、前端开发者而言无疑是非常友好的。
官方也提供了包括IOS开发者，React Native 等开发者迁移到 Flutter 上的文档，所以请不要担心，Dart语言不会是你掌握 Flutter 的门槛。甚至作为开发者，就算你不懂 Dart 也可以看着代码摸索。
Come on，下面主要通过对比，简单讲述下 Dart 的一些特性，主要涉及的是 Flutter 下使用。
基本类型 var 可以定义变量，如 var tag = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a9743aae200a1195db9bcf0e46a303d1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-29T15:56:25+08:00" />
<meta property="article:modified_time" content="2023-03-29T15:56:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Flutter完整开发实战详解(一、Dart语言和Flutter基础)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_3"></a>前言</h3> 
<p>在如今的 Fultter 大潮下，本系列是让你看完会安心的文章。本系列将完整讲述：如何快速从0开发一个完整的 Flutter APP，配套高完成度 Flutter 开源项目 <a href="https://github.com/CarGuo/GSYGithubAppFlutter">GSYGithubAppFlutter</a>。同时也会提供一些Flutter的开发细节技巧，并针对开发过程中可能遇到的问题进行填坑。</p> 
<p></p> 
<h3><a id="_10"></a>一、基础篇</h3> 
<p><em>本篇主要涉及：环境搭建、Dart语言、Flutter的基础。</em></p> 
<h4><a id="1_15"></a>1、环境搭建</h4> 
<p>Flutter 的环境搭建十分省心，特别对应 Android 开发者而言，只是在 Android Stuido</p> 
<p>上安装插件，并下载flutter Sdk到本地，配置在环境变量即可。其实中文网的<a href="https://flutterchina.club/get-started/install/" rel="nofollow">搭建Futter开发环境</a> 已经很贴心详细，从平台指引开始安装基本都不会遇到问题。</p> 
<p>这里主要是需要注意，因为某些不可抗力的原因，国内的用户需要配置 Flutter 的代理，并且国内用户在搜索 Flutter 第三方包时，也是在 <a href="https://pub.flutter-io.cn/" rel="nofollow">https://pub.flutter-io.cn</a> 内查找，下方是需要配置到环境变量的地址。<em>（ps Android Studio下运行 IOS 也是蛮有意思的(◐‿◑)﻿）</em></p> 
<pre><code>///win直接配置到环境编辑即可，mac配置到bash_profile
export PUB_HOSTED_URL=https://pub.flutter-io.cn //国内用户需要设置
export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn //国内用户需要设置
</code></pre> 
<h4><a id="2DartFlutter_30"></a>2、Dart语言下的Flutter</h4> 
<p>在跨平台开领域被 JS 一统天下的今天，Dart 语言的出现无疑是一股清流。作为后来者，Dart语言有着不少Java、kotlin 和 JS 的影子，所以对于 Android 原生开发者、前端开发者而言无疑是非常友好的。</p> 
<p>官方也提供了包括IOS开发者，React Native 等开发者迁移到 Flutter 上的文档，所以请不要担心，Dart语言不会是你掌握 Flutter 的门槛。甚至作为开发者，就算你不懂 Dart 也可以看着代码摸索。</p> 
<p>Come on，下面主要通过对比，简单讲述下 Dart 的一些特性，主要涉及的是 Flutter 下使用。</p> 
<ul><li>基本类型</li></ul> 
<p>var 可以定义变量，如 <code>var tag = "666"</code> ，这和 JS 、 Kotlin 等语言类似，同时 Dart 属于动态类型语言，支持闭包。</p> 
<p>Dart 中 number 类型分为 <code>int</code> 和 <code>double</code> ，其中 java 中的 long 对应的也是 Dart 中的 int 类型。Dart 中没有 float 类型。</p> 
<p>Dart 下只有 bool 型可以用于 if 等判断，不同于 JS 这种使用方式是不合法的 <code>var g = "null"; if(g){}</code> 。</p> 
<p>DART中，switch 支持 String 类型。</p> 
<ul><li>变量</li></ul> 
<p>Dart 不需要给变量设置 <code>setter getter</code> 方法， 这和 kotlin 等类似。Dart 中所有的基础类型、类等都继承 Object ，默认值是 NULL， 自带 getter 和 setter ，而如果是 final 或者 const 的话，那么它只有一个 getter 方法。</p> 
<p>Dart 中 final 和 const 表示常量，比如 <code>final name = 'GSY'; const value= 1000000;</code> 同时 <code>static const</code> 组合代表了静态常量。其中 const 的值在编译期确定，final 的值要到编译时才确定。<em>（ps Flutter 在 Release 下是 AOT 模式。）</em></p> 
<p>Dart 下的数值，在作为字符串使用时，是需要显式指定的。比如：<code>int i = 0; print("aaaa" + i);</code> 这样并不支持，需要 <code>print("aaaa" + i.toString());</code> 这样使用。这和 Java 与 JS 存在差异。<strong>所以在使用动态类型时，需要注意不要把 number 类型当做 String 使用。</strong></p> 
<p>DART 中数组等于列表，所以 <code>var list = [];</code> 和 <code>List list = new List()</code> 可以简单看做一样。</p> 
<ul><li>方法</li></ul> 
<p>Dart 下 <code>??</code> 、<code>??=</code> 属于操作符，如: <code>AA ?? "999"</code> 表示如果 AA 为空，返回99；<code>AA ??= "999"</code> 表示如果 AA 为空，给 AA 设置成 99。</p> 
<p>Dart 方法可以设置 <em>参数默认值</em> 和 <em>指定名称</em> 。比如： <code>getDetail(Sting userName, reposName, {branch = "master"}){}</code> 方法，这里 branch 不设置的话，默认是 “master” 。<em>参数类型</em> 可以指定或者不指定。调用效果： <code>getRepositoryDetailDao(“aaa", "bbbb", branch: "dev");</code></p> 
<p>Dart 不像 Java ，没有关键词 public 、private 等修饰符，<code>_</code>下横向直接代表 private ，但是有 <code>@protected</code> 注解。</p> 
<p>Dart 中多构造函数，可以通过如下代码实现的。默认构造方法只能有一个，而通过<code>Model.empty()</code> 方法可以创建一个空参数的类，其实方法名称随你喜欢。而变量初始化值时，只需要通过 <code>this.name</code> 在构造方法中指定即可：</p> 
<pre><code>class ModelA {
  String name;
  String tag;
  
  //默认构造方法，赋值给name和tag
  ModelA(this.name, this.tag);

  //返回一个空的ModelA
  ModelA.empty();
  
  //返回一个设置了name的ModelA
  ModelA.forName(this.name);
}
</code></pre> 
<ul><li>Flutter</li></ul> 
<p>Flutter 中支持 <code>async</code>/<code>await</code> 。这一点和 ES7 很像，<strong>如下代码所示</strong>，只是定义的位置不同。同时异步操作也和 ES6 中的<code>Promise</code> 很像，只是 Flutter 中返回的是 <code>Future</code> 对象，通过 <code>then</code> 可以执行下一步。如果返回的还是 <code>Future</code> 便可以 <code>then().then.()</code> 的流式操作了 。</p> 
<pre><code>  ///模拟等待两秒，返回OK
  request() async {
    await Future.delayed(Duration(seconds: 1));
    return "ok!";
  }

  ///得到"ok!"后，将"ok!"修改为"ok from request"
  doSomeThing() async {
    String data = await request();
    data = "ok from request";
    return data;
  }

  ///打印结果
  renderSome() {
    doSomeThing().then((value) {
      print(value);
      ///输出ok from request
    });
  }
</code></pre> 
<p>Flutter 中 <code>setState</code> 很有 React Native 的既视感，Flutter 中也是通过 state 跨帧实现管理数据状态的，这个后面会详细讲到。</p> 
<p>Flutter 中一切皆 Widget 呈现，通过 <code>build</code>方法返回 Widget，这也是和 React Native 中，通过 <code>render</code> 函数返回需要渲染的 component 一样的模式。</p> 
<h4><a id="3Flutter_Widget_118"></a>3、Flutter Widget</h4> 
<p>在 Flutter 中，一切的显示都是 Widget 。Widget 是一切的基础，作为响应式的渲染，属于 MVVM 的实现机制。我们可以通过修改数据，再用<code>setState</code> 设置数据，Flutter 会自动通过绑定的数据更新 Widget 。 <strong>所以你需要做的就是实现 Widget 界面，并且和数据绑定起来</strong>。</p> 
<p>Widget 分为 <em>有状态</em> 和 <em>无状态</em> 两种，在 Flutter 中每个页面都是一帧。无状态就是保持在那一帧。而有状态的 Widget 当数据更新时，其实是绘制了新的 Widget，只是 State 实现了跨帧的数据同步保存。</p> 
<blockquote> 
 <p>这里有个小 Tip ，当代码框里输入 <code>stl</code> 的时候，可以自动弹出创建无状态控件的模板选项，而输入 <code>stf</code> 的时，就会弹出创建有状态 Widget 的模板选项。</p> 
 <p>代码格式化的时候，括号内外的逗号都会影响格式化时换行的位置。</p> 
 <p>如果觉得默认换行的线太短，可以在设置-Editor-Code Style-Dart-Wrapping and Braces-Hard wrap at 设置你接受的数值。</p> 
</blockquote> 
<h5><a id="31StatelessWidget_130"></a>3.1、无状态StatelessWidget</h5> 
<p>直接进入主题，下方代码是无状态 Widget 的简单实现。</p> 
<p><strong>继承 StatelessWidget，通过 <code>build</code> 方法返回一个布局好的控件</strong>。可能现在你还对 Flutter 的内置控件不熟悉，but <strong>Don’t worry , take is easy</strong> ，后面我们就会详细介绍。这里你只需要知道，一个无状态的 Widget 就是这么简单。</p> 
<p>Widget 和 Widget 之间通过 <code>child:</code> 进行嵌套。其中有的 Widget 只能有一个 child，比如下方的 <code>Container</code> ；有的 Widget 可以多个 child ，也就是<code>children:</code>，比如` Colum 布局。下方代码便是 Container Widget 嵌套了 Text Widget。</p> 
<pre><code>import 'package:flutter/material.dart';

class DEMOWidget extends StatelessWidget {
  final String text;

  //数据可以通过构造方法传递进来
  DEMOWidget(this.text);

  @override
  Widget build(BuildContext context) {
    //这里返回你需要的控件
    //这里末尾有没有的逗号，对于格式化代码而已是不一样的。
    return Container(
      //白色背景
      color: Colors.white,
      //Dart语法中，?? 表示如果text为空，就返回尾号后的内容。
      child: Text(text ?? "这就是无状态DMEO"),
    );
  }
}
</code></pre> 
<h5><a id="32StatefulWidget_163"></a>3.2、有状态StatefulWidget</h5> 
<p>继续直插主题，如下代码，是有状态的widget的简单实现。</p> 
<p>你需要创建管理的是主要是 <code>State</code> ， 通过 State 的 <code>build</code> 方法去构建控件。在 State 中，你可以动态改变数据，这类似 MVVM 实现，在 <code>setState</code> 之后，改变的数据会触发 Widget 重新构建刷新。而下方代码中，是通过延两秒之后，让文本显示为 <em>“这就变了数值”</em>。</p> 
<p>如下代码还可以看出，State 中主要的声明周期有 ：</p> 
<ul><li><strong>initState</strong> ：初始化，理论上只有初始化一次，第二篇中会说特殊情况下。</li><li><strong>didChangeDependencies</strong>：在 initState 之后调用，此时可以获取其他 State 。</li><li><strong>dispose</strong> ：销毁，只会调用一次。</li></ul> 
<p>看到没，Flutter 其实就是这么简单！你的关注点只要在：创建你的 <code>StatelessWidget</code> 或者 <code>StatefulWidget</code> 而已。<strong>你需要的就是在 <code>build</code> 中堆积你的布局，然后把数据添加到 Widget 中，最后通过 <code>setState</code> 改变数据，从而实现画面变化。</strong></p> 
<pre><code>import 'dart:async';
import 'package:flutter/material.dart';

class DemoStateWidget extends StatefulWidget {

  final String text;

  通过构造方法传值
  DemoStateWidget(this.text);

  ///主要是负责创建state
  @override
  _DemoStateWidgetState createState() =&gt; _DemoStateWidgetState(text);
}

class _DemoStateWidgetState extends State&lt;DemoStateWidget&gt; {

  String text;

  _DemoStateWidgetState(this.text);
  
  @override
  void initState() {
    ///初始化，这个函数在生命周期中只调用一次
    super.initState();
    ///定时2秒
    new Future.delayed(const Duration(seconds: 1), () {
      setState(() {
        text = "这就变了数值";
      });
    });
  }

  @override
  void dispose() {
    ///销毁
    super.dispose();
  }

  @override
  void didChangeDependencies() {
    ///在initState之后调 Called when a dependency of this [State] object changes.
    super.didChangeDependencies();
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      child: Text(text ?? "这就是有状态DMEO"),
    );
  }
}
</code></pre> 
<h4><a id="4Flutter__234"></a>4、Flutter 布局</h4> 
<p>Flutter 中拥有需要将近30种内置的 <a href="https://flutterchina.club/widgets/layout" rel="nofollow">布局Widget</a>，其中常用有 <em>Container、Padding、Center、Flex、Stack、Row、Colum、ListView</em> 等，下面简单讲解它们的特性和使用。</p> 
<p>|<br> 类型</p> 
<p>|</p> 
<p>作用特点</p> 
<p>|<br> | — | — |<br> |</p> 
<p>Container</p> 
<p>|</p> 
<p>只有一个子 Widget。默认充满，包含了padding、margin、color、宽高、decoration 等配置。</p> 
<p>|<br> |</p> 
<p>Padding</p> 
<p>|</p> 
<p>只有一个子 Widget。只用于设置Padding，常用于嵌套child，给child设置padding。</p> 
<p>|<br> |</p> 
<p>Center</p> 
<p>|</p> 
<p>只有一个子 Widget。只用于居中显示，常用于嵌套child，给child设置居中。</p> 
<p>|<br> |</p> 
<p>Stack</p> 
<p>|</p> 
<p>可以有多个子 Widget。 子Widget堆叠在一起。</p> 
<p>|<br> |</p> 
<p>Colum</p> 
<p>|</p> 
<p>可以有多个子 Widget。垂直布局。</p> 
<p>|<br> |</p> 
<p>Row</p> 
<p>|</p> 
<p>可以有多个子 Widget。水平布局。</p> 
<p>|<br> |</p> 
<p>Expanded</p> 
<p>|</p> 
<p>只有一个子 Widget。在 Colum 和 Row 中充满。</p> 
<p>|<br> |</p> 
<p>ListView</p> 
<p>|</p> 
<p>可以有多个子 Widget。自己意会吧。</p> 
<p>|</p> 
<ul><li>Container ：最常用的默认布局！只能包含一个<code>child:</code>，支持配置 <em>padding,margin,color,宽高,decoration（一般配置边框和阴影）等配置</em>，在 Flutter 中，不是所有的控件都有 <em>宽高、padding、margin、color</em> 等属性，所以才会有 Padding、Center 等 Widget 的存在。 new Container( ///四周10大小的maring margin: EdgeInsets.all(10.0), height: 120.0, width: 500.0, ///透明黑色遮罩 decoration: new BoxDecoration( ///弧度为4.0 borderRadius: BorderRadius.all(Radius.circular(4.0)), ///设置了decoration的color，就不能设置Container的color。 color: Colors.black, ///边框 border: new Border.all(color: Color(GSYColors.subTextColor), width: 0.3)), child:new Text(“666666”));</li><li>Colum、Row 绝对是必备布局， 横竖布局也是日常中最常见的场景。如下方所示，它们常用的有这些属性配置：主轴方向是 start 或 center 等；副轴方向方向是 start 或 center 等；mainAxisSize 是充满最大尺寸，或者只根据子 Widget 显示最小尺寸。</li></ul> 
<pre><code>//主轴方向，Colum的竖向、Row我的横向
mainAxisAlignment: MainAxisAlignment.start, 
//默认是最大充满、还是根据child显示最小大小
mainAxisSize: MainAxisSize.max,
//副轴方向，Colum的横向、Row我的竖向
crossAxisAlignment :CrossAxisAlignment.center,
</code></pre> 
<ul><li>Expanded 在 Colum 和 Row 中代表着平均充满，当有两个存在的时候默认均分充满。同时页可以设置 <code>flex</code> 属性决定比例。</li></ul> 
<pre><code>    new Column(
     ///主轴居中,即是竖直向居中
     mainAxisAlignment: MainAxisAlignment.center,
     ///大小按照最小显示
     mainAxisSize : MainAxisSize.min,
     ///横向也居中
      crossAxisAlignment : CrossAxisAlignment.center,
      children: &lt;Widget&gt;[
        ///flex默认为1
        new Expanded(child: new Text("1111"), flex: 2,),
        new Expanded(child: new Text("2222")),
      ],
    );
</code></pre> 
<p>接下来我们来写一个复杂一些的控件。首先我们创建一个私有方法<code>_getBottomItem</code>，返回一个 <code>Expanded Widget</code>，因为后面我们需要将这个方法返回的 Widget 在 Row 下平均充满。</p> 
<p>如代码中注释，布局内主要是现实一个居中的Icon图标和文本，中间间隔5.0的 padding：</p> 
<pre><code>  ///返回一个居中带图标和文本的Item
  _getBottomItem(IconData icon, String text) {
    ///充满 Row 横向的布局
    return new Expanded(
      flex: 1,
      ///居中显示
      child: new Center(
        ///横向布局
        child: new Row(
          ///主轴居中,即是横向居中
          mainAxisAlignment: MainAxisAlignment.center,
          ///大小按照最大充满
          mainAxisSize : MainAxisSize.max,
          ///竖向也居中
          crossAxisAlignment : CrossAxisAlignment.center,
          children: &lt;Widget&gt;[
            ///一个图标，大小16.0，灰色
            new Icon(
              icon,
              size: 16.0,
              color: Colors.grey,
            ),
            ///间隔
            new Padding(padding: new EdgeInsets.only(left:5.0)),
            ///显示文本
            new Text(
              text,
              //设置字体样式：颜色灰色，字体大小14.0
              style: new TextStyle(color: Colors.grey, fontSize: 14.0),
              //超过的省略为...显示
              overflow: TextOverflow.ellipsis,
              //最长一行
              maxLines: 1,
            ),
          ],
        ),
      ),
    );
  }
</code></pre> 
<p>item效果</p> 
<p>接着我们把上方的方法，放到新的布局里。如下流程和代码：</p> 
<ul><li>首先是 <code>Container</code>包含了<code>Card</code>，用于快速简单的实现圆角和阴影。</li><li>然后接下来包含了<code>FlatButton</code>实现了点击，通过Padding实现了边距。</li><li>接着通过<code>Column</code>垂直包含了两个子Widget，一个是<code>Container</code>、一个是<code>Row</code>。</li><li>Row 内使用的就是<code>_getBottomItem</code>方法返回的 Widget ，效果如下图。</li></ul> 
<pre><code>  @override
  Widget build(BuildContext context) {
    return new Container(
      ///卡片包装
      child: new Card(
           ///增加点击效果
          child: new FlatButton(
              onPressed: (){print("点击了哦");},
              child: new Padding(
                padding: new EdgeInsets.only(left: 0.0, top: 10.0, right: 10.0, bottom: 10.0),
                child: new Column(
                  mainAxisSize: MainAxisSize.min,
                  children: &lt;Widget&gt;[
                    ///文本描述
                    new Container(
                        child: new Text(
                          "这是一点描述",
                          style: TextStyle(
                            color: Color(GSYColors.subTextColor),
                            fontSize: 14.0,
                          ),
                          ///最长三行，超过 ... 显示
                          maxLines: 3,
                          overflow: TextOverflow.ellipsis,
                        ),
                        margin: new EdgeInsets.only(top: 6.0, bottom: 2.0),
                        alignment: Alignment.topLeft),
                    new Padding(padding: EdgeInsets.all(10.0)),

                    ///三个平均分配的横向图标文字
                    new Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: &lt;Widget&gt;[
                        _getBottomItem(Icons.star, "1000"),
                        _getBottomItem(Icons.link, "1000"),
                        _getBottomItem(Icons.subject, "1000"),
                      ],
                    ),
                  ],
                ),
              ))),
    );
  }
</code></pre> 
<p>完整Item</p> 
<p>Flutter 中，你的布局很多时候就是这么一层一层嵌套出来的，当然还有其他更高级的布局方式，这里就先不展开了。</p> 
<h4><a id="5Flutter__535"></a>5、Flutter 页面</h4> 
<p>Flutter 中除了布局的 Widget，还有交互显示的 Widget 和完整页面呈现的Widget。其中常见的有 _MaterialApp、Scaffold、Appbar、Text、Image、FlatButton_等。下面简单介绍这些 Wdiget，并完成一个页面。</p> 
<p>|<br> 类型</p> 
<p>|</p> 
<p>作用特点</p> 
<p>|<br> | — | — |<br> |</p> 
<p>MaterialApp</p> 
<p>|</p> 
<p>一般作为APP顶层的主页入口，可配置主题，多语言，路由等</p> 
<p>|<br> |</p> 
<p>Scaffold</p> 
<p>|</p> 
<p>一般用户页面的承载Widget，包含appbar、snackbar、drawer等material design的设定。</p> 
<p>|<br> |</p> 
<p>Appbar</p> 
<p>|</p> 
<p>一般用于Scaffold的appbar ，内有标题，二级页面返回按键等，当然不止这些，tabbar等也会需要它 。</p> 
<p>|<br> |</p> 
<p>Text</p> 
<p>|</p> 
<p>显示文本，几乎都会用到，主要是通过style设置TextStyle来设置字体样式等。</p> 
<p>|<br> |</p> 
<p>RichText</p> 
<p>|</p> 
<p>富文本，通过设置<code>TextSpan</code>，可以拼接出富文本场景。</p> 
<p>|<br> |</p> 
<p>TextField</p> 
<p>|</p> 
<p>文本输入框 ：<code>new TextField(controller: //文本控制器, obscureText: "hint文本");</code></p> 
<p>|<br> |</p> 
<p>Image</p> 
<p>|</p> 
<p>|<br> |</p> 
<p>FlatButton</p> 
<p>|</p> 
<p>按键点击: <code>new FlatButton(onPressed: () {},child: new Container());</code></p> 
<p>|</p> 
<p>那么再次直插主题实现一个简单完整的页面试试。如下方代码：</p> 
<ul><li>首先我们创建一个StatefulWidget：<code>DemoPage</code>。</li><li>然后在 _DemoPageState中，通过<code>build</code>创建了一个<code>Scaffold</code>。</li><li>Scaffold内包含了一个<code>AppBar</code>和一个<code>ListView</code>。</li><li>AppBar类似标题了区域，其中设置了 <code>title</code>为 Text Widget。</li><li>body是<code>ListView</code>,返回了20个之前我们创建过的 DemoItem Widget。</li></ul> 
<pre><code>import 'package:flutter/material.dart';
import 'package:gsy_github_app_flutter/test/DemoItem.dart';

class DemoPage extends StatefulWidget {
  @override
  _DemoPageState createState() =&gt; _DemoPageState();
}

class _DemoPageState extends State&lt;DemoPage&gt; {
  @override
  Widget build(BuildContext context) {
    ///一个页面的开始
    ///如果是新页面，会自带返回按键
    return new Scaffold(
      ///背景样式
      backgroundColor: Colors.blue,
      ///标题栏，当然不仅仅是标题栏
      appBar: new AppBar(
        ///这个title是一个Widget
        title: new Text("Title"),
      ),
      ///正式的页面开始
      ///一个ListView，20个Item
      body: new ListView.builder(
        itemBuilder: (context, index) {
          return new DemoItem();
        },
        itemCount: 20,
      ),
    );
  }
}
</code></pre> 
<p>最后我们创建一个StatelessWidget作为入口文件，实现一个<code>MaterialApp</code>将上方的<code>DemoPage</code>设置为home页面，通过<code>main</code>入口执行页面。</p> 
<pre><code>import 'package:flutter/material.dart';
import 'package:gsy_github_app_flutter/test/DemoPage.dart';

void main() {
  runApp(new DemoApp());
}

class DemoApp extends StatelessWidget {
  DemoApp({Key key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return new MaterialApp(home: DemoPage());
  }
}
</code></pre> 
<p>更多的Flutter学习资料可以扫码免费领取！</p> 
<img src="https://images2.imgbox.com/b5/a2/LuSJdw3v_o.png"> # **Flutter技术解析与实战，全家桶学习资料（含Flutter进阶学习笔记、入门与实战和完整开发实战详解）** 
<p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。</p> 
<p>在这里为了方便大家系统的学习Flutter，这里特意联合了阿里P7架构师和谷歌技术团队共同整理了一份Flutter全家桶学习资料。</p> 
<p>由于文章内容比较多，篇幅有限，资料已经被整理成了PDF文档，有需要 Flutter技术解析与实战 完整文档的<strong>可扫描下方卡片免费获取！</strong></p> 
<img src="https://images2.imgbox.com/7f/e5/SnKndcCg_o.png"> 
<h2><a id="Flutter_778"></a><strong>《Flutter技术解析与实战》</strong></h2> 
<h3><a id="_780"></a><strong>目录</strong></h3> 
<p><img src="https://images2.imgbox.com/01/bc/YDJj1dI5_o.png" alt="img"></p> 
<h3><a id="__784"></a><strong>第一章 混合工程</strong></h3> 
<p>​ ● Flutter工程体系</p> 
<p>​ ● 混合工程改造实战</p> 
<p>​ ● 混合工程与持续集成</p> 
<p>​ ● 快速完成混合工程搭建</p> 
<p>​ ● 使用混合栈框架开发</p> 
<p><img src="https://images2.imgbox.com/18/70/FcE3WTmX_o.png" alt="img"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2bd66d79deffd2412fd46b22d2d9631d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vscode连接远程服务器 &#43; Tensorflow2环境配置 &#43; 深度学习训练</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/56f6b0713b7f3284fbf884f0e90e3456/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux 集群时钟不同步导致的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>