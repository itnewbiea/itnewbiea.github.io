<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux网络高级——Modbus TCP及Modbus库 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux网络高级——Modbus TCP及Modbus库" />
<meta property="og:description" content="Modbus是一种串行通信协议，是Modicon公司（现在的施耐德电气 Schneider Electric）于1979年为使用可编程逻辑控制器（PLC）通信而发表。Modbus已经成为工业领域通信协议的业界标准（De facto），并且现在是工业电子设备之间常用的连接方式。
Modbus协议是一项应用层报文传输协议，包括ASCII、RTU、TCP三种报文类型。
标准的Modbus协议物理层接口有RS232、RS422、RS485和以太网接口，采用master/slave方式通信。
Modbus TCP协议格式
ModbusTCP的数据帧可分为两部分：MBAP&#43;PDU
1）报文头MBAP
2）功能代码
3）PDU详细结构
0x01：读线圈
在从站中读1~2000个连续线圈状态，ON=1,OFF=0
请求：MBAP 功能码 起始地址H 起始地址L 数量H 数量L（共12字节）
响应：MBAP 功能码 数据长度 数据（一个地址的数据为1位）
0x05：写单个线圈
将从站中的一个输出写成ON或OFF，0xFF00请求输出为ON,0x000请求输出为OFF
请求：MBAP 功能码 输出地址H 输出地址L 输出值H 输出值L（共12字节）
响应：MBAP 功能码 输出地址H 输出地址L 输出值H 输出值L（共12字节）
0x0F：写多个线圈
将一个从站中的一个线圈序列的每个线圈都强制为ON或OFF，数据域中置1的位请求相应输出位ON，置0的位请求响应输出为OFF
请求：MBAP 功能码 起始地址H 起始地址L 输出数量H 输出数量L 字节长度 输出值H 输出值L
响应：MBAP 功能码 起始地址H 起始地址L 输出数量H 输出数量L
0x02：读离散量输入
从一个从站中读1~2000个连续的离散量输入状态
请求：MBAP 功能码 起始地址H 起始地址L 数量H 数量L（共12字节）
响应：MBAP 功能码 数据长度 数据（长度：9&#43;ceil（数量/8））
0x04：读输入寄存器
从一个远程设备中读1~2000个连续输入寄存器" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/45beaccada0a9eed2f2c4a15323b42dd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-14T21:09:40+08:00" />
<meta property="article:modified_time" content="2023-02-14T21:09:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux网络高级——Modbus TCP及Modbus库</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p> Modbus是一种串行通信协议，是Modicon公司（现在的施耐德电气 Schneider Electric）于1979年为使用可编程逻辑控制器（PLC）通信而发表。Modbus已经成为工业领域通信协议的业界标准（De facto），并且现在是工业电子设备之间常用的连接方式。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>Modbus协议是一项应用层报文传输协议，包括ASCII、RTU、<span class="kdocs-bold" style="font-weight:bold;">TCP</span>三种报文类型。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>标准的Modbus协议物理层接口有RS232、RS422、RS485和<span class="kdocs-bold" style="font-weight:bold;">以太网</span>接口，采用<span class="kdocs-bold" style="font-weight:bold;">master/slave</span>方式通信。</p></li></ul> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p><span class="kdocs-fontSize" style="font-size:19pt;"><span class="kdocs-bold" style="font-weight:bold;">Modbus TCP协议格式</span></span></p></li></ol> 
 <p style=""><span class="kdocs-fontSize" style="font-size:19pt;"> ModbusTCP的数据帧可分为两部分：<span class="kdocs-color" style="background-color:#FBF5B3;">MBAP+PDU</span></span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:734px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:39.237057%;height:0;"> 
    <img src="https://images2.imgbox.com/21/58/2hFlhfxR_o.png" style="margin-left:;display:block;width:734px;margin-top:-39.237057%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"><span class="kdocs-bold" style="font-weight:bold;"> 1）报文头MBAP</span></span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:678px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:47.935104%;height:0;"> 
    <img src="https://images2.imgbox.com/d4/a5/Y8lM21s2_o.png" style="margin-left:;display:block;width:678px;margin-top:-47.935104%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"><span class="kdocs-bold" style="font-weight:bold;"> 2）功能代码</span></span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:686px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:52.332363%;height:0;"> 
    <img src="https://images2.imgbox.com/4e/cd/NP8U004U_o.png" style="margin-left:;display:block;width:686px;margin-top:-52.332363%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"><span class="kdocs-bold" style="font-weight:bold;"> 3）PDU详细结构</span></span></p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">0x01：读线圈</span></p> 
 <p style="">在从站中读1~2000个连续线圈状态，ON=1,OFF=0</p> 
 <p style="">请求：MBAP 功能码 起始地址H 起始地址L 数量H 数量L（共12字节）</p> 
 <p style="">响应：MBAP 功能码 数据长度 数据（一个地址的数据为1位）</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">0x05：写单个线圈</span></p> 
 <p style="">将从站中的一个输出写成ON或OFF，0xFF00请求输出为ON,0x000请求输出为OFF</p> 
 <p style="">请求：MBAP 功能码 输出地址H 输出地址L 输出值H 输出值L（共12字节）</p> 
 <p style="">响应：MBAP 功能码 输出地址H 输出地址L 输出值H 输出值L（共12字节）</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">0x0F：写多个线圈</span></p> 
 <p style="">将一个从站中的一个线圈序列的每个线圈都强制为ON或OFF，数据域中置1的位请求相应输出位ON，置0的位请求响应输出为OFF</p> 
 <p style="">请求：MBAP 功能码 起始地址H 起始地址L 输出数量H 输出数量L 字节长度 输出值H 输出值L</p> 
 <p style="">响应：MBAP 功能码 起始地址H 起始地址L 输出数量H 输出数量L</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">0x02：读离散量输入</span></p> 
 <p style="">从一个从站中读1~2000个连续的离散量输入状态</p> 
 <p style="">请求：MBAP 功能码 起始地址H 起始地址L 数量H 数量L（共12字节）</p> 
 <p style="">响应：MBAP 功能码 数据长度 数据（长度：9+ceil（数量/8））</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">0x04：读输入寄存器</span></p> 
 <p style="">从一个远程设备中读1~2000个连续输入寄存器</p> 
 <p style="">请求：MBAP 功能码 起始地址H 起始地址L 寄存器数量H 寄存器数量L（共12字节）</p> 
 <p style="">响应：MBAP 功能码 数据长度 寄存器数据(长度：9+寄存器数量×2)</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">0x03：读保持寄存器</span></p> 
 <p style="">从远程设备中读保持寄存器连续块的内容</p> 
 <p style="">请求：MBAP 功能码 起始地址H 起始地址L 寄存器数量H 寄存器数量L（共12字节）</p> 
 <p style="">响应：MBAP 功能码 数据长度 寄存器数据(长度：9+寄存器数量×2)</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">0x06：写单个保持寄存器</span></p> 
 <p style="">在一个远程设备中写一个保持寄存器</p> 
 <p style="">请求：MBAP 功能码 寄存器地址H 寄存器地址L 寄存器值H 寄存器值L（共12字节）</p> 
 <p style="">响应：MBAP 功能码 寄存器地址H 寄存器地址L 寄存器值H 寄存器值L（共12字节）</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">0x10：写多个保持寄存器</span></p> 
 <p style="">在一个远程设备中写连续寄存器块（1~123个寄存器）</p> 
 <p style="">请求：MBAP 功能码 起始地址H 起始地址L 寄存器数量H 寄存器数量L 字节长度 寄存器值（13+寄存器数量×2）</p> 
 <p style="">响应：MBAP 功能码 起始地址H 起始地址L 寄存器数量H 寄存器数量L（共12字节）</p> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p><span class="kdocs-fontSize" style="font-size:19pt;"><span class="kdocs-bold" style="font-weight:bold;">Modbus TCP协议通信</span></span></p></li></ol> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"><span class="kdocs-bold" style="font-weight:bold;">1）通信方式</span></span></p> 
 <p style="">Modbus设备可分为主站(poll)和从站(slave)。主站只有一个，从站有多个，主站向各从站发送请求帧，从站给予响应。在使用TCP通信时，主站为client端，主动建立连接；从站为server端，等待连接。</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>主站请求：功能码+数据</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>从站正常响应：请求功能码+响应数据</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>从站异常响应：异常功能码+异常码，其中异常功能码即将请求功能码的最高有效位置1，异常码指示差错类型</p></li></ul> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"><span class="kdocs-bold" style="font-weight:bold;">2）通信过程</span></span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>connect 建立TCP连接</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>准备Modbus报文</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>使用send命令发送报文</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>在同一连接下等待应答</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>使用recv命令读取报文，完成一次数据交换</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>通信任务结束时，关闭TCP连接</p></li></ul> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p><span class="kdocs-fontSize" style="font-size:19pt;"><span class="kdocs-bold" style="font-weight:bold;">Modbus 库</span></span></p></li></ol> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"><span class="kdocs-bold" style="font-weight:bold;">Linux下Modbus库的使用</span></span></p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">#include &lt;stdio.h&gt;
#include &lt;modbus-tcp.h&gt;
#include &lt;modbus.h&gt;
#include &lt;stdlib.h&gt;
#include&lt;unistd.h&gt;
int main(int argc, char const *argv[])
{
    modbus_t *ctx;
    uint16_t data[64] = {0};
    //1.创建modbus实例
    ctx = modbus_new_tcp(argv[1], atoi(argv[2]));
    if (ctx == NULL)
    {
        perror("modbus new tcp err");
        return -1;
    }
    //2.设置从机id
    modbus_set_slave(ctx, 1);
    //3.和从机建立联系
    modbus_connect(ctx);
    //4.03 读取寄存器
    while (1)
    {
        modbus_read_registers(ctx, 0, 1, data);
        printf("%d \n", data[0]);
        sleep(2);
    }
    //5.关闭套接字
    modbus_close(ctx);
    //6.释放实例
    modbus_free(ctx);
    return 0;
}</code></pre> 
 <p style=""></p> 
 <p style=""></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/41d048efa206ce1336c58089f7da7649/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Cortex-M0存储器系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b766f56e45e35343baec12a43b3974cd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">罗德里格旋转公式的推导</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>