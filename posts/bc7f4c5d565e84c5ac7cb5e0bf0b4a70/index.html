<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JAVA设计模式之组合模式 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JAVA设计模式之组合模式" />
<meta property="og:description" content="转自 JAVA设计模式之组合模式 组合模式（Composite）的定义 组合(Composite)模式是一种对象的行为模式。将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
组合模式的本质：统一叶子对象和组合对象。
组合模式的目的：让客户端不再区分操作的是组合对象还是叶子对象，而是以一个统一的方式来操作。
从上图可以看出，文件系统是一个树结构，树上长有节点。树的节点有两种，一种是树枝节点，即目录，有内部树结构，在图中涂有颜色；另一种是文件，即树叶节点，没有内部树结构。
显然，可以把目录和文件当做同一种对象同等对待和处理，这也就是合成模式的应用。
合成模式可以不提供父对象的管理方法，但是合成模式必须在合适的地方提供子对象的管理方法，诸如：add()、remove()、以及getChild()等。
合成模式的实现根据所实现接口的区别分为两种形式，分别称为安全式和透明式。
组合模式（Composite）优缺点 组合模式是一种结构型设计模式。其主要优点如下：
组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”； 缺点：
设计较复杂，客户端需要花更多时间理清类之间的层次关系；不容易限制容器中的构件；不容易用继承的方法来增加构件的新功能； 适用环境：
在现实生活中，存在很多“部分-整体”的关系。汽车与轮胎、发动机的关系。医院与科室、医生的关系。学校与学院、学生、老师的关系。
组合模式是一种非常普遍和常用的模式，接口服务互相组合，提供更丰富的接口，实现复杂的业务逻辑。一般情况会选择使用组合代替继承，组合更灵活、更方便。
安全式合成模式的结构 安全模式的合成模式要求管理聚集的方法只出现在树枝构件类中，而不出现在树叶构件类中。
这种形式涉及到三个角色：
抽象构件(Component)角色：这是一个抽象角色，它给参加组合的对象定义出公共的接口及其默认行为，可以用来管理所有的子对象。合成对象通常把它所包含的子对象当做类型为Component的对象。在安全式的合成模式里，构件角色并不定义出管理子对象的方法，这一定义由树枝构件对象给出。树叶构件(Leaf)角色：树叶对象是没有下级子对象的对象，定义出参加组合的原始对象的行为。树枝构件(Composite)角色：代表参加组合的有下级子对象的对象。树枝构件类给出所有的管理子对象的方法，如add()、remove()以及getChild()。 安全式合成模式的应用实例 // 抽象构件角色类 public interface Component { /** * 输出组建自身的名称 */ public void printStruct(String preStr); } // 树枝构件角色类 public class Composite implements Component { /** * 用来存储组合对象中包含的子组件对象 */ private List&lt;Component&gt; childComponents = new ArrayList&lt;Component&gt;(); /** * 组合对象的名字 */ private String name; /** * 构造方法，传入组合对象的名字 * @param name 组合对象的名字 */ public Composite(String name){ this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/bc7f4c5d565e84c5ac7cb5e0bf0b4a70/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-15T19:51:51+08:00" />
<meta property="article:modified_time" content="2022-04-15T19:51:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JAVA设计模式之组合模式</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>转自 <a href="http://www.kongzid.com/archives/design10" rel="nofollow" title="JAVA设计模式之组合模式">JAVA设计模式之组合模式</a></h4> 
<h4></h4> 
<h4>组合模式（Composite）的定义</h4> 
<p>组合(Composite)模式是一种对象的行为模式。将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p> 
<p>组合模式的本质：统一叶子对象和组合对象。</p> 
<p>组合模式的目的：让客户端不再区分操作的是组合对象还是叶子对象，而是以一个统一的方式来操作。</p> 
<p style="text-align:center;"><img alt="" class="has" height="245" src="https://images2.imgbox.com/53/7b/PPzrMsYp_o.png" width="783"></p> 
<p>从上图可以看出，文件系统是一个树结构，树上长有节点。树的节点有两种，一种是树枝节点，即目录，有内部树结构，在图中涂有颜色；另一种是文件，即树叶节点，没有内部树结构。</p> 
<p>　　显然，可以把目录和文件当做同一种对象同等对待和处理，这也就是合成模式的应用。</p> 
<p>　　合成模式可以不提供父对象的管理方法，但是合成模式必须在合适的地方提供子对象的管理方法，诸如：add()、remove()、以及getChild()等。</p> 
<p>　　合成模式的实现根据所实现接口的区别分为两种形式，分别称为<strong>安全式</strong>和<strong>透明式</strong>。</p> 
<h4>组合模式（Composite）优缺点</h4> 
<p>组合模式是一种结构型设计模式。其主要<span style="color:#f33b45;"><strong>优点</strong></span>如下：</p> 
<ol><li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</li><li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</li></ol> 
<p><strong><span style="color:#f33b45;">缺点：</span></strong></p> 
<ol><li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li><li>不容易限制容器中的构件；</li><li>不容易用继承的方法来增加构件的新功能；</li></ol> 
<p><span style="color:#f33b45;"><strong>适用环境：</strong></span></p> 
<p>在现实生活中，存在很多“部分-整体”的关系。汽车与轮胎、发动机的关系。医院与科室、医生的关系。学校与学院、学生、老师的关系。</p> 
<p>组合模式是一种非常普遍和常用的模式，接口服务互相组合，提供更丰富的接口，实现复杂的业务逻辑。一般情况会选择使用组合代替继承，组合更灵活、更方便。</p> 
<h4>安全式合成模式的结构</h4> 
<p>安全模式的合成模式要求管理聚集的方法只出现在树枝构件类中，而不出现在树叶构件类中。</p> 
<p style="text-align:center;"><img alt="" class="has" height="300" src="https://images2.imgbox.com/a3/f0/iUDDNvGH_o.png" width="563"></p> 
<p>这种形式涉及到三个角色：</p> 
<ul><li><strong>抽象构件(Component)角色：</strong>这是一个抽象角色，它给参加组合的对象定义出公共的接口及其默认行为，可以用来管理所有的子对象。合成对象通常把它所包含的子对象当做类型为Component的对象。在安全式的合成模式里，构件角色并不定义出管理子对象的方法，这一定义由树枝构件对象给出。</li><li><strong>树叶构件(Leaf)角色：</strong>树叶对象是没有下级子对象的对象，定义出参加组合的原始对象的行为。</li><li><strong>树枝构件(Composite)角色：</strong>代表参加组合的有下级子对象的对象。树枝构件类给出所有的管理子对象的方法，如add()、remove()以及getChild()。</li></ul> 
<h4>安全式合成模式<strong>的应用实例</strong></h4> 
<pre class="has"><code>// 抽象构件角色类
public interface Component {
    /**
     * 输出组建自身的名称
     */
    public void printStruct(String preStr);
}

// 树枝构件角色类
public class Composite implements Component {
    /**
     * 用来存储组合对象中包含的子组件对象
     */
    private List&lt;Component&gt; childComponents = new ArrayList&lt;Component&gt;();
    /**
     * 组合对象的名字
     */
    private String name;
    /**
     * 构造方法，传入组合对象的名字
     * @param name    组合对象的名字
     */
    public Composite(String name){
        this.name = name;
    }
    /**
     * 聚集管理方法，增加一个子构件对象
     * @param child 子构件对象
     */
    public void addChild(Component child){
        childComponents.add(child);
    }
    /**
     * 聚集管理方法，删除一个子构件对象
     * @param index 子构件对象的下标
     */
    public void removeChild(int index){
        childComponents.remove(index);
    }
    /**
     * 聚集管理方法，返回所有子构件对象
     */
    public List&lt;Component&gt; getChild(){
        return childComponents;
    }
    /**
     * 输出对象的自身结构
     * @param preStr 前缀，主要是按照层级拼接空格，实现向后缩进
     */
    @Override
    public void printStruct(String preStr) {
        // 先把自己输出
        System.out.println(preStr + "+" + this.name);
        //如果还包含有子组件，那么就输出这些子组件对象
        if(this.childComponents != null){
            //添加两个空格，表示向后缩进两个空格
            preStr += "  ";
            //输出当前对象的子对象
            for(Component c : childComponents){
                //递归输出每个子对象
                c.printStruct(preStr);
            }
        }
        
    }

}

// 树叶构件角色类
public class Leaf implements Component {
    /**
     * 叶子对象的名字
     */
    private String name;
    /**
     * 构造方法，传入叶子对象的名称
     * @param name 叶子对象的名字
     */
    public Leaf(String name){
        this.name = name;
    }
    /**
     * 输出叶子对象的结构，叶子对象没有子对象，也就是输出叶子对象的名字
     * @param preStr 前缀，主要是按照层级拼接的空格，实现向后缩进
     */
    @Override
    public void printStruct(String preStr) {
        // TODO Auto-generated method stub
        System.out.println(preStr + "-" + name);
    }

}

// 客户端类
public class Client {
    public static void main(String[]args){
        Composite root = new Composite("服装");
        Composite c1 = new Composite("男装");
        Composite c2 = new Composite("女装");
        
        Leaf leaf1 = new Leaf("衬衫");
        Leaf leaf2 = new Leaf("夹克");
        Leaf leaf3 = new Leaf("裙子");
        Leaf leaf4 = new Leaf("套装");
        
        root.addChild(c1);
        root.addChild(c2);
        c1.addChild(leaf1);
        c1.addChild(leaf2);
        c2.addChild(leaf3);
        c2.addChild(leaf4);
        
        root.printStruct("");
    }
}
</code></pre> 
<p>可以看出，树枝构件类(Composite)给出了addChild()、removeChild()以及getChild()等方法的声明和实现，而树叶构件类则没有给出这些方法的声明或实现。这样的做法是安全的做法，由于这个特点，客户端应用程序不可能错误地调用树叶构件的聚集方法，因为树叶构件没有这些方法，调用会导致编译错误。</p> 
<p>　　安全式合成模式的缺点是不够透明，因为树叶类和树枝类将具有不同的接口。</p> 
<h4>透明式合成模式的结构</h4> 
<p>与安全式的合成模式不同的是，透明式的合成模式要求所有的具体构件类，不论树枝构件还是树叶构件，均符合一个固定接口。</p> 
<p style="text-align:center;"><img alt="" class="has" height="360" src="https://images2.imgbox.com/57/6a/SOpd7lc8_o.png" width="537"></p> 
<h4>透明式合成模式<strong>的应用实例</strong></h4> 
<pre class="has"><code>// 抽象构件角色类
public abstract class Component {
    /**
     * 输出组建自身的名称
     */
    public abstract void printStruct(String preStr);
    /**
     * 聚集管理方法，增加一个子构件对象
     * @param child 子构件对象
     */
    public void addChild(Component child){
        /**
         * 缺省实现，抛出异常，因为叶子对象没有此功能
         * 或者子组件没有实现这个功能
         */
        throw new UnsupportedOperationException("对象不支持此功能");
    }
    /**
     * 聚集管理方法，删除一个子构件对象
     * @param index 子构件对象的下标
     */
    public void removeChild(int index){
        /**
         * 缺省实现，抛出异常，因为叶子对象没有此功能
         * 或者子组件没有实现这个功能
         */
        throw new UnsupportedOperationException("对象不支持此功能");
    }
    
    /**
     * 聚集管理方法，返回所有子构件对象
     */
    public List&lt;Component&gt; getChild(){
        /**
         * 缺省实现，抛出异常，因为叶子对象没有此功能
         * 或者子组件没有实现这个功能
         */
        throw new UnsupportedOperationException("对象不支持此功能");
    }
}</code></pre> 
<p>树枝构件角色类，此类将implements Conponent改为extends Conponent，其他地方无变化。</p> 
<pre class="has"><code>public class Composite extends Component {
    /**
     * 用来存储组合对象中包含的子组件对象
     */
    private List&lt;Component&gt; childComponents = new ArrayList&lt;Component&gt;();
    /**
     * 组合对象的名字
     */
    private String name;
    /**
     * 构造方法，传入组合对象的名字
     * @param name    组合对象的名字
     */
    public Composite(String name){
        this.name = name;
    }
    /**
     * 聚集管理方法，增加一个子构件对象
     * @param child 子构件对象
     */
    public void addChild(Component child){
        childComponents.add(child);
    }
    /**
     * 聚集管理方法，删除一个子构件对象
     * @param index 子构件对象的下标
     */
    public void removeChild(int index){
        childComponents.remove(index);
    }
    /**
     * 聚集管理方法，返回所有子构件对象
     */
    public List&lt;Component&gt; getChild(){
        return childComponents;
    }
    /**
     * 输出对象的自身结构
     * @param preStr 前缀，主要是按照层级拼接空格，实现向后缩进
     */
    @Override
    public void printStruct(String preStr) {
        // 先把自己输出
        System.out.println(preStr + "+" + this.name);
        //如果还包含有子组件，那么就输出这些子组件对象
        if(this.childComponents != null){
            //添加两个空格，表示向后缩进两个空格
            preStr += "  ";
            //输出当前对象的子对象
            for(Component c : childComponents){
                //递归输出每个子对象
                c.printStruct(preStr);
            }
        }
        
    }

}</code></pre> 
<p>树叶构件角色类，此类将implements Conponent改为extends Conponent，其他地方无变化。</p> 
<pre class="has"><code>public class Leaf extends Component {
    /**
     * 叶子对象的名字
     */
    private String name;
    /**
     * 构造方法，传入叶子对象的名称
     * @param name 叶子对象的名字
     */
    public Leaf(String name){
        this.name = name;
    }
    /**
     * 输出叶子对象的结构，叶子对象没有子对象，也就是输出叶子对象的名字
     * @param preStr 前缀，主要是按照层级拼接的空格，实现向后缩进
     */
    @Override
    public void printStruct(String preStr) {
        // TODO Auto-generated method stub
        System.out.println(preStr + "-" + name);
    }

}</code></pre> 
<p>客户端类的主要变化是不再区分Composite对象和Leaf对象。</p> 
<pre class="has"><code>public class Client {
    public static void main(String[]args){
        Component root = new Composite("服装");
        Component c1 = new Composite("男装");
        Component c2 = new Composite("女装");
        
        Component leaf1 = new Leaf("衬衫");
        Component leaf2 = new Leaf("夹克");
        Component leaf3 = new Leaf("裙子");
        Component leaf4 = new Leaf("套装");
        
        root.addChild(c1);
        root.addChild(c2);
        c1.addChild(leaf1);
        c1.addChild(leaf2);
        c2.addChild(leaf3);
        c2.addChild(leaf4);
        
        root.printStruct("");
    }
}</code></pre> 
<p>可以看出，客户端无需再区分操作的是树枝对象(Composite)还是树叶对象(Leaf)了；对于客户端而言，操作的都是Component对象。</p> 
<h4>两种实现方法的选择</h4> 
<p>　　<strong>这里所说的安全性合成模式是指：</strong>从客户端使用合成模式上看是否更安全，如果是安全的，那么就不会有发生误操作的可能，能访问的方法都是被支持的。</p> 
<p>　　<strong>这里所说的透明性合成模式是指：</strong>从客户端使用合成模式上，是否需要区分到底是“树枝对象”还是“树叶对象”。如果是透明的，那就不用区分，对于客户而言，都是Compoent对象，具体的类型对于客户端而言是透明的，是无须关心的。</p> 
<p>　　对于合成模式而言，在安全性和透明性上，<strong>会更看重透明性</strong>，毕竟合成模式的目的是：让客户端不再区分操作的是树枝对象还是树叶对象，而是以一个统一的方式来操作。</p> 
<p>　　而且对于安全性的实现，需要区分是树枝对象还是树叶对象。有时候，需要将对象进行类型转换，却发现类型信息丢失了，只好强行转换，这种类型转换必然是不够安全的。</p> 
<p>　　因此在使用合成模式的时候，建议多采用透明性的实现方式。　</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ceea975ec095c385bbe75a42470f8332/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VSCode 必备插件推荐</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/84b1a65209c4302169851742749081eb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android SDK解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>