<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>在react中正确修改state - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="在react中正确修改state" />
<meta property="og:description" content="一，在react中可以通过this.state.{属性}的方式直接获取state，但当我们想要修改state的时候有许多的坑需要注意，以下 为三种常见的陷阱： 不能直接修改state。 组件直接修改state，并不会重新触发render。列如：
this.state.title=&#39;React&#39;; 正确修改方式是：
this.setState({title:&#39;React&#39;}); state的更新是异步的 调用setState时，组件state并不会立即改变，而是把要修改的状态放入事件队列中，而react优化了真正的执行时机，并且出于本身性能原因，可能会将多次setState的状态修改合并成一次状态修改。因此不要依靠当前的state计算下一个state，因为当真正执行状态修改时，有时候依赖的this.state并不能保证是最新的state，因为react本身会把多次state合并成一次，这时this.state还是旧state，因此也不能依赖当前的props计算下一个状态，因为props的更新也是异步。如：对于react常用的列子中有一个点击加号数值增加一的操作，点击一次&#43;，数量会加1，如果连续点击两次，还是会加1，这是在react合并修改为一次的情况下，相当与执行了如下代码：
Object.assign( previousState, {quantity:this.state.quantity&#43;1}, {quantity:this.state.quantity&#43;1}, ) 于是后面覆盖前面的操作，最终数值只加1，此时可以使用另一个函数作为参数的setState，这个函数有两个参数，第一个参数是本次组件修改前的状态，第二个参数是当前最新的props。
正确修改方式是：
this.setState((preState, props)=&gt;counter:preState.quantity&#43;1) state的更新是一个合并的过程 当调用ssetState修改组件的状态时，只需要传入发生改变的state，而不是完整的state，因为组件state的更新时一个合并的过程，列如，一个组件的状态为：
this.state={ title:&#39;React&#39;, content:&#39;React is an wondeful JS library&#39; } 注：当只需要修改title时，将修改的title传给setState即可：
this.setState({title:&#39;ReactJs&#39;}); react会合并最新的title到原来的状态，同时保留原来状态的content，最终合并state为：
this.state={ title:&#39;ReactJs, content:&#39;&#39;React is an wondeful Js library } 二，state与不可变对象 react官方把state当成不可变对象，一方面直接修改this.state,组件并不会重新render；另一方面，state中包含的所有状态都应该是不可变的对象，当state当中的某一个状态发生变化时，应该重新创建这个状态对象，而不是直接修改原来的state状态，那么当状态发生变化时，如何去创建新的状态呢，我们根据状态类型可以分为下面三种情况：
状态类型为不可变类型（number，string，bool，bull,undefined） 这种情况最简单，因为状态是不可变类型，所以直接给要修改的状态赋一个新值即可，列如下面我们要修改的count为number型，title（string）,success(bool)三个状态:
this.setState({ count:1, title:&#39;React&#39;, success:true }) 状态类型为数组 假如有一个数组类型的状态books，当想books中增加一本书时，既可使用数组的concat方法或者es6的扩展语法(apread syntax)
方法一：使用preState，concat创建新数组 this.setState((preState)=&gt;books:preState.books.concat([&#39;React Guide&#39;])) 方法二：ES6 spread syntax this.setState(preState=&gt;books:[...preState,&#39;&#39;React Guide]) 当我们从books中截取部分元素作为新状态时，可以用数组的slice方法：
this.setState(preState=&gt;books:preState.books.slice(1,3)) 当从books中过滤部分元素后，作为新状态时，可以使用filter方法:
this.setState(preState =&gt; { books: preState.books.filter(item =&gt; { return item !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/bb67a44c4e93dc4d01886d61c7b3f505/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-01T19:17:54+08:00" />
<meta property="article:modified_time" content="2018-07-01T19:17:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">在react中正确修改state</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><strong>一，在react中可以通过this.state.{属性}的方式直接获取state，但当我们想要修改state的时候有许多的坑需要注意，</strong>以下 为三种常见的陷阱：</h3> 
<blockquote> 
 <strong>不能直接修改state。</strong> 
</blockquote> 
<p>组件直接修改state，并不会重新触发render。列如：</p> 
<pre><code>this.state.title='React';</code></pre> 
<p>正确修改方式是：</p> 
<pre><code>this.setState({title:'React'});</code></pre> 
<blockquote> 
 <strong>state的更新是异步的</strong> 
</blockquote> 
<p>调用setState时，组件state并不会立即改变，而是把要修改的状态放入事件队列中，而react优化了真正的执行时机，并且出于本身性能原因，可能会将多次setState的状态修改合并成一次状态修改。因此不要依靠当前的state计算下一个state，因为当真正执行状态修改时，有时候依赖的this.state并不能保证是最新的state，因为react本身会把多次state合并成一次，这时this.state还是旧state，因此也不能依赖当前的props计算下一个状态，因为props的更新也是异步。如：对于react常用的列子中有一个点击加号数值增加一的操作，点击一次+，数量会加1，如果连续点击两次，还是会加1，这是在react合并修改为一次的情况下，相当与执行了如下代码：</p> 
<pre><code>Object.assign(
previousState,
{quantity:this.state.quantity+1},
{quantity:this.state.quantity+1},
)</code></pre> 
<p>于是后面覆盖前面的操作，最终数值只加1，此时可以使用另一个函数作为参数的setState，这个函数有两个参数，第一个参数是本次组件修改前的状态，第二个参数是当前最新的props。</p> 
<p>正确修改方式是：</p> 
<pre><code>this.setState((preState, props)=&gt;counter:preState.quantity+1)</code></pre> 
<blockquote> 
 <strong>state的更新是一个合并的过程</strong> 
</blockquote> 
<p> </p> 
<p>当调用ssetState修改组件的状态时，只需要传入发生改变的state，而不是完整的state，因为组件state的更新时一个合并的过程，列如，一个组件的状态为：</p> 
<pre><code>this.state={

title:'React',

content:'React is an wondeful JS library'

}</code></pre> 
<p>注：当只需要修改title时，将修改的title传给setState即可：</p> 
<p> </p> 
<pre><code>this.setState({title:'ReactJs'});</code></pre> 
<p>react会合并最新的title到原来的状态，同时保留原来状态的content，最终合并state为：</p> 
<pre><code>this.state={
title:'ReactJs,
content:''React is an wondeful Js library
}</code></pre> 
<p> </p> 
<h3>二，state与不可变对象</h3> 
<p>react官方把state当成不可变对象，一方面直接修改this.state,组件并不会重新render；另一方面，state中包含的所有状态都应该是不可变的对象，当state当中的某一个状态发生变化时，应该重新创建这个状态对象，而不是直接修改原来的state状态，那么当状态发生变化时，如何去创建新的状态呢，我们根据状态类型可以分为下面三种情况：</p> 
<p> </p> 
<blockquote> 
 <strong>状态类型为不可变类型（number，string，bool，bull,undefined）</strong> 
</blockquote> 
<p>这种情况最简单，因为状态是不可变类型，所以直接给要修改的状态赋一个新值即可，列如下面我们要修改的count为number型，title（string）,success(bool)三个状态:</p> 
<p> </p> 
<pre><code>this.setState({
count:1,
title:'React',
success:true
})</code></pre> 
<p> </p> 
<blockquote> 
 <strong>状态类型为数组</strong> 
</blockquote> 
<p>假如有一个数组类型的状态books，当想books中增加一本书时，既可使用数组的concat方法或者es6的扩展语法(apread syntax)</p> 
<blockquote>
  方法一：使用preState，concat创建新数组 
</blockquote> 
<p> </p> 
<pre><code> this.setState((preState)=&gt;books:preState.books.concat(['React Guide']))</code></pre> 
<p> </p> 
<blockquote>
  方法二：ES6 spread syntax 
</blockquote> 
<p> </p> 
<pre><code>this.setState(preState=&gt;books:[...preState,''React Guide])</code></pre> 
<p> </p> 
<p>当我们从books中截取部分元素作为新状态时，可以用数组的slice方法：</p> 
<p> </p> 
<pre><code>this.setState(preState=&gt;books:preState.books.slice(1,3))</code></pre> 
<p> </p> 
<p>当从books中过滤部分元素后，作为新状态时，可以使用filter方法:</p> 
<p> </p> 
<pre><code> this.setState(preState =&gt; {
        books: preState.books.filter(item =&gt; {

        return item != 'React';

        })
    })</code></pre> 
<p> </p> 
<p>注意：不要使用push,pop,shift,unshift,splice登方法修改数组类型的状态，因为这些方法都是在原数组的基础上修改的，而concat，slice，filter会返回一个新的数组。</p> 
<p> </p> 
<blockquote>
  方法三：状态的类型是普通对象(不包含：string，array) 
</blockquote> 
<p> </p> 
<p>使用es6的Object.assgin()方法</p> 
<p> </p> 
<pre><code>this.setState({

onwer:Object.assgin({},preState.onwer,{name:'Jason'});

})</code></pre> 
<p> </p> 
<p>使用对象扩展语法（Object spread properties）:</p> 
<pre><code>this.setState(preState=&gt;{
owner:{...preState.owner,name:'Jason'}
})</code></pre> 
<p> </p> 
<p>总结：</p> 
<p>创建新的状态的关键是，避免使用会直接修改原对象的方法而是使用可以返回一个新对象的方法，当然可以使用Immutable的JS库（Immutable.js）实现类似的效果。</p> 
<p> </p> 
<p><strong>思考：</strong></p> 
<p>为什么React推荐组件状态的修改时不可变对象呢？</p> 
<ol><li>不可变对象的修改会返回一个新的对象，不用担心原对象在不小心的情况下修改导致的错误，方便程序的管理和调试</li><li>处于性能的考虑，对象组件的状态是不可变对象时，在组件的shouldComponentUpdate方法中仅需要比较前后两次状态对象的引用就可以判断状态是否真的改变，从而避免不必要的render调用</li></ol> 
<h3><strong>三：除了以上方法修改react组件的状态之外，我们还经常会用到replaceState改变组件的状态</strong></h3> 
<p> </p> 
<p>replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。使用语法：</p> 
<pre><code>replaceState(object nextState,[, function callback])</code></pre> 
<p>nextState，将要设置的新状态，该状态会替换当前的state。</p> 
<p>callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。</p> 
<p>如：</p> 
<pre><code> class App extends React.Component{

     constructor(props);

      this.state={

      count:1

      title:'数字计算'

      }

}

handleClick=()=&gt;{

  this.replaceState({

    count:this.state.count+1

  })

}

render(){
    return(
      &lt;button onClick={this.onClick}&gt;点我&lt;/button&gt;
      )
  }

}</code></pre> 
<p> </p> 
<p>结果为：</p> 
<p> </p> 
<pre><code>{
count：1
}</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/281a889289885397355bc0c531733097/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">获取request里面所有的Parameter所有的请求参数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/096fee44e00bc18e34412a7f0b005ade/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">USART_ClearITPendingBith和 USART_ClearFlag的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>