<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[转]视频捕捉全教程(vc&#43;vfw) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[转]视频捕捉全教程(vc&#43;vfw)" />
<meta property="og:description" content="目 录
一. 视频捕获快速入门 二.基本的捕获设置 １．设置捕获速度： ２．设置终止捕获 ３．捕获的时间限制 三.关于捕获窗口 １.创建一个AVICAP捕获窗口 ２．将一个捕获窗口连接至捕获设备 ３． 父窗口与子窗口的交互 ４．捕获窗口的状态 四.视频捕获驱动和音频驱动 １．视频捕获驱动的性能: ２．视频对话框: ３．PREVIEW 和 OVERLAY模式: ４．视频格式 ５．视频捕获设置 ６．声频格式 五．使用视频捕获 1.创建捕获窗口(CREATING A CAPTURE WINDOW) 2.连接到捕获驱动(CONNECTING TO A CAPTURE DRIVER) 3.列举所有已安装的捕获驱动(ENUMERATING INSTALLED CAPTURE DRIVERS) 4.得到捕获驱动的性能(OBTAINING THE CAPABILITIES OF A CAPTURE DRIVER) 5.得到捕获窗口的状态(OBTAINING THE STATUS OF A CAPTURE WINDOW) 6.显示对话框设置视频特征(DISPLAYING DIALOG BOXES TO SET VIDEO CHARACTERISTICS) 7.得到和设置视频格式(OBTAINING AND SETTING THE VIDEO FORMAT) 8. 预览视频(PREVIEWING VIDEO) 9.将视频设置为OVERLAY模式(ENABLING VIDEO OVERLAY) 10." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e43ce2751a3892daaec6b7b261d688d8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2005-09-21T11:42:00+08:00" />
<meta property="article:modified_time" content="2005-09-21T11:42:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[转]视频捕捉全教程(vc&#43;vfw)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>目 录</p> 
<p>一. 视频捕获快速入门 </p> 
<p>二.基本的捕获设置 </p> 
<p>          １．设置捕获速度： </p> 
<p>          ２．设置终止捕获 </p> 
<p>          ３．捕获的时间限制 </p> 
<p>三.关于捕获窗口 </p> 
<p>          １.创建一个AVICAP捕获窗口 </p> 
<p>          ２．将一个捕获窗口连接至捕获设备 </p> 
<p>          ３． 父窗口与子窗口的交互 </p> 
<p>          ４．捕获窗口的状态 </p> 
<p>四.视频捕获驱动和音频驱动 </p> 
<p>          １．视频捕获驱动的性能: </p> 
<p>          ２．视频对话框: </p> 
<p>          ３．PREVIEW 和 OVERLAY模式: </p> 
<p>          ４．视频格式 </p> 
<p>          ５．视频捕获设置 </p> 
<p>          ６．声频格式 </p> 
<p>五．使用视频捕获 </p> 
<p>        1.创建捕获窗口(CREATING A CAPTURE WINDOW) </p> 
<p>        2.连接到捕获驱动(CONNECTING TO A CAPTURE DRIVER) </p> 
<p>        3.列举所有已安装的捕获驱动(ENUMERATING INSTALLED CAPTURE DRIVERS) </p> 
<p>        4.得到捕获驱动的性能(OBTAINING THE CAPABILITIES OF A CAPTURE DRIVER) </p> 
<p>        5.得到捕获窗口的状态(OBTAINING THE STATUS OF A CAPTURE WINDOW) </p> 
<p>        6.显示对话框设置视频特征(DISPLAYING DIALOG BOXES TO SET VIDEO CHARACTERISTICS) </p> 
<p>        7.得到和设置视频格式(OBTAINING AND SETTING THE VIDEO FORMAT) </p> 
<p>        8. 预览视频(PREVIEWING VIDEO) </p> 
<p>        9.将视频设置为OVERLAY模式(ENABLING VIDEO OVERLAY) </p> 
<p>        10.命名捕获文件(NAMING THE CAPTURE FILE) </p> 
<p>        11.格式化声频捕获(FORMATTING AUDIO CAPTURE) </p> 
<p>        12.改变视频捕获设置(CHANGING A VIDEO CAPTURE SETTING) </p> 
<p>        13.捕获数据(CAPTURING DATA) </p> 
<p>        14.增加一个信息块(ADDING AN INFORMATION CHUNK) </p> 
<p>        15.在程序中加入一个回调函数(ADDING CALLBACK FUNCTIONS TO AN APPLICATION) </p> 
<p>        16.创建一个状态回调函数(CREATING A STATUS CALLBACK FUNCTION) </p> 
<p>        17.创建一个错误回调函数( CREATING AN ERROR CALLBACK FUNCTION) </p> 
<p>        18.创建一个框架回调函数(CREATING A FRAME CALLBACK FUNCTION) </p> 
<p>六．将四个标准对话框改成函数调用形式 </p> 
<p>         AUDIOFORMAT对话框 </p> 
<p>         VIDEOFORMAT对话框 </p> 
<p>         VIDEOSOURCE对话框 </p> 
<p>         VIDEO COMPRESSION对话框 　</p> 
<p>前 言</p> 
<p>         视频捕获是指由专用的视频采集卡捕获声频和视频信息，然后将其进行数据化处理，再经过软件的压缩进行处理，这时就可对这些数据进行保存、回放、传输等各种操作。</p> 
<p>         Windows专门提供了Video for Windows来对视频处理进行支持，提供的接口可以被大多数的视频采集卡支持，并有多种视频压缩驱动供选择（当然视频压缩可以自己开发），采集卡支持摄像头，ＴＶ等多种输入。</p> 
<p><br>一. 视频捕获快速入门</p> 
<p>          视频捕捉将一个视频流和音频流数字化, 然后存储在硬盘或其他存储介质上.</p> 
<p>          一个AVICap视窗口句柄描述了声频与视频流的细节, 这样就使你的应用程序从AVI文件格式, 声频视频缓冲管理, 低层声频视频驱动访问等等解脱出来, AVICap为应用程序提供了一个灵活的介面, 你可以仅仅使用如下几行代码就可以将视频捕捉加入你的程序:</p> 
<p>hWndC = capCreateCaptureWindow ( "My Own Capture Window",</p> 
<p>WS_CHILD | WS_VISIBLE , 0, 0, 160, 120, hwndParent, nID);</p> 
<p>SendMessage (hWndC, WM_CAP_DRIVER_CONNECT, 0 /* wIndex */, 0L);</p> 
<p>SendMessage (hWndC, WM_CAP_SEQUENCE, 0, 0L);</p> 
<p>           一个宏其实也是使用SendMessage, 只不过提供给程序一个更易读的代码而已, 下面的这些示例就是使用宏的方法将视频捕捉加入程序:</p> 
<p>hWndC = capCreateCaptureWindow ( "My Own Capture Window",</p> 
<p>WS_CHILD | WS_VISIBLE , 0, 0, 160, 120, hwndParent, nID);</p> 
<p>capDriverConnect (hWndC, 0);</p> 
<p>capCaptureSequence (hWndC);</p> 
<p><br>          当你创建了一个AVICap类的捕捉窗口并将它连接到一个视频驱动时, 此捕捉窗口即可以开始捕捉数据, 你的程序可以简单的发送WM_CAP_SEQUENCE消息(或者使用capCaptureSequence宏)来开始捕捉.</p> 
<p>          如果是缺省的设置, WM_CAP_SEQUENCE会开始捕捉视频音频流到CAPTURE.AVI文件中, 直到下面的某一事件发生为止:</p> 
<p>用户按下了ESC键或者一个鼠标键</p> 
<p>你的应用程序终止或异常中断捕捉操作</p> 
<p>磁盘已满</p> 
<p><br>              在一个应用程序里, 你可以发送WM_CAP_STOP消息来终止捕捉数据(或者使用capCaptureStop宏), 你也可以发送WM_CAP_ABORT消息(或者使用capCaptureAbort宏)来终止.</p> 
<p><br>二.基本的捕获设置</p> 
<p>          基本的捕获设置包括：设置捕获速度（每秒捕获多少帧），是否同时捕获声频，捕获缓冲，允许最大丢失多少帧，是否使用ＤＯＳ内存，以及用键盘的哪个键或鼠标的哪个键来终止捕获等等。这些基本的设置都可以使用ＣＡＰＴＵＲＥＰＡＲＡＭＳ结构来描述，你可以使用capCaptureGetSetup宏来得到当前的设置，然后改变此结构的成员变量，再使用capCaptureSetSetup宏设置新的设置。</p> 
<p>例如：</p> 
<p>１．设置捕获速度：</p> 
<p>           捕捉速度是指捕捉任务每秒钟捕获的帧数, 你可以发送WM_CAP_GET_SEQUENCE_SETUP消息(或者使用capCaptureGetSetup宏)来得到当前的捕捉速度, 当前的捕捉速度保存在CAPTUREPARAMS结构的dwRequestMicroSecPerFrame成员变量中, 你可以通过设置此变量来改变当前设置, 单位是每毫秒连续的帧数, 你可以发送WM_CAP_SET_SEQUENCE_SETUP消息(或者使用capCaptureSetSetup宏), dwRequestMicroSecPerFrame的值是66667, 相当于每秒15帧.</p> 
<p><br>２．设置终止捕获</p> 
<p>           你可以允许用户按下某键或某组合键或者鼠标的左右键来终止一个捕获任务, 如果是实时的捕获, 则捕获的文件将会被丢弃; 如果是单步捕获, 在终止之前所捕获的内容将会被保存.</p> 
<p>          你可以通过发送WM_CAP_GETQUENCE_SETUP消息(或者使用capCaptureGetSetup宏)来得到当前的设置, 当前的按键设置保存在CAPTUREPARAMS的vKeyAbort成员中, 当前的鼠标设置保存在fAbortLeftMouse和fAbortRightMouse成员中. 你可以设置新的按键或按键组合, 或者鼠标左右键, 当你修改的CAPTUREPARAMS后,应该发送WM_CAP_SET_SEQUENCE_SETUP消息来进行更新(或者使用capCaptureSetSetup宏). 缺省的按键是VK_ESCAPE. 你必须在指定按键之前使用RegisterHotKey函数, 鼠标缺省的值是fAbortLeftMouse和fAbortRightMouse都为TRUE.</p> 
<p><br>３．捕获的时间限制</p> 
<p>           CAPTUREPARAMS结构中的fLimitEnabled指示是否有时间限度, wTimeLimit指示最大的持续时间, 单位为秒.</p> 
<p>          得到fLimitEnabled和wTimeLimit的值可以发送WM_CAP_GET_SEQUENCE_SETUP消息(或使用capCatureGetSetup宏), 当设置了这些成员变量后, 应该发送消息WM_CAP_SET_SEQUENCE_SETUP消息(或capCaptureSetSetup宏)来更新CAPTUREPARAMS结构.</p> 
<p><br>三.关于捕获窗口</p> 
<p>        在捕获之前必须创建一个捕获窗口（capture window），在发送消息或使用宏的过程中都需要使用此窗口。</p> 
<p>１.创建一个AVICap捕获窗口</p> 
<p>        你可以使用capCreateCaptureWindow函数来创建一个AVICap捕获窗口, 此函数将会返回一个句柄, 此句柄以后在发送消息时要用.</p> 
<p>        你可以在一个程序里创建一个或多个捕获窗口, 然后给每一个窗口连接不同的捕获设置.</p> 
<p><br>２．将一个捕获窗口连接至捕获设备</p> 
<p>           你可以动态的在一个捕获窗口与一个捕获设备之前连接或断接, 你可以发送WM_CAP_DRIVER_CONNECT消息来使一个捕获窗口与一个捕获设备连接或关联. 当连接上以后, 你就可以通过捕获窗口向捕获设备发送各种消息.</p> 
<p>        如果你的系统里装有多个捕获设备, 你可以在发送WM_CAP_DRIVER_CONNECT消息时用wParam参数指定使用哪一个, 此参数是登记在SYSTEM.INI文件的[drivers]一节里的列表中的某一项, 0为第一个.</p> 
<p>          你可以使用capGetDriverDescription函数来得到已安装的捕获设备的名称及版本, 这样你的程序就可以列举所有已安装的捕获设备和驱动, 这样用户就可以选择其中的一个来与你的捕获窗口连接.</p> 
<p>         你可以发送WM_CAP_DRIVER_GET_NAME消息(或capDriverGetName宏)来得到连接到捕获窗口的捕获设备的名称, 得到版本发送WM_CAP_DRIVER_GET_VERSION消息(或capDriverGetVersion宏)</p> 
<p>         你可以发送WM_CAP_DRIVER_DISCONNECT消息(或capDriverDisconnect宏)来断接.</p> 
<p><br>３． 父窗口与子窗口的交互</p> 
<p>           一些象WM_PALETTECHANGED和WM_QUERYNEWPALETTE的系统级消息只能发送到顶级窗口或OVERLAPPED窗口, 如果一个捕获窗口是子窗口,就必须通过父窗口转送.</p> 
<p>         同样的, 如果父窗口的尺寸改变了, 它就需要通知捕获窗口, 相反地, 如果捕获窗口的尺寸改变了, 捕获窗口就需要发送消息给父窗口, 一个简单的方法就是始终保持捕获窗口的尺寸与视频流的尺寸一致, 并随时将尺寸的改变通知父窗口.</p> 
<p><br>４．捕获窗口的状态</p> 
<p>          你可以发送WM_CAP_GET_STATUS消息(或capGetStatus宏)来得到当前捕获窗口的状态, 得到的是一个CAPSTATUS结构的拷贝, 它包含图片的尺寸, 卷轴的当前位置, overlay和preview是否已设置.</p> 
<p>        因为CAPSTATUS信息是动态的, 你的程序应该只要捕获的视频流的尺寸或格式可能发生了改变就应该进行刷新(例如: 显示了捕获设备的视频格式以后).</p> 
<p>        改变捕获窗口的尺寸并不影响实际的捕获的视频流的尺寸, 视频捕获设备的格式对话框捕获频流的尺寸.</p> 
<p><br>四.视频捕获驱动和音频驱动</p> 
<p>１．视频捕获驱动的性能:</p> 
<p>          你可以通过发送WM_CAP_DRIVER_GET_CAPS消息(或者capDriverGetCaps宏)来得到当前连接的视频驱动的硬件性能. 得到的信息保存在CAPDRIVERCAPS结构中.</p> 
<p><br>２．视频对话框:</p> 
<p>          每一个视频驱动能够提供四个对话框来控制视频捕获和数字化处理, 定义压缩品质等, 这些对话框都定义在视频捕获驱动中.</p> 
<p>          Video Source对话框用于控制选择视频来源, 此对话框列举了此视频捕获卡连接的所有视频源(典型的例如:SVHS和合成输入), 并提供了改变色调, 对比度, 饱和度. 如果视频驱动支持此对话框, 你就可以显示并更新它, 使用WM_CAP_DLG_VIDEOSOURCE消息(或capDlgVideoSource宏).</p> 
<p>           Video Format对话框定义视频帧的尺寸以及精度, 视频捕获卡的压缩设置. 如果卡支持的话, 可以发送消息WM_CAP_DLG_VIDEOFORMAT消息或(capDlgVideoFormat宏).</p> 
<p>           Video Display对话框控制在视频捕获期间在显示器上的显示, 此控制不会影响视频数字数据, 但是他们可能会影响数字信号的表现形式, 例如: 如果捕获设备支持overlay, 可能允许改变色调和饱和度, 关键色彩 或者overlay队列. 如果卡支持, 你可以发送WM_CAP_DLG_VIDEODISPLAY消息(或者使用capDlgVideoDisplay宏).</p> 
<p>           Video Compression对话框控制压缩品质, 如果卡支持, 发送消息WM_CAP_DLG_VIDEOCOMPRESSION(或capDlgVideoCompression宏).</p> 
<p><br>３．Preview 和 Overlay模式:</p> 
<p>                 一个视频捕获驱动对进入的视频流有两种工作模式: Preview模式和overlay模式, 如果一个捕获驱动能够执行两种方法, 用户可以在其中选择一种.</p> 
<p>               Preview模式把从捕获硬件传来的数据送入系统内存并使用图形设备介面(GDI)将数字化帧显示在捕获窗口内. 应用程序可以在父窗口失去焦点时减缓显示速度, 当重新又得到焦点后加快显示速度, 此种模式要占用大量CPU时间.</p> 
<p>有三种消息控制Preview操作:</p> 
<p>WM_CAP_SET_PREIVEW消息(capPreview宏)允许或禁止preview模式</p> 
<p>WM_CAP_SET_PREVIEWRATE(capPreviewRate宏)当帧在preview模式显示时设置速度.</p> 
<p>WM_CAP_SET_SCALE(capPreviewScale宏)允许或禁止preview视频的缩放比例.</p> 
<p>          当preview和scaling同时使用, 捕获的视频帧将会根据捕获窗口的尺寸自动缩放, 允许preview模式会自动关闭overlay模式.</p> 
<p>                      overlay模式是一个硬件函数它将数据送入捕获缓冲区中因而不占用CPU资源. 你可以发送消息WM_CAP_SET_OVERLAY(或capOverlay宏)给捕获窗口来启用或终止overlay模式, 允许overlay模式会自动禁止preview模式.</p> 
<p>               你同时也可以在preview模式或overlay模式里发送WM_CAP_SET_SCROLL消息(或capSetScrollPos宏)来设置视频帧的客户区卷轴位置.</p> 
<p><br>４．视频格式</p> 
<p>            你可以通过发送WM_CAP_GET_VIDEOFORMAT消息(或capGetVideoFormat和capGetVideoFormatSize宏)来得到视频格式的结构或结构的尺寸. 你可以通过发送CAP_SET_VIDEOFORMAT消息(或capSetVideoFormat宏)来设置视频格式.</p> 
<p><br>５．视频捕获设置</p> 
<p>           CAPTUREPARMS结构包含了对视频捕获流的控制参数, 你可以完成以下这些任务:</p> 
<p>指定帧数</p> 
<p>指定分配多少视频缓冲</p> 
<p>允许或禁止声频捕获</p> 
<p>指定捕获的时间间隔</p> 
<p>指定在捕获的过程中是否使用MCI设置(VCR或者videodisc)</p> 
<p>指定终止流的键盘或鼠标</p> 
<p>specify the type of video averaging applied during capture.</p> 
<p><br>得到:WM_CAP_GET_SEQUENCE_SETUP消息(或capCaptureGetSetup宏)</p> 
<p>设置:WM_CAP_SET_SEQUENCE_SETUP消息(或capCaptureSetSetup宏)</p> 
<p><br>６．声频格式</p> 
<p>               你可以通过发送WM＿CAP＿GET＿AUDIOFORMAT消息（或capGetAudioFormat宏和capGetAudioFormatSize宏）来得到当前捕获音频数据的格式或尺寸格式。缺省的声频格式是：单声道、8位、11kHz PCM。 当你使用WM＿CAP＿GET＿AUDIOFORMAT时，总是使用WAVEFORMATEX结构。</p> 
<p>             设置发送消息WM＿CAP＿SET＿AUDIOFORMAT消息（或capSetAudioFormat宏），可以传送WAVEFORMAT，WAVEFORMATEX，PCMWAVEFORMAT结构指针。</p> 
<p>五．使用视频捕获</p> 
<p>1.创建捕获窗口(Creating a Capture Window)</p> 
<p>hWndC = capCreateCaptureWindow (</p> 
<p>(LPSTR) "My Capture Window", // window name if pop-up</p> 
<p>WS_CHILD | WS_VISIBLE, // window style</p> 
<p>0, 0, 160, 120, // window position and dimensions</p> 
<p>(HWND) hwndParent,</p> 
<p>(int) nID /* child ID */);</p> 
<p><br>2.连接到捕获驱动(Connecting to a Capture Driver)</p> 
<p>           下面的例子是将MSVIDEO驱动连接到句柄为hWndC的捕获窗口, 然后调用capDriverDisconnect宏来断接.</p> 
<p>fOK = SendMessage (hWndC, WM_CAP_DRIVER_CONNECT, 0, 0L);</p> 
<p>//</p> 
<p>// Or, use the macro to connect to the MSVIDEO driver:</p> 
<p>// fOK = capDriverConnect(hWndC, 0);</p> 
<p>//</p> 
<p>// Place code to set up and capture video here.</p> 
<p>//</p> 
<p>capDriverDisconnect (hWndC);</p> 
<p><br>3.列举所有已安装的捕获驱动(Enumerating Installed Capture Drivers)</p> 
<p>           下面的例子使用capGetDriverDescription函数得到已安装的捕获驱动的名称及版本:</p> 
<p>char szDeviceName[80];</p> 
<p>char szDeviceVersion[80];</p> 
<p><br>for (wIndex = 0; wIndex &lt; 10; wIndex++)</p> 
<p>{<!-- --></p> 
<p>if (capGetDriverDescription (wIndex, szDeviceName,</p> 
<p>sizeof (szDeviceName), szDeviceVersion,</p> 
<p>sizeof (szDeviceVersion))</p> 
<p>{<!-- --></p> 
<p>// Append name to list of installed capture drivers</p> 
<p>// and then let the user select a driver to use.</p> 
<p>}</p> 
<p>}</p> 
<p><br>4.得到捕获驱动的性能(Obtaining the Capabilities of a Capture Driver)</p> 
<p>              发送WM_CAP_DRIVER_GET_CAPS消息可以得到捕获驱动的性能,并保存入一个CAPDRIVERCAPS结构.每当程序连接一个新的捕获驱动到一个捕获窗口时, 就应该更新CAPDRIVERCAPS结构. 下面的程序举例说明了如何使用capDriverGetCaps宏来得到捕获驱动的性能:</p> 
<p><br>CAPDRIVERCAPS CapDrvCaps;</p> 
<p>SendMessage (hWndC, WM_CAP_DRIVER_GET_CAPS,</p> 
<p>sizeof (CAPDRIVERCAPS), (LONG) (LPVOID) &amp;CapDrvCaps);</p> 
<p>// Or, use the macro to retrieve the driver capabilities.</p> 
<p>// capDriverGetCaps(hWndC, &amp;CapDrvCaps, sizeof (CAPDRIVERCAPS));</p> 
<p><br>5.得到捕获窗口的状态(Obtaining the Status of a Capture Window)</p> 
<p>                 下面的例子使用SetWindowPos函数使捕获窗口与进来的视频流尺寸保持一致, 视频流的基本信息是使用capGetStatus宏得到的, 保存在CAPSTATUS结构中.</p> 
<p><br>CAPSTATUS CapStatus;</p> 
<p>capGetStatus(hWndC, &amp;CapStatus, sizeof (CAPSTATUS));</p> 
<p>SetWindowPos(hWndC, NULL, 0, 0, CapStatus.uiImageWidth,</p> 
<p>CapStatus.uiImageHeight, SWP_NOZORDER | SWP_NOMOVE);</p> 
<p><br>6.显示对话框设置视频特征(Displaying Dialog Boxes to Set Video Characteristics)</p> 
<p>              每个视频捕获卡一般能提供三个不同的对话框用于控制视频捕获及数字化处理. 下面的例子说明如何显示这些对话框, 在显示这些对话框之前,使用了capDriverGetCaps宏来检查CAPDRIVERCAPS结构, 以检测该卡是否有显示这些对话框:</p> 
<p><br>CAPDRIVERCAPS CapDrvCaps;</p> 
<p>capDriverGetCaps(hWndC, &amp;CapDrvCaps, sizeof (CAPDRIVERCAPS));</p> 
<p><br>// Video source dialog box.</p> 
<p>if (CapDriverCaps.fHasDlgVideoSource)</p> 
<p>capDlgVideoSource(hWndC);</p> 
<p><br>// Video format dialog box.</p> 
<p>if (CapDriverCaps.fHasDlgVideoFormat)</p> 
<p>{<!-- --></p> 
<p>capDlgVideoFormat(hWndC);</p> 
<p>// Are there new image dimensions?</p> 
<p>capGetStatus(hWndC, &amp;CapStatus, sizeof (CAPSTATUS));</p> 
<p>// If so, notify the parent of a size change.</p> 
<p>}</p> 
<p><br>// Video display dialog box.</p> 
<p>if (CapDriverCaps.fHasDlgVideoDisplay)</p> 
<p>capDlgVideoDisplay(hWndC);</p> 
<p><br>7.得到和设置视频格式(Obtaining and Setting the Video Format)</p> 
<p>                   BITMAPINFO结构的长度既适应于标准的也适应于压缩的数据格式, 所有程序必须总是询问此结构的尺寸以便在得到当前的视频格式之前分配内存. 下面的例子就是使用capGetVideoFormatSize宏来得到缓冲区尺寸并调用capGetVideoFormat宏来得到当前的视频格式.</p> 
<p><br>LPBITMAPINFO lpbi;</p> 
<p>DWORD dwSize;</p> 
<p>dwSize = capGetVideoFormatSize(hWndC);</p> 
<p>lpbi = GlobalAllocPtr (GHND, dwSize);</p> 
<p>capGetVideoFormat(hWndC, lpbi, dwSize);</p> 
<p><br>// Access the video format and then free the allocated memory.</p> 
<p><br>              程序可以使用capSetVideoFormat宏(或WM_CAP_SET_VIDEOFORMAT消息)发送一个BITMAPINFO头结构给捕获窗口, 因为视频格式是设备细节, 你的程序应该检查返回值以便确定此格式是否已被接受.</p> 
<p><br>8. 预览视频(Previewing Video)</p> 
<p>             下面的例子使用capPreviewRate宏来设置每66毫秒显示一帧, 并使用capPreview宏将它放置在捕获窗口里.</p> 
<p><br>capPreviewRate(hWndC, 66); // rate, in milliseconds</p> 
<p>capPreview(hWndC, TRUE); // starts preview</p> 
<p>// Preview</p> 
<p>capPreview(hWnd, FALSE); // disables preview</p> 
<p><br>9.将视频设置为overlay模式(Enabling Video Overlay)</p> 
<p>            下面的例子: capDriverGetCaps宏确定此捕获卡是否有overlay功能, 如果有就使用宏来设置它</p> 
<p><br>CAPDRIVERCAPS CapDrvCaps;</p> 
<p>capDriverGetCaps(hWndC, &amp;CapDrvCaps, sizeof (CAPDRIVERCAPS));</p> 
<p><br>if (CapDrvCaps.fHasOverlay)</p> 
<p>capOverlay(hWndC, TRUE);</p> 
<p><br>10.命名捕获文件(Naming the Capture File)</p> 
<p>             下面的例子: 使用capFileSetCaptureFile宏来指定预备文件名为:MYCAP.AVI, capFileAlloc宏预先指定它的大小为5M.</p> 
<p><br>char szCaptureFile[] = "MYCAP.AVI";</p> 
<p>capFileSetCaptureFile( hWndC, szCaptureFile);</p> 
<p>capFileAlloc( hWndC, (1024L * 1024L * 5));</p> 
<p><br>11.格式化声频捕获(Formatting Audio Capture)</p> 
<p>             下面的例子使用capSetAudioFormat来设置声频格式为:11kHz, PCM 8位, 立体声</p> 
<p><br>WAVEFORMATEX wfex;</p> 
<p>wfex.wFormatTag = WAVE_FORMAT_PCM;</p> 
<p>wfex.nChannels = 2; // Use stereo</p> 
<p>wfex.nSamplesPerSec = 11025;</p> 
<p>wfex.nAvgBytesPerSec = 22050;</p> 
<p>wfex.nBlockAlign = 2;</p> 
<p>wfex.wBitsPerSample = 8;</p> 
<p>wfex.cbSize = 0;</p> 
<p><br>capSetAudioFormat(hWndC, &amp;wfex, sizeof(WAVEFORMATEX));</p> 
<p><br>12.改变视频捕获设置(Changing a Video Capture Setting)</p> 
<p>               下面的例子使用capCaptureGetSetup和capCaptureSetSetup宏得将捕获帧数从缺省的15帧改成每秒10帧.</p> 
<p><br>CAPTUREPARMS CaptureParms;</p> 
<p>float FramesPerSec = 10.0;</p> 
<p><br>capCaptureGetSetup(hWndC, &amp;CaptureParms, sizeof(CAPTUREPARMS));</p> 
<p><br>CaptureParms.dwRequestMicroSecPerFrame = (DWORD) (1.0e6 /FramesPerSec);</p> 
<p>capCaptureSetSetup(hWndC, &amp;CaptureParms, sizeof (CAPTUREPARMS));</p> 
<p><br>13.捕获数据(Capturing Data)</p> 
<p>                下面的例子使用capCaptureSequence宏来开始捕获视频并使用capFileSaveAs宏来将捕获的数据拷贝至NEWFILE.AVI文件中.</p> 
<p><br>char szNewName[] = "NEWFILE.AVI";</p> 
<p>// Set up the capture operation.</p> 
<p>capCaptureSequence(hWndC);</p> 
<p>// Capture.</p> 
<p>capFileSaveAs(hWndC, szNewName);</p> 
<p><br>14.增加一个信息块(Adding an Information Chunk)</p> 
<p>               如果你需要在你的程序捕获的声频和视频数据中加入你的其他信息, 你可以创建一个信息块并将它们插入捕获文件中, 信息块可以包含一些典型的信息, 例如:版权信息,视频来源, 外部定位信息等. 下面的例子使用capFileSetInfoChunk宏来插入一个信息块, 里面包含了一个SMPTE的时间代码.</p> 
<p><br>// This example assumes the application controls</p> 
<p>// the video source for preroll and postroll.</p> 
<p>CAPINFOCHUNK cic;</p> 
<p>// .</p> 
<p>// .</p> 
<p>// .</p> 
<p>cic.fccInfoID = infotypeSMPTE_TIME;</p> 
<p>cic.lpData = "00:20:30:12";</p> 
<p>cic.cbData = strlen (cic.lpData) + 1;</p> 
<p>capFileSetInfoChunk (hwndC, &amp;cic);</p> 
<p><br>15.在程序中加入一个回调函数(Adding Callback Functions to an Application)</p> 
<p>               一个程序可以为捕获窗口登记一个回调函数以便在以下的这些情况下通知程序.</p> 
<p><br>状态改变</p> 
<p>错误发生</p> 
<p>视频框架和声频缓冲区变得可用</p> 
<p>程序应用在捕获视频流的过程中接收</p> 
<p><br>           下面的例子创建一个捕获窗口并登记状态,错误,视频流和框架回调函数在消息处理对列中, 也包括了一个终止回调函数的说明.</p> 
<p><br>case WM_CREATE:</p> 
<p>{<!-- --></p> 
<p>char achDeviceName[80] </p> 
<p>char achDeviceVersion[100] </p> 
<p>char achBuffer[100] </p> 
<p>WORD wDriverCount = 0 </p> 
<p>WORD wIndex </p> 
<p>WORD wError </p> 
<p>HMENU hMenu </p> 
<p><br>// Create a capture window using the capCreateCaptureWindow macro.</p> 
<p>ghWndCap = capCreateCaptureWindow((LPSTR)"Capture Window",</p> 
<p>WS_CHILD | WS_VISIBLE, 0, 0, 160, 120, (HWND) hWnd, (int) 0);</p> 
<p><br>// Register the error callback function using the</p> 
<p>// capSetCallbackOnError macro.</p> 
<p>capSetCallbackOnError(ghWndCap, fpErrorCallback);</p> 
<p><br>// Register the status callback function using the</p> 
<p>// capSetCallbackOnStatus macro.</p> 
<p>capSetCallbackOnStatus(ghWndCap, fpStatusCallback);</p> 
<p><br>// Register the video-stream callback function using the</p> 
<p>// capSetCallbackOnVideoStream macro.</p> 
<p>capSetCallbackOnVideoStream(ghWndCap, fpVideoCallback);</p> 
<p><br>// Register the frame callback function using the</p> 
<p>// capSetCallbackOnFrame macro.</p> 
<p>capSetCallbackOnFrame(ghWndCap, fpFrameCallback);</p> 
<p><br>// Connect to a capture driver</p> 
<p><br>break;</p> 
<p>}</p> 
<p>case WM_CLOSE:</p> 
<p>{<!-- --></p> 
<p>// Use the capSetCallbackOnFrame macro to</p> 
<p>// disable the frame callback. Similar calls exist for the other</p> 
<p>// callback functions.</p> 
<p><br>capSetCallbackOnFrame(hWndC, NULL);</p> 
<p><br>break;</p> 
<p>}</p> 
<p><br>16.创建一个状态回调函数(Creating a Status Callback Function)</p> 
<p>            下面的例子是创建一个简单的状态回调函数,登记此回调函数使用capSetCallbackOnStatus宏.</p> 
<p><br>// StatusCallbackProc: status callback function</p> 
<p>// hWnd: capture window handle</p> 
<p>// nID: status code for the current status</p> 
<p>// lpStatusText: status text string for the current status</p> 
<p>//</p> 
<p>LRESULT PASCAL StatusCallbackProc(HWND hWnd, int nID,</p> 
<p>LPSTR lpStatusText)</p> 
<p>{<!-- --></p> 
<p>if (!ghWndMain)</p> 
<p>return FALSE;</p> 
<p><br>if (nID == 0) { // Clear old status messages.</p> 
<p>SetWindowText(ghWndMain, (LPSTR) gachAppName);</p> 
<p>return (LRESULT) TRUE;</p> 
<p>}</p> 
<p>// Show the status ID and status text...</p> 
<p>wsprintf(gachBuffer, "Status# %d: %s", nID, lpStatusText);</p> 
<p><br>SetWindowText(ghWndMain, (LPSTR)gachBuffer);</p> 
<p>return (LRESULT) TRUE;</p> 
<p>}</p> 
<p><br>17.创建一个错误回调函数( Creating an Error Callback Function)</p> 
<p>             下面的例子是创建一个简单的错误回调函数,登记此回调函数使用capsetCallbackOnError宏:</p> 
<p><br>// ErrorCallbackProc: error callback function</p> 
<p>// hWnd: capture window handle</p> 
<p>// nErrID: error code for the encountered error</p> 
<p>// lpErrorText: error text string for the encountered error</p> 
<p>//</p> 
<p>LRESULT PASCAL ErrorCallbackProc(HWND hWnd, int nErrID,</p> 
<p>LPSTR lpErrorText)</p> 
<p>{<!-- --></p> 
<p>if (!ghWndMain)</p> 
<p>return FALSE;</p> 
<p><br>if (nErrID == 0) // Starting a new major function.</p> 
<p>return TRUE; // Clear out old errors.</p> 
<p><br>// Show the error identifier and text.</p> 
<p>wsprintf(gachBuffer, "Error# %d", nErrID);</p> 
<p><br>MessageBox(hWnd, lpErrorText, gachBuffer,</p> 
<p>MB_OK | MB_ICONEXCLAMATION);</p> 
<p><br>return (LRESULT) TRUE;</p> 
<p>}</p> 
<p><br>18.创建一个框架回调函数(Creating a Frame Callback Function)</p> 
<p>              登记此回调函数使用capSetCallbackOnFrame宏:</p> 
<p><br>// FrameCallbackProc: frame callback function</p> 
<p>// hWnd: capture window handle</p> 
<p>// lpVHdr: pointer to struct containing captured</p> 
<p>// frame information</p> 
<p>//</p> 
<p>LRESULT PASCAL FrameCallbackProc(HWND hWnd, LPVIDEOHDR lpVHdr)</p> 
<p>{<!-- --></p> 
<p>if (!ghWndMain)</p> 
<p>return FALSE;</p> 
<p><br>wsprintf(gachBuffer, "Preview frame# %ld ", gdwFrameNum++);</p> 
<p>SetWindowText(ghWndMain, (LPSTR)gachBuffer);</p> 
<p>return (LRESULT) TRUE </p> 
<p>}</p> 
<p><br>　</p> 
<p>六．将四个标准对话框改成函数调用形式</p> 
<p>              系统提供了四个标准的对话框：AudioFormat, VideoFormat, VideoSource, Video Compression，但有时程序希望通过函数控制它们，而不是使用系统提供的那个单一的对话框，此时就应该使用函数调用的方法：</p> 
<p><br>AudioFormat对话框</p> 
<p>            可以通过使用capSetAudioFormat来实现，此时要使用WAVEFORMATEX结构。</p> 
<p>例如：改成ＰＣＭ格式，立体声，１６声道，12.05kHz，则：</p> 
<p>WAVEFORMATEX audioFormat;</p> 
<p>// 确定宽度</p> 
<p>acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT,&amp;dwSize);</p> 
<p>dwSize = max (dwSize, capGetAudioFormatSize (m_hwCapCapturing));</p> 
<p>// 设置参数</p> 
<p>audioFormat.wFormatTag = WAVE_FORMAT_PCM;</p> 
<p>audioFormat.nChannels = 2;</p> 
<p>audioFormat.nSamplesPerSec = 120500;</p> 
<p>audioFormat.wBitsPerSample =16;</p> 
<p>audioFormat.nBlockAlign = nBitsPerSample * nChannels / 8;</p> 
<p>audioFormat.nAvgBytesPerSec =</p> 
<p>audioFormat.nBlockAlign * nSamplesPerSec;</p> 
<p>// 更新</p> 
<p>capSetAudioFormat(ghCapWnd,&amp;audioFormat,dwSize);</p> 
<p>VideoFormat对话框</p> 
<p>                  可以通过使用capSetVideoFormat来实现，此时要使用BITMAPINFOHEADER结构。</p> 
<p>例如：设置图片大小为ＲＧＢ２４位岁，大小为２３０Ｘ１６０</p> 
<p>BITMAPINFOHEADER bi;</p> 
<p>DWORD dwSize,dw;</p> 
<p>bi.biSize = sizeof(BITMAPINFOHEADER);</p> 
<p>bi.biWidth = 320; // 起作用</p> 
<p>bi.biHeight = 160; // 起作用</p> 
<p>bi.biPlanes = 1;</p> 
<p>bi.biBitCount = 24;</p> 
<p>bi.biCompression = BI_RGB;</p> 
<p>bi.biSizeImage = 0;</p> 
<p>bi.biXPelsPerMeter = 176;</p> 
<p>bi.biYPelsPerMeter = 144;</p> 
<p>bi.biClrUsed = 0;</p> 
<p>bi.biClrImportant = 0;</p> 
<p>dwSize = bi.biSize + ((bi.biBitCount &gt; 8 || bi.biClrUsed) ? (bi.biClrUsed * sizeof(PALETTEENTRY)) : (2 ^ bi.biBitCount * sizeof(PALETTEENTRY)));</p> 
<p>dw = capSetVideoFormat(m_hwCapCapturing, &amp;bi, dwSize);</p> 
<p>VideoSource对话框</p> 
<p>                没有找到现成的方法，但视频捕获卡提供的ＣＤ里面有一个动态链接库可以实现。</p> 
<p>Video Compression对话框</p> 
<p>             可以通过使用ICOpen,ICInfo等函数联合起来，得到当前系统里面的视频压缩驱动的列表，并可选择其一，ＭＳＤＮ里面有一个程序示范了此用户，程序名叫：ICWalk。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1aa6167e46e4145ae2dcaacbb76f8992/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据更新,记录数据更新情况,数据操作前后变化情况</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e66b90f628516a8f019c2477ed80ff3f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">正则表达式,网上资料收集整理!</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>