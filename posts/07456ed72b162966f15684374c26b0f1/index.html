<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>NumPy教程（二）—— 数据存储及各种常用方法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="NumPy教程（二）—— 数据存储及各种常用方法" />
<meta property="og:description" content="1.文件输入和输出 1.1 CSV文件的存取 csv文件的读取（读） 语法：np.loadtxt（frame，dtype=np.float，delimiter=None，unpack=False）
参数： frame：文件、字符串或产生器的名字，可以是.gz或.bz2的压缩文件
dtype：导入时需要将csv文件中的元素由字符串指定为一个固定格式
delimiter：分割字符串，默认是空格（存储CSV文件，要改为逗号）
unpack：读入的属性是否写入不同变量（默认False，写入同一个变量）
将数据写入文件（存） 语法：np.savetxt（frame，array，fmt = ‘%.18e’，delimiter = None）
参数： array：要存入文件的数组
fmt：写入文件时每个元素使用的格式（默认科学计数法保留18位小数） %d：整数
import numpy as np a = np.arange(100).reshape(5,20) np.savetxt(&#39;a.csv&#39;, a, fmt=&#34;%d&#34;, delimiter=&#34;,&#34;) #存储 b = np.loadtxt(&#39;a.csv&#39;,delimiter=&#34;,&#34;) #读取 print(b) 1.2 numpy的便捷文件存取 numpy可以在硬盘中将数据以文本或二进制的形式进行存入硬盘或由硬盘载入
下述函数是numpy高效存取硬盘数据的工具函数
函数描述np.save（frame，array） 将数组存储到文件中
但必须以.npy为文件名
np.savez（frame，a=arr1, b=arr2） 将多个数组保存到一个文件中
必须以.npz为文件名
数组以类似键值对形式传入
导入时，会得到一个类似字典的对象
np.savez_compressed
（frame，a=arr1, b=arr2）
将多个对象存入压缩文件中np.load（frame）读取 .npy 或 .npz 格式的数据 import numpy as np a = np.random.randn(5,5) b = np.random.randn(3,3) np.save(&#34;a.npy&#34;,a) np." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/07456ed72b162966f15684374c26b0f1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-25T22:22:19+08:00" />
<meta property="article:modified_time" content="2023-12-25T22:22:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">NumPy教程（二）—— 数据存储及各种常用方法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.文件输入和输出</h2> 
<h4> 1.1 CSV文件的存取</h4> 
<ul><li><strong>csv文件的读取（读）</strong></li></ul> 
<p>      <span style="color:#0d0016;"> 语法：</span><span style="background-color:#f9eda6;">np.loadtxt（frame，dtype=np.float，delimiter=None，unpack=False）</span></p> 
<p>       <span style="color:#0d0016;">参数</span>： <span style="color:#0d0016;">   </span>frame：文件、字符串或产生器的名字，可以是.gz或.bz2的压缩文件</p> 
<p>                      dtype：导入时需要将csv文件中的元素由字符串指定为一个固定格式</p> 
<p>                      delimiter：分割字符串，默认是空格（存储CSV文件，要改为逗号）</p> 
<p>                      unpack：读入的属性是否写入不同变量（默认False，写入同一个变量）</p> 
<p>                    </p> 
<ul><li><strong>将数据写入文件（存）</strong></li></ul> 
<p>       <span style="color:#0d0016;">语法：</span><span style="background-color:#f9eda6;">np.savetxt（frame，array，fmt = ‘%.18e’，delimiter = None）</span></p> 
<p>     <span style="color:#0d0016;">  参数：   </span> array：要存入文件的数组</p> 
<p>                       fmt：写入文件时每个元素使用的格式（默认科学计数法保留18位小数） %d：整数</p> 
<pre><code class="language-python">import numpy as np
a = np.arange(100).reshape(5,20)
np.savetxt('a.csv', a, fmt="%d", delimiter=",")  #存储

b = np.loadtxt('a.csv',delimiter=",")  #读取
print(b)</code></pre> 
<p>                                               </p> 
<p></p> 
<h4> 1.2 numpy的便捷文件存取</h4> 
<p>      numpy可以在硬盘中将数据以文本或二进制的形式进行存入硬盘或由硬盘载入</p> 
<p>      下述函数是numpy高效存取硬盘数据的工具函数</p> 
<table border="2" cellpadding="1" cellspacing="1" style="width:600px;"><thead><tr><th style="width:273px;">函数</th><th style="width:325px;">描述</th></tr></thead><tbody><tr><td style="width:273px;">np.save（frame，array）</td><td style="width:325px;"> <p>将数组存储到文件中</p> <p>但必须以<span style="background-color:#c7e6ea;">.npy</span>为文件名</p> </td></tr><tr><td style="width:273px;">np.savez（frame，a=arr1,  b=arr2）</td><td style="width:325px;"> <p></p> <p>将<span style="background-color:#c7e6ea;">多个数组</span>保存到一个文件中</p> <p>必须以<span style="background-color:#c7e6ea;">.npz</span>为文件名</p> <p>数组以类似键值对形式传入</p> <p>导入时，会得到一个类似字典的对象</p> <p></p> </td></tr><tr><td style="width:273px;"> <p>np.savez_compressed</p> <p>（frame，a=arr1,  b=arr2）</p> </td><td style="width:325px;">将多个对象存入压缩文件中</td></tr><tr><td style="width:273px;">np.load（frame）</td><td style="width:325px;">读取 .npy 或 .npz 格式的数据</td></tr></tbody></table> 
<pre><code class="language-python">import numpy as np
a = np.random.randn(5,5)
b = np.random.randn(3,3)

np.save("a.npy",a)
np.savez("ab.npz",a=a,b=b)

load = np.load("ab.npz")
print(load["a"]) #文件的读取 类似字典</code></pre> 
<h2></h2> 
<p></p> 
<p></p> 
<h2>2.利用数组做数据处理的各种方法</h2> 
<h4> 2.1 数组代替循环</h4> 
<p> Numpy数组可以用数组表达式去代替循环，这种方法称作矢量化。它可以大大提升循环速度</p> 
<ul><li>案例一：计算  sqrt(x^2+y^2)</li></ul> 
<p>        np.meshgrid函数：接收两个一维数组，分别复制成两个二维数组</p> 
<pre><code class="language-python">import numpy as np
data1 = np.arange(-5,5,0.1)
data2 = np.arange(-10,0,0.1) #生成两个一维数组
x,y = np.meshgrid(data1,data2) #复制成二维数组
print(x)
z = np.sqrt(x**2 + y**2)
z = np.rint(z) #取整
print(z)</code></pre> 
<p></p> 
<ul><li>案例二：将条件逻辑表述为数组</li></ul> 
<p>    <span style="background-color:#f9eda6;">   np.where（condition，xarr，yarr）</span>：等价于列表推导式 <span style="background-color:#f9eda6;">x if condition else y </span>                 </p> 
<p>                    当condition（布尔类型）的值为Ture时，选取xarr的值，反之选取yarr的值   </p> 
<pre><code class="language-python"># 案例：将arr中所有小于0的数替换为0
import numpy as np
arr = np.random.randn(4,4)
arrxin = np.where(arr&lt;0,0,arr)
print(arrxin)</code></pre> 
<p>                   </p> 
<ul><li>案例三：通过广播将一维数组设置到高维数组的列中</li></ul> 
<p> <span style="background-color:#f9eda6;">np.newaxis：插入新维度，将一维数组变成二维数组，二维变成三维</span></p> 
<pre><code class="language-python"># np.newaxis的用法
import numpy as np
x = np.arange(4) # [0 1 2 3]

print(x[np.newaxis,:]) # 插入行 [[0 1 2 3]]
print(x[:,np.newaxis]) # 插入列 [[0]
                       #        [1]
                       #        [2]
                       #        [3]]

# 案例
import numpy as np
old = np.array([1,2,3,4],dtype=int)
new = np.zeros((4,3),dtype=int)

new[:] = old[:,np.newaxis] # 插入列，再利用广播原则
print(new)</code></pre> 
<p>                           </p> 
<p>                  </p> 
<h4> 2.2 数学和统计方法</h4> 
<p>下述函数的调用方式全部为<strong> <span style="background-color:#fbd4d0;">np.函数名（arr）</span></strong><span style="background-color:#fbd4d0;">或者</span><strong><span style="background-color:#fbd4d0;">  arr.函数名（）</span></strong></p> 
<table border="2" cellpadding="1" cellspacing="1" style="width:600px;"><thead><tr><th style="background-color:#aaaaaa;width:124px;">函数</th><th style="background-color:#aaaaaa;width:220px;">说明</th><th style="background-color:#aaaaaa;width:254px;">备注</th></tr></thead><tbody><tr><td style="width:124px;"> <p>sum、mean、</p> <p>median</p> </td><td style="width:220px;"> <p>沿轴向计算累计和、均值、</p> <p>中位数</p> </td><td colspan="1" rowspan="4" style="width:254px;"> <p>可以接受一个可选参数<span style="background-color:#c7e6ea;">axis</span></p> <p>例如 arr.mean（axis = 1）</p> <p>用于<span style="background-color:#c7e6ea;">计算给定轴向上的统计值</span></p> <p>形成一个下降一维度的数组</p> </td></tr><tr><td style="background-color:#cccccc;width:124px;"> <p>std、var</p> </td><td style="background-color:#cccccc;width:220px;">标准差和方差</td></tr><tr><td style="background-color:#ffffff;width:124px;">min、max</td><td style="background-color:#ffffff;width:220px;">最小值和最大值</td></tr><tr><td style="background-color:#cccccc;width:124px;"><span style="background-color:#fbd4d0;">argmin、argmax</span></td><td style="background-color:#cccccc;width:220px;"><span style="background-color:#c7e6ea;">最小值和最大值的位置</span></td></tr><tr><td style="background-color:#ffffff;width:124px;">cumsum</td><td style="background-color:#ffffff;width:220px;">从位置0开始 写元素累计和</td><td colspan="1" rowspan="2" style="width:254px;"> <p></p> <p>不返回值，而是返回一个相同长度的数组，写出累计求和/积的<span style="background-color:#c7e6ea;">中间结果</span></p> <p>例如：[ 1,2,3 ]  一&gt; 累计和 [ 1,3,6 ]</p> <p></p> <p>多维则可指定axis，在轴向上分别计算</p> </td></tr><tr><td style="background-color:#cccccc;width:124px;">cumprod</td><td style="background-color:#cccccc;width:220px;">从位置1开始 写元素累计积</td></tr></tbody></table> 
<h4>                                                                   </h4> 
<p></p> 
<h4> 2.3 用于排序以及布尔数组的方法</h4> 
<table border="2" cellpadding="1" cellspacing="1" style="width:600px;"><thead><tr><th style="background-color:#bbbbbb;width:126px;">函数</th><th style="background-color:#bbbbbb;width:338px;">说明</th><th style="background-color:#bbbbbb;width:134px;">备注</th></tr></thead><tbody><tr><td style="width:126px;"><span style="background-color:#fbd4d0;">arr.sort（axis=）</span></td><td style="width:338px;">按值的大小排序（升序）</td><td style="width:134px;">多维可指定axis，在轴向上分别排序</td></tr><tr><td style="width:126px;"><span style="background-color:#fbd4d0;">sum</span></td><td style="width:338px;"> <p>在2.2的方法中，布尔值会被转化为1和0；</p> <p>因此我们可以用<span style="background-color:#c7e6ea;">sum对布尔型数组中的True值计数</span></p> </td><td style="width:134px;"></td></tr><tr><td style="width:126px;">arr.any（）</td><td style="width:338px;">测试数组中是否存在一个或多个True</td><td colspan="1" rowspan="2" style="width:134px;">返回布尔类型值</td></tr><tr><td style="width:126px;">arr.all（）</td><td style="width:338px;">测试数组中是否所有值都是True</td></tr></tbody></table> 
<p></p> 
<h4> 2.4 集合运算方法 </h4> 
<table border="2" cellpadding="1" cellspacing="1" style="width:600px;"><thead><tr><th style="background-color:#aaaaaa;">函数</th><th style="background-color:#aaaaaa;">说明</th></tr></thead><tbody><tr><td><span style="background-color:#fbd4d0;">unique（x）</span></td><td> <p>计算x的唯一值，并返回已排序的结果</p> <p>相当于重复的值只保留一个</p> </td></tr><tr><td style="background-color:#cccccc;">intersect1d（x，y）</td><td style="background-color:#cccccc;">计算交集，并排序</td></tr><tr><td>union1d（x，y）</td><td>计算并集，并排序</td></tr><tr><td style="background-color:#cccccc;">in1d（x，y）</td><td style="background-color:#cccccc;"> <p>计算x中的元素是否包含在y中，返回一个bool值数组</p> </td></tr><tr><td>setdiff1d（x，y）</td><td>差集，在x中，但不在y中的 x的元素</td></tr><tr><td style="background-color:#cccccc;">setxor1d（x，y）</td><td style="background-color:#cccccc;">异或集，在x或y中，但不属于二者交集的元素</td></tr></tbody></table> 
<p></p> 
<p></p> 
<p></p> 
<h2>3.线性代数函数</h2> 
<p>    为了应对矩阵运算，numpy.linalg提供了一些用于矩阵分解、求逆...之类的函数</p> 
<p>使用之前应先导入相应函数：<strong><span style="background-color:#fbd4d0;">from  numpy.linalg  import  函数名</span></strong></p> 
<table border="2" cellpadding="1" cellspacing="1" style="width:600px;"><thead><tr><th style="background-color:#bbbbbb;width:134px;">函数</th><th style="background-color:#bbbbbb;width:306px;">说明</th><th style="background-color:#bbbbbb;width:158px;">备注</th></tr></thead><tbody><tr><td style="width:134px;">diag（x）</td><td style="width:306px;"> <p>将方阵的<span style="background-color:#c7e6ea;">对角线元素</span>以一维数组形式返回；</p> <p>或将一维数组转化为方阵</p> </td><td style="width:158px;"></td></tr><tr><td style="background-color:#cccccc;width:134px;"> <p>x.dot（y）</p> </td><td style="background-color:#cccccc;width:306px;">矩阵<span style="background-color:#c7e6ea;">乘法</span></td><td style="background-color:#cccccc;width:158px;">@也可用作矩阵乘法运算符  如：X@Y</td></tr><tr><td style="background-color:#ffffff;width:134px;">trace（x）</td><td style="background-color:#ffffff;width:306px;">求<span style="background-color:#c7e6ea;">迹</span> ：对角线元素之和</td><td style="background-color:#ffffff;width:158px;"></td></tr><tr><td style="background-color:#cccccc;width:134px;">det（x）</td><td style="background-color:#cccccc;width:306px;">计算矩阵对应的<span style="background-color:#c7e6ea;">行列式</span></td><td style="background-color:#cccccc;width:158px;"></td></tr><tr><td style="background-color:#ffffff;width:134px;">eig（x）</td><td style="background-color:#ffffff;width:306px;"> <p>计算方阵<span style="background-color:#c7e6ea;">特征值和特征向量</span></p> <p>返回一个一维数组和一个多维数组</p> </td><td style="background-color:#ffffff;width:158px;"></td></tr><tr><td style="background-color:#cccccc;width:134px;">inv（x）</td><td style="background-color:#cccccc;width:306px;">计算方阵的<span style="background-color:#c7e6ea;">逆</span></td><td style="background-color:#cccccc;width:158px;">也可直接写 X.T</td></tr><tr><td style="background-color:#ffffff;width:134px;">pinv（x）</td><td style="background-color:#ffffff;width:306px;">计算矩阵的Moore-Penrose伪逆</td><td style="background-color:#ffffff;width:158px;"></td></tr><tr><td style="background-color:#cccccc;width:134px;">qr（x）</td><td style="background-color:#cccccc;width:306px;">计算QR分解，返回俩个数组</td><td style="background-color:#cccccc;width:158px;"></td></tr><tr><td style="background-color:#ffffff;width:134px;">svd（x）</td><td style="background-color:#ffffff;width:306px;">计算奇异值分解（SVD）</td><td style="background-color:#ffffff;width:158px;"></td></tr><tr><td style="background-color:#cccccc;width:134px;">solve（A，b）</td><td style="background-color:#cccccc;width:306px;">求解线性方程组 Ax=b ，其中A为一个方阵</td><td style="background-color:#cccccc;width:158px;"></td></tr><tr><td style="background-color:#cccccc;width:134px;">lstsq（A，b）</td><td style="background-color:#cccccc;width:306px;">计算 Ax=b 的最小二乘解</td><td style="background-color:#cccccc;width:158px;"></td></tr></tbody></table> 
<p></p> 
<p></p> 
<p></p> 
<h2>4.伪随机数生成</h2> 
<p>   <span style="background-color:#f9eda6;">伪随机数</span>是指<strong>由计算机算法生成的随机数</strong>，之所以称做伪随机是因为计算机  中的随机函数是按照一定算法模拟产生的，其结果是确定的，是可见的。</p> 
<p>   而真随机是真正随机的数，如人群身高、重复抛硬币等</p> 
<p></p> 
<h4> 4.1 seed设置随机数种子</h4> 
<p>      我们可以通过<span style="background-color:#f9eda6;"> np.random.seed（任意数字）</span>来设置一个随机数种子，这样可以保证我们每次调用这个文件，里面的随机数输出都是一样的</p> 
<p>      如果什么都不输入，则默认为系统时间</p> 
<p></p> 
<ul><li><strong>注意事项</strong></li></ul> 
<p>   <strong>   1）</strong>设置种子后，是<span style="background-color:#f9eda6;">每次运行</span><code><span style="background-color:#f9eda6;">.py</span></code><span style="background-color:#f9eda6;">文件的输出结果</span>都一样，而不是每次随机函数生成的结果一样，如下，我们可见a b两次调用random结果不同，但如果再次运行这个文件，结果还是这两个数</p> 
<pre><code class="language-python">import numpy as np
np.random.seed(123)
a = np.random.random()
b = np.random.random()
print(a,b)  # 输出结果为：0.6964691855978616
            #           0.28613933495037946         </code></pre> 
<p>           </p> 
<p>   <strong>    2）</strong>如果想a b两次调用结果都相同，需要在b之前再次设置相同的随机数种子，这是因为种子只会跟第一个碰到的生成器绑定</p> 
<pre><code class="language-python">import numpy as np
np.random.seed(123)
a = np.random.random()
np.random.seed(123)
b = np.random.random()
print(a,b)  # 输出结果为：0.6964691855978616
            #           0.6964691855978616</code></pre> 
<p><strong>       </strong></p> 
<p><strong>        3）</strong>如果设置了随机种子，那么它的<span style="background-color:#f9eda6;">作用域将是全局</span>，也就是之后的每一次random都会受他影响，输出一样的数据，如果想取消他的全局影响在后面的生成器采用随机输出，有两种方案</p> 
<p>       方案一：直接在后续的生成器之前都加上 np.random.seed（）</p> 
<p>                       原理是 默认填入系统时间，这样每次操作种子数就都不同，就会重新随机</p> 
<pre><code class="language-python">import numpy as np
np.random.seed(123)
a = np.random.random()
np.random.seed()
b = np.random.random()
print(a,b)  # 输出结果为：0.6964691855978616
            #           不固定</code></pre> 
<p>        方案二：使用 numpy.random.RandomState生成一个随机数生成器，使其独立于其他随机数</p> 
<pre><code class="language-python">import numpy as np
rng = np.random.RandomState(123)
a = rng.random() #若后续仍要调用，必须使用rng这个前缀

b = np.random.random() #其他的随机数

c =rng.random()  #再次调用这个随机数生成器

rng = np.random.RandomState(123) #再次调用这个随机数生成器种子
d = rng.random()

print(a,b,c,d)  # 输出结果为：0.6964691855978616
              #            不固定
              #            0.28613933495037946
              #            0.6964691855978616</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<h4> 4.2 随机数函数</h4> 
<p>下述函数的调用方式全部为<strong> <span style="background-color:#fbd4d0;">np.random.函数名（）</span></strong></p> 
<p>某些函数使用前需要先导入：<span style="background-color:#fbd4d0;"> from  random  import  函数名</span></p> 
<table border="2" cellpadding="1" cellspacing="1" style="width:600px;"><thead><tr><th style="background-color:#aaaaaa;width:217px;">函数</th><th style="background-color:#aaaaaa;width:381px;">说明</th></tr><tr><th style="background-color:#ffffff;width:217px;"></th><th style="background-color:#ffffff;width:381px;"></th></tr></thead><tbody><tr><td style="background-color:#cccccc;width:217px;">rand（size）</td><td style="background-color:#cccccc;width:381px;">根据size生成<span style="background-color:#c7e6ea;"> [ 0,1 ] 均匀分布</span>随机数 数组</td></tr><tr><td style="background-color:#cccccc;width:217px;">randn（size）</td><td style="background-color:#cccccc;width:381px;">根据size生成 <span style="background-color:#c7e6ea;">标准正态分布</span>随机数 数组</td></tr><tr><td style="background-color:#cccccc;width:217px;">randint（low，high，shape）</td><td style="background-color:#cccccc;width:381px;"> <p></p> <p>根据 shape生成<span style="background-color:#c7e6ea;"> [ low , high ) 之间的随机</span><strong><span style="background-color:#c7e6ea;">整数</span></strong><span style="background-color:#c7e6ea;"> </span>数组</p> <p><span style="color:#4da8ee;">如果不输入shape，则生成一个随机整数</span></p> <p><span style="color:#4da8ee;">如果不输入high，则生成 [ 0 , low ) 之间的一个随机整数</span></p> <p></p> </td></tr><tr><td style="background-color:#ffffff;width:217px;">shuffle（arr）</td><td style="background-color:#ffffff;width:381px;">根据arr的 <strong><span style="background-color:#c7e6ea;">零轴 </span></strong>进行随机排序，且<span style="background-color:#c7e6ea;">原数组发生改变</span></td></tr><tr><td style="background-color:#ffffff;width:217px;"> permutation（arr）</td><td style="background-color:#ffffff;width:381px;">同上，但创建一个新的数组，<span style="background-color:#c7e6ea;">原数组不变</span></td></tr><tr><td style="background-color:#ffffff;width:217px;">chioce（arr，[size,replace,p]）</td><td style="background-color:#ffffff;width:381px;"> <p></p> <p>从一维数组arr中以概率p抽取元素，形成size形状的新数组</p> <p>replace：是否可以重用元素，默认False；默认等概率</p> <p></p> </td></tr><tr><td style="background-color:#cccccc;width:217px;">uniform（low，high，size）</td><td style="background-color:#cccccc;width:381px;">根据size生成 <span style="background-color:#c7e6ea;">[low，high ] </span><span style="background-color:#c7e6ea;">均匀分布</span>随机数数组</td></tr><tr><td style="background-color:#cccccc;width:217px;">normal（loc，scale，size）</td><td style="background-color:#cccccc;width:381px;">根据size生成 <span style="background-color:#c7e6ea;">均值loc，标准差scale 正态分布</span>随机数 数组</td></tr><tr><td style="background-color:#cccccc;width:217px;">poission（lam，size）</td><td style="background-color:#cccccc;width:381px;">根据size生成 随机事件发生率为lam 的<span style="background-color:#c7e6ea;">泊松分布</span>随机数数组</td></tr></tbody></table> 
<p></p> 
<p></p> 
<h4> 4.3 案例</h4> 
<p>       要求：实现1000次的随机漫步</p> 
<pre><code class="language-python">import numpy as np
steps = 1000
draws = np.random.randint(0,2,size=steps)
move = np.where(draws==0,-1,draws)
walk = np.cumsum(move)
print(walk)

# 在数组运算下，我们可以轻易实现很多内容
# 例如：最远距离
print(np.abs(walk).max())
# 第一次到达10或-10时 的位置
print((np.abs(walk) &gt;= 10).argmax())</code></pre> 
<p></p> 
<h2></h2> 
<p></p> 
<h2>5.通用函数（了解）</h2> 
<h4> 5.1 一元通用函数</h4> 
<p>下述函数的调用方式全部为<strong> <span style="background-color:#fbd4d0;">np.函数名（arr）</span></strong></p> 
<table border="2" cellpadding="1" cellspacing="1" style="width:600px;"><thead><tr><th style="background-color:#aaaaaa;">一元函数</th><th style="background-color:#aaaaaa;">描述</th></tr></thead><tbody><tr><td> <p>abs</p> <p>fbs</p> </td><td>计算各个元素的绝对值，对于非复数，可以使用fbs函数</td></tr><tr><td style="background-color:#cccccc;">sqrt</td><td style="background-color:#cccccc;">计算各个元素平方根（要求非负）</td></tr><tr><td style="background-color:#ffffff;">square</td><td style="background-color:#ffffff;">计算各个元素的平方</td></tr><tr><td style="background-color:#cccccc;">exp</td><td style="background-color:#cccccc;">计算各个元素的自然指数值<img alt="e^{x}" class="mathcode" src="https://images2.imgbox.com/b0/bb/o1UW9Rtz_o.png"></td></tr><tr><td style="background-color:#ffffff;"> <p>log、log10</p> <p>log2、log1p</p> </td><td style="background-color:#ffffff;"> <p>分别对应：自然对数（e为底）、10为底、2为底、log（1+x）</p> <p>（要求正数）</p> </td></tr><tr><td style="background-color:#cccccc;">sign</td><td style="background-color:#cccccc;">计算符号值：1（正数）、0（0）、-1（负数）</td></tr><tr><td style="background-color:#eeeeee;">ceil</td><td style="background-color:#eeeeee;">向上取整（大于等于该值的最小整数）    如：3.5取为4</td></tr><tr><td style="background-color:#cccccc;">floor</td><td style="background-color:#cccccc;">向下取整（小于等于该值的最小整数）    如：3.5取为3</td></tr><tr><td style="background-color:#ffffff;">rint</td><td style="background-color:#ffffff;">将元素保留到整数位，并保持dtype</td></tr><tr><td style="background-color:#cccccc;">modf</td><td style="background-color:#cccccc;">分别将数组的小数部分和整数部分 按数组形式返回</td></tr><tr><td style="background-color:#ffffff;">isnan</td><td style="background-color:#ffffff;"> <p>返回一个布尔类型数组</p> <p>判断元素是否为NaN（不是一个数值）     数值会显示False</p> </td></tr><tr><td style="background-color:#cccccc;"> <p>isfinite</p> <p>isinf</p> </td><td style="background-color:#cccccc;"> <p>返回一个布尔类型数组</p> <p>分别判断元素是否有限（非inf 非NaN）、无限</p> </td></tr></tbody></table> 
<p></p> 
<p></p> 
<h4> 5.2 二元通用函数</h4> 
<p> 下述函数的调用方式全部为<strong> <span style="background-color:#fbd4d0;">np.函数名（arr1，arr2）</span></strong></p> 
<table border="2" cellpadding="1" cellspacing="1" style="width:600px;"><thead><tr><th style="background-color:#999999;">二元函数</th><th style="background-color:#999999;">描述</th></tr></thead><tbody><tr><td> <p>add</p> <p>multiply</p> <p>divide</p> <p>floor_divide</p> <p>mod</p> </td><td> <p>数组对应元素相加、相乘、除、整除（放弃余数）、求模</p> </td></tr><tr><td style="background-color:#cccccc;">subtracrt</td><td style="background-color:#cccccc;">在arr2中，去除arr1包含的元素</td></tr><tr><td style="background-color:#ffffff;">power</td><td style="background-color:#ffffff;">将arr2的元素作为arr1对应元素的幂次方</td></tr><tr><td style="background-color:#cccccc;"> <p>fmax</p> <p>fmin</p> </td><td style="background-color:#cccccc;">逐个元素计算最大（小）值、忽略NaN</td></tr><tr><td style="background-color:#ffffff;"> <p>greater</p> <p>greater_equal</p> <p>less</p> <p>less_equal</p> <p>equal</p> <p>not_equal</p> </td><td style="background-color:#ffffff;"> <p>逐个元素进行比较，返回布尔数组</p> <p>（分别表示 &gt;、&gt;=、&lt;、&lt;=、==、!=）</p> </td></tr><tr><td style="background-color:#cccccc;"> <p>logical_and</p> <p>logical_or</p> <p>logical_xor</p> </td><td style="background-color:#cccccc;"> <p>逐个元素进行逻辑操作</p> <p>（与&amp;、|、^效果一致）</p> </td></tr></tbody></table> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d486d26fc1d98ecb801eab5e51c2ac11/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue-Pinina基本教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/789a2f3553f97c61543eebdd6dd163ed/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【工具】HxD Hex Editor 的安装、使用详细教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>