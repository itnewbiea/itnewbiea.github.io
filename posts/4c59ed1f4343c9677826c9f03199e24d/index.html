<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring的Web MVC –重定向到内存泄漏 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring的Web MVC –重定向到内存泄漏" />
<meta property="og:description" content="他们说一块岩石会引起雪崩。 最近，我的一位同事Marcin Radoszewski给了我一块岩石。 您可能永远都不会猜测它是什么，但是有机会在许多Web应用程序中使用它。 请允许我向您介绍这块石头。 您可能很清楚发布模式后的重定向 。 使用Spring Framework，您有几种方法来实现它，让我们专注于其中一种， 将目标URL作为带有redirect： prefix的String返回 。 假设我们有使用这种重定向方法的控制器，并且在重定向期间必须传递一些参数，例如，让它成为某些实体ID： @RequestMapping(method = RequestMethod.POST) public String onPost(...) { ... return &#34;redirect:form.html?entityId=&#34; &#43; entityId; } 如您所见，我们的岩石看上去并不危险，甚至看上去都不可疑–这到底是怎么了？ –您可能会问。 好了，要解释一下，我们必须看看Spring Framework如何处理您返回的值的方式。 您可以从阅读Spring Framework文档中的解析视图开始，然后仔细查看AbstractCachingViewResolver的源代码，它是Spring中许多不同的视图解析器的基类，包括：JSP，FreeMarker，Velocity，Jasper Reports，Tiles和XSLT视图解析器。 当resolveViewName方法被调用AbstractCachingViewResolver的它采用了基于HashMap的视图缓存加快鉴于在未来的呼叫解决，和缓存关键是使用视图名称和当前语言环境中创建的默认。 现在，当您使用上述重定向方法时， Spring Framework将从控制器的方法返回的整个String用作视图名称，包括目标URL中包含的所有参数。 每次执行重定向时，参数可能会有所不同，因此这种重定向将在AbstractCachingViewResolver的视图缓存中留下一个额外的条目，从而导致内存泄漏。 多久会终止我的申请？ –您可能会问。 这取决于分配给JVM的内存量以及执行的重定向次数–我已经使用-Xmx64M选项进行了一些测试，仅通过一个控制器即可构建简单的应用程序-请参见本示例 。 大约76400重定向后，应用程序因OutOfMemoryError：Java heap space终止。 参考： Spring的Web MVC –在Warlock&#39;s Thoughts博客上从我们的JCG合作伙伴 Michal Jastak 重定向到Memory Leak 。 翻译自: https://www.javacodegeeks.com/2012/12/springs-web-mvc-redirect-to-the-memory-leak.html" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4c59ed1f4343c9677826c9f03199e24d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-14T02:03:03+08:00" />
<meta property="article:modified_time" content="2020-05-14T02:03:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring的Web MVC –重定向到内存泄漏</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="entry" style="font-size: 16px;"> 
 <div class="e3lan-post"> 
  <div> 
   <span class="bt-uid-tg"></span> 
  </div> 
 </div> 
 <p> 他们说一块岩石会引起雪崩。 最近，我的一位同事Marcin Radoszewski给了我一块岩石。 您可能永远都不会猜测它是什么，但是有机会在许多Web应用程序中使用它。 请允许我向您介绍这块石头。 </p> 
 <p> 您可能很清楚<em>发布</em>模式<em>后的重定向</em> 。 使用<a href="http://www.springsource.org/spring-framework" rel="nofollow noopener noreferrer" target="_blank">Spring Framework，</a>您有几种方法来实现它，让我们专注于其中一种， <a href="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/mvc.html#mvc-redirecting-redirect-prefix" rel="nofollow noopener noreferrer" target="_blank">将目标URL作为带有<em>redirect：</em> prefix的String返回</a> 。 </p> 
 <p> 假设我们有使用这种重定向方法的控制器，并且在重定向期间必须传递一些参数，例如，让它成为某些实体ID： <br></p> 
 <pre class="has"><code class="notranslate brush:java">@RequestMapping(method = RequestMethod.POST)
public String onPost(...) {
    ...
    return "redirect:form.html?entityId=" + entityId;
}</code></pre> 
 <p> 如您所见，我们的岩石看上去并不危险，甚至看上去都不可疑–这到底是怎么了？ –您可能会问。 好了，要解释一下，我们必须看看<a href="http://www.springsource.org/spring-framework" rel="nofollow noopener noreferrer" target="_blank">Spring Framework</a>如何处理您返回的值的方式。 </p> 
 <p> 您可以从阅读<a href="http://www.springsource.org/spring-framework" rel="nofollow noopener noreferrer" target="_blank">Spring Framework</a>文档中的<a href="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/mvc.html#mvc-viewresolver" rel="nofollow noopener noreferrer" target="_blank">解析视图</a>开始，然后仔细查看<em>AbstractCachingViewResolver</em>的源代码，它是Spring中许多不同的视图解析器的基类，包括：JSP，FreeMarker，Velocity，Jasper Reports，Tiles和XSLT视图解析器。 </p> 
 <p> 当<em>resolveViewName</em>方法被调用<em>AbstractCachingViewResolver的</em>它采用了基于<em>HashMap的</em>视图缓存加快鉴于在未来的呼叫解决，和缓存关键是使用视图名称和当前语言环境中创建的默认。 </p> 
 <p> 现在，当您使用上述重定向方法时， <a href="http://www.springsource.org/spring-framework" rel="nofollow noopener noreferrer" target="_blank">Spring Framework</a>将从控制器的方法返回的整个String用作视图名称，包括目标URL中包含的所有参数。 每次执行重定向时，参数可能会有所不同，因此这种重定向将在<em>AbstractCachingViewResolver的</em>视图缓存中留下一个额外的条目，从而导致内存泄漏。 </p> 
 <p> 多久会终止我的申请？ –您可能会问。 这取决于分配给JVM的内存量以及执行的重定向次数–我已经使用-Xmx64M选项进行了一些测试，仅通过一个控制器即可构建简单的应用程序-请参见<a href="https://github.com/vardlokkur/webapp-02" rel="nofollow noopener noreferrer" target="_blank">本示例</a> 。 大约76400重定向后，应用程序因<em>OutOfMemoryError：Java heap space</em>终止。 <br></p> 
 <p> <strong><em>参考：</em></strong> <a href="https://vard-lokkur.blogspot.com/2012/12/springs-web-mvc-redirect-to-memory-leak.html" rel="nofollow">Spring的Web MVC –</a>在<a href="https://vard-lokkur.blogspot.com/" rel="nofollow">Warlock's Thoughts</a>博客上从我们的<a href="//www.javacodegeeks.com/p/jcg.html" rel="nofollow">JCG合作伙伴</a> Michal Jastak <a href="https://vard-lokkur.blogspot.com/2012/12/springs-web-mvc-redirect-to-memory-leak.html" rel="nofollow">重定向到Memory Leak</a> 。 </p> 
 <blockquote> 
  <p>翻译自: <a href="https://www.javacodegeeks.com/2012/12/springs-web-mvc-redirect-to-the-memory-leak.html" rel="nofollow">https://www.javacodegeeks.com/2012/12/springs-web-mvc-redirect-to-the-memory-leak.html</a></p> 
 </blockquote> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4b6f844bb7ea3bbb327904599514b7e0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Transformers in NLP （一）：图说transformer结构</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8f21d720e8ba0274f00a9310351cf5fe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">gradle和git_使用git，gradle和markdown创建漂亮的发行说明</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>