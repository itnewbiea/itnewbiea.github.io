<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Dockerfile文件解释 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Dockerfile文件解释" />
<meta property="og:description" content="一、先来看一个简单的 Dockerfile #这个Dockerfile作用是打一个python3项目环境 FROM python:3-alpine WORKDIR /app ADD . /app RUN pip3 install -r requirements.txt -i https://pypi.douban.com/simple CMD [&#34;python3&#34;, &#34;main.py&#34;] #这个Dockerfile作用Dockerfile部署django项目 FROM centos:7 MAINTAINER annlin ADD requeriments.txt /home WORKDIR /home RUN yum update &amp;&amp; yum -y install mysql &amp;&amp; yum -y install python3-pip &amp;&amp; pip3 install -r requirements.txt ADD autoTest /home/ WORKDIR /home/autoTest EXPOSE 8000 ENTRYPOINT uwsgi --ini uwsgi.ini 二、Dockerfile 编写规则 指令大小写不敏感，为了区分习惯上用大写Dockerfile 非注释行第一行必须是 FROM文件名必须是 DockerfileDockerfile 指定一个专门的目录为工作空间所有引入映射的文件必须在这个工作空间目录下Dockerfile 工作空间目录下支持隐藏文件(.dockeringore)(.dockeringore)作用是用于存放不需要打包导入镜像的文件，根目录就是工作空间目录每一条指令都会生成一个镜像层，镜像层多了执行效率就慢，能写成一条指定的就写成一条 三、Dockerfile 指令详解 1、FROM：基础镜像 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/07b17157f44f3f283f1f1d09173d3270/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-08T14:42:30+08:00" />
<meta property="article:modified_time" content="2022-05-08T14:42:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Dockerfile文件解释</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、先来看一个简单的 Dockerfile</h3> 
<pre><code class="language-python">#这个Dockerfile作用是打一个python3项目环境 
FROM python:3-alpine 
WORKDIR /app 
ADD . /app 
RUN pip3 install -r requirements.txt -i https://pypi.douban.com/simple 
CMD ["python3", "main.py"] 

#这个Dockerfile作用Dockerfile部署django项目 
FROM centos:7 
MAINTAINER annlin 
ADD requeriments.txt /home 
WORKDIR /home 
RUN yum update &amp;&amp; yum -y install mysql &amp;&amp; yum -y install python3-pip &amp;&amp; pip3 install -r requirements.txt 
ADD autoTest /home/ WORKDIR /home/autoTest 
EXPOSE 8000 
ENTRYPOINT uwsgi --ini uwsgi.ini</code></pre> 
<h3>二、Dockerfile 编写规则</h3> 
<ol><li>指令大小写不敏感，为了区分习惯上用大写</li><li>Dockerfile 非注释行第一行必须是 FROM</li><li>文件名必须是 Dockerfile</li><li>Dockerfile 指定一个专门的目录为工作空间</li><li>所有引入映射的文件必须在这个工作空间目录下</li><li>Dockerfile 工作空间目录下支持隐藏文件(.dockeringore)</li><li>(.dockeringore)作用是用于存放不需要打包导入镜像的文件，根目录就是工作空间目录</li><li>每一条指令都会生成一个镜像层，镜像层多了执行效率就慢，能写成一条指定的就写成一条</li></ol> 
<h3>三、Dockerfile 指令详解</h3> 
<h4>1、FROM：基础镜像</h4> 
<p><code>1.1、FROM是Dockerfile文件开篇第一个非注释行代码 </code></p> 
<p><code>1.2、用于为镜像文件构建过程指定基础镜像，后续的指令都基于该基础镜像环境运行 </code></p> 
<p><code>1.3、基础镜像可以是任何一个镜像文件 </code></p> 
<p><code>1.4、docker build 会在docker宿主机上查找指定的文件，如未找到会自动去Docker Hub Registry上拉取 </code></p> 
<p><code>1.5、如果没找到对应的镜像就会返回错误信息 </code></p> 
<h4>2、MAINTAINER：镜像作者信息</h4> 
<p><code>2.1、废弃了，使用LABLE替代 </code></p> 
<h4>3、LABLE：镜像描述信息</h4> 
<p><code>3.1、LABLE author="annlin" </code></p> 
<h4>4、COPY：从 Docker 宿主机复制文件至创建的新镜像文件</h4> 
<p><code>4.1、COPY &lt;src&gt; &lt;dest&gt; </code></p> 
<p><code>4.2、COPY ["&lt;src&gt;",.... "&lt;dest&gt;"] </code></p> 
<p><code>4.3、&lt;src&gt;：要复制的源文件或目录，支持使用通配符 </code></p> 
<p><code>     1、&lt;src&gt;必须是build上下文中的路径，不能是其父目录路径 </code></p> 
<p><code>     2、如果&lt;src&gt;是目录，则其内部文件和子目录都会被递归复制，但是&lt;src&gt;目录本身不</code></p> 
<p><code>        会被复制 </code></p> 
<p><code>     3、如果指定了多个&lt;src&gt;,或者&lt;src&gt;中使用了通配符，则&lt;dest&gt;必须是一个目录，</code></p> 
<p><code>        且必须以/结尾 </code></p> 
<p><code>4.4、&lt;dest&gt;：目标路径，即正在创建的images的文件系统路径 </code></p> 
<p><code>     1、建议使用绝对路径，否则COPY指定以WORKDIR为其实路径 </code></p> 
<p><code>     2、如果&lt;dest&gt;不存在，将会被自动创建，包括其父目录路径一起创建 </code></p> 
<p><code>4.5、复制文件 COPY testFile /mnt </code></p> 
<p><code>4.6、复制目录 COPY testDir /mnt/testDir </code></p> 
<p><code>     1、testDir下所有文件和目录都会被递归复制 </code></p> 
<p><code>     2、目标路径要写testDir，否则会复制到/mnt下 </code></p> 
<h4>5、ADD：类似于 COPY 指令，ADD 支持 tar 文件和 URL 路径​​​​​​​​​​​​​​</h4> 
<p><code>5.1、ADD &lt;src&gt; &lt;dest&gt; </code></p> 
<p><code>5.2、ADD ["&lt;src&gt;",.... "&lt;dest&gt;"] </code></p> 
<p><code>5.3、如果&lt;src&gt;为URL切&lt;dest&gt;不以/结尾，则&lt;src&gt;指定的文件将被下载并直接被创建为&lt;fimename&gt;，如果&lt;dest&gt;以/结尾，则文件名URL指定的文件将被下载并保存为&lt;dest&gt;/fimename </code></p> 
<p><code>5.4、如果&lt;src&gt;是一个压缩文件(tar),会被解压为一个目录，但是通过URL下载的tar文件不会被解压 </code></p> 
<p><code>5.5、如果是多个&lt;src&gt;，或者是同一个&lt;src&gt;使用了通配符，则&lt;dest&gt;必须是以/结尾的目录，如果&lt;dest&gt;不以/结尾，则&lt;src&gt;会被作为一个普通文件,&lt;src&gt;内容讲被写入到&lt;dest&gt; </code></p> 
<h4>6、WORKDIR：用于为 Dockerfile 中所有的 RUN、CMD、ENTRYPOINT、COPY、ADD 指定设定工作目录</h4> 
<p><code>6.1、WORKDIR /mnt，如果目录不存在会自动创建，包括他的父目录 </code></p> 
<p><code>6.2、一个Dockerfile中WORKDIR可以出现多次，其路径也可以为相对路径,相对路径是基于前一个WORKDIR路径 </code></p> 
<p><code>6.3、WORKDIR也可以调用ENV指定的变量 </code></p> 
<p><code>6.4：举例 from python:latest workdir /mnt run touch a.txt workdir /usr run touch b.txt </code></p> 
<h4>7、VOLUME：数据卷，用于在 image 中创建挂载点目录，以挂载 Docker host 上的卷或者其他容器上的卷</h4> 
<p><code>7.1、VOLUM mount_point </code></p> 
<p><code>7.2、VOLUM ["mount_point1","mount_point2"] </code></p> 
<p><code>7.3、如果挂载点目录下有文件存在，docker run命令会在卷挂载完成后将所有文件复制到容器中 </code></p> 
<p>8、EXPOSE：为容器打开指定的监听端口以实现与外部通信</p> 
<p><code>8.1、EXPOSE &lt;port&gt; &lt;/portocol&gt; </code></p> 
<p><code>     1、&lt;port&gt;：端口号 </code></p> 
<p><code>     2、&lt;/portocol&gt;：协议类型，默认为TCP协议 EXPOSE 8080/tcp 8081/udp </code></p> 
<p><code>8.2、不会直接对外暴露这里的端口，只有在run的时候加上-P(大写)才会将EXPOSE的端口暴露出去 </code></p> 
<p>9、ENV：用于为镜像定义所需的环境变量，可以被 Dockerfile 文件中其他命令调用(ENV、ADD、COPY、RUN、CMD)</p> 
<p><code>9.1、ENV key value 1、key之后的所有内容都会被视为value,因此，一次只能设置一个变量 </code></p> 
<p><code>9.2、ENV key=value </code></p> 
<p><code>     1、可以设置多个变量，每个key=value键值对为一个变量 </code></p> 
<p><code>     2、如果value中包含空格需要用反斜杠转义，也可以对value加引号进行标识，反斜杠也可以用于续行 </code></p> 
<p><code>9.3、调用格式：$variable_name 或 ${variable_name} </code></p> 
<p><code>9.4、定义多个变量建议使用第二种方式，以便在同一层中完成 </code></p> 
<p><code>9.5、举例 ENV DOC_DIR=/mnt/doc COPY index.html ${DOC_DIR:-/mnt/doc} #-：如果DOC_DIR不存在则使用-后面的默认值 #+：如果DOC_DIR存在则使用+后面的值 </code></p> 
<p>10、RUN：docker build 镜像构建的时候需要执行的 shell 命令默认"/bin/sh -c"运行 </p> 
<p><code>10.1、docker build过程中需要执行的命令 </code></p> 
<p><code>10.2、RUN是在镜像构建完成之后运行结束 </code></p> 
<p><code>10.3、RUN执行的命令只能基于基础镜像的命令，执行之前先要确定基础镜像是否有该命令</code></p> 
<p><code>10.4、一个Dockerfile可以写多个RUN </code></p> 
<p><code>   语法一、RUN command1 &amp;&amp; command2.... </code></p> 
<p><code>     1、通常是shell命令且以"/bin/sh -c"来运行它，此时运行为shell的子进程 </code></p> 
<p><code>     2、进程在容器中的PID!=1，不能接收unix信号，当使用docker stop 将无法接收到</code></p> 
<p><code>     3、RUN echo "test_demo" &gt; a.txt 此时可以使用shell特性 </code></p> 
<p><code>   语法二、RUN ["executable","param1"，"param2"] </code></p> 
<p><code>     1、executable为要运行的命令 </code></p> 
<p><code>     2、param1为命令运行的参数 </code></p> 
<p><code>     3、不会以"/bin/sh -c"运行(非shell子进程)，因此不支持shell操作符如变量替换和通配符(?,*等) </code></p> 
<p><code>     4、如果运行命令需要依赖shell特性可以增加参数，手动启动为shell的子进程 RUN ["/bin/bash","-c","executable","param1"] </code></p> 
<p><code>     5、list中的参数要使用双引号 </code></p> 
<p><code>11、</code>CMD：启动容器指定默认要运行的程序或命令，默认"/bin/sh -c"运行</p> 
<p><code>11.1、docker run过程中需要执行的命令 </code></p> 
<p><code>11.2、CMD运行结束后容器就将终止 </code></p> 
<p><code>11.3、CMD指定的命令将可以被 docker run 最后面的命令覆盖 </code></p> 
<p><code>11.4、一个Dockerfile写多个CMD只有最后一个CMD会生效 </code></p> 
<p><code>   语法一、CMD command </code></p> 
<p><code>     1、通常是shell命令且以"/bin/sh -c"来运行它，此时运行为shell的子进程，能使用shell操作符 </code></p> 
<p><code>     2、进程在容器中的PID!=1，不能接收unix信号，当使用docker stop 将无法接收到 </code></p> 
<p><code>     3、CMD /bin/httpd -f -h ${httpd} 此时在运行容器的时候加-it参数无法进入交互式模式，需要使用docker exec进入交互模式 </code></p> 
<p><code>   语法二、CMD ["executable","param1","param2"] </code></p> 
<p><code>     1、不会以"/bin/sh -c"运行(非shell子进程)，因此不支持shell操作符如变量替换和通配符(?,*等) </code></p> 
<p><code>     2、如果运行命令需要依赖shell特性可以增加参数，手动启动为shell的子进程 CMD ["/bin/bash","-c","executable","param1","param2"](有问题，不能启动容器) </code></p> 
<p><code>   语法三、CMD ["param1","param2"] </code></p> 
<p><code>     1、需要结合ENTRYPOINT指令提供默认参数使用 </code></p> 
<p>12、ENTRYPOINT：类型 CMD 指令的功能，用于为容器指定默认运行程序或命令</p> 
<p><code>12.1、与CMD不同的是，由ENTRYPOINT启动的程序不会被docker run命令行指定的参数覆盖，这些命令行参数会被当做参数传递给ENTRYPOINT指定的程序 </code></p> 
<p><code>12.2、docker run命令的 --entrypoint选项参数可以覆盖ENTRYPOINT指令指定的程序 </code></p> 
<p><code>12.3、一个Dockerfile中可以有多个ENTRYPOINT，但是只有最后一个会生效 </code></p> 
<p><code>12.4、ENTRYPOINT主要用于shell作为启动其他进程的父进程，后面跟的参数被当成子进程来启动 </code></p> 
<p><code>   语法一：ENTRYPOINT command </code></p> 
<p><code>   语法二：ENTRYPOINT ["/bin/bash","param1","param2"] </code></p> 
<p>13、CMD 和 ENTRYPOINT 同时存在 Dockerfile 中</p> 
<p><code>13.1、CMD的值会当做参数传递给ENTRYPOINT </code></p> 
<p><code>13.2、实现使用shell子进程启动httpd </code></p> 
<p><code>13.3、如果docker run再传入参数，是传给ENTRYPOINT的，因为ENTRYPOINT有自己的参数，此时CMD参数会被ducker run后面跟的参数覆盖，并不是覆盖ENTRYPOINT的参数，要覆盖ENTRYPOINT的参数需要使用--entrypoint选项 CMD ["/bin/httpd/","-f"] ENTRYPOINT /bin/bash -c -h 通过传参启动容器 FROM python:latest LABLE auth="haili" ENV NGX_DOC_ROOT='/data/web/html' ADD entrypoint.sh /bin/ CMD ['/usr/sbin/nginx','-g','daemon off;'] ENTRYPOINT ['/bin/sh','-c','/bin/entrypoint.sh'] </code></p> 
<p><code>    1、先执行ENTRYPOINT，然后讲CMD的值当做参数传给ENTRYPOINT进行执行 </code></p> 
<p>14、USER：指定运行 image 时和 Dockerfile 中任何 RUN、CMD、ENTRYPOINT 指令指定的程序的用户</p> 
<p><code>14.1、使用用户名或者UID </code></p> 
<p><code>14.2、默认情况下container的运行身份为root用户 </code></p> 
<p><code>14.3、USER UID | user_name </code></p> 
<p><code>14.4、UID 和 user_name必须存在/etc/passwd当中，否则会报错 </code></p> 
<p>15、HEALTHCHECK：健康检查，定义一个命令用于检查主进程工作状态是否健康</p> 
<p><code>15.1、HEALTHCHECK参数 </code></p> 
<p><code>     1、--interval=DURATION(default 30s) 健康检查间隔时间 </code></p> 
<p><code>     2、--timeout=DURATION(default 30s) 超时时间 </code></p> 
<p><code>     3、--start-period=DURATION(default 0s) 容器启动多久后执行健康检查 </code></p> 
<p><code>     4、--retries=N(default 30s) 检测次数 </code></p> 
<p><code>15.2、检查结果 0：成功 1：失败 2：预留字段 </code></p> 
<p><code>15.3、举例 HEALTHCHECK --interval=5m --timeout=5s CMD curl -f http://localhost:8080 ||exit1 </code></p> 
<p>16、SHELL：指定运行 RUN、CMD、ENTRYPOINT 的 shell 程序</p> 
<p>17、STOPSIGNAL：给主进程发送信号</p> 
<p>18、ARG：docker build 过程中的参数</p> 
<p><code>18.1、定义pyton镜像作者，通过参数传入 FROM python ARG author="latest" LABLE author="${author}" </code></p> 
<p><code>18.2、使用 docker build --build-arg author="haili" </code></p> 
<p><code>18.3、常用在docker build 过程中替换参数 </code></p> 
<p>19、ONBUILD：用于在 Dockerfile 中定义一个触发器</p> 
<p><code>19.1、Dockerfile1中加一个ONBUILD add file，当docker build -t=testpython Dockerfile1的时候ONBUILD指令不会被执行,Dockerfile2中FROM testpython(Dockerfile1构建后生成的镜像)，当运行docker build -t=test Dockerfile2的时候Dockerfile1中的ONBUILD add file会被执行 </code></p> 
<p><code>19.2、Dockerfile用于build镜像文件，此镜像文件可以作为base image被另外一个Dockerfile作为FROM参数使用，并以之构建新的镜像文件 </code></p> 
<p><code>19.3、在后面这个Dockerfile中的FROM指令在build过程中被执行时，将触发创建其base image的Dockerfile中ONBUILD指定定义的触发器 </code></p> 
<p><code>19.4、尽管任何指令都可以注册为触发器指令，但是ONBUILD不能自我嵌套，且不会触发FROM和MAINTAINER指令 </code></p> 
<p><code>19.5、使用包含ONBUILD指令的Dockerfile构建镜像应该使用特殊标签如，python:1.0-onbuild </code></p> 
<p><code>19.6、ONBUILD指令中使用ADD COPY指令要格外小心，因为新构建过程山下文缺少指定的源文件就会失败</code>​​​​​​​</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4b2c7f95590d2fb9b6ce6dc3470ed611/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">创建ingress报错</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7e9ab2fc82f359de70b4161cfb0ccc5a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">org.apache.ibatis.binding.BindingException: Invalid bound statement (not found):的三种解决方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>