<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>探索 Docker 容器的文件系统 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="探索 Docker 容器的文件系统" />
<meta property="og:description" content="问： 我注意到 docker 我需要了解容器内发生了什么或其中存在哪些文件。一个例子是从 docker index 下载图像——你不知道图像包含什么，因此无法启动应用程序。
理想的情况是能够通过 ssh 进入它们或等效的。是否有工具可以做到这一点，或者我对 docker 的概念化认为我应该能够做到这一点是错误的。
答1: 一个优秀的自由职业者，应该有对需求敏感和精准需求捕获的能力，而huntsbot.com提供了这个机会
这里有几种不同的方法…
A）使用 docker exec（最简单）
Docker 1.3 或更高版本支持与 nsenter 类似的命令 exec。此命令可以在已经运行的容器中运行新进程（容器必须已经运行 PID 1 进程）。您可以运行 /bin/bash 来探索容器状态：
docker exec -t -i mycontainer /bin/bash 见Docker command line documentation
B) 使用快照
您可以通过这种方式评估容器文件系统：
# find ID of your running container: docker ps # create image (snapshot) from container filesystem docker commit 12345678904b5 mysnapshot # explore this filesystem using bash (for example) docker run -t -i mysnapshot /bin/bash 这样，您可以在精确的时刻评估正在运行的容器的文件系统。容器仍在运行，不包括未来的更改。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b74d3a6aabff206845bb9f11d4227c8d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-19T08:30:43+08:00" />
<meta property="article:modified_time" content="2023-01-19T08:30:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">探索 Docker 容器的文件系统</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>问：</h2> 
<p>我注意到 docker 我需要了解容器内发生了什么或其中存在哪些文件。一个例子是从 docker index 下载图像——你不知道图像包含什么，因此无法启动应用程序。</p> 
<p>理想的情况是能够通过 ssh 进入它们或等效的。是否有工具可以做到这一点，或者我对 docker 的概念化认为我应该能够做到这一点是错误的。</p> 
<h2><a id="1_5"></a>答1:</h2> 
<blockquote> 
 <p>一个优秀的自由职业者，应该有对需求敏感和精准需求捕获的能力，而huntsbot.com提供了这个机会</p> 
</blockquote> 
<p>这里有几种不同的方法…</p> 
<p>A）使用 docker exec（最简单）</p> 
<p>Docker 1.3 或更高版本支持与 nsenter 类似的命令 exec。此命令可以在已经运行的容器中运行新进程（容器必须已经运行 PID 1 进程）。您可以运行 /bin/bash 来探索容器状态：</p> 
<pre><code class="prism language-java">docker exec <span class="token operator">-</span>t <span class="token operator">-</span>i mycontainer <span class="token operator">/</span>bin<span class="token operator">/</span>bash

</code></pre> 
<p>见Docker command line documentation</p> 
<p>B) 使用快照</p> 
<p>您可以通过这种方式评估容器文件系统：</p> 
<pre><code class="prism language-java"># find <span class="token constant">ID</span> of your running container<span class="token operator">:</span>
docker ps

# create image <span class="token punctuation">(</span>snapshot<span class="token punctuation">)</span> from container filesystem
docker commit <span class="token number">12345678904</span>b5 mysnapshot

# explore <span class="token keyword">this</span> filesystem using bash <span class="token punctuation">(</span><span class="token keyword">for</span> example<span class="token punctuation">)</span>
docker run <span class="token operator">-</span>t <span class="token operator">-</span>i mysnapshot <span class="token operator">/</span>bin<span class="token operator">/</span>bash

</code></pre> 
<p>这样，您可以在精确的时刻评估正在运行的容器的文件系统。容器仍在运行，不包括未来的更改。</p> 
<p>您可以稍后使用（正在运行的容器的文件系统不受影响！）删除快照：</p> 
<pre><code class="prism language-java">docker rmi mysnapshot

</code></pre> 
<p>C) 使用 ssh</p> 
<p>如果您需要持续访问，您可以将 sshd 安装到您的容器并运行 sshd 守护进程：</p> 
<pre><code class="prism language-java"> docker run <span class="token operator">-</span>d <span class="token operator">-</span>p <span class="token number">22</span> mysnapshot <span class="token operator">/</span>usr<span class="token operator">/</span>sbin<span class="token operator">/</span>sshd <span class="token operator">-</span><span class="token class-name">D</span>
 
 # you need <span class="token keyword">to</span> <span class="token namespace">find</span> out which port <span class="token keyword">to</span> <span class="token namespace">connect</span><span class="token operator">:</span>
 docker ps

</code></pre> 
<p>这样，您可以使用 ssh 运行您的应用程序（连接并执行您想要的）。</p> 
<p>D) 使用 nsenter</p> 
<p>使用 nsenter，见 Why you don’t need to run SSHd in your Docker containers</p> 
<p>简短的版本是：使用 nsenter，您可以将 shell 放入现有容器中，即使该容器不运行 SSH 或任何类型的特殊用途守护程序</p> 
<p><code>但请注意，如果您需要访问文件，请使用“docker cp”命令用法： docker cp CONTAINER:PATH HOSTPATH 将文件/文件夹从容器文件系统复制到主机路径。路径是相对于文件系统的根目录的。 #&gt; docker cp 7bb0e258aefe:/etc/debian_version 。 #&gt; docker cp blue_frog:/etc/hosts 。</code></p> 
<p><code>选项 4 非常重要，应将其移至顶部并重命名为 Option 1。</code></p> 
<p><code>@JanusTroelsen 如果没有外壳，您可以安装它 - 例如在 alpine linux 的 dockerfile 中（确实没有外壳）：RUN apk update &amp;&amp; apk add bash（大小：~4MB）</code></p> 
<p><code>根据我自己的经验，Docker exec 的限制是该命令必须添加到正在运行的容器上或作为一种入口点。因此，停止的容器超出了此方法的范围。</code></p> 
<p><code>要使用 Window 的 linux shell，请使用 docker exec -t -i mycontainer /bin/sh</code></p> 
<h2><a id="2_84"></a>答2:</h2> 
<blockquote> 
 <p>huntsbot.com – 高效赚钱，自由工作</p> 
</blockquote> 
<p>更新：探索！</p> 
<p>这个命令应该让你探索一个正在运行的 docker 容器：</p> 
<pre><code class="prism language-java">docker exec <span class="token operator">-</span>it name<span class="token operator">-</span>of<span class="token operator">-</span>container bash

</code></pre> 
<p>docker-compose 中的等效项是：</p> 
<pre><code class="prism language-java">docker<span class="token operator">-</span>compose exec web bash

</code></pre> 
<p>（在这种情况下，web 是服务名称，默认情况下它具有 tty。）</p> 
<p>一旦你在里面做：</p> 
<pre><code class="prism language-java">ls <span class="token operator">-</span>lsa

</code></pre> 
<p>或任何其他 bash 命令，例如：</p> 
<pre><code class="prism language-java">cd <span class="token punctuation">.</span><span class="token punctuation">.</span>

</code></pre> 
<p>这个命令应该让你探索一个 docker 镜像：</p> 
<pre><code class="prism language-java">docker run <span class="token operator">--</span>rm <span class="token operator">-</span>it <span class="token operator">--</span>entrypoint<span class="token operator">=</span><span class="token operator">/</span>bin<span class="token operator">/</span>bash name<span class="token operator">-</span>of<span class="token operator">-</span>image

</code></pre> 
<p>一旦进入内部做：</p> 
<pre><code class="prism language-java">ls <span class="token operator">-</span>lsa

</code></pre> 
<p>或任何其他 bash 命令，例如：</p> 
<pre><code class="prism language-java">cd <span class="token punctuation">.</span><span class="token punctuation">.</span>

</code></pre> 
<p>-it 代表交互式…和 tty。</p> 
<p>此命令应允许您检查正在运行的 docker 容器或映像：</p> 
<p>docker inspect name-of-container-or-image</p> 
<p>您可能想要这样做并找出其中是否有任何 bash 或 sh。在 json 返回中查找入口点或 cmd。</p> 
<p>注意：此答案依赖于存在的常用工具，但如果没有 bash shell 或 ls 等常用工具，如果您有权访问 { 3}：高山的例子：</p> 
<pre><code class="prism language-java"><span class="token constant">RUN</span> apk add <span class="token operator">--</span>no<span class="token operator">-</span>cache bash

</code></pre> 
<p>否则，如果您无权访问 Dockerfile，则只需将文件从新创建的容器中复制出来，然后通过执行以下操作查看它们：</p> 
<pre><code class="prism language-java">docker create   # returns container <span class="token constant">ID</span> the container is never started<span class="token punctuation">.</span>
docker cp <span class="token operator">:</span> 
docker rm 
cd  <span class="token operator">&amp;&amp;</span> ls <span class="token operator">-</span>lsah

</code></pre> 
<p>见docker exec documentation</p> 
<p>见docker-compose exec documentation</p> 
<p>见docker inspect documentation</p> 
<p>见docker create documentation</p> 
<p><code>这非常有用，谢谢！我需要将包含在 docker 图像文件结构中的文件拖放到应用程序中，但除非它以 GUI 格式打开，否则这是不可能的。知道我该如何解决这个问题吗？</code></p> 
<p><code>很明显，这只适用于安装了 bash 的容器。</code></p> 
<p><code>对于想在 Windows Container/Powershell 上执行此操作的任何人，命令是 docker exec -ti powershell (source)</code></p> 
<p><code>@ssell 我的容器/图像由于某种原因没有 powershell，所以 docker exec -ti cmd 工作。对于像我这样的其他新手，请确保使用来自 docker ps 的容器实例名称（类似于 070494393ca5），而不是您为其分配的可读名称。</code></p> 
<p><code>关于图像中的 powershell github.com/aspnet/aspnet-docker/issues/362 - 如果您只需要在 Windows 图像上卷曲：blogs.technet.microsoft.com/virtualization/2017/12/19/…</code></p> 
<h2><a id="3_201"></a>答3:</h2> 
<blockquote> 
 <p>huntsbot.com提供全网独家一站式外包任务、远程工作、创意产品分享与订阅服务!</p> 
</blockquote> 
<p>如果您的容器已停止或没有外壳（例如 installation guide 中提到的 hello-world 或非 alpine traefik），这可能是探索文件系统的唯一可能方法。</p> 
<p>您可以将容器的文件系统归档到 tar 文件中：</p> 
<pre><code class="prism language-java">docker export adoring_kowalevski <span class="token operator">&gt;</span> contents<span class="token punctuation">.</span>tar

</code></pre> 
<p>或列出文件：</p> 
<pre><code class="prism language-java">docker export adoring_kowalevski <span class="token operator">|</span> tar t

</code></pre> 
<p>请注意，根据图像，可能需要一些时间和磁盘空间。</p> 
<p><code>我只是想列出一个没有安装标准 UNIX 工具的容器的内容。上面 export 示例的一个变体恰如其分：docker export adoring_kowalevski | tar tf -</code></p> 
<p><code>对粗心的人的警告：这可能会导出大量数据（&gt; GB）并需要很长时间。</code></p> 
<p><code>@berto 并不是说这是一件大事，但是您不需要 f - 在命令末尾， tar 默认情况下从标准输入读取。只需 docker export adoring_kowalevski | tar t 即可。</code></p> 
<p><code>越简单越好；太棒了，谢谢你的提示！ 🙌🏽</code></p> 
<p><code>@ShaunBouckaert tar f 的默认值取决于一个人的配置。一部分是 TAPE 环境变量。其他的则作为构建的一部分进行控制。最终结果是，永远不要假设它读取 stdin 或写入 stdout，但始终明确说明。</code></p> 
<h2><a id="4_236"></a>答4:</h2> 
<blockquote> 
 <p>HuntsBot周刊–不定时分享成功产品案例，学习他们如何成功建立自己的副业–huntsbot.com</p> 
</blockquote> 
<p>最受好评的答案是在容器实际启动时为我工作，但是当它无法运行并且您例如想要从容器中复制文件时，这已经救了我：</p> 
<pre><code class="prism language-java">docker cp <span class="token operator">:</span> 

</code></pre> 
<p>感谢 docker cp (link)，您可以直接从容器中复制，因为它是文件系统的任何其他部分。例如，恢复容器内的所有文件：</p> 
<pre><code class="prism language-java">mkdir <span class="token operator">/</span>tmp<span class="token operator">/</span>container_temp
docker cp example_container<span class="token operator">:</span><span class="token operator">/</span> <span class="token operator">/</span>tmp<span class="token operator">/</span>container_temp<span class="token operator">/</span>

</code></pre> 
<p>请注意，您无需指定要递归复制。</p> 
<p><code>为什么这没有更多的+1！绝对是最好的方法</code></p> 
<p><code>这比通过 tar 导出还要简单。我必须使用 -L 通过符号链接访问文件。无需运行容器！</code></p> 
<p><code>这应该是公认的答案！特别是如果您想在 docker 容器由于某种原因（“调试”）无法运行时探索文件系统。这种方式简单易行。</code></p> 
<h2><a id="5_266"></a>答5:</h2> 
<blockquote> 
 <p>与HuntsBot一起，探索全球自由职业机会–huntsbot.com</p> 
</blockquote> 
<p>容器创建之前：</p> 
<p>如果您要探索安装在容器内的图像的结构，您可以这样做</p> 
<pre><code class="prism language-java">sudo docker image save image_name <span class="token operator">&gt;</span> image<span class="token punctuation">.</span>tar
tar <span class="token operator">-</span>xvf image<span class="token punctuation">.</span>tar

</code></pre> 
<p>这将使您可以看到图像的所有层及其在 json 文件中的配置。</p> 
<p>容器创建后：</p> 
<p>为此，上面已经有很多答案。我首选的方法是-</p> 
<pre><code class="prism language-java">docker exec <span class="token operator">-</span>t <span class="token operator">-</span>i container <span class="token operator">/</span>bin<span class="token operator">/</span>bash

</code></pre> 
<p><code>参见sreeninet.wordpress.com/2016/06/11/…。</code></p> 
<p><code>这里应该提到的是，只有在与映像具有相同架构的机器上运行 bash 才能在容器内运行。如果您在 PC 上试图窥探 raspberry pi 的图像文件系统，那么 bash 技巧将不起作用。</code></p> 
<p><code>@MaximKulkin 真的吗？如果容器是 Linux，那么主机是什么并不重要，如果 bash 可用。也许您正在考虑 Windows 容器？</code></p> 
<p><code>在极少数情况下，我只能在容器中未加载 bash 时输入 sh 提示。</code></p> 
<h2><a id="6_302"></a>答6:</h2> 
<blockquote> 
 <p>与HuntsBot一起，探索全球自由职业机会–huntsbot.com</p> 
</blockquote> 
<p>容器的文件系统在docker的data文件夹下，一般在/var/lib/docker。为了启动和检查正在运行的容器文件系统，请执行以下操作：</p> 
<pre><code class="prism language-java">hash<span class="token operator">=</span>$<span class="token punctuation">(</span>docker run busybox<span class="token punctuation">)</span>
cd <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib<span class="token operator">/</span>docker<span class="token operator">/</span>aufs<span class="token operator">/</span>mnt<span class="token operator">/</span>$hash

</code></pre> 
<p>现在当前工作目录是容器的根目录。</p> 
<p><code>不过，这不包括任何已安装的卷。</code></p> 
<h2><a id="7_319"></a>答7:</h2> 
<blockquote> 
 <p>HuntsBot周刊–不定时分享成功产品案例，学习他们如何成功建立自己的副业–huntsbot.com</p> 
</blockquote> 
<p>您可以使用 Dive 与 TUI 交互地查看图像内容</p> 
<p>https://github.com/wagoodman/dive</p> 
<p>https://i.stack.imgur.com/OLFEC.png</p> 
<p><code>潜水真的是完美的工具！</code></p> 
<h2><a id="8_330"></a>答8:</h2> 
<blockquote> 
 <p>保持自己快人一步,享受全网独家提供的一站式外包任务、远程工作、创意产品订阅服务–huntsbot.com</p> 
</blockquote> 
<p>尝试使用</p> 
<pre><code class="prism language-java">docker exec <span class="token operator">-</span>it  <span class="token operator">/</span>bin<span class="token operator">/</span>bash

</code></pre> 
<p>bash 可能没有实现。为此，您可以使用</p> 
<pre><code class="prism language-java">docker exec <span class="token operator">-</span>it  sh

</code></pre> 
<h2><a id="9_351"></a>答9:</h2> 
<blockquote> 
 <p>huntsbot.com精选全球7大洲远程工作机会，涵盖各领域，帮助想要远程工作的数字游民们能更精准、更高效的找到对方。</p> 
</blockquote> 
<p>在运行 Docker 1.3.1 的 Ubuntu 14.04 上，我在主机上的以下目录中找到了容器根文件系统：</p> 
<pre><code class="prism language-java"><span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib<span class="token operator">/</span>docker<span class="token operator">/</span>devicemapper<span class="token operator">/</span>mnt<span class="token comment">//rootfs/</span>

</code></pre> 
<p>完整的 Docker 版本信息：</p> 
<pre><code class="prism language-java"><span class="token class-name">Client</span> version<span class="token operator">:</span> <span class="token number">1.3</span><span class="token number">.1</span>
<span class="token class-name">Client</span> <span class="token constant">API</span> version<span class="token operator">:</span> <span class="token number">1.15</span>
<span class="token class-name">Go</span> version <span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token operator">:</span> go1<span class="token punctuation">.</span><span class="token number">3.3</span>
<span class="token class-name">Git</span> commit <span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">4e9</span>bbfa
<span class="token constant">OS</span><span class="token operator">/</span><span class="token class-name">Arch</span> <span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token operator">:</span> linux<span class="token operator">/</span>amd64
<span class="token class-name">Server</span> version<span class="token operator">:</span> <span class="token number">1.3</span><span class="token number">.1</span>
<span class="token class-name">Server</span> <span class="token constant">API</span> version<span class="token operator">:</span> <span class="token number">1.15</span>
<span class="token class-name">Go</span> version <span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token operator">:</span> go1<span class="token punctuation">.</span><span class="token number">3.3</span>
<span class="token class-name">Git</span> commit <span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">4e9</span>bbfa

</code></pre> 
<p><code>像魅力一样工作： name= dockerId=$(docker inspect -f {<!-- -->{.Id}} $name) /var/lib/docker/devicemapper/mnt/$dockerId/rootfs/</code></p> 
<p><code>不幸的是，在 Ubuntu 16.10 和 docker 1.12.1 中，情况不再如此（没有devicemapper目录）。该文件存在于 /var/lib/docker/overlay//... 下。我不确定在那里访问文件的便携性/安全性</code></p> 
<p><code>从 1.10 开始，Docker 引入了一种新的内容可寻址存储模型，它不使用随机生成的 UUID，就像以前用于层和容器标识符一样。在新模型中，这被层 id 的安全内容散列所取代。所以这种方法将不再有效。</code></p> 
<p><code>这不是可移植的，很大程度上取决于 storage driver 的选择。例如，不确定该解决方案是否适用于 direct-lvm。</code></p> 
<h2><a id="10_388"></a>答10:</h2> 
<blockquote> 
 <p>huntsbot.com汇聚了国内外优秀的初创产品创意，可按收入、分类等筛选，希望这些产品与实践经验能给您带来灵感。</p> 
</blockquote> 
<p>在我的情况下，除了 sh 之外，容器中不支持任何 shell。所以，这就像一个魅力</p> 
<pre><code class="prism language-java">docker exec <span class="token operator">-</span>it  sh

</code></pre> 
<p><code>谢谢，考虑到OP询问如何通过SSH进入容器，我觉得这应该更高。</code></p> 
<h2><a id="11_402"></a>答11:</h2> 
<blockquote> 
 <p>huntsbot.com高效搞钱，一站式跟进超10+任务平台外包需求</p> 
</blockquote> 
<p>我使用了另一个与 aufs/devicemapper 无关的肮脏技巧。</p> 
<p>我查看容器正在运行的命令，例如 docker ps，如果它是 apache 或 java，我只需执行以下操作：</p> 
<pre><code class="prism language-java">sudo <span class="token operator">-</span>s
cd <span class="token operator">/</span>proc<span class="token operator">/</span>$<span class="token punctuation">(</span>pgrep java<span class="token punctuation">)</span><span class="token operator">/</span>root<span class="token operator">/</span>

</code></pre> 
<p>瞧，你在容器里面。</p> 
<p>基本上，只要该进程由容器运行，您就可以作为根 cd 进入 /proc//root/ 文件夹。当心符号链接在使用该模式时没有意义。</p> 
<p><code>此处有关此方法的其他信息：superuser.com/a/1288058/195840</code></p> 
<p>原文链接：<a href="https://www.huntsbot.com/qa/br5D/exploring-docker-containers-file-system?lang=zh_CN&amp;from=csdn" rel="nofollow">https://www.huntsbot.com/qa/br5D/exploring-docker-containers-file-system?lang=zh_CN&amp;from=csdn</a></p> 
<blockquote> 
 <p>huntsbot.com汇聚了国内外优秀的初创产品创意，可按收入、分类等筛选，希望这些产品与实践经验能给您带来灵感。</p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/18651b6d018300b9acc29a175451ac08/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">（已解决）jar!/BOOT-INF/classes!/application.yml (No such file or directory)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/129d5585f472548765251f6d3f706588/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Xcode 项目的 Git 忽略文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>