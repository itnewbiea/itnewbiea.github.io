<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java】PriorityQueue优先级队列（堆）&#43;比较器详解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Java】PriorityQueue优先级队列（堆）&#43;比较器详解" />
<meta property="og:description" content="目录
铺垫
堆
建堆
基本公式
调整为大(小)根堆
堆的增加
堆的删除 正文：
比较
重写基类的equals()比较方法：
内部比较器——Comparable.compareTo(E o)：
外部比较器——Comparator.compare(T o1, T o2)：
源码粗略分析
常用构造方法
实现Comparable接口 实现Comparator接口
改为大根堆
对于基本类型：
对于引用类型：
比较器快速写法
铺垫 堆 优先级队列的底层是一个数组，但这个数组又比较特殊——二叉树通过层序遍历存放到该数组的数据。这样存放的方式就是堆这种数据结构。
大根堆：如果在堆中，每个根结点的值大于两个孩子结点的值。（对左右孩子无要求）
小根堆：如果在堆中，每个根结点的值小于两个孩子结点的值。（对左右孩子无要求）
建堆 基本公式 调整为大(小)根堆 在一个一维数组中：
1.对于每一个根结点都要调整为大小根堆。
2.调整时，先要找到较大的孩子
3.然后二者交换，继续向下调整该根结点下面的结点。
4.调整时可能会存在越界的情况，孩子结点可能会越界。
public void createHeap() { //建大根堆 //对每一个根节点使用向下调整算法 //最后一个孩子 c = length - 1 //c = 2 * p &#43;1 //p = (c - 1)/2 for (int parent = (array.length - 1 -1) / 2; parent &gt;= 0; parent--) { shiftDown(parent, usedSize); } } //向下调整 private void shiftDown(int parent, int length) { int child = 2 * parent &#43; 1; while (child &lt; length) { //先判断孩子是否越界 if (child &lt; length - 1 &amp;&amp; array[child] &lt; array[child &#43; 1]) { child&#43;&#43;; } if (array[parent] &lt; array[child]) { swap(array, parent, child); parent = child; child = 2 * parent &#43; 1; } else { break; } } } private void swap(int[] array, int x, int y) { int tmp = array[x]; array[x] = array[y]; array[y] = tmp; } 堆的增加 在堆里添加完数据后，应该还要保证堆为大(小)根堆。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c5ee77db43c8ecdf1abb06da65608433/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-21T00:08:56+08:00" />
<meta property="article:modified_time" content="2022-10-21T00:08:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java】PriorityQueue优先级队列（堆）&#43;比较器详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E9%93%BA%E5%9E%AB-toc" style="margin-left:0px;"><a href="#%E9%93%BA%E5%9E%AB" rel="nofollow">铺垫</a></p> 
<p id="%E5%A0%86-toc" style="margin-left:40px;"><a href="#%E5%A0%86" rel="nofollow">堆</a></p> 
<p id="%E5%BB%BA%E5%A0%86-toc" style="margin-left:40px;"><a href="#%E5%BB%BA%E5%A0%86" rel="nofollow">建堆</a></p> 
<p id="%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F" rel="nofollow">基本公式</a></p> 
<p id="%C2%A0%E8%B0%83%E6%95%B4%E4%B8%BA%E5%A4%A7(%E5%B0%8F)%E6%A0%B9%E5%A0%86-toc" style="margin-left:80px;"><a href="#%C2%A0%E8%B0%83%E6%95%B4%E4%B8%BA%E5%A4%A7%28%E5%B0%8F%29%E6%A0%B9%E5%A0%86" rel="nofollow">调整为大(小)根堆</a></p> 
<p id="%E5%A0%86%E7%9A%84%E5%A2%9E%E5%8A%A0-toc" style="margin-left:80px;"><a href="#%E5%A0%86%E7%9A%84%E5%A2%9E%E5%8A%A0" rel="nofollow">堆的增加</a></p> 
<p id="%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4%C2%A0" rel="nofollow">堆的删除 </a></p> 
<p id="%C2%A0%E6%AD%A3%E6%96%87%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%C2%A0%E6%AD%A3%E6%96%87%EF%BC%9A" rel="nofollow"> 正文：</a></p> 
<p id="%E6%AF%94%E8%BE%83-toc" style="margin-left:40px;"><a href="#%E6%AF%94%E8%BE%83" rel="nofollow">比较</a></p> 
<p id="%E9%87%8D%E5%86%99%E5%9F%BA%E7%B1%BB%E7%9A%84equals()%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E9%87%8D%E5%86%99%E5%9F%BA%E7%B1%BB%E7%9A%84equals%28%29%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow">重写基类的equals()比较方法：</a></p> 
<p id="%E5%86%85%E9%83%A8%E6%AF%94%E8%BE%83%E5%99%A8%E2%80%94%E2%80%94Comparable%3CE%3E.compareTo(E%20o)%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%86%85%E9%83%A8%E6%AF%94%E8%BE%83%E5%99%A8%E2%80%94%E2%80%94Comparable%3CE%3E.compareTo%28E%20o%29%EF%BC%9A" rel="nofollow">内部比较器——Comparable.compareTo(E o)：</a></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<p id="%E5%A4%96%E9%83%A8%E6%AF%94%E8%BE%83%E5%99%A8%E2%80%94%E2%80%94Comparator%3CT%3E.compare(T%C2%A0o1%2C%20T%C2%A0o2)%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%A4%96%E9%83%A8%E6%AF%94%E8%BE%83%E5%99%A8%E2%80%94%E2%80%94Comparator%3CT%3E.compare%28T%C2%A0o1%2C%20T%C2%A0o2%29%EF%BC%9A" rel="nofollow">外部比较器——Comparator.compare(T o1, T o2)：</a></p> 
<p id="%E6%BA%90%E7%A0%81%E7%B2%97%E7%95%A5%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E6%BA%90%E7%A0%81%E7%B2%97%E7%95%A5%E5%88%86%E6%9E%90" rel="nofollow">源码粗略分析</a></p> 
<p id="%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" rel="nofollow">常用构造方法</a></p> 
<p id="%E5%AE%9E%E7%8E%B0Comparable%E6%8E%A5%E5%8F%A3%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%AE%9E%E7%8E%B0Comparable%E6%8E%A5%E5%8F%A3%C2%A0" rel="nofollow">实现Comparable接口 </a></p> 
<p id="%E5%AE%9E%E7%8E%B0Comparator%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%E5%AE%9E%E7%8E%B0Comparator%E6%8E%A5%E5%8F%A3" rel="nofollow">实现Comparator接口</a></p> 
<p id="%C2%A0%E6%94%B9%E4%B8%BA%E5%A4%A7%E6%A0%B9%E5%A0%86-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%94%B9%E4%B8%BA%E5%A4%A7%E6%A0%B9%E5%A0%86" rel="nofollow">改为大根堆</a></p> 
<p id="%E5%AF%B9%E4%BA%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%AF%B9%E4%BA%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%EF%BC%9A" rel="nofollow">对于基本类型：</a></p> 
<p id="%C2%A0%E5%AF%B9%E4%BA%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%AF%B9%E4%BA%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9A" rel="nofollow">对于引用类型：</a></p> 
<p id="%E6%AF%94%E8%BE%83%E5%99%A8%E5%BF%AB%E9%80%9F%E5%86%99%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E6%AF%94%E8%BE%83%E5%99%A8%E5%BF%AB%E9%80%9F%E5%86%99%E6%B3%95" rel="nofollow">比较器快速写法</a></p> 
<hr> 
<h2 id="%E9%93%BA%E5%9E%AB">铺垫</h2> 
<h3 id="%E5%A0%86">堆</h3> 
<p>优先级队列的底层是一个<strong>数组</strong>，但这个数组又比较特殊——<strong>二叉树通过层序遍历存放到该数组的数据</strong>。这样存放的方式就是<strong>堆</strong>这种数据结构。</p> 
<p><strong>大根堆</strong>：如果在堆中，每个根结点的值大于两个孩子结点的值。（对左右孩子无要求）</p> 
<p><strong>小根堆</strong>：如果在堆中，每个根结点的值小于两个孩子结点的值。（对左右孩子无要求）</p> 
<hr> 
<h3 id="%E5%BB%BA%E5%A0%86">建堆</h3> 
<h4 id="%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F">基本公式</h4> 
<p><img alt="" height="425" src="https://images2.imgbox.com/59/d0/IBExiMFc_o.png" width="1174"></p> 
<h4 id="%C2%A0%E8%B0%83%E6%95%B4%E4%B8%BA%E5%A4%A7(%E5%B0%8F)%E6%A0%B9%E5%A0%86">调整为大(小)根堆</h4> 
<blockquote> 
 <p>在一个一维数组中：</p> 
 <p>1.对于每一个根结点都要调整为大小根堆。</p> 
 <p>2.调整时，先要找到较大的孩子</p> 
 <p>3.然后二者交换，继续向下调整该根结点下面的结点。</p> 
 <p>4.调整时可能会存在越界的情况，孩子结点可能会越界。</p> 
</blockquote> 
<pre><code class="language-java">    public void createHeap() {
        //建大根堆
        //对每一个根节点使用向下调整算法
        //最后一个孩子 c = length - 1
        //c = 2 * p +1
        //p = (c - 1)/2
        for (int parent = (array.length - 1 -1) / 2; parent &gt;= 0; parent--) {
            shiftDown(parent, usedSize);
        }
    }
    //向下调整
    private void shiftDown(int parent, int length) {
        int child = 2 * parent + 1;
        while (child &lt; length) {
               //先判断孩子是否越界
            if (child &lt; length - 1 &amp;&amp; array[child] &lt; array[child + 1]) {
                child++;
            }
            if (array[parent] &lt; array[child]) {
                swap(array, parent, child);
                parent = child;
                child = 2 * parent + 1;
            } else {
                break;
            }
        }
    }

    private void swap(int[] array, int x, int y) {
        int tmp = array[x];
        array[x] = array[y];
        array[y] = tmp;
    }</code></pre> 
<h4 id="%E5%A0%86%E7%9A%84%E5%A2%9E%E5%8A%A0">堆的增加</h4> 
<p>在堆里添加完数据后，应该还要保证堆为大(小)根堆。</p> 
<blockquote> 
 <p>1.判断堆是否满了，满了扩容。</p> 
 <p>2.把添加的数据放到数组的最后面。</p> 
 <p>3.找到最后一个结点的父亲结点，向上调整。</p> 
 <p>4.(建大堆)如果父亲结点比孩子结点小，就调整，然后，父亲结点指向孩子结点，重新计算父亲结点，直到最后一个孩子调整完。</p> 
 <p>5.useSized++</p> 
</blockquote> 
<p> </p> 
<h4 id="%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4%C2%A0">堆的删除 </h4> 
<p>优先级队列，是对于某些数据优先操作的结构，所以很自然的我们要优先对堆顶数据进行删除。</p> 
<blockquote> 
 <p>1.判断堆是否为空，为空抛出异常。</p> 
 <p>2.堆顶数据与最后一个结点进行交换。</p> 
 <p>3.对堆顶使用一次向下调整即可恢复成大(小)根堆。</p> 
 <p>4.useSized--</p> 
</blockquote> 
<pre><code class="language-java">    public void pop() {
        if (isEmpty()) {
            return;
        }
        swap(array, 0, usedSize - 1);
        usedSize--;
        shiftDown(0, usedSize);
    }</code></pre> 
<hr> 
<h2 id="%C2%A0%E6%AD%A3%E6%96%87%EF%BC%9A"> 正文：</h2> 
<p>有了以上概念，我们就能更容易理解PriorityQueue的源码部分的实现。</p> 
<h3 id="%E6%AF%94%E8%BE%83">比较</h3> 
<p>在生成大小根堆的时候，数据是<strong>通过比较大小</strong>来排序的。所以PriorityQueue底层必定有比较数据大小的东西。</p> 
<p></p> 
<h4 id="%E9%87%8D%E5%86%99%E5%9F%BA%E7%B1%BB%E7%9A%84equals()%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95%EF%BC%9A"><strong>重写基类的equals()比较方法</strong>：</h4> 
<p>所有的类都是继承Object类的，Object类中就有equals()方法。</p> 
<p>重写equals()方法用到这里显然不合适，因为该方法只能比较二者是否想等，<strong>无法比较出大小关系</strong>。</p> 
<p></p> 
<h4 id="%E5%86%85%E9%83%A8%E6%AF%94%E8%BE%83%E5%99%A8%E2%80%94%E2%80%94Comparable%3CE%3E.compareTo(E%20o)%EF%BC%9A"><strong>内部比较器——Comparable&lt;E&gt;.compareTo(E o)：</strong></h4> 
<p>Comparable是JDK提供的泛型接口类，源码如下：</p> 
<pre><code class="language-java">//Compareble是java.lang中的接口类，可以直接使用
public interface Comparable&lt;E&gt; {
    // 返回值:
    // &lt; 0: 表示 this 指向的对象小于形参 o 指向的对象
    // == 0: 表示 this 指向的对象等于形参 o 指向的对象
    // &gt; 0: 表示 this 指向的对象大于形参 o 指向的对象
    int compareTo(E o);
}

//对象支持自己与自己比较
//实现了该接口的类就可以自动进行排序
//集合通过Collection.sort()排序，数组通过Arrays.sort()进行排序</code></pre> 
<p>该方法可以比较出数据的大小，所以我们可以在<strong>定义类的时候实现该接口，重写方法</strong>就可以比较。</p> 
<h4></h4> 
<h4 id="%E5%A4%96%E9%83%A8%E6%AF%94%E8%BE%83%E5%99%A8%E2%80%94%E2%80%94Comparator%3CT%3E.compare(T%C2%A0o1%2C%20T%C2%A0o2)%EF%BC%9A">外部比较器——Comparator&lt;T&gt;.compare(T o1, T o2)：</h4> 
<pre><code class="language-java">//Comparator是java.util 包中的泛型接口类，使用时必须导入对应的包

public interface Comparator&lt;T&gt; {
// 返回值:
// &lt; 0: 表示 o1 指向的对象小于 o2 指向的对象
// == 0: 表示 o1 指向的对象等于 o2 指向的对象
// &gt; 0: 表示 o1 指向的对象等于 o2 指向的对象
int compare(T o1, T o2);
}

//使用Comparator的情况：
//1.没有实现Comparable接口
//2.实现了Comparable接口，但是其中的compareTo方法不符合自己的预期
</code></pre> 
<p><img alt="" height="370" src="https://images2.imgbox.com/30/07/BhX854if_o.png" width="1200"></p> 
<hr> 
<h3 id="%E6%BA%90%E7%A0%81%E7%B2%97%E7%95%A5%E5%88%86%E6%9E%90">源码粗略分析</h3> 
<pre><code class="language-java">    public static void main(String[] args) {
        PriorityQueue&lt;Integer&gt;  priorityQueue1= new PriorityQueue&lt;&gt;();
        priorityQueue1.offer(4);
        priorityQueue1.offer(6);
        priorityQueue1.offer(3);
        System.out.println(priorityQueue1);
    }</code></pre> 
<p><img alt="" height="96" src="https://images2.imgbox.com/1e/1d/ZvGluIz7_o.png" width="495"></p> 
<p> </p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/5f/a0/8qmsCffO_o.png" width="1200"></p> 
<p>若是其他引用类型，就不可以这样offer()了，在offer()第二个数据的时候就会抛异常。</p> 
<pre><code class="language-java">class Student {
    public String name;
    public int age;

    public Student (int age) {
        this.age = age;
    }
}

public class Test {
    public static void main(String[] args) {
        PriorityQueue&lt;Integer&gt;  priorityQueue1= new PriorityQueue&lt;&gt;();
        priorityQueue1.offer(4);
        priorityQueue1.offer(6);
        priorityQueue1.offer(3);
        System.out.println(priorityQueue1);

        PriorityQueue&lt;Student&gt;  priorityQueue2 = new PriorityQueue&lt;&gt;();
        priorityQueue2.offer(new Student(20));
        priorityQueue2.offer(new Student(22));
    }
}</code></pre> 
<p><img alt="" height="302" src="https://images2.imgbox.com/80/5b/SZKHGKnf_o.png" width="1200"></p> 
<hr> 
<h4 id="%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">常用构造方法</h4> 
<blockquote> 
 <p>第一种：什么都不传，那么默认空间大小为11，无比较器</p> 
</blockquote> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="138" src="https://images2.imgbox.com/a4/af/LLEC5vhS_o.png" width="897"></h4> 
<blockquote> 
 <p>第二种：只传空间大小，此时空间大小为所传的值</p> 
</blockquote> 
<p><img alt="" height="131" src="https://images2.imgbox.com/6c/cf/6aYyLWvh_o.png" width="703"></p> 
<blockquote> 
 <p>第三种：只传比较器，下面详解比较器作用</p> 
</blockquote> 
<p><img alt="" height="131" src="https://images2.imgbox.com/65/f4/CDdhHfYO_o.png" width="703"></p> 
<hr> 
<h3 id="%E5%AE%9E%E7%8E%B0Comparable%E6%8E%A5%E5%8F%A3%C2%A0">实现Comparable接口 </h3> 
<pre><code class="language-java">class Student implements Comparable&lt;Student&gt; {
    public String name;
    public int age;

    public Student (int age) {
        this.age = age;
    }

    @Override
    public int compareTo(Student o) {
        return this.age - o.age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}

public class Test {
    public static void main(String[] args) {
        PriorityQueue&lt;Integer&gt;  priorityQueue1= new PriorityQueue&lt;&gt;();
        priorityQueue1.offer(4);
        priorityQueue1.offer(6);
        priorityQueue1.offer(3);
        System.out.println(priorityQueue1);

        PriorityQueue&lt;Student&gt;  priorityQueue2 = new PriorityQueue&lt;&gt;();
        priorityQueue2.offer(new Student(20));
        priorityQueue2.offer(new Student(22));
        priorityQueue2.offer(new Student(23));
        System.out.println(priorityQueue2);
    }
}</code></pre> 
<p><img alt="" height="234" src="https://images2.imgbox.com/76/25/WXb0m5HL_o.png" width="1200"></p> 
<p> 当实现了Comparable接口后，重写CompareTo方法后，此时就可以比较引用类型了。</p> 
<p>此时它应该执行到一下源码部分。</p> 
<p><img alt="" height="622" src="https://images2.imgbox.com/81/59/FyUZfZSX_o.png" width="1200"></p> 
<h3 id="%E5%AE%9E%E7%8E%B0Comparator%E6%8E%A5%E5%8F%A3">实现Comparator接口</h3> 
<pre><code class="language-java">class Student {
    public String name;
    public int age;

    public Student (int age) {
        this.age = age;
    }


    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
class StuCompare implements Comparator&lt;Student&gt; {
    @Override
    public int compare(Student o1, Student o2) {
        return o2.age - o1.age;
    }
}

public class Test {
    public static void main(String[] args) {
        PriorityQueue&lt;Integer&gt;  priorityQueue1= new PriorityQueue&lt;&gt;();
        priorityQueue1.offer(4);
        priorityQueue1.offer(6);
        priorityQueue1.offer(3);
        System.out.println(priorityQueue1);

        PriorityQueue&lt;Student&gt;  priorityQueue2 = new PriorityQueue&lt;&gt;(new StuCompare());
        priorityQueue2.offer(new Student(20));
        priorityQueue2.offer(new Student(22));
        priorityQueue2.offer(new Student(23));
        System.out.println(priorityQueue2);
    }
}</code></pre> 
<p>通过自定义的比较器，并且通过传入比较器的构造方法后，我们也可以比较。</p> 
<p>此时它应该执行到下面的源码部分。</p> 
<p><img alt="" height="528" src="https://images2.imgbox.com/7d/21/UQnTwQ7z_o.png" width="847"></p> 
<hr> 
<h3 id="%C2%A0%E6%94%B9%E4%B8%BA%E5%A4%A7%E6%A0%B9%E5%A0%86">改为大根堆</h3> 
<p>因为源码默认建小根堆，如果我们想建大根堆，有了以上源码分析，我们不难发现，关键就在比较器上，我们只需要改变比较规则，就可以建立大根堆。</p> 
<h4 id="%E5%AF%B9%E4%BA%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%EF%BC%9A"><strong>对于基本类型：</strong></h4> 
<p>比如Integer，我们无法到源码中改变比较规则，所以只能传比较器，这样会优先使用有比较器的方法。</p> 
<pre><code class="language-java">class IntCompare implements Comparator&lt;Integer&gt; {
    @Override
    public int compare (Integer o1, Integer o2) {
        return o2.compareTo(o1);
    }
}
public class Test {
    public static void main(String[] args) {
        PriorityQueue&lt;Integer&gt;  priorityQueue1= new PriorityQueue&lt;&gt;(new IntCompare());
        priorityQueue1.offer(4);
        priorityQueue1.offer(6);
        priorityQueue1.offer(3);
        System.out.println(priorityQueue1);
    }
}</code></pre> 
<p><img alt="" height="137" src="https://images2.imgbox.com/a2/85/gGOLMkhF_o.png" width="527"> </p> 
<h4 id="%C2%A0%E5%AF%B9%E4%BA%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9A"><strong>对于引用类型：</strong></h4> 
<p>若该引用类型实现了Comparable接口，我们直接修改compareTo</p> 
<p>若没有，则修改比较器中的compare</p> 
<pre><code class="language-java">    class Student implements Comparable&lt;Student&gt; {
    public String name;
    public int age;

    public Student (int age) {
        this.age = age;
    }

    @Override
    public int compareTo(Student o) {
        return o.age - this.age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
        }
    }



public class Test {
    public static void main(String[] args) {
        PriorityQueue&lt;Student&gt;  priorityQueue2 = new PriorityQueue&lt;&gt;();
        priorityQueue2.offer(new Student(20));
        priorityQueue2.offer(new Student(22));
        priorityQueue2.offer(new Student(23));
        System.out.println(priorityQueue2);
    }
}</code></pre> 
<p> ​​​​​<img alt="" height="141" src="https://images2.imgbox.com/ad/c8/EL04UTnf_o.png" width="1200"></p> 
<p> </p> 
<pre><code class="language-java">class Student {
    public String name;
    public int age;

    public Student (int age) {
        this.age = age;
    }


    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}

class StuCompare implements Comparator&lt;Student&gt; {
    @Override
    public int compare(Student o1, Student o2) {
        return o2.age - o1.age;
    }
}

public class Test {
    public static void main(String[] args) {
        PriorityQueue&lt;Student&gt;  priorityQueue2 = new PriorityQueue&lt;&gt;(new StuCompare());
        priorityQueue2.offer(new Student(20));
        priorityQueue2.offer(new Student(22));
        priorityQueue2.offer(new Student(23));
        System.out.println(priorityQueue2);
    }
}</code></pre> 
<p><img alt="" height="141" src="https://images2.imgbox.com/ed/be/pGmc6SuQ_o.png" width="1200"></p> 
<hr> 
<h3 id="%E6%AF%94%E8%BE%83%E5%99%A8%E5%BF%AB%E9%80%9F%E5%86%99%E6%B3%95">比较器快速写法</h3> 
<pre><code class="language-java">class Student {
    public String name;
    public int age;

    public Student (int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}

public class Test {
    public static void main(String[] args) {
        //这里直接new了一个比较器传过去了
        PriorityQueue&lt;Student&gt;  priorityQueue2 = new PriorityQueue&lt;&gt;(new Comparator&lt;Student&gt;() {
            @Override
            public int compare(Student o1, Student o2) {
                return o1.age - o2.age;
            }
        });
        priorityQueue2.offer(new Student(20));
        priorityQueue2.offer(new Student(22));
        priorityQueue2.offer(new Student(23));
        System.out.println(priorityQueue2);
    }

    public static void main1(String[] args) {
        MyPriorityQueue heap = new MyPriorityQueue();
        int[] arr = {27, 15, 19, 18, 28, 34, 65, 49, 25, 37};
        heap.initArray(arr);
        heap.createHeap();
        heap.push(100);
        //heap.pop();

        PriorityQueue&lt;Integer&gt;  priorityQueue1= new PriorityQueue&lt;&gt;();
        priorityQueue1.offer(4);
        priorityQueue1.offer(6);
        priorityQueue1.offer(3);
        System.out.println(priorityQueue1);

    }
}</code></pre> 
<p>有什么错误评论区指出，希望可以帮到你。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b27c0a2c4b2d108e004fea3f14d6975e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Epoll图解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7462e06b0df62ff5f5edea1e98c6c9ea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言基本语法——循环篇（三种常见的循环）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>