<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言中常用的几个头文件及库函数 (stdio.h ,string.h ,math.h ,stdlib.h) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言中常用的几个头文件及库函数 (stdio.h ,string.h ,math.h ,stdlib.h)" />
<meta property="og:description" content="（参考：https://www.jb51.net/article/124594.htm）
#include&lt;stdio.h&gt; 或 #include&#34;stdio.h&#34;
用#include&lt;stdio.h&gt;形式时，编译系统从存放C编译系统的子目录中去找所包含的文件stdio.h，这称为标准方式。
用#include&#34;stdio.h&#34;形式时，编译系统先在用户的当前目录(用户存放源程序文件的子目录)中寻找stdio.h，若找不到，再按标准方式查找。如果该头文件不在当前目录，可加入路径如（#include &#34;C:\temp\file1.h&#34;）。
不完全统计，C语言标准库中的头文件有15个之多，所以我主要介绍常用的这四个头文件stdio.h ,string.h ,math.h ,stdlib.h ，以后用到其他的再做补充。下面上干货：
1.&lt;stdio.h&gt;：定义了（standard input &amp; output的缩写）输入输出函数、类型以及宏，函数几乎占了标准库的1/3。 （1）文件访问。
1
FILE *fopen（“filename”，“mode”）：
以mode模式打开地址为&#39;filename&#39;的文件，并返回文件指针。
访问模式主要是“r”：只读； “w” ：只写，并删除已有内容； “a”：追加，在末尾追加；
“r&#43;”， “w&#43;”：读写； “a&#43;”追加，上述结尾加“b”：二进制文件操作。
注意：其中r是打开文件，而w会创建（如果文件不存在）； w会覆盖原有内容，a则是在原有文件末尾追加。
FILE *fp ; / 定义一个指向文件的指针变量fp fp = fopen(&#34;a1&#34;,&#34;r&#34;); / 将fopen函数的返回值(a1文件信息区的起始地址)赋给指针变量fp 表示要打开名字为“a1”的文件，使用文件方式为&#34;r&#34;读入。 2
int fclose（FILE *f）：
fclose(文件指针); 释放缓冲区数据，关闭流。如：fclose(fp); 前面曾把打开文件(用fopen函数)时函数返回的指针赋给了fp，现在把fp指向的文件关闭，此后fp不再指向该文件。当成功执行操作，则返回值为0，否则返回EOF(-1)。
下面两个没太用过：
1
FILE *freopen（“filename”，“mode”，FILE * f）：
以mode模式打开地址为&#39;filename&#39;的文件，并将该文件与流f2关联。
1
int fflush（FILE *f）：
将已写到缓冲区但未写入文件中的所有数据写入文件中。
（2）二进制输入/输出
1
fread（*ptr，size，n，FILE* f）：
从f中读取n个长度为size的对象，并放入ptr指向的数组中。
1
fwrite（*ptr，size，n，FILE* f）：
从ptr指向数组中读取n个长度为size的对象，并写入f中。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6d9e3806a2bd9cbdf1968980749ccacd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-07T12:14:59+08:00" />
<meta property="article:modified_time" content="2018-11-07T12:14:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言中常用的几个头文件及库函数 (stdio.h ,string.h ,math.h ,stdlib.h)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>（参考：<a href="https://www.jb51.net/article/124594.htm" rel="nofollow">https://www.jb51.net/article/124594.htm</a>）</p> 
<p>    <strong> #include&lt;stdio.h&gt; 或 #include"stdio.h"</strong></p> 
<p><strong>     用#include&lt;stdio.h&gt;形式时，编译系统从存放C编译系统的子目录中去找所包含的文件stdio.h，这称为标准方式。</strong></p> 
<p><strong>     用#include"stdio.h"形式时，编译系统先在用户的当前目录(用户存放源程序文件的子目录)中寻找stdio.h，若找不到，再按标准方式查找。如果该头文件不在当前目录，可加入路径如（#include "C:\temp\file1.h"）。</strong></p> 
<p> </p> 
<p>不完全统计，C语言标准库中的头文件有15个之多，所以我主要介绍常用的这四个头文件<strong>stdio.h </strong>,<strong>string.h ,math.h ,stdlib.h </strong>，以后用到其他的再做补充。下面上干货：</p> 
<h4><u><strong>1<span style="color:#e579b6;">.&lt;stdio.h&gt;</span></strong></u><strong>：定义了（standard input &amp; output的缩写）输入输出函数、类型以及宏，函数几乎占了标准库的1/3。</strong></h4> 
<p><span style="color:#3399ea;"><strong>（1）文件访问。</strong></span></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:35px;"> <p><strong>1</strong></p> </td><td> <p><strong><code>FILE</code> <code>*</code><span style="color:#f33b45;"><code>fopen</code></span><code>（“filename”，“mode”）：</code></strong></p> </td></tr></tbody></table> 
<p>以mode模式打开地址为'filename'的文件，并返回文件指针。</p> 
<p>访问模式主要是“r”：只读；   “w” ：只写，并删除已有内容；  “a”：追加，在末尾追加；</p> 
<p> “r+”， “w+”：读写； “a+”追加，上述结尾加“b”：二进制文件操作。</p> 
<p>注意：其中r是打开文件，而w会创建（如果文件不存在）；  w会覆盖原有内容，a则是在原有文件末尾追加。</p> 
<pre class="has"><code class="language-cpp">FILE *fp ;                    / 定义一个指向文件的指针变量fp
fp = fopen("a1","r");         / 将fopen函数的返回值(a1文件信息区的起始地址)赋给指针变量fp
表示要打开名字为“a1”的文件，使用文件方式为"r"读入。</code></pre> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:36px;"> <p><strong>2</strong></p> </td><td> <p><strong><code>int</code> <span style="color:#f33b45;"><code>fclose</code></span><code>（</code><code>FILE</code> <code>*f）：</code></strong></p> </td></tr></tbody></table> 
<p>fclose(文件指针); 释放缓冲区数据，关闭流。如：fclose(fp); 前面曾把打开文件(用fopen函数)时函数返回的指针赋给了fp，现在把fp指向的文件关闭，此后fp不再指向该文件。当成功执行操作，则返回值为0，否则返回EOF(-1)。</p> 
<p>下面两个没太用过：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:42px;"> <p><strong>1</strong></p> </td><td> <p><strong><code>FILE</code> <code>*</code><span style="color:#f33b45;"><code>freopen</code></span><code>（“filename”，“mode”，</code><code>FILE</code> <code>* f）：</code></strong></p> </td></tr></tbody></table> 
<p>以mode模式打开地址为'filename'的文件，并将该文件与流f2关联。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:44px;"> <p><strong>1</strong></p> </td><td> <p><strong><code>int</code> <span style="color:#f33b45;"><code>fflush</code></span><code>（</code><code>FILE</code> <code>*f）：</code></strong></p> </td></tr></tbody></table> 
<p>将已写到缓冲区但未写入文件中的所有数据写入文件中。</p> 
<p><strong><span style="color:#3399ea;">（2）二进制输入/输出</span></strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:45px;"> <p><strong>1</strong></p> </td><td> <p><strong><span style="color:#f33b45;"><code>fread</code></span><code>（*ptr，size，n，</code><code>FILE</code><code>* f）：</code></strong></p> </td></tr></tbody></table> 
<p>从f中读取n个长度为size的对象，并放入ptr指向的数组中。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:46px;"> <p><strong>1</strong></p> </td><td> <p><strong><span style="color:#f33b45;"><code>fwrite</code></span><code>（*ptr，size，n，</code><code>FILE</code><code>* f）：</code></strong></p> </td></tr></tbody></table> 
<p>从ptr指向数组中读取n个长度为size的对象，并写入f中。</p> 
<p>注意：要注意write与read的对象，读和写都是针对文件流f的。</p> 
<p><strong><span style="color:#3399ea;">（3）非格式化输入/输出</span></strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:52px;"> <p>1</p> </td><td> <p><code>int</code> <span style="color:#f33b45;"><code>fgetc</code></span><code>/</code><span style="color:#f33b45;"><code>getc</code></span><code>（</code><code>FILE</code> <code>*f）：</code></p> </td></tr></tbody></table> 
<p>返回流f 的下一个字符，到达文件末尾/发生错误，则返回EOF。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:49px;"> <p>1</p> </td><td> <p><code>int</code> <span style="color:#f33b45;"><code>fputc</code></span><code>/</code><span style="color:#f33b45;"><code>putc</code></span><code>（</code><code>int</code> <code>c， </code><code>FILE</code> <code>*f）</code></p> </td></tr></tbody></table> 
<p>将字符c输入到流f中。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:48px;"> <p>1</p> </td><td> <p><code>int</code> <span style="color:#f33b45;"><code>fgets</code></span><code>（</code><code>char</code> <code>* s，</code><code>int</code> <code>n，</code><code>FILE</code> <code>*f）：</code></p> </td></tr></tbody></table> 
<p>将f中下n-1个字符读入到数组s中。遇到换行符，则终止。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:44px;"> <p>1</p> </td><td> <p><code>int</code> <span style="color:#f33b45;"><code>fputs</code></span><code>（</code><code>const</code> <code>char</code> <code>* s，</code><code>FILE</code> <code>*f）：</code></p> </td></tr></tbody></table> 
<p>将字符串s输出到流中。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:45px;"> <p>1</p> </td><td> <p><code>int</code> <code><span style="color:#f33b45;">unget</span>（</code><code>int</code> <code>c， </code><code>FILE</code> <code>*f）</code></p> </td></tr></tbody></table> 
<p>将c写回到f中。</p> 
<p><strong><span style="color:#3399ea;">（4）格式化输入/输出</span></strong></p> 
<p>按一定格式转输出。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:50px;"> <p>1</p> <p>2</p> </td><td> <p><span style="color:#f33b45;"><code>scanf</code></span><code>/</code><span style="color:#f33b45;"><code>fscanf</code></span><code>/</code><span style="color:#f33b45;"><code>sscanf</code></span></p> <p><span style="color:#f33b45;"><code>printf</code></span><code>/</code><span style="color:#f33b45;"><code>fprintf</code></span><code>/</code><span style="color:#f33b45;"><code>sprintf</code></span></p> </td></tr></tbody></table> 
<p>注意：1，不加f/s，则是格式字符串标准输入/出函数，输入/出到终端/屏幕；</p> 
<p>         <strong> printf(格式控制，输出形式)；</strong>     例：printf( "%d , %c\n" , i , c);</p> 
<p><span style="color:#f33b45;">                                                                   printf</span>（const char *format，...）</p> 
<p>2，加s，输入/出到字符串中。<span style="color:#f33b45;">sprintf</span>（char *s，const char *format，...）,</p> 
<p>3，加f，输入/出到文件流中。  <span style="color:#f33b45;">fprintf</span>（FILE *f，const char *format，...）</p> 
<p>         <strong> scanf(格式控制，地址表列);</strong>     例：scanf("a=%f,b=%f,c=%f" ,&amp;a, &amp;b ,&amp;c);</p> 
<p>         <strong> putchar (c);  输出一个字符</strong></p> 
<p>          <strong> getchar ( );  输入一个字符</strong></p> 
<p><span style="color:#3399ea;"><strong>（5）文件定位</strong></span></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:44px;"> <p>1</p> </td><td> <p><span style="color:#3399ea;"><code>long</code></span> <span style="color:#f33b45;"><code>ftell</code></span><code>（</code><code>FILE</code> <code>*f）：</code></p> </td></tr></tbody></table> 
<p>返回当前指针位置。错误时返回-1L。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:48px;"> <p>1</p> </td><td> <p><span style="color:#3399ea;"><code>int</code></span> <span style="color:#f33b45;"><code>fseek</code></span><code>（</code><code>FILE</code> <code>*f，</code><code>long</code> <code>offset，</code><code>int</code> <code>origin）：</code></p> </td></tr></tbody></table> 
<p>将当前流f指针位置设置到：origin后offset个字符处。origin有：SEEK_SET：文件起始位置；SEEK_CUR指针当前位置，SEEK_END：文件结束位置。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:49px;"> <p>1</p> </td><td> <p><code>void</code> <span style="color:#f33b45;"><code>rewind</code></span><code>（</code><code>FILE</code> <code>*f）</code></p> </td></tr></tbody></table> 
<p>指针返回文件开始位置，相当于：fseek（f，0L，SEEK_SET）</p> 
<p>不常用：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:54px;"> <p>1</p> </td><td> <p><code>int</code><span style="color:#f33b45;"> <code>fgetpos</code></span><code>（</code><code>FILE</code> <code>*f，*p）</code></p> </td></tr></tbody></table> 
<p>将指针当前位置记录到*p中，以供fsetpos函数使用。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:54px;"> <p>1</p> </td><td> <p><code>int</code> <span style="color:#f33b45;"><code>fsetpos</code></span><code>（</code><code>FILE</code> <code>*f，</code><code>const</code> <code>*p）</code></p> </td></tr></tbody></table> 
<p>指针位置指向*p。</p> 
<p><strong><span style="color:#3399ea;">（6）错误处理与文件操作</span></strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:55px;"> <p>1</p> </td><td> <p><code>int</code> <span style="color:#f33b45;"><code>feof</code></span><code>（</code><code>FILE</code> <code>*f）</code></p> </td></tr></tbody></table> 
<p>指示文件结束，一直返回0，结束时返回非0值。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:55px;"> <p>1</p> </td><td> <p><code>int</code> <span style="color:#f33b45;"><code>ferror</code></span><code>（</code><code>FILE</code> <code>*f）</code></p> </td></tr></tbody></table> 
<p>如果设置了与f相关的错误指示符，则返回一个非0值。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:60px;"> <p>1</p> </td><td> <p><code>int</code> <span style="color:#f33b45;"><code>remove</code></span><code>（</code><code>char</code> <code>*filename）</code></p> </td></tr></tbody></table> 
<p>删除指定位置的文件。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:60px;"> <p>1</p> </td><td> <p><code>int</code> <span style="color:#f33b45;"><code>rename</code></span><code>（</code><code>const</code> <code>char</code> <code>*oldname，</code><code>const</code> <code>char</code> <code>*newname）</code></p> </td></tr></tbody></table> 
<p>改文件名，否则返回非0值。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:58px;"> <p>1</p> </td><td> <p><code>FILE</code> <code>*</code><span style="color:#f33b45;"><code>tmpfile</code></span><code>（</code><code>void</code><code>）</code></p> </td></tr></tbody></table> 
<p>建立临时文件，‘wb+'模式，在被关闭或程序正常结束时自动删除</p> 
<p> </p> 
<h4><u><strong>2. <span style="color:#e579b6;">&lt;string.h&gt;</span></strong></u><span style="color:#e579b6;"> </span><strong>分成两组，一组str开头，一组mem开头（该组函数在&lt;memory.h&gt;中也有定义，不是所有编译器都有）</strong></h4> 
<p><span style="color:#7c79e5;"><strong>（1）str</strong></span></p> 
<p><strong>      puts(字符数据);      </strong><span style="color:#ffbb66;"><strong> 输出字符串函数</strong></span></p> 
<p><strong>       </strong>例：char str[]="china";    puts(str);</p> 
<p><strong>       gets(字符数组);    </strong><span style="color:#ffbb66;"><strong> 输入字符串函数</strong></span></p> 
<p><strong>        </strong>例：gets(str);</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:26px;"> <p>1</p> </td><td> <p><code>char</code> <code>* </code><strong><span style="color:#f33b45;"><code>strcpy</code></span></strong> <code>(</code><code>char</code> <code>*dest, </code><code>const</code> <code>char</code> <code>*src); //<strong><span style="color:#ffbb66;">字符串复制函数</span></strong>，把字符串2和后面的'\0'复制到字符数组1中。</code></p> <p><code>例：char str1[10],str2[]="china";    strcpy(str1,str2); 注：str1必须<strong>够大</strong>，以便能放下str2</code></p> </td></tr></tbody></table> 
<p>将字符串src复制到字符串dest中（包括'\0'），返回dest</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:28px;"> <p>1</p> </td><td> <p><code>char</code> <code>*<strong> </strong></code><span style="color:#f33b45;"><strong><code>strncpy</code></strong> </span><code>(</code><code>char</code> <code>*dest, </code><code>const</code> <code>char</code> <code>*src，n); //<span style="color:#ffbb66;"><strong>字符串复制函数</strong></span>，将字符串2中前面的n个字符复制到字符数组1中,n必须少于str1的字符，不包括('\0')。</code></p> <p><code>例：char str1[10],str2[]="china"; strncpy(str1, str2, 2)  输出结果为str1="ch"</code></p> </td></tr></tbody></table> 
<p>将src中的前n个字符复制到dest中，返回dest，不够n个则补‘\0'</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td rowspan="2"> <p><code>char</code> <code>* </code><strong><span style="color:#f33b45;"><code>strcat</code></span></strong> <code>(</code><code>char</code> <code>*dest, </code><code>const</code> <code>char</code> <code>*src);   //<span style="color:#ffbb66;"><strong>字符串连接函数</strong></span>，把字符串2<strong>连接</strong>到字符串1的后面，<strong>结果</strong>放到字符数组<strong>1</strong>中。</code></p> <p><code> 例：char str1[10]="good "; char str2[]="boy";  strcat(str1,str2); 注：str1必须<strong>够大</strong>，以便能放下str2。</code></p> <p> </p> <p><code>char</code> <code>* </code><span style="color:#f33b45;"><code>strncat</code></span> <code>(</code><code>char</code> <code>*dest, </code><code>const</code> <code>char</code> <code>*src，n);</code></p> </td></tr></tbody></table> 
<p>src连接到dest后；src 中前n个字符连接到dest后。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p><code>int</code>  <span style="color:#f33b45;"><code>strcmp</code></span> <code>(</code><code>const</code> <code>char</code> <code>*s1, </code><code>const</code> <code>char</code> <code>*s2);  //<span style="color:#ffbb66;"><strong>字符串比较函数</strong></span>，比较字符串1和字符串2，将2个字符串自左至右逐个字符比较(按ASCII码值大小比较)，直到出现不同的字符或遇到'\0'为止。</code></p> <p>例：<code>char str1[]="china "; char str2[]="korea"; </code>strcmp(str1,str2); k比c大，所以函数值为负。</p> <p>  如果str1=str2,则函数值为0； 如果str1&gt;str2,则函数值为正； 如果str1&lt;str2，则函数值为负。 如： if(strcmp(str1,str2)=0)</p> <p> </p> <p><code>int</code>  <span style="color:#f33b45;"><code>strncmp</code></span> <code>(</code><code>const</code> <code>char</code> <code>*s1, </code><code>const</code> <code>char</code> <code>*s2，n); //<span style="color:#ffbb66;"><strong>字符串比较函数</strong></span> 比较s1与s2，s1&lt;s2则返回负数，否则返回0；比较前n个字符</code></p> <p> </p> <p><code>char</code> <code>* </code><span style="color:#f33b45;"><code>strchr</code></span> <code>(</code><code>const</code> <code>char</code> <code>*s, </code><code>int</code> <code>c);</code></p> <p> </p> <p><code>char</code> <code>* </code><span style="color:#f33b45;"><code>strrchr</code> </span><code>(</code><code>const</code> <code>char</code> <code>*s, </code><code>int</code> <code>c); 返回字符串s中第一次出现字符c的位置指针；返回字符串s中最后一次出现字符c的位置指针（c会转换成</code><code>char</code><code>）</code></p> </td></tr></tbody></table> 
<p>      <strong>strlen(字符数组); </strong>   //<span style="color:#ffbb66;"><strong>测字符串长度的函数</strong></span>，字符串实际长度(不包括'\0')</p> 
<p>       例：char str[10]="china";  printf("%d",strlenn(str)) ; 输出的结果不是10也不是6，而是5</p> 
<p>      <strong> strlwr(字符串); </strong>     //<strong><span style="color:#ffbb66;">转换为 小写 的函数</span></strong>，将字符串中的大写字母转换为小写字母</p> 
<p>        <strong>strupr(字符串)；</strong>  //<span style="color:#ffbb66;"><strong>转换为 大写 的函数</strong></span>，将字符串的小写字母转换为大写字母</p> 
<p>不常见 size_t   strcspn (const char *s1, const char *s2); char * strdup (const char *s); char * strerror(int errnum);</p> 
<p><span style="color:#7c79e5;"><strong>（2）mem</strong></span></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:41px;"> <p>1</p> </td><td> <p><code>void</code> <code>*</code><span style="color:#f33b45;"><code>memcpy</code></span><code>（</code><code>void</code> <code>*s， </code><code>const</code> <code>void</code> <code>*ct，n）</code></p> </td></tr></tbody></table> 
<p>将字符串ct中的前n个字符拷贝到s中，并返回s。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> </td><td> <p><code>void</code> <code>*</code><span style="color:#f33b45;"><code>memmove</code></span><code>（s，ct，n）同上一函数，只是在对象重叠时仍能正确执行。</code></p> <p><strong><code>void</code> <code>*</code><span style="color:#f33b45;"><code>memset</code></span><code>（</code><code>void</code> <code>*s，</code><code>int</code> <code>c， n）</code></strong></p> </td></tr></tbody></table> 
<p>void *<span style="color:#f33b45;">memset</span>(void *s, int c, <a href="https://baike.baidu.com/item/size_t" rel="nofollow">size_t</a> n);</p> 
<p>函数解释：将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 c 替换并返回 s 。</p> 
<p><span style="color:#ffbb66;"><strong>memset</strong></span>：作用是在一段内存块中填充某个给定的值，它是对较大的<a href="https://baike.baidu.com/item/%E7%BB%93%E6%9E%84%E4%BD%93" rel="nofollow">结构体</a>或<a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84" rel="nofollow">数组</a>进行清零操作的一种最快方法 [1]。</p> 
<p>memset()函数原型是extern void *memset(void *buffer, int c, int count) buffer：为指针或是数组,c：是赋给buffer的值,count：是buffer的长度</p> 
<p>将s中的前n个字符替换成c，并返回s。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:41px;"> <p>1</p> </td><td> <p><code>int</code> <span style="color:#f33b45;"><code>memcmp</code></span><code>（cs，ct，n）</code></p> </td></tr></tbody></table> 
<p>将cs前n个字符与ct进行比较，cs&lt;ct，返回负数；否则返回0</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:43px;"> <p>1</p> </td><td> <p><code>void</code> <code>*</code><span style="color:#f33b45;"><code>memchr</code></span><code>（cs，c，n）</code></p> </td></tr></tbody></table> 
<p>返回指向c在cs中第一次出现的位置指针。</p> 
<p> </p> 
<h4><strong><u>3.<span style="color:#e579b6;">&lt;math.h&gt;</span></u>一些数学函数</strong></h4> 
<p>求绝对值</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:40px;"> <p>1</p> <p>2</p> <p>3</p> </td><td> <p><code>int</code> <span style="color:#f33b45;"><code>abs</code> </span> <code>(</code><code>int</code> <code>x);</code></p> <p><code>long</code> <span style="color:#f33b45;"><code>labs</code></span> <code>(</code><code>long</code> <code>x);</code></p> <p><code>float</code> <span style="color:#f33b45;"><code>fabs</code> </span><code>（</code><code>float</code> <code>x）：</code></p> </td></tr></tbody></table> 
<p>所有返回值均为double，三角函数角度用弧度表示，x，y均为double</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> </td><td> <p><code>double</code> <span style="color:#f33b45;"><code>acos</code></span> <code>(x);</code></p> <p><code>double</code> <span style="color:#f33b45;"><code>asin</code></span> <code>(x)；</code></p> <p><code>double</code> <span style="color:#f33b45;"><code>atan</code></span> <code>(x);</code></p> <p><code>double</code> <span style="color:#f33b45;"><code>atan2</code></span> <code>(y, x)：  <span style="color:#f33b45;">arctan</span>（y/x）</code></p> <p><code>double</code> <span style="color:#f33b45;"><code>tan</code></span>  <code>(x);</code></p> <p><code>double</code> <span style="color:#f33b45;"><code>tanh</code> </span><code>(x)：    双曲正切</code></p> <p><code>double</code> <span style="color:#f33b45;"><code>sin</code> </span> <code>(x);</code></p> <p><code>double</code> <span style="color:#f33b45;"><code>sinh</code></span> <code>(x);</code></p> <p><code>double</code> <span style="color:#f33b45;"><code>cos</code></span>  <code>(x);</code></p> <p><code>double</code> <span style="color:#f33b45;"><code>cosh</code></span> <code>(x);</code></p> <p><code>double</code> <span style="color:#f33b45;"><code>pow</code></span>  <code>(x, y)；</code><code>//注意返回值类型为双精度型</code></p> <p><code>double</code> <span style="color:#f33b45;"><code>sqrt</code></span> <code>(x);</code></p> <p><code>double</code> <span style="color:#f33b45;"><code>ceil</code> </span><code>(x)：   不小于x的最小整型数（向上取整）</code></p> <p><code>double</code> <span style="color:#f33b45;"><code>floor</code></span> <code>(x)：  不大于x的最大整型数（向下取整）</code></p> <p><code>double</code> <span style="color:#f33b45;"><code>exp</code> </span> <code>(x);</code></p> <p><code>double</code> <span style="color:#f33b45;"><code>fabs</code></span> <code>(x);</code></p> <p><code>double</code> <span style="color:#f33b45;"><code>log</code> </span> <code>(x)：  <span style="color:#f33b45;">ln</span>（x）</code></p> <p><code>double</code> <span style="color:#f33b45;"><code>log10</code></span> <code>(x);</code></p> <p><code>double</code><span style="color:#f33b45;"> <code>fmod</code></span> <code>(x, y)：    x/y的余数</code></p> <p><code>double</code> <span style="color:#f33b45;"><code>ldexp</code> </span><code>(x, n)：         x*2^n</code></p> <p><code>double</code> <span style="color:#f33b45;"><code>modf</code> </span><code>(x, </code><code>double</code> <code>*ip):   将x分成整数与小数两部分，返回小数部分，整数部分放在*ip中</code></p> <p><code>double</code> <span style="color:#f33b45;"><code>frexp</code> </span><code>(x, </code><code>int</code> <code>*</code><code>exp</code><code>);    将x分成（0.5,1）之间的一个真分数和一个2的幂数，返回真分数，幂数放在</code><code>exp</code><code>中</code></p> </td></tr></tbody></table> 
<p><img alt="" class="has" height="535" src="https://images2.imgbox.com/2a/9d/9DCwdikO_o.png" width="1200"></p> 
<h4><img alt="" class="has" height="802" src="https://images2.imgbox.com/8e/f0/wsXBAGTh_o.png" width="1174"></h4> 
<h4><img alt="" class="has" height="649" src="https://images2.imgbox.com/0e/39/jr9uwPQo_o.png" width="1169"></h4> 
<p> </p> 
<h4><strong><u>4.<span style="color:#e579b6;">&lt;stdlib.h&gt;</span></u>数值转换、内存分配等问题。</strong></h4> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:48px;"> <p>1</p> </td><td> <p><code>int</code> <span style="color:#f33b45;"><code>rand</code></span><code>（</code><code>void</code><code>）</code></p> </td></tr></tbody></table> 
<p>产生一个0~32767之间的随机整数。</p> 
<p> </p> 
<p><strong>void *malloc(unsigned int size);</strong></p> 
<p>    作用是在内存的动态存储区中分配一个长度为<strong>size</strong>(不允许为负数)的连续空间。此函数的值(即“返回值”)是分配区域的第一个字节的地址，或者说，此函数是一个指针型函数，不指向任何类型的数据，只提供一个地址，返回的指针指向该分配域的开头位置，如内存空间不足则返回空指针NULL。如： </p> 
<p>        malloc(100);   //开辟100字节的心事分配域，函数值为其第一个字节的地址</p> 
<p><strong>void *calloc(unsiggned n,unsigned size);</strong></p> 
<p>    作用是在内存的动态存储区分配n个长度为size的连续空间，这个空间一般比较大，足以<strong>保存一个数组，</strong>可以为一维数组开辟动态存储空间，n为数组元素个数，每个元素长度为size,这是动态数组。函数返回指向所分配域的起始位置的指针，如果分配不成功则返回NULL。如：</p> 
<p>       p=calloc(50,4); //开辟50x4个字节的临时分匹配域，把起始地址赋给指针变量p</p> 
<p><strong>void free(void *p);</strong></p> 
<p>    作用是释放指针变量p所指向的动态空间(p为malloc,realloc,calloc最近一次所开辟的内存)，使这部分空间能重新被其他变量使用。如;</p> 
<p>        free(p);  //释放指针变量p所指向的已分配的动态空间   free函数无返回值</p> 
<p><strong>void *realloc(void *p,uunsigned int size);</strong></p> 
<p>    如果已经通过malloc或calloc函数获得了动态空间，想改变其大小，可以用realloc函数重新分配，用realloc函数将p所指向的动态空间的大小改为size，如果重分配不成功，则返回NULL。如：</p> 
<p>        realloc(p,50);  //将p所指向的已分配的动态空间改为50字节</p> 
<p> </p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:58px;"> <p>1</p> </td><td> <p><code>void</code> <code><span style="color:#f33b45;">abort</span> （</code><code>void</code><code>）</code></p> </td></tr></tbody></table> 
<p>使程序非正常终止。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="width:61px;"> <p>1</p> </td><td> <p><code>void</code> <code><span style="color:#f33b45;">exit</span>（</code><code>int</code> <code>status）</code></p> </td></tr></tbody></table> 
<p>使程序正常终止。</p> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ad86a04b45cccb5e7295490f1ada2b13/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决linux部署tomcat 报错不支持java.lang.NoClassDefFoundError: com/sun/image/codec/jpeg/JPEGCodec</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ded11f65e65b54e21571271778e87642/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mysql 增加rownum</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>