<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Flutter桌面开发 - windows插件开发 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Flutter桌面开发 - windows插件开发" />
<meta property="og:description" content="通过此篇文章，你将了解到：
Flutter插件的基本介绍；windows插件开发的真实踩坑经验。 ⚠️本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！
前言 我们都知道，Flutter的定位更多是作为一个跨平台的UI框架，对于原生平台的功能，开发过程中经常需要插件来提供。不幸的是Windows的生态又极其不完整，插件开发必不可少。但网上windows的文章少之又少，所以本篇文章，我们一起来聊聊插件开发的一些技巧。
插件介绍 Flutter的插件主要分两种：package和plugin。
Package是纯dart代码的库，不涉及原生平台的代码；Plugin是原生插件库，是一种特殊的Package。Plugin需要开发者分别在各原生平台实现对应的能力。 其中Plugin是我们要着重讲的，既然是原生平台实现，那跟dart层就势必需要通讯。Flutter Plugin的通讯主要有：methodChannel、eventChannel、basicMessageChannel。
MethodChannel：同步调用的通道，调用后可以通过result返回结果。可以 Native 端主动调用，也可以Flutter主动调用，属于双向通信。这种通信方式是我们日常开发中为最常用的方式， 关键点是Native 端的调用需要在主线程中执行。EventChannel：异步事件通知的通道，一般是Native端主动发出通知，Flutter接收通信信息。BasicMessageChannel：长链接的通道，双端可以随时发出消息，对方收到消息后可以使用reply进行回复。一般常用于需要双向通信可不知道何时需要发送的场景。 windows插件编写 Flutter Android的生态算是比较完整的，而且网上95%的插件文章，都是以移动端为主，对于不熟悉Windows开发的同学极度不友好。因此本篇文章我们不讲Android端的实现，重点讲Windows端的实践，不过我也不是C&#43;&#43;技术栈的，只能浅浅分享我踩过的坑。
如何创建通信通道？ // MethodChannel void XXXPlugin::RegisterWithRegistrar( flutter::PluginRegistrarWindows* registrar) { // 创建一个MethodChannel auto channel = std::make_unique&lt;flutter::MethodChannel&lt;flutter::EncodableValue&gt;&gt;( registrar-&gt;messenger(), &#34;usb_tool&#34;, &amp;flutter::StandardMethodCodec::GetInstance()); // 创建插件对象 auto plugin = std::make_unique&lt;XXXPlugin&gt;(); // 把通道设置给插件，同时传入消息的处理入口 channel-&gt;SetMethodCallHandler( [plugin_pointer = plugin.get()](const auto&amp; call, auto result) { plugin_pointer-&gt;HandleMethodCall(call, std::move(result)); }); } // EventChannel // 创建事件流处理对象 auto eventHandler = std::make_unique&lt; StreamHandlerFunctions&lt;EncodableValue&gt;&gt;( [plugin_pointer = plugin.get()]( const EncodableValue* arguments, std::unique_ptr&lt;EventSink&lt;EncodableValue&gt;&gt;&amp;&amp; events) -&gt; std::unique_ptr&lt;StreamHandlerError&lt;EncodableValue&gt;&gt; { return plugin_pointer-&gt;OnListen(arguments, std::move(events)); }, [plugin_pointer = plugin." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/bde4735a0a9070ee2de28e92950e1c94/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-30T16:44:45+08:00" />
<meta property="article:modified_time" content="2022-11-30T16:44:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Flutter桌面开发 - windows插件开发</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/07/13/vtCsnsqa_o.png" alt=""></p> 
<blockquote> 
 <p>通过此篇文章，你将了解到：</p> 
 <ol><li>Flutter插件的基本介绍；</li><li>windows插件开发的真实踩坑经验。</li></ol> 
</blockquote> 
<blockquote> 
 <p>⚠️本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！</p> 
</blockquote> 
<h3><a id="_10"></a>前言</h3> 
<p>我们都知道，Flutter的定位更多是作为一个跨平台的UI框架，对于原生平台的功能，开发过程中经常需要插件来提供。不幸的是Windows的生态又极其不完整，插件开发必不可少。但网上<strong>windows的文章少之又少</strong>，所以本篇文章，我们一起来聊聊插件开发的一些技巧。</p> 
<h3><a id="_14"></a>插件介绍</h3> 
<p>Flutter的插件主要分两种：package和plugin。</p> 
<ul><li>Package是<strong>纯dart代码</strong>的库，不涉及原生平台的代码；</li><li>Plugin是原生插件库，是一种特殊的Package。Plugin需要开发者分别在各原生平台实现对应的能力。</li></ul> 
<p>其中Plugin是我们要着重讲的，既然是原生平台实现，那跟dart层就<code>势必需要通讯</code>。Flutter Plugin的通讯主要有：methodChannel、eventChannel、basicMessageChannel。</p> 
<ul><li><strong>MethodChannel</strong>：同步调用的通道，调用后可以通过result返回结果。可以 Native 端主动调用，也可以Flutter主动调用，属于双向通信。这种通信方式是我们日常开发中为最常用的方式， 关键点是<code>Native 端的调用需要在主线程中执行</code>。</li><li><strong>EventChannel</strong>：异步事件通知的通道，一般是Native端主动发出通知，Flutter接收通信信息。</li><li><strong>BasicMessageChannel</strong>：长链接的通道，双端可以随时发出消息，对方收到消息后可以使用reply进行回复。一般常用于需要双向通信可不知道何时需要发送的场景。</li></ul> 
<h3><a id="windows_27"></a>windows插件编写</h3> 
<p>Flutter Android的生态算是比较完整的，而且网上95%的插件文章，都是以移动端为主，对于不熟悉Windows开发的同学极度不友好。因此本篇文章我们不讲Android端的实现，重点讲Windows端的实践，<strong>不过我也不是C++技术栈的，只能浅浅分享我踩过的坑。</strong></p> 
<ol><li><strong>如何创建通信通道？</strong></li></ol> 
<pre><code>// MethodChannel
void XXXPlugin::RegisterWithRegistrar(
	flutter::PluginRegistrarWindows* registrar) {
        // 创建一个MethodChannel
	auto channel =
		std::make_unique&lt;flutter::MethodChannel&lt;flutter::EncodableValue&gt;&gt;(
			registrar-&gt;messenger(), "usb_tool",
			&amp;flutter::StandardMethodCodec::GetInstance());
        // 创建插件对象
	auto plugin = std::make_unique&lt;XXXPlugin&gt;();
        // 把通道设置给插件，同时传入消息的处理入口
	channel-&gt;SetMethodCallHandler(
		[plugin_pointer = plugin.get()](const auto&amp; call, auto result) {
		plugin_pointer-&gt;HandleMethodCall(call, std::move(result));
	});
}
</code></pre> 
<pre><code>// EventChannel

// 创建事件流处理对象
auto eventHandler = std::make_unique&lt;
StreamHandlerFunctions&lt;EncodableValue&gt;&gt;(
	[plugin_pointer = plugin.get()](
		const EncodableValue* arguments,
		std::unique_ptr&lt;EventSink&lt;EncodableValue&gt;&gt;&amp;&amp; events)
		-&gt; std::unique_ptr&lt;StreamHandlerError&lt;EncodableValue&gt;&gt; {
			return plugin_pointer-&gt;OnListen(arguments, std::move(events));
	},
	[plugin_pointer = plugin.get()](const EncodableValue* arguments)
		-&gt; std::unique_ptr&lt;StreamHandlerError&lt;EncodableValue&gt;&gt; {
			return plugin_pointer-&gt;OnCancel(arguments);
	});
// 创建EventChannel对象
auto eventChannel = std::make_unique&lt;flutter::EventChannel&lt;flutter::EncodableValue&gt;&gt;(
	registrar-&gt;messenger(), eventChannelName,
	&amp;flutter::StandardMethodCodec::GetInstance());
// 把通道设置给插件
eventChannel-&gt;SetStreamHandler(std::move(eventHandler));
</code></pre> 
<p>最后我们还需要把插件注册进项目中</p> 
<pre><code>registrar-&gt;AddPlugin(std::move(plugin));
</code></pre> 
<ol start="2"><li><strong>如何处理消息？</strong> 在上面创建的过程中，其实已经把处理方法的传递给插件了。</li></ol> 
<pre><code>// MethodChannel的处理
// result即通信的对象
void XXXPlugin::HandleMethodCall(
	const flutter::MethodCall&lt;flutter::EncodableValue&gt;&amp; method_call,
	std::unique_ptr&lt;flutter::MethodResult&lt;flutter::EncodableValue&gt;&gt; result) {
        // 匹配通信的接口
	if (method_call.method_name().compare("getPlatformVersion") == 0) {
		std::ostringstream version_stream;
		version_stream &lt;&lt; "Windows ";

		if (IsWindows10OrGreater()) {
			version_stream &lt;&lt; "10+";
		}
		else if (IsWindows8OrGreater()) {
			version_stream &lt;&lt; "8";
		}
		else if (IsWindows7OrGreater()) {
			version_stream &lt;&lt; "7";
		}
                // 通过result-&gt;Succes回复消息
		result-&gt;Success(flutter::EncodableValue(version_stream.str()));
	} else {
		result-&gt;NotImplemented();

	}
}
</code></pre> 
<pre><code>// 主动向Flutter端发送消息
std::unique_ptr &lt; flutter::StreamHandlerError&lt;flutter::EncodableValue&gt;&gt; XXXPlugin::OnListen(const flutter::EncodableValue* arguments,
	std::unique_ptr&lt;flutter::EventSink&lt;flutter::EncodableValue&gt;&gt;&amp;&amp; events) {
	// 主动发送
	events_.reset(events.release());
	return nullptr;
}

// Flutter取消监听时触发
std::unique_ptr &lt; flutter::StreamHandlerError&lt;flutter::EncodableValue&gt;&gt; UsbToolPlugin::OnCancel(const flutter::EncodableValue* arguments) {
	return nullptr;
}
</code></pre> 
<p>BasicMessageChannel我暂时还没有用过，这里就不做记录了。但是看C++的api，还是很简单就能找到的。至于Flutter端的，无需多言。只要通信层连通了，其他想怎么玩都可以。</p> 
<h3><a id="Windows_130"></a>Windows插件的一些坑</h3> 
<p>这是本篇文章的重点。我们都知道Flutter是单线程的机制，来到原生平台也一样，Platform是运行在Flutter的主线程的，自然是不能做任何耗时的，不然会卡住主线程，系统会把我们认为无响应的应用，从而杀死应用。</p> 
<p>我们经常会在使用windows插件时，感觉点击卡顿，其实就是很多插件没有做这个处理，导致事件队列等待调度。这主要是因为在windows的开发习惯上，<code>耗时操作会丢到子线程异步执行，然后主线程如何等待执行结果？使用while一直去查询是否执行完成，这在windows上成为挂起。</code></p> 
<p>不过一个有趣的现象是：当有耗时操作的时候，Flutter的动画是可以流程播放的，但是点击事件却卡住了，这时候C++的同学就会扯，你看动画都是流程的，问题肯定出在Flutter上？其实是<code>因为动画在Flutter中属于微任务，它的优先级是高于事件队列的。</code>而while也是分配到事件队列中，所以动画优先执行，点击却需要一直等到while结束。</p> 
<p>在Android中，为了避免这个问题，我们一般会使用协程，把耗时操作丢给协程，让系统帮我们进行任务调度，通过await拿到执行完之后的结果，再把结果返回给dart层。整个机制其实还是保留了flutter的单线程机制，从而避免了卡顿问题。</p> 
<p>在Windows端，其实也有协程这个概念，比如WinRT、C++都有提供协程的能力。但问题在于协程这个东西，对于C++来说太新了，同时C++的历史包袱实在太重，到现在还是用着很老版本的库。这就导致很多C++的库没办法迁移到协程这种方式，至少在我现在的业务中，切换成本极高，几乎没办法完成。</p> 
<p>但问题总得解决，目前我们主要使用异步通知的方式，来解决这个问题。<code>此异步是真异步</code>，非flutter单线程任务调度的异步。我们会把耗时的操作<code>丢给子线程</code>，但是我们不再通过while进行<code>异步转同步</code>，而是在子线程中，主动通过channel去通知会Dart层。</p> 
<pre><code>if (*method == "getAsync") {
            async_pipe_stream_-&gt;Get(request, std::bind(&amp;XXXPlugin::OnResponse, this, std::placeholders::_1, *uuid));
            // 直接返回true，但真正的执行结果再OnResponse中主动返回
            result-&gt;Success(EncodableValue(true)); 
            return;
        }
</code></pre> 
<p>在插件的dart代码中，我们需要主动创建一个MethodChannel的接收器，异步接收到后，通过执行业务端传入的回调通知回去。</p> 
<pre><code>class NativePlugin {
  static const MethodChannel _channel =
      MethodChannel('com.open.flutter/xxx/xxx');

  static NativePlugin? _instance;

  // 获取实例，单例
  static NativePlugin getInstance({String defaultToken = _token}) {
    _instance ??= NativePlugin._internal(defaultToken);
    return _instance!;
  }

  // 私有命名构造函数，做一次初始化
  NativePlugin._internal(String defaultToken) {
    _defaultToken = defaultToken;

    _channel.setMethodCallHandler((MethodCall call) async {
      if (call.method == 'onResponse') {
        final arguments = Map&lt;String, dynamic&gt;.from(call.arguments);
        // 执行业务端传入的回调
        await _onResponse(arguments);
      }
    });
  }
</code></pre> 
<p><strong>插件的Flutter层需要接收/维护回调列表</strong>，不过此方式有隐患，传入的回调容易造成闭包问题，增加一些内存泄露的风险；但是对于没办法使用协程的C++插件来说，此方案确实可以解决不少问题。亲测可用的！</p> 
<h3><a id="_184"></a>写在最后</h3> 
<p>这篇文章，适合熟悉Flutter插件开发，但是想接触C++的同学学习讨论。<br> 此专栏从窗口管理、分辨率适配、桌面小工具、项目框架、插件编写；下次我们讲讲如何进行打包！</p> 
<h3><a id="_190"></a>最后</h3> 
<p>如果想要成为架构师或想突破20~30K薪资范畴，那就不要局限在编码，业务，要会选型、扩展，提升编程思维。此外，良好的职业规划也很重要，学习的习惯很重要，但是最重要的还是要能持之以恒，任何不能坚持落实的计划都是空谈。</p> 
<p>如果你没有方向，这里给大家分享一套由阿里高级架构师编写的《Android八大模块进阶笔记》，帮大家将杂乱、零散、碎片化的知识进行体系化的整理，让大家系统而高效地掌握Android开发的各个知识点。<br> <img src="https://images2.imgbox.com/57/97/sGgF0llL_o.png" alt="在这里插入图片描述"><br> 相对于我们平时看的碎片化内容，这份笔记的知识点更系统化，更容易理解和记忆，是严格按照知识体系编排的。</p> 
<h4><a id="_200"></a>全套视频资料：</h4> 
<p><strong>一、面试合集</strong><br> <img src="https://images2.imgbox.com/9f/ee/z9lxKFpB_o.png" alt="在这里插入图片描述"><br> <strong>二、源码解析合集</strong></p> 
<p><img src="https://images2.imgbox.com/e5/c0/7lzRQbvZ_o.png" alt="在这里插入图片描述"><br> <strong>三、开源框架合集</strong></p> 
<p><img src="https://images2.imgbox.com/36/b6/f9qe8l7W_o.png" alt="在这里插入图片描述"><br> <strong>欢迎大家一键三连支持，若需要文中资料，直接点击文末CSDN官方认证微信卡片免费领取↓↓↓</strong></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2a655916bc2662c045beb81c92b9fa3d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于Android开发的记账软件（附带源码）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1229f2480a8fc97ad657180b02066ab2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Word 中Mathtype按钮灰色不可用的解决办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>