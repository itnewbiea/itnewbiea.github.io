<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HDU1301--Jungle Roads - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HDU1301--Jungle Roads" />
<meta property="og:description" content="Problem Description The Head Elder of the tropical island of Lagrishan has a problem. A burst of foreign aid money was spent on extra roads between villages some years ago. But the jungle overtakes roads relentlessly, so the large road network is too expensive to maintain. The Council of Elders must choose to stop maintaining some roads. The map above on the left shows all the roads in use now and the cost in aacms per month to maintain them." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/fd07ca64e52cca6b89fc6a9fd9afb645/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-04-26T23:38:03+08:00" />
<meta property="article:modified_time" content="2013-04-26T23:38:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HDU1301--Jungle Roads</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="panel_title" align="left">
  Problem Description 
</div> 
<div class="panel_content"> 
 <center> 
  <img src="https://images2.imgbox.com/4b/b1/NGkjqrma_o.gif" alt=""> 
 </center> 
 <br> The Head Elder of the tropical island of Lagrishan has a problem. A burst of foreign aid money was spent on extra roads between villages some years ago. But the jungle overtakes roads relentlessly, so the large road network is too expensive to maintain. The Council of Elders must choose to stop maintaining some roads. The map above on the left shows all the roads in use now and the cost in aacms per month to maintain them. Of course there needs to be some way to get between all the villages on maintained roads, even if the route is not as short as before. The Chief Elder would like to tell the Council of Elders what would be the smallest amount they could spend in aacms per month to maintain roads that would connect all the villages. The villages are labeled A through I in the maps above. The map on the right shows the roads that could be maintained most cheaply, for 216 aacms per month. Your task is to write a program that will solve such problems. 
 <br> 
 <br> The input consists of one to 100 data sets, followed by a final line containing only 0. Each data set starts with a line containing only a number n, which is the number of villages, 1 &lt; n &lt; 27, and the villages are labeled with the first n letters of the alphabet, capitalized. Each data set is completed with n-1 lines that start with village labels in alphabetical order. There is no line for the last village. Each line for a village starts with the village label followed by a number, k, of roads from this village to villages with labels later in the alphabet. If k is greater than 0, the line continues with data for each of the k roads. The data for each road is the village label for the other end of the road followed by the monthly maintenance cost in aacms for the road. Maintenance costs will be positive integers less than 100. All data fields in the row are separated by single blanks. The road network will always allow travel between all the villages. The network will never have more than 75 roads. No village will have more than 15 roads going to other villages (before or after in the alphabet). In the sample input below, the first data set goes with the map above. 
 <br> 
 <br> The output is one integer per line for each data set: the minimum cost in aacms per month to maintain a road system that connect all the villages. Caution: A brute force solution that examines every possible set of roads will not finish within the one minute time limit. 
 <br> 
</div> 
<div class="panel_bottom">
    
 <br> 
 <div class="panel_title" align="left">
   Sample Input 
 </div> 
 <div class="panel_content"> 
  <pre>   
   <div style="font-family:Courier New,Courier,monospace">
    
    9
A 2 B 12 I 25
B 3 C 10 H 40 I 8
C 2 D 18 G 55
D 1 E 44
E 2 F 60 G 38
F 0
G 1 H 35
H 1 I 35
3
A 2 B 10 C 40
B 1 C 20
0
   
   </div></pre> 
 </div> 
 <div class="panel_bottom"></div> 
 <br> 
 <div class="panel_title" align="left">
   Sample Output 
 </div> 
 <div class="panel_content"> 
  <pre>   
   <div style="font-family:Courier New,Courier,monospace">
    
    216
30
   
   </div></pre> 
 </div> 
</div> 
<div class="panel_bottom">
    
</div> 
<div class="panel_bottom">
  首先是Kruskal算法： 
</div> 
<div class="panel_bottom"> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 28
int father[maxn];
int find(int x)
{
	if(x == father[x]) return x;
	return father[x] = find(father[x]);
}
struct Edge
{
	int from,to,key;
}edge[78];
bool cmp(Edge a,Edge b)
{
	return a.key &lt; b.key;
}
int main()
{
	int n;
	while(scanf("%d",&amp;n)!=EOF &amp;&amp; n)
	{
		int cost,num;
		int k = 1;
		getchar();
		for(int i=1;i&lt;n;i++)
		{
			getchar();
			getchar();
			scanf("%d",&amp;num);
			for(int j=1;j&lt;=num;j++)
			{
				getchar();
				char c = getchar()-'A'+1;
				scanf("%d",&amp;cost);
				edge[k].from = i;
				edge[k].to = c;
				edge[k++].key = cost;
			}
		}
		for(int i=1;i&lt;=n;i++)
		{
			father[i] = i;
		}
		sort(edge+1,edge+k,cmp);
		int sumcost = 0;
		int z=0;
		for(int i=1;i&lt;k;i++)
		{
			int uu = find(edge[i].from);
			int vv = find(edge[i].to);
			if(uu != vv)
			{
				sumcost += edge[i].key;
				father[uu] = vv;
				z++;
				if(z == n-1)break;
			}
		}
		printf("%d\n",sumcost);
	}
	return 0;
}
</code></pre> 
</div> 
<div class="panel_bottom">
  接下来是优化的Prim算法： 
</div> 
<div class="panel_bottom"> 
 <pre><code class="language-cpp">/*
接下来是优化的Prim
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
using namespace std;
#define maxn 28
#define inf 0x3f3f3f3f
bool vis[maxn];
int dis[maxn];
int n;
struct Edge
{
	int v,w;
	bool operator &lt; (const Edge &amp; a) const
	{
		return w &gt; a.w;
	}
}edge;
vector &lt;Edge&gt; ans[maxn];
int heapprim()
{
	int cost = 0;
	int nowv,nown = 0;
	priority_queue &lt;Edge&gt; q;
	edge.v = 1;
	edge.w = 0;
	q.push(edge);
	while(nown &lt; n &amp;&amp; !q.empty())
	{
L:
		edge = q.top();
		q.pop();
		while(vis[edge.v] &amp;&amp; !q.empty()) goto L;
		if(!vis[edge.v])
		{
			nowv = edge.v;
			vis[nowv] = 1;
			cost += edge.w;
			nown++;
			for(int i=0;i&lt;ans[nowv].size();i++)
			{
				if(!vis[ans[nowv][i].v] &amp;&amp; dis[ans[nowv][i].v] &gt; ans[nowv][i].w)
				{
					dis[ans[nowv][i].v] = ans[nowv][i].w;
					edge.v = ans[nowv][i].v;
					edge.w = ans[nowv][i].w;
					q.push(edge);
				}
			}
		}
	}
	return cost;
}
int main()
{
	while(scanf("%d",&amp;n)!=EOF &amp;&amp; n)
	{
		memset(vis,0,sizeof(vis));
		memset(dis,0x3f,sizeof(dis));
		for(int i=1;i&lt;=n;i++)
		{
			ans[i].clear();
		}
		getchar();
		for(int i=1;i&lt;n;i++)
		{
			getchar();
			getchar();
			int num;
			scanf("%d",&amp;num);
			for(int j=1;j&lt;=num;j++)
			{
				getchar();
				char c = getchar()-'A'+1;
				int cost;
				scanf("%d",&amp;cost);
				edge.v = c;
				edge.w = cost;
				ans[i].push_back(edge);
				edge.v = i;
				ans[c].push_back(edge);
			}
			getchar();
		}
		printf("%d\n",heapprim());
	}
	return 0;
}</code></pre> 
</div> 
<div class="panel_bottom"> 
 <br>   
</div> 
<div class="panel_bottom"> 
 <pre><code class="language-cpp">/*
接下来是不优化的Prim算法
*/
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
#define maxn 28
#define inf 0x3f3f3f3f
int W[maxn][maxn];
bool vis[maxn];
int dis[maxn];
int main()
{
	int n;
	while(scanf("%d",&amp;n)!=EOF &amp;&amp;n)
	{
		memset(W,0,sizeof(W));
		memset(dis,0x3f,sizeof(dis));
		memset(vis,0,sizeof(vis));
		getchar();
		for(int i=1;i&lt;n;i++)
		{
			getchar();
			getchar();
			int num;
			scanf("%d",&amp;num);
			for(int j=1;j&lt;=num;j++)
			{
				getchar();
				char c = getchar()-'A'+1;
				int cost;
				scanf("%d",&amp;cost);
				W[i][c] = W[c][i] = cost;
			}
		}
		dis[1] = 0;
		int cost = 0;
		for(int i=1;i&lt;=n;i++)
		{
			int minlen = inf,nowv;
			for(int j=1;j&lt;=n;j++)
			{
				if(!vis[j] &amp;&amp; dis[j] &lt; minlen)
				{
					minlen = dis[j];
					nowv = j;
				}
			}
			cost += minlen;
			vis[nowv] = 1;
			for(int j=1;j&lt;=n;j++)
			{
				if(!vis[j] &amp;&amp; dis[j] &gt; W[nowv][j] &amp;&amp; W[nowv][j])
				{
					dis[j] = W[nowv][j];
				}
			}
		}
		printf("%d\n",cost);
	}
	return 0;
}</code></pre> 
 <br> 
 <br> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ce86f0a12af8f219f5cfbd8822b50150/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IMB的Zest文档学习 代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ba78d42df28366fef2e23f5c042d484b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HDU3790--最短路径问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>