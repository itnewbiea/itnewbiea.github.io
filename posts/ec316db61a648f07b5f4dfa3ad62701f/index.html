<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>神经网络一 | ImageNet Classification with Deep Convolutional Neural Networks - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="神经网络一 | ImageNet Classification with Deep Convolutional Neural Networks" />
<meta property="og:description" content="一 大量数据集与大规模网络训练 1.1 个人简单理解 该文章设计目的是能够学习大规模，高分辨率的图像数据集且具备足够学习能力的网络。
如此一来就免不了对网络的宽度和深度有较高的要求，与此同时网络参数的数量和计算量也是庞大的。
作者首先确定使用CNNs的架构，这样做减少了神经层之间的连接以及参数量，便于训练，且性能相比标准的具有相似尺寸大小的网络层的前馈神经网络只是轻微的下降。之后作者在框架中引入了几个设计，如ReLU的使用，数据集的扩增等等，提高了CNN网络的性能，还有就是GPU的使用硬性保证了大规模网络能够train起来。
二 框架学习 先展示神经网络框架：五个卷积层和三个全连接层
【网络分析】
输入为224×224×3的图像
卷积层1的卷积核为11×11×3，strde=4，每个GPU内（2.2讲解）输出55×55×48，响应规范化（2.3节内容），池化（2.4节内容）
卷积层2：256个卷积核，大小为5×5×48；响应规范化，池化
卷积层3，4：384个卷积核，大小为3×3×256；无池化
卷积层5：256个卷积核，大小为3×3×192
全连接层6，7：每个GPU内有2048个神经元，共4096个
全连接层8：输出与1000个softmax相连
输出：关于1000个类的分布
具体网络各详细参数的分析可以参考另一篇博文，讲的很详细：
https://blog.csdn.net/zziahgf/article/details/79619059
本文主要讲了设计的框架的四个新颖的特点，并按重要性顺序展开讲述
2.1 激活函数 —— 使用ReLU 作者用非饱和非线性函数（non-saturating nonlinearity）:
替代了饱和非线性函数（saturating nonlinearities）,如,在网络中作为激活函数的作用。
作者用实验来证明：在达到相同训练误差的情况下，使用前者的速度要比后者快了六倍
2.2 用多块GPU训练 作者从单块GPU的内存太小，而网络较大无法放下的角度出发，提出用两块GPU来训练
【优点】
允许大规模的神经网络的设计
【训练模式】
大部分训练阶段，每个GPU都计算自己对应的那一部分网络里的数据，即网络的下一层输入是上一层的输出，都存储在同一个CPU内。
只有在卷积层的第三层需要输出的交互（即第三层的输入是两个GPU内第二卷积层输出在第三维度上的堆叠），以及全连接层。
2.3 局部响应规范Local Response Normalization 当神经元是ReLUs时，只要神经元的输入是正的，那么就会有输出，也就能继续学习（神经元输入为负时，输出为0，相当于这个神经元‘失活’了，无法参与网络的训练）。
下面提出的方法有助于泛化（generalization）
假设在某一个卷积层有N个卷积核，在同一空间位置下，令表示该位置使用第i个卷积核，并通过ReLU计算后的结果，称为activity of a neuron，n是邻接的卷积核的数量，这种响应规范是受生物上神经元侧抑制的启发，增加神经元输出之间的竞争。称为response-normalized activity。
【参数】
由一组验证集确定得到的
2.4 重叠池化 传统池化的方法中，被池化的区域都是不相交的，设被池化区域为 ，池化层是由以s个像素为间隔的网格，其满足。
当时，池化就产生了重叠，池化的像素可能是由多个区域拼成的。
【效果】
实验结论是可以降低0.4%的top-1 error和0.3%的top-5 error
3 对抗过拟合 3.1 数据扩增Data Augmentation 3.1.1 enlarge the dataset using label-preserving transformations" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ec316db61a648f07b5f4dfa3ad62701f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-05T12:33:45+08:00" />
<meta property="article:modified_time" content="2021-09-05T12:33:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">神经网络一 | ImageNet Classification with Deep Convolutional Neural Networks</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一 大量数据集与大规模网络训练</h2> 
<h3>1.1 个人简单理解</h3> 
<p>该文章设计目的是能够学习大规模，高分辨率的图像数据集且具备足够学习能力的网络。</p> 
<p>如此一来就免不了对网络的宽度和深度有较高的要求，与此同时网络参数的数量和计算量也是庞大的。</p> 
<p>作者首先确定使用CNNs的架构，这样做减少了神经层之间的连接以及参数量，便于训练，且性能相比标准的具有相似尺寸大小的网络层的前馈神经网络只是轻微的下降。之后作者在框架中引入了几个设计，如ReLU的使用，数据集的扩增等等，提高了CNN网络的性能，还有就是GPU的使用硬性保证了大规模网络能够train起来。</p> 
<h2>二 框架学习</h2> 
<p>先展示神经网络框架：五个卷积层和三个全连接层</p> 
<p></p> 
<p><img alt="" height="949" src="https://images2.imgbox.com/72/14/aVw0i0Wx_o.png" width="1200"></p> 
<p>【网络分析】</p> 
<p>        输入为<span style="color:#be191c;">224×224×3</span>的图像</p> 
<p>        卷积层1的卷积核为<span style="color:#be191c;">11×11×3</span>，strde=4，每个GPU内（2.2讲解）输出55×55×48，响应规范化（2.3节内容），池化（2.4节内容）</p> 
<p>        卷积层2：<span style="color:#be191c;">256</span>个卷积核，大小为<span style="color:#be191c;">5×5×48</span>；响应规范化，池化</p> 
<p>        卷积层3，4：<span style="color:#be191c;">384</span>个卷积核，大小为<span style="color:#be191c;">3×3×256</span>；无池化</p> 
<p>        卷积层5：<span style="color:#be191c;">256</span>个卷积核，大小为<span style="color:#be191c;">3×3×192</span></p> 
<p>        全连接层6，7：每个GPU内有<span style="color:#be191c;">2048</span>个神经元，共<span style="color:#0d0016;">4096</span>个</p> 
<p>        全连接层8：输出与1000个softmax相连</p> 
<p>        输出：关于<span style="color:#be191c;">1000</span>个类的分布</p> 
<p></p> 
<p>具体网络各详细参数的分析可以参考另一篇博文，讲的很详细：</p> 
<p><a href="https://blog.csdn.net/zziahgf/article/details/79619059">https://blog.csdn.net/zziahgf/article/details/79619059</a></p> 
<p></p> 
<p>本文主要讲了设计的框架的四个新颖的特点，并按重要性顺序展开讲述</p> 
<h4>2.1 激活函数 —— 使用ReLU</h4> 
<p>        作者用<u>非饱和非线性函数</u>（non-saturating nonlinearity）:</p> 
<p style="text-align:center;">                <img alt="f(x) = max(0,x)" class="mathcode" src="https://images2.imgbox.com/60/b1/moQ5mdZL_o.png"></p> 
<p>替代了<u>饱和非线性函数</u>（saturating nonlinearities）<u>,</u>如<img alt="f(x) = tanh(x),f(x) = (1+e^{-x})^{-1}" class="mathcode" src="https://images2.imgbox.com/11/42/wey5K5YR_o.png">,在网络中作为激活函数的作用。</p> 
<p></p> 
<p>作者用实验来证明：<strong>在达到相同训练误差的情况下，使用前者的速度要比后者快了六倍</strong></p> 
<p><img alt="" height="1168" src="https://images2.imgbox.com/6c/77/y3PTlYy2_o.png" width="1062"></p> 
<p></p> 
<h4>2.2 用多块GPU训练</h4> 
<p>         作者从单块GPU的内存太小，而网络较大无法放下的角度出发，提出用两块GPU来训练</p> 
<p>【优点】</p> 
<p>        允许大规模的神经网络的设计</p> 
<p>【训练模式】</p> 
<p>        大部分训练阶段，每个GPU都计算自己对应的那一部分网络里的数据，即网络的下一层输入是上一层的输出，都存储在同一个CPU内。</p> 
<p>        只有在卷积层的第三层需要输出的交互（即第三层的输入是两个GPU内第二卷积层输出在第三维度上的堆叠），以及全连接层。</p> 
<p></p> 
<h4>2.3 局部响应规范Local Response Normalization</h4> 
<p>        当神经元是ReLUs时，只要神经元的输入是正的，那么就会有输出，也就能继续学习（神经元输入为负时，输出为0，相当于这个神经元‘失活’了，无法参与网络的训练）。</p> 
<p>        下面提出的方法有助于泛化（generalization）</p> 
<p style="text-align:center;"><img alt="b_{x,y}^i = a_{x,y}^i/\left ( k+\alpha \sum\limits_{max(0,i-n/2)} ^{min(N-1, i + n/2)}{(a_{x,y}^j)}^2\right )^\beta" class="mathcode" src="https://images2.imgbox.com/69/ab/CM6MlNbF_o.png"></p> 
<p>        假设在某一个卷积层有N个卷积核，在同一空间位置<img alt="(x,y)" class="mathcode" src="https://images2.imgbox.com/b2/12/vrdcTuph_o.png">下，令<img alt="a_{x,y}^i" class="mathcode" src="https://images2.imgbox.com/35/69/db1qliVY_o.png">表示该位置使用第i个卷积核，并通过ReLU计算后的结果，称为activity of a neuron，n是邻接的卷积核的数量，这种响应规范是受生物上神经元侧抑制的启发，增加神经元输出之间的竞争。<img alt="b_{x,y}^i" class="mathcode" src="https://images2.imgbox.com/80/f3/JC4a4icZ_o.png">称为response-normalized activity。</p> 
<p>【参数<img alt="k = 2, n =5,\alpha = 10^{-4}, \beta = 0.75" class="mathcode" src="https://images2.imgbox.com/23/1d/MZKP6HCA_o.png">】</p> 
<p>         由一组验证集确定得到的</p> 
<p></p> 
<h4>2.4 重叠池化</h4> 
<p>        传统池化的方法中，被池化的区域都是不相交的，设被池化区域为<img alt="z\times z" class="mathcode" src="https://images2.imgbox.com/ca/c4/tUrHYlSo_o.png"> ，池化层是由以s个像素为间隔的网格，其满足<img alt="s=z" class="mathcode" src="https://images2.imgbox.com/42/3d/WpUVSYav_o.png">。</p> 
<p>        当<img alt="s&lt;z" class="mathcode" src="https://images2.imgbox.com/bb/c2/8Fio8pNo_o.png">时，池化就产生了重叠，池化的像素可能是由多个区域拼成的。</p> 
<p>【效果】</p> 
<p>        实验结论是可以降低0.4%的top-1 error和0.3%的top-5 error</p> 
<p></p> 
<p></p> 
<h3>3 对抗过拟合</h3> 
<h4>3.1 数据扩增Data Augmentation</h4> 
<p><strong>3.1.1 enlarge the dataset using label-preserving transformations</strong></p> 
<p>【方法优点】</p> 
<p>（1）转换后的图像可以在原图上用小的计算量生成，无需占用额外的存储</p> 
<p>（2）转换后的图像在CPU上生成，网络在GPU上训练，故不占用计算</p> 
<p></p> 
<p>【扩增方法】</p> 
<p>        从256×256的图像上随机生成224×224patches，并生成其水平方向的翻转图，用于网络的训练。这样的方法以2048倍扩大训练集（这个倍数存疑）。</p> 
<p></p> 
<p>【实验数据集】</p> 
<p>        提取了四个角，以及中心的patch，共五个patches，再生成其对应的水平方向的反射，共10个patches用于网络训练。</p> 
<p></p> 
<p><strong>3.1.2 改变RGB通道强度 altering the intensities of the RGB channels</strong></p> 
<p>在RGB像素值集合上使用PCA，给每个主成分的幅度值添加一个乘数：对应特征值×从均值为0，标准差为0.1的高斯分布中随机生成的数。</p> 
<p>【转换公式】</p> 
<p>        对RGB图像中的像素<img alt="I_{xy} = [I_{xy}^R,I_{xy}^G,I_{xy}^B]" class="mathcode" src="https://images2.imgbox.com/38/47/UEwUxn61_o.png"></p> 
<p>        增加项：</p> 
<p style="text-align:center;"><img alt="[p_1,p_2,p_3][\alpha_1\lambda_1,\alpha_2\lambda_2,\alpha_3\lambda_3]^T" class="mathcode" src="https://images2.imgbox.com/3f/81/Fmyfjr03_o.png"></p> 
<p>        <img alt="p_i,\lambda_i" class="mathcode" src="https://images2.imgbox.com/ed/db/HXKT4Q2d_o.png">分别是单个像素3×3RGB协方差矩阵的第i个特征值和特征向量，<img alt="\alpha" class="mathcode" src="https://images2.imgbox.com/97/e4/3qKkX8ij_o.png">是前面提到的服从高斯分布的随机采样值，对于每个训练图像只采样一次，所有像素公用。</p> 
<p>【解释】</p> 
<p>        对自然图像来说，目标种类对于照明的色彩和强度的改变是不变的</p> 
<p>【效果】</p> 
<p>        减少了1%的top-1 error</p> 
<h4></h4> 
<h4>3.2 Dropout</h4> 
<p>        避免神经元之间的依赖，增强网络的鲁棒性</p> 
<p>【实验设置】</p> 
<p>        使用所有的神经元但是输出都乘以0.5</p> 
<p>        在前两层全连接层使用dropout</p> 
<p>【效果】</p> 
<p>        没有dropout时本文的网络出现大量的过拟合，</p> 
<p></p> 
<h3>4 网络学习的一些细节</h3> 
<h3>4.1 训练方法</h3> 
<p>【学习方法】</p> 
<p>        随机梯度下降法，batchsize 128，momentum = 0.9，权重衰减0.0005，</p> 
<p style="text-align:center;"><img alt="v_{i+1} : = 0.9 \cdot v_i - 0.0005 \cdot \epsilon \cdot w_i - \epsilon \cdot {\left \langle \frac{\partial L}{\partial w}|w_i \right \rangle}_{D_i}" class="mathcode" src="https://images2.imgbox.com/88/07/iR4baqFp_o.png"></p> 
<p style="text-align:center;"><img alt="w_{i+1} := w_i + v_{i+1}" class="mathcode" src="https://images2.imgbox.com/ce/5d/bQHdEDej_o.png"></p> 
<p>【参数说明】</p> 
<p>        i是迭代次数，v是动量，<img alt="\epsilon" class="mathcode" src="https://images2.imgbox.com/bb/9b/DpRCnHRO_o.png"> 是学习率</p> 
<p>        <img alt="{\left \langle \frac{\partial L}{\partial w}|w_i \right \rangle}D_i" class="mathcode" src="https://images2.imgbox.com/d2/cb/pqOt4ucu_o.png"> ：batch<img alt="D_i" class="mathcode" src="https://images2.imgbox.com/0c/69/ialLb1bO_o.png">的关于<img alt="w" class="mathcode" src="https://images2.imgbox.com/79/d9/y9Z6sjw8_o.png">在<img alt="w_i" class="mathcode" src="https://images2.imgbox.com/4e/a6/gghnRrWa_o.png">导数的平均值</p> 
<p></p> 
<h3>4.2 网络初始化</h3> 
<p>【weight】每层的权重由均值为0，方差为0.01的高斯分布中取得</p> 
<p>【bias】第二，三，四层卷积层，全连接的hidden layers的bias为1，其他层bias为0。</p> 
<p></p> 
<h3>4.3 一些补充细节</h3> 
<p>【学习率】</p> 
<p>        当validation error rate停止下降时将当前学习率除以10，初始化为0.01</p> 
<p>【实验】</p> 
<p>        训练了120万图像，90epoch，在NVIDIA GTX 580 3GB GPUs上训练了五到六天</p> 
<p></p> 
<h2>5 模型评估</h2> 
<h3>5.1 数据集与实验数据</h3> 
<h4>5.1.1 数据集相关知识</h4> 
<p>【ImageNet】 有1500万有标签，高分辨率图像，约有22000个类别。图像的分辨率不统一。</p> 
<p>【ILSVRC】</p> 
<p>        全名：ImageNet Large-Scale Visual Recognition Challenge，一类视觉目标竞赛，它又有ILSVRC-2010，有公开测试集标签数据，ILSVRC-2012，无可用测试集标签。</p> 
<p></p> 
<p>【评估指标】ImageNet通常用两个指标来代表错误率：top-1和top-5。top-5表示正确标签不在网络模型认为的最有可能的五个标签内的比例。</p> 
<p></p> 
<h4><strong>5.1.2 实验数据</strong></h4> 
<p>【Table1解读】在ILSVRC-2010的数据结果，第三行是本文的模型</p> 
<p style="text-align:center;"><img alt="" height="216" src="https://images2.imgbox.com/17/81/DHWGUF0A_o.png" width="384"></p> 
<p>前两行是之前表现最优的实验结果，用的应该都是传统方法。 </p> 
<p></p> 
<p>【Table2】在IRSVRC-2012的数据结果 </p> 
<p style="text-align:center;"><img alt="" height="234" src="https://images2.imgbox.com/7e/0f/8kgt4VAr_o.png" width="463"></p> 
<p>作者做了很多组相似网络的实验 ，因为测试集不公开，但测试集与验证集数据接近，所以1 CNNs和 1CNN*用验证集的数据来表示 。</p> 
<p>1 CNN是本文描述的网络</p> 
<p>5 CNNs是五个相似CNN的预测平均值</p> 
<p>1 CNNs是在1CNN基础上，在最后一个池化层后接了一个新的卷积层（第六层卷积层），用整个ImageNet Fall 2011 release训练（15M images 22K categories）然后在ILSVRC-2012上进行"fine-tuning"的结果</p> 
<p>7 CNNs* 两个在Fall 2011上与训练的模型和5CNNs的预测平均值。</p> 
<p> </p> 
<p></p> 
<h3>5.2 Figure 3，4的解读</h3> 
<h4>5.2.1 Figure3</h4> 
<p style="text-align:center;"><img alt="" height="307" src="https://images2.imgbox.com/de/9c/E8vu3Hqr_o.png" width="388"></p> 
<p>展示了第一层卷积层的96个卷积核的可视化图，可以看到每个核都学到了不同的内容，上面48个是CPU1内的核，学习的侧重可能是方向，纹理类的；下面48个是在GPU2内的核，侧重点可以看出是颜色，方向 。</p> 
<p> </p> 
<h4> 5.2.2 Figure4</h4> 
<h3><img alt="" height="920" src="https://images2.imgbox.com/3c/11/xJ4MxqcQ_o.png" width="1200"></h3> 
<p><strong>  左图</strong></p> 
<p>【数据来源】</p> 
<p><strong>        ILSVRC-2010</strong>中的8张测试集中的图片和其对应的五个标签（网络生成的概率最大的五个标签），<span style="color:#1a439c;">紫色</span>是模型认为的概率分布，<span style="color:#1a439c;">红色</span>是正确的标签。</p> 
<p>【模型评估结论】</p> 
<p>        网络可以对目标不处于中心位置的图片正确的识别,大多数图片对应的标签都是合理的。比如豹子（leopard）被误认为可能是一种猫科动物（Egyptian cat）。</p> 
<p></p> 
<p><strong>右图</strong></p> 
<p>【数据来源】 </p> 
<p>        第一列是<strong>ILSVRC-2010</strong>中的测试集中的五个图像，剩下的六列是由<strong>训练集</strong>图像经网络训练后在the last hidden layer的特征向量，且与对应的<strong>测试集</strong>图像的欧氏距离最小。</p> 
<p>【模型评估结论】</p> 
<p>        右图是从另一个角度来分析模型的效果，左图是从最终的分类结果（softmax输出每一类的判别概率）来观察的；右图则是将网络中最后一个4096维的hidden layer的输出向量用图片形式可视化。</p> 
<p>        在<span style="color:#1a439c;">输出向量的层面</span>，训练集经过网络产生的特征激活向量（feature activation vector）与测试集图像的特征激活向量在欧式距离上的差距很小。</p> 
<p>        另外一点是，来源于训练集和测试集的两类图像在并不是在<span style="color:#1a439c;">像素层级</span>上的L2范数的接近，可以从图4右侧中看出，例如狗和大象，它们在图像中的有呈对称角度的。</p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f984ff0d760df3960a4f9cd0179cca31/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构】设F是一个森林，B是由F变换得的二叉树。若F中有n个非终端结点，则B中右指针域为空的结点有多少个</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2277abe4108893c8e9ea4aaf3b545d92/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JVM调优实战场景一，CPU飙升100%</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>