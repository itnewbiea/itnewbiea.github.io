<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>halcon算子学习 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="halcon算子学习" />
<meta property="og:description" content="get_camera_setup_param( : : CameraSetupModelID, CameraIdx, GenParamName : GenParamValue)
get_camera_setup_param可用于检查相机设置模型CameraSetupModelID的各种通用参数。可以使用此运算符查询两种类型的参数：
General parameters:（CameraIdx）
‘num_cameras’ 模型中描述的摄像机数量。摄像机的数量是随摄像机设置模型的创建而固定的，此后无法更改
’camera_calib_error’:
相机系统优化的反投影的均方根误差（RMSE）。此错误与传回的错误相同
’reference_camera’:
返回已在系统中定义为参考摄像机的摄像机的索引。如果未使用set_camera_setup_param指定参考摄像机，则返回索引0。如果通过在set_camera_setup_param中使用参数’coord_transf_pose’设置姿势来移动坐标系，则坐标系的原点不在任何可用的摄像机中。因此，返回索引-1。
’coord_transf_pose’:
返回已移动设置的坐标系的姿势。请注意，在使用set_camera_setup_param设置参考摄像机之后，将返回此摄像机的姿态。随后使用set_camera_setup_param中的参数’coord_transf_pose’调整此坐标系会产生一个姿态，该姿态对应于所需坐标系相对于当前坐标系的位置和方向。（GenParamName）Camera parameters：（CameraIdx）
’type’: 相机类型 (see set_camera_setup_cam_param).
’params’: 具有内部相机参数的元组。元组的长度取决于相机类型。
’params_deviations’: 一个表示内部摄像机参数的标准偏差的元组。元组的长度取决于相机类型。
’params_covariances’: 如果内部相机参数，则表示协方差矩阵的元组。元组的长度取决于相机类型。
’pose’: 相对于设置的坐标系的相机姿态（有关更多详细信息，请参见create_camera_setup_model）。（GenParamName） tuple_regexp_test( : : Data, Expression : NumMatches)
tuple_regexp_test将Expression中的正则表达式应用于Data中的一个或多个输入字符串，并在NumMatches中返回匹配字符串的数量**。特别是，如果匹配，单个输入字符串的结果将为1，否则为0。请参阅tuple_regexp_match的文档以获取正则表达式的语法和选项。此外，tuple_regexp_test支持选项’invert_match’，这将导致对那些与正则表达式不匹配的输入字符串进行计数。（正则表达式看不懂）
change_radial_distortion_cam_par( : : Mode, CamParamIn, DistortionCoeffs : CamParamOut)
change_radial_distortion_cam_par根据指定的径向失真系数DistortionCoeffs修改内部摄像机参数。该操作员仅可用于面扫描相机（任何类型的镜头）和带远心镜头的线扫描相机。不支持带有透视镜的线扫描相机。
mode的参数：
’fixed’: 仅修改失真系数，其他内部摄像机参数保持不变。通常，这会导致场景可见部分的变化。
’fullsize’ 对于区域扫描相机，将修改比例因子和图像中心点，以保留场景的可见部分。对于带有远心镜头的线扫描相机，请更改比例因子，图像中心点和运动矢量的分量以实现此效果。因此，原始图像中所有可见的点在修改后的图像中也可见。通常，这会导致修改后的图像中出现未定义的像素。
**‘adaptive’**在其他模式之间进行权衡：场景的可见部分会稍有减少，以防止修改后的图像中出现未定义的像素。与“全尺寸”相同的参数被修改。
’preserve_resolution’ 与在“全尺寸”模式下一样，原始图像中所有可见的点在修改后的（校正后的）图像中也可见。对于区域扫描相机，将修改比例因子和图像中心点。对于带有远心镜头的线扫描相机，更改比例因子，图像中心点以及运动矢量的分量可能会达到这种效果。通常，这会导致修改后的图像中出现未定义的像素。与“全屏”模式相反，此外，修改后的图像的大小会增加，以使图像分辨率在图像的任何部分均不会降低。
gen_radial_distortion_map( : Map : CamParamIn, CamParamOut, MapType : )
gen_radial_distortion_map根据内部摄像机参数CamParamIn和CamParamOut计算出与变化的径向失真相对应的图像映射，例如，可以使用操作员calibrate_cameras获得这些参数。 CamParamIn和CamParamOut分别包含旧的和新的相机参数，包括旧的和新的径向变形（另请参阅校准以了解参数序列和基础相机模型）。潜在输出图像的每个像素都使用CamParamOut变换到图像平面，然后使用CamParamIn投影到潜在输入图像的子像素位置。请注意，gen_radial_distortion_map只能与区域扫描相机一起使用。
注：change_radial_distortion_cam_par算子将相机的畸变系数（k1-k3，p1,p2）设置为0，然后利用gen_radial_distortion_map算子将没有畸变的参数和有畸变的参数生成一个映射,就可以利用这个映射进行畸变校正" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0956d31b0ac30ce2284967109240eced/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-29T15:38:08+08:00" />
<meta property="article:modified_time" content="2021-04-29T15:38:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">halcon算子学习</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <ul><li> <p><strong>get_camera_setup_param( : : CameraSetupModelID, CameraIdx, GenParamName : GenParamValue)</strong><br> get_camera_setup_param可用于检查相机设置模型CameraSetupModelID的各种通用参数。可以使用此运算符查询两种类型的参数：</p> 
  <ul><li><strong>General parameters:</strong>（CameraIdx）<br> <strong>‘num_cameras’</strong> 模型中描述的摄像机数量。摄像机的数量是随摄像机设置模型的创建而固定的，此后无法更改<br> <strong>’camera_calib_error’:</strong><br> 相机系统优化的反投影的均方根误差（RMSE）。此错误与传回的错误相同<br> <strong>’reference_camera’:</strong><br> 返回已在系统中定义为参考摄像机的摄像机的索引。如果未使用set_camera_setup_param指定参考摄像机，则返回索引0。如果通过在set_camera_setup_param中使用参数’coord_transf_pose’设置姿势来移动坐标系，则坐标系的原点不在任何可用的摄像机中。因此，返回索引-1。<br> <strong>’coord_transf_pose’:</strong><br> 返回已移动设置的坐标系的姿势。请注意，在使用set_camera_setup_param设置参考摄像机之后，将返回此摄像机的姿态。随后使用set_camera_setup_param中的参数’coord_transf_pose’调整此坐标系会产生一个姿态，该姿态对应于所需坐标系相对于当前坐标系的位置和方向。（GenParamName）</li><li><strong>Camera parameters：</strong>（CameraIdx）<br> <strong>’type’:</strong> 相机类型 (see set_camera_setup_cam_param).<br> <strong>’params’:</strong> 具有内部相机参数的元组。元组的长度取决于相机类型。<br> <strong>’params_deviations’:</strong> 一个表示内部摄像机参数的标准偏差的元组。元组的长度取决于相机类型。<br> <strong>’params_covariances’:</strong> 如果内部相机参数，则表示协方差矩阵的元组。元组的长度取决于相机类型。<br> <strong>’pose’:</strong> 相对于设置的坐标系的相机姿态（有关更多详细信息，请参见create_camera_setup_model）。（GenParamName）</li></ul> </li><li> <p><strong>tuple_regexp_test( : : Data, Expression : NumMatches)<br> tuple_regexp_test将Expression中的正则表达式应用于Data中的一个或多个输入字符串，并在NumMatches中</strong>返回匹配字符串的数量**。特别是，如果匹配，单个输入字符串的结果将为1，否则为0。请参阅tuple_regexp_match的文档以获取正则表达式的语法和选项。此外，tuple_regexp_test支持选项’invert_match’，这将导致对那些与正则表达式不匹配的输入字符串进行计数。（正则表达式看不懂）</p> </li><li> <p><strong>change_radial_distortion_cam_par( : : Mode, CamParamIn, DistortionCoeffs : CamParamOut)</strong><br> change_radial_distortion_cam_par根据指定的径向失真系数DistortionCoeffs修改内部摄像机参数。该操作员仅可用于面扫描相机（任何类型的镜头）和带远心镜头的线扫描相机。不支持带有透视镜的线扫描相机。<br> mode的参数：<br> <strong>’fixed’:</strong> 仅修改失真系数，其他内部摄像机参数保持不变。通常，这会导致场景可见部分的变化。<br> <strong>’fullsize’</strong> 对于区域扫描相机，将修改比例因子和图像中心点，以保留场景的可见部分。对于带有远心镜头的线扫描相机，请更改比例因子，图像中心点和运动矢量的分量以实现此效果。因此，原始图像中所有可见的点在修改后的图像中也可见。通常，这会导致修改后的图像中出现未定义的像素。<br> **‘adaptive’**在其他模式之间进行权衡：场景的可见部分会稍有减少，以防止修改后的图像中出现未定义的像素。与“全尺寸”相同的参数被修改。<br> <strong>’preserve_resolution’</strong> 与在“全尺寸”模式下一样，原始图像中所有可见的点在修改后的（校正后的）图像中也可见。对于区域扫描相机，将修改比例因子和图像中心点。对于带有远心镜头的线扫描相机，更改比例因子，图像中心点以及运动矢量的分量可能会达到这种效果。通常，这会导致修改后的图像中出现未定义的像素。与“全屏”模式相反，此外，修改后的图像的大小会增加，以使图像分辨率在图像的任何部分均不会降低。</p> </li><li> <p><strong>gen_radial_distortion_map( : Map : CamParamIn, CamParamOut, MapType : )</strong><br> gen_radial_distortion_map根据内部摄像机参数CamParamIn和CamParamOut计算出与变化的径向失真相对应的图像映射，例如，可以使用操作员calibrate_cameras获得这些参数。 CamParamIn和CamParamOut分别包含旧的和新的相机参数，包括旧的和新的径向变形（另请参阅校准以了解参数序列和基础相机模型）。潜在输出图像的每个像素都使用CamParamOut变换到图像平面，然后使用CamParamIn投影到潜在输入图像的子像素位置。请注意，gen_radial_distortion_map只能与区域扫描相机一起使用。<br> <strong>注：change_radial_distortion_cam_par算子将相机的畸变系数（k1-k3，p1,p2）设置为0，然后利用gen_radial_distortion_map算子将没有畸变的参数和有畸变的参数生成一个映射,就可以利用这个映射进行畸变校正</strong></p> </li><li> <p><strong>concat_obj(Objects1, Objects2 : ObjectsConcat : : )</strong><br> concat_obj将图标对象Objects1和Objects2的两个元组串联为一个新的图标对象ObjectsConcat的元组。因此，该元组包含两个输入元组的所有图标对象：</p> </li><li> <p><strong>create_matrix( : : Rows, Columns, Value : MatrixID)</strong><br> 运算符create_matrix用Rows行和Columns列创建一个新的Matrix，并返回矩阵句柄MatrixID。例如，可以访问矩阵的元素。与运算符get_full_matrix一起使用。参数Value是字符串或浮点数或整数的元组。整数自动转换为浮点数</p> </li><li> <p><strong>eigenvalues_symmetric_matrix( : : MatrixID, ComputeEigenvectors : EigenvaluesID, EigenvectorsID)</strong><br> 运算符eigenvalues_symmetric_matrix计算对称矩阵的所有特征值以及特征向量。矩阵由矩阵句柄MatrixID定义。在输出时，将创建具有特征值升序的新矩阵特征值，以及可选地，具有特征向量的新矩阵特征向量。运算符返回矩阵特征值和特征向量的矩阵句柄EigenvaluesID和EigenvectorsID。例如，可以访问矩阵的元素。与运算符get_full_matrix一起使用。</p> </li><li> <p><strong>get_value_matrix( : : MatrixID, Row, Column : Value)</strong><br> 运算符get_value_matrix返回一个或多个Matrix元素的值作为浮点数的元组。矩阵由矩阵句柄MatrixID给出。矩阵元素的行坐标由元组Row确定，列坐标由元组Column确定。</p> </li><li> <p><strong>hom_mat3d_to_pose( : : HomMat3D : Pose)</strong><br> hom_mat3d_to_pose将齐次变换矩阵转换为类型代码为0的相应3D姿势。有关3D姿势和相应变换矩阵的详细信息，请参考create_pose。</p> </li><li> <p><strong>pose_to_hom_mat3d( : : Pose : HomMat3D)</strong><br> pose_to_hom_mat3d将3D姿势姿态（例如外部相机参数）转换为等效的均质变换矩阵HomMat3D。有关3D姿势和相应变换矩阵的详细信息，请参考create_pose。</p> </li><li> <p><strong>create_pose( : : TransX, TransY, TransZ, RotX, RotY, RotZ, OrderOfTransform, OrderOfRotation, ViewOfTransform : Pose)</strong><br> create_pose创建3D姿势姿势。姿势描述了刚性3D变换，即由任意平移和旋转组成的变换，具有6个参数：TransX，TransY和TransZ分别指定沿x轴，y轴和z轴的平移，而RotX ，RotY和RotZ描述旋转。</p> </li><li> <p><strong>gen_contour_polygon_xld( : Contour : Row, Col : )</strong><br> gen_contour_polygon_xld从元组Row和Col中给定的多边形生成XLD轮廓等值线。如果已从核心库外的例程中获取了轮廓，则该运算符很有用，但是要使用更高级别的运算符（例如，多边形逼近和平行线的提取）是可行的。在轮廓上执行。</p> </li><li> <p><strong>hom_mat3d_compose( : : HomMat3DLeft, HomMat3DRight : HomMat3DCompose)</strong><br> hom_mat3d_compose通过将两个输入矩阵相乘组成一个新的3D转换矩阵</p> </li><li> <p><strong>affine_trans_point_3d( : : HomMat3D, Px, Py, Pz : Qx, Qy, Qz)</strong><br> affine_trans_point_3d将任意仿射3D变换（即缩放，旋转和平移）应用于输入点（Px，Py，Pz），并以（Qx，Qy，Qz）返回结果点。仿射变换由HomMat3D中给出的齐次变换矩阵描述。这对应于以下方程式（输入点和输出点为齐次矢量）：</p> </li><li> <p><strong>project_3d_point( : : X, Y, Z, CameraParam : Row, Column)</strong><br> project_3d_point将一个或多个3D点（坐标X，Y和Z）投影到图像平面（以像素为单位）中，并以行和列的形式返回结果。坐标X，Y和Z在摄像机坐标系中给出，即，它们描述了点相对于摄像机的位置</p> </li><li> <p><strong>intersection_line_contour_xld(Contour : : LineRow1, LineColumn1, LineRow2, LineColumn2 : Row, Column, IsOverlapping)</strong><br> intersection_line_contour_xld计算直线和XLD轮廓的交点。该线由点（LineRow1，LineColumn1）和（LineRow2，LineColumn2）定义。相交点（如果有）在（行，列）中返回。如果XLD轮廓的一部分位于线IsOverlapping上，则返回值1，否则返回0。在这种情况下，将在（Row，Column）中返回XLD段的端点。</p> </li><li> <p><strong>get_line_of_sight( : : Row, Column, CameraParam : PX, PY, PZ, QX, QY, QZ)</strong><br> get_line_of_sight计算与图像中的像素（行，列）相对应的视线。视线是相机坐标系中的（直线）线，由线上的两个点（PX，PY，PZ）和（QX，QY，QZ）描述。摄像机由内部摄像机参数CameraParam描述（有关详细信息，请参见“校准”）。</p> </li><li> <p><strong>hom_mat3d_invert( : : HomMat3D : HomMat3DInvert)</strong><br> hom_mat3d_invert反转由HomMat3D给出的齐次3D转换矩阵。结果矩阵在HomMat3DInvert中返回。</p> </li><li> <p><strong>set_camera_setup_param( : : CameraSetupModelID, CameraIdx, GenParamName, GenParamValue : )</strong><br> 运算符set_camera_setup_param可用于为相机设置模型CameraSetupModelID设置各种通用参数或转换。可以使用此运算符设置两种类型的参数：</p> 
  <ul><li><strong>oordinate system of the setup and transformation of camera poses:：</strong> 通过将CameraIdx设置为’<strong>general’</strong>，并将GenParamName设置为以下值之一，您可以为所有摄像机执行以下常规姿态转换： <br> <strong>’reference_camera’</strong>:将GetParamValue设置为有效的摄像机索引时，将相对于此摄像机的坐标系重新计算所有摄像机姿势。<br> <strong>’coord_transf_pose’:</strong> 在GenParamValue中以HALCON姿势格式传递元组时，当前坐标系将移入该姿势。 GenParamValue中的姿势表示所需坐标系相对于当前坐标系的位置和方向。 相对于新坐标系，将重新计算所有相机姿态。 可以使用运算符get_camera_setup_param检查重新计算的相机姿态。</li><li><strong>Camera parameters:</strong> 通过将CameraIdx设置为<strong>有效的设置摄像机索引</strong>（介于0和NumCameras-1之间的值）并将GenParamName设置为以下值之一，可以使用GenParamValue设置摄像机特定的参数：<br> <strong>’params’:</strong> 具有内部相机参数的元组：<br> <strong>’params_deviations’:</strong> 具有内部摄像机参数标准差的元组。 元组的长度必须等于内部参数的长度，该长度取决于相机的类型。 有关更多详细信息，请参见set_camera_setup_cam_param。<br> <strong>’params_covariances’:</strong> 具有内部摄像机参数协方差矩阵的元组。 元组的长度必须是内部摄像机参数的元组长度的平方，具体取决于摄像机的类型。 有关更多详细信息，请参见set_camera_setup_cam_param。<br> <strong>’pose’:</strong> 以HALCON姿势格式表示摄像机姿势的元组，相对于摄像机设置的坐标系。 有关更多详细信息，请参见以上部分。</li></ul> </li></ul> 
<p>请注意，必须先在模型中定义摄像机，然后才能通过set_camera_setup_param更改其任何参数。 如果CameraIdx是未定义摄像机的索引，则操作员将返回错误。可以通过get_camera_setup_param读取所有参数。</p> 
<ul><li><strong>select_obj(Objects : ObjectSelected : Index : )</strong><br> select_obj将具有由Index（以1开头）给出的索引的图标对象从图标输入对象元组Objects复制到输出对象ObjectSelected。没有为区域和图像分配新的存储。而是创建包含对现有对象的引用的新对象。可以使用运算符count_obj查询对象元组中的对象数。</li><li><strong>map_image(Image, Map : ImageMapped : : )</strong><br> map_image使用任意变换映射对图像Image进行变换，例如，该映射先前是使用gen_image_to_world_plane_map或gen_radial_distortion_map生成的。多通道图像映射必须按以下方式组织： 
  <ul><li>Map的高度和宽度定义了输出图像ImageMapped的大小。映射中的通道数定义了不应该使用插值法还是使用双线性插值法。如果“地图”仅包含一个通道，则在转换期间不应用插值。此通道包含描述几何变换的’int4’（如果’int4’的值范围不足，则在HALCON XL中为’int8’）值，这些值描述了几何变换：对于输出图像中的每个像素，ImageMapped在像素中的线性化坐标。输入图像存储应从中获取灰度值的图像。</li><li>如果应在输入图像的像素之间应用双线性插值，则Map必须包含5个通道。第一个通道再次由一个’int4’组成。 'int8’图像并描述几何变换。通道2-5分别由一个’uint2’图像组成，并包含在双线性插值过程中使用的四个相邻像素的权重[0 … 1]。如果输出图像ImageMapped的整体亮度不应与输入图像Image的整体亮度不同，则每个像素的四个未缩放权重的总和必须为1。权重[0 … 1]缩放到’uint2’图像的值范围，因此保留从0到65535的整数值</li><li>此外，必须以不超出输出图像ImageMapped的值范围的方式选择权重。下图显示了四个通道2-5之间的几何关系：</li></ul> </li><li><strong>create_funct_1d_pairs( : : XValues, YValues : Function)</strong><br> create_funct_1d_pairs从一组成对的（x，y）值中创建一个一维函数。函数的XValue必须按升序传递。然后可以使用一维函数的运算符来处理和分析所得的函数。<br> 或者，可以使用运算符create_funct_1d_array创建函数。与该运算符相反，可以使用create_funct_1d_pairs指定具有任意位置的x值。因此，它是更通用的运算符。但是，应注意的是，由于这种普遍性，使用create_funct_1d_pairs创建的函数的处理无法像等距函数那样高效地执行。特别是，并非所有操作员都接受此类功能。如有必要，可以使用运算符sample_funct_1d将一个函数转换为等距函数。</li><li><strong>set_fuzzy_measure( : : MeasureHandle, SetType, Function : )</strong><br> set_fuzzy_measure指定在Function中传递的模糊函数。通过指定的模糊函数，可以使Fuzzy_measure_pos和Fuzzy_measure_pairs / Fuzzy_measure_pairing评估并选择检测到的边缘候选者。为此，可以通过一个功能分别定义不同边缘特征的加权特征。这样的指定特征称为模糊集。对模糊集不指定任何功能意味着不要在最终边缘评估中使用此功能。将第二模糊函数设置为集合意味着放弃第一个定义的函数，然后将其替换为第二个模糊函数。可以通过reset_fuzzy_measure完全放弃先前定义的模糊函数。<br> 可以定义通过SetType参数选择的五种不同模糊集类型的函数，集合的子类型是互斥的： 
  <ul><li><strong>’contrast’：</strong> 将使用模糊函数来评估候选边缘的幅度。当提取边缘对时，通过两个边缘的模糊对比度分数的几何平均值来获得模糊评估。</li><li><strong>“position”</strong> 的模糊函数评估每个边沿候选点到gen_measure_arc或gen_measure_rectangle2生成的测量对象的参考点的距离。参考点位于起点，而“ position_center”或“ position_end”将参考点设置为一维灰度值轮廓的中间或终点。如果模糊位置评估取决于对象在轮廓上的位置，则“ position_first_edge” “ position_last_edge”将参考点设置在提取的第一个/最后一个边缘的位置。当提取边缘对时，通过两个边缘的模糊位置分数的几何平均值来参考一对的位置。</li><li>类似于“position”，<strong>“ position_pair”</strong> 评估每个边对到测量对象参考点的距离。一对的位置由两条边之间的中心点定义。可以分别通过“ position_pair_center”，“ position_pair_end”和“ position_first_pair”，“ position_last_pair”设置对象的参考。与“位置”相反，此集合仅由Fuzzy_measure_pairs / fuzzy_measure_pairing使用。</li><li>**“size”**表示一个模糊集，用于评估一对像素对的两个边缘的标准距离。该集合仅由Fuzzy_measure_pairs / fuzzy_measure_pairing使用。通过终止函数的对应模糊值0.0指定大小的上限，将加快Fuzzy_measure_pairs / Fuzzy_measure_pairing，因为不需要考虑所有可能的对。</li><li><strong>“gray”</strong> 设置模糊函数以加权一对中两个边之间的平均投影灰度值。该集合仅由Fuzzy_measure_pairs / Fuzzy_measure_pairing使用。</li></ul> </li></ul> 
<p>模糊函数由至少两对值定义为分段线性函数，并按其x值按升序排序。 x值表示边缘特征，并且必须位于设置类型的参数空间内，即在<code>对比''和</code>灰色’'特征的情况下，例如在0.0 &lt;= x &lt;= 255.0范围内的字节图像。在“大小”的情况下，x必须满足0.0 &lt;= x，而在“位置”的情况下，x可以是任何实数。模糊函数的y值表示相应特征值的权重，并且必须满足0.0 &lt;= y &lt;= 1.0的范围。在由最小x最大值和最大x值定义的函数间隔之外，间隔边界的y值将连续不断。这样的模糊函数可以由create_funct_1d_pairs生成。</p> 
<ul><li> <p><strong>fuzzy_measure_pairing(Image : : MeasureHandle, Sigma, AmpThresh, FuzzyThresh, Transition, Pairing, NumPairs : RowEdgeFirst, ColumnEdgeFirst, AmplitudeFirst, RowEdgeSecond, ColumnEdgeSecond,AmplitudeSecond, RowPairCenter, ColumnPairCenter, FuzzyScore, IntraDistance)</strong><br> Fuzzy_measure_pairing用于提取垂直于矩形或圆弧的主轴的直边对。Fuzzy_measure_pairing的提取算法与Fuzzy_measure_pairs相同（有关详细信息，请参见此处），不同之处在于，还可以使用参数Pairing提取交织和包含对。当前只有“ no_restriction”可用，它返回所有可能的边对，从而允许对边进行交织和包含。<br> 仅返回得分最高的NumPairs边缘对，而0表示返回所有可能的找到的边缘组合。<br> 所选边作为单点返回，该点位于矩形或圆弧的主轴上。在AmplitudeFirst和AmplitudeSecond中返回相应的边缘幅度，在FuzzyScore中返回模糊分数。另外，每个边缘对之间的距离以IntraDistance返回，与EdgeFirst [i]和EdgeSecond [i]之间的距离相对应。</p> 
  <ul><li>Image (input_object) ：Input image.</li><li>MeasureHandle (input_control) ：测量句柄</li><li>Sigma (input_control) ：<br> 高斯平滑的Sigma。<br> 默认值：1.0<br> 建议值：0.4、0.6、0.8、1.0、1.5、2.0、3.0、4.0、5.0、7.0、10.0<br> 典型值范围：0.4≤Sigma≤100（lin）<br> 最小增量：0.01<br> 建议增量：0.1<br> 限制：Sigma&gt; = 0.4</li><li>AmpThresh (input_control)<br> 最小边缘幅度。<br> 默认值：30.0<br> 建议值：5.0、10.0、20.0、30.0、40.0、50.0、60.0、70.0、90.0、110.0<br> 典型值范围：1≤AmpThresh≤255（lin）<br> 最小增幅：0.5<br> 推荐增量：2</li><li>FuzzyThresh (input_control)<br> 最小模糊值。<br> 默认值：0.5<br> 建议值：0.1、0.3、0.5、0.7、0.9<br> 典型值范围：0.0≤FuzzyThresh≤1.0（lin）<br> 建议增量：0.1</li><li>Transition (input_control)<br> 选择边对的第一个灰度值过渡。<br> 默认值：“全部”<br> 值列表：“所有”，“负”，“正”</li><li>Pairing (input_control)<br> 配对的约束。<br> 默认值：“ no_restriction”<br> 值列表：‘no_restriction’</li><li>NumPairs (input_control)<br> 数字→（整数）<br> 边对的数量。<br> 默认值：10<br> 建议值：0、1、10、20、50<br> 典型值范围：0≤NumPairs<br> 推荐增量：1</li><li>RowEdgeFirst (output_control):第一条边的行坐标。</li><li>ColumnEdgeFirst (output_control) :第一条边的列坐标。</li><li>AmplitudeFirst (output_control) :第一边缘的边缘幅度（带符号）。</li><li>RowEdgeSecond (output_control) :第二条边的行坐标。</li><li>ColumnEdgeSecond (output_control) : 第二条边的列坐标。</li><li>AmplitudeSecond (output_control) :第二条边的边缘幅度（带符号）。</li><li>RowPairCenter (output_control) : 边缘对中心的行坐标。</li><li>ColumnPairCenter (output_control) :边缘对中心的列坐标。</li><li>FuzzyScore (output_control) :边缘对的模糊评估。</li><li>IntraDistance (output_control) :边对的边之间的距离。<br> 如果参数值正确，则操作员Fuzzy_measure_pairing返回值2（H_MSG_TRUE）。否则会引发异常。</li></ul> </li><li> <p><strong>gen_cross_contour_xld( : Cross : Row, Col, Size, Angle : )</strong><br> gen_cross_contour_xld为每个输入点（Row，Col）生成一个十字形的XLD轮廓。从概念上讲，轮廓由长度为Size的两条线组成，这两条线在输入点中精确相交。它们的方向由角度确定。十字架返回十字架。如果要处理多个点，则必须将它们的坐标作为元组传递。</p> </li><li> <p><strong>tuple_sort_index( : : Tuple : Indices)</strong><br> tuple_sort_index以升序​​对Tuple的所有元素进行排序，并返回带有索引的已排序元组的元素索引（相对于输入元组Tuple）。作为前提，元组的单个元素必须具有可比性。因此，元组必须专门由字符串组成，或者只能包含（整数或浮点数）数字。在后一种情况下，可以将整数和浮点数混合。</p> </li><li> <p><strong>solve_matrix( : : MatrixLHSID, MatrixLHSType, Epsilon, MatrixRHSID : MatrixResultID)</strong><br> 运算符solve_matrix计算线性方程组或线性最小二乘问题的解。输入矩阵MatrixLHS和MatrixRHS由矩阵句柄MatrixLHSID和MatrixRHSID定义。矩阵MatrixLHS和MatrixRHS的行数必须相同。操作员返回矩阵MatrixResult的矩阵句柄MatrixResultID。例如，可以访问矩阵的元素。与运算符get_full_matrix一起使用。</p> </li><li> <p><strong>dilation_rectangle1(Region : RegionDilation : Width, Height : )</strong><br> dilation_rectangle1将具有矩形结构元素的膨胀应用于输入区域Region。结构矩形的大小为“宽x高”。操作者得到扩大的区域，并且在区域内部小于矩形掩模的孔被封闭。</p> </li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/924d32891abd3756a3dfd79765ead970/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">恢复 MyBase 误删除的内容</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f158fa323db846e58333c4e45fdc6f59/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">http相关</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>