<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis 请求的一次网络旅程 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis 请求的一次网络旅程" />
<meta property="og:description" content="Redis 请求的一次网络旅程 Redis 不必多说，可以说是目前互联网使用最广泛的内存数据库，源于其丰富的数据结构、支持数据持久化、集群、高性能的这些特性。
本文从 Redis 单线程模式，对于 Redis 客户端从登录到发送消息和收到消息的连续的行为，以 Redis 源码的角度做出解释，详细分析一个 Redis 连接的完整旅程，也作为我在 Redis 学习过程中的一个深入思考的过程。
要解释 Redis 连接的完整过程，事实上主要是对 Redis 网络模型进行分析，因此会分为这几个部分（服务端角度）：注册事件、建立连接、接收请求、解析请求、 执行请求、响应请求等。
注册事件 Redis Server 首先会在 initServer() 函数中注册自身的 listenfd。
在 IO 多路复用模型中，如果要监听事件，需要将服务端的 listenfd 注册到 IO 多路复用模型中，这个行为在启动 aeMain 之前通过 createSocketAcceptHandler 已经注册到事件循环器中，这里忽略监听套接字 listenfd 的生成过程，直接进入注册监听事件的流程。
createSocketAcceptHandler 为服务端注册 listenfd 和 accept 事件，也就是接收客户端连接的处理事件，代码如下：
int createSocketAcceptHandler(socketFds *sfd, aeFileProc *accept_handler) { int j; for (j = 0; j &lt; sfd-&gt;count; j&#43;&#43;) { // 注册可读事件 if (aeCreateFileEvent(server.el, sfd-&gt;fd[j], AE_READABLE, accept_handler,NULL) == AE_ERR) { /* Rollback */ for (j = j-1; j &gt;= 0; j--) aeDeleteFileEvent(server." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/00d8a659e96abc7ff861cfd2513d72cb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-22T21:43:11+08:00" />
<meta property="article:modified_time" content="2021-08-22T21:43:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis 请求的一次网络旅程</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Redis__0"></a>Redis 请求的一次网络旅程</h2> 
<blockquote> 
 <p>Redis 不必多说，可以说是目前互联网使用最广泛的内存数据库，源于其丰富的数据结构、支持数据持久化、集群、高性能的这些特性。</p> 
</blockquote> 
<p>本文从 Redis 单线程模式，对于 Redis 客户端从登录到发送消息和收到消息的连续的行为，以 Redis 源码的角度做出解释，详细分析一个 Redis 连接的完整旅程，也作为我在 Redis 学习过程中的一个深入思考的过程。</p> 
<p>要解释 Redis 连接的完整过程，事实上主要是对 Redis 网络模型进行分析，因此会分为这几个部分（服务端角度）：注册事件、建立连接、接收请求、解析请求、 执行请求、响应请求等。</p> 
<h3><a id="_8"></a>注册事件</h3> 
<p>Redis Server 首先会在 <code>initServer()</code> 函数中注册自身的 listenfd。</p> 
<p>在 IO 多路复用模型中，如果要监听事件，需要将服务端的 listenfd 注册到 IO 多路复用模型中，这个行为在启动 <code>aeMain</code> 之前通过 <code>createSocketAcceptHandler</code> 已经注册到事件循环器中，这里忽略监听套接字 listenfd 的生成过程，直接进入注册监听事件的流程。</p> 
<p><code>createSocketAcceptHandler</code> 为服务端注册 listenfd 和 accept 事件，也就是接收客户端连接的处理事件，代码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">createSocketAcceptHandler</span><span class="token punctuation">(</span>socketFds <span class="token operator">*</span>sfd<span class="token punctuation">,</span> aeFileProc <span class="token operator">*</span>accept_handler<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> j<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sfd<span class="token operator">-&gt;</span>count<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 注册可读事件</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> sfd<span class="token operator">-&gt;</span>fd<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> AE_READABLE<span class="token punctuation">,</span> accept_handler<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> AE_ERR<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">/* Rollback */</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token function">aeDeleteFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> sfd<span class="token operator">-&gt;</span>fd<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> AE_READABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>createSocketAcceptHandler</code> 通过 <code>aeCreateFileEvent</code> 在网络模型中注册可读事件和事件回调函数 <code>accept_handler</code>，该读事件回调中调用 <code>accept</code> 来接收客户端连接。因此所有新连接的 Redis 客户端都需要经过该函数，来建立与 Redis 服务器的连接。</p> 
<p><img src="https://images2.imgbox.com/62/94/5HL2Pzl0_o.png" alt="在这里插入图片描述"></p> 
<p>上图表明了每次的连接到来事件，都会调用 <code>acceptTcpHandler</code> 进行处理，起到了事件监听的效果。</p> 
<h3><a id="_39"></a>事件循环</h3> 
<p>注册好监听事件后，需要启动事件循环器来监听网络事件，Redis 服务端的 <code>main</code> （server.c）函数通过 <code>aemain</code>（ae.c） 会开启一个事件循环，从这可以看出来 Redis 的默认网络模型是单线程的IO多路复用。</p> 
<p><img src="https://images2.imgbox.com/3f/8c/rhCOlOrQ_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">aeMain</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    eventLoop<span class="token operator">-&gt;</span>stop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>eventLoop<span class="token operator">-&gt;</span>stop<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 处理活跃事件，事件类型默认为所有事件、before_sleep与after_sleep</span>
        <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> AE_ALL_EVENTS<span class="token operator">|</span>
                                   AE_CALL_BEFORE_SLEEP<span class="token operator">|</span>
                                   AE_CALL_AFTER_SLEEP<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>其中真正处理事件是在 <code>aeProcessEvents</code> 中，默认 flag 会开启所有事件、before sleep 和 after sleep，<code>aeProcessEvents</code> 是 Redis 网络模块中最重要的函数，属于调度核心，源码如下：</p> 
<p><img src="https://images2.imgbox.com/22/6c/VUKCdMC1_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> processed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> numevents<span class="token punctuation">;</span>

    <span class="token comment">// 即非定时事件也非网络事件，什么也不做</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_FILE_EVENTS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

	<span class="token comment">// 如果有注册的网络事件或者有定时事件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>maxfd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_DONT_WAIT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> j<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">timeval</span> tv<span class="token punctuation">,</span> <span class="token operator">*</span>tvp<span class="token punctuation">;</span>
        <span class="token class-name">int64_t</span> usUntilTimer <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token comment">// 如果有定时事件，取出最近要触发的定时事件时间</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_DONT_WAIT<span class="token punctuation">)</span><span class="token punctuation">)</span>
            usUntilTimer <span class="token operator">=</span> <span class="token function">usUntilEarliestTimer</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 如果最近定时时间大于零则记录到 tv 中，作为事件循环的 timeout</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>usUntilTimer <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            tv<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> usUntilTimer <span class="token operator">/</span> <span class="token number">1000000</span><span class="token punctuation">;</span>
            tv<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> usUntilTimer <span class="token operator">%</span> <span class="token number">1000000</span><span class="token punctuation">;</span>
            tvp <span class="token operator">=</span> <span class="token operator">&amp;</span>tv<span class="token punctuation">;</span>
		<span class="token comment">// 如果最近定时时间小于零，也就是有待触发的定时事件</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 如果是 AE_DONT_WAIT 事件，设置io模型 timeout 为 0，轮询模式</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_DONT_WAIT<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                tv<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> tv<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                tvp <span class="token operator">=</span> <span class="token operator">&amp;</span>tv<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 一般情况设置io模型 timeout 为 NULL，也就是阻塞模式</span>
                tvp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">/* wait forever */</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        
		<span class="token comment">// 如果是 AE_DONT_WAIT 事件，设置io模型 timeout 为 0，轮询模式</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> AE_DONT_WAIT<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            tv<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> tv<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            tvp <span class="token operator">=</span> <span class="token operator">&amp;</span>tv<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
		<span class="token comment">// 处理 beforesleep 回调函数</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>beforesleep <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> flags <span class="token operator">&amp;</span> AE_CALL_BEFORE_SLEEP<span class="token punctuation">)</span>
            eventLoop<span class="token operator">-&gt;</span><span class="token function">beforesleep</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 调用 IO 多路复用网络模型，并设置其 timeout，返回目前活跃网络事件个数</span>
        numevents <span class="token operator">=</span> <span class="token function">aeApiPoll</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> tvp<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 处理 aftersleep 回调函数</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>aftersleep <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> flags <span class="token operator">&amp;</span> AE_CALL_AFTER_SLEEP<span class="token punctuation">)</span>
            eventLoop<span class="token operator">-&gt;</span><span class="token function">aftersleep</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 循环处理活跃网络事件</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> numevents<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> fd <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>fired<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">;</span>
            <span class="token comment">// 取出活跃网络事件</span>
            aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token comment">// 取出活跃网络事件的事件类型</span>
            <span class="token keyword">int</span> mask <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>fired<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>mask<span class="token punctuation">;</span>
            <span class="token keyword">int</span> fired <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* 当前 fd 已处理的事件个数 */</span>

            <span class="token comment">// 是否设置反转标志</span>
            <span class="token keyword">int</span> invert <span class="token operator">=</span> fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> AE_BARRIER<span class="token punctuation">;</span>

            <span class="token comment">// 如果未反转，则先处理可读事件</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>invert <span class="token operator">&amp;&amp;</span> fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 调用当前事件的读回调函数</span>
                fe<span class="token operator">-&gt;</span><span class="token function">rfileProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>fe<span class="token operator">-&gt;</span>clientData<span class="token punctuation">,</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
                fired<span class="token operator">++</span><span class="token punctuation">;</span>
                fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* Refresh in case of resize. */</span>
            <span class="token punctuation">}</span>

            <span class="token comment">// 处理可写事件</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fired <span class="token operator">||</span> fe<span class="token operator">-&gt;</span>wfileProc <span class="token operator">!=</span> fe<span class="token operator">-&gt;</span>rfileProc<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// 调用当前事件的写回调函数</span>
                    fe<span class="token operator">-&gt;</span><span class="token function">wfileProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>fe<span class="token operator">-&gt;</span>clientData<span class="token punctuation">,</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    fired<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token comment">// 如果设置反转，则后处理可读事件</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>invert<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* Refresh in case of resize. */</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                    <span class="token punctuation">(</span><span class="token operator">!</span>fired <span class="token operator">||</span> fe<span class="token operator">-&gt;</span>wfileProc <span class="token operator">!=</span> fe<span class="token operator">-&gt;</span>rfileProc<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">{<!-- --></span>
                    fe<span class="token operator">-&gt;</span><span class="token function">rfileProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>fe<span class="token operator">-&gt;</span>clientData<span class="token punctuation">,</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    fired<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            processed<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
   
    <span class="token comment">// 处理定时事件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS<span class="token punctuation">)</span>
        processed <span class="token operator">+=</span> <span class="token function">processTimeEvents</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
    <span class="token comment">// 返回已处理的网络/定时事件个数</span>
    <span class="token keyword">return</span> processed<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<p>通过 <code>aeProcessEvents</code> 可以理清 Redis 网络处理的主要逻辑，大致会处理两类事件：网络事件、定时事件，对于网络事件，则是会通过 IO 多路复用器 <code>aeApiPoll</code> 来检测活跃事件，并依次处理这些事件的回调函数，其次对于网络事件默认会优先处理可读事件，其次处理可写事件，保证对读事件的高响应；对于定时事件，会根据最近定时触发时间来设置 IO 多路复用模型的 timeout，使得能够及时唤醒 IO 多路复用模型，防止定时事件无法及时得到响应。如果最近定时时间小于零， 会将 timeout 设为 0 以便及时处理定时事件。从该函数中看出，Redis 总是优先处理网络事件，其次处理定时事件。</p> 
<p>事件循环器启动后，如果无时间处理，默认会阻塞在 <code>aeApiPoll</code> 这里，等待事件的到达或者 timeout 时间耗尽才会唤醒并处理事件。</p> 
<h3><a id="_173"></a>建立连接</h3> 
<p>Redis 客户端发起连接请求，通常情况下服务器会在 <code>aeApiPoll</code> 阻塞中被唤醒（如果空闲），产生读事件，因此会调用 <code>fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask)</code> ，来进行处理该事件。</p> 
<p>新连接事件的处理函数在 Redis 服务器 initServer 阶段被注册为 <code>acceptTcpHandler</code> ，因此 rfileProc 最终调用的函数是 <code>acceptTcpHandler</code>，通过该函数来与客户端建立连接，代码如下：</p> 
<p><img src="https://images2.imgbox.com/47/c5/gSCd4tVD_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">acceptTcpHandler</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> cport<span class="token punctuation">,</span> cfd<span class="token punctuation">,</span> max <span class="token operator">=</span> MAX_ACCEPTS_PER_CALL<span class="token punctuation">;</span>
    <span class="token keyword">char</span> cip<span class="token punctuation">[</span>NET_IP_STR_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">UNUSED</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">UNUSED</span><span class="token punctuation">(</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">UNUSED</span><span class="token punctuation">(</span>privdata<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// max为每次最大接受连接的数量</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>max<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 通过 accept 接收连接，得到客户端文件描述符 cfd</span>
        cfd <span class="token operator">=</span> <span class="token function">anetTcpAccept</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>neterr<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> cip<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cip<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>cport<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cfd <span class="token operator">==</span> ANET_ERR<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">!=</span> EWOULDBLOCK<span class="token punctuation">)</span>
                <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span>
                    <span class="token string">"Accepting client connection: %s"</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>neterr<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 开启 cloexec 选项</span>
        <span class="token function">anetCloexec</span><span class="token punctuation">(</span>cfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_VERBOSE<span class="token punctuation">,</span><span class="token string">"Accepted %s:%d"</span><span class="token punctuation">,</span> cip<span class="token punctuation">,</span> cport<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 创建客户端对象和连接对象</span>
        <span class="token function">acceptCommonHandler</span><span class="token punctuation">(</span><span class="token function">connCreateAcceptedSocket</span><span class="token punctuation">(</span>cfd<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>cip<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里由于服务器 listenfd 是非阻塞套接字，因此可以使用一个参数 max 来限制每次accept的连接数量。 <code>acceptTcpHandler</code> 中通过 <code>anetTcpAccept</code> 对客户端事件进行响应，得到客户端的文件描述符。其次打开了 cfd 的 cloexec 选项，该选项防止在执行 exec 系函数的进程中会继承 cfd。然后调用 <code>acceptCommonHandler</code> 来创建客户端对象，其中 <code>connCreateAcceptedSocket</code> 创建 cfd 对应的连接对象 connection：</p> 
<pre><code class="prism language-c">connection <span class="token operator">*</span><span class="token function">connCreateAcceptedSocket</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    connection <span class="token operator">*</span>conn <span class="token operator">=</span> <span class="token function">connCreateSocket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    conn<span class="token operator">-&gt;</span>fd <span class="token operator">=</span> fd<span class="token punctuation">;</span>
    conn<span class="token operator">-&gt;</span>state <span class="token operator">=</span> CONN_STATE_ACCEPTING<span class="token punctuation">;</span>
    <span class="token keyword">return</span> conn<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
connection <span class="token operator">*</span><span class="token function">connCreateSocket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    connection <span class="token operator">*</span>conn <span class="token operator">=</span> <span class="token function">zcalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 设置回调函数</span>
    conn<span class="token operator">-&gt;</span>type <span class="token operator">=</span> <span class="token operator">&amp;</span>CT_Socket<span class="token punctuation">;</span>
    conn<span class="token operator">-&gt;</span>fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> conn<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>创建新的连接对象 conn，主要的工作是注册了回调函数结构体 conn-&gt;type，该结构定义了 read、write 等常规系统调用回调函数，其次设置连接的 fd、state。</p> 
<p>创建好连接对象，便通过 <code>acceptCommonHandler</code> 创建客户端对象：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_ACCEPTS_PER_CALL</span> <span class="token expression"><span class="token number">1000</span></span></span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">acceptCommonHandler</span><span class="token punctuation">(</span>connection <span class="token operator">*</span>conn<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>ip<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    client <span class="token operator">*</span>c<span class="token punctuation">;</span>
    <span class="token keyword">char</span> conninfo<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">UNUSED</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 如果客户端连接状态为 accepting，则出错处理</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">connGetState</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span> <span class="token operator">!=</span> CONN_STATE_ACCEPTING<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 代码省略...</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 如果客户端连接超出限制，出错处理</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">getClusterConnectionsCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token operator">&gt;=</span> server<span class="token punctuation">.</span>maxclients<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 代码省略...</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* 创建客户端对象 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token function">createClient</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 代码省略...</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 设置客户端对象的状态</span>
    c<span class="token operator">-&gt;</span>flags <span class="token operator">|=</span> flags<span class="token punctuation">;</span>

    <span class="token comment">// </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">connAccept</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> clientAcceptHandler<span class="token punctuation">)</span> <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
       <span class="token comment">// 代码省略...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>acceptCommonHandler</code> 中除了一些异常处理之外，最主要的是调用了 <code>createClient</code> 来生成客户端对象，主要代码如下：</p> 
<p><img src="https://images2.imgbox.com/73/66/o1Y7ydy8_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c">client <span class="token operator">*</span><span class="token function">createClient</span><span class="token punctuation">(</span>connection <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>conn<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 设置非阻塞模式</span>
        <span class="token function">connNonBlock</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 打开TCPNoDelay选项</span>
        <span class="token function">connEnableTcpNoDelay</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 开启 keepalive 选项</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>tcpkeepalive<span class="token punctuation">)</span>
            <span class="token function">connKeepAlive</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span>server<span class="token punctuation">.</span>tcpkeepalive<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 绑定客户端读事件回调</span>
        <span class="token function">connSetReadHandler</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> readQueryFromClient<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 将连接对象 private_data 设为 客户端对象 c</span>
        <span class="token function">connSetPrivateData</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 初始化 client 参数</span>
	<span class="token comment">// 代码省略...</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>createClient</code> 主要对客户端对象client进行创建，需要注意的是，这里考虑了 conn 为空，也就是空连接的情况，这是因为有一些客户端无需处理网络连接，比如 lua 脚本，只需要使用到客户端对象的上下文。创建客户端步骤如下：</p> 
<ul><li>设置连接为非阻塞模式。</li><li>打开 TCPNoDelay 选项，禁用了Nagle算法,允许小包的发送。</li><li>开启 tcp keepalive 选项，用于开启TCP探活机制。</li><li>向网络模型注册客户端读事件和其回调函数 <code>readQueryFromClient</code>，保证了客户端有读事件到来会调用该函数。</li><li>将客户端对象设为连接对象的 private_data 成员。</li><li>初始化客户端各项参数。</li></ul> 
<p>这里最重要的是 <code>connSetReadHandler</code> 注册读事件，这里最终注册的是 <code>callHandler</code>（connhelper.c）函数：</p> 
<p><img src="https://images2.imgbox.com/d1/75/VER5RgNZ_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">callHandler</span><span class="token punctuation">(</span>connection <span class="token operator">*</span>conn<span class="token punctuation">,</span> ConnectionCallbackFunc handler<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">connIncrRefs</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 真正调用回调函数的地方（readQueryFromClient）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>handler<span class="token punctuation">)</span> <span class="token function">handler</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">connDecrRefs</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>conn<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CONN_FLAG_CLOSE_SCHEDULED<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">connHasRefs</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">connClose</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上述函数中对连接对象 conn 使用了引用计数，通过 connIncrRef 和 connDecrRef，防止连接事件未处理完就被关闭。</p> 
<p>到此为止一个新的客户端连接已经建立完毕，接下来是等待客户端的请求。</p> 
<h3><a id="_325"></a>处理请求</h3> 
<p>建立完客户端连接，服务器便等待客户端的请求到来。如果此时有请求到来，同样服务器会在 <code>aeApiPoll</code> 阻塞中被唤醒（如果空闲），产生读事件，调用 <code>fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask)</code> ，其中 rfileProc 最终调用的是 <code>readQueryFromClient</code> 函数处理客户端请求。</p> 
<p><img src="https://images2.imgbox.com/a3/c5/39iPwZNp_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>connection <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 得到客户端对象</span>
    client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">connGetPrivateData</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> nread<span class="token punctuation">,</span> readlen<span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> qblen<span class="token punctuation">;</span>

    <span class="token comment">// 用于多线程 I/O</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">postponeClientRead</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token comment">// 记录服务器读处理次数</span>
    <span class="token function">atomicIncr</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>stat_total_reads_processed<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 每次读取的最大字节数</span>
    readlen <span class="token operator">=</span> PROTO_IOBUF_LEN<span class="token punctuation">;</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reqtype <span class="token operator">==</span> PROTO_REQ_MULTIBULK <span class="token operator">&amp;&amp;</span> c<span class="token operator">-&gt;</span>multibulklen <span class="token operator">&amp;&amp;</span> c<span class="token operator">-&gt;</span>bulklen <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span>
        <span class="token operator">&amp;&amp;</span> c<span class="token operator">-&gt;</span>bulklen <span class="token operator">&gt;=</span> PROTO_MBULK_BIG_ARG<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ssize_t</span> remaining <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>bulklen<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">sdslen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* Note that the 'remaining' variable may be zero in some edge case,
         * for example once we resume a blocked client after CLIENT PAUSE. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>remaining <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> remaining <span class="token operator">&lt;</span> readlen<span class="token punctuation">)</span> readlen <span class="token operator">=</span> remaining<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	<span class="token comment">// 计算读缓冲区已有数据大小</span>
    qblen <span class="token operator">=</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf_peak <span class="token operator">&lt;</span> qblen<span class="token punctuation">)</span> c<span class="token operator">-&gt;</span>querybuf_peak <span class="token operator">=</span> qblen<span class="token punctuation">;</span>
	<span class="token comment">// 扩大缓冲区至 readlen</span>
    c<span class="token operator">-&gt;</span>querybuf <span class="token operator">=</span> <span class="token function">sdsMakeRoomFor</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 读取客户端数据</span>
    nread <span class="token operator">=</span> <span class="token function">connRead</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">,</span> c<span class="token operator">-&gt;</span>querybuf<span class="token operator">+</span>qblen<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 省略读结果处理代码</span>
 
	<span class="token comment">// 更新接收缓冲区长度</span>
    <span class="token function">sdsIncrLen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">,</span>nread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 省略代码</span>

   	<span class="token comment">// 处理读缓冲区中的数据</span>
     <span class="token function">processInputBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>从 <code>readQueryFromClient</code> 函数可以看出其主要工作是通过 connRead 将客户端请求的数据读入到客户端读缓存区 c-&gt;querybuf，connRead 是调用了 read系统调用函数来读取数据，在读取数据之前需要对客户端读缓冲区大小进行调整，防止缓冲区过小，Redis 的字符串结构 sds 有提供这类接口 <code>sdsMakeRoomFor</code> 用来扩充缓冲区的可用空间。获取到客户端数据后，通过 <code>processInputBuffer</code> 对读缓存区数据进行处理。</p> 
<p><img src="https://images2.imgbox.com/36/43/VRCRwbF0_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">processInputBuffer</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 循环处理客户端请求，通过标识 c-&gt;qb_pos 位判断</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>qb_pos <span class="token operator">&lt;</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        
        <span class="token comment">// 省略代码，客户端处于某些 flag 状态下无需处理请求，直接退出</span>

        <span class="token comment">// 判断请求协议是RESP还是纯字符串inline（未编码）格式</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>c<span class="token operator">-&gt;</span>reqtype<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">[</span>c<span class="token operator">-&gt;</span>qb_pos<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                c<span class="token operator">-&gt;</span>reqtype <span class="token operator">=</span> PROTO_REQ_MULTIBULK<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                c<span class="token operator">-&gt;</span>reqtype <span class="token operator">=</span> PROTO_REQ_INLINE<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 处理 inline 格式</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reqtype <span class="token operator">==</span> PROTO_REQ_INLINE<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">processInlineBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果开启gopher模式且非多线程模式，处理gopher协议格式</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>gopher_enabled <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>server<span class="token punctuation">.</span>io_threads_do_reads <span class="token operator">&amp;&amp;</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>argc <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token operator">||</span>
                  c<span class="token operator">-&gt;</span>argc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token function">processGopherRequest</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">resetClient</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
                c<span class="token operator">-&gt;</span>flags <span class="token operator">|=</span> CLIENT_CLOSE_AFTER_REPLY<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token comment">// 处理RESP格式协议</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reqtype <span class="token operator">==</span> PROTO_REQ_MULTIBULK<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">processMultibulkBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">serverPanic</span><span class="token punctuation">(</span><span class="token string">"Unknown request type"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 参数为0，</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>argc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">resetClient</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// Redis多线程模式， IO 线程中不立即执行命令，直接退出</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_PENDING_READ<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                c<span class="token operator">-&gt;</span>flags <span class="token operator">|=</span> CLIENT_PENDING_COMMAND<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token comment">// 终于在这里可以执行客户端命令</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">processCommandAndResetClient</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 客户端已经不存在会返回ERR，直接退出</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 重置客户端请求位标识</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>qb_pos<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">sdsrange</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>qb_pos<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        c<span class="token operator">-&gt;</span>qb_pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>processInputBuffer</code> 中需要判断客户端请求的协议格式，默认情况下是 RESP 协议，该协议能序列化整型、字符串等结构，是一种文本协议。RESP 是二进制安全的，并且不需要处理从一个进程发到另外一个进程的批量数据，因为它使用前缀长度来传输批量数据。下图说明 RESP 协议的字段含义：</p> 
<p><img src="https://images2.imgbox.com/ee/8d/gCI0jlAS_o.png" alt="img"></p> 
<p>Redis官方协议文档：<a href="https://www.redis.com.cn/topics/protocol.html" rel="nofollow">Redis协议详细规范</a></p> 
<p>请求的具体解析由 <code>processMultibulkBuffer</code> 函数来执行，这里就不展开该函数，其工作是根据 RESP 协议格式，把请求内容解析为 Redis 字符串格式，存放到客户端对象的 argc、argv 中。</p> 
<p>解析完成后，调用 <code>processCommandAndResetClient</code> 来执行客户端命令，其主要调用 <code>processCommand</code> 来执行命令，函数定义如下：</p> 
<p><img src="https://images2.imgbox.com/79/e4/rZQtf9bm_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">processCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    
    <span class="token comment">// 代码省略</span>
    
    <span class="token comment">// 找到相应命令的执行函数</span>
    c<span class="token operator">-&gt;</span>cmd <span class="token operator">=</span> c<span class="token operator">-&gt;</span>lastcmd <span class="token operator">=</span> <span class="token function">lookupCommand</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 处理命令异常情况，省略</span>

    <span class="token comment">// 根据命令类型设置相应字段</span>
    <span class="token keyword">int</span> is_read_command <span class="token operator">=</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CMD_READONLY<span class="token punctuation">)</span> <span class="token operator">||</span>
                           <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>proc <span class="token operator">==</span> execCommand <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>mstate<span class="token punctuation">.</span>cmd_flags <span class="token operator">&amp;</span> CMD_READONLY<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> is_write_command <span class="token operator">=</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CMD_WRITE<span class="token punctuation">)</span> <span class="token operator">||</span>
                           <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>proc <span class="token operator">==</span> execCommand <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>mstate<span class="token punctuation">.</span>cmd_flags <span class="token operator">&amp;</span> CMD_WRITE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> is_denyoom_command <span class="token operator">=</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CMD_DENYOOM<span class="token punctuation">)</span> <span class="token operator">||</span>
                             <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>proc <span class="token operator">==</span> execCommand <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>mstate<span class="token punctuation">.</span>cmd_flags <span class="token operator">&amp;</span> CMD_DENYOOM<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> is_denystale_command <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CMD_STALE<span class="token punctuation">)</span> <span class="token operator">||</span>
                               <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>proc <span class="token operator">==</span> execCommand <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>mstate<span class="token punctuation">.</span>cmd_inv_flags <span class="token operator">&amp;</span> CMD_STALE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> is_denyloading_command <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CMD_LOADING<span class="token punctuation">)</span> <span class="token operator">||</span>
                                 <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>proc <span class="token operator">==</span> execCommand <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>mstate<span class="token punctuation">.</span>cmd_inv_flags <span class="token operator">&amp;</span> CMD_LOADING<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> is_may_replicate_command <span class="token operator">=</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>CMD_WRITE <span class="token operator">|</span> CMD_MAY_REPLICATE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span>
                                   <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>proc <span class="token operator">==</span> execCommand <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>mstate<span class="token punctuation">.</span>cmd_flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>CMD_WRITE <span class="token operator">|</span> CMD_MAY_REPLICATE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 处理认证模式，代码省略</span>

    <span class="token comment">// 处理集群模式，代码省略</span>

    <span class="token comment">// 处理最大内存使用限制功能，如果上限会拒绝某类请求</span>

    <span class="token comment">// 处理其他情况，代码省略</span>

    <span class="token comment">// 处理事务</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_MULTI <span class="token operator">&amp;&amp;</span>
        c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>proc <span class="token operator">!=</span> execCommand <span class="token operator">&amp;&amp;</span> c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>proc <span class="token operator">!=</span> discardCommand <span class="token operator">&amp;&amp;</span>
        c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>proc <span class="token operator">!=</span> multiCommand <span class="token operator">&amp;&amp;</span> c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>proc <span class="token operator">!=</span> watchCommand <span class="token operator">&amp;&amp;</span>
        c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>proc <span class="token operator">!=</span> resetCommand<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">queueMultiCommand</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>queued<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 执行命令</span>
        <span class="token function">call</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>CMD_CALL_FULL<span class="token punctuation">)</span><span class="token punctuation">;</span>
        c<span class="token operator">-&gt;</span>woff <span class="token operator">=</span> server<span class="token punctuation">.</span>master_repl_offset<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>ready_keys<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">handleClientsBlockedOnKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到 <code>processCommand</code> 事实上主要是调用 <code>lookupCommand</code> 来根据请求内容查找到对应的命令执行函数，来填充客户端 cmd 字段。</p> 
<p>其次最重要的就是调用 <code>call</code> 函数，该函数是真正执行客户端命令的地方，属于 Redis 执行命令的核心函数，其中调用了 <code>c-&gt;cmd-&gt;proc(c)</code>，来调用 <code>lookupCommand</code> 绑定好的命令执行函数来真正执行命令。</p> 
<h3><a id="_510"></a>响应请求</h3> 
<p>在调用相应的命令执行函数并执行完成后，会调用 <code>addReply</code> 生成响应数据，填入到客户端的写缓冲区。其函数定义如下：</p> 
<p><img src="https://images2.imgbox.com/b1/6b/Vfx5yX48_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">addReply</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">,</span> robj <span class="token operator">*</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">prepareClientToWrite</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sdsEncodedObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_addReplyToBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>obj<span class="token operator">-&gt;</span>ptr<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>obj<span class="token operator">-&gt;</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span>
            <span class="token function">_addReplyProtoToList</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>obj<span class="token operator">-&gt;</span>ptr<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>obj<span class="token operator">-&gt;</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token operator">-&gt;</span>encoding <span class="token operator">==</span> OBJ_ENCODING_INT<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token class-name">size_t</span> len <span class="token operator">=</span> <span class="token function">ll2string</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>obj<span class="token operator">-&gt;</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_addReplyToBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>len<span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span>
            <span class="token function">_addReplyProtoToList</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">serverPanic</span><span class="token punctuation">(</span><span class="token string">"Wrong obj-&gt;encoding in addReply()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>addReply</code> 首先会调用 <code>prepareClientToWrite</code> ，该函数主要是判断客户端是否还有未发送完的数据，如果存在，将未发送完的数据附加到未发送数据尾部并注册写事件，其函数定义如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">prepareClientToWrite</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 省略代码</span>
    
    <span class="token comment">// 判断当前客户端发送缓冲区是否有未发送完的数据</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_PENDING_READ<span class="token punctuation">)</span><span class="token punctuation">)</span>
        	<span class="token comment">// 注册写事件，将数据附加到未发送数据尾部</span>
            <span class="token function">clientInstallWriteHandler</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>其次 <code>addReply</code> 会调用 <code>_addReplyToBuffer</code> 函数，该函数将返回消息写入客户端发送缓冲区 c-&gt;buf，如果发送缓冲区已有数据，则调用 <code>_addReplyProtoToList</code> 将待发送数据添加到上一次未发送数据 c-&gt;reply 尾部。</p> 
<p><img src="https://images2.imgbox.com/d0/87/NJhhR82k_o.png" alt="在这里插入图片描述"></p> 
<p>到此可写事件已经注册完毕，整个的客户端数据从接收到解析到处理，已经全部执行完毕，就等待响应消息发出。</p> 
<p>Redis 如何将消息发出？是使用 beforeSleep，在文章开头介绍的事件循环函数 <code>aeProcessEvents</code> 中可以知道， beforeSleep 是在监听事件前执行的 hook 函数，Redis server 在初始化阶段已将 beforeSleep 绑定到 ae-&gt;before_sleep。该函数定义如下：</p> 
<p><img src="https://images2.imgbox.com/9f/0f/NmrN5yuU_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">beforeSleep</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 
    <span class="token comment">// 省略代码</span>
    
    <span class="token function">handleClientsWithPendingWritesUsingThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 省略代码</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里我们省略其他代码，只考虑发送消息相关代码。发送消息在 <code>handleClientsWithPendingWritesUsingThreads</code> 中，Redis 默认是单线程，我们不考虑多线程情况，这个函数会判断是否开启了多线程模式，如果未开启会直接调用 <code>handleClientsWithPendingWrites</code>。该函数定义如下：</p> 
<p><img src="https://images2.imgbox.com/a5/86/ck1Km7DA_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">handleClientsWithPendingWrites</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    listIter li<span class="token punctuation">;</span>
    listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>
	<span class="token comment">// 获取未发送消息客户端个数</span>
    <span class="token keyword">int</span> processed <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 逐个获取客户端</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 取消可写标志</span>
        c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;=</span> <span class="token operator">~</span>CLIENT_PENDING_WRITE<span class="token punctuation">;</span>
        <span class="token comment">// 从未发送消息客户端list删除当前客户端</span>
        <span class="token function">listDelNode</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">,</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_PROTECTED<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_CLOSE_ASAP<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>

        <span class="token comment">// 真正发送消息</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">writeToClient</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>

        <span class="token comment">// 如果数据未全部发送完</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> ae_barrier <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token comment">// 设置 ae_barrier 确保可写事件先与可读事件执行</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_state <span class="token operator">==</span> AOF_ON <span class="token operator">&amp;&amp;</span>
                server<span class="token punctuation">.</span>aof_fsync <span class="token operator">==</span> AOF_FSYNC_ALWAYS<span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                ae_barrier <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 注册可写事件回调 sendReplyToClient</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">connSetWriteHandlerWithBarrier</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">,</span> sendReplyToClient<span class="token punctuation">,</span> ae_barrier<span class="token punctuation">)</span> <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> processed<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>handleClientsWithPendingWrites</code> 会从 clients_pending_write 链表中依次取出待发送消息的客户端，然后分别给每个客户端发送消息。从 <code>handleClientsWithPendingWrites</code> 函数可以看出，Redis 发送消息的逻辑是先直接调用 <code>writeToClient</code> 将数据发出，如果数据因为网络原因或者客户端原语未全部发送完毕，再通过 <code>connSetWriteHandlerWithBarrier</code> 注册可写事件。</p> 
<p><img src="https://images2.imgbox.com/28/bd/Ev1cr8k2_o.png" alt="在这里插入图片描述"></p> 
<p><code>writeToClient</code>负责发送数据，<code>writeToClient</code> 函数定义如下：</p> 
<p><img src="https://images2.imgbox.com/89/dc/SxQS26Sb_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">writeToClient</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">int</span> handler_installed<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">atomicIncr</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>stat_total_writes_processed<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">ssize_t</span> nwritten <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> totwritten <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> objlen<span class="token punctuation">;</span>
    clientReplyBlock <span class="token operator">*</span>o<span class="token punctuation">;</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>bufpos <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            nwritten <span class="token operator">=</span> <span class="token function">connWrite</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>buf<span class="token operator">+</span>c<span class="token operator">-&gt;</span>sentlen<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>bufpos<span class="token operator">-</span>c<span class="token operator">-&gt;</span>sentlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
            c<span class="token operator">-&gt;</span>sentlen <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>
            totwritten <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>

            <span class="token comment">// 如果全部发送完毕，清零相关变量</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>c<span class="token operator">-&gt;</span>sentlen <span class="token operator">==</span> c<span class="token operator">-&gt;</span>bufpos<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                c<span class="token operator">-&gt;</span>bufpos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                c<span class="token operator">-&gt;</span>sentlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 缓冲区数据发送完毕，从 reply 中拿待发送数据</span>
            o <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span><span class="token function">listFirst</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            objlen <span class="token operator">=</span> o<span class="token operator">-&gt;</span>used<span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>objlen <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                c<span class="token operator">-&gt;</span>reply_bytes <span class="token operator">-=</span> o<span class="token operator">-&gt;</span>size<span class="token punctuation">;</span>
                <span class="token function">listDelNode</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">,</span><span class="token function">listFirst</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token comment">// 发送数据</span>
            nwritten <span class="token operator">=</span> <span class="token function">connWrite</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">,</span> o<span class="token operator">-&gt;</span>buf <span class="token operator">+</span> c<span class="token operator">-&gt;</span>sentlen<span class="token punctuation">,</span> objlen <span class="token operator">-</span> c<span class="token operator">-&gt;</span>sentlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 发送失败或者未发送出任何数据则退出</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
            c<span class="token operator">-&gt;</span>sentlen <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>
            totwritten <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>

           <span class="token comment">// 如果全部发送完毕</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>sentlen <span class="token operator">==</span> objlen<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                c<span class="token operator">-&gt;</span>reply_bytes <span class="token operator">-=</span> o<span class="token operator">-&gt;</span>size<span class="token punctuation">;</span>
                <span class="token function">listDelNode</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">,</span><span class="token function">listFirst</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                c<span class="token operator">-&gt;</span>sentlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token comment">// 断言确保数据全部发送</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">listLength</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    <span class="token function">serverAssert</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply_bytes <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        
        <span class="token comment">// 防止写操作写过多数据，slave 服务除外</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>totwritten <span class="token operator">&gt;</span> NET_MAX_WRITES_PER_EVENT <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span>
             <span class="token function">zmalloc_used_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>maxmemory<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
            <span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_SLAVE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">atomicIncr</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>stat_net_output_bytes<span class="token punctuation">,</span> totwritten<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 处理写异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">connGetState</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">)</span> <span class="token operator">!=</span> CONN_STATE_CONNECTED<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_VERBOSE<span class="token punctuation">,</span>
                <span class="token string">"Error writing to client: %s"</span><span class="token punctuation">,</span> <span class="token function">connGetLastError</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>totwritten <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_MASTER<span class="token punctuation">)</span><span class="token punctuation">)</span> c<span class="token operator">-&gt;</span>lastinteraction <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        c<span class="token operator">-&gt;</span>sentlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">// 多线程相关</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>handler_installed<span class="token punctuation">)</span> <span class="token function">connSetWriteHandler</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 关闭发送完毕的客户端连接</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_CLOSE_AFTER_REPLY<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>writeToClient</code> 会先把写缓冲区 c-&gt;buf 中的数据发送出去，然后再依次发送 c-&gt;reply 中所有的数据，如果数据未全部发送完直接退出 reply 循环。</p> 
<p>数据未发送完毕，会将 <code>sendReplyToClient</code> 注册为写事件回调，其函数定义如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">sendReplyToClient</span><span class="token punctuation">(</span>connection <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">connGetPrivateData</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">writeToClient</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>其实还是调用了 <code>writeToClient</code> 函数，直到数据发送完为止，会取消可写事件。</p> 
<p>Redis 整个从建立连接到发送响应的流程：</p> 
<p><img src="https://images2.imgbox.com/2f/f7/2atNaFCS_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7463f4be6c158b63a8bf0bcc07b2a2e0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微信小程序云开发笔记：2.代码结构初始化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5dff9041f52321fedf0a601726286189/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IIS错误:不能在此路径中使用此配置节。如果在父级别上锁定了该节，便会出现这种情况。锁定是默认设置的(overrideModeDefault=“Deny“)......</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>