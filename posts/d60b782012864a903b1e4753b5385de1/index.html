<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL元数据获取基础笔记day05 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySQL元数据获取基础笔记day05" />
<meta property="og:description" content="多表连接查询 1、作用 业务需要的数据来自多张表时 2、多表连接查询基本语法 ??内连接
? 外链接
全链接
笛卡尔
3、内连接的类型 传统连接 where
自连接
join ming
join on ? ? ? ? ?
4、join on的语法 select xxx
from A
join B
on A.xxx=B.yyy
where
group
having
order by
limit
把原来的两张表按照一定的逻辑条件并成了一张表。
select a.name,b.addr from a join b on a.id=b.id where a.name=&#39;zhongsan&#39;;
如果是3张表 A B C
那么先A join C
on A.xx=C.yy
join B
on C.aa=B.bb
5、多表连接的套路： 1.根据需求找到关联表。
2.找到表与表的关联列。
3.列名调用时，需要添加表前缀，例如a.id ,b.name之类
多表连接案例 world表为例。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d60b782012864a903b1e4753b5385de1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-23T17:42:34+08:00" />
<meta property="article:modified_time" content="2019-08-23T17:42:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL元数据获取基础笔记day05</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>多表连接查询</h2> 
<h3>1、作用 业务需要的数据来自多张表时</h3> 
<h3>2、多表连接查询基本语法</h3> 
<blockquote> 
 <p>??内连接<br> ? 外链接<br> 全链接<br> 笛卡尔</p> 
</blockquote> 
<h3>3、内连接的类型</h3> 
<p>传统连接 where<br> 自连接<br> join ming<br> join on ? ? ? ? ?</p> 
<h3>4、join on的语法</h3> 
<blockquote> 
 <p>select xxx<br> from A<br> join B<br> on A.xxx=B.yyy<br> where<br> group<br> having<br> order by<br> limit</p> 
</blockquote> 
<p>把原来的两张表按照一定的逻辑条件并成了一张表。</p> 
<blockquote> 
 <p>select a.name,b.addr from a join b on a.id=b.id where a.name='zhongsan';<br> 如果是3张表 A B C<br> 那么先A join C<br> on A.xx=C.yy<br> join B<br> on C.aa=B.bb</p> 
</blockquote> 
<h3>5、多表连接的套路：</h3> 
<p>1.根据需求找到关联表。<br> 2.找到表与表的关联列。<br> 3.列名调用时，需要添加表前缀，例如a.id ,b.name之类</p> 
<p>多表连接案例 world表为例。<br> 查询人口数量少于100人的城市所在的国家名、国土面积、城市名和人口名。</p> 
<blockquote> 
 <p>SELECT country.name,country.surfacearea,city.name,city.population<br> from city<br> join country<br> on city.countrycode=country.code<br> WHERE city.population&lt;100;</p> 
</blockquote> 
<p>5.2 查询zhang3学习了几门课程</p> 
<p>涉及到的表 student<br> sc</p> 
<blockquote> 
 <p>select student.sname,count(sc.cno) from student join sc<br> on student.sno=sc.sno<br> where student.sname='zhang3';</p> 
</blockquote> 
<p>5.3 统计zhang3学习了课程 名称<br> student<br> sc<br> course</p> 
<blockquote> 
 <p>select student.sname,group_concat(course.cname) from student join sc on student.sno=sc.sno<br> join course<br> on sc.cno=course.cno<br> where student.sname='zhang3';</p> 
</blockquote> 
<p>5.4 oldguo老师教了学生的个数<br> teacher</p> 
<blockquote> 
 <p>select teacher.tname,count(student.sno)<br> from teacher<br> join course<br> on teacher.tno=course.tno<br> join sc<br> on course.cno=sc.cno<br> join student<br> on sc.sno=student.sno<br> where teacher.tname='oldguo';</p> 
</blockquote> 
<p>5.5 每位老师所教课程的平均分，并按平均分排序</p> 
<blockquote> 
 <p>select teacher.tname,avg(sc.score)<br> from teacher<br> join course<br> on teacher.tno=course.tno<br> join sc<br> on course.cno=sc.cno<br> group by teacher.tno,teacher.tname<br> order by avg(sc.score);</p> 
</blockquote> 
<p>5.6 查询oldguo所教的不及格的学生姓名</p> 
<blockquote> 
 <p>select teacher.tname,group_concat(student.sname)<br> from teacher<br> join course<br> on teacher.tno=course.tno<br> join sc<br> on course.cno=sc.cno<br> join student<br> on sc.sno=student.sno<br> where teacher.tname='oldguo' and sc.score&lt;60;</p> 
</blockquote> 
<p>5.7 查询所有老师所教学生不及格的信息</p> 
<blockquote> 
 <p>select teacher.tname, group_concat(student.sname)<br> from teacher<br> join course<br> on teacher.tno=course.tno<br> join sc<br> on course.cno=sc.cno<br> join student<br> on sc.sno=student.sno<br> where sc.score&lt;60<br> group by teacher.tname;</p> 
</blockquote> 
<p>6.别名的使用。<br> 6.1 表别名</p> 
<blockquote> 
 <p>select a.tname, group_concat(d.sname)<br> from teacher as a<br> join course as b<br> on a.tno=b.tno<br> join sc as c<br> on b.cno=c.cno<br> join student as d<br> on c.sno=d.sno<br> where c.score&lt;60<br> group by a.tname;</p> 
</blockquote> 
<p>说明：表别名一般是在from的表的表名，或者join后的表的别名。<br> 在where, group by ,select后的列，having, order by</p> 
<p>6.2 列别名</p> 
<blockquote> 
 <p>select a.tname as 讲师,group_concat(d.sname) as 学生<br> from teacher as a<br> join course as b<br> on a.tno=b.tno<br> join sc as c<br> on b.cno=c.cno<br> join student as d<br> on c.sno=d.sno<br> where c.score&lt;60<br> group by a.tname;</p> 
</blockquote> 
<blockquote> 
 <p>select 列<br> from 表 表别名<br> where 表别名.列<br> group b考别名. 列<br> having 列别名<br> order by 列别名</p> 
</blockquote> 
<p>说明：列别名一般是在select后的列，定义的别名<br> 作用：1.结果集显示会以别名形式展示。<br> 2.在having和order by 中可以调用列别名。</p> 
<h3>7.外链接简介</h3> 
<blockquote> 
 <p>left join<br> a left join b<br> on a.x=b.y<br> right join</p> 
</blockquote> 
<h2>8.元数据获取</h2> 
<p>基表----数据字典信息（列结构frm），系统状态，对象状态。<br> 相当于linux inode</p> 
<p>DDL DCL</p> 
<blockquote> 
 <p>information_schema 虚拟库 视图</p> 
</blockquote> 
<p>8.1 show 语句 （mysql独家）</p> 
<blockquote> 
 <p>show databases;<br> show tables;<br> show create databases xxx;<br> show create table xxx;<br> show grant for xxx(用户);<br> show charset;（支持字符集情况;<br> show collation;校对<br> show variables like ''%trx%;<br> show engines; (存储引擎)<br> show process list; （进程）<br> show index from t1; (查看索引)<br> show status;（看数据库状态）<br> show engine innodb status\G;（看存储引擎状态）<br> show binlog events in'';(二进制)<br> show binary logs;<br> show master status;<br> show slave status\G;<br> show relaylog events in ''；<br> show table status;<br> help show;</p> 
</blockquote> 
<p>8.2 information_schema虚拟库<br> information_schema ---&gt;values 视图</p> 
<p>8.2.1 TABLES作用和结构</p> 
<p>视图中保存中mysql所有的表的元数据信息。<br> 作用：存储整个数据库中，所有表的元数据查询方式。</p> 
<blockquote> 
 <p>desc tables;<br> TABLE_SCHEMA 表所在的库<br> TABLE_NAME 表名<br> ENGINE 表的引擎<br> TABLE_ROWS 表的行数<br> AVG_ROW_LENGTH 平均行长度<br> INDEX_LENGTH 索引长度</p> 
</blockquote> 
<p>例子：<br> 1、查询world数据库下所有的表名。</p> 
<blockquote> 
 <p>show tables from world;</p> 
</blockquote> 
<blockquote> 
 <p>use information_schema;<br> 2、查询整个数据库下所有的表名。<br> select table_name from information_schema.tables;<br> 3.查询所有innodb引擎的表<br> select * from information_schema.tables where engine='innodb';</p> 
</blockquote> 
<p>4.统计每张表的实际空间占用大小情况(avg_row_length*table_rows+index_length)一张表的空间占用大小情况</p> 
<blockquote> 
 <p>select table_name , avg_row_length*table_rows+index_length<br> from information_schema.tables;</p> 
</blockquote> 
<p>5.统计每个库的空间使用情况大小</p> 
<blockquote> 
 <p>select table_schema,<br> sum(avg_row_length*table_rows+index_length)/1024/1024 as total_mb<br> from information_schema.tables<br> group by table_schema ;</p> 
</blockquote> 
<p>6.对mysql的数据库进行分库分表备份</p> 
<blockquote> 
 <p>mysqldump -uroot -p world(库名) city（表名） &gt;/backup/world_city.sql</p> 
</blockquote> 
<blockquote> 
 <p>SELECT CONCAT("mysqldump -uroot -p123456 ",table_schema ," ",table_name ," &gt;/backup/",table_schema,<br> "_",table_name,".sql")<br> FROM information_schema.tables INTO OUTFILE '/tmp/bak.sql';</p> 
</blockquote> 
<p>会报错，这是5.7以后的一个约束，需要把参数加入配置文件中。然后保存退出，重启数据库，每次导出名不能重复。</p> 
<blockquote> 
 <p>secure-file-priv=/tmp</p> 
</blockquote> 
<p>然后进入相应目录 sh 执行脚本即可。</p> 
<p>7.模仿模版语句，对world数据库下的表进行批量操作。<br> alter table world.city discard table space;</p> 
<blockquote> 
 <p>select concat("alter table ",table_schema,".",table_name," discard table space;") from information_schema.tables where table_schema='world'<br> into outfield '/tmp/discard.sql'<br> ;</p> 
</blockquote> 
<ol start="8"><li> 
  <blockquote> 
   <p>索引及执行计划管理<br> 1.索引的作用<br> 类似于一本书的目录，起到优化查询的功能。<br> 2.索引类型<br> Btree索引 ⭐️⭐️⭐️⭐️⭐️<br> RTREE索引<br> HASH索引<br> FUllText索引 （全文索引）</p> 
  </blockquote></li></ol> 
<blockquote> 
 <ol start="3"><li> <p>BTREE的细分类(算法)<br> B-Tree 从根遍历然后遍历枝最后找到叶子。<br> B+Tree 在下面叶节点双向指针。<br> B*Tree 在相邻枝节点加入了枝节点的双向指针。</p> <br> 
   <div class="image-package"> 
    <div class="image-container"> 
     <div class="image-container-fill"></div> 
     <div class="image-view"> 
      <img src="https://images2.imgbox.com/22/56/x9pjOj2M_o.png" alt="16955047-7b8056e305af91aa.JPG"> 
     </div> 
    </div> 
    <div class="image-caption">
      b+tree.JPG 
    </div> 
   </div> </li></ol> 
</blockquote> 
<p>B-Tree先排序 然后分成几份 有个范围。</p> 
<blockquote> 
 <p>4.Btree索引的功能 （innode默认Btree*）<br> 聚集索引（集群索引）cluster index<br> 辅助索引 （二级索引）secondary index</p> 
</blockquote> 
<p>5.B-tree是如何构建的<br> 辅助索引： alter table t1 add index idx_name(name);<br> 创建了一个B-tree的结构。</p> 
<blockquote> 
 <p>1.将name列的所有值取出来，进行自动排序。<br> 2.将排完序的值均匀的落到16KB叶子节点数据页中，并将索引键值所对应的数据行的页码记录。<br> 3.向上生成枝节点和根节点。</p> 
</blockquote> 
<p>聚集索引（IOT）</p> 
<blockquote> 
 <p>1.默认是按照主键生成聚集索引，没有主键，存储引擎会使用唯一键，如果都没有会自动生成一个隐藏的聚集索引。<br> 2.数据在存储时，就会按照聚集索引的顺序存储到磁盘的数据页。<br> 3.由于本身数据就是有序的，所以聚集索引构建时，不需要排序。<br> 4.聚集索引直接将磁盘的数据页作为叶子节点。<br> 5.枝节点和根节点只会调取下层节点主键的最小值。</p> 
</blockquote> 
<p>聚集索引和辅助索引的区别？</p> 
<blockquote> 
 <p>辅助索引的叶子节点是手工创建的<br> 聚集索引是自动跟主键生成的<br> 聚集索引只有一个<br> 辅助索引可以有多个</p> 
</blockquote> 
<p>索引可以用来提高查询速度。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d58b7ce7f322409fae78cf8ab6e7773d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">logback 日志压缩</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/261d925ef818d90603e1230433b21602/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android Q 不叫 Q，正式命名为 Android 10</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>