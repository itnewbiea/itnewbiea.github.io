<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Set集合详细讲解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Set集合详细讲解" />
<meta property="og:description" content="目录
一.Set集合
二.HashSet集合
foreach循环遍历
迭代器遍历数组 三.TreeSet集合
一.Set集合 Set集合其实就是一个接口，HashSet和TreeSet实现了Set接口，所有Set所具备的方法HashSet和TreeSet也是具备的。
特点：
set集合是无序的，不重复的（无序的意思是不会按照我们增加进集合的顺序）遍历通过foreach，迭代器，无法通过下标，因为set集合没有下标初始容量为16，负载因子0.75倍，扩容量增加1倍 二.HashSet集合 HashSet是实现Set集合接口的，所以Set集合所具备的，它也具备。它只储存唯一元素并且允许为空值。储存唯一元素的意思是，如果你增加两个1，那么有一个1会被干掉，只有1一个1存在。由HashMap支持。不保持插入顺序线程不安全 foreach循环遍历 如果里面有的元素增加进去会被覆盖，大家可以按住Ctrl点击add进去看源码。源码里有一个boolean的方法，该方法是判断新增加的元素在该集合是否已经存在了，如果为false那么里面已经存在和该元素一样的元素，如果为true那么里面没有该元素，增加进该集合。
注:如果已经有元素存在
package com.yjx.test; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; import org.junit.Before; import org.junit.Test; public class Test01 { private Set&lt;Integer&gt; set=new HashSet&lt;Integer&gt;(); @Before public void list() { set.add(1); set.add(1); set.add(2); set.add(3); set.add(3); set.add(4); set.add(5); set.add(6); } @Test public void test01() { for(Integer e:set) { System.out.println(e); } } } set集合增加的源码里的判断元素是否在集合中存在的方法
boolean add(E e); 得到结果：
迭代器遍历数组 hasNext:判断集合中是否还有元素" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/38dc191c97e0aaf120215fc3e7f467c0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-29T16:51:26+08:00" />
<meta property="article:modified_time" content="2022-06-29T16:51:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Set集合详细讲解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.Set%E9%9B%86%E5%90%88-toc" style="margin-left:40px;"><a href="#%E4%B8%80.Set%E9%9B%86%E5%90%88" rel="nofollow">一.Set集合</a></p> 
<p id="%E4%BA%8C.HashSet%E9%9B%86%E5%90%88-toc" style="margin-left:40px;"><a href="#%E4%BA%8C.HashSet%E9%9B%86%E5%90%88" rel="nofollow">二.HashSet集合</a></p> 
<p id="%C2%A0foreach%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86-toc" style="margin-left:80px;"><a href="#%C2%A0foreach%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86" rel="nofollow"> foreach循环遍历</a></p> 
<p id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%C2%A0%C2%A0-toc" style="margin-left:80px;"><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%C2%A0%C2%A0" rel="nofollow">迭代器遍历数组  </a></p> 
<p id="%E4%B8%89.TreeSet%E9%9B%86%E5%90%88-toc" style="margin-left:40px;"><a href="#%E4%B8%89.TreeSet%E9%9B%86%E5%90%88" rel="nofollow">三.TreeSet集合</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E4%B8%80.Set%E9%9B%86%E5%90%88">一.Set集合</h3> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>Set集合其实就是一个接口，HashSet和TreeSet实现了Set接口，所有Set所具备的方法HashSet和TreeSet也是具备的。</strong></span></p> 
 <p><strong>特点：</strong></p> 
 <ul><li><strong>set集合是无序的，不重复的（无序的意思是不会按照我们增加进集合的顺序）</strong></li><li><span style="color:#0d0016;"><strong>遍历通过foreach，迭代器，无法通过下标，因为set集合没有下标</strong></span></li><li><strong>初始容量为16，负载因子0.75倍，扩容量增加1倍 </strong></li></ul> 
 <p><strong>  </strong><span style="color:#fe2c24;"><strong> </strong></span></p> 
</blockquote> 
<hr> 
<h3 id="%E4%BA%8C.HashSet%E9%9B%86%E5%90%88">二.HashSet集合</h3> 
<blockquote> 
 <ul><li><strong>HashSet是实现Set集合接口的，所以Set集合所具备的，它也具备。</strong></li><li><strong>它只储存唯一元素并且允许为空值。储存唯一元素的意思是，如果你增加两个1，那么有一个1会被干掉，只有1一个1存在。</strong></li><li><strong>由HashMap支持。</strong></li><li><strong>不保持插入顺序</strong></li><li><strong>线程不安全</strong></li></ul> 
 <p><strong> </strong></p> 
 <ul><li> <h4 id="%C2%A0foreach%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86"> foreach循环遍历</h4> </li></ul> 
 <p>     如果里面有的元素增加进去会被覆盖，大家可以按住Ctrl点击add进去看源码。源码里有一个boolean的方法，该方法是判断新增加的元素在该集合是否已经存在了，如果为false那么里面已经存在和该元素一样的元素，如果为true那么里面没有该元素，增加进该集合。</p> 
 <p></p> 
 <p>  注:如果已经有元素存在<br>         </p> 
 <pre><code class="language-java">package com.yjx.test;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.junit.Before;
import org.junit.Test;



public class Test01 {
	
	
	private Set&lt;Integer&gt; set=new HashSet&lt;Integer&gt;();
	
	@Before
	public void list() {
		set.add(1);
		set.add(1);
		set.add(2);
		set.add(3);
		set.add(3);
		set.add(4);
		set.add(5);
		set.add(6);
	
	}
	
	
	
	@Test
	public void test01() {
		for(Integer e:set) {
			System.out.println(e);
		}
	}
	

}
</code></pre> 
 <p><strong><span style="color:#0d0016;">  set集合增加的源码里的判断元素是否在集合中存在的方法</span></strong></p> 
 <p><strong><span style="color:#0d0016;">  </span></strong></p> 
 <pre><code class="language-java">boolean add(E e);</code></pre> 
 <p><span style="color:#0d0016;"><strong>得到结果：</strong></span></p> 
 <p style="text-align:center;"><span style="color:#0d0016;"><strong>  <img alt="" src="https://images2.imgbox.com/f2/48/Nv9Sm0Uc_o.png"></strong></span></p> 
 <p></p> 
 <ul><li> <h4 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%C2%A0%C2%A0"><strong><span style="color:#0d0016;">迭代器遍历数组 </span></strong> </h4> </li></ul> 
 <p><span style="color:#0d0016;"><strong>     hasNext:判断集合中是否还有元素</strong></span></p> 
 <pre><code class="language-java">  public void test02() {
     Iterator&lt;Integer&gt;it=set.iterator();
    	while(it.hasNext()) {
    		System.out.println(it.next());
    	}
    }
</code></pre> 
 <p><span style="color:#0d0016;"><strong>  得到结果:</strong></span></p> 
 <p>  <span style="color:#0d0016;"><strong><img alt="" src="https://images2.imgbox.com/46/19/6eNtQuMd_o.png"></strong></span></p> 
 <p><span style="color:#0d0016;"><strong> </strong></span></p> 
 <p><span style="color:#0d0016;"><strong>  </strong></span></p> 
 <p><span style="color:#0d0016;"><strong>  我们创建一个学生实体类，然后将学生增加进集合。</strong></span></p> 
 <ul><li><span style="color:#0d0016;"><strong>  Stundet类一定要实现hashCode()和equals方法，因为他们用来对比两个对象是否相等一致</strong></span></li><li><span style="color:#0d0016;"><strong>大家可以试一下在stundet类中实现这两个方法，和去除这两个方法的区别，如果Studnet中没有这个方法，那么就算id和名字和年龄全相等，依旧可以增加进去</strong></span></li></ul> 
 <p><span style="color:#0d0016;"><strong>  Studnet类</strong></span></p> 
 <pre><code class="language-java">package com.yjx.test;

public class Stundet {
	
	private Integer id;
	private String name;
	private Integer age;
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Integer getAge() {
		return age;
	}
	public void setAge(Integer age) {
		this.age = age;
	}
	
	public Stundet() {
		// TODO Auto-generated constructor stub
	}
	
	
	public Stundet(Integer id, String name, Integer age) {
		super();
		this.id = id;
		this.name = name;
		this.age = age;
	}
	
	
	
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((age == null) ? 0 : age.hashCode());
		result = prime * result + ((id == null) ? 0 : id.hashCode());
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Stundet other = (Stundet) obj;
		if (age == null) {
			if (other.age != null)
				return false;
		} else if (!age.equals(other.age))
			return false;
		if (id == null) {
			if (other.id != null)
				return false;
		} else if (!id.equals(other.id))
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}
	@Override
	public String toString() {
		return "Stundet [id=" + id + ", name=" + name + ", age=" + age + "]";
	}

	
	
	

}
</code></pre> 
 <p><span style="color:#0d0016;"><strong> 方法</strong></span></p> 
 <p><span style="color:#0d0016;"><strong> 像这种学生id和学生名字都相同，但是年龄不同，所以他们不是同一个人，两个都会增加进去的。</strong></span></p> 
 <p><span style="color:#0d0016;"><strong> </strong></span></p> 
 <pre><code class="language-java"> public void test03() {
		 //先创建一个集合
		 Set&lt;Stundet&gt; set=new HashSet&lt;Stundet&gt;();
		 set.add(new Stundet(1,"张三",18));
		 set.add(new Stundet(1,"张三",19));
		 set.add(new Stundet(3,"张五",16));
		 set.add(new Stundet(5,"张六",11));
		 set.add(new Stundet(3,"张七",12));
		 
		 for(Stundet s:set) {
			 System.out.println(s);
		 }
	 }</code></pre> 
 <p><span style="color:#0d0016;"><strong> 得到结果：</strong></span></p> 
 <p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/ab/38/nkj0zr0x_o.png"></p> 
 <p>  </p> 
 <p><span style="color:#0d0016;"><strong> 但是如果我们将第一个和第二个将id和名字和年龄都设置为一样的，那么只有一个会增加进去。</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>   </strong></span></p> 
 <pre><code class="language-java"> public void test03() {
		 //先创建一个集合
		 Set&lt;Stundet&gt; set=new HashSet&lt;Stundet&gt;();
		 set.add(new Stundet(1,"张三",18));
		 set.add(new Stundet(1,"张三",18));
		 set.add(new Stundet(3,"张五",16));
		 set.add(new Stundet(5,"张六",11));
		 set.add(new Stundet(3,"张七",12));
		 
		 for(Stundet s:set) {
			 System.out.println(s);
		 }
	 }</code></pre> 
 <p><span style="color:#0d0016;"><strong>得到结果：而且还会帮我们根据id进行一个排序</strong></span></p> 
 <p style="text-align:center;"><span style="color:#0d0016;"><strong>  <img alt="" src="https://images2.imgbox.com/1e/e0/8J8YGu8X_o.png"></strong></span></p> 
 <p> 如果我们想用根据年龄进行一个排序，这个时候就要用到TreeSet，接着往下看。</p> 
</blockquote> 
<h3 id="%E4%B8%89.TreeSet%E9%9B%86%E5%90%88">三.TreeSet集合</h3> 
<blockquote> 
 <ul><li><strong>是一个包含有序的且没有重复元素的集合</strong></li><li><strong>作用是提供有序的Set集合，自然排序或者根据提供的Comparator进行排序</strong></li><li><strong>TreeSet是基于TreeMap实现的</strong></li></ul> 
 <p><span style="color:#fe2c24;"><strong> 什么使用TreeSet集合？</strong></span></p> 
 <p><strong> 当我们想根据什么进行排序的话就可以使用TreeSet集合，下面就教大家如何使用TreeSet集合进行排序。 </strong></p> 
 <p><strong> </strong></p> 
 <ul><li><strong><span style="color:#0d0016;">   第一种方法</span></strong></li></ul> 
 <p>  <span style="color:#0d0016;"><strong>    我们使用Comparator进行一个排序，可以从小到大，也可以从大到小，但是这种方法存在一个很大的问题，如果有年龄相同的，那么只会有一个留下，其他的就会不存在该集合中了。</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>  </strong></span></p> 
 <p><span style="color:#0d0016;"><strong>这个是从小到大排序的，想要从大到小，就o2.getAge-o1.getAge。</strong></span></p> 
 <pre><code class="language-java">public void test04() { 
		TreeSet&lt;Stundet&gt; tree=new TreeSet&lt;Stundet&gt;(new Comparator&lt;Stundet&gt;() {
			@Override
			public int compare(Stundet o1, Stundet o2) {
				 
				return o1.getAge() - o2.getAge();
			}
			
		});
		//先创建一个集合
		
		tree.add(new Stundet(1,"张三",18));
		tree.add(new Stundet(3,"张五",16));
		tree.add(new Stundet(5,"张六",18));
		tree.add(new Stundet(4,"张七",12));
		tree.add(new Stundet(6,"张七",12));
		 
		 for(Stundet s:tree) {
			 System.out.println(s);
		 }
	}</code></pre> 
 <p> <strong>    得到结果：</strong></p> 
 <p style="text-align:center;">    <img alt="" src="https://images2.imgbox.com/2d/5a/Jhy5YuOv_o.png"></p> 
 <p>  </p> 
 <p>   刚刚我们也说了，出现年龄相同，只会留下一个，那么这种方法该如何解决嘞，大家看下面代码。</p> 
 <p><strong> 我们增加了一个判断，当年龄相减为0，他们相等，那就根据他们的id进行排序。就可以解决这样子的问题啦。</strong></p> 
 <p></p> 
 <pre><code class="language-java">public void test04() { 
		TreeSet&lt;Stundet&gt; tree=new TreeSet&lt;Stundet&gt;(new Comparator&lt;Stundet&gt;() {
			@Override
			public int compare(Stundet o1, Stundet o2) {
				 if(o1.getAge() - o2.getAge()==0) {
					 return o1.getId()-o2.getId();
				 }
				return o1.getAge() - o2.getAge();
			}
			
		});
		//先创建一个集合
		
		tree.add(new Stundet(1,"张三",18));
		tree.add(new Stundet(3,"张五",16));
		tree.add(new Stundet(5,"张六",18));
		tree.add(new Stundet(4,"张七",12));
		tree.add(new Stundet(6,"张七",12));
		 
		 for(Stundet s:tree) {
			 System.out.println(s);
		 }
	}</code></pre> 
 <p><strong>    得到结果：所有的数据都存在，id根据从小到大的顺序。</strong></p> 
 <p style="text-align:center;">    <img alt="" src="https://images2.imgbox.com/b8/7d/kPHLBp6A_o.png"></p> 
 <p>   </p> 
 <p>     </p> 
 <ul><li><span style="color:#0d0016;"><strong>     第二种方法</strong></span></li></ul> 
 <p><span style="color:#0d0016;"><strong>   我们在Studnet实体类中做判断，实现Comparable</strong></span></p> 
 <p></p> 
 <pre><code class="language-java">package com.yjx.test;

import java.util.Comparator;

public class Stundet implements Comparable&lt;Stundet&gt;{
	
	private Integer id;
	private String name;
	private Integer age;
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Integer getAge() {
		return age;
	}
	public void setAge(Integer age) {
		this.age = age;
	}
	
	public Stundet() {
		// TODO Auto-generated constructor stub
	}
	
	
	public Stundet(Integer id, String name, Integer age) {
		super();
		this.id = id;
		this.name = name;
		this.age = age;
	}
	
	
	
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((age == null) ? 0 : age.hashCode());
		result = prime * result + ((id == null) ? 0 : id.hashCode());
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Stundet other = (Stundet) obj;
		if (age == null) {
			if (other.age != null)
				return false;
		} else if (!age.equals(other.age))
			return false;
		if (id == null) {
			if (other.id != null)
				return false;
		} else if (!id.equals(other.id))
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}
	@Override
	public String toString() {
		return "Stundet [id=" + id + ", name=" + name + ", age=" + age + "]";
	}
	
	
	@Override
	public int compareTo(Stundet o) {
		if(o.getAge()-this.getAge()==0) {
			return o.getId()-this.getId();
		}
		return o.getAge()-this.getAge();
	}


	  
	
	

}
</code></pre> 
 <p><strong> 测试方法代码</strong></p> 
 <p></p> 
 <pre><code class="language-java">@Test
	public void test05() { 
		TreeSet&lt;Stundet&gt; tree=new TreeSet&lt;Stundet&gt;();
		//先创建一个集合
		
		tree.add(new Stundet(1,"张三",18));
		tree.add(new Stundet(3,"张五",16));
		tree.add(new Stundet(5,"张六",18));
		tree.add(new Stundet(4,"张七",12));
		tree.add(new Stundet(6,"张七",12));
		 
		 for(Stundet s:tree) {
			 System.out.println(s);
		 }
	}</code></pre> 
 <p> 这种方法也是可以的噢，大家最好做个判断，避免出现一样大的数据而只留下一个这种情况。 </p> 
</blockquote> 
<p>今天的学习就到这里啦。 </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/63e5e2b048da1536c5f8c48683017208/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JSON在线序列化网站</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ba9d1c4d69d8295046a3869a2248c747/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Dockercompose创建redis主从复制</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>