<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>多级缓存原理及实现 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="多级缓存原理及实现" />
<meta property="og:description" content="首先为什么需要多级缓存？
传统的缓存策略一般是请求到达Tomcat服务后，先查询Redis，如果未命中则查询数据库，存在下面的问题：
请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈。
Redis缓存失效时，会对数据库产生冲击。
多级缓存方案:多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能
用户请求 ——》 反向代理Nginx ——》 业务Nginx （通过lua编写业务逻辑） ——》Redis ——&gt; tomcat（本地缓存） ——》数据库。
实现多级缓存我们需要了解到的知识：Lua 编程（针对Nginx中的逻辑编码）、Nginx本地缓存、本地缓存实现、Openresty、Redis缓存预热。
分布式缓存，例如Redis：
优点：存储容量更大、可靠性更好、可以在集群间共享
缺点：访问缓存有网络开销
场景：缓存数据量较大、可靠性要求较高、需要在集群间共享
进程本地缓存，例如HashMap、GuavaCache、Caffeine
优点：读取本地内存，没有网络开销，速度更快
缺点：存储容量有限、可靠性较低、无法共享
场景：性能要求较高，缓存数据量较小
Redis 冷启动与缓存预热
冷启动：服务刚刚启动时，Redis中并没有缓存，如果所有商品数据都在第一次查询时添加缓存，可能会给数据库带来较大压力。
缓存预热：在实际开发中，我们可以利用大数据统计用户访问的热点数据，在项目启动时将这些热点数据提前查询并保存到Redis中。
缓存预热
@Componentpublic class RedisHandler implements InitializingBean { @Autowired private StringRedisTemplate redisTemplate; @Override public void afterPropertiesSet() throws Exception { // 初始化缓存 ... } } 缓存同步策略
缓存数据同步的常见方式有三种：
设置有效期：给缓存设置有效期，到期后自动删除。再次查询时更新
优势：简单、方便
缺点：时效性差，缓存过期之前可能不一致
场景：更新频率较低，时效性要求低的业务
同步双写：在修改数据库的同时，直接修改缓存
优势：时效性强，缓存与数据库强一致
缺点：有代码侵入，耦合度高；
场景：对一致性、时效性要求较高的缓存数据
异步通知：修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据
优势：低耦合，可以同时通知多个缓存服务
缺点：时效性一般，可能存在中间不一致状态
场景：时效性要求一般，有多个服务需要同步
基于MQ的异步同步策略
基于Canal的异步通知：Canal提供了各种语言的客户端，当Canal监听到binlog变化时，会通知Canal的客户端。
Canal提供了各种语言的客户端，当Canal监听到binlog变化时，会通知Canal的客户端。不过这里我们会使用GitHub上的第三方开源的canal-starter。地址：https://github.com/NormanGyllenhaal/canal-client" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/93ae85a2bd532c6e86392c10689311a6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-18T21:53:07+08:00" />
<meta property="article:modified_time" content="2023-02-18T21:53:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">多级缓存原理及实现</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">首先为什么需要多级缓存？</span></span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">传统的缓存策略一般是请求到达Tomcat服务后，先查询Redis，如果未命中则查询数据库，存在下面的问题：</span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈。</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p><span class="kdocs-fontSize" style="font-size:9pt;">Redis缓存失效时，会对数据库产生冲击。</span></p></li></ul> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">多级缓存方案:</span>多级缓存就是充分利用<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">请求处理的每个环节，分别添加缓存</span></span>，减轻Tomcat压力，提升服务性能</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">用户请求 ——》 反向代理Nginx ——》 业务Nginx （通过lua编写业务逻辑） ——》Redis ——&gt; tomcat（本地缓存） ——》数据库。</span></span></span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:30.54054%;height:0;"> 
    <img src="https://images2.imgbox.com/2b/01/ONbCndXI_o.png" style="margin-left:;display:block;width:740px;margin-top:-30.54054%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">实现多级缓存我们需要了解到的知识：Lua 编程（针对Nginx中的逻辑编码）、Nginx本地缓存、本地缓存实现、Openresty、Redis缓存预热。</span></span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">分布式缓存，例如Redis：</span></span></p> 
 <p style="padding-left:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">优点：存储容量更大、可靠性更好、可以在集群间共享</span></p> 
 <p style="padding-left:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">缺点：访问缓存有网络开销</span></p> 
 <p style="padding-left:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">场景：缓存数据量较大、可靠性要求较高、需要在集群间共享</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">进程本地缓存，例如HashMap、GuavaCache、Caffeine</span></span></p> 
 <p style="padding-left:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">优点：读取本地内存，没有网络开销，速度更快</span></p> 
 <p style="padding-left:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">缺点：存储容量有限、可靠性较低、无法共享</span></p> 
 <p style="padding-left:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">场景：性能要求较高，缓存数据量较小</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">Redis 冷启动与缓存预热</span></span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">冷启动：服务刚刚启动时，Redis中并没有缓存，如果所有商品数据都在第一次查询时添加缓存，可能会给数据库带来较大压力。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">缓存预热：在实际开发中，我们可以利用大数据统计用户访问的热点数据，在项目启动时将这些热点数据提前查询并保存到Redis中。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">缓存预热</span></span></span></p> 
 <pre class="kdocs-java"><code class="language-java">@Componentpublic class RedisHandler implements InitializingBean {
    @Autowired
    private StringRedisTemplate redisTemplate;
    @Override         
    public void afterPropertiesSet() throws Exception {
     // 初始化缓存 ... 
    }
}</code></pre> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">缓存同步策略</span></span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">缓存数据同步的常见方式有三种：</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">设置有效期</span>：给缓存设置有效期，到期后自动删除。再次查询时更新</span></p> 
 <p style="padding-left:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">优势：简单、方便</span></p> 
 <p style="padding-left:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">缺点：时效性差，缓存过期之前可能不一致</span></p> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">场景：更新频率较低，时效性要求低的业务</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">同步双写</span>：在修改数据库的同时，直接修改缓存</span></p> 
 <p style="padding-left:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">优势：时效性强，缓存与数据库强一致</span></p> 
 <p style="padding-left:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">缺点：有代码侵入，耦合度高；</span></p> 
 <p style="text-indent:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">场景：对一致性、时效性要求较高的缓存数据</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">异步通知</span>：修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据</span></p> 
 <p style="padding-left:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">优势：低耦合，可以同时通知多个缓存服务</span></p> 
 <p style="padding-left:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">缺点：时效性一般，可能存在中间不一致状态</span></p> 
 <p style="padding-left:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">场景：时效性要求一般，有多个服务需要同步</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">基于MQ的异步同步策略</span></span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:31.486488%;height:0;"> 
    <img src="https://images2.imgbox.com/1b/f7/rXby4HRa_o.png" style="margin-left:;display:block;width:740px;margin-top:-31.486488%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">基于Canal的异步通知：Canal提供了各种语言的客户端，当Canal监听到binlog变化时，会通知Canal的客户端。</span></span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:35.675674%;height:0;"> 
    <img src="https://images2.imgbox.com/72/91/Va778DSw_o.png" style="margin-left:;display:block;width:740px;margin-top:-35.675674%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">Canal提供了各种语言的客户端，当Canal监听到binlog变化时，会通知Canal的客户端。不过这里我们会使用GitHub上的第三方开源的canal-starter。</span>地址：</span><a class="kdocs-link" style="color:#0A6CFF;" href="https://github.com/NormanGyllenhaal/canal-client" target="_blank" rel="noopener noreferrer"><span class="kdocs-fontSize" style="font-size:9pt;">https://github.com/NormanGyllenhaal/canal-client</span></a></p> 
 <pre class="kdocs-xml"><code class="language-xml">&lt;!--canal--&gt;
&lt;dependency&gt;
  &lt;groupId&gt;top.javatool&lt;/groupId&gt;
  &lt;artifactId&gt;canal-spring-boot-starter&lt;/artifactId&gt;
  &lt;version&gt;1.2.1-RELEASE&lt;/version&gt; 
&lt;/dependency&gt;</code></pre> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">编写配置</span></span></p> 
 <pre class="kdocs-yaml"><code class="language-yaml">canal:   
    destination: canalName # canal实例名称，要跟canal-server运行时设置的destination一致   
    server: IP:port # canal地址 </code></pre> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">编写监听器，监听Canal消息</span></p> 
 <pre class="kdocs-java"><code class="language-java">@CanalTable("tb_ table") 
@Component 
public class ItemHandler implements EntryHandler&lt;Item&gt; {
    @Override   
    public void insert(Item item) {
     // 新增数据到redis         
    }          
    @Override          
    public void update(Item before, Item after) {
        // 更新redis数据                       
        // 更新本地缓存       
    }  
   @Override          
   public void delete(Item item) {
         // 删除redis数据                      
        // 清理本地缓存         
   }
}</code></pre> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">Canal推送给canal-client的是被修改的这一行数据（row），而我们引入的canal-client则会帮我们把行数据封装到Item实体类中。这个过程中需要知道数据库与实体的映射关系，要用到JPA的几个注解：</span></span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">@Id 标记表中的id字段</span></span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">@Column(name = "name") 标记表中与属性名不一致的字段</span></span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">@Transient 标记不属于表中的字段</span></span></p> 
 <p style=""></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5ae6f809a5c27bddae8c13e53eae7721/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【博客624】MAC地址表、ARP表、路由表(RIB表)、转发表(FIB表)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ee82935b112662a696c35c8fd71f0097/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JVM学习（四）---类加载过程、类加载器和双亲委派机制的原理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>