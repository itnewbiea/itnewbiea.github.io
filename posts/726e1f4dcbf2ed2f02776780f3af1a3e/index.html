<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java通过jol-core库分析对象内存分布以及查看Synchronized锁升级过程 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java通过jol-core库分析对象内存分布以及查看Synchronized锁升级过程" />
<meta property="og:description" content="在Java开发中，我们可以借助jol-core这个库来查看对象内存信息。
引入依赖：
&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.17&lt;/version&gt; &lt;/dependency&gt; 要查看对象内存信息，我们只需要调用ClassLayout.parseInstance(object).toPrintable() 如下所示的代码，是查看两个对象信息：
package com.xxx.mem; import org.openjdk.jol.info.ClassLayout; public class ObjectPrintExample { public static void main(String[] args) { Object object = new Object(); System.out.println(ClassLayout.parseInstance(object).toPrintable()); Object[] arr = new Object[10]; System.out.println(ClassLayout.parseInstance(arr).toPrintable()); } } 运行程序，打印信息如下所示：
从打印内容来看，我们看到了对象包含：对象头，对象体，对齐字节。
其中对象头包括： mark word,klass word,数组长度。如果对象不是数组，数组长度可以忽略不记，上图中，我们打印object，数组长度就没有体现（array length）。
我们这里重点关注一下对象头中的mark word，如下所示：
这里面通过对象头64位中的最后3位的值，我们看到它们取值不同，可能会出现几种状态，其中无锁 、偏向锁、轻量级锁，重量级锁正是Sychronized锁升级过程中表现出来的升级状态。
下面我们通过一段代码的运行来感受一下这几个状态的变化：
package com.xxx.mem; import org.openjdk.jol.info.ClassLayout; import java.util.concurrent.TimeUnit; public class LayoutPrintExample { public static void main(String[] args) throws InterruptedException { Object o = new Object(); // Step 1 System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/726e1f4dcbf2ed2f02776780f3af1a3e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-27T16:10:00+08:00" />
<meta property="article:modified_time" content="2023-10-27T16:10:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java通过jol-core库分析对象内存分布以及查看Synchronized锁升级过程</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>    在Java开发中，我们可以借助jol-core这个库来查看对象内存信息。</p> 
<p>     引入依赖：</p> 
<pre><code class="language-html">&lt;dependency&gt;
      &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;
      &lt;artifactId&gt;jol-core&lt;/artifactId&gt;
      &lt;version&gt;0.17&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p>    要查看对象内存信息，我们只需要调用ClassLayout.parseInstance(object).toPrintable() </p> 
<p>    如下所示的代码，是查看两个对象信息：</p> 
<pre><code class="language-java">package com.xxx.mem;
import org.openjdk.jol.info.ClassLayout;
public class ObjectPrintExample {
    public static void main(String[] args) {
        Object object = new Object();
        System.out.println(ClassLayout.parseInstance(object).toPrintable());
        Object[] arr = new Object[10];
        System.out.println(ClassLayout.parseInstance(arr).toPrintable());
    }
}
</code></pre> 
<p>    运行程序，打印信息如下所示：</p> 
<p style="text-align:center;"><img alt="" class="left" src="https://images2.imgbox.com/d8/f8/BT5aGYls_o.png"> </p> 
<p>    从打印内容来看，我们看到了对象包含：对象头，对象体，对齐字节。</p> 
<p>    其中对象头包括： mark word,klass word,数组长度。如果对象不是数组，数组长度可以忽略不记，上图中，我们打印object，数组长度就没有体现（array length）。</p> 
<p>    我们这里重点关注一下对象头中的mark word，如下所示：</p> 
<p style="text-align:center;"><img alt="" class="left" src="https://images2.imgbox.com/0a/a8/cVayWHpr_o.png"></p> 
<p>    这里面通过对象头64位中的最后3位的值，我们看到它们取值不同，可能会出现几种状态，其中无锁 、偏向锁、轻量级锁，重量级锁正是Sychronized锁升级过程中表现出来的升级状态。</p> 
<p>    下面我们通过一段代码的运行来感受一下这几个状态的变化：</p> 
<pre><code class="language-java">package com.xxx.mem;
import org.openjdk.jol.info.ClassLayout;
import java.util.concurrent.TimeUnit;
public class LayoutPrintExample {
    public static void main(String[] args) throws InterruptedException {
        Object o = new Object();
        // Step 1
        System.out.println(ClassLayout.parseInstance(new Object()).toPrintable());
        TimeUnit.SECONDS.sleep(4);
        // Step 2
        System.out.println(ClassLayout.parseInstance(new Object()).toPrintable());
        //Step 3
        synchronized(o) {
            System.out.println(ClassLayout.parseInstance(o).toPrintable());
        }
        // Step 4
        new Thread(()-&gt; {
            synchronized(o) {
                System.out.println(ClassLayout.parseInstance(o).toPrintable());
            }
        }).start();
        // Step 5
        new Thread(()-&gt; {
            synchronized(o) {
                System.out.println(ClassLayout.parseInstance(o).toPrintable());
            }
        }).start();
    }
}
</code></pre> 
<p>    这段代码直接运行，可能达不到我们需要的效果，因为jdk默认不会开启偏向锁，所以我们要手动开启，并且设置一个延时4秒，这样我们正好看清整个锁升级过程。</p> 
<p>    虚拟机参数：-XX:BiasedLockingStartupDelay=4 -XX:+UseBiasedLocking</p> 
<p style="text-align:center;"><img alt="" class="left" src="https://images2.imgbox.com/2c/13/9BfdcEGR_o.png"></p> 
<p>    运行程序，打印结果：</p> 
<p style="text-align:center;"><img alt="" class="left" src="https://images2.imgbox.com/60/f1/iAQDMdis_o.png"> </p> 
<p>    这个结果的解释：</p> 
<p>   step1，程序刚开始运行，因为开启了偏向锁，第一次打印无锁状态。</p> 
<p>   step2，这里睡眠4秒，相当于延时4秒，虚拟机偏向锁生效，打印出偏向锁状态。</p> 
<p>   step3，由于程序调用synchronized，对象锁升级为轻量级锁。</p> 
<p>   step4，在线程中调用synchronized，这时候竞争并不是很激烈，还是轻量级锁。</p> 
<p>   step5，在另一个线程中调用synchronized，相当于多线程环境，这时候竞争激烈，自身cas已经无法满足需求，对象锁升级为重量级锁。</p> 
<p>    这里我们通过对象头markword也看出了锁状态，分别是non-biasable,biasable,thin lock,thin lock,fat lock。另外，通过16进制对应的二进制结果也验证了一下markword对应后三位状态。</p> 
<p>    jol-core可能因为版本不同，显示的markword，可能是十六进制，也有可能是二进制，如果是二进制，我们需要注意，是否为小端序、大端序，如果端序搞错，结果有可能不是我们期望的锁状态。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d26167d9378a3ec2f17ce76d3936e867/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nginx: [alert] could not open error log file: open() “/usr/local/nginx/logs/error.log“ failed 问题解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e27593ef9425fc407ed0fac121ab3cba/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;版-----信息学奥赛一本通-----编程启蒙--- #M1001. 石头剪刀布(game.cpp)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>