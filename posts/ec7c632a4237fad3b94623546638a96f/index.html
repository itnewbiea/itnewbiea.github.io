<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>记录acwing蓝桥杯每日一题 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="记录acwing蓝桥杯每日一题" />
<meta property="og:description" content="3956.截断数组 思路：好吧从j循环那边我就有点想不到，y总的思路就是固定第二个分割点，枚举第一个分割点的位置
3729.改变数组元素 思路：主要就是差分，记录一下差分模板，差分可以用来处理对某一区间的数据同时加上或者减去一个数
1460.我在哪？ 先放上一个暴力算法（遇到估计我也只能暴力了，能拿几分是几分了）
y总的优化思路：使用二分，且用哈希表
很好哈希表又是我还不会的东西
unordered_set&lt;string&gt; hash//定义一个哈希表
string类型中substr(i,j)函数可以截取区间i-j的字符串
1497.树的遍历 思路：把后序中序分为三段：根节点、左子树、右子树
感觉数据结构经常用到这样的递归，记住是怎么做的吧orz
1249.亲戚 终于有一道我会做的了，但是没想到习惯用的cin cout会被判超时（果然还是要用scanf吗）
2058. 笨拙的手指 #include &lt;bits/stdc&#43;&#43;.h&gt; using namespace std; const int N=1e9; int base(string s,int a){ int ans=0; for (int i=0;i&lt;s.size();i&#43;&#43;){ ans=a*ans&#43;s[i]-&#39;0&#39;; } return ans; } int main(){ string x,y; cin&gt;&gt;x&gt;&gt;y; unordered_set&lt;int&gt; hash; for (int i=0;i&lt;x.size();i&#43;&#43;){ string s=x; s[i]^=1; if(s.size()&gt;1&amp;&amp;s[0]==&#39;0&#39;) continue; hash.insert(base(s,2)); } for (int i=0;i&lt;y.size();i&#43;&#43;){ for (int j=0;j&lt;3;j&#43;&#43;){ if(y[i]-&#39;0&#39;!=j){ string s=y; s[i]=j&#43;&#39;0&#39;; if(s.size()&gt;1&amp;&amp;s[0]==&#39;0&#39;) continue; int n=base(s,3); if(hash." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ec7c632a4237fad3b94623546638a96f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-30T22:39:28+08:00" />
<meta property="article:modified_time" content="2023-03-30T22:39:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">记录acwing蓝桥杯每日一题</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h6 style=""><span class="kdocs-bold" style="font-weight:bold;">3956.截断数组</span></h6> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:386px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:106.99482%;height:0;"> 
    <img src="https://images2.imgbox.com/76/ba/p6Kek5kh_o.png" style="margin-left:;display:block;width:386px;margin-top:-106.99482%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">思路：好吧从j循环那边我就有点想不到，y总的思路就是固定第二个分割点，枚举第一个分割点的位置</p> 
 <p style=""></p> 
 <h6 style=""><span class="kdocs-bold" style="font-weight:bold;">3729.改变数组元素</span></h6> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:367px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:110.08174%;height:0;"> 
    <img src="https://images2.imgbox.com/a8/81/b7MKZ2zz_o.png" style="margin-left:;display:block;width:367px;margin-top:-110.08174%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">思路：主要就是差分，记录一下差分模板，差分可以用来处理对某一区间的数据同时加上或者减去一个数</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:354px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:31.073446%;height:0;"> 
    <img src="https://images2.imgbox.com/6b/12/bIWfq1Jc_o.png" style="margin-left:;display:block;width:354px;margin-top:-31.073446%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <h6 style=""><span class="kdocs-bold" style="font-weight:bold;">1460.我在哪？</span></h6> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:360px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:131.3889%;height:0;"> 
    <img src="https://images2.imgbox.com/f8/5d/wjlZl543_o.png" style="margin-left:;display:block;width:360px;margin-top:-131.3889%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">先放上一个暴力算法（遇到估计我也只能暴力了，能拿几分是几分了）</p> 
 <p style="">y总的优化思路：使用二分，且用哈希表</p> 
 <p style="">很好哈希表又是我还不会的东西</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:504px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:78.968254%;height:0;"> 
    <img src="https://images2.imgbox.com/b4/42/R8sZTlyF_o.png" style="margin-left:;display:block;width:504px;margin-top:-78.968254%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">unordered_set&lt;string&gt; hash//定义一个哈希表</p> 
 <p style="">string类型中substr(i,j)函数可以截取区间i-j的字符串</p> 
 <h6 style=""><span class="kdocs-bold" style="font-weight:bold;">1497.树的遍历</span></h6> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:465px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:120.64516%;height:0;"> 
    <img src="https://images2.imgbox.com/83/6e/ED740lWR_o.png" style="margin-left:;display:block;width:465px;margin-top:-120.64516%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">思路：把后序中序分为三段：根节点、左子树、右子树</p> 
 <p style="">感觉数据结构经常用到这样的递归，记住是怎么做的吧orz</p> 
 <h6 style=""><span class="kdocs-bold" style="font-weight:bold;">1249.亲戚</span></h6> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:372px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:130.37634%;height:0;"> 
    <img src="https://images2.imgbox.com/2c/7c/djeZrmVv_o.png" style="margin-left:;display:block;width:372px;margin-top:-130.37634%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">终于有一道我会做的了，但是没想到习惯用的cin cout会被判超时（果然还是要用scanf吗）</p> 
 <h6 style=""><span class="kdocs-bold" style="font-weight:bold;">2058. 笨拙的手指</span></h6> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N=1e9;

int base(string s,int a){
    int ans=0;
    for (int i=0;i&lt;s.size();i++){
        ans=a*ans+s[i]-'0';
    }
    return ans;
}

int main(){
    string x,y;
    cin&gt;&gt;x&gt;&gt;y;
    
    unordered_set&lt;int&gt; hash;
    for (int i=0;i&lt;x.size();i++){
        string s=x;
        s[i]^=1;
        if(s.size()&gt;1&amp;&amp;s[0]=='0') continue;
        hash.insert(base(s,2));
    }
    for (int i=0;i&lt;y.size();i++){
        for (int j=0;j&lt;3;j++){
            if(y[i]-'0'!=j){
                string s=y;
                s[i]=j+'0';
                if(s.size()&gt;1&amp;&amp;s[0]=='0') continue;
                int n=base(s,3);
                if(hash.count(n))
                    cout&lt;&lt;n&lt;&lt;endl;
            }
        }
    }
    return 0;
}</code></pre> 
 <p style="">思路：需要查找的时候就考虑用哈希表的insert和count函数，然后进制转换的模板也背一下</p> 
 <h6 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3485. 最大异或和（每日一题</span></h6> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m;
const int N=31e5+10;//最多有n*31
int p[N][35],ct[N],idx;//ct[n]的作用是标记滑动窗口内0，1的数量

int sum[100010];//sum[i]存前i个数的异或和
void insertt(int u,int c){
    int t=0;
    for(int i=30;i&gt;=0;i--){
        int x=u&gt;&gt;i&amp;1;
        if(!p[t][x]){
           p[t][x]=++idx;
        }
        t=p[t][x];
        ct[t]+=c;//标记这里（有或删除）一个数可以达到该位置
    }
}
int query(int u){
    int t=0;
    int res=u;
    for(int i=30;i&gt;=0;i--){
        int x=u&gt;&gt;i&amp;1;
        if(ct[p[t][!x]]&gt;0){//当x对面的那个数！x存在时(0,1)
            x=(x+1)%2;//x就变成另外一个数 !x
        }
        res^=x&lt;&lt;i;
        t=p[t][x];
    }
    return res;
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    int t;
    for(int i=1;i&lt;=n;i++){
        scanf("%d",&amp;t);
        sum[i]=sum[i-1]^t;//sum[i]表示前i个数的^
    }
    insertt(0,1);//插入0，是为了方便前m个数进行异或得出的答案可以是它本身的值
    int res=0;//求最大值
    for(int i=1;i&lt;=n;i++){
        if(i&gt;m) insertt(sum[i-m-1],-1);//将滑动窗口外的数除去，这时就要修改ct，故-1
        res=max(res,query(sum[i]));//在滑动窗口内求最大值
        insertt(sum[i],1);//求完后记得插入该值，方便后面的值进行异或
    }
    cout&lt;&lt;res;
    return 0;
}
</code></pre> 
 <p style="">思路：目前感觉最难的一道题，前缀和是真的没想到，但是是不是异或就适合用trie数组，也是模板背一下（估计遇到也不会的）</p> 
 <h6 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">1562. 微博转发</span></h6> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N=1010,M=100010;

int n,L;
int e[M],h[N],ne[M],idx;
bool st[N];

void add(int a,int b){
    e[idx]=b;ne[idx]=h[a];h[a]=idx++;
}

int bfs(int start){
    queue&lt;int&gt; q;
    memset(st,0,sizeof st);
    q.push(start);
    st[start]=true;
    
    int res=0;
    for (int i=0;i&lt;L;i++){
        int sz=q.size();
        while(sz--){
            int t=q.front();
            q.pop();
            for (int j=h[t];~j;j=ne[j]){
                int x=e[j];
                if(!st[x]){
                    q.push(x);
                    res++;
                    st[x]=true;
                }
            }
        }
    }
    return res;
}

int main(){
    cin&gt;&gt;n&gt;&gt;L;
    memset(h,-1,sizeof h);
    for(int i=1;i&lt;=n;i++){
        int cnt;cin&gt;&gt;cnt;
        while(cnt--){
            int x;cin&gt;&gt;x;
            add(x,i);
        }
    }
    int m;
    cin&gt;&gt;m;
    while(m--){
        int x;cin&gt;&gt;x;
        cout&lt;&lt;bfs(x)&lt;&lt;endl;
    }
    return 0;
}</code></pre> 
 <p style="">思路：add函数是模板，背一下，以及我老是忘记memset，其实bfs也是模板</p> 
 <h6 style=""><span class="kdocs-bold" style="font-weight:bold;">3502.不同路径数</span></h6> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N=10;
int a[N][N];
string str;
int n,m,k;
unordered_set&lt;int&gt; S;

void dfs(int i,int j,int x,int num){
    if(x==k){
            S.insert(num);
    }
    else {
        if(0&lt;=i&amp;&amp;i&lt;n&amp;&amp;0&lt;=j+1&amp;&amp;j+1&lt;m)
        dfs(i,j+1,x+1,num*10+a[i][j+1]);
        if(0&lt;=i&amp;&amp;i&lt;n&amp;&amp;0&lt;=j-1&amp;&amp;j-1&lt;m)
        dfs(i,j-1,x+1,num*10+a[i][j-1]);
        if(0&lt;=i+1&amp;&amp;i+1&lt;n&amp;&amp;0&lt;=j&amp;&amp;j&lt;m)
        dfs(i+1,j,x+1,num*10+a[i+1][j]);
        if(0&lt;=i-1&amp;&amp;i-1&lt;n&amp;&amp;0&lt;=j&amp;&amp;j&lt;m)
        dfs(i-1,j,x+1,num*10+a[i-1][j]);
        
    }
}

int main(){
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
    for (int i=0;i&lt;n;i++){
        for (int j=0;j&lt;m;j++){
            cin&gt;&gt;a[i][j];
        }
    }
    for (int i=0;i&lt;n;i++){
        for (int j=0;j&lt;m;j++){
            dfs(i,j,0,a[i][j]);
        }
    }
    cout&lt;&lt;S.size();
    return 0;
}</code></pre> 
 <p style="">难的又是一个自己做出来的题，提醒一下不要直接用hash可能会重名，换一个名字</p> 
 <h6 style=""><span class="kdocs-bold" style="font-weight:bold;">1488.最短距离</span></h6> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N=100010,M=N*3;
typedef pair&lt;int,int&gt; PII;
int e[M],h[N],ne[M],w[M],idx;
int dist[N];
bool st[N];

int n,m;

void add(int a,int b,int c){
    e[idx]=b;ne[idx]=h[a];w[idx]=c;h[a]=idx++;
}

void dijkstra(){
    memset(dist,0x3f,sizeof dist);
    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;
    heap.push({0,0});
    dist[0]=0;
    while(heap.size()){
        //当堆栈中有数时
        auto t=heap.top();
        heap.pop();
        int d=t.first,ver=t.second;//ver起点编号
        if(st[ver]) continue;//如果已经拓展过就continue
        st[ver]=true;//标记一下
        
        for(int i=h[ver];~i;i=ne[i]){
            int j=e[i];
            if(dist[j]&gt;dist[ver]+w[i]){
                dist[j]=dist[ver]+w[i];
                heap.push({dist[j],j});
            }
        }
    }
}

int main(){
    cin&gt;&gt;n&gt;&gt;m;
    memset(h,-1,sizeof h);
    while(m--){
        int a,b,c;
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
        add(a,b,c);
        add(b,a,c);
    }
    cin&gt;&gt;m;
    while(m--){
        int x;
        cin&gt;&gt;x;
        add(0,x,0);
    }
    dijkstra();
    cin&gt;&gt;m;
    while(m--){
        int x;
        cin&gt;&gt;x;
        cout&lt;&lt;dist[x]&lt;&lt;endl;
    }
    return 0;
}</code></pre> 
 <p style="">思路：当点数多的时候就不能用朴素dijkstra算法了，要用这个进阶版，朴素版的我也放一下：</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">int dijkstra(){
    memset(dist,0x3f,sizeof dist);
    dist[1]=0;
    
    for (int i=0;i&lt;n;i++){
        int t=-1;
        for (int j=1;j&lt;=n;j++){
            if(!st[j]&amp;&amp;(t==-1||dist[t]&gt;dist[j]))
              t=j;
        }
        st[t]=true;
        for (int j=1;j&lt;=n;j++){
            dist[j]=min(dist[j],dist[t]+g[t][j]);
        }
    }
    if(dist[n]==0x3f3f3f3f) return -1;
    return dist[n];
}</code></pre> 
 <p style="">优化版的使用了小根堆（其实也不大懂为什么但总而言之先背下来），这题还有个重要思路就是先手动填上一个虚拟原点，这样就可以把出发点统一起来了。不过要注意：dijkstra算法适用于求正权有向图中，源点到其余各个节点的最短路径。图中可以有环，但不能有负权边。</p> 
 <h6 style="">3305.作物杂交</h6> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=2010,M=200010;
int n,m,k,t;
int h[N],e[M],ne[M],target[M],w[N],idx,dist[N];
bool st[N];
queue&lt;int&gt; q;

void add(int a,int b,int c){
    e[idx]=b;target[idx]=c;ne[idx]=h[a];h[a]=idx++;
}

void spfa(){
    while(q.size()){
        auto x=q.front();
        q.pop();
        st[x]=false;
        for (int i=h[x];~i;i=ne[i]){
            int y=e[i],z=target[i];
            if(dist[z]&gt;max(dist[x],dist[y])+max(w[x],w[y])){
                dist[z]=max(dist[x],dist[y])+max(w[x],w[y]);
                if(!st[z]){
                    q.push(z);
                    st[z]=true;
                }
            }
        }
    }
}

int main(){
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;t;
    memset(h,-1,sizeof h);
    for (int i=1;i&lt;=n;i++){
        cin&gt;&gt;w[i];
    }
    memset (dist,0x3f,sizeof dist);
    while(m--){
        int x;
        cin&gt;&gt;x;
        q.push(x);
        dist[x]=0;
        st[x]=true;
    }
    while(k--){
        int a,b,c;
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
        add(a,b,c);
        add(b,a,c);
    }
    spfa();
    cout&lt;&lt;dist[t];
    return 0;
}</code></pre> 
 <p style="">思路：一个一开始根本就没有想到用图做的题，spfa看起来比dijkstra简单点，都是单源最短路，不过spfa可以计算图中有负权边的。</p> 
 <h6 style="">4074.铁路与公路</h6> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=410,INF=0x3f3f3f3f;
int n,m;
int f[N][N],g[N][N];

int floyd(int d[][N]){
    if(d[1][n]==1) return 1;
    for (int k=1;k&lt;=n;k++){
        for (int i=1;i&lt;=n;i++){
            for (int j=1;j&lt;=n;j++){
                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
            }
        }
    }
    return d[1][n];
}

int main(){
    cin&gt;&gt;n&gt;&gt;m;
    memset(f,0x3f,sizeof f);
    memset(g,0x3f,sizeof g);
    while(m--){
        int x,y;
        cin&gt;&gt;x&gt;&gt;y;
        f[x][y]=f[y][x]=1;
    }
    for (int i=1;i&lt;=n;i++){
        for (int j=1;j&lt;=n;j++){
            if(i!=j&amp;&amp;f[i][j]!=1) g[i][j]=g[j][i]=1;
        }
    }
    int res=max(floyd(f),floyd(g));
    if(res==INF) res=-1;
    cout&lt;&lt;res;
    return 0;
}</code></pre> 
 <p style="">思路：floyd可以用于多源最短路，不过三层循环时间会慢一点，数据量少的时候可以用，不顾看起来模板是最好背的 <span class="kdocs-strike" style="text-decoration:line-through;">乐</span></p> 
 <p style=""></p> 
 <p style="">下面的题目就不全是acwing蓝桥杯每日一题了，自己找了点网站别的题做做<span class="kdocs-strike" style="text-decoration:line-through;">（依然还是什么都不会写）</span></p> 
 <h6 style="">4865.有效类型</h6> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">#include &lt;bits/stdc++.h&gt;
using namespace std;
int flag=1;
string str="",s;

void input(){
    if(cin&gt;&gt;s){
        str+=s;
        if(s=="pair"){
            str+='&lt;';
            input();
            str+=',';
            input();
            str+='&gt;';
        }
    }
    else flag=0;
}

int main(){
    int n;
    cin&gt;&gt;n;
    input();
    if(cin&gt;&gt;s) flag=0;
    if(flag==0) cout&lt;&lt;"Error occurred";
    else cout&lt;&lt;str;
    return 0;
}</code></pre> 
 <p style="">思路：y总的思路是构造一棵二叉树，可能会出现两种异常：1、需要输入的时候没有输入了 2、输入完毕了发现还有要输入的。思路真的巧妙但愿我能记住吧</p> 
 <h6 style="">3382.整数划分</h6> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N=21,M=1000010,MOD=1e9;

int m,f[M];

int main(){
    cin&gt;&gt;m;
    f[0]=1;
    
    int n=0;
    for (int i=1,v=1;v&lt;=m;i++,v*=2){
        n++;
        for (int j=v;j&lt;=m;j++){
            f[j]=(f[j]+f[j-v])%MOD;
        }
    }
    cout&lt;&lt;f[m];
    return 0;
}</code></pre> 
 <p style="">思路：有限制的选择问题可以选择用背包，然后就是模板了，二维转换为一维的优化需要记一下。背包背包背包，你咋老是想不起来用。</p> 
 <p style="">以上仅是我个人学习记录，有问题还请大家指正</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/48a6530da7cbcd157977e030cb7f88ee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">软件开发的复杂性与效能提升</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c765c7c467cac86a323bd05d7de02223/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C】文件操作(fopen等函数)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>