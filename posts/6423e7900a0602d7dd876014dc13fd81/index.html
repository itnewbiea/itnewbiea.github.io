<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第二章 HTTP请求方法、状态码详解与缓存机制解析 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第二章 HTTP请求方法、状态码详解与缓存机制解析" />
<meta property="og:description" content="1. 请求方法（GET、POST、PUT、DELETE等）及其应用场景 本质上只有get和post请求，其他都是post请求
1.1 GET 定义：GET是HTTP中最常用的方法，用于从服务器获取资源。特点： 请求参数通常放在URL的查询字符串中，即?key1=value1&amp;key2=value2格式。GET请求可被浏览器缓存，并且会被保存在浏览历史记录中。（不理解没关系，后面会单独说）2m的数据限制。不应有副作用，也就是说，它不应该改变服务器上的资源状态。 应用场景： 获取静态页面内容。查询数据库以获取列表信息或详情信息。 1.2 POST 定义：POST方法用于向指定资源提交数据，请求被包含在请求体中，可能引起服务器端资源的创建、更新或操作。特点： 数据不会显示在URL中，而是通过请求体传输，可以携带大量数据。可能会有副作用，比如新增用户信息、发表评论等操作。非幂等性：多次执行相同的POST请求可能会有不同的结果，例如每次提交都会创建一个新的资源实例。 应用场景： 提交表单数据。创建新的资源，如添加一篇文章、上传文件等。 POST请求的请求体（Body）是用来承载客户端要发送给服务器的数据部分，根据不同的应用场景和内容类型（Content-Type），请求体的内容格式会有所不同。对于上传文件的情况，通常采用multipart/form-data、application/x-www-form-urlencoded、application/json。
multipart/form-data：
这是最常见的文件上传方式，尤其在HTML表单中通过&lt;input type=&#34;file&#34;&gt;元素选择文件时，默认使用此Content-Type。请求体被划分为多个部分（parts），每个部分包含一个或多个字段及其对应的值，文件字段则包含了文件内容本身。每个部分都有自己的Header描述信息，例如：
--boundary_string Content-Disposition: form-data; name=&#34;field1&#34; value1 --boundary_string Content-Disposition: form-data; name=&#34;file&#34;; filename=&#34;example.txt&#34; Content-Type: text/plain ... file contents here ... --boundary_string-- 在这个例子中，“boundary_string”是一个由服务器指定或者浏览器自动生成的分隔符，用于区分各个部分。文件字段通过Content-Disposition头部中的filename属性来标识上传文件的名字，并且其内容紧跟在头部后面。
application/x-www-form-urlencoded：
尽管这种Content-Type也能上传少量数据，但不适合大文件或二进制文件的上传，因为这种方式下所有的键值对都会被编码为一串连续的字符序列，例如：
field1=value1&amp;file=encoded_file_contents 对于文件内容，通常是不现实的将其编码成URL安全的形式并作为请求体的一部分。
在实际编程过程中，比如使用Python的requests库、JavaScript的Fetch API或XMLHttpRequest等工具，都需要正确设置Content-Type，并将文件内容以适当的方式添加到请求体中。例如，在requests库中，可以这样上传文件：
import requests url = &#39;https://example.com/upload&#39; files = {&#39;file&#39;: (&#39;example.txt&#39;, open(&#39;path_to_your_file.txt&#39;, &#39;rb&#39;))} response = requests.post(url, files=files) 这里open(&#39;path_to_your_file.txt&#39;, &#39;rb&#39;)用来打开文件并以二进制读取模式准备上传，requests库会自动处理请求头和请求体的格式化工作。
在使用multipart/form-data格式上传文件时，除了基本的文件内容传输外，还可以携带其他非文件字段数据。例如，在一个表单中可能同时包含文本输入框和其他控件的数据，整个POST请求体将会包括这些额外信息：
--boundary_string Content-Disposition: form-data; name=&#34;title&#34; File Title --boundary_string Content-Disposition: form-data; name=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6423e7900a0602d7dd876014dc13fd81/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-05T17:17:51+08:00" />
<meta property="article:modified_time" content="2024-01-05T17:17:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第二章 HTTP请求方法、状态码详解与缓存机制解析</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_GETPOSTPUTDELETE_0"></a>1. 请求方法（GET、POST、PUT、DELETE等）及其应用场景</h2> 
<p>本质上只有get和post请求，其他都是post请求</p> 
<h3><a id="11_GET_2"></a>1.1 GET</h3> 
<ul><li><strong>定义</strong>：GET是HTTP中最常用的方法，用于从服务器获取资源。</li><li><strong>特点</strong>： 
  <ul><li>请求参数通常放在URL的查询字符串中，即<code>?key1=value1&amp;key2=value2</code>格式。</li><li>GET请求可被浏览器缓存，并且会被保存在浏览历史记录中。<code>（不理解没关系，后面会单独说）</code></li><li>2m的数据限制。</li><li>不应有副作用，也就是说，它不应该改变服务器上的资源状态。</li></ul> </li><li><strong>应用场景</strong>： 
  <ul><li>获取静态页面内容。</li><li>查询数据库以获取列表信息或详情信息。</li></ul> </li></ul> 
<h3><a id="12_POST_13"></a>1.2 POST</h3> 
<ul><li><strong>定义</strong>：POST方法用于向指定资源提交数据，请求被包含在请求体中，可能引起服务器端资源的创建、更新或操作。</li><li><strong>特点</strong>： 
  <ul><li>数据不会显示在URL中，而是通过请求体传输，可以携带大量数据。</li><li>可能会有副作用，比如新增用户信息、发表评论等操作。</li><li>非幂等性：多次执行相同的POST请求可能会有不同的结果，例如每次提交都会创建一个新的资源实例。</li></ul> </li><li><strong>应用场景</strong>： 
  <ul><li>提交表单数据。</li><li>创建新的资源，如添加一篇文章、上传文件等。</li></ul> </li></ul> 
<p>POST请求的请求体（Body）是用来承载客户端要发送给服务器的数据部分，根据不同的应用场景和内容类型（Content-Type），请求体的内容格式会有所不同。对于上传文件的情况，通常采用<code>multipart/form-data</code>、<code>application/x-www-form-urlencoded</code>、<code>application/json</code>。</p> 
<p><strong>multipart/form-data</strong>：<br> 这是最常见的文件上传方式，尤其在HTML表单中通过<code>&lt;input type="file"&gt;</code>元素选择文件时，默认使用此Content-Type。请求体被划分为多个部分（parts），每个部分包含一个或多个字段及其对应的值，文件字段则包含了文件内容本身。每个部分都有自己的Header描述信息，例如：</p> 
<pre><code class="prism language-http">--boundary_string
Content-Disposition: form-data; name="field1"

value1
--boundary_string
Content-Disposition: form-data; name="file"; filename="example.txt"
Content-Type: text/plain

... file contents here ...
--boundary_string--
</code></pre> 
<p>在这个例子中，“boundary_string”是一个由服务器指定或者浏览器自动生成的分隔符，用于区分各个部分。文件字段通过<code>Content-Disposition</code>头部中的<code>filename</code>属性来标识上传文件的名字，并且其内容紧跟在头部后面。</p> 
<p><strong>application/x-www-form-urlencoded</strong>：<br> 尽管这种Content-Type也能上传少量数据，但不适合大文件或二进制文件的上传，因为这种方式下所有的键值对都会被编码为一串连续的字符序列，例如：</p> 
<pre><code class="prism language-text">field1=value1&amp;file=encoded_file_contents
</code></pre> 
<p>对于文件内容，通常是不现实的将其编码成URL安全的形式并作为请求体的一部分。</p> 
<p>在实际编程过程中，比如使用Python的requests库、JavaScript的Fetch API或XMLHttpRequest等工具，都需要正确设置Content-Type，并将文件内容以适当的方式添加到请求体中。例如，在requests库中，可以这样上传文件：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> requests

url <span class="token operator">=</span> <span class="token string">'https://example.com/upload'</span>
files <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">'file'</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token string">'example.txt'</span><span class="token punctuation">,</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'path_to_your_file.txt'</span><span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
response <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span> files<span class="token operator">=</span>files<span class="token punctuation">)</span>
</code></pre> 
<p>这里<code>open('path_to_your_file.txt', 'rb')</code>用来打开文件并以二进制读取模式准备上传，requests库会自动处理请求头和请求体的格式化工作。<br> 在使用<code>multipart/form-data</code>格式上传文件时，除了基本的文件内容传输外，还可以携带其他非文件字段数据。例如，在一个表单中可能同时包含文本输入框和其他控件的数据，整个POST请求体将会包括这些额外信息：</p> 
<pre><code class="prism language-http">--boundary_string
Content-Disposition: form-data; name="title"

File Title
--boundary_string
Content-Disposition: form-data; name="description"

A brief description of the file
--boundary_string
Content-Disposition: form-data; name="file"; filename="example.txt"
Content-Type: text/plain

... file contents here ...
--boundary_string--
</code></pre> 
<p>这里的“File Title”和“A brief description of the file”是与文件一同提交的额外字段数据。</p> 
<p>在服务器端处理POST请求时，需要能够解析这种多部分格式的请求体来提取出各个字段的值以及文件内容。大多数现代Web框架（如Django、Express.js等）都提供了内置或第三方中间件来方便地处理<code>multipart/form-data</code>类型的文件上传。</p> 
<p>另外，对于大文件的上传，还需要考虑以下几点：</p> 
<ul><li><strong>分块上传</strong>：为了支持大文件上传并提高稳定性，可以采用分块上传的方式，将文件分成多个小块分别发送，最后在服务器端合并。</li><li><strong>限制大小</strong>：服务器通常会设置最大允许上传文件的大小限制，以防止资源耗尽或其他安全风险。</li><li><strong>进度监控</strong>：在前端实现文件上传时，可以通过监听事件来实时显示上传进度，提升用户体验。</li></ul> 
<p>总之，POST请求体用于文件上传是一个相对复杂的过程，涉及到了HTTP协议、浏览器行为、服务器端编程等多个环节的协同工作。</p> 
<h3><a id="13_PUT_91"></a>1.3 PUT</h3> 
<ul><li><strong>定义</strong>：PUT方法用于替换目标资源的所有当前表示。如果资源不存在，则服务器通常会创建该资源。与POST相比，PUT更强调幂等性，即多次执行同样的PUT操作，服务器端状态应该保持一致。</li><li><strong>特点</strong>： 
  <ul><li>客户端需提供完整的资源实体，服务器根据请求URI进行更新或创建。</li><li>操作具有幂等性，多次执行同样的PUT请求应该产生相同的效果（除非资源本身发生了变化）。</li></ul> </li><li><strong>应用场景</strong>： 
  <ul><li>更新已存在的资源属性，例如修改用户个人资料。</li><li>对于RESTful API设计，全量更新资源时使用。</li></ul> </li></ul> 
<h3><a id="14_DELETE_100"></a>1.4 DELETE</h3> 
<ul><li><strong>定义</strong>：DELETE方法请求服务器删除指定的资源。</li><li><strong>特点</strong>： 
  <ul><li>删除操作无响应主体，仅通过HTTP响应头部和状态码告知结果。</li><li>也具有幂等性，多次发出相同的DELETE请求都会删除同一个资源。</li></ul> </li><li><strong>应用场景</strong>： 
  <ul><li>删除某个特定资源，例如删除一个文章、账户或者订单。</li></ul> </li></ul> 
<h3><a id="15__108"></a>1.5 其他方法</h3> 
<p>除了上述四种常见方法外，还有HEAD、OPTIONS、PATCH等：</p> 
<ul><li>HEAD类似于GET，但只返回响应头而不返回实体主体，常用来检查资源是否存在或获取资源的元信息。</li><li>OPTIONS允许客户端查看服务器支持哪些HTTP方法，用于服务发现或跨域预检。</li><li>PATCH用于对资源进行部分更新，仅提交需要更改的内容而不是整个资源。</li></ul> 
<hr> 
<h2><a id="2___117"></a>2. 状态码含义及常见状态码分析</h2> 
<h5><a id="_119"></a>常见状态码：</h5> 
<ul><li><strong>200 OK</strong>：请求成功，服务器已成功处理请求并返回资源。</li><li><strong>301 Moved Permanently</strong>：永久重定向，请求的资源已被分配了新的URL。</li><li><strong>302 Found</strong>：临时重定向，请求的资源临时位于其他URL下。</li><li><strong>400 Bad Request</strong>：客户端请求语法错误，服务器无法理解。</li><li><strong>401 Unauthorized</strong>：请求未经授权，需要提供认证信息（如API Key、Token等）。</li><li><strong>403 Forbidden</strong>：服务器理解请求，但拒绝提供服务，通常因为权限问题。</li><li><strong>404 Not Found</strong>：请求的资源在服务器上未找到。</li><li><strong>500 Internal Server Error</strong>：服务器遇到了意外情况，无法完成请求。</li><li><strong>503 Service Unavailable</strong>：服务器暂时无法处理请求，可能由于过载或维护。</li></ul> 
<hr> 
<h2><a id="3__133"></a>3. 请求头与响应头关键字段解析</h2> 
<h3><a id="31__135"></a>3.1 常见请求头：</h3> 
<ul><li><strong>User-Agent</strong>：标识客户端应用程序的信息，如浏览器类型、版本等。</li><li><strong>Authorization</strong>：用于验证用户的凭证，例如Bearer Token或Basic Auth凭据。</li><li><strong>Content-Type</strong>：指示请求主体的数据格式，如<code>application/json</code>、<code>multipart/form-data</code>等。</li><li><strong>Accept</strong>：告诉服务器客户端接受哪些媒体类型作为响应。</li><li><strong>Cookie</strong>：客户端发送到服务器的cookies信息，用于保持会话状态。</li></ul> 
<h3><a id="32__142"></a>3.2 常见响应头：</h3> 
<ul><li><strong>Content-Type</strong>：同请求头，指示响应主体的数据格式。</li><li><strong>Content-Length</strong>：响应主体内容的长度（字节数）。</li><li><strong>Location</strong>：用于重定向的URL，在3xx状态码出现时使用。</li><li><strong>Set-Cookie</strong>：服务器发给客户端的cookie信息，用于设置新会话或更新现有会话。</li><li><strong>Cache-Control</strong>：控制缓存策略，如最大Age、是否允许缓存等。</li></ul> 
<hr> 
<h2><a id="4_HTTP_151"></a>4. HTTP缓存机制介绍</h2> 
<p>HTTP协议支持多种缓存机制来提高性能和减少网络带宽消耗，主要通过以下几种头部字段实现：</p> 
<ul><li> <p><strong>Expires</strong>：规定缓存过期时间，到了这个时间点后，缓存不再有效。</p> </li><li> <p><strong>Cache-Control</strong>：更详细的缓存控制指令集，包括max-age、no-cache、public、private等。</p> 
  <ul><li><code>max-age</code>：设置缓存的最大生存时间（秒数）。</li><li><code>no-cache</code>：要求验证缓存的有效性，即使有缓存也要与服务器确认。</li><li><code>public</code>：指示响应可以被任何中间缓存存储。</li><li><code>private</code>：指示响应只能被单个用户浏览器缓存，不能被共享缓存（如CDN）存储。</li></ul> </li><li> <p><strong>Last-Modified / If-Modified-Since</strong>：基于时间戳判断资源是否发生过改动。</p> </li><li> <p><strong>ETag / If-None-Match</strong>：基于资源实体标签判断资源是否发生过变动。</p> </li></ul> 
<p>HTTP缓存机制是Web性能优化中非常重要的一环，它允许浏览器、代理服务器以及其他中间件存储HTTP响应的副本，并在后续请求时使用这些副本来避免不必要的网络延迟。以下是一些核心的HTTP缓存机制以及相关的代码示例：</p> 
<h3><a id="41_Expires_167"></a>4.1. <strong>Expires</strong></h3> 
<ul><li>Expires头字段是一个绝对时间戳，表示缓存何时应该失效。</li></ul> 
<pre><code class="prism language-http">HTTP/1.1 200 OK
Content-Type: text/html
Cache-Control: max-age=3600
Expires: Wed, 01 Jan 2025 00:00:00 GMT
</code></pre> 
<p>在上述响应头中，<code>Cache-Control: max-age=3600</code> 表示资源在接下来的一个小时内有效；而 <code>Expires</code> 设置了一个未来的时间点，过了这个时间点后，浏览器认为缓存过期。</p> 
<h3><a id="42_CacheControl_177"></a>4.2. <strong>Cache-Control</strong></h3> 
<ul><li><code>Cache-Control</code> 是一个更强大的缓存控制策略，它可以设置多种指令如：<code>max-age</code>（相对有效期）、<code>no-cache</code>（需要验证缓存的有效性）、<code>public</code>（可以被任何缓存存储）和 <code>private</code>（只能被单个用户浏览器缓存）等。</li></ul> 
<pre><code class="prism language-http">HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: max-age=300, public
</code></pre> 
<h3><a id="43_LastModified__IfModifiedSince_185"></a>4.3. <strong>Last-Modified / If-Modified-Since</strong></h3> 
<ul><li>服务器通过 <code>Last-Modified</code> 头部提供资源最后修改的时间戳，客户端在下一次请求时带上 <code>If-Modified-Since</code> 头部，询问服务器资源是否自上次访问以来有变化。</li></ul> 
<pre><code class="prism language-http">// 首次请求响应：
HTTP/1.1 200 OK
Last-Modified: Sat, 23 Oct 2021 08:23:45 GMT

// 客户端再次请求时：
GET /resource HTTP/1.1
If-Modified-Since: Sat, 23 Oct 2021 08:23:45 GMT
</code></pre> 
<p>如果资源未改变，服务器会返回304 Not Modified状态码，并且没有响应体，客户端则从缓存中获取内容。</p> 
<h3><a id="44_ETag__IfNoneMatch_198"></a>4.4. <strong>ETag / If-None-Match</strong></h3> 
<ul><li>ETag（实体标签）是服务器为每个资源生成的一个唯一标识符，用来判断资源是否有变动。与 <code>Last-Modified</code> 类似，客户端会在下次请求时携带 <code>If-None-Match</code> 头部。</li></ul> 
<pre><code class="prism language-http">// 首次请求响应：
HTTP/1.1 200 OK
ETag: "ae3f7e9a"

// 客户端再次请求时：
GET /resource HTTP/1.1
If-None-Match: "ae3f7e9a"
</code></pre> 
<p>如果ETag匹配，服务器同样会返回304状态码。</p> 
<p>在实际编程中，开发者通常不需要直接编写处理这些头部信息的代码，因为现代Web框架或库（如Express.js、axios等）已经内置了对HTTP缓存机制的支持。不过，开发者可以根据业务需求配置响应头，以实现定制化的缓存策略。例如，在Node.js的Express框架中：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/resource'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 假设这里的getResource函数从数据库获取数据</span>
  <span class="token keyword">const</span> resource <span class="token operator">=</span> <span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 设置缓存策略</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Cache-Control'</span><span class="token punctuation">,</span> <span class="token string">'public, max-age=3600'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'ETag'</span><span class="token punctuation">,</span> <span class="token function">generateETag</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 假设有generateETag函数用于生成ETag</span>
  
  res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<hr> 
<h2><a id="5_HTTPS_232"></a>5. HTTPS加密传输原理</h2> 
<p>HTTPS（Hypertext Transfer Protocol Secure）是在HTTP协议的基础上加入了SSL/TLS协议，为数据传输提供了安全保证。</p> 
<ul><li><strong>握手过程</strong>：客户端与服务器首先进行TLS握手阶段，协商加密算法、交换证书等，建立安全连接。</li><li><strong>证书验证</strong>：服务器向客户端发送其数字证书，客户端验证证书合法性，确保与正确的服务器通信。</li><li><strong>密钥交换</strong>：双方利用非对称加密算法（如RSA）生成会话密钥，用于后续的数据加密。</li><li><strong>加密传输</strong>：实际数据传输阶段，所有通信内容都采用协商好的会话密钥进行对称加密，确保数据在传输过程中不被窃取或篡改。</li></ul> 
<p>通过HTTPS，客户端和服务器之间建立起了一条安全通道，既保证了数据的机密性，又确保了数据的完整性，同时还能够防止中间人攻击。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/db63b1c140adbafcb1c20e42c68f96e5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MyBatis-Plus框架学习笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/913b961c0aeebcb2b0271406ad5b656f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RFC3261: SIP:11.2 OPTIONS请求的处理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>