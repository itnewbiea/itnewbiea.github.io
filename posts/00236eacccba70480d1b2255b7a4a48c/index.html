<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Springboot实现微信公众号模板消息发送 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Springboot实现微信公众号模板消息发送" />
<meta property="og:description" content="最近看了一个地推的公众号，每天都会给你推送好几条地推需要的模板消息，好一段时间没有做公众号开发了，最近刚申请了个服务号，刚好可以拿来开发。模板消息需要服务号才可以，申请服务号的话需要企业营业执照，个人的话是没有办法申请的。下面来分享一下我的开发过程。
开发步骤 1.微信公众号服务号 2.准备好 APPID 跟AppSecret 3.开通模板消息，申请一个模板，获取模板ID 4.获取ACCESS_TOKEN 5.获取关注公众号的用户列表 6.选择需要发送的用户，并推送消息 一、资料申请 1.1、获取 APPID 跟AppSecret 1.2、获取 模板消息ID 找不到的话，就在新功能上面去添加；
二、开发 2.1、编写yml配置文件 #公众号配置 wechat: appid: APPID appkey: APP密钥 messageId: 模板ID 2.2、编写配置类 import lombok.Data; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component @Data public class WechatConfig { @Value(&#34;${wechat.appid}&#34;) private String appid; @Value(&#34;${wechat.appkey}&#34;) private String appkey; } 2.3、获取ACCESS_TOKEN 这里有点类似登录吧，就是用咱们的APPID跟APP密钥送到官方接口那边去验证身份，如果没问题人家就给你返回一个token，方便后面调用接口可以传，让官方接口知道是谁发过来的。token是临时的，有效期是2个小时.
2.3.1、导入工具类 （hutool）maven依赖 &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;${hutool.version}&lt;/version&gt; &lt;/dependency&gt; 2.3.2、导入工具类 （hutool）maven依赖 @Component public class ConfigurationService { private String accessTokenUrl = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/00236eacccba70480d1b2255b7a4a48c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-20T20:59:21+08:00" />
<meta property="article:modified_time" content="2023-07-20T20:59:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Springboot实现微信公众号模板消息发送</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>最近看了一个地推的公众号，每天都会给你推送好几条地推需要的模板消息，好一段时间没有做公众号开发了，最近刚申请了个服务号，刚好可以拿来开发。模板消息需要服务号才可以，申请服务号的话需要企业营业执照，个人的话是没有办法申请的。下面来分享一下我的开发过程。<br> <img src="https://images2.imgbox.com/b6/a6/psvNx8Ky_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_3"></a>开发步骤</h5> 
<h6><a id="1_4"></a>1.微信公众号服务号</h6> 
<h6><a id="2_APPID_AppSecret_5"></a>2.准备好 APPID 跟AppSecret</h6> 
<h6><a id="3ID_6"></a>3.开通模板消息，申请一个模板，获取模板ID</h6> 
<h6><a id="4ACCESS_TOKEN_7"></a>4.获取ACCESS_TOKEN</h6> 
<h6><a id="5_8"></a>5.获取关注公众号的用户列表</h6> 
<h6><a id="6_9"></a>6.选择需要发送的用户，并推送消息</h6> 
<h2><a id="_10"></a>一、资料申请</h2> 
<h4><a id="11_APPID_AppSecret_11"></a>1.1、获取 APPID 跟AppSecret</h4> 
<p><img src="https://images2.imgbox.com/3a/77/WLcox3mv_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ab/6b/eCkfK2Kv_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="12_ID_14"></a>1.2、获取 模板消息ID</h4> 
<p>找不到的话，就在新功能上面去添加；<br> <img src="https://images2.imgbox.com/09/b0/6vd8oV2f_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/08/17/PPUAhyjq_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_19"></a>二、开发</h2> 
<h4><a id="21yml_20"></a>2.1、编写yml配置文件</h4> 
<pre><code>#公众号配置
wechat:
    appid:  APPID
    appkey: APP密钥
    messageId: 模板ID
</code></pre> 
<h4><a id="22_28"></a>2.2、编写配置类</h4> 
<pre><code>import lombok.Data;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
@Data
public class WechatConfig {
    @Value("${wechat.appid}")
    private String appid;
    @Value("${wechat.appkey}")
    private String appkey;
}
</code></pre> 
<h4><a id="23ACCESS_TOKEN_43"></a>2.3、获取ACCESS_TOKEN</h4> 
<p>这里有点类似登录吧，就是用咱们的APPID跟APP密钥送到官方接口那边去验证身份，如果没问题人家就给你返回一个token，方便后面调用接口可以传，让官方接口知道是谁发过来的。token是临时的，有效期是2个小时.</p> 
<h5><a id="231_hutoolmaven_45"></a>2.3.1、导入工具类 （hutool）maven依赖</h5> 
<pre><code>		&lt;dependency&gt;
			&lt;groupId&gt;cn.hutool&lt;/groupId&gt;
			&lt;artifactId&gt;hutool-all&lt;/artifactId&gt;
			&lt;version&gt;${hutool.version}&lt;/version&gt;
		&lt;/dependency&gt;
</code></pre> 
<h5><a id="232_hutoolmaven_54"></a>2.3.2、导入工具类 （hutool）maven依赖</h5> 
<pre><code>@Component
public class ConfigurationService {
    private String accessTokenUrl = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;";

    @Autowired
    private WechatConfig wechatConfig;

    public JSONObject getAccessToken() {
        String requestUrl = accessTokenUrl + "appid=" + wechatConfig.getAppid() + "&amp;secret=" + wechatConfig.getAppkey();
        String resp = HttpUtil.get(requestUrl);
        JSONObject result = JSONUtil.parseObj(resp);
        System.out.println("获取access_token:" + resp);

        return result;
    }
}

</code></pre> 
<h4><a id="24_74"></a>2.4、获取关注你公众号的用户列表</h4> 
<p>因为我们在发送模板消息的时候，需要填推送的对象（openid），<br> 所以我们需要先查询出用户，再一个个推送。</p> 
<pre><code>    /**
     * 获取用户列表
     * @param accessToken
     * @return
     */

    public JSONObject getUserList(String accessToken) {
        String requestUrl = "https://api.weixin.qq.com/cgi-bin/user/get?access_token=" + accessToken + "&amp;next_openid=";
        String resp = HttpUtil.get(requestUrl);
        JSONObject result = JSONUtil.parseObj(resp);
        System.out.println("用户列表:" + resp);
        return result;
    }
</code></pre> 
<blockquote> 
 <p>next_openid=这个可以为空，代表从头查起。也可以放上某个用户的openid,发送请求的到时候，用来告诉官方接口从哪个用户开始查起。因为查询一次，最多只能查一万条数据，假设你有几万个用户，那么你就需要查询好几次了，就需要用到这个参数。</p> 
</blockquote> 
<h4><a id="25_94"></a>2.5、发送模板消息</h4> 
<h5><a id="251_95"></a>2.5.1、新建消息配置类</h5> 
<p>因为我是将把配置写到数据库里面了，方便后面添加发送任务。大家不一定要做这部操作哈。！</p> 
<pre><code>@Data
@TableName("template_msg")
public class TemplateMsgEntity implements Serializable {
    private static final long serialVersionUID = 1L;

    /**
     *
     */
    @TableId
    private Integer id;
    /**
     * 标题
     */
    private String tTitle;
    /**
     * 第一行
     */
    private String tKeyword1;
    /**
     * 第二行
     */
    private String tKeyword2;
    /**
     * 第三行
     */
    private String tKeyword3;
    /**
     * 第四行
     */
    private String tKeyword4;
    /**
     * 备注
     */
    private String tRemark;
    /**
     * 跳转连接
     */
    private String tUrl;
    /**
     * 模板编码
     */
    private String tCode;
    /**
     * 状态
     */
    private int tStatus;
}
</code></pre> 
<p>模板发送</p> 
<pre><code>  public JSONObject sendMsg(TemplateMsgEntity messageVo, String token, String openId) {
        String requestUrl = " https://api.weixin.qq.com/cgi-bin/message/template/send?access_token="  + token;
        Map&lt;String,Object&gt; content=new HashMap&lt;&gt;();
        JSONObject data = JSONUtil.createObj();
        data.put("first",new JSONObject().put("value",messageVo.getTTitle()));
        data.put("keyword1",new JSONObject().put("value",messageVo.getTKeyword1()));
        data.put("keyword2",new JSONObject().put("value",messageVo.getTKeyword2()));
        data.put("keyword3",new JSONObject().put("value",messageVo.getTKeyword3()));
        data.put("keyword4",new JSONObject().put("value",messageVo.getTKeyword4()));
        data.put("remark",new JSONObject().put("value",messageVo.getTRemark()));
        
        content.put("touser",openId);
        content.put("url",messageVo.getTUrl());
        content.put("template_id","jbgHt8W8RNpRN2KZwvAMty40iiZU2sa9dqnFXOsCvqw");
        content.put("data",data);
        String resp = HttpUtil.post(requestUrl,JSONUtil.parseFromMap(content).toString());
        System.out.println(content.toString());
        System.out.println(JSONUtil.parseFromMap(content));
        JSONObject result = JSONUtil.parseObj(resp);
        System.out.println("发送消息:" + resp);
        return result;
    }
</code></pre> 
<blockquote> 
 <p>接口字段要对应着来。<br> 官方文档：https://mp.weixin.qq.com/advanced/tmplmsg?action=faq&amp;token=1066457355&amp;lang=zh_CN</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/e5/34/mJvcGrdR_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>有个需要注意的地方就是，模板封装好之后，推送到官方提供的接口时，数据类型是String类型哦，别整个对象就过来，那样解析不了的。</p> 
</blockquote> 
<h2><a id="_179"></a>三、测试</h2> 
<pre><code>  /**
     * 发送模板消息
     * @return
     */
    @GetMapping( "/sedMsg")
    public JSONObject sedMsg(){
      JSONObject accessToken = configurationService.getAccessToken();
      String token=accessToken.getStr("access_token");
       //获取用户列表
        JSONObject userList = configurationService.getUserList(token);
        JSONArray openids = userList.getJSONObject("data").getJSONArray("openid");
        System.out.println(openids.toArray());
        TemplateMsgEntity messageVo=new TemplateMsgEntity();
        messageVo.setTTitle("标题");
        messageVo.setTKeyword1("测试1");
        messageVo.setTKeyword2("测试2");
        messageVo.setTKeyword3("测试3");
        messageVo.setTKeyword4("测试4");
        messageVo.setTRemark("remark");
        for (Object openid:openids) {
            JSONObject resp = configurationService.sendMsg(messageVo,token,openid.toString());

        }
        return null;
    }
</code></pre> 
<p><img src="https://images2.imgbox.com/18/a9/h0TTlvPz_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_208"></a>四、优化</h2> 
<p>由于ACCESS_TOKEN只有两个小时就过期，所以我们应该专门写一个服务，或者一个定时间任务，隔一段时间就去读取数据库中记录的access_token,并且将写入access_token的时间跟现在的时间进行比较，大概超过117分钟时，就重新刷新写到数据中去。思路是这样的，大家可以自己写哈，方式很多。</p> 
<pre><code>@Configuration
@EnableScheduling
public class MessageTask {
    @Autowired
    SysConfigService sysConfigService;
    @Autowired
    ConfigurationService configurationService;
    @Autowired
    TemplateMsgService templateMsgService;
    /**
     * 维护Token
     */
    @Scheduled(fixedRate = 120000)
    public void tokenTask(){
        System.out.println("定时任务开启：");
        //获取token
        String token = sysConfigService.getValue("ACCESS_TOKEN");
        
        JSONObject json = JSONUtil.parseObj(token);
        String expires_date = json.getStr("expires_date");
        //token创建的时间
        DateTime parse = DateUtil.parse(expires_date);
        //跟现在的时间对比是否大于7000s 
        long between = DateUtil.between(parse, new DateTime(), DateUnit.MINUTE);
        System.out.println("时间比较："+between);
        //快过期了，重新刷新token
        if (between&gt;115){ 
            JSONObject accessToken = configurationService.getAccessToken();
            if (accessToken.getStr("expires_in")!=null&amp;&amp;accessToken.getStr("expires_in").equals("7200")){
                accessToken.put("expires_date",DateUtil.now().toString());
                sysConfigService.updateValueByKey("ACCESS_TOKEN",accessToken.toString());
                System.out.println("token更新了："+accessToken.toString());
            }
            
        }

    }
   
}

</code></pre> 
<blockquote> 
 <p>希望能帮助到大家</p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b89c490b2667b2a9ff06ee5dbef963e5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">OpenGL安装配置-全网最简单教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1f6eaf2b7574ce3ab57107fb04f28ebb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python数据爬取超详细讲解（零基础入门，老年人都看的懂）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>