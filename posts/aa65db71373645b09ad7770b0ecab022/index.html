<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GYP用户文档 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GYP用户文档" />
<meta property="og:description" content="文章目录 介绍标准的Chromium .gyp文件的骨架.gyp文件中标准的可执行目标.gyp文件中标准的库目标使用实例添加新的源文件添加一个在所有平台构建的源文件添加特定平台的源文件 添加可执行文件为目标添加设置跨平台编译添加新的库目标目标之间依赖支持 MAC OS X bundle移动文件自定义构建步骤构建特色 GYP 是一个元构建系统，一个生成其他构建系统的构建系统
GYP旨在支持需要构建在多个平台上的大型项目(例如，Mac、Windows、Linux)，重要的是项目可以使用在每个平台上流行的IDE来构建，就像项目是一个“本地”项目一样。
它可以用来生成XCode项目、Visual Studio项目、Ninja构建文件和makefile文件。在每种情况下，GYP的目标都是尽可能地复制使用IDE设置本机构建项目的方式。
GYP还可以用于生成“混合”项目，这些项目为良好的用户体验提供IDE脚手架，但需要Ninja来进行实际的构建(这通常比IDE的本地构建系统快得多)。
介绍 本文档旨在提供用户级的GYP指南，这里的重点是如何使用GYP来完成特定的任务，而不是完整的技术语言规范。(对此，请参阅语言描述。)
下面的文档从提供上下文的览开始:.gyp文件本身的结构概览、.gyp文件中典型的可执行程序目标概览、.gyp文件中典型的库目标概览。
在概览之后，有一些针对不同常见用例的gyp模式示例。
标准的Chromium .gyp文件的骨架 这是Chromium项目中一个典型的.gyp文件的骨架：
{ &#39;variables&#39;: { . . . }, &#39;includes&#39;: [ &#39;../build/common.gypi&#39;, ], &#39;target_defaults&#39;: { . . . }, &#39;targets&#39;: [ { &#39;target_name&#39;: &#39;target_1&#39;, . . . }, { &#39;target_name&#39;: &#39;target_2&#39;, . . . }, ], &#39;conditions&#39;: [ [&#39;OS==&#34;linux&#34;&#39;, { &#39;targets&#39;: [ { &#39;target_name&#39;: &#39;linux_target_3&#39;, . . . }, ], }], [&#39;OS==&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/aa65db71373645b09ad7770b0ecab022/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-18T17:07:27+08:00" />
<meta property="article:modified_time" content="2020-11-18T17:07:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GYP用户文档</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><a href="#_12" rel="nofollow">介绍</a></li><li><a href="#Chromium_gyp_20" rel="nofollow">标准的Chromium .gyp文件的骨架</a></li><li><a href="#gyp_92" rel="nofollow">.gyp文件中标准的可执行目标</a></li><li><a href="#gyp_150" rel="nofollow">.gyp文件中标准的库目标</a></li><li><a href="#_213" rel="nofollow">使用实例</a></li><li><ul><li><a href="#_217" rel="nofollow">添加新的源文件</a></li><li><ul><li><ul><li><a href="#_220" rel="nofollow">添加一个在所有平台构建的源文件</a></li><li><a href="#_240" rel="nofollow">添加特定平台的源文件</a></li></ul> 
     </li></ul> 
     </li><li><a href="#_264" rel="nofollow">添加可执行文件</a></li><li><a href="#_266" rel="nofollow">为目标添加设置</a></li><li><a href="#_267" rel="nofollow">跨平台编译</a></li><li><a href="#_268" rel="nofollow">添加新的库目标</a></li><li><a href="#_269" rel="nofollow">目标之间依赖</a></li><li><a href="#_MAC_OS_X_bundle_270" rel="nofollow">支持 MAC OS X bundle</a></li><li><a href="#_271" rel="nofollow">移动文件</a></li><li><a href="#_273" rel="nofollow">自定义构建步骤</a></li><li><a href="#_274" rel="nofollow">构建特色</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p><a href="https://chromium.googlesource.com/external/gyp" rel="nofollow"><code>GYP</code></a> 是一个元构建系统，一个生成其他构建系统的构建系统</p> 
<p><code>GYP</code>旨在支持需要构建在多个平台上的大型项目(例如，<code>Mac</code>、<code>Windows</code>、<code>Linux</code>)，重要的是项目可以使用在每个平台上流行的<code>IDE</code>来构建，就像项目是一个“本地”项目一样。</p> 
<p>它可以用来生成<code>XCode</code>项目、<code>Visual Studio</code>项目、<code>Ninja</code>构建文件和<code>makefile</code>文件。在每种情况下，<code>GYP</code>的目标都是尽可能地复制使用<code>IDE</code>设置本机构建项目的方式。</p> 
<p><code>GYP</code>还可以用于生成“混合”项目，这些项目为良好的用户体验提供<code>IDE</code>脚手架，但需要<code>Ninja</code>来进行实际的构建(这通常比<code>IDE</code>的本地构建系统快得多)。</p> 
<h4><a id="_12"></a>介绍</h4> 
<p>本文档旨在提供用户级的<code>GYP</code>指南，这里的重点是如何使用<code>GYP</code>来完成特定的任务，而不是完整的技术语言规范。(对此，请参阅语言描述。)</p> 
<p>下面的文档从提供上下文的览开始:<code>.gyp</code>文件本身的结构概览、<code>.gyp</code>文件中典型的可执行程序目标概览、<code>.gyp</code>文件中典型的库目标概览。</p> 
<p>在概览之后，有一些针对不同常见用例的<code>gyp</code>模式示例。</p> 
<h4><a id="Chromium_gyp_20"></a>标准的Chromium .gyp文件的骨架</h4> 
<p>这是<code>Chromium</code>项目中一个典型的<code>.gyp</code>文件的骨架：</p> 
<pre><code>{
    'variables': {
      .
      .
      .
    },
    'includes': [
      '../build/common.gypi',
    ],
    'target_defaults': {
      .
      .
      .
    },
    'targets': [
      {
        'target_name': 'target_1',
          .
          .
          .
      },
      {
        'target_name': 'target_2',
          .
          .
          .
      },
    ],
    'conditions': [
      ['OS=="linux"', {
        'targets': [
          {
            'target_name': 'linux_target_3',
              .
              .
              .
          },
        ],
      }],
      ['OS=="win"', {
        'targets': [
          {
            'target_name': 'windows_target_4',
              .
              .
              .
          },
        ],
      }, { # OS != "win"
        'targets': [
          {
            'target_name': 'non_windows_target_5',
              .
              .
              .
          },
      }],
    ],
  }
</code></pre> 
<p>整个文件只包含一个<code>Python</code> 字典。（它实际上是<code>JSON</code>，具有两个<code>Python</code>的小差异：注释用<code>#</code>, 逗号<code>,</code>位于<code>list</code>或是<code>dictionary</code>最后一个元素之后是合法的。 ）</p> 
<p><code>.gyp</code>文件的顶级部分如下:</p> 
<ul><li><code>variables</code>: 可以在文件的其他部分插入和使用的变量的定义。</li><li><code>includes</code>: 将包含在此文件中的其他文件的列表。按照惯例，包含的文件后缀为<code>.gypi</code> (<code>gyp include</code>)。</li><li><code>target_defaults</code>: 适用于这个<code>.gyp</code>文件中定义的所有目标的设置。</li><li><code>targets</code>: 这个<code>.gyp</code>文件可以生成构建的目标列表。每个目标都是一个字典，其中包含描述构建目标所需的所有信息的设置。</li><li><code>conditions</code>: 一个条件规范列表，它可以根据不同变量的值修改<code>.gyp</code>文件定义的全局字典中的项的内容。如上例所示，顶级字典中的条件部分最常见的用法是添加特定平台的目标到目标列表中。</li></ul> 
<h4><a id="gyp_92"></a>.gyp文件中标准的可执行目标</h4> 
<p>最直接的目标可能是一个简单的可执行程序。下面是一个可执行目标示例，它演示了<code>gyp</code>最简单的用法</p> 
<pre><code>  {
    'targets': [
      {
        'target_name': 'foo',
        'type': 'executable',
        'msvs_guid': '5ECEC9E5-8F23-47B6-93E0-C3B328B3BE65',
        'dependencies': [
          'xyzzy',
          '../bar/bar.gyp:bar',
        ],
        'defines': [
          'DEFINE_FOO',
          'DEFINE_A_VALUE=value',
        ],
        'include_dirs': [
          '..',
        ],
        'sources': [
          'file1.cc',
          'file2.cc',
        ],
        'conditions': [
          ['OS=="linux"', {
            'defines': [
              'LINUX_DEFINE',
            ],
            'include_dirs': [
              'include/linux',
            ],
          }],
          ['OS=="win"', {
            'defines': [
              'WINDOWS_SPECIFIC_DEFINE',
            ],
          }, { # OS != "win",
            'defines': [
              'NON_WINDOWS_DEFINE',
            ],
          }]
        ],
      },
    ],
  }
</code></pre> 
<p>目标的顶级设置包括:</p> 
<ul><li><code>target_name</code>: 目标的名称，它应该在所有<code>.gyp</code>文件中是唯一的。这个名称将在生成的<code>Visual Studio</code>解决方案中用作项目名，在生成的<code>XCode</code>配置中用作目标名，并在生成的<code>SCons</code>配置的命令行中用作构建这个目标的别名。</li><li><code>type</code>: 设置为<code>executable</code>，表明可执行。</li><li><code>msvs_guid</code>: <em>这个变量只过渡使用</em>。这是一个硬编码的GUID值，将在生成的<code>Visual Studio</code>解决方案文件中使用。这让我们将<code>gyp</code>生成的项目文件互操作记录到一个<code>chrome.sln</code>文件。一旦<code>Chromium</code>中的所有内容都由<code>gyp</code>生成，那么跨调用保持<code>guid</code>不变就不再重要了，我们可能会去掉这些设置</li><li><code>dependencies</code>: 目标所依赖的其他目标列表。<code>gyp</code>生成的文件将确保在此目标之前构建其他目标。依赖项列表中的任何库目标都将与此目标链接。在目标的<code>direct_dependent_settings</code>部分中列出的各种设置(<code>definition</code>, <code>include_dirs</code>等)将应用于如何构建和链接该目标。请参阅下面关于<code>direct_dependent_settings</code>的更完整的讨论。</li><li><code>definitions</code>: 将通过编译命令行传递的<code>C</code>预处理器定义(使用<code>-D</code>或<code>/D</code>选项)。</li><li><code>include_dirs</code>: 包含头文件的目录。它们将通过编译命令行传递(使用<code>-I</code>或<code>/I</code>选项)。</li><li><code>sources</code>: 此目标的源文件。</li><li><code>conditions</code>: 一个条件块，用于更新目标字典中的不同设置。</li></ul> 
<h4><a id="gyp_150"></a>.gyp文件中标准的库目标</h4> 
<p>绝大多数目标是库。下面是一个库目标的例子，其中包括了应该涵盖库的大多数需求的附加特性</p> 
<pre><code>  {
    'targets': [
      {
        'target_name': 'foo',
        'type': '&lt;(library)'
        'msvs_guid': '5ECEC9E5-8F23-47B6-93E0-C3B328B3BE65',
        'dependencies': [
          'xyzzy',
          '../bar/bar.gyp:bar',
        ],
        'defines': [
          'DEFINE_FOO',
          'DEFINE_A_VALUE=value',
        ],
        'include_dirs': [
          '..',
        ],
        'direct_dependent_settings': {
          'defines': [
            'DEFINE_FOO',
            'DEFINE_ADDITIONAL',
          ],
          'linkflags': [
          ],
        },
        'export_dependent_settings': [
          '../bar/bar.gyp:bar',
        ],
        'sources': [
          'file1.cc',
          'file2.cc',
        ],
        'conditions': [
          ['OS=="linux"', {
            'defines': [
              'LINUX_DEFINE',
            ],
            'include_dirs': [
              'include/linux',
            ],
          ],
          ['OS=="win"', {
            'defines': [
              'WINDOWS_SPECIFIC_DEFINE',
            ],
          }, { # OS != "win",
            'defines': [
              'NON_WINDOWS_DEFINE',
            ],
          }]
        ],
    ],
  }
</code></pre> 
<p>库目标中可能的条目与可执行目标中指定的条目基本相同(<code>definition</code>, <code>include_dirs</code>等)。区别包括:</p> 
<ul><li><code>type</code>: 总是应该设置为<code>&lt;(library)</code>，这允许用户在生成构建项目时定义库是静态构建还是共享构建。(至少在<code>Linux上</code>，链接共享库可以节省大量链接时间)如果有必要确定要构建的库的类型，则可以显式地将<code>type</code>设置为<code>static_library</code>或<code>shared_library</code>。</li><li><code>direct_dependent_settings</code>: 这定义了将应用于直接依赖于此目标的其他目标的设置——也就是说，在它们的<code>dependencies</code>设置中列出此目标。这是你列出<code>defines</code>，<code>include_dirs</code>, <code>cflags</code>和<code>linkflags</code>的地方，其他目标编译或链接需要一致地建立这个目标。</li><li><code>export_dependent_settings</code>: 这列出了应该将<code>direct_dependent_settings</code>“传递”给使用(依赖于)此目标的其他目标的目标。<code>TODO</code>:对这个描述进行扩展。</li></ul> 
<h4><a id="_213"></a>使用实例</h4> 
<p>这些用例旨在涵盖开发者使用<code>GYP</code>执行的最长见操作。<br> 请注意，这些示例都不是功能完整的、自包含的示例(否则它们就太长了)。每个示例大多只包含与示例相关的关键字和设置，可能还有一些用于上下文的额外关键字。这样做的目的是为了展示你在做某件事时需要注意的具体细节。[ 注:如果在实际使用中，这些例子在没有上下文的情况下让人感到困惑，请添加必要的内容来澄清。]</p> 
<h5><a id="_217"></a>添加新的源文件</h5> 
<p>添加独立于平台的源文件与添加只在某些受支持平台上构建的源文件有相似之处，但也有些许不同的模式。</p> 
<h6><a id="_220"></a>添加一个在所有平台构建的源文件</h6> 
<p>最简单的情况: 添加一个在所有平台上构建的文件。 只需将文件添加到目标列表中相应字典的源列表中:</p> 
<pre><code>  {
    'targets': [
      {
        'target_name': 'my_target',
        'type': 'executable',
        'sources': [
          '../other/file_1.cc',
          'new_file.cc',
          'subdir/file3.cc',
        ],
      },
    ],
  },
</code></pre> 
<p>文件路径名相对于<code>.gyp</code>文件所在的目录。<br> 保持列表按字母顺序排列(除非有非常、非常、非常好的理由不这样做)。</p> 
<h6><a id="_240"></a>添加特定平台的源文件</h6> 
<p>特定平台的文件名为<code>*_linux.{ext}</code>、 <code>* _mac.{ext}</code> 、<code>* _posix.{ext}</code>或<code>* _win.{ext}</code><br> 要添加一个特定平台的源文件，最简单的方法(假设你要添加一个全新的文件并命名它)是使用以下标准后缀之一:</p> 
<ul><li><code>_linux</code>(例如<code>foo_linux.cc</code>)</li><li><code>_mac</code>(例如<code>foo_mac.cc</code>)</li><li><code>_posix</code>(例如<code>foo_posix.cc</code>)</li><li><code>_win</code>(例如<code>foo_win.cc</code>)</li></ul> 
<p>只需将该文件添加到适当的dict的<code>targets</code>列表下的<code>sources</code>属性中，就像添加任何其他源文件一样。</p> 
<pre><code>  {
    'targets': [
      {
        'target_name': 'foo',
        'type': 'executable',
        'sources': [
          'independent.cc',
          'specific_win.cc',
        ],
      },
    ],
  },
</code></pre> 
<h5><a id="_264"></a>添加可执行文件</h5> 
<h5><a id="_266"></a>为目标添加设置</h5> 
<h5><a id="_267"></a>跨平台编译</h5> 
<h5><a id="_268"></a>添加新的库目标</h5> 
<h5><a id="_269"></a>目标之间依赖</h5> 
<h5><a id="_MAC_OS_X_bundle_270"></a>支持 MAC OS X bundle</h5> 
<h5><a id="_271"></a>移动文件</h5> 
<h5><a id="_273"></a>自定义构建步骤</h5> 
<h5><a id="_274"></a>构建特色</h5>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/05ffefcef65bdad19f3a0a5e4bb7a92d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">switch手柄可以连电脑吗_你想要的手柄：既能连switch又能连PC！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cffecefcbeeff9d69505101681b5b4f7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ORACLE存储过程RECORD数据类型的使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>