<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>关于“Python”的核心知识点整理大全26 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="关于“Python”的核心知识点整理大全26" />
<meta property="og:description" content="目录
10.3.9 决定报告哪些错误
10.4 存储数据
10.4.1 使用 json.dump()和 json.load()
number_writer.py
number_reader.py
10.4.2 保存和读取用户生成的数据
对于用户生成的数据，使用json保存它们大有裨益，因为如果不以某种方式进行存储，等程 序停止运行时用户的信息将丢失。下面来看一个这样的例子：用户首次运行程序时被提示输入自己的名字，这样再次运行程序时就记住他了。 我们先来存储用户的名字： remember_me.py
greet_user.py
remember_me.py
10.4.3 重构
remember_me.py
往期快速传送门👆（在文章最后）：
感谢大家的支持！欢迎订阅收藏！专栏将持续更新！
10.3.9 决定报告哪些错误 在什么情况下该向用户报告错误？在什么情况下又应该在失败时一声不吭呢？如果用户知 道要分析哪些文件，他们可能希望在有文件没有分析时出现一条消息，将其中的原因告诉他们。 如果用户只想看到结果，而并不知道要分析哪些文件，可能就无需在有些文件不存在时告知他们。 向用户显示他不想看到的信息可能会降低程序的可用性。Python的错误处理结构让你能够细致地 控制与用户分享错误信息的程度，要分享多少信息由你决定。 编写得很好且经过详尽测试的代码不容易出现内部错误，如语法或逻辑错误，但只要程序依 赖于外部因素，如用户输入、存在指定的文件、有网络链接，就有可能出现异常。凭借经验可判 断该在程序的什么地方包含异常处理块，以及出现错误时该向用户提供多少相关的信息。
10.4 存储数据 很多程序都要求用户输入某种信息，如让用户存储游戏首选项或提供要可视化的数据。不管 专注的是什么，程序都把用户提供的信息存储在列表和字典等数据结构中。用户关闭程序时，你 几乎总是要保存他们提供的信息；一种简单的方式是使用模块json来存储数据。
模块json让你能够将简单的Python数据结构转储到文件中，并在程序再次运行时加载该文件 中的数据。你还可以使用json在Python程序之间分享数据。更重要的是，JSON数据格式并非Python 专用的，这让你能够将以JSON格式存储的数据与使用其他编程语言的人分享。这是一种轻便格 式，很有用，也易于学习。
注意 JSON（JavaScript Object Notation）格式最初是为JavaScript开发的，但随后成了一种常见 格式，被包括Python在内的众多语言采用。
10.4.1 使用 json.dump()和 json.load() 我们来编写一个存储一组数字的简短程序，再编写一个将这些数字读取到内存中的程序。第 一个程序将使用json.dump()来存储这组数字，而第二个程序将使用json.load()。 函数json.dump()接受两个实参：要存储的数据以及可用于存储数据的文件对象。下面演示了如何使用json.dump()来存储数字列表：
number_writer.py import json numbers = [2, 3, 5, 7, 11, 13] 1 filename = &#39;numbers." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b1b6323074927efeca8de127b0db3d95/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-18T08:05:23+08:00" />
<meta property="article:modified_time" content="2023-12-18T08:05:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">关于“Python”的核心知识点整理大全26</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"></p> 
<p style="text-align:center;"><img alt="" height="234" src="https://images2.imgbox.com/e1/9f/9MmkmIWd_o.png" width="373"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="10.3.9%20%E5%86%B3%E5%AE%9A%E6%8A%A5%E5%91%8A%E5%93%AA%E4%BA%9B%E9%94%99%E8%AF%AF-toc" style="margin-left:40px;"><a href="#10.3.9%20%E5%86%B3%E5%AE%9A%E6%8A%A5%E5%91%8A%E5%93%AA%E4%BA%9B%E9%94%99%E8%AF%AF" rel="nofollow">10.3.9 决定报告哪些错误</a></p> 
<p id="10.4%20%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#10.4%20%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE" rel="nofollow">10.4 存储数据</a></p> 
<p id="10.4.1%20%E4%BD%BF%E7%94%A8%20json.dump()%E5%92%8C%20json.load()-toc" style="margin-left:80px;"><a href="#10.4.1%20%E4%BD%BF%E7%94%A8%20json.dump%28%29%E5%92%8C%20json.load%28%29" rel="nofollow">10.4.1 使用 json.dump()和 json.load()</a></p> 
<p id="number_writer.py-toc" style="margin-left:120px;"><a href="#number_writer.py" rel="nofollow">number_writer.py</a></p> 
<p id="number_reader.py-toc" style="margin-left:120px;"><a href="#number_reader.py" rel="nofollow">number_reader.py</a></p> 
<p id="10.4.2%20%E4%BF%9D%E5%AD%98%E5%92%8C%E8%AF%BB%E5%8F%96%E7%94%A8%E6%88%B7%E7%94%9F%E6%88%90%E7%9A%84%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#10.4.2%20%E4%BF%9D%E5%AD%98%E5%92%8C%E8%AF%BB%E5%8F%96%E7%94%A8%E6%88%B7%E7%94%9F%E6%88%90%E7%9A%84%E6%95%B0%E6%8D%AE" rel="nofollow">10.4.2 保存和读取用户生成的数据</a></p> 
<p id="%E5%AF%B9%E4%BA%8E%E7%94%A8%E6%88%B7%E7%94%9F%E6%88%90%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BD%BF%E7%94%A8json%E4%BF%9D%E5%AD%98%E5%AE%83%E4%BB%AC%E5%A4%A7%E6%9C%89%E8%A3%A8%E7%9B%8A%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%A6%82%E6%9E%9C%E4%B8%8D%E4%BB%A5%E6%9F%90%E7%A7%8D%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%AD%98%E5%82%A8%EF%BC%8C%E7%AD%89%E7%A8%8B%20%E5%BA%8F%E5%81%9C%E6%AD%A2%E8%BF%90%E8%A1%8C%E6%97%B6%E7%94%A8%E6%88%B7%E7%9A%84%E4%BF%A1%E6%81%AF%E5%B0%86%E4%B8%A2%E5%A4%B1%E3%80%82%E4%B8%8B%E9%9D%A2%E6%9D%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E8%BF%99%E6%A0%B7%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9A%E7%94%A8%E6%88%B7%E9%A6%96%E6%AC%A1%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%97%B6%E8%A2%AB%E6%8F%90%E7%A4%BA%E8%BE%93%E5%85%A5%E8%87%AA%E5%B7%B1%E7%9A%84%E5%90%8D%E5%AD%97%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%86%8D%E6%AC%A1%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%97%B6%E5%B0%B1%E8%AE%B0%E4%BD%8F%E4%BB%96%E4%BA%86%E3%80%82%20%E6%88%91%E4%BB%AC%E5%85%88%E6%9D%A5%E5%AD%98%E5%82%A8%E7%94%A8%E6%88%B7%E7%9A%84%E5%90%8D%E5%AD%97%EF%BC%9A%20remember_me.py-toc" style="margin-left:120px;"><a href="#%E5%AF%B9%E4%BA%8E%E7%94%A8%E6%88%B7%E7%94%9F%E6%88%90%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BD%BF%E7%94%A8json%E4%BF%9D%E5%AD%98%E5%AE%83%E4%BB%AC%E5%A4%A7%E6%9C%89%E8%A3%A8%E7%9B%8A%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%A6%82%E6%9E%9C%E4%B8%8D%E4%BB%A5%E6%9F%90%E7%A7%8D%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%AD%98%E5%82%A8%EF%BC%8C%E7%AD%89%E7%A8%8B%20%E5%BA%8F%E5%81%9C%E6%AD%A2%E8%BF%90%E8%A1%8C%E6%97%B6%E7%94%A8%E6%88%B7%E7%9A%84%E4%BF%A1%E6%81%AF%E5%B0%86%E4%B8%A2%E5%A4%B1%E3%80%82%E4%B8%8B%E9%9D%A2%E6%9D%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E8%BF%99%E6%A0%B7%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9A%E7%94%A8%E6%88%B7%E9%A6%96%E6%AC%A1%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%97%B6%E8%A2%AB%E6%8F%90%E7%A4%BA%E8%BE%93%E5%85%A5%E8%87%AA%E5%B7%B1%E7%9A%84%E5%90%8D%E5%AD%97%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%86%8D%E6%AC%A1%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%97%B6%E5%B0%B1%E8%AE%B0%E4%BD%8F%E4%BB%96%E4%BA%86%E3%80%82%20%E6%88%91%E4%BB%AC%E5%85%88%E6%9D%A5%E5%AD%98%E5%82%A8%E7%94%A8%E6%88%B7%E7%9A%84%E5%90%8D%E5%AD%97%EF%BC%9A%20remember_me.py" rel="nofollow">对于用户生成的数据，使用json保存它们大有裨益，因为如果不以某种方式进行存储，等程 序停止运行时用户的信息将丢失。下面来看一个这样的例子：用户首次运行程序时被提示输入自己的名字，这样再次运行程序时就记住他了。 我们先来存储用户的名字： remember_me.py</a></p> 
<p id="greet_user.py-toc" style="margin-left:120px;"><a href="#greet_user.py" rel="nofollow">greet_user.py</a></p> 
<p id="remember_me.py-toc" style="margin-left:120px;"><a href="#remember_me.py" rel="nofollow">remember_me.py</a></p> 
<p id="10.4.3%20%E9%87%8D%E6%9E%84-toc" style="margin-left:80px;"><a href="#10.4.3%20%E9%87%8D%E6%9E%84" rel="nofollow">10.4.3 重构</a></p> 
<p id="remember_me.py-toc" style="margin-left:120px;"><a href="#remember_me.py" rel="nofollow">remember_me.py</a></p> 
<p id="%E5%BE%80%E6%9C%9F%E5%BF%AB%E9%80%9F%E4%BC%A0%E9%80%81%E9%97%A8%F0%9F%91%86%EF%BC%88%E5%9C%A8%E6%96%87%E7%AB%A0%E6%9C%80%E5%90%8E%EF%BC%89%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%BE%80%E6%9C%9F%E5%BF%AB%E9%80%9F%E4%BC%A0%E9%80%81%E9%97%A8%F0%9F%91%86%EF%BC%88%E5%9C%A8%E6%96%87%E7%AB%A0%E6%9C%80%E5%90%8E%EF%BC%89%EF%BC%9A" rel="nofollow">往期快速传送门👆（在文章最后）：</a></p> 
<p id="%E6%84%9F%E8%B0%A2%E5%A4%A7%E5%AE%B6%E7%9A%84%E6%94%AF%E6%8C%81%EF%BC%81%E6%AC%A2%E8%BF%8E%E8%AE%A2%E9%98%85%E6%94%B6%E8%97%8F%EF%BC%81%E4%B8%93%E6%A0%8F%E5%B0%86%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%81-toc" style="margin-left:0px;"><a href="#%E6%84%9F%E8%B0%A2%E5%A4%A7%E5%AE%B6%E7%9A%84%E6%94%AF%E6%8C%81%EF%BC%81%E6%AC%A2%E8%BF%8E%E8%AE%A2%E9%98%85%E6%94%B6%E8%97%8F%EF%BC%81%E4%B8%93%E6%A0%8F%E5%B0%86%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%81" rel="nofollow">感谢大家的支持！欢迎订阅收藏！专栏将持续更新！</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 style="text-align:center;">10.3.9 决定报告哪些错误</h3> 
<blockquote> 
 <p style="text-align:center;">在什么情况下该向用户报告错误？在什么情况下又应该在失败时一声不吭呢？如果用户知 道要分析哪些文件，他们可能希望在有文件没有分析时出现一条消息，将其中的原因告诉他们。 如果用户只想看到结果，而并不知道要分析哪些文件，可能就无需在有些文件不存在时告知他们。 向用户显示他不想看到的信息可能会降低程序的可用性。Python的错误处理结构让你能够细致地 控制与用户分享错误信息的程度，要分享多少信息由你决定。 编写得很好且经过详尽测试的代码不容易出现内部错误，如语法或逻辑错误，但只要程序依 赖于外部因素，如用户输入、存在指定的文件、有网络链接，就有可能出现异常。凭借经验可判 断该在程序的什么地方包含异常处理块，以及出现错误时该向用户提供多少相关的信息。</p> 
</blockquote> 
<h3 id="10.4%20%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE" style="text-align:center;"><strong>10.4 存储数据</strong></h3> 
<blockquote> 
 <p style="text-align:center;">很多程序都要求用户输入某种信息，如让用户存储游戏首选项或提供要可视化的数据。不管 专注的是什么，程序都把用户提供的信息存储在列表和字典等数据结构中。用户关闭程序时，你 几乎总是要保存他们提供的信息；一种简单的方式是使用模块json来存储数据。</p> 
 <p style="text-align:center;">模块json让你能够将简单的Python数据结构转储到文件中，并在程序再次运行时加载该文件 中的数据。你还可以使用json在Python程序之间分享数据。更重要的是，JSON数据格式并非Python 专用的，这让你能够将以JSON格式存储的数据与使用其他编程语言的人分享。这是一种轻便格 式，很有用，也易于学习。</p> 
</blockquote> 
<hr> 
<p style="text-align:center;">注意 JSON（JavaScript Object Notation）格式最初是为JavaScript开发的，但随后成了一种常见 格式，被包括Python在内的众多语言采用。</p> 
<hr> 
<h4 id="10.4.1%20%E4%BD%BF%E7%94%A8%20json.dump()%E5%92%8C%20json.load()" style="text-align:center;">10.4.1 使用 json.dump()和 json.load()</h4> 
<blockquote> 
 <p style="text-align:center;">我们来编写一个存储一组数字的简短程序，再编写一个将这些数字读取到内存中的程序。第 一个程序将使用json.dump()来存储这组数字，而第二个程序将使用json.load()。 函数json.dump()接受两个实参：要存储的数据以及可用于存储数据的文件对象。下面演示了如何使用json.dump()来存储数字列表：</p> 
 <h5 id="number_writer.py" style="text-align:center;">number_writer.py</h5> 
</blockquote> 
<pre><code class="language-python">import json
numbers = [2, 3, 5, 7, 11, 13]
1 filename = 'numbers.json'
2 with open(filename, 'w') as f_obj:
3 json.dump(numbers, f_obj) </code></pre> 
<blockquote> 
 <p style="text-align:center;">我们先导入模块json，再创建一个数字列表。在1处，我们指定了要将该数字列表存储到其 中的文件的名称。通常使用文件扩展名.json来指出文件存储的数据为JSON格式。接下来，我们 以写入模式打开这个文件，让json能够将数据写入其中（见2）。在3处，我们使用函数json.dump() 将数字列表存储到文件numbers.json中。</p> 
 <p style="text-align:center;">这个程序没有输出，但我们可以打开文件numbers.json，看看其内容。数据的存储格式与 Python中一样：</p> 
</blockquote> 
<pre><code class="language-python">[2, 3, 5, 7, 11, 13]</code></pre> 
<blockquote> 
 <p style="text-align:center;">下面再编写一个程序，使用json.load()将这个列表读取到内存中：</p> 
 <h5 id="number_reader.py" style="text-align:center;">number_reader.py</h5> 
</blockquote> 
<pre><code class="language-python">mport json
1 filename = 'numbers.json'
2 with open(filename) as f_obj:
3 numbers = json.load(f_obj)
print(numbers)</code></pre> 
<blockquote> 
 <p style="text-align:center;">在1处，我们确保读取的是前面写入的文件。这次我们以读取方式打开这个文件，因为Python 只需读取这个文件（见2）。在3处，我们使用函数json.load()加载存储在numbers.json中的信息， 并将其存储到变量numbers中。最后，我们打印恢复的数字列表，看看它是否与number_writer.py 中创建的数字列表相同：</p> 
</blockquote> 
<pre><code class="language-python">[2, 3, 5, 7, 11, 13] 
</code></pre> 
<blockquote> 
 <p style="text-align:center;">这是一种在程序之间共享数据的简单方式。</p> 
</blockquote> 
<h4 id="10.4.2%20%E4%BF%9D%E5%AD%98%E5%92%8C%E8%AF%BB%E5%8F%96%E7%94%A8%E6%88%B7%E7%94%9F%E6%88%90%E7%9A%84%E6%95%B0%E6%8D%AE" style="text-align:center;">10.4.2 保存和读取用户生成的数据</h4> 
<blockquote> 
 <h5 id="%E5%AF%B9%E4%BA%8E%E7%94%A8%E6%88%B7%E7%94%9F%E6%88%90%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BD%BF%E7%94%A8json%E4%BF%9D%E5%AD%98%E5%AE%83%E4%BB%AC%E5%A4%A7%E6%9C%89%E8%A3%A8%E7%9B%8A%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%A6%82%E6%9E%9C%E4%B8%8D%E4%BB%A5%E6%9F%90%E7%A7%8D%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%AD%98%E5%82%A8%EF%BC%8C%E7%AD%89%E7%A8%8B%20%E5%BA%8F%E5%81%9C%E6%AD%A2%E8%BF%90%E8%A1%8C%E6%97%B6%E7%94%A8%E6%88%B7%E7%9A%84%E4%BF%A1%E6%81%AF%E5%B0%86%E4%B8%A2%E5%A4%B1%E3%80%82%E4%B8%8B%E9%9D%A2%E6%9D%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E8%BF%99%E6%A0%B7%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9A%E7%94%A8%E6%88%B7%E9%A6%96%E6%AC%A1%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%97%B6%E8%A2%AB%E6%8F%90%E7%A4%BA%E8%BE%93%E5%85%A5%E8%87%AA%E5%B7%B1%E7%9A%84%E5%90%8D%E5%AD%97%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%86%8D%E6%AC%A1%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%97%B6%E5%B0%B1%E8%AE%B0%E4%BD%8F%E4%BB%96%E4%BA%86%E3%80%82%20%E6%88%91%E4%BB%AC%E5%85%88%E6%9D%A5%E5%AD%98%E5%82%A8%E7%94%A8%E6%88%B7%E7%9A%84%E5%90%8D%E5%AD%97%EF%BC%9A%20remember_me.py" style="text-align:center;">对于用户生成的数据，使用json保存它们大有裨益，因为如果不以某种方式进行存储，等程 序停止运行时用户的信息将丢失。下面来看一个这样的例子：用户首次运行程序时被提示输入自己的名字，这样再次运行程序时就记住他了。 我们先来存储用户的名字： remember_me.py</h5> 
</blockquote> 
<pre><code class="language-python">import json
1 username = input("What is your name? ")
filename = 'username.json'
with open(filename, 'w') as f_obj:
2 json.dump(username, f_obj)
3 print("We'll remember you when you come back, " + username + "!")</code></pre> 
<blockquote> 
 <p style="text-align:center;">在1处，我们提示输入用户名，并将其存储在一个变量中。接下来，我们调用json.dump()， 并将用户名和一个文件对象传递给它，从而将用户名存储到文件中（见2）。然后，我们打印一 条消息，指出我们存储了他输入的信息（见3）：</p> 
</blockquote> 
<pre><code class="language-python">What is your name? Eric
We'll remember you when you come back, Eric! </code></pre> 
<blockquote> 
 <p style="text-align:center;">现在再编写一个程序，向其名字被存储的用户发出问候：</p> 
 <h5 id="greet_user.py" style="text-align:center;">greet_user.py</h5> 
</blockquote> 
<pre><code class="language-python">import json
filename = 'username.json'
with open(filename) as f_obj:
1 username = json.load(f_obj)
2 print("Welcome back, " + username + "!")</code></pre> 
<blockquote> 
 <p style="text-align:center;">在1处，我们使用json.load()将存储在username.json中的信息读取到变量username中。恢复 用户名后，我们就可以欢迎用户回来了（见2）：</p> 
</blockquote> 
<pre><code class="language-python">Welcome back, Eric! </code></pre> 
<blockquote> 
 <p style="text-align:center;">我们需要将这两个程序合并到一个程序（remember_me.py）中。这个程序运行时，我们将尝 试从文件username.json中获取用户名，因此我们首先编写一个尝试恢复用户名的try代码块。如 果这个文件不存在，我们就在except代码块中提示用户输入用户名，并将其存储在username.json 中，以便程序再次运行时能够获取它：</p> 
 <h5 id="remember_me.py" style="text-align:center;">remember_me.py</h5> 
</blockquote> 
<pre><code class="language-python">import json
# 如果以前存储了用户名，就加载它
# 否则，就提示用户输入用户名并存储它
filename = 'username.json'
try:
1 with open(filename) as f_obj:
2 username = json.load(f_obj)
3 except FileNotFoundError:
4 username = input("What is your name? ")
5 with open(filename, 'w') as f_obj:
 json.dump(username, f_obj)
 print("We'll remember you when you come back, " + username + "!")
else:
 print("Welcome back, " + username + "!")</code></pre> 
<blockquote> 
 <p style="text-align:center;">这里没有任何新代码，只是将前两个示例的代码合并到了一个程序中。在1处，我们尝试打 开文件username.json。如果这个文件存在，就将其中的用户名读取到内存中（见2），再执行else 代码块，即打印一条欢迎用户回来的消息。用户首次运行这个程序时，文件username.json不存在， 将引发FileNotFoundError异常（见3），因此Python将执行except代码块：提示用户输入其用户名 （见4），再使用json.dump()存储该用户名，并打印一句问候语（见5）。</p> 
 <p style="text-align:center;">无论执行的是except代码块还是else代码块，都将显示用户名和合适的问候语。如果这个程 序是首次运行，输出将如下：</p> 
</blockquote> 
<pre><code class="language-python">What is your name? Eric
We'll remember you when you come back, Eric!</code></pre> 
<blockquote> 
 <p style="text-align:center;">否则，输出将如下：</p> 
</blockquote> 
<pre><code class="language-python">Welcome back, Eric! </code></pre> 
<blockquote> 
 <p style="text-align:center;">这是程序之前至少运行了一次时的输出。</p> 
</blockquote> 
<h4 id="10.4.3%20%E9%87%8D%E6%9E%84" style="text-align:center;">10.4.3 重构</h4> 
<blockquote> 
 <p style="text-align:center;">你经常会遇到这样的情况：代码能够正确地运行，但可做进一步的改进——将代码划分为 一系列完成具体工作的函数。这样的过程被称为重构。重构让代码更清晰、更易于理解、更容 易扩展。 要重构remember_me.py，可将其大部分逻辑放到一个或多个函数中。remember_me.py的重点 是问候用户，因此我们将其所有代码都放到一个名为greet_user()的函数中：</p> 
 <h5 style="text-align:center;">remember_me.py</h5> 
</blockquote> 
<pre><code class="language-python">import json
def greet_user():
1 """问候用户，并指出其名字"""
filename = 'username.json'
try
 with open(filename) as f_obj:
 username = json.load(f_obj)
 except FileNotFoundError:
 username = input("What is your name? ")
 with open(filename, 'w') as f_obj:
 json.dump(username, f_obj)
 print("We'll remember you when you come back, " + username + "!")
 else:
 print("Welcome back, " + username + "!")
greet_user()</code></pre> 
<blockquote> 
 <p style="text-align:center;">考虑到现在使用了一个函数，我们删除了注释，转而使用一个文档字符串来指出程序是做什 么的（见1）。这个程序更清晰些，但函数greet_user()所做的不仅仅是问候用户，还在存储了用 户名时获取它，而在没有存储用户名时提示用户输入一个。</p> 
 <p style="text-align:center;">下面来重构greet_user()，让它不执行这么多任务。为此，我们首先将获取存储的用户名的 代码移到另一个函数中：</p> 
</blockquote> 
<pre><code class="language-python">import json
def get_stored_username():
1 """如果存储了用户名，就获取它"""
filename = 'username.json'
try:
 with open(filename) as f_obj:
 username = json.load(f_obj)
 except FileNotFoundError:
2 return None
 else:
 return username
def greet_user():
 """问候用户，并指出其名字"""
 username = get_stored_username()
3 if username:
 print("Welcome back, " + username + "!")
 else:
 username = input("What is your name? ")
 filename = 'username.json'
 with open(filename, 'w') as f_obj:
 json.dump(username, f_obj)
 print("We'll remember you when you come back, " + username + "!")
greet_user()</code></pre> 
<blockquote> 
 <p style="text-align:center;">新增的函数get_stored_username()目标明确，1处的文档字符串指出了这一点。如果存储了 用户名，这个函数就获取并返回它；如果文件username.json不存在，这个函数就返回None（见2）。 这是一种不错的做法：函数要么返回预期的值，要么返回None；这让我们能够使用函数的返回值 做简单测试。在3处，如果成功地获取了用户名，就打印一条欢迎用户回来的消息，否则就提示用户输入用户名。 我们还需将greet_user()中的另一个代码块提取出来：将没有存储用户名时提示用户输入的 代码放在一个独立的函数中：</p> 
</blockquote> 
<pre><code class="language-python">import json
def get_stored_username():
 """如果存储了用户名，就获取它"""
 --snip--
def get_new_username():
 """提示用户输入用户名"""
 username = input("What is your name? ")
 filename = 'username.json'
 with open(filename, 'w') as f_obj:
 json.dump(username, f_obj)
 return username
def greet_user():
 """问候用户，并指出其名字"""
 username = get_stored_username()
 if username:
 print("Welcome back, " + username + "!")
 else:
 username = get_new_username()
 print("We'll remember you when you come back, " + username + "!")
greet_user()</code></pre> 
<blockquote> 
 <p style="text-align:center;">在remember_me.py的这个最终版本中，每个函数都执行单一而清晰的任务。我们调用 greet_user()，它打印一条合适的消息：要么欢迎老用户回来，要么问候新用户。为此，它首先 调用get_stored_username()，这个函数只负责获取存储的用户名（如果存储了的话），再在必要 时调用get_new_username()，这个函数只负责获取并存储新用户的用户名。要编写出清晰而易于 维护和扩展的代码，这种划分工作必不可少。</p> 
</blockquote> 
<hr> 
<p style="text-align:center;"><a href="https://blog.csdn.net/lzy302810/article/details/135043856?spm=1001.2014.3001.5501" title="关于“Python”的核心知识点整理大全25-CSDN博客">关于“Python”的核心知识点整理大全25-CSDN博客</a></p> 
<p style="text-align:center;"><a href="https://blog.csdn.net/lzy302810/article/details/134917938?spm=1001.2014.3001.5502" title="关于“Python”的核心知识点整理大全12-CSDN博客">关于“Python”的核心知识点整理大全12-CSDN博客</a></p> 
<h2 id="%E5%BE%80%E6%9C%9F%E5%BF%AB%E9%80%9F%E4%BC%A0%E9%80%81%E9%97%A8%F0%9F%91%86%EF%BC%88%E5%9C%A8%E6%96%87%E7%AB%A0%E6%9C%80%E5%90%8E%EF%BC%89%EF%BC%9A" style="text-align:center;">往期快速传送门👆（在文章最后）：</h2> 
<h2 id="%E6%84%9F%E8%B0%A2%E5%A4%A7%E5%AE%B6%E7%9A%84%E6%94%AF%E6%8C%81%EF%BC%81%E6%AC%A2%E8%BF%8E%E8%AE%A2%E9%98%85%E6%94%B6%E8%97%8F%EF%BC%81%E4%B8%93%E6%A0%8F%E5%B0%86%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%81" style="text-align:center;"><a name="t8"></a><a name="t10"></a><a name="t13"></a><a name="t11"></a>感谢大家的支持！欢迎订阅收藏！专栏将持续更新！</h2>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3aa3f106a4310494dd2ac1ddafc3a244/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Dart设计模式之单例模式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3e6b3c8bb89dc9742a45ef3e93d007c7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2023 年最后一波工具安利「GitHub 热点速览」</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>