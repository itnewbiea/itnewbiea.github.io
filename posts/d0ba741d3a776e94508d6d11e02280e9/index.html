<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>三种方法构建Java树形结构 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="三种方法构建Java树形结构" />
<meta property="og:description" content="平时大概率我们会构建一些树形结果返回给前端，比如菜单结构、部门列表、文件结构等，我们一般想到的就是利用递归来循环构建；现在，就我个人解决的方法如下：
原始递归利用Java 8 Stream流进行处理（原理还是递归）Stream流升级构建 场景构建 public class TreeSelect implements Serializable { /** 节点ID */ private Long id; /** 节点名称 */ private String label; /** 父ID */ private Long parentId; /** 子节点 */ private List&lt;TreeSelect&gt; children; public TreeSelect() { } public TreeSelect(Long id, String label, Long parentId) { this.id = id; this.label = label; this.parentId = parentId; } public TreeSelect(TreeSelect treeSelect) { this.id = treeSelect.getId(); this.label = treeSelect.getLabel(); this.children = treeSelect." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d0ba741d3a776e94508d6d11e02280e9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-30T18:53:55+08:00" />
<meta property="article:modified_time" content="2022-07-30T18:53:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">三种方法构建Java树形结构</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>平时大概率我们会构建一些树形结果返回给前端，比如菜单结构、部门列表、文件结构等，我们一般想到的就是利用递归来循环构建；现在，就我个人解决的方法如下：</p> 
 <ul><li>原始递归</li><li>利用Java 8 Stream流进行处理（原理还是递归）</li><li>Stream流升级构建</li></ul> 
</blockquote> 
<p>场景构建 </p> 
<pre><code>public class TreeSelect implements Serializable
{

    /** 节点ID */
    private Long id;

    /** 节点名称 */
    private String label;
    
    /** 父ID */
    private Long parentId;

    /** 子节点 */
    private List&lt;TreeSelect&gt; children;

    public TreeSelect()
    {

    }

    public TreeSelect(Long id, String label, Long parentId) {
        this.id = id;
        this.label = label;
        this.parentId = parentId;
    }

    public TreeSelect(TreeSelect treeSelect)
    {
        this.id = treeSelect.getId();
        this.label = treeSelect.getLabel();
        this.children = treeSelect.getChildren();
    }

    public Long getId()
    {
        return id;
    }

    public void setId(Long id)
    {
        this.id = id;
    }

    public String getLabel()
    {
        return label;
    }

    public void setLabel(String label)
    {
        this.label = label;
    }

    public List&lt;TreeSelect&gt; getChildren()
    {
        return children;
    }

    public void setChildren(List&lt;TreeSelect&gt; children)
    {
        this.children = children;
    }
}
</code></pre> 
<h4>1、原始递归构建树</h4> 
<pre><code>    /**
     * 构建前端所需要树结构
     *
     * @param trees 列表
     * @return 树结构列表
     */
    public static List&lt;TreeSelect&gt; buildDeptTree(List&lt;TreeSelect&gt; trees)
    {
        List&lt;TreeSelect&gt; returnList = new ArrayList&lt;TreeSelect&gt;();
        List&lt;Long&gt; tempList = new ArrayList&lt;Long&gt;();
        for (TreeSelect dept : trees)
        {
            tempList.add(dept.getId());
        }
        for (Iterator&lt;TreeSelect&gt; iterator = trees.iterator(); iterator.hasNext();)
        {
            TreeSelect treeSelect = (TreeSelect) iterator.next();
            // 如果是顶级节点, 遍历该父节点的所有子节点
            if (!tempList.contains(treeSelect.getParentId()))
            {
                recursionFn(trees, treeSelect);
                returnList.add(treeSelect);
            }
        }
        if (returnList.isEmpty())
        {
            returnList = trees;
        }
        return returnList;
    }
    /**
     * 递归列表
     */
    private static void recursionFn(List&lt;TreeSelect&gt; list, TreeSelect t)
    {
        // 得到子节点列表
        List&lt;TreeSelect&gt; childList = getChildList(list, t);
        t.setChildren(childList);
        for (TreeSelect tChild : childList)
        {
            if (hasChild(list, tChild))
            {
                recursionFn(list, tChild);
            }
        }
    }

    /**
     * 得到子节点列表
     */
    private static List&lt;TreeSelect&gt; getChildList(List&lt;TreeSelect&gt; list, TreeSelect t)
    {
        List&lt;TreeSelect&gt; tlist = new ArrayList&lt;TreeSelect&gt;();
        for (TreeSelect n : list) {
            if (StringUtils.isNotNull(n.getParentId()) &amp;&amp; n.getParentId().longValue() == t.getId().longValue()) {
                tlist.add(n);
            }
        }
        return tlist;
    }

    /**
     * 判断是否有子节点
     */
    private static boolean hasChild(List&lt;TreeSelect&gt; list, TreeSelect t)
    {
        return getChildList(list, t).size() &gt; 0;
    }
</code></pre> 
<h4>2、利用Java 8 <a href="https://so.csdn.net/so/search?q=Stream&amp;spm=1001.2101.3001.7020" title="Stream">Stream</a>流进行处理（原理还是递归）</h4> 
<pre><code>   public static List&lt;TreeSelect&gt; buildDeptTreeByStream(List&lt;TreeSelect&gt; trees){
        //获取parentId = 0的根节点
        List&lt;TreeSelect&gt; list = trees.stream().filter(item -&gt; item.getParentId() == 0L).collect(Collectors.toList());
        //根据parentId进行分组
        Map&lt;Long, List&lt;TreeSelect&gt;&gt; map = trees.stream().collect(Collectors.groupingBy(TreeSelect::getParentId));
        recursionFnTree(list, map);
        return list;
    }

    /**
     * 递归遍历节点
     * @param list
     * @param map
     */
    public static void recursionFnTree(List&lt;TreeSelect&gt; list, Map&lt;Long, List&lt;TreeSelect&gt;&gt; map){
        for (TreeSelect treeSelect : list) {
            List&lt;TreeSelect&gt; childList = map.get(treeSelect.getId());
            treeSelect.setChildren(childList);
            if (null != childList &amp;&amp; 0 &lt; childList.size()){
                recursionFnTree(childList,map);
            }
        }
    }
</code></pre> 
<h4>3、Stream流升级构建</h4> 
<pre><code>//获取父节点
List&lt;TreeSelect&gt; collect = trees.stream().filter(m -&gt; m.getParentId() == 0).map(
    (m) -&gt; {
        m.setChildren(getChildrenList(m, trees));
        return m;
    }
).collect(Collectors.toList());

    /**
     * 获取子节点列表
     * @param tree
     * @param list
     * @return
     */
    public static List&lt;TreeSelect&gt; getChildrenList(TreeSelect tree, List&lt;TreeSelect&gt; list){
        List&lt;TreeSelect&gt; children = list.stream().filter(item -&gt; Objects.equals(item.getParentId(), tree.getId())).map(
                (item) -&gt; {
                    item.setChildren(getChildrenList(item, list));
                    return item;
                }
        ).collect(Collectors.toList());
        return children;
    }
</code></pre> 
<p>PS：个人还是比较倾向用<code>Stream</code>流构建<a href="https://so.csdn.net/so/search?q=%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84&amp;spm=1001.2101.3001.7020" title="树形结构">树形结构</a>，节省代码量还通俗易懂！！！<code>Stream</code>在实际开发过程中，运用得体的话，既能节省代码量，还能提高效率，但是复杂的流式处理数据也会让代码看起来不易理解！</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bb5abba5df0d3fca0cc59589e5ee11d2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[MATLAB]matlab自定义母线画旋转面</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/019ed30e7da10742f462a1a5dc790f58/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">将二维tensor矩阵中不为0元素转换为一维向量</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>