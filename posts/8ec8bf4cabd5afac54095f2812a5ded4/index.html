<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>面试官：说说你对装饰者模式的理解？应用场景？ - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="面试官：说说你对装饰者模式的理解？应用场景？" />
<meta property="og:description" content="一、是什么 装饰者模式（Decorator Pattern）就是动态的给类或对象增加职责的设计模式。它能在不改变类或对象自身的基础上，在程序的运行期间动态的添加职责，跟继承相比，装饰者是一种更轻便灵活的做法
这种设计模式非常符合敏捷开发的设计思想：先提炼出产品的最小可用产品，再通过快速迭代的方式添加功能
在生活中，同一张图片，组合不同的滤镜就会有不同的体验
这里实际上就应用了装饰者模式：是通过滤镜装饰了照片。在不改变对象（照片）的情况下动态的为其添加功能（滤镜）
二、使用 在es6上，增添了类的装饰器，用来注释或修改类和类方法，使用类的装饰器实际上就应用了装饰者模式（关于类装饰器的使用这里不再陈述）如下：
在JavaScript 中可以很方便地给某个对象扩展属性和方法，但却很难在不改动某个函数源代码的情况下，给该函数添加一些额外的功能
要想为函数添加一些功能，最简单粗暴的方式就是直接改写该函数，但这是最差的办法，直接违反了开放-封闭原则，如下：
var a = function () { alert(1); } // 改成 var a = function () { alert(1); alert(2); } 实际开发中，比如我们想给 window 绑定 onload 事件，但是又不确定这个事件是不是已经被其他人绑定过，为了避免覆盖掉之前的 window.onload 函数中的行为，我们一般都会先保存好原先的 window.onload，把它放入新的 window.onload 里执行
window.onload = function () { alert(1); } var _onload = window.onload || function () { }; window.onload = function () { _onload(); alert(2); } 同样，我们还可以使用AOP 面向切面编程来装饰函数
什么是面向切面编程？举个例子，餐前洗手、饭后漱口，吃饭这个动作相当于切点，我们可以在这个切点前、后插入其它如洗手等动作
下面则使用AOP来修饰onLoad：
首先定义Function.prototype.before 方法和 Function." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8ec8bf4cabd5afac54095f2812a5ded4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-16T08:31:00+08:00" />
<meta property="article:modified_time" content="2021-11-16T08:31:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">面试官：说说你对装饰者模式的理解？应用场景？</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align:left;"><img src="https://images2.imgbox.com/c2/3b/0VLiXsse_o.png" alt="3970141a9a3ab673fbff90e02fb0a154.png"></p> 
 <h3>一、是什么</h3> 
 <p>装饰者模式（Decorator Pattern）就是动态的给类或对象增加职责的设计模式。它能在不改变类或对象自身的基础上，在程序的运行期间动态的添加职责，跟继承相比，装饰者是一种更轻便灵活的做法</p> 
 <p>这种设计模式非常符合敏捷开发的设计思想：先提炼出产品的最小可用产品，再通过快速迭代的方式添加功能</p> 
 <p>在生活中，同一张图片，组合不同的滤镜就会有不同的体验</p> 
 <p>这里实际上就应用了装饰者模式：是通过滤镜装饰了照片。在不改变对象（照片）的情况下动态的为其添加功能（滤镜）</p> 
 <h3>二、使用</h3> 
 <p>在<code>es6</code>上，增添了类的装饰器，用来注释或修改类和类方法，使用类的装饰器实际上就应用了装饰者模式（关于类装饰器的使用这里不再陈述）如下：</p> 
 <img src="https://images2.imgbox.com/56/9e/5smj4KF0_o.png" alt="f92fc9c4e45c4edce85b18c896787a39.png"> 
 <p>在<code>JavaScript</code> 中可以很方便地给某个对象扩展属性和方法，但却很难在不改动某个函数源代码的情况下，给该函数添加一些额外的功能</p> 
 <p>要想为函数添加一些功能，最简单粗暴的方式就是直接改写该函数，但这是最差的办法，直接违反了开放-封闭原则，如下：</p> 
 <pre class="has"><code class="language-go">var a = function () {
  alert(1);
}
// 改成
var a = function () {
  alert(1);
  alert(2);
}</code></pre> 
 <p>实际开发中，比如我们想给 <code>window</code> 绑定 <code>onload</code> 事件，但是又不确定这个事件是不是已经被其他人绑定过，为了避免覆盖掉之前的 <code>window.onload</code> 函数中的行为，我们一般都会先保存好原先的 <code>window.onload</code>，把它放入新的 <code>window.onload</code> 里执行</p> 
 <pre class="has"><code class="language-go">window.onload = function () {
  alert(1);
}
var _onload = window.onload || function () { };
window.onload = function () {
  _onload();
  alert(2);
}</code></pre> 
 <p>同样，我们还可以使用<code>AOP</code> 面向切面编程来装饰函数</p> 
 <p>什么是面向切面编程？举个例子，餐前洗手、饭后漱口，吃饭这个动作相当于切点，我们可以在这个切点前、后插入其它如洗手等动作</p> 
 <p>下面则使用<code>AOP</code>来修饰<code>onLoad</code>：</p> 
 <p>首先定义<code>Function.prototype.before</code> 方法和 <code>Function.prototype.after</code> 方法，如下：</p> 
 <pre class="has"><code class="language-go">Function.prototype.before = function (beforefn) {
  var __self = this; // 保存原函数的引用
  return function () { // 返回包含了原函数和新函数的"代理"函数
    beforefn.apply(this, arguments); // 执行新函数，且保证 this 不被劫持，新函数接受的参数也会被原封不动地传入原函数，新函数在原函数之前执行
    return __self.apply(this, arguments); // 执行原函数并返回原函数的执行结果，并且保证 this 不被劫持
  }
}
Function.prototype.after = function (afterfn) {
  var __self = this;
  return function () {
    var ret = __self.apply(this, arguments);
    afterfn.apply(this, arguments);
    return ret;
  }
};</code></pre> 
 <p><code>Function.prototype.before</code> 接受一个函数当作参数，这个函数即为新添加的函数，它装载了新添加的功能代码</p> 
 <p>它的工作是把请求分别转发给新添加的函数和原函数，且负责保证它们的执行顺序，让新添加的函数在原函数之前执行(前置装饰)，这样就实现了动态装饰的效果。通过 <code>Function.prototype.apply</code> 来动态传入正确的 <code>this</code>，保证了函数在被装饰之后，<code>this</code> 不会被劫持</p> 
 <p><code>Function.prototype.after</code> 的原理跟 <code>Function.prototype.before</code> 一模一样，唯一不同的地方在于让新添加的函数在原函数执行之后再执行</p> 
 <p>修改后代码如下：</p> 
 <pre class="has"><code class="language-go">window.onload = function () {
  alert(1);
}
window.onload = (window.onload || function () { }).after(function () {
  alert(2);
}).after(function () {
  alert(3);
}).after(function () {
  alert(4);
});</code></pre> 
 <h3>三、总结</h3> 
 <h5>应用场景：</h5> 
 <p>适合对已拥有必备组件的对象进行扩展高阶组件或属性</p> 
 <h5>优点：</h5> 
 <ul><li><p>无需修改现有对象，也无需创建对象的子类，即可扩展对象的功能。</p></li><li><p>可以多扩展功能进行动态添加或删除</p></li><li><p>可以扩展不同的装饰者来解决扩展不同功能的问题</p></li></ul> 
 <h3>参考文献</h3> 
 <ul><li><p>https://juejin.cn/post/6844903873262387208</p></li><li><p>https://juejin.cn/post/6999826902642851854</p></li><li><p>https://juejin.cn/post/6844904100144889864</p></li></ul> 
 <p style="text-align:center;">--The End--</p> 
 <p style="text-align:center;">系列正在更新：13/14</p> 
 <p style="text-align:center;">点击下方卡片解锁更多</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/0e/8c/48yHoekU_o.png" alt="6b492fcbba0d381382f93b781d13578f.png"></p> 
 <p style="text-align:center;">创作不易，星标、点赞、在看 三连支持</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a06d5fe38f120430eecfe47c25059669/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Swin Transformer对CNN的降维打击</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3645f2c06898e24e7820d5ca207a8e28/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言程序设计（第4版）苏小红 课后程序参考6.9</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>