<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python接口自动化脚本业务框架总概（一） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python接口自动化脚本业务框架总概（一）" />
<meta property="og:description" content="目录
接口自动化框架目录
基础类封装概览
基础类封装方法详解
Log.py文件
Request.py文件
Python是目前主流的接口自动化脚本语言之一。
本专栏将联系业务介绍使用python接口自动化脚本范例。
适合对象：已有一定python基础，对自动化感兴趣的小伙伴。
接口自动化框架目录 目录说明：
在Project目录下新建你的项目，里面再次拆分出本项目的相关配置公共模块、接口层、用例层。
公共模块功能：存放配置、封装公共调用方法
接口层功能：封装调用接口
用例层功能：调用封装的接口，传入不同参数校验、场景模式校验，设置断言
基础类封装概览 将公共的模块封装为基础类，比如发送请求的request、log日志封装等等。
这些模块是每个业务线或者接口都需要使用到的，故将其放在Common下面进行编写封装。
基础类封装方法详解 Log.py文件 目的：用例执行过程中打印日志，定位问题。
小tips：
导入模块，如果有标红显示，说明你的lib下面没有这个第三方的资源了，可以在Terminal下面使用命令直接下载 pip install colorama
下面为封装Log日志的方法：
# -*- coding: utf-8 -*- &#34;&#34;&#34; 封装log方法 &#34;&#34;&#34; import logging import os import time import stat import datetime from hashlib import md5 from colorama import Fore, Style TRACE_ID_LIST = [] LEVELS = { &#39;debug&#39;: logging.DEBUG, &#39;info&#39;: logging.INFO, &#39;warning&#39;: logging.WARNING, &#39;error&#39;: logging.ERROR, &#39;critical&#39;: logging." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/780b53fb513fd50a7e29c76daef79cc8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-18T17:39:24+08:00" />
<meta property="article:modified_time" content="2023-03-18T17:39:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python接口自动化脚本业务框架总概（一）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p style="margin-left:0px;"><a href="#%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E7%9B%AE%E5%BD%95" rel="nofollow">接口自动化框架目录</a></p> 
<p style="margin-left:0px;"><a href="#%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%B0%81%E8%A3%85" rel="nofollow">基础类封装概览</a></p> 
<p style="margin-left:0px;"><a href="#%C2%A0%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%B0%81%E8%A3%85%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3" rel="nofollow"> 基础类封装方法详解</a></p> 
<p style="margin-left:40px;"><a href="#Log.py%E6%96%87%E4%BB%B6" rel="nofollow">Log.py文件</a></p> 
<p style="margin-left:40px;"><a href="#Request.py%E6%96%87%E4%BB%B6" rel="nofollow">Request.py文件</a></p> 
<hr> 
<p> </p> 
<p>Python是目前主流的接口自动化脚本语言之一。</p> 
<p>本专栏将联系业务介绍使用python接口自动化脚本范例。</p> 
<p>适合对象：已有一定python基础，对自动化感兴趣的小伙伴。</p> 
<p> </p> 
<h2>接口自动化框架目录</h2> 
<p><img src="https://images2.imgbox.com/9f/a6/4jd0fyIx_o.png" alt="b5bf9bf404fa44419656fdff64b5ad7a.png"></p> 
<p> </p> 
<p>目录说明：</p> 
<p><img src="https://images2.imgbox.com/de/39/f9t93Blw_o.png" alt="1ba0b01d766c48d096cc7f4e9c926767.png"></p> 
<p> </p> 
<p>在Project目录下新建你的项目，里面再次拆分出本项目的相关配置<strong>公共模块、接口层、用例层。</strong></p> 
<p>公共模块功能：存放配置、封装公共调用方法</p> 
<p>接口层功能：封装调用接口</p> 
<p>用例层功能：调用封装的接口，传入不同参数校验、场景模式校验，设置断言</p> 
<p> </p> 
<h2>基础类封装概览</h2> 
<p> </p> 
<p>将公共的模块封装为基础类，比如发送请求的request、log日志封装等等。</p> 
<p>这些模块是每个业务线或者接口都需要使用到的，故将其放在Common下面进行编写封装。</p> 
<p><img src="https://images2.imgbox.com/eb/8c/349z9ILa_o.png" alt="436cbd96fa22466999092cae09cce42a.png"></p> 
<h2>基础类封装方法详解</h2> 
<h3>Log.py文件</h3> 
<p>目的：用例执行过程中打印日志，定位问题。</p> 
<p>小tips：</p> 
<p>导入模块，如果有标红显示，说明你的lib下面没有这个第三方的资源了，可以在Terminal下面使用命令直接下载 pip install colorama</p> 
<p><img src="https://images2.imgbox.com/25/06/YEoQcabp_o.png" alt="afd79e86f0fa480da653c3c4ba9c9616.png"></p> 
<p><img src="https://images2.imgbox.com/68/cf/qc4nDivH_o.png" alt="9721c6af980e4ae58114a657340fd025.png"></p> 
<p>下面为封装Log日志的方法：</p> 
<pre><code class="language-python"># -*- coding: utf-8 -*-

"""
封装log方法

"""

import logging
import os
import time
import stat
import datetime
from hashlib import md5
from colorama import Fore, Style


TRACE_ID_LIST = []
LEVELS = {
    'debug': logging.DEBUG,
    'info': logging.INFO,
    'warning': logging.WARNING,
    'error': logging.ERROR,
    'critical': logging.CRITICAL
}

logger = logging.getLogger()
level = 'default'


def set_file_permission(filename):
    # 设置日志目录文件及权限
    path = filename[0:filename.rfind('/')]
    if not os.path.isdir(path):
        os.makedirs(path)
    if not os.path.isfile(filename):
        return None
    try:
        # 赋予文件777的权限,防止不同用户访问时报错
        os.chmod(filename, stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)
        return True
    except Exception as e:
        print('设置日志文件权限错误，error：{}'.format(e))
        return False


def set_handler(levels):
    # 日志文件内写入内容
    if levels == 'error':
        set_file_permission(MyLog.err_file)
        logger.addHandler(MyLog.err_handler)
    set_file_permission(MyLog.log_file)
    logger.addHandler(MyLog.handler)


def remove_handler(levels):
    if levels == 'error':
        logger.removeHandler(MyLog.err_handler)
    logger.removeHandler(MyLog.handler)


def get_current_time():
    return datetime.datetime.now().strftime(MyLog.date)


class MyLog:
    backup_count = 5
    path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    local_time = time.strftime('%Y-%m-%d', time.localtime(time.time()))
    log_file = path + '/Log/info.log'
    err_file = path + '/Log/error.log'
    logger.setLevel(LEVELS.get(level, logging.NOTSET))

    date = '%Y-%m-%d %H:%M:%S.%f'

    from logging.handlers import TimedRotatingFileHandler
    #分割日志记录
    handler = TimedRotatingFileHandler(filename=log_file, when="MIDNIGHT", interval=1, backupCount=backup_count,
                                       encoding='utf-8')
    err_handler = TimedRotatingFileHandler(filename=err_file, when="MIDNIGHT", interval=1, backupCount=backup_count,
                                           encoding='utf-8')

    @staticmethod
    def debug(log_meg):
        set_handler('debug')
        logger.debug("[DEBUG " + get_current_time() + "]" + str(log_meg))
        print(Fore.LIGHTGREEN_EX + "[DEBUG]" + str(log_meg) + Style.RESET_ALL)
        remove_handler('debug')

    @staticmethod
    def info(log_meg):
        set_handler('info')
        logger.info("[INFO " + get_current_time() + "]" + str(log_meg))
        print("[INFO]" + str(log_meg))
        remove_handler('info')

    @staticmethod
    def warning(log_meg):
        set_handler('warning')
        logger.warning("[WARNING " + get_current_time() + "]" + str(log_meg))
        print(Fore.LIGHTYELLOW_EX + "[WARNING]" + str(log_meg) + Style.RESET_ALL)
        remove_handler('warning')

    @staticmethod
    def error(log_meg):
        try:
            raise RuntimeError
        except RuntimeError:
            import sys
            f = sys.exc_info()[2].tb_frame.f_back
        datas = 'The error source: ' + f.f_code.co_filename + ' ' + f.f_code.co_name + ' ' + str(f.f_lineno)
        set_handler('error')
        logger.error("[ERROR " + get_current_time() + "]" + str(log_meg), exc_info=True)
        logger.error(datas)
        print(Fore.LIGHTRED_EX + "[ERROR]" + str(log_meg) + Style.RESET_ALL)
        print(datas)
        remove_handler('error')

    @staticmethod
    def critical(log_meg):
        set_handler('critical')
        logger.critical("[CRITICAL " + get_current_time() + "]" + str(log_meg))
        print(Fore.RED + "[CRITICAL]" + str(log_meg) + Style.RESET_ALL)
        remove_handler('critical')

</code></pre> 
<h3>Request.py文件</h3> 
<pre><code class="language-python"># -*- coding: utf-8 -*-
"""
封装request
"""
import requests
from retry import retry
from requests.adapters import HTTPAdapter
from Common.Log import MyLog
import urllib3
import json

class Request:

    def __init__(self):
        self.log = MyLog

    @retry((Exception, requests.RequestException), tries=3, delay=1, backoff=2, max_delay=4)
    def base_request(self, url, data=None, header=None, method=None, time_out=None, body_json=None, params=None):
        """
        客户端请求基础方法
        :param url: 完整的请求url，包括url和path
        :param data: 请求的数据
        :param header: 请求头
        :param method 请求方式，支持POST和GET方式请求
        :param time_out 请求超时时间
        :param body_json : 以json进行传参
        :param params: GET请求的时直接传参
        :return:
        """
        header = {} if header is None else header
        method = 'POST' if method is None else method
        time_out = 60 if time_out is None else time_out

        # 定义user_agent
        user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36'
        user_agent_header = {'User-Agent': user_agent}
        if header.get('User-Agent') is None:
            header.update(user_agent_header)
        if header.get('Content-Type') is None and type(data) is str:
            header.update({'Content-Type': 'application/json;charset=utf-8'})
        # 将请求body字典转化为json格式，并去除其中的空格
        if (type(data) is dict or type(data) is list) and 'application/json' in str(header.get('Content-Type')):
            data = json.dumps(data, separators=(',', ':'))
        self.log.info('请求的url: %s' % str(url))
        if data:
            self.log.info('请求的data: %s' % str(data))
        if params:
            self.log.info(f'请求的params: {params}')
        if body_json:
            self.log.info(f'请求的body_json: {body_json}')
        self.log.info('请求的header: %s' % str(header))
        self.log.info('请求的method: %s' % str(method))

        # 关闭警告
        urllib3.disable_warnings()
        # 增加失败重试
        session = requests.Session()
        session.mount('http://', HTTPAdapter(max_retries=1))
        session.mount('https://', HTTPAdapter(max_retries=1))

        try:
            res = session.request(method=method, url=url, params=params, data=data, json=body_json, headers=header, timeout=time_out, verify=False, proxies=None, stream=False)
        except requests.RequestException as e:
            self.log.info('%s%s' % ('RequestException url: ', url))
            self.log.info(e)
            raise RuntimeError(e)
        except Exception as e:
            self.log.info('%s%s' % ('Exception url: ', url))
            self.log.info(e)
            raise RuntimeError(e)

        # time_consuming为响应时间，单位为毫秒
        time_consuming = res.elapsed.microseconds / 1000
        # time_total为响应时间，单位为秒
        time_total = res.elapsed.total_seconds()
        response_dicts = dict()
        response_dicts['code'] = res.status_code
        try:
            response_dicts['body'] = res.json()
        except Exception as e:
            self.log.info('解析响应json异常：{}'.format(e))
            response_dicts['body'] = ''
            self.log.info('响应text:{}'.format(res.text))

        response_dicts['time_consuming'] = time_consuming
        response_dicts['time_total'] = time_total
        response_dicts['text'] = res.text
        response_dicts['headers'] = res.headers
        response_dicts['cookies'] = dict(res.cookies)
        self.log.info('响应码：%s' % response_dicts['code'])
        self.log.info('响应体：%s' % response_dicts['body'])
        self.log.info('请求总耗时：%s' % response_dicts['time_total'])
        return response_dicts</code></pre> 
<p><strong>如果写的不错，来个三连行～～～</strong></p> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9b26938b416aea39da5c3a9a8e53b1ed/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">STM32G070 使用 OpenBLT 记录。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/678923b7927622ec42a5c92ccc1bf98d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算imbalanced dataset的class weight</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>