<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>将png/jpg图像数据集转四维tensor输入PyTorch - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="将png/jpg图像数据集转四维tensor输入PyTorch" />
<meta property="og:description" content="如果拥有了自己的数据集，首先需要考虑的就是将你的数据集输入到PyTorch当中去。如果你的数据是来自于网络（比如说，从Kaggle下载，从论文作者处获得，从某个数据集官方的网站进行下载）， 那你遇见的原始数据格式可能是各种情况，最常见的是各类压缩文件、pt文件、数据库格式文件或者png/jpg/webp等原始图像。如果你的数据是来自于实验室、公司数据库、甚至是领导/导师给的数据， 那你的数据大概率都是csv/txt/mat等结构的二维数据表。无论我们的原始数据集是呈现什么样的格式，我们必须将其转换为四维的张量，数据才可以被卷积神经网络处理。对于任意压缩文件，先解压查看内部是什么内容。
这里详细说明从图像png/jpg到四维tensor 当你拥有的数据是一系列图像，并且每个标签对应的图像是存放在单独的文件夹中时，这种情况比较简单。在torchvision中存在直接将文件夹中的图片打包成tensor类的类ImageFolder,它的参数和torchvision.datasets中其他数据导入类的参数非常相似，其中root是你的原始图像所在的根目录，transform是你希望对图像执行的具体操作。
这个类可以接受.jpg、.jpeg、.png、.ppm、.bmp、.pgm、.tif、.tiff、.webp这9种不同的图片格式作为输入，并且还能够通过文件夹的分类自动识别标签。在你的根目录下，每个类别需要有一个单独的文件夹，而类别文件夹中可以存在多个子文件夹，或直接存放图片。图片的格式不需要统一，只要在ImageFolder可接受的9中格式中即可。
train_dataset有几种可以调用的属性，例如：
train_dataset..classes #查看类别
train_dataset.targets #查看标签
train_dataset.imgs #查看具体的图像地址，返回所有图像的具体地址以及对应的标签
例如下面的例子：
ImageFolder只能够读取根目录的子文件夹中的图片，并且一定会将子文件夹的名称作为类别。当根目录中只有一个子文件夹时，则对所有的图片标签都标注为0。当根目录中没有文件夹，而是直接存放图片时，则会直接报错。
使用ImageFolder读取后的数据是无法轻易更改标签的，这是因为ImageFolder继承自pytorch中的visiondataset类，标签在这个父类中生成，并与特征图一起被固定为一个元组（用来表示从特征到标签的映射）。我们可以通过ImageFolder的各种属性、或索引等方式调用出这个元组的一份复制来进行展示，却无法直接触及到元组中的数据本身，因此我们无法通过ImageFolder读取出的标签进行改变。因此，当数据不能按照类别进行下载时，一般不会用ImageFolder对数据进行读取，而会选择更加灵活的方式：自己写一个读取数据用的类。
CLASS torch.utils.data.Dataset
在PyTorch中存在一个专门帮助我们构筑数据集的类Dataset，这个类在torch.utils.data模块下，属于PyTorch中数据处理的经典父类之一（另一个我们总是使用的经典父类是nn.Module)。在PyTorch中，许多torchvision.datasets中读数据的类，以及TensotDataset这些合并张量来生成数据的类，都继承自Dataset。如果一个读取数据的类继承自Dataset,那它读取出的数据一定是可以通过索引的方式进行调用和查看的，而继承自其他父类的、读取数据集的功能却不一定能使用索引进行查看，这种性质让Dataset子类的构成也与其他类不同。
Dataset的使用还可以参考Dataset与DataLoder基本使用方法与数据集切分函数
Dataset中规定，如果一个子类要继承Dataset，则必须在子类中定义__getitem__()方法。从这个方法的名字可以看出，它是帮助我们“获取对象”的方法。这个方法中的代码必须满足三个功能：
1）读取单个图片并转化为张量
2）读取该图片对应的标签
3）将该图片的张量与对应标签打包成一个样本并输出
该样本的形式是一个元组，元组中的第一个对象是图像张量，第二个对象是该图像对应的标签。
Dataset类中包含自动循环__getitem__()并拼接其输出结果的功能。对于任意继承自Dataset的子类，只要我们恰当地定义了__getitem__(）,该子类的输出就一定是打包好的整个数据集。我们可以根据数据的实际情况定义__getitem__()，可以说实现了最大程度上的灵活性。
如何使用继承自Dataset的类读取不同的图片和标签类别？
在写具体的类之前，我们可以先定义__getitem__()方法中要求的内容，试着读取一张图片并生成样本的元组。事实上，有大量的库中都包含能够将图像转化为像素值的函数，原则上我们可以使用任何说自己熟悉的函数，比如使用opencv中的cv.imread函数进行图像的读取或使用pytorch官方推荐的scikit-learn图像处理库scikit-image来进行处理。
1）若标签为identity时
2）若标签为属性时" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/432f3e2699976f84e7e56562bea952a6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-11T10:10:43+08:00" />
<meta property="article:modified_time" content="2022-02-11T10:10:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">将png/jpg图像数据集转四维tensor输入PyTorch</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>       如果拥有了自己的数据集，首先需要考虑的就是将你的数据集输入到PyTorch当中去。如果你的数据是来自于网络（比如说，从Kaggle下载，从论文作者处获得，从某个数据集官方的网站进行下载）， 那你遇见的原始数据格式可能是各种情况，最常见的是<span style="color:#956fe7;"><strong>各类压缩文件</strong></span>、<span style="color:#956fe7;"><strong>pt文件</strong></span>、<span style="color:#956fe7;"><strong>数据库格式文件</strong></span>或者<span style="color:#956fe7;"><strong>png/jpg/webp等原始图像</strong></span>。如果你的数据是来自于实验室、公司数据库、甚至是领导/导师给的数据， 那你的数据大概率都是csv/txt/mat等结构的二维数据表。<span style="color:#511b78;"><strong>无论我们的原始数据集是呈现什么样的格式，我们必须将其转换为四维的张量，数据才可以被卷积神经网络处理。</strong></span>对于任意压缩文件，先解压查看内部是什么内容。</p> 
<h4><strong>这里详细说明从图像png/jpg到四维tensor</strong></h4> 
<p>       当你拥有的数据是一系列图像，并且每个标签对应的图像是存放在单独的文件夹中时，这种情况比较简单。在torchvision中存在直接将文件夹中的图片打包成tensor类的类<span style="color:#511b78;"><strong>ImageFolder</strong></span>,它的参数和torchvision.datasets中其他数据导入类的参数非常相似，其中<strong><span style="color:#956fe7;">root</span></strong>是你的原始图像所在的根目录，<span style="color:#956fe7;"><strong>transform</strong></span>是你希望对图像执行的具体操作。</p> 
<p><img alt="" height="88" src="https://images2.imgbox.com/7c/38/4kjrD9Si_o.png" width="743"></p> 
<p>      这个类可以接受<span style="color:#956fe7;"><strong>.jpg、.jpeg、.png、.ppm、.bmp、.pgm、.tif、.tiff、.webp</strong></span>这9种不同的图片格式作为输入，并且还<span style="color:#956fe7;"><strong>能够通过文件夹的分类自动识别标签</strong></span>。在你的根目录下，每个类别需要有一个单独的文件夹，而类别文件夹中可以存在多个子文件夹，或直接存放图片。图片的格式不需要统一，只要在ImageFolder可接受的9中格式中即可。</p> 
<p>train_dataset有几种可以调用的属性，例如：</p> 
<p>train_dataset..classes       #查看类别</p> 
<p>train_dataset.targets         #查看标签</p> 
<p>train_dataset.imgs            #查看具体的图像地址，返回所有图像的具体地址以及对应的标签</p> 
<p>例如下面的例子：</p> 
<p><img alt="" height="302" src="https://images2.imgbox.com/d7/a5/8mpgiyYF_o.png" width="911"><img alt="" height="297" src="https://images2.imgbox.com/ae/c7/F609Z053_o.png" width="912"></p> 
<p><img alt="" height="388" src="https://images2.imgbox.com/79/78/2cQQpFQo_o.png" width="908"></p> 
<p>      ImageFolder只能够读取<span style="color:#511b78;"><strong>根目录的子文件夹</strong></span>中的图片，并且一定会将子文件夹的名称作为类别。当根目录中只有一个子文件夹时，则对所有的图片标签都标注为0。当根目录中没有文件夹，而是直接存放图片时，则会直接报错。</p> 
<p><span style="color:#511b78;"><strong>      使用ImageFolder读取后的数据是无法轻易更改标签的</strong></span>，这是因为ImageFolder继承自pytorch中的visiondataset类，标签在这个父类中生成，并与特征图一起被固定为一个元组（用来表示从特征到标签的映射）。我们可以通过ImageFolder的各种属性、或索引等方式调用出这个元组的<span style="color:#511b78;"><strong>一份复制</strong></span>来进行展示，却无法直接触及到元组中的数据本身，因此我们无法通过ImageFolder读取出的标签进行改变。因此，当数据不能按照类别进行下载时，一般不会用ImageFolder对数据进行读取，而会选择更加灵活的方式：<span style="color:#511b78;"><strong>自己写一个读取数据用的类</strong></span>。</p> 
<p><span style="color:#511b78;"><strong>CLASS <span style="background-color:#cccccc;"> torch.utils.data.Dataset</span></strong></span></p> 
<p>      在PyTorch中存在一个专门帮助我们构筑数据集的类Dataset，这个类在torch.utils.data模块下，属于PyTorch中数据处理的经典<span style="color:#511b78;"><strong>父类</strong></span>之一（另一个我们总是使用的经典父类是nn.Module)。在PyTorch中，许多torchvision.datasets中读数据的类，以及TensotDataset这些合并张量来生成数据的类，都继承自Dataset。<span style="color:#956fe7;"><strong>如果一个读取数据的类继承自Dataset,那它读取出的数据一定是可以通过索引的方式进行调用和查看的，而继承自其他父类的、读取数据集的功能却不一定能使用索引进行查看，这种性质让Dataset子类的构成也与其他类不同</strong></span>。</p> 
<p>       Dataset的使用还可以参考<a class="link-info" href="https://blog.csdn.net/qq_44289607/article/details/122760500?utm_source=app&amp;app_version=5.0.1&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen" title="Dataset与DataLoder基本使用方法与数据集切分函数">Dataset与DataLoder基本使用方法与数据集切分函数</a></p> 
<p>       Dataset中规定，如果一个子类要继承Dataset，则必须在子类中定义__getitem__()方法。从这个方法的名字可以看出，它是帮助我们“获取对象”的方法。这个方法中的代码必须满足三个功能：</p> 
<p>1）读取单个图片并转化为张量</p> 
<p>2）读取该图片对应的标签</p> 
<p>3）将该图片的张量与对应标签打包成一个样本并输出</p> 
<p>该样本的形式是一个元组，元组中的第一个对象是图像张量，第二个对象是该图像对应的标签。</p> 
<p>       Dataset类中包含自动循环__getitem__()并拼接其输出结果的功能。对于任意继承自Dataset的子类，只要我们恰当地定义了__getitem__(）,该子类的输出就一定是打包好的整个数据集。我们可以根据数据的实际情况定义__getitem__()，可以说实现了最大程度上的灵活性。</p> 
<p>如何使用继承自Dataset的类读取不同的图片和标签类别？</p> 
<p>       在写具体的类之前，我们可以先定义__getitem__()方法中要求的内容，试着读取一张图片并生成样本的元组。事实上，有大量的库中都包含能够将图像转化为像素值的函数，原则上我们可以使用任何说自己熟悉的函数，比如使用opencv中的cv.imread函数进行图像的读取或使用pytorch官方推荐的scikit-learn图像处理库scikit-image来进行处理。</p> 
<p><img alt="" height="122" src="https://images2.imgbox.com/c6/55/vCX15Z5N_o.png" width="909"></p> 
<p>1）若标签为identity时</p> 
<p><img alt="" height="357" src="https://images2.imgbox.com/98/10/bJKZx0BG_o.png" width="912"><img alt="" height="443" src="https://images2.imgbox.com/4d/15/86Jb8dDa_o.png" width="909"></p> 
<p> 2）若标签为属性时<img alt="" height="450" src="https://images2.imgbox.com/c9/6f/So9ZnAOh_o.png" width="911"></p> 
<p><img alt="" height="441" src="https://images2.imgbox.com/35/36/i4jvTBJI_o.png" width="904"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e6c03b170dbf1cd4b8752da9eadf3291/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【ctfshow】文件包含练习2</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/49124545771daf5c2588fb29d820e6b5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言的内存管理（堆，栈，代码段，数据段）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>