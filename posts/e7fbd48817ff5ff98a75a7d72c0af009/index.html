<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TCP实现FTP功能 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TCP实现FTP功能" />
<meta property="og:description" content="目录
server
client
makefile
运行顺序
FTP（File Transfer Protocol）是一种用于在计算机网络上传输文件的标准协议。
它允许用户通过网络将文件从一个计算机（称为FTP服务器）传输到另一个计算机（称为FTP客户端）
以下是FTP的一般工作流程：
建立连接：客户端使用FTP客户端软件连接到FTP服务器；身份验证：客户端在连接建立后，提供登录凭据；导航文件系统：验证成功，客户端可以浏览FTP服务器上的文件系统，并选择要上传或下载的文件；上传文件：客户端可以选择要上传到FTP服务器的本地文件，并将其发送到服务器；下载文件：客户端可以选择要从FTP服务器下载的文件，并将其复制到本地计算机；其他操作：FTP还支持其他操作，例如重命名文件、删除文件、创建文件夹等； 项目功能介绍： 均有服务器和客户端代码，基于TCP写的。 在同一路径下，将客户端可执行代码复制到其他的路径下，接下来再不同的路径下运行服务器和客户端。 相当于另外一台电脑在访问服务器。 客户端和服务器链接成功后出现以下提示：四个功能 ***************list************** //列出服务器所在目录下的文件名(除目录不显示) ***********put filename********** //上传一个文件 ***********get filename********** //重服务器所在路径下载文件 **************quit*************** //退出(可只退出客户端，服务器等待下一个客户端链接) server #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;netinet/ip.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;dirent.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; void list_server(int acceptfd, char *buf, int size);	//list功能 void put_server(int acceptfd, char *buf, int size);	//put功能 void get_server(int acceptfd,char *buf, int size);	//get功能 int main(int argc, char const *argv[]) { if (argc !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e7fbd48817ff5ff98a75a7d72c0af009/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-19T19:02:26+08:00" />
<meta property="article:modified_time" content="2023-07-19T19:02:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TCP实现FTP功能</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="PzMCu-toc" style="margin-left:0px;"><a href="#PzMCu" rel="nofollow">server</a></p> 
<p id="tfqcU-toc" style="margin-left:0px;"><a href="#tfqcU" rel="nofollow">client</a></p> 
<p id="KjxKY-toc" style="margin-left:0px;"><a href="#KjxKY" rel="nofollow">makefile</a></p> 
<p id="%C2%A0%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F-toc" style="margin-left:0px;"><a href="#%C2%A0%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F" rel="nofollow"> 运行顺序</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p id="u8e420dea">FTP（File Transfer Protocol）是一种用于在计算机网络上传输文件的标准协议。</p> 
<p id="u96fe61bb">它允许用户通过网络将文件从<strong>一个计算机（称为FTP服务器）传输到另一个计算机（称为FTP客户端）</strong></p> 
<p id="u1822cb94">以下是FTP的一般工作流程：</p> 
<ol><li id="u59003598">建立连接：客户端使用FTP客户端软件连接到FTP服务器；</li><li id="uc08c4302">身份验证：客户端在连接建立后，提供登录凭据；</li><li id="uae1481d5">导航文件系统：验证成功，客户端可以浏览FTP服务器上的文件系统，并选择要上传或下载的文件；</li><li id="u8f8f991e">上传文件：客户端可以选择要上传到FTP服务器的本地文件，并将其发送到服务器；</li><li id="u0f5ad997">下载文件：客户端可以选择要从FTP服务器下载的文件，并将其复制到本地计算机；</li><li id="ub5012974">其他操作：FTP还支持其他操作，例如重命名文件、删除文件、创建文件夹等；</li></ol> 
<pre><code class="language-cpp">项目功能介绍：
均有服务器和客户端代码，基于TCP写的。
在同一路径下，将客户端可执行代码复制到其他的路径下，接下来再不同的路径下运行服务器和客户端。
相当于另外一台电脑在访问服务器。
客户端和服务器链接成功后出现以下提示：四个功能
***************list************** //列出服务器所在目录下的文件名(除目录不显示)
***********put filename********** //上传一个文件
***********get filename********** //重服务器所在路径下载文件
**************quit*************** //退出(可只退出客户端，服务器等待下一个客户端链接)</code></pre> 
<h2 id="PzMCu">server</h2> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/ip.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

void list_server(int acceptfd, char *buf, int size);	//list功能
void put_server(int acceptfd, char *buf, int size);		//put功能
void get_server(int acceptfd,char *buf, int size);		//get功能
int main(int argc, char const *argv[])
{
    if (argc != 2)
    {
        printf("please input %s &lt;port&gt;\n", argv[0]);
        return -1;
    }
    //1.创建流式套接字
    int sockfd = socket(AF_INET, SOCK_STREAM, 0); //链接
    if (sockfd &lt; 0)
    {
        perror("socket err.");
        return -1;
    }
    printf("sockfd:%d\n", sockfd); //3
    //填充ipv4的通信结构体

    struct sockaddr_in saddr, caddr;
    saddr.sin_family = AF_INET;
    saddr.sin_port = htons(atoi(argv[1])); //"8888" int a= atoi("8888")//a=8888
    saddr.sin_addr.s_addr = inet_addr("0.0.0.0");

    socklen_t len = sizeof(caddr);

    //2.绑定套接字 ip和端口(自己)
    if (bind(sockfd, (struct sockaddr *)&amp;saddr, sizeof(saddr)) &lt; 0)
    {
        perror("bind err.");
        return -1;
    }
    printf("bind ok.\n");

    //3.监听
    if (listen(sockfd, 5) &lt; 0)
    {
        perror("listen err.");
        return -1;
    }
    printf("listen ok.\n");
    //4.阻塞等待客户端链接
    while (1)
    {
        int acceptfd = accept(sockfd, (struct sockaddr *)&amp;caddr, &amp;len);
        if (acceptfd &lt; 0)
        {
            perror("accept err.");
            return -1;
        }
        printf("acceptfd=%d\n", acceptfd); //通信
        printf("client:ip=%s port=%d\n",
               inet_ntoa(caddr.sin_addr),
			   ntohs(caddr.sin_port));
        //循环收发消息
        char buf[128];
        int ret;
        while (1)
        {
            ret = recv(acceptfd, buf, sizeof(buf), 0);
            if (ret &lt; 0)
            {
                perror("recv err.");
                return -1;
            }
            else if (ret == 0)
            {
                printf("client exit\n");
                break;
            }
            else
            {
                if (strncmp(buf, "list", 4) == 0)
                { //打开当前目录读文件判断文件是普通文件将文件名传给客户端
                    list_server(acceptfd, buf, sizeof(buf));
                }
                else if (strncmp(buf, "put ", 4) == 0)
                { //接收文件(本地：打开新建文件接收客户端发送过来的内容写到文件)
                    put_server(acceptfd, buf, sizeof(buf));
                }
                else if (strncmp(buf, "get ", 4) == 0)
                { //发送文件
                    //(本地：打开文件读文件内容发送给客户端)
                    get_server(acceptfd, buf, sizeof(buf));
                }
            }
        }
        close(acceptfd);
    }
    close(sockfd);
    return 0;
}

//3、get
void get_server(int acceptfd,char *buf, int size) //buf-&gt;put xxx.c
{
    //1&gt;打开文件 读
    int fd = open(buf + 4, O_RDONLY);	//buf-&gt;put xxx.c
    if (fd &lt; 0)
    {
        perror("open file err.");
        return;
    }
    int ret; //实际读到的个数
    while ((ret = read(fd, buf, size - 1)) != 0)
    {
        buf[ret] = '\0';				// 将读取的内容以字符串形式结束
        send(acceptfd, buf, size, 0);	// 发送读取的内容给客户端
    }
    strcpy(buf, "get ok.");				// 将"get ok."字符串复制到缓冲区
    send(acceptfd, buf, size, 0);		// 发送"get ok."给客户端
}
//2.接收文件(本地：打开新建文件接收客户端发送过来的内容写到文件)
void put_server(int acceptfd, char *buf, int size)
{
	 // 1. 打开文件，以写入方式打开（如果不存在则创建，如果存在则清空内容）
    int fd = open(buf + 4, O_TRUNC | O_CREAT | O_WRONLY, 0666);
    if (fd &lt; 0)
    {
        perror("open err.");
        return;
    }
    while (1)
    {
		// 2. 接收客户端发送的数据
        if (recv(acceptfd, buf, size, 0) &lt; 0)
        {
            perror("recv err.");
            return;
        }
		// 3. 检查是否接收到结束标识"put ok."
        if (strncmp(buf, "put ok.", 7) == 0)
            break;
		// 4. 将接收到的数据写入文件
        write(fd, buf, strlen(buf));
    }
}

//list：打开当前目录读文件判断文件是普通文件将文件名传给客户端
void list_server(int acceptfd, char *buf, int size)
{
    //1.打开当前目录文件
    DIR *dir = opendir("./");
    if (dir == NULL)
    {
        perror("opendir err.");
        return;
    }
    //2.循环读目录文件  readdir
    struct dirent *dp = NULL;
    struct stat st;
    while ((dp = readdir(dir)) != NULL)
    {
        //dp-&gt;d_name拿到的文件名
        //判断文件属性stat
        stat(dp-&gt;d_name, &amp;st);
        if (S_ISREG(st.st_mode))
        {
            strcpy(buf, dp-&gt;d_name);		// 将文件名拷贝到缓冲区		
            send(acceptfd, buf, size, 0);	// 发送文件名给客户端
        }
    }
    //发送结束标志
    strcpy(buf, "list ok.");
    send(acceptfd, buf, size, 0);
}</code></pre> 
<h2 id="tfqcU">client</h2> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/ip.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

void show(void);
void list_client(int sockfd, char *buf, int size);
void put_client(int sockfd, char *buf, int size);
void get_client(int sockfd, char *buf, int size);
int main(int argc, char const *argv[])
{
    if (argc != 3)
    {
        printf("please input %s &lt;ip&gt; &lt;port&gt;\n", argv[0]);
        return -1;
    }
    //1.创建套接子
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd &lt; 0)
    {
        perror("socket err.");
        return -1;
    }
    //填充结构体
    struct sockaddr_in saddr;
    saddr.sin_family = AF_INET;
    saddr.sin_port = htons(atoi(argv[2]));
    saddr.sin_addr.s_addr = inet_addr(argv[1]);
    if (connect(sockfd, (struct sockaddr *)&amp;saddr, sizeof(saddr)) &lt; 0)
    {
        perror("connect err.");
        return -1;
    }
    //收发消息
    char buf[128];
    while (1)
    {
        //1.请求窗口
        show();
        //2.获取请求
        fgets(buf, sizeof(buf), stdin);
        if (buf[strlen(buf) - 1] == '\n')
            buf[strlen(buf) - 1] = '\0';
		
        send(sockfd, buf, sizeof(buf), 0);
		
        if (strncmp(buf, "list", 4) == 0)
        { 	//循环接收服务器发送过来的普通文件名输出到终端
            list_client(sockfd, buf, sizeof(buf));
        }
        else if (strncmp(buf, "put ", 4) == 0)
        { 	//上传文件(本地：打开文件读内容发送给服务器)
            put_client(sockfd,buf,sizeof(buf));
        }
        else if (strncmp(buf, "get ", 4) == 0)
        { 	//下载服务器路径下的文件
        	//(本地：打开新建文件接收服务器发送过来的内容写到文件)
            get_client(sockfd,buf,sizeof(buf));
        }
        else if (strncmp(buf, "quit", 4) == 0)
        {
            break;
        }
    }
    close(sockfd);
    return 0;
}
//3.get
void get_client(int sockfd, char *buf, int size)
{
    int fd = open(buf + 4, O_TRUNC | O_CREAT | O_WRONLY, 0666);
    if (fd &lt; 0)
    {
        perror("open err.");
        return;
    }
    while (1)
    {
        if (recv(sockfd, buf, size, 0) &lt; 0)
        {
            perror("recv err.");
            return;
        }
        if (strncmp(buf, "get ok.", 7) == 0)
            break;
        write(fd, buf, strlen(buf));
    }
}
//2.put 上传文件(本地：打开文件读内容发送给服务器)
void put_client(int sockfd, char *buf, int size) //buf-&gt;put xxx.c
{
    //1&gt;打开文件 读
    int fd = open(buf + 4, O_RDONLY);
    if (fd &lt; 0)
    {
        perror("open file err.");
        return;
    }
    int ret; //实际读到的个数
    while ((ret = read(fd, buf, size - 1)) != 0)
    {
        buf[ret] = '\0';
        send(sockfd, buf, size, 0);
    }
    strcpy(buf, "put ok.");
    send(sockfd, buf, size, 0);
}

//1.list:循环接收服务器发送过来的普通文件名输出到终端
void list_client(int sockfd, char *buf, int size)
{

    while (1)
    {
        if (recv(sockfd, buf, size, 0) &lt; 0)
        {
            perror("list recv err.");
            return;
        }
        if (strncmp(buf, "list ok.", 8) == 0)
        {
            break;
        }
        printf("%s\n", buf);
    }
}

void show(void)
{
    printf("************list***************\n");
    printf("************put filename*******\n");
    printf("************get filename*******\n");
    printf("************quit***************\n");
}</code></pre> 
<h2 id="KjxKY">makefile</h2> 
<pre><code class="language-cpp">all:
	gcc server.c -o ser		
	gcc client.c -o cli	
.PHONY:clean	
clean:
	rm ser cli	</code></pre> 
<p id="u97611b20"></p> 
<h2 id="%C2%A0%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F"><strong> 运行顺序</strong></h2> 
<p class="img-center"><img alt="" height="338" id="u1ee2f61f" src="https://images2.imgbox.com/d9/c9/v4p8J8xI_o.png" width="1158"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/af4961b6104687db5172f0009e56a596/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Win10电脑怎么查看图片分辨率</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d17c9141c269a2a4a60f949df8fc4f49/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">记账小程序源码，可做毕设或期末作业</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>