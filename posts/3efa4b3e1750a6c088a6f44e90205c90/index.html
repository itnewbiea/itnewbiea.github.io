<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HashMap.computeIfAbsent与computeIfPresent - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HashMap.computeIfAbsent与computeIfPresent" />
<meta property="og:description" content="HashMap.computeIfAbsent
如果需要向Map中push一个键值对，需要判断K key在当前map中是否已经存在，不存在则通过后面的 Function&lt;? super K, ? extends V&gt; mappingFunction 来进行value计算，且将结果当作value同key一起push到Map中。
computeIfAbsent() 方法的用法总结: 只有在当前 Map 中 key 对应的值不存在或为 null 时 ，才调用 mappingFunction，并在 mappingFunction 执行结果非 null 时，将结果跟 key 关联，mappingFunction 为空时 将抛出空指针异常。
公共代码：
Map &lt;String, List&lt;Integer&gt;&gt; map=new HashMap&lt;&gt;(); List&lt;Integer&gt; l1=new ArrayList();List &lt;Integer&gt; l2=new ArrayList&lt;&gt;(); l1.add(1);l1.add(11);l2.add(2);l2.add(22); map.put(&#34;1&#34;,l1); map.put(&#34;2&#34;,l2); 接下来就是使用了：
写法1：
List&lt;Integer&gt; l3=new ArrayList&lt;&gt;();l3.add(3);l3.add(33); System.out.println(map.computeIfAbsent(&#34;2&#34;,v-&gt;l3)); System.out.println(map); 结果：如果原来map中有2，那么不会更新原来的值,并且computeIfAbsent方法返回原有的2这条值对于的value
[2, 22] {1=[1, 11], 2=[2, 22]} 写法2：
List&lt;Integer&gt; l3=new ArrayList&lt;&gt;();l3.add(3);l3.add(33); System.out.println(map.computeIfAbsent(&#34;3&#34;,v-&gt;l3)); System.out.println(map); 结果：如果原来map中无3那么会向map中新增3这条值，并且computeIfAbsent方法返回新增的3这条值的value
[3, 33] {1=[1, 11], 2=[2, 22], 3=[3, 33]} 写法3：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/3efa4b3e1750a6c088a6f44e90205c90/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-17T11:19:40+08:00" />
<meta property="article:modified_time" content="2022-01-17T11:19:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HashMap.computeIfAbsent与computeIfPresent</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>HashMap.computeIfAbsent<br> 如果需要向Map中push一个键值对，需要判断K key在当前map中是否已经存在，不存在则通过后面的 Function&lt;? super K, ? extends V&gt; mappingFunction 来进行value计算，且将结果当作value同key一起push到Map中。</p> 
<h3><a id="computeIfAbsent__3"></a><strong>computeIfAbsent() 方法的用法总结:</strong></h3> 
<p>只有在当前 Map 中 key 对应的值不存在或为 null 时 ，才调用 mappingFunction，并在 mappingFunction 执行结果非 null 时，将结果跟 key 关联，mappingFunction 为空时 将抛出空指针异常。</p> 
<p>公共代码：</p> 
<pre><code>Map &lt;String, List&lt;Integer&gt;&gt; map=new HashMap&lt;&gt;();
List&lt;Integer&gt; l1=new ArrayList();List &lt;Integer&gt; l2=new ArrayList&lt;&gt;();
l1.add(1);l1.add(11);l2.add(2);l2.add(22);
map.put("1",l1);
map.put("2",l2);
</code></pre> 
<p>接下来就是使用了：</p> 
<p><em><strong>写法1：</strong></em></p> 
<pre><code>List&lt;Integer&gt; l3=new ArrayList&lt;&gt;();l3.add(3);l3.add(33);
System.out.println(map.computeIfAbsent("2",v-&gt;l3));
System.out.println(map);
</code></pre> 
<p>结果：如果原来map中有2，那么不会更新原来的值,并且computeIfAbsent方法返回原有的2这条值对于的value</p> 
<pre><code>[2, 22]
{1=[1, 11], 2=[2, 22]}
</code></pre> 
<p><em><strong>写法2：</strong></em></p> 
<pre><code>List&lt;Integer&gt; l3=new ArrayList&lt;&gt;();l3.add(3);l3.add(33);
System.out.println(map.computeIfAbsent("3",v-&gt;l3));
System.out.println(map);
</code></pre> 
<p>结果：如果原来map中无3那么会向map中新增3这条值，并且computeIfAbsent方法返回新增的3这条值的value</p> 
<pre><code>[3, 33]
{1=[1, 11], 2=[2, 22], 3=[3, 33]}
</code></pre> 
<p><em><strong>写法3：</strong></em></p> 
<pre><code>System.out.println(map.computeIfAbsent("3",v-&gt;null));
System.out.println(map);
</code></pre> 
<p>结果：如果原来map中无3，并且mappingFunction的返回值为null（新增的value为null），则不会新增这条记录，并且computeIfAbsent方法返回的是null值</p> 
<pre><code>null
{1=[1, 11], 2=[2, 22]}
</code></pre> 
<p><em><strong>写法4：</strong></em></p> 
<pre><code>System.out.println(map.computeIfAbsent("3",k-&gt;{
    List&lt;Integer&gt; l3=new ArrayList&lt;&gt;();l3.add(3);l3.add(33);
    return l3;
}));
System.out.println(map);
</code></pre> 
<p>或者：</p> 
<pre><code>
List&lt;Integer&gt; l3=new ArrayList&lt;&gt;();l3.add(3);l3.add(33);
System.out.println(map.computeIfAbsent("3",k-&gt;{
    return l3;
}));
System.out.println(map);
</code></pre> 
<p>结果：和上面写法2是一样的，只不过把返回值写成函数的形式了</p> 
<pre><code>[3, 33]
{1=[1, 11], 2=[2, 22], 3=[3, 33]}
</code></pre> 
<p><em><strong>写法5：</strong></em></p> 
<pre><code>List&lt;Integer&gt; l3=new ArrayList&lt;&gt;();l3.add(3);l3.add(33);
System.out.println(map.computeIfAbsent("3",k-&gt;{
    System.out.println(k);
    List&lt;Integer&gt; l4=new ArrayList&lt;&gt;();l4.add(4);l4.add(44);
    map.put("4",l4);
    return l3;
}));
System.out.println(map);
</code></pre> 
<p>结果：这么套娃也是可以的，这里为了验证先添加的3还是先添加的4，我们继续试验</p> 
<pre><code>3
[3, 33]
{1=[1, 11], 2=[2, 22], 3=[3, 33], 4=[4, 44]}
</code></pre> 
<p><em><strong>写法6：</strong></em></p> 
<pre><code>List&lt;Integer&gt; l3=new ArrayList&lt;&gt;();l3.add(3);l3.add(33);
System.out.println(map.computeIfAbsent("3",k-&gt;{
    System.out.println(k);
    List&lt;Integer&gt; l4=new ArrayList&lt;&gt;();l4.add(4);l4.add(44);
    map.put("3",l4);
    return l3;
}));
System.out.println(map);
</code></pre> 
<p>结果：这里明显可以看出来，computeIfAbsent方法先判断3是否存在在map中，判断不存在，则执行mappingFunction方法获得返回值，如果3存在，则不会执行mappingFunction方法，这里执行后先赋值3，最后在替换掉3，当然，正常情况是不会这么用的，这相当于骗了computeIfAbsent方法，哈哈</p> 
<pre><code>3
[3, 33]
{1=[1, 11], 2=[2, 22], 3=[3, 33]}
</code></pre> 
<p><em><strong>写法7：</strong></em></p> 
<pre><code>System.out.println(map.computeIfAbsent("2",null));
System.out.println(map);
</code></pre> 
<p>结果：不管key存在不存在，只要mappingFunction为空，则直接报错</p> 
<pre><code>Exception in thread "main" java.lang.NullPointerException
at java.util.HashMap.computeIfAbsent(HashMap.java:1098)
at Test1.main(Test1.java:14)
</code></pre> 
<p>一共这7种写法吧，如果有不足，还需要及时补充；</p> 
<h3><a id="HashMapcomputeIfPresent_143"></a><strong>HashMap.computeIfPresent</strong></h3> 
<p>computeIfPresent() 方法对 hashMap 中指定 key 的值进行重新计算，前提是该 key 存在于 hashMap 中。</p> 
<p>computeIfPresent() 方法的语法为：hashmap.computeIfPresent(K key, BiFunction remappingFunction)</p> 
<p><em><strong>公共代码：</strong></em></p> 
<pre><code>Map &lt;String, List&lt;Integer&gt;&gt; map=new HashMap&lt;&gt;();
List&lt;Integer&gt; l1=new ArrayList();List &lt;Integer&gt; l2=new ArrayList&lt;&gt;();
l1.add(1);l1.add(11);l2.add(2);l2.add(22);
map.put("1",l1);
map.put("2",l2);
</code></pre> 
<p><em><strong>写法1：</strong></em></p> 
<pre><code>List&lt;Integer&gt; l3=new ArrayList&lt;&gt;();l3.add(3);l3.add(33);
System.out.println(map.computeIfPresent("2",(k,v)-&gt;l3));
System.out.println(map);
</code></pre> 
<p>结果：如果map中2存在，则修改map中2的value值，并且返回新修改的值；</p> 
<pre><code>[3, 33]
{1=[1, 11], 2=[3, 33]}
</code></pre> 
<p><em><strong>写法2：</strong></em></p> 
<pre><code>List&lt;Integer&gt; l3=new ArrayList&lt;&gt;();l3.add(3);l3.add(33);
System.out.println(map.computeIfPresent("3",(k,v)-&gt;l3));
System.out.println(map);
</code></pre> 
<p>结果：如果要修改的key值不存在，则不修改值，并且返回空值<br> null<br> {1=[1, 11], 2=[2, 22]}</p> 
<p><em><strong>写法3：</strong></em></p> 
<pre><code>System.out.println(map.computeIfPresent("2",(k,v)-&gt;null));
System.out.println(map);
</code></pre> 
<p>结果：如果map中存在值，并且要修改的值为空，则会删除掉原来map中的存在的值</p> 
<pre><code>null
{1=[1, 11]}
</code></pre> 
<p><em><strong>写法4：</strong></em></p> 
<pre><code>List&lt;Integer&gt; l3=new ArrayList&lt;&gt;();l3.add(3);l3.add(33);
System.out.println(map.computeIfPresent("2",(k,v)-&gt;{
    return l3;
}));
System.out.println(map);
</code></pre> 
<p>或者：</p> 
<pre><code>System.out.println(map.computeIfPresent("2",(k,v)-&gt;{
    List&lt;Integer&gt; l3=new ArrayList&lt;&gt;();l3.add(3);l3.add(33);
    return l3;
}));
System.out.println(map);
</code></pre> 
<p>结果：和上面的写法1一样，只不过改成了函数的形式</p> 
<pre><code>[3, 33]
{1=[1, 11], 2=[3, 33]}
</code></pre> 
<p><em><strong>写法5：</strong></em></p> 
<pre><code>System.out.println(map.computeIfPresent("2",(k,v)-&gt;{
    System.out.println(k);
    System.out.println(v);
    List&lt;Integer&gt; l3=new ArrayList&lt;&gt;();l3.add(3);l3.add(33);
    List&lt;Integer&gt; l4=new ArrayList&lt;&gt;();l4.add(4);l4.add(44);
    map.put("4",l4);
    return l3;
}));
System.out.println(map);
</code></pre> 
<p>结果：这么套娃也是可以的，为了验证先添加的4还是先修改的2，我们继续试验</p> 
<pre><code>2
[2, 22]
[3, 33]
{1=[1, 11], 2=[3, 33], 4=[4, 44]}
</code></pre> 
<p><em><strong>写法6：</strong></em></p> 
<pre><code>System.out.println(map.computeIfPresent("2",(k,v)-&gt;{
    System.out.println(k);
    System.out.println(v);
    List&lt;Integer&gt; l3=new ArrayList&lt;&gt;();l3.add(3);l3.add(33);
    List&lt;Integer&gt; l4=new ArrayList&lt;&gt;();l4.add(4);l4.add(44);
    map.put("2",l4);
    return l3;
}));
System.out.println(map);
</code></pre> 
<p>结果：这里明显可以看出来，computeIfPresent方法先判断2是否存在在map中，判断存在，则执行mappingFunction方法获得返回值，如果2不存在，则不会执行mappingFunction方法，这里执行后先赋值2，最后在替换掉2，当然，正常情况是不会这么用的，这相当于骗了computeIfAbsent方法，哈哈</p> 
<p><em><strong>写法7：</strong></em></p> 
<pre><code>System.out.println(map.computeIfPresent("2",null));
System.out.println(map);
</code></pre> 
<p>结果：不管key存在不存在，只要mappingFunction为空，则直接报错</p> 
<pre><code>Exception in thread "main" java.lang.NullPointerException
at java.util.HashMap.computeIfPresent(HashMap.java:1151)
at Test1.main(Test1.java:14)
</code></pre> 
<p>一共这7种写法吧，如有不足吗，还会及时补充。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7659f06a5b551ee38ecd2ed73f32c3a3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">贪心算法详细介绍（贪心算法与动态规划的区别）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1b803248070a841ac9570be8e391fd70/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">动态SQL查询，动态内表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>