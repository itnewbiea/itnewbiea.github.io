<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用Spring @DependsOn控制bean加载顺序 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用Spring @DependsOn控制bean加载顺序" />
<meta property="og:description" content="使用Spring @DependsOn控制bean加载顺序 spring容器载入bean顺序是不确定的，spring框架没有约定特定顺序逻辑规范。但spring保证如果A依赖B(如beanA中有@Autowired B的变量)，那么B将先于A被加载。但如果beanA不直接依赖B，我们如何让B仍先加载呢？
控制bean初始化顺序 可能有些场景中，bean A 间接依赖 bean B。如Bean B应该需要更新一些全局缓存，可能通过单例模式实现且没有在spring容器注册，bean A需要使用该缓存；因此，如果bean B没有准备好，bean A无法访问。 另一个场景中，bean A是事件发布者（或JMS发布者），bean B (或一些) 负责监听这些事件，典型的如观察者模式。我们不想B 错过任何事件，那么B需要首先被初始化。
简言之，有很多场景需要bean B应该被先于bean A被初始化，从而避免各种负面影响。我们可以在bean A上使用@DependsOn注解，告诉容器bean B应该先被初始化。下面通过示例来说明。
示例说明 示例通过事件机制说明，发布者和监听者，然后通过spring配置运行。为了方便说明，示例进行了简化。
EventManager.java 事件管理类，维护监听器列表，通过单例方法获取事件管理器，可以增加监听器或发布事件。
import java.util.ArrayList; import java.util.List; import java.util.function.Consumer; public class EventManager { private final List&lt;Consumer&lt;String&gt;&gt; listeners = new ArrayList&lt;&gt;(); private EventManager() { } private static class SingletonHolder { private static final EventManager INSTANCE = new EventManager(); } public static EventManager getInstance() { return SingletonHolder." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/24ee4aadd1360930a6784b12973b1126/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-12-11T18:26:39+08:00" />
<meta property="article:modified_time" content="2017-12-11T18:26:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用Spring @DependsOn控制bean加载顺序</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="使用spring-dependson控制bean加载顺序">使用Spring @DependsOn控制bean加载顺序</h2> 
<blockquote> 
 <p>spring容器载入bean顺序是不确定的，spring框架没有约定特定顺序逻辑规范。但spring保证如果A依赖B(如beanA中有@Autowired B的变量)，那么B将先于A被加载。但如果beanA不直接依赖B，我们如何让B仍先加载呢？</p> 
</blockquote> 
<h3 id="控制bean初始化顺序">控制bean初始化顺序</h3> 
<p>可能有些场景中，bean A 间接依赖 bean B。如Bean B应该需要更新一些全局缓存，可能通过单例模式实现且没有在spring容器注册，bean A需要使用该缓存；因此，如果bean B没有准备好，bean A无法访问。 </p> 
<p>另一个场景中，bean A是事件发布者（或JMS发布者），bean B (或一些) 负责监听这些事件，典型的如观察者模式。我们不想B 错过任何事件，那么B需要首先被初始化。</p> 
<p>简言之，有很多场景需要bean B应该被先于bean A被初始化，从而避免各种负面影响。我们可以在bean A上使用<code>@DependsOn</code>注解，告诉容器bean B应该先被初始化。下面通过示例来说明。</p> 
<h3 id="示例说明">示例说明</h3> 
<p>示例通过事件机制说明，发布者和监听者，然后通过spring配置运行。为了方便说明，示例进行了简化。</p> 
<p><strong>EventManager.java</strong> <br> 事件管理类，维护监听器列表，通过单例方法获取事件管理器，可以增加监听器或发布事件。</p> 
<pre class="prettyprint"><code class=" hljs java">
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.function.Consumer;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventManager</span> {<!-- --></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Consumer&lt;String&gt;&gt; listeners = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

    <span class="hljs-keyword">private</span> <span class="hljs-title">EventManager</span>() {
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> {<!-- --></span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EventManager INSTANCE = <span class="hljs-keyword">new</span> EventManager();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EventManager <span class="hljs-title">getInstance</span>() {
        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publish</span>(<span class="hljs-keyword">final</span> String message) {
        listeners.forEach(l -&gt; l.accept(message));
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addListener</span>(Consumer&lt;String&gt; eventConsumer) {
        listeners.add(eventConsumer);
    }
}</code></pre> 
<p><strong>EventPublisherBean.java</strong> <br> 事件发布类，通过EventManager类发布事件。</p> 
<pre class="prettyprint"><code class=" hljs cs">import com.logicbig.example.EventManager;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> EventPublisherBean {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span>() {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"EventPublisherBean initializing"</span>);
        EventManager.getInstance().publish(<span class="hljs-string">"event published from EventPublisherBean"</span>);
    }
}</code></pre> 
<p><strong>EventListenerBean.java</strong> <br> 事件监听者，可以增加监听器。</p> 
<pre class="prettyprint"><code class=" hljs cs">import com.logicbig.example.EventManager;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> EventListenerBean {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span>() {
        EventManager.getInstance().
                addListener(s -&gt;
                        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"event received in EventListenerBean : "</span> + s));
    }
}</code></pre> 
<p><strong>AppConfig.java</strong> <br> 配置运行类。</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-annotation">@Configuration</span>
<span class="hljs-annotation">@ComponentScan</span>(<span class="hljs-string">"com.logicbig.example"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> {<!-- --></span>

    <span class="hljs-annotation">@Bean</span>(initMethod = <span class="hljs-string">"initialize"</span>)
    <span class="hljs-annotation">@DependsOn</span>(<span class="hljs-string">"eventListener"</span>)
    <span class="hljs-keyword">public</span> EventPublisherBean <span class="hljs-title">eventPublisherBean</span> () {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EventPublisherBean();
    }

    <span class="hljs-annotation">@Bean</span>(name = <span class="hljs-string">"eventListener"</span>, initMethod = <span class="hljs-string">"initialize"</span>)
    <span class="hljs-comment">// @Lazy</span>
    <span class="hljs-keyword">public</span> EventListenerBean <span class="hljs-title">eventListenerBean</span> () {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EventListenerBean();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> (String... strings) {
        <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);
    }
}</code></pre> 
<p>运行AppConfig的main方法，输出结果为：</p> 
<pre class="prettyprint"><code class=" hljs oxygene">EventListenerBean initializing
EventPublisherBean initializing
<span class="hljs-keyword">event</span> received <span class="hljs-keyword">in</span> EventListenerBean : <span class="hljs-keyword">event</span> <span class="hljs-keyword">published</span> <span class="hljs-keyword">from</span> EventPublisherBean</code></pre> 
<h3 id="总结">总结</h3> 
<p>如果我们注释掉<code>@DependsOn("eventListener")</code>，我们可能不确定获得相同结果。尝试多次运行main方法，偶尔我们将看到EventListenerBean 没有收到事件。为什么是偶尔呢？因为容器启动过程中，spring按任意顺序加载bean。 </p> 
<p>那么当不使用<code>@DependsOn</code>可以让其100%确定吗？可以使用<code>@Lazy</code>注解放在<code>eventListenerBean ()</code>上。因为<code>EventListenerBean</code>在启动阶段不加载，当其他bean需要其时才加载。这次我们仅<code>EventListenerBean</code>被初始化。</p> 
<pre class="prettyprint"><code class=" hljs ">EventPublisherBean initializing</code></pre> 
<p>现在从新增加<code>@DependsOn</code>，也不删除<code>@Lazy</code>注解，输出结果和第一次一致，虽然我们使用了<code>@Lazy</code>注解，<code>eventListenerBean</code>在启动时仍然被加载，因为<code>@DependsOn</code>表明需要<code>EventListenerBean</code>。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/57db9282a0f53911004286c8bf0e4c65/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">jtopo限制滚轮缩放范围，zoomOut()与zoomIn()缩放限制</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8897da3e73d6ba2fbe4c635a6504019e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在xilinx SDK中查询API函数的方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>