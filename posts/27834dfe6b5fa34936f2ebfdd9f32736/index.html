<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>反汇编基础、OllyDbg简介和界面、基本操作、初级TraceMe练习 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="反汇编基础、OllyDbg简介和界面、基本操作、初级TraceMe练习" />
<meta property="og:description" content="以下使用的练习示例是《Windows程序设计》第五版第一章的HelloMsg.exe；以及《加密与解密》第三版附带的RebPE.exe；
一 反汇编基础 1 字节顺序
字节存储顺序
和CPU有关；微处理器的存放顺序有正序（Big-Endian），逆序（Little-Endian）；Intel逆序，Power-PC正序；
正序：高位字节存入低地址，低位字节存入高地址；
逆序：反之；
十进制7869，十六进制是1EBD；
看一下此数在emu8086中的存放；Intel逆序；低位字节存入低地址，高位字节存入高地址；
1E是高位字节，BD是低位字节；
1E存入01001单元，BD存入01000单元，逆序；
2 调试符号
Windows调试基础 - 符号
当应用程序被链接以后，代码被逐一地翻译为一个个的地址。
使用vs或者windbg等微软的调试工具进行调试的时候，可以方便地使用变量名来查看内存、可以使用函数名称来下断点、可以指定某个文件的某一行来下断点。
这一切背后，是符号在指导调试器工作，pdb或者dbg文件。
（.NET自己有元数据，符号不需要元数据已有的信息）。
程序运行的时候，计算机只需要逐条执行指令即可。而与源代码对应的关系是完全不需要知道的。这就给调试带来了困难。
无论什么编译都有自己的一套用于对应代码和可执行程序。各种编译器都有自己保存类似这种对应关系的办法，有的直接嵌入可执行文件，有的则是独立出来的。
而微软的编译器则是独立产生了这种文件，它就被成为符号文件。
符号文件一般都是pdb文件。
pdb文件，根据微软官方的解释，包含有： 全局变量；局部变量；函数名及入口点；FPO记录；源代码行号。
3 调试寄存器机制
利用调试寄存器机制
Win操作系统提供了两种层次的进程控制和修改机制：
跨进程内存存取机制；
Debug API 监控目标进程运行信息；
这两种是运行在“操作系统”层次之上的。
自386以后，Intel公司已经在其CPU内部集成了Dr0-Dr7一共8个调试寄存器；并且对EFLAGS标志寄存器的功能也进行了扩展，使其也具有一部分调试的能力。
调试信息通知机制。
作为接收方，不能直接接收DrX调试寄存器发出来的中断/异常信息，Windows已经将这个调试信息包装到了Debug API 体系中，每当DrX调试信息被触发时，ExceptionRecord.ExceptionCode部分都被设置成EXCEPTION_SINGLE_STEP，只需要在Debug API 循环中接受这个消息就可以达到目的。
自Win2000起，CreateProcess后，没有办法在目标进程的入口点地址处中断，常见的解决办法有两种。
1 利用Single Step机制
2 利用ntdll.ntcontinue作为跳板
二 OllyDbg 简介和界面 1
OllyDbg，简称OD；www.ollydbg.de；
结合了动态调试和静态分析；
调试Ring 3级程序的首选工具；
可识别大量被C和Windows频繁使用的函数，并能将其参数注释出；
开放插件接口，功能变得越来越强；
当前默认窗口是CPU窗口，调试的大部分操作在这个窗口中进行；它包含5个面板窗口：反汇编面板，寄存器面板，信息面板，数据面板，堆栈面板；
2
OllyDbg的配置
配置在菜单Options里，有界面选项、调试选项，配置保存在ollydbg.ini文件里；
Options-Appearance-Directories，设置UDD文件和插件的路径；
UDD文件是OllyDbg的工程文件，保存当前调试的一些状态，断点、注释等；
将插件复制到目录，主菜单会出现“Plugin”菜单项；
颜色：可根据喜好设置；
调试设置：一般按默认；异常（Exceptions），可以设置让OllyDbg忽略或不忽略哪些异常；可以全选；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/27834dfe6b5fa34936f2ebfdd9f32736/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-14T20:00:35+08:00" />
<meta property="article:modified_time" content="2020-03-14T20:00:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">反汇编基础、OllyDbg简介和界面、基本操作、初级TraceMe练习</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>    以下使用的练习示例是《Windows程序设计》第五版第一章的HelloMsg.exe；以及《加密与解密》第三版附带的RebPE.exe；</p> 
<p> </p> 
<h4>一 反汇编基础</h4> 
<p>1 字节顺序</p> 
<p>字节存储顺序<br>     和CPU有关；微处理器的存放顺序有正序（Big-Endian），逆序（Little-Endian）；Intel逆序，Power-PC正序；<br>     正序：高位字节存入低地址，低位字节存入高地址；<br>     逆序：反之；</p> 
<p>十进制7869，十六进制是1EBD；<br> 看一下此数在emu8086中的存放；Intel逆序；低位字节存入低地址，高位字节存入高地址；<br> 1E是高位字节，BD是低位字节；<br> 1E存入01001单元，BD存入01000单元，逆序；</p> 
<p><img alt="" src="https://images2.imgbox.com/30/95/j9Lu9Htu_o.png"></p> 
<p>2 调试符号</p> 
<p>Windows调试基础 - 符号</p> 
<p>    当应用程序被链接以后，代码被逐一地翻译为一个个的地址。<br>     使用vs或者windbg等微软的调试工具进行调试的时候，可以方便地使用变量名来查看内存、可以使用函数名称来下断点、可以指定某个文件的某一行来下断点。<br>     这一切背后，是符号在指导调试器工作，pdb或者dbg文件。<br>   （.NET自己有元数据，符号不需要元数据已有的信息）。</p> 
<p>    程序运行的时候，计算机只需要逐条执行指令即可。而与源代码对应的关系是完全不需要知道的。这就给调试带来了困难。<br>     无论什么编译都有自己的一套用于对应代码和可执行程序。各种编译器都有自己保存类似这种对应关系的办法，有的直接嵌入可执行文件，有的则是独立出来的。<br>     而微软的编译器则是独立产生了这种文件，它就被成为符号文件。</p> 
<p>    符号文件一般都是pdb文件。<br>     pdb文件，根据微软官方的解释，包含有： 全局变量；局部变量；函数名及入口点；FPO记录；源代码行号。</p> 
<p>3 调试寄存器机制</p> 
<p>利用调试寄存器机制<br>     Win操作系统提供了两种层次的进程控制和修改机制：<br>         跨进程内存存取机制；<br>         Debug API 监控目标进程运行信息；<br>     这两种是运行在“操作系统”层次之上的。</p> 
<p>    自386以后，Intel公司已经在其CPU内部集成了Dr0-Dr7一共8个调试寄存器；并且对EFLAGS标志寄存器的功能也进行了扩展，使其也具有一部分调试的能力。</p> 
<p>    调试信息通知机制。<br>     作为接收方，不能直接接收DrX调试寄存器发出来的中断/异常信息，Windows已经将这个调试信息包装到了Debug API 体系中，每当DrX调试信息被触发时，ExceptionRecord.ExceptionCode部分都被设置成EXCEPTION_SINGLE_STEP，只需要在Debug API 循环中接受这个消息就可以达到目的。</p> 
<p>    自Win2000起，CreateProcess后，没有办法在目标进程的入口点地址处中断，常见的解决办法有两种。<br>     1 利用Single Step机制<br>     2 利用ntdll.ntcontinue作为跳板</p> 
<p> </p> 
<h4>二 OllyDbg 简介和界面</h4> 
<p>1</p> 
<p>OllyDbg，简称OD；www.ollydbg.de；<br> 结合了动态调试和静态分析；<br> 调试Ring 3级程序的首选工具；<br> 可识别大量被C和Windows频繁使用的函数，并能将其参数注释出；<br> 开放插件接口，功能变得越来越强；</p> 
<p>当前默认窗口是CPU窗口，调试的大部分操作在这个窗口中进行；它包含5个面板窗口：反汇编面板，寄存器面板，信息面板，数据面板，堆栈面板；</p> 
<p>2</p> 
<p>OllyDbg的配置<br>     配置在菜单Options里，有界面选项、调试选项，配置保存在ollydbg.ini文件里；<br>     Options-Appearance-Directories，设置UDD文件和插件的路径；<br>     UDD文件是OllyDbg的工程文件，保存当前调试的一些状态，断点、注释等；<br>     将插件复制到目录，主菜单会出现“Plugin”菜单项；<br>     颜色：可根据喜好设置；</p> 
<p>    调试设置：一般按默认；异常（Exceptions），可以设置让OllyDbg忽略或不忽略哪些异常；可以全选；</p> 
<p>    加载符号文件<br>     可以让OllyDbg以函数名显示DLL中的函数。<br>     例如MFC42.DLL是以序号输出函数，在OllyDbg显示的是序号，如果加载MFC42.DLL调试符号，则以函数名显示相关输出函数；</p> 
<p>加载程序<br>     OllyDbg可以两种方式加载目标调试程序：通过CreateProcess创建进程；利用DebugActiveProcess函数将调试器捆绑到一个正在运行的进程上；</p> 
<h4>三 工具条打开窗口</h4> 
<p> </p> 
<p>绿色一排按钮用于打开各种窗口；</p> 
<p>L：打开日志窗口；<br> E：打开可执行模块窗口；<br> M：打开内存映射窗口；<br> W：打开窗口列表；指被反汇编的程序所包含的窗口；<br> T：打开线程窗口；查看被反汇编的程序所包含的线程；<br> C：打开CPU窗口；默认打开；<br> R：打开搜索结果窗口；<br> ...：打开运行跟踪窗口；<br> K：打开调用堆栈窗口；</p> 
<p><img alt="" src="https://images2.imgbox.com/da/43/jYigMQaF_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/3c/52/5tlbSSzT_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/b1/96/07OlSYaJ_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/3b/2c/n0bzQQve_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/e6/cf/EHBHv1L6_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/02/ac/KJk9Ax4C_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/70/f0/g5hkbn2G_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/79/76/wZ0H8LFe_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/70/a1/qY1CELxC_o.png"></p> 
<h4>四 常见问题和UDD目录</h4> 
<p> </p> 
<p>OllyDbg常见问题</p> 
<p>1 跟踪程序时乱码<br>     这是因为OllyDbg将一段代码当成数据；没有进行反汇编识别；右键快捷菜单，执行 Analysis/Analyse code （分析/分析代码）；<br>     不行，则执行菜单 Analysis/Remove analysis from module (分析/从模块中删除分析)；或在UDD目录中删除相应的.udd文件；</p> 
<p>2 快速回到当前领空<br>     如果查看代码翻页到其他地方，想快速回到当前CPU所在的指令上，双击寄存器面板中的EIP或单击</p> 
<p>3 修改EIP<br>     将光标移到需要的地址；执行右键菜单 New origin here （此处新建EIP）；</p> 
<p>4 在反汇编窗口键入汇编代码，输入 push E000，提示 未知标识符<br>     不能识别E是字母还是数字；输入 push 0E000；</p> 
<p>启动函数<br> 在编写Win32 应用程序时，都必须在源码里实现一个WinMain函数；但Windows程序执行并不是从WinMain函数开始；首先被执行的是启动函数相关代码，这段代码是编译器生成的。<br> 对于VC++程序，它调用的是C/C++运行时启动函数，该函数负责对C/C++运行库进行初始化。</p> 
<p>对一个程序跟踪调试后；退出时，此处调试情况默认保存在安装目录下，xxxx.udd文件中；<br> 时间长了安装目录会乱；按图2，设置新的UDD目录；</p> 
<p><img alt="" src="https://images2.imgbox.com/a5/97/4ZYwuoAU_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/60/00/Wsx4KhOE_o.png"></p> 
<p> </p> 
<h4>五 运行代码到指定地址情况1</h4> 
<p> </p> 
<p>装载程序；<br> 在CPU窗口右击，选择 转到-表达式；<br> 输入欲运行代码到的地址；假设要运行到004011B4；点击 跟随表达式；<br> 光标定位到004011B4；<br> 打F4，（F4是运行到光标，Execute till cursor），程序运行到004011B4停住；<br><img alt="" src="https://images2.imgbox.com/08/04/k0J5Jfkm_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/f5/0c/HgMe9B7j_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/cb/0c/CWV4jLvQ_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/d7/f5/BCaGqI1b_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/b3/20/HfeE2C9z_o.png"></p> 
<h4>六 运行代码到指定地址情况2</h4> 
<p> </p> 
<p>装载程序；<br> 在CPU窗口右击，选择 转到-表达式；<br> 输入欲运行代码到的地址；假设要运行到00413033；点击 跟随表达式；<br> 光标定位到00413033；<br> 打F4，（F4是运行到光标，Execute till cursor），程序运行到75E305A0停住；<br>  </p> 
<p><img alt="" src="https://images2.imgbox.com/74/c8/RvTaJZ0i_o.png"></p> 
<p> </p> 
<p><img alt="" src="https://images2.imgbox.com/46/fd/lP8tHul9_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/15/e7/ZjJivj3h_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/04/f5/VuzyHmnS_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/c7/d0/QZi19P2N_o.png"></p> 
<h4>七 设置函数断点</h4> 
<p><br> 加载程序；</p> 
<p>在反汇编代码窗口右击；选择 搜索 - 名称；</p> 
<p>名称窗口列出此程序调用的API函数；双击要下断点的API函数；</p> 
<p>反汇编代码窗口定位到调用该API函数处；<br> 按F2设置断点；<br><img alt="" src="https://images2.imgbox.com/8b/ad/QUFgmloH_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/60/d9/88inuLvi_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/fb/41/0siUJpjF_o.png"></p> 
<h4>八 对函数设置断点以跟踪</h4> 
<p> </p> 
<p>要跟踪程序的C代码如下；</p> 
<p>#include &lt;windows.h&gt;</p> 
<p>int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,<br>                     PSTR szCmdLine, int iCmdShow)<br> {<!-- --><br>      MessageBox (NULL, TEXT ("Hello, Windows 98!"), TEXT ("HelloMsg"), 0) ;</p> 
<p>     return 0 ;<br> }</p> 
<p>装载程序；先练习跟踪MessageBox函数；<br> 打Ctrl+G，弹出对话框；输入MessageBox；<br> 点击 跟随表达式 按钮；提示要选定一个匹配项；系统dll中以MessageBox打头的函数有多个；<br> 后缀A是ASCII版本；后缀W是宽字符版本；<br> 此处选定MessageBoxA；<br> 确定；自动定位到75231F70处；看CPU窗口第四列，此处是USER32.MessageBoxA函数的地址；<br> 打F2在此行下一个断点；可以点击B按钮，查看已经对此程序下的断点；有2个，一个是前次下的；<br> 现在只跟踪MessageBoxA，禁用另一个断点；在断点上右击弹出菜单即可禁用；<br> 打F9运行程序；中断在75231F70处；</p> 
<p><img alt="" src="https://images2.imgbox.com/32/a0/Ew9piqwa_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/bf/ca/eZ1AA0Co_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/cc/14/Tyaxtt3V_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/82/4b/KewQ5iqR_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/33/ad/GGcXEeZv_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/c0/79/aCfDWzQG_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/13/eb/C5POgpWg_o.png"></p> 
<h4>九 反汇编单步步进和单步步过</h4> 
<p> </p> 
<p>OllyDbg<br>     F7，单步步进，遇到Call跟进；<br>     F8，单步步过，遇到Call跳过；</p> 
<p>加载HelloMsg.exe；<br> 停留在004011C0；这是一条Call语句；Call的地址是004027BC；<br> 打F7，代码运行到地址004027BC处；</p> 
<p>重新加载程序；停留在004011C0；<br> 打F8，程序运行到下一条，地址004011C5处；没有跟进Call；</p> 
<p><img alt="" src="https://images2.imgbox.com/ce/94/eyL5XfBy_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/cb/e2/0DB6LLM3_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/49/d6/Icbii2sX_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/da/62/kWXCWBf5_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/c3/97/84XU05aA_o.png"></p> 
<h4>十 反汇编从call中返回</h4> 
<p> </p> 
<p>加载程序；停留在004011C0；<br> 打F7单步步进，跳到004027BC；<br> 执行数次F7，程序运行到004027C1；<br> 现在想从此call中返回；打Ctrl+F9，执行到返回（Execute till return）；OllyDbg会停在遇到的第一个返回命令（RET、RETF、IRET）；在此是 00402851;</p> 
<p><img alt="" src="https://images2.imgbox.com/32/81/XpEudSMc_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/ce/97/kIoZpIWD_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/d7/a3/5fI8b83Y_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/f9/04/v7uLX2er_o.png"></p> 
<h4>十一 对代码段设置断点</h4> 
<p> </p> 
<p>Ollydbg可以对代码段设置断点；<br> 加载程序；<br> 按 Alt+M 打开内存模板；对代码段，此处是.text区块，按F2键，设置内存访问断点；<br> 运行程序；中断在图2；<br><img alt="" src="https://images2.imgbox.com/3e/63/OoNfhc1C_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/d8/42/LUbYpHxZ_o.png"></p> 
<h4>十二 反汇编从系统地址空间返回应用程序领空</h4> 
<p> </p> 
<p>运行程序；按前述进入到系统地址空间，76F805A0；<br> 看右侧寄存器窗口，此地址处是系统dll，KERNEL32.dll；<br> 打F7往前走几步；运行到76F805A8；<br> Windows程序的内存布局中，7XXXXXXX通常是系统地址空间；0040XXXX通常是应用程序地址；<br> 现在想返回应用程序地址空间；打Alt+F9；<br> 程序返回到00402443；</p> 
<p><img alt="" src="https://images2.imgbox.com/95/25/pCdKur73_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/ce/e8/nLx5zNa8_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/76/ab/oJiYac3n_o.png"></p> 
<h4>十三 初级TraceMe练习</h4> 
<p> </p> 
<p>Win32 API 的GetDlgItemTextA函数获取窗口上控件的文本；跟踪此函数有可能获取到密码；</p> 
<p>这是根据《加密与解密》第三版第2章所做的练习；使用的示例程序是原书附带的TraceMe.exe；</p> 
<p> </p> 
<p>操作细节只有2个地方和原书不一样；</p> 
<p>一个是ollydbg，右击eax寄存器查看数据窗口时，非汉化版本的菜单是 Follow in Dump ，汉化版的菜单是 在转储跟随 ；<br> 一个是1.x版本，改变一条指令为nop空指令，是手动输入nop；2.x版本已经在右键菜单中集成此功能，无需手动输入nop；</p> 
<p>ollydbg版本不同，生成的反汇编注释略有差别；</p> 
<p>1 装载程序；<br> 2 对 GetDlgItemTextA 函数设置断点；<br> 3 在程序窗口输入用户名pediy，随便输入个密码；点 check 按钮；<br> 4 程序中断在 GetDlgItemTextA 函数地址处；此处是 752468C0；</p> 
<p>5 打Alt+F9回到调用函数的地方；004011B6；<br> 先禁用 GetDlgItemTextA 断点；<br> 6 为了方便反复跟踪；在004011AE处下一个断点；</p> 
<p>API 函数基本采用__stdcall调用约定：函数入口参数按从右到左的顺序入栈，由被调用者清理栈中参数，返回值放在eax寄存器中；调用API前的push指令，这些push指令将参数放进堆栈以传给API调用；</p> 
<p>C代码中的子程序采用C调用约定：函数入口参数按从右到左的顺序入栈，由调用者清理栈中的参数；</p> 
<p>GetDlgItemTextA函数，第一个参数是对话框句柄，第二个参数是控件标识（id），第三个参数是文本缓冲区指针，第四个参数是最大字符数；</p> 
<p>7 push 51 ...... push esi，这四句是把调用GetDlgItemTextA需要的参数压入堆栈；</p> 
<p>8 打F8，使程序运行到004011B0停住；在寄存器窗口右击EAX，在菜单选择 在转储跟随；<br> 9,10 EAX内容为 0019F790，数据窗口定位到0019F790；此时数据窗口没有什么有价值的；ASCII是些乱码；</p> 
<p>11 打F8，执行完CALL EDI一句；即调用了GetDlgItemTextA函数；获取了用户在对话框输入的内容；<br> 此时用户输入的用户名，字符串pediy，出现在数据窗口；</p> 
<p>12 004011E5 到 004011F5，这段是序列号的判断核心，最后一句跳转语句不跳转，即可注册成功；</p> 
<p>13 使程序运行到004011F5停住；</p> 
<p>14 此时可以在寄存器窗口，Z标志，右击，选择菜单 切换，改变Z标志的值为1或0，来判断；</p> 
<p>15，16 或者；右击004011F5，选择如图15菜单；把此句跳转指令改为NOP，空指令；</p> 
<p>17 改为空指令后，判断语句失效；随便输入的密码注册成功；</p> 
<p>TraceMe先进行到此；密码尚未破解；下回再搞；</p> 
<p><img alt="" src="https://images2.imgbox.com/ca/72/GyA3cAQo_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/d9/32/V0LaWmFe_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/e6/2c/orlRQu7Z_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/6d/bf/qfsjfcqN_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/f4/d3/gvnAwq0T_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/11/ef/7ePdo7v2_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/0b/f4/MT5BlDLN_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/5d/d4/KXVrDjIs_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/7e/5e/PpGQqv1X_o.png"></p> 
<p><img alt="" height="149" src="https://images2.imgbox.com/bb/d3/gzNpcS5P_o.png" width="460"></p> 
<p><img alt="" src="https://images2.imgbox.com/c2/1e/iorIIvQf_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/49/3f/Ppq8WM8N_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/46/cf/arkQQgJh_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/2e/40/aHXoY5Vq_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/10/8b/XUucRfQK_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/49/74/vcI5TeJC_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/b7/ad/Ys6yFtME_o.png"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5665c09e7fed8b4c5462c0ce41e8e405/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Leectcode417太平洋大西洋水流问题_med_C&#43;&#43;</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/09e925e55fde8104ceb5cdb0ce613b85/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【信号与系统】3. 阶跃函数、冲激函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>