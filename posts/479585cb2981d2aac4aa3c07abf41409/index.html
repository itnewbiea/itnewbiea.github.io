<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一个 Qml MenuBar 的问题 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一个 Qml MenuBar 的问题" />
<meta property="og:description" content="基本情况 使用 QQuick.Control 中的 MenuBar 实现主菜单栏。菜单栏包括 File、Edit、View、Help 菜单项。点击菜单项，会弹出对应的菜单。
ApplicationWindow { id: window width: 320 height: 260 visible: true menuBar: MenuBar { Menu { title: qsTr(&#34;&amp;File&#34;) Action { text: qsTr(&#34;&amp;New...&#34;) } Action { text: qsTr(&#34;&amp;Open...&#34;) } Action { text: qsTr(&#34;&amp;Save&#34;) } Action { text: qsTr(&#34;Save &amp;As...&#34;) } MenuSeparator { } Action { text: qsTr(&#34;&amp;Quit&#34;) } } Menu { title: qsTr(&#34;&amp;Edit&#34;) Action { text: qsTr(&#34;Cu&amp;t&#34;) } Action { text: qsTr(&#34;&amp;Copy&#34;) } Action { text: qsTr(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/479585cb2981d2aac4aa3c07abf41409/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-05T10:41:35+08:00" />
<meta property="article:modified_time" content="2023-01-05T10:41:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一个 Qml MenuBar 的问题</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>基本情况</h2> 
<p>使用 QQuick.Control 中的 MenuBar 实现主菜单栏。菜单栏包括 File、Edit、View、Help 菜单项。点击菜单项，会弹出对应的菜单。</p> 
<pre><code class="language-cpp">ApplicationWindow {
    id: window
    width: 320
    height: 260
    visible: true

    menuBar: MenuBar {
        Menu {
            title: qsTr("&amp;File")
            Action { text: qsTr("&amp;New...") }
            Action { text: qsTr("&amp;Open...") }
            Action { text: qsTr("&amp;Save") }
            Action { text: qsTr("Save &amp;As...") }
            MenuSeparator { }
            Action { text: qsTr("&amp;Quit") }
        }
        Menu {
            title: qsTr("&amp;Edit")
            Action { text: qsTr("Cu&amp;t") }
            Action { text: qsTr("&amp;Copy") }
            Action { text: qsTr("&amp;Paste") }
        }
        Menu {
            title: qsTr("&amp;Help")
            Action { text: qsTr("&amp;About") }
        }
    }
}</code></pre> 
<p>流程1：点击菜单栏上的菜单项，该菜单项被激活（弹出），再次点击该菜单项，菜单项退出激活状态。</p> 
<p><img alt="" height="221" src="https://images2.imgbox.com/8a/ec/HiYjCfhI_o.png" width="272"><img alt="" height="220" src="https://images2.imgbox.com/c6/91/brtrkYr5_o.png" width="301"></p> 
<p>流程2：如果在激活状态，移动鼠标到另一个菜单项，自动激活（不需要点击）另一个菜单项，当前激活的菜单项退出激活状态。</p> 
<p><img alt="" height="221" src="https://images2.imgbox.com/ec/86/htAnNiba_o.png" width="272"><img alt="" height="219" src="https://images2.imgbox.com/28/10/0ncHQ7oY_o.png" width="274"></p> 
<p>以上都符合预期，但是问题来了。</p> 
<h2>问题现象</h2> 
<p>流程3：在弹出的菜单上，点击某一个项目，弹出菜单消失，但是对应的菜单项并没有退出激活状态。</p> 
<p><img alt="" height="221" src="https://images2.imgbox.com/31/6e/oqH5Je10_o.png" width="272"><img alt="" height="219" src="https://images2.imgbox.com/3d/4c/B9QReFM7_o.png" width="258"></p> 
<h2>尝试解决</h2> 
<p>首先想到的方法，就是针对性处理。在弹出菜单消失时，触发菜单项状态切换。</p> 
<pre><code class="language-javascript">        delegate: MenuBarItem {
            id: menuBarItem

            property bool opened: menu.opened
            onOpenedChanged: {
                if (!opened &amp;&amp; highlighted) {
                    highlighted = false
                    triggered()
                }
            }
        }</code></pre> 
<p>实测流程3是OK了，但是流程1有问题了。在激活状态，再次点击菜单项，没有退出激活状态。</p> 
<h2>代码分析</h2> 
<p>看来只能分析源代码了。相同的思路，其实源代码里面已经实现了。</p> 
<p>注意下面代码的 aboutToHide 一行，在弹出菜单将要消失时，是有处理的。</p> 
<pre><code class="language-cpp">void QQuickMenuBar::itemAdded(int index, QQuickItem *item)
{
    Q_D(QQuickMenuBar);
    QQuickContainer::itemAdded(index, item);
    if (QQuickMenuBarItem *menuBarItem = qobject_cast&lt;QQuickMenuBarItem *&gt;(item)) {
        QQuickMenuBarItemPrivate::get(menuBarItem)-&gt;setMenuBar(this);
        QObjectPrivate::connect(menuBarItem, &amp;QQuickControl::hoveredChanged, d, &amp;QQuickMenuBarPrivate::onItemHovered);
        QObjectPrivate::connect(menuBarItem, &amp;QQuickMenuBarItem::triggered, d, &amp;QQuickMenuBarPrivate::onItemTriggered);
        if (QQuickMenu *menu = menuBarItem-&gt;menu())
            QObjectPrivate::connect(menu, &amp;QQuickPopup::aboutToHide, d, &amp;QQuickMenuBarPrivate::onMenuAboutToHide);
    }
    d-&gt;updateImplicitContentSize();
    emit menusChanged();
}
</code></pre> 
<p>菜单栏里面维护了激活状态（即 popupMode 为 true），菜单消失时，退出激活状态。</p> 
<pre><code class="language-cpp">void QQuickMenuBarPrivate::onMenuAboutToHide()
{
    if (triggering || !currentItem || (currentItem-&gt;isHovered() &amp;&amp; currentItem-&gt;isEnabled()) || !currentItem-&gt;isHighlighted())
        return;
    popupMode = false;
    activateItem(nullptr);
}</code></pre> 
<p>那为什么没有生效呢？通过调试，发现上面的代码 menu 是空指针，所以没有与 aboutToHide 信号连接。调用栈如下：</p> 
<pre><code class="language-javascript">1   QQuickMenuBar::itemAdded              qquickmenubar.cpp       534  0x7ffc9884f04f 
2   QQuickContainerPrivate::insertItem    qquickcontainer.cpp     250  0x7ffc98814a3b 
3   QQuickContainer::insertItem           qquickcontainer.cpp     532  0x7ffc98813378 
4   QQuickContainer::addItem              qquickcontainer.cpp     507  0x7ffc9881327c 
5   QQuickContainer::itemChange           qquickcontainer.cpp     865  0x7ffc98813da0 
6   QQuickItemPrivate::itemChange         qquickitem.cpp          6231 0x7ffc7b509ed7 
7   QQuickItemPrivate::addChild           qquickitem.cpp          2976 0x7ffc7b505cf3 
8   QQuickItem::setParentItem             qquickitem.cpp          2765 0x7ffc7b4f699c 
9   QQuickMenuBarPrivate::beginCreateItem qquickmenubar.cpp       100  0x7ffc9884f6d8 
10  QQuickMenuBarPrivate::createItem      qquickmenubar.cpp       115  0x7ffc9884f768 
11  QQuickMenuBar::addMenu                qquickmenubar.cpp       341  0x7ffc9884e9cc 
12  QQuickMenuBar::qt_static_metacall     moc_qquickmenubar_p.cpp 131  0x7ffc9884e30d 
13  QQuickMenuBar::qt_metacall            moc_qquickmenubar_p.cpp 230  0x7ffc9884e0f9 
14  QMetaObject::metacall                 qmetaobject.cpp         310  0x7ffc5d08dcb4 
15  QQmlObjectOrGadget::metacall          qqmlpropertycache.cpp   1772 0x7ffc7140ed1b 
16  CallMethod                            qv4qobjectwrapper.cpp   1297 0x7ffc711c923e 
17  CallPrecise                           qv4qobjectwrapper.cpp   1557 0x7ffc711c9f56 
18  QV4::QObjectMethod::callInternal      qv4qobjectwrapper.cpp   2118 0x7ffc711c63da 
19  QV4::QObjectMethod::virtualCall       qv4qobjectwrapper.cpp   2056 0x7ffc711c5eeb 
20  QV4::FunctionObject::call             qv4functionobject_p.h   203  0x7ffc70f8a031 
... &lt;更多&gt;                                                                              
</code></pre> 
<p>为什么 menu 是空的呢，原来 itemAdded 调用得比较早，这个时候还没有 setMenu。下面的代码（Qt 5.12.4） beginCreateItem 会调用 setParentItem，此时就触发了 itemAdded。</p> 
<pre><code class="language-cpp">QQuickItem *QQuickMenuBarPrivate::createItem(QQuickMenu *menu)
{
    QQuickItem *item = beginCreateItem();
    if (QQuickMenuBarItem *menuBarItem = qobject_cast&lt;QQuickMenuBarItem *&gt;(item))
        menuBarItem-&gt;setMenu(menu);
    completeCreateItem();
    return item;
}
</code></pre> 
<p> 后来看到一个比较新的 Qt5 代码，这个问题就是修复了的。他将 setMenu 放在了更前面。</p> 
<pre><code class="language-cpp">QQuickItem *QQuickMenuBarPrivate::beginCreateItem(QQuickMenu *menu)
{
    ......
    if (QQuickMenuBarItem *menuBarItem = qobject_cast&lt;QQuickMenuBarItem *&gt;(item))
        menuBarItem-&gt;setMenu(menu);
    item-&gt;setParentItem(q);
    QQml_setParent_noEvent(item, q);
    return item;
}</code></pre> 
<h2>解决方案</h2> 
<p>如果不升级 Qt，有没有办法解决这个问题呢？</p> 
<p>其实只要将 MenuItem 重新添加到 MenuBar 中就行了，这个时候 menu 就不是空的了。</p> 
<p>看代码：</p> 
<pre><code class="language-javascript">    MenuBar {
        id: menuBar

        delegate: MenuBarItem {
            id: menuBarItem

            onMenuChanged: {
                // MenuBar has BUG on addMenu, it can't detach menu on MenuBarItem which is set later
                //  Re-add the item to fix the BUG
                menuBar.addItem(menuBar.takeItem(menuBar.count - 1))
            }
        }
    }

</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f88e99f96f28a3474db71a058f74dff8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">GitHub 2022 的趋势和见解（JavaScript 连续四年摘得桂冠，Python 成为后端最常用的语言）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/44b2974d840edeb556fc1cdad28fedc3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">简单易懂的隐马尔可夫模型（HMM）讲解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>