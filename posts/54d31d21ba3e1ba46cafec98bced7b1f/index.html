<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>carla中lka实现(二) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="carla中lka实现(二)" />
<meta property="og:description" content="前言： 首先计算之前检测出来的车道线的中线与输入图像的中线进行计算距离，，并设置不同的阈值对于不同的方向进行相关的调整。
一、车辆中心线 一般而言将摄像头架设在车辆的正中心轴上，所获得的图像的中间线极为车辆的中心。
def CalculateCurvature(binary_image, left_fit, right_fit, l_lane_inds, r_lane_inds): img_size = (binary_image.shape[1], binary_image.shape[0]) ploty = np.linspace(0, img_size[1]-1, img_size[1]) y_eval = np.max(ploty) # 找到图像中不为零的所有像素点的像素坐标 nonzero = binary_image.nonzero() nonzeroy = np.array(nonzero[0]) nonzerox = np.array(nonzero[1]) # 将这些不为零的像素点坐标分成x，y车道线中 leftx = nonzerox[l_lane_inds] lefty = nonzeroy[l_lane_inds] rightx = nonzerox[r_lane_inds] righty = nonzeroy[r_lane_inds] # 将这些像素点对应到世界坐标系中，然后拟合成二次曲线 left_fit_cr = np.polyfit(lefty, leftx*xm_per_pix, 2) right_fit_cr = np.polyfit(righty, rightx*xm_per_pix, 2) ## 以下计算本车在车道线中心的位置 dist_from_center = 0.0 if right_fit is not None: if left_fit is not None: # 摄像头位于图像中间，也是本车的中心 camera_pos = img_size[0] / 2 # 左右车道线最底端x坐标 left_lane_pix = np." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/54d31d21ba3e1ba46cafec98bced7b1f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-18T20:32:10+08:00" />
<meta property="article:modified_time" content="2023-08-18T20:32:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">carla中lka实现(二)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言：</h2> 
<p>首先计算之前检测出来的车道线的中线与输入图像的中线进行计算距离，，并设置不同的阈值对于不同的方向进行相关的调整。</p> 
<h2>一、车辆中心线</h2> 
<p>一般而言将摄像头架设在车辆的正中心轴上，所获得的图像的中间线极为车辆的中心。</p> 
<pre><code class="language-python">def CalculateCurvature(binary_image, left_fit, right_fit, l_lane_inds, r_lane_inds):

    img_size = (binary_image.shape[1], binary_image.shape[0])
    ploty = np.linspace(0, img_size[1]-1, img_size[1])
    y_eval = np.max(ploty)
  
  # 找到图像中不为零的所有像素点的像素坐标
    nonzero = binary_image.nonzero()
    nonzeroy = np.array(nonzero[0])
    nonzerox = np.array(nonzero[1])
    # 将这些不为零的像素点坐标分成x，y车道线中
    leftx = nonzerox[l_lane_inds]
    lefty = nonzeroy[l_lane_inds] 
    rightx = nonzerox[r_lane_inds]
    righty = nonzeroy[r_lane_inds]
    # 将这些像素点对应到世界坐标系中，然后拟合成二次曲线
    left_fit_cr = np.polyfit(lefty, leftx*xm_per_pix, 2)
    right_fit_cr = np.polyfit(righty, rightx*xm_per_pix, 2) 

## 以下计算本车在车道线中心的位置
    dist_from_center = 0.0
    if right_fit is not None:
        if left_fit is not None:
            # 摄像头位于图像中间，也是本车的中心
            camera_pos = img_size[0] / 2
        # 左右车道线最底端x坐标
            left_lane_pix = np.polyval(left_fit, binary_image.shape[0])
            right_lane_pix = np.polyval(right_fit, binary_image.shape[0])
        # 左右车道线中点x坐标
            center_of_lane_pix = (left_lane_pix + right_lane_pix) / 2
        # 摄像头（本车中心）与车道线中心的距离
            dist_from_center = (camera_pos - center_of_lane_pix) * 3.7/960
    return dist_from_center</code></pre> 
<p>其中返回的dist_from_center是车辆中心线和车道线中心线之间的距离。</p> 
<h2>二、输出显示距离</h2> 
<p>在Carla中生成一辆车，并在车辆中心线位置生成一个相机，采集图像信息，首先在车辆中心线上生成一一条线，并显示出来。</p> 
<p>直接取图像的size然后设置起点和终点，</p> 
<p>使用函数cv2.line就可以，</p> 
<pre><code class="language-python">results = cv2.line(results, start_point, end_point, line_color, thickness)</code></pre> 
<p>这个是在图像正中间画上一条线。</p> 
<p>然后再在识别出的车道线正中间画上一条线</p> 
<p>之前写的函数lane_position会返回左边和右边的车道线的点，</p> 
<p>取这两个点然后算平均值，</p> 
<pre><code class="language-python">        lanes_pos = lane_position(img_histogram)
        l1 = lanes_pos[0][0]
        r1 = lanes_pos[1][0]
        p1 = int((l1 + r1) / 2)
        start_point1 = (p1, 0)
        end_point1 = (p1, int(height))</code></pre> 
<p>最后输出结果：</p> 
<p class="img-center"><img alt="" height="1108" src="https://images2.imgbox.com/25/3d/isQbvCQQ_o.png" width="1200"></p> 
<p> 红线是图像的中心线，黄线是车道线的中心线。</p> 
<p>之后的步骤就是直接用它们两个之间的距离来计算控制车辆左转和右转。</p> 
<h2>三、车辆控制</h2> 
<p>在Carla中生成一辆车，中心线上搭载相机，Carla中有两种相机可以选择，一种是普通的RGB相机，另外一种是直接有的语义分割相机，选择语义分割相机简单简单很多。</p> 
<p>注意Carla中输出的是图像的格式是png格式，这会有一个问题，是它rgb通道会归一化，所以输出为0.8到1之间，大坑卡了我很久。</p> 
<p>原始图像：</p> 
<p class="img-center"><img alt="" height="490" src="https://images2.imgbox.com/ea/26/FQHef354_o.png" width="606"></p> 
<p>通过rgb图像旋转输出的图像：</p> 
<p class="img-center"><img alt="" height="535" src="https://images2.imgbox.com/21/22/XYM2KbQc_o.png" width="583"></p> 
<p><strong>tmd，4通道图象第四列全部设置为1才行！卡我很久</strong></p> 
<p><strong>最好直接把第4列去除，方便！</strong></p> 
<p>融合sobel和rgb信息后输出：</p> 
<p><img alt="" height="535" src="https://images2.imgbox.com/fc/be/JQ0dH1SR_o.png" width="631"></p> 
<p> 然后选择感兴趣的区域：</p> 
<p><img alt="" height="505" src="https://images2.imgbox.com/da/c5/64nl23uU_o.png" width="595"></p> 
<p> 透视变换：</p> 
<p>找到点为：</p> 
<pre><code class="language-python">    top_left =[1000,700]
    top_right = [1374,700]
    bottom_left = [330,1100]
    bottom_right =  [2000,1100]
    # give 4 points to project.
    proj_top_left = [200,100]
    proj_top_right = [2200,100]
    proj_bottom_left  =  [200,1100]
    proj_bottom_right =  [2200,1100]</code></pre> 
<p><img alt="" height="514" src="https://images2.imgbox.com/e4/4b/6FAvlsoQ_o.png" width="606"></p> 
<p> 直方图输出：</p> 
<p><img alt="" height="551" src="https://images2.imgbox.com/03/18/MJGMjSjo_o.png" width="631"></p> 
<p> 滑动窗口输出：<br><img alt="" height="518" src="https://images2.imgbox.com/b6/83/ac9RptYF_o.png" width="604"></p> 
<p> 曲线拟合：<br><img alt="" height="540" src="https://images2.imgbox.com/fa/30/Um2wQF3X_o.png" width="609"></p> 
<p> 添加图层蒙版：</p> 
<p><img alt="" height="534" src="https://images2.imgbox.com/ae/6d/H08MJU2c_o.png" width="624"></p> 
<p>未完待续。。。</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6ce6a9eecc2066b14c6d67d5715186dc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C语言】每日一题（找到所有数组中消失的数字）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/95d4b724ff54c258db891bd45c88ce77/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何在HTML中使用React</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>