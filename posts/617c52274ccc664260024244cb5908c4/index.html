<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43; auto类型用法总结 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43; auto类型用法总结" />
<meta property="og:description" content="一、用途 auto是c&#43;&#43;程序设计语言的关键字。用于两种情况
（1）声明变量时根据初始化表达式自动推断该变量的类型
（2）声明函数时函数返回值的占位符
二、简要理解 auto可以在声明变量时根据变量初始值的类型自动为此变量选择匹配的类型。
举例：对于值x=1；既可以声明： int x=1 或 long x=1，也可以直接声明 auto x=1
三、用法 根据初始化表达式自动推断被声明的变量的类型，如：
auto f = 3.14; //double auto s(&#34;hello&#34;); //const char* auto z = new auto(9); //int * auto x1 = 5, x2 = 5.0, x3 = &#39;r&#39;; //错误，必须是初始化为同一类型 但是，这么简单的变量声明类型，不建议用auto关键字，而是应更清晰地直接写出其类型。
auto关键字更适用于类型冗长复杂、变量使用范围专一时，使程序更清晰易读。如：
std::vector&lt;int&gt; vect; for(auto it = vect.begin(); it != vect.end(); &#43;&#43;it) { //it的类型是std::vector&lt;int&gt;::iterator std::cin &gt;&gt; *it; } 或者保存lambda表达式类型的变量声明：
auto ptr = [](double x){return x*x;};//类型为std::function&lt;double(double)&gt;函数对象 四、优势 （1）拥有初始化表达式的复杂类型变量声明时简化代码。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/617c52274ccc664260024244cb5908c4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-23T10:07:13+08:00" />
<meta property="article:modified_time" content="2021-09-23T10:07:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43; auto类型用法总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、用途</h3> 
<p>auto是c++程序设计语言的关键字。用于两种情况</p> 
<p>（1）声明变量时根据初始化表达式自动推断该变量的类型</p> 
<p>（2）声明函数时函数返回值的占位符</p> 
<p></p> 
<h3>二、简要理解</h3> 
<p>auto可以在声明变量时根据变量初始值的类型自动为此变量选择匹配的类型。</p> 
<p>举例：对于值x=1；既可以声明： int x=1 或 long x=1，也可以直接声明 auto x=1</p> 
<h3><br> 三、用法</h3> 
<p>根据初始化表达式自动推断被声明的变量的类型，如：</p> 
<pre><code>auto f = 3.14;  //double
auto s("hello");  //const char*
auto z = new auto(9);  //int *
auto x1 = 5, x2 = 5.0, x3 = 'r';   //错误，必须是初始化为同一类型</code></pre> 
<p>但是，这么简单的变量声明类型，不建议用auto关键字，而是应更清晰地直接写出其类型。</p> 
<p><br> auto关键字更适用于类型冗长复杂、变量使用范围专一时，使程序更清晰易读。如：</p> 
<pre><code> std::vector&lt;int&gt; vect; 
 for(auto it = vect.begin(); it != vect.end(); ++it)
 {  //it的类型是std::vector&lt;int&gt;::iterator
    std::cin &gt;&gt; *it;
  }</code></pre> 
<p><br> 或者保存lambda表达式类型的变量声明：</p> 
<pre><code>  auto ptr = [](double x){return x*x;};//类型为std::function&lt;double(double)&gt;函数对象</code></pre> 
<h3><br> 四、优势</h3> 
<p>（1）拥有初始化表达式的复杂类型变量声明时简化代码。</p> 
<p>比如：</p> 
<pre><code>#include &lt;string&gt;  
#include &lt;vector&gt;  
void loopover(std::vector&lt;std::string&gt;&amp;vs)  
{  
    std::vector&lt;std::string&gt;::iterator i=vs.begin();  
    for(;i&lt;vs.end();i++)  
    {  
      
    }  
  
}</code></pre> 
<p>变为：</p> 
<pre><code>#include &lt;string&gt;  
#include &lt;vector&gt;  
void loopover(std::vector&lt;std::string&gt;&amp;vs)  
{  
    for(  auto i=vs.begin();;i&lt;vs.end();i++)  
    {  
      
    }  
  
}  </code></pre> 
<p>使用std::vector&lt;std::string&gt;::iterator来定义i是C++常用的良好的习惯，但是这样长的声明带来了代码可读性的困难，因此引入auto，使代码可读性增加。并且使用STL将会变得更加容易</p> 
<p><br> （2）可以避免类型声明时的麻烦而且避免类型声明时的错误。</p> 
<p>但是auto不能解决所有的精度问题。比如：</p> 
<pre><code>#include &lt;iostream&gt;  
using namespace std;  
int main()  
{  
   unsigned int a=4294967295;//最大的unsigned int值  
   unsigned int b=1；  
   auto c=a+b;  
   cout&lt;&lt;"a="&lt;&lt;a&lt;&lt;endl;  
   cout&lt;&lt;"b="&lt;&lt;b&lt;&lt;endl;  
   cout&lt;&lt;"c="&lt;&lt;c&lt;&lt;endl;  
}  </code></pre> 
<p>上面代码中，程序员希望通过声明变量c为auto就能解决a+b溢出的问题。而实际上由于a+b返回的依然是unsigned int的值，姑且c的类型依然被推导为unsigned int，auto并不能帮上忙。这个跟动态类型语言中数据hi自动进行拓展的特性还是不一样的。</p> 
<h3><br> 五、注意的地方</h3> 
<p>（1）可以用valatile，pointer（*），reference（&amp;），rvalue reference（&amp;&amp;） 来修饰auto</p> 
<pre><code>auto k = 5;  
auto* pK = new auto(k);  
auto** ppK = new auto(&amp;k);  
const auto n = 6;  </code></pre> 
<p><br> （2）用auto声明的变量必须初始化</p> 
<p>（3）auto不能与其他类型组合连用</p> 
<p>（4）函数和模板参数不能被声明为auto</p> 
<p>（5）定义在堆上的变量，使用了auto的表达式必须被初始化</p> 
<p></p> 
<pre><code>int* p = new auto(0); //fine  
int* pp = new auto(); // should be initialized  
auto x = new auto(); // Hmmm ... no intializer  
auto* y = new auto(9); // Fine. Here y is a int*  
auto z = new auto(9); //Fine. Here z is a int* (It is not just an int)  </code></pre> 
<p><br> （6）以为auto是一个占位符，并不是一个他自己的类型，因此不能用于类型转换或其他一些操作，如sizeof和typeid</p> 
<p>（7）定义在一个auto序列的变量必须始终推导成同一类型</p> 
<p>auto x1 = 5, x2 = 5.0, x3='r';  /&lt;span style="font-family: Arial, Helvetica, sans-serif;"&gt;/错误，必须是初始化为同一类型&lt;/span&gt;</p> 
<p><br> （8）auto不能自动推导成CV-qualifiers (constant &amp; volatile qualifiers)</p> 
<p>（9）auto会退化成指向数组的指针，除非被声明为引用<br> ————————————————<br> 版权声明：本文为CSDN博主「小拳头」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：https://blog.csdn.net/xiaoquantouer/article/details/51647865</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c08234a0ecdcaf46b4c8237f8be332ae/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">维护华为服务器的好工具KVM</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8318a7b35ad4569aadcda1355fa8d92b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">OpenStack组件之Nova</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>