<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Linux】基础IO——系统文件IO&amp;fd&amp;重定向&amp;理解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Linux】基础IO——系统文件IO&amp;fd&amp;重定向&amp;理解" />
<meta property="og:description" content="文章目录 一、回顾C文件接口1.打开和关闭2.读写文件3.细节 二、系统文件I/O 1.open和closeumask小细节 2.read和write1.write2.read3.小总结 三、理解文件四、文件描述符fd1.引入2.理解3.分配规则4.close(1)问题 五、重定向1.重定向2.接口3.追加重定向4.输入重定向 六、Linux一切皆文件 一、回顾C文件接口 1.打开和关闭 对于C语言的文件操作，首先我们需要打开（fopen）文件，打开失败将会返回NULL ，而打开成功则返回文件的指针（FILE*）
最后我们则需要关闭（fclose）文件。
FILE *fopen(char *filename, char *mode) filename为文件名（包括文件路径），mode为打开方式，它们都是字符串
int fclose(FILE *stream) stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了要被关闭的流。
下面我们用C语言来实现打开和关闭文件：
2.读写文件 我们可以通过fgets和fputs以字符串形式进行读写，也可以通过fprint和fscanf进行格式化读写
int fputs (const char * str, FILE * stream ); char * fgets (char * str, int num, FILE * stream ); int fprintf (FILE * stream, const char * format, ... ); int fscanf (FILE * stream, const char * format, ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d6717266c8471ad1f68802a2177b0c61/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-25T15:39:22+08:00" />
<meta property="article:modified_time" content="2022-12-25T15:39:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Linux】基础IO——系统文件IO&amp;fd&amp;重定向&amp;理解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#font_color___RedCfont_1" rel="nofollow"><font color="Red">一、回顾C文件接口</font></a></li><li><ul><li><a href="#1_3" rel="nofollow">1.打开和关闭</a></li><li><a href="#2_25" rel="nofollow">2.读写文件</a></li><li><a href="#3_68" rel="nofollow">3.细节</a></li></ul> 
   </li><li><a href="#font_color___RedIO__font_90" rel="nofollow"><font color="Red">二、系统文件I/O </font></a></li><li><ul><li><a href="#1openclose_96" rel="nofollow">1.open和close</a></li><li><ul><li><a href="#umask_156" rel="nofollow">umask小细节</a></li></ul> 
    </li><li><a href="#2readwrite_168" rel="nofollow">2.read和write</a></li><li><ul><li><a href="#1write_170" rel="nofollow">1.write</a></li><li><a href="#2read_279" rel="nofollow">2.read</a></li><li><a href="#3_306" rel="nofollow">3.小总结</a></li></ul> 
   </li></ul> 
   </li><li><a href="#font_color___Redfont_319" rel="nofollow"><font color="Red">三、理解文件</font></a></li><li><a href="#font_color___Redfdfont_365" rel="nofollow"><font color="Red">四、文件描述符fd</font></a></li><li><ul><li><ul><li><a href="#1_367" rel="nofollow">1.引入</a></li><li><a href="#2_383" rel="nofollow">2.理解</a></li><li><a href="#3_395" rel="nofollow">3.分配规则</a></li><li><a href="#4close1_409" rel="nofollow">4.close(1)问题</a></li></ul> 
   </li></ul> 
   </li><li><a href="#font_color___Redfont_432" rel="nofollow"><font color="Red">五、重定向</font></a></li><li><ul><li><ul><li><a href="#1_434" rel="nofollow">1.重定向</a></li><li><a href="#2_444" rel="nofollow">2.接口</a></li><li><a href="#3_458" rel="nofollow">3.追加重定向</a></li><li><a href="#4_464" rel="nofollow">4.输入重定向</a></li></ul> 
   </li></ul> 
   </li><li><a href="#font_color___RedLinuxfont_474" rel="nofollow"><font color="Red">六、Linux一切皆文件</font></a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="font_color___RedCfont_1"></a><font color="Red">一、回顾C文件接口</font></h3> 
<h4><a id="1_3"></a>1.打开和关闭</h4> 
<p>对于C语言的文件操作，首先我们需要打开（fopen）文件，打开失败将会返回NULL ，而打开成功则返回文件的指针（FILE*）</p> 
<p>最后我们则需要关闭（fclose）文件。</p> 
<pre><code class="prism language-c++">FILE *fopen(char *filename, char *mode)
</code></pre> 
<p><code>filename</code>为文件名（包括文件路径），<code>mode</code>为打开方式，它们都是字符串</p> 
<pre><code class="prism language-c++">int fclose(FILE *stream)
</code></pre> 
<p><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象指定了要被关闭的流。</p> 
<p>下面我们用C语言来实现打开和关闭文件：</p> 
<p><img src="https://images2.imgbox.com/86/d5/wOOgdoux_o.png" alt="image-20221214231013245"></p> 
<h4><a id="2_25"></a>2.读写文件</h4> 
<p>我们可以通过fgets和fputs以字符串形式进行读写，也可以通过fprint和fscanf进行格式化读写</p> 
<pre><code class="prism language-c++">int fputs (const char * str, FILE * stream );
char * fgets (char * str, int num, FILE * stream );
int fprintf (FILE * stream, const char * format, ... );
int fscanf (FILE * stream, const char * format, ... );
</code></pre> 
<p>在这个地方，我们先重新理解下当前路径：</p> 
<p><font color="Red" size="3"><strong>当前路径：一个进程运行起来的时候，每个进程都会去记录自己当前所处的工作路径</strong></font>。</p> 
<p>所有当前路径也就是当前进程的工作路径，可以被修改，所以每个进程都有自己的当前路径</p> 
<p><img src="https://images2.imgbox.com/aa/e1/JaN2vpkc_o.png" alt="image-20221214225056132"></p> 
<p><font color="Red"><strong>文件操作的本质是进程和被打开文件的关系</strong></font></p> 
<p>文件操作中r和w分别代表读和写，r+（读写）代表不存在则出错,w+（读写）代表不存在则创建，a(append)进行追加，追加也是写入，a+()也是读写，写是追加。</p> 
<p><strong>fprintf+w:</strong></p> 
<p><img src="https://images2.imgbox.com/e9/d0/gXsl1jKs_o.png" alt="image-20221214231527583"></p> 
<p><strong>fgets+r</strong></p> 
<p>fgets会给字符串结尾添加\0</p> 
<p><img src="https://images2.imgbox.com/5a/52/QpPY82yE_o.png" alt="image-20221214232546954"></p> 
<p>运行的结果和文件的内容每行都多出了一行，这是因为在读取的时候按行打印，把\n多读了，所以我们可以处理一下\n:</p> 
<p><img src="https://images2.imgbox.com/5e/0e/hMJmegjM_o.png" alt="image-20221214233037822"></p> 
<p><strong>a</strong>追加</p> 
<p><img src="https://images2.imgbox.com/1b/0c/38bi4Npw_o.png" alt="image-20221214235425674"></p> 
<p>对于C语言文件操作接口我们就先说到这里。这些都是我们之前所学的，在这里简单复习一下。</p> 
<h4><a id="3_68"></a>3.细节</h4> 
<p>对于C语言文件操作存在一些细节在这个地方提出来：</p> 
<p>1.<strong>以w方式单纯的打开文件，c会自动清空内部的数据</strong>：</p> 
<p><img src="https://images2.imgbox.com/cc/88/IpSNyZwR_o.png" alt="image-20221215084018711"></p> 
<p>为什么会自动清空内部的数据，这是一个值得思考的问题：这是因为O_TRUNC(这文件内容做清空)，不懂的话那就先继续往下看把。</p> 
<p>2.<strong>使用比特位传递选项</strong></p> 
<p>在C语言中，我们传标记位一个整数标记位一般传一个整数，而一个整数有32个比特位，所以我们可以通过比特位来传递选项。下面，我们要说的就是使用比特位来传递选项，一个比特位一个选项，比特位位置不能重复：</p> 
<p><img src="https://images2.imgbox.com/7e/16/b7nrltC7_o.png" alt="image-20221216092931982"></p> 
<p><img src="https://images2.imgbox.com/6e/57/sNqPVL0u_o.png" alt="image-20221216095822185"></p> 
<p>通过|传递参数，这样就能传递多个标志位了。</p> 
<hr> 
<h3><a id="font_color___RedIO__font_90"></a><font color="Red">二、系统文件I/O </font></h3> 
<p>文件操作除了上面我们所说的语言级别的文件操作，还有系统级别的文件操作调用接口。</p> 
<p>我们知道：普通文件默认创建的是664：一个文件形成的时候有默认文件的野码，普通文件创建的时候默认的起始权限是666，在形成文件的时候666&amp;~umask。</p> 
<h4><a id="1openclose_96"></a>1.open和close</h4> 
<p>fopen调用底层实际上是open：</p> 
<ul><li><strong>open</strong></li></ul> 
<p>我们可以来看看open的参数以及返回值（man 2 open）：</p> 
<p><img src="https://images2.imgbox.com/22/83/1ygW7QwL_o.png" alt="image-20221216105500024"></p> 
<pre><code class="prism language-c++">//头文件
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

int open(const char *pathname, int flags);//文件存在
int open(const char *pathname, int flags, mode_t mode);//文件不存在
//pathname:打开文件名
//flags:标志位。O_RDONLY：只读 O_WRONLY:只写 O_RDWR:读写
</code></pre> 
<pre><code class="prism language-c++">//返回值
return the new file descriptor, or -1 if an error occurred (in which case, errno is set appropriately)
//成功：打开文件描述符
//失败：返回-1
</code></pre> 
<ul><li><strong>close</strong></li></ul> 
<p>man 2 close</p> 
<pre><code class="prism language-c++">//头文件
#include &lt;unistd.h&gt;
//参数
int close(int fd);
</code></pre> 
<p>同时，O_CREAT:文件不存在，则需要我们去创建它，并不会自动创建好哈。也要使用mode选项，来指明此时新文件的权限。</p> 
<p><font color="Red" size="3">注意：<strong>O_CREAT是一个建议选项，文件存在还是不存在都可以使用</strong></font></p> 
<p><img src="https://images2.imgbox.com/4d/e3/PYAtDoXr_o.png" alt="image-20221216110218005"></p> 
<p><font color="blue"><strong>1.我们发现了open并没有去帮我们自动创建文件。以写的方式去创建方式并没有自动创建，想啥呢哈哈。而在C语言封装了会帮我们自动创建，但是对于系统接口我们需要加上O_CREAT（文件不存在自动创建）.最终成功帮我们自动创建成功</strong>！！！</font></p> 
<p><font color="blue">**2.但是对于log.txt文件创建了，权限是乱的，但是文件默认以什么权限创建？我们默认情况下目录以777，普通文件以666开始，**这些都是通过open的第三个参数mode选项设置权限的，设定创建默认文件的权限</font></p> 
<p>使用mode选项设置权限，我们一起来看一看：</p> 
<p><img src="https://images2.imgbox.com/a8/75/RDzN3KUp_o.png" alt="image-20221216110343536"></p> 
<p>我们可以设置unmask改变权限：</p> 
<p><img src="https://images2.imgbox.com/db/53/27x2risX_o.png" alt="image-20221216115723673"></p> 
<p>此时log.txt的权限才是664，与C语言创建的默认权限就一致了！</p> 
<h5><a id="umask_156"></a>umask小细节</h5> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/77/fb/lNxsBrAM_o.png" alt=""></p> 
 <p><font color="Red"><strong>我们如果想创建文件的权限如果不想受系统影响，也可以自己定义创建文件的野码</strong></font></p> 
 <p><strong>换句话来说：我们默认使用的是系统给我们所提供的umak，也就是父shell给我们提供的，而子进程会继承，所以我们很容易知道子进程对应的野码是多少。但是如果我们不想受系统野码影响限制权限，我们就可以在我们自己的子进程使用umask(0)清空野码（也就是上面的代码）</strong>：<img src="https://images2.imgbox.com/f2/f8/AZgCaUad_o.png" alt="image-20221218234930208"></p> 
 <p><strong>但是此时父进程shell的umask结果还是0002，我们改变的是子进程的文件权限，因为进程具有独立性，并不会影响父进程的umask</strong></p> 
</blockquote> 
<p>这就是在这里所说的umask小细节，值得注意一下。</p> 
<h4><a id="2readwrite_168"></a>2.read和write</h4> 
<h5><a id="1write_170"></a>1.write</h5> 
<p>文件打开和关闭说完之后，自然就是我们的写入接口了</p> 
<pre><code class="prism language-c++">//man 2 write
#include &lt;unistd.h&gt;
//把一个文件先描述符输入
ssize_t write(int fd, const void *buf, size_t count);
</code></pre> 
<p>fd：所写的文件</p> 
<p>buf:缓冲区数据，参数是void*,这从侧面说明了很多的东西：我们之前所说，文件读取分为文本类和二进制类，这是对于语言所提供的文件读取的分类。但是在操作系统看来，都是void*，也就是二进制！</p> 
<p>count:缓冲区所写的字节个数</p> 
<p>返回值：返回写入的字节数,在这里我们并不太需要关注返回值</p> 
<p>sprintf:将特定的内容格式化到字符串</p> 
<p>话不多说，我们直接代码练习：</p> 
<pre><code class="prism language-c++">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;assert.h&gt;
#define FILE_NAME "log.txt"
int main()
{
    umask(0);
    int fd = open(FILE_NAME,O_WRONLY | O_CREAT,0666);
    if(fd&lt;0)
    {
        perror("open");
        return 1;
    }
    int cnt = 5;
    char outBuffer[64];
    while(cnt)
    {
        sprintf(outBuffer,"%s:%d\n","helloworld",cnt--);
        
        write(fd,outBuffer,strlen(outBuffer)+1);  //注意这个地方+1了                                                 
    }
    close(fd);
}
</code></pre> 
<p><img src="https://images2.imgbox.com/d3/3b/HyWAkKJk_o.png" alt="image-20221219001548321"></p> 
<p>结果很正常，符合我们的预期，但是我们以文本打开：</p> 
<ul><li><strong>string+1出现乱码问题</strong></li></ul> 
<p><img src="https://images2.imgbox.com/28/b5/3e8ZQ3n0_o.png" alt="image-20221219001235543"></p> 
<p>出现上面这种情况乱码问题，实际是当我们向文件写入string的时候，要不要加1的问题？</p> 
<p>\0作为字符串的结尾，是C语言的规定，和文件并没有什么关系，是有效内容结尾。所以我们并不需要+1。这又是一个小细节</p> 
<p><img src="https://images2.imgbox.com/a8/3d/x3N9BlxE_o.png" alt="image-20221219003844530"></p> 
<ul><li><strong>清空问题</strong></li></ul> 
<p><img src="https://images2.imgbox.com/04/a0/Ilg4CHt4_o.png" alt="image-20221219004148371"></p> 
<p>我们发现，在这里，当我们重新打印内容时，居然还残留着上一次所打印的helloworld，这并没有帮我们自动清空内容，需要我们自己添加选项内容（而在C语言中，我们一开始说的细节：<strong>以w方式单纯的打开文件，c会自动清空内部的数据</strong>，这是封装好的）。</p> 
<p>清空内容需要带上O_TRUNC:</p> 
<p><img src="https://images2.imgbox.com/85/36/7ZWdgZBn_o.png" alt="image-20221219005441008"></p> 
<p>此时如果我们就打开和关闭，所有内容也会被清空：</p> 
<pre><code class="prism language-c++">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;assert.h&gt;
#define FILE_NAME "log.txt" 
int main()
{
    umask(0);
    int fd = open(FILE_NAME,O_WRONLY | O_CREAT | O_TRUNC,0666);
    if(fd&lt;0)
    {
        perror("open");
        return 1;
    }                                                                                             
    close(fd);
}
</code></pre> 
<p><img src="https://images2.imgbox.com/97/c5/FwSyeIlj_o.png" alt="image-20221219005845857"></p> 
<p>通过上面的这些内容，我们知道，在操作系统上层一个简单的"w"选项,操作系统底层就需要我们传O_WROLY(写入)，O_CREAT(不存在则创建)，O_TRUNC(清空)，以及传入属性！这就是C语言与系统接口的联系。</p> 
<ul><li><strong>追加O_APPEND</strong></li></ul> 
<p><img src="https://images2.imgbox.com/c6/26/nOrPfPzs_o.png" alt="image-20221219091326874"></p> 
<h5><a id="2read_279"></a>2.read</h5> 
<p><img src="https://images2.imgbox.com/25/0f/APEnkbNT_o.png" alt="image-20221219212743663"></p> 
<p>从一个文件描述符中读取文件</p> 
<pre><code class="prism language-c++">//头文件
#include &lt;unistd.h&gt;
//返回值ssize_t系统定制类型
ssize_t read(int fd, void *buf, size_t count);
</code></pre> 
<p>此时读文件需要用到选项O_RDONLY</p> 
<p>返回值：</p> 
<p><img src="https://images2.imgbox.com/2f/0e/EBV5H8nP_o.png" alt="image-20221219212857501"></p> 
<p>成功返回读取到多少个字节，0代表读到文件结尾。</p> 
<p>读文件的前提是文件已经是存在的了，不涉及创建和权限的问题。</p> 
<p>下面，进入代码演示环节：</p> 
<p><img src="https://images2.imgbox.com/e4/6b/LVRWeplS_o.png" alt="image-20221219213456369"></p> 
<h5><a id="3_306"></a>3.小总结</h5> 
<p>小总结：我们上面学习了open/close/write/read接口，当然还有lseek接口，这里就不展开说了</p> 
<p>实际上，这上面四个系统调用接口就对应着C语言的fopen/fclose/fwrite/fread,以及fseek库接口。</p> 
<p><img src="https://images2.imgbox.com/12/d7/9LubA09y_o.png" alt="image-20221219214336022"></p> 
<p>上面的 fopen fclose fread fwrite 都是C标准库当中的函数，我们称之为库函数（libc）。<br> 而open close read write lseek 都属于系统提供的接口，称之为系统调用接口</p> 
<hr> 
<h3><a id="font_color___Redfont_319"></a><font color="Red">三、理解文件</font></h3> 
<p><font color="Red"><strong>1.文件操作的本质：进程和被打开文件的关系</strong></font></p> 
<p><strong>2.进程可以打开多个文件，这也就意味着系统中一定会存在大量的被打开的文件，然而被打开的文件则需要被操作系统管理，我们知道，管理的本质就是先描述在组织，所以操作系统为了管理对应的打开文件，操作系统必定要为文件创建对应的内核数据结构来标识文件，这个内核数据结构就是struct file{}结构体（与C语言的FILE没有关系哦）；包含了文件的大部分属性</strong>。</p> 
<p>**3.而进程和被打开的文件如何关联，也就是说进程和被打开文件的关系是如何维护的？**通过文件打开（open）的返回值和文件描述符进行联系。</p> 
<p>下面我们通过代码来看一看返回值究竟是多少</p> 
<pre><code class="prism language-c++">#include &lt;stdio.h&gt;  
#include &lt;unistd.h&gt;  
#include &lt;string.h&gt;  
#include &lt;sys/types.h&gt;  
#include &lt;sys/stat.h&gt;  
#include &lt;fcntl.h&gt;  
#include &lt;assert.h&gt;  
#define FILE_NAME(number) "log.txt"#number     
int main()  
{
    umask(0);  
    int fd0 =open(FILE_NAME(1),O_WRONLY | O_CREAT | O_APPEND,0666);  
    int fd1 =open(FILE_NAME(2),O_WRONLY | O_CREAT | O_APPEND,0666);  
    int fd2 =open(FILE_NAME(3),O_WRONLY | O_CREAT | O_APPEND,0666);  
    int fd3 =open(FILE_NAME(4),O_WRONLY | O_CREAT | O_APPEND,0666);  、
    int fd4 =open(FILE_NAME(5),O_WRONLY | O_CREAT | O_APPEND,0666);  
    printf("fd: %d\n",fd0);  
    printf("fd: %d\n",fd1);  
    printf("fd: %d\n",fd2);  
    printf("fd: %d\n",fd3);  
    printf("fd: %d\n",fd4);  
    close(fd0);
    close(fd1);
    close(fd2);
    close(fd3);
    close(fd4);    
}
</code></pre> 
<p><img src="https://images2.imgbox.com/c9/2a/L9NXMY3Z_o.png" alt="image-20221219215843210"></p> 
<p>为什么从3开始？？？👇</p> 
<hr> 
<h3><a id="font_color___Redfdfont_365"></a><font color="Red">四、文件描述符fd</font></h3> 
<h5><a id="1_367"></a>1.引入</h5> 
<p><strong>看到上面的结果，open的返回值为什么是从3开始的，那0,1,2跑哪里去了呢，而且还是连续的小整数（说到连续，我们想到的是数组下标连续）</strong></p> 
<p>在C语言阶段，我们知道<font color="red"><strong>C程序会默认打开三个标准输入输出流：stdin(标准输入设备键盘).stout（输出设备显示器）.stderr（显示器）</strong></font></p> 
<p><em><em>而对于C语言的FILE，我们对其并不太了解:c语言的FILE究竟是何方神圣？这实际上是一个结构体！访问文件时，底层open必须采用系统调用，而系统调用接口访问文件必须用文件描述符，<font color="Red">而在C语言用的并不是文件描述符，而是FILE</font></em>，所以这个FILE结构体必定有一个文件描述符的字段。所以C语言不仅在接口上有封装，连数据类型都有封装。</em>*</p> 
<p>所以，我们可以查看到stdin，stout，stderr里面对应的值是多少：</p> 
<p><img src="https://images2.imgbox.com/ad/ba/gCGGxw5G_o.png" alt="image-20221219223133032"></p> 
<p><strong>这就很好的解答了为什么open的返回值是从3开始的问题！因为0,1,2默认被占用，我们的C语言封装了接口，同时也封装了操作系统内的文件描述符。</strong></p> 
<p><strong>此外，数字为什么从0,1,2连续的整数，文件描述符的本质是什么？</strong></p> 
<h5><a id="2_383"></a>2.理解</h5> 
<p><font color="blue"><strong>文件描述符的本质是数组的下标</strong></font></p> 
<p><img src="https://images2.imgbox.com/b0/b8/mAMVcB6f_o.png" alt="image-20221220162335757"></p> 
<p><strong>一个文件如果没有被打开那就是在磁盘上的，而要操作文件，就需要打开文件，把文件相关的属性信息从磁盘加载到内存，操作系统中会存在大量的进程，一个进程可以打开多个文件，所以操作系统要把很多的文件在内存中管理起来，如何管理？先描述，在组织。OS为了管理每一个打开的文件，构造了struct file对象，那打开那么的文件，OS为了让进程和文件之间产生关联，进程创建struct file_struct的结构，同时里面包含了数组struct file*fd_array[]指针数组，把描述文件的结构体对象地址填充到对应的下标之中</strong>。</p> 
<p>这也就很好结社了为什么打开文件返回值为3，打开文件内核会描述struct file结构，把对应的地址填充到struct file*fd_array[]数组中的下标中去，又因为0,1,2，默认会被占用，于是从3号下标开始，对应的数组下标返回给用户，这样就能找到进程的文件描述符表，找到对应的文件了。</p> 
<p><font color="Red"><strong>这也就是为什么文件操作系统读到的数是整数，而且是连续的，因为文件操作系统内标记进程和文件之间的关系就是文件描述符表，用数组标定文件内容！</strong></font>通过文件描述符来访问文件！</p> 
<h5><a id="3_395"></a>3.分配规则</h5> 
<p>文件描述符说白了就是数组的下标。下面，我们进入的是文件描述符的分配规则。</p> 
<p>既然默认会打开0,1,2，那我们如果将其关闭呢</p> 
<p><img src="https://images2.imgbox.com/8a/ea/3sZOIJ7P_o.png" alt="image-20221220180049971"></p> 
<p><em><em>一个文件被打开是进程被打开，进程的task_struct，被打开的文件struct_file,进程和被打开的文件通过文件描述符表struct files_struct里面包含一个数组struct file</em> fd_array[]指向对应文件的数组，里面写着被打开文件的地址，下标对应着填充的文件对象。进程找到自己的文件描述符表传入对应的下标值访问对应的文件。当我们把0关掉了，没有被占用，此时如果在创建一个文件对象，会在自己的文件描述符表从小到大按照顺序寻找最小的且没有被占用的fd.</em>*</p> 
<p><font color="Red" size="3"><strong>fd的分配规则总结一句话：从小到大按照顺序寻找最小的且没有被占用的fd。而默认会把0,1,2占用了，所以一开始文件描述符是3.当我们把0关闭，0没有被占用，那文件描述符那就是0了。</strong></font></p> 
<p>看到这里，如果细心的话就会发现，前面我们都没有close(1)，那close(1)会发生什么问题？👇这又引出了另外一个问题</p> 
<h5><a id="4close1_409"></a>4.close(1)问题</h5> 
<p><strong>根据前面所说的分配规则:我们可以知道，当我们关闭1时，此时1不在指向标准输出（显示器），不在向显示器打印，当我们打开文件的时候，系统会存在文件对象，然后在把文件的地址在files_struct找一个最小的没有被使用的文件描述符，此时是1，此时就把文件的地址填入1的下标里，在把1号文件描述符返回给上层，此时fd就拿到返回值1。</strong></p> 
<p>但是结果是1吗？</p> 
<p><img src="https://images2.imgbox.com/d6/0a/yQY3NLXO_o.png" alt="image-20221224093013256"></p> 
<p>但是我们运行并没有看到结果，原因是因为：printf实际就是向stdout打印的。</p> 
<p><strong>我们向标准输出显示器进行打印的时候，默认是向stdout打印，而stdout的文件描述符封装了1，当我们进行文件操作的时候，都是在向stdout打印，而stdout的fd都是1，当1号文件描述符没变，里面的指向发生了变化，指向了新打开的文件。</strong><br> <mark><strong>注意：此时打印的结果并没有在新打开的文件里，这是因为缓冲区的问题，没有被显示出来</strong></mark></p> 
<p><img src="https://images2.imgbox.com/fc/ff/TvFIDYyf_o.png" alt="image-20221224093111028"></p> 
<p>此时我们刷新缓冲区，即可看到结果：</p> 
<p><img src="https://images2.imgbox.com/ec/0b/PZziwPPZ_o.png" alt="image-20221224093405188"></p> 
<p><font color="Red" size="3"><strong>本来我们应该把打印往显示器文件里打印，最后经过我们的一系列操作把输出的结果写到了文件里。也就是本来应该写到显示器，却写到了文件，这种特性我们称之为重定向！</strong></font></p> 
<hr> 
<h3><a id="font_color___Redfont_432"></a><font color="Red">五、重定向</font></h3> 
<h5><a id="1_434"></a>1.重定向</h5> 
<p>重定向我们最早接触就是&gt;输出;&gt;&gt;追加;&lt;输入</p> 
<p><font color="blue"><strong>重定向最典型的特征就是在上层调用不变的情况下，改变底层的数组方向</strong></font>：比如调用fwrite(stdout,…);无论如何调用，上层都会用到stdin(标准输入),stdout（标准输出）,stderr（标准错误），也就是0,1,2不变，当我们把3号描述符的指针指向1号描述符，1本来是指向标准输出的，此时1却指向了新打开的文件.</p> 
<p>重定向的本质就是上层的fd不变，在内核中更改fd对应的struct_file*的地址</p> 
<p>下面，我们要介绍的就是重定向接口。</p> 
<h5><a id="2_444"></a>2.接口</h5> 
<p><img src="https://images2.imgbox.com/d2/2a/HV2GTOJR_o.png" alt="image-20221224151325824"></p> 
<p>dup2的作用是两个文件描述符之间进行拷贝，是把fd里面的内容拷贝，这点是我们需要注意的。</p> 
<p>dup2的参数我们需要去格外关注一下：dup2一旦重定向之后，最终剩下的都是oldfd:</p> 
<p><img src="https://images2.imgbox.com/cb/49/r1oS3E7U_o.png" alt="image-20221224230500743"></p> 
<p>下面，我们直接通过dup2重定向把原来显示到显示器的内容却显示到文件里面：</p> 
<p><img src="https://images2.imgbox.com/2d/7c/oXVE5747_o.png" alt="image-20221224231252163"></p> 
<h5><a id="3_458"></a>3.追加重定向</h5> 
<p>无非就是在打开文件的时候不需要清空直接改成追加方式O_APPEND：</p> 
<p><img src="https://images2.imgbox.com/59/e1/9v2133Cr_o.png" alt="image-20221224232404401"></p> 
<h5><a id="4_464"></a>4.输入重定向</h5> 
<p>输入重定向前提条件是文件必须存在。stdin—&gt;0,dup2(fd,0);//输入重定向</p> 
<p><img src="https://images2.imgbox.com/8d/3d/IhpQv9zl_o.png" alt="image-20221224233831347"></p> 
<hr> 
<h3><a id="font_color___RedLinuxfont_474"></a><font color="Red">六、Linux一切皆文件</font></h3> 
<p>Linux一切皆文件：</p> 
<p><strong>在冯诺依曼体系中，我们知道硬件有键盘、显示器、磁盘、网卡等外设，在IO过程中，外设任何的数据处理都需要把数据读到内存，处理完毕之后将内存中的数据刷新到外设当中。因为软硬件资源多，所以操作系统需要对其先描述，在组织。所以这些外设都有对应的结构体，对应着属性信息，同时，对应着自己的IO函数，具体硬件的读写方法都在应用匹配的驱动程序里。每种硬件的访问方法都是不一样的，而Linux一切皆文件是这样体现的：任何一个被打开的文件结构体对象struct file{ //各种文件的属性 }对象，不同的文件对应的读写方法不一样，struct file对象里面可以有很多的（*readp）()、(*writep)()函数指针，通过函数指针指向具体的读写方法。</strong></p> 
<p><font color="Red"><strong>站在struct file上层看来，所有的设备和文件，统一都是struct file-&gt;，就可以调用具体的设备方法了，所以在用户级看到的就是Linux下一切皆文件！</strong></font></p> 
<p>**上层调用不同的文件，底层可以调用不同的方法，在上层看来，只需要使用对应统一的文件，使用struct file，访问不同的文件，这是C语言实现多态的特征。这里struct file称为在操作系统层面上虚拟出来的文件对象vfs（虚拟文件系统）**不用关心底层差别，统一使用文件的接口方式进行文件操作</p> 
<p>下面我们可以查看源码，看看一些细节：</p> 
<p>PCB指向所有被打开的文件：</p> 
<p><img src="https://images2.imgbox.com/92/53/Wt75RRba_o.png" alt="image-20221225092708540"></p> 
<p><img src="https://images2.imgbox.com/61/48/dKOE738Q_o.png" alt="image-20221225142519130"></p> 
<p><img src="https://images2.imgbox.com/89/84/M2tRTeNO_o.png" alt="image-20221225150013937"></p> 
<p>我们所谓的关闭文件只是在表明用户给OS说已经不需要使用了，由OS决定，OS把引用计数减到0时，才被OS真正删除掉。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aba6238ebc455205148ff3334a1f0a5b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【编译】NCNN编译安装</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b4763ac3081fc09c428666704d9d1e8d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python词云图词频统计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>