<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JavaWeb之Servlet - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JavaWeb之Servlet" />
<meta property="og:description" content="1、什么是JavaWeb？ Servlet 是 JavaEE 规范之一。规范就是接口 Servlet 就 JavaWeb 三大组件之一。三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监听器。 Servlet 是运行在服务器上的一个 java 小程序，它可以接收客户端发送过来的请求，并响应数据给客户端。 2、第一个Servlet程序 2.1 实现步骤 实现一个简单的Servlet程序的步骤：
编写一个类去实现 Servlet 接口或者Servlet接口的子类实现 service 方法，处理请求，并响应数据 到 web.xml 中去配置 servlet 程序的访问地址 2.2 继承Servlet接口并实现service方法 public class HelloServlet implements Servlet { /** * service 方法是专门用来处理请求和响应的 * @param servletRequest 客户端的请求 * @param servletResponse 服务器的响应 */ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(&#34;Hello Servlet&#34;); } } 2.3 配置web.xml &lt;?xml version=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8df0b96394005c12c4978cec1bc52e5a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-06T11:13:19+08:00" />
<meta property="article:modified_time" content="2023-06-06T11:13:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaWeb之Servlet</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1、什么是JavaWeb？</h2> 
<ol><li><span style="color:#000000;">Servlet </span><span style="color:#000000;">是 </span><span style="color:#000000;">JavaEE </span><span style="color:#000000;">规范之一。规范就是接口 </span></li><li><span style="color:#000000;">Servlet </span><span style="color:#000000;">就 </span><span style="color:#000000;">JavaWeb </span><span style="color:#000000;">三大组件之一。三大组件分别是：</span><span style="color:#000000;">Servlet </span><span style="color:#000000;">程序、</span><span style="color:#000000;">Filter </span><span style="color:#000000;">过滤器、</span><span style="color:#000000;">Listener </span><span style="color:#000000;">监听器。 </span></li><li><span style="color:#000000;">Servlet </span><span style="color:#000000;">是运行在服务器上的一个 </span><span style="color:#000000;">java </span><span style="color:#000000;">小程序，</span><span style="color:#ff0000;">它可以接收客户端发送过来的请求，并响应数据给客户端。</span></li></ol> 
<h2>2、第一个Servlet程序</h2> 
<h3>2.1 实现步骤</h3> 
<p>实现一个简单的Servlet程序的步骤：</p> 
<ol><li><span style="color:#000000;">编写一个类去实现 </span><span style="color:#000000;">Servlet </span><span style="color:#000000;">接口或者Servlet接口的子类</span></li><li><span style="color:#000000;">实现 </span><span style="color:#000000;">service </span><span style="color:#000000;">方法，处理请求，并响应数据 </span></li><li><span style="color:#000000;">到 </span><span style="color:#000000;">web.xml </span><span style="color:#000000;">中去配置 </span><span style="color:#000000;">servlet </span><span style="color:#000000;">程序的访问地址</span></li></ol> 
<h3><span style="color:#000000;">2.2 继承Servlet接口并实现service方法</span></h3> 
<pre><code class="language-java">public class HelloServlet implements Servlet {
/**
* service 方法是专门用来处理请求和响应的
* @param servletRequest 客户端的请求
* @param servletResponse 服务器的响应
*/
@Override
public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws
ServletException, IOException {
System.out.println("Hello Servlet");
}
}</code></pre> 
<h3>2.3 配置web.xml </h3> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
version="4.0"&gt;
&lt;!-- servlet 标签给 Tomcat 配置 Servlet 程序 --&gt;
&lt;servlet&gt;
&lt;!--servlet-name 标签 Servlet 程序起一个别名（一般是类名） --&gt;
&lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
&lt;!--servlet-class 是 Servlet 程序的全类名--&gt;
&lt;servlet-class&gt;com.lyh.servlet.HelloServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;!--servlet-mapping 标签给 servlet 程序配置访问地址--&gt;
&lt;servlet-mapping&gt;
&lt;!--servlet-name 标签的作用是告诉服务器，我当前配置的地址给哪个 Servlet 程序使用--&gt;
&lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
&lt;!--url-pattern 标签配置访问地址 &lt;br/&gt;
/ 斜杠在服务器解析的时候，表示地址为：http://ip:port/工程路径 &lt;br/&gt;
/hello 表示地址为：http://ip:port/工程路径/hello &lt;br/&gt;
--&gt;
&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;/web-app&gt;</code></pre> 
<h2>3、Servlet的生命周期</h2> 
<ol><li><span style="color:#000000;">执行 </span><span style="color:#000000;">Servlet </span><span style="color:#000000;">构造器方法（只调用一次）</span></li><li><span style="color:#000000;">执行 </span><span style="color:#000000;">init </span><span style="color:#000000;">初始化方法（只调用一次）</span></li><li><span style="color:#000000;">执行 </span><span style="color:#000000;">service </span><span style="color:#000000;">方法 （每次访问Servlet对应的网页都会调用）</span></li><li><span style="color:#000000;">执行 destroy 销毁方法  （在 web 工程停止的时候调用）</span></li></ol> 
<pre><code class="language-java">public class HelloServlet implements Servlet {

    public HelloServlet(){

        System.out.println("1. 构造器方法被调用");

    }

    //这里使用了 ServletConfig这个类
    @Override
    public void init(ServletConfig servletConfig) throws ServletException {

        System.out.println("2. 初始化方法被调用");
        
    }

  

    /**
     * service是专门用来处理请求和响应的
     * 当需要查询服务器并且不包含敏感数据时，可以使用GET方法。而当需要向服务器发送大量数据或包含敏感数据时，则应使用POST方法。
     */
    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {

        System.out.println("3 service()方法被调用 Hello Servlet");

    }

    

    @Override
    public void destroy() {
        System.out.println("4. destroy()方法被调用");
    }
}
</code></pre> 
<h2>4、GET 和 POST</h2> 
<h3>4.1概述</h3> 
<p>        因为 service方法是专门用来处理客户端请求和返回响应的，所以使用该方法需要我们用户根据自己的需求来实现相关的方法完成对不同类型请求（GET/POST）的处理。</p> 
<h3>4.2GET/POST的选择</h3> 
<p><br>         当需要查询服务器并且不包含敏感数据时，可以使用GET方法。而当需要向服务器发送大量数据或包含敏感数据时，则应使用POST方法。</p> 
<h3>4.3实现对不同请求的处理</h3> 
<p>        由于我们继承的是Servlet接口，它没有直接对GET和POST这两种请求类型的区分，所以需要我们自己来实现区分并做不同的处理。</p> 
<pre><code class="language-java">public class HelloServlet implements Servlet {
/**
* service 方法是专门用来处理请求和响应的
*/
    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws
ServletException, IOException {
        System.out.println("3 service === Hello Servlet 被访问了");
        // 类型转换（因为它有 getMethod()方法）
        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;
        // 获取请求的方式
        String method = httpServletRequest.getMethod();
        if ("GET".equals(method)) {
            doGet();
        } else if ("POST".equals(method)) {
            doPost();
        }
    }
        /**
        * 做 get 请求的操作
        */
        public void doGet(){
            System.out.println("get 请求");
        }
        /**
        * 做 post 请求的操作
        */
        public void doPost(){
            System.out.println("post 请求");
        }
}</code></pre> 
<h2>5、继承HttpServlet</h2> 
<p>        通过上面的案例我们可以看到，直接继承Servlet接口很不方便，因为它毕竟只是一个接口，只对方法进行了规范并没有实现，我们看看Servlet接口的源码：</p> 
<h3>5.1 Servlet接口源码</h3> 
<pre><code class="language-java">public interface Servlet {
    void init(ServletConfig var1) throws ServletException;

    ServletConfig getServletConfig();

    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;

    String getServletInfo();

    void destroy();
}</code></pre> 
<p>        实际开发中我们很少直接继承Servlet接口去实现servlet程序 而是继承它的子类HttpServlet，因为HttpServlet这个抽象子类对Servlet的方法都进行了实现而且对GET/POST请求也添加了专门的方法去实现。</p> 
<h3>5.2 doGet/doPost</h3> 
<p>        HttpServlet为GET/POST这两种客户端请求封装了两个方法，使得我们实现自己的业务逻辑更加简单明了。</p> 
<pre><code class="language-java">public class HelloServlet2 extends HttpServlet {
 
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("HelloServlet2 的 doGet 方法");
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("HelloServlet2 的 doPost 方法");
    }
}</code></pre> 
<p>每一个Servlet类都需要配置web.xml： </p> 
<pre><code class="language-XML">&lt;servlet&gt;
&lt;servlet-name&gt;HelloServlet2&lt;/servlet-name&gt;
&lt;servlet-class&gt;com.lyh.servlet.HelloServlet2&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;HelloServlet2&lt;/servlet-name&gt;
&lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre> 
<h3> 5.3 HttpServlet继承体系</h3> 
<p><img alt="" height="514" src="https://images2.imgbox.com/13/c3/ZEjuMGi1_o.png" width="978"></p> 
<h2>6、ServletConfig</h2> 
<h3>6.1 概述及源码</h3> 
<ul><li><span style="color:#000000;">ServletConfig </span><span style="color:#000000;">是 </span><span style="color:#000000;">Servlet </span><span style="color:#000000;">程序的配置信息类。 </span></li><li><span style="color:#000000;">Servlet </span><span style="color:#000000;">程序和 </span><span style="color:#000000;">ServletConfig </span><span style="color:#000000;">对象都是由 </span><span style="color:#000000;">Tomcat </span><span style="color:#000000;">负责创建，我们负责使用。 </span></li><li><span style="color:#000000;">Servlet </span><span style="color:#000000;">程序默认是第一次访问的时候创建，</span><span style="color:#000000;">ServletConfig </span><span style="color:#000000;">是每个 </span><span style="color:#000000;">Servlet </span><span style="color:#000000;">程序创建时，就创建一个对应的 </span><span style="color:#000000;">ServletConfig </span><span style="color:#000000;">对象。</span></li></ul> 
<pre><code class="language-java">public interface ServletConfig {
    String getServletName();

    ServletContext getServletContext();

    String getInitParameter(String var1);

    Enumeration&lt;String&gt; getInitParameterNames();
}</code></pre> 
<p> 通过源码，我们可以了解到它的三大作用：</p> 
<h3><span style="color:#000000;"><strong>6.2 ServletConfig </strong></span><span style="color:#000000;"><strong>类的三大作用 </strong></span></h3> 
<ol><li><span style="color:#000000;">可以获取 </span><span style="color:#000000;">Servlet </span><span style="color:#000000;">程序的别名 </span><span style="color:#000000;">servlet-name </span><span style="color:#000000;">的值 </span></li><li><span style="color:#000000;">获取初始化参数 </span><span style="color:#000000;">init-param </span> 
  <ol><li>获取初始化参数可以帮助我们在运行时配置 Servlet 的行为，例如设置数据库连接信息、数据源名称等参数。</li></ol></li><li><span style="color:#000000;">获取 </span><span style="color:#000000;">ServletContext </span><span style="color:#000000;">对象（Servlet的上下文对象）</span></li></ol> 
<h3> 6.3、ServletConfig 的使用</h3> 
<h4>6.3.1、初始化参数&lt;init-param&gt;</h4> 
<p>需要在我们的Servlet程序的配置信息中添加</p> 
<pre><code class="language-XML">&lt;servlet&gt;
        &lt;!--servlet-name 标签 Servlet 程序起一个别名（一般是类名） --&gt;
        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
        &lt;!--servlet-class 是 Servlet 程序的全类名--&gt;
        &lt;servlet-class&gt;com.lyh.servlet.HelloServlet&lt;/servlet-class&gt;

        &lt;!--   初始化参数 可以是多个参数  --&gt;
        &lt;init-param&gt;
            &lt;!--  参数名--&gt;
            &lt;param-name&gt;url&lt;/param-name&gt;
            &lt;!--  参数值--&gt;
            &lt;param-value&gt;jdbc:mysql://localhost:3306/test&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;username&lt;/param-name&gt;
            &lt;param-value&gt;root&lt;/param-value&gt;
        &lt;/init-param&gt;

    &lt;/servlet&gt;</code></pre> 
<p> </p> 
<pre><code class="language-java">public class HelloServlet implements Servlet {


    //继承了HttpServlet的类在重写init时 一定要调用父类的初始化方法
    super.init(config);
   
    //这里使用了 ServletConfig这个类
    @Override
    public void init(ServletConfig servletConfig) throws ServletException {

        // 1、可以获取 Servlet 程序的别名 servlet-name 的值
        System.out.println("HelloServlet 程序的别名是:" + servletConfig.getServletName());
        // 2、获取初始化参数 init-param
        System.out.println("初始化参数 username 的值是;" + servletConfig.getInitParameter("username"));
        System.out.println("初始化参数 url 的值是;" + servletConfig.getInitParameter("url"));
        // 3、获取 ServletContext 对象 
        ServletContext context = servletConfig.getServletContext();
    }
}</code></pre> 
<p>注意：</p> 
<blockquote> 
 <p>继承了HttpServlet的类在重写init时 一定要调用父类的初始化方法<br> super.init(config); </p> 
</blockquote> 
<h2>7、ServletContext</h2> 
<h3>7.1 概述</h3> 
<ol><li><span style="color:#000000;">ServletContext </span><span style="color:#000000;">是一个接口，它表示 </span><span style="color:#000000;">Servlet </span><span style="color:#000000;">上下文对象。</span></li><li><span style="color:#000000;">一个 </span><span style="color:#000000;">web </span><span style="color:#000000;">工程，只有一个 </span><span style="color:#000000;">ServletContext </span><span style="color:#000000;">对象实例。 </span></li><li><span style="color:#000000;">ServletContext 对象是一个域对象，我们可以通过它来获取整个web工程中在web.xml中配置的所有被&lt;</span><span style="color:#000080;"><strong>context-param</strong></span><span style="color:#000000;">&gt;标记的参数（不管web工程中有多少个Servlet程序）。 </span></li><li><span style="color:#000000;">ServletContext </span><span style="color:#000000;">是在 </span><span style="color:#000000;">web </span><span style="color:#000000;">工程部署启动的时候创建。在 </span><span style="color:#000000;">web </span><span style="color:#000000;">工程停止的时候销毁。</span></li></ol> 
<h3>7.2 ServletContext的四大作用 </h3> 
<ol><li><span style="color:#000000;">获取 </span><span style="color:#000000;">web.xml </span><span style="color:#000000;">中配置的上下文参数 </span><span style="color:#000000;">context-param </span></li><li><span style="color:#000000;">获取当前的工程路径，格式</span><span style="color:#000000;">: /</span><span style="color:#000000;">工程路径 </span></li><li><span style="color:#000000;">获取工程部署后在服务器硬盘上的绝对路径 </span></li><li><span style="color:#000000;">像 </span><span style="color:#000000;">Map </span><span style="color:#000000;">一样存取数据</span></li></ol> 
<h3>7.3 ServletContext的使用</h3> 
<h4>7.3.1 配置web.xml</h4> 
<pre><code class="language-XML">&lt;!--context-param 是上下文参数(它属于整个 web 工程)--&gt;
&lt;context-param&gt;
&lt;param-name&gt;username&lt;/param-name&gt;
&lt;param-value&gt;context&lt;/param-value&gt;
&lt;/context-param&gt;
&lt;!--context-param 是上下文参数(它属于整个 web 工程)--&gt;
&lt;context-param&gt;
&lt;param-name&gt;password&lt;/param-name&gt;
&lt;param-value&gt;root&lt;/param-value&gt;
&lt;/context-param&gt;</code></pre> 
<h4>7.3.2 读取工程文件的配置参数以及工程路径</h4> 
<p>读取配置工程文件web.xml参数用<span style="color:#ed7976;"><strong> getInitParameter() </strong></span>方法。</p> 
<pre><code class="language-java">/**
 * &lt;init-param&gt;不同于ServletConfig的标签&lt;context-param&gt;
 * &lt;init-param&gt;的作用域是它自己对应的Servlet程序
 * &lt;context-param&gt;的作用域是每个Servlet程序
 */
public class ContextServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        //1.获取配置文件中的&lt;context-param&gt;参数
        ServletContext context = getServletContext();
        String username = context.getInitParameter("username");
        System.out.println("context-param 参数 username 的值是:" + username);

        //2.获取当前工程路径 /JavaWebStudy_war_exploded
        System.out.println("当前工程路径 ="+context.getContextPath());
        //获取工程部署在服务器上的绝对路径 D:\IdeaProjects\JavaWebStudy\target\JavaWebStudy-1.0-SNAPSHOT\
        //斜杠 / 被服务器解析为 http://127.0.0.1:8080/JavaWebStudy/ 映射到idea的web目录
        System.out.println("工程部署的绝对路径是 ="+context.getRealPath("/"));

        System.out.println("工程下 css 目录的绝对路径是:" + context.getRealPath("/css"));
    }
}</code></pre> 
<h4>7.3.3 多个Servle程序之间的存取数据</h4> 
<p>读取数据用<span style="color:#ed7976;"><strong> getAttribute() </strong></span>方法 。</p> 
<p>        因为ServletContext的作用域是整个web工程，所以不同Servlet程序之间也可以共享参数以及自己配置参数供其他Servlet读取。</p> 
<p>例：写两个Servlet类，Servlet1负责设置参数数据，Servlet2负责读取参数数据。</p> 
<pre><code class="language-java">public class ContextServlet1 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        ServletContext context = getServletContext();
        context.setAttribute("username","root");
        context.setAttribute("password","123456");
    }

   
}</code></pre> 
<pre><code class="language-java">public class ContextServlet2 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println(getServletContext().getAttribute("username"));
        System.out.println(getServletContext().getAttribute("password"));
    }

}
</code></pre> 
<blockquote> 
 <p>注意：</p> 
 <p>这两个不一样</p> 
 <ol><li>读取配置工程文件web.xml参数用<span style="color:#ed7976;"><strong> getInitParameter() </strong></span>方法</li><li>读取数据用<span style="color:#ed7976;"><strong> getAttribute() </strong></span>方法 </li></ol> 
</blockquote> 
<h2>8、HttpServletRequest </h2> 
<h3>8.1 概述</h3> 
<p>我们可以看到service（）方法里有两个参数，分别对应客户端的请求以及我们服务端的响应。</p> 
<pre><code class="language-java">@Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws
ServletException, IOException {
    //用户业务逻辑代码。。。
}</code></pre> 
<div> 
 <span style="color:#000000;">        每次只要有请求进入 Tomcat </span> 
 <span style="color:#000000;">服务器，</span> 
 <span style="color:#000000;">Tomcat </span> 
 <span style="color:#000000;">服务器就会把请求过来的 </span> 
 <span style="color:#000000;">HTTP </span> 
 <span style="color:#000000;">协议信息解析好封装到 </span> 
 <span style="color:#000000;">Request </span> 
 <span style="color:#000000;">对象中。 然后传递到 service </span> 
 <span style="color:#000000;">方法（doGet 和 </span> 
 <span style="color:#000000;">doPost</span> 
 <span style="color:#000000;">）中给我们使用。我们可以通过 </span> 
 <span style="color:#000000;">HttpServletRequest </span> 
 <span style="color:#000000;">对象，获取到所有请求的信息。 </span> 
</div> 
<h3><span style="color:#000000;">8.2 常用方法</span></h3> 
<p></p> 
<ul><li><span style="color:#000000;">getRequestURI()         获取请求的资源路径 </span></li><li><span style="color:#000000;">getRequestURL()       获取请求的统一资源定位符（绝对路径） </span></li><li><span style="color:#000000;">getRemoteHost()         获取客户端的 ip 地址 </span></li><li><span style="color:#000000;">getHeader()                 获取请求头 </span></li><li><span style="color:#000000;">getParameter()                 获取请求的参数 </span></li><li><span style="color:#000000;">getParameterValues()         获取请求的参数（多个值的时候使用） </span></li><li><span style="color:#000000;">getMethod()                         获取请求的方式 GET 或 POST </span></li><li><span style="color:#000000;">setAttribute(key, value);         设置域数据 </span></li><li><span style="color:#000000;">getAttribute(key);                 获取域数据 </span></li><li><span style="color:#000000;">getRequestDispatcher()         获取请求转发对象</span></li></ul> 
<h3>8.3、实例</h3> 
<p>通过html中的表单提交数据，通过Servlet程序读取表单中的数据。</p> 
<h4>8.3.1、html</h4> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action="http://localhost:8080/JavaWebStudy_war_exploded/request1" method="get"&gt;
  用户名:&lt;input type="text" name="username"&gt;&lt;br/&gt;
  密码:&lt;input type="text" name="password"&gt;&lt;br/&gt;
  爱好:&lt;input type="checkbox" name="hobby" value="Java"&gt;Java
        &lt;input type="checkbox" name="hobby" value="JS"&gt;JavaScript
        &lt;input type="checkbox" name="hobby" value="Scala"&gt;Scala&lt;br/&gt;
    &lt;input type="submit"&gt;
&lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<h4>8.3.2、Servlet类</h4> 
<p>Servlet只需要实现doGet方法即可。</p> 
<p>注意：</p> 
<ol><li>当参数不只一个的时候（比如多选框），我们需要用的是getParameterValues方法，它会返回一个数组对象。使用getParameter来读取多选框的话，最终只会返回一个值（用户最后选的值，先选的值会被覆盖）。</li><li>中文乱码问题：我们需要设置请求体的字符集编码格式，设置编码格式的代码只有放到doGet/doPost方法下的第一行才有效。</li></ol> 
<p></p> 
<pre><code class="language-java"> @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        
        //设置请求体的字符集为 UTF-8 解决post的请求乱码问题
        //必须放在获取请求参数getParameter()方法之前调用才有效果
        req.setCharacterEncoding("UTF-8");
        System.out.println("URI =&gt; "+req.getRequestURI());
        System.out.println("URL =&gt; "+req.getRequestURL());
        System.out.println("客户端Host的ip =&gt; "+req.getRemoteHost());
//        我的真实ip 10.49.xx.xxx 可通过网络管理查看ipv4地址 就是本地真实地址
        System.out.println("请求头 =&gt; "+req.getHeader("User-Agent"));
        System.out.println("请求的方法 =&gt; "+req.getMethod());

//        参数名称就是 &lt;input&gt;标签中的 name属性
        String username = req.getParameter("username");
        String password = req.getParameter("password");
        String[] hobby = req.getParameterValues("hobby");
        System.out.println("请求的参数 username =&gt; "+username);
        System.out.println("请求的参数 password =&gt; "+password);
        System.out.print("请求的参数 hobby =&gt; ");
        //打印数组的两种方式 1. Arrays.toString  Arrays.asList(数组名)
        System.out.println(Arrays.toString(hobby));
//        System.out.println(Arrays.asList(hobby));

    }</code></pre> 
<h3>8.4、请求转发</h3> 
<h4>8.4.1 特点：</h4> 
<ol><li>浏览器地址没有变化</li><li>是一次请求</li><li>共享request域的数据</li><li>可以转发到WEB-INF目录下的资源</li><li>不可以访问外部资源（比如www.baidu.com）</li></ol> 
<blockquote> 
 <p>核心代码：</p> 
 <p><strong>req.getRequestDispatcher("转发路径").forward(req,resp);</strong></p> 
</blockquote> 
<p><img alt="" height="105" src="https://images2.imgbox.com/d4/1a/uq5qb6cG_o.png" width="292"></p> 
<p>实例：客户端请求 /forwardc的资源， 由ForwardC这个Servlet程序转发到<a href="http://localhost:8080/JavaWebStudy_war_exploded/forwardC" rel="nofollow" title="http://localhost:8080/JavaWebStudy_war_exploded/a/b/c.html">http://localhost:8080/JavaWebStudy_war_exploded/a/b/c.html</a>。</p> 
<p>需要再我们上面的html中添加超链接（我们的ForwardC对应的工程url为"/forwardc"）。</p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;a href="a/b/c.html"&gt;跳转到c.html&lt;/a&gt;&lt;/br&gt;

    &lt;a href="http://localhost:8080/JavaWebStudy_war_exploded/forwardC"&gt;通过请求转发跳转到c.html&lt;/a&gt;&lt;/br&gt;

    &lt;a href="http://localhost:8080/JavaWebStudy_war_exploded/redirect"&gt;请求重定向到c.html&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<pre><code class="language-java">public class ForwardC extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("经过了ForwardC请求转发到了 c.html");
        //转发到http://localhost:8080/JavaWebStudy_war_exploded + /a/b/c.html
        //这里的斜杠 / 是协议//ip:端口号/工程路径的意思
        req.getRequestDispatcher("/a/b/c.html").forward(req,resp);
    }
}</code></pre> 
<h4>c.html</h4> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;c页面&lt;/title&gt;
&lt;!--  有了base标签 浏览器就不会根据当前的浏览器地址的路径去判断 ../../后的路径了  --&gt;
  &lt;base href="http://localhost:8080/JavaWebStudy_war_exploded/a/b/"&gt;
&lt;/head&gt;
&lt;body&gt;
C页面
&lt;a href="../../index.html"&gt;回到首页&lt;/a&gt;&lt;/br&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<h2> 9、<span style="color:#000000;"><strong>HttpServletResponse</strong></span></h2> 
<h3><span style="color:#000000;"><strong>9.1 HttpServletResponse </strong></span><span style="color:#000000;"><strong>类的作用</strong></span></h3> 
<div> 
 <span style="color:#000000;">HttpServletResponse </span> 
 <span style="color:#000000;">类和 </span> 
 <span style="color:#000000;">HttpServletRequest </span> 
 <span style="color:#000000;">类一样。每次请求进来，</span> 
 <span style="color:#000000;">Tomcat </span> 
 <span style="color:#000000;">服务器都会创建一个 </span> 
 <span style="color:#000000;">Response </span> 
 <span style="color:#000000;">对象传 递给 Servlet </span> 
 <span style="color:#000000;">程序去使用。</span> 
 <span style="color:#000000;">HttpServletRequest </span> 
 <span style="color:#000000;">表示请求过来的信息，</span> 
 <span style="color:#000000;">HttpServletResponse </span> 
 <span style="color:#000000;">表示所有响应的信息， 我们如果需要设置返回给客户端的信息，都可以通过 HttpServletResponse </span> 
 <span style="color:#000000;">对象来进行设置。</span> 
</div> 
<h4><span style="color:#000000;"><strong>9.1.1 两个输出流的说明。 </strong></span></h4> 
<ul><li><span style="color:#000000;">字节流   getOutputStream()  常用于下载（传递二进制数据） </span></li><li><span style="color:#000000;">字符流  getWriter();  常用于回传字符串（常用） </span></li></ul> 
<div> 
 <span style="color:#000000;">两个流同时只能使用一个。 </span> 
</div> 
<div> 
 <span style="color:#000000;">使用了字节流，就不能再使用字符流，反之亦然，否则就会报错。</span> 
</div> 
<div></div> 
<div> 
 <pre><code class="language-java">public class ResponseIOServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //回传中文字符串同样会乱码,需要设置编码格式
        //1.1这里设置的是我们服务器的编码格式 如果客户的浏览器不是UTF-8仍然是乱码
//        resp.setCharacterEncoding("UTF-8");
        //1.2通过响应头来设置浏览器编码
//        resp.setHeader("Content-Type","text/html; charset=UTF-8");

        //2.设置相应内容的格式 这种方法可以同时设置服务器和浏览器的编码格式
        resp.setContentType("text/html; charset=UTF-8");

        /**
         * 字符流和字节流只能用一个
         */
        //字符流 回传字符串 展示到html上
        PrintWriter writer = resp.getWriter();
        writer.write("Hello Response");
    }
}</code></pre> 
 <h3><br><br> 9.2 请求重定向</h3> 
 <h4>9.2.1 特点：</h4> 
 <ol><li>浏览器地址会发生变化</li><li>两次请求</li><li>不共享request域中的数据</li><li>不能访问WEB-INF目录下的资源</li><li>可以访问外部资源（比如www.baidu.com）</li></ol> 
 <h4>9.2.2 实现</h4> 
 <pre><code class="language-java">/**
 * 请求重定向
 */
public class RedirectServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("Servlet程序接收到用户请求");


        //设置重定向的两种方法
        //设置响应状态码 302 ，表示重定向，（已搬迁）
        resp.setStatus(302);
        //1. 设置响应头，说明 新的地址在哪里 不推荐
       // resp.setHeader("Location", "http://localhost:8080");

        //2.第二种方法 推荐使用
        resp.sendRedirect("http://localhost:8080/JavaWebStudy_war_exploded/a/b/c.html");
    }
}
</code></pre> 
 <p></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2ff075405f896e0dc7fb859382fbb32e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【mmrotate代码解读】以FasterRcnn中的RPN&#43;ROI部分为例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/439a52f06c627f19b7c673164b6b5fe6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">OpenCV - cv::Mat与unsigned char*数组或者float*数组相互转换，cv::Mat与std::vector的相互转换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>