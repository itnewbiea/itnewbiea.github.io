<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入理解Android插件化技术 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深入理解Android插件化技术" />
<meta property="og:description" content="插件化技术可以说是Android高级工程师所必须具备的技能之一，从2012年插件化概念的提出（Android版本），到2016年插件化的百花争艳，可以说，插件化技术引领着Android技术的进步。
插件化提要 可以说，插件化技术涉及得非常广泛，其中最核心的就是Android的类加载机制和反射机制，相关原理请大家自行百度。
插件化发展历史 插件化技术最初源于免安装运行apk的想法，这个免安装的apk可以理解为插件。支持插件化的app可以在运行时加载和运行插件，这样便可以将app中一些不常用的功能模块做成插件，一方面减小了安装包的大小，另一方面可以实现app功能的动态扩展。想要实现插件化，主要是解决下面三个问题：
插件中代码的加载和与主工程的互相调用
插件中资源的加载和与主工程的互相访问
四大组件生命周期的管理
下面是比较出名的几个开源的插件化框架，按照出现的时间排序。研究它们的实现原理，可以大致看出插件化技术的发展，根据实现原理可以将这几个框架划分成了三代。
第一代：dynamic-load-apk最早使用ProxyActivity这种静态代理技术，由ProxyActivity去控制插件中PluginActivity的生命周期。该种方式缺点明显，插件中的activity必须继承PluginActivity，开发时要小心处理context。而DroidPlugin通过Hook系统服务的方式启动插件中的Activity，使得开发插件的过程和开发普通的app没有什么区别，但是由于hook过多系统服务，异常复杂且不够稳定。
第二代：为了同时达到插件开发的低侵入性（像开发普通app一样开发插件）和框架的稳定性，在实现原理上都是趋近于选择尽量少的hook，并通过在manifest中预埋一些组件实现对四大组件的插件化。另外各个框架根据其设计思想都做了不同程度的扩展，其中Small更是做成了一个跨平台，组件化的开发框架。
第三代：VirtualApp比较厉害，能够完全模拟app的运行环境，能够实现app的免安装运行和双开技术。Atlas是阿里今年开源出来的一个结合组件化和热修复技术的一个app基础框架，其广泛的应用与阿里系的各个app，其号称是一个容器化框架。
插件化原理 类加载 Android中常用的有两种类加载器，DexClassLoader和PathClassLoader，它们都继承于BaseDexClassLoader。相关源码如下：
区别在于调用父类构造器时，DexClassLoader多传了一个optimizedDirectory参数，这个目录必须是内部存储路径，用来缓存系统创建的Dex文件。而PathClassLoader该参数为null，只能加载内部存储目录的Dex文件。所以我们可以用DexClassLoader去加载外部的apk，用法如下：
其实，关于类加载更详细的内容，笔者也深入剖析过，可以查看下面的链接：类加载机制详解
双亲委托机制 ClassLoader调用loadClass方法加载类，代码如下：
可以看出ClassLoader加载类时，先查看自身是否已经加载过该类，如果没有加载过会首先让父加载器去加载，如果父加载器无法加载该类时才会调用自身的findClass方法加载，该机制很大程度上避免了类的重复加载。
DexPathList
这里要重点说一下DexClassLoader的DexPathList。DexClassLoader重载了findClass方法，在加载类时会调用其内部的DexPathList去加载。DexPathList是在构造DexClassLoader时生成的，其内部包含了DexFile。如下图所示：
DexPathList的loadClass会去遍历DexFile直到找到需要加载的类。
腾讯的qq空间热修复技术正是利用了DexClassLoader的加载机制，将需要替换的类添加到dexElements的前面，这样系统会使用先找到的修复过的类。
单DexClassLoader与多DexClassLoader
通过给插件apk生成相应的DexClassLoader便可以访问其中的类，这边又有两种处理方式，有单DexClassLoader和多DexClassLoader两种结构。
对于多DexClassLoader结构来说，可以用下面的模型来标识。
对于每个插件都会生成一个DexClassLoader，当加载该插件中的类时需要通过对应DexClassLoader加载。这样不同插件的类是隔离的，当不同插件引用了同一个类库的不同版本时，不会出问题，RePlugin采用的就是此方案。
对于单DexClassLoader来说，其模型如下：
将插件的DexClassLoader中的pathList合并到主工程的DexClassLoader中。这样做的好处时，可以在不同的插件以及主工程间直接互相调用类和方法，并且可以将不同插件的公共模块抽出来放在一个common插件中直接供其他插件使用。Small采用的是这种方式。
插件和主工程的互相调用涉及到以下两个问题：
插件调用主工程
在构造插件的ClassLoader时会传入主工程的ClassLoader作为父加载器，所以插件是可以直接可以通过类名引用主工程的类。
主工程调用插件
若使用多ClassLoader机制，主工程引用插件中类需要先通过插件的ClassLoader加载该类再通过反射调用其方法。插件化框架一般会通过统一的入口去管理对各个插件中类的访问，并且做一定的限制。
若使用单ClassLoader机制，主工程则可以直接通过类名去访问插件中的类。该方式有个弊病，若两个不同的插件工程引用了一个库的不同版本，则程序可能会出错，所以要通过一些规范去避免该情况发生。
资源加载 Android系统通过Resource对象加载资源，下面代码展示了该对象的生成过程。
因此，只要将插件apk的路径加入到AssetManager中，便能够实现对插件资源的访问。
具体实现时，由于AssetManager并不是一个public的类，需要通过反射去创建，并且部分Rom对创建的Resource类进行了修改，所以需要考虑不同Rom的兼容性。
资源路径的处理
和代码加载相似，插件和主工程的资源关系也有两种处理方式：
合并式：addAssetPath时加入所有插件和主工程的路径；
独立式：各个插件只添加自己apk路径
合并式由于AssetManager中加入了所有插件和主工程的路径，因此生成的Resource可以同时访问插件和主工程的资源。但是由于主工程和各个插件都是独立编译的，生成的资源id会存在相同的情况，在访问时会产生资源冲突。
独立式时，各个插件的资源是互相隔离的，不过如果想要实现资源的共享，必须拿到对应的Resource对象。
Context的处理
通常我们通过Context对象访问资源，光创建出Resource对象还不够，因此还需要一些额外的工作。 对资源访问的不同实现方式也需要不同的额外工作。以VirtualAPK的处理方式为例。
第一步：创建Resource
第二步：hook主工程的Resource
对于合并式的资源访问方式，需要替换主工程的Resource，下面是具体替换的代码。
注意下上述代码hook了几个地方，包括以下几个hook点：
替换了主工程context中LoadedApk的mResource对象。
将新的Resource添加到主工程ActivityThread的mResourceManager中，并且根据Android版本做了不同处理。
第三步：关联resource和Activity
上述代码是在Activity创建时被调用的（后面会介绍如何hook Activity的创建过程），在activity被构造出来后，需要替换其中的mResources为插件的Resource。由于独立式时主工程的Resource不能访问插件的资源，所以如果不做替换，会产生资源访问错误。
做完以上工作后，则可以在插件的Activity中放心的使用setContentView，inflater等方法加载布局了。
解决资源冲突
合并式的资源处理方式，会引入资源冲突，原因在于不同插件中的资源id可能相同，所以解决方法就是使得不同的插件资源拥有不同的资源id。
资源id是由8位16进制数表示，表示为0xPPTTNNNN。PP段用来区分包空间，默认只区分了应用资源和系统资源，TT段为资源类型，NNNN段在同一个APK中从0000递增。如下表所示：
所以思路是修改资源ID的PP段，对于不同的插件使用不同的PP段，从而区分不同插件的资源。具体实现方式有两种：
修改aapt源码，编译期修改PP段。
修改resources.arsc文件，该文件列出了资源id到具体资源路径的映射。
四大组件支持 Android开发中有一些特殊的类，是由系统创建的，并且由系统管理生命周期。如常用的四大组件，Activity，Service，BroadcastReceiver和ContentProvider。 仅仅构造出这些类的实例是没用的，还需要管理组件的生命周期。其中以Activity最为复杂，不同框架采用的方法也不尽相同。下面以Activity为例详细介绍插件化如何支持组件生命周期的管理。 大致分为两种方式：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/3f2af9e9756ac0e30a9e8a60f846c85b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-15T00:15:00+08:00" />
<meta property="article:modified_time" content="2023-03-15T00:15:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入理解Android插件化技术</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <p style="text-align:null;">插件化技术可以说是Android高级工程师所必须具备的技能之一，从2012年插件化概念的提出（Android版本），到2016年插件化的百花争艳，可以说，插件化技术引领着Android技术的进步。</p> 
 <p style=""></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">插件化提要</span></h3> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1208px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:93.87417%;height:0;"> 
    <img src="https://images2.imgbox.com/11/e6/hMSvNpPI_o.png" style="margin-left:;display:block;width:1208px;margin-top:-93.87417%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">可以说，插件化技术涉及得非常广泛，其中最核心的就是Android的类加载机制和反射机制，相关原理请大家自行百度。</p> 
 <p style=""></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">插件化发展历史</span></h3> 
 <p style="text-align:null;">插件化技术最初源于免安装运行apk的想法，这个免安装的apk可以理解为插件。支持插件化的app可以在运行时加载和运行插件，这样便可以将app中一些不常用的功能模块做成插件，一方面减小了安装包的大小，另一方面可以实现app功能的动态扩展。想要实现插件化，主要是解决下面三个问题：</p> 
 <p style="">插件中代码的加载和与主工程的互相调用</p> 
 <p style="">插件中资源的加载和与主工程的互相访问</p> 
 <p style="">四大组件生命周期的管理</p> 
 <p style="text-align:null;">下面是比较出名的几个开源的插件化框架，按照出现的时间排序。研究它们的实现原理，可以大致看出插件化技术的发展，根据实现原理可以将这几个框架划分成了三代。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1170px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:21.538462%;height:0;"> 
    <img src="https://images2.imgbox.com/75/d2/H1IIAweH_o.jpg" style="margin-left:;display:block;width:1170px;margin-top:-21.538462%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">第一代</span>：dynamic-load-apk最早使用ProxyActivity这种静态代理技术，由ProxyActivity去控制插件中PluginActivity的生命周期。该种方式缺点明显，插件中的activity必须继承PluginActivity，开发时要小心处理context。而DroidPlugin通过Hook系统服务的方式启动插件中的Activity，使得开发插件的过程和开发普通的app没有什么区别，但是由于hook过多系统服务，异常复杂且不够稳定。</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">第二代</span>：为了同时达到插件开发的低侵入性（像开发普通app一样开发插件）和框架的稳定性，在实现原理上都是趋近于选择尽量少的hook，并通过在manifest中预埋一些组件实现对四大组件的插件化。另外各个框架根据其设计思想都做了不同程度的扩展，其中Small更是做成了一个跨平台，组件化的开发框架。</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">第三代</span>：VirtualApp比较厉害，能够完全模拟app的运行环境，能够实现app的免安装运行和双开技术。Atlas是阿里今年开源出来的一个结合组件化和热修复技术的一个app基础框架，其广泛的应用与阿里系的各个app，其号称是一个容器化框架。</p> 
 <p style=""></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">插件化原理</span></h3> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">类加载</span></h3> 
 <p style="text-align:null;">Android中常用的有两种类加载器，DexClassLoader和PathClassLoader，它们都继承于BaseDexClassLoader。相关源码如下：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:865px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:36.416183%;height:0;"> 
    <img src="https://images2.imgbox.com/fb/bc/RoKadZxX_o.png" style="margin-left:;display:block;width:865px;margin-top:-36.416183%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">区别在于调用父类构造器时，DexClassLoader多传了一个optimizedDirectory参数，这个目录必须是内部存储路径，用来缓存系统创建的Dex文件。而PathClassLoader该参数为null，只能加载内部存储目录的Dex文件。所以我们可以用DexClassLoader去加载外部的apk，用法如下：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:859px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:13.853318%;height:0;"> 
    <img src="https://images2.imgbox.com/46/90/7SbDKkye_o.png" style="margin-left:;display:block;width:859px;margin-top:-13.853318%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">其实，关于类加载更详细的内容，笔者也深入剖析过，可以查看下面的链接：<a class="kdocs-link" style="color:#0A6CFF;" href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/xiangzhihong8/article/details/52880327" rel="nofollow noopener noreferrer" target="_blank">类加载机制详解</a></p> 
 <p style=""></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">双亲委托机制</span></h3> 
 <p style="text-align:null;">ClassLoader调用loadClass方法加载类，代码如下：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:865px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:56.069363%;height:0;"> 
    <img src="https://images2.imgbox.com/1e/39/PDu5yFHg_o.png" style="margin-left:;display:block;width:865px;margin-top:-56.069363%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">可以看出ClassLoader加载类时，先查看自身是否已经加载过该类，如果没有加载过会首先让父加载器去加载，如果父加载器无法加载该类时才会调用自身的findClass方法加载，该机制很大程度上避免了类的重复加载。</p> 
 <p style="text-align:null;"></p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">DexPathList</span></p> 
 <p style="text-align:null;">这里要重点说一下DexClassLoader的DexPathList。DexClassLoader重载了findClass方法，在加载类时会调用其内部的DexPathList去加载。DexPathList是在构造DexClassLoader时生成的，其内部包含了DexFile。如下图所示：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:402px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:87.56219%;height:0;"> 
    <img src="https://images2.imgbox.com/1c/39/MKK5Ey3k_o.jpg" style="margin-left:;display:block;width:402px;margin-top:-87.56219%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">DexPathList的loadClass会去遍历DexFile直到找到需要加载的类。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:867px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:38.177624%;height:0;"> 
    <img src="https://images2.imgbox.com/5c/2f/5kJ8zBdv_o.png" style="margin-left:;display:block;width:867px;margin-top:-38.177624%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">腾讯的qq空间热修复技术正是利用了DexClassLoader的加载机制，将需要替换的类添加到dexElements的前面，这样系统会使用先找到的修复过的类。</p> 
 <p style="text-align:null;"></p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">单DexClassLoader与多DexClassLoader</span></p> 
 <p style="text-align:null;">通过给插件apk生成相应的DexClassLoader便可以访问其中的类，这边又有两种处理方式，有单DexClassLoader和多DexClassLoader两种结构。</p> 
 <p style="text-align:null;">对于多DexClassLoader结构来说，可以用下面的模型来标识。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:562px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:95.01779%;height:0;"> 
    <img src="https://images2.imgbox.com/7c/5e/S8FXv8oT_o.jpg" style="margin-left:;display:block;width:562px;margin-top:-95.01779%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">对于每个插件都会生成一个DexClassLoader，当加载该插件中的类时需要通过对应DexClassLoader加载。这样不同插件的类是隔离的，当不同插件引用了同一个类库的不同版本时，不会出问题，RePlugin采用的就是此方案。</p> 
 <p style="text-align:null;">对于单DexClassLoader来说，其模型如下：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:572px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:94.05595%;height:0;"> 
    <img src="https://images2.imgbox.com/d2/dc/nmE8hjw1_o.jpg" style="margin-left:;display:block;width:572px;margin-top:-94.05595%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">将插件的DexClassLoader中的pathList合并到主工程的DexClassLoader中。这样做的好处时，可以在不同的插件以及主工程间直接互相调用类和方法，并且可以将不同插件的公共模块抽出来放在一个common插件中直接供其他插件使用。Small采用的是这种方式。</p> 
 <p style="text-align:null;">插件和主工程的互相调用涉及到以下两个问题：</p> 
 <p style="text-align:null;"></p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">插件调用主工程</span></p> 
 <p style="text-align:null;">在构造插件的ClassLoader时会传入主工程的ClassLoader作为父加载器，所以插件是可以直接可以通过类名引用主工程的类。</p> 
 <p style="text-align:null;"></p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">主工程调用插件</span></p> 
 <p style="">若使用多ClassLoader机制，主工程引用插件中类需要先通过插件的ClassLoader加载该类再通过反射调用其方法。插件化框架一般会通过统一的入口去管理对各个插件中类的访问，并且做一定的限制。</p> 
 <p style="">若使用单ClassLoader机制，主工程则可以直接通过类名去访问插件中的类。该方式有个弊病，若两个不同的插件工程引用了一个库的不同版本，则程序可能会出错，所以要通过一些规范去避免该情况发生。</p> 
 <p style="text-align:null;"></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">资源加载</span></h3> 
 <p style="text-align:null;">Android系统通过Resource对象加载资源，下面代码展示了该对象的生成过程。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:866px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:23.210161%;height:0;"> 
    <img src="https://images2.imgbox.com/0e/c1/evMhmEPT_o.png" style="margin-left:;display:block;width:866px;margin-top:-23.210161%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">因此，只要将插件apk的路径加入到AssetManager中，便能够实现对插件资源的访问。</p> 
 <p style="text-align:null;">具体实现时，由于AssetManager并不是一个public的类，需要通过反射去创建，并且部分Rom对创建的Resource类进行了修改，所以需要考虑不同Rom的兼容性。</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">资源路径的处理</span></p> 
 <p style="text-align:null;">和代码加载相似，插件和主工程的资源关系也有两种处理方式：</p> 
 <p style="">合并式：addAssetPath时加入所有插件和主工程的路径；</p> 
 <p style="">独立式：各个插件只添加自己apk路径</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1194px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:24.288107%;height:0;"> 
    <img src="https://images2.imgbox.com/0a/2a/ix0ahJam_o.jpg" style="margin-left:;display:block;width:1194px;margin-top:-24.288107%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">合并式由于AssetManager中加入了所有插件和主工程的路径，因此生成的Resource可以同时访问插件和主工程的资源。但是由于主工程和各个插件都是独立编译的，生成的资源id会存在相同的情况，在访问时会产生资源冲突。</p> 
 <p style="text-align:null;">独立式时，各个插件的资源是互相隔离的，不过如果想要实现资源的共享，必须拿到对应的Resource对象。</p> 
 <p style="text-align:null;"></p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">Context的处理</span></p> 
 <p style="text-align:null;">通常我们通过Context对象访问资源，光创建出Resource对象还不够，因此还需要一些额外的工作。 对资源访问的不同实现方式也需要不同的额外工作。以VirtualAPK的处理方式为例。</p> 
 <p style="text-align:null;">第一步：创建Resource</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:864px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:27.314816%;height:0;"> 
    <img src="https://images2.imgbox.com/13/d7/3ArG1MfH_o.png" style="margin-left:;display:block;width:864px;margin-top:-27.314816%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">第二步：hook主工程的Resource</p> 
 <p style="text-align:null;">对于合并式的资源访问方式，需要替换主工程的Resource，下面是具体替换的代码。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:865px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:47.16763%;height:0;"> 
    <img src="https://images2.imgbox.com/bf/04/ucviJAJO_o.png" style="margin-left:;display:block;width:865px;margin-top:-47.16763%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">注意下上述代码hook了几个地方，包括以下几个hook点：</p> 
 <p style="text-align:null;">替换了主工程context中LoadedApk的mResource对象。</p> 
 <p style="text-align:null;">将新的Resource添加到主工程ActivityThread的mResourceManager中，并且根据Android版本做了不同处理。</p> 
 <p style="text-align:null;">第三步：关联resource和Activity</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:864px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:14.236111%;height:0;"> 
    <img src="https://images2.imgbox.com/49/ef/EpqAhlPJ_o.png" style="margin-left:;display:block;width:864px;margin-top:-14.236111%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">上述代码是在Activity创建时被调用的（后面会介绍如何hook Activity的创建过程），在activity被构造出来后，需要替换其中的mResources为插件的Resource。由于独立式时主工程的Resource不能访问插件的资源，所以如果不做替换，会产生资源访问错误。</p> 
 <p style="text-align:null;">做完以上工作后，则可以在插件的Activity中放心的使用setContentView，inflater等方法加载布局了。</p> 
 <p style="text-align:null;"></p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">解决资源冲突</span></p> 
 <p style="text-align:null;">合并式的资源处理方式，会引入资源冲突，原因在于不同插件中的资源id可能相同，所以解决方法就是使得不同的插件资源拥有不同的资源id。</p> 
 <p style="text-align:null;">资源id是由8位16进制数表示，表示为0xPPTTNNNN。PP段用来区分包空间，默认只区分了应用资源和系统资源，TT段为资源类型，NNNN段在同一个APK中从0000递增。如下表所示：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1180px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:18.135593%;height:0;"> 
    <img src="https://images2.imgbox.com/a6/f8/VbbMxHY3_o.jpg" style="margin-left:;display:block;width:1180px;margin-top:-18.135593%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">所以思路是修改资源ID的PP段，对于不同的插件使用不同的PP段，从而区分不同插件的资源。具体实现方式有两种：</p> 
 <p style="">修改aapt源码，编译期修改PP段。</p> 
 <p style="">修改resources.arsc文件，该文件列出了资源id到具体资源路径的映射。</p> 
 <p style=""></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">四大组件支持</span></h3> 
 <p style="text-align:null;">Android开发中有一些特殊的类，是由系统创建的，并且由系统管理生命周期。如常用的四大组件，Activity，Service，BroadcastReceiver和ContentProvider。 仅仅构造出这些类的实例是没用的，还需要管理组件的生命周期。其中以Activity最为复杂，不同框架采用的方法也不尽相同。下面以Activity为例详细介绍插件化如何支持组件生命周期的管理。 大致分为两种方式：</p> 
 <p style="">ProxyActivity代理</p> 
 <p style="">预埋StubActivity，hook系统启动Activity的过程</p> 
 <p style=""></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">ProxyActivity代理</span></h3> 
 <p style="text-align:null;">ProxyActivity代理的方式最早是由dynamic-load-apk提出的，其思想很简单，在主工程中放一个ProxyActivy，启动插件中的Activity时会先启动ProxyActivity，在ProxyActivity中创建插件Activity，并同步生命周期。下图展示了启动插件Activity的过程。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1244px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:38.987137%;height:0;"> 
    <img src="https://images2.imgbox.com/4d/d5/zmyBMUGg_o.png" style="margin-left:;display:block;width:1244px;margin-top:-38.987137%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">具体的过程如下：</p> 
 <p style="">首先需要通过统一的入口（如图中的PluginManager）启动插件Activity，其内部会将启动的插件Activity信息保存下来，并将intent替换为启动ProxyActivity的intent。</p> 
 <p style="">ProxyActivity根据插件的信息拿到该插件的ClassLoader和Resource，通过反射创建PluginActivity并调用其onCreate方法。</p> 
 <p style="">PluginActivty调用的setContentView被重写了，会去调用ProxyActivty的setContentView。由于ProxyActivity重写了getResource返回的是插件的Resource，所以setContentView能够访问到插件中的资源。同样findViewById也是调用ProxyActivity的。</p> 
 <p style="">ProxyActivity中的其他生命周期回调函数中调用相应PluginActivity的生命周期。</p> 
 <p style="text-align:null;"></p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">理解ProxyActivity代理方式主要注意两点：</span></p> 
 <p style="">ProxyActivity中需要重写getResouces，getAssets，getClassLoader方法返回插件的相应对象。生命周期函数以及和用户交互相关函数，如onResume，onStop，onBackPressedon，KeyUponWindow，FocusChanged等需要转发给插件。</p> 
 <p style="">PluginActivity中所有调用context的相关的方法，如setContentView，getLayoutInflater，getSystemService等都需要调用ProxyActivity的相应方法。</p> 
 <p style="text-align:null;"></p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">缺点</span></p> 
 <p style="">插件中的Activity必须继承PluginActivity，开发侵入性强。</p> 
 <p style="">如果想支持Activity的singleTask，singleInstance等launchMode时，需要自己管理Activity栈，实现起来很繁琐。</p> 
 <p style="">插件中需要小心处理Context，容易出错。</p> 
 <p style="">如果想把之前的模块改造成插件需要很多额外的工作。</p> 
 <p style="text-align:null;">该方式虽然能够很好的实现启动插件Activity的目的，但是由于开发式侵入性很强，dynamic-load-apk之后的插件化方案很少继续使用该方式，而是通过hook系统启动Activity的过程，让启动插件中的Activity像启动主工程的Activity一样简单。</p> 
 <p style=""></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">hook方式</span></h3> 
 <p style="text-align:null;">在介绍hook方式之前，先用一张图简要的介绍下系统是如何启动一个Activity的。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1250px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:37.76%;height:0;"> 
    <img src="https://images2.imgbox.com/c0/fb/pH1N6Zzv_o.png" style="margin-left:;display:block;width:1250px;margin-top:-37.76%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">上图列出的是启动一个Activity的主要过程，具体步骤如下：</p> 
 <p style="">Activity1调用startActivity，实际会调用Instrumentation类的execStartActivity方法，Instrumentation是系统用来监控Activity运行的一个类，Activity的整个生命周期都有它的影子。</p> 
 <p style="">通过跨进程的binder调用，进入到ActivityManagerService中，其内部会处理Activity栈。之后又通过跨进程调用进入到Activity2所在的进程中。</p> 
 <p style="">ApplicationThread是一个binder对象，其运行在binder线程池中，内部包含一个H类，该类继承于类Handler。ApplicationThread将启动Activity2的信息通过H对象发送给主线程。</p> 
 <p style="">主线程拿到Activity2的信息后，调用Instrumentation类的newActivity方法，其内通过ClassLoader创建Activity2实例。</p> 
 <p style="text-align:null;">下面介绍如何通过hook的方式启动插件中的Activity，需要解决以下两个问题：</p> 
 <p style="">插件中的Activity没有在AndroidManifest中注册，如何绕过检测。</p> 
 <p style="">如何构造Activity实例，同步生命周期</p> 
 <p style="text-align:null;">解决方法有很多种，以VirtualAPK为例，核心思路如下：</p> 
 <p style="">先在Manifest中预埋StubActivity，启动时hook上图第1步，将Intent替换成StubActivity。</p> 
 <p style="">hook第10步，通过插件的ClassLoader反射创建插件Activity</p> 
 <p style="">之后Activity的所有生命周期回调都会通知给插件Activity</p> 
 <p style="text-align:null;"></p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">替换系统Instrumentation</span></p> 
 <p style="text-align:null;">VirtualAPK在初始化时会调用hookInstrumentationAndHandler，该方法hook了系统的Instrumentaiton类，由上文可知该类和Activity的启动息息相关。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:868px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:35.829494%;height:0;"> 
    <img src="https://images2.imgbox.com/06/21/jd3d8FUX_o.png" style="margin-left:;display:block;width:868px;margin-top:-35.829494%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">该段代码将主线程中的Instrumentation对象替换成了自定义的VAInstrumentation类。在启动和创建插件activity时，该类都会偷偷做一些手脚。</p> 
 <p style="text-align:null;"></p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">hook activity启动过程</span></p> 
 <p style="text-align:null;">VAInstrumentation类重写了execStartActivity方法，相关代码如下：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:867px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:58.016148%;height:0;"> 
    <img src="https://images2.imgbox.com/01/c3/9h1kjfsH_o.png" style="margin-left:;display:block;width:867px;margin-top:-58.016148%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">execStartActivity中会先去处理隐式intent，如果该隐式intent匹配到了插件中的Activity，将其转换成显式。之后通过markIntentIfNeeded将待启动的的插件Activity替换成了预先在AndroidManifest中占坑的StubActivity，并将插件Activity的信息保存到该intent中。其中有个dispatchStubActivity函数，会根据Activity的launchMode选择具体启动哪个StubActivity。VirtualAPK为了支持Activity的launchMode在主工程的AndroidManifest中对于每种启动模式的Activity都预埋了多个坑位。</p> 
 <p style="text-align:null;"></p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">hook Activity的创建过程</span></p> 
 <p style="text-align:null;">上一步欺骗了系统，让系统以为自己启动的是一个正常的Activity。当来到图 3.2的第10步时，再将插件的Activity换回来。此时调用的是VAInstrumentation类的newActivity方法。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:868px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:53.1106%;height:0;"> 
    <img src="https://images2.imgbox.com/f2/93/0yh3mJgf_o.png" style="margin-left:;display:block;width:868px;margin-top:-53.1106%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">由于AndroidManifest中预埋的StubActivity并没有具体的实现类，所以此时会发生ClassNotFoundException。之后在处理异常时取出插件Activity的信息，通过插件的ClassLoader反射构造插件的Activity。</p> 
 <p style="text-align:null;"></p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">其他操作</span></p> 
 <p style="text-align:null;">插件Activity构造出来后，为了能够保证其正常运行还要做些额外的工作。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:863px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:55.967556%;height:0;"> 
    <img src="https://images2.imgbox.com/45/ad/6TH5m7SY_o.png" style="margin-left:;display:block;width:863px;margin-top:-55.967556%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">这段代码主要是将Activity中的Resource，Context等对象替换成了插件的相应对象，保证插件Activity在调用涉及到Context的方法时能够正确运行。</p> 
 <p style="text-align:null;">经过上述步骤后，便实现了插件Activity的启动，并且该插件Activity中并不需要什么额外的处理，和常规的Activity一样。那问题来了，之后的onResume，onStop等生命周期怎么办呢？答案是所有和Activity相关的生命周期函数，系统都会调用插件中的Activity。原因在于AMS在处理Activity时，通过一个token表示具体Activity对象，而这个token正是和启动Activity时创建的对象对应的，而这个Activity被我们替换成了插件中的Activity，所以之后AMS的所有调用都会传给插件中的Activity。</p> 
 <p style=""></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">其他组件</span></h3> 
 <p style="text-align:null;">四大组件中Activity的支持是最复杂的，其他组件的实现原理要简单很多，简要概括如下：</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">Service</span>：Service和Activity的差别在于，Activity的生命周期是由用户交互决定的，而Service的生命周期是我们通过代码主动调用的，且Service实例和manifest中注册的是一一对应的。实现Service插件化的思路是通过在manifest中预埋StubService，hook系统startService等调用替换启动的Service，之后在StubService中创建插件Service，并手动管理其生命周期。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">BroadCastReceiver</span>：解析插件的manifest，将静态注册的广播转为动态注册。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">ContentProvider</span>：类似于Service的方式，对插件ContentProvider的所有调用都会通过一个在manifest中占坑的ContentProvider分发。</p> 
 <p style=""></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">小结</span></h3> 
 <p style="text-align:null;">VirtualAPK通过替换了系统的Instrumentation，hook了Activity的启动和创建，省去了手动管理插件Activity生命周期的繁琐，让插件Activity像正常的Activity一样被系统管理，并且插件Activity在开发时和常规一样，即能独立运行又能作为插件被主工程调用。</p> 
 <p style="text-align:null;">其他插件框架在处理Activity时思想大都差不多，无非是这两种方式之一或者两者的结合。在hook时，不同的框架可能会选择不同的hook点。如360的RePlugin框架选择hook了系统的ClassLoader，即图3.2中构造Activity2的ClassLoader，在判断出待启动的Activity是插件中的时，会调用插件的ClassLoader构造相应对象。另外RePlugin为了系统稳定性，选择了尽量少的hook，因此它并没有选择hook系统的startActivity方法来替换intent，而是通过重写Activity的startActivity，因此其插件Activity是需要继承一个类似PluginActivity的基类的。不过RePlugin提供了一个Gradle插件将插件中的Activity的基类换成了PluginActivity，用户在开发插件Activity时也是没有感知的。</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/25aca80ebce6c2e727a535f28ba9efc5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Python实用小工具】PDF文件快速拆分</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8521947fe261abf821fb257dbe8ffd94/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【从现有的数据库中 反射flask-sqlalchemy的models】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>