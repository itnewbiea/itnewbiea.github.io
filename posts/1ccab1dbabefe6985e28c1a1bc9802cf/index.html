<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>二分法查找 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="二分法查找" />
<meta property="og:description" content="一、二分法的原理 二分法查找针对的是一个有序的数据集合,每次通过与区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0.
故时间复杂度就是O(logn)
二、非递归实现 1、二分查找非递归实现
第一种写法，我们定义 target 是在一个在左闭右闭的区间里，也就是[Left, Right] 1、循环退出的条件
注意这里要写成Left&lt;= Right,而不是Left&lt; Right,因为当Left==Right，区间[Left, Right]依然有效，比如区间[2, 2]，这里还有一个值2。只有Left &#43;1 &gt; Right,比如[2,3]，while循环才退出
2、Left与Right的赋值
if (nums[middle] &gt; target) Right要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找下个位置就是 middle - 1,同理Left要赋值为 middle &#43; 1
3、middle的取值
如果写成 middle= (Left&#43;Right)/2是有问题的,数字较大就可能溢出,计算机位运算比除法快,故可改成low&#43;((high-low)&gt;&gt;1)
class Solution { public: int search(vector&lt;int&gt;&amp; nums, int target) { int left = 0; int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right] while (left &lt;= right) { // 当left==right，区间[left, right]依然有效，所以用 &lt;= int middle = left &#43; ((right - left) &gt;&gt; 1 );// 防止溢出 等同于(left &#43; right)/2 if (nums[middle] &gt; target) { right = middle - 1; // target 在左区间，所以[left, middle - 1] } else if (nums[middle] &lt; target) { left = middle &#43; 1; // target 在右区间，所以[middle &#43; 1, right] } else // (nums[middle] == target) return middle; // 数组中找到目标值，直接返回下标 } } // 未找到目标值 return -1; } }; 第二种写法:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/1ccab1dbabefe6985e28c1a1bc9802cf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-23T22:09:13+08:00" />
<meta property="article:modified_time" content="2022-11-23T22:09:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">二分法查找</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>一、二分法的原理</h4> 
<p>二分法查找针对的是一个有序的数据集合,每次通过与区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0.</p> 
<p style="text-align:center;"><img alt="" height="251" src="https://images2.imgbox.com/f2/a8/0RguZfHX_o.png" width="748"></p> 
<p>故时间复杂度就是O(logn)</p> 
<h4>二、非递归实现</h4> 
<p>1、二分查找非递归实现</p> 
<p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[Left, Right] </strong></p> 
<p>    1、循环退出的条件</p> 
<p>    注意这里要写成Left&lt;= Right,而不是Left&lt; Right,因为当Left==Right，区间[Left, Right]依然有效，比如区间[2, 2]，这里还有一个值2。只有Left +1 &gt; Right,比如[2,3]，while循环才退出</p> 
<p>    2、Left与Right的赋值</p> 
<p>if (nums[middle] &gt; target) Right要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找下个位置就是 middle - 1,同理Left要赋值为 middle + 1</p> 
<p>   3、middle的取值</p> 
<p>    如果写成 middle= (Left+Right)/2是有问题的,数字较大就可能溢出,计算机位运算比除法快,故可改成low+((high-low)&gt;&gt;1)</p> 
<pre><code class="language-cpp">class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]

        while (left &lt;= right) { // 当left==right，区间[left, right]依然有效，所以用 &lt;=
            int middle = left + ((right - left) &gt;&gt; 1 );// 防止溢出 等同于(left + right)/2
            if (nums[middle] &gt; target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            }
            else if (nums[middle] &lt; target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            }
            else // (nums[middle] == target)
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};</code></pre> 
<p>第二种写法:</p> 
<p>如果说定义 target 是在一个在左闭右开的区间里，也就是[Left, Right) ，那么二分法的边界处理方式则截然不同。</p> 
<p>1、循环退出的条件</p> 
<p>注意是Left&lt; Right,而不是Left&lt;= Right。因为当Left==Right，区间[Left, Right）是无效的，比如区间[2, 2），已经没有值了</p> 
<p>2、Left与Right的赋值</p> 
<p>if (nums[middle] &gt; target) Right 更新为 middle，因为寻找区间是左闭右开区间，所以right更新为middle，而Left还是闭区间，所以Left依然为 middle + 1</p> 
<pre><code class="language-cpp">class Solution2 {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        int left = 0;
        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)
        while (left &lt; right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;
            int middle = left + ((right - left) &gt;&gt; 1);
            if (nums[middle] &gt; target) {
                right = middle; // target 在左区间，在[left, middle)中
            }
            else if (nums[middle] &lt; target) {
                left = middle + 1; // target 在右区间，在[middle + 1, right)中
            }
            else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};</code></pre> 
<h4><br> 三、递归实现</h4> 
<pre><code class="language-cpp">int bsearchInternally(vector&lt;int&gt;&amp; a, int low, int high, int value)
{
	if (low &gt; high)
    {
        return -1;
    }
		
	int mid = low + ((high - low) &gt;&gt; 1);
	if (a[mid] == value) {
		return mid;
	}
	else if (a[mid] &lt; value)
		return bsearchInternally(a, mid + 1, high, value);
	else {
		return bsearchInternally(a, low, mid - 1, value);
	}
}

int bsearch(vector&lt;int&gt;&amp; a, int val) {
    int length = a.size();
	int res= bsearchInternally(a, 0, length - 1, val);
	return res;
}
</code></pre> 
<h4>四、二分法的写法总结</h4> 
<p>二分法是非常重要的基础算法，为什么很多人对于二分法都是<strong>一看就会，一写就废</strong>？</p> 
<p>其实主要就是对区间的定义没有理解清楚，在循环中没有始终坚持根据查找区间的定义来做边界处理。区间的定义就是不变量，那么在循环中坚持根据查找区间的定义来做边界处理，就是循环不变量规则。</p> 
<p></p> 
<p>参考：</p> 
<p><a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF" rel="nofollow" title="代码随想录">代码随想录</a></p> 
<p><a href="https://labuladong.github.io/algo/1/17/" rel="nofollow" title="算法笔试「骗分」套路 :: labuladong的算法小抄">算法笔试「骗分」套路 :: labuladong的算法小抄</a></p> 
<p><a href="https://blog.csdn.net/z_s_z2016/article/details/98470716" title="二分法查找_Zach的博客-CSDN博客_二分法查找">二分法查找_Zach的博客-CSDN博客_二分法查找</a><br><br>  </p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5b0c1aa96ea76af848d441295d1fa678/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用Python获取最新的省、市、县</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ba587e0617f576a7701c8ec6cc84d175/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Typora</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>