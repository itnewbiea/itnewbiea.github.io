<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一文讲清楚检索增强生成（RAG） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一文讲清楚检索增强生成（RAG）" />
<meta property="og:description" content="文章目录 什么是检索增强生成？逆向工作：为大语言模型提供额外的知识来回答问题通过系统提示给出LLM自定义指令为LLM提供特定的知识来源将所有内容放在一起并提出问题检索步骤：从您的知识库中获取正确的信息什么是嵌入？它们与知识检索有什么关系？使用嵌入找到最好的知识片段为您的知识库建立索引回顾整个过程 推荐阅读 How do domain-specific chatbots work? An Overview of Retrieval Augmented Generation (RAG)，本文是该文章的中译版。
有一个名为LangChain的流行开源库，它可以创建聊天机器人，其中包括用 3 3 3 行代码对任何网站/文档进行问答。这是LangChain文档中的一个示例。
from langchain.document_loaders import WebBaseLoader from langchain.indexes import VectorstoreIndexCreator loader = WebBaseLoader(&#34;http://www.paulgraham.com/greatwork.html&#34;) index = VectorstoreIndexCreator().from_loaders([loader]) index.query(&#34;What should I work on?&#34;) 它输出特定于Paul Graham文章的答案：
The work you choose should ideally have three qualities: it should be something you have a natural aptitude for, something you have a deep interest in, and something that offers scope to do great work." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e99b91cc286961d4615bd8eb337d7c52/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-19T15:12:05+08:00" />
<meta property="article:modified_time" content="2023-10-19T15:12:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一文讲清楚检索增强生成（RAG）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_32" rel="nofollow">什么是检索增强生成？</a></li><li><a href="#_58" rel="nofollow">逆向工作：为大语言模型提供额外的知识来回答问题</a></li><li><a href="#LLM_70" rel="nofollow">通过系统提示给出LLM自定义指令</a></li><li><a href="#LLM_82" rel="nofollow">为LLM提供特定的知识来源</a></li><li><a href="#_110" rel="nofollow">将所有内容放在一起并提出问题</a></li><li><a href="#_143" rel="nofollow">检索步骤：从您的知识库中获取正确的信息</a></li><li><a href="#_164" rel="nofollow">什么是嵌入？它们与知识检索有什么关系？</a></li><li><a href="#_191" rel="nofollow">使用嵌入找到最好的知识片段</a></li><li><a href="#_239" rel="nofollow">为您的知识库建立索引</a></li><li><a href="#_299" rel="nofollow">回顾整个过程</a></li></ul> 
</div> 
<p></p> 
<p>推荐阅读 <a href="https://scriv.ai/guides/retrieval-augmented-generation-overview/" rel="nofollow">How do domain-specific chatbots work? An Overview of Retrieval Augmented Generation (RAG)</a>，本文是该文章的中译版。</p> 
<p>有一个名为<a href="https://python.langchain.com/" rel="nofollow">LangChain</a>的流行开源库，它可以创建聊天机器人，其中包括用 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         3 
        
       
      
        3 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">3</span></span></span></span></span> 行代码对任何网站/文档进行问答。这是<a href="https://python.langchain.com/docs/use_cases/question_answering/" rel="nofollow">LangChain文档中的一个示例</a>。</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> langchain<span class="token punctuation">.</span>document_loaders <span class="token keyword">import</span> WebBaseLoader
<span class="token keyword">from</span> langchain<span class="token punctuation">.</span>indexes <span class="token keyword">import</span> VectorstoreIndexCreator

loader <span class="token operator">=</span> WebBaseLoader<span class="token punctuation">(</span><span class="token string">"http://www.paulgraham.com/greatwork.html"</span><span class="token punctuation">)</span>
index <span class="token operator">=</span> VectorstoreIndexCreator<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>from_loaders<span class="token punctuation">(</span><span class="token punctuation">[</span>loader<span class="token punctuation">]</span><span class="token punctuation">)</span>
index<span class="token punctuation">.</span>query<span class="token punctuation">(</span><span class="token string">"What should I work on?"</span><span class="token punctuation">)</span>
</code></pre> 
<p>它输出特定于<a href="http://www.paulgraham.com/greatwork.html" rel="nofollow">Paul Graham文章</a>的答案：</p> 
<blockquote> 
 <p>The work you choose should ideally have three qualities: it should be something you have a natural aptitude for, something you have a deep interest in, and something that offers scope to do great work. If you’re unsure, you could start by working on your own projects that seem excitingly ambitious to you. It’s also beneficial to be curious, try lots of things, meet lots of people, read lots of books, and ask lots of questions. When in doubt, optimize for interestingness. It’s okay to guess and be wrong sometimes, as this can lead to discovering what you’re truly good at or interested in.</p> 
</blockquote> 
<p>注意：如果您有兴趣，可以尝试<a href="https://scriv.ai/a/scriv/bots/b/pg-bot/chat/" rel="nofollow">根据Paul Graham的文章构建的聊天机器人</a>。</p> 
<p>第一次运行它时感觉就像纯粹的魔法。这到底是如何工作的？</p> 
<p>答案是一个称为 <strong>检索增强生成（Retrieval Augmented Generation）</strong> 的过程，简称 <strong>RAG</strong>。这是一个非常简单的概念，但其实现细节也具有令人难以置信的深度。</p> 
<p>这篇文章将提供RAG的深层概述。我们将从正在发生的事情的整体工作流程开始，然后放大所有单独的部分。到最后，您应该对这三行神奇代码的工作原理以及创建这些问答机器人所涉及的所有原理有一个深入的了解。</p> 
<p>如果您是一名尝试构建这样的机器人的开发人员，您将学到您可以调整哪些旋钮以及如何调整它们。如果您是一名非开发人员，希望在数据集上使用AI工具，您将获得有助于您充分利用这些工具的知识。而且，如果您只是一个好奇的人，您有望对一些正在颠覆我们生活的技术了解一两件事。</p> 
<p>让我们深入了解一下。</p> 
<h2><a id="_32"></a>什么是检索增强生成？</h2> 
<p>检索增强生成是用从其他地方检索到的附加信息来补充用户输入到ChatGPT等大语言模型（large language model, LLM）的过程。然后，LLM可以使用该信息来增强其生成的回复。</p> 
<p>下图显示了它在实践中的工作原理：</p> 
<p><img src="https://images2.imgbox.com/17/52/lKjcGEqs_o.png" alt="" width="90%"></p> 
<p>它从用户的问题开始。例如 <code>How do I do &lt;something&gt;?</code></p> 
<p>首先发生的是检索步骤。这是接受用户问题并从知识库中搜索可能回答该问题的最相关内容的过程。检索步骤是迄今为止RAG链中最重要、最复杂的部分。但现在，可以仅仅将其想象成一个知道如何提取与用户查询相关的最佳相关信息块的黑匣子。</p> 
<blockquote> 
 <p><strong>难道我们不能只给LLM整个知识库吗？</strong><br> 您可能想知道为什么我们费心检索而不是只将整个知识库发送给LLM。原因之一是模型对一次可以消耗的文本量有内置的限制（尽管这些限制正在迅速增加）。第二个原因是成本——发送大量文本会变得相当昂贵。最后，有<a href="https://arxiv.org/abs/2307.03172" rel="nofollow">证据</a>表明发送少量相关信息会得到更好的答案。</p> 
</blockquote> 
<p>一旦我们从知识库中获取了相关信息，我们就会将其与用户的问题一起发送到大语言模型（LLM）。然后，LLM（最常见的是ChatGPT）“读取”所提供的信息并回答问题。这是增强生成步骤。</p> 
<p>非常简单，对吧？</p> 
<h2><a id="_58"></a>逆向工作：为大语言模型提供额外的知识来回答问题</h2> 
<p>我们将从最后一步开始：答案生成（answer generation）。也就是说，假设我们已经从知识库中提取了我们认为可以回答问题的相关信息。我们如何使用它来生成答案？</p> 
<p><img src="https://images2.imgbox.com/78/f0/XAx7AFMI_o.png" alt="" width="70%"></p> 
<p>这个过程可能感觉像黑魔法，但在幕后它只是一个语言模型。因此，从广义上讲，答案是“只需询问LLM即可”。我们如何让大语言模型来做这样的事情？</p> 
<p>我们将使用ChatGPT作为示例。就像常规ChatGPT一样，这一切都取决于提示和消息。</p> 
<h2><a id="LLM_70"></a>通过系统提示给出LLM自定义指令</h2> 
<p>第一个组成部分是系统提示（system prompt）。系统提示给予语言模型整体指导。对于ChatGPT，系统提示类似于 <code>You are a helpful assistant.</code>。</p> 
<p>在这种情况下，我们希望它执行更具体的操作。而且，由于它是一个语言模型，我们可以告诉它我们想要它做什么。下面是一个简短的系统提示示例，为LLM提供了更详细的说明：</p> 
<blockquote> 
 <p>You are a Knowledge Bot. You will be given the extracted parts of a knowledge base (labeled with DOCUMENT) and a question. Answer the question using information from the knowledge base.</p> 
</blockquote> 
<p>我们基本上是在说 <code>Hey AI, we’re gonna give you some stuff to read. Read it and then answer our question, k? Thx.</code>，而且，因为AI非常善于遵循我们的指示，所以它有点……有效。</p> 
<h2><a id="LLM_82"></a>为LLM提供特定的知识来源</h2> 
<p>接下来，我们需要为AI提供阅读材料。再说一遍——最新的AI真的很擅长解决问题。但是，我们可以通过一些结构和格式来帮助它。</p> 
<p>以下是您可以用来将文档传递给LLM的示例格式：</p> 
<pre><code>------------ DOCUMENT 1 -------------

This document describes the blah blah blah...

------------ DOCUMENT 2 -------------

This document is another example of using x, y and z...

------------ DOCUMENT 3 -------------

[more documents here...]
</code></pre> 
<p>您需要所有这些格式吗？可能不是，但是让事情尽可能明确是件好事。您还可以使用机器可读的格式，例如JSON或YAML。或者，如果您感觉很活跃，您可以将所有内容转储到一大堆文本中。但是，在更高级的用例中，保持一些一致的格式变得很重要，例如，如果您希望LLM引用其来源。</p> 
<p>一旦我们格式化了文档，我们只需将其作为普通聊天消息发送给LLM。请记住，在系统提示中我们告诉它我们要给它一些文件，这就是我们在这里所做的一切。</p> 
<h2><a id="_110"></a>将所有内容放在一起并提出问题</h2> 
<p>一旦我们收到系统提示和文档消息，我们只需将用户的问题与它们一起发送给大语言模型。以下是使用 OpenAI <a href="https://platform.openai.com/docs/guides/gpt/chat-completions-api" rel="nofollow">ChatCompletion API</a> 在 Python 代码中的样子：</p> 
<pre><code class="prism language-python">openai_response <span class="token operator">=</span> openai<span class="token punctuation">.</span>ChatCompletion<span class="token punctuation">.</span>create<span class="token punctuation">(</span>
    model<span class="token operator">=</span><span class="token string">"gpt-3.5-turbo"</span><span class="token punctuation">,</span>
    messages<span class="token operator">=</span><span class="token punctuation">[</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token string">"role"</span><span class="token punctuation">:</span> <span class="token string">"system"</span><span class="token punctuation">,</span>
            <span class="token string">"content"</span><span class="token punctuation">:</span> get_system_prompt<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment"># the system prompt as per above</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token string">"role"</span><span class="token punctuation">:</span> <span class="token string">"system"</span><span class="token punctuation">,</span>
            <span class="token string">"content"</span><span class="token punctuation">:</span> get_sources_prompt<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment"># the formatted documents as per above</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token string">"role"</span><span class="token punctuation">:</span> <span class="token string">"user"</span><span class="token punctuation">,</span>
            <span class="token string">"content"</span><span class="token punctuation">:</span> user_question<span class="token punctuation">,</span>  <span class="token comment"># the question we want to answer</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
</code></pre> 
<p>就是这样！一个自定义系统提示、两条消息，您就可以得到特定于上下文的答案！</p> 
<p>这是一个简单的用例，可以对其进行扩展和改进。我们还没有做的一件事是告诉AI如果在来源中找不到答案该怎么办。我们可以将这些指令添加到系统提示中，通常是告诉它拒绝回答，或者使用它的常识，具体取决于您的机器人所需的行为。您还可以让大语言模型引用其用于回答问题的具体来源。我们将在以后的帖子中讨论这些策略，但现在，这是答案生成的基础知识。</p> 
<p>简单的部分已经完成，是时候回到我们跳过的那个黑匣子了……</p> 
<h2><a id="_143"></a>检索步骤：从您的知识库中获取正确的信息</h2> 
<p>上面我们假设我们有正确的知识片段可以发送给大语言模型。但我们如何从用户的问题中真正得到这些呢？这便是检索步骤，它是任何“与数据聊天”系统中基础设施的核心部分。</p> 
<p><img src="https://images2.imgbox.com/69/b4/yhrKub4X_o.png" alt="" width="78%"></p> 
<p>从本质上讲，检索是一种搜索操作——我们希望根据用户的输入查找最相关的信息。就像搜索一样，有两个主要部分：</p> 
<ol><li><strong>索引（Indexing）</strong>：将您的知识库变成可以搜索/查询的内容。</li><li><strong>查询（Querying）</strong>：从搜索词中提取最相关的知识。</li></ol> 
<p>值得注意的是，任何搜索过程都可以用于检索。任何接受用户输入并返回一些结果的东西都可以工作。因此，举例来说，您可以尝试查找与用户问题相匹配的文本并将其发送给大语言模型，或者您可以通过Google搜索该问题并将最重要的结果发送出去——顺便说一句，这大约就是Bing聊天机器人的工作原理。</p> 
<p>当今大多数RAG系统都依赖于语义搜索（semantic search），它使用AI技术的另一个核心部分：嵌入（embeddings）。在这里我们将重点关注该用例。</p> 
<p>那么……什么是嵌入？</p> 
<h2><a id="_164"></a>什么是嵌入？它们与知识检索有什么关系？</h2> 
<p>LLMs很奇怪。它们最奇怪的事情之一是没有人真正知道它们如何理解语言。嵌入是这个故事的重要组成部分。</p> 
<p>如果你问一个人如何将单词转化为意义，他们可能会摸索并说出一些模糊且自我指涉的内容，例如“因为我知道它们的意思”。在我们大脑深处的某个地方，有一个复杂的结构，它知道“child”和“kid”基本上是相同的，“red”和“green”都是颜色，“pleased”、“happy”和“elated”代表着相同的情绪，但程度不同。我们无法解释它是如何工作的，我们只是知道它。</p> 
<p>语言模型对语言有类似的复杂理解，只不过，因为它们是计算机，所以它不在它们的大脑中，而是由数字组成。在大语言模型的世界中，任何人类语言都可以表示为数字向量（列表）。这个数字向量就是一个嵌入（embedding）。</p> 
<p>LLM技术的一个关键部分是从人类的文字语言（word-language）到AI的数字语言（number-language）的翻译器（translator）。我们将这个翻译器称为“嵌入机”（embedding machine），尽管在幕后它只是一个API调用。输入人类语言，输出AI数字。</p> 
<p><img src="https://images2.imgbox.com/9a/3f/m4yVoyqE_o.png" alt="" width="88%"></p> 
<p>这些数字意味着什么？没有人知道！它们只对AI有意义。但是，我们所知道的是，相似的单词最终会得到相似的数字组。因为在幕后，AI使用这些数字来“阅读”和“说话”。因此，这些数字在AI语言中融入了某种神奇的理解力，即使我们无法理解它。嵌入机就是我们的翻译器。</p> 
<p>现在，既然我们有了这些神奇的AI数字，我们就可以绘制它们。上述示例的简化图可能看起来像这样——其中轴只是人类/AI语言的一些抽象表示：</p> 
<p><img src="https://images2.imgbox.com/6d/9c/wk0dBEGt_o.png" alt="" width="70%"></p> 
<p>一旦我们绘制了它们，我们就可以看到，在这个假设的语言空间中，两点彼此越接近，它们就越相似。<code>Hello, how are you?</code> 和 <code>Hey, how’s it going?</code> 实际上是互相重叠的。另一种问候语 <code>Good morning!</code> 与这些问候语相距不远。而 <code>I like cupcakes.</code> 则位于一个与其他完全不同的岛屿上。</p> 
<p>当然，你无法在二维图上表示整个人类语言，但理论是相同的。实际上，嵌入有更多的坐标（OpenAI当前使用的模型有1536个）。但您仍然可以进行基本数学计算来确定两个嵌入（两段文本）彼此之间的接近程度。</p> 
<p>这些嵌入和确定“接近度”（closeness）是语义搜索背后的核心原则，为检索步骤提供动力。</p> 
<h2><a id="_191"></a>使用嵌入找到最好的知识片段</h2> 
<p>一旦我们了解了嵌入搜索的工作原理，我们就可以构建检索步骤的高级图像。</p> 
<p>在索引方面，首先我们必须将知识库分解为文本块。这个过程本身就是一个完整的优化问题，我们接下来将介绍它，但现在假设我们知道如何去做。</p> 
<p><img src="https://images2.imgbox.com/01/95/mMAPl6gD_o.png" alt="" width="75%"></p> 
<p>完成此操作后，我们将每个知识片段通过嵌入机（实际上是OpenAI API或类似机制）传递，并返回该文本的嵌入表示。然后，我们保存该片段以及向量数据库（vector database）中的嵌入，该数据库针对数字向量进行了优化。</p> 
<p><img src="https://images2.imgbox.com/46/24/ku0ZozL5_o.png" alt="" width="70%"></p> 
<p>现在我们有了一个数据库，其中嵌入了我们所有的内容。从概念上讲，您可以将其视为我们整个知识库在“语言”图上的图：</p> 
<p><img src="https://images2.imgbox.com/11/4d/9ugxZ2P4_o.png" alt="" width="70%"></p> 
<p>一旦我们有了这个图，在查询方面，我们就会执行类似的过程。首先我们获得用户输入的嵌入：</p> 
<p><img src="https://images2.imgbox.com/af/da/gd7YemWb_o.png" alt="" width="88%"></p> 
<p>然后我们将其绘制在相同的向量空间中并找到最接近的片段（在本例中为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
      
        1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
      
        2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span></span></span></span>）：</p> 
<p><img src="https://images2.imgbox.com/4c/39/S4On590U_o.png" alt="" width="73%"></p> 
<p>神奇的嵌入机认为这些是与所提出的问题最相关的答案，因此这些是我们提取发送给大语言模型的片段！</p> 
<p>实际上，“最近的点是什么”这个问题是通过在我们的向量数据库中查询完成的。所以实际的过程看起来更像是这样的：</p> 
<p><img src="https://images2.imgbox.com/98/c0/gkvUKmyj_o.png" alt="" width="90%"></p> 
<p>查询本身涉及一些半复杂的数学——通常使用称为余弦距离的东西，尽管还有其他计算方法。数学是您可以进入的整个空间，但超出了本文的范围，并且从实际角度来看，很大程度上可以转移到图书馆或数据库中。</p> 
<blockquote> 
 <p><strong>回到LangChain</strong><br> 在我们的LangChain示例中，我们现在已经涵盖了下面这一行代码完成的所有操作。这个小函数调用隐藏了很多复杂性！<br> <code>index.query("What should I work on?")</code></p> 
</blockquote> 
<h2><a id="_239"></a>为您的知识库建立索引</h2> 
<p>好吧，我们就快完成了。我们现在了解如何使用嵌入来查找知识库中最相关的部分，将所有内容传递给大语言模型，并获取增强的答案。我们将介绍的最后一步是从您的知识库创建初始索引。换句话说，就是下面这张图中的“知识分片机”（knowledge splitting machine）。</p> 
<p><img src="https://images2.imgbox.com/63/3e/wpIcYrLk_o.png" alt="" width="85%"></p> 
<p>也许令人惊讶的是，索引您的知识库通常是整个事情中最困难和最重要的部分。不幸的是，它更多的是艺术而不是科学，并且涉及大量的试验和错误。总体而言，索引过程可归结为两个高级步骤。</p> 
<ol><li><strong>加载（Loading）</strong>：从通常存储的位置获取知识库的内容。</li><li><strong>分片（Splitting）</strong>：将知识分割成适合嵌入搜索的片段大小的块。</li></ol> 
<blockquote> 
 <p><strong>技术澄清</strong><br> 从技术上讲，“加载器”（loaders）和“分片器”（splitters）之间的区别有些随意。你可以想象一个单一的组件同时完成所有的工作，或者将加载阶段分解为多个子组件。<br> 也就是说，“加载器”和“分片器”是LangChain中的完成方式，它们提供了基本概念之上的有用抽象。</p> 
</blockquote> 
<p>让我们以我自己的用例为例。我想构建一个聊天机器人来回答有关我的 <a href="https://www.saaspegasus.com/" rel="nofollow">saas boilerplate product, SaaS Pegasus</a> 问题。我想添加到我的知识库中的第一件事是<a href="https://docs.saaspegasus.com/" rel="nofollow">文档站点</a>。加载器是一个基础设施，它可以访问我的文档，找出可用的页面，然后拉取每个页面。加载程序完成后，它将输出单独的文档——网站上的每个页面都有一个文档。</p> 
<p><img src="https://images2.imgbox.com/ef/a6/HtqgOUii_o.png" alt="" width="86%"></p> 
<p>加载器内部发生了很多事情！我们需要抓取所有页面，抓取每个页面的内容，然后将HTML格式化为可用的文本。还有用于其他东西（例如PDF或Google Drive）的加载器有不同的部分。还有并行化、错误处理等等需要解决。再强调一遍，这是一个几乎无限复杂的主题，但出于本文的目的，我们将主要将其转移到一个库中。所以现在，我们再次假设我们有一个神奇的盒子，里面有一个“知识库”（knowledge base），然后出来的是单独的“文档”（documents）。</p> 
<blockquote> 
 <p><strong>LangChain中的加载器</strong><br> 内置加载器是LangChain最有用的部件之一。它们提供了<a href="https://python.langchain.com/docs/integrations/document_loaders/" rel="nofollow">一系列的内置加载器</a>，可用于从Microsoft Word文档到整个Notion站点的任何内容中提取内容。<br> LangChain加载器的界面与上面描述的完全相同。输入一个“知识库”，出来一系列“文档”。</p> 
</blockquote> 
<p>从加载器中出来后，我们将获得与文档站点中每个页面相对应的文档集合。此外，理想情况下，此时额外的标记已被删除，仅保留底层结构和文本。</p> 
<p>现在，我们可以将这些整个网页传递到我们的嵌入机并将其用作我们的知识片段。但是，每一页可能涵盖很多内容！而且，页面中的内容越多，该页面的嵌入就越“不具体”（unspecific）。这意味着我们的“接近度”搜索算法可能不太有效。</p> 
<p>更有可能的是用户问题的主题与页面内的某些文本相匹配。这就是下图中分片的作用。通过分片，我们将任何单个文档分割成小块的、可嵌入的块，更适合搜索。</p> 
<p><img src="https://images2.imgbox.com/eb/ec/n79ECIva_o.png" alt="" width="80%"></p> 
<p>再次注意，分割文档是一门完整的艺术，包括平均片段的大小（太大，它们不能很好地匹配查询；太小，它们没有足够的有用上下文来生成答案），如何拆分内容（通常按标题，如果有的话）等等。但是，一些合理的默认值足以开始使用和完善您的数据。</p> 
<blockquote> 
 <p><strong>LangChain中的分片器</strong><br> 在LangChain中，分片器属于一个更大的类别，称为<a href="https://python.langchain.com/docs/modules/data_connection/document_transformers/" rel="nofollow">文档转换器</a>（document transformer）。除了提供各种分割文档的策略之外，他们还提供删除冗余内容、翻译、添加元数据等工具。我们在这里只关注分片器，因为它们代表了绝大多数文档转换。</p> 
</blockquote> 
<p>一旦我们有了文档片段，我们就将它们保存到我们的向量数据库中，如上所述，我们终于完成了！</p> 
<p>这是索引知识库的完整图片。</p> 
<p><img src="https://images2.imgbox.com/97/fb/5VlIY9xL_o.png" alt="" width="90%"></p> 
<blockquote> 
 <p><strong>回到LangChain</strong><br> 在LangChain中，整个索引过程都封装在这两行代码中。首先我们初始化网站加载器并告诉它我们要使用什么内容：<br> <code>loader = WebBaseLoader("http://www.paulgraham.com/greatwork.html")</code><br> 然后我们从加载器构建整个索引并保存它到我们的向量数据库：<br> <code>index = VectorstoreIndexCreator().from_loaders([loader])</code><br> 加载（loading）、分片（splitting）、嵌入（embedding）和保存（saving）都在幕后发生。</p> 
</blockquote> 
<h2><a id="_299"></a>回顾整个过程</h2> 
<p>最后，我们可以得出整个RAG工作流程。它看起来是这样的：</p> 
<p><img src="https://images2.imgbox.com/16/6d/Ugnh8wMB_o.png" alt="" width="88%"></p> 
<p>首先，我们索引我们的知识库。我们获取知识并使用加载器将其转换为单独的文档，然后使用分片器将其转换为小块或片段。一旦我们有了这些，我们就把它们传递给嵌入机，嵌入机将它们转换成可用于语义搜索的向量。我们将这些嵌入及其文本片段保存在我们的向量数据库中。</p> 
<p>接下来是检索。它从问题开始，然后通过相同的嵌入机发送并传递到我们的向量数据库以确定最接近的匹配片段，我们将用它来回答问题。</p> 
<p>最后，增强答案生成。我们获取知识片段，将它们与自定义系统提示和我们的问题一起格式化，最后得到我们上下文特定的答案。</p> 
<p>哇！希望您现在对检索增强生成的工作原理有一个基本的了解。如果您想在自己的知识库上尝试一下，而不需要进行所有设置工作，请查看<a href="https://scriv.ai/" rel="nofollow">Scriv.ai</a>，它可以让您在短短几分钟内构建特定领域的聊天机器人，而无需任何编码技能。</p> 
<p>在以后的文章中，我们将扩展其中许多概念，包括可以改进此处概述的“默认”设置的所有方法。正如我所提到的，这些部分中的每一部分都有几乎无限的深度，将来我们将一次深入地研究这些部分。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fb436176e70334e1007236e78c98cb45/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">开发板配置AP模式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ab13e50b9427f04b1c3764c598e21913/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;——入门</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>