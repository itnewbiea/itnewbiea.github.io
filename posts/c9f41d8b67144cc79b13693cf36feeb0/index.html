<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringCloud&#43;SpringBoot&#43;SSO单点登录之OAuth2.0登录认证(1) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringCloud&#43;SpringBoot&#43;SSO单点登录之OAuth2.0登录认证(1)" />
<meta property="og:description" content="今天我们对OAuth2.0的整合方式做一下笔记，首先我从网上找了一些关于OAuth2.0的一些基础知识点，帮助大家回顾一下知识点：
一、oauth中的角色
client：调用资源服务器API的应用
Oauth 2.0 Provider：包括Authorization Server和Resource Server
（1）Authorization Server：认证服务器，进行认证和授权
（2）Resource Server：资源服务器，保护受保护的资源
user：资源的拥有者
二、下面详细介绍一下Oauth 2.0 Provider（了解源码可&#43;求求: 1791743380）
Authorization Server:
（1）AuthorizationEndpoint:进行授权的服务，Default URL: /oauth/authorize
（2）TokenEndpoint：获取token的服务，Default URL: /oauth/token
Resource Server:
OAuth2AuthenticationProcessingFilter：给带有访问令牌的请求加载认证
三、下面再来详细介绍一下Authorization Server:
一般情况下，创建两个配置类，一个继承AuthorizationServerConfigurerAdapter，一个继承WebSecurityConfigurerAdapter，再去复写里面的方法。
主要出现的两种注解：
1、@EnableAuthorizationServer：声明一个认证服务器，当用此注解后，应用启动后将自动生成几个Endpoint：（注：其实实现一个认证服务器就是这么简单，加一个注解就搞定，当然真正用到生产环境还是要进行一些配置和复写工作的。）
/oauth/authorize：验证
/oauth/token：获取token
/oauth/confirm_access：用户授权
/oauth/error：认证失败
/oauth/check_token：资源服务器用来校验token
/oauth/token_key：如果jwt模式则可以用此来从认证服务器获取公钥
以上这些endpoint都在源码里的endpoint包里面。
2、@Beans：需要实现AuthorizationServerConfigurer
AuthorizationServerConfigurer包含三种配置：
ClientDetailsServiceConfigurer：client客户端的信息配置，client信息包括：clientId、secret、scope、authorizedGrantTypes、authorities
（1）scope：表示权限范围，可选项，用户授权页面时进行选择
（2）authorizedGrantTypes：有四种授权方式
Authorization Code：用验证获取code，再用code去获取token（用的最多的方式，也是最安全的方式）
Implicit: 隐式授权模式
Client Credentials (用來取得 App Access Token)
Resource Owner Password Credentials
（3）authorities：授予client的权限
这里的具体实现有多种，in-memory、JdbcClientDetailsService、jwt等。
AuthorizationServerSecurityConfigurer：声明安全约束，哪些允许访问，哪些不允许访问
AuthorizationServerEndpointsConfigurer：声明授权和token的端点以及token的服务的一些配置信息，比如采用什么存储方式、token的有效期等
client的信息的读取：在ClientDetailsServiceConfigurer类里面进行配置，可以有in-memory、jdbc等多种读取方式。
jdbc需要调用JdbcClientDetailsService类，此类需要传入相应的DataSource.
下面再介绍一下如何管理token:
AuthorizationServerTokenServices接口:声明必要的关于token的操作
（1）当token创建后，保存起来，以便之后的接受访问令牌的资源可以引用它。
（2）访问令牌用来加载认证" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c9f41d8b67144cc79b13693cf36feeb0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-10T11:42:17+08:00" />
<meta property="article:modified_time" content="2020-06-10T11:42:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringCloud&#43;SpringBoot&#43;SSO单点登录之OAuth2.0登录认证(1)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>今天我们对OAuth2.0的整合方式做一下笔记，首先我从网上找了一些关于OAuth2.0的一些基础知识点，帮助大家回顾一下知识点：</p> 
<p><strong>一、oauth中的角色</strong></p> 
<p>client：调用资源服务器API的应用<br> Oauth 2.0 Provider：包括Authorization Server和Resource Server</p> 
<p>（1）Authorization Server：认证服务器，进行认证和授权</p> 
<p>（2）Resource Server：资源服务器，保护受保护的资源</p> 
<p>user：资源的拥有者</p> 
<p><strong>二、下面详细介绍一下Oauth 2.0 Provider</strong>（了解源码可+求求: 1791743380）<br> Authorization Server:</p> 
<p>（1）AuthorizationEndpoint:进行授权的服务，Default URL: /oauth/authorize</p> 
<p>（2）TokenEndpoint：获取token的服务，Default URL: /oauth/token<br> Resource Server:</p> 
<p>OAuth2AuthenticationProcessingFilter：给带有访问令牌的请求加载认证</p> 
<p><strong>三、下面再来详细介绍一下Authorization Server:</strong></p> 
<p>一般情况下，创建两个配置类，一个继承AuthorizationServerConfigurerAdapter，一个继承WebSecurityConfigurerAdapter，再去复写里面的方法。</p> 
<p>主要出现的两种注解：</p> 
<p>1、@EnableAuthorizationServer：声明一个认证服务器，当用此注解后，应用启动后将自动生成几个Endpoint：（注：其实实现一个认证服务器就是这么简单，加一个注解就搞定，当然真正用到生产环境还是要进行一些配置和复写工作的。）</p> 
<p>/oauth/authorize：验证<br> /oauth/token：获取token<br> /oauth/confirm_access：用户授权<br> /oauth/error：认证失败<br> /oauth/check_token：资源服务器用来校验token<br> /oauth/token_key：如果jwt模式则可以用此来从认证服务器获取公钥</p> 
<p>以上这些endpoint都在源码里的endpoint包里面。</p> 
<p>2、@Beans：需要实现AuthorizationServerConfigurer</p> 
<p>AuthorizationServerConfigurer包含三种配置：<br> ClientDetailsServiceConfigurer：client客户端的信息配置，client信息包括：clientId、secret、scope、authorizedGrantTypes、authorities</p> 
<p>（1）scope：表示权限范围，可选项，用户授权页面时进行选择</p> 
<p>（2）authorizedGrantTypes：有四种授权方式</p> 
<p>Authorization Code：用验证获取code，再用code去获取token（用的最多的方式，也是最安全的方式）<br> Implicit: 隐式授权模式</p> 
<p>Client Credentials (用來取得 App Access Token)<br> Resource Owner Password Credentials</p> 
<p>（3）authorities：授予client的权限</p> 
<p>这里的具体实现有多种，in-memory、JdbcClientDetailsService、jwt等。</p> 
<p>AuthorizationServerSecurityConfigurer：声明安全约束，哪些允许访问，哪些不允许访问</p> 
<p>AuthorizationServerEndpointsConfigurer：声明授权和token的端点以及token的服务的一些配置信息，比如采用什么存储方式、token的有效期等</p> 
<p>client的信息的读取：在ClientDetailsServiceConfigurer类里面进行配置，可以有in-memory、jdbc等多种读取方式。</p> 
<p>jdbc需要调用JdbcClientDetailsService类，此类需要传入相应的DataSource.</p> 
<p>下面再介绍一下如何管理token:<br> AuthorizationServerTokenServices接口:声明必要的关于token的操作</p> 
<p>（1）当token创建后，保存起来，以便之后的接受访问令牌的资源可以引用它。<br> （2）访问令牌用来加载认证</p> 
<p>接口的实现也有多种，DefaultTokenServices是其默认实现，他使用了默认的InMemoryTokenStore，不会持久化token；</p> 
<p>token存储方式共有三种分别是：<br> （1）InMemoryTokenStore：存放内存中，不会持久化<br> （2）JdbcTokenStore：存放数据库中<br> （3）Jwt: json web token</p> 
<p><strong>授权类型：</strong><br> 可以通过AuthorizationServerEndpointsConfigurer来进行配置，默认情况下，支持除了密码外的所有授权类型。相关授权类型的一些类：</p> 
<p>（1）authenticationManager：直接注入一个AuthenticationManager，自动开启密码授权类型<br> （2）userDetailsService：如果注入UserDetailsService，那么将会启动刷新token授权类型，会判断用户是否还是存活的<br> （3）authorizationCodeServices：AuthorizationCodeServices的实例，auth code 授权类型的服务<br> （4）implicitGrantService：imlpicit grant<br> （5）tokenGranter：</p> 
<p><strong>endpoint的URL的配置：</strong><br> （1）AuthorizationServerEndpointsConfigurer的pathMapping()方法，有两个参数，第一个是默认的URL路径，第二个是自定义的路径<br> （2）WebSecurityConfigurer的实例，可以配置哪些路径不需要保护，哪些需要保护。默认全都保护。</p> 
<p><strong>自定义UI:</strong><br> （1）有时候，我们可能需要自定义的登录页面和认证页面。登陆页面的话，只需要创建一个login为前缀名的网页即可，在代码里，设置为允许访问，这样，系统会自动执行你的登陆页。此登陆页的action要注意一下，必须是跳转到认证的地址。<br> （2）另外一个是授权页，让你勾选选项的页面。此页面可以参考源码里的实现，自己生成一个controller的类，再创建一个对应的web页面即可实现自定义的功能。</p> 
<p><strong>下面梳理一下授权获取token流程：</strong></p> 
<p>（1）端口号换成你自己的认证服务器的端口号，client_id也换成你自己的，response_type类型为code。<br> localhost:8080/uaa/oauth/authorize?client_id=client&amp;response_type=code&amp;redirect_uri=http://www.baidu.com<br> （2）这时候你将获得一个code值：http://www.baidu.com/?code=G0C20Z<br> （3）使用此code值来获取最终的token：<br> curl -X POST -H “Cant-Type: application/x-www-form-urlencoded” -d ‘grant_type=authorization_code&amp;code=G0C20Z&amp;redirect_uri=http://www.baidu.com’ “http://client:secret@localhost:8080/uaa/oauth/token”</p> 
<p>返回值：<br> {“access_token”:“b251b453-cc08-4520-9dd0-9aedf58e6ca3”,“token_type”:“bearer”,“expires_in”:2591324,“scope”:“app”}</p> 
<p>（4）用此token值来调用资源服务器内容（如果资源服务器和认证服务器在同一个应用中，那么资源服务器会自己解析token值，如果不在，那么你要自己去做处理）<br> curl -H “Authorization: Bearer b251b453-cc08-4520-9dd0-9aedf58e6ca3” “localhost:8081/service2（此处换上你自己的url）”</p> 
<p><strong>四、Resource Server：保护资源，需要令牌才能访问</strong><br> 在配置类上加上注解@EnableResourceServer即启动。使用ResourceServerConfigurer进行配置：</p> 
<p>（1）tokenServices：ResourceServerTokenServices的实例，声明了token的服务<br> （2）resourceId：资源Id，由auth Server验证。<br> （3）其它一些扩展点，比如可以从请求中提取token的tokenExtractor<br> （4）一些自定义的资源保护配置，通过HttpSecurity来设置</p> 
<p><strong>使用token的方式也有两种：</strong><br> （1）Bearer Token（https传输方式保证传输过程的安全）:主流<br> （2）Mac（http+sign）</p> 
<p>如何访问资源服务器中的API？<br> 如果资源服务器和授权服务器在同一个应用程序中，并且您使用DefaultTokenServices，那么您不必太考虑这一点，因为它实现所有必要的接口，因此它是自动一致的。如果您的资源服务器是一个单独的应用程序，那么您必须确保您匹配授权服务器的功能，并提供知道如何正确解码令牌的</p> 
<p>ResourceServerTokenServices。与授权服务器一样，您可以经常使用DefaultTokenServices，并且选项大多通过TokenStore（后端存储或本地编码）表示。</p> 
<p>（1）在校验request中的token时，使用RemoteTokenServices去调用AuthServer中的/auth/check_token。<br> （2）共享数据库，使用Jdbc存储和校验token，避免再去访问AuthServer。<br> （3）使用JWT签名的方式，资源服务器自己直接进行校验，不借助任何中间媒介。</p> 
<p><strong>五、oauth client</strong><br> 在客户端获取到token之后，想去调用下游服务API时，为了能将token进行传递，可以使用RestTemplate.然后使用restTemplate进行调用Api。<br> 注：<br> scopes和authorities的区别：<br> scopes是client权限，至少授予一个scope的权限，否则报错。<br> authorities是用户权限。</p> 
<p>以上是我从网上找到的一篇写的不错的博客，希望可以帮助大家快速了解OAuth2.0,下一篇文章我们正式介绍OAuth2.0在当前框架中的使用。</p> 
<p>从现在开始，我这边会将近期研发的spring cloud微服务云架构的搭建过程和精髓记录下来，帮助更多有兴趣研发spring cloud框架的朋友，大家来一起探讨spring cloud架构的搭建过程及如何运用于企业项目。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/86bbb0a9017bd6c0e9bf71f65870a719/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">sql 动态写入数据库字段_批处理写入，动态SQL和参数化SQL，数据库的性能如何？...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b70c903ed1c97f9c14e58cb405e4b9fd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">操作系统---(38)关于页面调入和页面访问时间的讨论</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>