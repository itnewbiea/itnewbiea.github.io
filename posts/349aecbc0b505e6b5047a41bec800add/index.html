<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——非线性结构（图） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构——非线性结构（图）" />
<meta property="og:description" content="文章目录 一. 非线性结构的概述二. 图的基本概念1. 定义2. 无向图、有向图2.1 无向图2.2 有向图2.3 简单图2.4 多重图 3. 顶点的度、出度、入度3.1 对于无向图3.2 对于有向图 4. 边的权、带权图 (网）5. 点到点的关系5.1 顶点与顶点之间的关系描述5.2 连通的、强连通的、连通图、强连通图 6. 图的局部6.1 无向图子图、生成子图6.2 有向图子图、生成子图6.3 连通分量6.4 强连通分量 7. 几种特殊形态的图7.1 生成树7.2 生成森林7.3 无向完全图和有向完全图7.4 稀疏图和稠密图7.5 生成树和有向树 三. 图的存储1. 邻接矩阵法1.1 定义1.2 邻接矩阵存储有向图和无向图1.3 邻接矩阵存储带权图（网）1.4 邻接矩阵法的性能分析1.5 邻接矩阵法的性质 2. 邻接表法2.1 来源2.2 定义（采用顺序存储和链式存储结合）2.3 邻接表法的性质2.4 邻接表和邻接矩阵的比较 3. 十字链表（只能存储有向图）3.1 来源3.2 定义3.3 十字链表法性能分析 4. 邻接多重表（只能存储无向图）4.1 来源4.2 定义4.3 邻接多重表性能分析 5. 四种存储结构的比较 四. 图的基本操作五. 图的遍历1. 广度优先搜索（BFS遍历）1.1 概述1.2 复杂度分析1.3 广度优先生成树 2. 深度优先搜索（DFS遍历）2.1 概述2.2 复杂度分析2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/349aecbc0b505e6b5047a41bec800add/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-01T16:02:15+08:00" />
<meta property="article:modified_time" content="2022-10-01T16:02:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——非线性结构（图）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#__1" rel="nofollow">一. 非线性结构的概述</a></li><li><a href="#__3" rel="nofollow">二. 图的基本概念</a></li><li><ul><li><a href="#1__4" rel="nofollow">1. 定义</a></li><li><a href="#2__7" rel="nofollow">2. 无向图、有向图</a></li><li><ul><li><a href="#21__8" rel="nofollow">2.1 无向图</a></li><li><a href="#22__10" rel="nofollow">2.2 有向图</a></li><li><a href="#23__12" rel="nofollow">2.3 简单图</a></li><li><a href="#24__15" rel="nofollow">2.4 多重图</a></li></ul> 
   </li><li><a href="#3__18" rel="nofollow">3. 顶点的度、出度、入度</a></li><li><ul><li><a href="#31__19" rel="nofollow">3.1 对于无向图</a></li><li><a href="#32__22" rel="nofollow">3.2 对于有向图</a></li></ul> 
   </li><li><a href="#4___25" rel="nofollow">4. 边的权、带权图 (网）</a></li><li><a href="#5__29" rel="nofollow">5. 点到点的关系</a></li><li><ul><li><a href="#51__30" rel="nofollow">5.1 顶点与顶点之间的关系描述</a></li><li><a href="#52__32" rel="nofollow">5.2 连通的、强连通的、连通图、强连通图</a></li></ul> 
   </li><li><a href="#6__42" rel="nofollow">6. 图的局部</a></li><li><ul><li><a href="#61__43" rel="nofollow">6.1 无向图子图、生成子图</a></li><li><a href="#62__45" rel="nofollow">6.2 有向图子图、生成子图</a></li><li><a href="#63__47" rel="nofollow">6.3 连通分量</a></li><li><a href="#64__51" rel="nofollow">6.4 强连通分量</a></li></ul> 
   </li><li><a href="#7__54" rel="nofollow">7. 几种特殊形态的图</a></li><li><ul><li><a href="#71__55" rel="nofollow">7.1 生成树</a></li><li><a href="#72__58" rel="nofollow">7.2 生成森林</a></li><li><a href="#73__61" rel="nofollow">7.3 无向完全图和有向完全图</a></li><li><a href="#74__64" rel="nofollow">7.4 稀疏图和稠密图</a></li><li><a href="#75__66" rel="nofollow">7.5 生成树和有向树</a></li></ul> 
  </li></ul> 
  </li><li><a href="#__70" rel="nofollow">三. 图的存储</a></li><li><ul><li><a href="#1__74" rel="nofollow">1. 邻接矩阵法</a></li><li><ul><li><a href="#11__75" rel="nofollow">1.1 定义</a></li><li><a href="#12__79" rel="nofollow">1.2 邻接矩阵存储有向图和无向图</a></li><li><a href="#13__83" rel="nofollow">1.3 邻接矩阵存储带权图（网）</a></li><li><a href="#14__87" rel="nofollow">1.4 邻接矩阵法的性能分析</a></li><li><a href="#15__90" rel="nofollow">1.5 邻接矩阵法的性质</a></li></ul> 
   </li><li><a href="#2__99" rel="nofollow">2. 邻接表法</a></li><li><ul><li><a href="#21__100" rel="nofollow">2.1 来源</a></li><li><a href="#22__104" rel="nofollow">2.2 定义（采用顺序存储和链式存储结合）</a></li><li><a href="#23__108" rel="nofollow">2.3 邻接表法的性质</a></li><li><a href="#24__113" rel="nofollow">2.4 邻接表和邻接矩阵的比较</a></li></ul> 
   </li><li><a href="#3__119" rel="nofollow">3. 十字链表（只能存储有向图）</a></li><li><ul><li><a href="#31__120" rel="nofollow">3.1 来源</a></li><li><a href="#32__124" rel="nofollow">3.2 定义</a></li><li><a href="#33__132" rel="nofollow">3.3 十字链表法性能分析</a></li></ul> 
   </li><li><a href="#4__138" rel="nofollow">4. 邻接多重表（只能存储无向图）</a></li><li><ul><li><a href="#41__139" rel="nofollow">4.1 来源</a></li><li><a href="#42__144" rel="nofollow">4.2 定义</a></li><li><a href="#43__149" rel="nofollow">4.3 邻接多重表性能分析</a></li></ul> 
   </li><li><a href="#5__151" rel="nofollow">5. 四种存储结构的比较</a></li></ul> 
  </li><li><a href="#__155" rel="nofollow">四. 图的基本操作</a></li><li><a href="#__160" rel="nofollow">五. 图的遍历</a></li><li><ul><li><a href="#1_BFS_175" rel="nofollow">1. 广度优先搜索（BFS遍历）</a></li><li><ul><li><a href="#11__176" rel="nofollow">1.1 概述</a></li><li><a href="#12__196" rel="nofollow">1.2 复杂度分析</a></li><li><a href="#13__205" rel="nofollow">1.3 广度优先生成树</a></li></ul> 
   </li><li><a href="#2_DFS_212" rel="nofollow">2. 深度优先搜索（DFS遍历）</a></li><li><ul><li><a href="#21__213" rel="nofollow">2.1 概述</a></li><li><a href="#22__231" rel="nofollow">2.2 复杂度分析</a></li><li><a href="#23__239" rel="nofollow">2.3 深度优先生成树</a></li></ul> 
   </li><li><a href="#3__250" rel="nofollow">3. 图的遍历和图的连通性</a></li><li><ul><li><a href="#31__253" rel="nofollow">3.1 对于无向图</a></li><li><a href="#32__256" rel="nofollow">3.2 对于有向图</a></li></ul> 
  </li></ul> 
  </li><li><a href="#__260" rel="nofollow">六. 图的应用</a></li><li><ul><li><a href="#1__261" rel="nofollow">1. 最小生成（代价）树</a></li><li><ul><li><a href="#11__262" rel="nofollow">1.1 概述</a></li><li><ul><li><a href="#1__263" rel="nofollow">1) 来源</a></li><li><a href="#2__266" rel="nofollow">2) 定义</a></li><li><a href="#3__271" rel="nofollow">3) 性质</a></li></ul> 
    </li><li><a href="#12__276" rel="nofollow">1.2 求最小生成树的两种算法</a></li><li><ul><li><a href="#1_Prim_279" rel="nofollow">1) Prim算法</a></li><li><a href="#2_Kruskal_300" rel="nofollow">2) Kruskal算法</a></li><li><a href="#3__310" rel="nofollow">3) 两个算法的比较</a></li></ul> 
   </li></ul> 
   </li><li><a href="#2__318" rel="nofollow">2. 最短路径</a></li><li><ul><li><a href="#21__319" rel="nofollow">2.1 定义</a></li><li><a href="#22__322" rel="nofollow">2.2 分类</a></li><li><ul><li><a href="#1BFS_328" rel="nofollow">1）BFS求无权图的单源最短路径</a></li><li><a href="#2Dijkstra_336" rel="nofollow">2）Dijkstra算法求单源最短路径</a></li><li><a href="#3Floyd_362" rel="nofollow">3）Floyd算法求各顶点之间最短路径</a></li></ul> 
    </li><li><a href="#23__385" rel="nofollow">2.3 三种算法的比较</a></li></ul> 
   </li><li><a href="#3__389" rel="nofollow">3. 有向无环图描述表达式</a></li><li><ul><li><a href="#31__390" rel="nofollow">3.1 概述</a></li><li><a href="#32_DAG_401" rel="nofollow">3.2 DAG描述表达式</a></li><li><a href="#33__405" rel="nofollow">3.3 解题方法</a></li></ul> 
   </li><li><a href="#4__409" rel="nofollow">4. 拓扑排序</a></li><li><ul><li><a href="#41_AOV_410" rel="nofollow">4.1 AOV网</a></li><li><a href="#42__418" rel="nofollow">4.2 拓扑排序概述</a></li><li><a href="#43__430" rel="nofollow">4.3 拓扑排序常用方法</a></li><li><a href="#44__434" rel="nofollow">4.4 拓扑排序复杂度</a></li><li><a href="#45__440" rel="nofollow">4.5 逆拓扑排序</a></li></ul> 
   </li><li><a href="#5__446" rel="nofollow">5. 关键路径</a></li><li><ul><li><a href="#51_AOE_447" rel="nofollow">5.1 AOE网</a></li><li><a href="#52__463" rel="nofollow">5.2 关键路径概述</a></li><li><a href="#53__482" rel="nofollow">5.3 求关键路径的步骤</a></li><li><a href="#54__491" rel="nofollow">5.4 关键路径的特性</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="__1"></a>一. 非线性结构的概述</h2> 
<p><img src="https://images2.imgbox.com/df/fd/EV9tRSN1_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="__3"></a>二. 图的基本概念</h2> 
<h3><a id="1__4"></a>1. 定义</h3> 
<p><img src="https://images2.imgbox.com/b8/f0/WMYR59V0_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2__7"></a>2. 无向图、有向图</h3> 
<h4><a id="21__8"></a>2.1 无向图</h4> 
<p><img src="https://images2.imgbox.com/c8/08/v1rnhvf7_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="22__10"></a>2.2 有向图</h4> 
<p><img src="https://images2.imgbox.com/11/ab/YLnS4dDo_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="23__12"></a>2.3 简单图</h4> 
<p><img src="https://images2.imgbox.com/35/ed/UCedmyF2_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="24__15"></a>2.4 多重图</h4> 
<p><img src="https://images2.imgbox.com/0d/62/BMWuwmdb_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3__18"></a>3. 顶点的度、出度、入度</h3> 
<h4><a id="31__19"></a>3.1 对于无向图</h4> 
<p><img src="https://images2.imgbox.com/99/35/RSHgBwCm_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="32__22"></a>3.2 对于有向图</h4> 
<p><img src="https://images2.imgbox.com/80/a1/mk2sy6Tj_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4___25"></a>4. 边的权、带权图 (网）</h3> 
<p><img src="https://images2.imgbox.com/5c/dc/PpVTz9dk_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5__29"></a>5. 点到点的关系</h3> 
<h4><a id="51__30"></a>5.1 顶点与顶点之间的关系描述</h4> 
<p><img src="https://images2.imgbox.com/1e/44/xDWCgJO4_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="52__32"></a>5.2 连通的、强连通的、连通图、强连通图</h4> 
<p><img src="https://images2.imgbox.com/97/a8/N9cClkEN_o.png" alt="在这里插入图片描述"><br> 如果本身就是连通图，则本身就是其连通分量，而非连通图的各个连通图作为其组成部分均为其连通分量</p> 
<hr> 
<p>强连通图：任意顶点出发可以到达其余任意节点</p> 
<ul><li><font color="red"> 假设一个图有n个节点，如果边数小于n-1，那么此图必是非连通图</font></li><li><font color="red">一个图有n个顶点，并且有大于n-1条边，则此图一定有环</font></li></ul> 
<h3><a id="6__42"></a>6. 图的局部</h3> 
<h4><a id="61__43"></a>6.1 无向图子图、生成子图</h4> 
<p><img src="https://images2.imgbox.com/58/ff/tR68AjrJ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="62__45"></a>6.2 有向图子图、生成子图</h4> 
<p><img src="https://images2.imgbox.com/36/21/wqtMnxN4_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="63__47"></a>6.3 连通分量</h4> 
<p><img src="https://images2.imgbox.com/57/34/KsYCNXMR_o.png" alt="在这里插入图片描述"><br> 极小连通子图：保证了连通，且有着最少的边数</p> 
<h4><a id="64__51"></a>6.4 强连通分量</h4> 
<p><img src="https://images2.imgbox.com/52/e0/U1aI8tYD_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="7__54"></a>7. 几种特殊形态的图</h3> 
<h4><a id="71__55"></a>7.1 生成树</h4> 
<p><img src="https://images2.imgbox.com/89/f9/YlYlrX6P_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="72__58"></a>7.2 生成森林</h4> 
<p><img src="https://images2.imgbox.com/b3/fb/dCw9cM9t_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="73__61"></a>7.3 无向完全图和有向完全图</h4> 
<p><img src="https://images2.imgbox.com/2c/50/JSBGGPUD_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="74__64"></a>7.4 稀疏图和稠密图</h4> 
<p><img src="https://images2.imgbox.com/1b/cf/75P56jrz_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="75__66"></a>7.5 生成树和有向树</h4> 
<p><img src="https://images2.imgbox.com/f1/a9/YlLwANtu_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="__70"></a>三. 图的存储</h2> 
<ul><li>要根据不同图的结构和算法，采用不同存储结构，以使的程序的效率最大化</li><li>由于图的结构比较复杂，任意两个顶点之间都有可能存在联系，因此无法以数据元素在内存中的物理位置来表示元素之间的关系</li></ul> 
<h3><a id="1__74"></a>1. 邻接矩阵法</h3> 
<h4><a id="11__75"></a>1.1 定义</h4> 
<ul><li>顶点不分大小、主次，所以用一个一维数组存储图中顶点的信息</li><li>边或弧由于是顶点之间的关系，用一个二维数组存储图中边的信息（这个二维数组称为邻接矩阵）</li></ul> 
<h4><a id="12__79"></a>1.2 邻接矩阵存储有向图和无向图</h4> 
<p><img src="https://images2.imgbox.com/e3/15/XtFQnGbo_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/fa/ef/Y79pHvmk_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="13__83"></a>1.3 邻接矩阵存储带权图（网）</h4> 
<p><img src="https://images2.imgbox.com/81/0f/dkcVhA0j_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a2/bc/RHc1OA2f_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/33/23/zzPWeiJi_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="14__87"></a>1.4 邻接矩阵法的性能分析</h4> 
<p><img src="https://images2.imgbox.com/cd/d4/Dd7t1B0a_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="15__90"></a>1.5 邻接矩阵法的性质</h4> 
<p><strong>性质1：</strong><br> <img src="https://images2.imgbox.com/57/b8/BBsfcw9L_o.png" alt="在这里插入图片描述"></p> 
<p><strong>性质2：</strong><br> <img src="https://images2.imgbox.com/76/c6/XD0wqgzf_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2__99"></a>2. 邻接表法</h3> 
<h4><a id="21__100"></a>2.1 来源</h4> 
<p>由于邻接矩阵是使用数组实现的顺序存储，空间复杂度高，不适合存储稀疏图。<br> <img src="https://images2.imgbox.com/83/8b/EmBfCDbA_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="22__104"></a>2.2 定义（采用顺序存储和链式存储结合）</h4> 
<p><img src="https://images2.imgbox.com/cc/62/scQeOQe9_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e6/4d/NSHfDmW0_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f6/52/3SQqKP3i_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="23__108"></a>2.3 邻接表法的性质</h4> 
<p><strong>性质1：</strong><br> <img src="https://images2.imgbox.com/41/19/U4kbP5Dw_o.png" alt="在这里插入图片描述"><br> <strong>性质2：</strong><br> <img src="https://images2.imgbox.com/6c/ab/eFlbnrVP_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="24__113"></a>2.4 邻接表和邻接矩阵的比较</h4> 
<p><img src="https://images2.imgbox.com/7c/c0/TMiMK5Gk_o.png" alt="在这里插入图片描述"><br> tip</p> 
<ul><li>空间复杂度只与存储的节点数有关，与边数无关</li></ul> 
<h3><a id="3__119"></a>3. 十字链表（只能存储有向图）</h3> 
<h4><a id="31__120"></a>3.1 来源</h4> 
<p><img src="https://images2.imgbox.com/11/f5/JqIy2XW5_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="32__124"></a>3.2 定义</h4> 
<p>是有向图的一种链式存储结构：将邻接表和逆邻接表整合在一起</p> 
<p><img src="https://images2.imgbox.com/4f/e4/qhmVg4OV_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d1/1a/KsFWkvXA_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/5a/23/5PNhAofF_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="33__132"></a>3.3 十字链表法性能分析</h4> 
<p><img src="https://images2.imgbox.com/34/11/NLfWLtib_o.png" alt="在这里插入图片描述"></p> 
<ul><li>十字链表中容易求得顶点的出度和入度</li><li>图的十字链表表示是不唯一的，但一个十字链表表示确定一个图</li></ul> 
<h3><a id="4__138"></a>4. 邻接多重表（只能存储无向图）</h3> 
<h4><a id="41__139"></a>4.1 来源</h4> 
<p>在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低</p> 
<p><img src="https://images2.imgbox.com/06/2e/Il9iWp58_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="42__144"></a>4.2 定义</h4> 
<p>邻接多重表是无向图的另一种链式存储结构</p> 
<p><img src="https://images2.imgbox.com/8c/06/XdWcq11q_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/5b/3f/Pn3UEm9h_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="43__149"></a>4.3 邻接多重表性能分析</h4> 
<p><img src="https://images2.imgbox.com/1b/43/cAkTuKHC_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5__151"></a>5. 四种存储结构的比较</h3> 
<p><img src="https://images2.imgbox.com/68/b7/e1g2MrVV_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="__155"></a>四. 图的基本操作</h2> 
<p>图的基本操作是独立于图的存储结构的。不同的存储结构，操作算法有着不同的的性能。</p> 
<p><img src="https://images2.imgbox.com/2d/e1/v21gUQeO_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="__160"></a>五. 图的遍历</h2> 
<p>1）什么是图的遍历？</p> 
<ul><li>指从图中某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有节点访问一次且仅访问一次</li></ul> 
<p>2） 图遍历与树遍历的关系</p> 
<ul><li>树遍历本质上也视为一种特殊的图遍历</li></ul> 
<p>3）为什么需要图的遍历</p> 
<ul><li>为了求解图的连通性</li><li>为了进行拓扑排序</li><li>为了求关键路径</li></ul> 
<p>4）图遍历的关键是什么？</p> 
<ul><li>为了避免同一顶点被访问多次，在遍历图的过程中必须记下已访问过的顶点（可设一个辅助数组visited[ ]标记顶点）</li></ul> 
<h3><a id="1_BFS_175"></a>1. 广度优先搜索（BFS遍历）</h3> 
<h4><a id="11__176"></a>1.1 概述</h4> 
<p>1）树的广度优先搜索</p> 
<ul><li>也就是二叉树的层序遍历</li><li>访问完第一层节点之后再访问第二层节点</li></ul> 
<p>2）图的广度优先搜索（Breadth-First-Search）</p> 
<ul><li>是二叉树层次遍历算法的扩展</li><li>从某个节点开始访问，访问完该节点后，访问与该节点相邻的且未被访问过的节点，再从这些访问过的节点出发，访问他们所有未被访问的相邻节点，直至所有节点被访问完为止。此时若图中还有节点未被访问，则另外选一个未被访问的节点作为起始节点，重复上面过程。</li></ul> 
<p>3）树和图的广度优先遍历的比较<br> <img src="https://images2.imgbox.com/c8/ee/jRKeZI1J_o.png" alt="在这里插入图片描述"></p> 
<p><font color="red">广度优先遍历是一种分层查找过程，为了实现逐层的访问，算法必须借助一个辅助队列，以记忆正在访问的顶点的下一层顶点。</font></p> 
<p>4）广度优先遍历序列<br> <img src="https://images2.imgbox.com/19/79/UrIg98Ch_o.png" alt="在这里插入图片描述"></p> 
<p>tip</p> 
<ul><li>广度优先搜索以起始结点为中心，一层一层地向外层扩展遍历图的顶点，因此无法考虑到边权值，只适合求边权值相等的图的单源最短路径</li></ul> 
<h4><a id="12__196"></a>1.2 复杂度分析</h4> 
<p>1）空间复杂度<br> <img src="https://images2.imgbox.com/b7/6e/JEHAD9cO_o.png" alt="在这里插入图片描述"></p> 
<p>2）时间复杂度<br> <img src="https://images2.imgbox.com/d4/af/06gLZrzP_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="13__205"></a>1.3 广度优先生成树</h4> 
<p><img src="https://images2.imgbox.com/bb/b7/Z958zCJC_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c4/d0/zX09TNFn_o.png" alt="在这里插入图片描述"><br> 扩展：广度优先生成森林<br> <img src="https://images2.imgbox.com/e4/6e/Y5Eujt5z_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_DFS_212"></a>2. 深度优先搜索（DFS遍历）</h3> 
<h4><a id="21__213"></a>2.1 概述</h4> 
<p>1）树的深度优先遍历</p> 
<ul><li>从根节点出发，能往更深处走就尽量往深处走。每当访问一个节点的时候，要检查是否还有与当前节点相邻的且没有被访问过的节点，如果有的话就往下一层钻。</li></ul> 
<p>2）图的深度优先遍历（Depth-First-Search）</p> 
<ul><li>与树的先根遍历类似</li><li>算法思想：首先访问图中某一起始顶点，然后由该顶点出发，访问与该顶点相邻且没有被访问的任意顶点w，在访问与w相邻且没有被访问的任意顶点x。当不能继续访问时，依次向后退到最近被访问的顶点，判断是否有邻接顶点被访问。</li><li>DFS算法是一个递归算法，需要借助一个递归工作栈，故其空间复杂度为O(|V|)。</li></ul> 
<p>3）深度优先遍历序列<br> <img src="https://images2.imgbox.com/f0/5b/pC1AUbd5_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ad/d7/TegDUAy6_o.png" alt="在这里插入图片描述"><br> tip</p> 
<ul><li>利用深度优先遍历可以判断图G中是否存在回路。对于无向图来说，若深度优先遍历过程中遇到了回边，则必定存在环</li></ul> 
<h4><a id="22__231"></a>2.2 复杂度分析</h4> 
<p>1）空间复杂度</p> 
<p><img src="https://images2.imgbox.com/59/3e/JuZMvHCN_o.png" alt="在这里插入图片描述"><br> 2）时间复杂度<br> <img src="https://images2.imgbox.com/d9/42/yhetVrAl_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="23__239"></a>2.3 深度优先生成树</h4> 
<p><img src="https://images2.imgbox.com/47/a5/p4pb0c1q_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4c/dc/8RyIP1Ax_o.png" alt="在这里插入图片描述"></p> 
<p>扩展：深度优先生成森林</p> 
<ul><li>非连通，需要调用多次DFS函数</li></ul> 
<p><img src="https://images2.imgbox.com/f3/af/hGa1wjvz_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3__250"></a>3. 图的遍历和图的连通性</h3> 
<p>图的遍历算法可以用来判断图的连通性</p> 
<h4><a id="31__253"></a>3.1 对于无向图</h4> 
<p><img src="https://images2.imgbox.com/b3/f4/OCE0fY5Z_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="32__256"></a>3.2 对于有向图</h4> 
<p><img src="https://images2.imgbox.com/6b/16/9zwAppJt_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="__260"></a>六. 图的应用</h2> 
<h3><a id="1__261"></a>1. 最小生成（代价）树</h3> 
<h4><a id="11__262"></a>1.1 概述</h4> 
<h5><a id="1__263"></a>1) 来源</h5> 
<p><img src="https://images2.imgbox.com/a6/de/GF0HHBlT_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2__266"></a>2) 定义</h5> 
<p>一个带权的图中（网），有n个顶点，用n-1条边把一个连通图连接起来，并要使的权值的和最小。<br> <img src="https://images2.imgbox.com/94/41/BejE46Oq_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3__271"></a>3) 性质</h5> 
<p><img src="https://images2.imgbox.com/66/d9/NKnsPcak_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/da/9c/EkGLf0nD_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="12__276"></a>1.2 求最小生成树的两种算法</h4> 
<p>都是基于贪心算法策略</p> 
<h5><a id="1_Prim_279"></a>1) Prim算法</h5> 
<p>从某一个顶点出发，找一条与顶点集权值最小的边相连</p> 
<p><strong>算法思想：</strong></p> 
<ul><li>从顶点开始扩展最小生成树</li><li><font color="red">从某一个顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止</font></li><li>算法的执行非常类似于寻找图的最短路径的Dijkstra算法</li></ul> 
<p><strong>算法演示：</strong></p> 
<p><img src="https://images2.imgbox.com/36/9a/9Itm5aSh_o.png" alt="。。。见笔记"></p> 
<p><strong>算法总结：</strong></p> 
<ul><li>同一个图最小生成树的方案可能不只一个，但是最小代价是相同的</li><li>不同起点图构成的生成树可能方案是相同的</li></ul> 
<hr> 
<h5><a id="2_Kruskal_300"></a>2) Kruskal算法</h5> 
<p>每次选边权值最小的相连，顶点已连接的，边就不需要连接了。</p> 
<p><strong>算法思想：</strong></p> 
<ul><li>按权值的递增次序选择合适的边来构造最小生成树</li><li><font color="red">每次选择一条权值最小的边，使这条边的两头连通（原本已经连通的就不选）直到所有节点都连通</font></li></ul> 
<p><strong>算法演示：</strong><br> <img src="https://images2.imgbox.com/76/82/eWFeV3oj_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3__310"></a>3) 两个算法的比较</h5> 
<p><img src="https://images2.imgbox.com/c9/c2/xqX2s3O7_o.png" alt="在这里插入图片描述"></p> 
<ul><li>Prim算法的时间复杂度为O(|V|^2),不依赖于|E|</li><li>在Kruskal算法中，采用堆来存放边的集合，因此每次选择最小权值的边只需O (log|E|) 的时间。由于生成树T中的所有边可视为一个等价类，因此每次添加新的边的过程类似于求解等价类的过程，由此可以采用并查集的数据结构来描述T，从而构造T的时间复杂度为O (|Elog|E|）</li></ul> 
<h3><a id="2__318"></a>2. 最短路径</h3> 
<h4><a id="21__319"></a>2.1 定义</h4> 
<p><img src="https://images2.imgbox.com/6b/02/gFk0EbMH_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="22__322"></a>2.2 分类</h4> 
<p><img src="https://images2.imgbox.com/62/91/lEz722k0_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/e7/c3/wmkPcNdN_o.png" alt="在这里插入图片描述"></p> 
<ul><li>单源最短路径：从源点到其余各顶点的最短路径</li></ul> 
<h5><a id="1BFS_328"></a>1）BFS求无权图的单源最短路径</h5> 
<p><img src="https://images2.imgbox.com/0b/1e/Oo4FJajV_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/49/29/ayFuh2Mm_o.png" alt="在这里插入图片描述"></p> 
<p>缺点：BFS算法只适用于无权图，或所有边的权值都相同的图</p> 
<h5><a id="2Dijkstra_336"></a>2）Dijkstra算法求单源最短路径</h5> 
<p><strong>算法思想：</strong></p> 
<ul><li>基于贪心策略<br> <img src="https://images2.imgbox.com/9a/69/YDseK4DX_o.png" alt="在这里插入图片描述"></li></ul> 
<p><strong>算法时间复杂度：</strong></p> 
<ul><li>使用邻接矩阵表示时，时间复杂度为O (|V|^2)。</li><li>使用带权的邻接表表示时，虽然修改dist[]的时间可以减少，但由于在dist[]中选择最小分量的时间不变，时间复杂度仍为O (|V|^2)</li></ul> 
<p><strong>Prim算法和Dijkstra算法区别：</strong></p> 
<p>两者的区别在于，每次更新路径的不一样</p> 
<ul><li>prim更新的是已标记集合到未标记集合之间的距离</li><li>Dijkstra更新的是源点到未标记集合之间的距离</li></ul> 
<p>参考文献：<br> <a href="https://blog.csdn.net/dutmathjc/article/details/105888831">https://blog.csdn.net/dutmathjc/article/details/105888831</a><br> <a href="https://zhuanlan.zhihu.com/p/87748517" rel="nofollow">https://zhuanlan.zhihu.com/p/87748517</a></p> 
<p><strong>算法不足：</strong></p> 
<p><img src="https://images2.imgbox.com/4c/7a/Hln39YMM_o.png" alt="在这里插入图片描述"></p> 
<ul><li>其最短路径长度加上这条负边的权值结果可能小于原先确定的最短路径长度，而此时a在Dijkstra算法下是无法更新的</li></ul> 
<h5><a id="3Floyd_362"></a>3）Floyd算法求各顶点之间最短路径</h5> 
<p><strong>算法思想：</strong><br> <img src="https://images2.imgbox.com/b8/a9/ksRiaofO_o.png" alt="在这里插入图片描述"></p> 
<p><strong>算法演示：</strong><br> <img src="https://images2.imgbox.com/31/0e/bcw2C8dc_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4f/01/5abWlpj4_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/54/23/0ysIgxc7_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/dc/07/up0llfDp_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a6/15/NckbVcX3_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4d/db/Arxo1buU_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1c/50/NDkgGSjA_o.png" alt="在这里插入图片描述"></p> 
<p><strong>算法时间复杂度：</strong><br> <img src="https://images2.imgbox.com/ab/8f/hTPz8Rpt_o.png" alt="在这里插入图片描述"></p> 
<p><strong>算法的缺点：</strong></p> 
<ul><li>Floyd算法虽然用于负权值带权图，但不能解决负权回路图<br> <img src="https://images2.imgbox.com/4f/71/e5zuO84p_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="23__385"></a>2.3 三种算法的比较</h4> 
<p><img src="https://images2.imgbox.com/ca/e4/QxKSxAkx_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3__389"></a>3. 有向无环图描述表达式</h3> 
<h4><a id="31__390"></a>3.1 概述</h4> 
<p><img src="https://images2.imgbox.com/8c/6f/iJhbbtdg_o.png" alt="在这里插入图片描述"><br> 有向无环图是描述含有公共子式的表达式的有效工具</p> 
<p><img src="https://images2.imgbox.com/c6/5e/1U0ABsvA_o.png" alt="在这里插入图片描述"></p> 
<ul><li>用二叉树来描述表达式时，有相同的子表达式</li><li>利用有向无环图，则可实现对相同子式的共享，从而节省存储空间</li></ul> 
<h4><a id="32_DAG_401"></a>3.2 DAG描述表达式</h4> 
<p><img src="https://images2.imgbox.com/1e/33/p68pq5om_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="33__405"></a>3.3 解题方法</h4> 
<p><img src="https://images2.imgbox.com/dd/a1/2lfz4kh1_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4__409"></a>4. 拓扑排序</h3> 
<h4><a id="41_AOV_410"></a>4.1 AOV网</h4> 
<p>Activity on Vertex Network(AOV)网：一个有向图中，顶点表示活动，弧表示活动之间优先关系（不能存在回路）这样有向图为顶点表示活动的AOV网</p> 
<p><img src="https://images2.imgbox.com/27/24/YpjFvS9a_o.png" alt="在这里插入图片描述"><br> 特点：</p> 
<ul><li>活动Vi是活动Vj的直接前驱，活动Vj是活动Vi的直接后继，这种前驱和后继关系具有传递性，且任何活动Vi不能以它自己作为自己的前驱或后继</li></ul> 
<h4><a id="42__418"></a>4.2 拓扑排序概述</h4> 
<p>定义：</p> 
<ul><li>对一个有向图构造拓扑序列的过程，即找一条从顶点Vi到Vj的一条路径且顶点序列中Vi必须在Vj之前</li></ul> 
<p>作用：</p> 
<ul><li>解决一个工程能否顺利进行的问题</li></ul> 
<p>目的：</p> 
<ul><li>找到做事的先后顺序</li></ul> 
<p><img src="https://images2.imgbox.com/b8/89/r3Qg7AiP_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="43__430"></a>4.3 拓扑排序常用方法</h4> 
<p><img src="https://images2.imgbox.com/63/88/RC1dsAa4_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/d4/d9/QlZmNjJu_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="44__434"></a>4.4 拓扑排序复杂度</h4> 
<p><img src="https://images2.imgbox.com/5e/b7/w8M1xjHb_o.png" alt="在这里插入图片描述"><br> 由于输出每个顶点的同时还要删除以它为起点的边</p> 
<ul><li>故采用邻接表存储时拓扑排序的时间复杂度为O(|V|+|E|)</li><li>采用邻接矩阵存储时拓扑排序的时间复杂度为O(|V|^2)</li></ul> 
<h4><a id="45__440"></a>4.5 逆拓扑排序</h4> 
<p><img src="https://images2.imgbox.com/5b/42/U3VC7C7P_o.png" alt="在这里插入图片描述"><br> 特点：</p> 
<ul><li>逆拓扑排序序列可能不唯一</li></ul> 
<h3><a id="5__446"></a>5. 关键路径</h3> 
<h4><a id="51_AOE_447"></a>5.1 AOE网</h4> 
<p><strong>定义：</strong><br> <img src="https://images2.imgbox.com/ff/74/2I6Fqo7h_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/91/7a/xmQvDfQZ_o.png" alt="在这里插入图片描述"></p> 
<p><strong>性质：</strong><br> <img src="https://images2.imgbox.com/ea/24/DyzeJSIf_o.png" alt="在这里插入图片描述"></p> 
<p><strong>AOV网和AOE网的异同：</strong></p> 
<ul><li>同：都是有向无环图</li><li>异：AOE网:边有权值；AOV网:边无权值，仅表示顶点之间前后关系</li></ul> 
<p><img src="https://images2.imgbox.com/3e/95/fEEwidyS_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e4/18/4LJmNqkQ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="52__463"></a>5.2 关键路径概述</h4> 
<ul><li>解决工程完成需要的最短时间问题，分析他们拓扑关系，找到当中最关键的流程，这个流程时间就是最短时间</li><li>路径上各个活动持续的时间之后称为路径长度，从源点到终点具有最大长度的路径叫做关键路径，关键路径上的活动叫做关键活动</li></ul> 
<p><img src="https://images2.imgbox.com/0e/d4/goTMA4QW_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/14/50/i5dDgnYp_o.png" alt="在这里插入图片描述"></p> 
<p><strong>找关键活动时所需的参量：</strong><br> <img src="https://images2.imgbox.com/f5/ea/dr9Xg3gl_o.png" alt="在这里插入图片描述"><br> ve(k) = e(i)</p> 
<p><img src="https://images2.imgbox.com/ab/39/luhLMr3O_o.png" alt="在这里插入图片描述"><br> l(i) = vl(k)-weight</p> 
<p><img src="https://images2.imgbox.com/e3/8e/QjxWEHER_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="53__482"></a>5.3 求关键路径的步骤</h4> 
<p><img src="https://images2.imgbox.com/4b/fa/B1ZhAYei_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3b/07/azRIQrrH_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><img src="https://images2.imgbox.com/00/ed/76isGRNc_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/24/e8/4nNocRtO_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="54__491"></a>5.4 关键路径的特性</h4> 
<p><img src="https://images2.imgbox.com/e0/f2/CJXsP2Wy_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f1/a0/mYnCrhbf_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p>参考文献：王道数据结构</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/65af79f1da1b48c773532f02971f5319/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">将csv数据转换成张量格式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/144c97ccbf46c83fe525ad3060c771a1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">node-crypto-js可逆数据加密与解密</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>