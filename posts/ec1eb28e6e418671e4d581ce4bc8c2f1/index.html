<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>magrittr管道操作符使用解释(一) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="magrittr管道操作符使用解释(一)" />
<meta property="og:description" content="使用管道操作符提高代码简洁性 在编写R语言代码时，有时候需要对一个变量进行一系列的运算，例如对于一个同时包含数值列和字符串列的数据框，如果要计算所有数值列之间的相关系数，一般要分两步，第一步首先筛选数据框中的数值列，第二步计算数值列之间的相关系数。
x=data.frame(x1=c(1,34,22),x2=c(4,6,29),x3=c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)) 假设我们需要计算上数据框x中数值列的相关系数，通常有两种做法：
分步进行 x_num=x[,unlist(lapply(x,function(i){is.numeric(i)==TRUE}))] cor(x_num) ## x1 x2 ## x1 1.0000000 0.2262448 ## x2 0.2262448 1.0000000 在分步进行的方法中，我们需要保存每一步产生的中间结果，用于下一步的计算，对于包含多步骤连续运算的计算问题，分步进行将会变得非常繁琐。
嵌套函数 cor(x[,unlist(lapply(x,function(i){is.numeric(i)==TRUE}))]) ## x1 x2 ## x1 1.0000000 0.2262448 ## x2 0.2262448 1.0000000 以上展示了嵌套函数的写法，嵌套函数通过逐层向外扩充表示对数据进行从内到外的不断依次计算，通常对于一两步连续运算，嵌套函数的写法还可以接受，但是超过三步的运算，如果不断向外嵌套，对于他人阅读理解代码以及代码的整洁性是非常不理想的，此外，嵌套写法不利于代码的修改。
以上两种写法是初学者在学习R语言执行多步计算时经常采用的写法，一种更为简洁明了、便于维护的写作方式便是今天讲的管道操作符。如果有人之前用过 dplyr 这个程序包，想必已经对于管道操作符的高效有了一定的了解和掌握。事实上， dplyr 中管道符的实现是依赖于另一个函数包 magrittr ，此处主要讲解该软件包中对于管道操作符的一些常用用法。
magrittr 包含四种管道操作符”%&gt;%”,”%T&gt;%”,”%&lt;&gt;%”,”%$%”，其中最重要最常用的是第一个”%&gt;%”操作符。管道操作符是通过一种流程式的书写方式来表达一系列依次进行的运算操作，逻辑清晰且书写简便，下面通过一系列实际例子讲解管道操作符”%&gt;%”的使用。
管道操作符”%&gt;%”的基本用法 library(magrittr) x[,unlist(lapply(x,function(i){is.numeric(i)==TRUE}))]%&gt;%cor() ## x1 x2 ## x1 1.0000000 0.2262448 ## x2 0.2262448 1.0000000 注意到上式中管道操作符的写法”%&gt;%cor()”，事实上，管道操作符的实质就是将左边表达式（前一步运算）返回的结果默认地传给后续要执行的函数，因此管道操作符的实质可以用如下表达式清晰地表示为：
管道操作符：x%&gt;%f1()%&gt;%f2() 嵌套表达式：f2(f1(x)) 分步书写： res_1=x res_2=f1(res_1) res_3=f2(res_2) 可以看出，使用管道操作符具有逻辑清晰，书写方便的优点，此外管道操作符的表达方式允许我们方便地增加或删除其中一步的运算。
管道操作符中‘.’号的用法 在使用管道操作符时，默认地实际上是将左边表达式的结果作为右边函数的第一个参数传入的，如果右边函数只有一个参数，那自然无需考虑，但对于右边函数有多个参数，我们并不希望表达式的结果作为第一个参数时，就需要考虑更换默认的参数位置了。如何更换呢？这就需要了解‘.’在管道操作符中的用法。‘.’表达的即是左边表达式返回的结果，请观察下例：
x[,unlist(lapply(x,function(i){is.numeric(i)==TRUE}))]%&gt;%cor(.) ## x1 x2 ## x1 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ec1eb28e6e418671e4d581ce4bc8c2f1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-01-05T22:58:16+08:00" />
<meta property="article:modified_time" content="2018-01-05T22:58:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">magrittr管道操作符使用解释(一)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="使用管道操作符提高代码简洁性">使用管道操作符提高代码简洁性</h3> 
<p>在编写R语言代码时，有时候需要对一个变量进行一系列的运算，例如对于一个同时包含数值列和字符串列的数据框，如果要计算所有数值列之间的相关系数，一般要分两步，第一步首先筛选数据框中的数值列，第二步计算数值列之间的相关系数。</p> 
<pre class="prettyprint"><code class="language-r hljs ">x=data.frame(x1=c(<span class="hljs-number">1</span>,<span class="hljs-number">34</span>,<span class="hljs-number">22</span>),x2=c(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">29</span>),x3=c(<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>))</code></pre> 
<p>假设我们需要计算上数据框x中数值列的相关系数，通常有两种做法：</p> 
<ul><li>分步进行</li></ul> 
<pre class="prettyprint"><code class="language-r hljs ">x_num=x[,unlist(lapply(x,<span class="hljs-keyword">function</span>(i){is.numeric(i)==<span class="hljs-literal">TRUE</span>}))]
cor(x_num)</code></pre> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">##           x1        x2</span>
<span class="hljs-preprocessor">## x1 1.0000000 0.2262448</span>
<span class="hljs-preprocessor">## x2 0.2262448 1.0000000</span></code></pre> 
<p>在分步进行的方法中，我们需要保存每一步产生的中间结果，用于下一步的计算，对于包含多步骤连续运算的计算问题，分步进行将会变得非常繁琐。</p> 
<ul><li>嵌套函数</li></ul> 
<pre class="prettyprint"><code class="language-r hljs ">cor(x[,unlist(lapply(x,<span class="hljs-keyword">function</span>(i){is.numeric(i)==<span class="hljs-literal">TRUE</span>}))])</code></pre> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">##           x1        x2</span>
<span class="hljs-preprocessor">## x1 1.0000000 0.2262448</span>
<span class="hljs-preprocessor">## x2 0.2262448 1.0000000</span></code></pre> 
<p>以上展示了嵌套函数的写法，嵌套函数通过逐层向外扩充表示对数据进行从内到外的不断依次计算，通常对于一两步连续运算，嵌套函数的写法还可以接受，但是超过三步的运算，如果不断向外嵌套，对于他人阅读理解代码以及代码的整洁性是非常不理想的，此外，嵌套写法不利于代码的修改。</p> 
<p>以上两种写法是初学者在学习R语言执行多步计算时经常采用的写法，一种更为简洁明了、便于维护的写作方式便是今天讲的管道操作符。如果有人之前用过<strong><span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-1-Frame" style=""> 
    
    <span class="math" id="MathJax-Span-1" style="width: 2.267em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.142em; height: 0px; font-size: 106%;"><span style="position: absolute; clip: rect(1.638em 1000em 2.896em -0.563em); top: -2.513em; left: 0.003em;"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3" style="font-family: STIXGeneral; font-style: italic;">d<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-4" style="font-family: STIXGeneral; font-style: italic;">p</span><span class="mi" id="MathJax-Span-5" style="font-family: STIXGeneral; font-style: italic;">l<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-6" style="font-family: STIXGeneral; font-style: italic;">y</span><span class="mi" id="MathJax-Span-7" style="font-family: STIXGeneral; font-style: italic;">r<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.519em;"></span></span></span><span style="border-left: 0.003em solid; display: inline-block; overflow: hidden; width: 0px; height: 1.07em; vertical-align: -0.263em;"></span></span> 
   </span><script type="math/tex" id="MathJax-Element-1">dplyr</script></strong>这个程序包，想必已经对于管道操作符的高效有了一定的了解和掌握。事实上，<strong><span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-2-Frame" style=""> 
    
    <span class="math" id="MathJax-Span-8" style="width: 2.267em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.142em; height: 0px; font-size: 106%;"><span style="position: absolute; clip: rect(1.638em 1000em 2.896em -0.563em); top: -2.513em; left: 0.003em;"><span class="mrow" id="MathJax-Span-9"><span class="mi" id="MathJax-Span-10" style="font-family: STIXGeneral; font-style: italic;">d<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-11" style="font-family: STIXGeneral; font-style: italic;">p</span><span class="mi" id="MathJax-Span-12" style="font-family: STIXGeneral; font-style: italic;">l<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-13" style="font-family: STIXGeneral; font-style: italic;">y</span><span class="mi" id="MathJax-Span-14" style="font-family: STIXGeneral; font-style: italic;">r<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.519em;"></span></span></span><span style="border-left: 0.003em solid; display: inline-block; overflow: hidden; width: 0px; height: 1.07em; vertical-align: -0.263em;"></span></span> 
   </span><script type="math/tex" id="MathJax-Element-2">dplyr</script></strong>中管道符的实现是依赖于另一个函数包<strong><span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-3-Frame" style=""> 
    
    <span class="math" id="MathJax-Span-15" style="width: 3.525em; display: inline-block;"><span style="display: inline-block; position: relative; width: 3.336em; height: 0px; font-size: 106%;"><span style="position: absolute; clip: rect(1.701em 1000em 2.896em -0.563em); top: -2.513em; left: 0.003em;"><span class="mrow" id="MathJax-Span-16"><span class="mi" id="MathJax-Span-17" style="font-family: STIXGeneral; font-style: italic;">m</span><span class="mi" id="MathJax-Span-18" style="font-family: STIXGeneral; font-style: italic;">a</span><span class="mi" id="MathJax-Span-19" style="font-family: STIXGeneral; font-style: italic;">g</span><span class="mi" id="MathJax-Span-20" style="font-family: STIXGeneral; font-style: italic;">r<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-21" style="font-family: STIXGeneral; font-style: italic;">i</span><span class="mi" id="MathJax-Span-22" style="font-family: STIXGeneral; font-style: italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-23" style="font-family: STIXGeneral; font-style: italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-24" style="font-family: STIXGeneral; font-style: italic;">r<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.519em;"></span></span></span><span style="border-left: 0.003em solid; display: inline-block; overflow: hidden; width: 0px; height: 1.07em; vertical-align: -0.263em;"></span></span> 
   </span><script type="math/tex" id="MathJax-Element-3">magrittr</script></strong>，此处主要讲解该软件包中对于管道操作符的一些常用用法。</p> 
<p><strong><span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-4-Frame" style=""> 
    
    <span class="math" id="MathJax-Span-25" style="width: 3.525em; display: inline-block;"><span style="display: inline-block; position: relative; width: 3.336em; height: 0px; font-size: 106%;"><span style="position: absolute; clip: rect(1.701em 1000em 2.896em -0.563em); top: -2.513em; left: 0.003em;"><span class="mrow" id="MathJax-Span-26"><span class="mi" id="MathJax-Span-27" style="font-family: STIXGeneral; font-style: italic;">m</span><span class="mi" id="MathJax-Span-28" style="font-family: STIXGeneral; font-style: italic;">a</span><span class="mi" id="MathJax-Span-29" style="font-family: STIXGeneral; font-style: italic;">g</span><span class="mi" id="MathJax-Span-30" style="font-family: STIXGeneral; font-style: italic;">r<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-31" style="font-family: STIXGeneral; font-style: italic;">i</span><span class="mi" id="MathJax-Span-32" style="font-family: STIXGeneral; font-style: italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-33" style="font-family: STIXGeneral; font-style: italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-34" style="font-family: STIXGeneral; font-style: italic;">r<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.519em;"></span></span></span><span style="border-left: 0.003em solid; display: inline-block; overflow: hidden; width: 0px; height: 1.07em; vertical-align: -0.263em;"></span></span> 
   </span><script type="math/tex" id="MathJax-Element-4">magrittr</script></strong>包含四种管道操作符”%&gt;%”,”%T&gt;%”,”%&lt;&gt;%”,”%$%”，其中最重要最常用的是第一个”%&gt;%”操作符。管道操作符是通过一种流程式的书写方式来表达一系列依次进行的运算操作，逻辑清晰且书写简便，下面通过一系列实际例子讲解管道操作符”%&gt;%”的使用。</p> 
<h4 id="管道操作符的基本用法">管道操作符”%&gt;%”的基本用法</h4> 
<pre class="prettyprint"><code class="language-r hljs "><span class="hljs-keyword">library</span>(magrittr)
x[,unlist(lapply(x,<span class="hljs-keyword">function</span>(i){is.numeric(i)==<span class="hljs-literal">TRUE</span>}))]%&gt;%cor()</code></pre> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">##           x1        x2</span>
<span class="hljs-preprocessor">## x1 1.0000000 0.2262448</span>
<span class="hljs-preprocessor">## x2 0.2262448 1.0000000</span></code></pre> 
<p>注意到上式中管道操作符的写法”%&gt;%cor()”，事实上，管道操作符的实质就是将左边表达式（前一步运算）返回的结果默认地传给后续要执行的函数，因此管道操作符的实质可以用如下表达式清晰地表示为：</p> 
<pre class="prettyprint"><code class="language-r hljs ">管道操作符：x%&gt;%f1()%&gt;%f2()
嵌套表达式：f2(f1(x))
分步书写： res_1=x
           res_2=f1(res_1)
           res_3=f2(res_2)</code></pre> 
<p>可以看出，使用管道操作符具有逻辑清晰，书写方便的优点，此外管道操作符的表达方式允许我们方便地增加或删除其中一步的运算。</p> 
<h4 id="管道操作符中号的用法">管道操作符中‘.’号的用法</h4> 
<p>在使用管道操作符时，默认地实际上是将左边表达式的结果作为右边函数的第一个参数传入的，如果右边函数只有一个参数，那自然无需考虑，但对于右边函数有多个参数，我们并不希望表达式的结果作为第一个参数时，就需要考虑更换默认的参数位置了。如何更换呢？这就需要了解‘.’在管道操作符中的用法。‘.’表达的即是左边表达式返回的结果，请观察下例：</p> 
<pre class="prettyprint"><code class="language-r hljs ">x[,unlist(lapply(x,<span class="hljs-keyword">function</span>(i){is.numeric(i)==<span class="hljs-literal">TRUE</span>}))]%&gt;%cor(.)</code></pre> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">##           x1        x2</span>
<span class="hljs-preprocessor">## x1 1.0000000 0.2262448</span>
<span class="hljs-preprocessor">## x2 0.2262448 1.0000000</span></code></pre> 
<p>注意到，在右边函数中有一个‘.’，这表示的即是左边筛选的数据框结果，对于右边函数只有一个参数或者只需要将表达式作为第一个参数传入的情形，我们可以不用显示地将这个‘.’号写出来，但对于需要更改表达式结果作为函数其他位置的参数或者需要将表达式结果的其他形式作为函数参数的情形，则需要使用‘.’号来显示地表达上一表达式返回的结果。下面通过实例分别讲解这两种情况： <br> – 将表达式结果作为其他位置的参数传入</p> 
<p>假设需要通过sum函数计算一系列向量的和，通常我们会制定na.rm参数来设定是否忽略缺失值。如果我们需要根据前面表达式的结果（TRUE or FALSE）来决定是否忽略缺失值NA，便会遇到一个问题，na.rm参数并不是sum函数的第一个参数，为了正确地执行，我们需要修改表达式参数的默认位置，这一需求便可通过‘.’来实现</p> 
<pre class="prettyprint"><code class="language-r hljs "><span class="hljs-literal">TRUE</span>%&gt;%sum(c(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">NA</span>),na.rm = .)</code></pre> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">## [1] 6</span></code></pre> 
<p>可以看到，通过显示地制定‘.’的位置，我们可以更改参数的默认位置，‘.’号可以在函数中出现在任意多次任意位置，表示其他参数设定需要依赖该结果。</p> 
<p>– 将表达式结果的其他形式作为函数参数</p> 
<p>第二种用法实际上和第一种用法是一致的，在此单一列出只是为了更清楚的展示。借助tidyr中的fill函数来说明这一用法。tidyr中的fill函数可以用来根据前一行的值填充后一行的缺失值。</p> 
<pre class="prettyprint"><code class="language-r hljs ">x=data.frame(x1=c(<span class="hljs-number">1</span>,<span class="hljs-literal">NA</span>,<span class="hljs-number">3</span>),x2=c(<span class="hljs-number">12.3</span>,<span class="hljs-number">34</span>,<span class="hljs-literal">NA</span>))
x</code></pre> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">##   x1   x2</span>
<span class="hljs-preprocessor">## 1  1 12.3</span>
<span class="hljs-preprocessor">## 2 NA 34.0</span>
<span class="hljs-preprocessor">## 3  3   NA</span></code></pre> 
<p>这种填充缺失值的方法对于一系列时间上连续的采样样本应用较为合适。使用tidyr时，需要指定哪一列需要填充，如果我们需要填充函数的所有列，则需要在传入所有的列名称。由于列名称是数据框的某一属性，因此此时我们的函数既需要表达式的结果（即数据框）作为函数的第一个参数，又需要表达式结果的其他属性或者变形作为函数的另外参数，这一问题的解决可以依靠‘.’号来实现。</p> 
<pre class="prettyprint"><code class="language-r hljs "><span class="hljs-keyword">library</span>(tidyr)
x%&gt;%fill(names(.))</code></pre> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">##   x1   x2</span>
<span class="hljs-preprocessor">## 1  1 12.3</span>
<span class="hljs-preprocessor">## 2  1 34.0</span>
<span class="hljs-preprocessor">## 3  3 34.0</span></code></pre> 
<p>更为具体的，可以写成</p> 
<pre class="prettyprint"><code class="language-r hljs ">x%&gt;%fill(.,names(.))</code></pre> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">##   x1   x2</span>
<span class="hljs-preprocessor">## 1  1 12.3</span>
<span class="hljs-preprocessor">## 2  1 34.0</span>
<span class="hljs-preprocessor">## 3  3 34.0</span></code></pre> 
<p>以上便是‘.’号的用法。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/feff03cdb353722fbaf14e33b2904ced/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android开发工作经验总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/708af7729328636daf7d0ddb7819b271/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">学生信息保存到文件中（JAVA）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>