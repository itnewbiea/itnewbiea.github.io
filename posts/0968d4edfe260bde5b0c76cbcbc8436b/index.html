<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>集成学习介绍——Random Forest - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="集成学习介绍——Random Forest" />
<meta property="og:description" content="随机森林是一个非常直观，理解起来也比较容易的Bagging算法。前面我们介绍过决策树，其最大的一个缺点就是容易过拟合。随机森林则是由若干决策树组成的模型，其思想就是“三个臭皮匠顶个诸葛亮”。比如下图，就是由9个决策树组成的一个随机森林，其中6个决策树预测值为1，三个预测为0 ，所以最终预测值取多数方：1。如果是回归问题，一般取所有决策树预测结果的均值。
理解随机森林的关键点在于理解“ 相关度低甚至不相关的多个决策树组合在一起的效果好于其中任何一个决策树 ”。这里拿一个例子做论证（注：此例来自第一个参考文章），做一个游戏：使用一个均匀分布的随机数产生器产生一个数字，如果这个数字大于等于40，则算你赢，可以获得一些钱；如果小于40，则算你输，你需要给对方同样数额的钱。现在有三种玩法供选择：
玩法1（Game1）：玩100次，每次的筹码是1元。玩法2（Game2）：玩10次，每次筹码是10元。玩法3（Game3）：玩1次，筹码是100. 你会怎么选哪一个？我们计算一下赢钱的期望值：
$E_1 = (0.6*1&#43;0.4*(-1))*100=20$$E_2=(0.6*10&#43;0.4*(-10))*100=20$$E_3=(0.6*100&#43;0.4*(-100))=20$ 三种选择赢钱的期望值是一样的，那到底该如何选？我们做一个模拟：每种情况都模拟10000次，代码如下：
import numpy as np import matplotlib.pyplot as plt import seaborn as sns sns.set_theme() # Game 1 simulations = 10000 # number of Monte Carlo Simulations games = 100 # number of times the game is played threshold = 40 # threshold where if greater than or equal to you win bet = 1 # dollar bet for the game # outer loop is Monte Carlo sims and inner loop is games played sim_results_1 = [] for sim in range(simulations): result = [] for g in range(games): number = int(np." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0968d4edfe260bde5b0c76cbcbc8436b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-21T22:15:34+08:00" />
<meta property="article:modified_time" content="2022-03-21T22:15:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">集成学习介绍——Random Forest</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>随机森林是一个非常直观，理解起来也比较容易的Bagging算法。前面我们介绍过决策树，其最大的一个缺点就是容易过拟合。随机森林则是由若干决策树组成的模型，其思想就是“三个臭皮匠顶个诸葛亮”。比如下图，就是由9个决策树组成的一个随机森林，其中6个决策树预测值为1，三个预测为0 ，所以最终预测值取多数方：1。如果是回归问题，一般取所有决策树预测结果的均值。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/dc/d0/I0mvZLv5_o.png"></p> 
<p>理解随机森林的关键点在于理解“ 相关度低甚至不相关的多个决策树组合在一起的效果好于其中任何一个决策树 ”。这里拿一个例子做论证（注：此例来自第一个参考文章），做一个游戏：使用一个均匀分布的随机数产生器产生一个数字，如果这个数字大于等于40，则算你赢，可以获得一些钱；如果小于40，则算你输，你需要给对方同样数额的钱。现在有三种玩法供选择：</p> 
<ul><li>玩法1（Game1）：玩100次，每次的筹码是1元。</li><li>玩法2（Game2）：玩10次，每次筹码是10元。</li><li>玩法3（Game3）：玩1次，筹码是100.</li></ul> 
<p>你会怎么选哪一个？我们计算一下赢钱的期望值：</p> 
<ul><li>$E_1 = (0.6*1+0.4*(-1))*100=20$</li><li>$E_2=(0.6*10+0.4*(-10))*100=20$</li><li>$E_3=(0.6*100+0.4*(-100))=20$</li></ul> 
<p>三种选择赢钱的期望值是一样的，那到底该如何选？我们做一个模拟：每种情况都模拟10000次，代码如下：</p> 
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

sns.set_theme()

# Game 1
simulations = 10000  # number of Monte Carlo Simulations
games = 100          # number of times the game is played
threshold = 40       # threshold where if greater than or equal to you win
bet = 1              # dollar bet for the game

# outer loop is Monte Carlo sims and inner loop is games played
sim_results_1 = []
for sim in range(simulations):
    result = []
    for g in range(games):
        number = int(np.random.uniform()*100)  # get a random number to see who wins
        if number &gt;= threshold:
            result.append(bet)
        else:
            result.append(-bet)
    sim_results_1.append(sum(result))          # sim_results_1 stores results for Game 1
print('Game 1 Mean: ', round(np.mean(sim_results_1), 2))
print('Game 1 Prob Positive: ', round(sum([1 for i in sim_results_1 if i&gt;0])/simulations, 2))
print('\n')
    

# Game 2 (structure of code is same as above)
simulations = 10000
games = 10
threshold = 40
bet = 10

sim_results_2 = []
for sim in range(simulations):
    result = []
    for g in range(games):
        number = int(np.random.uniform()*100)
        if number &gt;= threshold:
            result.append(bet)
        else:
            result.append(-bet)
    sim_results_2.append(sum(result))
print('Game 2 Mean: ', round(np.mean(sim_results_2), 2))
print('Game 2 Prob Positive: ', round(sum([1 for i in sim_results_2 if i&gt;0])/simulations, 2))
print('\n')
    
    
# Game 3 (structure of code is same as above)
simulations = 10000
games = 1
threshold = 40
bet = 100

sim_results_3 = []
for sim in range(simulations):
    result = []
    for g in range(games):
        number = int(np.random.uniform()*100)
        if number &gt;= threshold:
            result.append(bet)
        else:
            result.append(-bet)
    sim_results_3.append(sum(result))
print('Game 3 Mean: ', round(np.mean(sim_results_3), 2))
print('Game 3 Prob Positive: ', round(sum([1 for i in sim_results_3 if i&gt;0])/simulations, 2))

# Histogram that shows the distribution of the Monte Carlo Results for 2 spending levels
fig, ax = plt.subplots(figsize=(8,6))
sns.distplot(sim_results_1, kde=False, bins=60, label='Play 100 Times')
sns.distplot(sim_results_2, kde=False, bins=60, label='Play 10 Times', color='orange')
sns.distplot(sim_results_3, kde=False, bins=60, label='Play 1 Time', color='pink')

ax.set_xlabel('Money Won by You', fontsize=16)
ax.set_ylabel('Frequency',fontsize=16)
plt.legend()
plt.tight_layout()

plt.savefig(fname='game_hist', dpi=150)
plt.show()</code></pre> 
<p>模拟的输出以分布图如下：</p> 
<pre><code class="language-python"># 代码输出
Game 1 Mean:  20.01
Game 1 Prob Positive:  0.97

Game 2 Mean:  20.2
Game 2 Prob Positive:  0.63

Game 3 Mean:  21.08
Game 3 Prob Positive:  0.61</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/48/a4/1bsnQmcV_o.png"></p> 
<p>那可以看到赢钱的均值和即我们先前计算的期望值是一致的，三种玩法都接近20（Game x Mean），但赢钱的概率却相差很大，玩法1是97%，玩法2是63%，玩法3是61%。当然模拟次数再多一些，还有有一些变化。随机森林的思想和这个是一样的，里面包含的决策树的个数就是这里玩的次数。</p> 
<p>另外，随机森林还有一个非常关键的限定条件：各个决策树之间不相关或者关联度很低。类比到上面的游戏中，我们的假设是产生随机数的算法是遵从均匀分布的，也就是产生1~100之间的数字的概率是完全相等的。如果不是，那上面第一种玩法1最优的结论就不一定成立了。而随机森林实现各个决策树之间不相关或者关联度很低是通过“ <strong>两个随机</strong> ”实现的：</p> 
<ol><li><strong>数据随机</strong> ：即每次只选取原始数据集的一个子集作为一个决策树的训练集，一般就是自助采样法（Bootstrap）。这是最核心的随机，主要是去除或者削弱各独立模型之间的相关性。</li><li><strong>属性随机</strong> ：属性随机化的好处在于让每个单独的基学习器不会过分关注在训练集中具有高度预测性或者描述性的特征。</li></ol> 
<p>通过两个随机，可以降低最终生成的模型的方差。而且通过这种方式生成的树一般也无需剪枝。Wikipedia上面的描述是这样的：</p> 
<p>Each decision tree in the forest considers <strong>a random subset of features</strong> when forming questions and only has access to <strong>a random set of the training data points</strong> . This increases diversity in the forest leading to more robust overall predictions and the name ‘random forest.’</p> 
<p>随机森林还有一个变种：Extra Trees。也称Extremely Randomized Trees，一般翻译为极限树，是随机森林的一个变种，进行了更彻底的随机，主要有两点：</p> 
<ol><li>训练各个决策树的时候使用全部数据集，而非一个采样的数据子集；</li><li>在选择决策树的拆分点的时候，均匀随机选择一个特征，而不是像随机森林那样根据信息增益或者基尼不纯度进行选择。</li></ol> 
<p>极限树的两个改动点在大部分情况下会进一步的降低方差，但可能会稍微增大一些偏差。</p> 
<p>总结一下，随机森林的思路就是“群众的眼睛是雪亮的”，通过使用多个决策树组成一个“委员会”来进行预测或者回归，这些“群众”就是集成算法中的“若分类器”，他们相互之间没有关联度或者关联度低，而且一般在某一个点表现还可以。这点是通过“ <strong>两个随机</strong> ”去实现的，也是随机森林最核心的地方。</p> 
<p>References：</p> 
<ul><li><a href="https://towardsdatascience.com/understanding-random-forest-58381e0602d2" rel="nofollow" title="Understanding Random Forest">Understanding Random Forest</a></li><li><a href="https://en.wikipedia.org/wiki/Random_forest" rel="nofollow" title="Wikipedia：Random Forest">Wikipedia：Random Forest</a></li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6cbbd78fb3936b9338070dcbeeeb1b61/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">net1. Reactor关键结构——EventLoop事件循环类</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b92091d402c82e4d13aea84c6352982b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【ButterKnife被弃用】Resource IDs will be non-final by default in Android Gradle Plugin version 8.0, avoi</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>