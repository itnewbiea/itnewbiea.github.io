<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL模糊查询优化，字符串精准匹配 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySQL模糊查询优化，字符串精准匹配" />
<meta property="og:description" content="文章目录 1.简介2.直接使用like语句效率低的原因3.模糊查询优化的方法1.索引2.LOCATE（‘substr’,str,pos）方法3.POSITION(‘substr’ IN field)方法4.INSTR(str,‘substr’)方法5.CONTAINS(`column`,str)方法 4.字符串精准匹配1.默认函数2.自定义函数 1.简介 在平时使用msyql需要模糊的匹配字段的时候，我们第一反应就是使用like查询语句来模糊匹配，当数据量小的时候，我们通常感觉不到是否影响查询效率，但在数据量达到百万级，千万级的时候，like查询的低效率就很容易显现出来。这个时候查询的效率就显得很重要。
2.直接使用like语句效率低的原因 下面建立一张测试表作为所有演示的数据。
在mysql中直接使用like并不会影响查询使用索引，但在开头使用通配符后(% 或者_)索引就会失效，查询数据量较大时必然会造成性能问题。
3.模糊查询优化的方法 1.索引 SELECT `column` FROM `table` WHERE `field` like &#39;keyword%&#39;; 没加索引情况下是全表搜索，加了索引情况下速度会大幅度提升，但不适用于全部搜索，只适用于&#34;keywork%&#34;关键字开头
2.LOCATE（‘substr’,str,pos）方法 SELECT `column` FROM `table` WHERE LOCATE(&#39;keyword&#39;, `field`)&gt;0 keyword是要搜索的内容，field为被匹配的字段，查询出全部存在keyword的数据
3.POSITION(‘substr’ IN field)方法 SELECT `column` FROM `table` WHERE POSITION(&#39;keyword&#39; IN `filed`) position能够看作是locate的别名，功能跟locate同样
4.INSTR(str,‘substr’)方法 SELECT `column` FROM `table` WHERE INSTR(`field`, &#39;keyword&#39;)&gt;0 5.CONTAINS(column,str)方法 SELECT `column` FROM `table` WHERE CONTAINS(`column`, &#39;keyword&#39;) 4.字符串精准匹配 如测试表中的数据所示，如果我们使用like模糊查询，%admin的查询结果会导致student字段不以admin结尾的数据都无法查出来，而使用%admin%则会导致admin1，admin12这种数据也被查出来。
为解决这种问题，需要使用到精准匹配的函数FIND_IN_SET(‘str’,column)。
1.默认函数 select * from test where find_in_set(&#39;admin&#39;,student); 查询结果：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0c0cc64a53167aff3e749d91a608d853/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-24T16:02:57+08:00" />
<meta property="article:modified_time" content="2022-10-24T16:02:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL模糊查询优化，字符串精准匹配</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1_1" rel="nofollow">1.简介</a></li><li><a href="#2like_8" rel="nofollow">2.直接使用like语句效率低的原因</a></li><li><a href="#3_24" rel="nofollow">3.模糊查询优化的方法</a></li><li><ul><li><a href="#1_26" rel="nofollow">1.索引</a></li><li><a href="#2LOCATEsubstrstrpos_35" rel="nofollow">2.LOCATE（‘substr’,str,pos）方法</a></li><li><a href="#3POSITIONsubstr_IN_field_43" rel="nofollow">3.POSITION(‘substr’ IN field)方法</a></li><li><a href="#4INSTRstrsubstr_51" rel="nofollow">4.INSTR(str,‘substr’)方法</a></li><li><a href="#5CONTAINScolumnstr_57" rel="nofollow">5.CONTAINS(`column`,str)方法</a></li></ul> 
  </li><li><a href="#4_66" rel="nofollow">4.字符串精准匹配</a></li><li><ul><li><a href="#1_78" rel="nofollow">1.默认函数</a></li><li><a href="#2_90" rel="nofollow">2.自定义函数</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1_1"></a>1.简介</h2> 
<p>在平时使用msyql需要模糊的匹配字段的时候，我们第一反应就是使用like查询语句来模糊匹配，当数据量小的时候，我们通常感觉不到是否影响查询效率，但在数据量达到百万级，千万级的时候，like查询的低效率就很容易显现出来。这个时候查询的效率就显得很重要。</p> 
<br> 
<br> 
<h2><a id="2like_8"></a>2.直接使用like语句效率低的原因</h2> 
<p>下面建立一张测试表作为所有演示的数据。</p> 
<p><img src="https://images2.imgbox.com/1b/3c/lK0bGRDk_o.jpg" alt="在这里插入图片描述"></p> 
<p>在mysql中直接使用like并不会影响查询使用索引，但在开头使用通配符后(% 或者_)索引就会失效，查询数据量较大时必然会造成性能问题。</p> 
<p><img src="https://images2.imgbox.com/2f/9f/cVALKdUT_o.jpg" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/91/22/P2vP0Qvf_o.jpg" alt="在这里插入图片描述"></p> 
<br> 
<br> 
<h2><a id="3_24"></a>3.模糊查询优化的方法</h2> 
<h3><a id="1_26"></a>1.索引</h3> 
<pre><code class="prism language-mysql">SELECT `column` FROM `table` WHERE `field` like 'keyword%';
</code></pre> 
<p>没加索引情况下是全表搜索，加了索引情况下速度会大幅度提升，但不适用于全部搜索，只适用于"keywork%"关键字开头</p> 
<h3><a id="2LOCATEsubstrstrpos_35"></a>2.LOCATE（‘substr’,str,pos）方法</h3> 
<pre><code class="prism language-mysql">SELECT `column` FROM `table` WHERE LOCATE('keyword', `field`)&gt;0
</code></pre> 
<p>keyword是要搜索的内容，field为被匹配的字段，查询出全部存在keyword的数据</p> 
<h3><a id="3POSITIONsubstr_IN_field_43"></a>3.POSITION(‘substr’ IN field)方法</h3> 
<pre><code class="prism language-mysql">SELECT `column` FROM `table` WHERE POSITION('keyword' IN `filed`)
</code></pre> 
<p>position能够看作是locate的别名，功能跟locate同样</p> 
<h3><a id="4INSTRstrsubstr_51"></a>4.INSTR(str,‘substr’)方法</h3> 
<pre><code class="prism language-mysql">SELECT `column` FROM `table` WHERE INSTR(`field`, 'keyword')&gt;0
</code></pre> 
<h3><a id="5CONTAINScolumnstr_57"></a>5.CONTAINS(<code>column</code>,str)方法</h3> 
<pre><code class="prism language-mysql">SELECT `column` FROM `table` WHERE CONTAINS(`column`, 'keyword')
</code></pre> 
<br> 
<br> 
<h2><a id="4_66"></a>4.字符串精准匹配</h2> 
<p>如测试表中的数据所示，如果我们使用like模糊查询，<code>%admin</code>的查询结果会导致student字段不以admin结尾的数据都无法查出来，而使用<code>%admin%</code>则会导致<code>admin1</code>，<code>admin12</code>这种数据也被查出来。</p> 
<p><img src="https://images2.imgbox.com/c6/ba/dEw19Ztd_o.jpg" alt="在这里插入图片描述"></p> 
<p>为解决这种问题，需要使用到精准匹配的函数FIND_IN_SET(‘str’,<code>column</code>)。<br> <br></p> 
<h3><a id="1_78"></a>1.默认函数</h3> 
<pre><code>select * from test where find_in_set('admin',student);
</code></pre> 
<p><strong>查询结果：</strong></p> 
<p><img src="https://images2.imgbox.com/35/fa/VYTlD3mP_o.jpg" alt="在这里插入图片描述"></p> 
<br> 
<h3><a id="2_90"></a>2.自定义函数</h3> 
<p>有时候分隔符不一定会按照逗号来分割，可能会有各种分隔符，如|,&amp;等，需要自定义函数。</p> 
<pre><code class="prism language-mysql">select * from test where find_in_set('admin',REPLACE(student,'|',','));
</code></pre> 
<p>查询结果：</p> 
<p><img src="https://images2.imgbox.com/70/96/09fe8Xtj_o.jpg" alt="在这里插入图片描述"><br> 以上就是关于MySQL 模糊查询优化，以及字符串精准匹配的所有内容，希望对大家有帮助。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/27acd6ea5aeee7d02eb7f0754f109a5d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python中的selenium库做爬虫一些关于元素找不到的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dfbfa7ad562a6457654dfc2d8882f09e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Tomcat配置错误：消息 Request processing failed； nested exception is org.thymeleaf.exceptions.TemplateInputE</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>