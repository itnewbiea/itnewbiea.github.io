<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>什么是递归，通过这篇文章，让你彻底搞懂递归 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="什么是递归，通过这篇文章，让你彻底搞懂递归" />
<meta property="og:description" content="想了解更多数据结构以及算法题，可以关注微信公众号“数据结构和算法”，每天一题为你精彩解答。也可以扫描下面的二维码关注
啥叫递归 聊递归之前先看一下什么叫递归。
递归，就是在运行的过程中调用自己。
构成递归需具备的条件：
1. 子问题须与原始问题为同样的事，且更为简单；
2. 不能无限制地调用本身，须有个出口，化简为非递归状况处理。
递归语言例子 我们用2个故事来阐述一下什么叫递归。
1，从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？‘从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……’”
2，大雄在房里，用时光电视看着从前的情况。电视画面中的那个时候，他正在房里，用时光电视，看着从前的情况。电视画面中的电视画面的那个时候，他正在房里，用时光电视，看着从前的情况……
递归模板 我们知道递归必须具备两个条件，一个是调用自己，一个是有终止条件。这两个条件必须同时具备，且一个都不能少。并且终止条件必须是在递归最开始的地方，也就是下面这样
public void recursion(参数0) { if (终止条件) { return; } recursion(参数1); } 不能把终止条件写在递归结束的位置，下面这种写法是错误的
public void recursion(参数0) { recursion(参数1); if (终止条件) { return; } } 如果这样的话，递归永远退不出来了，就会出现堆栈溢出异常(StackOverflowError)。
但实际上递归可能调用自己不止一次，并且很多递归在调用之前或调用之后都会有一些逻辑上的处理，比如下面这样。
public void recursion(参数0) { if (终止条件) { return; } 可能有一些逻辑运算 recursion(参数1) 可能有一些逻辑运算 recursion(参数2) …… recursion(参数n) 可能有一些逻辑运算 } 实例分析 我对递归的理解是先往下一层层传递，当碰到终止条件的时候会反弹，最终会反弹到调用处。下面我们就以5个最常见的示例来分析下
1，阶乘
我们先来看一个最简单的递归调用-阶乘，代码如下
public int recursion(int n) { if (n == 1) return 1; return n * recursion(n - 1);5} 这个递归在熟悉不过了，第2-3行是终止条件，第4行是调用自己。我们就用n等于5的时候来画个图看一下递归究竟是怎么调用的" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f6dfedd22eeb85130d38cde338602838/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-10T10:40:50+08:00" />
<meta property="article:modified_time" content="2020-08-10T10:40:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">什么是递归，通过这篇文章，让你彻底搞懂递归</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>想了解更多数据结构以及算法题，可以关注微信公众号“<strong>数据结构和算法</strong>”，每天一题为你精彩解答。也可以扫描下面的二维码关注<br> <img src="https://images2.imgbox.com/47/e7/mJ0365tu_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_3"></a>啥叫递归</h3> 
<p>聊递归之前先看一下什么叫递归。<br> <strong>递归，就是在运行的过程中调用自己。</strong></p> 
<p>构成递归需具备的条件：<br> <strong>1. 子问题须与原始问题为同样的事，且更为简单；<br> 2. 不能无限制地调用本身，须有个出口，化简为非递归状况处理。</strong></p> 
<h3><a id="_14"></a>递归语言例子</h3> 
<p>我们用2个故事来阐述一下什么叫递归。</p> 
<p>1，从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？‘从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……’”</p> 
<p>2，大雄在房里，用时光电视看着从前的情况。电视画面中的那个时候，他正在房里，用时光电视，看着从前的情况。电视画面中的电视画面的那个时候，他正在房里，用时光电视，看着从前的情况……</p> 
<h3><a id="_25"></a>递归模板</h3> 
<p>我们知道递归必须具备两个条件，<strong>一个是调用自己，一个是有终止条件</strong>。这两个条件必须同时具备，且一个都不能少。并且<strong>终止条件必须是在递归最开始的地方</strong>，也就是下面这样</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recursion</span><span class="token punctuation">(</span>参数<span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">recursion</span><span class="token punctuation">(</span>参数<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>不能把终止条件写在递归结束的位置，下面这种写法是错误的</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recursion</span><span class="token punctuation">(</span>参数<span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">recursion</span><span class="token punctuation">(</span>参数<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果这样的话，递归永远退不出来了，就会出现堆栈溢出异常(StackOverflowError)。</p> 
<p>但实际上递归可能调用自己不止一次，并且很多递归在调用之前或调用之后都会有一些逻辑上的处理，比如下面这样。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recursion</span><span class="token punctuation">(</span>参数<span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    可能有一些逻辑运算
    <span class="token function">recursion</span><span class="token punctuation">(</span>参数<span class="token number">1</span><span class="token punctuation">)</span>
    可能有一些逻辑运算
    <span class="token function">recursion</span><span class="token punctuation">(</span>参数<span class="token number">2</span><span class="token punctuation">)</span>
            ……
    <span class="token function">recursion</span><span class="token punctuation">(</span>参数n<span class="token punctuation">)</span>
    可能有一些逻辑运算
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_71"></a>实例分析</h3> 
<p>我对递归的理解是先往下一层层传递，当碰到终止条件的时候会反弹，最终会反弹到调用处。下面我们就以5个最常见的示例来分析下</p> 
<p><strong>1，阶乘</strong></p> 
<p>我们先来看一个最简单的递归调用-阶乘，代码如下</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">recursion</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">recursion</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">5</span><span class="token punctuation">}</span>
</code></pre> 
<p>这个递归在熟悉不过了，第2-3行是终止条件，第4行是调用自己。我们就用n等于5的时候来画个图看一下递归究竟是怎么调用的<br> <img src="https://images2.imgbox.com/ac/92/hfhWKLMj_o.png" alt="在这里插入图片描述"></p> 
<p>如果看不清，图片可点击放大。</p> 
<p>这种递归还是很简单的，我们求f(5)的时候，只需要求出f(4)即可，如果求f(4)我们要求出f(3)……，一层一层的调用，当n=1的时候，我们直接返回1，然后再一层一层的返回，直到返回f(5)为止。</p> 
<p>递归的目的是把一个大的问题细分为更小的子问题，我们只需要知道递归函数的功能即可，不要把递归一层一层的拆开来想，如果同时调用多次的话这样你很可能会陷入循环而出不来。比如上面的题中要求f(5)，我们只需要计算f(4)即可，即f(5)=5*f(4)；至于f(4)是怎么计算的，我们就不要管了。因为我们知道f(n)中的n可以代表任何正整数，我们只需要传入4就可以计算f(4)。</p> 
<p><strong>2，斐波那契数列</strong></p> 
<p>我们再来看另一道经典的递归题，就是斐波那契数列，数列的前几项如下所示</p> 
<p>[1，1，2，3，5，8，13……]</p> 
<p>我们参照递归的模板来写下，首先终止条件是当n等于1或者2的时候返回1，也就是数列的前两个值是1，代码如下</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    这里是递归调用；
<span class="token punctuation">}</span>
</code></pre> 
<p>递归的两个条件，一个是终止条件，我们找到了。还一个是调用自己，我们知道斐波那契数列当前的值是前两个值的和，也就是</p> 
<p><strong>fibonacci(n) =fibonacci(n - 1) + fibonacci(n - 2)</strong></p> 
<p>所以代码很容易就写出来了</p> 
<pre><code class="prism language-java"><span class="token comment">//1,1,2,3,5,8,13……</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>3，汉诺塔</strong></p> 
<p>通过前面两个示例的分析，我们对递归有一个大概的了解，下面我们再来看另一个示例-汉诺塔，这个其实前面讲过，有兴趣的可以看下<a href="https://blog.csdn.net/abcdef314159/article/details/106113088">汉诺塔图文详解</a></p> 
<p><img src="https://images2.imgbox.com/4e/e2/qPYsaXIZ_o.png" alt="在这里插入图片描述"></p> 
<p>汉诺塔的原理这里再简单提一下，就是有3根柱子A，B，C。A柱子上由上至下依次由小至大排列的圆盘。把A柱子上的圆盘借B柱子全部移动到C柱子上，并且移动的过程始终是小的圆盘在上，大的在下。我们还是用递归的方式来解这道题，先来定义一个函数</p> 
<p><strong>public void hanoi(int n, char A, char B, char C)<br> 他表示的是把n个圆盘从A借助B成功的移动到C。</strong></p> 
<p>我们先来回顾一下递归的条件，一个是终止条件，一个是调用自己。我们先来看下递归的终止条件就是当n等于1的时候，也就是A柱子上只有一个圆盘的时候，我们直接把A柱子上的圆盘移动到C柱子上即可。</p> 
<pre><code class="prism language-java"><span class="token comment">//表示的是把n个圆盘借助柱子B成功的从A移动到C</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hanoi</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span> A<span class="token punctuation">,</span> <span class="token keyword">char</span> B<span class="token punctuation">,</span> <span class="token keyword">char</span> C<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//如果只有一个，直接从A移动到C即可</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"从"</span> <span class="token operator">+</span> A <span class="token operator">+</span> <span class="token string">"移动到"</span> <span class="token operator">+</span> C<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    这里是递归调用
<span class="token punctuation">}</span>
</code></pre> 
<p>再来看一下递归调用，如果n不等于1，我们要分3步，</p> 
<p><strong>1，先把n-1个圆盘从A借助C成功的移动到B<br> 2，然后再把第n个圆盘从A移动到C<br> 3，最后再把n-1个圆盘从B借助A成功的移动到C。</strong></p> 
<p>那代码该怎么写呢，我们知道函数</p> 
<p>hanoi(n, ‘A’, ‘B’, ‘C’)表示的是把n个圆盘从A借助B成功的移动到C<br> 所以hanoi(n-1, ‘A’, ‘C’, ‘B’)就表示的是把n-1个圆盘从A借助C成功的移动到B<br> hanoi(n-1, ‘B’, ‘A’, ‘C’)就表示的是把n-1个圆盘从B借助A成功的移动到C</p> 
<p>所以上面3步如果用代码就可以这样来表示</p> 
<p><strong>1，hanoi(n-1, ‘A’, ‘C’, ‘B’)<br> 2，System.out.println(“从” + A + “移动到” + C);<br> 3，hanoi(n-1, ‘B’, ‘A’, ‘C’)</strong></p> 
<p>所以最终完整代码如下</p> 
<pre><code class="prism language-java"><span class="token comment">//表示的是把n个圆盘借助柱子B成功的从A移动到C</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hanoi</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span> A<span class="token punctuation">,</span> <span class="token keyword">char</span> B<span class="token punctuation">,</span> <span class="token keyword">char</span> C<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//如果只有一个，直接从A移动到C即可</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"从"</span> <span class="token operator">+</span> A <span class="token operator">+</span> <span class="token string">"移动到"</span> <span class="token operator">+</span> C<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//表示先把n-1个圆盘成功从A移动到B</span>
    <span class="token function">hanoi</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> A<span class="token punctuation">,</span> C<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//把第n个圆盘从A移动到C</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"从"</span> <span class="token operator">+</span> A <span class="token operator">+</span> <span class="token string">"移动到"</span> <span class="token operator">+</span> C<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//表示把n-1个圆盘再成功从B移动到C</span>
    <span class="token function">hanoi</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> B<span class="token punctuation">,</span> A<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过上面的分析，是不是感觉递归很简单。所以我们写递归的时候完全可以套用上面的模板，先写出终止条件，然后在写递归的逻辑调用。还有一点非常重要，就是<strong>一定要明白递归函数中每个参数的含义</strong>，这样在逻辑处理和函数调用的时候才能得心应手，函数的调用我们一定不要去一步步拆开去想，这样很有可能你会奔溃的。</p> 
<p><strong>4，二叉树的遍历</strong></p> 
<p>再来看最后一个常见的示例就是二叉树的遍历，在前面也讲过，如果有兴趣的话可以看下<a href="https://blog.csdn.net/abcdef314159/article/details/107130830">树的各种遍历</a>，我们主要来看一下二叉树的前中后3种遍历方式，</p> 
<p>1，先看一下前序遍历（根节点最开始），他的顺序是</p> 
<p><strong>根节点</strong>→左子树→右子树</p> 
<p>我们来套用模板看一下</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span><span class="token comment">// (必须要有)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    逻辑处理<span class="token comment">//（不是必须的）</span>
    递归调用<span class="token comment">//(必须要有)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>终止条件</strong>是node等于空，<strong>逻辑处理</strong>这块直接打印当前节点的值即可，<strong>递归调用</strong>是先打印左子树在打印右子树，我们来看下</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">preOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">preOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>中序遍历和后续遍历直接看下</p> 
<p>2，中序遍历（根节点在中间）</p> 
<p>左子树→<strong>根节点</strong>→右子树</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">inOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">inOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>3，后序遍历（根节点在最后）</p> 
<p>左子树→右子树→<strong>根节点</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span>TreeNode tree<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> null<span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">postOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">postOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>5，链表的逆序打印</strong></p> 
<p>这个就不在说了，直接看下</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printRevers</span><span class="token punctuation">(</span>ListNode root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//（终止条件）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token comment">//（递归调用）先打印下一个</span>
    <span class="token function">printRevers</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//（逻辑处理）把后面的都打印完了在打印当前节点</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_294"></a>分支污染问题</h3> 
<p>通过上面的分析，我们对递归有了更深一层的认识。但总觉得还少了点什么，其实递归我们还可以通过另一种方式来认识他，就是n叉树。在递归中如果只调用自己一次，我们可以把它想象为是一棵一叉树（这是我自己想的，我们可以认为只有一个子节点的树），如果调用自己2次，我们可以把它想象为一棵二叉树，如果调用自己n次，我们可以把它想象为一棵n叉树……。就像下面这样，当到达叶子节点的时候开始往回反弹。<br> <img src="https://images2.imgbox.com/fe/94/sdveIvqt_o.png" alt="在这里插入图片描述"></p> 
<p>递归的时候如果处理不当可能会出现<strong>分支污染导致结果错误</strong>。为什么会出现这种情况，我先来解释一下，因为除了基本类型是值传递以外，其他类型基本上很多都是引用传递。看一下上面的图，比如我开始调用的时候传入一个list对象，在调用第一个分支之后list中的数据修改了，那么后面的所有分支都能感知到，实际上也就是对后面的分支造成了污染。</p> 
<p><strong>我们先来看一个例子吧</strong></p> 
<p>给定一个数组nums=[2，3，5]和一个固定的值target=8。找出数组sums中所有可以使数字和为target的组合。先来画个图看一下<br> <img src="https://images2.imgbox.com/99/3b/1FnuUFlO_o.png" alt="在这里插入图片描述"></p> 
<p>图中红色的表示的是选择成功的组合，这里只画了选择2的分支，由于图太大，所以选择3和选择5的分支没画。在仔细一看这不就是一棵3叉树吗，OK，我们来使用递归的方式，先来看一下函数的定义</p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">combinationSum</span><span class="token punctuation">(</span>List<span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">&gt;</span></span> cur<span class="token punctuation">,</span> <span class="token keyword">int</span> sums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

<span class="token punctuation">}</span>
</code></pre> 
<p>在把递归的模板拿出来</p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">combinationSum</span><span class="token punctuation">(</span>List<span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">&gt;</span></span> cur<span class="token punctuation">,</span> <span class="token keyword">int</span> sums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//逻辑处理</span>

    <span class="token comment">//因为是3叉树，所以这里要调用3次</span>
    <span class="token comment">//递归调用</span>
    <span class="token comment">//递归调用</span>
    <span class="token comment">//递归调用</span>

    <span class="token comment">//逻辑处理</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这种解法灵活性不是很高，如果nums的长度是3，我们3次递归调用，如果nums的长度是n，那么我们就要n次调用……。所以我们可以直接写成for循环的形式，也就是下面这样</p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">combinationSum</span><span class="token punctuation">(</span>List<span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">&gt;</span></span> cur<span class="token punctuation">,</span> <span class="token keyword">int</span> sums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//终止条件必须要有</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//逻辑处理(可有可无，是情况而定)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//逻辑处理(可有可无，是情况而定)</span>
        <span class="token comment">//递归调用(递归调用必须要有)</span>
        <span class="token comment">//逻辑处理(可有可无，是情况而定)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//逻辑处理(可有可无，是情况而定)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>下面我们再来一步一步看</p> 
<p>1，终止条件是什么？</p> 
<p>当target等于0的时候，说明我们找到了一组组合，我们就把他打印出来，所以终止条件很容易写，代码如下</p> 
<pre><code class="prism language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>2，逻辑处理和递归调用</p> 
<p>我们一个个往下选的时候如果要选的值比target大，我们就不要选了，如果不比target大，就把他加入到list中，表示我们选了他，如果选了他之后在递归调用的时候target值就要减去选择的值，代码如下</p> 
<pre><code class="prism language-java">        <span class="token comment">//逻辑处理</span>
        <span class="token comment">//如果当前值大于target我们就不要选了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> sums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
           <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token comment">//否则我们就把他加入到集合中</span>
        cur<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//递归调用</span>
        <span class="token function">combinationSum</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> sums<span class="token punctuation">,</span> target <span class="token operator">-</span> sums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>终止条件和递归调用都已经写出来了，感觉代码是不是很简单，我们再来把它组合起来看下完整代码</p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">combinationSum</span><span class="token punctuation">(</span>List<span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">&gt;</span></span> cur<span class="token punctuation">,</span> <span class="token keyword">int</span> sums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//终止条件必须要有</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//逻辑处理</span>
        <span class="token comment">//如果当前值大于target我们就不要选了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> sums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token comment">//否则我们就把他加入到集合中</span>
        cur<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//递归调用</span>
        <span class="token function">combinationSum</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> sums<span class="token punctuation">,</span> target <span class="token operator">-</span> sums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>我们还用上面的数据打印测试一下</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">new</span> <span class="token class-name">Recursion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">combinationSum</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行结果如下<br> <img src="https://images2.imgbox.com/91/79/DVnNepdY_o.png" alt="在这里插入图片描述"></p> 
<p>是不是很意外，我们思路并没有出错，结果为什么不对呢，其实这就是典型的分支污染，我们再来看一下图<br> <img src="https://images2.imgbox.com/72/86/SX6RHElO_o.png" alt="在这里插入图片描述"></p> 
<p>当我们选择2的时候是一个分支，当我们选择3的时候又是另外一个分支，这两个分支的数据应该是互不干涉的，但实际上当我们沿着选择2的分支走下去的时候list中会携带选择2的那个分支的数据，当我们再选择3的那个分支的时候这些数据还依然存在list中，所以对选择3的那个分支造成了污染。有一种解决方式就是每个分支都创建一个新的list，也就是下面这样，这样任何一个分支的修改都不会影响到其他分支。<br> <img src="https://images2.imgbox.com/af/11/Zsv8C0Z8_o.png" alt="在这里插入图片描述"></p> 
<p>再来看下代码</p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">combinationSum</span><span class="token punctuation">(</span>List<span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">&gt;</span></span> cur<span class="token punctuation">,</span> <span class="token keyword">int</span> sums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//终止条件必须要有</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//逻辑处理</span>
        <span class="token comment">//如果当前值大于target我们就不要选了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> sums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token comment">//由于List是引用传递，所以这里要重新创建一个</span>
        List<span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//把数据加入到集合中</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//递归调用</span>
        <span class="token function">combinationSum</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> sums<span class="token punctuation">,</span> target <span class="token operator">-</span> sums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们看到第13行是重新创建了一个list。再来打印一下看下结果，结果完全正确，每一组数据的和都是8<br> <img src="https://images2.imgbox.com/f3/66/cEjvGzCe_o.png" alt="在这里插入图片描述"></p> 
<p>上面我们每一个分支都创建了一个新的list，所以任何分支修改都只会对当前分支有影响，不会影响到其他分支，也算是一种解决方式。但每次都重新创建数据，运行效率很差。我们知道当执行完分支1的时候，list中会携带分支1的数据，当执行分支2的时候，实际上我们是不需要分支1的数据的，所以有一种方式就是从分支1执行到分支2的时候要把分支1的数据给删除，这就是大家经常提到的<strong>回溯算法</strong>，我们来看下</p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">combinationSum</span><span class="token punctuation">(</span>List<span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">&gt;</span></span> cur<span class="token punctuation">,</span> <span class="token keyword">int</span> sums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//终止条件必须要有</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//逻辑处理</span>
        <span class="token comment">//如果当前值大于target我们就不要选了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> sums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token comment">//把数据sums[i]加入到集合中，然后参与下一轮的递归</span>
        cur<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//递归调用</span>
        <span class="token function">combinationSum</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> sums<span class="token punctuation">,</span> target <span class="token operator">-</span> sums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//sums[i]这个数据你用完了吧，我要把它删了</span>
        cur<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们再来看一下打印结果，完全正确</p> 
<p><img src="https://images2.imgbox.com/b2/91/eNotryxD_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_485"></a>递归分支污染对结果的影响</h3> 
<p>分支污染一般会对结果造成致命错误，但也不是绝对的，我们再来看个例子。生成一个2^n 长的数组，数组的值从0到 (2^n)-1，比如n是3，那么要生成</p> 
<pre><code class="prism language-java"><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
</code></pre> 
<p>我们先来画个图看一下<br> <img src="https://images2.imgbox.com/de/e4/B4bh42Cc_o.png" alt="在这里插入图片描述"></p> 
<p>这不就是个二叉树吗，对于递归前面已经讲的很多了，我们来直接看代码</p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">binary</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
        array<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token function">binary</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        array<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token function">binary</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        array<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面代码很好理解，首先是终止条件，然后是递归调用，在调用之前会把array[index]的值保存下来，最后再还原。我们来测试一下</p> 
<pre><code class="prism language-java"><span class="token keyword">new</span> <span class="token class-name">Recursion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">binary</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>看下打印结果<br> <img src="https://images2.imgbox.com/cf/52/ULHn2b1C_o.png" alt="在这里插入图片描述"></p> 
<p>结果完全正确，我们再来改一下代码</p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">binary</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        array<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token function">binary</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        array<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token function">binary</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>再来看一下打印结果</p> 
<p><img src="https://images2.imgbox.com/18/d0/0kDhF0eR_o.png" alt="在这里插入图片描述"></p> 
<p>和上面结果一模一样，开始的时候我们没有把array[index]的值保存下来，最后也没有对他进行复原，但结果丝毫不差。原因就在上面代码第5行array[index]=0，这是因为，上一分支执行的时候即使对array[index]造成了污染，在下一分支又会对他进行重新修改。即使你把它改为任何数字也都不会影响到最终结果，比如我们在上一分支执行完了时候我们把它改为100，你在试试</p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">binary</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        array<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token function">binary</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        array<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token function">binary</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//注意，这里改成100了</span>
        array<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们看到第10行，把array[index]改为100了，最终打印结果也是不会变的，所以这种分支污染并不会造成最终的结果错误。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/41149bbdb66131cfb728223ac9edd033/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">WPF基本介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/53a2c1c44ea1a8a36ca7607a060df2ad/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">发送HTTP请求返回415状态码的解决办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>