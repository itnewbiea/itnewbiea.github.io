<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>k8s之StatefulSet - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="k8s之StatefulSet" />
<meta property="og:description" content="什么是StatefulSet? 是用来创建有状态应用，可以通过过某种方式记录这些状态，然后在 Pod 被重新创建时，能够为新 Pod 恢复这些状态。
什么是有状态应用？
首先是需要有数据的持久化，及时Pod被重启后，也能恢复，与重启前保持一致。然后是应用创建的所有pod有依赖关系，顺序的创建、需要运行在指定的宿主机上，并且都有对应的网络标志。
应用场景？
分布式应用，它的多个实例之间，往往有依赖关系，比如：主从关系、主备关系。
使用StatefulSet 创建StatefulSet 创建yaml文件定义StatefulSet对象如下，与Deployment比较，多了一个serviceName字段，这个是用来指定StatefulSet锁管理的pod是用域名访问是通过该service所设定的。
apiVersion: apps/v1 kind: StatefulSet metadata: name: redis-sts spec: serviceName: redis-svc replicas: 2 selector: matchLabels: app: redis-sts template: metadata: labels: app: redis-sts spec: containers: - image: redis name: redis ports: - containerPort: 6379 创建StatefulSet对象
[root@k8s-worker1 zwf]# kubectl apply -f statefulset.yaml -n zwf statefulset.apps/redis-sts created [root@k8s-worker1 zwf]# kubectl get sts -n zwf NAME READY AGE redis-sts 2/2 54s 查看创建的Pod会发现，命名不在是随机创建的名字，而是有了顺序号，从0开始，而k8s也会按照这个顺序一次创建。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e2dcd2e1c2282ce99984ab51a2ca643e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-01T23:27:26+08:00" />
<meta property="article:modified_time" content="2022-11-01T23:27:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">k8s之StatefulSet</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="StatefulSet_0"></a>什么是StatefulSet?</h3> 
<p>是用来创建有状态应用，可以通过过某种方式记录这些状态，然后在 Pod 被重新创建时，能够为新 Pod 恢复这些状态。</p> 
<p><strong>什么是有状态应用？</strong></p> 
<p>首先是需要有数据的持久化，及时Pod被重启后，也能恢复，与重启前保持一致。然后是应用创建的所有pod有依赖关系，顺序的创建、需要运行在指定的宿主机上，并且都有对应的网络标志。</p> 
<p><strong>应用场景？</strong></p> 
<p>分布式应用，它的多个实例之间，往往有依赖关系，比如：主从关系、主备关系。</p> 
<h3><a id="StatefulSet_18"></a>使用StatefulSet</h3> 
<h4><a id="StatefulSet_22"></a>创建StatefulSet</h4> 
<p>创建yaml文件定义StatefulSet对象如下，与Deployment比较，多了一个serviceName字段，这个是用来指定StatefulSet锁管理的pod是用域名访问是通过该service所设定的。</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> StatefulSet
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>sts

<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>svc
  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
      <span class="token key atrule">app</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>sts

  <span class="token key atrule">template</span><span class="token punctuation">:</span>
    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>
      <span class="token key atrule">labels</span><span class="token punctuation">:</span>
        <span class="token key atrule">app</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>sts
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">containers</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> redis
        <span class="token key atrule">name</span><span class="token punctuation">:</span> redis
        <span class="token key atrule">ports</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">6379</span>
</code></pre> 
<p>创建StatefulSet对象</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@k8s-worker1 zwf<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f statefulset.yaml  -n zwf</span>
statefulset.apps/redis-sts created

<span class="token punctuation">[</span>root@k8s-worker1 zwf<span class="token punctuation">]</span><span class="token comment"># kubectl get sts -n zwf</span>
NAME        READY   AGE
redis-sts   <span class="token number">2</span>/2     54s
</code></pre> 
<p>查看创建的Pod会发现，命名不在是随机创建的名字，而是有了顺序号，从0开始，而k8s也会按照这个顺序一次创建。</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@k8s-worker1 zwf<span class="token punctuation">]</span><span class="token comment"># kubectl get pods -n zwf</span>
NAME          READY   STATUS    RESTARTS   AGE
redis-sts-0   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          61s
redis-sts-1   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          54s
</code></pre> 
<p>输出pod中的hostname发现与pod的名称也保持一致，也就是应用可以自行决定依赖关系，比如该例子中可以使用0号pod作为主实例，而1号pod作为从实例。</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@k8s-worker1 zwf<span class="token punctuation">]</span><span class="token comment"># kubectl exec -it redis-sts-0 -n zwf -- hostname</span>
redis-sts-0
</code></pre> 
<h4><a id="Service_86"></a>Service配置</h4> 
<p>定义匹配上面的创建StatefulSet对象所有管理的Service，也就是标签筛选需要和pod的标签保持一致，并且这里的metadata.name也要与StatefulSet中的serviceName一样。</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>svc

<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>sts

  <span class="token key atrule">ports</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>
    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP
    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">6379</span>
</code></pre> 
<p>创建Service对象，我们可以看到已经将StatefulSet所创建的pod加入到端点列表了，也就是可以稳定的通过Service来访问到Pod</p> 
<pre><code class="prism language-yaml"><span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>worker1 zwf<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f service_statefulset.yaml -n zwf</span>
kservice/redis<span class="token punctuation">-</span>svc created

<span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>worker1 zwf<span class="token punctuation">]</span><span class="token comment"># kubectl get svc -n zwf</span>
NAME                   TYPE        CLUSTER<span class="token punctuation">-</span>IP   EXTERNAL<span class="token punctuation">-</span>IP   PORT(S)        AGE
redis<span class="token punctuation">-</span>svc              ClusterIP   10.0.0.246   &lt;none<span class="token punctuation">&gt;</span>        6379/TCP       5s

<span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>worker1 zwf<span class="token punctuation">]</span><span class="token comment"># kubectl describe svc redis-svc -n zwf</span>
<span class="token key atrule">Name</span><span class="token punctuation">:</span>              redis<span class="token punctuation">-</span>svc
<span class="token key atrule">Namespace</span><span class="token punctuation">:</span>         zwf
<span class="token key atrule">Labels</span><span class="token punctuation">:</span>            &lt;none<span class="token punctuation">&gt;</span>
<span class="token key atrule">Annotations</span><span class="token punctuation">:</span>       &lt;none<span class="token punctuation">&gt;</span>
<span class="token key atrule">Selector</span><span class="token punctuation">:</span>          app=redis<span class="token punctuation">-</span>sts
<span class="token key atrule">Type</span><span class="token punctuation">:</span>              ClusterIP
<span class="token key atrule">IP Family Policy</span><span class="token punctuation">:</span>  SingleStack
<span class="token key atrule">IP Families</span><span class="token punctuation">:</span>       IPv4
<span class="token key atrule">IP</span><span class="token punctuation">:</span>                10.0.0.246
<span class="token key atrule">IPs</span><span class="token punctuation">:</span>               10.0.0.246
<span class="token key atrule">Port</span><span class="token punctuation">:</span>              &lt;unset<span class="token punctuation">&gt;</span>  6379/TCP
<span class="token key atrule">TargetPort</span><span class="token punctuation">:</span>        6379/TCP
<span class="token key atrule">Endpoints</span><span class="token punctuation">:</span>         10.222.126.51<span class="token punctuation">:</span><span class="token number">6379</span><span class="token punctuation">,</span>10.222.194.84<span class="token punctuation">:</span><span class="token number">6379</span>
<span class="token key atrule">Session Affinity</span><span class="token punctuation">:</span>  None
<span class="token key atrule">Events</span><span class="token punctuation">:</span>            &lt;none<span class="token punctuation">&gt;</span>
</code></pre> 
<p>但是我们的Pod不是一般的的应用，是有状态的应用，需要有稳定的网络标识，所以会为每一个Pod也创建一个域名，格式是：<code>&lt;podName&gt;.&lt;serviceName&gt;.&lt;namesapce&gt;.svc.cluster.local</code>。</p> 
<p>我们进入pod中验证一下，通过<code>ping redis-sts-1.redis-svc.zwf.svc.cluster.local</code>发现是可以ping通的，虽然Pod的IP会变化，但是通过固定的域名就能访问到指定Pod了。</p> 
<pre><code>[root@k8s-worker1 zwf]# kubectl exec -it redis-sts-0 -n zwf -- ping redis-sts-1.redis-svc.zwf.svc.cluster.local
PING redis-sts-1.redis-svc.zwf.svc.cluster.local (10.222.126.51) 56(84) bytes of data.
64 bytes from redis-sts-1.redis-svc.zwf.svc.cluster.local (10.222.126.51): icmp_seq=1 ttl=62 time=0.964 ms
64 bytes from redis-sts-1.redis-svc.zwf.svc.cluster.local (10.222.126.51): icmp_seq=2 ttl=62 time=0.932 ms
</code></pre> 
<p>既然我们的pod有了稳定的网络标识，Service也就不需要再分配ClusterIP了，这个时候，只需要添加字段clusterIP: None，这样就不会再分配IP了，这样的Service称为<strong>Headless Service</strong></p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>svc

<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">clusterIP</span><span class="token punctuation">:</span> None
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>sts

  <span class="token key atrule">ports</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>
    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP
    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">6379</span>
</code></pre> 
<p>创建Headless Service，可以看到CLUSTER-IP为None</p> 
<pre><code>[root@k8s-worker1 zwf]# kubectl get svc -n zwf
NAME                   TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE
demoapp-nodeport-svc   NodePort    10.0.0.144   &lt;none&gt;        80:31999/TCP   21h
demoapp-svc            ClusterIP   10.0.0.74    &lt;none&gt;        80/TCP         22h
redis-svc              ClusterIP   None         &lt;none&gt;        6379/TCP       4s
</code></pre> 
<p>Service和StatefulSet配置图如下：</p> 
<p><img src="https://images2.imgbox.com/c4/02/x80yBzhB_o.png" alt=""></p> 
<h4><a id="_190"></a>持久化配置</h4> 
<p>接下来是给StatefulSet对象添加持久化配置。</p> 
<p>定义StatefulSet描述如下：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> StatefulSet
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>pv<span class="token punctuation">-</span>sts

<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>pv<span class="token punctuation">-</span>svc

  <span class="token key atrule">volumeClaimTemplates</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">metadata</span><span class="token punctuation">:</span>
      <span class="token key atrule">name</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>100m<span class="token punctuation">-</span>pvc
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client
      <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> ReadWriteMany
      <span class="token key atrule">resources</span><span class="token punctuation">:</span>
        <span class="token key atrule">requests</span><span class="token punctuation">:</span>
          <span class="token key atrule">storage</span><span class="token punctuation">:</span> 100Mi

  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
      <span class="token key atrule">app</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>pv<span class="token punctuation">-</span>sts

  <span class="token key atrule">template</span><span class="token punctuation">:</span>
    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>
      <span class="token key atrule">labels</span><span class="token punctuation">:</span>
        <span class="token key atrule">app</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>pv<span class="token punctuation">-</span>sts
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">containers</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token punctuation">:</span>5<span class="token punctuation">-</span>alpine
        <span class="token key atrule">name</span><span class="token punctuation">:</span> redis

        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>100m<span class="token punctuation">-</span>pvc
          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data
</code></pre> 
<p>参数：</p> 
<ul><li>volumeClaimTemplates，用来将PVC的定义嵌入到StatefulSet中的字段，是创建PVC的模板，可以让每一个Pod都能自动创建PVC</li><li>voulumeMounts，是用来选择上面的PVC挂载在容器的/data目录中</li></ul> 
<p>创建StatefulSet对象，可以看到pod已经创建起来了。</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@k8s-worker1 zwf<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f statefulset_pvc.yaml -n zwf</span>
statefulset.apps/redis-pv-sts created

<span class="token punctuation">[</span>root@k8s-worker1 zwf<span class="token punctuation">]</span><span class="token comment"># kubectl get sts -n zwf</span>
NAME           READY   AGE
redis-pv-sts   <span class="token number">2</span>/2     <span class="token number">25</span>

<span class="token punctuation">[</span>root@k8s-worker1 zwf<span class="token punctuation">]</span><span class="token comment"># kubectl get pods -n zwf</span>
NAME             READY   STATUS    RESTARTS   AGE
redis-pv-sts-0   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          63s
redis-pv-sts-1   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          54s
</code></pre> 
<p>我们查看pvc，会发现创建了2个对象 ，以<code>PVC名称-pod名称</code>命名。</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@k8s-worker1 zwf<span class="token punctuation">]</span><span class="token comment"># kubectl get pvc -n zwf</span>
NAME                            STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
redis-100m-pvc-redis-pv-sts-0   Bound    pvc-2712daa4-36b4-4a63-ac2f-7d3b31e2a887   100Mi      RWX            nfs-client     109s
redis-100m-pvc-redis-pv-sts-1   Bound    pvc-a3781354-e182-42f7-b6f6-983999603653   100Mi      RWX            nfs-client     100s
</code></pre> 
<p>进入到pod中，使用redis-cli运行redis客户端，添加一些数据</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@k8s-worker1 zwf<span class="token punctuation">]</span><span class="token comment"># kubectl exec -it redis-pv-sts-0 -n zwf /bin/bash</span>
<span class="token punctuation">[</span> root@redis-pv-sts-0:/data <span class="token punctuation">]</span>$ redis-cli  
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> name zhangsan
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> age <span class="token number">18</span>
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> keys *
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"name"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"age"</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> quit
</code></pre> 
<p>将pod删除，然后再重新进入Pod中，查询之前创建的redis的key，还是能够查询到。</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@k8s-worker1 zwf<span class="token punctuation">]</span><span class="token comment"># kubectl exec -it redis-pv-sts-0  -n zwf -- /bin/bash</span>
<span class="token punctuation">[</span> root@redis-pv-sts-0:/data <span class="token punctuation">]</span>$ redis-cli  
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> keys *
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"name"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"age"</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get name
<span class="token string">"zhangsan"</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get age
<span class="token string">"18"</span>
</code></pre> 
<p>配置的关系图如下：</p> 
<p><img src="https://images2.imgbox.com/02/28/7ILXs8p5_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_307"></a>欢迎关注，互相学习，共同进步~</h3> 
<p>我的<a href="https://www.zhengwenfeng.com" rel="nofollow">个人博客</a></p> 
<p>我的微信公众号：编程黑洞</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c8d085db89fa396367d8ad6886064835/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2022年长安杯比赛复现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cd78f340dfd2a18b7d0d10bfe312746f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pyspark streaming简介 和 消费 kafka示例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>