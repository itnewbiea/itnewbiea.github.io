<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL索引建立和优化策略 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySQL索引建立和优化策略" />
<meta property="og:description" content="索引执行查看以及失效情况 示例表建表语句：
explain 查看执行计划 一条简单查询的执行计划：
possible_key 字段表示可能用到到索引key 字段表示实际用的索引key_len 表示索引的长度rows 表示扫描的数据行数type 表示数据扫描类型 常见扫描类型执行效率从低到高的顺序为：
ALL(全表扫描)、index(全索引扫描)、range(索引范围扫描)、ref(非唯一索引扫描)、eq_ref（唯一索引扫描）、const(结果只有一条的主键或唯一索引扫描)。 PS：全表扫描和全索引扫描是需要尽量避免的。
索引失效的例子 like 语句
结合普通索引的B&#43;tree 结构解释原因
当MySQL优化器根据name like ‘%Parto’ 这个条件到索引 index_name 的B&#43;tree数上进行查询评估时，发现当前节点的左右子节点上的值都有可能符合‘%Parto’这个条件，于是优化器判定当前索引需要扫描整个索引并且还要回表查询，不如直接全表扫描。
一些其他类似索引失效的情况： 1、在索引列上做了计算、函数、类型转换操作。2、like 匹配使用了前缀匹配符 ‘%abc’。3、字符串不加引号导致类型转换。 这些索引失效的原因时查询过程需要扫描整个索引并回表，代价高于直接全表扫描。
可能发送索引失效的情况： 1、索引列上用了 != , &gt; , &gt;= , &lt; , &lt;= , or , in 等。2、索引列上用了 is null , is not null 如果MySQL查询优化器预估走索引的代价比全表扫描的代价还要大，则不走相应的索引直接全表扫描。如果走索引比全表扫描代价小，则使用索引。
可以通过 force index 的方式强制查询引擎走特定的索引 index_name ,MySQL查询优化器的预估并不是精确的，在对索引的效率有把握的情况下可以强制走特定的索引来提高查询效率。
高效索引的建立 建立前缀索引 建立前缀索引时常用的方法之一，通常字符类型的字段只需要对它前面几位字符建立索引就能满足性能要求了，过长的索引会占用更多空间，也影响查找效率。
建立覆盖索引 所谓覆盖索引是指SQL中查询的所有字段在索引 B&#43;tree 的叶子节点上都能找到的那些索引。
使用覆盖索引查询时无需回表查询。
联合索引的最左匹配准则：
这个准则指明了联合索引中某个字段如果想要被用到联合索引的过滤当中，除了这个字段不会使联合索引失效以外，还一个必要前提是这个字段的前一个字段也被用到了联合索引的过滤中。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d12292bc3fe21910967b8c738c894b09/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-17T16:42:00+08:00" />
<meta property="article:modified_time" content="2021-06-17T16:42:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL索引建立和优化策略</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>索引执行查看以及失效情况</h3> 
<blockquote> 
 <p>示例表建表语句：<br> <img src="https://images2.imgbox.com/b3/bd/sN1sqrca_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h5><a id="explain__3"></a>explain 查看执行计划</h5> 
<blockquote> 
 <p>一条简单查询的执行计划：<br> <img src="https://images2.imgbox.com/d4/24/qJXPOJNB_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<ul><li>possible_key 字段表示可能用到到索引</li><li>key 字段表示实际用的索引</li><li>key_len 表示索引的长度</li><li>rows 表示扫描的数据行数</li><li>type 表示数据扫描类型 
  <ul><li>常见扫描类型执行效率从低到高的顺序为：<br> ALL(全表扫描)、index(全索引扫描)、range(索引范围扫描)、ref(非唯一索引扫描)、eq_ref（唯一索引扫描）、const(结果只有一条的主键或唯一索引扫描)。</li></ul> </li></ul> 
<blockquote> 
 <p>PS：全表扫描和全索引扫描是需要尽量避免的。</p> 
</blockquote> 
<h5><a id="_15"></a>索引失效的例子</h5> 
<blockquote> 
 <p>like 语句<br> <img src="https://images2.imgbox.com/46/ef/Jvt73WT0_o.png" alt="在这里插入图片描述"><br> 结合普通索引的B+tree 结构解释原因<br> <img src="https://images2.imgbox.com/a7/24/GiECFQiJ_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>当MySQL优化器根据name like ‘%Parto’ 这个条件到索引 index_name 的B+tree数上进行查询评估时，发现当前节点的左右子节点上的值都有可能符合‘%Parto’这个条件，于是优化器判定当前索引需要扫描整个索引并且还要回表查询，不如直接全表扫描。</p> 
</blockquote> 
<ul><li>一些其他类似索引失效的情况： 
  <ul><li>1、在索引列上做了计算、函数、类型转换操作。</li><li>2、like 匹配使用了前缀匹配符 ‘%abc’。</li><li>3、字符串不加引号导致类型转换。</li></ul> </li></ul> 
<blockquote> 
 <p>这些索引失效的原因时查询过程需要扫描整个索引并回表，代价高于直接全表扫描。</p> 
</blockquote> 
<ul><li>可能发送索引失效的情况： 
  <ul><li>1、索引列上用了 != , &gt; , &gt;= , &lt; , &lt;= , or , in 等。</li><li>2、索引列上用了 is null , is not null</li></ul> </li></ul> 
<blockquote> 
 <p>如果MySQL查询优化器预估走索引的代价比全表扫描的代价还要大，则不走相应的索引直接全表扫描。如果走索引比全表扫描代价小，则使用索引。<br> <img src="https://images2.imgbox.com/a9/d1/Oqwx0Qvv_o.png" alt="在这里插入图片描述"><br> 可以通过 force index 的方式强制查询引擎走特定的索引 index_name ,MySQL查询优化器的预估并不是精确的，在对索引的效率有把握的情况下可以强制走特定的索引来提高查询效率。<br> <img src="https://images2.imgbox.com/e3/ed/BNHvsSi8_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_39"></a>高效索引的建立</h3> 
<h5><a id="_40"></a>建立前缀索引</h5> 
<p>建立前缀索引时常用的方法之一，通常字符类型的字段只需要对它前面几位字符建立索引就能满足性能要求了，过长的索引会占用更多空间，也影响查找效率。</p> 
<h5><a id="_43"></a>建立覆盖索引</h5> 
<p>所谓覆盖索引是指SQL中查询的所有字段在索引 B+tree 的叶子节点上都能找到的那些索引。<br> 使用覆盖索引查询时无需回表查询。</p> 
<blockquote> 
 <p>联合索引的最左匹配准则：<br> 这个准则指明了联合索引中某个字段如果想要被用到联合索引的过滤当中，除了这个字段不会使联合索引失效以外，还一个必要前提是<strong>这个字段的前一个字段也被用到了联合索引的过滤中</strong>。<br> 因此建立联合索引是的字段顺序对索引效率是有很大影响的，越靠前的字段被用于索引过滤的概率越高。开发工作中建立联合索引时需要把区分度大的字段排在靠前的位置，这样区分度大的字段越有可能被更多的SQL用到。(如性别这种区分度小的字段就不适合靠前，uuid则合适)<br> 失效示例：<br> <img src="https://images2.imgbox.com/f9/31/Wi7njJc1_o.png" alt="在这里插入图片描述"></p> 
 <ul><li>sales字段前面的 name 字段使得联合索引失效了 ，无法满足最左匹配准则。<br> 有效示例：<br> <img src="https://images2.imgbox.com/24/b7/bfYRUVNn_o.png" alt="在这里插入图片描述"></li></ul> 
</blockquote> 
<h6><a id="_55"></a>索引下推机制</h6> 
<blockquote> 
 <p>依据联合索引的最左匹配准则，当联合索引中某个字段使得索引失效时，这个字段就不能被联合索引用于索引过滤了。<br> MySQL 从5.6 版本开始针对这种情况引入了索引下推机制。</p> 
</blockquote> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>sales<span class="token punctuation">,</span>age <span class="token keyword">from</span> workers <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'Parto'</span> <span class="token operator">and</span> sales <span class="token operator">&gt;</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/d2/7a/eiZgXaNv_o.png" alt="在这里插入图片描述"></p> 
<p>这条语句中的name字段被用在了联合索引的过滤中,而 sales 字段由于是一个范围很广的范围查询，被优化器判定位使得索引失效了。执行计划中的 Using index condition 表面SQL 查询用到了索引下推。<br> 在索引下推机制开启时，查询引擎在根据 name = ‘Parto’ 的条件找到联合索引 index_name_sales的叶子节点后，会在叶子节点上根据 sales &gt; 10 的条件进一步过滤数据。<br> 而在索引下推机制关闭时，sales &gt; 10 的条件实在 MySQL Server 层根据查询引擎返回的结果再过滤的。<br> 显然<strong>索引下推机制能减少二级索引的回表次数，也能减少查询引擎和MySQL Server 层之间的传递数据量。</strong><br> <img src="https://images2.imgbox.com/0e/e5/zAg82owg_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="joinorder_by__group_by__70"></a>join、order by 和 group by 的使用注意</h4> 
<h6><a id="join_71"></a>join</h6> 
<ul><li>参与 join 的字段上一般需要加上索引</li></ul> 
<h6><a id="order_by_74"></a>order by</h6> 
<ul><li>在实际开发中并不是提倡一定要在 order by 字段上加索引，而是提倡尽量结合现有的索引字段进行 order by 操作，尽量避免低效的文件排序操作，以提升SQL查询效率。</li></ul> 
<h6><a id="group_by_77"></a>group by</h6> 
<ul><li>如果 group by 操作能够依赖索引完成则不需要创建临时表，执行效率高。<br> <img src="https://images2.imgbox.com/04/84/OtQp5jwm_o.png" alt="在这里插入图片描述"></li></ul> 
<blockquote> 
 <p>在实际场景中，复杂的语句很容易使得 order by 和 group by 无法使用相关的索引，所以我们要有意识地寻求 order by 和 group by 依赖相关索引完成。以避免 order by 中低效的文件排序或在 group by 中创建临时表.<br> 如果难度太大或建立索引代价太高的话，也不必强求使用索引。</p> 
</blockquote> 
<h3><a id="_83"></a>索引的缺点</h3> 
<ul><li>索引会带来数据写入延迟。</li><li>索引会引入额外的空间损耗。</li><li>索引能提升查询效率的场景是有限的，大数据量时需要其它的如<strong>读写分离、分库分表</strong>等方案。</li></ul> 
<blockquote> 
 <p>在整表数据量不大且查询走了索引仍然很慢的情况，可能的原因有：</p> 
 <ul><li>SQL 查询是事务中依赖MVCC(多版本并发控制)的快照读，需要多次版本回退。</li><li>或者SQL查询操作需要等待上一次更新操作释放表的写锁。</li></ul> 
</blockquote> 
<h3><a id="_92"></a>总结</h3> 
<p><img src="https://images2.imgbox.com/8a/c7/OjTnVas2_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<blockquote> 
 <p>笔记依据：https://time.geekbang.org/dailylesson/detail/100056830?tid=143 内容编写。</p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/83479f8b5211b041c175131d19ac0c73/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何将input的值设为不可修改</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9f161291abe6a363afeee5ee2e707870/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">用Python根据Excel指定文件名将其批量移动到另一个文件夹</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>