<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Pandas教程（五）—— 数据重塑透视及批量处理 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Pandas教程（五）—— 数据重塑透视及批量处理" />
<meta property="og:description" content="1.数据重塑 重塑数据主要有两种方式，分别是 stack（堆叠）和 unstack（拆堆），他们两个是互逆的操作
函数作用 data.stack（ ）
堆叠
会“旋转”或将列中的数据透视到行
列 一一&gt; 行
data.unstack（ ）
拆堆
将行中的数据透视到列 行 一一&gt; 列
参数说明：
level：要堆叠的列 / 行的层级，默认为-1（最内层）
dropna：是否排除缺失的组合。默认为 True
import pandas as pd import numpy as np data = pd.DataFrame(np.arange(12).reshape(6,2), index = pd.MultiIndex.from_product([[&#34;Ohio&#34;,&#34;Colorado&#34;],[&#34;one&#34;,&#34;two&#34;,&#34;three&#34;]],names = [&#34;state&#34;,&#34;number&#34;]), columns = pd.Index([&#34;left&#34;,&#34;right&#34;],name = &#34;side&#34;)) print(data) print(&#34;-&#34;*35) # 拆堆 行透视为列 chai = data.unstack(&#34;state&#34;) # 传入要拆分的层级 print(chai) print(&#34;-&#34;*35) # 堆叠 列透视为行 dui = chai.stack(&#34;side&#34;) print(dui) 上述代码示意图 2.数据透视表 透视表是一种可以对数据动态排布并且分类汇总的表格格式
可以让我们从不同的角度去分析一个大数据库，有点类似于分类筛选的高阶版操作" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c90f7b978768e96189dc466cda7d2980/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-03T21:14:52+08:00" />
<meta property="article:modified_time" content="2024-01-03T21:14:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Pandas教程（五）—— 数据重塑透视及批量处理</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="background-color:transparent;">1.数据重塑</h2> 
<p>重塑数据主要有两种方式，分别是 stack（堆叠）和 unstack（拆堆），他们两个是互逆的操作</p> 
<table border="2" cellpadding="1" cellspacing="1" style="width:600px;"><thead><tr><th style="text-align:center;width:148px;">函数</th><th style="text-align:center;width:239px;">作用</th></tr></thead><tbody><tr><td style="text-align:center;width:148px;"> <p style="text-align:center;">data.stack（ ）</p> <p style="text-align:center;">堆叠</p> </td><td style="width:239px;"> <p style="text-align:center;">会“旋转”或<span style="background-color:#f9eda6;">将列中的数据透视到行</span></p> <p style="text-align:center;"><strong><span style="background-color:#fbd4d0;">列 一一&gt; 行</span></strong></p> </td></tr><tr><td style="text-align:center;width:148px;"> <p style="text-align:center;">data.unstack（ ）</p> <p style="text-align:center;">拆堆</p> </td><td style="width:239px;"> <p style="text-align:center;"><span style="background-color:#f9eda6;">将行中的数据透视到列</span> </p> <p style="text-align:center;"><strong><span style="background-color:#fbd4d0;">行 一一&gt; 列</span></strong></p> </td></tr></tbody></table> 
<blockquote> 
 <p><strong>参数说明：</strong></p> 
 <p>           <span style="background-color:#f9eda6;"><span style="color:#fe2c24;"><strong>level：</strong></span>要堆叠的列 / 行的层级，<strong>默认为-1（最内层）</strong></span></p> 
 <p>           dropna：是否排除缺失的组合。默认为 True</p> 
</blockquote> 
<p> </p> 
<pre><code class="language-python">import pandas as pd
import numpy as np
data = pd.DataFrame(np.arange(12).reshape(6,2),
                    index = pd.MultiIndex.from_product([["Ohio","Colorado"],["one","two","three"]],names = ["state","number"]),
                    columns = pd.Index(["left","right"],name = "side"))
print(data)
print("-"*35)

# 拆堆 行透视为列
chai = data.unstack("state") # 传入要拆分的层级
print(chai)
print("-"*35)

# 堆叠 列透视为行
dui = chai.stack("side")
print(dui)</code></pre> 
<p></p> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" height="488" src="https://images2.imgbox.com/2b/4f/oXI5lWPb_o.png" width="532"> 
  <figcaption>
    上述代码示意图 
  </figcaption> 
 </figure> 
</div> 
<p></p> 
<p></p> 
<h2 style="background-color:transparent;">2.数据透视表</h2> 
<p>透视表是一种可以对数据<strong>动态排布</strong>并且<strong>分类汇总</strong>的表格格式</p> 
<p>可以让我们从不同的角度去分析一个大数据库，有点类似于分类筛选的高阶版操作</p> 
<h3></h3> 
<h3> 2.1 pivot_table </h3> 
<p>  该部分笔记参考了以下文章：</p> 
<p><a class="link-info has-card" href="https://zhuanlan.zhihu.com/p/31952948" rel="nofollow" title="https://zhuanlan.zhihu.com/p/31952948"><span class="link-card-box"><span class="link-title">https://zhuanlan.zhihu.com/p/31952948</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/ad/fd/YdG08Xye_o.png" alt="icon-default.png?t=N7T8">https://zhuanlan.zhihu.com/p/31952948</span></span></a></p> 
<ul><li><strong>语法：</strong>     </li></ul> 
<p>         <span style="background-color:#f9eda6;">pivot_table ( data,  index = None,  values = None,  columns = None,  aggfunc = 'mean' ) </span> </p> 
<blockquote> 
 <p><strong>常用参数说明：</strong> </p> 
 <p></p> 
 <p>                  <strong> index：</strong>  设置<strong>行分层字段</strong>，将选中的列设为<span style="background-color:#f9eda6;">行索引   👇</span></p> 
 <p>                  <strong> values：</strong>输入一个含列名的列表，筛选我们需要保留的列</p> 
 <p>                   <strong>columns：</strong>类似Index设置<strong>列分层字段，</strong>将选中的列设为<span style="background-color:#f9eda6;">列索引   👉</span></p> 
 <p>                  <strong> aggfunc：</strong>设置我们对数据聚合时进行的函数操作，默认为 mean</p> 
 <p></p> 
 <p>                   fill_value：替换缺失值</p> 
 <p>                   drop_na：是否去除所有条目均为NA的列（默认False，不去除）</p> 
 <p>                   margins：是否添加行 / 列计数 及 总计数（默认False，不添加）</p> 
</blockquote> 
<p></p> 
<ul><li><strong>参数使用说明</strong></li></ul> 
<p>       下面我们以詹姆斯某赛季的数据为例，来对pivot_table函数进行讲解</p> 
<p></p> 
<p>  <strong>step1</strong>  首先导入数据，并展示前五场：</p> 
<pre><code class="language-python">import pandas as pd
import numpy as np
road = "E:\python 资料\孙兴华 数据分析教程\Pandas课件\课件\pandas教程\课件028-029\Lebron_James.csv"
data = pd.read_table(road,sep=",")
print(data.head(5))</code></pre> 
<figure class="image"> 
 <img alt="" height="170" src="https://images2.imgbox.com/e9/14/CI3U7aea_o.png" width="659"> 
 <figcaption>
   詹姆斯比赛数据，前五场 
 </figcaption> 
</figure> 
<p></p> 
<p></p> 
<p><strong> step2</strong>  需要james在<strong>主客场和不同胜负情况（<span style="background-color:#f9eda6;">index</span>）</strong>下的<strong>得分、篮板与助攻（<span style="background-color:#f9eda6;">values</span>）</strong>三项数据</p> 
<pre><code class="language-python">data1 = pd.pivot_table(data, index=['对手', '主客场'],values=['得分','助攻','篮板'])
print(data1.head(5))</code></pre> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" height="189" src="https://images2.imgbox.com/c7/c0/WkhzLS2S_o.png" width="296"> 
  <figcaption>
    上述代码筛选得到的数据 
  </figcaption> 
 </figure> 
</div> 
<p></p> 
<p></p> 
<p><strong>   step3  </strong>我们还想获得james在主客场和不同胜负情况下的<strong><span style="background-color:#f9eda6;">总</span></strong><span style="background-color:#f9eda6;">得分、</span><strong><span style="background-color:#f9eda6;">总</span></strong><span style="background-color:#f9eda6;">篮板、</span><strong><span style="background-color:#f9eda6;">总</span></strong><span style="background-color:#f9eda6;">助攻（<strong>aggfunc</strong>）</span></p> 
<p>              此时应该向aggfunc中输入sum函数，按层次求和</p> 
<pre><code class="language-python"># 这里要注意mean不是内置函数，它是numpy中的一个函数
data2 = pd.pivot_table(data, index=['对手', '主客场'],values=['得分','助攻','篮板'],
                       aggfunc=[sum,np.mean])
print(data2.head(5))</code></pre> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" height="214" src="https://images2.imgbox.com/77/be/XNct5VLd_o.png" width="450"> 
  <figcaption>
    总得分、篮板、助攻情况如图 
  </figcaption> 
 </figure> 
</div> 
<p></p> 
<p></p> 
<p> <strong> step4  </strong>我们也可以通过columns再设置一个列索引，并且通过margin来汇总</p> 
<pre><code class="language-python"># fill_value填充空值,margins=True进行汇总
data3 =pd.pivot_table(data,index=['主客场'],columns=['对手'],values=['得分'],aggfunc=[np.sum],fill_value=0,margins=1)
print(data3)</code></pre> 
<figure class="image"> 
 <img alt="" height="199" src="https://images2.imgbox.com/b6/38/1MNmUqEc_o.png" width="1075"> 
 <figcaption>
   行索引为主客场，列索引为对手球队 
 </figcaption> 
</figure> 
<p></p> 
<p></p> 
<p></p> 
<h3> 2.2 <span style="color:#222226;"><strong>实现excel的vlookup功能</strong></span></h3> 
<ul><li><span style="color:#222226;">要求：一个excel表中有两个sheet，要求将 sheet1 中的某列，插入到 sheet2 的指定位置</span> </li></ul> 
<p></p> 
<ul><li><strong>step：</strong></li></ul> 
<ol><li> 切片要合并的列 </li><li>将它和sheet2合并</li><li>再在合并的数据中提取出该列，并在合并数据中删除该列</li><li>将提取出的该列插入指定位置</li></ol> 
<pre><code class="language-python">import pandas as pd
road = "E:\python 资料\孙兴华 数据分析教程\Pandas课件\课件\pandas教程\课件028-029\Vlookup.xlsx"
data1 = pd.read_excel(road,sheet_name="花名册")
data2 = pd.read_excel(road,sheet_name="成绩单")

# 将 花名册 与 成绩单中的总分、学号 合并
hebing = pd.merge(data1,data2.loc[:,["学号","总分"]],how = "left",on = "学号")
print(hebing)
print("-" * 40)

# 将总分放到第二列的位置
score = hebing.总分 # 提取出 总分 列
hebing = hebing.drop("总分",axis = 1) # 在原数据中删除该列
hebing.insert(1,"总分",score) # 在原数据第二列插入新列
print(hebing)</code></pre> 
<p><img alt="" height="440" src="https://images2.imgbox.com/bb/10/D4V4AZce_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<h2 style="background-color:transparent;">3.数据处理两板斧</h2> 
<p>     在数据处理中，经常会对一个DataFrame进行逐行、逐列和逐元素的操作，对应这些操作，Pandas中的 map \ apply  可以解决绝大部分这样的数据处理需求</p> 
<p></p> 
<h3> 3.1 map</h3> 
<p>          map会根据提供的函数或字典对指定序列做映射，它更多地适用于简单的批量处理数据，function中的参数最好只有一个</p> 
<p></p> 
<ul><li><strong>语法：</strong><span style="background-color:#f9eda6;">map（字典） 或   data.map（function）或 map（function，data）</span></li></ul> 
<p></p> 
<ul><li><strong>案例一</strong>：对每个单元格（元素）执行指定的函数操作</li></ul> 
<p>             <span style="color:#fe2c24;">一般使用匿名函数 lambda 去定义函数，进行操作 </span></p> 
<pre><code class="language-python">import pandas as pd
road = "E:\python 资料\孙兴华 数据分析教程\Pandas课件\课件\pandas教程\课件030-031\数据2.xlsx"
data = pd.read_excel(road)
print(data)
print("-"*40)

data2 = data.map(lambda x:"%.2f" % x) #每个元素保留两位小数
print(data2)
print("-"*40)

data3 = data.map(lambda x: x ** 2) #每个元素的平方
print(data3)</code></pre> 
<figure class="image"> 
 <img alt="" height="267" src="https://images2.imgbox.com/f8/bf/V5Pf4bIK_o.png" width="1200"> 
 <figcaption>
   运行结果 
 </figcaption> 
</figure> 
<p></p> 
<p></p> 
<ul><li><strong>案例二：逐行 / 列处理数据</strong></li></ul> 
<p>       在原数据中新增两列， 若为男就是先生，若为女就是女士；再根据体重判断体型，若大于80kg就是魁梧，小于80kg就是瘦小</p> 
<pre><code class="language-python">import pandas as pd
road = "E:\python 资料\孙兴华 数据分析教程\Pandas课件\课件\pandas教程\课件030-031\数据.xlsx"
data = pd.read_excel(road)
print(data)
print("-"*40)

# 一：用字典做映射
zidian = {'男':'先生','女':'女士'}
data["称呼"] = data["性别"].map(zidian) #新增一个 称呼 列，若为男就是先生，若为女就是女士
print(data)
print("-"*40)

# 二：用函数做映射
def judge(x):
    result = "魁梧" if x &gt; 80 else "瘦小"
    return result
data["体型"] = data["体重"].map(judge) #根据体重判断体型
print(data)</code></pre> 
<p><img alt="" height="362" src="https://images2.imgbox.com/7b/12/Ck3bF7dY_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<p></p> 
<h3 style="background-color:transparent;"> 3.2 apply</h3> 
<p>apply() 函数的自由度较高，可以直接对 DataFrame 中元素进行逐元素的遍历操作，方便且高效；与map相比，它可以<span style="background-color:#f9eda6;">在一个函数中传入多个参数</span>来使用，适用范围较广（可传入更复杂的函数）</p> 
<p></p> 
<ul><li><strong>语法</strong> ：<span style="background-color:#f9eda6;">data.apply（  function，axis = 0，row = False，arg = （元组））</span></li></ul> 
<blockquote> 
 <p>参数说明：</p> 
 <p>           axis = ：沿哪个轴进行数据处理（默认为0，处理每一列）</p> 
 <p>           row = ：0表示把每一行或列作为 Series 传入函数中；1表示接收ndarry数组</p> 
 <p>          <span style="background-color:#c7e6ea;"><span style="color:#fe2c24;"> <strong>arg =</strong></span><span style="color:#fbd4d0;"><strong> </strong></span>：若函数有多个参数，则传入一个<strong>元组</strong>，接收第二至最后一个参数 </span> </p> 
</blockquote> 
<p></p> 
<blockquote> 
 <p> 其余说明事项：</p> 
 <ol><li>在处理多个参数时，需要用arg参数接收第二至最后一个参数</li><li>在处理多行时，直接在data位置传入 dataframe 或者 df切片后的多列即可</li><li>当axis=1对行进行操作时，<span style="background-color:#f9eda6;">会默认将每一行数据以Series的形式</span>（Series的索引为列名）传入指定函数，返回相应的结果；axis = 0同理</li></ol> 
</blockquote> 
<p></p> 
<p></p> 
<p></p> 
<ul><li><strong>案例一</strong>：单行或单列进行操作（map也可以完成） </li></ul> 
<p>       要求：仍然使用map中案例二的数据，修改分数：所有人的语文成绩 +5 分 </p> 
<pre><code class="language-python">def score_change(x,y): # x为科目，y为修改值
    return x + y

#arg传入一个元组，接受第二个参数
data["语文"] = data["语文"].apply(score_change,args=(5,)) </code></pre> 
<p></p> 
<ul><li><strong>案例二</strong>：对多行 / 多列进行操作</li></ul> 
<p>  要求：计算每个人（逐行）三科的总成绩，并根据总成绩排序</p> 
<pre><code class="language-python">data["总成绩"] = data[['语文','数学','英语']].apply(sum,axis=1) # 逐行相加

data = data.sort_values (by="总成绩",ascending=False) # 根据总成绩降序排序
print(data)</code></pre> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" height="165" src="https://images2.imgbox.com/9c/ab/PWqElbiu_o.png" width="412"> 
  <figcaption>
    根据总成绩排序结果（部分） 
  </figcaption> 
 </figure> 
</div> 
<p></p> 
<ul><li><strong>案例三：</strong> 综合运用</li></ul> 
<p>       要求：计算每个人的bmi</p> 
<pre><code class="language-python">def BMI(data):
    height = data["身高"]
    weight = data["体重"]
    BMI =weight / height ** 2
    return BMI

data["BMI"] = data.apply(BMI,axis=1)
print(data)</code></pre> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" height="175" src="https://images2.imgbox.com/f3/02/mVXIsoDO_o.png" width="487"> 
  <figcaption>
    BMI（部分） 
  </figcaption> 
 </figure> 
</div> 
<p></p> 
<p></p> 
<p></p> 
<h3></h3>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/44d044bd3b6d222cb3e1b4f32c79dde6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用C#发送邮箱验证码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3f8a8ab0dc47ce83c9b3f420ec57c45a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">利用腐蚀去除图像噪声、利用膨胀填充两个字符中的空隙</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>