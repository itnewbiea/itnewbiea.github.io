<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RocketMQ 5.0 时代，6 张图带你理解 Proxy！ - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RocketMQ 5.0 时代，6 张图带你理解 Proxy！" />
<meta property="og:description" content="大家好，今天来聊一聊 RocketMQ 5.0 中的 Proxy。
RocketMQ 5.0 为了更好地拥抱云原生，引入了无状态的 Proxy 模块，新的架构图如下：
引入 Proxy 模块后，Proxy 承担了协议适配、权限管理、消息管理等计算功能，Broker 则更加专注于存储。这样存储和计算相分离，在云原生环境下可以更好地进行资源调度。
1.Proxy 介绍 RocketMQ 5.0 把客户端的部分功能下沉到 Proxy，Proxy 承接了之前 客户端的计算能力，客户端变得更加轻量级。
1.1 NameServer 从上面的架构图可以看到，Producer/Consumer 不再需要注册到 NameServer，这一部分功能下移到了 Proxy，由 Proxy 跟 NameServer 进行交互，比如查询 TopicRouteData。代码如下：
public CompletableFuture&lt;QueryRouteResponse&gt; queryRoute(ProxyContext ctx, QueryRouteRequest request) { CompletableFuture&lt;QueryRouteResponse&gt; future = new CompletableFuture&lt;&gt;(); try { //省略部分代码 ProxyTopicRouteData proxyTopicRouteData = this.messagingProcessor.getTopicRouteDataForProxy( ctx, addressList, topicName); List&lt;MessageQueue&gt; messageQueueList = new ArrayList&lt;&gt;(); Map&lt;String, Map&lt;Long, Broker&gt;&gt; brokerMap = buildBrokerMap(proxyTopicRouteData.getBrokerDatas()); TopicMessageType topicMessageType = messagingProcessor." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/21765313e8d7b26685c94d6b6eefa9b9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-11T11:30:56+08:00" />
<meta property="article:modified_time" content="2023-04-11T11:30:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RocketMQ 5.0 时代，6 张图带你理解 Proxy！</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> 大家好，今天来聊一聊 RocketMQ 5.0 中的 Proxy。</p> 
<p>RocketMQ 5.0 为了更好地拥抱云原生，引入了无状态的 Proxy 模块，新的架构图如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2b/75/aynuvptZ_o.png"></p> 
<p>引入 Proxy 模块后，Proxy 承担了协议适配、权限管理、消息管理等计算功能，Broker 则更加专注于存储。这样存储和计算相分离，在云原生环境下可以更好地进行资源调度。</p> 
<h3>1.Proxy 介绍</h3> 
<p>RocketMQ 5.0 把客户端的部分功能下沉到 Proxy，Proxy 承接了之前 客户端的计算能力，客户端变得更加轻量级。</p> 
<h4>1.1 NameServer</h4> 
<p>从上面的架构图可以看到，Producer/Consumer 不再需要注册到 NameServer，这一部分功能下移到了 Proxy，由 Proxy 跟 NameServer 进行交互，比如查询 TopicRouteData。代码如下：</p> 
<pre><code>public CompletableFuture&lt;QueryRouteResponse&gt; queryRoute(ProxyContext ctx, QueryRouteRequest request) {
 CompletableFuture&lt;QueryRouteResponse&gt; future = new CompletableFuture&lt;&gt;();
 try {
  //省略部分代码
  ProxyTopicRouteData proxyTopicRouteData = this.messagingProcessor.getTopicRouteDataForProxy(
   ctx, addressList, topicName);

  List&lt;MessageQueue&gt; messageQueueList = new ArrayList&lt;&gt;();
  Map&lt;String, Map&lt;Long, Broker&gt;&gt; brokerMap = buildBrokerMap(proxyTopicRouteData.getBrokerDatas());

  TopicMessageType topicMessageType = messagingProcessor.getMetadataService().getTopicMessageType(topicName);
  for (QueueData queueData : proxyTopicRouteData.getQueueDatas()) {
   String brokerName = queueData.getBrokerName();
   Map&lt;Long, Broker&gt; brokerIdMap = brokerMap.get(brokerName);
   if (brokerIdMap == null) {
    break;
   }
   for (Broker broker : brokerIdMap.values()) {
    messageQueueList.addAll(this.genMessageQueueFromQueueData(queueData, request.getTopic(), topicMessageType, broker));
   }
  }

  QueryRouteResponse response = QueryRouteResponse.newBuilder()
   .setStatus(ResponseBuilder.getInstance().buildStatus(Code.OK, Code.OK.name()))
   .addAllMessageQueues(messageQueueList)
   .build();
  future.complete(response);
 } catch (Throwable t) {
  future.completeExceptionally(t);
 }
 return future;
}
</code></pre> 
<p>Proxy 适配多种协议，比如 HTTP、gRPC、remoting 等，不同协议的客户端跟 Proxy 建立连接后，Proxy 统一使用 remoting 协议跟 Broker、NameServer 进行通信。</p> 
<h4>1.2 流量控制</h4> 
<p>客户端所有的请求都要经过 Proxy，Proxy 将流量分发到 Broker。这样在 Proxy 可以进行流量控制和流量治理。</p> 
<h4>1.3 POP 模式</h4> 
<p>我们知道，PUSH 消费模式下，Broker 中的每个 MessageQueue 只能被同一个 Consumer Group 中的一个消费者消费，如下图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/09/34/yz0PiWYm_o.png"></p> 
<p>PUSH 模式存在下面几个问题：</p> 
<ol><li> <p>消费者最大数量只能等于 MessageQueue 的数量，消费者数量等于 MessageQueue 的数量后，再增加消费者，也不能提高消费能力了；</p> </li><li> <p>客户端的处理逻辑比较多，比如负载均衡、offset 管理、消费失败后的处理（比如失败消息发送回 Broker）；</p> </li><li> <p>如果一个消费者机器故障，比如上图中 Consumer0 这个消费者 hang 住了，Topic1 下的两个 MessageQueue 就不能被消费了，导致消息积压，最终只能是重启或下线 Consumer0，Consumer 做重平衡；</p> </li><li> <p>客户端很重，如果要用其他语言编写，工作量很大。</p> </li></ol> 
<p>基于 PUSH 模式的不足，RocketMQ 5.0 引入了 POP 消费模式，如下图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3c/82/ytFptIRk_o.png"></p> 
<p>跟 PUSH 模式消费者相比，POP 模式客户端有如下优势：</p> 
<ol><li> <p>POP 模式消费者可以拉取所有的 MessageQueue，这样即使某个消费者 hang 住，也不会影响某一个 MessageQueue 的消费；</p> </li><li> <p>POP 模式消费者不再会重平衡，因为每个消费者默认会去所有的 MessageQueue 拉取消息；</p> </li><li> <p>因为消费者可以拉取所有的 MessageQueue 消息，所以，增加消费者数量，是可以提高消费能力的；</p> </li><li> <p>消费者减少了很多逻辑，变得户端轻量化了，可以方便多语言实现；</p> </li><li> <p>消费者不再维护 offset（offset 由 Broker 维护），变成了无状态组件。</p> </li></ol> 
<p><strong>注意：消费者请求 Proxy 时，POP 模式和 PUSH 模式都可以使用，而 Proxy 请求 Broker 时，使用的是 POP 模式，这样可以避免上面提到的一系列问题。</strong>如下图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/66/c4/m2cSK2Of_o.png"></p> 
<h4>1.4 gRPC</h4> 
<p>Proxy 基于 gRPC 的标准性、兼容性和多语言传输层代码生成能力，可以轻松构建多语言的轻量级客户端。</p> 
<h3>2 部署方式</h3> 
<p>根据不同的场景，Proxy 有两种部署方式，LOCAL 模式和 CLUSTER 模式。</p> 
<h4>2.1 LOCAL 模式</h4> 
<p>RocketMQ 4.x 版本 Client 和 Broker 直接通信，RocketMQ 5.0 引入 Proxy 后，Client 和 Broker 之间的通信多了一道网络，也增加了一次序列化和反序列化的过程，这势必增加了延迟，对于延迟敏感的场景可能不能接受。RocketMQ 5.0 引入了 LOCAL 模式部署 Proxy，如下图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fd/a0/OLpWR0Kz_o.png"></p> 
<p>Proxy 仍然可以适配多种语言的客户端，而且 Proxy 和 Broker 部署在一起，通信方式使用进程内通信，这样可以减少因为多一道网络带来的延迟，提高吞吐量。同时运维也变得简单，运维成本降低。</p> 
<p><strong>LOCAL 模式有一个缺点，因为 Proxy 部署在 Broker 端，受网络环境的限制，对于多网络接入的情况并不友好，成本高。</strong></p> 
<h4>2.2 CLUSTER 模式</h4> 
<p>CLUSTER 模式主要用于对延迟不敏感的场景，Proxy 独立部署，在 Proxy 层适配多网络的接入，同时 Proxy 和 Broker 可以独立扩容，互不影响。如下图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d9/13/ikFyRzxL_o.png"></p> 
<h4>2.3 总结</h4> 
<p>LOCAL 模式更适合对延迟敏感、期望运维成本低、网络接入类型单一的场景。</p> 
<p>CLUSTER 模式更适合对延迟要求低、网络接入类型多样的场景。</p> 
<h3>3 总结</h3> 
<p>RocketMQ 5.0 跟之前的版本相比，改动很大，更加地拥抱云原生。学习 RocketMQ 5.0，首先要理解 Proxy，希望本文能对您理解 Proxy 有所帮助。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1908064477b53749112fd691e308df6d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">opencv笔记（三十一）——Mat 矩阵数据类型转换convertTo</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b66ad1f4e823fe1aef9d866cd0629b94/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;Primer第五版 习题答案 第五章 语句（Statements）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>