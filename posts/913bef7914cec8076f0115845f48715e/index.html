<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>22 操作系统之内存管理 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="22 操作系统之内存管理" />
<meta property="og:description" content="内存是什么–内存相关的基础知识补充 内存由很多小的存储单元组成，每个存储单元对应一个内存地址。
按字节编址和按字编址 如果计算机按字节编址，则一个内存地址对应的存储单元存储一个字节。
如果计算机的字长是32位，则每个内存地址对应的存储单元存储一个字，每个字的大小为32个二进制位。
什么是指令 指令是由操作码和若干参数组成的。
写程序到运行的过程 写源代码文件编译（源代码文件经过编译得到目标模块，目标模块是一系列由机器语言表示的指令集合，每个目标模块都会有独自的逻辑地址空间）链接（链接程序可以将编译得到的一组目标模块进行链接，这一组目标模块经过链接程序的链接可以得到一个完整的装入模块，也叫可执行文件。这个装入模块拥有一组完整的逻辑地址。）装入：完成逻辑地址到物理地址的转换，并由装入程序将装入模块装入内存运行。 装入的三种方式 装入模块在进行装入的时候，有三种方式：绝对装入，静态重定位，动态重定位。
绝对装入；在编译时，直接将逻辑地址转化为绝对地址。在装入的时候，装入程序直接按照装入模块中的绝对地址
进行装入。
静态重定位：又称可重定位式装入。它是在装入的时候才进行逻辑地址和绝对地址之间的转化。静态重定位有一个缺陷，在一个作业进行装入的时候必须为其分配全部的内存空间，否则无法装入。
动态重定位：又称动态运行时装入。它解决了静态重定位的缺陷，只有在程序需要执行的时候才进行装入，并且允许程序在内存中发生移动，这种方式需要一个重定位寄存器的支持。
链接的三种方式 链接的三种方式：静态链接、装入式动态链接、运行时动态链接。
静态链接：在装入前就链接好。
装入时动态链接：在装入的时候，边装入边链接。
运行时动态链接：在程序执行到这个模块的时候，再进行链接。
存储保护 方式1：通过上下限寄存器，进行判断。通过这两个寄存器就可以判断是否越界，然后决定是否允许访问。
方式2：通过重定位寄存器和界地址寄存器。重定位寄存器存储的是存储单元的起始地址，界地址寄存器存储的是最大逻辑地址。通过这两个寄存器就可以判断是否越界，然后决定是否允许访问。
内存管理 内存管理主要包含四个模块：内存的分配和回收、内存空间的扩充（覆盖、交换、虚拟存储技术）、地址转换、存储保护。
内存空间的扩充 在本节主要讲解虚拟内存以外的其他技术，虚拟内存技术将会另起一个章节进行讲解。
覆盖技术和交换技术 覆盖技术 覆盖技术：将程序分为多个段。常用的段常驻内存，不常用的段在需要时调入内存。
常驻内存的段放在固定区，不常用的段放在覆盖区，需要用到时调入内存，不需要的时候换出外存。
运用覆盖技术的话，覆盖结构必须由程序员声明，并且对用户不透明，增加了编程负担。
交换技术 内存空间紧张的时候将程序中的某些进程暂时换出外存，把外存中某些具备运行条件的进程换入内存。
中级调度就是在将某个处于挂起态的进程调入内存。因此中级调度又叫内存调度。
处于就绪状态和阻塞状态的进程都有可能被挂起。当被激活，就会解除挂起状态。
内存空间的分配–连续分配管理方式 内存空间的分配方式，可以分为连续分配和非连续分配管理方式两种。
连续分配管理方式：单一连续分配，固定分区分配，动态分区分配。
单一连续分配 在单一连续分配方式中，内存被分为系统区和用户区。
缺陷：
内存中只能有一道用户程序，用户程序独占整个用户区。存储利用率低。有内部碎片。只能用于单用户单任务的操作系统中。 优点：
实现简单，无外部碎片。可以采用覆盖技术扩充内存。不一定需要内存保护。 固定分区分配 将用户空间划分成若干个固定大小的分区，每个分区中装入一个作业。无外部碎片有内部碎片。
动态分区分配 动态分区分配又称可变分区分配，不会虚线划分内存分区，而是在装入进程的时候，根据进程的大小动态的建立分区，使分区的大小刚好适合进程的需要。
因此系统分区的数目和大小是可变的。
动态分区分配没有内部碎片但是有外部碎片。
动态分区分配算法 常见的四种动态分区分配算法：首次适应算法，最佳适应算法，最坏适应算法，临近适应算法。
首次适应算法 空闲分区以地址递增的方式进行排列，从头到尾寻找合适的分区。
优点：综合看性能最好，算法开销小，回收分区后不需要对空闲分区队列进行重新排序。
最佳适应算法 优先使用空间更小的分区。
空闲分区以容量递增的方式进行排列。
优点：会有很多大分区被保留下来，更能满足大进程的需求。
缺点：会产生很对太小的，难以利用的碎片。并且算法的开销比较大，因为在回收分区后，需要对分区重新排序。
最坏适应算法 优先使用更大的分区。
空闲分区以容量递减的顺序进行排列。
优点：可以防止产生小的，不可用的碎片。
缺点：虽然解决了最佳适应算法的缺点，但是无法保留大分区，对大进程并不友好。
临近适应算法 最坏适应算法其实是由首次适应算法演变过来的，每次从上次查找结束的位置开始查询。
空闲分区以地址递增的方式进行排序，并组成一个循环链表。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/913bef7914cec8076f0115845f48715e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-15T22:26:30+08:00" />
<meta property="article:modified_time" content="2023-04-15T22:26:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">22 操作系统之内存管理</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_1"></a>内存是什么–内存相关的基础知识补充</h3> 
<p>内存由很多小的存储单元组成，每个存储单元对应一个内存地址。</p> 
<h4><a id="_4"></a>按字节编址和按字编址</h4> 
<p>如果计算机按字节编址，则一个内存地址对应的存储单元存储一个字节。<br> 如果计算机的字长是32位，则每个内存地址对应的存储单元存储一个字，每个字的大小为32个二进制位。</p> 
<h4><a id="_9"></a>什么是指令</h4> 
<p>指令是由操作码和若干参数组成的。</p> 
<h4><a id="_12"></a>写程序到运行的过程</h4> 
<ul><li>写源代码文件</li><li>编译（源代码文件经过编译得到目标模块，目标模块是一系列由机器语言表示的指令集合，每个目标模块都会有独自的逻辑地址空间）</li><li>链接（链接程序可以将编译得到的一组目标模块进行链接，这一组目标模块经过链接程序的链接可以得到一个完整的装入模块，也叫可执行文件。这个装入模块拥有一组完整的逻辑地址。）</li><li>装入：完成逻辑地址到物理地址的转换，并由装入程序将装入模块装入内存运行。</li></ul> 
<p><img src="https://images2.imgbox.com/26/25/8hyRjK14_o.png" alt="image.png"></p> 
<h5><a id="_21"></a>装入的三种方式</h5> 
<p>装入模块在进行装入的时候，有三种方式：绝对装入，静态重定位，动态重定位。</p> 
<p>绝对装入；在编译时，直接将逻辑地址转化为绝对地址。在装入的时候，装入程序直接按照装入模块中的绝对地址<br> 进行装入。</p> 
<p>静态重定位：又称可重定位式装入。它是在装入的时候才进行逻辑地址和绝对地址之间的转化。静态重定位有一个缺陷，在一个作业进行装入的时候必须为其分配全部的内存空间，否则无法装入。</p> 
<p>动态重定位：又称动态运行时装入。它解决了静态重定位的缺陷，只有在程序需要执行的时候才进行装入，并且允许程序在内存中发生移动，这种方式需要一个重定位寄存器的支持。</p> 
<p><img src="https://images2.imgbox.com/36/87/mq96cD19_o.png" alt="image.png"></p> 
<h5><a id="_35"></a>链接的三种方式</h5> 
<p>链接的三种方式：静态链接、装入式动态链接、运行时动态链接。<br> 静态链接：在装入前就链接好。</p> 
<p>装入时动态链接：在装入的时候，边装入边链接。</p> 
<p>运行时动态链接：在程序执行到这个模块的时候，再进行链接。</p> 
<p><img src="https://images2.imgbox.com/cf/ab/ESkY0BKa_o.png" alt="image.png"></p> 
<h5><a id="_45"></a>存储保护</h5> 
<p>方式1：通过上下限寄存器，进行判断。通过这两个寄存器就可以判断是否越界，然后决定是否允许访问。</p> 
<p><img src="https://images2.imgbox.com/59/93/PLXUO3HT_o.png" alt="image.png"></p> 
<p><img src="https://images2.imgbox.com/f7/8b/WvmXepTy_o.png" alt="image.png"><br> 方式2：通过重定位寄存器和界地址寄存器。重定位寄存器存储的是存储单元的起始地址，界地址寄存器存储的是最大逻辑地址。通过这两个寄存器就可以判断是否越界，然后决定是否允许访问。</p> 
<p><img src="https://images2.imgbox.com/75/2c/brIpijhJ_o.png" alt="image.png"></p> 
<p><img src="https://images2.imgbox.com/f5/9b/8cRyRsN9_o.png" alt="image.png"></p> 
<h3><a id="_57"></a>内存管理</h3> 
<p>内存管理主要包含四个模块：内存的分配和回收、内存空间的扩充（覆盖、交换、虚拟存储技术）、地址转换、存储保护。</p> 
<p><img src="https://images2.imgbox.com/e7/8b/w2BZqNkB_o.png" alt="image.png"></p> 
<h3><a id="_63"></a>内存空间的扩充</h3> 
<p>在本节主要讲解虚拟内存以外的其他技术，虚拟内存技术将会另起一个章节进行讲解。</p> 
<h4><a id="_66"></a>覆盖技术和交换技术</h4> 
<h5><a id="_67"></a>覆盖技术</h5> 
<p>覆盖技术：将程序分为多个段。常用的段常驻内存，不常用的段在需要时调入内存。</p> 
<p>常驻内存的段放在固定区，不常用的段放在覆盖区，需要用到时调入内存，不需要的时候换出外存。</p> 
<p><img src="https://images2.imgbox.com/a2/99/hG4JoYmI_o.png" alt="image.png"></p> 
<p>运用覆盖技术的话，覆盖结构必须由程序员声明，并且对用户不透明，增加了编程负担。</p> 
<h5><a id="_75"></a>交换技术</h5> 
<p>内存空间紧张的时候将程序中的某些进程暂时换出外存，把外存中某些具备运行条件的进程换入内存。</p> 
<p>中级调度就是在将某个处于挂起态的进程调入内存。因此中级调度又叫内存调度。</p> 
<p>处于就绪状态和阻塞状态的进程都有可能被挂起。当被激活，就会解除挂起状态。</p> 
<p><img src="https://images2.imgbox.com/ac/d8/ThhNUMwE_o.png" alt="image.png"></p> 
<h3><a id="_85"></a>内存空间的分配–连续分配管理方式</h3> 
<p>内存空间的分配方式，可以分为连续分配和非连续分配管理方式两种。</p> 
<p>连续分配管理方式：单一连续分配，固定分区分配，动态分区分配。</p> 
<h4><a id="_92"></a>单一连续分配</h4> 
<p>在单一连续分配方式中，内存被分为系统区和用户区。</p> 
<p>缺陷：</p> 
<ol><li>内存中只能有一道用户程序，用户程序独占整个用户区。存储利用率低。</li><li>有内部碎片。</li><li>只能用于单用户单任务的操作系统中。</li></ol> 
<p>优点：</p> 
<ol><li>实现简单，无外部碎片。</li><li>可以采用覆盖技术扩充内存。</li><li>不一定需要内存保护。</li></ol> 
<p><img src="https://images2.imgbox.com/04/e0/WnzrVoI9_o.png" alt="image.png"></p> 
<h4><a id="_109"></a>固定分区分配</h4> 
<p>将用户空间划分成若干个固定大小的分区，每个分区中装入一个作业。无外部碎片有内部碎片。<br> <img src="https://images2.imgbox.com/e9/20/zKyk0Plh_o.png" alt="image.png"></p> 
<h4><a id="_113"></a>动态分区分配</h4> 
<p>动态分区分配又称可变分区分配，不会虚线划分内存分区，而是在装入进程的时候，根据进程的大小动态的建立分区，使分区的大小刚好适合进程的需要。</p> 
<p>因此系统分区的数目和大小是可变的。</p> 
<p>动态分区分配没有内部碎片但是有外部碎片。</p> 
<p><img src="https://images2.imgbox.com/57/ea/qxSMi8Cu_o.png" alt="image.png"></p> 
<h5><a id="_123"></a>动态分区分配算法</h5> 
<p>常见的四种动态分区分配算法：首次适应算法，最佳适应算法，最坏适应算法，临近适应算法。</p> 
<h6><a id="_127"></a>首次适应算法</h6> 
<p>空闲分区以地址递增的方式进行排列，从头到尾寻找合适的分区。<br> 优点：综合看性能最好，算法开销小，回收分区后不需要对空闲分区队列进行重新排序。</p> 
<h6><a id="_131"></a>最佳适应算法</h6> 
<p>优先使用空间更小的分区。<br> 空闲分区以容量递增的方式进行排列。<br> 优点：会有很多大分区被保留下来，更能满足大进程的需求。<br> 缺点：会产生很对太小的，难以利用的碎片。并且算法的开销比较大，因为在回收分区后，需要对分区重新排序。</p> 
<h6><a id="_137"></a>最坏适应算法</h6> 
<p>优先使用更大的分区。<br> 空闲分区以容量递减的顺序进行排列。<br> 优点：可以防止产生小的，不可用的碎片。<br> 缺点：虽然解决了最佳适应算法的缺点，但是无法保留大分区，对大进程并不友好。</p> 
<h6><a id="_143"></a>临近适应算法</h6> 
<p>最坏适应算法其实是由首次适应算法演变过来的，每次从上次查找结束的位置开始查询。<br> 空闲分区以地址递增的方式进行排序，并组成一个循环链表。<br> 优点：不用每次都从最低的地址开始检索。算法开销小。<br> 缺点：高地址的大分区也会被用完。</p> 
<h3><a id="_149"></a>内存空间的分配–离散分配管理方式</h3> 
<p>如果允许将一个进程分散地装入许多不相邻的分区中，便可充分的利用内存，苏旭在进行“紧凑”处理。</p> 
<p>基于这一思想提出了离散分配管理方式。</p> 
<p>离散分配管理方式主要有：分页存储管理、分段存储管理、段页式存储管理三种。</p> 
<h4><a id="_156"></a>分页存储管理</h4> 
<p>把进程分页，进程的各个页面可以离散的分散到各个内存块中。</p> 
<p>分页存储管理方式是如何实现的：逻辑地址经过地址转换，得到页号和页内偏移量。根据页号查询页表（页表由页号和内存块号组成），找到最终需要访问的内存块。</p> 
<p>需要注意：页表中的每个页表项的长度相同，页号是隐含的。分页管理方式中，地址是一维的。</p> 
<p><img src="https://images2.imgbox.com/ec/42/93T5Pf5M_o.png" alt="image.png"></p> 
<h5><a id="__166"></a>单级页表存在的问题 如何解决？</h5> 
<p>单级页表存在的问题：<br> 1.页表必须用一块连续的内存空间来进行存放。当页表很大的时候需要占用很多连续的页框，造成内存的浪费。<br> 2.没有必要让整个巨大的页表持续的占用内存，这样会造成性能的浪费。</p> 
<p>因此可以采用多级页表来解决这个问题。<br> 我们这里以两级页表为例进行介绍：腰围离散的页表再建立一层页表，这层页表叫做页目录表，外层页表或者顶层页表。</p> 
<p>一级页表的地址结构由两部分组成：页号和页内偏移量。</p> 
<p>二级页表的地址结构由三部分组成：一级页号，二级页号，页内偏移量。</p> 
<p><img src="https://images2.imgbox.com/4d/c5/PwZq3hWq_o.png" alt="image.png"><br> 以下图为例：<br> 将一个巨大的页表拆分成1024个小页表。这样我们在对某个地址进行访问时，首先需要根据一级页号查询顶级页表，根据顶级页表中的内存块号，查询该内存块，得到二级页表，二级页表在此时触发缺页中断，并将其被加载到内存中（如果采用虚拟存储技术，会在该页表项上加一个标志位，表示该页表目前是否处于内存总，如果已经在内存中，则无需再将该页表调入内存）。再根据二级页号查询二级页表，对查询到的内存块号进行访问。</p> 
<p><img src="https://images2.imgbox.com/c5/f5/Uc13amcl_o.png" alt="image.png"></p> 
<p>注意：在分也是存储管理中，各级也标的大小不能超过一个页面。</p> 
<h4><a id="_188"></a>分段存储管理</h4> 
<p>在分段存储管理中：一个程序按逻辑结构可以分为多个段。</p> 
<p><img src="https://images2.imgbox.com/ca/da/QwIVhSph_o.png" alt="image.png"></p> 
<p>逻辑地址结构是由段号和段内地址组成。<br> 实现逻辑：首先，通过逻辑地址，得到段号和段内地址，检查段号是否越界。然后去查询段表，得到该段号对应的基址和段长，并通过段长检查段内地址是否合法。在段表中，因为每个段表项的大小都是固定的，因此段号是隐含的，并不占存储空间。</p> 
<p>分段存储的优点，更容易实现信息的共享和保护。</p> 
<h4><a id="_200"></a>段页式存储管理</h4> 
<p>为什么要有段页式存储？</p> 
<p>因为页式存储和段式存储各有优缺点：</p> 
<p><img src="https://images2.imgbox.com/e3/6f/y7wiVea1_o.png" alt="image.png"></p> 
<p>段页式存储实现流程：<br> 首先逻辑地址构成为段号加页号加页内地址。</p> 
<p>段表中存储：段号、页表存放块号、页表长度。</p> 
<p>页表中存放：页号、内存块号。</p> 
<p>首先，操作系统会根据逻辑地址，判断段号是否合法，然后查询段表，根据段表中的信息，得到存储页表的块内地址、页表长度，从而得到页表。然后判断页号的合法性，如果合法，则根据页内地址和内存块号的访问目标存储单元。整个过程需要三次访存。</p> 
<p>注意：分段对用户来说是可见的，而分页对用户来说是不可见的。如果引入快表结构，则在快表命中的时候只需要一次访存。</p> 
<p><img src="https://images2.imgbox.com/e1/19/2aWNtf6L_o.png" alt="image.png"></p> 
<h3><a id="_221"></a>交换技术和虚拟存储技术有什么区别</h3> 
<p>操作系统的交换技术和虚拟存储技术都是为了扩充内存的容量，但是它们有一些区别：</p> 
<p>交换技术是在不同的进程（作业）间进行的，当内存紧张时，可以把暂时不能执行的进程换出到外存，腾出内存空间，再把需要执行的进程换入到内存。<br> 虚拟存储技术是在一个进程（作业）内部进行的，当一个进程的大小超过了内存的容量时，可以把进程分成若干个页或段，只把当前需要用到的页或段装入到内存，其他的页或段放在外存，从而实现逻辑上的内存扩充。<br> 举个例子，玩游戏时，虚拟存储技术可以让我们只把当前场景的数据加载到内存，而不需要把整个游戏的数据都放在内存里。而交换技术可以让我们在后台运行多个程序，当我们切换程序时，可以把不用的程序换出到外存，再把要用的程序换入到内存。</p> 
<h6><a id="___227"></a>何时被换出 换出到哪里 应该换出哪些进程</h6> 
<h6><a id="_229"></a>何时被换出</h6> 
<p>当操作系统的缺页率高的时候，就会换出一些进程。当缺页率明显降低，则停止换出。</p> 
<h6><a id="_232"></a>换出到哪里</h6> 
<p>外存分为文件区和对换区。文件区属于离散分配，访问的时候属于随机IO，注重空间利用率。对换区是连续分配，在访问的时候属于连续IO，注重效率。</p> 
<p>因此当换出的时候，会被换出到对换区。</p> 
<h6><a id="_236"></a>应该换出哪些进程</h6> 
<p>可以换出优先级低的进程，也可以优先换出阻塞进程，因为需要防止出现内存抖动现象（刚换入内存的进程被快速换出）操作系统会考虑进程的驻留时间。</p> 
<h3><a id="_238"></a>为什么要有虚拟内存？</h3> 
<p>传统存储管理方式存在一些缺点：尤其是<strong>一次性</strong>和<strong>驻留性</strong>。</p> 
<p>一次性是指：作业数据必须一次全部调入内存中。<br> 驻留性是指：作业数据在整个运行期间都会常驻内存。</p> 
<h4><a id="_244"></a>如何改善传统的存储管理方式的缺点？</h4> 
<p>虚拟内存技术是基于局部性原理提出的，要改善传统存储方式的缺点首先要了解<strong>局部性原理</strong>。</p> 
<p>局部性原理：包含时间局部性、空间局部性、顺序局部性。</p> 
<p>时间局部性：如果一个信息项正在被访问，那么在近期还有可能被访问。</p> 
<p>空间局部性：如果一个信息正在被访问，那么将来被访问的信息项在空间地址上很可能和它是临近的。</p> 
<p>顺序局部性：大部分指令都是顺序执行的。顺序执行和非顺序执行的比例大致是5比1。</p> 
<p>指令的顺序执行和数组的连续存放是产生顺序局部性的原因。</p> 
<h3><a id="_258"></a>虚拟内存的定义和特征</h3> 
<h4><a id="_259"></a>虚拟内存的定义</h4> 
<p>定义：程序不需要完全装入即可运行，运行时根据需要动态装入，若内存不够，还需要换出一些数据。</p> 
<p>特征：多次性、对换性、虚拟性</p> 
<h3><a id="_264"></a>如何实现虚拟内存技术：</h3> 
<p>访问的信息不存在于内存中时，由操作系统将所需要的信息从外存调入内存（请求调页）。<br> 当内存空间不够的时候，将内存中暂时用不到的信息换入到外存。（页面置换）</p> 
<p>虚拟内存的实现：依赖于请求分页、请求分段和请求段页式存储管理技术。</p> 
<h3><a id="_271"></a>请求分页、请求分段和请求段页式存储管理技术</h3> 
<h4><a id="_272"></a>请求分页存储管理技术</h4> 
<p>下图为请求分页存储管理技术的页表：</p> 
<p><img src="https://images2.imgbox.com/50/0f/jXzrIi79_o.png" alt="image.png"></p> 
<p>它比普通的分页存储的页表多了四个字段：<strong>状态位、访问字段、修改位、外存地址</strong>。并且引入了缺页中断机构。</p> 
<p>举个例子，需要访问一个地址，我们根据逻辑地址来计算出它所对应的页号，判断页号是否越界，如果页号是合法的，那么接下来我们需要查询快表，如果快表没有命中，则需要查询页表（慢表）。在查询页表时，首先查询状态位，通过状态位得知该页号是否已经在内存中，如果不在内存中则触发缺页中断机构，将当前缺页的进程阻塞，放入阻塞队列，进行调页，调页完成后再将其唤醒，再放入就绪队列。</p> 
<p>在调页的时候，如果内存中有空闲块，则将所缺页面装入空闲块。如果没有空闲块，则依据访问字段的值（访问字段可以在一定程度上表明该页面的访问频率）通过页面置换算法淘汰掉一个页面，放入外存。如果通过修改位得知，被淘汰的页面在内存中发生过修改，则需要根据外存地址将其重新写入外存。未被修改过的页面在被页面置换算法淘汰时，无需写回外存。页面被调入回内存后，需要将该页面写入快表中。<br> <strong>注：缺页中断是由于当前执行的指令产生的，因此属于内中断。</strong></p> 
<p><img src="https://images2.imgbox.com/47/3d/fImHIapG_o.png" alt="image.png"></p> 
<h4><a id="_286"></a>常见的页面置换算法</h4> 
<h5><a id="OPT_287"></a>OPT算法</h5> 
<p>OPT（optimal）算法，又称最佳置换算法，预知接下来的一个时间段内访问频率最低的那个页面，并将其淘汰，这种算法性能好，但是无法实现。</p> 
<h5><a id="FIFO_290"></a>FIFO先进先出算法</h5> 
<p>先进先出算法，根据页面进入内存的先后顺序，淘汰最早进入内存的页面。<br> 因为在淘汰的时候完全不考虑内存中页面的使用频率，也就导致，增加内存块的数量并不一定增加命中率，故存在贝拉迪异常。</p> 
<h5><a id="LRULeast_Recently_Used_294"></a>LRU算法（Least Recently Used）最近最少使用算法</h5> 
<p>淘汰掉最近的一个时间段内使用频率最低的那个页面，留下最近访问频率最高的页面。<br> 算法简单，性能也不错。</p> 
<h5><a id="ClockNRU_Not_Recently_Used_300"></a>Clock算法（NRU Not Recently Used算法）也叫循环扫描算法</h5> 
<p>访问位为1代表最近访问过，访问位位0代表最近未访问过。</p> 
<p>对访问位进行循环扫描，并判断是否为0，如果为1则置0，对最先扫描到的访问位为0的页面进行淘汰。</p> 
<p>若在第一轮扫描中未扫描出访问位为0的页面，则在第二轮中进行淘汰。</p> 
<h5><a id="Clock_308"></a>改进后的Clock算法</h5> 
<p>考虑到了修改位，淘汰规则如下：</p> 
<p><img src="https://images2.imgbox.com/ce/cf/ckzt8qms_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/d9/0b/y4F6jQxW_o.png" alt="image.png"></p> 
<h3><a id="_316"></a>页面分配和置换策略</h3> 
<p>页面分配有固定分配和可变分配两种：</p> 
<ul><li>固定分配是指，进程运行前操作系统会为进程<strong>分配固定数量的内存块</strong>。</li><li>可变分配是指，进程运行时所占用的<strong>内存块数量是可以随时进行调整</strong>的。</li></ul> 
<p>置换策略有局部置换和全局置换两种：</p> 
<ul><li>局部置换是指，当进程在运行发生缺页时，<strong>只能从该进程的内存中选出一页换出</strong>。</li><li>全局置换是指，当进程在运行发生缺页时，可以获取<strong>操作系统的空闲块</strong>或获取<strong>其他进程内存中换出外存所得的空闲块</strong>。</li></ul> 
<p>常用的页面分配与置换策略有三种：固定分配局部替换，可变分配全局替换，可变分配局部替换。</p> 
<p>固定分配局部替换：首先，一个进程在运行时所占用的内存块数量是固定的。其次，当发生缺页时只能在该进程的内存的页面中选出一页进行换出。</p> 
<p>可变分配全局替换：刚开始会为每个进程分配一定数量的内存块，这个数量在后续的操作中是可变的。操作系统会维护一个空闲块队列，当前进程发生缺页的时候，若还有空闲块，则会从空闲块中取出一块分配给该进程。若已经没有空闲块，则从其他进程的内存中选择一个未锁定的页面通过页面置换算法换出外存。这种方法会导致被选中的进程的物理块会减少，缺页率会增加。</p> 
<p>可变分配局部置换：刚开始会为每个进程分配一定数量的内存块，这个数量在后续是可变的。当前进程发生缺页的时候，只允许从该进程自己的内存块中通过页面置换算法选出一个页面换入外存中。这种方式的优点在于，可以通过该进程缺页率的大小，来动态的调整该进程的内存块数量。当这个进程频繁缺页，缺页率特别高，则应该适当增加为该进程分配的内存块数量。当这个进程几乎不会发生缺页，则应该适当降低其所占用的内存块数量。</p> 
<h4><a id="_337"></a>何时调入页面</h4> 
<p>常见的调用时机有两种，预调页和请求调页。</p> 
<p>请求调页：当发生缺页的时候，才将所缺页面调入内存。这种策略调入的页面一定会被访问到，但是每次只能调入一页，每次调入都需要IO操作，会导致频繁IO。</p> 
<p>预调页：根据局部性原理可知，如果一个页面被被访问，那么与之相邻的页面也有很大的几率被访问，将相邻的页面预先调入内存，这样可以减少IO次数，防止出现频繁IO。但是目前预测的成功率在百分之50左右，故这种策略目前多用于首次调入。</p> 
<h4><a id="_345"></a>从何处调入</h4> 
<p><img src="https://images2.imgbox.com/50/9c/27wm3Xir_o.png" alt="image.png"><br> 外存分为对换区和文件区。文件区采用离散分配的方式，对换区采用连续分配的方式，速度更快。</p> 
<p>UNIX在运行前，将文件进程相关的数据全部放在文件区，故未使用过的页面都可以从文件区调入。若被使用过的页面需要换出，则换出到对换区。</p> 
<h4><a id="_352"></a>如何解决颠簸现象？</h4> 
<p>颠簸是指：</p> 
<p><img src="https://images2.imgbox.com/a0/09/0aJeppDp_o.png" alt="image.png"></p> 
<p>驻留集的大小小于工作集的大小，则很容易出现颠簸。故应该增加驻留集的大小，至少要大于等于工作集。<br> <img src="https://images2.imgbox.com/5f/a3/L3KBoAbB_o.png" alt="image.png"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2234e31a9950ee4bacd26081114670dc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">信捷PLC 批量传送位 MOV DMOV QMOV</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/13b91ab761c4f1c0182b51d89c770ad5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">23 DMA与零拷贝技术</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>