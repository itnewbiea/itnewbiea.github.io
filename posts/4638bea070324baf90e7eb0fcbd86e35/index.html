<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>实验五 二叉树的建立及遍历应用 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="实验五 二叉树的建立及遍历应用" />
<meta property="og:description" content="一、【实验目的】
1、掌握二叉树的建立方法
2、掌握二叉树遍历的基本方法（先序、中序、后序）
3、掌握递归二叉树遍历算法的应用
二、【实验内容】
1.构造一棵二叉树,打印出先序遍历、中序遍历、后序遍历的遍历序列。
2.选择一种遍历方式计算该树中叶子结点的个数，并打印出叶子结点。
提示:
先根据给定的树，写出此树的扩展先序遍历序列，然后根据此遍历序列建立二叉树。
3.选作题:编写一个层序遍历算法，利用队列结构按层次（同一层自左至右）输出二叉树中所有的结点。
三、【实验源代码】
头文件 typedef struct LBinaryTreeNode { ElemType data; struct LBinaryTreeNode *lchild; struct LBinaryTreeNode *rchild; }LPBTreeNode; void Initiate(LPBTreeNode *p) /*初始化创建二叉树的头结点*/ { p=(LPBTreeNode *)malloc(sizeof(LPBTreeNode)); p-&gt;lchild =NULL; p-&gt;rchild=NULL; } LPBTreeNode *createbintree() { LPBTreeNode *pbnode; char ch; scanf(&#34;%c&#34;,&amp;ch); if(ch==&#39;#&#39;)pbnode=NULL; else { pbnode=(LPBTreeNode *)malloc(sizeof(LPBTreeNode)); if(pbnode==NULL) { printf(&#34;out of space!\n&#34;); return pbnode; } pbnode-&gt;data =ch; pbnode-&gt;lchild =createbintree(); pbnode-&gt;rchild =createbintree(); } return pbnode; } void preorder(LPBTreeNode *t) { if(t==NULL)return; printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4638bea070324baf90e7eb0fcbd86e35/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-09T21:37:03+08:00" />
<meta property="article:modified_time" content="2023-06-09T21:37:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">实验五 二叉树的建立及遍历应用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#333333;">一、【实验目的】</span></span><br><span style="background-color:#ffffff;"><span style="color:#333333;">1、掌握二叉树的建立方法</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#333333;">2、掌握二叉树遍历的基本方法（先序、中序、后序）</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#333333;">3、掌握递归二叉树遍历算法的应用</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#333333;">二、【实验内容】</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#333333;">1.构造一棵二叉树,打印出先序遍历、中序遍历、后序遍历的遍历序列。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#333333;">2.选择一种遍历方式计算该树中叶子结点的个数，并打印出叶子结点。</span></span></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="background-color:#ffffff;"><span style="color:#ff0000;">提示:</span></span></strong></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="background-color:#ffffff;"><span style="color:#ff0000;">先根据给定的树，写出此树的扩展先序遍历序列，然后根据此遍历序列建立二叉树。</span></span></strong></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#333333;">3.选作题:编写一个层序遍历算法，利用队列结构按层次（同一层自左至右）输出二叉树中所有的结点。</span></span></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="background-color:#ffffff;"><span style="color:#ff0000;"> </span></span></strong></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#333333;">三、【实验源代码】</span></span></p> 
<pre><code class="language-cpp">头文件
typedef struct LBinaryTreeNode
{
	ElemType data;
	struct  LBinaryTreeNode *lchild;
	struct  LBinaryTreeNode *rchild;
}LPBTreeNode;
void Initiate(LPBTreeNode *p)  /*初始化创建二叉树的头结点*/
{
	p=(LPBTreeNode *)malloc(sizeof(LPBTreeNode));
	p-&gt;lchild =NULL;
	p-&gt;rchild=NULL;
	
}
LPBTreeNode *createbintree()
{
	LPBTreeNode *pbnode;
	char ch;
	scanf("%c",&amp;ch);
	if(ch=='#')pbnode=NULL;
	else
	{
		pbnode=(LPBTreeNode *)malloc(sizeof(LPBTreeNode));
		if(pbnode==NULL)
		{
			printf("out of space!\n");
			return pbnode;
		}
		pbnode-&gt;data =ch;
		pbnode-&gt;lchild =createbintree();
		pbnode-&gt;rchild =createbintree();
	}
	return pbnode;
}

void preorder(LPBTreeNode *t)
{
	if(t==NULL)return;
	printf("%c",t-&gt;data);
	preorder(t-&gt;lchild );
	preorder(t-&gt;rchild );
}
void inorder(LPBTreeNode *t)
{
	if(t==NULL)return ;
	inorder(t-&gt;lchild );
	printf("%c",t-&gt;data);
	inorder(t-&gt;rchild );
}
void postorder(LPBTreeNode *t)
{
	if(t==NULL)return ;
	postorder(t-&gt;lchild );
	postorder(t-&gt;rchild );
	printf("%c",t-&gt;data);
}
void leaf(LPBTreeNode *p)
{
	if(p!=NULL)
	{
		if((p-&gt;lchild==NULL)&amp;&amp;(p-&gt;rchild ==NULL))
		printf("%c",p-&gt;data);
		leaf(p-&gt;lchild );
		leaf(p-&gt;rchild );
	}
}

主函数
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
typedef  char ElemType;
#include"LBinaryTreeNode.h"

int main()
{
	LPBTreeNode *p; 
	Initiate(p);
	if(p!=NULL)
	{
	   p=createbintree();
    }
	printf("先序遍历:\n");
	preorder(p);
	printf("\n中序遍历:\n");
	inorder(p);
	printf("\n后序遍历:\n");
	postorder(p);
    printf("\n打印叶子节点:\n");
	leaf(p);
    return 0;
}
选做题
头文件
typedef struct Node
{
    char data;
    struct Node *LChild, *RChild;
}BiNode, *BiTree;

typedef struct
{
    BiTree data[QueueMax];
    int head;
    int rear;
    int len;
}Queue;
BiTree CreateTree()
{  //建立二叉树
    char c;
    scanf("%c",&amp;c);
    BiTree T;
    if (c == '#') {
        return NULL;
    }
    T = (BiTree) malloc (sizeof(BiNode));
    T-&gt;data = c;
    T-&gt;LChild = CreateTree();
    T-&gt;RChild = CreateTree();
    return T;
}

Queue InitQueue()
{  //初始化队列
    Queue seq;
    int i; 
    for( i = 0; i &lt; QueueMax; i++) 
	{
        seq.data[i] = NULL;
    }
    seq.head = 0;
    seq.rear = -1;
    seq.len = 0;
    return seq;
}

int IsEmptyQueue(Queue seq)
{  //队列判空
    if (seq.len == 0) {
        return 1;
    }
    return 0;
}

int IsFullQueue(Queue seq)
{  //队列判满
    if (seq.len == QueueMax) {
        return 1;
    }
    return 0;
}

void PushQueue(Queue *seq, BiTree T)
{  //入队
    if (IsFullQueue(*seq)) {
        printf("ErrorFull");
        return;
    }
    seq-&gt;rear = (seq-&gt;rear + 1) % QueueMax;
    seq-&gt;len++;
    seq-&gt;data[seq-&gt;rear] = T;
}

void PopQueue(Queue *seq, BiTree *T)
{  //出队
    if (IsEmptyQueue(*seq)) {
        printf("ErrorEmpty");
        return;
    }
    seq-&gt;head = (seq-&gt;head + 1) % QueueMax;
    *T = seq-&gt;data[seq-&gt;head];
    seq-&gt;len--;
}

void LayerOrder(BiTree T)
{  //层序遍历
    Queue seq;
    seq = InitQueue();
    BiTree tmp;
    tmp = T;
    PushQueue(&amp;seq, tmp);
    while(!IsEmptyQueue(seq)) {
        printf("%c", tmp-&gt;data);
        if (tmp-&gt;LChild != NULL) {
            PushQueue(&amp;seq, tmp-&gt;LChild);
        }
        if (tmp-&gt;RChild != NULL) {
            PushQueue(&amp;seq, tmp-&gt;RChild);
        }
        PopQueue(&amp;seq, &amp;tmp);
    }
}

主函数
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define QueueMax 100
#include"Tree.h"
int main()
{
    BiTree T;
    T = CreateTree();
    printf("层序遍历：\n");
    LayerOrder(T);
    return 0;
}
</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d2b76bd7412b3b9a25f3a5a49a5f2f35/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C语言】关键字</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7c11f65254e5d9c62371abbe5fe7eb1b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ES文档字段类型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>