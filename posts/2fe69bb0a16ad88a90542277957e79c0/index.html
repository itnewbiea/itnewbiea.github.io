<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CountDownLatch、CyclicBarrier和Semaphore - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CountDownLatch、CyclicBarrier和Semaphore" />
<meta property="og:description" content="在java 1.5中，提供了一些非常有用的辅助类来帮助我们进行并发编程，比如CountDownLatch，CyclicBarrier和Semaphore，今天我们就来学习一下这三个辅助类的用法。
以下是本文目录大纲：
一.CountDownLatch用法
二.CyclicBarrier用法
三.Semaphore用法
一.CountDownLatch用法 CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。
CountDownLatch类只提供了一个构造器：
1
public CountDownLatch(int count) { }; //参数count为计数值
然后下面这3个方法是CountDownLatch类中最重要的方法：
1
2
3
public void await() throws InterruptedException { }; //调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行
public boolean await(long timeout, TimeUnit unit) throws InterruptedException { }; //和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行
public void countDown() { }; //将count值减1
下面看一个例子大家就清楚CountDownLatch的用法了：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2fe69bb0a16ad88a90542277957e79c0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-10T17:14:47+08:00" />
<meta property="article:modified_time" content="2020-08-10T17:14:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CountDownLatch、CyclicBarrier和Semaphore</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>　在java 1.5中，提供了一些非常有用的辅助类来帮助我们进行并发编程，比如CountDownLatch，CyclicBarrier和Semaphore，今天我们就来学习一下这三个辅助类的用法。</p> 
<p>　　以下是本文目录大纲：</p> 
<p>　　一.CountDownLatch用法</p> 
<p>　　二.CyclicBarrier用法</p> 
<p>　　三.Semaphore用法</p> 
<h3>一.CountDownLatch用法</h3> 
<p>　　CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。</p> 
<p>　　CountDownLatch类只提供了一个构造器：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p><code>public</code> <code>CountDownLatch(</code><code>int</code> <code>count) {  };  </code><code>//参数count为计数值</code></p> </td></tr></tbody></table> 
<p> 　　然后下面这3个方法是CountDownLatch类中最重要的方法：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> </td><td> <p><code>public</code> <code>void</code> <code>await() </code><code>throws</code> <code>InterruptedException { };   </code><code>//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</code></p> <p><code>public</code> <code>boolean</code> <code>await(</code><code>long</code> <code>timeout, TimeUnit unit) </code><code>throws</code> <code>InterruptedException { };  </code><code>//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</code></p> <p><code>public</code> <code>void</code> <code>countDown() { };  </code><code>//将count值减1</code></p> </td></tr></tbody></table> 
<p> 　　下面看一个例子大家就清楚CountDownLatch的用法了：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> <p>36</p> <p>37</p> <p>38</p> <p>39</p> <p>40</p> </td><td> <p><code>public</code> <code>class</code> <code>Test {<!-- --></code></p> <p><code>     </code><code>public</code> <code>static</code> <code>void</code> <code>main(String[] args) {   </code></p> <p><code>         </code><code>final</code> <code>CountDownLatch latch = </code><code>new</code> <code>CountDownLatch(</code><code>2</code><code>);</code></p> <p><code>         </code> </p> <p><code>         </code><code>new</code> <code>Thread(){<!-- --></code></p> <p><code>             </code><code>public</code> <code>void</code> <code>run() {<!-- --></code></p> <p><code>                 </code><code>try</code> <code>{<!-- --></code></p> <p><code>                     </code><code>System.out.println(</code><code>"子线程"</code><code>+Thread.currentThread().getName()+</code><code>"正在执行"</code><code>);</code></p> <p><code>                    </code><code>Thread.sleep(</code><code>3000</code><code>);</code></p> <p><code>                    </code><code>System.out.println(</code><code>"子线程"</code><code>+Thread.currentThread().getName()+</code><code>"执行完毕"</code><code>);</code></p> <p><code>                    </code><code>latch.countDown();</code></p> <p><code>                </code><code>} </code><code>catch</code> <code>(InterruptedException e) {<!-- --></code></p> <p><code>                    </code><code>e.printStackTrace();</code></p> <p><code>                </code><code>}</code></p> <p><code>             </code><code>};</code></p> <p><code>         </code><code>}.start();</code></p> <p><code>         </code> </p> <p><code>         </code><code>new</code> <code>Thread(){<!-- --></code></p> <p><code>             </code><code>public</code> <code>void</code> <code>run() {<!-- --></code></p> <p><code>                 </code><code>try</code> <code>{<!-- --></code></p> <p><code>                     </code><code>System.out.println(</code><code>"子线程"</code><code>+Thread.currentThread().getName()+</code><code>"正在执行"</code><code>);</code></p> <p><code>                     </code><code>Thread.sleep(</code><code>3000</code><code>);</code></p> <p><code>                     </code><code>System.out.println(</code><code>"子线程"</code><code>+Thread.currentThread().getName()+</code><code>"执行完毕"</code><code>);</code></p> <p><code>                     </code><code>latch.countDown();</code></p> <p><code>                </code><code>} </code><code>catch</code> <code>(InterruptedException e) {<!-- --></code></p> <p><code>                    </code><code>e.printStackTrace();</code></p> <p><code>                </code><code>}</code></p> <p><code>             </code><code>};</code></p> <p><code>         </code><code>}.start();</code></p> <p><code>         </code> </p> <p><code>         </code><code>try</code> <code>{<!-- --></code></p> <p><code>             </code><code>System.out.println(</code><code>"等待2个子线程执行完毕..."</code><code>);</code></p> <p><code>            </code><code>latch.await();</code></p> <p><code>            </code><code>System.out.println(</code><code>"2个子线程已经执行完毕"</code><code>);</code></p> <p><code>            </code><code>System.out.println(</code><code>"继续执行主线程"</code><code>);</code></p> <p><code>        </code><code>} </code><code>catch</code> <code>(InterruptedException e) {<!-- --></code></p> <p><code>            </code><code>e.printStackTrace();</code></p> <p><code>        </code><code>}</code></p> <p><code>     </code><code>}</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>执行结果：</p> 
<p><img alt="" height="189" src="https://images2.imgbox.com/ff/73/JpJAu98Z_o.png" width="425"></p> 
<h3>二.CyclicBarrier用法</h3> 
<p>　　字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。</p> 
<p>　　CyclicBarrier类位于java.util.concurrent包下，CyclicBarrier提供2个构造器：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> </td><td> <p><code>public</code> <code>CyclicBarrier(</code><code>int</code> <code>parties, Runnable barrierAction) {<!-- --></code></p> <p><code>}</code></p> <p> </p> <p><code>public</code> <code>CyclicBarrier(</code><code>int</code> <code>parties) {<!-- --></code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>　　参数parties指让多少个线程或者任务等待至barrier状态；参数barrierAction为当这些线程都达到barrier状态时会执行的内容。</p> 
<p>　　然后CyclicBarrier中最重要的方法就是await方法，它有2个重载版本：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> </td><td> <p><code>public</code> <code>int</code> <code>await() </code><code>throws</code> <code>InterruptedException, BrokenBarrierException { };</code></p> <p><code>public</code> <code>int</code> <code>await(</code><code>long</code> <code>timeout, TimeUnit unit)</code><code>throws</code> <code>InterruptedException,BrokenBarrierException,TimeoutException { };</code></p> </td></tr></tbody></table> 
<p> 　　第一个版本比较常用，用来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务；</p> 
<p>　　第二个版本是让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。</p> 
<p>　　下面举几个例子就明白了：</p> 
<p>　　假若有若干个线程都要进行写数据操作，并且只有所有线程都完成写数据操作之后，这些线程才能继续做后面的事情，此时就可以利用CyclicBarrier了：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> </td><td> <p><code>public</code> <code>class</code> <code>Test {<!-- --></code></p> <p><code>    </code><code>public</code> <code>static</code> <code>void</code> <code>main(String[] args) {<!-- --></code></p> <p><code>        </code><code>int</code> <code>N = </code><code>4</code><code>;</code></p> <p><code>        </code><code>CyclicBarrier barrier  = </code><code>new</code> <code>CyclicBarrier(N);</code></p> <p><code>        </code><code>for</code><code>(</code><code>int</code> <code>i=</code><code>0</code><code>;i&lt;N;i++)</code></p> <p><code>            </code><code>new</code> <code>Writer(barrier).start();</code></p> <p><code>    </code><code>}</code></p> <p><code>    </code><code>static</code> <code>class</code> <code>Writer </code><code>extends</code> <code>Thread{<!-- --></code></p> <p><code>        </code><code>private</code> <code>CyclicBarrier cyclicBarrier;</code></p> <p><code>        </code><code>public</code> <code>Writer(CyclicBarrier cyclicBarrier) {<!-- --></code></p> <p><code>            </code><code>this</code><code>.cyclicBarrier = cyclicBarrier;</code></p> <p><code>        </code><code>}</code></p> <p> </p> <p><code>        </code><code>@Override</code></p> <p><code>        </code><code>public</code> <code>void</code> <code>run() {<!-- --></code></p> <p><code>            </code><code>System.out.println(</code><code>"线程"</code><code>+Thread.currentThread().getName()+</code><code>"正在写入数据..."</code><code>);</code></p> <p><code>            </code><code>try</code> <code>{<!-- --></code></p> <p><code>                </code><code>Thread.sleep(</code><code>5000</code><code>);      </code><code>//以睡眠来模拟写入数据操作</code></p> <p><code>                </code><code>System.out.println(</code><code>"线程"</code><code>+Thread.currentThread().getName()+</code><code>"写入数据完毕，等待其他线程写入完毕"</code><code>);</code></p> <p><code>                </code><code>cyclicBarrier.await();</code></p> <p><code>            </code><code>} </code><code>catch</code> <code>(InterruptedException e) {<!-- --></code></p> <p><code>                </code><code>e.printStackTrace();</code></p> <p><code>            </code><code>}</code><code>catch</code><code>(BrokenBarrierException e){<!-- --></code></p> <p><code>                </code><code>e.printStackTrace();</code></p> <p><code>            </code><code>}</code></p> <p><code>            </code><code>System.out.println(</code><code>"所有线程写入完毕，继续处理其他任务..."</code><code>);</code></p> <p><code>        </code><code>}</code></p> <p><code>    </code><code>}</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p> 　　执行结果：</p> 
<p><img alt="" height="227" src="https://images2.imgbox.com/a9/81/sa5xJJX9_o.png" width="371"></p> 
<p>从上面输出结果可以看出，每个写入线程执行完写数据操作之后，就在等待其他线程写入操作完毕。</p> 
<p>　　当所有线程线程写入操作完毕之后，所有线程就继续进行后续的操作了。</p> 
<p>　　如果说想在所有线程写入操作完之后，进行额外的其他操作可以为CyclicBarrier提供Runnable参数：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> </td><td> <p><code>public</code> <code>class</code> <code>Test {<!-- --></code></p> <p><code>    </code><code>public</code> <code>static</code> <code>void</code> <code>main(String[] args) {<!-- --></code></p> <p><code>        </code><code>int</code> <code>N = </code><code>4</code><code>;</code></p> <p><code>        </code><code>CyclicBarrier barrier  = </code><code>new</code> <code>CyclicBarrier(N,</code><code>new</code> <code>Runnable() {<!-- --></code></p> <p><code>            </code><code>@Override</code></p> <p><code>            </code><code>public</code> <code>void</code> <code>run() {<!-- --></code></p> <p><code>                </code><code>System.out.println(</code><code>"当前线程"</code><code>+Thread.currentThread().getName());   </code></p> <p><code>            </code><code>}</code></p> <p><code>        </code><code>});</code></p> <p><code>        </code> </p> <p><code>        </code><code>for</code><code>(</code><code>int</code> <code>i=</code><code>0</code><code>;i&lt;N;i++)</code></p> <p><code>            </code><code>new</code> <code>Writer(barrier).start();</code></p> <p><code>    </code><code>}</code></p> <p><code>    </code><code>static</code> <code>class</code> <code>Writer </code><code>extends</code> <code>Thread{<!-- --></code></p> <p><code>        </code><code>private</code> <code>CyclicBarrier cyclicBarrier;</code></p> <p><code>        </code><code>public</code> <code>Writer(CyclicBarrier cyclicBarrier) {<!-- --></code></p> <p><code>            </code><code>this</code><code>.cyclicBarrier = cyclicBarrier;</code></p> <p><code>        </code><code>}</code></p> <p> </p> <p><code>        </code><code>@Override</code></p> <p><code>        </code><code>public</code> <code>void</code> <code>run() {<!-- --></code></p> <p><code>            </code><code>System.out.println(</code><code>"线程"</code><code>+Thread.currentThread().getName()+</code><code>"正在写入数据..."</code><code>);</code></p> <p><code>            </code><code>try</code> <code>{<!-- --></code></p> <p><code>                </code><code>Thread.sleep(</code><code>5000</code><code>);      </code><code>//以睡眠来模拟写入数据操作</code></p> <p><code>                </code><code>System.out.println(</code><code>"线程"</code><code>+Thread.currentThread().getName()+</code><code>"写入数据完毕，等待其他线程写入完毕"</code><code>);</code></p> <p><code>                </code><code>cyclicBarrier.await();</code></p> <p><code>            </code><code>} </code><code>catch</code> <code>(InterruptedException e) {<!-- --></code></p> <p><code>                </code><code>e.printStackTrace();</code></p> <p><code>            </code><code>}</code><code>catch</code><code>(BrokenBarrierException e){<!-- --></code></p> <p><code>                </code><code>e.printStackTrace();</code></p> <p><code>            </code><code>}</code></p> <p><code>            </code><code>System.out.println(</code><code>"所有线程写入完毕，继续处理其他任务..."</code><code>);</code></p> <p><code>        </code><code>}</code></p> <p><code>    </code><code>}</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p> 　　运行结果：</p> 
<p><img alt="" height="229" src="https://images2.imgbox.com/ab/f7/2oKbGV13_o.png" width="397"></p> 
<p>从结果可以看出，当四个线程都到达barrier状态后，会从四个线程中选择一个线程去执行Runnable。</p> 
<p> 　　下面看一下为await指定时间的效果：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> <p>36</p> <p>37</p> <p>38</p> <p>39</p> <p>40</p> <p>41</p> <p>42</p> <p>43</p> <p>44</p> <p>45</p> </td><td> <p><code>public</code> <code>class</code> <code>Test {<!-- --></code></p> <p><code>    </code><code>public</code> <code>static</code> <code>void</code> <code>main(String[] args) {<!-- --></code></p> <p><code>        </code><code>int</code> <code>N = </code><code>4</code><code>;</code></p> <p><code>        </code><code>CyclicBarrier barrier  = </code><code>new</code> <code>CyclicBarrier(N);</code></p> <p><code>        </code> </p> <p><code>        </code><code>for</code><code>(</code><code>int</code> <code>i=</code><code>0</code><code>;i&lt;N;i++) {<!-- --></code></p> <p><code>            </code><code>if</code><code>(i&lt;N-</code><code>1</code><code>)</code></p> <p><code>                </code><code>new</code> <code>Writer(barrier).start();</code></p> <p><code>            </code><code>else</code> <code>{<!-- --></code></p> <p><code>                </code><code>try</code> <code>{<!-- --></code></p> <p><code>                    </code><code>Thread.sleep(</code><code>5000</code><code>);</code></p> <p><code>                </code><code>} </code><code>catch</code> <code>(InterruptedException e) {<!-- --></code></p> <p><code>                    </code><code>e.printStackTrace();</code></p> <p><code>                </code><code>}</code></p> <p><code>                </code><code>new</code> <code>Writer(barrier).start();</code></p> <p><code>            </code><code>}</code></p> <p><code>        </code><code>}</code></p> <p><code>    </code><code>}</code></p> <p><code>    </code><code>static</code> <code>class</code> <code>Writer </code><code>extends</code> <code>Thread{<!-- --></code></p> <p><code>        </code><code>private</code> <code>CyclicBarrier cyclicBarrier;</code></p> <p><code>        </code><code>public</code> <code>Writer(CyclicBarrier cyclicBarrier) {<!-- --></code></p> <p><code>            </code><code>this</code><code>.cyclicBarrier = cyclicBarrier;</code></p> <p><code>        </code><code>}</code></p> <p> </p> <p><code>        </code><code>@Override</code></p> <p><code>        </code><code>public</code> <code>void</code> <code>run() {<!-- --></code></p> <p><code>            </code><code>System.out.println(</code><code>"线程"</code><code>+Thread.currentThread().getName()+</code><code>"正在写入数据..."</code><code>);</code></p> <p><code>            </code><code>try</code> <code>{<!-- --></code></p> <p><code>                </code><code>Thread.sleep(</code><code>5000</code><code>);      </code><code>//以睡眠来模拟写入数据操作</code></p> <p><code>                </code><code>System.out.println(</code><code>"线程"</code><code>+Thread.currentThread().getName()+</code><code>"写入数据完毕，等待其他线程写入完毕"</code><code>);</code></p> <p><code>                </code><code>try</code> <code>{<!-- --></code></p> <p><code>                    </code><code>cyclicBarrier.await(</code><code>2000</code><code>, TimeUnit.MILLISECONDS);</code></p> <p><code>                </code><code>} </code><code>catch</code> <code>(TimeoutException e) {<!-- --></code></p> <p><code>                    </code><code>// TODO Auto-generated catch block</code></p> <p><code>                    </code><code>e.printStackTrace();</code></p> <p><code>                </code><code>}</code></p> <p><code>            </code><code>} </code><code>catch</code> <code>(InterruptedException e) {<!-- --></code></p> <p><code>                </code><code>e.printStackTrace();</code></p> <p><code>            </code><code>}</code><code>catch</code><code>(BrokenBarrierException e){<!-- --></code></p> <p><code>                </code><code>e.printStackTrace();</code></p> <p><code>            </code><code>}</code></p> <p><code>            </code><code>System.out.println(Thread.currentThread().getName()+</code><code>"所有线程写入完毕，继续处理其他任务..."</code><code>);</code></p> <p><code>        </code><code>}</code></p> <p><code>    </code><code>}</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p> 　　执行结果：</p> 
<p><img alt="" height="402" src="https://images2.imgbox.com/cf/f9/d0ULD2Me_o.png" width="485"></p> 
<p>上面的代码在main方法的for循环中，故意让最后一个线程启动延迟，因为在前面三个线程都达到barrier之后，等待了指定的时间发现第四个线程还没有达到barrier，就抛出异常并继续执行后面的任务。</p> 
<p>　　另外CyclicBarrier是可以重用的，看下面这个例子：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> <p>36</p> <p>37</p> <p>38</p> <p>39</p> <p>40</p> <p>41</p> <p>42</p> <p>43</p> <p>44</p> </td><td> <p><code>public</code> <code>class</code> <code>Test {<!-- --></code></p> <p><code>    </code><code>public</code> <code>static</code> <code>void</code> <code>main(String[] args) {<!-- --></code></p> <p><code>        </code><code>int</code> <code>N = </code><code>4</code><code>;</code></p> <p><code>        </code><code>CyclicBarrier barrier  = </code><code>new</code> <code>CyclicBarrier(N);</code></p> <p><code>        </code> </p> <p><code>        </code><code>for</code><code>(</code><code>int</code> <code>i=</code><code>0</code><code>;i&lt;N;i++) {<!-- --></code></p> <p><code>            </code><code>new</code> <code>Writer(barrier).start();</code></p> <p><code>        </code><code>}</code></p> <p><code>        </code> </p> <p><code>        </code><code>try</code> <code>{<!-- --></code></p> <p><code>            </code><code>Thread.sleep(</code><code>25000</code><code>);</code></p> <p><code>        </code><code>} </code><code>catch</code> <code>(InterruptedException e) {<!-- --></code></p> <p><code>            </code><code>e.printStackTrace();</code></p> <p><code>        </code><code>}</code></p> <p><code>        </code> </p> <p><code>        </code><code>System.out.println(</code><code>"CyclicBarrier重用"</code><code>);</code></p> <p><code>        </code> </p> <p><code>        </code><code>for</code><code>(</code><code>int</code> <code>i=</code><code>0</code><code>;i&lt;N;i++) {<!-- --></code></p> <p><code>            </code><code>new</code> <code>Writer(barrier).start();</code></p> <p><code>        </code><code>}</code></p> <p><code>    </code><code>}</code></p> <p><code>    </code><code>static</code> <code>class</code> <code>Writer </code><code>extends</code> <code>Thread{<!-- --></code></p> <p><code>        </code><code>private</code> <code>CyclicBarrier cyclicBarrier;</code></p> <p><code>        </code><code>public</code> <code>Writer(CyclicBarrier cyclicBarrier) {<!-- --></code></p> <p><code>            </code><code>this</code><code>.cyclicBarrier = cyclicBarrier;</code></p> <p><code>        </code><code>}</code></p> <p> </p> <p><code>        </code><code>@Override</code></p> <p><code>        </code><code>public</code> <code>void</code> <code>run() {<!-- --></code></p> <p><code>            </code><code>System.out.println(</code><code>"线程"</code><code>+Thread.currentThread().getName()+</code><code>"正在写入数据..."</code><code>);</code></p> <p><code>            </code><code>try</code> <code>{<!-- --></code></p> <p><code>                </code><code>Thread.sleep(</code><code>5000</code><code>);      </code><code>//以睡眠来模拟写入数据操作</code></p> <p><code>                </code><code>System.out.println(</code><code>"线程"</code><code>+Thread.currentThread().getName()+</code><code>"写入数据完毕，等待其他线程写入完毕"</code><code>);</code></p> <p><code>            </code> </p> <p><code>                </code><code>cyclicBarrier.await();</code></p> <p><code>            </code><code>} </code><code>catch</code> <code>(InterruptedException e) {<!-- --></code></p> <p><code>                </code><code>e.printStackTrace();</code></p> <p><code>            </code><code>}</code><code>catch</code><code>(BrokenBarrierException e){<!-- --></code></p> <p><code>                </code><code>e.printStackTrace();</code></p> <p><code>            </code><code>}</code></p> <p><code>            </code><code>System.out.println(Thread.currentThread().getName()+</code><code>"所有线程写入完毕，继续处理其他任务..."</code><code>);</code></p> <p><code>        </code><code>}</code></p> <p><code>    </code><code>}</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p> 　　执行结果：</p> 
<p><img alt="" height="392" src="https://images2.imgbox.com/1c/75/jvEqmmHh_o.png" width="403"></p> 
<p> </p> 
<p>从执行结果可以看出，在初次的4个线程越过barrier状态后，又可以用来进行新一轮的使用。而CountDownLatch无法进行重复使用。</p> 
<h3>三.Semaphore用法</h3> 
<p>　　Semaphore翻译成字面意思为 信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</p> 
<p>　　Semaphore类位于java.util.concurrent包下，它提供了2个构造器：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>public</code> <code>Semaphore(</code><code>int</code> <code>permits) {          </code><code>//参数permits表示许可数目，即同时可以允许多少线程进行访问</code></p> <p><code>    </code><code>sync = </code><code>new</code> <code>NonfairSync(permits);</code></p> <p><code>}</code></p> <p><code>public</code> <code>Semaphore(</code><code>int</code> <code>permits, </code><code>boolean</code> <code>fair) {    </code><code>//这个多了一个参数fair表示是否是公平的，即等待时间越久的越先获取许可</code></p> <p><code>    </code><code>sync = (fair)? </code><code>new</code> <code>FairSync(permits) : </code><code>new</code> <code>NonfairSync(permits);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p> 　　下面说一下Semaphore类中比较重要的几个方法，首先是acquire()、release()方法：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> </td><td> <p><code>public</code> <code>void</code> <code>acquire() </code><code>throws</code> <code>InterruptedException {  }     </code><code>//获取一个许可</code></p> <p><code>public</code> <code>void</code> <code>acquire(</code><code>int</code> <code>permits) </code><code>throws</code> <code>InterruptedException { }    </code><code>//获取permits个许可</code></p> <p><code>public</code> <code>void</code> <code>release() { }          </code><code>//释放一个许可</code></p> <p><code>public</code> <code>void</code> <code>release(</code><code>int</code> <code>permits) { }    </code><code>//释放permits个许可</code></p> </td></tr></tbody></table> 
<p>　　acquire()用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。</p> 
<p>　　release()用来释放许可。注意，在释放许可之前，必须先获获得许可。</p> 
<p>　　这4个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> </td><td> <p><code>public</code> <code>boolean</code> <code>tryAcquire() { };    </code><code>//尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</code></p> <p><code>public</code> <code>boolean</code> <code>tryAcquire(</code><code>long</code> <code>timeout, TimeUnit unit) </code><code>throws</code> <code>InterruptedException { };  </code><code>//尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</code></p> <p><code>public</code> <code>boolean</code> <code>tryAcquire(</code><code>int</code> <code>permits) { }; </code><code>//尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</code></p> <p><code>public</code> <code>boolean</code> <code>tryAcquire(</code><code>int</code> <code>permits, </code><code>long</code> <code>timeout, TimeUnit unit) </code><code>throws</code> <code>InterruptedException { }; </code><code>//尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</code></p> </td></tr></tbody></table> 
<p> 　　另外还可以通过availablePermits()方法得到可用的许可数目。</p> 
<p>　　下面通过一个例子来看一下Semaphore的具体使用：</p> 
<p>　　假若一个工厂有5台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过Semaphore来实现：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> </td><td> <p><code>public</code> <code>class</code> <code>Test {<!-- --></code></p> <p><code>    </code><code>public</code> <code>static</code> <code>void</code> <code>main(String[] args) {<!-- --></code></p> <p><code>        </code><code>int</code> <code>N = </code><code>8</code><code>;            </code><code>//工人数</code></p> <p><code>        </code><code>Semaphore semaphore = </code><code>new</code> <code>Semaphore(</code><code>5</code><code>); </code><code>//机器数目</code></p> <p><code>        </code><code>for</code><code>(</code><code>int</code> <code>i=</code><code>0</code><code>;i&lt;N;i++)</code></p> <p><code>            </code><code>new</code> <code>Worker(i,semaphore).start();</code></p> <p><code>    </code><code>}</code></p> <p><code>    </code> </p> <p><code>    </code><code>static</code> <code>class</code> <code>Worker </code><code>extends</code> <code>Thread{<!-- --></code></p> <p><code>        </code><code>private</code> <code>int</code> <code>num;</code></p> <p><code>        </code><code>private</code> <code>Semaphore semaphore;</code></p> <p><code>        </code><code>public</code> <code>Worker(</code><code>int</code> <code>num,Semaphore semaphore){<!-- --></code></p> <p><code>            </code><code>this</code><code>.num = num;</code></p> <p><code>            </code><code>this</code><code>.semaphore = semaphore;</code></p> <p><code>        </code><code>}</code></p> <p><code>        </code> </p> <p><code>        </code><code>@Override</code></p> <p><code>        </code><code>public</code> <code>void</code> <code>run() {<!-- --></code></p> <p><code>            </code><code>try</code> <code>{<!-- --></code></p> <p><code>                </code><code>semaphore.acquire();</code></p> <p><code>                </code><code>System.out.println(</code><code>"工人"</code><code>+</code><code>this</code><code>.num+</code><code>"占用一个机器在生产..."</code><code>);</code></p> <p><code>                </code><code>Thread.sleep(</code><code>2000</code><code>);</code></p> <p><code>                </code><code>System.out.println(</code><code>"工人"</code><code>+</code><code>this</code><code>.num+</code><code>"释放出机器"</code><code>);</code></p> <p><code>                </code><code>semaphore.release();           </code></p> <p><code>            </code><code>} </code><code>catch</code> <code>(InterruptedException e) {<!-- --></code></p> <p><code>                </code><code>e.printStackTrace();</code></p> <p><code>            </code><code>}</code></p> <p><code>        </code><code>}</code></p> <p><code>    </code><code>}</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>  　　执行结果：</p> 
<p><img alt="" height="276" src="https://images2.imgbox.com/e7/6d/3xu38Rug_o.png" width="346"></p> 
<p>下面对上面说的三个辅助类进行一个总结：</p> 
<p>　　1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：</p> 
<p>　　　　CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；</p> 
<p>　　　　而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</p> 
<p>　　　　另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。</p> 
<p>　　2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。</p> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3cdb41dbd570453e5ccfd5bdaed979e6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java调用第三方接口（项目亲测）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a50b2e4affef1742ec9a4449b7dde16d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Netty架构篇 - NioServerSocketChannel、NioSocketChannel</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>