<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ADC、DMA、EXTI、定时器、NVIC等片上外设篇 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ADC、DMA、EXTI、定时器、NVIC等片上外设篇" />
<meta property="og:description" content="不知是否是干货，有什么问题，欢迎留言，看见都会答复的
目录
1. 首先呢，放一个STM32芯片框图，这样心里有底 2
2. 第一呢，我们闲聊聊中断 2
2.1什么叫做中断 2
2.2为什么我们要引入NVIC外设 3
2.3 NVIC主要做了那些工作呢 3
2.3.1 NVIC管理时用到的寄存器 3
2.4 NVIC编程 4
3. 说完NVIC，我们就来聊聊外部中断EXTI(IO上的中断) 4
3.1EXTI 功能框图 4
3.2中断/事件线 5
3.3 编程 5
3.3.1EXTI结构体（库函数） 5
3.3.2 编程要点 5
4 .TIM定时器 6
4.1基本定时器的原理 6
4.2基本定时器的基本初始化结构体 7
4.3 编程要点 7
5. 聊聊ADC 8
5.1 ADC原理详解 8
5.1.1①电压输入范围 8
5.1.2 ②输入通道 9
5.1.3 ③转换顺序 9
5.1.4 ④触发源 10
5.1.5 ⑤转换时间 10
5.1.6 ⑥数据寄存器 11" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8ab5e363f84f3584ee8790ffcf7a4673/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-11T14:16:56+08:00" />
<meta property="article:modified_time" content="2020-10-11T14:16:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ADC、DMA、EXTI、定时器、NVIC等片上外设篇</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0pt;">不知是否是干货，有什么问题，欢迎留言，看见都会答复的</p> 
<p style="margin-left:0pt;">目录</p> 
<p style="margin-left:0pt;"><a href="#_Toc25577" rel="nofollow">1. 首先呢，放一个STM32芯片框图，这样心里有底 2</a></p> 
<p style="margin-left:0pt;"><a href="#_Toc22872" rel="nofollow">2. 第一呢，我们闲聊聊中断 2</a></p> 
<p style="margin-left:21pt;"><a href="#_Toc5917" rel="nofollow">2.1什么叫做中断 2</a></p> 
<p style="margin-left:21pt;"><a href="#_Toc24709" rel="nofollow">2.2为什么我们要引入NVIC外设 3</a></p> 
<p style="margin-left:21pt;"><a href="#_Toc9554" rel="nofollow">2.3 NVIC主要做了那些工作呢 3</a></p> 
<p style="margin-left:42pt;"><a href="#_Toc14408" rel="nofollow">2.3.1 NVIC管理时用到的寄存器 3</a></p> 
<p style="margin-left:21pt;"><a href="#_Toc19968" rel="nofollow">2.4 NVIC编程 4</a></p> 
<p style="margin-left:0pt;"><a href="#_Toc2302" rel="nofollow">3. 说完NVIC，我们就来聊聊外部中断EXTI(IO上的中断) 4</a></p> 
<p style="margin-left:21pt;"><a href="#_Toc27590" rel="nofollow">3.1EXTI 功能框图 4</a></p> 
<p style="margin-left:21pt;"><a href="#_Toc12182" rel="nofollow">3.2中断/事件线 5</a></p> 
<p style="margin-left:21pt;"><a href="#_Toc26978" rel="nofollow">3.3 编程 5</a></p> 
<p style="margin-left:42pt;"><a href="#_Toc3896" rel="nofollow">3.3.1EXTI结构体（库函数） 5</a></p> 
<p style="margin-left:42pt;"><a href="#_Toc15154" rel="nofollow">3.3.2 编程要点 5</a></p> 
<p style="margin-left:0pt;"><a href="#_Toc22849" rel="nofollow">4 .TIM定时器 6</a></p> 
<p style="margin-left:21pt;"><a href="#_Toc27085" rel="nofollow">4.1基本定时器的原理 6</a></p> 
<p style="margin-left:21pt;"><a href="#_Toc17897" rel="nofollow">4.2基本定时器的基本初始化结构体 7</a></p> 
<p style="margin-left:21pt;"><a href="#_Toc24198" rel="nofollow">4.3 编程要点 7</a></p> 
<p style="margin-left:0pt;"><a href="#_Toc19278" rel="nofollow">5. 聊聊ADC 8</a></p> 
<p style="margin-left:21pt;"><a href="#_Toc26828" rel="nofollow">5.1 ADC原理详解 8</a></p> 
<p style="margin-left:42pt;"><a href="#_Toc3520" rel="nofollow">5.1.1①电压输入范围 8</a></p> 
<p style="margin-left:42pt;"><a href="#_Toc23423" rel="nofollow">5.1.2 ②输入通道 9</a></p> 
<p style="margin-left:42pt;"><a href="#_Toc23969" rel="nofollow">5.1.3 ③转换顺序 9</a></p> 
<p style="margin-left:42pt;"><a href="#_Toc22345" rel="nofollow">5.1.4 ④触发源 10</a></p> 
<p style="margin-left:42pt;"><a href="#_Toc20062" rel="nofollow">5.1.5 ⑤转换时间 10</a></p> 
<p style="margin-left:42pt;"><a href="#_Toc20579" rel="nofollow">5.1.6 ⑥数据寄存器 11</a></p> 
<p style="margin-left:42pt;"><a href="#_Toc6709" rel="nofollow">5.1.7 ⑦中断 12</a></p> 
<p style="margin-left:42pt;"><a href="#_Toc31760" rel="nofollow">5.1.8 ⑧电压转换 12</a></p> 
<p style="margin-left:21pt;"><a href="#_Toc19383" rel="nofollow">5.2 ADC 初始化结构体详解 12</a></p> 
<p style="margin-left:21pt;"><a href="#_Toc9103" rel="nofollow">5.3 编程要点 13</a></p> 
<p style="margin-left:0pt;"><a href="#_Toc5205" rel="nofollow">6. 说完了ADC，就在说下，ARM公司设计的DMA, 13</a></p> 
<p style="margin-left:21pt;"><a href="#_Toc13065" rel="nofollow">6.1简介： 13</a></p> 
<p style="margin-left:21pt;"><a href="#_Toc13831" rel="nofollow">6.2 要想真正的了解一个外设，必要看懂他的原理框图 14</a></p> 
<p style="margin-left:21pt;"><a href="#_Toc14634" rel="nofollow">6.3 我们在使用DMA的时候，我们会考虑的： 15</a></p> 
<p style="margin-left:42pt;"><a href="#_Toc20250" rel="nofollow">6.3.2 要传多少，单位是什么 ，什么时候传输完成 15</a></p> 
<p style="margin-left:21pt;"><a href="#_Toc9263" rel="nofollow">6.4 DMA 初始化结构体详解 16</a></p> 
<p style="margin-left:21pt;"><a href="#_Toc16749" rel="nofollow">6.5 编程要点 17</a></p> 
<p style="margin-left:0pt;"> </p> 
<ol><li><strong><a name="_Toc25577"></a> <strong><strong>首先呢，放一个STM32芯片框图，这样心里有底</strong></strong></strong> <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d9/ab/iPMap7YA_o.png"></p> </li></ol> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">这里要是想了解STM32，就需要了解他的内部结构，随意推荐去看野火的视频，链接如下：</p> 
<p style="margin-left:0pt;"><a href="https://www.bilibili.com/video/BV1yW411Y7Gw?from=search&amp;seid=15398269326892868602%E7%9A%84P6%E3%80%81P7%E3%80%82" rel="nofollow"><u><span style="color:#0000ff;"><u>https://www.bilibili.com/video/BV1yW411Y7Gw?from=search&amp;seid=15398269326892868602</u></span></u><u><span style="color:#0000ff;"><u>的P6、P7。</u></span></u></a></p> 
<ol><li><strong><a name="_Toc22872"></a> <strong><strong>第一呢，我们闲聊聊中断</strong></strong></strong></li></ol> 
<h3><strong><a name="_Toc5917"></a><strong><strong>2.1什么叫做中断</strong></strong></strong></h3> 
<p style="margin-left:0pt;">官方解释：Cortex-M3 处理器和嵌套向量中断控制器（ NVIC）对所有异常按优先级进行排序并处理。所有异常都在处理模式中操作。出现异常时，自动将处理器状态保存到堆栈中，并在中断服务程序（ ISR）结束时自动从堆栈中恢复。在状态保存的同时取出向量快速地进入中断。处理器支持末尾连锁（ tail-chaining）中断技术，它能够在没有多余的状态保存和恢复指令的情况下执行背对背中断（ back-to-back interrupt）。</p> 
<p style="margin-left:0pt;">我理解的：当CPU正在处理一段程序的时候，如果某个时刻，中断触发，哪么此刻CPU会保存当时正在处理的程序而去执行中断服务函数里的程序，当中断服务函数里面的程序执行完毕后，在恢复现场，回来继续的执行中断打断前的程序。</p> 
<p style="margin-left:0pt;"><span style="color:#000000;">F103 </span><span style="color:#000000;">在内核水平上搭载了一个异常响应系统</span> ，其中支持众多系统异常（中断）和外部中断。</p> 
<p style="margin-left:0pt;">系统中断：10个，如果<span style="color:#000000;">Reset</span><span style="color:#000000;">（</span><span style="color:#000000;">不可编程</span><span style="color:#000000;">）</span> <span style="color:#000000;">、</span><span style="color:#000000;">HardFault</span><span style="color:#000000;">（</span><span style="color:#000000;">不可编程</span><span style="color:#000000;">）、</span><span style="color:#000000;">SysTick（可）</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">外部中断：60个（可编程的）</span> </p> 
<p style="margin-left:0pt;"> </p> 
<h3><strong><a name="_Toc24709"></a><strong><strong>2.2为什么我们要引入NVIC外设</strong></strong></strong></h3> 
<p style="margin-left:0pt;">所以呢，可以理解为中断的优先级是比普通的顺序执行的优先级高，那么中断就是说是分优先级的，总要东西来控制各个优先级的高低啊有，于是就设计出了一个内核外设NVIC（嵌套向量中断控制器）。那么我们到底是怎么管理中断的呢,下面我们来分析。</p> 
<h3><strong><a name="_Toc9554"></a><strong><strong>2.3 NVIC主要做了那些工作呢</strong></strong></strong></h3> 
<p style="margin-left:0pt;">首先，我想说的是任何中断触发后都会经过NVIC来控制中断的优先级问题。</p> 
<h4><strong><a name="_Toc14408"></a><strong><strong>2.3.1 NVIC管理时用到的寄存器</strong></strong></strong></h4> 
<p style="margin-left:0pt;"><span style="color:#000000;">在配置中断的时候我们一般只用 </span><span style="color:#000000;">ISER</span><span style="color:#000000;">、 </span><span style="color:#000000;">ICER </span><span style="color:#000000;">和 </span><span style="color:#000000;">IP </span><span style="color:#000000;">这三个寄存器， </span><span style="color:#000000;">ISER </span><span style="color:#000000;">用来使能中断，</span><span style="color:#000000;">ICER </span><span style="color:#000000;">用来失能中断， </span><span style="color:#000000;">IP </span><span style="color:#000000;">用来设置中断优先级</span> 。</p> 
<p style="margin-left:0pt;"><span style="color:#000000;">1.</span><span style="color:#000000;">中断优先级寄存器 </span><span style="color:#000000;">NVIC_IPRx</span> ：</p> 
<p style="text-align:center;"><img alt="" height="97" src="https://images2.imgbox.com/1a/89/xUhPDsYe_o.png" width="750"></p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">高四位用于控制中断优先级高低，但是M3把这4位分为抢占优先级和响应优先级，就要对优先级分组了。</p> 
<p style="margin-left:0pt;">2.优先级分组</p> 
<p style="margin-left:0pt;"><span style="color:#000000;">优先级的分组由内核外设 </span><span style="color:#000000;">SCB </span><span style="color:#000000;">的应用程序中断及复位控制寄存器 </span><span style="color:#000000;">AIRCR </span><span style="color:#000000;">的</span><br><span style="color:#000000;">PRIGROUP[10:8]</span><span style="color:#000000;">位决定</span> </p> 
<p style="margin-left:0pt;"> </p> 
<p> </p> 
<p style="text-align:center;"><img alt="" height="153" src="https://images2.imgbox.com/3c/8d/Cv78zr9t_o.png" width="711"></p> 
<p style="margin-left:0pt;"> </p> 
<h3><strong><a name="_Toc19968"></a></strong></h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/41/6d/a5qYRnoD_o.png"></p> 
<h3><strong><strong><strong>2.4 NVIC编程</strong></strong></strong></h3> 
<p style="margin-left:0pt;">1.首先，中断优先级分组： NVIC_SetPriorityGrouping(5);//第五个分组 占--2位 次--2位</p> 
<p style="margin-left:0pt;">2.设置中断优先级：NVIC_SetPriority(USART1_IRQn,5);</p> 
<p style="margin-left:0pt;">3.使能：NVIC_EnableIRQ(USART1_IRQn);</p> 
<h2><strong><a name="_Toc2302"></a><strong><strong>3. 说完NVIC，我们就来聊聊外部中断EXTI(IO上的中断)</strong></strong></strong></h2> 
<h3><strong><a name="_Toc27590"></a><strong><strong>3.1</strong></strong><strong><strong>EXTI </strong></strong><strong><strong>功能框图 </strong></strong></strong></h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/64/5c/0FtSxduV_o.png"></p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">从这个图上可以看出，这里一共有20根中断信号线，也就是说<span style="color:#000000;">EXTI</span> 管理了20个外部中断（io中断）</p> 
<h3><strong><a name="_Toc12182"></a><strong><strong>3.2中断/事件线</strong></strong></strong></h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ef/c3/gEZLaOtE_o.png"></p> 
<p style="margin-left:0pt;"> </p> 
<h3><strong><a name="_Toc26978"></a><strong><strong>3.3 编程</strong></strong></strong></h3> 
<h4><strong><a name="_Toc3896"></a><strong><strong>3.3.1EXTI结构体（库函数）</strong></strong></strong></h4> 
<p style="margin-left:0pt;"><span style="color:#2b91af;">1 typedef </span><span style="color:#0000ff;">struct </span><span style="color:#000000;">{<!-- --></span><br><span style="color:#2b91af;">2 </span><span style="color:#0000ff;">uint32_t </span><span style="color:#000000;">EXTI_Line; </span><span style="color:#008000;">// </span><span style="color:#008000;">中断</span><span style="color:#008000;">/</span><span style="color:#008000;">事件线</span><br><span style="color:#2b91af;">3 </span><span style="color:#000000;">EXTIMode_TypeDef EXTI_Mode; </span><span style="color:#008000;">// EXTI </span><span style="color:#008000;">模式</span><span style="color:#008000;">（</span><span style="color:#008000;">中断或者事件</span><span style="color:#008000;">）</span><br><span style="color:#2b91af;">4 </span><span style="color:#000000;">EXTITrigger_TypeDef EXTI_Trigger; </span><span style="color:#008000;">// </span><span style="color:#008000;">触发类型</span><br><span style="color:#2b91af;">5 </span><span style="color:#000000;">FunctionalState EXTI_LineCmd; </span><span style="color:#008000;">// EXTI </span><span style="color:#008000;">使能</span><br><span style="color:#2b91af;">6 </span><span style="color:#000000;">} EXTI_InitTypeDef;</span> </p> 
<p style="margin-left:0pt;">我们只需要填充这个结构体就行</p> 
<h4><strong><a name="_Toc15154"></a><strong><strong>3.3.2 编程要点 </strong></strong></strong></h4> 
<p style="margin-left:0pt;">（1）初始化用来产生中断的GPIO</p> 
<p style="margin-left:0pt;">（2）将PA0映射到EXTI0</p> 
<p style="margin-left:0pt;">（3）初始化EXTI,就是填充结构体</p> 
<p style="margin-left:0pt;">（4）配置NVIC</p> 
<p style="margin-left:0pt;">（5）编写中断服务函数</p> 
<p style="margin-left:0pt;"> </p> 
<h2><strong><a name="_Toc22849"></a><strong><strong>4 .TIM定时器</strong></strong></strong></h2> 
<p style="margin-left:0pt;"><span style="color:#414141;">定时器一个分为基本、通用、高级定时器定时器</span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/91/1c/VlREmdiI_o.png"></p> 
<p style="margin-left:0pt;"> </p> 
<h3><strong><a name="_Toc27085"></a><strong><strong>4.1基本定时器的原理</strong></strong></strong></h3> 
<ol><li><span style="color:#414141;">看图</span> <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b1/af/VyblZPoE_o.png"></p> </li></ol> 
<p style="margin-left:0pt;"><span style="color:#000000;">①时钟源</span> </p> 
<p style="margin-left:0pt;"><span style="color:#444444;">定时器时钟 </span><span style="color:#444444;">TIMxCLK</span><span style="color:#444444;">，即内部时钟 </span><span style="color:#444444;">CK_INT</span><span style="color:#444444;">，经 </span><span style="color:#444444;">APB1 </span><span style="color:#444444;">预分频器后分频提供，如果</span><br><span style="color:#444444;">APB1 </span><span style="color:#444444;">预分频系数等于 </span><span style="color:#444444;">1</span><span style="color:#444444;">，则频率不变，否则频率乘以 </span><span style="color:#444444;">2</span><span style="color:#444444;">，库函数中 </span><span style="color:#444444;">APB1 </span><span style="color:#444444;">预分频的系</span><br><span style="color:#444444;">数是 </span><span style="color:#444444;">2</span><span style="color:#444444;">，即 </span><span style="color:#444444;">PCLK1=36M</span><span style="color:#444444;">，所以定时器时钟 </span><span style="color:#444444;">TIMxCLK=36*2=72M</span><span style="color:#000000;">。</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">②计数器时钟</span><br><span style="color:#000000;">定时器时钟经过 </span><span style="color:#000000;">PSC </span><span style="color:#000000;">预分频器之后，即 </span><span style="color:#000000;">CK_CNT</span><span style="color:#000000;">，用来驱动计数器计数。 </span><span style="color:#000000;">PSC </span><span style="color:#000000;">是一个</span><span style="color:#000000;">16 </span><span style="color:#000000;">位的预分频器，可以对定时器时钟 </span><span style="color:#000000;">TIMxCLK </span><span style="color:#000000;">进行 </span><span style="color:#000000;">1~65536 </span><span style="color:#000000;">之间的任何一个数进行分频。具体计算方式为： </span><span style="color:#000000;">CK_CNT=TIMxCLK/(PSC+1)</span><span style="color:#000000;">。</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">③计数器</span><br><span style="color:#000000;">计数器 </span><span style="color:#000000;">CNT </span><span style="color:#000000;">是一个 </span><span style="color:#000000;">16 </span><span style="color:#000000;">位的计数器，只能往上计数，最大计数值为 </span><span style="color:#000000;">65535</span><span style="color:#000000;">。当计数达</span><br><span style="color:#000000;">到自动重装载寄存器的时候产生更新事件，并清零从头开始计数。</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">④自动重装载寄存器</span><br><span style="color:#000000;">自动重装载寄存器 </span><span style="color:#000000;">ARR </span><span style="color:#000000;">是一个 </span><span style="color:#000000;">16 </span><span style="color:#000000;">位的寄存器，这里面装着计数器能计数的最大数</span><br> 值。当计数到这个值的时候，如果使能了中断的话，定时器就产生溢出中断。</p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">重点：就是在计时的时候，其实是③计数器的值向上加，但是，我们在设置其加到多大的时候，是通过改变④自动重装载寄存器的大小来决定的，也就是说我们以后配置定时时间的时候是根据两点来决定的：1.定时器的时钟频率 2.重装载的值</p> 
<h3><strong><a name="_Toc17897"></a><strong><strong>4.2基本定时器的基本初始化结构体</strong></strong></strong></h3> 
<p style="margin-left:0pt;"><span style="color:#2b91af;">typedef </span><span style="color:#0000ff;">struct </span><span style="color:#000000;">{<!-- --></span><br><span style="color:#2b91af;">2 </span><span style="color:#0000ff;">uint16_t </span><span style="color:#000000;">TIM_Prescaler; </span><span style="color:#008000;">// </span><span style="color:#008000;">预分频器</span><br><span style="color:#2b91af;">3 </span><span style="color:#0000ff;">uint16_t </span><span style="color:#000000;">TIM_CounterMode; </span><span style="color:#008000;">// </span><span style="color:#008000;">计数模式</span><br><span style="color:#2b91af;">4 </span><span style="color:#0000ff;">uint32_t </span><span style="color:#000000;">TIM_Period; </span><span style="color:#008000;">// </span><span style="color:#008000;">定时器周期</span><br><span style="color:#2b91af;">5 </span><span style="color:#0000ff;">uint16_t </span><span style="color:#000000;">TIM_ClockDivision; </span><span style="color:#008000;">// </span><span style="color:#008000;">时钟分频</span><br><span style="color:#2b91af;">6 </span><span style="color:#0000ff;">uint8_t </span><span style="color:#000000;">TIM_RepetitionCounter; </span><span style="color:#008000;">// </span><span style="color:#008000;">重复计算器</span><br><span style="color:#2b91af;">7 </span><span style="color:#000000;">} TIM_TimeBaseInitTypeDef;</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">TIM_Prescaler</span><span style="color:#000000;">：</span> <span style="color:#000000;">定时器预分频器设置，时钟源经该预分频器才是定时器时钟，它设定</span><br><span style="color:#000000;">TIMx_PSC </span><span style="color:#000000;">寄存器的值。可设置范围为 </span><span style="color:#000000;">0 </span><span style="color:#000000;">至 </span><span style="color:#000000;">65535</span><span style="color:#000000;">，实现 </span><span style="color:#000000;">1 </span><span style="color:#000000;">至 </span><span style="color:#000000;">65536 </span><span style="color:#000000;">分频。</span><span style="color:#000000;">也就是说这里如果设置72，那么就相当于是72MHZ的72倍分频，即72M/72=1M</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">TIM_CounterMode</span><span style="color:#000000;">：</span> 基本定时器只能是向上计数</p> 
<p style="margin-left:0pt;"><span style="color:#000000;">TIM_Period</span><span style="color:#000000;">：</span> 重装载的值</p> 
<h3><strong><a name="_Toc24198"></a><strong><strong>4.3 编程要点 </strong></strong></strong></h3> 
<p style="margin-left:0pt;"><span style="color:#000000;">1.开启定时器时钟</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">2.配置定时器（填充定时器结构体）</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">3.计数器清零</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">4.开启定时器中断</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">5.设置NVIC</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">6.使能定时器</span></p> 
<h2><strong><a name="_Toc19278"></a><strong><strong>5. 聊聊ADC</strong></strong></strong></h2> 
<p style="margin-left:0pt;"><span style="color:#000000;">AD 转换作用：将模拟量转换为数字量 </span></p> 
<h3><strong><a name="_Toc26828"></a><strong><strong>5.1 ADC原理详解</strong></strong></strong></h3> 
<p style="margin-left:0pt;"><span style="color:#000000;">STM32f103 </span><span style="color:#000000;">系列有 </span><span style="color:#000000;">3 </span><span style="color:#000000;">个 </span><span style="color:#000000;">ADC</span><span style="color:#000000;">，精度为 </span><span style="color:#000000;">12 </span><span style="color:#000000;">位，每个 </span><span style="color:#000000;">ADC </span><span style="color:#000000;">最多有 </span><span style="color:#000000;">16 </span><span style="color:#000000;">个外部通道。其中</span><br><span style="color:#000000;">ADC1 </span><span style="color:#000000;">和 </span><span style="color:#000000;">ADC2 </span><span style="color:#000000;">都有 </span><span style="color:#000000;">16 </span><span style="color:#000000;">个外部通道， </span><span style="color:#000000;">ADC3 </span><span style="color:#000000;">根据 </span><span style="color:#000000;">CPU </span><span style="color:#000000;">引脚的不同通道数也不同，一般都有</span><span style="color:#000000;">8 </span><span style="color:#000000;">个外部通道。 </span><span style="color:#000000;">ADC </span><span style="color:#000000;">的模式非常多，功能非常强大，具体的我们在功能框图中分析每个部分的功能。</span> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/47/a5/6mLJOSzF_o.png"></p> 
<p style="margin-left:0pt;"><a name="_Toc3520"></a><strong><strong>5.1.1</strong></strong><strong><strong>①电压输入范围</strong></strong><br><span style="color:#000000;">ADC </span><span style="color:#000000;">输入范围为： </span><span style="color:#000000;">V</span><span style="color:#000000;">REF- </span><span style="color:#000000;">≤ </span><span style="color:#000000;">V</span><span style="color:#000000;">IN </span><span style="color:#000000;">≤ </span><span style="color:#000000;">V</span><span style="color:#000000;">REF+</span><span style="color:#000000;">。由 </span><span style="color:#000000;">V</span><span style="color:#000000;">REF-</span><span style="color:#000000;">、 </span><span style="color:#000000;">V</span><span style="color:#000000;">REF+ </span><span style="color:#000000;">、 </span><span style="color:#000000;">V</span><span style="color:#000000;">DDA </span><span style="color:#000000;">、 </span><span style="color:#000000;">V</span><span style="color:#000000;">SSA</span><span style="color:#000000;">、这四个外部引脚决定。</span><br><span style="color:#000000;">我们在设计原理图的时候一般把 </span><span style="color:#000000;">V</span><span style="color:#000000;">SSA </span><span style="color:#000000;">和 </span><span style="color:#000000;">V</span><span style="color:#000000;">REF-</span><span style="color:#000000;">接地，把 </span><span style="color:#000000;">V</span><span style="color:#000000;">REF+</span><span style="color:#000000;">和 </span><span style="color:#000000;">V</span><span style="color:#000000;">DDA </span><span style="color:#000000;">接 </span><span style="color:#000000;">3V3</span><span style="color:#000000;">，得到</span><br><span style="color:#000000;">ADC </span><span style="color:#000000;">的输入电压范围为： </span><span style="color:#000000;">0~3.3V</span><span style="color:#000000;">。</span><br><span style="color:#000000;">如果我们想让输入的电压范围变宽，去到可以测试负电压或者更高的正电压，我们可</span><br><span style="color:#000000;">以在外部加一个电压调理电路，把需要转换的电压抬升或者降压到 </span><span style="color:#000000;">0~3.3V</span><span style="color:#000000;">，这样 </span><span style="color:#000000;">ADC </span><span style="color:#000000;">就可以测量。</span> </p> 
<h4><strong><a name="_Toc23423"></a><strong><strong>5.1.2 </strong></strong><strong><strong>②输入通道 </strong></strong></strong></h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d9/be/WkpWqjyH_o.png"></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">外部的 </span><span style="color:#000000;">16 </span><span style="color:#000000;">个通道在转换的时候又分为规则通道和注入通道，其中规则通道最多有 </span><span style="color:#000000;">16</span><br><span style="color:#000000;">路，注入通道最多有 </span><span style="color:#000000;">4 </span><span style="color:#000000;">路。那这两个通道有什么区别？在什么时候使用？</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">规则通道</span><br><span style="color:#000000;">规则通道：顾名思意，规则通道就是很规矩的意思，我们平时一般使用的就是这个通</span><br><span style="color:#000000;">道，或者应该说我们用到的都是这个通道，没有什么特别要注意的可讲。</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">注入通道</span><br><span style="color:#000000;">注入，可以理解为插入，插队的意思，是一种不安分的通道。它是一种在规则通道转</span><br><span style="color:#000000;">换的时候强行插入要转换的一种。如果在规则通道转换过程中，有注入通道插队，那么就要先转换完注入通道，等注入通道转换完成后，再回到规则通道的转换流程。这点跟中断程序很像，都是不安分的主。所以，注入通道只有在规则通道存在时才会出现。</span>  </p> 
<h4><strong><a name="_Toc23969"></a><strong><strong>5.1.3 </strong></strong><strong><strong>③转换顺序 </strong></strong></strong></h4> 
<p style="margin-left:0pt;"><span style="color:#000000;">规则序列</span> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/72/c6/uNJbXEQA_o.png"></p> 
<p style="margin-left:0pt;">这里呢，主要就是SQR三个寄存器来控制各个ADC通道的的转化顺序</p> 
<p style="margin-left:0pt;">比如说，SQR3中的，5位控制一个转换的通道，就是说，比如，你想让你想让那个通道放在第几个转化，就配置那个SQ</p> 
<h4><strong><a name="_Toc22345"></a><strong><strong>5.1.4 </strong></strong><strong><strong>④触发源 </strong></strong></strong></h4> 
<p style="margin-left:0pt;">通道选好了，转换的顺序也设置好了，那接下来就该开始转换了， 我们一般用的是软件中断，即<span style="color:#444444;">ADC_CR2 </span><span style="color:#444444;">的 </span><span style="color:#444444;">ADON </span><span style="color:#444444;">这个位来控制</span> ，<span style="color:#444444;">写 </span><span style="color:#444444;">1 </span><span style="color:#444444;">的时候开始转换，写 </span><span style="color:#444444;">0 </span><span style="color:#444444;">的时候停止转换，</span></p> 
<p style="margin-left:0pt;"><span style="color:#444444;">这个是最简单也是最好理解的开启 </span><span style="color:#444444;">ADC </span><span style="color:#444444;">转换的控制方式，理解起来没啥技术含量</span> 。<span style="color:#444444;">除了这种庶民式的控制方法， </span><span style="color:#444444;">ADC </span><span style="color:#444444;">还支持触发转换，这个触发包括内部定时器触发和</span><br><span style="color:#444444;">外部 </span><span style="color:#444444;">IO </span><span style="color:#444444;">触发。触发源有很多，具体选择哪一种触发源，由 </span><span style="color:#444444;">ADC </span><span style="color:#444444;">控制寄存器 </span><span style="color:#444444;">2:ADC_CR2 </span><span style="color:#444444;">的</span><span style="color:#444444;">EXTSEL[2:0]</span><span style="color:#444444;">和 </span><span style="color:#444444;">JEXTSEL[2:0]</span><span style="color:#444444;">位来控制。 </span><span style="color:#444444;">EXTSEL[2:0]</span><span style="color:#444444;">用于选择规则通道的触发源，</span><span style="color:#444444;">JEXTSEL[2:0]</span><span style="color:#444444;">用于选择注入通道的触发源。选定好触发源之后，触发源是否要激活，则由</span><span style="color:#444444;">ADC </span><span style="color:#444444;">控制寄存器 </span><span style="color:#444444;">2:ADC_CR2 </span><span style="color:#444444;">的 </span><span style="color:#444444;">EXTTRIG </span><span style="color:#444444;">和 </span><span style="color:#444444;">JEXTTRIG </span><span style="color:#444444;">这两位来激活。其中 </span><span style="color:#444444;">ADC3 </span><span style="color:#444444;">的规则转换和注入转换的触发源与 </span><span style="color:#444444;">ADC1/2 </span><span style="color:#444444;">的有所不同，在框图上已经表示出来</span><span style="color:#000000;">。</span> </p> 
<h4><strong><a name="_Toc20062"></a><strong><strong>5.1.5 </strong></strong><strong><strong>⑤转换时间 </strong></strong></strong></h4> 
<p style="margin-left:0pt;"><strong><span style="color:#000000;"><strong>ADC </strong></span></strong><span style="color:#000000;">时钟</span> </p> 
<p style="margin-left:0pt;">ADC是挂载在APB2,即ADC的时钟是由PCLK2（72MHZ）分频产生的，最大时14MHZ，<span style="color:#000000;">RCC </span><span style="color:#000000;">时钟配置寄存器 </span><span style="color:#000000;">RCC_CFGR </span><span style="color:#000000;">的位 </span><span style="color:#000000;">15:14 ADCPRE[1:0]</span><span style="color:#000000;">设置，可以是 </span><span style="color:#000000;">2/4/6/8 </span><span style="color:#000000;">分频</span> </p> 
<p style="margin-left:0pt;">采样时间</p> 
<p style="margin-left:0pt;">ADC使用若干个<span style="color:#000000;">ADC_CLK </span><span style="color:#000000;">周期</span> 对电压进行采样的，那么每一个通道的采样周期数时通过什么来控制的呢，是通过<span style="color:#000000;">ADC_SMPR1 </span><span style="color:#000000;">和 </span><span style="color:#000000;">ADC_SMPR2 </span><span style="color:#000000;">中的 </span><span style="color:#000000;">SMP[2:0]</span><span style="color:#000000;">位设置</span> ，<span style="color:#000000;">ADC_SMPR2 </span><span style="color:#000000;">控制的是通道 </span><span style="color:#000000;">0~9</span><span style="color:#000000;">， </span><span style="color:#000000;">ADC_SMPR1 </span><span style="color:#000000;">控制的是通道 </span><span style="color:#000000;">10~17</span><span style="color:#000000;">。</span> <span style="color:#000000;">每个通道可以分别用不同的时间采样。其中采样周期最小是 </span><span style="color:#000000;">1.5 </span><span style="color:#000000;">个，即如果我们要达到最快的采样，那么应该设置采样周期为 </span><span style="color:#000000;">1.5</span><span style="color:#000000;">个周期</span> </p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">ADC </span><span style="color:#000000;">的转换时间跟 </span><span style="color:#000000;">ADC </span><span style="color:#000000;">的输入时钟和采样时间有关，公式为： </span><span style="color:#444444;">Tconv = </span><span style="color:#444444;">采样时间 </span><span style="color:#444444;">+</span><br><span style="color:#444444;">12.5 </span><span style="color:#444444;">个周期。 当 </span><span style="color:#444444;">ADCLK = 14MHZ </span><span style="color:#444444;">（最高），采样时间设置为 </span><span style="color:#444444;">1.5 </span><span style="color:#444444;">周期（最快），那么总的转换时间（最短） </span><span style="color:#444444;">Tconv = 1.5 </span><span style="color:#444444;">周期 </span><span style="color:#444444;">+ 12.5 </span><span style="color:#444444;">周期 </span><span style="color:#444444;">= 14 </span><span style="color:#444444;">周期 </span><span style="color:#444444;">= 1us</span><span style="color:#444444;">。</span> </p> 
<p style="margin-left:0pt;"><span style="color:#444444;">一般我们设置 </span><span style="color:#444444;">PCLK2=72M</span><span style="color:#444444;">，经过 </span><span style="color:#444444;">ADC </span><span style="color:#444444;">预分频器能分频到最大的时钟只能是 </span><span style="color:#444444;">12M</span><span style="color:#444444;">，采</span><br><span style="color:#444444;">样周期设置为 </span><span style="color:#444444;">1.5 </span><span style="color:#444444;">个周期，算出最短的转换时间为 </span><span style="color:#444444;">1.17us</span><span style="color:#444444;">，这个才是最常用的</span><span style="color:#000000;">。</span> </p> 
<h4><strong><a name="_Toc20579"></a><strong><strong>5.1.6 </strong></strong><strong><strong>⑥数据寄存器 </strong></strong></strong></h4> 
<p style="margin-left:0pt;"><span style="color:#444444;">一切准备就绪后， </span><span style="color:#444444;">ADC </span><span style="color:#444444;">转换后的数据根据转换组的不同，规则组的数据放在 </span><span style="color:#444444;">ADC_DR</span><br><span style="color:#444444;">寄存器，注入组的数据放在 </span><span style="color:#444444;">JDRx</span><span style="color:#444444;">。</span> 这里，我们聊聊规则组，如果日后用到注入组的话，自己再去细看。</p> 
<p style="margin-left:0pt;">ADC规则数据寄存器(ADC_DR)</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2b/ff/uQD3DjrZ_o.png"></p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">这里呢，我们可以看到，<span style="color:#444444;">ADC </span><span style="color:#444444;">规则组数据寄存器 </span><span style="color:#444444;">ADC_DR </span><span style="color:#444444;">只有一个，是一个 </span><span style="color:#444444;">32 </span><span style="color:#444444;">位的寄存器，低 </span><span style="color:#444444;">16 </span><span style="color:#444444;">位在单 </span><span style="color:#444444;">ADC</span><span style="color:#444444;">时使用，高 </span><span style="color:#444444;">16 </span><span style="color:#444444;">位是在 </span><span style="color:#444444;">ADC1 </span><span style="color:#444444;">中双模式下保存 </span><span style="color:#444444;">ADC2 </span><span style="color:#444444;">转换的规则数据，双模式就是 </span><span style="color:#444444;">ADC1 </span><span style="color:#444444;">和</span><span style="color:#444444;">ADC2 </span><span style="color:#444444;">同时使用。在单模式下， </span><span style="color:#444444;">ADC1/2/3 </span><span style="color:#444444;">都不使用高 </span><span style="color:#444444;">16 </span><span style="color:#444444;">位。因为 </span><span style="color:#444444;">ADC </span><span style="color:#444444;">的精度是 </span><span style="color:#444444;">12 </span><span style="color:#444444;">位，无论 </span><span style="color:#444444;">ADC_DR </span><span style="color:#444444;">的高 </span><span style="color:#444444;">16 </span><span style="color:#444444;">或者低 </span><span style="color:#444444;">16 </span><span style="color:#444444;">位都放不满，只能左对齐或者右对齐，具体是以哪一种方式存放，由 </span><span style="color:#444444;">ADC_CR2 </span><span style="color:#444444;">的 </span><span style="color:#444444;">11 </span><span style="color:#444444;">位 </span><span style="color:#444444;">ALIGN </span><span style="color:#444444;">设置。</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">规则通道可以有 </span><span style="color:#000000;">16 </span><span style="color:#000000;">个这么多，可规则数据寄存器只有一个， 如果使用多通道转换， 那</span><br><span style="color:#000000;">转换的数据就全部都挤在了 </span><span style="color:#000000;">DR </span><span style="color:#000000;">里面，前一个时间点转换的通道数据，就会被下一个时间点的另外一个通道转换的数据覆盖掉，所以当通道转换完成后就应该把数据取走，或者开启 </span><span style="color:#000000;">DMA </span><span style="color:#000000;">模式，把数据传输到内存里面，不然就会造成数据的覆盖。 最常用的做法就是开启 </span><span style="color:#000000;">DMA </span><span style="color:#000000;">传输。</span> </p> 
<p style="margin-left:0pt;">while(!ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC )); //等待 <span style="color:#000000;">前一个时间点转换的通道数据</span><span style="color:#000000;">转换完成</span></p> 
<p style="margin-left:0pt;"> data_adc[0]=ADC_GetConversionValue(ADC1);</p> 
<h4><strong><a name="_Toc6709"></a><strong><strong>5.1.7 </strong></strong><strong><strong>⑦中断 </strong></strong></strong></h4> 
<p style="margin-left:0pt;">数据转换完成后，可以产生3种中断，<span style="color:#000000;">中断分为三种：</span> 规则通道转换结束中断，注入通道转换结束中断，模拟看门口中断，其中转换结束中断好理解，他有<span style="color:#000000;">中断标志位</span><span style="color:#000000;">（</span><span style="color:#000000;">中断触发，状态位发送变化</span><span style="color:#000000;">）</span><span style="color:#000000;">和中断使能位</span><span style="color:#000000;">（</span><span style="color:#000000;">开启此中断</span><span style="color:#000000;">），</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">模拟看门狗中断</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">当被 </span><span style="color:#000000;">ADC </span><span style="color:#000000;">转换的模拟电压低于低阈值或者高于高阈值时，就会产生中断，前提是我</span><br><span style="color:#000000;">们开启了模拟看门狗中断，其中低阈值和高阈值由 </span><span style="color:#000000;">ADC_LTR </span><span style="color:#000000;">和 </span><span style="color:#000000;">ADC_HTR </span><span style="color:#000000;">设置。例如我们设置高阈值是 </span><span style="color:#000000;">2.5V</span><span style="color:#000000;">，那么模拟电压超过 </span><span style="color:#000000;">2.5V </span><span style="color:#000000;">的时候，就会产生模拟看门狗中断，反之低阈值也一样。</span>  </p> 
<p style="margin-left:0pt;"><strong><span style="color:#000000;"><strong>DMA </strong></span></strong><span style="color:#000000;">请求</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">规则和注入通道转换结束后，除了产生中断外，还可以产生 </span><span style="color:#000000;">DMA </span><span style="color:#000000;">请求，把转换好的</span><br><span style="color:#000000;">数据直接存储在内存里面。要注意的是只有 </span><span style="color:#000000;">ADC1 </span><span style="color:#000000;">和 </span><span style="color:#000000;">ADC3 </span><span style="color:#000000;">可以产生 </span><span style="color:#000000;">DMA </span><span style="color:#000000;">请求。</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">有关</span><span style="color:#000000;">DMA </span><span style="color:#000000;">请求需要配合《 </span><span style="color:#000000;">STM32F10X-</span><span style="color:#000000;">中文参考手册》 </span><span style="color:#000000;">DMA </span><span style="color:#000000;">控制器这一章节来学习。一般我们在使用 </span><span style="color:#000000;">ADC </span><span style="color:#000000;">的时候都会开启 </span><span style="color:#000000;">DMA </span><span style="color:#000000;">传输</span> </p> 
<h4><strong><a name="_Toc31760"></a><strong><strong>5.1.8 </strong></strong><strong><strong>⑧电压转换 </strong></strong></strong></h4> 
<p style="margin-left:0pt;">我们采集到的是数字电压，那么我们需要把数字电压转化位真实的模拟电压，比如，我们我们的ADC的基准电压是3.3V，而我们的ADC是12位的精准度，那么12位的量程是2^12=4096，那么最小单元就是3.3/4096，如果采集到数字电压是X，那么转化位模拟电压就是(3.3/4096)*X</p> 
<p style="margin-left:0pt;"><a name="_Toc19383"></a><strong><strong>5.2 </strong></strong><strong><strong>ADC </strong></strong><strong><strong>初始化结构体详解</strong></strong> </p> 
<p style="margin-left:0pt;"><span style="color:#2b91af;">typedef </span><span style="color:#0000ff;">struct</span><br><span style="color:#2b91af;">2 </span><span style="color:#000000;">{<!-- --></span><br><span style="color:#2b91af;">3 </span><span style="color:#0000ff;">uint32_t </span><span style="color:#000000;">ADC_Mode; </span><span style="color:#008000;">// ADC </span><span style="color:#008000;">工作模式选择</span><br><span style="color:#2b91af;">4 </span><span style="color:#000000;">FunctionalState ADC_ScanConvMode; </span><span style="color:#008000;">/* ADC </span><span style="color:#008000;">扫描（多通道）</span><br><span style="color:#2b91af;">5 </span><span style="color:#008000;">或者单次（单通道）模式选择 </span><span style="color:#008000;">*/</span><br><span style="color:#2b91af;">6 </span><span style="color:#000000;">FunctionalState ADC_ContinuousConvMode; </span><span style="color:#008000;">// ADC </span><span style="color:#008000;">单次转换或者连续转换选择</span><br><span style="color:#2b91af;">7 </span><span style="color:#0000ff;">uint32_t </span><span style="color:#000000;">ADC_ExternalTrigConv; </span><span style="color:#008000;">// ADC </span><span style="color:#008000;">转换触发信号选择</span><br><span style="color:#2b91af;">8 </span><span style="color:#0000ff;">uint32_t </span><span style="color:#000000;">ADC_DataAlign; </span><span style="color:#008000;">// ADC </span><span style="color:#008000;">数据寄存器对齐格式</span><br><span style="color:#2b91af;">9 </span><span style="color:#0000ff;">uint8_t </span><span style="color:#000000;">ADC_NbrOfChannel; </span><span style="color:#008000;">// ADC </span><span style="color:#008000;">采集通道数</span><br><span style="color:#2b91af;">10 </span><span style="color:#000000;">} ADC_InitTypeDef;</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">ADC_Mode</span><span style="color:#000000;">：</span><span style="color:#000000;">配置 </span><span style="color:#000000;">ADC </span><span style="color:#000000;">的模式，当使用一个 </span><span style="color:#000000;">ADC </span><span style="color:#000000;">时是独立模式，使用两个 </span><span style="color:#000000;">ADC </span><span style="color:#000000;">时</span><br><span style="color:#000000;">是双模式，在双模式下还有很多细分模式可选，我们一般使用一个 </span><span style="color:#000000;">ADC </span><span style="color:#000000;">的独立模式。</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;"> ADC_ScanConvMode</span><span style="color:#000000;">：</span><span style="color:#000000;">可选参数为 </span><span style="color:#000000;">ENABLE </span><span style="color:#000000;">和 </span><span style="color:#000000;">DISABLE</span><span style="color:#000000;">，配置是否使用扫描。如果是单通道 </span><span style="color:#000000;">AD </span><span style="color:#000000;">转换使用 </span><span style="color:#000000;">DISABLE</span><span style="color:#000000;">，如果是多通道 </span><span style="color:#000000;">AD </span><span style="color:#000000;">转换使用 </span><span style="color:#000000;">ENABLE</span><span style="color:#000000;">。</span> 也就是连续不连续。</p> 
<p style="margin-left:0pt;"><span style="color:#000000;">ADC_ContinuousConvMode</span><span style="color:#000000;">：</span><span style="color:#000000;">可选参数为 </span><span style="color:#000000;">ENABLE </span><span style="color:#000000;">和 </span><span style="color:#000000;">DISABLE</span><span style="color:#000000;">，配置是启动自动连</span><br><span style="color:#000000;">续转换还是单次转换。使用 </span><span style="color:#000000;">ENABLE </span><span style="color:#000000;">配置为使能自动连续转换；使用 </span><span style="color:#000000;">DISABLE </span><span style="color:#000000;">配置为单次转换，转换一次后停止需要手动控制才重新启动转换。一般设置为连续转换。</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">ADC_ExternalTrigConv</span><span style="color:#000000;">：</span><span style="color:#000000;">外部触发选择， 图 </span><span style="color:#000000;">30-1 </span><span style="color:#000000;">中列举了很多外部触发条件，可根据</span><br><span style="color:#000000;">项目需求配置触发来源。实际上，我们一般使用软件自动触发</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">ADC_DataAlign</span><span style="color:#000000;">：</span><span style="color:#000000;">转换结果数据对齐模式，可选右对齐 </span><span style="color:#000000;">ADC_DataAlign_Right </span><span style="color:#000000;">或者左</span><br><span style="color:#000000;">对齐 </span><span style="color:#000000;">ADC_DataAlign_Left</span><span style="color:#000000;">。一般我们选择右对齐模式。</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">ADC_NbrOfChannel</span><span style="color:#000000;">：</span><span style="color:#000000;">AD </span><span style="color:#000000;">转换通道数目，根据实际设置即可。</span> </p> 
<h3><strong><a name="_Toc9103"></a><strong><strong>5.3 编程要点</strong></strong></strong></h3> 
<p style="margin-left:0pt;">（1）初始化ADC用到的GPIO</p> 
<p style="margin-left:0pt;">（2）初始化ADC，就是填充结构体</p> 
<p style="margin-left:0pt;">（3）设置好ADC的时钟</p> 
<p style="margin-left:0pt;">（4）设置采样通道的顺序和采样的时间</p> 
<p style="margin-left:0pt;">（5）配置使能 ADC 转换完成中断，在中断内读取转换完数据；</p> 
<p style="margin-left:0pt;">（6）使能ADC</p> 
<p style="margin-left:0pt;">（7）使能软件触发 ADC 转换。 </p> 
<p style="margin-left:0pt;">如果要是想开启DMA,还是需要去设置一下的</p> 
<ol><li><strong><a name="_Toc5205"></a> <strong><strong>说完了ADC，就在说下，ARM公司设计的DMA,</strong></strong></strong></li></ol> 
<p style="margin-left:0pt;">我们大家都知道，STM32是单片机，就是说只有一个大脑，那么在跑起程序多少比较乏力，那么ARM公司出厂的时候就设计了DMA，可以把DMA看成内核的小弟，只要内核大哥发送一天指令就可以交给一些事情给DMA来做，这样CPU就有时间来做其他的事情，有点类似于多线程，极大的利用的CPU资源，提高速率。</p> 
<p style="margin-left:0pt;"> </p> 
<h3><strong><a name="_Toc13065"></a><strong><strong>6.1简介：</strong></strong></strong></h3> 
<p style="margin-left:0pt;">DMA(直接存储器存取)，他是单片机外设，他的主要功能就是帮助CPU来搬运数据，但是不需要CPU,DMA支持从（外设数据寄存器-存储器）、（存储器-存储器），这里的存储器可以是SRAM和FLASH。只要两个DMA,其中DMA1有7个通道，DMA2有5个通道，这里的管道可以理解为传输数据的通道，<span style="color:#000000;">要注意的是 </span><span style="color:#000000;">DMA2 </span><span style="color:#000000;">只存在于大容量的单片机中</span> 。</p> 
<h3><strong><a name="_Toc13831"></a><strong><strong>6.2 要想真正的了解一个外设，必要看懂他的原理框图</strong></strong></strong></h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ea/51/O0XsaoRx_o.png"></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">①</span><span style="color:#000000;">DMA </span><span style="color:#000000;">请求</span> </p> 
<p style="margin-left:0pt;">如果外设想通过DMA发送数据，首先外设需要给DMA发送请求，然后DMA收到请求后应答外设后，才可以启动DMA传输，知道传输完毕</p> 
<p style="margin-left:0pt;">不同外设想通过DMA传输都是有固定的通道的，所以说，DMA通道是核心，那么具体对应的是：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/68/3d/uCfTAjUE_o.png"></p> 
<p style="margin-left:0pt;">这里要注意的是虽然每个通道可以接收多个外设的请求，但是同一时间只能接收一个，不能同时接收多个。</p> 
<p style="margin-left:0pt;"><span style="color:#000000;">②仲裁器</span> </p> 
<p style="margin-left:0pt;">先不说</p> 
<h3><strong><a name="_Toc14634"></a><strong><strong>6.3 我们在使用DMA的时候，我们会考虑的：</strong></strong></strong></h3> 
<p style="margin-left:0pt;">6.3.1 数据的传输方向，（这个传输的方向也是由DMA_CCRX的位4）</p> 
<p style="margin-left:0pt;"><span style="color:#000000;">1.</span><span style="color:#000000;">外设到存储器</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">当我们使用从外设到存储器传输时，以 </span><span style="color:#000000;">ADC </span><span style="color:#000000;">采集为例。 </span><span style="color:#000000;">DMA </span><span style="color:#000000;">外设寄存器的地址对应的就是 </span><span style="color:#000000;">ADC </span><span style="color:#000000;">数据寄存器的地址， </span><span style="color:#000000;">DMA </span><span style="color:#000000;">存储器的地址就是我们自定义的变量（用来接收存储 </span><span style="color:#000000;">AD </span><span style="color:#000000;">采集的数据） 的地址。 方向我们设置外设为源地址。</span>  2 <span style="color:#000000;">存储器到外设</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">当我们使用从存储器到外设传输时，以串口向电脑端发送数据为例。 </span><span style="color:#000000;">DMA </span><span style="color:#000000;">外设寄存器的地址对应的就是串口数据寄存器的地址， </span><span style="color:#000000;">DMA </span><span style="color:#000000;">存储器的地址就是我们自定义的变量（相当于一个缓冲区，用来存储通过串口发送到电脑的数据） 的地址。方向我们设置外设为目标地址。</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">3.</span><span style="color:#000000;">存储器到存储器</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">当我们使用从存储器到存储器传输时，以内部 </span><span style="color:#000000;">FLASH </span><span style="color:#000000;">向内部 </span><span style="color:#000000;">SRAM </span><span style="color:#000000;">复制数据为例。</span><span style="color:#000000;">DMA </span><span style="color:#000000;">外设寄存器的地址对应的就是内部 </span><span style="color:#000000;">FLASH</span><span style="color:#000000;">（我们这里把内部 </span><span style="color:#000000;">FALSH </span><span style="color:#000000;">当作一个外设来看） 的地址， </span><span style="color:#000000;">DMA </span><span style="color:#000000;">存储器的地址就是我们自定义的变量（相当于一个缓冲区，用来存储来自内部 </span><span style="color:#000000;">FLASH </span><span style="color:#000000;">的数据）的地址。 方向我们设置外设（即内部 </span><span style="color:#000000;">FLASH</span><span style="color:#000000;">） 为源地址。 跟上面两个不一样的是，这里需要把 </span><span style="color:#000000;">DMA_CCR </span><span style="color:#000000;">位 </span><span style="color:#000000;">14</span><span style="color:#000000;">： </span><span style="color:#000000;">MEM2MEM</span><span style="color:#000000;">：存储器到存储器模式配置为 </span><span style="color:#000000;">1</span><span style="color:#000000;">，启动 </span><span style="color:#000000;">M2M </span><span style="color:#000000;">模式。</span> </p> 
<h4><strong><a name="_Toc20250"></a><strong><strong>6.3.2 </strong></strong><strong><strong>要传多少，单位是什么 </strong></strong><strong><strong>，</strong></strong><strong><strong>什么时候传输完成 </strong></strong><strong> </strong></strong></h4> 
<p style="margin-left:0pt;"><span style="color:#000000;">当我们配置好数据要从哪里来到哪里去之后，我们还需要知道我们要传输的数据是多少，数据的单位是什么。</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">（</span><span style="color:#000000;">1</span><span style="color:#000000;">）</span><span style="color:#000000;">传多少</span></p> 
<p style="margin-left:0pt;"> 首先，我们要传多少的数据量，这里呢，有一个寄存器<span style="color:#000000;">DMA_CNDTR </span><span style="color:#000000;">配置，这是一个 </span><span style="color:#000000;">32 </span><span style="color:#000000;">位的寄存器，一次最多只能传输 </span><span style="color:#000000;">65535 </span><span style="color:#000000;">个数据。</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">（</span><span style="color:#000000;">2</span><span style="color:#000000;">）</span><span style="color:#000000;">传输的数据宽度</span> </p> 
<p style="margin-left:0pt;">其次，要是想传输的数据是正确的，源和目标的数据宽度要是一样的，比如说，串口的寄存器的数据宽度是8位，那么我们如果以串口为源的时候，那么目标的区的数据宽度就也要是8位。   这里呢，无论是外设还是自己开辟的目标地址的数据都会分别放到DMA的两个32位的寄存器当中，但是数据的宽度是由：<span style="color:#000000;">外设的数据宽度由 </span><span style="color:#000000;">DMA_CCRx </span><span style="color:#000000;">的</span><span style="color:#000000;">PSIZE[1:0]</span><span style="color:#000000;">配置，可以是 </span><span style="color:#000000;">8/16/32 </span><span style="color:#000000;">位，存储器的数据宽度由 </span><span style="color:#000000;">DMA_CCRx </span><span style="color:#000000;">的 </span><span style="color:#000000;">MSIZE[1:0]</span><span style="color:#000000;">配置，可以是 </span><span style="color:#000000;">8/16/32 </span><span style="color:#000000;">位。</span> </p> 
<p style="margin-left:0pt;">（3）源和目标的地址的偏移</p> 
<p style="margin-left:0pt;"><span style="color:#000000;">在 </span><span style="color:#000000;">DMA </span><span style="color:#000000;">控制器的控制下，数据要想有条不紊的从一个地方搬到另外一个地方，还必须正确设置两边数据指针的增量模式。 外设的地址指针由 </span><span style="color:#000000;">DMA_CCRx </span><span style="color:#000000;">的 </span><span style="color:#000000;">PINC </span><span style="color:#000000;">配置，存储器的地址指针由 </span><span style="color:#000000;">MINC </span><span style="color:#000000;">配置。 以串口向电脑发送数据为例，要发送的数据很多，每发送完一个，那么存储器的地址指针就应该加 </span><span style="color:#000000;">1</span><span style="color:#000000;">，而串口数据寄存器只有一个，那么外设的地址指针就固定不变。具体的数据指针的增量模式由实际情况决定。</span>  </p> 
<ol><li><span style="color:#000000;">数据什么时候传输完成，我们可以通过</span><span style="color:#0000ff;">查询标志位</span><span style="color:#000000;">或者通过</span><span style="color:#0000ff;">中断的方式</span><span style="color:#000000;">来鉴别。 每个</span><span style="color:#000000;">DMA </span><span style="color:#000000;">通道在 </span><span style="color:#000000;">DMA </span><span style="color:#0000ff;">传输过半</span><span style="color:#000000;">、</span><span style="color:#0000ff;">传输完成</span><span style="color:#000000;">和</span><span style="color:#0000ff;">传输错误</span><span style="color:#000000;">时都会有相应的标志位，如果使能了该类型的中断后，则会产生中断。关各个标志位的详细描述请参考 </span><span style="color:#000000;">DMA </span><span style="color:#000000;">中断状态寄存器</span><span style="color:#000000;">DMA_ISR </span><span style="color:#000000;">的详细描述。</span> 最大通道7</li></ol> 
<h3><strong><a name="_Toc9263"></a><strong><strong>6.4 </strong></strong><strong><strong>DMA </strong></strong><strong><strong>初始化结构体详解 </strong></strong></strong></h3> 
<p style="margin-left:0pt;"><span style="color:#2b91af;">1 typedef </span><span style="color:#0000ff;">struct</span><br><span style="color:#2b91af;">2 </span><span style="color:#000000;">{<!-- --></span><br><span style="color:#2b91af;">3 </span><span style="color:#0000ff;">uint32_t </span><span style="color:#000000;">DMA_PeripheralBaseAddr; </span><span style="color:#008000;">// </span><span style="color:#008000;">外设地址</span><br><span style="color:#2b91af;">4 </span><span style="color:#0000ff;">uint32_t </span><span style="color:#000000;">DMA_MemoryBaseAddr; </span><span style="color:#008000;">// </span><span style="color:#008000;">存储器地址</span><br><span style="color:#2b91af;">5 </span><span style="color:#0000ff;">uint32_t </span><span style="color:#000000;">DMA_DIR; </span><span style="color:#008000;">// </span><span style="color:#008000;">传输方向</span><br><span style="color:#2b91af;">6 </span><span style="color:#0000ff;">uint32_t </span><span style="color:#000000;">DMA_BufferSize; </span><span style="color:#008000;">// </span><span style="color:#008000;">传输数目</span><br><span style="color:#2b91af;">7 </span><span style="color:#0000ff;">uint32_t </span><span style="color:#000000;">DMA_PeripheralInc; </span><span style="color:#008000;">// </span><span style="color:#008000;">外设地址增量模式</span><br><span style="color:#2b91af;">8 </span><span style="color:#0000ff;">uint32_t </span><span style="color:#000000;">DMA_MemoryInc; </span><span style="color:#008000;">// </span><span style="color:#008000;">存储器地址增量模式</span><br><span style="color:#2b91af;">9 </span><span style="color:#0000ff;">uint32_t </span><span style="color:#000000;">DMA_PeripheralDataSize; </span><span style="color:#008000;">// </span><span style="color:#008000;">外设数据宽度</span><br><span style="color:#2b91af;">10 </span><span style="color:#0000ff;">uint32_t </span><span style="color:#000000;">DMA_MemoryDataSize; </span><span style="color:#008000;">// </span><span style="color:#008000;">存储器数据宽度</span><br><span style="color:#2b91af;">11 </span><span style="color:#0000ff;">uint32_t </span><span style="color:#000000;">DMA_Mode; </span><span style="color:#008000;">// </span><span style="color:#008000;">模式选择</span><br><span style="color:#2b91af;">12 </span><span style="color:#0000ff;">uint32_t </span><span style="color:#000000;">DMA_Priority; </span><span style="color:#008000;">// </span><span style="color:#008000;">通道优先级</span><br><span style="color:#2b91af;">13 </span><span style="color:#0000ff;">uint32_t </span><span style="color:#000000;">DMA_M2M; </span><span style="color:#008000;">// </span><span style="color:#008000;">存储器到存储器模式</span><br><span style="color:#2b91af;">14 </span><span style="color:#000000;">} DMA_InitTypeDef;</span> </p> 
<p style="margin-left:0pt;"><span style="color:#000000;">DMA_InitTypeDef DMA_InitStructures;</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">DMA_DeInit(DMA1_Channel4);    //将通道一寄存器设为默认值</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">DMA_InitStructures.DMA_PeripheralBaseAddr=(u32)&amp;USART1-&gt;DR;//USART1外设地址：USART1-&gt;DR</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">DMA_InitStructures.DMA_PeripheralDataSize=DMA_PeripheralDataSize_Byte;//外设数据宽度--8位</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">DMA_InitStructures.DMA_MemoryBaseAddr=(u32)send_val;//缓存区地址（存储器地址）</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">DMA_InitStructures.DMA_MemoryDataSize=DMA_MemoryDataSize_Byte;//缓存区地址宽度--8位</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">DMA_InitStructures.DMA_BufferSize=sizeof(send_val)/sizeof(u8);//传输的数据量--20个</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">DMA_InitStructures.DMA_DIR=DMA_DIR_PeripheralDST;//DMA传输方向--外设作为目标</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">DMA_InitStructures.DMA_M2M=DMA_M2M_Disable;//存储器到存储器</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">DMA_InitStructures.DMA_MemoryInc=DMA_MemoryInc_Enable;//内存地址递增</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">DMA_InitStructures.DMA_PeripheralInc=DMA_PeripheralInc_Disable;//外设地址保持不变</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">DMA_InitStructures.DMA_Mode=DMA_Mode_Normal;//单次转换</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">DMA_InitStructures.DMA_Priority=DMA_Priority_High;//优先级</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">DMA_Init(DMA1_Channel4,&amp;DMA_InitStructures);//DMA1_IN4初始化</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">DMA_Cmd(DMA1_Channel4, ENABLE);//启动DMA通道1</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">USART_DMACmd(USART1,USART_DMAReq_Tx,ENABLE);</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">//传输出错中断</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">DMA_ITConfig(DMA1_Channel4,DMA_IT_TE,ENABLE);</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">NVIC_SetPriority(DMA1_Channel4_IRQn,7);</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">NVIC_EnableIRQ(DMA1_Channel4_IRQn); </span></p> 
<h3><strong><a name="_Toc16749"></a><strong><strong>6.5 编程要点</strong></strong></strong></h3> 
<p style="margin-left:0pt;"><span style="color:#000000;">（1）使能DMA时钟</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">（2）配置DMA,即填充核心结构体</span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">（3）使能 </span><span style="color:#000000;">DMA</span><span style="color:#000000;">，进行传输； </span></p> 
<p style="margin-left:0pt;"><span style="color:#000000;">（4）等待传输完成，并对源数据和目标地址数据进行比较 </span></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fced79b45f544def740cb625fe8f97ae/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何在Microsoft白板上进行协作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bdf79fd12a205a7cdf1a11214595eb83/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Policy gradient(策略梯度详解)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>