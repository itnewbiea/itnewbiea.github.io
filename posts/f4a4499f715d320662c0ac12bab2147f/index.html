<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——排序 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构——排序" />
<meta property="og:description" content="排序 排序就是重新排列表中的元素，使得表中的元素满足按关键字有序的过程，为了查找方便，通常希望计算机中的表是按关键字有序的。
排序定义:
输入：n个记录 R 1 , R 2 , . . . , R n R_1,R_2,...,R_n R1​,R2​,...,Rn​，对应的关键字为 k 1 , k 2 , . . . , k n k_1,k_2,...,k_n k1​,k2​,...,kn​
输出：输入序列的一个重排 R 1 ′ , R 2 ′ , . . . , R n ′ R_1&#39;,R_2&#39;,...,R_n&#39; R1′​,R2′​,...,Rn′​，使得 k 1 ′ &lt; k 2 ′ &lt; . . . &lt; k n ′ k_1&#39;&lt;k_2&#39;&lt;...&lt;k_n&#39; k1′​&lt;k2′​&lt;...&lt;kn′​（其中小于号可以换成其他符号）
算法稳定性，若待排序表中两个元素a,b其对应的关键字相同，且a在b前面，若在某一算法排序之后，a仍然在b前面(相对位置不变)，则可以说这个算法稳定，若相对位置发生改变，则算法不稳定
稳定性并能评判一个算法的优劣，主要是对算法性质描述，若一个序列中不允许重复元素出现，则稳定性的概念也就不存在了" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f4a4499f715d320662c0ac12bab2147f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-09T16:02:15+08:00" />
<meta property="article:modified_time" content="2022-07-09T16:02:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——排序</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>排序</h2> 
<p>排序就是重新排列表中的元素，使得表中的元素满足按关键字有序的过程，为了查找方便，通常希望计算机中的表是按关键字有序的。</p> 
<blockquote> 
 <p>排序定义:<br> 输入：n个记录<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           R 
          
         
           1 
          
         
        
          , 
         
         
         
           R 
          
         
           2 
          
         
        
          , 
         
        
          . 
         
        
          . 
         
        
          . 
         
        
          , 
         
         
         
           R 
          
         
           n 
          
         
        
       
         R_1,R_2,...,R_n 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.00773em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.00773em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: -0.00773em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，对应的关键字为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           k 
          
         
           1 
          
         
        
          , 
         
         
         
           k 
          
         
           2 
          
         
        
          , 
         
        
          . 
         
        
          . 
         
        
          . 
         
        
          , 
         
         
         
           k 
          
         
           n 
          
         
        
       
         k_1,k_2,...,k_n 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03148em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03148em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: -0.03148em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span><br> 输出：输入序列的一个重排<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           R 
          
         
           1 
          
         
           ′ 
          
         
        
          , 
         
         
         
           R 
          
         
           2 
          
         
           ′ 
          
         
        
          , 
         
        
          . 
         
        
          . 
         
        
          . 
         
        
          , 
         
         
         
           R 
          
         
           n 
          
         
           ′ 
          
         
        
       
         R_1',R_2',...,R_n' 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.248108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -2.45189em; margin-left: -0.00773em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.248108em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -2.45189em; margin-left: -0.00773em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.248108em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -2.453em; margin-left: -0.00773em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.247em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，使得<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           k 
          
         
           1 
          
         
           ′ 
          
         
        
          &lt; 
         
         
         
           k 
          
         
           2 
          
         
           ′ 
          
         
        
          &lt; 
         
        
          . 
         
        
          . 
         
        
          . 
         
        
          &lt; 
         
         
         
           k 
          
         
           n 
          
         
           ′ 
          
         
        
       
         k_1'&lt;k_2'&lt;...&lt;k_n' 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.248108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -2.45189em; margin-left: -0.03148em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.248108em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.248108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -2.45189em; margin-left: -0.03148em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.248108em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.998892em; vertical-align: -0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -2.453em; margin-left: -0.03148em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.247em;"><span class=""></span></span></span></span></span></span></span></span></span></span>（其中小于号可以换成其他符号）</p> 
</blockquote> 
<p><strong>算法稳定性</strong>，若待排序表中两个元素a,b其对应的关键字相同，且a在b前面，若在某一算法排序之后，a仍然在b前面(相对位置不变)，则可以说这个<strong>算法稳定</strong>，若相对位置发生改变，则<strong>算法不稳定</strong><br> <em>稳定性并能评判一个算法的优劣，主要是对算法性质描述，若一个序列中不允许重复元素出现，则稳定性的概念也就不存在了</em><br> 在排序过程中，根据元素是否完全在内存中可分为<strong>内部排序</strong>和<strong>外部排序</strong></p> 
<blockquote> 
 <p>内部排序：是指在排序期间元素全部存放在内存中的排序<br> 外部排序： 是指在排序区间元素无法全部同时存放在内存中，必须在排序过程中根据要求不断的在内、外存之间移动的排序。</p> 
</blockquote> 
<p>在这里我们只讨论内部排序，一般情况下，内部排序都要进行两种操作：<strong>移动和比较</strong>(基数排序除外)<br> 每种算法都有其自身的优劣性，一般我们通过时空复杂度以及稳定性来客观了解每一种算法。时间复杂度一般都是由移动和比较次数决定的。</p> 
<h2><a id="_15"></a>插入排序</h2> 
<p>插入排序是一种简单直观的方法，主要思想是，将无序的元素逐个插入有序序列中，知道全部插入完成。</p> 
<h4><a id="_17"></a>直接插入排序</h4> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  <span class="token comment">//交换两个元素位置</span>
	<span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>a <span class="token operator">^</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
	<span class="token operator">*</span>b <span class="token operator">=</span> <span class="token operator">*</span>a <span class="token operator">^</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
	<span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>a <span class="token operator">^</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>	<span class="token comment">//传入参数为数组地址，以及元素个数</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>		<span class="token comment">//设置有序序列的边界</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span> <span class="token punctuation">)</span>  <span class="token comment">// 取无序序列中第一个数进行比较移动的插入操作</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>			<span class="token comment">//将无序数与有序序列依次比较</span>
				<span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//若满足调教进行交换</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>					<span class="token comment">//因为是有序序列，一旦没有触发交换，说明已经有序，终止比较</span>
			<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>				
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>array<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//输入十个数据</span>
		n<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>				
	<span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> 				<span class="token comment">//对十个数据进行排序</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>	
<span class="token punctuation">}</span> 
</code></pre> 
<p><strong>空间复杂度：<strong>很明显为常数级别，当然我们虽然没有用到中间变量，而是通过异或操作实现<br> <strong>时间复杂度：****最好情况</strong>是有完全有序，所以我们不需要移动，但仍需要遍历整个表进行比较，所以时间复杂度为</strong>O(N)</strong>；<strong>最坏情况</strong>是元素完全逆序，则我们需要进行比较约<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
          
          
            n 
           
          
            2 
           
          
         
           − 
          
         
           n 
          
         
        
          2 
         
        
       
      
        \frac{n^2-n}{2} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.36292em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.01792em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.891314em;"><span class="" style="top: -2.931em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>，移动次数也差不多，所以总的<strong>时间复杂度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
         
         
           n 
          
         
           2 
          
         
        
          ) 
         
        
       
         O(n^2) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></strong>，所以平均情况下为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
        
        
          n 
         
        
          2 
         
        
       
         ) 
        
       
      
        O(n^2) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>。<br> **稳定性：**因为每次插入都是先比较再移动，所以不会出现相同元素相对位置发生改变的现象<br> **适用性：**适合顺序存储和链式存储的线性表(大部分算法都仅适用于此)</p> 
<h4><a id="_56"></a>折半插入排序</h4> 
<p>折半插入排序实际上就是用折半查找的的方法找到插入的位置，然后插入。这样的话，寻找比较的时间变成了O(logn)但是移动的次数仍未发生改变，所以其时间复杂度仍然为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
        
        
          n 
         
        
          2 
         
        
       
         ) 
        
       
      
        O(n^2) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，折半插入排序也是一种稳定排序</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">insert_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>num<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
 <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> key<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>num<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>         <span class="token comment">// 判断当前数据是否需要进行插入</span>
            key <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>       		 <span class="token comment">// 获取需要插入的数据</span>
            low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    				<span class="token comment">// 初始查找范围为 [0, i-1]（有序）</span>
            high <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>			  <span class="token comment">// 进行折半二分算法查找插入的位置</span>
                 mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment">// 获取中间下标</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;=</span> num<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
				   high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 如果key小于中间值，则缩小查找范围到左子序列</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                    low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 如果key大于中间值，则缩小查找范围到右子序列</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 整体后移</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                num<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 插入数据</span>
            num<span class="token punctuation">[</span>high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_86"></a>希尔排序</h4> 
<p>直接插入排序中，我们可以知道当数据完全有序的时候时间复杂度可以从O(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          n 
         
        
          2 
         
        
       
      
        n^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>)提高到O(n),由此可见，在数据基本有序且数据量不大的情况下直接插入排序要更适合。正是基于此，希尔排序有直接插入排序改进而来。也称<strong>缩小增量排序</strong><br> 希尔排序的基本思想</p> 
<blockquote> 
 <p>在一组数据中取一个数字间隔，然后按照所取的增量把数组划分成若干组，然后在组内进行排序，然后取步长值(小于第一次的步长值)，如此往复，直到步长值为1，这时数组已经基本有序，使用直接插入排序<br> 例: 49 38 65 97 76 13 27 49 55 4 ============== 取步长值为5<br> 13 27 49 55 4 49 38 65 97 76 ============ 步长值取3 (下面同一字体样式的数字为一组)<br> <strong>13</strong> <em>4</em> 49 <strong>38</strong> <em>27</em> 49 <strong>55</strong> <em>65</em> 97 <strong>76</strong> ============ 这时已经基本有序取步长值为1，直接插入排序<br> 4 13 27 38 49 49 55 65 76 97</p> 
</blockquote> 
<p>希尔排序代码在此进行实现了(有点懒我之前没打)<br> 空间复杂度：因为希尔排序是组内进行交换所以为O(1)<br> 时间复杂度：这是个玄学问题，还有数学上尚未解决的问题，所以其复杂度在O(n)~O(n<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
        
          2 
         
        
       
      
        ^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class=""></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>)之间<br> 稳定性：很明显在例子中两个49的相对位置就发生了改变，所以是不稳定的<br> 仅适用于线性表为顺序存储的情况</p> 
<h2><a id="_100"></a>交换排序</h2> 
<p>交换排序是指两个元素进行比较然后进行位置交换，基于交换的排序有冒泡排序、快排等…</p> 
<h4><a id="_102"></a>冒泡排序</h4> 
<p>冒泡排序一般来讲会是我们接触排序学习的第一个排序算法，因为他理解以及代码实现都比较简单。</p> 
<blockquote> 
 <p>冒泡排序主要思想:<br> 从前往后或是从后往前两两相互比较，这里以从后往前为例，当后面的数据小于前面的就进行交换，这样完成一次就成功完成把该数组最小的数据放到了数组首位，如此往复此过程防止第二位、第三位…当完成第n-1此排序时，就完成了排序过程。我们可以理解为每一次排序都是在把无序部分最小的元素放到有序数组后面，所以说每一次排序都会确定一个元素的最终位置。</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		bool flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>				<span class="token comment">//加了一个小优化</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> i<span class="token punctuation">;</span> j<span class="token operator">--</span> <span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
				<span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
				flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>			<span class="token comment">//当这次冒泡排序的过程中没有发生交换，则说明数组已然有序可以终止排序</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>空间复杂度：O(1)<br> 时间复杂度：在加了上面优化的情况下，我们可以知道，在最好的情况下，时间复杂度为O(n),当最坏情况完全逆序，时间复杂度为O(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          n 
         
        
          2 
         
        
       
      
        n^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>)，这一点从代码中也很容易看出。其平均复杂度也是O(N<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
        
          2 
         
        
       
      
        ^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class=""></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>)<br> 稳定性：相同元素相对位置并不会发生改变，所是一种稳定排序<br> 而且冒泡排序所形成的子序列是<strong>全局有序</strong>的，即每一次排序都会确定一个数据的位置。</p> 
<h4><a id="_126"></a>快速排序</h4> 
<p>快速排序虽然也是交换排序，但是他的思想却与冒泡排序有很大差异。</p> 
<blockquote> 
 <p>快排的思想：<br> 快排采用的是一种递归的思想，首先要先选定一个基准，然后根据基准把整个数组分为大于它和小于它的两个部分。然后再在分好的子序列中，重新按照刚才的方法选定基准进行快排，如此往复，直至整个序列有序。当然在交换的过程中，基准是与数组头部和尾部交替进行比较交换，最终确定自己的位置，把数组划分为两个部分。因此在选择基准上，找到一个合适的基准可以极大的缩短排序的时间，在我的代码中呢，还是以数组第一个元素为基准</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">q_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>num<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>    <span class="token comment">//传入待排数组指针，以及左边界和右边界</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span> l <span class="token operator">&gt;=</span> r<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>		<span class="token comment">//当左右边界重合或大于时，排序完成(设置递归终止条件)</span>
		<span class="token keyword">return</span> <span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> temp <span class="token operator">=</span> num<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">//设置基准</span>
	<span class="token keyword">int</span> ll <span class="token operator">=</span> l<span class="token punctuation">,</span> rr <span class="token operator">=</span> r<span class="token punctuation">;</span>		<span class="token comment">//存储左右边界</span>

	<span class="token keyword">while</span><span class="token punctuation">(</span>ll <span class="token operator">&lt;</span> rr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>					<span class="token comment">//进行交换过程，基准与数组头部和尾部向里依次比较和交换</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>ll <span class="token operator">&lt;</span> rr <span class="token operator">&amp;&amp;</span> num<span class="token punctuation">[</span>rr<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> temp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			rr<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>ll <span class="token operator">&lt;</span> rr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			num<span class="token punctuation">[</span>ll<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>rr<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">//比基准小的移到左边</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>ll <span class="token operator">&lt;</span> rr <span class="token operator">&amp;&amp;</span> num<span class="token punctuation">[</span>ll<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> temp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			ll<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>ll <span class="token operator">&lt;</span> rr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			num<span class="token punctuation">[</span>rr<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>ll<span class="token punctuation">]</span><span class="token punctuation">;</span>			<span class="token comment">//比基准大的移到右边</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	num<span class="token punctuation">[</span>ll<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>		<span class="token comment">//完成交换后，一次快排完成，确定选定基准在数组中的位置</span>
	<span class="token function">q_sort</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> l<span class="token punctuation">,</span> ll<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">q_sort</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> ll <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>	
	 
<span class="token punctuation">}</span>
</code></pre> 
<p>空间复杂度：因为快排时递归的，所以需要栈来辅助实现，其容量最大深度最坏情况下为O(n);最好情况以及平均情况为O(log<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
        
          2 
         
        
       
         n 
        
       
      
        _2n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class=""></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span></span>)<br> 时间效率：最坏情况下，即在数组完全有序的情况下，时间复杂度为O(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          n 
         
        
          2 
         
        
       
      
        n^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>)，在理想情况下时间复杂度为O(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
         l 
        
       
         o 
        
        
        
          g 
         
        
          2 
         
        
       
         n 
        
       
      
        nlog_2n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span></span>)，即在每次划分子区间的长度都不大于n/2时。<br> 稳定性：快速排序会在排序过程中改变相同大小元素的相对位置，所以时不稳定排序<br> <strong>快速排序时所有内部排序算法中平均性能最优的排序算法</strong><br> 快排在每次基准把表划分两个长度相近的表时，速度最快，当表中本身有序（正序或逆序），速度最慢</p> 
<h2><a id="_164"></a>选择排序</h2> 
<p>选择排序顾名思义，每次都选择表中最大或最小的元素，放到表为或表首。每一趟确定一个元素位置，当进行第n-1趟时完成排序</p> 
<h4><a id="_166"></a>简单选择排序</h4> 
<p>遍历整个数组，选择最小的元素与第一个元素进行交换<br> 在这里也不代码实现了，使用两个for循环，第一个循环时遍历n次。每次确定一个元素位置，第二个循环是表内元素遍历选择最小元素。<br> 空间复杂度：O(1)<br> 时间复杂度：因为用了两层循环很明显是O(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          n 
         
        
          2 
         
        
       
      
        n^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>)<br> 稳定性：在选择排序过程中，可能会改变相同大小元素的相对位置所以是不稳定排序。</p> 
<h4><a id="_172"></a>堆排序(优先队列)</h4> 
<p>堆实际上是用顺序表实现的二叉树，有自己的排序规则。根据规则我们也可以把堆分为<strong>大顶堆</strong>和<strong>小顶堆</strong></p> 
<blockquote> 
 <p>大顶堆 L(i) &gt;= L(2i) &amp;&amp; L(i) &gt;=(2i + 1)<br> 小顶堆 L(i) &lt;= L(2i) &amp;&amp; L(i) &lt;=(2i + 1)<br> 其中1&lt;=i&lt;=n/2<br> 简单讲大顶堆就是满足双亲节点大于自己的孩子节点，小顶堆的双亲节点小于自己的孩子节点<br> <img src="https://images2.imgbox.com/64/30/0Pny77YR_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>堆排序的思想：(大顶堆为例)<br> 首先是先建堆，由于其本身特性，则堆顶元素就是最大值。先输出堆顶元素，然后堆顶数据空了，我们让数组中的最后一位也就是堆底元素送入堆顶，这时候堆的性质不满足，则调整堆，把堆顶向下调整，直至堆再次平衡，然后输出平衡后的堆顶。如此往复，输出的序列则是有序的。<br> 在这个过程中我们可以发现，其实我们需要解决的问题主要是堆的建立和堆的调整两个问题。<br> <img src="https://images2.imgbox.com/30/4e/tiRddfTk_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a <span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>		<span class="token comment">// 反复调整堆，因为采用顺序存储结构，</span>
		<span class="token function">headAdjust</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i <span class="token punctuation">,</span> len<span class="token punctuation">)</span>			  
	<span class="token punctuation">}</span>								      <span class="token comment">// 而且应该自下向上调整</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">headAdjust</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token comment">//函数将元素为k为根的子树进行调整</span>
	a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>							<span class="token comment">//树的顺序存储结构中，我们一般是从下标为1的位置开始存储</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> i <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>       <span class="token comment">//一个双亲节点有两个孩子节点，而且对应顺序存储下标</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>		<span class="token comment">//在两个孩子节点中选取大的元素</span>
			i<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>				<span class="token comment">//如果当前子树根节点大于两个孩子节点则说明有序，无需调整</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
			a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>					<span class="token comment">//如需要调整，把数值大的记录在根节点</span>
			k <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>						<span class="token comment">// 再把根节点数据记录到当前孩子节点，完成调整</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token function">buildMaxHeap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 建堆</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len<span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>	<span class="token comment">// 排序过程</span>
		<span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">heapAdjust</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 排序时破坏了堆，所以调整堆</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>在排序过程中，从代码中我们可以看到，只是从后往前遍历了整个数组，然后与堆顶进行了交换。那么其排序的原理就是我们采用的是顺序存储结构，且我们实现的是大顶堆，所以堆顶一定是数值最大的应该在数组最后，当交换完成后，数组从后往前依次有序，则有序的部分已经有序不再进行任何操作，所以，在对堆调整的函数传参的时候我们传入的右边界也是动态的。而在交换之后，堆已经被破坏，所以，我们需要重新调整堆，使得其重新成为大顶堆，则再重复上述过程，到最后我们会得到一棵有序的数组。即将堆进行分层遍历得到的序列是从小到大排列</p> 
</blockquote> 
<p><strong>空间复杂度</strong>：我们仅仅再调整堆的时候使用了，顺序表的未使用空间。所以为O(1)<br> <strong>时间复杂度</strong>：建堆的过程为O(n)，之后又进行了n-1次向下调整的操作，每次调整的时间与高度有关，所以为O(h)，所以在最好，最坏和平均情况下，堆排序的时间复杂度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         l 
        
       
         o 
        
        
        
          g 
         
        
          2 
         
        
       
         n 
        
       
         ) 
        
       
      
        O(log_2n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span><br> <strong>稳定性</strong>：进行堆排序的时候有可能会改变相同数值元素的相对位置，所以，是一个不稳定排序</p> 
<h2><a id="_221"></a>归并排序</h2> 
<p>归并排序与上述的排序方式思想不一样，“归并”是指，将两个或连个以上的有序表组合成一个新的有序表。就像是那个奥利奥的消息一样，一个人拿“奥”， 一个人拿“利”，先自己把自己的“奥”和“利”从小到大拍好，然后两个人再依次拿出来比较当前“奥”和“利”的大小然后依次排序。</p> 
<p>归并排序的话可能看起来有一点快排的影子，快排是把一个大序列逐渐化成小序列，而归并排序是先把其划成小序列，然后两两归并成大序列。</p> 
<blockquote> 
 <p>归并排序：<br> 假设待排列表中有n个元素，我们可以视为有n个有序的子表，每个子表长度为1，然后两两归并，得到n/2个长度1或2的有序表，然后继续两两归并，直到成为一个长度为n有序表。<br> 如下表排序过程：<br> [49] [38] [65] [97] [76] [13] [27] ===n个子表<br> [38 49] [65 97] [13 76] [27] ===两两合并<br> [38 49 65 97] [13 27 76] ====继续两两合并<br> [13 27 38 49 65 76 97] ==== 最终合并为一个子表</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">m_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>num<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>temp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  <span class="token comment">//需要传入一个辅助数组</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">&gt;=</span> r<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span>r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment">//取中间值划分两个部分</span>
	<span class="token function">m_sort</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 对左侧子序列继续进行归并</span>
	<span class="token function">m_sort</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 对右侧侧子序列继续进行归并</span>
	<span class="token keyword">int</span> p1 <span class="token operator">=</span> l<span class="token punctuation">,</span> p2 <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">=</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 获取两个子序列的左右边界</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>				
		<span class="token keyword">if</span><span class="token punctuation">(</span>p2 <span class="token operator">&gt;</span> r <span class="token operator">||</span> p1 <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> num<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> num<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>		<span class="token comment">//排序过程</span>
			temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">;</span>
			p1<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
			temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">;</span>
			p2<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>   
		num<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>空间复杂度：因为我们用到一个辅助序列,所以空间复杂度O(n)<br> 时间复杂度：每次归并的时间复杂度为O(n)，需要进行<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         l 
        
       
         o 
        
        
        
          g 
         
        
          2 
         
        
       
         n 
        
       
      
        log_2n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span></span>趟归并，所以算法时间复杂度<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         n 
        
       
         l 
        
       
         o 
        
        
        
          g 
         
        
          2 
         
        
       
         n 
        
       
         ) 
        
       
      
        O(nlog_2n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span><br> 稳定性：归并排序不会改变相同数值元素的相对位置，所以是一种稳定排序</p> 
<h2><a id="_259"></a>基数排序</h2> 
<p>基数排序是一种特别的排序，它与其他基本的内部排序不同，它并不基于比较和移动，而是基于关键字各位大小的影响。基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。<br> 实现基数排序通常有两种方法，第一种是<strong>最高位优先</strong>，另一种是<strong>最低位优先</strong>。<br> 我们以最高位举例：</p> 
<blockquote> 
 <p>619 742 471 929 123 951 628 323 109<img src="https://images2.imgbox.com/ba/ff/0EGL2Vum_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/3d/bf/Yqhjn7ap_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/5d/6e/sri0wpdc_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/ad/8c/YKfuIgQH_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/f5/05/3SbFwZSO_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/4b/25/vCVcFG1s_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/14/cd/N21yALka_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/f8/f9/qXwn8Ltj_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/24/34/Hl50Hnvs_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>空间复杂度：一次排序需要的辅助存储空间为r(r个队列：r个队头指针和r个队尾指针)，但会重复使用。所以复杂度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         r 
        
       
         ) 
        
       
      
        O(r) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mclose">)</span></span></span></span></span><br> 时间复杂度：基数排序需要进行d趟分配和收集，一趟分配需要O(n)，一趟收集为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         r 
        
       
         ) 
        
       
      
        O(r) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mclose">)</span></span></span></span></span>，所以基数排序的时间复杂度为O(n + r)<br> 稳定性：对于基数排序来讲，很重要的一点就是按位排序时必须是稳定的，所以它是稳定排序</p> 
<h2><a id="_268"></a>内部排序算法比较</h2> 
<p><img src="https://images2.imgbox.com/16/d0/K6Xksyw3_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f3ea8c7d850995fd4f668d8837d8e3ba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Ant-design-vue表格禁用行复选框后点击全选依旧选中，而后面没禁用的没有选中的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c93b94f677709f0dc126f1a05667592a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">antd Table组件rowSelection方法的一些坑：table组件多选时，会选中上一页或者下一页的表格同行数据</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>