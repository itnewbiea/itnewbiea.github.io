<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>js中call,apply,bind方法的简单总结 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="js中call,apply,bind方法的简单总结" />
<meta property="og:description" content="一、作用 call、apply、bind作用是改变函数执行时的上下文，简而言之就是改变函数运行时的this指向call、apply、bind是Function.prototype下的方法，都是用于改变函数运行时上下文，最终的返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined。 二、区别 最主要的区别是call()、apply()方法是立即调用当前函数，而bind()是返回一个改变了this指向的新函数，并不立即调用。
call()，bind()的参数是依次传参，一一对应传递的。 apply() 需要把多个参数放在一个数组中，作为第二个参数传递 三、说明 (一)、call()
用法： call(newThis,arg1,arg2。。。)
call 的第一个参数就是 this 所要指向的那个对象，后面的参数则是函数调用时所需的参数。
1、 newThis包括以下类型：
（1） 传null,undefined或不传， 函数中的this指向window对象。
（2） 传递另一个函数的函数名，函数中的this指向这个函数的引用，则就指向函数体。
（3） 传递字符串、数值或布尔类型等基础类型，函数中的this指向其对应的包装对象，如 String、Number、Boolean等。
（4） 传递一个对象，函数中的this指向这个对象。
2、args是将会传入被绑定函数的参数，被绑定函数的执行时参数顺序为：newThis,args,原参数
列子：
var fan = { user:&#34;dragon&#34;, fun:function(age,sex){ console.log(this.user); //dragon console.log(this.user,age,sex) //dragon 男 学习 } } var b = fan.fun; b.call(fan,&#39;男&#39;,&#39;学习&#39;); b.call(fan); //传递函数名. this指向这个函数的引用 function fan1(){ console.log(this); //输出函数a中的this对象 } function fan2(){} var fan3={name:&#34;dragon&#34;};//定义对象fan3 fan1.call(); //window 不传， 函数中的this指向window对象。 fan1.call(null); //window 传null， 函数中的this指向window对象。 fan1.call(undefined); //window 传undefined， 函数中的this指向window对象。 fan1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/97b2496c8885fb0da5c8c236bc360116/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-03T17:45:17+08:00" />
<meta property="article:modified_time" content="2023-04-03T17:45:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">js中call,apply,bind方法的简单总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><a id="_0"></a><strong><span style="color:#34495e;"><strong>一、作用 </strong></span></strong></h2> 
<p></p> 
<ol><li>call、apply、bind作用是改变函数执行时的上下文，简而言之就是改变函数运行时的this指向</li><li>call、apply、bind是Function.prototype下的方法，都是用于改变函数运行时上下文，最终的返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined。</li></ol> 
<hr> 
<p></p> 
<h2><strong><span style="color:#34495e;"><strong>二、区别</strong></span></strong></h2> 
<p><span style="color:#34495e;">      最主要的区别是call()、apply()方法是立即调用当前函数，而bind()是返回一个改变了this指向的新函数，并不立即调用。</span></p> 
<p></p> 
<h4>　　call()，bind()的参数是依次传参，一一对应传递的。</h4> 
<h4>　　apply() 需要把多个参数放在一个数组中，作为第二个参数传递</h4> 
<hr> 
<p></p> 
<h2><a id="_26"></a>三、说明</h2> 
<h4><a id="1_27"></a></h4> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="color:#000000;"><strong>(一)、call()</strong></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#34495e;"><strong>     用法： call(newThis,arg1,arg2。。。)</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;">      call 的第一个参数就是 this 所要指向的那个对象，后面的参数则是函数调用时所需的参数。</p> 
<p style="margin-left:0pt;text-align:left;"><strong><span style="color:#34495e;"><strong>     1、 </strong></span></strong><span style="color:#34495e;">newThis包括以下类型：</span></p> 
<p style="margin-left:0pt;text-align:left;"><span style="color:#34495e;">        （1） 传null,undefined或不传， 函数中的this指向window对象。</span><br><span style="color:#34495e;">　　 （2） 传递另一个函数的函数名，函数中的this指向这个函数的引用，</span><span style="color:#34495e;">则就指向函数体。</span><br><span style="color:#34495e;">　　 （3） 传递字符串、数值或布尔类型等基础类型，函数中的this指向其对应的包装对象，如 String、Number、Boolean等。</span><br><span style="color:#34495e;">　     （4） 传递一个对象，函数中的this指向这个对象。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#34495e;">      2、args是将会传入被绑定函数的参数，被绑定函数的执行时参数顺序为：newThis,args,原参数</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#34495e;">  列子：</span></p> 
<pre><code class="language-javascript">var fan = {
    user:"dragon",
    fun:function(age,sex){
        console.log(this.user); //dragon

        console.log(this.user,age,sex)  //dragon 男 学习
    }
}
var b = fan.fun;
b.call(fan,'男','学习');  
b.call(fan);             //传递函数名. this指向这个函数的引用
function fan1(){  
　　console.log(this);    //输出函数a中的this对象
}      
 
function fan2(){}      
 
var fan3={name:"dragon"};//定义对象fan3
 
fan1.call();           //window     不传， 函数中的this指向window对象。
fan1.call(null);       //window     传null， 函数中的this指向window对象。
fan1.call(undefined);  //window     传undefined， 函数中的this指向window对象。
fan1.call(1);          //Number     Number {1}     传递数值   
fan1.call('');         //String     String {''}    传递字符串
fan1.call(true);       //Boolean    Boolean {true} 传递布尔
fan1.call(fan2);       //function fan2(){}  //传递函数名. this指向这个函数的引用但无引用就指向函数体。
fan1.call(fan3);       //Object  {name: 'dragon'}
 
</code></pre> 
<p></p> 
<p>call实现分析：</p> 
<pre><code class="language-javascript">// 传参默认是指向window
Function.prototype.myCall = function(context = window){ 
  
  context.fan = this;                 //为对象添加方法（this指向调用myCall的函数）
  let args = [...arguments].slice(1); // 剩余的参数
  let res = context.fan(...args);     // 调用该方法，该方法this指向context
  delete context.fan;                 //删除添加的方法
  return res;
} </code></pre> 
<p> 还有就是对象继承中的组合继承</p> 
<pre><code>//临时中转函数
function obj(o) {

    function F() {
    }

    F.prototype = o;

    return new F();

}

//寄生函数
function create(subType, superType){
    // var protoType = Object.create(superType.prototype);    //创建对象
    var protoType = obj(superType.prototype);            //创建对象
    protoType.constructor = subType;                    //增强对象
    subType.prototype = protoType;                        //指定对象
}
function Sup(name, age) {

    this.name = name;

    this.age = age;

}

Sup.prototype.run = function () {

    return this.name + " " + this.age + " running..."

}

function Sub(name, age) {

    Sup.call(this, name);
    this.age = age;

}

create(Sub,Sup);              //替代D.prototype=new B();
Sub.prototype.sayAge = function(){
    return this.name + " " + this.age + " Sub..."
}
var d= new Sub('dragon',100);
console.log(d.run());        //dragon 100 running...
console.log(d.sayAge());      //dragon 100 Sub...</code></pre> 
<p> (<span style="background-color:#ffffff;"><strong><span style="color:#000000;"><strong>二)、apply() </strong></span></strong></span></p> 
<p>               用法;<span style="color:#34495e;">apply(newThis,[arrArg])</span>    </p> 
<p>              apply和call类似，它接受两个参数，第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入。</p> 
<pre><code class="language-javascript">var fan = {
    user:"dragon",
    fun:function(age,sex){
        console.log(this.user); //dragon

        console.log(this.user,age,sex)  //dragon 男 学习
    }
}
var b = fan.fun;
b.apply(fan,['男','学习']);  
b.apply(fan);             //传递函数名. this指向这个函数的引用

function fan1(){  
　　console.log(this);    //输出函数a中的this对象
}      
 
function fan2(){}      
 
var fan3={name:"dragon"};//定义对象fan3
 
fan1.apply();           //window     不传， 函数中的this指向window对象。
fan1.apply(null);       //window     传null， 函数中的this指向window对象。
fan1.apply(undefined);  //window     传undefined， 函数中的this指向window对象。
fan1.apply(1);          //Number     Number {1}     传递数值   
fan1.apply('');         //String     String {''}    传递字符串
fan1.apply(true);       //Boolean    Boolean {true} 传递布尔
fan1.apply(fan2);       //function fan2(){}  //传递函数名. this指向这个函数的引用但无引用就指向函数体。
fan1.apply(fan3);       //Object  {name: 'dragon'} </code></pre> 
<p>apply实现分析：</p> 
<pre><code class="language-javascript">// 传参默认是指向window
Function.prototype.myApply = function(context = window){ 
  context.fan = this;                  //为对象添加方法（this指向调用myCall的函数）
  let res;
  if(arguments[1]){                    //判断是否有第二个参数
    res = context.fan(...arguments[1]);// 调用该方法，该方法this指向context
  }else{
    res = context.fan();               // 调用该方法，该方法this指向context
  }
  delete context.fan;                  //删除添加的方法
  return res;
} </code></pre> 
<p></p> 
<h4>(三)、结合call、apply操作数组或对象</h4> 
<h4>         1、找出数组的最大值、最小值</h4> 
<pre><code class="language-javascript">var dragon = [11, 21, 4, 55, 19,88,22,33];
Math.max.apply(null, dragon) // 88 最大值
Math.max.call(null, ...dragon) // 88 最大值
 
Math.min.apply(null, dragon) // 4 最小值
Math.min.call(null, ...dragon) // 4 最小值</code></pre> 
<h4>         2、转换类似数组的对象</h4> 
<pre><code class="language-javascript">Array.prototype.slice.apply({0: 66,1: 88, length: 2}) // [66，88]
Array.prototype.slice.call({0: 66,1: 88, length: 2})  // [66，88]
Array.prototype.slice.apply({0: 66,1: 88, length: 3}) // [66, 88, undefined]
Array.prototype.slice.call({0: 66,1: 88, length: 3})  // [66, 88, undefined]
Array.prototype.slice.apply({0: 66})                  // []
Array.prototype.slice.call({0: 66})                   // []</code></pre> 
<p>     <strong>为什么通过 Array.prototype.slice.call(arrayLike) 可以转换类数组为数组？</strong> </p> 
<p>  大概具体是这样的:   </p> 
<pre><code class="language-javascript">Array.prototype.mySlice = function(start=0, end) {
    const array = this;
    const end = end === undefined ? array.length : end;
    
    const resultArray = [];
    if (array.length === 0) return resultArray;
    for (let index = start; index &lt; end; index++) {
        resultArray.push(array[index]);
    }
    return resultArray;
}</code></pre> 
<h4>          3、将数组的空元素变为 undefined</h4> 
<pre><code class="language-javascript">Array.apply(null, ['aaa', ,'bbb']); // [ 'aaa', undefined, 'bbb' ]
Array.call(null, ...['aaa', ,'bbb']); // [ 'aaa', undefined, 'bbb' ]
</code></pre> 
<h4>          4、合并数组</h4> 
<pre><code class="language-javascript">var arr1=new Array("1","2","3","4","5");  
var arr2=new Array("6","7","8","9","10");  
  
Array.prototype.push.apply(arr1,arr2); 

console.log(arr1) //['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']</code></pre> 
<h4>（四）bind()</h4> 
<p>bind()函数会创建一个新的绑定函数，这个绑定函数包装了原函数的对象。调用绑定函数通常会执行包装函数。<br> 绑定函数内部属性：</p> 
<p>1 、包装的函数对象</p> 
<p>2、在调用包装函数时始终作为this传递的值</p> 
<p>3、在对包装函数做任何调用时都会优先用列表元素填充参数列表。</p> 
<pre><code class="language-javascript">var user="winDragon";
var fan = {
    user:"dragon",
    fun:function(age,sex){
        console.log(this.user); //dragon

        console.log(this.user,age,sex)  
    }
}
var b = fan.fun;
b();                          //winDragon  没bind前this指向window
var c = b.bind(fan);
console.log(c());             //dragon     bind后this指向对象中的user 
b.bind(fan,'男','学习')();     //dragon     男 学习

b.bind(fan,['男','学习'])();   //dragon     ['男', '学习'] undefined




</code></pre> 
<p> bind实现分析： </p> 
<pre><code class="language-javascript">// 传参默认是指向window
Function.prototype.myBind = function(context = window){
  let fan = this;                       // 调用bind的函数
  let args = [...arguments].slice(1);   // myBind的参数
  let bind = function(){
    let args1 = [...arguments].slice(); // bind的参数
    return fan.apply(context,args.concat(args1));
  }
  return bind;
} </code></pre> 
<h2></h2> 
<h2>四、总结</h2> 
<p><strong>　　</strong></p> 
<p>1、apply 、call、bind 三者都是用来改变函数的 this 对象的指向的；</p> 
<p>2、apply、call、bind 三者第一个参数都是 this 要指向的对象；</p> 
<p>3、apply、call、bind 三者都可以利用后续参数传参；</p> 
<p>4、bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。</p> 
<p><br>  </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e1095a51abc9c9bb0cf74a862230628c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">uniapp动态获取验证码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bdf3d0422d204aa3327c66bec72c69b5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c语言结构体学习整理(结构体初始化，结构体指针)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>