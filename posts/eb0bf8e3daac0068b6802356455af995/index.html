<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>大模型上下文长度的超强扩展：从LongLoRA到LongQLoRA - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="大模型上下文长度的超强扩展：从LongLoRA到LongQLoRA" />
<meta property="og:description" content="前言 本文一开始是《七月论文审稿GPT第2版：从Meta Nougat、GPT4审稿到Mistral、LongLora Llama》中4.3节的内容，但考虑到
一方面，LongLora的实用性较高二方面，为了把LongLora和LongQLora更好的写清楚，而不至于受篇幅之限制三方面，独立成文可以有更好的排版，而更好的排版可以有更高的可读性(哪怕一个小小的换行都能提高可读性，更何况独立成文带来的可读性的提高) 故把这部分的内容抽取出来独立成本文
第一部分 LongLora 具体而言，LongLora是港中文和MIT的研究者通过此篇论文《LongLoRA: Efficient Fine-tuning of Long-Context Large Language Models》于23年9月底提出的(这是其GitHub)，其显著特点有三
longlora的作者团队认为：尽管在推理过程中需要密集的全局注意力，但通过稀疏局部注意力(sparse local attention)也可以高效地完成模型的微调，比如他们提出的移位稀疏注意力(shifted sparse attention，简称S2-Attn)可有效地实现上下文扩展且显著节省计算资源，具有与使用vanilla注意力(vanilla attention)进行微调相似的性能
简言之，用sparse local attention替换掉dense global attention，类似检索，不需要把所有的东西都拿过来，把相似度高的，匹配度高的一部分context拿来就可以了他们发现，LoRA加到embedding matrix以及normalization的子网络上的时候，效果更好
啥意思？这点在于常规操作是lora一般加到query, key, value等部分上，而这里是加到embedding matrix上，以及normaliztion上了LongLoRA在保留原始架构的同时扩展了模型的上下文，并且与大多数现有技术(如Flash-Attention2)兼容
此外，还进一步发布了使用LongLoRA技术的长指令遵循数据集LongAlpaca，以进行监督微调(we further conduct supervised fine-tuning with LongLoRA and our long instruction-following LongAlpaca dataset) 1.1 LoRA在长文本上的不足 通过本博客内的多篇文章可知，原始transformer的计算复杂度虽序列长度的二次方成正比，这一点一直导致模型的长下文长度不好扩展(比如把长度从2048扩展到8192，复杂度得上升4x4 = 16倍)，对于该问题 很多研究者或团队做了各种改进与探索
比如Flash-Attention、Flash-Attention2(详见此文《通透理解FlashAttention与FlashAttention2：让大模型上下文长度突破32K的技术之一》)再比如Position Interpolation (详见此文《大模型上下文扩展之YaRN解析：从直接外推ALiBi、位置插值、NTK-aware插值、YaRN》的2.3节) spent 32 A100 GPUs to extend LLaMA models from 2k to 8k context，当然了，这种资源开销即便是七月项目团队也不一定舍得耗(其实，我司项目团队一直在“低成本 高效果”的方向上探索，过程中积攒了这方面的很多经验)，更别说一般个人了 如何降低资源开销呢？一种直接的方法是通过LoRA对预训练的LLM进行微调" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/eb0bf8e3daac0068b6802356455af995/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-04T22:50:20+08:00" />
<meta property="article:modified_time" content="2024-01-04T22:50:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">大模型上下文长度的超强扩展：从LongLoRA到LongQLoRA</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言</h2> 
<p>本文一开始是《<a class="link-info" href="https://blog.csdn.net/v_JULY_v/article/details/134183799" title="七月论文审稿GPT第2版：从Meta Nougat、GPT4审稿到Mistral、LongLora Llama">七月论文审稿GPT第2版：从Meta Nougat、GPT4审稿到Mistral、LongLora Llama</a>》中4.3节的内容，但考虑到</p> 
<ul><li>一方面，LongLora的实用性较高</li><li>二方面，为了把LongLora和LongQLora更好的写清楚，而不至于受篇幅之限制</li><li>三方面，独立成文可以有更好的排版，而更好的排版可以有更高的可读性(哪怕一个小小的换行都能提高可读性，更何况独立成文带来的可读性的提高)</li></ul> 
<p>故把这部分的内容抽取出来独立成本文</p> 
<p></p> 
<h2>第一部分 LongLora</h2> 
<p>具体而言，LongLora是港中文和MIT的研究者通过此篇论文《<a href="http://2309.12307" rel="nofollow" title="LongLoRA: Efficient Fine-tuning of Long-Context Large Language Models">LongLoRA: Efficient Fine-tuning of Long-Context Large Language Models</a>》于23年9月底提出的(这是<a href="https://github.com/dvlab-research/LongLoRA" title="其GitHub">其GitHub</a>)，其显著特点有三</p> 
<ol><li>longlora的作者团队认为：尽管在推理过程中需要密集的全局注意力，但通过稀疏局部注意力(<em>sparse local attention</em>)也可以高效地完成模型的微调，比如他们提出的移位稀疏注意力(<strong><em>shifted sparse attention，简称S2-Attn</em></strong>)可有效地实现上下文扩展且显著节省计算资源，具有与使用vanilla注意力(<em>vanilla attention</em>)进行微调相似的性能<br><br> 简言之，用sparse local attention替换掉dense global attention，类似检索，不需要把所有的东西都拿过来，把相似度高的，匹配度高的一部分context拿来就可以了</li><li>他们发现，LoRA加到embedding matrix以及normalization的子网络上的时候，效果更好<br> 啥意思？这点在于常规操作是lora一般加到query, key, value等部分上，而这里是加到embedding matrix上，以及normaliztion上了</li><li>LongLoRA在保留原始架构的同时扩展了模型的上下文，并且与大多数现有技术(如Flash-Attention2)兼容<br> 此外，还进一步发布了使用LongLoRA技术的长指令遵循数据集LongAlpaca，以进行监督微调(<em>we further conduct supervised fine-tuning with LongLoRA and our long instruction-following LongAlpaca dataset</em>)</li></ol> 
<h3>1.1 LoRA在长文本上的不足</h3> 
<p>通过本博客内的多篇文章可知，原始transformer的计算复杂度虽序列长度的二次方成正比，这一点一直导致模型的长下文长度不好扩展(<em>比如把长度从2048扩展到8192，复杂度得上升4x4 = 16倍</em>)，对于该问题 很多研究者或团队做了各种改进与探索</p> 
<ul><li>比如Flash-Attention、Flash-Attention2(<em>详见此文《<em><a href="https://blog.csdn.net/v_JULY_v/article/details/133619540" title="通透理解FlashAttention与FlashAttention2：让大模型上下文长度突破32K的技术之一">通透理解FlashAttention与FlashAttention2：让大模型上下文长度突破32K的技术之一</a></em>》</em>)</li><li>再比如Position Interpolation (<em>详见此文《<em><a href="https://blog.csdn.net/v_JULY_v/article/details/135072211" title="大模型上下文扩展之YaRN解析：从直接外推ALiBi、位置插值、NTK-aware插值、YaRN">大模型上下文扩展之YaRN解析：从直接外推ALiBi、位置插值、NTK-aware插值、YaRN</a></em>》的2.3节</em>) spent 32 A100 GPUs to extend LLaMA models from 2k to 8k context，当然了，这种资源开销即便是七月项目团队也不一定舍得耗(<em>其实，我司项目团队一直在“<strong>低成本 高效果</strong>”的方向上探索，过程中积攒了这方面的很多经验</em>)，更别说一般个人了</li></ul> 
<p>如何降低资源开销呢？一种直接的方法是通过LoRA对预训练的LLM进行微调</p> 
<ul><li id="t-page3-s7-c0-b0-p0">对于预训练的权重矩阵W∈Rd×k，它通过低秩分解W +∆W = W + BA进行更新，其中B∈Rd×r和A∈Rr×k。秩r≪min(d, k)，在训练过程中，W被冻结，没有梯度更新，而A和B是可训练的(<em>关于LoRA的更多说明，详见此文《<em><a href="https://blog.csdn.net/v_JULY_v/article/details/132116949" title="LLM高效参数微调方法：从Prefix Tuning、Prompt Tuning、P-Tuning V1/V2到LoRA、QLoRA(含对模型量化的解释)">LLM高效参数微调方法：从Prefix Tuning、Prompt Tuning、P-Tuning V1/V2到LoRA、QLoRA(含对模型量化的解释)</a></em>》的第4部分</em>) <p><em>For a pre-trained weight matrix W ∈ R d×k , it is updated with a low-rank decomposition W + ∆W = W + BA, where B ∈ R d×r and A ∈ R r×k . </em></p> <p><em>The rank r ≪ min(d, k). During training, W is frozen with no gradient updates, while A and B are trainable. This is the reason why LoRA training is much more efficient than full fine-tuning.</em></p> </li><li id="t-page3-s7-c0-b1-p0">在Transformer结构中，LoRA只关注权重(Wq、Wk、Wv、Wo)，而冻结所有其他层，包括MLP层和归一化层 <p><em>In the Transformer structure, LoRA only adapts the attention weights (Wq, Wk, Wv, Wo) and freezes </em><em>all other layers, including MLP and normalization layers</em></p> </li></ul> 
<p>LoRA利用低秩矩阵对自注意块中的线性投影层进行修改，从而减少了可训练参数的数量(<em>LoRA modifies the <strong>linear projection layers</strong> in self-attention blocks by utilizing <strong>low-rank matrices</strong>, which are generally efficient and reduce the number of trainable parameters</em>)</p> 
<ol><li>然而，单纯的低秩自适应会导致长上下文扩展的困惑度(<em>perplexityin，简称PPL</em>)很高，如下表所示，且即便将秩增加到一个更高的值，例如rank = 256，也并不能缓解这个问题<br> 那咋办呢？让embedding层和Norm层也添加LoRA训练之后，困惑度PPL可以显著降低 <p class="img-center"><img alt="" height="95" src="https://images2.imgbox.com/e4/67/GYZlskSZ_o.png" width="1000"></p> </li><li>在效率方面，无论是否采用LoRA，计算成本都会随着上下文规模的扩大而急剧增加，这主要是由于标准的自注意机制所导致的(Vaswani et al.， 2017)。如下图所示，即便使用LoRA，当上下文窗口扩展时，Llama2模型的训练时间也会大大增加 <p class="img-center"><img alt="" height="246" src="https://images2.imgbox.com/08/88/M78h7QLd_o.png" width="1000"></p> 为此，他们提出shifted sparse attention(S2-Attn)以替代标准自注意力机制</li></ol> 
<h3>1.2  shifted sparse attention(S2-Attn)</h3> 
<h4>1.2.1 S2-Attn的原理解释</h4> 
<p>如下图所示</p> 
<p class="img-center"><img alt="" height="326" src="https://images2.imgbox.com/25/3e/HuqeDmuz_o.png" width="1000"></p> 
<ol><li>将上下文长度分成几个组，并在每个组中单独计算注意力。在半注意力头中，将token按半组大小进行移位，这保证了相邻组之间的信息流动(<em>In half attention heads, we shift the tokens by half group size, which ensures the information flow between neighboring groups</em>)</li><li>例如，使用组大小为2048的S2-Attn来近似总共8192个上下文长度训练，这与Swin Transformer具有高度的相似(<em>详见此文《<em><a href="https://blog.csdn.net/v_JULY_v/article/details/130361959" title="AI绘画能力的起源：从VAE、扩散模型DDPM、DETR到ViT/Swin transformer">AI绘画能力的起源：从VAE、扩散模型DDPM、DETR到ViT/Swin transformer</a></em>》的第五部分</em>)</li></ol> 
<p>上面的描述还是不够形象具体，那到底怎么理解这个S2-Attn呢？如下图所示(<em>值得一提的是，这个图是论文v2版的，和论文v1版稍有细微差别，当然 不影响本质</em>)</p> 
<p class="img-center"><img alt="" height="289" src="https://images2.imgbox.com/6f/f6/kc1hT8d2_o.png" width="1200"></p> 
<ol><li>首先，它将沿头部维度的特征分成两大块(<em>即it splits features along the head dimension into two chunks，比如8行4列，8行相当于8个token，4列可以认为是有4个头，然后竖着一切为二</em>)<br><br> 相当于[L, H, D], L=token num=8, H=head num=4, D=dimension of expression=1(可暂且认为是1了，毕竟一个方块，算是长度为1的一个向量）<br> 执行完操作之后是：[L, H, D] -&gt; [L, H/2, D] and [L, H/2, D]，即被竖着切成了左右两个part</li><li>其次，其中一个块中的标记被移动组大小的一半(<em>tokens in one of the chunks are shifted by half of the group size</em>)<br> 如上图step 2的shift所示，shift the <img alt="2^{nd}" src="https://images2.imgbox.com/bc/39/6i77iymh_o.png"> part by half group，相当于<br><strong><img alt="\rightarrow" src="https://images2.imgbox.com/f0/4f/LAOO2LdW_o.png">  第2个part的第8个token的后一半表示</strong>(<strong><em>也即原始inputs第8个token的后两个heads</em></strong>)<strong>移动到第2个part的第1行</strong><br><img alt="\rightarrow" src="https://images2.imgbox.com/09/14/pSExQGTj_o.png">  而<strong>第2个part中原来的「第1-7个token的后一半表示」整体往下移动一行</strong></li><li>第三，将token分组并重塑为批量维度，注意力只在每个组内计算，信息通过移位在不同组之间流动。虽然移位可能会引入潜在的信息泄漏，但这可以通过对注意力掩码进行微调来避免<br><em>Third, we split tokens into groups and reshape them into batch dimensions. Attention only computes in each group in ours while the information flows between groups via shifting. Potential information leakage might be introduced by shifting, while this is easy to prevent via a small modification on the attention mask.</em><br><br> 相当于把两个part连起来后，然后横着切三刀切成了4个group，每个group有8个小方块<br> 第一个group相当于包含：第一part的前两行，和第二part中更新之后的前两行<br> 然后计算该group内的注意力，类似于做了“cross-over”，正因为只是计算group内部的几个tokens之间的attention，所以称之为short attention</li></ol> 
<blockquote> 
 <p>为方便大家更快的理解，特再补充两点</p> 
 <ol><li>为形象起见，举个例子，假定这8个单词是i am learning Machine Learning by julyedu online，然后上述过程可用下表表示 
   <table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>i 前一半(表示)</td><td></td><td>i 后一半(表示)</td><td></td><td><em>i 前一半</em></td><td></td><td><em><strong>online 后一半：line</strong></em></td><td></td></tr><tr><td>am 前一半</td><td></td><td>am 后一半</td><td></td><td><em>am 前一半</em></td><td></td><td><em>i 后一半</em></td><td></td></tr><tr><td>learning 前一半</td><td></td><td>learning 后一半</td><td></td><td>learning 前一半</td><td></td><td>am 后一半</td><td></td></tr><tr><td>Machine 前一半</td><td></td><td>Machine 后一半</td><td></td><td>Machine 前一半</td><td></td><td>learning 后一半</td><td></td></tr><tr><td>Learning 前一半</td><td></td><td>Learning 后一半</td><td></td><td><em>Learning 前一半</em></td><td></td><td><em>Machine 后一半</em></td><td></td></tr><tr><td>by 前一半</td><td></td><td>by 后一半</td><td></td><td><em>by 前一半</em></td><td></td><td><em>Learning 后一半</em></td><td></td></tr><tr><td>julyedu 前一半</td><td></td><td>julyedu 后一半</td><td></td><td>julyedu 前一半</td><td></td><td>by 后一半</td><td></td></tr><tr><td>online 前一半</td><td></td><td>online 后一半</td><td></td><td><strong>online 前一半：on</strong></td><td></td><td>julyedu 后一半</td><td></td></tr></tbody></table></li><li>针对上面那个S2-Attn示意图<br> 该图的左边部分 上文已经解释的很清楚了，那右侧的两个图呢？<br> 咋一看，比较抽象，其实仔细琢磨之后，右侧的两个图描述的注意力范围，pattern2相对于pattern1的注意力窗口是“移位”了的 <p class="img-center"><img alt="" height="289" src="https://images2.imgbox.com/84/d1/ekfvZdlx_o.png" width="1200"></p> 具体到某个token来观察会清楚一点，除了“pattern1中q1”和“pattern2中q1”的注意力范围是一致 都是k1之外<br> pattern1中q2的注意力范围是[k1,k2]，pattern2中q2的注意力范围变成了仅[k2]；<br> pattern1中q3的注意力范围仅是[k3]，pattern2中q3的注意力范围变成了[k2,k3]；<br> pattern1中q4的注意力范围是[k3,k4]，pattern2中q4的注意力范围变成了仅[k4]；<br> pattern1中q5的注意力范围是仅[k5]，pattern2中q5的注意力范围变成了[k4,k5]；<br> ...<br> 两个pattern从最开始的token注意力范围就是错位的，所以后续token注意力范围就一直是错开的，这样错开的形式使得两个pattern聚合起来就可以让组外信息有机会产生交互</li></ol> 
</blockquote> 
<h4>1.2.2 S2-Attn的伪代码表示</h4> 
<p>如下图所示</p> 
<p class="img-center"><img alt="" height="280" src="https://images2.imgbox.com/99/ba/1J539Rwm_o.png" width="800"></p> 
<ol><li>第一步，B=batch size, N=sequence length, 3=q,k,v，H=head num，D=每个head的表示维度<br> 例如：qkv=[1, 4, 3, 4, 1]<br> 即batch size=1，一共一个序列；4=4个tokens，3=q,k,v，4=head num，1=dim of a head 
  <table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>1</td><td>head2</td><td>head3</td><td>head4</td><td><strong>head1</strong></td><td><strong>head2</strong></td><td><strong>head3</strong></td><td><strong>4</strong></td></tr><tr><td>2</td><td></td><td></td><td></td><td></td><td></td><td></td><td><strong>1</strong></td></tr><tr><td>3</td><td></td><td></td><td></td><td></td><td></td><td></td><td><strong>2</strong></td></tr><tr><td>4</td><td></td><td></td><td></td><td></td><td></td><td></td><td><strong>3</strong></td></tr></tbody></table></li><li><strong>qkv.chunk(2, 3)</strong>，得到的是一个tuple，包括两个张量，[1, 4, 3, 2, 1]左边的part，以及[1, 4, 3, 2, 1]是右边的part<br> qkv.chunk(2, 3)[0]，即左边的包括两个heads的part<br> qkv.chunk(2,3)[1]， 即右边的包括两个heads的part，这里是对其shift 1个token了</li><li>接下来，按照group分别计算group内的tokens的注意力</li><li>最后，复原</li></ol> 
<h4>1.2.3 LongAlpaca-13B</h4> 
<p>在llama 13B上应用longlora技术，便是<a href="https://huggingface.co/Yukang/LongAlpaca-13B" rel="nofollow" title="LongAlpaca-13B">LongAlpaca-13B</a></p> 
<p class="img-center"><img alt="" height="283" src="https://images2.imgbox.com/01/c9/2Yr4M72J_o.png" width="800"></p> 
<p></p> 
<h2 style="background-color:transparent;">第二部分 LongQLora</h2> 
<h3>2.1 LongLoRA与LongQLoRA异同</h3> 
<table><tbody><tr><td colspan="1" rowspan="1"> <p></p> </td><td colspan="1" rowspan="1"> <p><strong>Standard</strong></p> </td><td colspan="1" rowspan="1"> <p><strong>LongLoRA</strong></p> </td><td colspan="1" rowspan="1"> <p><strong>LongQLoRA</strong></p> </td></tr><tr><td colspan="1" rowspan="1"> <p><strong>位置编码扩展</strong></p> </td><td colspan="1" rowspan="1"> <p>-/Position Interpolation/...</p> </td><td colspan="1" rowspan="1"> <p>Position Interpolation</p> </td><td colspan="1" rowspan="1"> <p>Position Interpolation</p> </td></tr><tr><td colspan="1" rowspan="1"> <p><strong>训练所用注意力机制</strong></p> </td><td colspan="1" rowspan="1"> <p>Standard Global Attention</p> </td><td colspan="1" rowspan="1"> <p>Shift Short Attention</p> </td><td colspan="1" rowspan="1"> <p>Shift Short Attention</p> </td></tr><tr><td colspan="1" rowspan="1"> <p><strong>训练方式</strong></p> </td><td colspan="1" rowspan="1"> <p>Full/LoRA/QLoRA</p> </td><td colspan="1" rowspan="1"> <p><strong>Full/LoRA</strong></p> </td><td colspan="1" rowspan="1"> <p><strong>QLoRA</strong></p> </td></tr><tr><td colspan="1" rowspan="1"> <p><strong>LoRA可训练层</strong></p> <p><strong>(通常情况)</strong></p> </td><td colspan="1" rowspan="1"> <p>Attention层</p> </td><td colspan="1" rowspan="1"> <p><strong>Attention层、Norm层、Embedding层</strong></p> </td><td colspan="1" rowspan="1"> <p><strong>Attention层</strong></p> </td></tr><tr><td colspan="1" rowspan="1"> <p><strong>LoRA Rank</strong></p> </td><td colspan="1" rowspan="1"> <p>8/16/32/...</p> </td><td colspan="1" rowspan="1"> <p><strong>8/16/...</strong></p> </td><td colspan="1" rowspan="1"> <p><strong>16/32/64/...</strong></p> </td></tr><tr><td colspan="1" rowspan="1"> <p><strong>推理所用注意力机制</strong></p> </td><td colspan="1" rowspan="1"> <p>Standard Global Attention</p> </td><td colspan="1" rowspan="1"> <p>Standard Global Attention</p> </td><td colspan="1" rowspan="1"> <p>Standard Global Attention</p> </td></tr></tbody></table> 
<h4>2.1.1 可训练层和LoRA Rank的设置</h4> 
<p>研究团队发现在LongQLoRA中即使不放开Norm层和Embedding层来进行训练，也可以通过设置更大的LoRA Rank来实现更好的微调效果。</p> 
<p>即<em>Different from LongLoRA, LongQLoRA can achieve better performance even without training word embeddings and normalization layers[Ba et al., 2016]. This is due to the fact that we add more LoRA adapters and use larger LoRA rank.</em></p> 
<p class="img-center"><img alt="" height="171" src="https://images2.imgbox.com/5f/b8/wxBfV4Xh_o.png" width="800"></p> 
<p></p> 
<h4>2.1.2 推理所用注意力机制的设置</h4> 
<p>研究团队发现</p> 
<blockquote> 
 <p>在LongQLoRA中，即使模型是在Shift Short Attention下训练的，但在推理时使用传统的Standard Global Attention表现会更好（在相应测试数据集上困惑度更低）</p> 
</blockquote> 
<p>这一特性具备不小的意义：由于现有的大部分推理优化策略均是基于Standard Global Attention的，因此即使使用LongQLoRA进行训练，也仍可以使用Standard Global Attention进行推理，从而直接兼容现有的大部分推理策略</p> 
<p class="img-center"><img alt="" height="154" src="https://images2.imgbox.com/44/27/KuqqmYgc_o.png" width="800"></p> 
<p>// 待更</p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e9c4441fe48f8700a25fc04aa0d8a511/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">根本记不住MySQL进阶查询语句</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1e548385da850d1d54657ad672e186d3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">代码随想录day20 开始二叉搜索树</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>