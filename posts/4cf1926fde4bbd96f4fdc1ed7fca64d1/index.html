<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据分析基础之《numpy（4）—ndarry运算》 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据分析基础之《numpy（4）—ndarry运算》" />
<meta property="og:description" content="一、逻辑运算
当我们要操作符合某一条件的数据时，需要用到逻辑运算
1、运算符
满足条件返回true，不满足条件返回false
# 重新生成8只股票10个交易日的涨跌幅数据 stock_change = np.random.normal(loc=0, scale=1, size=(8, 10)) # 获取前5行前5列的数据 stock_change = stock_change[0:5, 0:5] # 逻辑判断，如果涨跌幅大于0.5，就标记为true，否则标记为false stock_change &gt; 0.5 2、布尔索引
想要对布尔数据进行一个统一的操作，相当于是取出数组中为true的所以值，或为false的所有值
# 布尔索引 stock_change[stock_change &gt; 0.5] 二、通用判断函数
1、np.all()
传入一组布尔值，只要有一个false，就返回false，全都是true才返回true
2、np.any()
传入一组布尔值，只要有一个true，就返回true，全都是false才返回false
3、例子
# 判断stock_change是否全是上涨的 np.all(stock_change &gt; 0) stock_change # 判断stock_change是否有上涨的 np.any(stock_change &gt; 0) 三、np.where（三元运算符）
1、通过使用np.where能够进行更加复杂的运算
np.where(布尔值, true的位置要设置的值, false的位置要设置的值)
2、例子
# 判断前四个股票前四天的涨跌幅，大于0的置为1，否则为0 temp = stock_change[:4, :4] temp np.where(temp &gt; 0, 1, 0) 3、np.logical_and 逻辑与
4、np.logical_or 逻辑或" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4cf1926fde4bbd96f4fdc1ed7fca64d1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-20T14:22:55+08:00" />
<meta property="article:modified_time" content="2023-12-20T14:22:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据分析基础之《numpy（4）—ndarry运算》</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、逻辑运算</p> 
<p>当我们要操作符合某一条件的数据时，需要用到逻辑运算</p> 
<p>1、运算符<br> 满足条件返回true，不满足条件返回false</p> 
<pre><code class="language-python"># 重新生成8只股票10个交易日的涨跌幅数据
stock_change = np.random.normal(loc=0, scale=1, size=(8, 10))

# 获取前5行前5列的数据
stock_change = stock_change[0:5, 0:5]

# 逻辑判断，如果涨跌幅大于0.5，就标记为true，否则标记为false
stock_change &gt; 0.5</code></pre> 
<p><img alt="" height="408" src="https://images2.imgbox.com/24/a1/5MtLDfoE_o.png" width="1200"></p> 
<p>2、布尔索引<br> 想要对布尔数据进行一个统一的操作，相当于是取出数组中为true的所以值，或为false的所有值</p> 
<pre><code class="language-python"># 布尔索引
stock_change[stock_change &gt; 0.5]</code></pre> 
<p><img alt="" height="189" src="https://images2.imgbox.com/b7/d8/Iu3JxSzR_o.png" width="1200"></p> 
<p>二、通用判断函数</p> 
<p>1、np.all()<br> 传入一组布尔值，只要有一个false，就返回false，全都是true才返回true</p> 
<p>2、np.any()<br> 传入一组布尔值，只要有一个true，就返回true，全都是false才返回false</p> 
<p>3、例子</p> 
<pre><code class="language-python"># 判断stock_change是否全是上涨的
np.all(stock_change &gt; 0)

stock_change

# 判断stock_change是否有上涨的
np.any(stock_change &gt; 0)</code></pre> 
<p><img alt="" height="477" src="https://images2.imgbox.com/48/fd/hdpjgxPN_o.png" width="1200"></p> 
<p>三、np.where（三元运算符）</p> 
<p>1、通过使用np.where能够进行更加复杂的运算<br> np.where(布尔值, true的位置要设置的值, false的位置要设置的值)</p> 
<p>2、例子</p> 
<pre><code class="language-python"># 判断前四个股票前四天的涨跌幅，大于0的置为1，否则为0
temp = stock_change[:4, :4]

temp

np.where(temp &gt; 0, 1, 0)</code></pre> 
<p><img alt="" height="457" src="https://images2.imgbox.com/60/29/B09yZp7c_o.png" width="1200"></p> 
<p>3、np.logical_and 逻辑与</p> 
<p>4、np.logical_or 逻辑或</p> 
<p>5、例子</p> 
<pre><code class="language-python"># 判断前四个股票前四天的涨跌幅，大于0.5并且小于1的，置为1，否则置为0
np.where(np.logical_and(temp &gt; 0.5, temp &lt; 1), 1, 0)

# 判断前四个股票前四天的涨跌幅，大于0.5或者小于-0.5的，置为1，否则置为0
np.where(np.logical_or(temp &gt; 0.5, temp &lt; -0.5), 1, 0)</code></pre> 
<p><img alt="" height="421" src="https://images2.imgbox.com/16/ab/g1BBpOL3_o.png" width="1200"></p> 
<p>四、统计运算</p> 
<p>1、如果想要知道涨幅或者跌幅最大的数据，应该怎么做</p> 
<p>2、统计指标函数<br> np.min(a, axis=None, out=None, keepdims=False)：最小值<br> np.max(a, axis=None, out=None, keepdims=False)：最大值<br> np.mean(a, axis=None, out=None, keepdims=False)：平均值<br> np.median(a, axis=None, out=None, keepdims=False)：中位数<br> np.var(a, axis=None, out=None, keepdims=False)：方差<br> np.std(a, axis=None, out=None, keepdims=False)：标准差</p> 
<p>3、可以用两种方式调用<br> np.函数名<br> ndarray.方法名</p> 
<p>4、axis默认为axis=0即列向，如果axis=1即横向</p> 
<p>5、例子</p> 
<pre><code class="language-python"># 对于前四个股票前四天数据，进行一些统计运算
print("前四只股票前四天的最大涨幅{}".format(np.max(temp, axis=1)))
print("前四只股票前四天的最大跌幅{}".format(np.min(temp, axis=1)))
print("前四只股票前四天的波动程度{}".format(np.std(temp, axis=1)))
print("前四只骨片前四天的平均涨跌幅{}".format(np.mean(temp, axis=1)))</code></pre> 
<p><img alt="" height="289" src="https://images2.imgbox.com/d9/3a/agjiZBlU_o.png" width="1200"></p> 
<p>6、获得最大值最小值的位置（索引）<br> np.argmax(a, axis)<br> np.argmin(a, axis)</p> 
<p>7、例子</p> 
<pre><code class="language-python"># 获取股票指定哪一天的涨幅最大
print("前四只股票前四天内涨幅最大{}".format(np.argmax(temp, axis=1)))
print("前四天一天内涨幅最大的股票{}".format(np.argmax(temp, axis=0)))</code></pre> 
<p><img alt="" height="180" src="https://images2.imgbox.com/fa/ca/KRwxxfXz_o.png" width="1200"></p> 
<p>五、数组运算</p> 
<p>1、场景<br> 平时成绩占30%，期末成绩占70%，算出最终成绩</p> 
<p>2、数组与数的运算<br> 运算符作用到数组中的每一个元素</p> 
<pre><code class="language-python"># 数组与数的运算
arr = np.array([[1,2,3,2,1,4], [5,6,1,2,3,1]])

arr + 10</code></pre> 
<p><img alt="" height="220" src="https://images2.imgbox.com/57/b6/qMKk95p2_o.png" width="1200"></p> 
<p>3、数组与数组的运算</p> 
<pre><code class="language-python"># 数组与数组的运算
arr1 = np.array([[1,2,3,2,1,4], [5,6,1,2,3,1]])
arr2 = np.array([[1,2,3,4], [3,4,5,6]])
arr1 + arr2</code></pre> 
<p><img alt="" height="372" src="https://images2.imgbox.com/4d/a2/wsKEI2SL_o.png" width="1200"></p> 
<p>提示不满足广播机制！</p> 
<p>4、广播机制</p> 
<p>（1）执行broadcast的前提在于，两个nadarray执行的是element-wise的运算，Broadcast机制的功能是为了方便不同形状的ndarray（numpy库的核心数据结构）进行数学运算</p> 
<p>（2）当操作两个数组时，numpy会逐个比较它们的shape（构成的元组tuple），只有在下述情况下，两个数组才能够进行数组与数组的运算<br> 维度相等（单看这一列）<br> shape（其中相对应的一个地方为1）</p> 
<p>（3）可以这样理解，首先把数组形状展开，从右到左按列来看，两个情况中只要满足一个就可以<br><img alt="" height="310" src="https://images2.imgbox.com/f1/53/bKpOppdO_o.png" width="322"></p> 
<p>以下情况不匹配：<br><img alt="" height="124" src="https://images2.imgbox.com/d9/56/QCyflTv6_o.png" width="274"></p> 
<p>（4）运算的结果，每一个维度取最大的</p> 
<p>（5）例子</p> 
<pre><code class="language-python">arr1 = np.array([[1,2,3,2,1,4], [5,6,1,2,3,1]])
arr2 = np.array([[1], [3]])

arr1 # (2, 6)

arr2 # (2, 1)

arr1 + arr2</code></pre> 
<p><img alt="" height="496" src="https://images2.imgbox.com/1f/36/EcEcQfMV_o.png" width="1200"></p> 
<p>arr1是2行6列，arr2是2行1列</p> 
<p>相加的结果，维度相同的，对应的每一行分别运算，维度为1的对所有行运算</p> 
<p>六、矩阵运算</p> 
<p>1、如何才能进行学生成绩计算呢<br><img alt="" height="258" src="https://images2.imgbox.com/3e/e4/OLyFceIg_o.png" width="481"></p> 
<p>2、什么是矩阵<br> 矩阵，英文matrix，和array的区别矩阵必须是2维的，但是array可以是多维的</p> 
<p>3、两种方法存储矩阵<br> （1）ndarray 二维数组</p> 
<pre><code class="language-python"># 矩阵运算
# ndarray存储矩阵
data = np.array([[80,86], [82,80], [85,78], [90,90], [86,82], [82,90], [78,80], [92,94]])

data

type(data)</code></pre> 
<p><img alt="" height="511" src="https://images2.imgbox.com/69/a8/iG2U2oFY_o.png" width="1200"><br> （2）matrix 数据结构<br> np.mat()<br> 将数组转换成矩阵类型</p> 
<pre><code class="language-python"># matrix存储矩阵
data_mat = np.mat([[80,86], [82,80], [85,78], [90,90], [86,82], [82,90], [78,80], [92,94]])

data_mat

type(data_mat)</code></pre> 
<p><img alt="" height="481" src="https://images2.imgbox.com/f5/42/CO4E9H85_o.png" width="1200"></p> 
<p>4、矩阵乘法运算<br> 矩阵乘法的两个关键：形状改变和运算规则</p> 
<p>（1）形状改变<br><img alt="" height="52" src="https://images2.imgbox.com/9f/76/KXfRe7Te_o.png" width="469"></p> 
<p>必须符合上面的式子，否则运算出错。第一个矩阵的列数和第二个矩阵的行数要一致</p> 
<p>（2）运算规则<br><img alt="" height="316" src="https://images2.imgbox.com/a5/49/Mp6CArIC_o.png" width="1033"></p> 
<p>5、ndarray矩阵乘法api<br> np.matmul：矩阵相乘<br> np.dot：点乘</p> 
<p>6、计算成绩<br> ndarray存储方式</p> 
<pre><code class="language-python"># 计算成绩
data

weights = np.array([[0.3], [0.7]])

weights

np.matmul(data, weights)

np.dot(data, weights)</code></pre> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/9f/c3/9vjA0hkG_o.png" width="1200"></p> 
<p>matrix存储方式</p> 
<pre><code class="language-python">weights_mat = np.mat(weights)

weights_mat

data_mat * weights_mat</code></pre> 
<p><img alt="" height="489" src="https://images2.imgbox.com/f5/25/VkEnhhjn_o.png" width="1200"></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4e26125f5f7f8693f58b0cc1b2df3412/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">大数据存储技术（4）—— NoSQL数据库</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/46efe21134667470ca838702b0bc30e3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【组件本质学习】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>