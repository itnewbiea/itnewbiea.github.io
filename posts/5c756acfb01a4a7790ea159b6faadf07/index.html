<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spark RDD的转换 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spark RDD的转换" />
<meta property="og:description" content="按颜色区分转换：
绿色是单 RDD 窄依赖转换黑色是多 RDD 窄依赖转换紫色是 KV 洗牌型转换黄色是重分区转换蓝色是特例的转换 单 RDD 窄依赖转换 MapPartitionRDD 这个 RDD 在第一次分析中已经分析过。简单复述一下：
依赖列表：一个窄依赖，依赖上游 RDD分区列表：上游 RDD 的分区列表计算流程：映射关系（输入一个分区，返回一个迭代器）分区器 ：上游 RDD 的分区器存储位置：上游 RDD 的优先位置 可见除了计算流程，其他都是上游 RDD 的内容。 map 传入一个带“值到值”转化函数的迭代器（例如字符串到字符串长度）mapPartitions 传入一个“迭代器到迭代器”的转化函数，如果需要按分区做一些比较重的过程（例如数据库连接等）flatMap 传入一个“迭代器到迭代器的迭代器”的转化函数（例如，统计字母，“字符串的迭代器”到“‘字符的迭代器’的迭代器”）filter 传入了一个带“值到布尔值”筛选函数的迭代器 PartitionwiseSampledRDD 在分区中采样的RDD
分区列表：在上游的分区的基础上包装一个采样过程，形成一个新的分区PartitionwiseSampledRDDPartition计算流程：采样器返回的迭代器其他成分：与上游 RDD 相同 PartitionwiseSampledRDD，有放回的采样用泊松采样器，无放回的采样用伯努利采样器，传给分区器。 多 RDD 窄依赖 UnionRDD 依赖列表：每个上游 RDD 一个RangeDependency，每个RangeDependency依赖上游 RDD 的所有分区分区列表：每个上游 RDD 一个UnionPartition，构成列表计算流程：获得目标分区的迭代器分区器 ：None存储位置：每个上游 RDD 的优先位置 CartesianRDD 笛卡尔积，是两个 RDD 每个数据都进行一次关联。下文中两个 RDD 的关联中，两个 RDD 分别称为 rdd1、rdd2。
依赖列表：两个窄依赖组成的数组，分别依赖 rdd1、rdd2分区列表：“rdd1的分区数 乘以 rdd2的分区数”个分区计算流程：rdd1的一条记录与 rdd2的一条记录合成元组分区器 ：None存储位置：rdd1、rdd2的存储位置的积 洗牌型转换 洗牌型转换，是多个 RDD 关联的的转换。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5c756acfb01a4a7790ea159b6faadf07/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-13T16:00:14+08:00" />
<meta property="article:modified_time" content="2023-12-13T16:00:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spark RDD的转换</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="634" src="https://images2.imgbox.com/99/9e/ZNpoVzta_o.png" width="912"></p> 
<p><strong>按颜色区分转换：</strong></p> 
<ul><li>绿色是单 RDD 窄依赖转换</li><li>黑色是多 RDD 窄依赖转换</li><li>紫色是 KV 洗牌型转换</li><li>黄色是重分区转换</li><li>蓝色是特例的转换</li></ul> 
<h3>单 RDD 窄依赖转换</h3> 
<h4>MapPartitionRDD</h4> 
<p>这个 RDD 在第一次分析中已经分析过。简单复述一下：</p> 
<ul><li>依赖列表：一个窄依赖，依赖上游 RDD</li><li>分区列表：上游 RDD 的分区列表</li><li>计算流程：映射关系（输入一个分区，返回一个迭代器）</li><li>分区器 ：上游 RDD 的分区器</li><li>存储位置：上游 RDD 的优先位置 可见除了计算流程，其他都是上游 RDD 的内容。</li></ul> 
<ol><li>map 传入一个带“值到值”转化函数的迭代器（例如字符串到字符串长度）</li><li>mapPartitions 传入一个“迭代器到迭代器”的转化函数，如果需要按分区做一些比较重的过程（例如数据库连接等）</li><li>flatMap 传入一个“迭代器到迭代器的迭代器”的转化函数（例如，统计字母，“字符串的迭代器”到“‘字符的迭代器’的迭代器”）</li><li>filter 传入了一个带“值到布尔值”筛选函数的迭代器</li></ol> 
<h4>PartitionwiseSampledRDD</h4> 
<p>在分区中采样的RDD</p> 
<ul><li>分区列表：在上游的分区的基础上包装一个采样过程，形成一个新的分区PartitionwiseSampledRDDPartition</li><li>计算流程：采样器返回的迭代器</li><li>其他成分：与上游 RDD 相同 PartitionwiseSampledRDD，有放回的采样用泊松采样器，无放回的采样用伯努利采样器，传给分区器。</li></ul> 
<h3>多 RDD 窄依赖</h3> 
<h4>UnionRDD</h4> 
<ul><li>依赖列表：每个上游 RDD 一个RangeDependency，每个RangeDependency依赖上游 RDD 的所有分区</li><li>分区列表：每个上游 RDD 一个UnionPartition，构成列表</li><li>计算流程：获得目标分区的迭代器</li><li>分区器 ：None</li><li>存储位置：每个上游 RDD 的优先位置</li></ul> 
<h4>CartesianRDD</h4> 
<p>笛卡尔积，是两个 RDD 每个数据都进行一次关联。下文中两个 RDD 的关联中，两个 RDD 分别称为 rdd1、rdd2。</p> 
<ul><li>依赖列表：两个窄依赖组成的数组，分别依赖 rdd1、rdd2</li><li>分区列表：“rdd1的分区数 乘以 rdd2的分区数”个分区</li><li>计算流程：rdd1的一条记录与 rdd2的一条记录合成元组</li><li>分区器 ：None</li><li>存储位置：rdd1、rdd2的存储位置的积</li></ul> 
<h3>洗牌型转换</h3> 
<p>洗牌型转换，是多个 RDD 关联的的转换。</p> 
<h4>CoGroupedRDD</h4> 
<p>多个源 RDD 依据 key 关联，key 相同的合并，形成最终的目标 RDD。</p> 
<ul><li>依赖列表：每个源 RDD 一个依赖，构成列表。如果源 RDD 的分区器与目标的分区器相同，则是1-to-1依赖，如果不同，则是洗牌依赖</li><li>分区列表：目标 RDD 分区器指定的分区数量个CoGroupPartition，每个分区记录了数据来源分区。其中如果是洗牌依赖的数据源，需要洗牌过程，具体洗牌过程以后再分析</li><li>计算流程：返回一个迭代器，迭代对象是 key 和 key 对应源分区迭代器的数组 组成的元祖</li><li>分区器 ：目标 RDD 的分区器</li><li>存储位置：None</li></ul> 
<h4>ShuffledRDD</h4> 
<p>同样是多个源 RDD 依据 key 关联，key 相同的做排序或聚合运算，形成最终的目标 RDD。</p> 
<ul><li>依赖列表：一个洗牌依赖，依赖所有上游 RDD</li><li>分区列表：目标 RDD 分区器指定的分区数量个ShuffledRDDPartition，每个分区只有一个编号（因为每个上游分区）</li><li>计算流程：洗牌过程，具体洗牌过程以后再分析</li><li>分区器 ：目标 RDD 的分区器</li><li>存储位置：None</li></ul> 
<p>除了这五个成员以外，还有另外几个重要的成员：序列化器、key 排序器、聚合器、map 端合并器，他们都将用于洗牌</p> 
<h3>其他</h3> 
<ul><li>coalesce，是减少分区数量，可以在过滤之后，使数据更集中，以提高效率</li><li>repartition，是重新分区，增加或减少分区数量，数据随机重新分配，可以消除分区间的数据量差异</li><li>pipe，是与外部程序管道关联，从外部程序中获取数据。</li></ul> 
<h3>Scala语法</h3> 
<p>在 RDD.scala中，几乎每一个转换和操作函数都会有一个withScope，例如：</p> 
<pre><code>def map[U: ClassTag](f: T =&gt; U): RDD[U] = withScope {
    val cleanF = sc.clean(f)
    new MapPartitionsRDD[U, T](this, (context, pid, iter) =&gt; iter.map(cleanF))
}
def flatMap[U: ClassTag](f: T =&gt; TraversableOnce[U]): RDD[U] = withScope {
    val cleanF = sc.clean(f)
    new MapPartitionsRDD[U, T](this, (context, pid, iter) =&gt; iter.flatMap(cleanF))
}</code></pre> 
<p>withScope是一个函数，调用了RDDOperationScope.withScope方法：</p> 
<pre><code>private[spark] def withScope[U](body: =&gt; U): U = RDDOperationScope.withScope[U](sc)(body)</code></pre> 
<p>withScope就像是一个 AOP（面向切面编程），嵌入到所有RDD 的转换和操作的函数中，RDDOperationScope会把调用栈记录下来，用于绘制Spark UI的 DAG（有向无环图，可以理解为 Spark 的执行计划）。</p> 
<p>我们用下面的代码简单演示一下 Scala 用函数做 AOP：</p> 
<pre><code>object Day1 {
  def main(args: Array[String]) = {
    Range(1,5).foreach(twice)
    println()
    Array("China", "Beijing", "HelloWorld").foreach(length)
  }

  def twice(i: Int): Int = aopPrint {
    i * 2
  }

  def length(s: String): Int = aopPrint {
    s.length
  }

  def aopPrint[U](i: =&gt; U): U = {
    print(i + " ")
    i
  }
}</code></pre> 
<p>aopPrint的 入参是“一个返回类型为U的函数”。这段程序中aopPrint就是一个模拟的切面，作用是把所有的函数返回值打印出来。结果是：</p> 
<pre><code>2 4 6 8 
5 7 10</code></pre> 
<p>从代码上看，aopPrint并没有降低代码的可读性。读者依然能很清楚地读懂twice和length函数。打印返回结果这个流程是独立于函数之外的切面。</p> 
<h3>结论</h3> 
<ol><li>RDD 的转换分图上几种</li><li>RDD 的转换可以看成是产生新的 RDD，而新的 RDD 记录了每一个分区依赖上游的哪些分区、每个分区如何用上游分区计算而来</li></ol> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4c2a067a93c8b2a5d4fb8e364518f5b7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RDD是什么</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5d06af426c03cc6998be4ba201f673de/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Windows Knowledge</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>