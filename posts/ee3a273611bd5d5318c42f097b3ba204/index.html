<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JVM知识总结（简单且高效） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JVM知识总结（简单且高效）" />
<meta property="og:description" content="1. JVM内存与本地内存
JVM内存：受虚拟机内存大小的参数控制，当大小超过参数设置的大小时会报OOM。本地内存：本地内存不受虚拟机内存参数的限制，只受物理内存容量的限制；虽然不受参数的限制，如果所占内存超过物理内存，仍然会报OOM。 2. JVM内存结构
虚拟机栈：服务于Java方法本地方法栈：服务于本地方法程序计数器：保存当前线程执行的字节码位置，当然每个线程工作时都有独立的计数器。堆：用于存放对象方法区：用于存放常量、静态变量、数据类型、类信息等元数据
3. 线程独占与共享区域
独占：虚拟机栈、本地方法栈、程序计数器共享：堆、方法区 4. 栈与堆的区别
栈：是运行时单位，代表逻辑，且区域连续堆：是存储单位，代表数据，区域不连续 5. 方法区、永久代、元空间
方法区：是规范，是概念。永久代：是实现，在JDK7及之前版本，是方法区的一种实现。元空间：是实现，在JDK8及之后版本，是方法区的一种实现。（替代了永久代）
6. 元空间为什么替代了永久代
突破内存限制，减少OOM。 由于元空间使用的是本地内存，而不是 JVM 内存。提高 Full GC 的效率。 因为永久代中存放了很多 JVM 需要的类信息，这些数据大多数是不会被清理的，所以 Full GC 往往无法回收多少空间。但在元空间模型中，由于字符串常量池已移至堆中，因此可以更有效地进行垃圾回收，避免了因频繁的 Full GC 导致的性能影响。满足不同的类加载需求和动态类加载的情况。 元空间可以动态地调整大小，在一些大型的、模块化的应用中，可能需要加载大量的类，这就需要大量的元数据存储空间。避免永久代调优和大小设置的复杂性。 在 Java8 之前的版本中，通常需要手动设置永久代的大小，以避免内存溢出的错误。这增加了应用的配置和管理的复杂性。而元空间使用本地内存，根据实际需求动态调整，大大简化了内存管理的复杂性。 7. JVM内存可见性
线程对于变量的操作只能在自己的工作内存中进行，而不能直接对主存操作。
8. 类的生命周期
加载：通过类的完全限定名，查找此类字节码文件，并创建Class对象。验证：确保Class文件符合当前虚拟机的要求。准备：为static修饰的类变量分配内存，不包含final修饰的变量，因为final已经在编译时分配。解析：将常量池的符号引用替换为直接引用。初始化：静态块执行、静态变量赋值。使用：new出对象程序中使用。卸载：执行垃圾回收。
9. 符号引用和直接引用
符号引用即用**(用字符串符号的形式)**来表示引用，其实被引用的类、方法或者变量还没有被加载到内存中。而直接引用则是有具体引用地址的指针，被引用的类、方法或者变量已经被加载到内存中。 10. 类的初始化
只有对类主动使用时才会初始化，触发条件包括
创建类的实例时。访问类的静态方法或静态变量的时候。使用Class.forName反射类的时候。某个子类初始化的时候。 11. 双亲委派加载机制
AppClassLoader从缓存查找类，没有则委托给父加载器ExtClassLoaderExtClassLoader从缓存查找类，没有则委托给父加载器BootStrapClassLoaderBootStrapClassLoader从缓存查找类，没有则sun.mic.boot.class路径查找BootStrapClassLoader从sun.mic.boot.class路径查找，没有则让子类ExtClassLoader加载ExtClassLoader从java.ext.dirs路径查找，没有则让子类AppClassLoader加载AppClassLoader从java.class.path路径查找，如果找到就加载类，否则就抛出异常。
12. 双亲委派机制的优点
避免类的重复加载避免Java的核心API被篡改 13. GC如何判断对象可以被回收
引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收可达性分析法：从GC Roots开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象 14. 可达性分析算法
可达性算法中的不可达对象并不是立即死亡的，对象拥有一次自我拯救的机会当对象编程（GC Roots）不可达时，GC会判断该对象是否执行过finalize方法，若执行了则直接回收。否则，若对象未执行过finalized方法，将其放入F-Queue队列。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则对象复活。 15. 四种JVM的垃圾回收算法
标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。
标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ee3a273611bd5d5318c42f097b3ba204/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-30T18:37:58+08:00" />
<meta property="article:modified_time" content="2023-12-30T18:37:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JVM知识总结（简单且高效）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><code>1. JVM内存与本地内存</code></p> 
<blockquote> 
 <ul><li>JVM内存：受虚拟机内存大小的参数控制，当大小超过参数设置的大小时会报OOM。</li><li>本地内存：本地内存不受虚拟机内存参数的限制，只受物理内存容量的限制；虽然不受参数的限制，如果所占内存超过物理内存，仍然会报OOM。</li></ul> 
</blockquote> 
<p><code>2. JVM内存结构</code></p> 
<blockquote> 
 <ul><li>虚拟机栈：服务于Java方法</li><li>本地方法栈：服务于本地方法</li><li>程序计数器：保存当前线程执行的字节码位置，当然每个线程工作时都有独立的计数器。</li><li>堆：用于存放对象</li><li>方法区：用于存放常量、静态变量、数据类型、类信息等元数据<br> <img src="https://images2.imgbox.com/a7/d3/hJZVHUJb_o.png" alt="在这里插入图片描述"></li></ul> 
</blockquote> 
<p><code>3. 线程独占与共享区域</code></p> 
<blockquote> 
 <ul><li>独占：虚拟机栈、本地方法栈、程序计数器</li><li>共享：堆、方法区</li></ul> 
</blockquote> 
<p><code>4. 栈与堆的区别</code></p> 
<blockquote> 
 <ul><li>栈：是运行时单位，代表逻辑，且区域连续</li><li>堆：是存储单位，代表数据，区域不连续</li></ul> 
</blockquote> 
<p><code>5. 方法区、永久代、元空间</code></p> 
<blockquote> 
 <ul><li>方法区：是规范，是概念。</li><li>永久代：是实现，在JDK7及之前版本，是方法区的一种实现。</li><li>元空间：是实现，在JDK8及之后版本，是方法区的一种实现。（替代了永久代）<br> <img src="https://images2.imgbox.com/ec/92/Qh0AJChW_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/96/e7/0TPHrsWH_o.png" alt="在这里插入图片描述"></li></ul> 
</blockquote> 
<p><code>6. 元空间为什么替代了永久代</code></p> 
<blockquote> 
 <ul><li><strong>突破内存限制，减少OOM</strong>。 由于元空间使用的是本地内存，而不是 JVM 内存。</li><li><strong>提高 Full GC 的效率</strong>。 因为永久代中存放了很多 JVM 需要的类信息，这些数据大多数是不会被清理的，所以 Full GC 往往无法回收多少空间。但在元空间模型中，由于字符串常量池已移至堆中，因此可以更有效地进行垃圾回收，避免了因频繁的 Full GC 导致的性能影响。</li><li><strong>满足不同的类加载需求和动态类加载的情况</strong>。 元空间可以动态地调整大小，在一些大型的、模块化的应用中，可能需要加载大量的类，这就需要大量的元数据存储空间。</li><li><strong>避免永久代调优和大小设置的复杂性</strong>。 在 Java8 之前的版本中，通常需要手动设置永久代的大小，以避免内存溢出的错误。这增加了应用的配置和管理的复杂性。而元空间使用本地内存，根据实际需求动态调整，大大简化了内存管理的复杂性。</li></ul> 
</blockquote> 
<p><code>7. JVM内存可见性</code></p> 
<blockquote> 
 <ul><li>线程对于变量的操作只能在自己的工作内存中进行，而不能直接对主存操作。<br> <img src="https://images2.imgbox.com/51/bc/G5tmR04i_o.png" alt="在这里插入图片描述"></li></ul> 
</blockquote> 
<p><code>8. 类的生命周期</code></p> 
<blockquote> 
 <ul><li>加载：通过类的完全限定名，查找此类字节码文件，并创建Class对象。</li><li>验证：确保Class文件符合当前虚拟机的要求。</li><li>准备：为static修饰的类变量分配内存，不包含final修饰的变量，因为final已经在编译时分配。</li><li>解析：将常量池的符号引用替换为直接引用。</li><li>初始化：静态块执行、静态变量赋值。</li><li>使用：new出对象程序中使用。</li><li>卸载：执行垃圾回收。<br> <img src="https://images2.imgbox.com/03/33/d4kmrsJw_o.png" alt="在这里插入图片描述"></li></ul> 
</blockquote> 
<p><code>9. 符号引用和直接引用</code></p> 
<blockquote> 
 <ul><li>符号引用即用**(用字符串符号的形式)**来表示引用，其实被引用的类、方法或者变量还没有被加载到内存中。而直接引用则是有具体引用地址的指针，被引用的类、方法或者变量已经被加载到内存中。</li></ul> 
</blockquote> 
<p><code>10. 类的初始化</code></p> 
<blockquote> 
 <p>只有对类主动使用时才会初始化，触发条件包括</p> 
 <ul><li>创建类的实例时。</li><li>访问类的静态方法或静态变量的时候。</li><li>使用Class.forName反射类的时候。</li><li>某个子类初始化的时候。</li></ul> 
</blockquote> 
<p><code>11. 双亲委派加载机制</code></p> 
<blockquote> 
 <ul><li><code>AppClassLoader</code>从缓存查找类，没有则委托给父加载器<code>ExtClassLoader</code></li><li><code>ExtClassLoader</code>从缓存查找类，没有则委托给父加载器<code>BootStrapClassLoader</code></li><li><code>BootStrapClassLoader</code>从缓存查找类，没有则<code>sun.mic.boot.class</code>路径查找</li><li><code>BootStrapClassLoader</code>从<code>sun.mic.boot.class</code>路径查找，没有则让子类<code>ExtClassLoader</code>加载</li><li><code>ExtClassLoader</code>从<code>java.ext.dirs</code>路径查找，没有则让子类<code>AppClassLoader</code>加载</li><li><code>AppClassLoader</code>从<code>java.class.path</code>路径查找，如果找到就加载类，否则就抛出异常。<br> <img src="https://images2.imgbox.com/e1/36/G3dCNwuj_o.png" alt="在这里插入图片描述"></li></ul> 
</blockquote> 
<p><code>12. 双亲委派机制的优点</code></p> 
<blockquote> 
 <ul><li>避免类的重复加载</li><li>避免Java的核心API被篡改</li></ul> 
</blockquote> 
<p><code>13. GC如何判断对象可以被回收</code></p> 
<blockquote> 
 <ul><li><strong>引用计数法</strong>：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收</li><li><strong>可达性分析法</strong>：从GC Roots开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象</li></ul> 
</blockquote> 
<p><code>14. 可达性分析算法</code></p> 
<blockquote> 
 <ul><li>可达性算法中的不可达对象并不是立即死亡的，对象拥有一次自我拯救的机会</li><li>当对象编程（GC Roots）不可达时，GC会判断该对象是否执行过finalize方法，若执行了则直接回收。否则，若对象未执行过finalized方法，将其放入F-Queue队列。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则对象复活。</li></ul> 
</blockquote> 
<p><code>15. 四种JVM的垃圾回收算法</code></p> 
<blockquote> 
 <p><strong>标记-清除算法</strong>：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。<br> <strong>标记-整理算法</strong>：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。<br> <strong>复制算法</strong>：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。<br> <strong>分代算法</strong>：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</p> 
</blockquote> 
<p><code>16. 分代算法</code></p> 
<blockquote> 
 <ol><li>new新对象放入堆中</li><li>如果在Eden区没有空间，那就发生Minor GC，保留存活的对象</li><li>当新生代仍然没有空间，那就将部分年龄大的新生代对象放入老年代</li><li>当老年代仍然没有空间，那就发生Major GC，保留存活的对象</li><li>Major GC之后仍然没有空间，就会抛出OOM<br> <img src="https://images2.imgbox.com/58/b7/d55cmNfV_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<p><code>17. 为什么会出现OOM</code></p> 
<blockquote> 
 <ul><li>内存泄漏：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了。因为申请者不用了，而又不能被虚拟机分配给别人用</li><li>内存溢出：申请的内存超出了 JVM 能提供的内存大小，此时称之为溢出内存泄漏持续存在，最后一定会溢出，两者是因果关系</li></ul> 
</blockquote> 
<p><code>18. 常见的OOM报错</code></p> 
<blockquote> 
 <p><code>方法区溢出</code></p> 
 <ul><li>报错信息：java.lang.OutOfMemoryError: PermGen space</li><li>常见问题：一般出现于大量Class对象，或者方法区过小</li></ul> 
 <p><code>栈区溢出</code></p> 
 <ul><li>报错信息：java.lang.StackOverflowError</li><li>常见问题：一般是由于程序中存在 死循环或者深度递归调用 造成的，或者栈区过小</li></ul> 
 <p><code>堆区溢出</code></p> 
 <ul><li>报错信息：java.lang.OutOfMemoryError: Java heap space</li><li>常见问题：内存泄漏、内存溢出</li></ul> 
</blockquote> 
<p><code>19. OOM如何解决</code></p> 
<blockquote> 
 <ul><li>主要使用<code>dump文件</code>和<code>jprofiler</code>两个工具，具体自行学习</li></ul> 
</blockquote> 
<p><code>20. JVM的元空间中会发生垃圾回收吗</code></p> 
<blockquote> 
 <ul><li>垃圾回收不会发生在元空间，如果元空间满了或者是超过了临界值，会触发完全垃圾回收(FullGC)。</li><li>如果正确设置元空间大小，那么就可以避免Full GC</li></ul> 
</blockquote> 
<p><code>21. 查看相关线程命令</code></p> 
<blockquote> 
 <ul><li>jps(JVM Process Status Tool)：显示指定系统内所有的HotSpot虚拟机进程。</li><li>jstat(JVM statistics Monitoring)：显示出类装载、内存、垃圾收集、JIT编译等运行数据。</li><li>jmap(JVM Memory Map)：命令用于生成heap dump文件</li><li>jhat(JVM Heap Analysis Tool)：命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内<br> 置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看</li><li>jstack：用于生成java虚拟机当前时刻的线程快照。</li><li>jinfo(JVM Configuration info)：这个命令作用是实时查看和调整虚拟机运行参数。</li></ul> 
</blockquote> 
<p><code>22. Minor GC与Full GC分别在什么时候发生？</code></p> 
<blockquote> 
 <ul><li>新生代内存不够用时候发生MGC也叫YGC，JVM内存不够的时候发生FGC。</li></ul> 
</blockquote> 
<p><code>23. 对象一定分配在堆中吗？有没有了解逃逸分析技术？</code></p> 
<blockquote> 
 <ul><li>不一定的，JVM通过「逃逸分析」，那些逃不出方法的对象会在栈上分配。</li></ul> 
</blockquote> 
<p><code>24. 什么是逃逸分析</code></p> 
<blockquote> 
 <ul><li>方法逃逸：在一个方法体内，定义一个局部变量，而它可能被外部方法引用，比如作为调用参数传递给方法，或作为对象直接返回。或者，可以理解成对象跳出了方法。</li><li>线程逃逸：这个对象被其他线程访问到，比如赋值给了实例变量，并被其他线程访问到了。对象逃出了当前线程。</li><li>逃逸分析：没有发生逃逸的对象，会进一步优化，将其放在栈中</li></ul> 
</blockquote> 
<pre><code class="prism language-java"><span class="token comment">// sb就逃逸了</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StringBuffer</span> <span class="token function">craeteStringBuffer</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sb<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// sb没有逃逸了</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">createStringBuffer</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>25. 逃逸分析带来的好处</code></p> 
<blockquote> 
 <ul><li>同步省略：如果对象只能一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li>将堆分配转化为栈分配：对象可能是栈分配的候选，而不是堆分配。</li><li>分离对象：有的对象可以，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ul> 
</blockquote> 
<p><code>26. 逃逸分析的开启关闭</code></p> 
<blockquote> 
 <ul><li>从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis</li><li>-XX:+DoEscapeAnalysis ： 表示开启逃逸分析</li><li>-XX:-DoEscapeAnalysis ： 表示关闭逃逸分析</li></ul> 
</blockquote> 
<p><code>27. 同步省略</code><br> 在<strong>动态编译同步块</strong>的时候，<strong>JIT编译器</strong>可以借助<strong>逃逸分析</strong>来证实同步块的对象只能够被一个线程访问，就会取消对这部分代码的同步，这个过程也叫<strong>锁消除</strong>。</p> 
<p>如以下代码：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Object</span> hollis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>hollis<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hollis<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段优化成：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Object</span> hollis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hollis<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>28. 元空间为什么能替代永久代</code></p> 
<blockquote> 
 <ul><li>区别：永久代存在于JVM限制内存，元空间存在于本地内存。所以元空间会更大。</li><li>好处：能够避免方法区OOM异常，虽然我们可以通过设置永久代的大小来解决OOM，但是不是总能知道应该设置为多大合适, 如果使用默认值很容易遇到OOM错误。当使用元空间时，可以加载多少类的元数据就由系统的实际可用空间来控制啦，即元空间具有伸缩性。</li></ul> 
</blockquote> 
<p><code>29. Stop The World</code></p> 
<blockquote> 
 <ul><li>进行垃圾回收的过程中，会涉及对象的移动。为了保证对象引用更新的正确性，必须暂停所有的用户线程，像这样的停顿，虚拟机设计者形象描述为「Stop The World」，也简称STW。</li></ul> 
</blockquote> 
<p><code>30. 指针碰撞</code></p> 
<blockquote> 
 <ul><li>分配方式：一般情况下，JVM的对象都放在堆内存中（发生逃逸分析除外）。当类加载检查通过后，Java虚拟机开始为新生对象分配内存。如果Java堆中内存是绝对规整的，所有被使用过的的内存都被放到一边，空闲的内存放到另外一边，中间放着一个指针作为分界点的指示器，所分配内存仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的实例。</li><li>指针碰撞：如果现在两个线程同时创建对象呢？<br> <img src="https://images2.imgbox.com/16/1a/d3Mip0XC_o.png" alt="在这里插入图片描述"></li></ul> 
</blockquote> 
<p><code>31. 空闲列表</code></p> 
<blockquote> 
 <ul><li>如果Java堆内存中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，不可以进行指针碰撞啦，虚拟机必须维护一个列表，记录哪些内存是可用的，在分配的时候从列表找到一块大的空间分配给对象实例，并更新列表上的记录，这种分配方式就是空闲列表。</li></ul> 
</blockquote> 
<p><code>32. 什么是TLAB</code></p> 
<blockquote> 
 <ul><li>每个线程都有自己的一小块内存，这就是TLAB（Thread Local Allocation Buffer，本地线程分配缓存） 。虚拟机通过 -XX:UseTLAB 设定它的。</li></ul> 
</blockquote> 
<p><code>33. JVM有哪些垃圾回收器</code></p> 
<blockquote> 
 <ul><li>Serial：新生代、单线程、复制算法（适用于小堆、单核）</li><li>ParScavenge：新生代、多线程、复制算法、高吞吐</li><li>Serial Old：老年代、单线程、标记-整理（适用于大堆、多核）</li><li>ParOld：老年代、多线程、标记-整理、低交互</li><li>CMS：老年代、多线程、标记-整理、低停顿低吞吐</li><li>G1：全堆、多线程、标记-整理</li></ul> 
</blockquote> 
<h2><a id="_210"></a>附录</h2> 
<p>「堆栈内存相关」</p> 
<blockquote> 
 <p>-Xms 设置初始堆的大小<br> -Xmx 设置最大堆的大小<br> -Xmn 设置年轻代大小，相当于同时配置-XX:NewSize和-XX:MaxNewSize为一样的值<br> -Xss 每个线程的堆栈大小<br> -XX:NewSize 设置年轻代大小(for 1.3/1.4)<br> -XX:MaxNewSize 年轻代最大值(for 1.3/1.4)<br> -XX:NewRatio 年轻代与年老代的比值(除去持久代)<br> -XX:SurvivorRatio Eden区与Survivor区的的比值<br> -XX:PretenureSizeThreshold 当创建的对象超过指定大小时，直接把对象分配在老年代。<br> -XX:MaxTenuringThreshold设定对象在Survivor复制的最大年龄阈值，超过阈值转移到<br> 老年代</p> 
</blockquote> 
<p>「垃圾收集器相关」</p> 
<blockquote> 
 <p>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。<br> -XX:ParallelGCThreads=20：配置并行收集器的线程数<br> -XX:+UseConcMarkSweepGC：设置年老代为并发收集。<br> -XX:CMSFullGCsBeforeCompaction=5 由于并发收集器不对内存空间进行压缩、整理，<br> 所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行5次GC以后对内<br> 存空间进行压缩、整理。<br> -XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是<br> 可以消除碎片</p> 
</blockquote> 
<p>「辅助信息相关」</p> 
<blockquote> 
 <p>-XX:+PrintGCDetails 打印GC详细信息<br> -XX:+HeapDumpOnOutOfMemoryError让JVM在发生内存溢出的时候自动生成内存快照,<br> 排查问题用<br> -XX:+DisableExplicitGC禁止系统System.gc()，防止手动误触发FGC造成问题.<br> -XX:+PrintTLAB 查看TLAB空间的使用情况</p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4aa85d38553864d680cd30262bb1eb1a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">什么是IDE，新手用哪个IDE比较好</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6931592e095ef18b116d98932bfbd5b0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机组成原理-总线概述</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>