<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C/C&#43;&#43;程序设计面试题目整理 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C/C&#43;&#43;程序设计面试题目整理" />
<meta property="og:description" content="文章目录 1.C/C&#43;&#43;程序基础1.1 C和C&#43;&#43;的区别面向对象程序设计的主要优点面向过程和面向对象编程区别 1.2 模块化程序设计1.3 C&#43;&#43;主函数前后执行的语句主函数能不能有参数 1.4 常用的循环结构：for,while,dowhile1.5 i&#43;&#43;和&#43;&#43;i的效率区别（后缀自增运算符与前缀自增运算符）1.6 不使用临时变量替换a与b的值1.7 if..else和switch区别1.8以分号结束和不以分数结束的语句 2.预处理、const、static和sizeofconst作用 2.2 include预编译指令：将被包含的头文件插入到该编译指令的位置。include头文件&lt;&gt;和&#34;&#34;区别条件编译与头文件保护 2.3 static作用、类静态成员和方法2.4 sizeof和strlen区别2.5 typedef和define区别2.6 内联函数：替代宏定义来解决函数调用的效率问题为什么函数不全部替换成内联函数？内联函数与宏定义区别？ 3.引用和指针3.1 引用和指针区别3.2 什么是野指针3.3 为什么有了malloc/free，还要有new/delete3.4 内存分配/释放函数及区别：malloc、calloc、realloc、free等 4.字符串4.1 strcpy和memcopy区别 6.面向对象6.1 类的特性：封装、继承、多态（面向对象三大特征）、抽象、重载类和对象区别 6.2 struct和clas区别6.3 C&#43;&#43;空类中默认产生哪些成员函数：默认构造函数、复制构造函数、析构函数、赋值函数和取址函数6.4 简要说明构造函数与析构函数复制构造函数：特殊的构造函数，完成同一类其他对象的初始化深拷贝与浅拷贝区别 初始化列表：可在构造函数初始化列表初始化成员虚析构函数：当一个类作为基类时，虚析构函数会先执行子类虚构函数 6.5 复制构造函数和赋值函数区别6.6 什么是内存泄漏6.7 访问修饰符与继承方式 7.多态和继承7.1 多态：同一操作作用于不同的对象，可以有不同的解释，产生不同类型的执行结果虚函数：允许用基类的指针来调用 子类对应的虚函数实现纯虚函数与抽象类：含有纯虚函数的类被称为抽象类 重载：同一作用域中多个同名函数，形参列表必须不同覆盖（重写）：覆盖基类虚函数（参数必须相同）隐藏与覆盖的区别 7.2 抽象类（概念，并有具体对应）接口（概念，无具体对应。对应 仅纯虚函数的抽象类） 7.3 多继承：一个类有多个基类,这样的继承关系称为多继承多继承重复调用同一基类构造函数造成二义性：虚继承解决多继承的二义性问题 7.4 接口继承和实现继承7.5 this指针的含义：指向成员函数作用的对象7.6 类对象与类指针： 8.数据结构8.1 两个栈实现队列 10.泛型编程：多种数据类型皆可操作（模板实现）10.1 函数模板与类模板10.2 模板缺点 1.C/C&#43;&#43;程序基础 1.1 C和C&#43;&#43;的区别 （1）C是结构化语言，偏向于面向过程，它的重点在于设计算法和数据结构。
（2）C是偏向于面向对象的语言。C&#43;&#43;扩展了面向对象的功能，如类、继承、模板、虚函数等，不仅要考虑封装，还要考虑对象接口的设计、继承使用等问题。
（3）最大区别在于解决问题的思想不同，C考虑的是如何通过一个过程来完成任务，C&#43;&#43;考虑的是如何构造一个对象模型，让这个模型能配合对应的问题。
（4）C&#43;&#43;拥有面向对象的特征但是也可以实现过程化的程序，Java才是真正面向对象的。
延伸，C和C&#43;&#43;具体区别：
1、从机制上：
C是面向过程的结构化编程语言（但也可以编写面向对象的程序），偏向于面向过程的程序设计
C&#43;&#43;是面向对象的，提供了类。侧重于类的设计而不是过程的设计。
2、从适用的方向：
C适合代码体积小的，效率高的场合，如嵌入式；
C&#43;&#43;适合更上层的，复杂的场合。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b2ecdf5493b5c737cf9675200a921a87/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-30T00:06:20+08:00" />
<meta property="article:modified_time" content="2020-04-30T00:06:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C/C&#43;&#43;程序设计面试题目整理</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1CC_2" rel="nofollow">1.C/C++程序基础</a></li><li><ul><li><a href="#11_CC_4" rel="nofollow">1.1 C和C++的区别</a></li><li><ul><li><a href="#_42" rel="nofollow">面向对象程序设计的主要优点</a></li><li><a href="#_55" rel="nofollow">面向过程和面向对象编程区别</a></li></ul> 
   </li><li><a href="#12__66" rel="nofollow">1.2 模块化程序设计</a></li><li><a href="#13_C_83" rel="nofollow">1.3 C++主函数前后执行的语句</a></li><li><ul><li><a href="#_100" rel="nofollow">主函数能不能有参数</a></li></ul> 
   </li><li><a href="#14_forwhiledowhile_112" rel="nofollow">1.4 常用的循环结构：for,while,dowhile</a></li><li><a href="#15_ii_134" rel="nofollow">1.5 i++和++i的效率区别（后缀自增运算符与前缀自增运算符）</a></li><li><a href="#16_ab_157" rel="nofollow">1.6 不使用临时变量替换a与b的值</a></li><li><a href="#17_ifelseswitch_169" rel="nofollow">1.7 if..else和switch区别</a></li><li><a href="#18_188" rel="nofollow">1.8以分号结束和不以分数结束的语句</a></li></ul> 
  </li><li><a href="#2conststaticsizeof_208" rel="nofollow">2.预处理、const、static和sizeof</a></li><li><ul><li><ul><li><a href="#const_209" rel="nofollow">const作用</a></li></ul> 
   </li><li><a href="#22_include_223" rel="nofollow">2.2 include预编译指令：将被包含的头文件插入到该编译指令的位置。</a></li><li><ul><li><a href="#include_227" rel="nofollow">include头文件&lt;&gt;和""区别</a></li><li><a href="#_235" rel="nofollow">条件编译与头文件保护</a></li></ul> 
   </li><li><a href="#23_static_246" rel="nofollow">2.3 static作用、类静态成员和方法</a></li><li><a href="#24_sizeofstrlen_262" rel="nofollow">2.4 sizeof和strlen区别</a></li><li><a href="#25_typedefdefine_270" rel="nofollow">2.5 typedef和define区别</a></li><li><a href="#26__281" rel="nofollow">2.6 内联函数：替代宏定义来解决函数调用的效率问题</a></li><li><ul><li><a href="#_291" rel="nofollow">为什么函数不全部替换成内联函数？</a></li><li><a href="#_295" rel="nofollow">内联函数与宏定义区别？</a></li></ul> 
  </li></ul> 
  </li><li><a href="#3_307" rel="nofollow">3.引用和指针</a></li><li><ul><li><a href="#31__312" rel="nofollow">3.1 引用和指针区别</a></li><li><a href="#32___326" rel="nofollow">3.2 什么是野指针</a></li><li><a href="#33_mallocfreenewdelete_331" rel="nofollow">3.3 为什么有了malloc/free，还要有new/delete</a></li><li><a href="#34_malloccallocreallocfree_337" rel="nofollow">3.4 内存分配/释放函数及区别：malloc、calloc、realloc、free等</a></li></ul> 
  </li><li><a href="#4_350" rel="nofollow">4.字符串</a></li><li><ul><li><a href="#41_strcpymemcopy_351" rel="nofollow">4.1 strcpy和memcopy区别</a></li></ul> 
  </li><li><a href="#6_357" rel="nofollow">6.面向对象</a></li><li><ul><li><a href="#61__358" rel="nofollow">6.1 类的特性：封装、继承、多态（面向对象三大特征）、抽象、重载</a></li><li><ul><li><a href="#_380" rel="nofollow">类和对象区别</a></li></ul> 
   </li><li><a href="#62_structclas_393" rel="nofollow">6.2 struct和clas区别</a></li><li><a href="#63_C_408" rel="nofollow">6.3 C++空类中默认产生哪些成员函数：默认构造函数、复制构造函数、析构函数、赋值函数和取址函数</a></li><li><a href="#64__413" rel="nofollow">6.4 简要说明构造函数与析构函数</a></li><li><ul><li><a href="#_446" rel="nofollow">复制构造函数：特殊的构造函数，完成同一类其他对象的初始化</a></li><li><ul><li><a href="#_451" rel="nofollow">深拷贝与浅拷贝区别</a></li></ul> 
    </li><li><a href="#_464" rel="nofollow">初始化列表：可在构造函数初始化列表初始化成员</a></li><li><a href="#_491" rel="nofollow">虚析构函数：当一个类作为基类时，虚析构函数会先执行子类虚构函数</a></li></ul> 
   </li><li><a href="#65__496" rel="nofollow">6.5 复制构造函数和赋值函数区别</a></li><li><a href="#66__509" rel="nofollow">6.6 什么是内存泄漏</a></li><li><a href="#67__514" rel="nofollow">6.7 访问修饰符与继承方式</a></li></ul> 
  </li><li><a href="#7_542" rel="nofollow">7.多态和继承</a></li><li><ul><li><a href="#71__543" rel="nofollow">7.1 多态：同一操作作用于不同的对象，可以有不同的解释，产生不同类型的执行结果</a></li><li><ul><li><a href="#__552" rel="nofollow">虚函数：允许用基类的指针来调用 子类对应的虚函数实现</a></li><li><ul><li><a href="#_571" rel="nofollow">纯虚函数与抽象类：含有纯虚函数的类被称为抽象类</a></li></ul> 
    </li><li><a href="#_592" rel="nofollow">重载：同一作用域中多个同名函数，形参列表必须不同</a></li><li><a href="#_594" rel="nofollow">覆盖（重写）：覆盖基类虚函数（参数必须相同）</a></li><li><ul><li><a href="#_608" rel="nofollow">隐藏与覆盖的区别</a></li></ul> 
   </li></ul> 
   </li><li><a href="#72__622" rel="nofollow">7.2 抽象类（概念，并有具体对应）</a></li><li><ul><li><a href="#__635" rel="nofollow">接口（概念，无具体对应。对应 仅纯虚函数的抽象类）</a></li></ul> 
   </li><li><a href="#73__654" rel="nofollow">7.3 多继承：一个类有多个基类,这样的继承关系称为多继承</a></li><li><ul><li><a href="#_660" rel="nofollow">多继承重复调用同一基类构造函数造成二义性：</a></li><li><a href="#_677" rel="nofollow">虚继承解决多继承的二义性问题</a></li></ul> 
   </li><li><a href="#74__703" rel="nofollow">7.4 接口继承和实现继承</a></li><li><a href="#75_this_721" rel="nofollow">7.5 this指针的含义：指向成员函数作用的对象</a></li><li><a href="#76__729" rel="nofollow">7.6 类对象与类指针：</a></li></ul> 
  </li><li><a href="#8_758" rel="nofollow">8.数据结构</a></li><li><ul><li><a href="#81__759" rel="nofollow">8.1 两个栈实现队列</a></li></ul> 
  </li><li><a href="#10_767" rel="nofollow">10.泛型编程：多种数据类型皆可操作（模板实现）</a></li><li><ul><li><a href="#101__768" rel="nofollow">10.1 函数模板与类模板</a></li><li><a href="#102__816" rel="nofollow">10.2 模板缺点</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1CC_2"></a>1.C/C++程序基础</h2> 
<h3><a id="11_CC_4"></a>1.1 C和C++的区别</h3> 
<p><strong>（1）C是结构化语言，偏向于面向过程，它的重点在于设计算法和数据结构。</strong></p> 
<p><strong>（2）C是偏向于面向对象的语言。C++扩展了面向对象的功能，如类、继承、模板、虚函数等，不仅要考虑封装，还要考虑对象接口的设计、继承使用等问题。</strong></p> 
<p>（3）最大区别在于解决问题的思想不同，C考虑的是如何通过一个过程来完成任务，C++考虑的是如何构造一个对象模型，让这个模型能配合对应的问题。</p> 
<p>（4）C++拥有面向对象的特征但是也可以实现过程化的程序，Java才是真正面向对象的。</p> 
<p><br><br></p> 
<p><strong>延伸，C和C++具体区别：</strong><br> 1、从机制上：<br> C是面向过程的结构化编程语言（但也可以编写面向对象的程序），偏向于面向过程的程序设计<br> C++是面向对象的，提供了类。侧重于类的设计而不是过程的设计。</p> 
<br> 
<p>2、从适用的方向：<br> C适合代码体积小的，效率高的场合，如嵌入式；<br> C++适合更上层的，复杂的场合。</p> 
<br> 
<p>3、语法的细微差异：<br> （1）C语言中没有特定的字符串类型，我们通常是将字符串放在一个字符数组中<br> c++和c中字符串：c++是类，c中是基本类型函数。</p> 
<p>（2）C语言的结构体只是复杂的数据类型，而C++的结构体拥有类的功能。</p> 
<p><br><br></p> 
<h4><a id="_42"></a>面向对象程序设计的主要优点</h4> 
<p>使程序设计者摆脱具体的数据格式和过程的束缚，极大减少软件开发的复杂性，提高软件开发效率。</p> 
<p>优点：<br> （1）提高程序的重用性<br> （2）控制程序的复杂性<br> （3）改善程序的可维护性<br> （4）能更好地支持大型程序设计<br> （5）增强计算机处理信息的范围<br> （6）能更好地适应新的硬件环境</p> 
<p><br><br></p> 
<h4><a id="_55"></a>面向过程和面向对象编程区别</h4> 
<p>1)面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用</p> 
<p>2)面向对象是把构成问题事物分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为</p> 
<p><strong>3）总的来说，面向对象就是高度事物抽象化，而面向过程就是自顶向下的编程</strong></p> 
<p><br><br></p> 
<h3><a id="12__66"></a>1.2 模块化程序设计</h3> 
<p><strong>模块化程序设计：是指在进行程序设计时将一个大程序按照功能划分为若干小程序模块，每个小程序模块完成一个确定的功能，并在这些模块之间建立必要的联系，通过模块的互相协作完成整个程序功能（的程序设计方法）</strong><br> <br></p> 
<p><strong>模块化程序设计意义：</strong><br> 1）模块化程序设计的思想基本思想是自顶向下、逐步分解、分而治之。即将一个较大的程序按照功能分割成一些小模块，各模块相互独立、功能单一、结构清晰、接口简单</p> 
<p>2）降低程序复杂度，使程序设计、调试和维护等操作简单化</p> 
<p>3）提高了代码的重用性</p> 
<p>4）易于维护和功能扩充</p> 
<p>5）有利于团队开发<br> <br><br></p> 
<h3><a id="13_C_83"></a>1.3 C++主函数前后执行的语句</h3> 
<p><strong>主函数前执行的语句：全局对象的构造函数（构造全局自定义的 对象）。</strong></p> 
<p>一个程序的启动函数这个可以采用链接器来设置，但是gcc中默认main就是C语言的入口函数。<br> 在main函数启动之前，内核会调用一个特殊的启动例程，这个启动例程从内核中取得命令行参数值和环境变量值，为调用main函数做好准备，因此对应程序而言main函数并不是起始，但是对应C 语言而言，main函数就是入口地址，其</p> 
<br> 
<p><strong>主函数后执行的语句：可以用atexit函数来注册程序正常中止时要被调用的函数，并且在main函数结束时调用这些函数（调用顺序与注册顺序相反）</strong><br> 只可以注册无返回值无参数的函数。</p> 
<p><br><br></p> 
<h4><a id="_100"></a>主函数能不能有参数</h4> 
<p>可以。</p> 
<p>第一个参数表示参数的个数</p> 
<p>第二个参数是参数的向量，是一个指向字符串数组的指针，其中每个字符串对应一个参数。</p> 
<p>第三个参数是环境变量。</p> 
<p><br><br></p> 
<h3><a id="14_forwhiledowhile_112"></a>1.4 常用的循环结构：for,while,dowhile</h3> 
<p>for：知道循环次数，先判断后循环</p> 
<p>while：不知道循环次数，先判断后循环</p> 
<p>dowhile：不知道循环次数。先循环后判断</p> 
<br> 
<p><strong>for循环和while循环是否任何时候都可以互相转化？</strong><br> 可以。<br> 不过for循环适用于已知循环次数，while循环适用于未知循环次数的时候</p> 
<p><br><br></p> 
<h3><a id="15_ii_134"></a>1.5 i++和++i的效率区别（后缀自增运算符与前缀自增运算符）</h3> 
<p><strong>内建数据类型的情况，效率没有区别。<br> 自定义数据类型的情况，++i效率较高。</strong></p> 
<p>当处理自定义数据类型（类、结构体）时，尽量使用前缀自增运算符，因为（++i）可以返回对象的引用，而后缀（i++）必须返回对象的值</p> 
<p><br><br></p> 
<p>后缀运算符：先对变量运算后自增。</p> 
<p>符号争夺优先级（*与++、–同一级，右结合律，从右向左）</p> 
<pre><code class="prism language-cpp">cout<span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">++</span>   先输出<span class="token operator">*</span>p<span class="token punctuation">,</span>后（<span class="token operator">*</span>p）值<span class="token operator">+</span><span class="token number">1</span>

cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>p<span class="token operator">++</span>   先输出<span class="token operator">*</span>p<span class="token punctuation">,</span>再p<span class="token operator">++</span>

cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>（p<span class="token operator">++</span>）  等同于<span class="token operator">*</span>p<span class="token operator">++</span><span class="token punctuation">,</span>（两个都可以理解为，先p<span class="token operator">++</span>，然后<span class="token operator">*</span>p   <span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span>    <span class="token operator">++</span>函数中<span class="token keyword">return</span>原来的p ）
</code></pre> 
<p><br><br></p> 
<h3><a id="16_ab_157"></a>1.6 不使用临时变量替换a与b的值</h3> 
<pre><code class="prism language-cpp">a<span class="token operator">=</span>a<span class="token operator">+</span>b<span class="token punctuation">;</span>
b<span class="token operator">=</span>a<span class="token operator">-</span>b<span class="token punctuation">;</span>
a<span class="token operator">=</span>a<span class="token operator">-</span>b<span class="token punctuation">;</span>
</code></pre> 
<p><br><br></p> 
<h3><a id="17_ifelseswitch_169"></a>1.7 if…else和switch区别</h3> 
<p><strong>总结：都是条件选中语句。但switch语句只能取代if语句的一部分功能。</strong></p> 
<p><strong>（1）比较的范围不同：</strong><br> <strong>if 语句可做各种关系比较</strong>（只要是 boolean 表达式都可以用 if 判断）</p> 
<p><strong>switch语句只能做等式比较，即只能对基本类型进行数值比较。</strong> (switch只能做几个数据类型的等式比较，实现非等式效率低，)<br> switch之后括号内的表达式只能是整型（byte、short、char和int）、枚举型或字符型表达式，不能是长整型或其他任何类型。<br> <br></p> 
<p><strong>(2)效率不同：</strong><br> if 语句每次判断都要读写寄存器一次，判断多效率低。</p> 
<p>switch 一次性读取要判断的值，判断多效率高</p> 
<p><br><br></p> 
<h3><a id="18_188"></a>1.8以分号结束和不以分数结束的语句</h3> 
<p>以分号结束：<br> 结构体定义加分号<br> C++强制规定类在定义和声明时，结尾必来须加分号.</p> 
<p>不加分号：<br> 预编译指令<br> 函数定义</p> 
<p><br></p> 
<hr> 
<br> 
<p></p> 
<h2><a id="2conststaticsizeof_208"></a>2.预处理、const、static和sizeof</h2> 
<h4><a id="const_209"></a>const作用</h4> 
<p><strong>（1）定义常量（在程序数据段-静态区中）</strong></p> 
<p>（2）修饰引用传参（自定义数据类型，防止引用对象不小心改变了对象）</p> 
<p>（3）修饰函数返回值（返回值在静态区），则返回值只能赋值给同为const的变量</p> 
<p>（4）修饰成员函数（成员函数后加 const），表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。<br> 规则：const离谁近，谁就不能被修改；</p> 
<p><br><br></p> 
<h3><a id="22_include_223"></a>2.2 include预编译指令：将被包含的头文件插入到该编译指令的位置。</h3> 
<p>（这个过程是递归进行的，因为被包含的文件可能还包含了其他文件）<br> <br></p> 
<h4><a id="include_227"></a>include头文件&lt;&gt;和""区别</h4> 
<p>&lt;&gt;表明文件是一个工程或标准头文件，查找过程将首先检查 预定义目录。</p> 
<p>双引号表明文件是用户提供的头文件，查找时在当前目录下找，然后再在标准文件寻找。</p> 
<br> 
<h4><a id="_235"></a>条件编译与头文件保护</h4> 
<p><strong>条件编译：有时候希望只对其中一部分内容进行编译.此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃。</strong><br> <br></p> 
<p><strong>头文件保护：头文件中允许包含其它的头文件，为避免头文件被重复包含，可在其中使用条件编译。</strong></p> 
<p><br><br></p> 
<h3><a id="23_static_246"></a>2.3 static作用、类静态成员和方法</h3> 
<p><strong>static<br> （1）静态全局变量作用域只在定义该变量的源文件。全局变量作用域是整个源程序（可能为多个源文件）（作用域不同·）<br> （2）静态局部变量只能被其作用域内的变量和函数进行访问使用，数据存放在全局数据区，只初始化一次。（存储方式不同）<br> （3）静态函数作用域仅在本文件（静态函数在内存只有一份，代码区？），非静态函数每个调用保持一份复制品。</strong><br> <br></p> 
<p><strong>（4）类的静态成员和方法不属于类的实例，而属于类本身，并在所有类的实例间共享。（不含this指针，静态成员函数无法调用非静态数据成员）<br> 类中不可以初始化，只能在类外全局作用域初始化（默认为0），静态成员可以独立访问，无需依赖任何对象的建立（通过域操作符）</strong></p> 
<p>静态数据成员比全局变量的优势：（1）静态数据成员没进入全局区，所以不会和其他全局变量名字冲突（2）静态数据成员可以用private隐藏信息，全局变量不行。</p> 
<p><br><br></p> 
<h3><a id="24_sizeofstrlen_262"></a>2.4 sizeof和strlen区别</h3> 
<p>（1）sizeof是操作符、strlen是函数<br> （2）sizeof参数可以是类型，str参数只能是字符指针且必须以结束符‘\0’作结尾。<br> （3）sizeof是计算对象分配内存空间的大小，strlen是从某个位置开始计数，到结束符停止返回计数值。</p> 
<p><br><br></p> 
<h3><a id="25_typedefdefine_270"></a>2.5 typedef和define区别</h3> 
<p><strong>typedeff是关键字，对已经存在的数据类型取别名。<br> 在编译阶段处理，会进行类型检查，只能在定义的作用域内使用。</strong><br> <br></p> 
<p><strong>define是预处理指令（宏定义），只进行简单的字符替换，是否产生错误要在编译时才可知。<br> 没有作用域限制，可以对类型/变量/常量等进行替换</strong></p> 
<p><br><br></p> 
<h3><a id="26__281"></a>2.6 内联函数：替代宏定义来解决函数调用的效率问题</h3> 
<p>（1）inline定义的类的内联函数，代码被放入符号表中，在使用时直接进行替换（像宏一样展开），没有了调用的开销，提升了效率。<br> （2）类的内联函数是一个真正的函数，调用内联函数时会进行一系列的相关检查，消除了隐患。</p> 
<p>（3）inline可以作为某个类的成员函数，从而使用类的成员（保护私有公有）</p> 
<br> 
<h4><a id="_291"></a>为什么函数不全部替换成内联函数？</h4> 
<p>内联是以代码膨胀（复制）为代价的，仅仅省去了调用的开销，执行函数体内代码比较长（或内联中有循环）就会消耗内存，失去意义。</p> 
<h4><a id="_295"></a>内联函数与宏定义区别？</h4> 
<p>（1）宏定义在预编译时展开，内联函数在编译时展开。<br> （2）编译时内联可被镶嵌到目标代码中，宏定义只是字符替换。<br> （3）内联函数有一系列的安全性检查<br> （4）内联函数是函数<br> （5）宏容易出现二义性</p> 
<p><br><br></p> 
<h2><a id="3_307"></a>3.引用和指针</h2> 
<p><strong>基本数据类型的特点：直接存储在栈(stack)中的数据</strong><br> <br></p> 
<h3><a id="31__312"></a>3.1 引用和指针区别</h3> 
<p><strong>1）引用需要初始化，指针不需要（可以只声明不初始化）。</strong><br> 不存在指向空值的引用，但存在指向空值的指针。</p> 
<p><strong>2）引用初始化之后不能被改变（所引用的变量不能改变），指针可以改变所指的对象</strong><br> 引用：引用一个现有的变量来声明一个别名变量</p> 
<p><br><br></p> 
<h3><a id="32___326"></a>3.2 什么是野指针</h3> 
<p>野指针不是NULL指针，而是指向垃圾内存的指针。<br> 成因主要为：指针变量没有被初始化，或指针p被free或delete之后，没有置为NULL<br> <br><br></p> 
<h3><a id="33_mallocfreenewdelete_331"></a>3.3 为什么有了malloc/free，还要有new/delete</h3> 
<p>对于非内部数据类型的对象而言，对象在消亡之前要自动执行析构函数。<br> 由于malloc/free是库函数，不在编译器控制权限之内，不能把执行构造函数和析构函数的任务强加于malloc/free，因此只有使用new/delete运算符。</p> 
<p><br><br></p> 
<h3><a id="34_malloccallocreallocfree_337"></a>3.4 内存分配/释放函数及区别：malloc、calloc、realloc、free等</h3> 
<p>1、malloc：一块内存，一块长度为size的内存，返回首地址，内存里面值没有初始化，是随机数。<br> calloc是分配n块内存，n块长度为size的内存，返回首地址，内存值初始化为0</p> 
<p>2、realloc将原有内存大小增加到size大小，新增内存未初始化</p> 
<p>3、free：释放ptr（内存空间指针）所指向的内存空间</p> 
<p>new、free可以调用类的构造函数和析构函数。<br> <br></p> 
<hr> 
<br> 
<p></p> 
<h2><a id="4_350"></a>4.字符串</h2> 
<h3><a id="41_strcpymemcopy_351"></a>4.1 strcpy和memcopy区别</h3> 
<p>strpy：只能复制字符串，不需要指定长度，遇到结束符停止</p> 
<p>memorycopy：可以复制任何内容，需要一个参数来指定长度.<br> <br><br></p> 
<h2><a id="6_357"></a>6.面向对象</h2> 
<h3><a id="61__358"></a>6.1 类的特性：封装、继承、多态（面向对象三大特征）、抽象、重载</h3> 
<p><strong>1、封装：隐藏对象的属性和实现细节，仅对外公开接口 。</strong></p> 
<p>（1）将抽象得到的属性和（属性上的）方法相结合，形成一个有机的整体，形成“类”，其中数据和函数都是类的成员。</p> 
<p>（2）封装使得代码模块化</p> 
<br> 
<p><strong>2、继承 ：使得子类具有父类的属性和方法或者重新定义、追加属性和方法等</strong><br> （1）继承是使代码可以复用的重要手段，也是面向对象程序设计的核心思想之一。</p> 
<p>（2）继承就是不修改原有的类，直接利用原来的类的属性和方法并进行扩展。<br> 原来的类称为基类，继承的类称为派生类，他们的关系就像父子一样，所以又叫父类和子类。</p> 
<p><br><br></p> 
<h4><a id="_380"></a>类和对象区别</h4> 
<p>1）类是事物的描述和抽象，是具有相同属性和行为的对象集合，类是用于创建对象的蓝图。</p> 
<p>对象是类的实例，是具体存在的事物，明确定义状态和行为<br> <br></p> 
<p>2）类是抽象的，不占用内存，而对象是具体的，占有存储空间，</p> 
<p><br><br></p> 
<h3><a id="62_structclas_393"></a>6.2 struct和clas区别</h3> 
<p><strong>1、C语言struct：<br> 只是一个复杂的数据结构，定义成员变量时不可以初始化值，而且不可以定义成员函数。结构体不能为空</strong></p> 
<p><strong>2、C++ struct：<br> 可以实现面向对象，成员默认访问权限和继承方式为public，不可以用于表示模板类型。</strong><br> （C++中保留struct关键字是为了使C++编译器能够兼容C语言开发的程序）</p> 
<p><strong>3、C++ Class：成员访问权限和继承方式默认为private，可以用于表示模板类型。</strong></p> 
<p><br><br></p> 
<h3><a id="63_C_408"></a>6.3 C++空类中默认产生哪些成员函数：默认构造函数、复制构造函数、析构函数、赋值函数和取址函数</h3> 
<p><br><br></p> 
<h3><a id="64__413"></a>6.4 简要说明构造函数与析构函数</h3> 
<p>构造、析构函数的名称与类的名称相同。为了区分，析构函数名字前面有~<br> 都无返回值，都不能被直接调用 （像调用其他成员函数一样）</p> 
<br> 
<p><strong>1、构造函数：用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</strong></p> 
<p>（1）构造函数可以重载，因为构造函数可以有多个，且可以带参数。</p> 
<p>（2）调用不带参数的构造函数不需要小括号</p> 
<p>（3）定义了自定义构造函数后，编译器是不会创建默认无参构造函数的</p> 
<p>（4）初始化类时自动调用构造函数，可通过new调用</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> Test
<span class="token punctuation">{<!-- --></span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"调用无参构造函数"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>Test a<span class="token punctuation">;</span><span class="token comment">//无参不加括号}</span>
</code></pre> 
<br> 
<p><strong>构造函数：完成与构造函数相反的工作，对象退出生命周期时，完成清理的工作如释放内存</strong><br> （1）不可重载，只能有一个，而且不能有参数</p> 
<p>（2）当类中有动态内存分配时，需要增加自定义的析构函数，否则有可能导致内存泄漏。</p> 
<p>（3）对象退出作用域时自动调用析构函数，释放对象，可通过delete调用<br> <br><br></p> 
<h4><a id="_446"></a>复制构造函数：特殊的构造函数，完成同一类其他对象的初始化</h4> 
<p>如果用户没有定义复制构造函数，并且在代码中用到了复制构造函数，编译器会生成默认的复制构造函数。<br> 但如果用户定义了复制构造函数，那么编译器不会再生成复制构造函数。<br> <br><br></p> 
<h5><a id="_451"></a>深拷贝与浅拷贝区别</h5> 
<p>深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。（也就是对象）</p> 
<p><strong>浅复制：新旧对象指向同一个外部内容。</strong><br> 只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存<br> <br></p> 
<p><strong>深复制：为新对象制造了外部对象的独立复制。</strong><br> 会另外创造一个一模一样的对象，新对象跟原对象不共享内存。</p> 
<p><br><br></p> 
<h4><a id="_464"></a>初始化列表：可在构造函数初始化列表初始化成员</h4> 
<p><strong>1、使用情况<br> 当类中含有const、reference成员变量和基类的构造函数时都需要初始化列表</strong></p> 
<p>const、reference只能被初始化不能被赋值，基类的构造函数也不能直接调用。</p> 
<br> 
<p><strong>2、构造顺序<br> 初始化内置数据类型（自定义类型也是）：构造顺序与变量声明顺序一致</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> Test
<span class="token punctuation">{<!-- --></span>
<span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">j</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">i</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token comment">//先执行i=j（随机数），再执行j=k=2；</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>  <span class="token comment">//先声明的i</span>
    <span class="token keyword">int</span> j<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><br><br></p> 
<h4><a id="_491"></a>虚析构函数：当一个类作为基类时，虚析构函数会先执行子类虚构函数</h4> 
<p>防止内存泄漏。</p> 
<p><br><br></p> 
<h3><a id="65__496"></a>6.5 复制构造函数和赋值函数区别</h3> 
<p><strong>（1）复制构造函数是用一个对象来初始化一个内存空间，这块内存就是新对象的内存。</strong></p> 
<p><strong>（2）复制构造函数首先是一个构造函数，通过参数传递的对象来初始化产生一个对象。</strong><br> 赋值函数是把一个对象赋值给一个原有的对象（先把原有对象内存释放）</p> 
<p><strong>（3）对数据成员为指针对象的操作，一是复制（指针对象），二是引用。</strong><br> 复制构造函数大多都是复制，赋值函数是引用。</p> 
<p><br><br></p> 
<h3><a id="66__509"></a>6.6 什么是内存泄漏</h3> 
<p>new创建的对象，没有delete。<br> <br><br></p> 
<h3><a id="67__514"></a>6.7 访问修饰符与继承方式</h3> 
<p><strong>1、公有（public）成员：在程序中类的外部是可访问的。可以不使用任何成员函数来设置和获取公有变量的值</strong></p> 
<br> 
<p><strong>2、保护（protected）成员：只能被类成员函数、友元访问和派生类（成员函数）访问，派生类对象也不能（在类外）访问</strong></p> 
<br> 
<p><strong>3、私有（private）成员：只能被本类成员（类内）和友元访问，不能被派生类访问。默认情况下，类的所有成员都是私有的</strong>。<br> <br></p> 
<br> 
<p><strong>继承方式：</strong></p> 
<p><strong>1.public 继承：基类 成员访问属性在派生类中保持不变。</strong></p> 
<p><strong>2.protected 继承：基类 public 成员在派生类中变成protected成员，其他不变。</strong></p> 
<p><strong>3.private 继承：基类成员访问属性在派生类中都变为private属性。</strong></p> 
<p><br></p> 
<hr> 
<br> 
<p></p> 
<h2><a id="7_542"></a>7.多态和继承</h2> 
<h3><a id="71__543"></a>7.1 多态：同一操作作用于不同的对象，可以有不同的解释，产生不同类型的执行结果</h3> 
<p>有两种类型的多态性</p> 
<p>（1）编译时的多态性：编译时的多态性通过重载来实现，对于非虚的成员来说，系统在编译时，根据传递的参数、返回的类型等信息决定实现何种操作。</p> 
<p>（2）运行的多态性：运行的多态性通过虚成员，直到运行时才根据实际情况确定实现何种操作。</p> 
<p><br><br></p> 
<h4><a id="__552"></a>虚函数：允许用基类的指针来调用 子类对应的虚函数实现</h4> 
<p><strong>是C++中用于实现多态的机制，核心理念就是通过基类访问派生类定义的函数。</strong><br> 一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由多态方式调用的时候（通过指针）动态绑定。<br> <br></p> 
<p><strong>1、虚函数可以被直接使用（动态多态，由子类实现覆盖，使用指针）。</strong><br> <br></p> 
<p><strong>2、虚函数只能借助于指针或者引用来达到多态的效果。</strong><br> <br></p> 
<p><strong>3、虚函数和纯虚函数的定义中不能有static标识符</strong><br> <br></p> 
<p><strong>4、虚函数是严格的一对一关系（父类 子类的一对同名同参数 函数）</strong><br> 子类的函数与父类虚函数若同名但不同参，则毫无关系。属于对继承的父类虚函数的一种重载。</p> 
<p><br><br></p> 
<h5><a id="_571"></a>纯虚函数与抽象类：含有纯虚函数的类被称为抽象类</h5> 
<p><strong>纯虚函数：在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。</strong><br> 在基类中实现纯虚函数的方法是在函数原型后加 =0:</p> 
<pre><code class="prism language-cpp"><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">funtion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span>
</code></pre> 
<p><font color="red">含有纯虚函数的类被称为抽象类(abstract class)</font></p> 
<p><br></p> 
<p><strong>纯虚函数是特殊的虚函数，特殊在于不可以直接调用，必须在子类(sub class)中实现该函数才可以使用，因为纯虚函数在基类(base class)只有声明而没有定义。</strong></p> 
<p><br> <br></p> 
<h4><a id="_592"></a>重载：同一作用域中多个同名函数，形参列表必须不同</h4> 
<h4><a id="_594"></a>覆盖（重写）：覆盖基类虚函数（参数必须相同）</h4> 
<p><strong>覆盖（也叫重写）：是指在派生类中重新对基类中的<font color="red">虚函数</font>重新实现。<br> 函数名和参数必须一样，返回值可以不一样（允许返回值协变）。</strong></p> 
<p>（1）不同的范围（分别位于派生类与基类）；<br> （2）函数名字相同；<br> （3）参数相同；<br> （4）基类函数必须有virtual 关键字。</p> 
<p>如果参数不同，即使有virtual也算作隐藏。<br> <br><br></p> 
<h5><a id="_608"></a>隐藏与覆盖的区别</h5> 
<p><strong>函数本身有（代码区）对应的地址</strong></p> 
<p><strong>（1）重载是子类改写了父类的方法，另辟空间，父类原函数还在。</strong><br> 方法名必须相同，参数必须不相同，（返回类型可以不相同）</p> 
<p><strong>（2）覆盖是派生类重写基类的虚函数，父类原函数被替换</strong></p> 
<p><strong>（3）重载不属于面向对象，只是一种语法规则，在编译阶段完成。</strong></p> 
<p><strong>（4）覆盖是面向对象的特征，在运行时决定。</strong></p> 
<p><br><br></p> 
<h3><a id="72__622"></a>7.2 抽象类（概念，并有具体对应）</h3> 
<p><strong>1、抽象类至少包含一个纯虚函数，子类只有实现所有纯虚函数才不是抽象类。</strong></p> 
<p><strong>2、抽象类不能直接实例化。</strong></p> 
<p><strong>3、抽象类可以有非纯虚函数。</strong></p> 
<p><strong>4、可以支持多继承</strong><br> <br></p> 
<br> 
<h4><a id="__635"></a>接口（概念，无具体对应。对应 仅纯虚函数的抽象类）</h4> 
<p>C++中并没有明确的接口的定义，与之等价的是纯虚类，既只有纯虚函数的（抽象）类。</p> 
<p><strong>1、接口不包含方法的实现，全部都为纯虚函数</strong></p> 
<p><strong>2、接口的子类必须实现其所有方法</strong></p> 
<p><strong>3、接口是抽象方法的集合，不能被实例化；</strong></p> 
<p><strong>4、可以支持多继承</strong></p> 
<p><strong>5、通常不带成员变量，也没有构造函数。</strong><br> 接口不能包含成员变量，除了 static 和 final 变量。<br> <br><br></p> 
<p><br><br></p> 
<h3><a id="73__654"></a>7.3 多继承：一个类有多个基类,这样的继承关系称为多继承</h3> 
<p><img src="https://images2.imgbox.com/28/13/p6PzuJXB_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_660"></a>多继承重复调用同一基类构造函数造成二义性：</h4> 
<p>根据多继承构造函数的调用顺序，先构造Base类对象再被继承为a类对象，<br> 然后又先构造Base类对象再被继承为b类对象。</p> 
<p>可见对于C类对象来说，Base构造了两次，所以Base中的任何属性都具有二义性。</p> 
<p><strong>分析C的对象模型：</strong><br> <img src="https://images2.imgbox.com/07/b0/IboQmBH4_o.png" width="70%"></p> 
<p><br><br></p> 
<h4><a id="_677"></a>虚继承解决多继承的二义性问题</h4> 
<p>如果要让Base在C中只产生一个对象,则应该对公共基类Base声明为虚继承,使得这个公共基类成为虚基类。</p> 
<p><strong>当类中出现virtual时,C++编译器会对象添加一个vptr指针,同时会产生一个虚函数表</strong></p> 
<pre><code class="prism language-cpp"><span class="token comment">//当类中出现virtual时,C++编译器会对象添加一个vptr指针,同时会产生一个虚函数表</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">A</span><span class="token operator">:</span> <span class="token keyword">virtual</span> <span class="token keyword">public</span> Base<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token keyword">virtual</span> <span class="token keyword">public</span> Base<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span><span class="token keyword">public</span> A<span class="token punctuation">,</span><span class="token keyword">public</span> B<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>C的对象模型：<br> 实际上A应该包括a和vptr指向的x，共12字节。B一样</strong><br> <img src="https://images2.imgbox.com/06/8e/rkTh35Iu_o.png" width="70%"></p> 
<br> 
<br> 
<h3><a id="74__703"></a>7.4 接口继承和实现继承</h3> 
<p>所谓接口继承就是派生类只继承函数的接口，也就是声明。而实现继承就是派生类同时继承函数的接口和实现。</p> 
<p>1、声明一个纯虚函数（pure visual）的目的就是为了让派生类只继承函数接口，即接口继承。</p> 
<p>2、声明一个非纯虚函数（impure visual）的目的是为了让派生类继承函数接口和缺省实现。</p> 
<p>3、声明一个非虚函数（non visual）的目的是为了让派生类继承函数接口和一份强制实现。</p> 
<p><br><br></p> 
<br> 
<h3><a id="75_this_721"></a>7.5 this指针的含义：指向成员函数作用的对象</h3> 
<p>“this指针”指向了成员函数作用的对象，在成员函数执行的过程中，正是通过“this指针”才能找到对象所在的地址，因而也就能找到对象的所有非静态成员变量的地址。</p> 
<p>在类中构造函数创造一个对象。</p> 
<p><br><br></p> 
<h3><a id="76__729"></a>7.6 类对象与类指针：</h3> 
<p>两者不可相提并论，类对象不可理解成指针，虽然实现机制很像。<br> <br></p> 
<p><strong>1、类对象：利用类的构造函数（构造函数：对类进行初始化工作）在内存中分配的一块区域（包括一些成员变量赋值）；</strong><br> <br></p> 
<p><strong>2、类指针：一个内存地址值,指向内存中存放的类对象(包括一些成员变量所赋的值).</strong></p> 
<p>要发挥虚函数的强大作用,必须使用指针来访问对象. 指针可以实现动态多态，直接用对象不行<br> <br></p> 
<p><strong>区别与特征：</strong></p> 
<p>（1）在类的声明尚未完成的情况下，可以声明指向该类的指针，但是不可声明该类的对象…</p> 
<p>（2）父类的指针可以指向子类的对象…</p> 
<p>（3）定义对象实例时，分配了内存。指针变量则未分配类对象所需内存</p> 
<p>（4）指针变量是间接访问，但可实现多态（通过父类指针可调用子类对象），并且没有调用构造函数。<br> 直接声明可直接访问，但不能实现多态，声明即调用了构造函数（已分配了内存）。</p> 
<p><br><br></p> 
<h2><a id="8_758"></a>8.数据结构</h2> 
<h3><a id="81__759"></a>8.1 两个栈实现队列</h3> 
<p><strong>栈A入栈B：栈A提供入队列，栈B提供出队列。</strong><br> （1）栈A不空，直接弹出<br> （2）栈B空，弹A数据如B</p> 
<p><br><br></p> 
<h2><a id="10_767"></a>10.泛型编程：多种数据类型皆可操作（模板实现）</h2> 
<h3><a id="101__768"></a>10.1 函数模板与类模板</h3> 
<p><strong>函数模板：是一个抽象的函数定义，它代表一类同构函数。<br> 通过用户提供的具体参数，C++编译器在编译时刻能够将模板函数实例化，根据同一模板创建出不同的具体函数。</strong></p> 
<p>这些函数的不同之处主要在于内部一些数据类型的不同。<br> <br></p> 
<p>函数模板用于生产函数，是一个模板。<br> 模板函数是由一个模板生产的函数。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span>模板参数表<span class="token operator">&gt;</span>函数定义

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span><span class="token keyword">typename</span> Y<span class="token operator">&gt;</span>  <span class="token comment">//class此处不代表类而是类型（可用typeame替换）</span>
T <span class="token function">max</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span>T b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">return</span> a<span class="token operator">&gt;</span>b<span class="token operator">?</span>a<span class="token operator">:</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
cout<span class="token operator">&lt;&lt;</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cout<span class="token operator">&lt;&lt;</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">2.3</span><span class="token punctuation">,</span><span class="token number">5.4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

cout<span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//指定是int</span>
<span class="token punctuation">}</span>
</code></pre> 
<br> 
<p><strong>类模板：更高层次的抽象的类定义。<br> 实例化必须由程序员在程序中显式地指定</strong><br> <br></p> 
<p>类模板用于生产类<br> 模板类是由一个模板生产的类。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span>模板参数表<span class="token operator">&gt;</span>类定义
<span class="token comment">//假设类名max</span>

max<span class="token operator">&lt;</span><span class="token keyword">int</span>，<span class="token keyword">int</span><span class="token operator">&gt;</span> m1<span class="token punctuation">;</span>  <span class="token comment">//必须指定实例化，m1是模板类的对象</span>
</code></pre> 
<p><br><br></p> 
<h3><a id="102__816"></a>10.2 模板缺点</h3> 
<p>模板函数缺点：不正当使用会导致代码膨胀，严重影响程序运行效率；</p> 
<p>解决办法：把C++模板中与参数无关的代码分离出来。</p> 
<p><br><br></p> 
<p><br><br></p> 
<p><br><br></p> 
<p><br><br><br> <br><br><br> <br><br><br> <br><br><br> <br><br><br> <br><br><br> <br><br><br> <br><br></p> 
<p><br><br></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a41504db8a45ce5d9e084a55c8ec2db9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Unity Shader - Ray Marching - T7 - AO</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3ef91b3d08185c7464421f73b5909567/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">top.layer.open 子页面按钮点击关闭刷新父页面</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>