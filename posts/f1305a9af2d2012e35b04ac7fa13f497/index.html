<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux下生成.so文件 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux下生成.so文件" />
<meta property="og:description" content=".so文件是什么？ linux下的.so文件即Shared Libraries。Shared Library 是程序运行时加载的库文件。当一个shared library 被成功的安装以后，之后启动的所有程序都会自动使用最新的shared library。也就是说，生成一个.so文件并告诉编译器它的位置之后，所有的需要引入它的程序都可以同时调用它。
使用.so文件有以下这么几个好处：
升级库但是可以继续支持一些程序，这些程序想要使用较老版本的，或者不向后兼容的库。重写特定的库文件或者甚至可以在执行特定程序时，指定一个库文件的特定函数做以上这些的时候程序甚至可以正在使用着当前的库文件 每一个shared library都有一个soname、一个real name、一个linker name。
soname有一个前缀lib、自定义的短语、后跟一个.so、还有一个版本号。如：/usr/lib/libreadline.so.3
real name是一个soname的实体，在文件名中包涵了真实的库版本号。real name相比soname添加了一个句点，一个次要版本号，另一个句点，和一个发型版本号。最后一个句点和发行版本号是可选的。次要号码和发行号码支持配置控制，使别人可以明白安装的是哪个确切的版本。
linker name是没有任何版本号的soname。如/usr/lib/libreadline.so。
管理shared libraries的关键就是将这个文件名拆开。当程序内部列出它们需要的shared libraries时，仅仅需要列出soname即可。相反的，当创建一个shared library时，你只需要创建一个特定的文件名（包括详细的版本信息）即可。当你安装了一个新版本的库时，你只需将它安装在一小部分特殊的文件夹中的一个之中，然后运行程序ldconfig。lgconfig将会检查现存的文件，并且创建real name的soname和symbolic link，同时设置好春村文件。缓存文件位于/etc/ld.so.cache。
ldconfig并不设置linker name；通常这是在库安装时干的事，然后linker name作为指向最新soname或者realname的symbolic link被创建。
symbolic link（软连接）是自己指定的。名字如： /usr/lib/libreadline.so.3.0。
linker name就是一个与/usr/lib/libreadline.so.3相关联的symbolic link。
如果以上看不懂的话，是的我也没看懂，只是大体翻译了这篇文章
LD_LIBRARY_PATH 这个路径中的库文件将被在正常寻找前首先寻找。
注意事项 .so文件（也就是Shared Libraries）必须以lib开头，以.so结尾，比如：libalpha.so。（作为特例，一些最低级的C库并不是以lib开头的） 必须将自定义的文件加入到LD_LIBRARY_PATH中才能运行。 生成并测试.so文件。 aplusb.c
#include &lt;iostream&gt; #include &#34;aplusb.h&#34; using namespace std; int aPlusB(int a, int b) { int c = a &#43; b; return c; } aplusb.h
#ifndef APLUSB_H__ #define APLUSB_H__ extern int aPlusB(int a, int b); #endif main." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f1305a9af2d2012e35b04ac7fa13f497/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-07-28T09:47:00+08:00" />
<meta property="article:modified_time" content="2016-07-28T09:47:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux下生成.so文件</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="so文件是什么"><strong>.so</strong>文件是什么？</h3> 
<p>linux下的<strong>.so</strong>文件即<strong>Shared Libraries</strong>。Shared Library 是程序运行时加载的库文件。当一个shared library 被成功的安装以后，之后启动的所有程序都会自动使用最新的shared library。也就是说，生成一个.so文件并告诉编译器它的位置之后，所有的需要引入它的程序都可以同时调用它。</p> 
<p>使用.so文件有以下这么几个好处：</p> 
<ul><li>升级库但是可以继续支持一些程序，这些程序想要使用较老版本的，或者不向后兼容的库。</li><li>重写特定的库文件或者甚至可以在执行特定程序时，指定一个库文件的特定函数</li><li>做以上这些的时候程序甚至可以正在使用着当前的库文件</li></ul> 
<p>每一个shared library都有一个soname、一个real name、一个linker name。</p> 
<p>soname有一个前缀lib、自定义的短语、后跟一个.so、还有一个版本号。如：/usr/lib/libreadline.so.3</p> 
<p>real name是一个soname的实体，在文件名中包涵了真实的库版本号。real name相比soname添加了一个句点，一个次要版本号，另一个句点，和一个发型版本号。最后一个句点和发行版本号是可选的。次要号码和发行号码支持配置控制，使别人可以明白安装的是哪个确切的版本。</p> 
<p>linker name是没有任何版本号的soname。如/usr/lib/libreadline.so。</p> 
<p>管理shared libraries的关键就是将这个文件名拆开。当程序内部列出它们需要的shared libraries时，仅仅需要列出soname即可。相反的，当创建一个shared library时，你只需要创建一个特定的文件名（包括详细的版本信息）即可。当你安装了一个新版本的库时，你只需将它安装在一小部分特殊的文件夹中的一个之中，然后运行程序ldconfig。lgconfig将会检查现存的文件，并且创建real name的soname和symbolic link，同时设置好春村文件。缓存文件位于/etc/ld.so.cache。</p> 
<p>ldconfig并不设置linker name；通常这是在库安装时干的事，然后linker name作为指向最新soname或者realname的symbolic link被创建。</p> 
<p>symbolic link（软连接）是自己指定的。名字如： /usr/lib/libreadline.so.3.0。</p> 
<p>linker name就是一个与/usr/lib/libreadline.so.3相关联的symbolic link。</p> 
<p>如果以上看不懂的话，是的我也没看懂，只是大体翻译了<a href="http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html" rel="nofollow">这篇文章</a></p> 
<p><strong>LD_LIBRARY_PATH</strong> <br> 这个路径中的库文件将被在正常寻找前首先寻找。</p> 
<h3 id="注意事项">注意事项</h3> 
<ol><li><strong>.so</strong>文件（也就是Shared Libraries）必须以<strong>lib</strong>开头，以.so结尾，比如：libalpha.so。（作为特例，一些最低级的C库并不是以lib开头的） </li><li>必须将自定义的文件加入到<strong>LD_LIBRARY_PATH</strong>中才能运行。</li></ol> 
<h3 id="生成并测试so文件">生成并测试<strong>.so</strong>文件。</h3> 
<p><strong>aplusb.c</strong></p> 
<pre class="prettyprint"><code class="language-C hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include "aplusb.h"</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> aPlusB(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)
{
    <span class="hljs-keyword">int</span> c = a + b;
    <span class="hljs-keyword">return</span> c;
} </code></pre> 
<p><strong>aplusb.h</strong></p> 
<pre class="prettyprint"><code class="language-C hljs cs"><span class="hljs-preprocessor">#ifndef APLUSB_H__</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> APLUSB_H__</span>
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> aPlusB(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b);
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span></code></pre> 
<p><strong>main.c</strong></p> 
<pre class="prettyprint"><code class="language-C hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include "aplusb.h"</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;
    c = aPlusB(a, b);
    <span class="hljs-built_in">cout</span>&lt;&lt;c&lt;&lt;endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h5 id="第一步创建pic文件">第一步：创建PIC文件</h5> 
<p><code>g++ -c -fPIC aplusb.c</code></p> 
<p>pic代码是位置无关代码，程序运行时计算机会找文件中指定的内存地址去读取数据，但是当读取一个库文件时，库本身指定的地址必须是与内存地址无关的。此时生成了aplusb.o。注意-fPIC比-fpic兼容性要高。</p> 
<p>-c 为编译和汇编但是不链接。</p> 
<p>生成的.o文件为机器码。</p> 
<h5 id="第二步用第一步生成的文件去创建so文件">第二步：用第一步生成的文件去创建.so文件。</h5> 
<p><code>g++ -shared -o libaplusb.so aplusb.o</code></p> 
<h5 id="第三步链接">第三步：链接</h5> 
<p><code>g++ -L/home/lee/JNI -o main main.c -laplusb</code></p> 
<h5 id="第四步-保证运行时可以调用">第四步: 保证运行时可以调用</h5> 
<p><code>$ export LD_LIBRARY_PATH=/home/lee/JNI:$LD_LIBRARY_PATH</code></p> 
<p>至此</p> 
<h5 id="第五部运行">第五部：运行</h5> 
<p><code>lee@lee-computer:~/JNI$ ./main <br> 3</code></p> 
<p>结果为3。调用成功。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/74f43b538e67cabc72758f05f7d90290/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">根据签名获取hashCode的值</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/67d047cb9651e4caeb44453ac765a974/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mac下教你如何使用Github客户端开源项目</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>