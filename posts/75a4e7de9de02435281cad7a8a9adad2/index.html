<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>（四）策略梯度(policy gradient) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="（四）策略梯度(policy gradient)" />
<meta property="og:description" content="前面一章表格型方法，进行策略迭代的时候利用到了Q函数。是一种value-base的方法，而之前介绍到还有一种policy-base，本章的就是一种policy-base的方法。
ps：强化学习的目的是寻找最佳策略，value-base相对复杂一点儿，先算价值再找策略。policy-base就是直接寻找策略的。
那有一个大问题就是：==明明已经有了value-base方法，为什么还要去开发policy-base呢？==有什么特殊性吗？当然有了，value-base是有局限性的，只适用于离散动作空间而且是确定性策略(原因还不清楚，但是就是这么回事~)。而policy-base使用场景包括随机策略、动作空间连续(当然也兼容离散动作空间，确定性策略)。所以研究policy-base的方法是十分有必要的。
还记得最开始那张RL的图吗？里面有三个元素组成：agent, reward, environment。其实在这三个里面能由我们主观控制的只有一个agent(其实对应的是policy)，剩下两个都是客观存在的，只不过在选取不同的策略下呈现方式会有不同。所以直接对policy进行修改是有意义的。那现在最大的问题就是：如何从policy出发寻找最佳policy呢？
回想第一章说过的，策略其实就是一个概率分布。会告诉在状态下执行各个动作的概率。那策略梯度的思想就十分清楚了：当判断出某种行为可以带给我们价值大的，就增加这种行为的概率。现在思路理解了，可怎么把思想进行建模呢？既然是概率分布，那就使用机器学习中常见的方法：概率参数化。把问题转换成对参数进行数学操作。本文中统一用Θ代替。下面就介绍下这个流程：
之前从概率的角度出发，每一个动作都是一个概率。而一条轨迹由无数个动作组成，轨迹也可以用概率表示：
注意上面的Θ代表的就是某个策略
RL关注的是奖励最大化，用概率分布的方法来表示策略的奖励：
为了便于说明，还是将上式转变成期望：
所以一切的一切现在都变成了对Θ进行操作，实现期望最大化。
一个问题来了：怎么实现期望最大化呢？——梯度上升
首先解释一下啥叫梯度，其实就是变化率，也叫导数。梯度上升就是一点儿一点儿的变化，但整体是上升趋势。这里求导的对象自然就是Θ了。
先给出结果式，然后再来看看这个东东是怎么来的：
具体的推导过程如下：
这里面用到了一个技巧：
可以很直观的理解上面的式子：从采样得到的数据中，确定状态动作对——(s(t), a(t))。如果发现轨迹奖励是正的，就增加这个动作对的概率。否则降低。那 升高降低多少呢？怎么体现在参数Θ上呢?就是利用上面的计算式确定梯度，然后进行更新。
所以整体策略梯度的更新流程如下图所示：
有几个点需要明确：
1.Θ更新式中的η是权重，就是这场游戏的奖励
2.数据采集时，智能体本身有随机性。对于相同的状态s不一定都会采取相同的a，所以要把每笔数据记录下来(每条数据内容状态动作对及对应的奖励)。
3.策略梯度采样的数据只能使用一次，更新参数后就不能用了(原因我也不知道为啥~)
上面讲的都是关于Θ的，那和我们的策略有啥关系。不要忘记，是用Θ来代表策略的。优化Θ就相当于优化策略。
以上介绍了策略梯度的思想及实现方法，下面介绍一些改进的小技巧。能够帮助我们提高策略梯度的效果。
技巧1：添加基线(baseline)
首先问自己一个问题：为啥要添加基线？
设想这样一种场景，之前解释过在进行梯度更新时，奖励为正的增大其概率，奖励为负的减少其概率。但现实中往往是这样的：奖励全部是非负的，像乒乓球中就是[0,11]。对于这种情况会出现一个问题：之前是使用概率去衡量的，当完成归一化之后，只有原来上升多的才会上升，上升少的相比之下会下降。这不是我们期望的结果。所以我们会期望奖励不要总是正的，这就是基线的作用。把奖励都减去一个常数，只有奖励超过基线的概率上升。否则即使是正的太小了也不好，让其概率下降，数学化的表达如下：
那怎么求呢？对于b的求解，可以使用MC进行一次完整训练，然后取期望，并且也可以不断更新这个b：
技巧2：分配合适的分数(给动作确定权重)
在前面的式子中有这样一个问题：在任意动作中，乘的奖励是相同的。因为一次轨迹的奖励是确定的，baseline也是确定的。但实际上动作有好有坏，所以希望能根据动作分配适合的奖励分数。并且通过这个不同的奖励分数，可以反应每一个动作是好还是不好。举一个例子来进行说明：
从上面图中看到，最终的奖励是&#43;3，如果不进行权重分配的话。所有的动作奖励都会被认定为&#43;3。以(s(b),a(2))这对为例，可以很明显的看出它其实并没有什么作用，奖励都是第一对来的，甚至它会带来负面影响，因为s(b)在执行a(2)后会进入s©，而s©会削弱当前的奖励。同理，如果前面是负的，s(b)即使增强，但幅度小的话，也看不太出来。所以可以认定执行这个动作前的奖励对于评价这个动作没有参考价值。只有把执行这个动作以后发生的所有奖励加起来，才是这个动作真正的贡献。修改后的数学表达式为：
代表从t时刻开始后面的奖励，更能代表动作所对奖励起到的贡献
甚至可以为将来的奖励加上折扣因子：
代表折扣回报
把R-b这一项合起来，就叫做优势函数，即
表示为：
下面介绍一个最简单也最经典的梯度策略算法：REINFORCE(蒙特卡洛策略梯度)
设计到蒙特卡洛思想，就是以回合为单位进行取样的。
因为对于算法了解不是很深入，在此就简单罗列一些相关知识点。等后面学习明确了再过来补充说明。
算法伪代码如下：
算法流程图如下：
老规矩，课后题：
参考资料：【强化学习】策略梯度方法-REINFORCE_哔哩哔哩_bilibili
因作者水平有限，如有错误之处，请在下方评论区指出，谢谢！" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/75a4e7de9de02435281cad7a8a9adad2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-30T06:39:04+08:00" />
<meta property="article:modified_time" content="2022-03-30T06:39:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">（四）策略梯度(policy gradient)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>  前面一章表格型方法，进行策略迭代的时候利用到了Q函数。是一种value-base的方法，而之前介绍到还有一种policy-base，本章的就是一种policy-base的方法。<br>   ps：强化学习的目的是寻找最佳策略，value-base相对复杂一点儿，先算价值再找策略。policy-base就是直接寻找策略的。<br>   那有一个大问题就是：==明明已经有了value-base方法，为什么还要去开发policy-base呢？==有什么特殊性吗？当然有了，value-base是有局限性的，只适用于离散动作空间而且是确定性策略(原因还不清楚，但是就是这么回事~)。而<strong>policy-base使用场景包括随机策略、动作空间连续</strong>(当然也兼容离散动作空间，确定性策略)。所以研究policy-base的方法是十分有必要的。<br>   还记得最开始那张RL的图吗？里面有三个元素组成：agent, reward, environment。其实在这三个里面能由我们主观控制的只有一个agent(其实对应的是policy)，剩下两个都是客观存在的，只不过在选取不同的策略下呈现方式会有不同。所以直接对policy进行修改是有意义的。那现在最大的问题就是：<mark>如何从policy出发寻找最佳policy呢？</mark><br>   回想第一章说过的，策略其实就是一个概率分布。会告诉在状态下执行各个动作的概率。那策略梯度的思想就十分清楚了：当判断出某种行为可以带给我们价值大的，就增加这种行为的概率。现在思路理解了，可怎么把思想进行建模呢？既然是概率分布，那就使用机器学习中常见的方法：概率参数化。把问题转换成对参数进行数学操作。本文中统一用Θ代替。下面就介绍下这个流程：<br>   之前从概率的角度出发，每一个动作都是一个概率。而一条轨迹由无数个动作组成，轨迹也可以用概率表示：<img src="https://images2.imgbox.com/04/2d/Tbt4Znk1_o.png" alt="在这里插入图片描述"><br>   注意上面的Θ代表的就是某个策略<br>   RL关注的是奖励最大化，用概率分布的方法来表示策略的奖励：<img src="https://images2.imgbox.com/a1/4b/NRjjm1Fv_o.png" alt="在这里插入图片描述"><br>   为了便于说明，还是将上式转变成期望：<img src="https://images2.imgbox.com/be/13/lyE8Rw9g_o.png" alt="在这里插入图片描述"><br>   所以一切的一切现在都变成了对Θ进行操作，实现期望最大化。<br>   一个问题来了：<mark>怎么实现期望最大化呢？——梯度上升</mark><br>   首先解释一下啥叫<strong>梯度</strong>，其实就是变化率，也叫导数。梯度上升就是一点儿一点儿的变化，但整体是上升趋势。这里求导的对象自然就是Θ了。<br> 先给出结果式，然后再来看看这个东东是怎么来的：<img src="https://images2.imgbox.com/b8/d0/h9ipqP08_o.png" alt="在这里插入图片描述"><br>   具体的推导过程如下：<img src="https://images2.imgbox.com/04/e5/bQYLSnaz_o.png" alt="在这里插入图片描述"><br>   这里面用到了一个技巧：<img src="https://images2.imgbox.com/71/1c/erA6sHdD_o.png" alt="在这里插入图片描述"><br>   可以很直观的理解上面的式子：从采样得到的数据中，确定状态动作对——(s(t), a(t))。如果发现轨迹奖励是正的，就增加这个动作对的概率。否则降低。那 <mark>升高降低多少呢？怎么体现在参数Θ上呢</mark>?就是利用上面的计算式确定梯度，然后进行更新。<br>   所以整体策略梯度的更新流程如下图所示：<img src="https://images2.imgbox.com/85/08/ESx7KdPK_o.png" alt="在这里插入图片描述"><br>   有几个点需要明确：<br>   1.Θ更新式中的η是权重，就是这场游戏的奖励<br>   2.数据采集时，智能体本身有随机性。对于相同的状态s不一定都会采取相同的a，所以要把每笔数据记录下来(每条数据内容状态动作对及对应的奖励)。<br>   3.策略梯度采样的数据只能使用一次，更新参数后就不能用了(原因我也不知道为啥~)</p> 
<p>  上面讲的都是关于Θ的，那和我们的策略有啥关系。不要忘记，是用Θ来代表策略的。优化Θ就相当于优化策略。<br>   以上介绍了策略梯度的思想及实现方法，下面介绍一些改进的小技巧。能够帮助我们提高策略梯度的效果。</p> 
<p>  <strong>技巧1：添加基线(baseline)</strong><br>   首先问自己一个问题：<mark>为啥要添加基线？</mark><br>   设想这样一种场景，之前解释过在进行梯度更新时，奖励为正的增大其概率，奖励为负的减少其概率。但现实中往往是这样的：奖励全部是非负的，像乒乓球中就是[0,11]。对于这种情况会出现一个问题：之前是使用概率去衡量的，当完成归一化之后，只有原来上升多的才会上升，上升少的相比之下会下降。这不是我们期望的结果。所以我们会期望奖励不要总是正的，这就是基线的作用。把奖励都减去一个常数，只有奖励超过基线的概率上升。否则即使是正的太小了也不好，让其概率下降，数学化的表达如下：<img src="https://images2.imgbox.com/f3/51/T6kmcZ67_o.png" alt="在这里插入图片描述"><br>   那怎么求呢？对于b的求解，可以使用MC进行一次完整训练，然后取期望，并且也可以不断更新这个b：<img src="https://images2.imgbox.com/7e/9e/IocxSaUM_o.png" alt="在这里插入图片描述"><br>   <strong>技巧2：分配合适的分数(给动作确定权重)</strong><br>   在前面的式子中有这样一个问题：在任意动作中，乘的奖励是相同的。因为一次轨迹的奖励是确定的，baseline也是确定的。但实际上动作有好有坏，所以希望能根据动作分配适合的奖励分数。并且通过这个不同的奖励分数，可以反应每一个动作是好还是不好。举一个例子来进行说明：<img src="https://images2.imgbox.com/da/9c/FULLn6KD_o.png" alt="在这里插入图片描述"><br>   从上面图中看到，最终的奖励是+3，如果不进行权重分配的话。所有的动作奖励都会被认定为+3。以(s(b),a(2))这对为例，可以很明显的看出它其实并没有什么作用，奖励都是第一对来的，甚至它会带来负面影响，因为s(b)在执行a(2)后会进入s©，而s©会削弱当前的奖励。同理，如果前面是负的，s(b)即使增强，但幅度小的话，也看不太出来。所以可以认定执行这个动作前的奖励对于评价这个动作没有参考价值。只有把执行这个动作以后发生的所有奖励加起来，才是这个动作真正的贡献。修改后的数学表达式为：<img src="https://images2.imgbox.com/8f/fa/YAdU7srN_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e5/11/1Syrybte_o.png" alt="在这里插入图片描述"><br>   代表从t时刻开始后面的奖励，更能代表动作所对奖励起到的贡献<br> 甚至可以为将来的奖励加上折扣因子：<img src="https://images2.imgbox.com/76/26/idIkVFZ9_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7b/a4/WRrUsaCx_o.png" alt="在这里插入图片描述"><br>   代表折扣回报<br>   把R-b这一项合起来，就叫做优势函数，即<img src="https://images2.imgbox.com/4f/c3/w0KSxJkG_o.png" alt="在这里插入图片描述"><br>   表示为：<img src="https://images2.imgbox.com/4e/01/rYVyHJAl_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/96/8b/cd9coYx6_o.png" alt="在这里插入图片描述"><br>   下面介绍一个最简单也最经典的梯度策略算法：REINFORCE(蒙特卡洛策略梯度)<br>   设计到蒙特卡洛思想，就是以回合为单位进行取样的。<br>   因为对于算法了解不是很深入，在此就简单罗列一些相关知识点。等后面学习明确了再过来补充说明。<br>   算法伪代码如下：<img src="https://images2.imgbox.com/79/ea/6bs1jCPE_o.png" alt="在这里插入图片描述"><br>   算法流程图如下：<img src="https://images2.imgbox.com/10/96/6HlHcA9v_o.png" alt="在这里插入图片描述"><br>   老规矩，课后题：<img src="https://images2.imgbox.com/c1/00/1N8FZACk_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/13/d8/GDGGskg0_o.png" alt="在这里插入图片描述"><br> 参考资料：<a href="https://www.bilibili.com/video/BV1xb4y1W7Ye?spm_id_from=333.337.search-card.all.click" rel="nofollow">【强化学习】策略梯度方法-REINFORCE_哔哩哔哩_bilibili</a></p> 
<p><strong>因作者水平有限，如有错误之处，请在下方评论区指出，谢谢！</strong></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e066c3cd4202c591750751536d14b60d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">protobuf序列化与反序列化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b982ad7f2b51240c28296d65a4c8a998/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Uncaught (in promise) DOMException: Failed to load because no supported source was found.</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>