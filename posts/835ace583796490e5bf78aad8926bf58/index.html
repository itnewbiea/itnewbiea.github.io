<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>es6 javascript的Reflect 对象的方法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="es6 javascript的Reflect 对象的方法" />
<meta property="og:description" content="Reflect对象的方法清单如下， 共 13 个。
Reflect.apply(target, thisArg, args) Reflect.construct(target, args) Reflect.get(target, name, receiver) Reflect.set(target, name, value, receiver) Reflect.defineProperty(target, name, desc) Reflect.deleteProperty(target, name) Reflect.has(target, name) Reflect.ownKeys(target) Reflect.isExtensible(target) Reflect.preventExtensions(target) Reflect.getOwnPropertyDescriptor(target, name) Reflect.getPrototypeOf(target) Reflect.setPrototypeOf(target, prototype)上面这些方法的作用， 大部分与Object对象的同名方法的作用都是相同的， 而且它与Proxy对象的方法是一一对应的。 下面是对其中几个方法的解释。 （ 1） Reflect.get(target, name, receiver)
查找并返回target对象的name属性， 如果没有该属性， 则返回undefined。
如果name属性部署了读取函数， 则读取函数的 this 绑定receiver。
var obj = { get foo() { return this.bar(); }, bar: function() { ... } }; // 下面语句会让 this.bar() // 变成调用 wrapper.bar() Reflect.get(obj, &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/835ace583796490e5bf78aad8926bf58/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-12-03T11:42:25+08:00" />
<meta property="article:modified_time" content="2016-12-03T11:42:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">es6 javascript的Reflect 对象的方法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Reflect对象的方法清单如下， 共 13 个。</p> 
<p></p> 
<pre><code class="language-javascript">Reflect.apply(target, thisArg, args)
Reflect.construct(target, args)
Reflect.get(target, name, receiver)
Reflect.set(target, name, value, receiver)
Reflect.defineProperty(target, name, desc)
Reflect.deleteProperty(target, name)
Reflect.has(target, name)
Reflect.ownKeys(target)
Reflect.isExtensible(target)
Reflect.preventExtensions(target)
Reflect.getOwnPropertyDescriptor(target, name)
Reflect.getPrototypeOf(target)
Reflect.setPrototypeOf(target, prototype)</code></pre>上面这些方法的作用， 大部分与Object对象的同名方法的作用都是相同的， 而且它与Proxy对象的方法是一一对应的。 下面是对其中几个方法的解释。 
<p></p> 
<p>（ 1） Reflect.get(target, name, receiver)<br>查找并返回target对象的name属性， 如果没有该属性， 则返回undefined。<br>如果name属性部署了读取函数， 则读取函数的 this 绑定receiver。</p> 
<p></p> 
<pre><code class="language-javascript">var obj = {
	get foo() {
		return this.bar();
	},
	bar: function() {
		...
	}
};
//  下面语句会让 this.bar()
//  变成调用 wrapper.bar()
Reflect.get(obj, "foo", wrapper);</code></pre>（2） Reflect.set(target, name, value, receiver) 
<br>设置target对象的name属性等于value。 如果name属性设置了赋值函数， 则赋值函数的this绑定receiver。 
<br>（ 3） Reflect.has(obj, name) 
<br>等同于name in obj。 
<br>（ 4） Reflect.deleteProperty(obj, name) 
<br>等同于delete obj[name]。 
<br>（ 5） Reflect.construct(target, args) 
<br>等同于new target(...args)， 这提供了一种不使用new， 来调用构造函数的方法。 
<br>（ 6） Reflect.getPrototypeOf(obj) 
<br>读取对象的__proto__属性， 对应Object.getPrototypeOf(obj)。 
<br>（ 7） Reflect.setPrototypeOf(obj, newProto) 
<br>设置对象的__proto__属性， 对应Object.setPrototypeOf(obj, newProto)。 
<br>（ 8） Reflect.apply(fun, thisArg, args) 
<br>等同于Function.prototype.apply.call(fun, thisArg, args)。 一般来说， 如果要绑定一个函数的 this 对象， 可以这样写fn.apply(obj, args)， 但是如果函数定义了自己的apply方法， 就只能写成Function.prototype.apply.call(fn, obj, args)， 采用 Reflect 对象可以简化这种操作。 
<br>另外， 需要注意的是， Reflect.set()、 Reflect.defineProperty()、 Reflect.freeze()、 Reflect.seal() 和Reflect.preventExtensions() 返回一个布尔值， 表示操作是否成功。 它们对应的 Object 方法， 失败时都会抛出错误。 
<p></p> 
<p></p> 
<pre><code class="language-javascript">//  失败时抛出错误
Object.defineProperty(obj, name, desc);
//  失败时返回 false
Reflect.defineProperty(obj, name, desc);</code></pre>上面代码中， Reflect.defineProperty方法的作用与Object.defineProperty是一样的， 都是为对象定义一个属性。 但是， Reflect.defineProperty方法失败时， 不会抛出错误， 只会返回false。 
<br> 
<br> 
<br> 
<br> 
<br> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6b98f3661fbe4ab09bae543ed9a311c1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python数据类型之“集合(Sets)与映射(Mapping)”</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0971bdfa1c0394e9ae155d718811dfb1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ListView  中Item  位置获取</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>