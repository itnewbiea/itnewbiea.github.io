<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>三、ovs-dpdk ——代码结构 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="三、ovs-dpdk ——代码结构" />
<meta property="og:description" content="转载请注明出处，谢谢。
支持dpdk结构 ovs-dpdk的vswitchd进程
ovs的dpdk网卡结构：
支持三种类型：物理网卡/vhostuser/vhostuserclient
对于ovs使用dpdk 需要在启动ovs的时候需要配置一些参数 other_config
dpdk-init
指定ovs是否初始化和支持dpdk端口。
dpdk-lcore-mask
指明dpdk使用的逻辑核。同dpdk的-c参数。
dpdk-socket-mem
指明不同numa节点提前申请的大页内存。同dpdk的--socket-mem参数。
dpdk-hugepage-dir
大页文件系统mount的目录。同dpdk的--huge-dir参数。
vhost-sock-dir
设置vhost-user 套接字的路径。
dpdk-extra
其他的dpdk配置参数。
dpdk初始化
主要包括：
1) dpdk eal初始化。
2) 启动dpdk接口状态监控线程（使用dpdk的库函数），如果状态发送变化，则更新netdev设备的变化标记。
3) 注册dpdk类型的netdev class。其中包括dpdk设备类型，ring类型、vhost、vhost client类型。
pmd线程 vswitchd/ovs-vswitchd.c启动main–&gt;netdev_run–&gt;netdev_initialize–&gt;netdev_dpdk_register–&gt;
netdev_register_provider注册dpdk_vhost_user_class
添加dpdk端口的时候，会触发创建pmd线程的操作。
dpif_netdev_port_add–&gt;do_add_port–&gt; reconfigure_datapath-&gt; reconfigure_pmd_threads –&gt;pmd_thread_main
如果已经添加了dpdk端口，启动的时候也会触发创建pmd线程的操作。
bridge_run-&gt;bridge_run__-&gt;ofproto_run-&gt;dpif_netdev_run–&gt; reconfigure_datapath–&gt; pmd_thread_main
重新配置cmask的时候也会触发pmd线程的操作
dpif_netdev_set_config-&gt;dp_netdev_request_reconfigure-&gt; reconfigure_datapath-&gt; reconfigure_pmd_threads–&gt;pmd_thread_main
dp_netdev_process_rxq_port接口负责接收报文，然后调用接口dp_netdev_input–&gt;dp_netdev_input__负责查表，然后调用packet_batch_execute–&gt;dp_netdev_execute_actions执行actions操作。
pmd_thread_main
pmd_thread_setaffinity_cpu设置线程绑定的lcore。for无限循环for循环各个端口，执行dp_netdev_process_rxq_port处理端口。循环中间会根据变动重新加载端口和队列信息。 dp_netdev_process_rxq_port
调用netdev_rxq_recv接收报文，前后都有计时。调用dp_netdev_input将报文传输给flow，并且发送报文，前后都有计时。netdev_rxq_recv=&gt;netdev_dpdk_vhost_rxq_recv调用dpdk接口rte_vhost_dequeue_burst接收报文。调用netdev_dpdk_vhost_update_rx_counters更新统计信息。 dp_netdev_input=&gt;dp_netdev_input__
emc_processing主要是将收到的几个报文解析key值，并且从cache中查找流表，匹配的报文放入流表；返回不匹配的报文个数。如果存在不匹配的报文，调用fast_path_processing则继续查找全部表项，找到则将流表放入cache，不匹配则上报到controller。调用packet_batch_execute根据流表来操作报文。 dfc_processing
调用miniflow_extract将报文解析到key值。调用emc_lookup，从hash表中查找，并且进行key值比较。如果匹配，调用dp_netdev_queue_batches将报文添加在flow-&gt;batches中。不匹配将不匹配的报文当前排。调用dp_netdev_count_packet统计匹配的报文数。 fast_path_processing
dpcls_lookup通过classifier查找子流表，如果所有的报文都找到了匹配的子流表，将流表插入缓存中，并且将报文加入flow-&gt;batches。如果不匹配，则上报到controller。统计匹配、不匹配和丢失。 packet_batch_per_flow_execute
调用dp_netdev_flow_get_actions获取flow对应的actions。dp_netdev_execute_actions执行对应的actionsactions操作 dp_netdev_execute_actions=&gt;odp_execute_actions
如果是一些基本操作的话，调用接口dp_execute_cb。 dp_execute_cb
如果是OVS_ACTION_ATTR_OUTPUT，调用dp_netdev_lookup_port查找端口，然后调用netdev_send进行报文发送。如果是OVS_ACTION_ATTR_TUNNEL_PUSH，调用push_tnl_action进行tunnel封装，然后调用dp_netdev_recirculate–&gt;dp_netdev_input__重新查表操作。如果是OVS_ACTION_ATTR_TUNNEL_POP，调用netdev_pop_header解封装，然后调用dp_netdev_recirculate–&gt;dp_netdev_input__重新查表操作。 netdev_send=&gt;netdev_dpdk_vhost_send=&gt;__netdev_dpdk_vhost_send
循环调用dpdk接口rte_vhost_enqueue_burst发送报文。调用netdev_dpdk_vhost_update_tx_counters更新统计信息。 PMD线程在其轮询列表中持续轮询输入端口，在每一个端口上最多可同时收32个包（NETDEV_MAX_BURST），根据激活的流规则可将每一个收包进行分类。分类的目的是为了找到一个流，从而对包进行恰当的处理。包根据流进行分组，并且每一个分组将执行特定的动作。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/667e68c30ff199697451439eba9686f5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-08T22:10:48+08:00" />
<meta property="article:modified_time" content="2021-02-08T22:10:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">三、ovs-dpdk ——代码结构</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0cm;">转载请注明出处，谢谢。</p> 
<h4 style="margin-left:0cm;">支持dpdk结构</h4> 
<p style="margin-left:0cm;">ovs-dpdk的vswitchd进程</p> 
<p style="margin-left:0cm;"><img alt="" height="399" src="https://images2.imgbox.com/29/cb/5L6PL39z_o.png" width="426"></p> 
<p style="margin-left:0cm;">ovs的dpdk网卡结构：</p> 
<p style="margin-left:0cm;">支持三种类型：物理网卡/vhostuser/vhostuserclient</p> 
<p style="margin-left:0cm;"><img alt="" height="555" src="https://images2.imgbox.com/bd/d2/J8KmGoTL_o.png" width="365"></p> 
<p style="margin-left:0cm;">对于ovs使用dpdk 需要在启动ovs的时候需要配置一些参数 other_config</p> 
<p style="margin-left:0cm;">dpdk-init</p> 
<p style="margin-left:0cm;">指定ovs是否初始化和支持dpdk端口。</p> 
<p style="margin-left:0cm;">dpdk-lcore-mask</p> 
<p style="margin-left:0cm;">指明dpdk使用的逻辑核。同dpdk的-c参数。</p> 
<p style="margin-left:0cm;">dpdk-socket-mem</p> 
<p style="margin-left:0cm;">指明不同numa节点提前申请的大页内存。同dpdk的--socket-mem参数。</p> 
<p style="margin-left:0cm;">dpdk-hugepage-dir</p> 
<p style="margin-left:0cm;">大页文件系统mount的目录。同dpdk的--huge-dir参数。</p> 
<p style="margin-left:0cm;">vhost-sock-dir</p> 
<p style="margin-left:0cm;">设置vhost-user 套接字的路径。</p> 
<p style="margin-left:0cm;">dpdk-extra</p> 
<p style="margin-left:0cm;">其他的dpdk配置参数。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">dpdk初始化</p> 
<p style="margin-left:0cm;">主要包括：</p> 
<p style="margin-left:0cm;">1)    dpdk eal初始化。</p> 
<p style="margin-left:0cm;">2)    启动dpdk接口状态监控线程（使用dpdk的库函数），如果状态发送变化，则更新netdev设备的变化标记。</p> 
<p style="margin-left:0cm;">3)     注册dpdk类型的netdev class。其中包括dpdk设备类型，ring类型、vhost、vhost client类型。</p> 
<h4 style="margin-left:0cm;">pmd线程</h4> 
<p style="margin-left:0cm;">vswitchd/ovs-vswitchd.c启动main–&gt;netdev_run–&gt;netdev_initialize–&gt;netdev_dpdk_register–&gt;</p> 
<p style="margin-left:0cm;">netdev_register_provider注册dpdk_vhost_user_class</p> 
<p style="margin-left:0cm;"><span style="color:#FF0000;">添加dpdk端口的时候，会触发创建pmd线程的操作</span>。</p> 
<p style="margin-left:0cm;">dpif_netdev_port_add–&gt;do_add_port–&gt; reconfigure_datapath-&gt; reconfigure_pmd_threads –&gt;pmd_thread_main</p> 
<p style="margin-left:0cm;"><span style="color:#FF0000;">如果已经添加了dpdk端口，启动的时候也会触发创建pmd线程的操作。</span></p> 
<p style="margin-left:0cm;">bridge_run-&gt;bridge_run__-&gt;ofproto_run-&gt;dpif_netdev_run–&gt; reconfigure_datapath–&gt; pmd_thread_main</p> 
<p style="margin-left:0cm;"><span style="color:#FF0000;">重新配置cmask的时候也会触发pmd线程的操作</span></p> 
<p style="margin-left:0cm;">dpif_netdev_set_config-&gt;dp_netdev_request_reconfigure-&gt; <span style="color:#FF0000;">reconfigure_datapath</span>-&gt; reconfigure_pmd_threads–&gt;pmd_thread_main</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">dp_netdev_process_rxq_port接口负责接收报文，然后调用接口dp_netdev_input–&gt;dp_netdev_input__负责查表，然后调用packet_batch_execute–&gt;dp_netdev_execute_actions执行actions操作。</p> 
<p style="margin-left:0cm;">pmd_thread_main</p> 
<ol><li>pmd_thread_setaffinity_cpu设置线程绑定的lcore。</li><li>for无限循环</li><li>for循环各个端口，执行dp_netdev_process_rxq_port处理端口。</li><li>循环中间会根据变动重新加载端口和队列信息。</li></ol> 
<p style="margin-left:0cm;">dp_netdev_process_rxq_port</p> 
<ol><li>调用netdev_rxq_recv接收报文，前后都有计时。</li><li>调用dp_netdev_input将报文传输给flow，并且发送报文，前后都有计时。</li><li>netdev_rxq_recv=&gt;netdev_dpdk_vhost_rxq_recv</li><li>调用dpdk接口rte_vhost_dequeue_burst接收报文。</li><li>调用netdev_dpdk_vhost_update_rx_counters更新统计信息。</li></ol> 
<p style="margin-left:0cm;">dp_netdev_input=&gt;dp_netdev_input__</p> 
<ol><li>emc_processing主要是将收到的几个报文解析key值，并且从cache中查找流表，匹配的报文放入流表；返回不匹配的报文个数。</li><li>如果存在不匹配的报文，调用fast_path_processing则继续查找全部表项，找到则将流表放入cache，不匹配则上报到controller。</li><li>调用packet_batch_execute根据流表来操作报文。</li></ol> 
<p style="margin-left:0cm;">dfc_processing</p> 
<ol><li>调用miniflow_extract将报文解析到key值。</li><li>调用emc_lookup，从hash表中查找，并且进行key值比较。</li><li>如果匹配，调用dp_netdev_queue_batches将报文添加在flow-&gt;batches中。</li><li>不匹配将不匹配的报文当前排。</li><li>调用dp_netdev_count_packet统计匹配的报文数。</li></ol> 
<p style="margin-left:0cm;">fast_path_processing</p> 
<ol><li>dpcls_lookup通过classifier查找子流表，如果所有的报文都找到了匹配的子流表，将流表插入缓存中，并且将报文加入flow-&gt;batches。</li><li>如果不匹配，则上报到controller。</li><li>统计匹配、不匹配和丢失。</li></ol> 
<p style="margin-left:0cm;">packet_batch_per_flow_execute</p> 
<ol><li>调用dp_netdev_flow_get_actions获取flow对应的actions。</li><li>dp_netdev_execute_actions执行对应的actions</li><li>actions操作</li></ol> 
<p style="margin-left:0cm;">dp_netdev_execute_actions=&gt;odp_execute_actions</p> 
<ol><li>如果是一些基本操作的话，调用接口dp_execute_cb。</li></ol> 
<p style="margin-left:0cm;">dp_execute_cb</p> 
<ol><li>如果是OVS_ACTION_ATTR_OUTPUT，调用dp_netdev_lookup_port查找端口，然后调用netdev_send进行报文发送。</li><li>如果是OVS_ACTION_ATTR_TUNNEL_PUSH，调用push_tnl_action进行tunnel封装，然后调用dp_netdev_recirculate–&gt;dp_netdev_input__重新查表操作。</li><li>如果是OVS_ACTION_ATTR_TUNNEL_POP，调用netdev_pop_header解封装，然后调用dp_netdev_recirculate–&gt;dp_netdev_input__重新查表操作。</li></ol> 
<p style="margin-left:0cm;">netdev_send=&gt;netdev_dpdk_vhost_send=&gt;__netdev_dpdk_vhost_send</p> 
<ol><li>循环调用dpdk接口rte_vhost_enqueue_burst发送报文。</li><li>调用netdev_dpdk_vhost_update_tx_counters更新统计信息。</li></ol> 
<p style="margin-left:0cm;">PMD线程在其轮询列表中持续轮询输入端口，在每一个端口上最多可同时收32个包（<span style="color:#FF0000;">NETDEV_MAX_BURST</span>），根据激活的流规则可将每一个收包进行分类。分类的目的是为了找到一个流，从而对包进行恰当的处理。包根据流进行分组，并且每一个分组将执行特定的动作。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e8e1e8ed142a9fd61fc67d5a0f654347/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">自定义TextView末尾增加高亮文字(ForegroundColorSpan)和点击事件(ClickableSpan)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c98d974ace82526b87996151c91f0219/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python 两个列表相互映射_Python：两个列表之间的快速映射和查找</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>