<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【JavaScript】原型对象 =＞ 原型链的深入浅出解读 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【JavaScript】原型对象 =＞ 原型链的深入浅出解读" />
<meta property="og:description" content="文章目录 先知概念：原型 prototype隐式原型 __ proto __原型链 先知概念： 在了解原型与原型链之前，我们应该要先明确以下几个概念：
1. 在 JS中 所有的普通对象 都是 通过 new 一个函数来创建的。
2. 在 JS中 所有的函数 本质上也是一个对象，它是通过 new Function产生的。
诠释：【1】
我们平时所写的 let a = {};，其实本质上 相当于 let a = new Object(); 我们所简写的 {} 算是一个语法糖，同理 let b = [];，相当于 let b = new Array();，我们简写的 [] 也是一个语法糖
let a = {}; //等同 new Object() console.log(a); let b = []; //等同 new Array() console.log(b); 案例说明：当我们自定义一个函数，并通过 new 来创建一个对象。
问：下面 new test()是否会产生一个对象，并且是哪个构造函数的对象？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/de19f267ca5641fb854c653f39584dc1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-26T10:45:29+08:00" />
<meta property="article:modified_time" content="2023-12-26T10:45:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【JavaScript】原型对象 =＞ 原型链的深入浅出解读</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/57/d3/CXqqmk7e_o.gif" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/c1/be/KW0Hg9Fa_o.png" alt="在这里插入图片描述"></p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_8" rel="nofollow">先知概念：</a></li><li><a href="#__prototype_88" rel="nofollow">原型 prototype</a></li><li><a href="#_____proto____108" rel="nofollow">隐式原型 __ proto __</a></li><li><a href="#_131" rel="nofollow">原型链</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_8"></a>先知概念：</h2> 
<blockquote> 
 <p><strong>在了解<code>原型与原型链</code>之前，我们应该要先明确以下几个概念：</strong></p> 
</blockquote> 
<p><strong>1. 在 JS中 <code>所有的普通对象</code> 都是 通过<code> new 一个函数</code>来创建的</strong>。<br> <strong>2. 在 JS中 <code>所有的函数</code> 本质上也是一个<code>对象</code>，它是通过 <code>new Function</code>产生的</strong>。</p> 
<p><strong><code>诠释</code>：</strong>【1】</p> 
<p><strong>我们平时所写的 <code>let a = {};</code>，其实本质上 相当于 <code>let a = new Object();</code> 我们所简写的 <code>{}</code> 算是一个语法糖，同理 <code>let b = [];</code>，相当于 <code>let b = new Array();</code>，我们简写的 <code>[]</code> 也是一个语法糖</strong></p> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//等同 new Object()</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//等同 new Array()</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>案例说明：当我们自定义一个函数，并通过 <code>new</code> 来创建一个对象。</p> 
<p>问：下面 <code>new test()</code>是否会产生一个对象，并且是哪个构造函数的对象？</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">test</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//  Object  </span>
</code></pre> 
<p><strong>首先 通过<code>new </code> 一个函数肯定会产生一个对象。因为我们说过对象也一定是通过 <code>new </code>一个函数产生的。</strong></p> 
<p><strong>在这一段代码中 有的小伙伴可能会认为这就是 <code>new test</code> 所以 构造函数 是<code>test</code>，其实非也。因为，如果一个函数中的返回值 <code>是一个对象</code>的话，那么我们通过 <code>new</code> 得到的就是它的<code>返回值本身</code>，此处的函数返回值是一个<code>{}</code>，相当于是 <code>new Object()</code>，就是说 obj 等于 <code>new Object()</code> 产生的 一个 <code>普通的 Object 对象</code></strong><br> <img src="https://images2.imgbox.com/cb/7a/8Vc7GibQ_o.png" alt="在这里插入图片描述"></p> 
<p>—__—<strong>同理反之：</strong><br> <strong>如果此处的函数返回值是一个<code>非对象</code> 的值或者 <code>没有返回值</code>，那么得到的就是<code>当前构造函数的对象</code></strong></p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">test</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">//return 123;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//  test</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ff/22/WX9tKnBB_o.png" alt="在这里插入图片描述"></p> 
<p><strong><code>诠释</code>：</strong>【2】 <strong>（ 在 JS中 <code>所有的函数</code> 本质上也是一个<code>对象</code>，它是通过 <code>new Function</code>产生的）</strong></p> 
<p><strong>我们平时写法定义的函数 <code>function fn() {}</code>，其实本质上 相当于 <code>let fn = new Function();</code> 我们定义函数的 <code>function </code> 关键字，其实也属于一个语法糖，再结合我们上面讲的，只要 <code>new</code> 一个函数，一定会产生一个对象，因为 函数也是通过 <code>new</code>得来的，所以说<code>函数本质上也是一个对象</code>。</strong></p> 
<blockquote> 
 <p><strong>从这里开始，我们就可以区分出在 JS 中，对象可以被分为 <code>普通对象</code> 和 <code>函数对象</code>。再说的通俗一点就是，函数本质上既是一个函数也是一个对象，而对象本质上是一个对象，但不一定是一个函数。</strong></p> 
</blockquote> 
<p><strong>图例：</strong><br> <img src="https://images2.imgbox.com/a5/af/N06AZJO5_o.png" alt="在这里插入图片描述"></p> 
<p><strong>结论：<code>普通对象</code>是一个对象，他通过 <code>new</code> 一个<code>函数</code> 来创建。<code>函数</code>也是一个对象，它通过 <code>new Function</code> 来创建。</strong></p> 
<blockquote> 
 <p><strong>看到图例这里，或许有的小伙伴又产生疑问：大写的 <code>Function</code> 其实本质上也是一个函数及构造函数，同时上面说过函数也是一个对象，而对象也一定是通过，<code>new 一个函数</code>创建的 ，那么好奇 <code>Function</code> 又是怎么来的呢？他又是 <code>new</code> 谁创建的呢？其实在这里，需要说明一下的就是 <code>Function</code> 是一个<code>比较特殊</code>的存在，它是<code> JS 引擎</code> 启动的时候，被<code>直接放在 内存中</code>的，它不通过任何东西来创建。</strong></p> 
</blockquote> 
<p><strong><code>补充</code>：</strong><br> <strong>只有<code>普通函数</code> 才能够被 <code>new</code>，用来作为一个构造函数使用。</strong><br> <strong>由于函数也是一个对象，所以函数身上可以<code>有属性或方法</code>。</strong><br> <strong>所有对象都是<code>引用类型</code>，赋值的时候实际上是赋值的一个地址，用来指向一块内存空间</strong></p> 
<hr> 
<h2><a id="__prototype_88"></a>原型 prototype</h2> 
<blockquote> 
 <p><strong><code>所有</code>的<code>函数</code>身上都有一个属性：<code>prototype</code>，被称之为 <code>函数原型</code>。</strong></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/7b/32/VkqrqZJY_o.png" alt="在这里插入图片描述"></p> 
<p><strong>默认情况下，<code>prototype</code> 是一个普通的 <code>Object 对象</code>，并且在 <code>prototype</code> 中默认会携带一个属性 叫做 <code>constructor</code> 的属性，它也是一个对象（函数对象），它指向当前构造函数自身。</strong></p> 
<p><img src="https://images2.imgbox.com/55/de/nZtPyssy_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/36/ef/Dco6nyZi_o.png" alt="在这里插入图片描述"></p> 
<p>理解图例：<br> <img src="https://images2.imgbox.com/15/01/ZcbSStnH_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="_____proto____108"></a>隐式原型 __ proto __</h2> 
<blockquote> 
 <p><strong><code>所有</code>的<code>对象</code>都有一个属性 <code>__proto__</code>，他被称之为<code>隐式原型</code>。</strong></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/98/fe/F7QaQApF_o.png" alt="在这里插入图片描述"></p> 
<p><strong>默认情况下 <code>隐式原型</code>指向<code>创建该对象</code>的<code>构造函数</code>的<code>原型</code></strong></p> 
<p><img src="https://images2.imgbox.com/1d/48/3U5gxDfZ_o.png" alt="在这里插入图片描述"><br> <strong>图例：</strong><br> <img src="https://images2.imgbox.com/d8/98/SXcdpbRa_o.png" alt="在这里插入图片描述"></p> 
<p><strong>当访问一个对象的属性成员时。</strong></p> 
<ol><li><strong>首先会在当前对象自身上查找，如果属性存在，则直接使用。</strong></li><li><strong>如果不存在，则会在当前对象的 <code>隐式原型</code> 上查看自己的构造函数身上有没有该属性，如果找到了就使用，没找到就继续向顶层查找，直到找到顶层的 <code>Object</code> 的身上，如果还没找到，这时候就会报错抛出异常。</strong></li></ol> 
<hr> 
<h2><a id="_131"></a>原型链</h2> 
<blockquote> 
 <p><strong>所谓的原型链 其实就是 一个<code>对象 由下逐步向上层逐层查找属性成员的一种形式描述</code>。</strong></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/56/3c/X80dfnAm_o.png" alt="在这里插入图片描述"></p> 
<p><strong><code>__proto__</code> 在进行向上查找时，由于 <code>__proto__</code> 自身也是对象，所以也可以调用 自身的 <code>__proto__</code>，这样的过程，由于看起来，像是一个链条一样，故而被称之为 <code>原型链</code></strong></p> 
<p><strong>图例分析：</strong><br> <img src="https://images2.imgbox.com/4d/c6/2zyKHuC1_o.png" alt="在这里插入图片描述"><br> <strong>补充：</strong></p> 
<ul><li><strong><code>Function </code>的<code>隐式原型</code>指向<code>自身的原型</code>（特殊点）</strong></li><li><strong><code>Obiect.prototype.__proto__ </code>指向 <code>null </code>（查找到顶层了，实在是没有了）</strong></li></ul> 
<p><img src="https://images2.imgbox.com/dd/20/n2e9EqNQ_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><img src="https://images2.imgbox.com/45/4c/jSMt4AGx_o.gif" alt="在这里插入图片描述"></p> 
<hr> 
<blockquote> 
 <p>🚵‍♂️ 博主座右铭：<em><strong>向阳而生，我还在路上！</strong></em><br> ——————————————————————————————<br> 🚴博主想说：<em><strong>将持续性为社区输出自己的资源，同时也见证自己的进步！</strong></em><br> ——————————————————————————————<br> 🤼‍♂️ 如果都看到这了，博主希望留下你的足迹！【📂收藏！👍点赞！✍️评论！】<br> ——————————————————————————————</p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ae8e72f357326d4fcc43192e3b5d928e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">background-size的几种取值</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ec90a6bbd48d208bb8fbb9347f7eb763/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uview表单校验带星号</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>