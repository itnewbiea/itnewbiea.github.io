<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【python】sort函数的时间&#43;空间复杂度（包括py内置.sort()） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【python】sort函数的时间&#43;空间复杂度（包括py内置.sort()）" />
<meta property="og:description" content="python有个内置的nums.sort()排序函数,其内部实现机制为：Timesort
最坏时间复杂度为：O（n log n）
空间复杂度为：O（n）
顺便整理一下其他的各种排序算法：
排序算法平均时间复杂度最好情况最坏情况空间复杂度排序方式稳定性插入排序O(n²)O(n)O(n²)O(1)In-place稳定冒泡排序O(n²)O(n)O(n²)O(1)In-place稳定选择排序O(n²)O(n²)O(n²)O(1)In-place不稳定快速排序O(n log n)O(n log n)O(n²)O(log n)In-place不稳定希尔排序O(n log n)O(n log n)O(n log n)O(1)In-place不稳定堆排序O(n log n)O(n log n)O(n log n)O(1)In-place不稳定归并排序O(n log n)O(n log n)O(n log n)O(n)Out-place稳定 直接插入排序： def insert_sort(array): for i in range(len(array)): for j in range(i): if array[i] &lt; array[j]: array.insert(j, array.pop(i)) break return array 希尔排序： def shell_sort(array): gap = len(array) while gap &gt; 1: gap = gap // 2 for i in range(gap, len(array)): for j in range(i % gap, i, gap): if array[i] &lt; array[j]: array[i], array[j] = array[j], array[i] return array 选择排序： def select_sort(array): for i in range(len(array)): x = i # min index for j in range(i, len(array)): if array[j] &lt; array[x]: x = j array[i], array[x] = array[x], array[i] return array 堆排序： def heap_sort(nums): # 调整堆 # 迭代写法 def adjust_heap(nums, startpos, endpos): newitem = nums[startpos] pos = startpos childpos = pos * 2 &#43; 1 while childpos &lt; endpos: rightpos = childpos &#43; 1 if rightpos &lt; endpos and nums[rightpos] &gt;= nums[childpos]: childpos = rightpos if newitem &lt; nums[childpos]: nums[pos] = nums[childpos] pos = childpos childpos = pos * 2 &#43; 1 else: break nums[pos] = newitem # 递归写法 def adjust_heap(nums, startpos, endpos): pos = startpos chilidpos = pos * 2 &#43; 1 if chilidpos &lt; endpos: rightpos = chilidpos &#43; 1 if rightpos &lt; endpos and nums[rightpos] &gt; nums[chilidpos]: chilidpos = rightpos if nums[chilidpos] &gt; nums[pos]: nums[pos], nums[chilidpos] = nums[chilidpos], nums[pos] adjust_heap(nums, pos, endpos) def heap_sort(array): def heap_adjust(parent): child = 2 * parent &#43; 1 # left child while child &lt; len(heap): if child &#43; 1 &lt; len(heap): if heap[child &#43; 1] &gt; heap[child]: child &#43;= 1 # right child if heap[parent] &gt;= heap[child]: break heap[parent], heap[child] = \ heap[child], heap[parent] parent, child = child, 2 * child &#43; 1 heap, array = array." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ae4136cb1bf3ef76160de496b4056207/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-10T11:58:33+08:00" />
<meta property="article:modified_time" content="2022-02-10T11:58:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【python】sort函数的时间&#43;空间复杂度（包括py内置.sort()）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>python有个内置的nums.sort()排序函数,其内部实现机制为：<span style="background-color:#ffd900;">Timesort</span></p> 
<p>最坏时间复杂度为：O（n log n）</p> 
<p>空间复杂度为：O（n）</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/64/1c/Zw1frTbb_o.png"></p> 
<p>顺便整理一下其他的各种排序算法：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/17/0a/IDrgxAXY_o.png"></p> 
<table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th><th>排序方式</th><th>稳定性</th></tr></thead><tbody><tr><td>插入排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>In-place</td><td>稳定</td></tr><tr><td>冒泡排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>In-place</td><td>稳定</td></tr><tr><td>选择排序</td><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>In-place</td><td>不稳定</td></tr><tr><td>快速排序</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n²)</td><td>O(log n)</td><td>In-place</td><td>不稳定</td></tr><tr><td>希尔排序</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td><td>O(1)</td><td>In-place</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td><td>O(1)</td><td>In-place</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n)</td><td>Out-place</td><td>稳定</td></tr></tbody></table> 
<h4><span style="color:#fe2c24;"><strong>直接插入排序：</strong></span></h4> 
<pre>def insert_sort(array):
    for i in range(len(array)):
        for j in range(i):
            if array[i] &lt; array[j]:
                array.insert(j, array.pop(i))
                break
    return array</pre> 
<h4><span style="color:#fe2c24;">希尔排序：</span></h4> 
<pre>def shell_sort(array):
    gap = len(array)
    while gap &gt; 1:
        gap = gap // 2
        for i in range(gap, len(array)):
            for j in range(i % gap, i, gap):
                if array[i] &lt; array[j]:
                    array[i], array[j] = array[j], array[i]
    return array</pre> 
<h4><span style="color:#fe2c24;">选择排序：</span></h4> 
<pre>def select_sort(array):
    for i in range(len(array)):
        x = i  # min index
        for j in range(i, len(array)):
            if array[j] &lt; array[x]:
                x = j
        array[i], array[x] = array[x], array[i]
    return array</pre> 
<h4><span style="color:#fe2c24;"> 堆排序：</span></h4> 
<pre>def heap_sort(nums):
    # 调整堆
    # 迭代写法
    def adjust_heap(nums, startpos, endpos):
        newitem = nums[startpos]
        pos = startpos
        childpos = pos * 2 + 1
        while childpos &lt; endpos:
            rightpos = childpos + 1
            if rightpos &lt; endpos and nums[rightpos] &gt;= nums[childpos]:
                childpos = rightpos
            if newitem &lt; nums[childpos]:
                nums[pos] = nums[childpos]
                pos = childpos
                childpos = pos * 2 + 1
            else:
                break
        nums[pos] = newitem
    
    # 递归写法
    def adjust_heap(nums, startpos, endpos):
        pos = startpos
        chilidpos = pos * 2 + 1
        if chilidpos &lt; endpos:
            rightpos = chilidpos + 1
            if rightpos &lt; endpos and nums[rightpos] &gt; nums[chilidpos]:
                chilidpos = rightpos
            if nums[chilidpos] &gt; nums[pos]:
                nums[pos], nums[chilidpos] = nums[chilidpos], nums[pos]
                adjust_heap(nums, pos, endpos)</pre> 
<pre>def heap_sort(array):
    def heap_adjust(parent):
        child = 2 * parent + 1  # left child
        while child &lt; len(heap):
            if child + 1 &lt; len(heap):
                if heap[child + 1] &gt; heap[child]:
                    child += 1  # right child
            if heap[parent] &gt;= heap[child]:
                break
            heap[parent], heap[child] = \
                heap[child], heap[parent]
            parent, child = child, 2 * child + 1

    heap, array = array.copy(), []
    for i in range(len(heap) // 2, -1, -1):
        heap_adjust(i)
    while len(heap) != 0:
        heap[0], heap[-1] = heap[-1], heap[0]
        array.insert(0, heap.pop())
        heap_adjust(0)
    return array</pre> 
<h4><span style="color:#fe2c24;">冒泡排序：</span></h4> 
<pre>def bubble_sort(array):
    for i in range(len(array)):
        for j in range(i, len(array)):
            if array[i] &gt; array[j]:
                array[i], array[j] = array[j], array[i]
    return array</pre> 
<h4><span style="color:#fe2c24;">快速排序：</span></h4> 
<pre>def Quick_sort(num_list):
    '''
    快速排序，时间复杂度：O(nlog₂n)，空间复杂度：O(nlog₂n)，不是稳定排序
    '''   
    if len(num_list)&lt;2:    
        return num_list    
    left_list = []  #存放比基准结点小的元素  
    right_list = []  #存放比基准元素大的元素  
    base_node = num_list.pop(0) #在这里采用pop()方法的原因就是需要移除这个基准结点，并且赋值给base_node这个变量  
                                #在这里不能使用del()方法，因为删除之后无法再赋值给其他变量使用，导致最终数据缺失  
                                #快排每轮可以确定一个元素的位置，之后递归地对两边的元素进行排序  
    for one_num in num_list:    
        if one_num &lt; base_node:    
            left_list.append(one_num)    
        else:    
            right_list.append(one_num)    
    return Quick_sort(left_list) + [base_node] + Quick_sort(right_list)</pre> 
<h4><span style="color:#fe2c24;">归并排序：</span></h4> 
<pre>def merge_sort(nums):
    if len(nums) &lt;= 1:
        return nums
    mid = len(nums) // 2
    # 分
    left = merge_sort(nums[:mid])
    right = merge_sort(nums[mid:])
    # 合并
    return merge(left, right)

def merge(left, right):
    res = []
    i = 0
    j = 0
    while i &lt; len(left) and j &lt; len(right):
        if left[i] &lt;= right[j]:
            res.append(left[i])
            i += 1
        else:
            res.append(right[j])
            j += 1
    res += left[i:]
    res += right[j:]
    return res</pre> 
<h4><span style="color:#fe2c24;">基数排序：</span></h4> 
<pre>def radix_sort(array):
    bucket, digit = [[]], 0
    while len(bucket[0]) != len(array):
        bucket = [[], [], [], [], [], [], [], [], [], []]
        for i in range(len(array)):
            num = (array[i] // 10 ** digit) % 10
            bucket[num].append(array[i])
        array.clear()
        for i in range(len(bucket)):
            array += bucket[i]
        digit += 1
    return array</pre> 
<p>参考大佬整理内容，附链接：</p> 
<p><a href="https://www.cnblogs.com/guangluwutu/p/13499221.html" rel="nofollow" title="【算法】八大排序以及时间空间复杂度分析以及用Python实现 - 雪原那么远 - 博客园 (cnblogs.com)">【算法】八大排序以及时间空间复杂度分析以及用Python实现 - 雪原那么远 - 博客园 (cnblogs.com)</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/86852aeaed1122937c8ba115436ed2d2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">DeBUG|实例化servlet类xxxx异常</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/af2d5785b47189749c77330988738d53/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Win11解决应用程序字体太小</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>