<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Springboot整合RocketMQ 基本消息处理 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Springboot整合RocketMQ 基本消息处理" />
<meta property="og:description" content="目录
1. 同步消息
2. 异步消息
3. 单向消息
4. 延迟消息
5. 批量消息
6. 顺序消息
7. Tag过滤
8. 广播消息
导入依赖
&lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; YAML配置
rocketmq: name-server: localhost:9876 producer: group: test-group-producer #生产者必须配备生产者组 1. 同步消息 同步消息是发送消息后等待Broker的响应，确保消息被成功接收。
生产者：
@Autowired RocketMQTemplate rocketMQTemplate; @Test void contextLoads() { SendResult result = rocketMQTemplate.syncSend(&#34;test&#34;, MessageBuilder.withPayload(&#34;同步消息&#34;).build()); // SendResult result = rocketMQTemplate.syncSend(&#34;test&#34;, &#34;同步消息&#34;); System.out.println(&#34;发送状态：&#34; &#43; result.getSendStatus() &#43; &#34; 消息id：&#34; &#43; result.getMsgId()); } 2. 异步消息 异步消息是发送消息后不等待Broker响应，通过回调函数处理发送结果。
@Autowired RocketMQTemplate rocketMQTemplate; @Test void contextLoads() { rocketMQTemplate." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/914e883938704683137a5229c462c677/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-06T21:33:26+08:00" />
<meta property="article:modified_time" content="2024-01-06T21:33:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Springboot整合RocketMQ 基本消息处理</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20%E5%90%8C%E6%AD%A5%E6%B6%88%E6%81%AF-toc" style="margin-left:0px;"><a href="#1.%20%E5%90%8C%E6%AD%A5%E6%B6%88%E6%81%AF" rel="nofollow">1. 同步消息</a></p> 
<p id="2.%20%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF-toc" style="margin-left:0px;"><a href="#2.%20%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF" rel="nofollow">2. 异步消息</a></p> 
<p id="3.%20%E5%8D%95%E5%90%91%E6%B6%88%E6%81%AF-toc" style="margin-left:0px;"><a href="#3.%20%E5%8D%95%E5%90%91%E6%B6%88%E6%81%AF" rel="nofollow">3. 单向消息</a></p> 
<p id="4.%20%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF-toc" style="margin-left:0px;"><a href="#4.%20%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF" rel="nofollow">4. 延迟消息</a></p> 
<p id="5.%20%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF-toc" style="margin-left:0px;"><a href="#5.%20%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF" rel="nofollow">5. 批量消息</a></p> 
<p id="6.%20%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF-toc" style="margin-left:0px;"><a href="#6.%20%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF" rel="nofollow">6. 顺序消息</a></p> 
<p id="%C2%A07.%20Tag%E8%BF%87%E6%BB%A4-toc" style="margin-left:0px;"><a href="#%C2%A07.%20Tag%E8%BF%87%E6%BB%A4" rel="nofollow"> 7. Tag过滤</a></p> 
<p id="8.%C2%A0%E5%B9%BF%E6%92%AD%E6%B6%88%E6%81%AF-toc" style="margin-left:0px;"><a href="#8.%C2%A0%E5%B9%BF%E6%92%AD%E6%B6%88%E6%81%AF" rel="nofollow">8. 广播消息</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>导入依赖</p> 
<pre><code>       &lt;dependency&gt;
            &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;
            &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;</code></pre> 
<p>YAML配置</p> 
<pre><code>rocketmq:
  name-server: localhost:9876
  producer:
    group: test-group-producer #生产者必须配备生产者组
</code></pre> 
<h2 id="1.%20%E5%90%8C%E6%AD%A5%E6%B6%88%E6%81%AF">1. 同步消息</h2> 
<p>同步消息是发送消息后等待Broker的响应，确保消息被成功接收。</p> 
<p>生产者：</p> 
<pre><code class="language-java">   @Autowired
    RocketMQTemplate rocketMQTemplate;

    @Test
    void contextLoads() {
        SendResult result = rocketMQTemplate.syncSend("test", MessageBuilder.withPayload("同步消息").build());
//        SendResult result = rocketMQTemplate.syncSend("test", "同步消息");
        System.out.println("发送状态：" + result.getSendStatus() + " 消息id：" + result.getMsgId());
    }</code></pre> 
<h2 id="2.%20%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF">2. 异步消息</h2> 
<p>异步消息是发送消息后不等待Broker响应，通过回调函数处理发送结果。</p> 
<pre><code class="language-java">@Autowired
    RocketMQTemplate rocketMQTemplate;

    @Test
    void contextLoads() {
        rocketMQTemplate.asyncSend("test", MessageBuilder.withPayload("异步消息").build(), new SendCallback() {
            @Override
            public void onSuccess(SendResult sendResult) {
                System.out.println("发送成功"+sendResult);
            }

            @Override
            public void onException(Throwable throwable) {
                System.out.println("发送失败"+throwable);
            }
        });
    }</code></pre> 
<h2 id="3.%20%E5%8D%95%E5%90%91%E6%B6%88%E6%81%AF">3. 单向消息</h2> 
<p>单向消息是发送消息后不等待Broker响应，也没有回调函数。</p> 
<pre><code class="language-java">    @Autowired
    RocketMQTemplate rocketMQTemplate;

    @Test
    void contextLoads() {
      rocketMQTemplate.sendOneWay("test","单向消息");
    }</code></pre> 
<h2 id="4.%20%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF">4. 延迟消息</h2> 
<p>延迟消息是设置消息的延迟时间，确保消息在指定时间后才被消费。</p> 
<pre><code class="language-java"> @Autowired
    RocketMQTemplate rocketMQTemplate;

    @Test
    void contextLoads() {
        //在RocketMQ中，timeout（超时时间）是指消息发送的最大等待时间。当你发送一个消息时，系统会等待一定的时间来获取发送结果，这个等待的时间就是超时时间。单位ms
        Message&lt;String&gt; message = MessageBuilder.withPayload("延迟消息").build();
         //延迟级别 "1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h" 2对应5s
        SendResult result = rocketMQTemplate.syncSend("test", message, 2000, 2);
    }</code></pre> 
<h2 id="5.%20%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF">5. 批量消息</h2> 
<p>批量消息是将多个消息打包成一个消息批次发送，提高发送效率。</p> 
<pre><code class="language-java">    @Autowired
    RocketMQTemplate rocketMQTemplate;

    @Test
    void contextLoads() {
        List&lt;String&gt; list = Arrays.asList("blue", "red", "pink", "yello");
        rocketMQTemplate.syncSend("test",list);
    }</code></pre> 
<p>上面所有生产者对应的消费者代码为：</p> 
<pre><code class="language-java">@Component
@RocketMQMessageListener(topic = "test",consumerGroup = "test-group-consumer")
public class MQMsgListener implements RocketMQListener&lt;MessageExt&gt; {
    @Override
    public void onMessage(MessageExt message) {
        String msgId = message.getMsgId();
        String msg = new String(message.getBody());
        System.out.println("消息id："+msgId+"消息内容："+msg);
    }
}</code></pre> 
<h2 id="6.%20%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF">6. 顺序消息</h2> 
<p>顺序消息是保证同一个消息队列中的消息按顺序消费。</p> 
<p>生产者代码：</p> 
<pre><code class="language-java">    @Autowired
    RocketMQTemplate rocketMQTemplate;

    @Test
    void contextLoads() {
        for(int i=0;i&lt;10;i++)
        {
            rocketMQTemplate.syncSendOrderly("test","顺序消息"+i,"1");
        }
    }</code></pre> 
<p>消费者代码更改：</p> 
<pre><code class="language-java">@Component
@RocketMQMessageListener(topic = "test",consumerGroup = "test-group-consumer",consumeMode = ConsumeMode.ORDERLY)
public class MQMsgListener implements RocketMQListener&lt;MessageExt&gt; {
    @Override
    public void onMessage(MessageExt message) {
        String msgId = message.getMsgId();
        String msg = new String(message.getBody());
        System.out.println("消息id："+msgId+"消息内容："+msg);
    }
}
</code></pre> 
<h2 id="%C2%A07.%20Tag%E8%BF%87%E6%BB%A4"> 7. Tag过滤</h2> 
<p>消费者订阅的Tag和发送者设置的消息Tag相互匹配，则消息被投递给消费端进行消费。</p> 
<p>生产者</p> 
<pre><code class="language-java">    @Autowired
    RocketMQTemplate rocketMQTemplate;

    @Test
    void contextLoads() {
       rocketMQTemplate.syncSend("test:test","hello");
    }</code></pre> 
<p>消费者</p> 
<pre><code class="language-java">@Component
@RocketMQMessageListener(topic = "test",consumerGroup = "test-group-consumer",selectorType = SelectorType.TAG,selectorExpression = "test")
public class MQMsgListener implements RocketMQListener&lt;MessageExt&gt; {
    @Override
    public void onMessage(MessageExt message) {
        String msgId = message.getMsgId();
        String msg = new String(message.getBody());
        System.out.println("消息id："+msgId+"消息内容："+msg);
    }
}</code></pre> 
<h2 id="8.%C2%A0%E5%B9%BF%E6%92%AD%E6%B6%88%E6%81%AF">8. 广播消息</h2> 
<p>消费者代码：</p> 
<pre><code class="language-java">@Component
@RocketMQMessageListener(topic = "test",consumerGroup = "test1-group-consumer",messageModel = MessageModel.BROADCASTING)
public class MQMsgListener implements RocketMQListener&lt;MessageExt&gt; {
    @Override
    public void onMessage(MessageExt message) {
        String msgId = message.getMsgId();
        String msg = new String(message.getBody());
        System.out.println("消息id："+msgId+"消息内容："+msg);
    }
}</code></pre> 
<p><strong> <code>@RocketMQMessageListener</code> 注解参数如下：</strong></p> 
<p><img alt="" height="451" src="https://images2.imgbox.com/f0/5a/inc4QoNT_o.png" width="1200"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0cd0ff9ada9015aeffd5fcf11f0be688/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构】二叉树的概念及堆</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ad1c4ed7d8f05441402539cb39936028/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】栈和队列</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>