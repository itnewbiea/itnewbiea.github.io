<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; 笔记 23 （STL常用算法 - 算术生成 &amp; 集合） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; 笔记 23 （STL常用算法 - 算术生成 &amp; 集合）" />
<meta property="og:description" content="五. STL-常用算法 5. 常用算术生成算法 算术生成算法属于小型算法，使用时包含的头文件为 :
#include &lt; numeric &gt;
accumulate //计算容器元素累计总和 fill //向容器中添加元素 5.1 accumulate 功能：计算区间内容器元素累计总和
原型：
accumulate(iterator beg ,iterator end ,value); //其中value是起始值 int total = accumlate (v.begin(),v.end(),0); 总结：accumulate 使用时头文件是numeric，这个算法很使用
5.2 fill 功能：向容器中填充指定的元素
原型：
fill (iterator beg , iterator end , value); //其中value是填充的值 fill(v.begin(), v.end(),100); 总结：利用fill可以将容器区间内元素填充为指定的值
6. 常用集合算法 set_intersection //求两个容器的交集 set_union //求两个容器的并集 set_difference //求两个容器的差集 6.1 set_intersection 功能：求两个容器的交集
原型：
set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); //两个集合必须是有序序列，其中iterator dest是目标容器开始迭代器 示例：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0a4be2caa8b9194c48ae8994868780f8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-24T17:03:17+08:00" />
<meta property="article:modified_time" content="2023-06-24T17:03:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; 笔记 23 （STL常用算法 - 算术生成 &amp; 集合）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_STL_0"></a>五. STL-常用算法</h3> 
<h4><a id="5__1"></a>5. 常用算术生成算法</h4> 
<p>算术生成算法属于小型算法，使用时包含的头文件为 :<br> <strong>#include &lt; numeric &gt;</strong></p> 
<pre><code class="prism language-cpp">accumulate  <span class="token comment">//计算容器元素累计总和</span>
fill        <span class="token comment">//向容器中添加元素</span>
</code></pre> 
<h5><a id="51_accumulate_8"></a>5.1 accumulate</h5> 
<p>功能：计算区间内容器元素累计总和<br> 原型：</p> 
<pre><code class="prism language-cpp"><span class="token function">accumulate</span><span class="token punctuation">(</span>iterator beg <span class="token punctuation">,</span>iterator end <span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//其中value是起始值</span>

<span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token function">accumlate</span> <span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>总结：accumulate 使用时头文件是numeric，这个算法很使用</p> 
<h5><a id="52_fill_18"></a>5.2 fill</h5> 
<p>功能：向容器中填充指定的元素<br> 原型：</p> 
<pre><code class="prism language-cpp"><span class="token function">fill</span> <span class="token punctuation">(</span>iterator beg <span class="token punctuation">,</span> iterator end <span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//其中value是填充的值</span>

<span class="token function">fill</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>总结：利用fill可以将容器区间内元素填充为指定的值</p> 
<h4><a id="6__28"></a>6. 常用集合算法</h4> 
<pre><code class="prism language-cpp">set_intersection   <span class="token comment">//求两个容器的交集</span>
set_union          <span class="token comment">//求两个容器的并集</span>
set_difference     <span class="token comment">//求两个容器的差集</span>
</code></pre> 
<h5><a id="61_set_intersection_34"></a>6.1 set_intersection</h5> 
<p>功能：求两个容器的交集<br> 原型：</p> 
<pre><code class="prism language-cpp"><span class="token function">set_intersection</span><span class="token punctuation">(</span>iterator beg1<span class="token punctuation">,</span> iterator end1<span class="token punctuation">,</span> iterator beg2<span class="token punctuation">,</span> 
					iterator end2<span class="token punctuation">,</span> iterator dest<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//两个集合必须是有序序列，其中iterator dest是目标容器开始迭代器</span>
</code></pre> 
<p>示例：</p> 
<pre><code class="prism language-cpp"><span class="token comment">//取两个里面较小的值给目标容器开辟空间</span>
vTarget<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token function">min</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//返回目标容器的最后一个元素的迭代器地址</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator itEnd <span class="token operator">=</span> <span class="token function">set_intersection</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		vTarget<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>总结：<br> 1）求交集的两个集合必须是有序序列；<br> 2）目标容器开辟空间需要从两个容器中取最小值<br> 3）set_intersecton返回值是交集中最后一个元素的位置</p> 
<h5><a id="62_set_union_55"></a>6.2 set_union</h5> 
<p>功能：求两个集合的并集<br> 原型：</p> 
<pre><code class="prism language-cpp"><span class="token function">set_union</span><span class="token punctuation">(</span>iterator beg1<span class="token punctuation">,</span> iterator end1<span class="token punctuation">,</span> iterator beg2<span class="token punctuation">,</span> 
					iterator end2<span class="token punctuation">,</span> iterator dest<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//两个集合必须是有序序列</span>

<span class="token comment">//取两个容器的和给目标容器开辟空间</span>
vTarget<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> v2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//返回目标容器的最后一个元素的迭代器地址</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator itEnd <span class="token operator">=</span> <span class="token function">set_union</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		vTarget<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>总结：<br> 1）求并集的两个集合必须是有序序列；<br> 2）目标容器开辟空间需要两个容器相加<br> 3）set_union返回值是并集中最后一个元素的位置</p> 
<h5><a id="63_set_difference_74"></a>6.3 set_difference</h5> 
<p>功能：求两个集合的差集<br> 原型：</p> 
<pre><code class="prism language-cpp"><span class="token function">set_difference</span><span class="token punctuation">(</span>iterator beg1<span class="token punctuation">,</span> iterator end1<span class="token punctuation">,</span> iterator beg2<span class="token punctuation">,</span> 
					iterator end2<span class="token punctuation">,</span> iterator dest<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//两个集合必须是有序序列</span>

<span class="token comment">//取两个里面较大的值给目标容器开辟空间</span>
vTarget<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//返回目标容器的最后一个元素的迭代器地址</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator itEnd <span class="token operator">=</span> <span class="token function">set_union</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		vTarget<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>总结：<br> 1）求差集的两个集合必须是有序序列；<br> 2）目标容器开辟空间需要从两个容器中取较大值<br> 3）set_difference返回值是差集中最后一个元素的位置</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a5cc1f400555025a9317d9fb1344f261/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43; 笔记 22 （STL常用算法 - 排序 &amp; 拷贝 &amp; 替换）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/869108d2ceefc5a3bd9b81633a5a6a4d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Spring Boot学习】怎么配置文件，配置文件有什么用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>