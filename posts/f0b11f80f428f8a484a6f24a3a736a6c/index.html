<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>如何实现基于场景的接口自动化测试用例？来看看大佬的方案 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="如何实现基于场景的接口自动化测试用例？来看看大佬的方案" />
<meta property="og:description" content="自动化本身是为了提高工作效率，不论选择何种框架，何种开发语言，我们最终想实现的效果，就是让大家用最少的代码，最小的投入，完成自动化测试的工作。
基于这个想法，我们的接口自动化测试思路如下：
1.不变的内容全部通过配置化来实现，比如：脚本执行的环境、请求的 HOST、URL 路径、测试数据等；
2.环境和数据关联变更：依据不同的环境，选择不同的配置及对应的测试数据；
3.抽取公共方法，避免冗余代码；
4.场景化的用例，实现可配置化；
5.数据驱动。
1.问题 在做自动化的过程中，不能只考虑单接口的脚本，也要考虑场景化的用例。场景化的用例 不需要每个步骤都去校验所有的数据，可能 更多看重串联后的最终效果。
那什么是场景用例？
其实就是多个接口组成的业务场景，常规写代码的做法是，先调用接口1，验证结果， 再调用接口2，再继续接口3，… 等等；在测试场景中，可能只是各个接口的入参不一样，或者是调用的接口不一样。这样代码写起来就会冗余。
比如：
def test_01(self): # step 01 result1 = PackDemo().getTest() assert result1 == 4 # step02 result2 = PackDemo2().getTest2(&#34;name&#34;) assert result2 == &#39;name&#39; # step03 result3 = DemoApi().getTest() assert result3 == 2 这样的用例，对于简单的接口没什么问题，但是对于复杂的接口，校验逻辑比较多，或者入参比较多，实现的方式就过于单一了。且不同场景的话，每个都要更改调用的步骤和返回值，场景越多冗余越多。
如果使用配置化的方式，每次从配置文件中动态加载配置的场景用例， 而且能够做到加载后做对应的断言，那该多好。
怎么做呢？咱们看看一些核心的实现。
2.方案 2.1 项目结构 项目结构如下：
img
采用当前比较流行的 Python &#43; Pytest &#43; Allure 来实现，具体结构不做展开。
2.2 场景用例的配置数据 test_scenario.json { &#34;test_01&#34;: { &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f0b11f80f428f8a484a6f24a3a736a6c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-16T18:22:04+08:00" />
<meta property="article:modified_time" content="2022-11-16T18:22:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何实现基于场景的接口自动化测试用例？来看看大佬的方案</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>自动化本身是为了提高工作效率，不论选择何种框架，何种开发语言，我们最终想实现的效果，就是让大家用最少的代码，最小的投入，完成自动化测试的工作。</p> 
<p>基于这个想法，我们的接口自动化测试思路如下：</p> 
<p><strong>1.不变的内容全部通过配置化来实现</strong>，比如：脚本执行的环境、请求的 HOST、URL 路径、测试数据等；</p> 
<p><strong>2.环境和数据关联变更</strong>：依据不同的环境，选择不同的配置及对应的测试数据；</p> 
<p><strong>3.抽取公共方法，避免冗余代码</strong>；</p> 
<p><strong>4.场景化的用例</strong>，实现可配置化；</p> 
<p><strong>5.数据驱动。</strong></p> 
<h3><a id="1_17"></a>1.问题</h3> 
<p>在做自动化的过程中，不能只考虑单接口的脚本，也要考虑场景化的用例。<strong>场景化的用例</strong> 不需要每个步骤都去校验所有的数据，可能 <strong>更多看重串联后的最终效果</strong>。</p> 
<p>那什么是场景用例？</p> 
<p>其实就是多个接口组成的业务场景，常规写代码的做法是，先调用接口1，验证结果， 再调用接口2，再继续接口3，… 等等；在测试场景中，可能只是各个接口的入参不一样，或者是调用的接口不一样。这样代码写起来就会冗余。</p> 
<p>比如：</p> 
<pre><code>def test_01(self):
    # step 01
    result1 = PackDemo().getTest()
    assert result1 == 4

    # step02
    result2 = PackDemo2().getTest2("name")
    assert result2 == 'name'
    
    # step03
    result3 = DemoApi().getTest()
    assert result3 == 2
</code></pre> 
<p>这样的用例，对于简单的接口没什么问题，但是对于复杂的接口，校验逻辑比较多，或者入参比较多，实现的方式就过于单一了。且不同场景的话，每个都要更改调用的步骤和返回值，场景越多冗余越多。</p> 
<p>如果使用配置化的方式，每次从配置文件中动态加载配置的场景用例， 而且能够做到加载后做对应的断言，那该多好。</p> 
<p><strong>怎么做呢</strong>？咱们看看一些核心的实现。</p> 
<h3><a id="2_50"></a>2.方案</h3> 
<h3><a id="21__53"></a>2.1 项目结构</h3> 
<p>项目结构如下：</p> 
<p><img src="https://images2.imgbox.com/23/8d/tsbuBKpi_o.png" alt="图片"></p> 
<p>img</p> 
<p>采用当前比较流行的 Python + Pytest + Allure 来实现，具体结构不做展开。</p> 
<h3><a id="22__63"></a>2.2 场景用例的配置数据</h3> 
<pre><code> test_scenario.json
{
  "test_01": {
    "step_1": {  ---- 步骤节点名称，可自定义
      "packagePath": "api", --- 这个步骤要运行的方法所属类的包路径
      "class": "DemoApi", --- 这个步骤要运行的方法所属类名称
      "method": "getTest", --- 这个步骤要运行的方法名称
      "request": null,  ---这个步骤运行的方法入参
      "response": 2, ---这个步骤运行的结果，可以是一个值，或者对象
      "verify": { --- 数据校验的节点
        "type": 1, ---数据校验的类型
        "keys": null  ---如果是校验的特定字段，这里需要输入部分校验的字段
      }
    },
    "step_2": {
      "packagePath": "api.demo",
      "class": "PackDemo",
      "method": "getTest2",
      "request": "request -&gt; name",
      "response": 6,
      "verify": {
        "type": 1,
        "keys": null
      }
    },
    "step_3": {
      "packagePath": "api.demo",
      "class": "PackDemo2",
      "method": "getTest3",
      "request": {
        "name": "param-name",
        "num_list": ["a", "b", "c"]
      },
      "response": 8,
      "verify": {
        "type": 1,
        "keys": null
      }
    }
  }
}
</code></pre> 
<h3><a id="23__109"></a>2.3 动态加载类</h3> 
<p>在我们配置了以上的测试场景的数据后，我们希望在用例执行的过程中，通过获取我们的配置，能够动态的加载数据文件中提到的方法，并执行对应的方法，那这个过程的实现我们主要通过如下的动态加载类来实现。</p> 
<pre><code># DynamicLoad.py 
# 部分主要的摘录如下
 def __load_module(self):
        """
        加载对应路径下的模块
        :param package_path: 包路径
        :param class_name: 类名称
        :return:
        """
        return importlib.import_module("." + self.class_name, package=self.package_path)

def __getClassInstance(self):
    """
    加载对应的模块下的类，并返回对应类的实例 
    :param module_name: 对应的模块
    :param class_name:
    :return:
    """
    self.my_module = self.__load_module()
    self.my_class = getattr(self.my_module, self.class_name)()
    return self.my_class

def execMethod(self, method, *args):
    """
    加载对应类下的方法 
    :param instance: 对应的实例
    :param method: 要执行的方法
    :return:
    """
    result = getattr(self.__getClassInstance(), method)(*args)
    return result
</code></pre> 
<p>有了以上动态加载的方法后，在执行场景用例时，依据上述的方法，就可以执行测试文件中提到的方法。</p> 
<h3><a id="24__149"></a>2.4 场景分析类</h3> 
<p>在场景用例的测试数据中，除了需要解析需要执行的类、方法外，还要解析文件中涉及到的出入参及数据比对方式，因此，这里还需要一个场景分析类，来解析数据文件中关于具体执行过程的配置。</p> 
<pre><code> #ScenariosAnalyze.py
 def analyse_exe_scenario(self, case_data):
        step_result = {}
        summary = True
        for i in case_data:
            instance = DynamicLoad(case_data[i]['packagePath'], case_data[i]['class'])
            if case_data[i]['request'] is not None:
                result = instance.execMethod(case_data[i]['method'], case_data[i]['request'])
            else:
                result = instance.execMethod(case_data[i]['method'])
            if case_data[i]['verify'] is not None:
                compare_type = case_data[i]['verify']['type']
                keys = case_data[i]['verify']['keys']
                step_compare_result = DataCompare().compare_type(compare_type=compare_type, actual=result,
                                                                 expect=case_data[i]['response'], keys=keys)
                if not step_compare_result:
                    summary = False
            step_result[i] = step_compare_result
        step_result['summary'] = summary
        return step_result
</code></pre> 
<h3><a id="25__176"></a>2.5 用例实现</h3> 
<pre><code> @File : test_scenario.py

class TestScenario:

    @allure.story('场景用例01')
    @allure.severity(allure.severity_level.BLOCKER)
    @pytest.mark.smoke
    def test_01(self):
        result = None
        case_data = self.test_data_json['test_01']
        result = self.scenario_analyze.analyse_exe_scenario(case_data)
        assert result['summary'] is True
</code></pre> 
<p>通过上述简单的脚本调用，就可以完成一个场景用例的测试了。</p> 
<h3><a id="3_198"></a>3.小结</h3> 
<p>以上就是场景用例配置化的实现思路。</p> 
<p>它的优点是：</p> 
<p><strong>1.配置化</strong>： 一切固定不变的内容全部配置化，最终达到：一个环境配置文件，一套脚本，几套测试数据，依据环境的不同选择不同的测试数据执行对应的测试脚本；</p> 
<p><strong>2.门槛低</strong>：因为配置化，测试同学只要把测试数据文件中的关键节点配置好，然后在脚本中写下调用方法，就完成用例编写了；</p> 
<p><strong>3.好扩展</strong>：在后续的实现中，可以将这些配置全部页面化，包括环境、数据、脚本，达到无代码开发的目的；</p> 
<p>缺点当然是不够灵活，所以没有完美的方案，只有合适的，以上，仅供大家参考。</p> 
<p>如果你不想一个人野蛮生长，找不到系统的资料，问题得不到帮助，坚持几天便放弃的感受的话，可以加入我们的QQ群：<strong>746506216</strong>，大家可以一起讨论交流，里面会有各种软件测试资料和技术交流。</p> 
<hr> 
<h3><a id="_221"></a>资源分享</h3> 
<p><strong>下方这份完整的软件测试视频学习教程已经上传CSDN官方认证的二维码，朋友们如果需要可以自行免费领取 <code>【保证100%免费】</code></strong></p> 
<p><img src="https://images2.imgbox.com/73/a8/YPqZWHPP_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/91/81/HNlmk2Cl_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d08aace71b49f1efc84e0f3a9097cc18/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">springBoot自动装配</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/43e0ccc746f9f94a4b2546fe1bd0a700/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">配置maven报错The JAVA_HOME environment variable is not defined correctly的解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>