<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>springboot学习笔记 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="springboot学习笔记" />
<meta property="og:description" content="springboot学习笔记 spring基础 Spring概述 Spring的简史
xml配置注解配置java配置 Spring概述
Spring的模块
核心容器CoreContainer
Spring-CoreSpring-BeansSpring-ContextSpring-Context-SupportSpring-Expression AOP
Spring-AOPSpring-Aspects Messaging
Spring-Messaging WEB
Spring-WebSpring-WebmvcSpring-WebSocketSpring-Webmvc-Portlet 数据访问/集成(DataAccess/Intefration)
Spring-JDBCSpring-TXSpring-ORMSpring-OXMSpring-JMS Spring的生态
Spring BootSpring XDSpring CloudSpring DataSpring IntegrationSpring BatchSpring SecuritySpring HATEOASSpring SocialSpring AMQPSpring MobileSpring for AndroidSpring Web FlowSpring Web ServicesSpring LDAPSpring Session Spring项目快速搭建 Maven简介
Maven安装
Maven的pom.xml
dependenciesdependency变量定义编译插件 Spring项目的搭建
Spring Tool Suite
https://spring.io/tools/sts/all IntelliJ IDEA
NetBeans
https://netbeans.org/downloads/ Spring基础配置 1.使用POJO进行轻量级和最小侵入式开发
2.通过依赖注入和基于接口编程实现松耦合
3.通过AOP和默认习惯进行声明式编程
4.使用AOP和模版(template)减少模式化代码
Spring所有功能的设计和实现都是基于此四大原则
依赖注入
声明Bean的注解
@Component组件,没有明确的角色@Service在业务逻辑层(service层)@Repository在数据访问层(dao层)@Controller在展现层(MVC→SpringMVC) 注入Bean的注解
@Autowired:Spring提供的注解@Inject:JSR-330提供的注解@Resource:JSR-250提供的注解 Java配置
@Configuration声明当前类是一个配置类@Bean注解在方法上,声明当前方法的返回值为一个Bean AOP
面向切面编程,相对于OOP面向对象编程
Spring的AOP的存在目的是为了解耦.
AOP可以让一组类共享相同的行为." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/77f3ad96a03c338be91e8c0fa2ead859/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-17T20:59:33+08:00" />
<meta property="article:modified_time" content="2021-09-17T20:59:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">springboot学习笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="springboot_0"></a>springboot学习笔记</h2> 
<h3><a id="spring_2"></a>spring基础</h3> 
<h4><a id="Spring_4"></a>Spring概述</h4> 
<ul><li> <p>Spring的简史</p> 
  <ul><li>xml配置</li><li>注解配置</li><li>java配置</li></ul> </li><li> <p>Spring概述</p> 
  <ul><li> <p>Spring的模块</p> 
    <ul><li> <p>核心容器CoreContainer</p> 
      <ul><li>Spring-Core</li><li>Spring-Beans</li><li>Spring-Context</li><li>Spring-Context-Support</li><li>Spring-Expression</li></ul> </li><li> <p>AOP</p> 
      <ul><li>Spring-AOP</li><li>Spring-Aspects</li></ul> </li><li> <p>Messaging</p> 
      <ul><li>Spring-Messaging</li></ul> </li><li> <p>WEB</p> 
      <ul><li>Spring-Web</li><li>Spring-Webmvc</li><li>Spring-WebSocket</li><li>Spring-Webmvc-Portlet</li></ul> </li><li> <p>数据访问/集成(DataAccess/Intefration)</p> 
      <ul><li>Spring-JDBC</li><li>Spring-TX</li><li>Spring-ORM</li><li>Spring-OXM</li><li>Spring-JMS</li></ul> </li></ul> </li><li> <p>Spring的生态</p> 
    <ul><li>Spring Boot</li><li>Spring XD</li><li>Spring Cloud</li><li>Spring Data</li><li>Spring Integration</li><li>Spring Batch</li><li>Spring Security</li><li>Spring HATEOAS</li><li>Spring Social</li><li>Spring AMQP</li><li>Spring Mobile</li><li>Spring for Android</li><li>Spring Web Flow</li><li>Spring Web Services</li><li>Spring LDAP</li><li>Spring Session</li></ul> </li></ul> </li></ul> 
<h4><a id="Spring_67"></a>Spring项目快速搭建</h4> 
<ul><li> <p>Maven简介</p> </li><li> <p>Maven安装</p> </li><li> <p>Maven的pom.xml</p> 
  <ul><li>dependencies</li><li>dependency</li><li>变量定义</li><li>编译插件</li></ul> </li><li> <p>Spring项目的搭建</p> 
  <ul><li> <p>Spring Tool Suite</p> 
    <ul><li>https://spring.io/tools/sts/all</li></ul> </li><li> <p>IntelliJ IDEA</p> </li><li> <p>NetBeans</p> 
    <ul><li>https://netbeans.org/downloads/</li></ul> </li></ul> </li></ul> 
<h4><a id="Spring_89"></a>Spring基础配置</h4> 
<p>1.使用POJO进行轻量级和最小侵入式开发<br> 2.通过依赖注入和基于接口编程实现松耦合<br> 3.通过AOP和默认习惯进行声明式编程<br> 4.使用AOP和模版(template)减少模式化代码<br> Spring所有功能的设计和实现都是基于此四大原则</p> 
<ul><li> <p>依赖注入</p> 
  <ul><li> <p>声明Bean的注解</p> 
    <ul><li>@Component组件,没有明确的角色</li><li>@Service在业务逻辑层(service层)</li><li>@Repository在数据访问层(dao层)</li><li>@Controller在展现层(MVC→SpringMVC)</li></ul> </li><li> <p>注入Bean的注解</p> 
    <ul><li>@Autowired:Spring提供的注解</li><li>@Inject:JSR-330提供的注解</li><li>@Resource:JSR-250提供的注解</li></ul> </li></ul> </li><li> <p>Java配置</p> 
  <ul><li>@Configuration声明当前类是一个配置类</li><li>@Bean注解在方法上,声明当前方法的返回值为一个Bean</li></ul> </li><li> <p>AOP</p> <p>面向切面编程,相对于OOP面向对象编程<br> Spring的AOP的存在目的是为了解耦.<br> AOP可以让一组类共享相同的行为.<br> 在OOP中只能通过继承类和实现接口,来使代码的耦合度增强,且类继承智能为单继承,阻碍更多行为添加到一组类上,AOP弥补了OOP的不足.</p> 
  <ul><li> <p>@Aspect 声明是一个切面</p> <p>面向切面编程,相对于OOP面向对象编程<br> Spring的AOP的存在目的是为了解耦.<br> AOP可以让一组类共享相同的行为.<br> 在OOP中只能通过继承类和实现接口,来使代码的耦合度增强,且类继承智能为单继承,阻碍更多行为添加到一组类上,AOP弥补了OOP的不足.</p> </li><li> <p>拦截规则@After @Before @Around</p> </li><li> <p>PointCut</p> </li><li> <p>JoinPoint</p> </li></ul> </li></ul> 
<h3><a id="Spring_132"></a>Spring常用配置</h3> 
<h4><a id="BeanScope_134"></a>Bean的Scope</h4> 
<p>Scope描述的是Spring容器如何新建Bean的实例</p> 
<ul><li> <p>Singleton</p> <p>一个Spring容器中只有一个Bean的实例,此为Spring的默认配置,全容器共享一个实例</p> </li><li> <p>Prototype</p> <p>每次调用新建一个Bean的实例</p> </li><li> <p>Request</p> <p>Web项目中,给每一个http request新建一个Bean实例</p> </li><li> <p>Session</p> <p>Web项目中,给每一个http Session新建一个Bean实例</p> </li><li> <p>GlobalSession</p> <p>这个只在portal应用中有用,给每一个global http session 新建一个Bean实例.</p> </li></ul> 
<h4><a id="SpringEL_152"></a>SpringEL和资源调用</h4> 
<p>commons-io 将file转换称字符串</p> 
<ul><li>注入普通字符</li><li>注入操作系统属性</li><li>注入表达式云算结果</li><li>注入其他Bean的属性</li><li>注入文件内容</li><li>注入网址内容</li><li>注入属性文件</li></ul> 
<h4><a id="Bean_163"></a>Bean的初始化和销毁</h4> 
<ul><li> <p>Java配置方式</p> <p>@Bean的initMethod和destroyMethod</p> </li><li> <p>注解方式</p> <p>jsr250-api</p> <p>利用JSR-250的@PostConstruct和@PreDestroy</p> </li></ul> 
<h4><a id="Profile_173"></a>Profile</h4> 
<p>Profile为在不同环境下使用不通的配置提供了支持</p> 
<ul><li>@Profile</li><li>通过设定jvm的spring.profiles.active参数</li><li>web项目设置在Servlet的context parameter中</li></ul> 
<h4><a id="Application_Event_180"></a>事件Application Event</h4> 
<p>为Bean与Bean之间的消息通信提供了支持.<br> 当一个Bean处理完一个任务之后,希望另一个Bean知道并能做相应的处理,这时我们就需要让另外一个Bean监听当前Bean所发送的事件.</p> 
<ul><li>自定义事件,集成ApplicationEvent</li><li>定义事件监听器,实现ApplicationListener</li><li>使用容器发布事件</li></ul> 
<h3><a id="Spring_188"></a>Spring高级话题</h3> 
<h4><a id="Spring_Aware_190"></a>Spring Aware</h4> 
<ul><li> <p>BeanNameAware</p> <p>获得到容器中Bean的名称</p> </li><li> <p>BeanFactoryAware</p> <p>获得当前bean factory,这样可以调用容器的服务</p> </li><li> <p>ApplicationContextAware</p> <p>当前的Application context, 这样可以调用容器的服务</p> </li><li> <p>MessageSourceAware</p> <p>获得Message source,这样可以获得文本信息</p> </li><li> <p>ApplicationEventPublisherAware</p> <p>应用时间发布器,可以发布时间,</p> </li><li> <p>ResourceLoaderAware</p> <p>获得资源加载器,可以获得外部资源文件</p> </li></ul> 
<h4><a id="_210"></a>多线程</h4> 
<p>Sprinng 通过任务执行器(TaskExecutor)来实现多线程和并发编程.<br> 使用ThreadPoolTaskExecutor可实现一个基于线程池的TaskExecutor.<br> 而实际开发中任务一般是非阻碍的,即异步的,所以我们要在配置类中通过@EnableAsync开启对异步任务的支持,并通过在实际执行的Bean的方法中使用@Async注解来声明其是一个异步任务.</p> 
<h4><a id="_215"></a>计划任务</h4> 
<p>计划任务在Spring中的实现变得异常的简单.<br> 首先通过在配置类注解@EnableScheduling来开启对计划任务的支持,然后在要执行计划任务的方法上注解@Scheduled,声明这是一个计划任务</p> 
<ul><li>cron</li><li>fixDelay</li><li>fixRate</li></ul> 
<h4><a id="Conditional_223"></a>条件注解@Conditional</h4> 
<p>@Conditional 根据满足某一个特定条件创建一个特定的Bean<br> 当某一个jar包在一个类路径下的时候,自动配置一个或多个Bean:或者只有某个Bean被创建才会创建另外一个Bean.总的来说,就是根据特定条件来控制Bean的创建行为,这样我们可以利用这个特性进行一些自动的配置.</p> 
<h4><a id="_227"></a>组合注解与元注解</h4> 
<h4><a id="Enable_229"></a>@Enable*注解的工作原理</h4> 
<ul><li>直接导入配置类</li><li>依据条件选择配置类</li><li>动态注册Bean</li></ul> 
<h4><a id="_235"></a>测试</h4> 
<p>测试是开发工作中不可缺少的部分.<br> 单元测试只针对当前开发的类和方法进行测试,可以简单通过模拟依赖来实现,对运行环境没有依赖;但是仅仅进行单元测试是不够的,它智能验证当前类或方法能否正常工作,而我们降妖知道系统的各个部分组合在一起是否能正常工作,这就是集成测试才能在的意义.<br> 集成测试一般需要来自不同层的不通对象交互,如数据库,网络连接,Ioc容器等.</p> 
<ul><li>Spring TestContext Framework集成测试</li></ul> 
<h3><a id="SpringMVC_242"></a>SpringMVC基础</h3> 
<h4><a id="Spring_MVC_244"></a>Spring MVC概述</h4> 
<h4><a id="SpringMVC_246"></a>SpringMVC项目快速搭建</h4> 
<ul><li>构建Maven项目</li><li>日志配置</li><li>演示页面</li><li>Spring MVC配置</li><li>Web配置</li><li>简单控制器</li><li>运行</li></ul> 
<h4><a id="Spring_MVC_256"></a>Spring MVC的常用注解</h4> 
<ul><li>@Controller</li><li>@RequestMapping</li><li>@ResponseBody</li><li>@RequestBody</li><li>@PathVariable</li><li>@RestController</li></ul> 
<h4><a id="Spring_MVC_265"></a>Spring MVC的基本配置</h4> 
<ul><li> <p>静态资源映射</p> </li><li> <p>拦截器配置</p> </li><li> <p>@ControllerAdivce</p> 
  <ul><li> <p>@ExceptionHandler</p> <p>用于全局处理控制器里的异常</p> </li><li> <p>@InitBinder</p> <p>用来设置WebDataBinder,WebDataBinder用来自动绑定前台请求参数到Model中</p> </li><li> <p>@ModelAttribute</p> <p>@ModelAttribute本来的作用是绑定键值对到Model里,此处是让全局的@RequestMapping都能获得在此处设置的键值对</p> </li></ul> </li><li> <p>其他配置</p> 
  <ul><li>ViewController</li><li>路径匹配参数配置</li><li>WebMvcConfigurerAdapter</li><li>WebMvcConfigurer</li></ul> </li></ul> 
<h4><a id="Spring_MVC_287"></a>Spring MVC的高级配置</h4> 
<ul><li> <p>文件上传配置</p> <p>commons-fileupload<br> 文件上传是一个项目里经常要用的功能,Spring MVC通过配置一个MultipartResolver来上传文件<br> 在Spring的控制器中,通过MultipartFile来接收文件,通过MultupartFile[] files接收多个文件上传.</p> </li><li> <p>自定义HttpMessageConverter</p> <p>HttpMessageConverter是用来处理request和response里的数据的.</p> 
  <ul><li>MappingJackson2HttpMessageConverter</li><li>StringHttpMessageConverter</li></ul> </li><li> <p>服务器端推送技术</p> <p>当客户端向服务端发送请求,服务端会抓住这个请求不放,等有数据更新的时候才返回给客户端,当客户端接收到消息后,再向服务端发送请求,周而复始.</p> 
  <ul><li> <p>SSE</p> <p>SSE(Server Send Event 服务端发送事件)的服务器端推送和基于Servlet3.0+的异步方法特性,其中第一种方式需要新式浏览器的支持,第二种方式是跨浏览器的.</p> </li><li> <p>Servlet3.0+异步方法处理</p> </li></ul> </li></ul> 
<h4><a id="Spring_MVC_308"></a>Spring MVC的测试</h4> 
<p>测试驱动开发(Test Driven Development,TDD),我们(设计人员)按照需求先写一个自己预期结果的测试用例,这个测试用例刚开始肯定是失败的测试,随着不断的编码和重构,最终让测试用例通过测试,这样才能保证软件的质量和可控性.</p> 
<ul><li>MockMVC</li><li>MockHttpServlerRequest</li><li>MockHttpServletResponse</li><li>MockHttpSession</li></ul> 
<h3><a id="SpringBoot_316"></a>SpringBoot基础</h3> 
<h4><a id="SpringBoot_318"></a>SpringBoot概述</h4> 
<ul><li> <p>什么是SpringBoot</p> <p>随着动态语言的流行,Java的开发显得格外的笨重:繁多的配置,低下的开发效率,复杂的部署流程以及第三方技术集成难度大.<br> SpringBoot应运而生.<br> 它使用"习惯优于配置"(项目中存在大量的配置,此外还内置一个习惯性配置,让你无需手动进行配置)的理念让你的项目快速运行起来.使用SpringBoot很容易创建一个独立运行(运行Jar内嵌Servlet容器)准生产级别的基于Spring框架的项目,使用SpringBoot你可以不用或者只需要很少的Spring配置.</p> </li><li> <p>SpringBoot核心功能</p> 
  <ul><li> <p>独立运行的Spring项目</p> <p>Spring Boot可以以Jar包的形式独立运行,运行一个Spring Boot项目只需通过 java -jar xx.jar来运行</p> </li><li> <p>内嵌Servlet容器</p> <p>Spring Boot可选择内嵌 Tomcat Jetty或者Undertow,这样我们无须以war包形式部署项目</p> </li><li> <p>提供Starter简化Maven配置</p> </li><li> <p>自动配置Spring</p> </li><li> <p>准生产的应用监控</p> </li><li> <p>无代码声称和xml配置</p> <p>注解</p> </li></ul> </li><li> <p>SpringBoot的优缺点</p> 
  <ul><li> <p>优点</p> 
    <ul><li>快速构建项目</li><li>对主流开发框架的无配置集成</li><li>项目可独立运行,无需外部依赖Servlet容器</li><li>提供运行时的应用监控</li><li>极大地提高了开发,部署效率</li><li>与云计算的天然集成</li></ul> </li><li> <p>缺点</p> 
    <ul><li>书籍文档较少,且不够深入</li></ul> </li></ul> </li><li> <p>SpringBoot版本</p> </li></ul> 
<h4><a id="SpringBoot_357"></a>SpringBoot快速搭建</h4> 
<ul><li>http://start.spring.io</li><li>SpringToolSuite</li><li>InterlliJIDEA</li><li>SpringBootCLI</li><li>Maven手工构建</li><li>简单演示</li></ul> 
<h3><a id="SpringBoot_366"></a>SpringBoot核心</h3> 
<h4><a id="_368"></a>基本配置</h4> 
<ul><li> <p>入口类和@SpringBootApplication</p> 
  <ul><li>@Configuration</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul> </li><li> <p>关闭特定的自动配置</p> <p>关闭特定的自动配置应该使用@SpringBootApplication注解的exclude参数<br> 例如:@SpringBootApplication(exclude={DataSourceAutoConfiguration.class})</p> </li><li> <p>定制Banner</p> 
  <ul><li> <p>修改Banner</p> <p>src/main/resources 新建一个banner.txt<br> 通过http://patorjk.com/software/taag</p> </li><li> <p>关闭Banner</p> 
    <ul><li>main里修改</li><li>fluentAPI</li></ul> </li></ul> </li><li> <p>SpringBoot的配置文件</p> 
  <ul><li>application.properties</li><li>application.yml</li><li>src/main/resources</li></ul> </li><li> <p>starter pom</p> 
  <ul><li> <p>官方starter pom</p> 
    <ul><li> <p>spring-boot-starter</p> <p>Spring Boot 核心starter,包含自动配置,日志,yaml配置文件的支持</p> </li><li> <p>spring-boot-starter-actuator</p> <p>准生产特性,用来监控和管理应用</p> </li><li> <p>spring-boot-starter-remote-shell</p> <p>提供基于ssh协议的监控和管理</p> </li><li> <p>spring-boot-starter-amqp</p> <p>使用spring-rabbit来支持AMQP</p> </li><li> <p>spring-boot-starter-aop</p> <p>使用spring-aop和AspectJ支持面向切面编程</p> </li><li> <p>spring-boot-starter-batch</p> <p>对Spring Batch的支持</p> </li><li> <p>spring-boot-starter-cache</p> <p>对Spring Cache抽象的支持</p> </li><li> <p>spring-boot-starter-cloud-connectors</p> <p>对云平台(Cloud Foundry Heroku)提供的服务提供简化的连接方式</p> </li><li> <p>spring-boot-starter-data-elasticsearch</p> <p>通过spring-data-elasticsearch对Elasticsearch支持</p> </li><li> <p>spring-boot-starter-data-gemfire</p> <p>通过对spring-data-gemfire对分布式存储GemFire的支持</p> </li><li> <p>spring-boot-starter-data-jpa</p> <p>对JPA的支持,包含spring-data-jpa spring-orm和Hibernate</p> </li><li> <p>spring-boot-starter-data-mongodb</p> <p>通过spring-data-mongdb,对MongoDB进行支持</p> </li><li> <p>spring-boot-starter-data-rest</p> <p>通过spring-data-rest-webmvc将Spring Data repository 暴露为REST形式的服务</p> </li><li> <p>spring-boot-starter-data-solr</p> <p>通过spring-data-solrd对Apache Solr 数据检索平台的支持</p> </li><li> <p>spring-boot-starter-freemarker</p> <p>对FreeMarker模板引擎的支持</p> </li><li> <p>spring-boot-starter-groovy-templates</p> <p>对Groovy模板引擎的支持</p> </li><li> <p>spring-boot-starter-hateoas</p> <p>通过spring-hateoas对基于HATEOAS的REST形式的网络服务的支持</p> </li><li> <p>spring-boot-starter-hornetq</p> <p>通过HornetQ对JMS的支持</p> </li><li> <p>spring-boot-starter-integration</p> <p>对系统集成框架spring-integration的支持</p> </li><li> <p>spring-boot-starter-jdbc</p> <p>对JDBC数据库的支持</p> </li><li> <p>spring-boot-starter-jerscy</p> <p>对Jersery REST形式的网络服务的支持</p> </li><li> <p>spring-boot-starter-jta-atomikos</p> <p>通过Atomikos对分布式事务的支持</p> </li><li> <p>spring-boot-starter-jta-bitronix</p> <p>通过Bitronix对分布式事务的支持</p> </li><li> <p>spring-boot-starter-mail</p> <p>对javax.mai的支持</p> </li><li> <p>spring-boot-starter-mobile</p> <p>对spring-mobile的支持</p> </li><li> <p>spring-boot-starter-mustache</p> <p>对Mustache模板引擎的支持</p> </li><li> <p>spring-boot-starter-redis</p> <p>对键值对内存数据库Redis的支持,包含spring-redis</p> </li><li> <p>spring-boot-starter-security</p> <p>对spring-security的支持</p> </li><li> <p>spring-boot-starter-social-facebook</p> <p>通过spring-social-facebook对Facebook的支持</p> </li><li> <p>spring-boot-starter-social-linkedin</p> <p>通过spring-social-linkedin对Linkedin的支持</p> </li><li> <p>spring-boot-starter-social-twitter</p> <p>通过spring-social-twitter对Twitter的支持</p> </li><li> <p>spring-boot-starter-test</p> <p>对常用的测试框架JUnit Hamcrest 和Mockito的支持,包含spring-test模块</p> </li><li> <p>spring-boot-starter-thymeleaf</p> <p>对Thymeleaf模版引擎的支持,包含于Spring整合的配置</p> </li><li> <p>spring-boot-starter-velocity</p> <p>对Velocity模版引擎的支持</p> </li><li> <p>spring-boot-starter-web</p> <p>对Web项目开发的支持,包含Tomcat和spring-webmvc</p> </li><li> <p>spring-boot-starter-Tomcat</p> <p>Spring Boot默认的Servlet容器Tomcat</p> </li><li> <p>spring-boot-starter-Jetty</p> <p>使用Jetty作为Servlet容器替换Tomcat</p> </li><li> <p>spring-boot-starter-undertow</p> <p>使用Undertow作为Servlet容器替换Tomcat</p> </li><li> <p>spring-boot-starter-logging</p> <p>Spring Boot 默认的日志框架Logback</p> </li><li> <p>spring-boot-starter-log4j</p> <p>支持使用Log4J日志框架</p> </li><li> <p>spring-boot-starter-websocket</p> <p>对WebSocket开发的支持</p> </li><li> <p>spring-boot-starter-ws</p> <p>对Spring Web Services的支持</p> </li></ul> </li><li> <p>第三方starter pom</p> 
    <ul><li>Handlebars</li><li>Vaadin</li><li>Apache Camel</li><li>WRO4J</li><li>Spring Batch</li><li>HDIV</li><li>Jade Templates(jade4J)</li><li>Actitivi</li></ul> </li></ul> </li><li> <p>使用XML配置</p> 
  <ul><li>@ImportResource</li></ul> </li></ul> 
<h4><a id="_542"></a>外部配置</h4> 
<ul><li>命令行参数配置</li><li>常规属性配置</li><li>类型安全的配置(基于properties)</li></ul> 
<h4><a id="_548"></a>日志配置</h4> 
<h4><a id="Profile_550"></a>Profile配置</h4> 
<h4><a id="SpringBoot_552"></a>SpringBoot运行原理</h4> 
<p>java -jar xx.jar --debug</p> 
<p>application.properties<br> debug=true</p> 
<ul><li> <p>运作原理</p> </li><li> <p>核心注解</p> 
  <ul><li> <p>@ConditionalOnBean</p> <p>当容器里有指定的Bean的条件下</p> </li><li> <p>@ConditionalOnClass</p> <p>当类路径下有指定的类的条件下</p> </li><li> <p>@ConditionalOnExpression</p> <p>基于SpEL表达式作为判断条件</p> </li><li> <p>@ConditionalOnJava</p> <p>基于JVM版本作为判断条件</p> </li><li> <p>@ConditionalOnJndi</p> <p>在JNDI存在的条件下查找指定的位置</p> </li><li> <p>ConditionalOnMissingBean</p> <p>当容器里没有指定Bean的情况下</p> </li><li> <p>ConditionalOnMissingClass</p> <p>当类路径下没有指定的类的条件下</p> </li><li> <p>ConditionalOnNotWebApplication</p> <p>当前项目不是Web项目的条件下</p> </li><li> <p>ConditionalOnProperty</p> <p>指定的属性是否有指定的值</p> </li><li> <p>ConditionalOnResource</p> <p>类路径是否有指定的值</p> </li><li> <p>ConditionalOnSingleCandidate</p> <p>当指定Bean在容器中只有一个,或者虽然有多个但是指定首选的Bean</p> </li><li> <p>ConditionalOnWebApplication</p> <p>当前项目是Web项目的条件下</p> </li></ul> </li><li> <p>实例分析</p> 
  <ul><li>配置参数</li><li>配置Bean</li></ul> </li><li> <p>实战</p> </li></ul> 
<h3><a id="SpringbootWeb_604"></a>Springboot的Web开发</h3> 
<h4><a id="SpringBootWeb_606"></a>SpringBoot的Web开发支持</h4> 
<ul><li> <p>ServerPropertiesAutoConfiguration和ServerProperties</p> <p>自动配置内嵌Servlet容器</p> </li><li> <p>HttpEncodingAutoConfiguration和HttpEncodingProperties</p> <p>用来自动配置http的编码</p> </li><li> <p>MultipartAutoConfiguration和MultipartProperties</p> <p>用来自动配置上传文件的属性</p> </li><li> <p>JacksonHttpMessageConvertersConfiguration</p> <p>用来自动配置mappingJackson2HttpMessageConverter和mappingJackson2XmlHttpMessage Converter</p> </li><li> <p>WebMvcAutoConfiguration和WebMvcProperties</p> <p>配置SpringMVC</p> </li></ul> 
<h4><a id="Thymeleaf_623"></a>Thymeleaf模板引擎</h4> 
<ul><li> <p>Thymeleaf基础知识</p> <p>Thymeleaf是一个Java类库,它是一个xml/xhtml/html5的模版引擎,可以作为MVC的Web应用的View层.<br> Thymeleaf还提供了额外的模块与Sping MVC集成,所以我们可以使用Thymeleaf完全替代JSP</p> 
  <ul><li> <p>引入Thymeleaf</p> </li><li> <p>访问model中的数据</p> </li><li> <p>model中的数据迭代</p> </li><li> <p>数据判断</p> </li><li> <p>在javaScript中访问model</p> </li><li> <p>其他知识</p> <p>http://www.thymeleaf.org</p> </li></ul> </li><li> <p>与SpringMVC集成</p> </li><li> <p>SpringBoot的Thymeleaf支持</p> </li><li> <p>实战</p> 
  <ul><li>新建Spring Boot项目</li><li>示例JavaBean</li><li>脚本样式静态文件</li><li>演示页面</li><li>数据准备</li><li>运行</li></ul> </li></ul> 
<h4><a id="Web_648"></a>Web相关配置</h4> 
<ul><li> <p>SpringBoot提供的自动配置</p> 
  <ul><li> <p>自动配置的ViewResolver</p> 
    <ul><li>ContentNegotiatingViewResolver</li><li>BeanNameViewResolver</li><li>InternalResourceViewResolver</li></ul> </li><li> <p>自动配置的静态资源</p> 
    <ul><li>类路径文件</li><li>webjar</li></ul> </li><li> <p>自动配置的Formatter和Conventer</p> </li><li> <p>自动配置的HttpMessageConverters</p> </li><li> <p>静态首页的支持</p> </li></ul> </li><li> <p>接管SpringBoot的Web配置</p> </li><li> <p>注册Servlet,Filter,Listener</p> </li></ul> 
<h4><a id="Tomcat_670"></a>Tomcat配置</h4> 
<ul><li> <p>配置Tomcat</p> <p>配置Servlet容器<br> server.port<br> 配置Tomcat<br> server.tomcat.uri-encoding</p> </li><li> <p>代码配置Tomcat</p> 
  <ul><li> <p>通用配置</p> 
    <ul><li>新建类的配置</li><li>当前配置文件内配置</li></ul> </li><li> <p>特定配置</p> </li></ul> </li><li> <p>替换Tomcat</p> 
  <ul><li>替换为Jetty</li><li>替换为Undertow</li></ul> </li><li> <p>SSL配置</p> 
  <ul><li> <p>生成证书</p> <p>keytool</p> <p>keytool -genkey -alias tomcat</p> </li><li> <p>Spring Boot配置SSL</p> </li><li> <p>http转向https</p> </li></ul> </li></ul> 
<h4><a id="Favicon_702"></a>Favicon配置</h4> 
<ul><li> <p>默认的Favicon</p> </li><li> <p>关闭Favicon</p> <p>spring.mvc.favicon.enabled=false</p> </li><li> <p>设置自己的Favicon</p> <p>favicon.ico放置在src/main/resources/static</p> </li></ul> 
<h4><a id="WebSocket_711"></a>WebSocket</h4> 
<ul><li> <p>什么是WebSocket</p> <p>WebSocket为浏览器和服务端提供了双工异步通信的功能,即浏览器可以向服务端发送消息,服务端也可以向浏览器发送消息.</p> </li><li> <p>SpringBoot提供的自动配置</p> <p>Spring Boot 为WebSocket提供的 stater pom<br> 是spring-boot-starter-websocket</p> </li><li> <p>实战</p> 
  <ul><li> <p>准备</p> <p>选择Thymeleaf和WebSocket依赖</p> </li><li> <p>广播式</p> <p>广播式即服务端有消息时,会将消息发送给所有连接了当前endpoint的浏览器</p> 
    <ul><li> <p>配置WebSocket</p> <p>需要在配置类上使用@EnableWebSocketMessageBroket开启WebSoccket支持,并通过继承AbstractWebSocketMessageBrokerConfigurer类,重写其方法来配置WebSocket</p> </li><li> <p>浏览器向服务端发送的消息用此类接受</p> </li><li> <p>服务端向浏览器发送的此类的消息</p> </li><li> <p>控制器</p> </li><li> <p>添加脚本</p> </li><li> <p>演示页面</p> </li><li> <p>配置viewController</p> </li></ul> </li><li> <p>点对点式</p> 
    <ul><li>添加Spring Security的starter pom</li><li>Spring Security的简单配置</li><li>配置WebSocket</li><li>控制器</li><li>登录页面</li><li>聊天页面</li><li>增加页面的viewController</li></ul> </li></ul> </li></ul> 
<h4><a id="BootstrapAnglarJSWeb_751"></a>基于Bootstrap和AnglarJS的现代Web应用</h4> 
<p>单页面应用(single-page application, 简称SPA)指的是一种类似于原生客户端软件的更流畅的用户体验的页面.</p> 
<p>响应式设计(Responseive web design,简称RWD)指的是不通的设备(电脑,平板,手机)访问相同的页面的时候,得到不同的页面视图,而得到视图是适应当前屏幕的.</p> 
<p>数据导向是对于页面导向而言的,页面上的数据获得是通过消费后台的REST服务来实现的,而不是通过服务器渲染的动态页面来实现的,一般数据交换使用的格式是JSON</p> 
<ul><li> <p>Bootstrap</p> 
  <ul><li>什么是Bootstrap</li><li>下载并引入Bootstrap</li><li>CSS支持</li><li>页面组件支持</li><li>Javascript支持</li></ul> </li><li> <p>AngularJS</p> 
  <ul><li> <p>什么是AngularJS</p> </li><li> <p>下载并引入AngularJS</p> </li><li> <p>模块,控制器和数据绑定</p> </li><li> <p>Scope和Event</p> 
    <ul><li> <p>Scope</p> </li><li> <p>Event</p> 
      <ul><li>冒泡事件</li><li>广播事件</li></ul> </li></ul> </li><li> <p>多视图和路由</p> </li><li> <p>依赖注入</p> </li><li> <p>Service和Factory</p> </li><li> <p>自定义指令</p> </li></ul> </li><li> <p>实战</p> </li></ul> 
<h3><a id="SpringBoot_787"></a>SpringBoot的数据访问</h3> 
<h4><a id="Docker_789"></a>引入Docker</h4> 
<ul><li> <p>Docker的安装</p> 
  <ul><li>Linux下安装</li><li>Windows下安装</li></ul> </li><li> <p>Docker常用命令及参数</p> 
  <ul><li> <p>Docker镜像命令</p> 
    <ul><li> <p>Docker镜像检索</p> <p>docker search 镜像名</p> <p>docker search redis</p> </li><li> <p>镜像下载</p> <p>docker pull 镜像名</p> <p>docker pull redis</p> </li><li> <p>镜像列表</p> <p>docker images</p> </li><li> <p>删除镜像</p> <p>删除指定镜像<br> docker rmi image-id</p> <p>删除所有镜像<br> docker rmi$(docker images -q)</p> </li></ul> </li><li> <p>Docker容器命令</p> 
    <ul><li> <p>容器基本操作</p> <p>最简单的运行镜像容器<br> docker run --name container-name -d image-name</p> </li><li> <p>容器列表</p> <p>docker ps</p> </li><li> <p>查看运行和停止状态</p> <p>docker ps -a</p> </li></ul> </li><li> <p>停止和启动容器</p> 
    <ul><li> <p>停止容器</p> <p>停止容器<br> docker stop container-name/container-id</p> <p>docker stop test-redis</p> </li><li> <p>启动容器</p> <p>停止容器<br> docker start container-name/container-id</p> <p>docker start test-redis</p> </li><li> <p>端口映射</p> <p>Docker容器中运行的软件所使用的端口,在本机和本机的局域网是不能访问的,所以我们需要将Docker容器中的端口映射到当前主机的端口上,这样我们在本机和本机所在的局域网就能够访问该软件了</p> <p>docker run -d -p 6378:6379 --name port-redis redis</p> </li><li> <p>删除容器</p> <p>删除单个容器<br> docker rm container-id</p> <p>删除所有容器<br> docker rm $(docker ps -a -q)</p> </li><li> <p>容器日志</p> <p>查看当前容器日志<br> docker logs container-name/container-id</p> <p>docker logs port-redis</p> </li><li> <p>登录容器</p> <p>docker exec -it container-id/container-name bash</p> </li></ul> </li></ul> </li><li> <p>下载所需的Docker镜像</p> <p>docker pull wnameless/oracle-xe-11g<br> docker pull mongo<br> docker pull redis:2.8.21<br> docker pull cloudesire/activemq<br> docker pull rabbitmq<br> docker pull rabbitmq:3-management</p> </li><li> <p>异常处理</p> <p>boot2docker ssh</p> </li></ul> 
<h4><a id="SpringDataJPA_878"></a>SpringDataJPA</h4> 
<ul><li> <p>SpringDataJPA</p> 
  <ul><li> <p>什么是Spring Data JPA</p> </li><li> <p>定义数据访问层</p> <p>继承JpaRepository<br> public interface PersonRepository extends JpaRepository&lt;Person,Long&gt;{<!-- --><br> //定义数据访问操作方法<br> }</p> </li><li> <p>配置使用Spring Data JPA</p> <p>@EnableJpaRepositories</p> </li><li> <p>定义查询方法</p> 
    <ul><li> <p>根据属性名查询</p> 
      <ul><li> <p>常规查询</p> <p>select p from person p wehere p.name=?1<br> List</p> </li><li> <p>限制结果数量</p> <p>List</p> </li></ul> </li><li> <p>使用JPA的NamedQuery</p> </li><li> <p>使用@Query查询</p> 
      <ul><li> <p>使用参数索引</p> </li><li> <p>使用命名参数</p> </li><li> <p>更新查询</p> </li><li> <p>Specification</p> </li><li> <p>排序与分页</p> 
        <ul><li>定义</li><li>使用排序</li><li>使用分页</li></ul> </li></ul> </li></ul> </li><li> <p>自定义Repository的实现</p> 
    <ul><li>定义自定义Repository接口</li><li>定义接口实现</li><li>自定义ReposityFactoryBean</li><li>开启自定义支持使用@EnableJpaRepositories的repositoryFactoryBeanClass来指定FactoryBean即可</li></ul> </li></ul> </li><li> <p>SpringBoot的支持</p> 
  <ul><li>JDBC的自动配置</li><li>对JPA的自动配置</li><li>对Spring Data JPA的自动配置</li><li>Spring Boot下的Spring Data JPA</li></ul> </li><li> <p>实例</p> 
  <ul><li> <p>安装Oracle XE</p> 
    <ul><li> <p>非Docker 安装</p> </li><li> <p>Docker 安装</p> <p>运行一个oracle容器<br> docker run -d -p 9090:8080 -p 1521:1521 我那么less/oracle-xe-11g</p> </li><li> <p>端口映射</p> </li><li> <p>管理</p> </li></ul> </li><li> <p>新建Spring Boot 项目</p> </li><li> <p>配置基本属性</p> <p>spring:<br> profiles: dev<br> datasource:<br> url: jdbc:postgresql://192.168.3.219:5432/intp-fxl?useUnicode=true=utf-8<br> username: postgres<br> password: postgres<br> filters: log4j,wall,mergeStat</p> </li><li> <p>定义映射实体类</p> </li><li> <p>定义数据访问接口</p> </li><li> <p>运行</p> </li></ul> </li></ul> 
<h4><a id="SpringDataREST_956"></a>SpringDataREST</h4> 
<ul><li> <p>Spring Data REST</p> 
  <ul><li> <p>什么是Spring Data REST</p> </li><li> <p>Spring MVC中配置使用Spring Data REST</p> 
    <ul><li> <p>继承方式</p> <p>RepositoryRestMvcConfiguration</p> </li><li> <p>导入方式</p> <p>@Configuration<br> @Import(RepositoryRestMvcConfiguration.class)</p> </li></ul> </li></ul> </li><li> <p>SpringBoot的支持</p> </li><li> <p>实例</p> 
  <ul><li> <p>新建Spring Boot项目</p> </li><li> <p>实体类</p> </li><li> <p>实体类的Repository</p> </li><li> <p>Postman</p> </li><li> <p>REST服务测试</p> 
    <ul><li>jQuery</li><li>AngularJS</li><li>列表</li><li>获取单一对象</li><li>查询</li><li>分页</li><li>排序</li><li>保存</li><li>更新</li><li>删除</li></ul> </li><li> <p>定制</p> 
    <ul><li> <p>定制根路径</p> <p>spring.data.rest.base-path= /api</p> </li><li> <p>定制节点路径</p> <p>@RepositoryRestResource(path=“people”)</p> </li></ul> </li></ul> </li></ul> 
<h4><a id="_998"></a>声明式事务</h4> 
<ul><li> <p>Spring的事务机制</p> <p>提供一个PlatformTransactionManager接口,不同的数据访问技术的事务使用不通的接口实现</p> 
  <ul><li> <p>JDBC</p> 
    <ul><li>DataSourceTransactionManager</li></ul> </li><li> <p>JPA</p> 
    <ul><li>JpaTransactionManger</li></ul> </li><li> <p>Hibernate</p> 
    <ul><li>HibernateTransactionManger</li></ul> </li><li> <p>JDO</p> 
    <ul><li>JdoTransactionManger</li></ul> </li><li> <p>分布式事务</p> 
    <ul><li>JtaTransactionManager</li></ul> </li></ul> </li><li> <p>声明式事务</p> <p>@Transactional</p> </li><li> <p>注解事务行为</p> </li><li> <p>类级别使用@Transactional</p> </li><li> <p>SpringDataJPA的事务支持</p> </li><li> <p>SpringBoot的事务支持</p> 
  <ul><li>自动配置的事务管理器</li><li>自动开启注解事务的支持</li></ul> </li><li> <p>实例</p> </li></ul> 
<h4><a id="Cache_1036"></a>数据缓存Cache</h4> 
<p>内存速度大于硬盘速度.<br> 当我们需要重复地获取相同的数据的时候,我们一次又一次的请求数据库或者远程服务,导致大量的时间耗费在数据库查询或者远程方法调用上,导致程序性能的恶化,这便是数据缓存要解决的问题.</p> 
<ul><li> <p>Spring缓存支持</p> 
  <ul><li> <p>Spring支持的CacheManager</p> 
    <ul><li> <p>SimpleCacheManager</p> <p>使用简单的Collection来存储缓存,主要用来测试用途</p> </li><li> <p>ConcurrentMapCacheManager</p> <p>使用ConcurrentMap来存储缓存</p> </li><li> <p>NoOpCacheManager</p> <p>仅测试用途,不会实际存储缓存</p> </li><li> <p>EhCacheCacheManager</p> <p>使用EhCache作为缓存技术</p> </li><li> <p>GuavaCacheManager</p> <p>使用Google Guava的GuavaCache作为缓存技术</p> </li><li> <p>HazelcastCacheManager</p> <p>使用Hazelcast作为缓存技术</p> </li><li> <p>JCacheCacheManager</p> <p>支持Jcache(JSR-107)标准的实现作为缓存技术,如Apache Commons JCS</p> </li><li> <p>RedisCacheManager</p> <p>使用Redis 作为缓存技术</p> </li></ul> </li><li> <p>声明式缓存注解</p> 
    <ul><li> <p>@Cacheable</p> <p>在方法执行前Spring先查看缓存中是否有数据,如果有数据,则直接返回缓存数据;若没有数据,调用方法并将方法返回值放进缓存</p> </li><li> <p>@CachePut</p> <p>无论怎样,都会将方法的返回值放到缓存中.@CachePut的属性与@Cacheable保持一致</p> </li><li> <p>@CacheEvict</p> <p>将一条或多条数据从缓存中删除</p> </li><li> <p>@Caching</p> <p>可以通过@Caching注解组合多个注解策略在一个方法上</p> </li></ul> </li><li> <p>开启声明式缓存支持</p> <p>@EnableCaching</p> </li></ul> </li><li> <p>SpringBoot的事务支持</p> </li><li> <p>实例</p> </li><li> <p>切换缓存技术</p> 
  <ul><li>EhCache</li><li>Guava</li><li>Redis</li></ul> </li></ul> 
<h4><a id="NoSQL_1093"></a>非关系型数据库NoSQL</h4> 
<p>noSQL是对于不使用惯性作为数据管理的数据库系统的统称.<br> NoSQL的主要特点是不使用SQL语言作为查询语言,数据存储也不是固定那个的表,字段</p> 
<p>主要有文档存储型(MongoDB)<br> 图形关系存储型(Neo4j)<br> 键值对存储型(Redis)</p> 
<ul><li> <p>MongoDB</p> <p>MongoDB是一个基于文档(Document)的存储型的数据库,使用面向对象的思想,每一条数据记录都是文档的对象.</p> 
  <ul><li> <p>Spring的支持</p> <p>Spring 对MongoDB的支持主要是通过Spring Data MongoDB来实现.</p> 
    <ul><li> <p>Object/Document映射注解支持</p> <p>JPA提供了一套Object/Relation映射的注解(@Entity @Id),</p> 
      <ul><li> <p>@Document</p> <p>映射领域对象与MongoDB的一个文档</p> </li><li> <p>@Id</p> <p>映射当前属性是ID</p> </li><li> <p>DbRef</p> <p>ID档前属性将参考其他的文档</p> </li><li> <p>@Field</p> <p>为文档的属性定义名称</p> </li><li> <p>@Version</p> <p>将当前属性作为版本</p> </li></ul> </li><li> <p>MongoTemplate</p> </li><li> <p>Repository的支持</p> </li></ul> </li><li> <p>SpringBoot的支持</p> </li><li> <p>安装MongoDB</p> 
    <ul><li> <p>非Docker</p> </li><li> <p>Docker安装</p> <p>docker run -d -p 27017:27017 mongo</p> </li></ul> </li></ul> </li><li> <p>Redis</p> 
  <ul><li> <p>Spring的支持</p> 
    <ul><li> <p>配置</p> </li><li> <p>使用</p> 
      <ul><li> <p>opsForValue()</p> <p>操作只有简单属性的数据</p> </li><li> <p>opsForList()</p> <p>操作含有list的数据</p> </li><li> <p>opsForSet()</p> <p>操作含有set的数据</p> </li><li> <p>opsForZSet()</p> <p>操作含有ZSet(有序的set)的数据</p> </li><li> <p>opsForHash()</p> <p>操作含有hash的数据</p> </li></ul> </li><li> <p>定义Serializer</p> </li></ul> </li><li> <p>Spring Boot的支持</p> </li><li> <p>安装Redis</p> 
    <ul><li> <p>非Docker安装</p> </li><li> <p>Docker安装</p> <p>docker run -d -p 6379:6379 redis:2.8.21</p> </li></ul> </li></ul> </li></ul> 
<h3><a id="SpringBoot_1166"></a>SpringBoot企业级开发</h3> 
<h4><a id="SpringSecurity_1168"></a>安全控制SpringSecurity</h4> 
<ul><li> <p>SpringSecurity快速入门</p> 
  <ul><li> <p>什么是Spring Security</p> <p>Spring Security是专门针对基于Spring的项目的安全框架,充分利用了依赖注入和AOP来实现安全的功能.<br> 安全框架有两个重要的概念,即认证(Authentication)和授权(Authorization)<br> 认证即确认用户可以访问当前系统;<br> 授权即确定用户在当前系统下所拥有的功能权限</p> </li><li> <p>Spring Security的配置</p> 
    <ul><li> <p>DelegatingFilterProxy</p> </li><li> <p>配置</p> </li><li> <p>用户认证</p> 
      <ul><li>内存中的用户</li><li>JDBC中的用户</li><li>通用的用户</li><li>请求授权</li><li>定制登录行为</li></ul> </li></ul> </li></ul> </li><li> <p>SpringBoot的支持</p> 
  <ul><li>自动配置了一个内存中的用户</li><li>忽略/css/** /js/** /images/** /**/favicon.ico等静态文件的拦截</li><li>自动配置的securityFilterChainRegistration的Bean</li></ul> </li><li> <p>实例</p> </li></ul> 
<h4><a id="SpringBatch_1198"></a>批处理SpringBatch</h4> 
<ul><li> <p>SpringBatch快速入门</p> 
  <ul><li> <p>什么是Spring Batch</p> <p>Spring Batch是用来处理大量数据操作的一个框架,主要用来读取大量数据,然后进行一定处理后输出称指定的形式.</p> </li><li> <p>Spring Batch主要组成</p> 
    <ul><li> <p>JobRepository</p> <p>用来注册Job的容器</p> </li><li> <p>JobLauncher</p> <p>用来启动Job的接口</p> </li><li> <p>Job</p> <p>我们要实际执行的任务,包含一个或多个Step</p> </li><li> <p>Step</p> <p>Step步骤包含ItemReader,ItemProcessor,ItemWriter</p> </li><li> <p>ItemReader</p> <p>用来读取数据的接口</p> </li><li> <p>ItemProcessor</p> <p>用来处理数据的接口</p> </li><li> <p>ItemWriter</p> <p>用来输出数据的接口</p> </li></ul> </li><li> <p>Job监听</p> <p>implements JobExecutionListener</p> </li><li> <p>数据读取</p> </li><li> <p>数据处理及校验</p> 
    <ul><li>数据处理</li><li>数据校验</li></ul> </li><li> <p>数据输出</p> </li><li> <p>计划任务</p> </li><li> <p>参数后置绑定</p> </li></ul> </li><li> <p>SpringBoot的支持</p> </li><li> <p>实例</p> </li></ul> 
<h4><a id="_1244"></a>异步消息</h4> 
<p>异步消息主要目的是为了系统与系统之间的通信.<br> 所谓异步消息即消息发送者无须等待消息接收者的处理及返回,甚至无须关心消息是否发送成功.</p> 
<p>在异步消息中有两个很重要的概念,即消息代理(message broker) 和目的地(destination).<br> 当消息发送者发送消息后,消息将由消息代理接管,消息代理保证消息传递到指定的目的地.</p> 
<p>异步消息主要有两种形式的目的地:队列(queue)和主题(topic).队列用于点对点式(point-to-point)的消息通信; 主题用于发布/订阅式(publish/subscribe)的消息通信.</p> 
<ul><li> <p>企业级消息代理</p> <p>JMS(java Message Service)即Java消息服务,是基于JVM消息代理的规范.而ActiveMQ,HornetQ是一个JMS消息代理的实现.</p> <p>AMQP(Advanced Message Queuing Protocol)也是一个消息代理的规范,但它不仅兼容JMS,还支持跨语言和平台.AMQP的主要实现有RabbitMQ</p> </li><li> <p>Spring的支持</p> </li><li> <p>SpringBoot的支持</p> </li><li> <p>JMS实战</p> </li><li> <p>AMQP实战</p> </li></ul> 
<h4><a id="SpringIntegration_1264"></a>系统集成SpringIntegration</h4> 
<ul><li> <p>SpringIntegration快速入门</p> </li><li> <p>Message</p> </li><li> <p>Channel</p> 
  <ul><li> <p>顶级接口</p> 
    <ul><li> <p>MessageChannel</p> </li><li> <p>PollableChannel</p> <p>轮询</p> </li><li> <p>SubscribaleChannel</p> <p>订阅</p> </li></ul> </li><li> <p>常用消息通道</p> 
    <ul><li>PublishSubscribeChannel</li><li>QueueChannel</li><li>PriorityChannel</li><li>RendezvousChannel</li><li>DirectChannel</li><li>ExecutorChannel</li></ul> </li><li> <p>通道拦截器</p> </li></ul> </li><li> <p>MessageEndPoint</p> 
  <ul><li> <p>Channel Adapter</p> <p>通道适配器(Channel Adapter)是一种连接外部系统或者传输协议的端点(EndPoint),可以分为入站(inbound)和出站(outbound).</p> <p>通道适配器是单向的,入站通道适配器只支持接收消息,出站通道适配器只支持输出消息.</p> </li><li> <p>Gateway</p> <p>消息网关(Gateway) 类似与Adapter,但是提供了双向请求/返回集成方式,也分为入站(inbound)和出站(outbound).</p> </li><li> <p>Service Activeator</p> <p>Service Activator 可调用Spring的Bean 来处理消息,并将处理后的结果输出到指定的消息通道.</p> </li><li> <p>Router</p> <p>路由(Router)可根据消息体类型(Payload Type Router) 消息头的值(Header Value Router)以及定义好的接收表(Recipient List Router)作为条件,来决定消息传递到的通道.</p> </li><li> <p>Filter</p> <p>过滤器(Filter) 类似于路由(Router),不通的是过滤器不决定消息路由到哪里,而是决定消息是否可以传递给消息通道.</p> </li><li> <p>Splitter</p> <p>拆分起(Splitter)将消息拆分为几个部分单独处理,拆分器处理的返回值是一个集合或者数组.</p> </li><li> <p>Aggregator</p> <p>据和气(Aggregator)与拆分器相反,它接收一个java.util.List作为参数,将多个消息合并为一个消息.</p> </li><li> <p>Enricher</p> <p>当我们从外部获得消息后,需要增加额外的消息到已有的消息中,这时就需要使用消息增强器(Enricher).</p> <p>消息增强器主要有消息体增强器(Payload Enricher)和消息头增强器(Header Enricher)两种</p> </li><li> <p>Transformer</p> <p>转换器(Transformer)是对获得的消息进行一定的逻辑转换处理(如数据格式转换).</p> </li><li> <p>Bridge</p> <p>使用连接桥(Bridge)可以简单地将两个消息通道连接起来</p> </li></ul> </li><li> <p>Spring Integration Java DSL</p> </li><li> <p>实例</p> </li></ul> 
<h3><a id="SpringBoot_1329"></a>SpringBoot开发部署与测试</h3> 
<h4><a id="_1331"></a>开发的热部署</h4> 
<ul><li> <p>模板热部署</p> <p>在Spring Boot里,模板引擎的页面默认是开启缓存的,如果修改了页面的内容,则刷新页面是得不到修改后的页面的,因此我们可以在application.properties中关闭模板引擎的缓存.</p> 
  <ul><li> <p>Thymeleaf</p> <p>spring.thyeleaf.cache=false</p> </li><li> <p>FreeMarker</p> <p>spring.freemarker.cache=false</p> </li><li> <p>Groovy</p> <p>spring.groovy.cache=false</p> </li><li> <p>Velocity</p> <p>spring.velocity.cache=false</p> </li></ul> </li><li> <p>SpringLoaded</p> <p>Spring loaded 可实现修改类文件的热部署</p> </li><li> <p>JRebel</p> </li><li> <p>spring-boot-devtools</p> </li></ul> 
<h4><a id="_1354"></a>常规部署</h4> 
<ul><li> <p>jar形式</p> 
  <ul><li> <p>打包</p> <p>mvn package</p> </li><li> <p>运行</p> <p>java -jar xx.jar</p> </li><li> <p>注册为Linux的服务</p> </li></ul> </li><li> <p>war形式</p> 
  <ul><li> <p>打包方式为war时</p> <p>mvn package</p> </li><li> <p>打包方式为jar时</p> </li></ul> </li></ul> 
<h4><a id="Docker_1373"></a>云部署–基于Docker的部署</h4> 
<ul><li> <p>Dockerfile</p> 
  <ul><li> <p>FROM指令</p> <p>FROM指令指明了当前镜像继承的基镜像.<br> 编译当前镜像时会自动下载基镜像</p> <p>FROM ubuntu</p> </li><li> <p>MAINTAINER指令</p> <p>MAINTAINER指令指明了当前镜像的作者</p> <p>MAINTAINER name</p> </li><li> <p>RUN指令</p> <p>RUN指令可以在当前镜像上执行Linux命令并形成一个新的层.<br> RUN是编译时(build)的动作</p> <p>RUN /bin/bash -c “echo helloworld”<br> 或<br> RUN["/bin/bash","-c",“echo hello”]</p> </li><li> <p>CMD指令</p> <p>CMD指令指明了启动那个镜像容器时的默认行为.<br> 一个Dockerfile里只能有一个CMD指令.<br> CMD指令里设定的命令可以在运行镜像时使用参数覆盖.</p> <p>CMD echo “this is a test”<br> 可被 docker run -d image_name echo “this is not a test” 覆盖</p> </li><li> <p>EXPOSE指令</p> <p>EXPOSE 指明了镜像运行时的容器必须监听指定的端口.</p> <p>EXPOSE 8080</p> </li><li> <p>ENV指令</p> <p>ENV指令可用来设置环境变量</p> <p>ENV myName=name<br> 或 ENV myname name</p> </li><li> <p>ADD指令</p> <p>ADD指令是从当前工作目录复制文件到镜像目录中去</p> <p>ADD test.txt /mydir/</p> </li><li> <p>ENTRYPOINT指令</p> <p>ENTRYPOINT指令可让容器像一个可执行程序一样运行,这样镜像运行时可以像软件一样接口参数执行.</p> <p>ENTRYPOINT ["/bin/echo"]</p> <p>我们可以向镜像传递参数运行<br> docker run -d image_name “this is not a test”</p> </li></ul> </li><li> <p>安装Docker</p> <p>安装Docker<br> yum install docker</p> <p>启动Docker 并保持开机启动<br> systemctl start docker<br> systemctl enable docker</p> </li><li> <p>项目目录及文件</p> </li><li> <p>编译镜像</p> <p>docker build -t wisely/ch10docker .</p> <p>wisely/ch10docker 为镜像名称,我们设置wisely作为前缀,这也是Docker镜像的一种命名习惯.</p> <p>注意,最后还有一个".",这是用来指明Dockerfile路径的,"."表示Dockerfile在当前路径下</p> </li><li> <p>运行</p> <p>docker run -d --name ch10 -p 8080:8080 wisely/ch10docker</p> </li></ul> 
<h4><a id="SpringBoot_1447"></a>SpringBoot的测试</h4> 
<p>Spring Boot为我们提供了一个@SpringApplicationConfiguration来替代@ContextConfiguration,用来配置 Application Context.</p> 
<ul><li>新建SpringBoot项目</li><li>业务代码</li><li>测试用例</li><li>执行测试</li></ul> 
<h3><a id="_1455"></a>应用监控</h3> 
<p>Spring Boot 提供了运行时的应用监控和管理的功能.<br> 我们可以通过http JMX SSH协议来进行操作.</p> 
<p>*actuator 所有EndPoint的列表,需加入spring HATEOAS支持</p> 
<ul><li>autoconfig 当前应用的所有自动配置</li><li>beans 当前应用中所有Bean的信息</li><li>configprops 当前应用中所有的配置属性</li><li>dump 显示当前应用线程状态信息</li><li>env 显示当前应用当前环境信息</li><li>health 显示当前应用健康状况</li><li>info 显示当前应用信息</li><li>metrics 显示当前应用的各项指标信息</li><li>mappings 显示所有的@RequestMapping映射的路径</li><li>shutdown 关闭当前应用(默认关闭)</li><li>trace 显示追踪信息(默认最新的http请求)</li></ul> 
<h4><a id="http_1472"></a>http</h4> 
<ul><li> <p>新建SpringBoot项目</p> <p>依赖<br> web<br> actuator<br> HATEOAS</p> </li><li> <p>测试端点</p> 
  <ul><li> <p>actuator</p> </li><li> <p>autoconfig</p> </li><li> <p>beans</p> </li><li> <p>dump</p> </li><li> <p>configprops</p> </li><li> <p>health</p> </li><li> <p>info</p> </li><li> <p>metrics</p> </li><li> <p>mappings</p> </li><li> <p>shutdown</p> <p>shutdown端点默认是关闭的,我们可以在application.properties中开启:<br> endpoints.shutdown.enabled=true</p> <p>shutdown端点不支持GET提交,不可以直接在浏览器上访问地址,所以我们使用PostMan来测试</p> </li><li> <p>trace</p> </li></ul> </li><li> <p>定制端点</p> 
  <ul><li> <p>修改端点id</p> <p>endpoints.beans.id=mybeans</p> </li><li> <p>开启端点</p> <p>endpoints.shutdown.enabled=true</p> </li><li> <p>关闭端点</p> <p>endpoints.beans.enabled=false</p> </li><li> <p>只开启所需端点</p> <p>若只开启所需端点的话,我们可以通过关闭所有的端点,然后再开启所需端点来实现.</p> <p>endpoints.enabled=false<br> endpoints.beans.enabled=true</p> </li><li> <p>定制端点访问路径</p> <p>默认的端点访问路径是在根目录下的<br> http://localhost:8080/beans</p> <p>management.context-path=/manage<br> http://localhost:8080/manage/beans</p> </li><li> <p>定制端点访问端口</p> <p>当我们基于安全的考虑,不暴露端点的端口到外部时,就需要应用本身的业务端口和端点锁用的端口使用不通的端口.</p> <p>我们可以通过如下配置改变端点访问的端口<br> management.port=8081</p> </li><li> <p>关闭http端点</p> <p>management.port=-1</p> </li></ul> </li><li> <p>自定义端点</p> 
  <ul><li>状态服务</li><li>自定义端点</li><li>注册端点并定义演示控制器</li></ul> </li><li> <p>自定义HealthIndicatior</p> </li></ul> 
<h4><a id="JMX_1540"></a>JMX</h4> 
<h4><a id="SSH_1542"></a>SSH</h4> 
<ul><li>新建SpringBoot项目</li><li>运行</li><li>常用命令</li><li>定制登录用户</li><li>扩展命令</li></ul> 
<h3><a id="_1550"></a>分布式系统开发</h3> 
<h4><a id="_1552"></a>微服务/原生云应用</h4> 
<p>微服务(Microservice)是近两年来非常火的概念,它的含义是:使用定义好边界的小的独立组建来做好一件事情.<br> 微服务是相对于传统单块式架构而言的.</p> 
<p>单块架构是一份代码,部署和伸缩都是基于单个单元进行的.<br> 优点:易于部署<br> 缺点:可用性低,可伸缩性差,集中发布的声明周期,违反单一功能原则</p> 
<h4><a id="SpringCloud_1560"></a>SpringCloud快速入门</h4> 
<ul><li>配置服务</li><li>服务发现</li><li>路由网关</li><li>负载均衡</li><li>断路由</li></ul> 
<h4><a id="_1568"></a>实战</h4> 
<ul><li>项目构建</li><li>服务发现Discovery(Eureka Server)</li><li>配置Config(ConfigServer)</li><li>服务模块Person服务</li><li>服务模块Some服务</li><li>界面模块UI(Ribbon,Feign)</li><li>断路器监控Monitor(DashBoard)</li><li>运行</li></ul> 
<h4><a id="Docker_1579"></a>基于Docker部署</h4> 
<ul><li> <p>Dockerfile编写</p> 
  <ul><li> <p>runboot.sh脚本的编写</p> <p>位于src/main/docker</p> <p>sleep 10</p> <p>java -Djava.security.egd=file:/dev/./urandom -jar /app/app.jar</p> </li><li> <p>Dockerfile编写</p> <p>位于src/main/docker</p> <p>FROM java:8<br> VOLUME /tmp<br> RUN mkdir /app<br> ADD config-1.0.0-SNAPSHOT.jar /app/app.jar<br> ADD runboot.sh /app/<br> RUN bash -c ‘touch /app/app.jar’<br> WORKDIR /app<br> RUN chmod a+x runboot.sh<br> EXPOSE 8888<br> CMD /app/runboot.sh</p> <p>为不同的微服务我们只需要修改<br> ADD config-1.0.0-SNAPSHOT.jar /app/app.jar<br> 以及端口<br> EXPOSE 8888</p> </li><li> <p>Docker的Mean插件</p> </li><li> <p>编译镜像</p> </li></ul> </li><li> <p>DockerCompose</p> </li><li> <p>Docker-compose.yml编写</p> </li><li> <p>运行</p> </li></ul> 
<h3><a id="_1616"></a>附录</h3> 
<h4><a id="JHipster_1618"></a>基于JHipster的代码生成</h4> 
<h4><a id="_1620"></a>常用应用属性配置列表</h4>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e562a9f6329a0ae99b20ce238712fdd1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于MongoDb的事件订阅实现hook监听</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1f81da986bfd8397c936e76186884110/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java内置工具类</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>