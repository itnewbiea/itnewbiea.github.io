<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>flask多进程多线程配置 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="flask多进程多线程配置" />
<meta property="og:description" content="flask.Flask.run接受**options转发给它的其他关键字参数（）werkzeug.serving.run_simple-其中两个参数是threaded（布尔值）和processes（您可以将其设置为大于1的数字以使werkzeug产生多个进程来处理请求）。
threaded默认True版本自Flask 1.0起，因此对于最新版本的Flask，默认情况下默认开发服务器将能够同时为多个客户端提供服务。对于较旧版本的Flask，您可以显式传递threaded=True以启用此行为。
例如，您可以
if name == ‘main’:
app.run(threaded=True)
以与旧Flask版本兼容的方式使用线程处理多个客户端，或者
if name == ‘main’:
app.run(threaded=False, processes=3)
告诉Werkzeug生成三个进程来处理传入的请求，或者只是
if name == ‘main’:
app.run()
如果您知道将使用Flask 1.0或更高版本，则可以使用线程来处理多个客户端。
话虽如此，Werkzeug的serving.run_simple包装了标准库的wsgiref软件包-该软件包包含WSGI的参考实现，而不是可用于生产的Web服务器。如果您要在生产环境中使用Flask（假设“生产环境”不是低流量的内部应用程序，并发用户不超过10个），请确保将其支撑在真实的Web服务器后面（请参阅Flask文档标题为“ 一些建议方法的部署选项）。
0x02 Flask开启自带的多线程或多进程 开启多线程： app.run(debug=debug, host=&#39;0.0.0.0&#39;, port=8082, threaded=True) 1 app.run(debug=debug, host=&#39;0.0.0.0&#39;, port=8082, threaded=True) 开启多进程 app.run(debug=debug, host=&#39;0.0.0.0&#39;, port=8082, processes=10) 1 app.run(debug=debug, host=&#39;0.0.0.0&#39;, port=8082, processes=10) 需要注意的是，多进程和多线程不可以同时开启，且需要关闭debug。下面再来看下请求结果 [Process 91295] [Thread 123145513381888] 2020-09-29 14:29:01 _internal.py _log[line:122] [Process 91295] [Thread 123145509175296] 2020-09-29 14:29:01 _internal.py _log[line:122] 1 2 [Process 91295] [Thread 123145513381888] 2020-09-29 14:29:01 _internal." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e8ab747f8dd18ee2865774bcc99f42f9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-13T17:45:50+08:00" />
<meta property="article:modified_time" content="2021-10-13T17:45:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">flask多进程多线程配置</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>flask.Flask.run接受**options转发给它的其他关键字参数（）werkzeug.serving.run_simple-其中两个参数是threaded（布尔值）和processes（您可以将其设置为大于1的数字以使werkzeug产生多个进程来处理请求）。</p> 
<p>threaded默认True版本自Flask 1.0起，因此对于最新版本的Flask，默认情况下默认开发服务器将能够同时为多个客户端提供服务。对于较旧版本的Flask，您可以显式传递threaded=True以启用此行为。</p> 
<p>例如，您可以</p> 
<p>if <strong>name</strong> == ‘<strong>main</strong>’:<br> app.run(threaded=True)<br> 以与旧Flask版本兼容的方式使用线程处理多个客户端，或者</p> 
<p>if <strong>name</strong> == ‘<strong>main</strong>’:<br> app.run(threaded=False, processes=3)<br> 告诉Werkzeug生成三个进程来处理传入的请求，或者只是</p> 
<p>if <strong>name</strong> == ‘<strong>main</strong>’:<br> app.run()<br> 如果您知道将使用Flask 1.0或更高版本，则可以使用线程来处理多个客户端。</p> 
<p>话虽如此，Werkzeug的serving.run_simple包装了标准库的wsgiref软件包-该软件包包含WSGI的参考实现，而不是可用于生产的Web服务器。如果您要在生产环境中使用Flask（假设“生产环境”不是低流量的内部应用程序，并发用户不超过10个），请确保将其支撑在真实的Web服务器后面（请参阅Flask文档标题为“ 一些建议方法的部署选项）。</p> 
<pre><code class="prism language-csharp"><span class="token number">0x02</span> Flask开启自带的多线程或多进程
开启多线程：

app<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>debug<span class="token operator">=</span>debug<span class="token punctuation">,</span> host<span class="token operator">=</span>'<span class="token number">0.0</span><span class="token number">.0</span><span class="token number">.0</span>'<span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">8082</span><span class="token punctuation">,</span> threaded<span class="token operator">=</span>True<span class="token punctuation">)</span>
<span class="token number">1</span>
app<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>debug<span class="token operator">=</span>debug<span class="token punctuation">,</span> host<span class="token operator">=</span>'<span class="token number">0.0</span><span class="token number">.0</span><span class="token number">.0</span>'<span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">8082</span><span class="token punctuation">,</span> threaded<span class="token operator">=</span>True<span class="token punctuation">)</span>
开启多进程

app<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>debug<span class="token operator">=</span>debug<span class="token punctuation">,</span> host<span class="token operator">=</span>'<span class="token number">0.0</span><span class="token number">.0</span><span class="token number">.0</span>'<span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">8082</span><span class="token punctuation">,</span> processes<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token number">1</span>
app<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>debug<span class="token operator">=</span>debug<span class="token punctuation">,</span> host<span class="token operator">=</span>'<span class="token number">0.0</span><span class="token number">.0</span><span class="token number">.0</span>'<span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">8082</span><span class="token punctuation">,</span> processes<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>
需要注意的是，多进程和多线程不可以同时开启，且需要关闭debug。下面再来看下请求结果

<span class="token punctuation">[</span>Process <span class="token number">91295</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>Thread <span class="token number">123145513381888</span><span class="token punctuation">]</span> <span class="token number">2020</span><span class="token operator">-</span><span class="token number">09</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">14</span><span class="token punctuation">:</span><span class="token number">29</span><span class="token punctuation">:</span><span class="token number">01</span> _internal<span class="token punctuation">.</span>py _log<span class="token punctuation">[</span>line<span class="token punctuation">:</span><span class="token number">122</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span>Process <span class="token number">91295</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>Thread <span class="token number">123145509175296</span><span class="token punctuation">]</span> <span class="token number">2020</span><span class="token operator">-</span><span class="token number">09</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">14</span><span class="token punctuation">:</span><span class="token number">29</span><span class="token punctuation">:</span><span class="token number">01</span> _internal<span class="token punctuation">.</span>py _log<span class="token punctuation">[</span>line<span class="token punctuation">:</span><span class="token number">122</span><span class="token punctuation">]</span>
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token punctuation">[</span>Process <span class="token number">91295</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>Thread <span class="token number">123145513381888</span><span class="token punctuation">]</span> <span class="token number">2020</span><span class="token operator">-</span><span class="token number">09</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">14</span><span class="token punctuation">:</span><span class="token number">29</span><span class="token punctuation">:</span><span class="token number">01</span> _internal<span class="token punctuation">.</span>py _log<span class="token punctuation">[</span>line<span class="token punctuation">:</span><span class="token number">122</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span>Process <span class="token number">91295</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>Thread <span class="token number">123145509175296</span><span class="token punctuation">]</span> <span class="token number">2020</span><span class="token operator">-</span><span class="token number">09</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">14</span><span class="token punctuation">:</span><span class="token number">29</span><span class="token punctuation">:</span><span class="token number">01</span> _internal<span class="token punctuation">.</span>py _log<span class="token punctuation">[</span>line<span class="token punctuation">:</span><span class="token number">122</span><span class="token punctuation">]</span>
可以看到，已经可以并发处理了。

关于多进程方式，processes参数是指定进程数量，当并发度大于请求数量的时候仍然会阻塞。

<span class="token number">0x03</span> 使用gunicorn多进程启动Flask
安装gunicorn

pip install gunicorn
<span class="token number">1</span>
pip install gunicorn
安装完成后可以使用下面的命令来启动

gunicorn 入口文件名<span class="token punctuation">:</span>app
<span class="token number">1</span>
gunicorn 入口文件名<span class="token punctuation">:</span>app
这里的app是<span class="token function">Flask</span><span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>返回值得接收变量

gunicorn支持配置文件启动，如下例子：

<span class="token preprocessor property"># gunicorn.conf</span>

bind <span class="token operator">=</span> <span class="token string">"0.0.0.0:5000"</span>
workers <span class="token operator">=</span> <span class="token number">4</span>
backlog <span class="token operator">=</span> <span class="token number">2048</span>
pidfile <span class="token operator">=</span> <span class="token string">"log/gunicorn.pid"</span>
accesslog <span class="token operator">=</span> <span class="token string">"log/access.log"</span>
errorlog <span class="token operator">=</span> <span class="token string">"log/debug.log"</span>
timeout <span class="token operator">=</span> <span class="token number">600</span>
debug<span class="token operator">=</span><span class="token class-name">False</span>
capture_output <span class="token operator">=</span> True

<span class="token preprocessor property"># gunicorn.conf</span>
 
bind <span class="token operator">=</span> <span class="token string">"0.0.0.0:5000"</span>
workers <span class="token operator">=</span> <span class="token number">4</span>
backlog <span class="token operator">=</span> <span class="token number">2048</span>
pidfile <span class="token operator">=</span> <span class="token string">"log/gunicorn.pid"</span>
accesslog <span class="token operator">=</span> <span class="token string">"log/access.log"</span>
errorlog <span class="token operator">=</span> <span class="token string">"log/debug.log"</span>
timeout <span class="token operator">=</span> <span class="token number">600</span>
debug<span class="token operator">=</span><span class="token class-name">False</span>
capture_output <span class="token operator">=</span> True
启动命令

gunicorn <span class="token operator">--</span>config <span class="token class-name">gunicorn<span class="token punctuation">.</span>conf</span> main<span class="token punctuation">:</span>app
<span class="token number">1</span>
gunicorn <span class="token operator">--</span>config <span class="token class-name">gunicorn<span class="token punctuation">.</span>conf</span> main<span class="token punctuation">:</span>app
 
</code></pre> 
<pre><code class="prism language-csharp">前言：
使用flask做服务时，可以使用python run<span class="token punctuation">.</span>py的方式运行，但是这样不能用于生产环境，可能会出现连接无响应的情况。后来通过查找资料，发现flask服务处理多线程、高并发的一下方法，主要有一下几个方面：

<span class="token number">1</span><span class="token punctuation">.</span>通过设置app<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>的参数，来达到多线程的效果，具体参数：

<span class="token preprocessor property"># 1.threaded : 多线程支持，默认为False，即不开启多线程;</span>
app<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>threaded<span class="token operator">=</span>True<span class="token punctuation">)</span>
<span class="token preprocessor property"># 2.processes：进程数量，默认为1.</span>
app<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>processes<span class="token operator">=</span>True<span class="token punctuation">)</span>
ps：多进程或多线程只能选择一个，不能同时开启
<span class="token number">2</span><span class="token punctuation">.</span>使用genvent做协程，解决高并发：

<span class="token keyword">from</span> genvent<span class="token punctuation">.</span>wsgi import  WSGIServer
<span class="token keyword">from</span> genvent import <span class="token return-type class-name">monkey</span>

monkey<span class="token punctuation">.</span><span class="token function">patch_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
app <span class="token operator">=</span> <span class="token function">Flask</span><span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>
app<span class="token punctuation">.</span>config<span class="token punctuation">.</span><span class="token function">from_object</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span>
api <span class="token operator">=</span> <span class="token function">Api</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span>

db <span class="token operator">=</span> <span class="token function">DBInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token preprocessor property"># db_old = DBInfo_old()</span>
然后通过这种方式包装<span class="token function">WSGIServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span>port<span class="token punctuation">)</span><span class="token punctuation">,</span> app<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">serve_forever</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
通过python code<span class="token punctuation">.</span>py 的方法，来启动服务

<span class="token number">3</span><span class="token punctuation">.</span>通过<span class="token function">Guicorn</span><span class="token punctuation">(</span><span class="token class-name">with</span> genvent<span class="token punctuation">)</span>的形式来对app进行包装，来启动服务；
通过一下代码，来启动项目

<span class="token preprocessor property"># 启动命令</span>
gunicorn <span class="token operator">-</span>c <span class="token class-name">gun<span class="token punctuation">.</span>py</span> thread_explore<span class="token punctuation">:</span>app
其中gun<span class="token punctuation">.</span>py是gunicorn的配置文件
thread_explore是服务的主程序
app是flask的app
gun<span class="token punctuation">.</span>py的具体内容：


import os 
import <span class="token return-type class-name">gevent<span class="token punctuation">.</span>monkey</span>
gevent<span class="token punctuation">.</span>monkey<span class="token punctuation">.</span><span class="token function">patch_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
import multiprocessing

<span class="token preprocessor property"># 服务地址（adderes:port） </span>
bind <span class="token operator">=</span> <span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">;</span><span class="token number">5000</span> 
<span class="token preprocessor property"># 启动进程数量</span>
workers <span class="token operator">=</span> multiprocessing<span class="token punctuation">.</span><span class="token function">cpu_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span><span class="token number">1</span>
worker_class <span class="token operator">=</span> 'gevent'
threads <span class="token operator">=</span> <span class="token number">20</span>
preload_app <span class="token operator">=</span> <span class="token class-name">True</span>
reload <span class="token operator">=</span> <span class="token class-name">True</span>
x_forwarded_for_header <span class="token operator">=</span> 'X_FORWARDED<span class="token operator">-</span>FOR'
ps：这里启动进程数量应该是根据CPU个数来确定的，最好是<span class="token number">2</span> <span class="token operator">*</span> CPU数 <span class="token operator">+</span> <span class="token number">1</span>
参考资料：
https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>jianshu<span class="token punctuation">.</span>com<span class="token operator">/</span>p<span class="token operator">/</span><span class="token class-name">a90775e33b52</span>
https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>cnblogs<span class="token punctuation">.</span>com<span class="token operator">/</span>lesliexong<span class="token operator">/</span>p<span class="token operator">/</span><span class="token number">9396850</span><span class="token punctuation">.</span>html

</code></pre> 
<p>对于一个网站而言，必须要有一定的承受并发的能力，request只是一个变量名，真正的实例对象是Request（）。同一时刻会有多个请求，而每一个请求的请求信息极有可能是不同的。这就会造成我们实际发送过来的请求信息是不相同的。那么用一个变量request怎么代表不同用户的请求信息呢？</p> 
<p><img src="https://images2.imgbox.com/8f/ea/BaawGsmJ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/9e/84/N2rHEEEZ_o.png" alt="在这里插入图片描述"><br> 由于单线程是顺序执行的，只有处理完一个请求才能处理另一个请求，对于单线程来说，请求就像排队一样，请求进来之后，flask会实例化一个Request对象，然后用request来装载我们的请求信息，这个时候我们只有一个实例化的Request，所以啊，用request变量名是可以拿到我们要的请求信息的，所以request变量名总是会指向当前的请求，request就不会出现混乱。</p> 
<p>多线程的请求，（对象是保存状态的地方）</p> 
<p>但是我们并不知道到底有多少个请求会发生，那么有没有一种用一个变量来表示的所有的请求信息呢，有，字典</p> 
<p>image.png<br> 线程里有什么可以唯一确定一个线程呢，那就是线程的id号，可以作为key，在flask中就是采用的这种原理来解决的，这种用不同id号作为键，其实就是线程隔离，线程隔离只是一种思想，并不一定都是用字典实现，还可以用其他的方式实现。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/516061d6b8b439e454e9f1e17fa53394/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Tensorflow是干什么的？Tensorflow的基础入门</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/49fe0a1bf50fd284512da0e04c114948/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">论文浅尝 | 异构图 Transformer</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>