<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c语言结构体学习整理(结构体初始化，结构体指针) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c语言结构体学习整理(结构体初始化，结构体指针)" />
<meta property="og:description" content="点击蓝字
关注我们
因公众号更改推送规则，请点“在看”并加“星标”第一时间获取精彩技术分享 来源于网络，侵删
1.关于c语言的结构体:
首先我们为什么要用到结构体，我们都已经学了很多int char …等类型还学到了同类型元素构成的数组，以及取上述类型的指针，在一些小应用可以灵活使用，然而，在我们实际应用中，每一种变量进行一次声明，再结合起来显然是不太实际的，类如一位学生的信息管理，他可能有，姓名（char），学号（int）成绩（float）等多种数据。如果把这些数据分别单独定义，就会特别松散、复杂，难以规划，因此我们需要把一些相关的变量组合起来，以一个整体形式对对象进行描述，这就是结构体的好处。
2、首先我们要了解一些小知识
2.1**只有结构体变量才分配地址，而结构体的定义是不分配空间的。**
2.2结构体中各成员的定义和之前的变量定义一样，但在定义时也不分配空间。
2.3结构体变量的声明需要在主函数之上或者主函数中声明，如果在主函数之下则会报错
2.4c语言中的结构体不能直接进行强制转换，只有结构体指针才能进行强制转换
2.5相同类型的成员是可以定义在同一类型下的
列如
struct Student
{ int number,age；//int型学号和年龄
char name[20],sex;//char类型姓名和性别
float score;
}；
最后的分号不要忘了 有的编译器会自动加上，因此有的同学就会不注意。
3、关于结构体变量的定义和引用
在编译时，结构体的定义并不分配存储空间，对结构体变量才按其数据结构分配相应的存储空间
struct Book
{ char title[20];//一个字符串表
示的titile 题目
char author[20];//一个字符串表示的author作者
float value;//价格表示 };//这里只是声明 结构体的定义 struct Book book1,book2;//结构体变量的定义 分配空间
book1.value;//引用结构体变量
定义结构体变量以后，系统就会为其分配内存单元，比如book1和book2在内存中占44个字节（20&#43;20&#43;4）具体的长度你可以在你的编译器中使用sizeof关键字分别求出来。
列如
当然，要注意一点：用sizeof关键字求结构体长度时，返回的最大基本类型所占字节的整数倍 比方说我们上面求得的为44 为 float(4个字节)的整数倍，
但是我们把title修改为title[22]; 这时正常长度为46 ，但是你会发现实际求得的为48，(4的整数倍)
这就涉及到结构体的存储：
1结构体整体空间是占用空间最大的成员（的类型）所占字节数的整数倍。
2.结构体的每个成员相对结构体首地址的偏移量(offset)都是最大基本类型成员字节大小的整数倍，如果不是编译器会自动补齐，
关于这个我们简单介绍下：
1.偏移量----偏移量指的是结构体变量中成员的地址和结构体变量首地址的差。即偏移字节数，结构体大小等于最后一个成员的偏移量加上他的大小，第一个成员的偏移量为0，
struct S1
{
char a;
int b;
double c;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/bdf3d0422d204aa3327c66bec72c69b5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-03T18:01:32+08:00" />
<meta property="article:modified_time" content="2023-04-03T18:01:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c语言结构体学习整理(结构体初始化，结构体指针)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p>点击蓝字</p> 
 <p><img src="https://images2.imgbox.com/00/71/ZjdpOY93_o.png" alt="d1da9cb83bf74b5bff98bb27b6b5d2b7.png"></p> 
 <p>关注我们<strong></strong></p> 
 <h2><strong>因公众号更改推送规则，请点“在看”并加“星标”第一时间获取精彩技术分享</strong></h2> 
 <p style="text-align:right;">来源于网络，侵删</p> 
 <p><strong>1.关于c语言的结构体:</strong></p> 
 <p>首先我们为什么要用到结构体，我们都已经学了很多int char …等类型还学到了同类型元素构成的数组，以及取上述类型的指针，在一些小应用可以灵活使用，然而，在我们实际应用中，每一种变量进行一次声明，再结合起来显然是不太实际的，类如一位学生的信息管理，他可能有，姓名（char），学号（int）成绩（float）等多种数据。如果把这些数据分别单独定义，就会特别松散、复杂，难以规划，因此我们需要把一些相关的变量组合起来，以一个整体形式对对象进行描述，这就是结构体的好处。</p> 
 <p><strong>2、首先我们要了解一些小知识</strong></p> 
 <p>2.1**只有结构体变量才分配地址，而结构体的定义是不分配空间的。**</p> 
 <p>2.2结构体中各成员的定义和之前的变量定义一样，但在定义时也不分配空间。</p> 
 <p>2.3结构体变量的声明需要在主函数之上或者主函数中声明，如果在主函数之下则会报错</p> 
 <p>2.4c语言中的结构体不能直接进行强制转换，只有结构体指针才能进行强制转换</p> 
 <p>2.5相同类型的成员是可以定义在同一类型下的</p> 
 <p>列如</p> 
 <p>struct Student</p> 
 <p>{ </p> 
 <p>int number,age；//int型学号和年龄</p> 
 <p>char name[20],sex;//char类型姓名和性别</p> 
 <p>float score;</p> 
 <p>}；</p> 
 <p>最后的分号不要忘了 有的编译器会自动加上，因此有的同学就会不注意。</p> 
 <p><strong>3、关于结构体变量的定义和引用</strong></p> 
 <p>在编译时，结构体的定义并不分配存储空间，对结构体变量才按其数据结构分配相应的存储空间</p> 
 <p> struct Book</p> 
 <p> { </p> 
 <p> char title[20];//一个字符串表</p> 
 <p>示的titile 题目</p> 
 <p>char author[20];//一个字符串表示的author作者</p> 
 <p> float value;//价格表示 </p> 
 <p> };//这里只是声明 结构体的定义 </p> 
 <p>struct Book book1,book2;//结构体变量的定义 分配空间</p> 
 <p>book1.value;//引用结构体变量</p> 
 <p>定义结构体变量以后，系统就会为其分配内存单元，比如book1和book2在内存中占44个字节（20+20+4）具体的长度你可以在你的编译器中使用sizeof关键字分别求出来。</p> 
 <p>列如</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/a3/2a/R8S1AxC3_o.png" alt="45539ce93ef8dc88ecaa8300aa984f28.png"></p> 
 <p>当然，要注意一点：用sizeof关键字求结构体长度时，返回的最大基本类型所占字节的整数倍 比方说我们上面求得的为44 为 float(4个字节)的整数倍，</p> 
 <p>但是我们把title修改为title[22]; 这时正常长度为46 ，但是你会发现实际求得的为48，(4的整数倍)</p> 
 <p>这就涉及到结构体的存储：</p> 
 <p>1结构体整体空间是占用空间最大的成员（的类型）所占字节数的整数倍。</p> 
 <p>2.结构体的每个成员相对结构体首地址的偏移量(offset)都是最大基本类型成员字节大小的整数倍，如果不是编译器会自动补齐，</p> 
 <p>关于这个我们简单介绍下：</p> 
 <p>1.偏移量----偏移量指的是结构体变量中成员的地址和结构体变量首地址的差。即偏移字节数，结构体大小等于最后一个成员的偏移量加上他的大小，第一个成员的偏移量为0，</p> 
 <p>struct S1</p> 
 <p>{<!-- --></p> 
 <p>    char a;</p> 
 <p>    int b;</p> 
 <p>    double c;</p> 
 <p>};</p> 
 <p>这里char a 偏移量为1 之后为int b 因为偏移量1不为int(4)的整数倍，所以会自动补齐，而在 double c 时，偏移量为8 是double(8)的整数倍，所以不用自动补齐 最后求得结构体得大小为 16</p> 
 <p>具体看下图：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/dc/a1/ie8dHtgP_o.png" alt="3f67089438030b0f54f4fda7b1fdf0d0.png"></p> 
 <p>通过上面的代码同学们应该会有一个简单的认知</p> 
 <p><strong>4、结构体变量的初始化</strong></p> 
 <p>结构体的初始化有很多需要注意的地方，这里我们说明下</p> 
 <p>首先是几种初始化的方法</p> 
 <p>ps：在对结构体变量初始化时，要对结构体成员一一赋值，不能跳过前面成员变量，而直接给后面成员赋初值，但是可以只赋值前面几个，对与后面未赋值的变量，如果是数值型，则会自动赋值为0,对于字符型，会自动赋初值为NULL，即‘\0’</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/38/b1/c3kStMpQ_o.png" alt="87dc2ce626653a54a6c32f4de30e99b4.png"></p> 
 <p>4.1定义时直接赋值</p> 
 <p>struct Student</p> 
 <p>{ </p> 
 <p>char name[20];</p> 
 <p>char sex;</p> 
 <p>int number;</p> 
 <p>}stu1={"zhaozixuan",'M',12345};</p> 
 <p>//或者</p> 
 <p>struct Student</p> 
 <p>{ </p> 
 <p>char name[20];</p> 
 <p>char sex;</p> 
 <p>int number;</p> 
 <p>}；</p> 
 <p>struct Student stu1={"zhaozixuan",'M',12345};</p> 
 <p>注意字符为‘ ’ 字符串为""</p> 
 <p>4.2定义结构体之后逐个赋值</p> 
 <p>stu1.name="王伟"；</p> 
 <p>stu1.sex='M';</p> 
 <p>stu1.number=12305;</p> 
 <p>//也可用strcpy函数进行赋值</p> 
 <p>strcpy(stu1.name,"王伟");</p> 
 <p>4.3定义之后任意赋值</p> 
 <p> struct Student stu1={<!-- --></p> 
 <p>  .name="Wang",</p> 
 <p>  .number=12345,</p> 
 <p>  .sex='W', </p> 
 <p> };//可以对任意变量赋值</p> 
 <p>这样写的好处时不用按照顺序来进行初始化，而且可以对你想要赋值的变量直接进行赋值，而不想赋值的变量可以不用赋值</p> 
 <p>需要注意的是如果在定义结构体变量的时候没有初始化，那么后面就不能全部一起初始化了；</p> 
 <p>等下结构体数组初始化时我们还会有一个讲解</p> 
 <p>这里我们顺带提一下typedef说明结构体类型</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/8f/cf/ElgnvDmD_o.png" alt="57e85d29c3de6ff90bfa9db8f2ffba17.png"></p> 
 <p>这里的BOOK就相当于struct book的一个别名一样，用它来定义结构体变量非常简便</p> 
 <p>主要也是考二级要用到，所以我们简单介绍下</p> 
 <p><strong>5、结构体变量的引用（输出和输入）</strong></p> 
 <p>5.1结构体变量的赋值用scanf赋值和printf输出时跟其他变量操作一样</p> 
 <p>但是有几点需要注意</p> 
 <p>(1) .是运算符，在所有运算符优先级中最高</p> 
 <p>(2)如果结构体的成员本身是一个结构体，则需要继续用.运算符，直到最低一级的成员。</p> 
 <p>struct Student</p> 
 <p>{ char name[20];</p> 
 <p>char sex;</p> 
 <p>int number;</p> 
 <p>struct Date</p> 
 <p>{<!-- --></p> 
 <p>int year;</p> 
 <p>  int month;</p> 
 <p>  int day;</p> 
 <p>}birthday;</p> 
 <p>}stu1;</p> 
 <p>printf("%d",stu1.birthday);//这样子是错误的，因为birthday也是一个结构体变量</p> 
 <p>scanf("%d",&amp;stu1.birthday.month);//正确</p> 
 <p>(3)可以引用接头体变量成员的地址，也可以引用结构体变量的地址：</p> 
 <p>printf("%o", student);(输出student的首地址)(%o 按八进制输出)</p> 
 <p><strong>6、结构体数组及其初始化(重点)</strong></p> 
 <p>这里我们简单说下，具有相同类型的结构体变量组成数组就是结构体数组</p> 
 <p>结构体数组与结构体变量区别只是将结构体变量替换为数组</p> 
 <p>struct Student</p> 
 <p>{ </p> 
 <p>char name[20];</p> 
 <p>char sex;</p> 
 <p>int number;</p> 
 <p>}stu1[5]={<!-- --></p> 
 <p>{"zhaozixuan",'M',12345},</p> 
 <p>{"houxiaohong",'M',12306},</p> 
 <p>{"qxiaoxin",'W',12546},</p> 
 <p>{"wangwei",'M',14679},</p> 
 <p>{"yulongjiao",'W',17857}</p> 
 <p>};</p> 
 <p>stu1[3].name[3]//表示stu1的第三个结构变量中姓名的第五个字符</p> 
 <p>//若初始化时已经是结构体数组全部元素[]中的数可以不写如stu1[]=</p> 
 <p>注意结构体数组要在定义时就直接初始化，如果先定义再赋初值是错误的</p> 
 <p>比如：</p> 
 <p>struct Student stu1；</p> 
 <p>stu1[3]={<!-- --></p> 
 <p>  {"zhaozixuan",'M',12345},</p> 
 <p>  {"houxiaohong",'M',12306},</p> 
 <p>  {"qxiaoxin",'W',12546}</p> 
 <p>  };</p> 
 <p>这样子是错误的，</p> 
 <p>这里我在写的时候遇到一些问题，还是结构体数组初始化的问题，折腾了下解决了，给大家分享下</p> 
 <p>对于数组初始化时</p> 
 <p>比如</p> 
 <p>char str[20];</p> 
 <p>str="I love you";/* 这样会修改数组的地址，但是数组的地址分配之后是不允许改变的 */</p> 
 <p>在第一条语句中 str就已经被定义成数组而在C99标准中不允许将字符串(实际上是一个指针变量) 赋值给数组，所以如果我们直接赋值是错误的</p> 
 <p>那么怎么弄呢</p> 
 <p>这里提供3种方法</p> 
 <p>1.定义数组时直接定义</p> 
 <p>char str[20]=“I love you”;</p> 
 <p>2.用strcpy或者memset函数进行复制</p> 
 <p>char str[20];</p> 
 <p>strcpy(str,“I love you”);</p> 
 <p>再用到memset函数时，出现了一些问题</p> 
 <p>对于memcset函数简单介绍下</p> 
 <p>memset</p> 
 <p>void *memset(void *s,int c,size_t n)</p> 
 <p>作用：将已开辟内存空间s的首n个字节的值设为值c。</p> 
 <p>char str[20];</p> 
 <p>memset(str,'a',20);</p> 
 <p>如果是字符类型数组的话，memset可以随便用，但是对于其他类型的数组，一般只用来清0或者填-1，如果是填充其他数据就会出错</p> 
 <p>int str[10];</p> 
 <p>memset(str,1,sizeof(str));//这样是错误的</p> 
 <p>这里我们说下这个错误，</p> 
 <p>首先我们要知道memset在进行赋值时，是按字节为单位来进行赋值的，每次填充的数据长度为一个字节，而对于其他类型的变量，比如int，占4个字节 所以sizeof(str)=40；而用memset赋值时，将会对指向str地址的前40个字节进行赋值0x01（00000001） 的操作，把0x00000000赋值4次0x01操作变为0x01010101（00000001000000010000000100000001）</p> 
 <p>相当于给“前10个int”进行了赋值0x01010101的操作 对应十进制的16843009</p> 
 <p>所以会出很大的错误</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/8b/c3/4LQQkoXl_o.png" alt="dfc888311ce7a2e4d7be2adacebb95fa.png"></p> 
 <p>这里请务必要注意，但是如果是清零一个数组用memset还是很方便的</p> 
 <p>简单使用的话同学们用strcmp函数就行</p> 
 <p>3用指针（注意内存分配）</p> 
 <p>char *str；</p> 
 <p>str=“I love you”;</p> 
 <p>这两句话的本质是，在内存中开辟一段内存空间，把"I love you"放进这段内存空间，然后把这段内存空间的地址交给str，由于str是变量，所以给它赋值是合法的。</p> 
 <p>请注意，在我们进行数组初始化的时候如果定义的数组过长，而我们只初始化了一部分数据，对于未初始化的数据如果是数值型，则会自动赋值为0,对于字符型，会自动赋初值为NULL，即‘\0’ 即不足的元素补以默认值</p> 
 <p>这里我们在4小节中也提到了</p> 
 <p>比如</p> 
 <p>int str[10]={1};//这里只是把str的第一个元素赋值为1，其他元素默认为0</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/17/42/mcvSgFF5_o.png" alt="3007a72c8f6c9be41ec90d90822af936.png"></p> 
 <p><strong>7、结构体与指针</strong></p> 
 <p>我们知道，指针指向的是变量所占内存的首地址，在结构体中，指针指向的是结构体变量的起始地址，当然也可指向结构体变量的元素</p> 
 <p>这里我们分为三部分</p> 
 <p>7.1指向结构体变量的指针</p> 
 <p>定义形式一般为</p> 
 <p>struct 结构体名* 指针名；</p> 
 <p>比如：struct Student* p；</p> 
 <p>struct Student</p> 
 <p>{<!-- --></p> 
 <p>char cName[20];</p> 
 <p>  int number;</p> 
 <p>  char csex;  </p> 
 <p>}student1;</p> 
 <p>struct Student*p;</p> 
 <p>p=&amp;student1;</p> 
 <p>//若为结构体数组则</p> 
 <p>struct Student stu1[5];</p> 
 <p>struct Student*p;</p> 
 <p>p=stu1;//因为stu1为结构体数组而p=stu1直接是指向stu1的首地址，就不用再加&amp;符</p> 
 <p>用结构体指针变量访问结构体变量成员有以下两种方式：</p> 
 <p>(*p).cName //这里的括号不能少，在5.1中有提到</p> 
 <p>p-&gt;cName</p> 
 <p>简单来说以下三种形式是等价的</p> 
 <p>p-&gt;cName</p> 
 <p>(*p).cName </p> 
 <p>student1.cName</p> 
 <p>p-&gt;cName //可以进行正常的运算</p> 
 <p>p-&gt;number++; 是将结构体变量中number的值进行运算，然后再加一，</p> 
 <p>这里要注意下，等下在7.2中会有比较</p> 
 <p>7.2指向结构体数组的指针</p> 
 <p>7.1中我们已经提到结构体数组指针的命名，这里我们仅对一些知识点做下介绍</p> 
 <p>这里我们接着来说结构体数组指针</p> 
 <p>在我们想要用指针访问结构体数组的第n个数据时可以用</p> 
 <p>struct Student stu1[5];</p> 
 <p>struct Student*p;</p> 
 <p>p=stu[n];</p> 
 <p>(++p).number//是指向了结构体数组下一个元素的地址</p> 
 <p>7.3结构体成员是指针类型变量</p> 
 <p>比如</p> 
 <p>struct Student</p> 
 <p>{<!-- --></p> 
 <p>  char* Name;//这样防止名字长短不一造成空间的浪费</p> 
 <p>  int number;</p> 
 <p>  char csex;  </p> 
 <p>}student1;</p> 
 <p>在使用时可以很好地防止内存被浪费，但是注意在引用时一定要给指针变量分配地址，如果你不分配地址，结果可能是对的，但是Name会被分配到任意的一的地址，结构体不为字符串分配任何内存存储空间具有不确定性，这样就存在潜在的危险，</p> 
 <p>struct Student</p> 
 <p>{<!-- --></p> 
 <p>  char* Name;</p> 
 <p>  int number;</p> 
 <p>  char csex;  </p> 
 <p>}stu，*stu；</p> 
 <p>stu.name=(char*)malloc(sizeof(char));//内存初始化</p> 
 <p>这里我们说一下，同学们看书的时候一般不会看到，</p> 
 <p>如果我们定义了结构体指针变量，他没有指向一个结构体，那么这个结构体指针也是要分配内存初始化的，他所对应的指针类型结构体成员也要相应初始化分配内存</p> 
 <p>struct Student</p> 
 <p>{<!-- --></p> 
 <p>  char* Name;</p> 
 <p>  int number;</p> 
 <p>char csex;  </p> 
 <p>}stu,*stu;</p> 
 <p>stu = (struct student*)malloc(sizeof(struct student));./*结构体指针初始化*/</p> 
 <p>  stu-&gt;name = (char*)malloc(sizeof(char));/*结构体指针的成员指针同样需要初始化*/  </p> 
 <p>7.4二叉树遍历算法</p> 
 <p>二叉树的二叉链表类型定义如下：</p> 
 <p>typedef struct btnode {<!-- --></p> 
 <p>datatype data;</p> 
 <p>struct btnode *lchild,*rchild;</p> 
 <p>}；</p> 
 <p>这里我们仅仅提出以下，因为涉及到链表，感兴趣的同学可以去学习下（二级要用），</p> 
 <p>7.5结构体作为函数参数</p> 
 <p>首先我们要注意的一点，使用结构体变量作为函数参数的时候，采取的是值传递的方式，将结构体所占内存单元的内容全部传递给形参，并且形参必须也要是同类型的结构体变量，在使用时，会自动创建一个结构体变量作为原变量的副本，并且也需要占内存，并且在调用期间如果修改（形参）结构体中成员的值，修改值是无效的，</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/5f/8b/r0QgfMav_o.png" alt="92970e0c851abe451499efc7f20bc7b9.png"></p> 
 <p>而如果用指针作为实参，传递给函数的形参，这时候传递的是结构体的地址，形参所指向的地址就是结构体变量的地址，这时候进行修改的话是可以修改的，这正是指针的精华所在</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/c3/6b/XmuU9206_o.png" alt="90f556452b17ba198efa8ebe56fe5f33.png"></p> 
 <p>在这里我们再提供几种互换两个结构体的方法</p> 
 <p>struct Student</p> 
 <p>{<!-- --></p> 
 <p> char cName[20];</p> 
 <p> int number;</p> 
 <p> char csex;  </p> 
 <p>}student1,student2;</p> 
 <p>struct Student student1={"Wang",12345,'W'};</p> 
 <p>struct Student student2={"Zhao",54321,'M'}; </p> 
 <p>struct Student*stu1=&amp;student1;</p> 
 <p>struct Student*stu2=&amp;student2;</p> 
 <p>struct Student *student3;</p> 
 <p>student3=stu1;</p> 
 <p>stu1=stu2;</p> 
 <p>stu2=student3;//互换地址</p> 
 <p>2对于同类型结构体直接互换值就行</p> 
 <p>struct stu student3;</p> 
 <p>student3=student1;</p> 
 <p>student1=student2;</p> 
 <p>student2=student3;</p> 
 <p>//这里也可以写成应strcmp函数互换</p> 
 <p>3用memcpy()函数进行互换</p> 
 <p>4比较笨的方法：用for循环互换</p> 
 <p>最后提下memset清空结构体</p> 
 <p>struct Student</p> 
 <p>{<!-- --></p> 
 <p> char cName[20];</p> 
 <p> int number;</p> 
 <p> char csex;  </p> 
 <p>}stu1;</p> 
 <p style="text-align:left;">一般情况下，清空str的方法：</p> 
 <p style="text-align:left;">　　str.cName[0]='\0';</p> 
 <p style="text-align:left;">　　str.csex='0';</p> 
 <p style="text-align:left;">　　str.number=0;</p> 
 <p style="text-align:left;">　　但是我们用memset就非常方便：</p> 
 <p style="text-align:left;">　　memset(&amp;str,0,sizeof(struct Student));</p> 
 <p style="text-align:left;">　　如果是数组：</p> 
 <p style="text-align:left;">　　struct Student stu[10];</p> 
 <p style="text-align:left;">　　就是</p> 
 <p style="text-align:left;">　　memset(stu,0,sizeof(struct Student)*10);</p> 
 <pre></pre> 
 <pre></pre> 
 <p style="text-align:center;"><img title="音符" src="https://images2.imgbox.com/74/50/NXFlvAyw_o.gif" alt="d3b2393e8c9e228d5bc1ce84296f64f2.gif"></p> 
 <pre class="has"><code class="language-go">如果你年满18周岁以上，又觉得学【C语言】太难？想尝试其他编程语言，那么我推荐你学Python，现有价值499元Python零基础课程限时免费领取，限10个名额！</code></pre> 
 <pre class="has"><code class="language-go">▲扫描二维码-免费领取</code></pre> 
 <p><strong>推荐阅读</strong><br></p> 
 <p><a href="" rel="nofollow">C语言实现二叉查找树详解</a><br></p> 
 <p><a href="" rel="nofollow">C++ 之父：Rust等内存安全语言的安全性并不优于C++</a><br></p> 
 <p><a href="" rel="nofollow">哪些著名软件是用C、C++编写的？</a><br></p> 
 <p><a href="" rel="nofollow">C语言字符数组与字符串的使用详解</a></p> 
 <p>戳“阅读原文”我们一起进步</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/97b2496c8885fb0da5c8c236bc360116/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">js中call,apply,bind方法的简单总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2e032f4ee4d2d18fae811f7a96e5b4f3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JS-获取DOM元素的四种方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>