<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Kubernetes二进制部署——理论部分 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Kubernetes二进制部署——理论部分" />
<meta property="og:description" content="Kubernetes二进制部署 一、环境准备 k8s集群master01: 192.168.80.71 kube-apiserver kube-controller-manager kube-scheduler etcd k8s集群master02: 192.168.80.74 k8s集群node01: 192.168.80.72 kubelet kube-proxy docker flannel k8s集群node02: 192.168.80.73 etcd集群节点1: 192.168.80.71 etcd etcd集群节点2: 192.168.80.72 etcd集群节点3: 192.168.80.73 负载均衡nginx&#43;keepalive01 (master) : 192.168.80.76 负载均衡nginx&#43;keepalive02 (backup) : 192.168.80.77 systemctl stop firewalld systemctl disable firewalld setenforce 0 单master至少3台k8s集群，一台master主机，两台node节点，运用去中心化思想，节省服务器，将三台etcd节点配置在master和node主机上双master节点至少六台主机，两台Master主机，两台node主机，三台etcd节点配置在master和node节点上，两台负载均衡节点主机api server与客户端kubectl通信加密，api server与etcd通信加密，etcd数据库之间通信加密，需要签发证书 二、部署etcd集群 1、准备签发证书环境 2、签发证书步骤 ##### 在 master01 节点上操作 //下载证书制作工具 wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 -O /usr/local/bin/cfssl wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 -O /usr/local/bin/cfssljson wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64 -O /usr/local/bin/cfssl-certinfo 或 curl -L https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 -o /usr/local/bin/cfssl curl -L https://pkg." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/72e1c12bb4daf52610123b67622ad7df/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-27T10:49:33+08:00" />
<meta property="article:modified_time" content="2022-07-27T10:49:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Kubernetes二进制部署——理论部分</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Kubernetes_0"></a>Kubernetes二进制部署</h2> 
<h3><a id="_2"></a>一、环境准备</h3> 
<pre><code>k8s集群master01: 192.168.80.71   kube-apiserver kube-controller-manager kube-scheduler etcd
k8s集群master02: 192.168.80.74

k8s集群node01: 192.168.80.72     kubelet kube-proxy docker flannel
k8s集群node02: 192.168.80.73

etcd集群节点1: 192.168.80.71     etcd
etcd集群节点2: 192.168.80.72
etcd集群节点3: 192.168.80.73

负载均衡nginx+keepalive01 (master) : 192.168.80.76
负载均衡nginx+keepalive02 (backup) : 192.168.80.77

systemctl stop firewalld
systemctl disable firewalld
setenforce 0

</code></pre> 
<ul><li>单master至少3台k8s集群，一台master主机，两台node节点，运用去中心化思想，节省服务器，将三台etcd节点配置在master和node主机上</li><li>双master节点至少六台主机，两台Master主机，两台node主机，三台etcd节点配置在master和node节点上，两台负载均衡节点主机</li><li>api server与客户端kubectl通信加密，api server与etcd通信加密，etcd数据库之间通信加密，需要签发证书</li></ul> 
<h2><a id="etcd_30"></a>二、部署etcd集群</h2> 
<h3><a id="1_32"></a>1、准备签发证书环境</h3> 
<h3><a id="2_34"></a>2、签发证书步骤</h3> 
<pre><code>##### 在 master01 节点上操作

//下载证书制作工具
wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 -O /usr/local/bin/cfssl
wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 -O /usr/local/bin/cfssljson
wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64 -O /usr/local/bin/cfssl-certinfo
或
curl -L https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 -o /usr/local/bin/cfssl
curl -L https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 -o /usr/local/bin/cfssljson
curl -L https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64 -o /usr/local/bin/cfssl-certinfo

chmod +x /usr/local/bin/cfssl*

------

cfssl：证书签发的工具命令
cfssljson：将 cfssl 生成的证书（json格式）变为文件承载式证书
cfssl-certinfo：验证证书的信息

## cfssl-certinfo -cert &lt;证书名称&gt;			#查看证书的信息

//创建k8s工作目录
mkdir /opt/k8s
cd /opt/k8s/

//上传 etcd-cert.sh 和 etcd.sh 到 /opt/k8s/ 目录中
chmod +x etcd-cert.sh etcd.sh

//创建用于生成CA证书、etcd 服务器证书以及私钥的目录
mkdir /opt/k8s/etcd-cert
mv etcd-cert.sh etcd-cert/
cd /opt/k8s/etcd-cert/
./etcd-cert.sh			#生成CA证书、etcd 服务器证书以及私钥

ls
ca-config.json  ca-csr.json  ca.pem        server.csr       server-key.pem
ca.csr          ca-key.pem   etcd-cert.sh  server-csr.json  server.pem

---------- 启动etcd服务 ---------- 
//etcd 二进制包地址：https://github.com/etcd-io/etcd/releases

//上传 etcd-v3.3.10-linux-amd64.tar.gz 到 /opt/k8s/ 目录中，解压 etcd 压缩包
cd /opt/k8s/
tar zxvf etcd-v3.3.10-linux-amd64.tar.gz
ls etcd-v3.3.10-linux-amd64

## Documentation  etcd  etcdctl  README-etcdctl.md  README.md  READMEv2-etcdctl.md

etcd就是etcd 服务的启动命令，后面可跟各种启动参数

## etcdctl主要为etcd 服务提供了命令行操作

//创建用于存放 etcd 配置文件，命令文件，证书的目录
mkdir -p /opt/etcd/{cfg,bin,ssl}

mv /opt/k8s/etcd-v3.3.10-linux-amd64/etcd /opt/k8s/etcd-v3.3.10-linux-amd64/etcdctl /opt/etcd/bin/
cp /opt/k8s/etcd-cert/*.pem /opt/etcd/ssl/

./etcd.sh etcd01 192.168.80.10 etcd02=https://192.168.80.11:2380,etcd03=https://192.168.80.12:2380
//进入卡住状态等待其他节点加入，这里需要三台etcd服务同时启动，如果只启动其中一台后，服务会卡在那里，直到集群中所有etcd节点都已启动，可忽略这个情况

//另外打开一个窗口查看etcd进程是否正常
ps -ef | grep etcd

//把etcd相关证书文件和命令文件全部拷贝到另外两个etcd集群节点
scp -r /opt/etcd/ root@192.168.80.11:/opt/
scp -r /opt/etcd/ root@192.168.80.12:/opt/

//把etcd服务管理文件拷贝到另外两个etcd集群节点
scp /usr/lib/systemd/system/etcd.service root@192.168.80.11:/usr/lib/systemd/system/
scp /usr/lib/systemd/system/etcd.service root@192.168.80.12:/usr/lib/systemd/system/

##### 在 node01 节点上修改

vim /opt/etcd/cfg/etcd
#[Member]
ETCD_NAME="etcd02"											#修改
ETCD_DATA_DIR="/var/lib/etcd/default.etcd"
ETCD_LISTEN_PEER_URLS="https://192.168.80.11:2380"			#修改
ETCD_LISTEN_CLIENT_URLS="https://192.168.80.11:2379"		#修改

#[Clustering]
ETCD_INITIAL_ADVERTISE_PEER_URLS="https://192.168.80.11:2380"		#修改
ETCD_ADVERTISE_CLIENT_URLS="https://192.168.80.11:2379"				#修改
ETCD_INITIAL_CLUSTER="etcd01=https://192.168.80.10:2380,etcd02=https://192.168.80.11:2380,etcd03=https://192.168.80.12:2380"
ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster"
ETCD_INITIAL_CLUSTER_STATE="new"

//启动etcd服务
systemctl start etcd
systemctl enable etcd
systemctl status etcd

##### 在 node02 节点上修改

vim /opt/etcd/cfg/etcd
#[Member]
ETCD_NAME="etcd03"											#修改
ETCD_DATA_DIR="/var/lib/etcd/default.etcd"
ETCD_LISTEN_PEER_URLS="https://192.168.80.12:2380"			#修改
ETCD_LISTEN_CLIENT_URLS="https://192.168.80.12:2379"		#修改

#[Clustering]
ETCD_INITIAL_ADVERTISE_PEER_URLS="https://192.168.80.12:2380"		#修改
ETCD_ADVERTISE_CLIENT_URLS="https://192.168.80.12:2379"				#修改
ETCD_INITIAL_CLUSTER="etcd01=https://192.168.80.10:2380,etcd02=https://192.168.80.11:2380,etcd03=https://192.168.80.12:2380"
ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster"
ETCD_INITIAL_CLUSTER_STATE="new"

//启动etcd服务
systemctl start etcd
systemctl enable etcd
systemctl status etcd

##### 在 master01 节点上操作

ln -s /opt/etcd/bin/etcd* /usr/local/bin

//检查etcd群集状态
cd /opt/etcd/ssl
/opt/etcd/bin/etcdctl \
--ca-file=ca.pem \
--cert-file=server.pem \
--key-file=server-key.pem \
--endpoints="https://192.168.80.10:2379,https://192.168.80.11:2379,https://192.168.80.12:2379" \
cluster-health

------

--cert-file：识别HTTPS端使用SSL证书文件
--key-file：使用此SSL密钥文件标识HTTPS客户端
--ca-file：使用此CA证书验证启用https的服务器的证书
--endpoints：集群中以逗号分隔的机器地址列表

## cluster-health：检查etcd集群的运行状况

//切换到etcd3版本查看集群节点状态和成员列表
export ETCDCTL_API=3						#v2和v3命令略有不同，etcd2和etcd3也是不兼容的，默认是v2版本
etcdctl --write-out=table endpoint status
etcdctl --write-out=table member list
export ETCDCTL_API=2						#再切回v2版本


</code></pre> 
<h3><a id="3etcdcertshetcdsh_182"></a>3、etcd-cert.sh和etcd.sh脚本</h3> 
<p><mark>etcd-cert.sh</mark></p> 
<pre><code>#!/bin/bash
#配置证书生成策略，让 CA 软件知道颁发有什么功能的证书，生成用来签发其他组件证书的根证书
cat &gt; ca-config.json &lt;&lt;EOF
{
  "signing": {
    "default": {
      "expiry": "87600h"
    },
    "profiles": {
      "www": {
         "expiry": "87600h",
         "usages": [
            "signing",
            "key encipherment",
            "server auth",
            "client auth"
        ]
      }
    }
  }
}
EOF

#ca-config.json：可以定义多个 profiles，分别指定不同的过期时间、使用场景等参数；
#后续在签名证书时会使用某个 profile；此实例只有一个 www 模板。
#expiry：指定了证书的有效期，87600h 为10年，如果用默认值一年的话，证书到期后集群会立即宕掉
#signing：表示该证书可用于签名其它证书；生成的 ca.pem 证书中 CA=TRUE；
#key encipherment：表示使用非对称密钥加密，如 RSA 加密；
#server auth：表示client可以用该 CA 对 server 提供的证书进行验证；
#client auth：表示server可以用该 CA 对 client 提供的证书进行验证；
#注意标点符号，最后一个字段一般是没有逗号的。

#-----------------------
#生成CA证书和私钥（根证书和私钥）
#特别说明： cfssl和openssl有一些区别，openssl需要先生成私钥，然后用私钥生成请求文件，最后生成签名的证书和私钥等，但是cfssl可以直接得到请求文件。
cat &gt; ca-csr.json &lt;&lt;EOF
{
    "CN": "etcd",
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "L": "Beijing",
            "ST": "Beijing"
        }
    ]
}
EOF

#CN：Common Name，浏览器使用该字段验证网站或机构是否合法，一般写的是域名 
#key：指定了加密算法，一般使用rsa（size：2048）
#C：Country，国家
#ST：State，州，省
#L：Locality，地区,城市
#O: Organization Name，组织名称，公司名称
#OU: Organization Unit Name，组织单位名称，公司部门

cfssl gencert -initca ca-csr.json | cfssljson -bare ca       ##cfssl证书制作工具

#生成的文件：
#ca-key.pem：根证书私钥
#ca.pem：根证书
#ca.csr：根证书签发请求文件

#cfssl gencert -initca &lt;CSRJSON&gt;：使用 CSRJSON 文件生成生成新的证书和私钥。如果不添加管道符号，会直接把所有证书内容输出到屏幕。
#注意：CSRJSON 文件用的是相对路径，所以 cfssl 的时候需要 csr 文件的路径下执行，也可以指定为绝对路径。
#cfssljson 将 cfssl 生成的证书（json格式）变为文件承载式证书，-bare 用于命名生成的证书文件。

#-----------------------
#生成 etcd 服务器证书和私钥
cat &gt; server-csr.json &lt;&lt;EOF     #服务器端的签名
{
    "CN": "etcd",
    "hosts": [                  #定义三个节点的IP地址
    "192.168.61.11",
    "192.168.61.22",
    "192.168.61.33"
    ],
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "L": "BeiJing",
            "ST": "BeiJing"
        }
    ]
}
EOF

#hosts：将所有 etcd 集群节点添加到 host 列表，需要指定所有 etcd 集群的节点 ip 或主机名不能使用网段，新增 etcd 服务器需要重新签发证书。

cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=www server-csr.json | cfssljson -bare server

#生成的文件：
#server.csr：服务器的证书请求文件
#server-key.pem：服务器的私钥
#server.pem：服务器的数字签名证书

#-config：引用证书生成策略文件 ca-config.json
#-profile：指定证书生成策略文件中的的使用场景，比如 ca-config.json 中的 www

</code></pre> 
<p><mark>etcd.sh</mark></p> 
<pre><code>#!/bin/bash

# example: ./etcd.sh etcd01 192.168.61.11
etcd02=https://192.168.61.22:2380,etcd03=https://192.168.61.33:2380

#创建etcd配置文件/opt/etcd/cfg/etcd
ETCD_NAME=$1
ETCD_IP=$2
ETCD_CLUSTER=$3

WORK_DIR=/opt/etcd

cat &gt; $WORK_DIR/cfg/etcd  &lt;&lt;EOF
#[Member]
ETCD_NAME="${ETCD_NAME}"
ETCD_DATA_DIR="/var/lib/etcd/default.etcd"
ETCD_LISTEN_PEER_URLS="https://${ETCD_IP}:2380"
ETCD_LISTEN_CLIENT_URLS="https://${ETCD_IP}:2379"

#[Clustering]
ETCD_INITIAL_ADVERTISE_PEER_URLS="https://${ETCD_IP}:2380"
ETCD_ADVERTISE_CLIENT_URLS="https://${ETCD_IP}:2379"
ETCD_INITIAL_CLUSTER="etcd01=https://${ETCD_IP}:2380,${ETCD_CLUSTER}"
ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster"
ETCD_INITIAL_CLUSTER_STATE="new"
EOF

#Member:成员配置
#ETCD_NAME：节点名称，集群中唯一。成员名字，集群中必须具备唯一性，如etcd01
#ETCD_LISTEN_PEER_URLS：集群通信监听地址。用于监听其他member发送信息的地址。ip为全0代表监听本机所有接口
#ETCD_LISTEN_CLIENT_URLS：客户端访问监听地址。用于监听etcd客户发送信息的地址。ip为全0代表监听本机所有接口

#Clustering：集群配置
#ETCD_ADVERTISE_CLIENT_URLS：客户端通告地址。etcd客户端使用，客户端通过该地址与本member交互信息。一定要保证从客户侧能可访问该地址
#ETCD_INITIAL_CLUSTER：集群节点地址。本member使用。描述集群中所有节点的信息，本member根据此信息去联系其他member
#ETCD_INITIAL_CLUSTER_TOKEN：集群Token。用于区分不同集群。本地如有多个集群要设为不同
#ETCD_INITIAL_CLUSTER_STATE：加入集群的当前状态，new是新集群，existing表示加入已有集群。

[Unit]
Description=Etcd Server
After=network.target
After=network-online.target
Wants=network-online.target

[Service]
Type=notify
EnvironmentFile=${WORK_DIR}/cfg/etcd
ExecStart=${WORK_DIR}/bin/etcd \
--name=\${ETCD_NAME} \
--data-dir=\${ETCD_DATA_DIR} \
--listen-peer-urls=\${ETCD_LISTEN_PEER_URLS} \
--listen-client-urls=\${ETCD_LISTEN_CLIENT_URLS},http://127.0.0.1:2379 \
--advertise-client-urls=\${ETCD_ADVERTISE_CLIENT_URLS} \
--initial-advertise-peer-urls=\${ETCD_INITIAL_ADVERTISE_PEER_URLS} \
--initial-cluster=\${ETCD_INITIAL_CLUSTER} \
--initial-cluster-token=\${ETCD_INITIAL_CLUSTER_TOKEN} \
--initial-cluster-state=new \
--cert-file=${WORK_DIR}/ssl/server.pem \
--key-file=${WORK_DIR}/ssl/server-key.pem \
--trusted-ca-file=${WORK_DIR}/ssl/ca.pem \
--peer-cert-file=${WORK_DIR}/ssl/server.pem \
--peer-key-file=${WORK_DIR}/ssl/server-key.pem \
--peer-trusted-ca-file=${WORK_DIR}/ssl/ca.pem
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
EOF

#--listen-client-urls：用于指定etcd和客户端的连接端口
#--advertise-client-urls：用于指定etcd服务器之间通讯的端口，etcd有要求，如果--listen-client-urls被设置了，那么就必须同时设置--advertise-client-urls，所以
即使设置和默认相同，也必须显式设置
#--peer开头的配置项用于指定集群内部TLS相关证书（peer 证书），这里全部都使用同一套证书认证
#不带--peer开头的的参数是指定 etcd 服务器TLS相关证书（server 证书），这里全部都使用同一套证书认证

systemctl daemon-reload
systemctl enable etcd
systemctl restart etcd
</code></pre> 
<h3><a id="4_380"></a>4、部署流程</h3> 
<ul><li> <p>准备cfssl证书生成工具</p> </li><li> <p>生成证书</p> </li><li> <p>生成etcd二进制包</p> </li><li> <p>生成etcd的配置文件和服务管理文件</p> </li><li> <p>启动etcd</p> </li><li> <p>把etcd01的配置文件，可执行文件，证书，etcd服务管理文件 复制到etcd02 etcd03 节点上</p> </li><li> <p>etcd02 etcd03 修改配置文件</p> </li><li> <p>启动etcd 加入集群</p> </li><li> <p>验证etcd集群状态</p> </li></ul> 
<h3><a id="5_398"></a>5、使用证书访问的工作流程:</h3> 
<p>(1)客户端发起请求，连接到服务器的进程端口。<br> (2)服务器必须要有一套数字证书(证书内容有公钥、证书颁发机构、失效日期等)。<br> (3)服务器将自己的数字证书发送给客户端(公钥在证书里面，私钥由服务器持有)。<br> (4)客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的密钥对，用证书.的公钥加密。<br> (5)客户端将公钥加密后的密钥发送到服务器。<br> (6)服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，这样传输的数据都是密文了。<br> (7)服务器将加密后的密文数据返回到客户端。<br> (8)客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。</p> 
<h2><a id="docker_411"></a>四、部署docker引擎</h2> 
<pre><code>//所有node节点部署docker引擎
yum install -y yum-utils device-mapper-persistent-data lvm2 
yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 
yum install -y docker-ce docker-ce-cli containerd.io

systemctl start docker.service
systemctl enable docker.service
</code></pre> 
<h2><a id="flannel_427"></a>五、flannel网络配置</h2> 
<h3><a id="1K8S_Pod__429"></a>1、K8S 中Pod 网络通信:</h3> 
<p><mark>Pod内容器与容器之间的通信</mark></p> 
<ul><li>在同一个Pod 内的容器(Pod 内的容器是不会跨宿主机的)共享同一个网络命令空间，相当于它们在同一台机器上一样，可以用localhost地址访问彼此的端口。</li></ul> 
<p><mark>同一个Node内Pod之间的通信</mark></p> 
<ul><li>每个Pod 都有一个真实的全局IP地址，同一个Node 内的不同Pod 之间可以直接采用对方Pod的IP地址进行通信，Pod1 与Pod2 都是通过Veth连接到同一-个docker0 网桥（172.1.0.0），网段相同，所以它们之间可以直接通信。</li></ul> 
<p><mark>不同Node上Pod之间的通信</mark></p> 
<ul><li>Pod 地址与docker0 在同一网段，docker0 网段与宿主机网卡是两个不同的网段，且不同Node之间的通信只能通过宿主机的物理网卡进行。</li><li>要想实现不同Node上Pod之间的通信，就必须想办法通过主机的物理网卡IP地址进行寻址和通信。因此要满足两个条件:Pod的IP不能冲突;将Pod的IP和所在的Node的IP关联起来，通过这个关联让不同Node上Pod之间直接通过内网IP地址通信。</li></ul> 
<p><img src="https://images2.imgbox.com/8e/02/4dv2WEw7_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2Flannel_455"></a>2、Flannel</h3> 
<p><mark>Overlay Network:</mark></p> 
<ul><li>叠加网络，在二层或者三层基础网络上叠加的一种虚拟网络技术模式，该网络中的主机通过虚拟链路隧道连接起来(类似于VPN)</li></ul> 
<p><mark>VXLAN:</mark></p> 
<ul><li>将源数据包封装到UDP中，并使用基础网络的IP/MAC作为外层报文头进行封装，然后在以太网上传输，到达目的地后由隧道端点解封装并将数据发送给目标地址。</li></ul> 
<p><mark>Flannel：</mark></p> 
<ul><li>Flannel的功能是让集群中的不同节点主机创建的Docker 容器都具有全集群唯一的虚拟 IP地址。</li><li>Flannel是Overlay网络的一种，也是将TCP源数据包封装在另一种网络包里面进行路由转发和通信，目前己经支持UDP、VXLAN、AWS VPC等数据转发方式。</li></ul> 
<p><mark>作用：Flannel网络插件，用于不同node组件pod相互通信</mark></p> 
<h3><a id="3Flannel_476"></a>3、Flannel工作原理:</h3> 
<ul><li> <p>数据从node01 上Pod 的源容器中发出后，经由所在主机的docker0 虚拟网卡转发到flannel0 虚拟网卡，flanneld 服务监听在flanne10虚拟网卡的另外一端。</p> </li><li> <p>Flannel通过Etcd服务维护了一张节点间的路由表。源主机node01的flanneld服务将原本的数据内容封装到UDP中后根据自己的路由表通过物理网卡投递给目的节点node02 的flanneld 服务，数据到达以后被解包，然后直接进入目的节点的flannel0虚拟网卡，之后被转发到目的主机的docker0 虚拟网卡，最后就像本机容器通信一样由docker0 转发到目标容器。</p> <p><img src="https://images2.imgbox.com/4d/f4/BqF2bTLF_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<pre><code>源IP  10.1.15.3   ---&gt;66.11  （Flannel封装）:[IP头部  MAC头部 比特流] 
(UDP)封装到UDP中吗UDP中有内部IP，包括源IP和目的IP
---&gt; 66.12  （Flannel解封装）:[MAC头部  IP头  UDP]  ---&gt;  目的IP 10.1.20.3

</code></pre> 
<blockquote> 
 <ul><li>flannel作用是实现不同Node上的pod之间相互通信</li><li>flannel会把内部的pod IP封装到UDP中，再通过API server查看etcd，再根据在 etcd 保存的路由表，通过物理网卡发送给目的node</li><li>目的node在接收到转发的数据后，由flannel解封装，暴露出udp里面的内部pod IP，再根据目的IP由flannei0–&gt;docker0转发到目的pod中。</li></ul> 
</blockquote> 
<p><mark>ETCD之Flannel 提供说明:</mark></p> 
<ul><li>存储管理Flannel可分配的IP地址段资源</li><li>监控ETCD中每个Pod 的实际地址，并在内存中建立维护Pod 节点路由表</li></ul> 
<h3><a id="4flannel_506"></a>4、搭建flannel</h3> 
<pre><code>##### 在 master01 节点上操作

//添加 flannel 网络配置信息，写入分配的子网段到 etcd 中，供 flannel 使用
cd /opt/etcd/ssl
/opt/etcd/bin/etcdctl \
--ca-file=ca.pem \
--cert-file=server.pem \
--key-file=server-key.pem \
--endpoints="https://192.168.80.10:2379,https://192.168.80.11:2379,https://192.168.80.12:2379" \
set /coreos.com/network/config '{"Network": "172.17.0.0/16", "Backend": {"Type": "vxlan"}}'

//查看写入的信息
/opt/etcd/bin/etcdctl \
--ca-file=ca.pem \
--cert-file=server.pem \
--key-file=server-key.pem \
--endpoints="https://192.168.80.10:2379,https://192.168.80.11:2379,https://192.168.80.12:2379" \
get /coreos.com/network/config

------

set &lt;key&gt; &lt;value&gt;
set /coreos.com/network/config 添加一条网络配置记录，这个配置将用于flannel分配给每个docker的虚拟IP地址段
get &lt;key&gt;
get /coreos.com/network/config 获取网络配置记录，后面不用再跟参数了

Network：用于指定Flannel地址池

## Backend：用于指定数据包以什么方式转发，默认为udp模式，Backend为vxlan比起预设的udp性能相对好一些

##### 在所有 node 节点上操作

//上传 flannel.sh 和 flannel-v0.10.0-linux-amd64.tar.gz 到 /opt 目录中，解压 flannel 压缩包
cd /opt
tar zxvf flannel-v0.10.0-linux-amd64.tar.gz
flanneld				#flanneld为主要的执行文件
mk-docker-opts.sh		#mk-docker-opts.sh脚本用于生成Docker启动参数
README.md

//创建kubernetes工作目录
mkdir -p /opt/kubernetes/{cfg,bin,ssl}

cd /opt
mv mk-docker-opts.sh flanneld /opt/kubernetes/bin/

//启动flanneld服务，开启flannel网络功能
cd /opt
chmod +x flannel.sh
./flannel.sh https://192.168.80.10:2379,https://192.168.80.11:2379,https://192.168.80.12:2379

//flannel启动后会生成一个docker网络相关信息配置文件/run/flannel/subnet.env，包含了docker要使用flannel通讯的相关参数
cat /run/flannel/subnet.env
DOCKER_OPT_BIP="--bip=172.17.26.1/24"
DOCKER_OPT_IPMASQ="--ip-masq=false"
DOCKER_OPT_MTU="--mtu=1450"

## DOCKER_NETWORK_OPTIONS=" --bip=172.17.26.1/24 --ip-masq=false --mtu=1450"

--bip：指定 docker 启动时的子网
--ip-masq：设置 ipmasq=false 关闭 snat 伪装策略
--mtu=1450：mtu 要留出50字节给外层的vxlan封包的额外开销使用

Flannel启动过程解析：
1、从etcd中获取network的配置信息
2、划分subnet，并在etcd中进行注册

## 3、将子网信息记录到/run/flannel/subnet.env中

//修改docker服务管理文件，配置docker连接flannel
vim /lib/systemd/system/docker.service
......
[Service]
Type=notify

# the default is not to use systemd for cgroups because the delegate issues still

# exists and systemd currently does not support the cgroup feature set required

# for containers run by docker

EnvironmentFile=/run/flannel/subnet.env						#添加
ExecStart=/usr/bin/dockerd $DOCKER_NETWORK_OPTIONS -H fd:// --containerd=/run/containerd/containerd.sock	#修改
ExecReload=/bin/kill -s HUP $MAINPID
TimeoutSec=0
RestartSec=2
Restart=always

//重启docker服务
systemctl daemon-reload
systemctl restart docker

//查看 docker0 和 flannel.1 的 IP 地址，此时应该在同一网段里
ifconfig
docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500
        inet 172.17.26.1  netmask 255.255.255.0  broadcast 172.17.26.255
......
flannel.1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1450
        inet 172.17.26.0  netmask 255.255.255.255  broadcast 0.0.0.0	
......

//在 node01 节点测试 ping 通 node02 节点的 docker0 网卡，证明 flannel 已起到路由作用
ping -I 172.17.26.1 172.17.36.1

//创建并进入容器
docker run -itd centos:7 /bin/bash

//在容器中下载工具，测试 ping 通 node02 节点中的 centos:7 容器
yum install net-tools -y
ping -I 172.17.26.2 172.17.36.2
</code></pre> 
<h3><a id="5flannel_622"></a>5、flannel的操作流程</h3> 
<ul><li>使用etcdctl 在 etcd 中添加flannel 的网段和转发模式 upd 、vxlan</li><li>准备flannel 安装包</li><li>生成 docker 网络参数 并启动 flannel 服务</li><li>修改 docker 启动参数 ，使 docker 0 网卡和 flannel 网卡保持在一个网段里</li><li>验证 node 之间的容器通信是否正常</li></ul> 
<h2><a id="_642"></a>总结</h2> 
<h3><a id="CA_644"></a>CA证书</h3> 
<p><img src="https://images2.imgbox.com/70/c3/rvmFtFeq_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a4fedead4ad241ee04c9659b4ed2a6fb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vuex的五个属性</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3df876a413654aecebca5cdaa395df80/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql查询条件字段值末尾有空格也能查到数据问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>