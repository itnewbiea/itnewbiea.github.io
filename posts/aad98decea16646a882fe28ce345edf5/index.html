<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入理解Python深拷贝(deepcopy)、浅拷贝（copy）、等号拷贝----看了还不懂找我 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深入理解Python深拷贝(deepcopy)、浅拷贝（copy）、等号拷贝----看了还不懂找我" />
<meta property="og:description" content="编程中难免会遇到copy（浅拷贝）与deepcopy（深拷贝）问题，一不小心就会掉进坑中了，或许很多人只知道有深浅拷贝，但是你又知道copy和&#34;=&#34;拷贝有什么区别么？也许很少有人对二者的区别能讲出一二三吧！下面这篇文章就对深拷贝(deepcopy)、浅拷贝（copy）、等号拷贝进行深入的讲解。
本文不是在网上抄袭别人的，而是本人通过研究学习后的自我总结，我想当你看完这篇文章后，1. 你会知道python的变量存储机制；2. 你会深浅拷贝以及等号拷贝的差异所在了；3. 你会理解为什么有的值改变，有的拷贝跟着变化，有的不会变化的根本原因所在了。当然如果本文有不正确的地方，欢迎大家批判指正。
首先在python中，什么是浅拷贝，什么是深拷贝呢？什么是等号拷贝（形如：bb = aa）呢？有谁能一句话解释清楚，他们的区别又在哪里？-----一定记住针只有对复杂对象才有区别意义！！！因为对于简单对象，他们是没有区别的！
主要是针对复杂结构对象，复杂结构对象就是嵌套两层及以上的子对象，比如：即列表中嵌套子列表,像[1, [2, 3]]这种结构
复杂对象中的深浅拷贝：
一句话解释(=)等号拷贝：当于对于电脑中某个文件夹新建了一个快捷图标，快捷图标永远和原文件是一致的。
一句话解释（copy）浅拷贝：相当于对于电脑中某个文件夹内部的所有子文件夹新建了快捷图标，放到新的文件夹中，所以内部子文件夹内数据会跟着原来文件的改变而改变。
一句话解释（deepcopy）深拷贝：相当于对于电脑中某个文件夹用u盘拷贝了一个备份。所以原来电脑中文件夹内文件改变时，u盘的文件是不会变化的。
官方解释：
浅层拷贝 构造一个新的复合对象，然后（在尽可能的范围内）将原始对象中找到的对象的 引用 插入其中。
深层拷贝构造一个新的复合对象，然后，递归地将在原始对象里找到的对象的 副本 插入其中
要弄清楚拷贝原理，首先应该弄清楚Python变量存储机制
Python中变量的存储机制 1. aa = 1的存储机制 当aa = 1 时，首先Python会在内存中新开辟一个空间存储数字“1”，然后将该内容的地址赋值给变量‘aa’。有点像如下图所示
2. bb = aa的复制机制 对于正常的“=” 赋值， 比如 bb = aa，则有
3. 形如or_list = [1, [2, 3]]的复制对象，他们的存储机制是如何的呢？ 读者可以先自我思考一下，在本文的后面讲解中，会给出解释。
Python中复杂对象，等号拷贝，copy浅拷贝，deepcopy深拷贝机制 1. 三者拷贝后的ID差异 看以下代码初始列表为 or_list = [1, [2, 3]]，分别进行&#34;=&#34;拷贝，copy浅拷贝，deepcopy深拷贝
操作如下 eq_list = or_list sh_list = copy(or_list) de_list = deepcopy(or_list)， 通过id可以看出三者和原来list的内存地址信息，如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/aad98decea16646a882fe28ce345edf5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-04T22:40:39+08:00" />
<meta property="article:modified_time" content="2022-10-04T22:40:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入理解Python深拷贝(deepcopy)、浅拷贝（copy）、等号拷贝----看了还不懂找我</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>         编程中难免会遇到copy（浅拷贝）与deepcopy（深拷贝）问题，一不小心就会掉进坑中了，或许很多人只知道有深浅拷贝，但是你又知道copy和"="拷贝有什么区别么？也许很少有人对二者的区别能讲出一二三吧！下面这篇文章就对深拷贝(deepcopy)、浅拷贝（copy）、等号拷贝进行深入的讲解。</p> 
<p>        本文不是在网上抄袭别人的，而是本人通过研究学习后的自我总结，我想当你看完这篇文章后，1. 你会知道python的变量存储机制；2. 你会深浅拷贝以及等号拷贝的差异所在了；3. 你会理解为什么有的值改变，有的拷贝跟着变化，有的不会变化的根本原因所在了。当然如果本文有不正确的地方，欢迎大家批判指正。</p> 
<p><strong>首先在python中，什么是浅拷贝，什么是深拷贝呢？什么是等号拷贝（形如：bb = aa）呢？有谁能一句话解释清楚，他们的区别又在哪里？</strong><span style="color:#956fe7;">-----一定记住针只有对复杂对象才有区别意义！！！因为对于简单对象，他们是没有区别的！</span></p> 
<p>主要是针对复杂结构对象，复杂结构对象就是嵌套两层及以上的子对象，比如：即列表中嵌套子列表,像[1, [2, 3]]这种结构</p> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>复杂对象中的深浅拷贝：</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>一句话解释(=)等号拷贝：</strong></span>当于对于电脑中某个文件夹新建了一个快捷图标，快捷图标永远和原文件是一致的。</p> 
 <p><span style="color:#fe2c24;"><strong>一句话解释（copy）浅拷贝</strong></span>：相当于对于电脑中某个文件夹内部的<span style="color:#ff9900;"><strong>所有子文件夹</strong></span>新建了快捷图标，放到新的文件夹中，所以内部子文件夹内数据会跟着原来文件的改变而改变。</p> 
 <p><span style="color:#fe2c24;"><strong>一句话解释（deepcopy）深拷贝</strong></span>：相当于对于电脑中某个文件夹用u盘拷贝了一个备份。所以原来电脑中文件夹内文件改变时，u盘的文件是不会变化的。</p> 
 <p></p> 
 <p><strong><span style="color:#956fe7;">官方解释：</span></strong></p> 
 <ul><li> <p><span style="color:#fe2c24;"><em>浅层拷贝</em></span> 构造一个新的复合对象，然后（在尽可能的范围内）将原始对象中找到的对象的 <em>引用</em> 插入其中。</p> </li><li> <p><span style="color:#fe2c24;"><em>深层拷贝</em></span>构造一个新的复合对象，然后，递归地将在原始对象里找到的对象的 <em>副本</em> 插入其中</p> </li></ul> 
</blockquote> 
<p>要弄清楚拷贝原理，首先应该弄清楚Python变量存储机制</p> 
<h2>Python中变量的存储机制</h2> 
<h4>1. aa = 1的存储机制</h4> 
<p>当aa = 1 时，首先Python会在内存中新开辟一个空间存储数字“1”，然后将该内容的地址赋值给变量‘aa’。有点像如下图所示</p> 
<p class="img-center"><img alt="" height="101" src="https://images2.imgbox.com/87/3a/BstPuUVd_o.png" width="304"></p> 
<h4>2. bb = aa的复制机制</h4> 
<p>对于正常的“=” 赋值， 比如 bb = aa，则有</p> 
<p class="img-center"><img alt="" height="177" src="https://images2.imgbox.com/8f/73/dd230XVz_o.png" width="358"></p> 
<p style="text-align:center;"></p> 
<h4><span style="color:#fe2c24;">3. 形如or_list = [1, [2, 3]]的复制对象，他们的存储机制是如何的呢？</span></h4> 
<p>读者可以先自我思考一下，在本文的后面讲解中，会给出解释。</p> 
<h2></h2> 
<h2>Python中复杂对象，等号拷贝，copy浅拷贝，deepcopy深拷贝机制</h2> 
<h3>1. 三者拷贝后的ID差异</h3> 
<p>看以下代码初始列表为 or_list = [1, [2, 3]]，分别进行"="拷贝，copy浅拷贝，deepcopy深拷贝</p> 
<p>操作如下   </p> 
<pre><code class="language-python">    eq_list = or_list
    sh_list = copy(or_list)
    de_list = deepcopy(or_list)，</code></pre> 
<p>通过id可以看出三者和原来list的内存地址信息，如下：</p> 
<pre><code class="language-python">    id(or_list)= 2269079198528
    id(eq_list)= 2269079198528
    id(sh_list)= 2269076677056
    id(de_list)= 2269076677632</code></pre> 
<blockquote> 
 <p>【解释说明】：</p> 
 <p>1. 对于等号拷贝，没有新建新的内存空间，只是吧eq_list变量指向or_list变量相同的地址，通过id可以看出来，两个地址一样 id(or_list)= 2269079198528 和 id(eq_list)= 2269079198528</p> 
 <p>2. 对于copy拷贝，新创建了内存空间，并且把sh_list变量指向了该新地址。此时的新地址为id(sh_list)= 2269076677056</p> 
 <p>3. 对于deepcopy拷贝，也新创建了一个内存空间，并且整个List也指向了新的地址。此时的新地址为 id(de_list)= 2269076677632</p> 
</blockquote> 
<h3>2. 查看List的不同位置的id值</h3> 
<p>再通过id查看List内部位置存储的是什么，可以看到不同操作，不同位置就有差异了。</p> 
<p>1. or_list[0]位置，所有的拷贝后的ID都是相同的，为什么呢？</p> 
<p>2. or_list[1]位置，只有deepcopy拷贝不同，其它拷贝的id不变，这是为什么呢？</p> 
<p>3. or_list[1][0]和or_list[1][1]的id为什么所有拷贝又都是一样的呢？</p> 
<pre><code class="language-python">5.  ======列表第一个位置的ID值=======  
    id(or_list[0]) = 2269075013872
    id(eq_list[0]) = 2269075013872
    id(sh_list[0]) = 2269075013872
    id(de_list[0]) = 2269075013872

6.  ======列表第二个位置的ID值===========
    id(or_list[1]) = 2269076677312
    id(eq_list[1]) = 2269076677312
    id(sh_list[1]) = 2269076677312
    id(de_list[1]) = 2269077081216

6.1 ====列表第二个位置的子列表第一位置的ID值=====
    id(or_list[1][0]) = 2269075013904
    id(eq_list[1][0]) = 2269075013904
    id(sh_list[1][0]) = 2269075013904
    id(de_list[1][0]) = 2269075013904

6.2 ====列表第二个位置的子列表第二位置的ID值=====
    id(or_list[1][1]) = 2269075013936
    id(eq_list[1][1]) = 2269075013936
    id(sh_list[1][1]) = 2269075013936
    id(de_list[1][1]) = 2269075013936
</code></pre> 
<blockquote> 
 <p>【解释说明】</p> 
 <p>要解释清楚上面的为什么，就需要弄明白python中形如or_list = [1, [2, 3]]这样的存储原理。</p> 
 <p><strong>首先，看形如or_list = [1, [2, 3]]的存储原理</strong>，在python中，形如or_list = [1, [2, 3]]的复制对象的存储原理为如下图所示：</p> 
 <p><img alt="" height="260" src="https://images2.imgbox.com/7c/56/0GvK0Iqa_o.png" width="964"></p> 
 <p><strong>其次，看不同拷贝的原理。</strong></p> 
 <p>1. 对于等号拷贝，拷贝后实际上是将List的地址引用直接给了等号拷贝的变量，示意图如下所示</p> 
 <p><img alt="" height="309" src="https://images2.imgbox.com/ea/7b/N1MwMYHk_o.png" width="964"></p> 
 <p></p> 
 <p></p> 
 <p>2. 对于copy拷贝，拷贝后的实际上新建了一个内存空间，一个用于存储List本身，内部子对象引用原来的地址，示意图如下：</p> 
 <p><img alt="" height="448" src="https://images2.imgbox.com/08/c7/X6aV8RBg_o.png" width="976"></p> 
 <p>3. 对于deepcopy拷贝，拷贝后的实际上新建了两个内存空间，一个用于存储List，另一个存储List的子对象，如果有更多，那么就会创建更多的内存空间。示意图如下：<img alt="" height="522" src="https://images2.imgbox.com/22/5b/32uU0pwb_o.png" width="976"></p> 
 <p><strong>最后，来回答上面的问题</strong></p> 
 <p>1. or_list[0]位置，所有的拷贝后的ID都是相同的，为什么呢？</p> 
 <p><span style="color:#fe2c24;">回答1：因为对于数字1，它是简单对象，不是复杂对象，不管怎么拷贝，他们都是相同的。</span></p> 
 <p>2. or_list[1]位置，只有deepcopy拷贝不同，其它拷贝的id不变，这是为什么呢？</p> 
 <p><span style="color:#fe2c24;">回答2：对于List[1]位置，它是一个复杂对象，所以只有deepcopy新建了新的内存，所以只有它的id变化了。</span></p> 
 <p>3. or_list[1][0]和or_list[1][1]的id为什么所有拷贝又都是一样的呢？</p> 
 <p><span style="color:#fe2c24;">回答3：因为这两个位置都是存储的是简单对象，所以在所有的拷贝之后，id是不会变的。</span></p> 
</blockquote> 
<h2></h2> 
<h2>Python中复杂对象修改值后，等号拷贝，copy浅拷贝，deepcopy深拷贝变化情况详解</h2> 
<p>将所有的拷贝原理图放到一起，可以看到他们的区别和联系，如下图所示。以下是各个位置在发生改变后不同拷贝的变化机制详解。</p> 
<p><img alt="" height="910" src="https://images2.imgbox.com/de/26/b7aLKbtg_o.png" width="1151"></p> 
<h3>1. 改变or_list[1][0]的值时</h3> 
<p>进行or_list[1][0] = 4操作，结果如下所示：</p> 
<p>可以看出原始该位置存储的id是*176，初始列表该位置发生改变时，等号拷贝和copy浅拷贝也跟着发生了改变，但是deepcopy深拷贝没有发生变化。为什么会这样呢？改变的原理可以看下面的示意图。<span style="color:#ff9900;"><strong>因为</strong>deepcopy是在List[1]位置就创建了新的内存空间，其它拷贝并没有，他们还是引用的原始列表相同的内存空间，所以才会跟着一起变化</span>。</p> 
<pre><code class="language-python">======更改前：or列表的子列表第二个位置的id值===========
id(or_list[1][0])= 2269075013904
id(eq_list[1][0])= 2269075013904
id(sh_list[1][0])= 2269075013904
id(de_list[1][0])= 2269075013904

进行更改： or_list[1][0] = 4 
======更改后：or列表的子列表第二个位置的ID值===========
id(or_list[1][0])= 2269075013968
id(eq_list[1][0])= 2269075013968
id(sh_list[1][0])= 2269075013968
id(de_list[1][0])= 2269075013904
======更改后变量值===========
or_list_after_change =  [1, [4, 3]]
eq_list_after_change =  [1, [4, 3]]
sh_list_after_change =  [1, [4, 3]]
de_list_after_change =  [1, [2, 3]]

</code></pre> 
<p><img alt="" height="902" src="https://images2.imgbox.com/9f/4a/cunntrRy_o.png" width="1134"></p> 
<h3> 2. 改变List[0]位置的值时</h3> 
<p>改变第一层的元素时，只有等号拷贝跟着改变了，是<span style="color:#ff9900;">因为copy浅拷贝和deepcopy深拷贝都是新开辟了内存空间，存储List[0],List[1]，所以当原始的List[0]发生改变时，这两个拷贝没有任何影响</span>，具体原理查看以下示意图</p> 
<pre><code class="language-python">======更改前：or列表的第一个位置的ID值===========
id(or_list[0])= 2269075013872
id(eq_list[0])= 2269075013872
id(sh_list[0])= 2269075013872
id(de_list[0])= 2269075013872

进行更改： or_list[0] = 5 
======更改后：or列表的第一个位置的ID值===========
id(or_list[0])= 2269075014000
id(eq_list[0])= 2269075014000
id(sh_list[0])= 2269075013872
id(de_list[0])= 2269075013872

======更改后变量值===========
or_list_after_change =  [5, [4, 3]]
eq_list_after_change =  [5, [4, 3]]
sh_list_after_change =  [1, [4, 3]]
de_list_after_change =  [1, [2, 3]]</code></pre> 
<p><img alt="" height="895" src="https://images2.imgbox.com/99/d0/R1cwGNJ5_o.png" width="1083"></p> 
<h3> 3. 改变List[1]位置的值时</h3> 
<p>原理同3改变List[0]位置的值。原理和代码参考以下代码是示意图</p> 
<pre><code class="language-python">======更改前： or列表的第一个位置的ID值===========
id(or_list[1])= 2269076677312
id(eq_list[1])= 2269076677312
id(sh_list[1])= 2269076677312
id(de_list[1])= 2269077081216

进行更改： or_list[1] = {'1': 'a', 'b': 1}
======更改后： or列表的第一个位置的ID值===========
id(or_list[1])= 2269076306688
id(eq_list[1])= 2269076306688
id(sh_list[1])= 2269076677312
id(de_list[1])= 2269077081216

======更改后变量值===========
or_list_after_change =  [5, {'1': 'a', 'b': 10}]
eq_list_after_change =  [5, {'1': 'a', 'b': 10}]
sh_list_after_change =  [1, [4, 3]]
de_list_after_change =  [1, [2, 3]]</code></pre> 
<p><img alt="" height="895" src="https://images2.imgbox.com/37/be/amxdsQIm_o.png" width="1083"></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/01290f6acf006e68de1fc028dc62a2ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue中使用animate.css</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5bb82872be9968b562c4cb66717f281a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">开关电源学习(一) MP2315S简介</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>