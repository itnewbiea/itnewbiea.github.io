<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>组合数学 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="组合数学" />
<meta property="og:description" content="下列所有的符号中，如果没有特殊说明，则n表示集合中所有元素的个数、r表示所取的元素个数，k表示种类数。
第一章：
绪论，介绍了为什么要研究组合数学，以及组合数学的三个研究内容。
第二章：
鸽巢原理：把N&#43;1个鸽子放到N个巢里面，则至少有一个巢里面有两只鸽子。
推论：如果把N个物体放到K个盒子当中，则至少有一个盒子里面有N/k取上界个物体。
例子：Ramsey数
第三章：
1、集合的排列：P（n，r）、集合的循环排列：P(n,r)/r、集合的组合：C（n，r）
2、多重集合的排列：1、每个元素有无限多个，取r个：K^r——有K种元素，也就是说每个位置有K种选择，取r个。
2、每个元素是有限个，全排列数：N！/N1!N2!...Nk!。
3、每个元素是有限个，取r个的排列数：用后面章节的生成函数(指数生成函数)求解
3、多重集合的组合：1、每个元素有无限多个：C(r&#43;k-1,r)
2、每个元素是有限个：用后面章节的容斥原理来求，用容斥原理将有限个转换成无限多个（最多取多少个转换成至少取多少个）。
第四章：
1、活动数：给数标一个方向，如果这个数比他所指方向的那个数大，那么这个数就叫做活动数。
2、生成排列（全排列）：活动数法，1、找到一个最大的活动数，2、将这个数与他所指方向的那个数互换位置，3、将所有比他大的数的方向转换。重复这三步，直到所有的数都不是活动数。
3、逆序数：给定一个数的序列，如果Xi&gt;Xj且i&lt;j。则称这两个数为一个逆序对，用ai表示数字i的逆序对的个数，也叫逆序数。
算法1：通过相对位置和从大的数到小的数的逆序数来确定具体序列：i前面有ai个逆序对。
算法2：通过从小的数到大的数逆序数来直接确定具体序列：i直接放在第ai&#43;1个空位上。
4、生成组合：通过2进制的&#43;1来生成所有的组合。
5、生成r-组合：按字典序来排序，的直接后继是.直接前驱是。其中后继的不与原序列任何一个数重复，前驱的也是如此。
6、生成r-排列：先生成r-组合，然后对每个组合进行全排列。
第六章：
1、容斥原理：S中不具有P1，P2...Pn任何一个属性的元素有如下多个：
具备任何一种属性中的其中一种的元素有如下多个：
2、错位排列：给定n个数，从1到n，将这n个数排列起来，若任何一个数都不在他的自然位置上，则称这个排列是一个错位排列。例如312，因为1不在第一个位置，2不在第二个位置，3不在第三个位置，所以这是一个错位排列。
我们定义为n个数的错位排列数，则根据容斥原理可得为：
3、带禁止位置的排列：给定N个位置和N个集合，每个位置对应一个集合，带禁止位置的排列就是指，该位置对应的集合中的元素不能在该位置上。当对应的集合中的元素就只有该位置时，带禁止位置的排列就等价于错位排列。
求带禁止位置的排列的时候，当禁止位置的数量不多时，可采用容斥原理来解，但是当禁止位置数量很多时，用容斥原理求解起来很麻烦，因为禁止位置多的时候，求解反问题和原问题复杂度是相同的，因此需要换一种思路来求解这个问题。
4、棋盘多项式：带禁止位置的排列可看成在一个NXN的棋盘上放置N个带禁止位置的非攻击性車（这些車相互之间是有区别的），则在该棋盘上放置N个車的排列数为：
其中是k个非攻击性車放在相对应的禁止位置上的方法数，现在问题就转换成了如何求解。
下面我们用棋盘多项式来求解,定义在为棋盘C上放K个非攻击性車的方法数。如：
进一步，我们定义:
,
其中是做位置保持的，对于来说，有以下两条性质：
(1) .也就是说，我们可以选定一个方格，然后原棋盘多项式就等于x乘以去掉该方格所在的行和列的棋盘多项式，再加上只去掉这个方格的棋盘多项式，来对一个很大的棋盘进行分解。例如：
(2)，其中和是相互独立的两部分。也就是说，如果一个棋盘可以分解成两个相互独立的部分，则原棋盘多项式就等于这两个独立棋盘多项式的乘积。
由以上两条性质，我们可知求解棋盘多项式时，我们应该尽可能挑选那些让棋盘分成两个独立部分的方格，来一步步使原问题变成一个个可直接求解的子问题。例如：
第七章：递推关系式和生成函数
1、线性齐次递推关系式
存在，以及，使得：则称这个数列满足K阶线性递推关系式。
进一步，如果，都为常数,且=0，我们称该递推关系式为线性齐次递推关系式。针对线性齐次递推关系式，我们可用以下方法求解：
为：
用替换,替换,依次类推，即得到如下关系式：
第一种情况：如果该方程有k个互异的根，则可以表示为:,为的一般表达式，即非递推表达式。（其中等根据已知的值代入求解）例如：
代入的值即可求出.
第二种情况：该方程有个重根，如果是该方程的重根，那么，其中例如：
2、生成函数：无穷级数是无穷数列的生成函数，其中是位置保持，是的系数。生成函数的系数即是我们所求解问题的解。
3、用生成函数求解线性齐次递推关系式的。求解时会用到牛顿二项式定理，先在这里说明一下，
下面给个例子：
4、一个例子
求凸多边形的三角划分：设是有n&#43;1条边的凸多边形，则根据该问题可得：
进一步可得：（后面会知道，这是一个特殊计数序列Catalan数）
5、指数生成函数
将生成函数中的换成即为指数生成函数，即每一项都除以自身幂次的阶乘，具体的形式为：
该生成函数用来做位置保持，刚好对应于排列，因此指数生成函数是用来求解排列问题的。
下面给个例子;
总结：这章介绍了如何用生成函数来求解递归定义的数列，其中生成函数用来求组合问题(与容斥原理不同点在于生成函数通常是求带有要求的无限多个元素的组合问题，例如取偶数个，取奇数个)，指数生成函数用来求排列问题。
第八章：特殊计数序列
1、Catalan数
该数的实际意义是：将n个-1和n个1这2n个数排成一个序列，从中任取前k个数，这k个数的和大于等于零的排列数。
2、差分序列
给定一个数的序列，差分.二阶差分,依此类推，可以得到三阶差分、四阶差分。这些差分所构成的表称为差分表。且如果是多项式，则差分表不会无限循环下去，若是p阶多项式，则第P&#43;1阶差分一定为0.
当是p阶多项式时，可由差分表的第0条对角线确定。
，其中是第0条对角线上的K阶差分。例如：
且有该序列的前n项和为：
3、Stirling数（这里介绍的是第二类Stirling）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d8976eee6ab18455b6dfb8b7f7ae1c36/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-11-14T20:34:21+08:00" />
<meta property="article:modified_time" content="2019-11-14T20:34:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">组合数学</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>下列所有的符号中，如果没有特殊说明，则n表示集合中所有元素的个数、r表示所取的元素个数，k表示种类数。</p> 
<p>第一章：</p> 
<p>绪论，介绍了为什么要研究组合数学，以及组合数学的三个研究内容。</p> 
<hr> 
<p>第二章：</p> 
<p>鸽巢原理：把N+1个鸽子放到N个巢里面，则至少有一个巢里面有两只鸽子。</p> 
<p>推论：如果把N个物体放到K个盒子当中，则至少有一个盒子里面有N/k取上界个物体。</p> 
<p>例子：Ramsey数</p> 
<hr> 
<p>第三章：</p> 
<p>1、集合的排列：P（n，r）、集合的循环排列：P(n,r)/r、集合的组合：C（n，r）</p> 
<p>2、多重集合的排列：1、每个元素有无限多个，取r个：K^r——有K种元素，也就是说每个位置有K种选择，取r个。</p> 
<p>                             2、每个元素是有限个，全排列数：N！/N1!N2!...Nk!。</p> 
<p>                             3、每个元素是有限个，取r个的排列数：用后面章节的生成函数(指数生成函数)求解</p> 
<p>3、多重集合的组合：1、每个元素有无限多个：C(r+k-1,r)</p> 
<p>                                  2、每个元素是有限个：用后面章节的容斥原理来求，用容斥原理将有限个转换成无限多个（最多取多少个转换成至少取多少个）。</p> 
<hr> 
<p>第四章：</p> 
<p>1、活动数：给数标一个方向，如果这个数比他所指方向的那个数大，那么这个数就叫做活动数。</p> 
<p>2、生成排列（全排列）：活动数法，1、找到一个最大的活动数，2、将这个数与他所指方向的那个数互换位置，3、将所有比他大的数的方向转换。重复这三步，直到所有的数都不是活动数。</p> 
<p>3、逆序数：给定一个数的序列，如果Xi&gt;Xj且i&lt;j。则称这两个数为一个逆序对，用ai表示数字i的逆序对的个数，也叫逆序数。</p> 
<p>              算法1：通过相对位置和从大的数到小的数的逆序数来确定具体序列：i前面有ai个逆序对。</p> 
<p>              算法2：通过从小的数到大的数逆序数来直接确定具体序列：i直接放在第ai+1个空位上。</p> 
<p>4、生成组合：通过2进制的+1来生成所有的组合。</p> 
<p>5、生成r-组合：按字典序来排序，<img alt="a_1a_2...a_r" class="mathcode" src="https://images2.imgbox.com/f2/b9/iuO5kU6w_o.gif">的直接后继是<img alt="a_1...a_{k-1}(a_k+1)(a_k+2)...(a_k+r-k+1)" class="mathcode" src="https://images2.imgbox.com/a8/83/kkzq0djq_o.gif">.直接前驱是<img alt="a_1...a_{k-1}(a_k-1)(n-r+k+1)...(n)" class="mathcode" src="https://images2.imgbox.com/ce/b8/nN60OERc_o.gif">。其中后继的<img alt="a_k+1" class="mathcode" src="https://images2.imgbox.com/ba/4d/uJweH8vc_o.gif">不与原序列任何一个数重复，前驱的<img alt="a_k-1" class="mathcode" src="https://images2.imgbox.com/11/51/suofqGL8_o.gif">也是如此。</p> 
<p>6、生成r-排列：先生成r-组合，然后对每个组合进行全排列。</p> 
<hr> 
<p>第六章：</p> 
<p>1、容斥原理：S中不具有P1，P2...Pn任何一个属性的元素有如下多个：</p> 
<p><img alt="" class="has" height="195" src="https://images2.imgbox.com/a8/96/jbU1dtRv_o.png" width="566"></p> 
<p>具备任何一种属性中的其中一种的元素有如下多个：</p> 
<p><img alt="" class="has" height="183" src="https://images2.imgbox.com/43/6f/HuGO7Y2K_o.png" width="550"></p> 
<p>2、错位排列：给定n个数，从1到n，将这n个数排列起来，若任何一个数都不在他的自然位置上，则称这个排列是一个错位排列。例如312，因为1不在第一个位置，2不在第二个位置，3不在第三个位置，所以这是一个错位排列。</p> 
<p>我们定义<img alt="D_n" class="mathcode" src="https://images2.imgbox.com/ee/dd/HuwpLtGj_o.gif">为n个数的错位排列数，则根据容斥原理可得<img alt="D_n" class="mathcode" src="https://images2.imgbox.com/7d/91/dbol2nEG_o.gif">为：</p> 
<p><img alt="" class="has" height="166" src="https://images2.imgbox.com/4e/cb/i7CQB4L6_o.png" width="423"></p> 
<p>3、带禁止位置的排列：给定N个位置和N个集合，每个位置对应一个集合，带禁止位置的排列就是指，该位置对应的集合中的元素不能在该位置上。当对应的集合中的元素就只有该位置时，带禁止位置的排列就等价于错位排列。</p> 
<p>求带禁止位置的排列的时候，当禁止位置的数量不多时，可采用容斥原理来解，但是当禁止位置数量很多时，用容斥原理求解起来很麻烦，因为禁止位置多的时候，求解反问题和原问题复杂度是相同的，因此需要换一种思路来求解这个问题。</p> 
<p>4、棋盘多项式：带禁止位置的排列可看成在一个NXN的棋盘上放置N个带禁止位置的非攻击性車（这些車相互之间是有区别的），则在该棋盘上放置N个車的排列数为：</p> 
<p><img alt="n!-r_1(n-1)!+r_2(n-2)!-...+(-1)^kr_k(n-k)!+...+(-1)^nr_n" class="mathcode" src="https://images2.imgbox.com/83/61/MtXZIQNf_o.gif"></p> 
<p>其中<img alt="r_k" class="mathcode" src="https://images2.imgbox.com/fa/1e/pwo8Bko8_o.gif">是k个非攻击性車放在相对应的禁止位置上的方法数，现在问题就转换成了如何求解<img alt="r_k" class="mathcode" src="https://images2.imgbox.com/db/1a/fy0vWgXl_o.gif">。</p> 
<p>下面我们用棋盘多项式来求解<img alt="r_k" class="mathcode" src="https://images2.imgbox.com/14/ea/msL5JXiZ_o.gif">,<img alt="r_k(C)" class="mathcode" src="https://images2.imgbox.com/eb/94/bwIEsfzK_o.gif">定义在为棋盘C上放K个非攻击性車的方法数。如：</p> 
<p><img alt="" class="has" height="123" src="https://images2.imgbox.com/ff/74/vfXoUgmx_o.png" width="321"></p> 
<p>进一步，我们定义:</p> 
<p><img alt="R(C)=\sum_{k=0}^{\infty }r_k(C)x^k" class="mathcode" src="https://images2.imgbox.com/b3/e8/UI1xQVEi_o.gif">,</p> 
<p>其中<img alt="x^k" class="mathcode" src="https://images2.imgbox.com/62/dc/10JDUGhv_o.gif">是做位置保持的，对于<img alt="R(C)" class="mathcode" src="https://images2.imgbox.com/9a/33/PRC2zVhu_o.gif">来说，有以下两条性质：</p> 
<p>(1) <img alt="R(C)=xR(C_i)+R(C_e)" class="mathcode" src="https://images2.imgbox.com/f8/f4/OfF29V1F_o.gif">.也就是说，我们可以选定一个方格，然后原棋盘多项式就等于x乘以去掉该方格所在的行和列的棋盘多项式，再加上只去掉这个方格的棋盘多项式，来对一个很大的棋盘进行分解。例如：</p> 
<p><img alt="" class="has" height="191" src="https://images2.imgbox.com/41/95/nznpt9qI_o.png" width="301"></p> 
<p>(2)<img alt="R(C)=R(C_1)R(C_2)" class="mathcode" src="https://images2.imgbox.com/80/96/Zupte1uv_o.gif">，其中<img alt="C_1" class="mathcode" src="https://images2.imgbox.com/53/63/F4aSUdCn_o.gif">和<img alt="C_2" class="mathcode" src="https://images2.imgbox.com/30/78/jhZNo3Rc_o.gif">是相互独立的两部分。也就是说，如果一个棋盘可以分解成两个相互独立的部分，则原棋盘多项式就等于这两个独立棋盘多项式的乘积。</p> 
<p>由以上两条性质，我们可知求解棋盘多项式时，我们应该尽可能挑选那些让棋盘分成两个独立部分的方格，来一步步使原问题变成一个个可直接求解的子问题。例如：</p> 
<p><img alt="" class="has" height="205" src="https://images2.imgbox.com/fb/9f/O09llVwC_o.png" width="383"></p> 
<hr> 
<p>第七章：递推关系式和生成函数</p> 
<p>1、线性齐次递推关系式</p> 
<p>存在<img alt="a_1,a_2...a_k" class="mathcode" src="https://images2.imgbox.com/90/a9/2m0yccWJ_o.gif">，<img alt="a_k\neq 0" class="mathcode" src="https://images2.imgbox.com/98/9f/ZF0p0qfv_o.gif">以及<img alt="b_n" class="mathcode" src="https://images2.imgbox.com/25/f5/p7AUAgKh_o.gif">，使得：<img alt="h_n=a_1h_{n-1}+a_2h_{n-2}+...+a_kh_{n-k}+b_n,(n\geqslant k)." class="mathcode" src="https://images2.imgbox.com/62/3d/oPYeBzbp_o.gif">则称这个数列满足K阶线性递推关系式。</p> 
<p>进一步，如果<img alt="a_k\neq 0" class="mathcode" src="https://images2.imgbox.com/17/51/suSYGlqJ_o.gif">，<img alt="a_1,a_2...a_k" class="mathcode" src="https://images2.imgbox.com/a5/fd/KxQYqRsk_o.gif">都为常数,且<img alt="b_n" class="mathcode" src="https://images2.imgbox.com/50/c4/KWjrLwSE_o.gif">=0，我们称该递推关系式为线性齐次递推关系式。针对线性齐次递推关系式，我们可用以下方法求解：</p> 
<p><img alt="h_n" class="mathcode" src="https://images2.imgbox.com/c8/aa/DI2XkjgI_o.gif">为：<img alt="h_n=a_1h_{n-1}+a_2h_{n-2}+...+a_kh_{n-k}+b_n,(n\geqslant k)." class="mathcode" src="https://images2.imgbox.com/6f/0c/46Fch6pD_o.gif"></p> 
<p>用<img alt="x^k" class="mathcode" src="https://images2.imgbox.com/27/1a/iBdWcugc_o.gif">替换<img alt="h_n" class="mathcode" src="https://images2.imgbox.com/2d/10/1SRirYaP_o.gif">,<img alt="x^{k-1}" class="mathcode" src="https://images2.imgbox.com/8c/5e/kZVfF7ma_o.gif">替换<img alt="h_{n-1}" class="mathcode" src="https://images2.imgbox.com/c0/7f/zgmPjzWW_o.gif">,依次类推，即得到如下关系式：</p> 
<p><img alt="x^k-a_1x^{k-1}-a_2x^{k-2}-...-a_k=0" class="mathcode" src="https://images2.imgbox.com/0c/1e/fBQZcQQc_o.gif"></p> 
<p>第一种情况：如果该方程有k个互异的根，则<img alt="h_n" class="mathcode" src="https://images2.imgbox.com/53/73/rNVkrQcy_o.gif">可以表示为:<img alt="h_n=c_1q_1^n+c_2q_2^n+...+c_kq_k^n" class="mathcode" src="https://images2.imgbox.com/00/7a/7lv2vfid_o.gif">,为<img alt="h_n" class="mathcode" src="https://images2.imgbox.com/f6/0a/gkecNcTP_o.gif">的一般表达式，即非递推表达式。（其中<img alt="c_1,c_2,c_k" class="mathcode" src="https://images2.imgbox.com/1f/db/G5816T0P_o.gif">等根据已知的值代入求解）例如：</p> 
<p><img alt="" class="has" height="191" src="https://images2.imgbox.com/14/16/XZ26IpRx_o.png" width="353"></p> 
<p>代入<img alt="h_0,h_1,h_2" class="mathcode" src="https://images2.imgbox.com/6e/b7/DxEpx5Lt_o.gif">的值即可求出<img alt="c_1,c_2,c_3" class="mathcode" src="https://images2.imgbox.com/1e/3a/iBIRfhos_o.gif">.</p> 
<p>第二种情况：该方程有<img alt="t" class="mathcode" src="https://images2.imgbox.com/67/d6/ssOoOI2r_o.gif">个重根，如果<img alt="q_i" class="mathcode" src="https://images2.imgbox.com/ab/11/8WKzxDoT_o.gif">是该方程的<img alt="s_i" class="mathcode" src="https://images2.imgbox.com/f9/2b/vW3a8M1P_o.gif">重根，那么<img alt="h_n=H_n^{(1)}+H_n^{(2)}+...+H_n^{(t)}" class="mathcode" src="https://images2.imgbox.com/8e/58/cSaKm6jQ_o.gif">，其中<img alt="H_n^i=c_1q_i^n+c_2nq_i^n+...+c_{si}n^{si-1}q_i^n=(c_1+c_2n+...+c_{si}n^{si-1})q_i^n" class="mathcode" src="https://images2.imgbox.com/e7/36/VCEQA7jT_o.gif">例如：</p> 
<p><img alt="" class="has" height="195" src="https://images2.imgbox.com/ab/8e/0dc39wbL_o.png" width="352"></p> 
<p>2、生成函数：无穷级数<img alt="g(x)=h_0+h_1x+h_2x^2+...+h_nx^n+..." class="mathcode" src="https://images2.imgbox.com/68/20/WI1IVwi3_o.gif">是无穷数列<img alt="h_0,h_1,h_2,...,h_n" class="mathcode" src="https://images2.imgbox.com/e0/20/FUlxPkGp_o.gif">的生成函数，其中<img alt="x^k" class="mathcode" src="https://images2.imgbox.com/6a/9b/bNLUbGaY_o.gif">是位置保持，<img alt="h_k" class="mathcode" src="https://images2.imgbox.com/67/0f/qnlOqTRo_o.gif">是<img alt="x^k" class="mathcode" src="https://images2.imgbox.com/52/2f/8p8NdfOT_o.gif">的系数。生成函数的系数即是我们所求解问题的解。</p> 
<p><img alt="" class="has" height="234" src="https://images2.imgbox.com/13/97/dc6YK6Jf_o.png" width="381"></p> 
<p>3、用生成函数求解线性齐次递推关系式的<img alt="h_n" class="mathcode" src="https://images2.imgbox.com/c3/41/pJUsitu8_o.gif">。求解时会用到牛顿二项式定理，先在这里说明一下，<img alt="(1-rx)^{-n}=\sum_{k=0}^{\infty }\binom{n+k-1}{k}r^kx^k" class="mathcode" src="https://images2.imgbox.com/a5/fc/PuQyiNMQ_o.gif"></p> 
<p>下面给个例子：</p> 
<p><img alt="" class="has" height="190" src="https://images2.imgbox.com/86/8b/fDK4J41i_o.png" width="359"><img alt="" class="has" height="282" src="https://images2.imgbox.com/1e/5f/3rXIOqI4_o.png" width="357"></p> 
<p><img alt="" class="has" height="238" src="https://images2.imgbox.com/45/6e/5vDKhm0C_o.png" width="364"></p> 
<p>4、一个例子</p> 
<p>求凸多边形的三角划分：设<img alt="h_n" class="mathcode" src="https://images2.imgbox.com/89/d4/x1GBCy0Z_o.gif">是有n+1条边的凸多边形，则根据该问题可得：</p> 
<p><img alt="h_n=h_1h_{n-1}+h_2h_{n-2}+...+h_{n-1}h_1,(n\geq 2)." class="mathcode" src="https://images2.imgbox.com/84/4d/zQDZueZp_o.gif"></p> 
<p>进一步可得：<img alt="h_n=\frac{1}{n}\binom{2n-2}{n-1}(n=1,2,3...)" class="mathcode" src="https://images2.imgbox.com/63/e1/0HXFTTUl_o.gif">（后面会知道，这是一个特殊计数序列Catalan数）</p> 
<p>5、指数生成函数</p> 
<p>将生成函数中的<img alt="x^n" class="mathcode" src="https://images2.imgbox.com/5d/7a/i7rnDGuk_o.gif">换成<img alt="\frac{x^n}{n!}" class="mathcode" src="https://images2.imgbox.com/40/8a/QvjuGpl5_o.gif">即为指数生成函数，即每一项都除以自身幂次的阶乘，具体的形式为：</p> 
<p><img alt="g^{(e)}(x)=\sum_{n=0}^{\infty }h_n\frac{x^n}{n!}=h_0+h_1x+h_2\frac{x^2}{2!}+...+h_n\frac{x^n}{n!}+..." class="mathcode" src="https://images2.imgbox.com/bc/5e/bYcgFJTm_o.gif"></p> 
<p>该生成函数用<img alt="\frac{x^n}{n!}" class="mathcode" src="https://images2.imgbox.com/e2/db/RTXKrIjW_o.gif">来做位置保持，刚好对应于排列，因此指数生成函数是用来求解排列问题的。</p> 
<p>下面给个例子;</p> 
<p><img alt="" class="has" height="293" src="https://images2.imgbox.com/72/04/zRg4rGXP_o.png" width="474"></p> 
<p><img alt="" class="has" height="352" src="https://images2.imgbox.com/6c/e8/EAxA6Mqy_o.png" width="488"></p> 
<p>总结：这章介绍了如何用生成函数来求解递归定义的数列，其中生成函数用来求组合问题(与容斥原理不同点在于生成函数通常是求带有要求的无限多个元素的组合问题，例如<img alt="x_1" class="mathcode" src="https://images2.imgbox.com/b2/07/CYEzzO3U_o.gif">取偶数个，<img alt="x_2" class="mathcode" src="https://images2.imgbox.com/7b/66/jPZf8ubI_o.gif">取奇数个)，指数生成函数用来求排列问题。</p> 
<hr> 
<p>第八章：特殊计数序列</p> 
<p>1、Catalan数</p> 
<p><img alt="C_n=\frac{1}{n+1}\binom{2n}{n},(n=0,1,2...)" class="mathcode" src="https://images2.imgbox.com/d9/da/0th7whSJ_o.gif"></p> 
<p>该数的实际意义是：将n个-1和n个1这2n个数排成一个序列，从中任取前k个数，这k个数的和大于等于零的排列数。</p> 
<p>2、差分序列</p> 
<p>给定一个数的序列<img alt="h_0,h_1,h_2,...,h_n" class="mathcode" src="https://images2.imgbox.com/c4/a4/x9c2hVLy_o.gif">，差分<img alt="\Delta h_n=h_{n+1}-h_n,(n\geq 0)" class="mathcode" src="https://images2.imgbox.com/84/4f/6vbdpHLz_o.gif">.二阶差分<img alt="\Delta (\Delta h_n)=\Delta h_{n+1}-\Delta h_n,(n\geq 0)" class="mathcode" src="https://images2.imgbox.com/77/69/2EzNcJ9M_o.gif">,依此类推，可以得到三阶差分、四阶差分。这些差分所构成的表称为差分表。且如果<img alt="h_n" class="mathcode" src="https://images2.imgbox.com/30/a4/Am5KO5PG_o.gif">是多项式，则差分表不会无限循环下去，若<img alt="h_n" class="mathcode" src="https://images2.imgbox.com/37/82/yFEPy3gO_o.gif">是p阶多项式，则第P+1阶差分一定为0.</p> 
<p>当<img alt="h_n" class="mathcode" src="https://images2.imgbox.com/3e/23/h7Zhsj0W_o.gif">是p阶多项式时，<img alt="h_n" class="mathcode" src="https://images2.imgbox.com/ec/76/1bSiKzL5_o.gif">可由差分表的第0条对角线确定。</p> 
<p><img alt="h_n=c_0C(n,0)+c_1C(n,1)+...+c_pC(n,p)" class="mathcode" src="https://images2.imgbox.com/2d/fd/QDZivuoU_o.gif">，其中<img alt="c_k" class="mathcode" src="https://images2.imgbox.com/1a/0c/v5GiuYvS_o.gif">是第0条对角线上的K阶差分。例如：</p> 
<p><img alt="" class="has" height="265" src="https://images2.imgbox.com/30/0f/Kzm8bvxT_o.png" width="410"></p> 
<p>且有该序列的前n项和为：</p> 
<p><img alt="\sum _{k=0}^nh_k=c_0\binom{n+1}{1}+c_1\binom{n+1}{2}+...+c_p\binom{n+1}{p+1}" class="mathcode" src="https://images2.imgbox.com/f2/e8/UwEoP332_o.gif"></p> 
<p>3、Stirling数（这里介绍的是第二类Stirling）</p> 
<p>假设<img alt="h_n=n^p" class="mathcode" src="https://images2.imgbox.com/5b/4c/VZbtwZ59_o.gif">,差分表的0零对角线上的元素为c(p,0)、c(p,1)、c(p,p)，则第二类Stirling数定义为：</p> 
<p><img alt="S(p,k)=\frac{c(p,k)}{k!} ,(0\leq k\leq p)" class="mathcode" src="https://images2.imgbox.com/08/2f/F9CZQmkN_o.gif"></p> 
<p>且有：<img alt="S(p,k)=kS(p-1,k)+S(p-1,k-1)" class="mathcode" src="https://images2.imgbox.com/b6/d8/okMEYQFA_o.gif"></p> 
<p>该数的实际意义是把P个物品放到K个不加相互区分的盒子里，且没有哪个盒子是空的，这样的放置的方法数。</p> 
<p>如果这些盒子相互区分，那么就有<img alt="S^\#(p,k)=p!S(p,k)" class="mathcode" src="https://images2.imgbox.com/2a/3d/DugMeDQE_o.gif">,即再讲这些盒子全排列。</p> 
<p>4、Bell数</p> 
<p>Bell数<img alt="B_p" class="mathcode" src="https://images2.imgbox.com/14/77/BckyugLH_o.gif">是将p个物品放到非空的相互区分的盒子里的方法数。因此有：</p> 
<p><img alt="B_p=S(p,0)+S(p,1)+...+S(p,p)" class="mathcode" src="https://images2.imgbox.com/7b/e8/86ranht6_o.gif"></p> 
<p>5、划分数</p> 
<p>将一个正整数划分成一个或多个正整数的和（划分出来的数相互之间是没有顺序的），这样的划分的种数。定义为<img alt="P_n" class="mathcode" src="https://images2.imgbox.com/1b/ca/yiorU7Qn_o.gif">,<img alt="P_n" class="mathcode" src="https://images2.imgbox.com/70/46/vSxYiPDr_o.gif">的生成函数为：</p> 
<p><img alt="\sum _{n=0}^\infty p_nx^n=\prod _{k=1}^\infty (1-x^k)^{-1}" class="mathcode" src="https://images2.imgbox.com/ba/0a/d9bjqiZN_o.gif"></p> 
<p><span style="color:#f33b45;">总结：本章一共介绍了五个特殊计数序列，分别是：(1)Catalan数:把n个-1，n个+1排列起来，且任取前K个，他们的和都不小于零的方法数；(2)第二类Stirling数:将p个元素放到k个不加区分的非空盒子里的方法数；(3)Bell数:将P个元素放到非空盒子里的方法数；(4)第一类Stirling数:把p个元素放到k个非空的循环排列中的方法数；(5)划分数:将一个正整数划分成一个或多个正整数的和的方法数。</span></p> 
<hr> 
<p>第九章：二部图的匹配问题</p> 
<p>1、通用问题模型</p> 
<p>给定一个二部图G(X,Y,<img alt="\Delta" class="mathcode" src="https://images2.imgbox.com/fc/c9/gp16MDyC_o.gif">),对于之前的求非攻击性車的放置数、以及多米诺骨牌的覆盖问题，都可以用二部图的匹配来解。</p> 
<p>非攻击性車：X、Y分别是行和列坐标的集合，如果某行某列的位置上可以放置一个非攻击性車，则这两点之间有一条边，那么非攻击性車的放置问题就对应于一个二部图的匹配问题。</p> 
<p>多米诺骨牌的覆盖问题：给定一个带禁止位置的棋盘B，求该棋盘的多米诺骨牌覆盖。我们可以通过这种方式来求解此问题，用黑白两色给该棋盘着色，要求为黑色格子的周围是白色格子，白色格子的周围是黑色格子，即相邻两个格子的颜色不能相同，X为黑色格子的集合，Y为白色格子的集合，若这两个格子之间有共同的边，这这两个点之间有一条边。那么多米诺骨牌的覆盖问题也就成了该二部图的匹配问题。</p> 
<p>任务分配：X、Y分别是人和任务的集合，如果某一个任务分配给了某个人，则这两者之间有一条边。那么任务分配问题也就成了一个二部图的匹配问题。</p> 
<p>由上可见，二部图可用来解很多实际问题，且这些问题都可以转换为二部图的匹配问题，下面介绍二部图的匹配。</p> 
<p>2、匹配</p> 
<p>极大匹配：不能再加边的匹配。最大匹配：极大匹配中的最大值。</p> 
<p>路径：点各不相同的点边序列（除了起始点和结束点可以相同之外），如果起始点和结束点相同，则称之为一个循环。</p> 
<p>M渗透点与M非渗透点：给定一个匹配M，如果某一点与该匹配中的边相关联，则称之为M渗透点，如果没有与之关联，则称之为M非渗透点。</p> 
<p>M交错路径：给定一个匹配M，M交错路径指的是该路径上的边是前一条在M中，下一条不在M中，依次交替出现的。</p> 
<p>M增广路径：起始点和结束点都是M非渗透点的M交错路径。由此可知，M增广路径上不在M中的边的条数比在M中的边的条数多1</p> 
<p>有了以上的概念之后，我们对一个增广路径一直增广，即可得到一个最大匹配，其中增广的方法为用该路径上不在M中的边替换该路径上在M中的边，得到一个新的集合M，即M'=(M-Mr)U<img alt="\overline{M}" class="mathcode" src="https://images2.imgbox.com/16/4b/yjIkrc4o_o.gif">,M’比M的边数多一。</p> 
<p>3、Holl定理</p> 
<p>如果存在一个渗透集合X的匹配，当且仅当|N(S)|&gt;=|S|对于所有的S<img alt="\subseteq" class="mathcode" src="https://images2.imgbox.com/32/c8/KcJ7Jv6T_o.gif">X。即如果一个匹配包括了集合X中的所有点，当且仅当该集合任意子集的邻居节点个数不少于该子集中点的个数。成婚定理也是这个意思。</p> 
<p>完备匹配：包含了二部图中所有的点的匹配叫做一个完备匹配。</p> 
<p>K正则图：二部图G中所有点的度数都是K。K正则图一定存在一个完备匹配。</p> 
<p>点覆盖：一个点的集合，图G中的任意一条边都能在该集合中找到一个与之关联的点。</p> 
<p>最小点覆盖：点覆盖中点数最少的覆盖称为点覆盖。</p> 
<p>4、Konig定理：二部图的最小点覆盖数等于最大边匹配数。</p> 
<p>5、求最大匹配（最小覆盖）的算法：（1）将所有的M非渗透点标记为*，并且称这些点为未扫描的点（2）对X中所有新标记的点进行扫描，如果不存在新标记的点，则算法停止；否则扫描所有新标记的点，将与<img alt="X_i" class="mathcode" src="https://images2.imgbox.com/73/28/pTOrrI0I_o.gif">通过不属于M中的边相连的点标记为<img alt="X_i" class="mathcode" src="https://images2.imgbox.com/ff/05/GrOGCdAf_o.gif">，扫描完所有新标记的点之后进入下一步（3）如果Y中没有新标记的点，则算法停止，否则扫描Y中所有新标记的点，将与<img alt="Y_i" class="mathcode" src="https://images2.imgbox.com/6a/68/X81aGIUL_o.gif">通过在M中的边相连的点标记为<img alt="Y_i" class="mathcode" src="https://images2.imgbox.com/d7/8e/x4AGuMWR_o.gif">，扫描完所有的点之后进入步骤（2）。</p> 
<p>突破点：Y中存在一个标记了但无法扫描过去的点，这样的点称为突破点。当出现突破点时，可以对该路径进行增广。</p> 
<p>非突破点：X中存在一个标记了但无法扫描过去的点，这样的点称为非突破点，当非突破点出现时，该路径为最大匹配。</p> 
<p>6、互异代表系统</p> 
<p>Y是一个有限集合，<img alt="A=(A_1,A_2,A_3...A_n)" class="mathcode" src="https://images2.imgbox.com/c6/80/6jZUl3S5_o.gif">是Y的n个子集族，从每个子集族中找一个元素代表该子集族，如果这n个代表元素互不相同，则称之为一个互异代表系统。</p> 
<p>易知，互异代表系统并不总是存在的。当且仅当满足成婚定理时，该子集族有互异代表系统；即从该子集族中任选K个子集族，这K个子集族的并的元素不少于K个时，该子集族存在互异代表系统。</p> 
<p>当这N个子集族不存在互异代表系统时，存在互异代表系统的最大子集族的个数可由下列式子中最小的值给出：</p> 
<p><img alt="|A_{i1}\cup A_{i2}\cup...\cup A_{ik}|+n-k,(k=1,2,3,..n)" class="mathcode" src="https://images2.imgbox.com/4f/bb/FGtQB0cw_o.gif"></p> 
<p>7、稳定婚姻</p> 
<p>给定一个优先排名矩阵，使用延迟认可算法可以得到一个稳定婚姻。该算法可分为女士优先和男士优先两种情况，算法步骤为：</p> 
<p>（女士优先）只要存在被拒绝的女士，就进行以下操作：</p> 
<p>（1）对所有被拒绝的女士来说，找一位排名最高的且没有拒绝她的男士与之匹配。</p> 
<p>（2）对每一个男士来说，从选择了他的女士当中挑选一位排名最高的女士延迟认可，拒绝其他所有女士。 </p> 
<hr> 
<p>第十章：区组设计</p> 
<p>1、模运算</p> 
<p>给定一个非负整数集合<img alt="Z_n=\{0,1,2,3,4,5,...,n-1\}" class="mathcode" src="https://images2.imgbox.com/44/ae/1jL5c2ag_o.gif">，定义在该集合上的两个操作，模加和模乘运算。即该集合是一个域，因为模加和模乘这两种操作保证了参与运算的数在经过运算后依然还在这个集合中。</p> 
<p>定义了模运算及域之后，还需要定义加法逆元和乘法逆元，使得这个运算系统能进行通常的四则运算。</p> 
<p>加法逆元：如果a+b=0,则称b是a的加法逆元，反过来，a也是b的加法逆元。</p> 
<p>乘法逆元：如果aXb=1，则称b是a的乘法逆元，记做<img alt="a^{-1}" class="mathcode" src="https://images2.imgbox.com/e4/2a/XkliBn2g_o.gif">。</p> 
<p>（此处的加法和乘法都是指的模加和模乘，即定义在该集合上的加法和乘法），易知，并不是域中的所有元素都有乘法逆元，只有当该元素与n互素时才存在乘法逆元。我们可用辗转相除法来求两个数的公因数，当公因数为1时，这两个数互素，我们可以根据该算法得到某个元素的乘法逆元。例如：</p> 
<p><img alt="" class="has" height="290" src="https://images2.imgbox.com/62/06/n6IN37AW_o.png" width="478"></p> 
<p>2、域及伴随多项式</p> 
<p>给定一个素数<img alt="p" class="mathcode" src="https://images2.imgbox.com/19/26/WteHYcDh_o.gif">和整数<img alt="k\geq 2" class="mathcode" src="https://images2.imgbox.com/30/54/NhfAgrmU_o.gif">,我们可以通过添加元素的方法从域<img alt="Z_p" class="mathcode" src="https://images2.imgbox.com/c8/ba/zCWeSE1H_o.gif">出发构造一个具有<img alt="P^k" class="mathcode" src="https://images2.imgbox.com/1e/db/JzC6iCxg_o.gif">个元素的域,该域中的元素为：<img alt="\{a+bi+ci^2+...+di^{k-1}:a,b,c...d\quad in\quad Z_p\}" class="mathcode" src="https://images2.imgbox.com/3b/e9/KOJvjb4h_o.gif">。构造方法为找到一个在<img alt="Z_p" class="mathcode" src="https://images2.imgbox.com/a2/53/EDKvzavu_o.gif">中没有解的<img alt="k" class="mathcode" src="https://images2.imgbox.com/37/35/EakKu4ak_o.gif">阶多项式，该多项式被称为<img alt="Z_p" class="mathcode" src="https://images2.imgbox.com/7e/b2/hOL8Ipv8_o.gif">的伴随多项式，该伴随多项式的要求为系数和方程的解都是取自<img alt="Z_p" class="mathcode" src="https://images2.imgbox.com/34/90/8j2ZJso0_o.gif">的。然后我们可以通过该多项式和<img alt="Z_p" class="mathcode" src="https://images2.imgbox.com/d9/4f/mpYhEYAH_o.gif">来构造一个新的域，下面给个例子说明这种构造方法：</p> 
<p><img alt="" class="has" height="224" src="https://images2.imgbox.com/f3/7e/MaHIDnN6_o.png" width="382"></p> 
<p>3、区组设计</p> 
<p>区组设计：给产品分组，但在分组时需要满足某些特定要求。下面给一个例子说明这些特殊要求：</p> 
<p><img alt="" class="has" height="201" src="https://images2.imgbox.com/a8/be/fcwHKFjC_o.png" width="385"></p> 
<p>即7种产品分成7组，要求每组中有3个产品，且每一对产品只出现一次，这样要求的分组该怎么设计，即每一组里面是哪几件产品。</p> 
<p>模型建立：给定<img alt="v" class="mathcode" src="https://images2.imgbox.com/54/54/fN7ocNZ4_o.gif">件产品，<img alt="" class="mathcode" src="https://images2.imgbox.com/9f/bc/RalHdoCN_o.png"><img alt="b" class="mathcode" src="https://images2.imgbox.com/21/a9/u7WoL400_o.gif">个区组，要求设计一个这样的分组方式：每个区组中有<img alt="k" class="mathcode" src="https://images2.imgbox.com/66/4b/shT1ORvG_o.gif">个元素，每个元素出现<img alt="r" class="mathcode" src="https://images2.imgbox.com/63/39/RWlVW8Au_o.gif">次，每对元素出现<img alt="\lambda" class="mathcode" src="https://images2.imgbox.com/6f/43/MPproNVI_o.gif">次，<img alt="\lambda" class="mathcode" src="https://images2.imgbox.com/27/5d/tcqmwobI_o.gif">称之为设计指数。当每个区组中包含的元素个数相同时，我们称之为一个平衡区组设计；当k=v时，我们称之为完全区组设计，在这种情况下，每个区组之间是相互独立的，因为每个区组都包含了所有的元素，这种情况在实际中没有研究价值，因此我们研究的都是平衡不完全区组设计，简写为：BIBD，即每个区组中元素个数相同(平衡的)，但小于<img alt="v" class="mathcode" src="https://images2.imgbox.com/b2/b6/WS2RGpgM_o.gif">(不完全)的区组设计。此外，当<img alt="b=v" class="mathcode" src="https://images2.imgbox.com/96/8e/kVSRIeM5_o.gif">时，称之为对称平衡不完全区组设计，简称：SBIBD.</p> 
<p>BIBD的四条性质：(1)<img alt="r=\frac{\lambda (v-1)}{k-1}" class="mathcode" src="https://images2.imgbox.com/5d/ba/eMFBSnDz_o.gif">(从元素对的角度)(2)<img alt="bk=vr" class="mathcode" src="https://images2.imgbox.com/95/44/MJvtInpo_o.gif">(从单个元素的角度)(3)<img alt="\lambda &lt; r" class="mathcode" src="https://images2.imgbox.com/24/22/CXmVhZhS_o.gif">(4)<img alt="b\geq v" class="mathcode" src="https://images2.imgbox.com/2d/2a/p2khWRS8_o.gif"></p> 
<p>4、区组设计方法</p> 
<p>(1)从一个给定的起始区组开始递增，该起始区组需要满足：起始区组中的任意两个元素做差对<img alt="v" class="mathcode" src="https://images2.imgbox.com/3c/28/a6gkdVPx_o.gif">取模的值出现的次数相同。即<img alt="x-y\quad (x,y\ in\ B;x\neq y)" class="mathcode" src="https://images2.imgbox.com/f1/ba/ZW9jGF1R_o.gif">的值出现的次数相同。例如：</p> 
<p><img alt="" class="has" height="250" src="https://images2.imgbox.com/ec/81/fW8tCDj9_o.png" width="410"></p> 
<p>(2)根据Steiner三元系统来构造一个新的Steiner三元系统。</p> 
<p>k=3的平衡区组设计称为Steiner三元系统，如果存在一个元素个数为<img alt="v" class="mathcode" src="https://images2.imgbox.com/5e/b5/v24mDtyk_o.gif">和一个元素个数为<img alt="w" class="mathcode" src="https://images2.imgbox.com/b1/23/ADe5KZJW_o.gif">的Steiner三元系统，且设计指数<img alt="\lambda" class="mathcode" src="https://images2.imgbox.com/d2/7c/pB5JKHRl_o.gif">都为1，那么就可以根据这两个三元系统设计一个个数为<img alt="vw" class="mathcode" src="https://images2.imgbox.com/50/55/Q8ErB7F9_o.gif">,<img alt="\lambda" class="mathcode" src="https://images2.imgbox.com/61/69/sQA3SpWJ_o.gif">=1的三元系统。如果一个设计指数<img alt="\lambda" class="mathcode" src="https://images2.imgbox.com/90/a9/nGzWA98C_o.gif">=1的三元系统可以分成几个部分，并且每个部分都包含所有的元素，那么称这个三元系统是可解的，每个部分称之为一个可解类。</p> 
<p>具体方法为：假设<img alt="a_1,a_2,..,a_v" class="mathcode" src="https://images2.imgbox.com/24/d5/mDT89HQ1_o.gif">是个数为<img alt="v" class="mathcode" src="https://images2.imgbox.com/9a/42/9JmQeRPZ_o.gif">的三元系统A，<img alt="b_1,b_2,...,b_w" class="mathcode" src="https://images2.imgbox.com/36/04/bTzEHVeu_o.gif">是个数为<img alt="w" class="mathcode" src="https://images2.imgbox.com/66/b1/pJqUraSb_o.gif">的另一个三元系统B。以A中元素为行，B中元素为列，拼成一个矩阵。</p> 
<p>（1）该矩阵中在同一行的且属于B中的某个区组的三个元素构成一个新的区组</p> 
<p>（2）该矩阵中在同一列的且属于A中的某个区组的三个元素构成一个新的区组</p> 
<p>（3）该矩阵中在不同行和不同列的，且既属于A中的某个区组又属于B中的某个区组的三个元素构成一个新的区组</p> 
<p>把符合这三个条件的区组拼起来就可以得到一个个数为<img alt="vw" class="mathcode" src="https://images2.imgbox.com/7f/7b/x8VJkOMw_o.gif">的新的区组。</p> 
<p>(3)根据拉丁方构造区组</p> 
<p>拉丁方：拉丁方是集合S上一个<img alt="n\times n" class="mathcode" src="https://images2.imgbox.com/4d/e4/INp0ZV5E_o.gif">的矩阵，该矩阵每行和每列的元素都取自S，且都各不相同。</p> 
<p>构造拉丁方：（1）设n是一个正整数，<img alt="a_{ij}=i+j\ mod\ n" class="mathcode" src="https://images2.imgbox.com/a8/46/nKWnAYfe_o.gif">,这样得到的一个矩阵是一个拉丁方</p> 
<p>                      （2）设n是一个正整数，r是<img alt="Z_n" class="mathcode" src="https://images2.imgbox.com/6d/6f/E11eUh0r_o.gif">中的一个和n互素的数，<img alt="a_{ij}=r*i+j\ mod\ n" class="mathcode" src="https://images2.imgbox.com/18/62/3292uOJy_o.gif">，这样得到的矩阵也是拉丁方。用这种方法得到的拉丁方我们记为：<img alt="L_n^r" class="mathcode" src="https://images2.imgbox.com/27/f9/5vmK2pDT_o.gif"></p> 
<p>正交拉丁方：如果A、B是<img alt="Z_n" class="mathcode" src="https://images2.imgbox.com/9d/5b/5ixnVxOX_o.gif">上的两个拉丁方，在并置矩阵AXB中，如果<img alt="Z_n" class="mathcode" src="https://images2.imgbox.com/6b/69/6DOKjmZm_o.gif">中的每一个序偶（A、B的对应位置拼成一个元组，第一个元素来自A，第二个元素来自B）恰好只出现一次，那么就称这两个拉丁方是正交的，记做MOLS。易知，不存在正交的2阶拉丁方。<img alt="R_n" class="mathcode" src="https://images2.imgbox.com/b7/4f/zZBmb2b4_o.gif">和<img alt="S_n" class="mathcode" src="https://images2.imgbox.com/22/0d/eZTuFNph_o.gif">是两个特殊的矩阵：</p> 
<p><img alt="" class="has" height="140" src="https://images2.imgbox.com/e4/95/Xgc1yyRf_o.png" width="266"><img alt="" class="has" height="143" src="https://images2.imgbox.com/33/6e/UXSq5I3x_o.png" width="235"></p> 
<p>当n是一个素数时，<img alt="L_n^1,L_n^2,L_n^3,...,L_n^{n-1}" class="mathcode" src="https://images2.imgbox.com/74/d9/xZbcKfx2_o.gif">是n-1个n阶MOLS；</p> 
<p>当n不是一个素数时，我们可以根据之前扩展域的方式来得到n-1个n阶MOLS，设F为<img alt="n=p^k" class="mathcode" src="https://images2.imgbox.com/05/a2/1EWWtqjc_o.gif">个元素的有限域，p是一个素数，k是一个正整数，假设<img alt="a_0=0,a_1,a_2,...,a_{n-1}" class="mathcode" src="https://images2.imgbox.com/fb/17/bVGhyjQ3_o.gif">是F中的元素，那么<img alt="a_{ij}=a_r\times a_i+a_j" class="mathcode" src="https://images2.imgbox.com/3f/e5/7KZMQ8s9_o.gif">,这样得到的矩阵是一个拉丁方。且根据这种方法得到的n-1个拉丁方是相互正交的。下面给个例子：</p> 
<p><img alt="" class="has" height="312" src="https://images2.imgbox.com/67/b1/F0VpOxCa_o.png" width="532"></p> 
<p>构造拉丁方：给定n-1个n阶的互相正交的拉丁方(MOLS),以及上面给的<img alt="R_n" class="mathcode" src="https://images2.imgbox.com/6e/18/SCuvITZB_o.gif">和<img alt="S_n" class="mathcode" src="https://images2.imgbox.com/40/d3/NCl9BWP1_o.gif">,我们可以这样构造一个BIBD：<img alt="R_n(i),S_n(i),A_1(i),,A_2(i),...,,A_{n-1}(i),i=0,1,2,...,n-1" class="mathcode" src="https://images2.imgbox.com/2e/40/laXyvHUo_o.gif">,这样得到的区组的参数是:<img alt="b=n^2+n,v=n^2,k=n,r=n+1,\lambda =1" class="mathcode" src="https://images2.imgbox.com/c9/71/vaqZKjgm_o.gif">；反之，如果存在参数形如上式的可解BIBD，则存在n-1个n阶MOLS。</p> 
<p>下面给个例子：</p> 
<p><img alt="" class="has" height="191" src="https://images2.imgbox.com/01/bb/jFYGesYl_o.png" width="382"><img alt="" class="has" height="187" src="https://images2.imgbox.com/67/b8/sUoiXpMV_o.png" width="209"></p> 
<p><span style="color:#f33b45;">总结：这张介绍了区组设计，以及如何进行区组设计，总共有三种办法，第一种是从一个初始区组开始递增、第二种是用两个Steiner三元系统设计、最后一种是用正交拉丁方。</span></p> 
<hr> 
<p>第14章：Polya计数</p> 
<p>1、置换：一种映射，记为<img alt="f" class="mathcode" src="https://images2.imgbox.com/85/b1/A20bUh0q_o.gif">，将集合<img alt="S_n" class="mathcode" src="https://images2.imgbox.com/a3/52/3JkSgE2L_o.gif">中的数<img alt="k" class="mathcode" src="https://images2.imgbox.com/d6/53/SXaXdZIv_o.gif">映射到<img alt="i_k" class="mathcode" src="https://images2.imgbox.com/09/c0/THs1dgOa_o.gif">,该映射是一个满射，集合中所有的点映射完之后还在该集合中。</p> 
<p>2、置换群：置换的集合，该集合满足三条性质：1、两个置换的复合还在该集合中。2、一定存在恒等置换3、任一置换有逆置换</p> 
<p>3、对称群：集合<img alt="S_n" class="mathcode" src="https://images2.imgbox.com/bb/93/AzOGAqfT_o.gif">上的所有置换的集合称之为对称群。</p> 
<p>4、着色方案：C是一个着色方案，C(1)、C(2)、...、C(n)是给n的点着色，着成C(i)的颜色。</p> 
<p>5、<img alt="(f\ast c)(i_k)=c(k)" class="mathcode" src="https://images2.imgbox.com/e7/8f/qmgWbE90_o.gif">，该公式的意思是将位置<img alt="i_k" class="mathcode" src="https://images2.imgbox.com/17/db/Ltv92jJi_o.gif">着成<img alt="c(k)" class="mathcode" src="https://images2.imgbox.com/f7/df/m9UaLmZ0_o.gif">的颜色。即将置换作用在着色方法上，点不变，着色方案按照置换映射到一个新的着色方案。如：</p> 
<p><img alt="" class="has" height="251" src="https://images2.imgbox.com/2d/f8/KZdwbCcQ_o.png" width="424"></p> 
<p>6、等价的着色方案：如果着色方案<img alt="c_1" class="mathcode" src="https://images2.imgbox.com/77/67/G5cka2YU_o.gif">经过某种置换<img alt="f" class="mathcode" src="https://images2.imgbox.com/be/ce/pv5ptgib_o.gif">后等于<img alt="c_1" class="mathcode" src="https://images2.imgbox.com/b3/d3/sC8YQyTg_o.gif">，那么称这两个置换时等价的，即:如果<img alt="f*c_1=c_2" class="mathcode" src="https://images2.imgbox.com/26/0b/UU1YpxSD_o.gif">,那么<img alt="c_1" class="mathcode" src="https://images2.imgbox.com/01/3d/sWYgE873_o.gif">与<img alt="c_2" class="mathcode" src="https://images2.imgbox.com/56/e6/X9JyzDWm_o.gif">等价.</p> 
<p>7、Burnside定理：我们可以通过这个定理来计算C中的非等价的着色方法数：</p> 
<p><img alt="N(G,C)=\frac{1}{|G|}\sum _{f\epsilon G}|C(f)|" class="mathcode" src="https://images2.imgbox.com/03/d9/5wf09Kli_o.gif"><br> 其中N(G,C)表示的是非等价的着色方案数，X是一个集合，如正方形的顶点的集合；G是X的置换群；C是X中满足以下条件的着色集合：对于G中所有的置换<img alt="f" class="mathcode" src="https://images2.imgbox.com/35/4e/3i0aOX5S_o.gif">和C中所有的<img alt="c" class="mathcode" src="https://images2.imgbox.com/3f/2b/KZj0hZRm_o.gif">都有<img alt="f*c" class="mathcode" src="https://images2.imgbox.com/18/de/PuCEzElp_o.gif">仍然在C中；C(<img alt="f" class="mathcode" src="https://images2.imgbox.com/5f/10/gd5yi8z8_o.gif">)是在<img alt="f" class="mathcode" src="https://images2.imgbox.com/a0/11/qPsRB37h_o.gif">作用下保持不变的着色方案的集合；</p> 
<p>8、Polya计数</p> 
<p>(1)循环因子：置换<img alt="f" class="mathcode" src="https://images2.imgbox.com/ab/49/DEg62vqe_o.gif">可用几个循环来表示，这些循环被称为循环因子。例如：8阶二面体上的置换群<img alt="D_4" class="mathcode" src="https://images2.imgbox.com/ef/09/73408NeE_o.gif"></p> 
<p><img alt="" class="has" height="311" src="https://images2.imgbox.com/ff/ef/xERVcZB8_o.png" width="279"></p> 
<p>(2)由循环因子可知，对于某个置换来说，只要循环因子的个数确定了，那么不变的着色方案数也就确定了。因为同一个循环因子内的元素必须是同色，否则在经过该置换后着色方案就和之前不等价了。记#<img alt="f" class="mathcode" src="https://images2.imgbox.com/4b/3c/JFualdk2_o.gif">为置换<img alt="f" class="mathcode" src="https://images2.imgbox.com/12/d4/ArmikZnt_o.gif">的循环因子数。继续以上述例子为例：</p> 
<p><img alt="" class="has" height="349" src="https://images2.imgbox.com/5b/90/WQguTEQG_o.png" width="519"><img alt="" class="has" height="68" src="https://images2.imgbox.com/71/fb/hiTF7GIw_o.png" width="378"></p> 
<p>（3）type:我们用<img alt="e_i" class="mathcode" src="https://images2.imgbox.com/8b/0d/gqADEOUP_o.gif">表示元素个数为<img alt="i" class="mathcode" src="https://images2.imgbox.com/30/84/jLnZdqdH_o.gif">的循环因子个数，那么对于任意一个作用在n个元素上的置换来说，我们可以用元组(<img alt="e_1,e_2,...,e_n" class="mathcode" src="https://images2.imgbox.com/99/86/92Pgkc5t_o.gif">)来表示这个置换的循环因子，因为循环因子里面具体是哪些元素对我们计算<img alt="|C(f)|" class="mathcode" src="https://images2.imgbox.com/e5/c6/Ju4J3RyZ_o.gif">来说没有影响。我们用<img alt="Z_i" class="mathcode" src="https://images2.imgbox.com/df/51/4dcmkcbC_o.gif">做<img alt="e_i" class="mathcode" src="https://images2.imgbox.com/10/75/wkwR1mYr_o.gif">的位置保持，那么就可以得到置换<img alt="f" class="mathcode" src="https://images2.imgbox.com/bb/c5/6qLFk4AG_o.gif">的单项表示，将所有置换的单项表示累加起来除以|G|，就可以得到整个置换的生成函数。还是上面那个例子：</p> 
<p><img alt="" class="has" height="316" src="https://images2.imgbox.com/8a/57/DhZThpUi_o.png" width="533"><img alt="" class="has" height="31" src="https://images2.imgbox.com/97/50/CuIqjYwX_o.png" width="363"></p> 
<p>如果用K种颜色给这个二面体着色，那么非等价的着色方案数<img alt="|N(G,C)|=P_G(k,k,...,k)" class="mathcode" src="https://images2.imgbox.com/3c/06/NHf8z0IG_o.gif">。</p> 
<p>进一步，如果我们要求一个给特定数量的点着色的方案数，我们只需要用以下方法就可以得到：假设用K种颜色给X中的元素着色，那么生成函数为<img alt="P_G(u_1+...+u_k,u_1^2+...+u_k^2,...,u_1^n+...+u_k^n)" class="mathcode" src="https://images2.imgbox.com/ae/34/dOnIhlHm_o.gif">，即用<img alt="u_1^i+u_2^i+...+u_k^i" class="mathcode" src="https://images2.imgbox.com/52/56/G642Z9Ym_o.gif">替换<img alt="Z_i" class="mathcode" src="https://images2.imgbox.com/05/47/4a3ZNbm3_o.gif">。然后就可以得到给特定数量的点着色的方案数，还是上面那个例子，我们根据这种方法得到的新的生成函数为：</p> 
<p><img alt="" class="has" height="216" src="https://images2.imgbox.com/b2/8a/UqF2BNli_o.png" width="592"></p> 
<p>由这个生成可得，如果要两个点红色两个点绿色，那么就是两种。即<img alt="r^i,b^i" class="mathcode" src="https://images2.imgbox.com/38/cb/BRXSmyLd_o.gif">是做未知保持的，幂次指的是用这种颜色着色的点的个数，系数指的是方案数。</p> 
<p>附：求一个图形对应的循环因子时，如果元素个数是偶数，则在求旋转置换时，会存在某几个点内部构成循环的情况；如果元素个数是奇数，则不存在这种情况，也就是旋转置换只能是所有元素构成一个循环因子，但是如果是偶数则有的情况会有多个循环因子，例如<img alt="\rho _4^2" class="mathcode" src="https://images2.imgbox.com/7c/ab/0X7IsJeF_o.gif">,有两个元素为2的循环因子。</p> 
<p><span style="color:#f33b45;">总结：这章介绍了如何求一个集合上的非等价着色方案数，BurnSide定理给出了求解的具体公式，而polya计数公式则给出了给特定数量的点着特定颜色的具体公式，相当于是Burnside公式的拓展。</span></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/afe546aa9c944ced214d7cf321ea98d3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">element-ui上传组件（el-upload）单文件上传，单选文件 覆盖已有文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/39247d32f61f2adaa0d9a2d1a585dbbf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL大数据量分页limit优化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>