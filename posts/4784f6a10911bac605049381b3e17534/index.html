<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android加密之文件级加密 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android加密之文件级加密" />
<meta property="og:description" content="Android加密之文件级加密 前置文章 《Android加密之全盘加密》
《Android系统之System Server大纲》
前言 Android 的安全性问题一直备受关注，Google 在 Android 系统的安全方面也是一直没有停止过更新，努力做到更加安全的手机移动操作系统。
在 Android 的安全性方面，有很多模块：
内核安全性应用安全性应用签名身份验证Trusty TEESELinux加密 等等 其中，加密又分全盘加密（Android 4.4 引入，《Android加密之全盘加密》）和文件级加密（Android 7.0 引入），本文将论述加密中的文件级加密的基本知识。
什么是文件级加密 Android 7.0 及更高版本支持文件级加密 (FBE)。采用文件级加密时，可以使用不同的密钥对不同的文件进行加密，并且可以对这些文件进行单独解密。
全盘加密和文件级加密的区别 借助文件级加密，Android 7.0 中引入了一项称为直接启动的新功能。该功能处于启用状态时，已加密设备在启动后将直接进入锁定屏幕。之前，在使用全盘加密 (FDE) 的已加密设备上，用户在访问任何数据之前都需要先提供凭据，从而导致手机无法执行除最基本操作之外的所有其他操作。例如，闹钟无法运行，无障碍服务不可用，手机无法接电话，而只能进行基本的紧急拨号操作。 文件级加密概述 引入文件级加密 (FBE) 和新 API 后，便可以将应用设为加密感知型应用，这样一来，它们将能够在受限环境中运行。这些应用将可以在用户提供凭据之前运行，同时系统仍能保护私密用户信息。
在启用了 FBE 的设备上，每位用户均有两个可供应用使用的存储位置：
凭据加密 (CE) 存储空间：这是默认存储位置，只有在用户解锁设备后才可用。设备加密 (DE) 存储空间：在直接启动模式期间以及用户解锁设备后均可用。 这种区分能够使工作资料更加安全，因为这样一来，加密不再只基于启动时密码，从而能够同时保护多位用户。
Direct Boot API 允许加密感知型应用访问上述每个区域。应用生命周期会发生一些变化，以便在用户的 CE 存储空间因用户在锁定屏幕上首次输入凭据而解锁时，或者在工作资料提供工作挑战时，通知应用。无论是否实现了 FBE，运行 Android 7.0 的设备都必须要支持这些新的 API 和生命周期。不过，如果没有 FBE，DE 和 CE 存储空间将始终处于解锁状态。 启用文件级加密 通过将不带参数的 fileencryption 标记添加到 userdata 分区最后一列的 fstab 行中，可以启用 FBE。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4784f6a10911bac605049381b3e17534/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-08-11T11:30:21+08:00" />
<meta property="article:modified_time" content="2017-08-11T11:30:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android加密之文件级加密</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="android加密之文件级加密">Android加密之文件级加密</h2> 
<h3 id="前置文章">前置文章</h3> 
<p><a href="http://blog.csdn.net/myfriend0/article/details/76615114">《Android加密之全盘加密》</a></p> 
<p><a href="http://blog.csdn.net/myfriend0/article/details/55098173">《Android系统之System Server大纲》</a></p> 
<h3 id="前言">前言</h3> 
<p>Android 的安全性问题一直备受关注，Google 在 Android 系统的安全方面也是一直没有停止过更新，努力做到更加安全的手机移动操作系统。</p> 
<p>在 Android 的安全性方面，有很多模块：</p> 
<ol><li>内核安全性</li><li>应用安全性</li><li>应用签名</li><li>身份验证</li><li>Trusty TEE</li><li>SELinux</li><li>加密 <br> 等等</li></ol> 
<p>其中，加密又分全盘加密（Android 4.4 引入，<a href="http://blog.csdn.net/myfriend0/article/details/76615114">《Android加密之全盘加密》</a>）和文件级加密（Android 7.0 引入），本文将论述加密中的文件级加密的基本知识。</p> 
<h3 id="什么是文件级加密">什么是文件级加密</h3> 
<p>Android 7.0 及更高版本支持文件级加密 (FBE)。采用文件级加密时，可以使用不同的密钥对不同的文件进行加密，并且可以对这些文件进行单独解密。</p> 
<h3 id="全盘加密和文件级加密的区别">全盘加密和文件级加密的区别</h3> 
<p>借助文件级加密，Android 7.0 中引入了一项称为直接启动的新功能。该功能处于启用状态时，已加密设备在启动后将直接进入锁定屏幕。之前，在使用全盘加密 (FDE) 的已加密设备上，用户在访问任何数据之前都需要先提供凭据，从而导致手机无法执行除最基本操作之外的所有其他操作。例如，闹钟无法运行，无障碍服务不可用，手机无法接电话，而只能进行基本的紧急拨号操作。 </p> 
<h3 id="文件级加密概述">文件级加密概述</h3> 
<p>引入文件级加密 (FBE) 和新 API 后，便可以将应用设为加密感知型应用，这样一来，它们将能够在受限环境中运行。这些应用将可以在用户提供凭据之前运行，同时系统仍能保护私密用户信息。</p> 
<p>在启用了 FBE 的设备上，每位用户均有两个可供应用使用的存储位置：</p> 
<ul><li>凭据加密 (CE) 存储空间：这是默认存储位置，只有在用户解锁设备后才可用。</li><li>设备加密 (DE) 存储空间：在直接启动模式期间以及用户解锁设备后均可用。</li></ul> 
<p>这种区分能够使工作资料更加安全，因为这样一来，加密不再只基于启动时密码，从而能够同时保护多位用户。</p> 
<p>Direct Boot API 允许加密感知型应用访问上述每个区域。应用生命周期会发生一些变化，以便在用户的 CE 存储空间因用户在锁定屏幕上首次输入凭据而解锁时，或者在工作资料提供工作挑战时，通知应用。无论是否实现了 FBE，运行 Android 7.0 的设备都必须要支持这些新的 API 和生命周期。不过，如果没有 FBE，DE 和 CE 存储空间将始终处于解锁状态。 </p> 
<h3 id="启用文件级加密">启用文件级加密</h3> 
<p>通过将不带参数的 fileencryption 标记添加到 userdata 分区最后一列的 fstab 行中，可以启用 FBE。</p> 
<h3 id="直接启动感知型应用">直接启动感知型应用</h3> 
<p>为了实现系统应用的快速迁移，新增了两个可在应用级别设置的属性。defaultToDeviceProtectedStorage 属性仅适用于系统应用，directBootAware 属性则适用于所有应用。</p> 
<p></p> 
<h3 id="启用文件级加密的条件">启用文件级加密的条件</h3> 
<ul><li>对 EXT4 加密的内核支持（内核配置选项：EXT4_FS_ENCRYPTION）</li><li>基于 1.0 或 2.0 版 HAL 的 Keymaster 支持。不支持 Keymaster 0.3，因为它既不提供必要的功能，也不能保证为加密密钥提供充分保护。</li><li>必须在可信执行环境 (TEE) 中实现 Keymaster/Keystore 和 Gatekeeper，以便为 DE 密钥提供保护，从而使未经授权的操作系统（刷到设备上的定制操作系统）无法直接请求 DE 密钥。</li><li>内核加密性能必须要在使用 AES XTS 时至少达到 50MB/s，以确保良好的用户体验。</li><li>硬件信任根和验证启动需要绑定到 Keymaster 初始化进程，以确保未经授权的操作系统无法获取设备加密凭据。</li></ul> 
<h3 id="加密过程">加密过程</h3> 
<h4 id="密钥创建">密钥创建</h4> 
<p>首次创建设备的 userdata 分区时，会由 init 脚本应用基本结构和政策。这些脚本将触发创建首位用户（用户 0）的 CE 密钥和 DE 密钥，并定义要使用这些密钥加密哪些目录。创建其他用户和资料时，会生成必要的其他密钥并将其存储在密钥代码库中；接下来会创建它们的凭据和设备存储位 置，并且加密政策会将这些密钥关联到相应目录。 </p> 
<h5 id="de密钥">DE密钥</h5> 
<p>触发 late-init action</p> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">// 开机执行init.cpp，</span>
<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv) {
    ......
    <span class="hljs-comment">// 解析 init.rc file</span>
    Parser&amp; parser = Parser::GetInstance();
    parser.ParseConfig(<span class="hljs-string">"/init.rc"</span>);

    <span class="hljs-comment">// Don't mount filesystems or start core system services in charger mode.</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> bootmode = property_get(<span class="hljs-string">"ro.bootmode"</span>);
    <span class="hljs-keyword">if</span> (bootmode == <span class="hljs-string">"charger"</span>) {
        am.QueueEventTrigger(<span class="hljs-string">"charger"</span>);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 触发 late-init action</span>
        am.QueueEventTrigger(<span class="hljs-string">"late-init"</span>);
    }
    ......
}</code></pre> 
<p>这个方法定义在文件 system/core/init/init.cpp 中。</p> 
<p>触发 post-fs-data</p> 
<pre class="prettyprint"><code class="language-bash hljs ">on late-init
    .....
    trigger post-fs
    <span class="hljs-comment"># Now we can mount /data. File encryption requires keymaster to decrypt</span>
    <span class="hljs-comment"># /data, which in turn can only be loaded when system properties are present</span>
    trigger post-fs-data
    .....</code></pre> 
<p>这个 action 定义在文件 system/core/rootdir/init.rc 中。</p> 
<p>执行 installkey 命令</p> 
<pre class="prettyprint"><code class="language-bash hljs ">on post-fs-data
    chown system system /data
    chmod <span class="hljs-number">0771</span> /data
    <span class="hljs-comment"># Make sure we have the device encryption key.</span>
    start vold
    <span class="hljs-comment">#执行 installkey 命令</span>
    installkey /data</code></pre> 
<p>这个 action 定义在文件 system/core/rootdir/init.rc 中。</p> 
<p>命令 installkey 实质执行 do_installkey 函数</p> 
<pre class="prettyprint"><code class="language-cpp hljs ">BuiltinFunctionMap::Map&amp; BuiltinFunctionMap::<span class="hljs-built_in">map</span>() <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::size_t kMax = <span class="hljs-built_in">std</span>::numeric_limits&lt;<span class="hljs-built_in">std</span>::size_t&gt;::max();
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> Map builtin_functions = {
        .....
        {<!-- --><span class="hljs-string">"installkey"</span>,              {<!-- --><span class="hljs-number">1</span>,     <span class="hljs-number">1</span>,    do_installkey}},
        {<!-- --><span class="hljs-string">"load_persist_props"</span>,      {<!-- --><span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,    do_load_persist_props}},
        .....
    };
    <span class="hljs-keyword">return</span> builtin_functions;</code></pre> 
<p>这个方法定义在文件 system/core/init/builtins.cpp 中。</p> 
<p>do_installkey() 函数定义如下</p> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">// 是否是 文件级加密</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> is_file_crypto() {
    <span class="hljs-comment">// 文件级加密 ro.crypto.type 的值是 file， 全盘加密是 block</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> value = property_get(<span class="hljs-string">"ro.crypto.type"</span>);
    <span class="hljs-keyword">return</span> value == <span class="hljs-string">"file"</span>;
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> do_installkey(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;</span>&amp; args) {
    <span class="hljs-comment">// 检查是否是文件级加密</span>
    <span class="hljs-keyword">if</span> (!is_file_crypto()) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-comment">// 创建密钥</span>
    <span class="hljs-keyword">return</span> e4crypt_create_device_key(args[<span class="hljs-number">1</span>].c_str(),
                                     do_installkeys_ensure_dir_exists);
}</code></pre> 
<p>这个方法定义在文件 system/core/init/builtins.cpp 中。</p> 
<p>ro.crypto.type 在函数 do_mount_all() 中设置 </p> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> do_mount_all(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;</span>&amp; args) {
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == FS_MGR_MNTALL_DEV_FILE_ENCRYPTED) {
        <span class="hljs-keyword">if</span> (e4crypt_install_keyring()) {
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }
        property_set(<span class="hljs-string">"ro.crypto.state"</span>, <span class="hljs-string">"encrypted"</span>);
        <span class="hljs-comment">//文件级加密</span>
        property_set(<span class="hljs-string">"ro.crypto.type"</span>, <span class="hljs-string">"file"</span>);
}</code></pre> 
<p>这个方法定义在文件 system/core/init/builtins.cpp 中。</p> 
<p>回到 do_installkey() 函数，e4crypt_create_device_key() 定义如下</p> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> e4crypt_create_device_key(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* dir,
                              <span class="hljs-keyword">int</span> ensure_dir_exists(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*))
{
    init_logging();
    .....
    <span class="hljs-comment">// 执行 vdc， 传入命令 enablefilecrypto， 同时需要注意参数 cryptfs</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* argv[] = { <span class="hljs-string">"/system/bin/vdc"</span>, <span class="hljs-string">"--wait"</span>, <span class="hljs-string">"cryptfs"</span>, <span class="hljs-string">"enablefilecrypto"</span> };
    <span class="hljs-comment">// 从 init， 到 vdc， 注意参数 argv[]</span>
    <span class="hljs-keyword">int</span> rc = android_fork_execvp(<span class="hljs-number">4</span>, (<span class="hljs-keyword">char</span>**) argv, NULL, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);
    LOG(INFO) &lt;&lt; <span class="hljs-string">"enablefilecrypto result: "</span> &lt;&lt; rc;
    <span class="hljs-keyword">return</span> rc;
}</code></pre> 
<p>这个方法定义在文件 system/extras/ext4_utils/ext4_crypt_init_extensions.cpp 中。</p> 
<p>android_fork_execvp() 实质是调用函数 android_fork_execvp_ext()</p> 
<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> android_fork_execvp(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[], <span class="hljs-keyword">int</span> *status,
                                     <span class="hljs-keyword">bool</span> ignore_int_quit, <span class="hljs-keyword">bool</span> logwrap)
{
    <span class="hljs-comment">// 实质是调用函数这个函数</span>
    <span class="hljs-keyword">return</span> android_fork_execvp_ext(argc, argv, status, ignore_int_quit,
                                   (logwrap ? LOG_ALOG : LOG_NONE), <span class="hljs-keyword">false</span>, NULL,
                                   NULL, <span class="hljs-number">0</span>);
}</code></pre> 
<p>这个方法定义在文件 system/core/logwrapper/include/logwrap/logwrap.h 中。</p> 
<p>函数 android_fork_execvp_ext() 的实现如下</p> 
<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">int</span> android_fork_execvp_ext(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[], <span class="hljs-keyword">int</span> *status, <span class="hljs-keyword">bool</span> ignore_int_quit,
        <span class="hljs-keyword">int</span> log_target, <span class="hljs-keyword">bool</span> abbreviated, <span class="hljs-keyword">char</span> *file_path,
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> AndroidForkExecvpOption* opts, size_t opts_len) {
    <span class="hljs-comment">// fork 一个新的进程运行 vdc 程序</span>
    pid = fork();
    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) {
        .....
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) {
        .....
        <span class="hljs-comment">// fork 进程成功， 执行函数 child()</span>
        child(argc, argv);
    } <span class="hljs-keyword">else</span> {

}</code></pre> 
<p>这个方法定义在文件 system/core/logwrapper/logwrap.c 中。</p> 
<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> child(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[]) {
    <span class="hljs-comment">// create null terminated argv_child array</span>
    <span class="hljs-keyword">char</span>* argv_child[argc + <span class="hljs-number">1</span>];
    <span class="hljs-built_in">memcpy</span>(argv_child, argv, argc * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span> *));
    argv_child[argc] = NULL;
    <span class="hljs-comment">// 开始运行 vdc 程序，参数 cryptfs， enablefilecrypto</span>
    <span class="hljs-comment">// 从 init 进程，进入到 vdc 进程</span>
    <span class="hljs-keyword">if</span> (execvp(argv_child[<span class="hljs-number">0</span>], argv_child)) {
        FATAL_CHILD(<span class="hljs-string">"executing %s failed: %s\n"</span>, argv_child[<span class="hljs-number">0</span>],
                strerror(errno));
    }
}</code></pre> 
<p>这个方法定义在文件 system/core/logwrapper/logwrap.c 中。</p> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv) {
    <span class="hljs-comment">// 定义待连接的 socket 标识</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* sockname = <span class="hljs-string">"vold"</span>;
    <span class="hljs-comment">//在上面的参数中 argv[1] 等于 cryptfs， 所以 socket name 等于 cryptd</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"cryptfs"</span>)) {
        sockname = <span class="hljs-string">"cryptd"</span>;
    }
    <span class="hljs-comment">// 等待连接到 vold</span>
    <span class="hljs-keyword">while</span> ((sock = socket_local_client(sockname,
                                 ANDROID_SOCKET_NAMESPACE_RESERVED,
                                 SOCK_STREAM)) &lt; <span class="hljs-number">0</span>) {
        .....
    }
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"monitor"</span>)) {
        <span class="hljs-built_in">exit</span>(do_monitor(sock, <span class="hljs-number">0</span>));
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//argv[1] 等于 cryptfs， 执行函数 do_cmd()</span>
        <span class="hljs-built_in">exit</span>(do_cmd(sock, argc, argv));
    }
}</code></pre> 
<p>这个方法定义在文件 system/vold/vdc.cpp 中。</p> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> do_cmd(<span class="hljs-keyword">int</span> sock, <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv) {
    .....
    <span class="hljs-comment">// 写入 socket，注意参数 cmd.c_str()</span>
    <span class="hljs-keyword">if</span> ((write(sock, cmd.c_str(), cmd.length() + <span class="hljs-number">1</span>)) &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Failed to write command: %s\n"</span>, strerror(errno));
        <span class="hljs-keyword">return</span> errno;
    }
    <span class="hljs-keyword">return</span> do_monitor(sock, seq);
}</code></pre> 
<p>这个方法定义在文件 system/vold/vdc.cpp 中。</p> 
<p>socket 写入数据到远程后，执行到 vold 进程</p> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> CryptCommandListener::CryptfsCmd::runCommand(SocketClient *cli,
                                                 <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv) {
    <span class="hljs-keyword">if</span> (subcommand == <span class="hljs-string">"checkpw"</span>) {
        .....
    } 
    ..... 
    <span class="hljs-comment">//传入的命令是 enablefilecrypto</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (subcommand == <span class="hljs-string">"enablefilecrypto"</span>) {
        <span class="hljs-keyword">if</span> (!check_argc(cli, subcommand, argc, <span class="hljs-number">2</span>, <span class="hljs-string">""</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        dumpArgs(argc, argv, -<span class="hljs-number">1</span>);
        rc = cryptfs_enable_file();
    }  
    .....                                             
}</code></pre> 
<p>这个方法定义在文件 system/vold/CryptCommandListener.cpp 中。</p> 
<p>函数 cryptfs_enable_file() 定义如下</p> 
<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">int</span> cryptfs_enable_file()
{
    <span class="hljs-keyword">return</span> e4crypt_initialize_global_de();
}</code></pre> 
<p>这个函数定义在文件 system/vold/cryptfs.c 中。</p> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">bool</span> e4crypt_initialize_global_de() {
    .....
    <span class="hljs-comment">// device_key_path = /data/unencrypted/key/</span>
    <span class="hljs-keyword">if</span> (path_exists(device_key_path)) {
        <span class="hljs-keyword">if</span> (!android::vold::retrieveKey(device_key_path,
                kEmptyAuthentication, &amp;device_key)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    } <span class="hljs-keyword">else</span> {
        LOG(INFO) &lt;&lt; <span class="hljs-string">"Creating new key"</span>;
        <span class="hljs-comment">// 创建 密钥</span>
        <span class="hljs-keyword">if</span> (!random_key(&amp;device_key)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-comment">//　保存密钥</span>
        <span class="hljs-keyword">if</span> (!store_key(device_key_path, device_key_temp,
                kEmptyAuthentication, device_key)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> device_key_ref;
    <span class="hljs-comment">//存储在密钥代码库中</span>
    <span class="hljs-keyword">if</span> (!install_key(device_key, &amp;device_key_ref)) {
        LOG(ERROR) &lt;&lt; <span class="hljs-string">"Failed to install device key"</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
    <span class="hljs-comment">// 应用密钥</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ref_filename = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"/data"</span>) + e4crypt_key_ref;
    <span class="hljs-keyword">if</span> (!android::base::WriteStringToFile(device_key_ref, ref_filename)) {
        PLOG(ERROR) &lt;&lt; <span class="hljs-string">"Cannot save key reference"</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }

    s_global_de_initialized = <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
<p>DE密钥创建过程就分析到这里。</p> 
<h5 id="ce密钥">CE密钥</h5> 
<p>同样在 init.rc 的 post-fs-data action 中</p> 
<pre class="prettyprint"><code class="language-bash hljs ">on post-fs-data
    .....
    installkey /data
    .....
    执行 init_user0 命令
    init_user0
    .....</code></pre> 
<p>这个 action 定义在文件 system/core/rootdir/init.rc 中。</p> 
<p>init_user0 实质是执行函数 </p> 
<pre class="prettyprint"><code class="language-cpp hljs ">BuiltinFunctionMap::Map&amp; BuiltinFunctionMap::<span class="hljs-built_in">map</span>() <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::size_t kMax = <span class="hljs-built_in">std</span>::numeric_limits&lt;<span class="hljs-built_in">std</span>::size_t&gt;::max();
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> Map builtin_functions = {
    .....
    {<!-- --><span class="hljs-string">"ifup"</span>,                    {<!-- --><span class="hljs-number">1</span>,     <span class="hljs-number">1</span>,    do_ifup}},
    <span class="hljs-comment">//执行 do_init_user0() 函数</span>
    {<!-- --><span class="hljs-string">"init_user0"</span>,              {<!-- --><span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,    do_init_user0}},
    .....
}</code></pre> 
<p>这个方法定义在文件 system/core/init/builtins.cpp 中。</p> 
<p>函数 do_init_user0() 定义如下</p> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> do_init_user0(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;</span>&amp; args) {
    <span class="hljs-comment">//直接调用了函数 e4crypt_do_init_user0()</span>
    <span class="hljs-keyword">return</span> e4crypt_do_init_user0();
}</code></pre> 
<p>这个方法定义在文件 system/core/init/builtins.cpp 中。</p> 
<p>函数 e4crypt_do_init_user0() 定义如下</p> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> e4crypt_do_init_user0()
{
    init_logging();
    <span class="hljs-comment">//执行 vdc ， 参数 cryptfs 和 init_user0， 和 DE 的创建过程类似</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* argv[] = { <span class="hljs-string">"/system/bin/vdc"</span>, <span class="hljs-string">"--wait"</span>, <span class="hljs-string">"cryptfs"</span>, <span class="hljs-string">"init_user0"</span> };
    <span class="hljs-comment">// fork vdc 进程，并运行 vdc 程序</span>
    <span class="hljs-keyword">int</span> rc = android_fork_execvp(<span class="hljs-number">4</span>, (<span class="hljs-keyword">char</span>**) argv, NULL, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);
    LOG(INFO) &lt;&lt; <span class="hljs-string">"init_user0 result: "</span> &lt;&lt; rc;
    <span class="hljs-keyword">return</span> rc;
}</code></pre> 
<p>这个方法定义在文件 system/extras/ext4_utils/ext4_crypt_init_extensions.cpp 中。</p> 
<p>函数 android_fork_execvp() 运行 vdc 后，vdc 并没有做什么具体的操作，只是把相应的参数继续传递给 vold，和 DE 的密钥创建过程一样，参数 “cryptfs” 和 参数 “init_user0” 决定会执行到 vold 的如下代码</p> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> CryptCommandListener::CryptfsCmd::runCommand(SocketClient *cli,
                                                 <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv) {    
    .....
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (subcommand == <span class="hljs-string">"init_user0"</span>) {
        <span class="hljs-keyword">if</span> (!check_argc(cli, subcommand, argc, <span class="hljs-number">2</span>, <span class="hljs-string">""</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-comment">//执行函数 e4crypt_init_user0()</span>
        <span class="hljs-keyword">return</span> sendGenericOkFailOnBool(cli, e4crypt_init_user0());
    .....
}</code></pre> 
<p>这个方法定义在文件 system/vold/CryptCommandListener.cpp 中。</p> 
<p>函数 e4crypt_init_user0() 定义如下</p> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">bool</span> e4crypt_init_user0() {
    LOG(DEBUG) &lt;&lt; <span class="hljs-string">"e4crypt_init_user0"</span>;
    <span class="hljs-keyword">if</span> (e4crypt_is_native()) {
        <span class="hljs-comment">// user_key_dir 等于 data/misc/vold/user_keys</span>
        <span class="hljs-keyword">if</span> (!prepare_dir(user_key_dir, <span class="hljs-number">0700</span>, AID_ROOT, AID_ROOT)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">if</span> (!prepare_dir(user_key_dir + <span class="hljs-string">"/ce"</span>, <span class="hljs-number">0700</span>, AID_ROOT, AID_ROOT)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">if</span> (!prepare_dir(user_key_dir + <span class="hljs-string">"/de"</span>, <span class="hljs-number">0700</span>, AID_ROOT, AID_ROOT)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">if</span> (!path_exists(get_de_key_path(<span class="hljs-number">0</span>))) {
            <span class="hljs-comment">//创建和安装 CD keys， user 为 0， 即开机默认的 user</span>
            <span class="hljs-keyword">if</span> (!create_and_install_user_keys(<span class="hljs-number">0</span>, <span class="hljs-keyword">false</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        }
        <span class="hljs-comment">// TODO: switch to loading only DE_0 here once framework makes</span>
        <span class="hljs-comment">// explicit calls to install DE keys for secondary users</span>
        <span class="hljs-keyword">if</span> (!load_all_de_keys()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
    <span class="hljs-comment">// We can only safely prepare DE storage here, since CE keys are probably</span>
    <span class="hljs-comment">// entangled with user credentials.  The framework will always prepare CE</span>
    <span class="hljs-comment">// storage once CE keys are installed.</span>
    <span class="hljs-keyword">if</span> (!e4crypt_prepare_user_storage(<span class="hljs-keyword">nullptr</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, FLAG_STORAGE_DE)) {
        LOG(ERROR) &lt;&lt; <span class="hljs-string">"Failed to prepare user 0 storage"</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }

    <span class="hljs-comment">// If this is a non-FBE device that recently left an emulated mode,</span>
    <span class="hljs-comment">// restore user data directories to known-good state.</span>
    <span class="hljs-keyword">if</span> (!e4crypt_is_native() &amp;&amp; !e4crypt_is_emulated()) {
        e4crypt_unlock_user_key(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">"!"</span>, <span class="hljs-string">"!"</span>);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
<p>这个方法定义在文件 system/vold/Ext4Crypt.cpp 中。</p> 
<p>函数 create_and_install_user_keys() 定义如下</p> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> create_and_install_user_keys(userid_t user_id, <span class="hljs-keyword">bool</span> create_ephemeral) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> de_key, ce_key;
    <span class="hljs-comment">//创建 DE 密钥</span>
    <span class="hljs-keyword">if</span> (!random_key(&amp;de_key)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    <span class="hljs-comment">//创建 CE 密钥</span>
    <span class="hljs-keyword">if</span> (!random_key(&amp;ce_key)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    .....
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> de_raw_ref;
    <span class="hljs-comment">// 存储 DE 密钥到密钥代码库</span>
    <span class="hljs-keyword">if</span> (!install_key(de_key, &amp;de_raw_ref)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    s_de_key_raw_refs[user_id] = de_raw_ref;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ce_raw_ref;
    <span class="hljs-comment">// 存储 CE 密钥到密钥代码库</span>
    <span class="hljs-keyword">if</span> (!install_key(ce_key, &amp;ce_raw_ref)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    s_ce_keys[user_id] = ce_key;
    s_ce_key_raw_refs[user_id] = ce_raw_ref;
    LOG(DEBUG) &lt;&lt; <span class="hljs-string">"Created keys for user "</span> &lt;&lt; user_id;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
<p>这个方法定义在文件 system/vold/Ext4Crypt.cpp 中。</p> 
<p>再看看密钥的真正生成过程 random_key()</p> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> random_key(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* key) {
    <span class="hljs-comment">// 读取随机密钥</span>
    <span class="hljs-keyword">if</span> (android::vold::ReadRandomBytes(EXT4_AES_256_XTS_KEY_SIZE, *key) != <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// TODO status_t plays badly with PLOG, fix it.</span>
        LOG(ERROR) &lt;&lt; <span class="hljs-string">"Random read failed"</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
<p>这个方法定义在文件 system/vold/Ext4Crypt.cpp 中。</p> 
<p>ReadRandomBytes() 定义如下</p> 
<pre class="prettyprint"><code class="language-cpp hljs ">status_t ReadRandomBytes(size_t bytes, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; out) {
    out.clear();
    <span class="hljs-comment">//打开 linux 的随机数文件</span>
    <span class="hljs-keyword">int</span> fd = TEMP_FAILURE_RETRY(open(<span class="hljs-string">"/dev/urandom"</span>, O_RDONLY | O_CLOEXEC | O_NOFOLLOW));
    <span class="hljs-keyword">if</span> (fd == -<span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> -errno;
    }

    <span class="hljs-keyword">char</span> buf[BUFSIZ];
    size_t n;
    <span class="hljs-comment">//读取一个随机数，作为密钥</span>
    <span class="hljs-keyword">while</span> ((n = TEMP_FAILURE_RETRY(read(fd, &amp;buf[<span class="hljs-number">0</span>], <span class="hljs-built_in">std</span>::min(<span class="hljs-keyword">sizeof</span>(buf), bytes)))) &gt; <span class="hljs-number">0</span>) {
        out.append(buf, n);
        bytes -= n;
    }
    close(fd);

    <span class="hljs-keyword">if</span> (bytes == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> OK;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> -EIO;
    }
}</code></pre> 
<p>这个方法定义在文件 system/vold/Utils.cpp 中。</p> 
<h3 id="使用创建的密钥加密">使用创建的密钥加密</h3> 
<p>在解析 init.rc 文件时，会执行命令 mkdir， 如</p> 
<pre class="prettyprint"><code class="language-cpp hljs ">mkdir /data/system_de <span class="hljs-number">0770</span> system system
on post-fs-data
    mkdir /data/system_ce <span class="hljs-number">0770</span> system system

    mkdir /data/misc_de <span class="hljs-number">01771</span> system misc
    mkdir /data/misc_ce <span class="hljs-number">01771</span> system misc
    <span class="hljs-comment">//用户数据路径</span>
    mkdir /data/user <span class="hljs-number">0711</span> system system
    <span class="hljs-comment">// 用户 DE 空间</span>
    mkdir /data/user_de <span class="hljs-number">0711</span> system system
    <span class="hljs-comment">// /data/data 连接到目录 /data/user/0</span>
    <span class="hljs-comment">// /data/user 和 /data/data 都是 CE 空间</span>
    symlink /data/data /data/user/<span class="hljs-number">0</span></code></pre> 
<p>这个 action 定义在文件 system/core/rootdir/init.rc 中。</p> 
<p>命令 mkdir 实质执行的的是函数 do_mkdir()</p> 
<pre class="prettyprint"><code class="language-cpp hljs ">BuiltinFunctionMap::Map&amp; BuiltinFunctionMap::<span class="hljs-built_in">map</span>() <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::size_t kMax = <span class="hljs-built_in">std</span>::numeric_limits&lt;<span class="hljs-built_in">std</span>::size_t&gt;::max();
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> Map builtin_functions = {
    .....
    {<!-- --><span class="hljs-string">"mkdir"</span>,                   {<!-- --><span class="hljs-number">1</span>,     <span class="hljs-number">4</span>,    do_mkdir}},
    .....
}</code></pre> 
<p>这个方法定义在文件 system/core/init/builtins.cpp 中。</p> 
<p>函数 do_mkdir() 的实现如下</p> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> do_mkdir(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;</span>&amp; args) {
    .....
    <span class="hljs-comment">// 创建目录</span>
    ret = make_dir(args[<span class="hljs-number">1</span>].c_str(), mode);
    .....
    <span class="hljs-keyword">if</span> (e4crypt_is_native()) {
        <span class="hljs-comment">// 加密目录</span>
        <span class="hljs-keyword">if</span> (e4crypt_set_directory_policy(args[<span class="hljs-number">1</span>].c_str())) {
            wipe_data_via_recovery(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>() + <span class="hljs-string">"set_policy_failed:"</span> + args[<span class="hljs-number">1</span>]);
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p>这个方法定义在文件 system/core/init/builtins.cpp 中。</p> 
<p>函数 e4crypt_set_directory_policy() 的实现如下</p> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> e4crypt_set_directory_policy(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* dir)
{
    <span class="hljs-comment">// 只加密 /data 目录以及子目录</span>
    <span class="hljs-keyword">if</span> (!dir || <span class="hljs-built_in">strncmp</span>(dir, <span class="hljs-string">"/data/"</span>, <span class="hljs-number">6</span>) || <span class="hljs-built_in">strchr</span>(dir + <span class="hljs-number">6</span>, <span class="hljs-string">'/'</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">// 不需要加密的目录在这里设置，但是，它们的子目录是会被加密的</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;</span> directories_to_exclude = {
        <span class="hljs-string">"lost+found"</span>,
        <span class="hljs-string">"system_ce"</span>, <span class="hljs-string">"system_de"</span>,
        <span class="hljs-string">"misc_ce"</span>, <span class="hljs-string">"misc_de"</span>,
        <span class="hljs-string">"media"</span>,
        <span class="hljs-string">"data"</span>, <span class="hljs-string">"user"</span>, <span class="hljs-string">"user_de"</span>,
    };
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> prefix = <span class="hljs-string">"/data/"</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> d: directories_to_exclude) {
        <span class="hljs-keyword">if</span> ((prefix + d) == dir) {
            KLOG_INFO(TAG, <span class="hljs-string">"Not setting policy on %s\n"</span>, dir);
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
    }
    <span class="hljs-comment">// 密钥引用</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ref_filename = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"/data"</span>) + e4crypt_key_ref;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> policy;
    <span class="hljs-keyword">if</span> (!android::base::ReadFileToString(ref_filename, &amp;policy)) {
        KLOG_ERROR(TAG, <span class="hljs-string">"Unable to read system policy to set on %s\n"</span>, dir);
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
    KLOG_INFO(TAG, <span class="hljs-string">"Setting policy on %s\n"</span>, dir);
    <span class="hljs-comment">// 加密目录</span>
    <span class="hljs-keyword">int</span> result = e4crypt_policy_ensure(dir, policy.c_str(), policy.size());
    <span class="hljs-keyword">if</span> (result) {
        KLOG_ERROR(TAG, <span class="hljs-string">"Setting %02x%02x%02x%02x policy on %s failed!\n"</span>,
                   policy[<span class="hljs-number">0</span>], policy[<span class="hljs-number">1</span>], policy[<span class="hljs-number">2</span>], policy[<span class="hljs-number">3</span>], dir);
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p>这个方法定义在文件 system/extras/ext4_utils/ext4_crypt_init_extensions.cpp 中。</p> 
<p>函数 e4crypt_policy_ensure() 定义如下</p> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> e4crypt_policy_ensure(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *directory, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *policy, size_t policy_length) {
    <span class="hljs-keyword">bool</span> is_empty;
    <span class="hljs-keyword">if</span> (!is_dir_empty(directory, &amp;is_empty)) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (is_empty) {
        <span class="hljs-comment">// 应用加密政策</span>
        <span class="hljs-keyword">if</span> (!e4crypt_policy_set(directory, policy, policy_length)) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (!e4crypt_policy_check(directory, policy, policy_length)) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p>这个方法定义在文件 system/extras/ext4_utils/ext4_crypt.cpp 中。</p> 
<p>函数 e4crypt_policy_set() 定义如下</p> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> e4crypt_policy_set(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *directory, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *policy, size_t policy_length) {
    <span class="hljs-keyword">int</span> fd = open(directory, O_DIRECTORY | O_NOFOLLOW | O_CLOEXEC);
    ......
    ext4_encryption_policy eep;
    eep.version = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// 设置加密类型 AES 256</span>
    eep.contents_encryption_mode = EXT4_ENCRYPTION_MODE_AES_256_XTS;
    eep.filenames_encryption_mode = EXT4_ENCRYPTION_MODE_AES_256_CTS;
    eep.flags = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memcpy</span>(eep.master_key_descriptor, policy, EXT4_KEY_DESCRIPTOR_SIZE);
    <span class="hljs-comment">// 用命令 EXT4_IOC_SET_ENCRYPTION_POLICY 控制 IO</span>
    <span class="hljs-keyword">if</span> (ioctl(fd, EXT4_IOC_SET_ENCRYPTION_POLICY, &amp;eep)) {
        PLOG(ERROR) &lt;&lt; <span class="hljs-string">"Failed to set encryption policy for "</span> &lt;&lt; directory;
        close(fd);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
    close(fd);

    <span class="hljs-keyword">char</span> policy_hex[EXT4_KEY_DESCRIPTOR_SIZE_HEX];
    policy_to_hex(policy, policy_hex);
    LOG(INFO) &lt;&lt; <span class="hljs-string">"Policy for "</span> &lt;&lt; directory &lt;&lt; <span class="hljs-string">" set to "</span> &lt;&lt; policy_hex;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
<p>这个方法定义在文件 system/extras/ext4_utils/ext4_crypt.cpp 中。</p> 
<p>加密过程就分析到这里。</p> 
<h3 id="直接启动">直接启动</h3> 
<p>应用了文件级加密的设备，可以以直接启动的方式启动。此时，设备可以加载并使用没有通过文件级加密的目录，如 /data/user_de/0/。那么，直接启动的 APP 的数据保存在这个目录下。</p> 
<p>在上文中，我们知道需要在直接启动就可以立马使用的的 APP，需要在应用的 manifest 的 application 标签声明 android:directBootAware=”true” 属性。对于系统的应用，声明 android:defaultToDeviceProtectedStorage=”true” 可以把应用的默认存储空间设置为 /data/user_de/。</p> 
<p>因此，在用户没有输入凭据解密 CE 空间之前，系统只是加载 DE 下的应用。</p> 
<p>在 AMS ready 时，如下（读者不了解这个过程的以看考文章<a href="http://blog.csdn.net/myfriend0/article/details/55098173">《 Android系统之System Server大纲》</a>）</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">systemReady</span>(<span class="hljs-keyword">final</span> Runnable goingCallback) {
    .....
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {
        <span class="hljs-comment">// Only start up encryption-aware persistent apps; once user is</span>
        <span class="hljs-comment">// unlocked we'll come back around and start unaware apps</span>
        <span class="hljs-comment">//启动 persistent app，注意参数 PackageManager.MATCH_DIRECT_BOOT_AWARE</span>
        startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE);
    }
    .....</code></pre> 
<p>这个方法定义在文件 frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 中。</p> 
<p>方法 startPersistentApps() 的实现如下</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startPersistentApps</span>(<span class="hljs-keyword">int</span> matchFlags) {
    <span class="hljs-keyword">if</span> (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">//获取所有 direct boot 的 app</span>
            <span class="hljs-keyword">final</span> List&lt;ApplicationInfo&gt; apps = AppGlobals.getPackageManager()
                    .getPersistentApplications(STOCK_PM_FLAGS | matchFlags).getList();
            <span class="hljs-keyword">for</span> (ApplicationInfo app : apps) {
                <span class="hljs-keyword">if</span> (!<span class="hljs-string">"android"</span>.equals(app.packageName) &amp;&amp; validNewProc(app.packageName, UserHandle.getUserId(app.uid))) {<!-- --><span class="hljs-comment">//modified by yongfeng.zhang for task 3682193 on 2016-12-28</span>
                    <span class="hljs-comment">// 加入启动队列</span>
                    addAppLocked(app, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* ABI override */</span>);
                }
            }
        } <span class="hljs-keyword">catch</span> (RemoteException ex) {
        }
    }
}</code></pre> 
<p>这个方法定义在文件 frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 中。</p> 
<p>方法 addAppLocked() 定义如下</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">final</span> ProcessRecord addAppLocked(ApplicationInfo info, <span class="hljs-keyword">boolean</span> isolated,
        String abiOverride) {
    .....
    <span class="hljs-keyword">if</span> (app.thread == <span class="hljs-keyword">null</span> &amp;&amp; mPersistentStartingProcesses.indexOf(app) &lt; <span class="hljs-number">0</span>) {
        mPersistentStartingProcesses.add(app);
        <span class="hljs-comment">// 启动 APP</span>
        startProcessLocked(app, <span class="hljs-string">"added application"</span>, app.processName, abiOverride,
                <span class="hljs-keyword">null</span> <span class="hljs-comment">/* entryPoint */</span>, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* entryPointArgs */</span>);
    }
    <span class="hljs-keyword">return</span> app;
}</code></pre> 
<p>这个方法定义在文件 frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 中。</p> 
<p>在 PMS 启动时，扫描安装 APP 是，会过滤不是直接启动的 APP</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">private</span> PackageParser.Package <span class="hljs-title">scanPackageDirtyLI</span>(PackageParser.Package pkg,
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> policyFlags, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> scanFlags, <span class="hljs-keyword">long</span> currentTime, UserHandle user)
        <span class="hljs-keyword">throws</span> PackageManagerException {
    <span class="hljs-comment">// Apply policy</span>
    <span class="hljs-keyword">if</span> ((policyFlags&amp;PackageParser.PARSE_IS_SYSTEM) != <span class="hljs-number">0</span>) {
        pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
        <span class="hljs-comment">//直接启动的 APP</span>
        <span class="hljs-keyword">if</span> (pkg.applicationInfo.isDirectBootAware()) {
            <span class="hljs-comment">// we're direct boot aware; set for all components</span>
            <span class="hljs-keyword">for</span> (PackageParser.Service s : pkg.services) {
                s.info.encryptionAware = s.info.directBootAware = <span class="hljs-keyword">true</span>;
            }
            <span class="hljs-keyword">for</span> (PackageParser.Provider p : pkg.providers) {
                p.info.encryptionAware = p.info.directBootAware = <span class="hljs-keyword">true</span>;
            }
            <span class="hljs-keyword">for</span> (PackageParser.Activity a : pkg.activities) {
                a.info.encryptionAware = a.info.directBootAware = <span class="hljs-keyword">true</span>;
            }
            <span class="hljs-keyword">for</span> (PackageParser.Activity r : pkg.receivers) {
                r.info.encryptionAware = r.info.directBootAware = <span class="hljs-keyword">true</span>;
            }
        }
    }

}</code></pre> 
<p>这个方法定义在文件 frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java 中。</p> 
<h3 id="总结">总结</h3> 
<p>文件级加密，比较全盘加密具有一些优点，可以让没有输入凭证的设备可以使用更多的功能。文件级加密分 CE 空间和 DE 空间，CE 空间需要凭证加密方可使用，DE 空间则是设备启动后即可使用。应用如果需要区分 CE 和 DE 空间，需要创建不同的上下文环境 Context。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/27f037ae73548ce3c75abb3f0ab278a3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">就 3 点，提升工作效率</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a89f0017ce2dc6912a38b0a2155b9415/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">android消息处理之messageQueue</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>