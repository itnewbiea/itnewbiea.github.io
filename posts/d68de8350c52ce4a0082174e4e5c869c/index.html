<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>模板方法模式 (Template Method Pattern) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="模板方法模式 (Template Method Pattern)" />
<meta property="og:description" content="定义 模板方法模式（Template Method Pattern）是一种行为型设计模式，它在一个方法中定义一个算法的骨架，将一些步骤的实现延迟到子类。通过这种方式，模板方法允许子类在不改变算法结构的情况下，重新定义算法的某些特定步骤。
模板方法模式通常包含以下两个角色：
抽象类（Abstract Class）：定义模板方法，以及算法的骨架。它可以包含具体方法、抽象方法和钩子（hook）方法。具体子类（Concrete Class）：实现抽象类中定义的抽象方法和钩子方法，从而完成算法中特定子部分的实现。 解决的问题 重复代码：在多个类中出现重复的代码是常见的问题，尤其是当这些类执行相似的任务时。模板方法模式通过将这些公共代码移到一个共同的父类中来减少重复。算法骨架的一致性：在某些情况下，你可能希望确保一个算法的基本结构保持一致，同时允许算法的某些步骤在不同的情境下有所不同。模板方法模式允许在保持算法结构不变的同时，让子类提供这些步骤的具体实现。扩展性：在不改变算法结构的情况下扩展功能。模板方法模式使得可以在子类中实现或重写某些步骤，而不需要更改基本算法的结构。反向控制结构（Inversion of Control）：模板方法模式是一种反向控制结构，因为在这种模式中，高层模块（抽象类）控制算法的流程，底层模块（具体实现）则提供某些步骤的具体实现。这有助于解耦算法的定义和实现。提供算法的框架：当你想提供一个算法的框架让其他开发者使用时，模板方法模式是一个不错的选择。开发者可以根据自己的需求覆写预定义的步骤，而无需更改算法的核心流程。 使用场景 算法步骤的共性和差异性分离： 当多个类有共同的行为，且这些行为中的步骤大体上相似，但每个步骤的具体实现不同时，模板方法模式非常有用。它允许你将共同的操作抽象到一个共有的父类中，而将各个步骤的具体实现留给子类。 一次性实现算法的不变部分： 在需要实现一个算法，并且算法的大体框架是稳定的，但某些关键步骤可能会发生变化的情况下，使用模板方法模式可以固定算法的框架，并将变化的部分留给子类来实现。 扩展类的功能： 当需要扩展类功能而不改变其主体结构时，模板方法模式提供了一种机制，允许在不改变类的主体结构的前提下对其进行扩展。 避免代码重复： 在多个类中执行相似的操作时，模板方法模式可以帮助避免重复代码。通过在父类中编写通用代码，可以减少重复，并使维护变得更容易。 控制子类扩展： 当你需要控制子类的扩展点时，模板方法模式是一个很好的选择。父类可以定义哪些操作是可变的，哪些是固定的，从而提供了一种方式来防止子类改变算法的结构。 示例代码 // 抽象类定义模板方法和抽象步骤 abstract class DataParser { // 模板方法 public final void parseData() { readData(); processData(); writeData(); } // 具体方法 public void readData() { System.out.println(&#34;Reading data...&#34;); } // 抽象方法 abstract protected void processData(); // 具体方法 public void writeData() { System.out.println(&#34;Writing data...&#34;); } } // 具体实现类 - XML解析 class XMLDataParser extends DataParser { @Override protected void processData() { System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d68de8350c52ce4a0082174e4e5c869c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-24T17:25:08+08:00" />
<meta property="article:modified_time" content="2023-11-24T17:25:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">模板方法模式 (Template Method Pattern)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h6><a id="_0"></a>定义</h6> 
<p>模板方法模式（Template Method Pattern）是一种行为型设计模式，它在一个方法中定义一个算法的骨架，将一些步骤的实现延迟到子类。通过这种方式，模板方法允许子类在不改变算法结构的情况下，重新定义算法的某些特定步骤。</p> 
<p>模板方法模式通常包含以下两个角色：</p> 
<ul><li><strong>抽象类（Abstract Class）</strong>：定义模板方法，以及算法的骨架。它可以包含具体方法、抽象方法和钩子（hook）方法。</li><li><strong>具体子类（Concrete Class）</strong>：实现抽象类中定义的抽象方法和钩子方法，从而完成算法中特定子部分的实现。</li></ul> 
<h6><a id="_9"></a>解决的问题</h6> 
<ul><li><strong>重复代码</strong>：在多个类中出现重复的代码是常见的问题，尤其是当这些类执行相似的任务时。模板方法模式通过将这些公共代码移到一个共同的父类中来减少重复。</li><li><strong>算法骨架的一致性</strong>：在某些情况下，你可能希望确保一个算法的基本结构保持一致，同时允许算法的某些步骤在不同的情境下有所不同。模板方法模式允许在保持算法结构不变的同时，让子类提供这些步骤的具体实现。</li><li><strong>扩展性</strong>：在不改变算法结构的情况下扩展功能。模板方法模式使得可以在子类中实现或重写某些步骤，而不需要更改基本算法的结构。</li><li><strong>反向控制结构（Inversion of Control）</strong>：模板方法模式是一种反向控制结构，因为在这种模式中，高层模块（抽象类）控制算法的流程，底层模块（具体实现）则提供某些步骤的具体实现。这有助于解耦算法的定义和实现。</li><li><strong>提供算法的框架</strong>：当你想提供一个算法的框架让其他开发者使用时，模板方法模式是一个不错的选择。开发者可以根据自己的需求覆写预定义的步骤，而无需更改算法的核心流程。</li></ul> 
<h6><a id="_17"></a>使用场景</h6> 
<ul><li><strong>算法步骤的共性和差异性分离</strong>： 
  <ul><li>当多个类有共同的行为，且这些行为中的步骤大体上相似，但每个步骤的具体实现不同时，模板方法模式非常有用。它允许你将共同的操作抽象到一个共有的父类中，而将各个步骤的具体实现留给子类。</li></ul> </li><li><strong>一次性实现算法的不变部分</strong>： 
  <ul><li>在需要实现一个算法，并且算法的大体框架是稳定的，但某些关键步骤可能会发生变化的情况下，使用模板方法模式可以固定算法的框架，并将变化的部分留给子类来实现。</li></ul> </li><li><strong>扩展类的功能</strong>： 
  <ul><li>当需要扩展类功能而不改变其主体结构时，模板方法模式提供了一种机制，允许在不改变类的主体结构的前提下对其进行扩展。</li></ul> </li><li><strong>避免代码重复</strong>： 
  <ul><li>在多个类中执行相似的操作时，模板方法模式可以帮助避免重复代码。通过在父类中编写通用代码，可以减少重复，并使维护变得更容易。</li></ul> </li><li><strong>控制子类扩展</strong>： 
  <ul><li>当你需要控制子类的扩展点时，模板方法模式是一个很好的选择。父类可以定义哪些操作是可变的，哪些是固定的，从而提供了一种方式来防止子类改变算法的结构。</li></ul> </li></ul> 
<h6><a id="_30"></a>示例代码</h6> 
<pre><code class="prism language-java"><span class="token comment">// 抽象类定义模板方法和抽象步骤</span>
<span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">DataParser</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 模板方法</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">parseData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">readData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">processData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">writeData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 具体方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Reading data..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 抽象方法</span>
    <span class="token keyword">abstract</span> <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">processData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 具体方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Writing data..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 具体实现类 - XML解析</span>
<span class="token keyword">class</span> <span class="token class-name">XMLDataParser</span> <span class="token keyword">extends</span> <span class="token class-name">DataParser</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">processData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Processing XML data"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 具体实现类 - JSON解析</span>
<span class="token keyword">class</span> <span class="token class-name">JSONDataParser</span> <span class="token keyword">extends</span> <span class="token class-name">DataParser</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">processData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Processing JSON data"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 客户端代码</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TemplateMethodDemo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">DataParser</span> xmlParser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLDataParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        xmlParser<span class="token punctuation">.</span><span class="token function">parseData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">DataParser</span> jsonParser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONDataParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        jsonParser<span class="token punctuation">.</span><span class="token function">parseData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="_86"></a>主要符合的设计原则</h6> 
<ul><li><strong>开闭原则（Open-Closed Principle）</strong>： 
  <ul><li>模板方法模式允许算法的结构保持不变（“关闭”），同时可以通过继承来扩展部分步骤的实现（“开放”）。这意味着可以在不修改现有代码的情况下，通过添加新的子类来扩展功能。</li></ul> </li><li><strong>好莱坞原则（Hollywood Principle）</strong>： 
  <ul><li>这个原则通常被表述为“不要给我们打电话，我们会给你打电话”，指的是高层模块对低层模块的调用，而不是相反。模板方法模式中，抽象类定义了高层的算法结构，它会在适当的时候调用子类的方法，而子类通常不会直接调用抽象类的方法。</li></ul> </li><li><strong>单一职责原则（Single Responsibility Principle）</strong>： 
  <ul><li>模板方法模式将算法的框架（骨架）和具体步骤的实现分离。抽象类负责定义算法的结构和管理整个算法的流程，而各个步骤的具体实现则由子类负责，符合单一职责原则。</li></ul> </li><li><strong>里氏替换原则（Liskov Substitution Principle）</strong>： 
  <ul><li>在模板方法模式中，子类必须能够替换其基类。这是因为算法的框架是在基类中定义的，而基类可以在运行时被任何合适的子类实例替换，而不影响算法的整体结构和最终结果。</li></ul> </li></ul> 
<h6><a id="JDK_97"></a>在JDK中的应用</h6> 
<ul><li><strong>Java I/O 类</strong>： 
  <ul><li>在 <code>java.io</code> 包中，许多流类（如 <code>InputStream</code>, <code>OutputStream</code>, <code>Reader</code>, 和 <code>Writer</code>）都使用了模板方法模式。这些类中的某些方法定义了操作的基本结构，而具体的读写操作则由子类（如 <code>FileInputStream</code>, <code>FileOutputStream</code>, <code>StringReader</code>, 和 <code>StringWriter</code>）实现。</li><li>例如，<code>InputStream</code> 中的 <code>read()</code> 方法是抽象的，定义了读取数据的框架，而具体的读取逻辑则由子类实现。</li></ul> </li><li><strong>Java Collections Framework</strong>： 
  <ul><li>在 <code>java.util</code> 包中，<code>AbstractList</code>, <code>AbstractSet</code> 和 <code>AbstractMap</code> 等抽象类为集合类提供了模板方法。这些类实现了 <code>Collection</code> 或 <code>Map</code> 接口的大部分方法，而将一些核心方法留给子类实现。</li><li>例如，<code>AbstractList</code> 提供了对 <code>List</code> 接口的大部分实现，但是具体的 <code>get(int index)</code>, <code>size()</code>, <code>set(int index, E element)</code> 等方法则需要由子类提供。</li></ul> </li><li><strong>Java Swing 库</strong>： 
  <ul><li>在Java Swing库中，许多GUI组件的绘制过程采用了模板方法模式。例如，<code>paintComponent(Graphics g)</code> 方法是一个模板方法，它定义了绘制组件的基本流程，而具体的绘制逻辑则由子类（如不同的按钮、面板等）实现。</li></ul> </li><li><strong>Java Servlet API</strong>： 
  <ul><li>在 <code>javax.servlet.http.HttpServlet</code> 类中，<code>doGet</code>, <code>doPost</code>, <code>doPut</code>, <code>doDelete</code> 等方法实现了HTTP请求的处理框架，而具体的处理逻辑则由开发者在子类中实现。</li></ul> </li></ul> 
<h6><a id="Spring_110"></a>在Spring中的应用</h6> 
<ul><li><strong>JdbcTemplate</strong>： 
  <ul><li><code>JdbcTemplate</code> 是Spring提供的用于简化JDBC操作的一个经典例子。它定义了执行数据库操作的基本流程（如建立连接、准备语句、执行查询、处理结果集），而将结果集的解析和数据的处理逻辑留给开发者通过回调来实现。这就是模板方法模式的典型应用。</li></ul> </li><li><strong>HibernateTemplate 和 HibernateDaoSupport</strong>： 
  <ul><li>类似于 <code>JdbcTemplate</code>，<code>HibernateTemplate</code> 和 <code>HibernateDaoSupport</code> 提供了一个框架来简化Hibernate操作。它们处理了开启会话、事务的管理等，而具体的Hibernate调用则是在回调中实现的。</li></ul> </li><li><strong>Spring Web MVC的Controller</strong>： 
  <ul><li>在Spring MVC中，<code>AbstractController</code> 提供了处理HTTP请求的模板方法。它处理请求的流程（如请求的接收和响应的发送），而具体的请求处理逻辑则由开发者在扩展的类中实现。</li></ul> </li><li><strong>Spring Security的认证和授权</strong>： 
  <ul><li>在Spring Security中，例如 <code>AbstractAuthenticationProcessingFilter</code> 提供了身份验证的模板方法。这个类处理了认证流程的大部分步骤，而具体的认证逻辑则是由开发者在子类中自定义的。</li></ul> </li></ul> 
<hr> 
<h6><a id="_123"></a></h6>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6fa8e2525a1af3c63ee4d706e73c0e8c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">策略模式 (Strategy Pattern)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cf86cb2ade7334ed508fa2b94f4aaca2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">访问者模式 (Visitor Pattern)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>