<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>详细图解,二叉排序树的遍历、删除、插入，通过bf优化构建成平衡二叉树(avl树)的原理 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="详细图解,二叉排序树的遍历、删除、插入，通过bf优化构建成平衡二叉树(avl树)的原理" />
<meta property="og:description" content="目录
一.二叉排序树的建立
二.二叉树的遍历
三.改造树结构
四.有序二叉树的查找
五.二叉排序树的节点删除
六.二叉排序树优化成平衡二叉树
七.平衡二叉树的建立过程
八.总结
一.二叉排序树的建立 1.数据结构定义
class TreeNode { public: int m_data = 0; //数据 TreeNode* m_lch = NULL; //左节点 TreeNode* m_rch = NULL; //右节点 TreeNode* m_father = NULL; //父亲节点 }; class Tree { public: void PreOrderVisit(TreeNode* node); //前序遍历 void InOrderVisit(TreeNode* node); //中序遍历 void PostOrderVisit(TreeNode* node);//后序遍历 void InitTree(int* pArr, int n ); private: void AddChild(TreeNode* TT, TreeNode* node); TreeNode* m_root = NULL; } 下图展示了数据10,7,20,3,1,5,17构建一个有序二叉树的过程。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0412a1f5d87cceed2e66957f62dfd853/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-03T01:40:08+08:00" />
<meta property="article:modified_time" content="2023-09-03T01:40:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">详细图解,二叉排序树的遍历、删除、插入，通过bf优化构建成平衡二叉树(avl树)的原理</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="main-toc-toc" style="margin-left:0px;"><a href="#main-toc" rel="nofollow">一.二叉排序树的建立</a></p> 
<p id="%E4%BA%8C.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86" rel="nofollow">二.二叉树的遍历</a></p> 
<p id="%E4%B8%89.%E6%94%B9%E9%80%A0%E6%A0%91%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E6%94%B9%E9%80%A0%E6%A0%91%E7%BB%93%E6%9E%84" rel="nofollow">三.改造树结构</a></p> 
<p id="%E5%9B%9B.%E6%9C%89%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%E6%9C%89%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE" rel="nofollow">四.有序二叉树的查找</a></p> 
<p id="%E4%BA%94.%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A4-toc" style="margin-left:0px;"><a href="#%E4%BA%94.%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A4" rel="nofollow">五.二叉排序树的节点删除</a></p> 
<p id="%E5%85%AD.%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E4%BC%98%E5%8C%96%E6%88%90%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><a href="#%E5%85%AD.%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E4%BC%98%E5%8C%96%E6%88%90%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">六.二叉排序树优化成平衡二叉树</a></p> 
<p id="%C2%A0%E4%B8%83.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%83.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B" rel="nofollow">七.平衡二叉树的建立过程</a></p> 
<p id="%E5%85%AB.%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E5%85%AB.%E6%80%BB%E7%BB%93" rel="nofollow">八.总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="main-toc"><strong>一.二叉排序树的建立</strong></h2> 
<p>1.数据结构定义</p> 
<pre><code class="language-cpp">class TreeNode
{
public:
	int m_data = 0; //数据
	TreeNode* m_lch = NULL; //左节点
	TreeNode* m_rch = NULL; //右节点
	TreeNode* m_father = NULL; //父亲节点
};

class Tree
{
public:
	void PreOrderVisit(TreeNode* node); //前序遍历
	void InOrderVisit(TreeNode* node);  //中序遍历
	void PostOrderVisit(TreeNode* node);//后序遍历
	void InitTree(int* pArr, int n );
	
private:
	void AddChild(TreeNode* TT, TreeNode* node);
	TreeNode* m_root = NULL;
}</code></pre> 
<p style="text-align:center;"></p> 
<p>                                下图展示了数据10,7,20,3,1,5,17构建一个有序二叉树的过程。</p> 
<p><img alt="" src="https://images2.imgbox.com/66/7d/7AoAREUL_o.jpg"></p> 
<p></p> 
<p>1.当树为空时，第一个数据设置为root。                                                                               </p> 
<p>2.新加入的数据如果比root小，root的左孩子为空，就加到root的左孩子节点。</p> 
<p>3.新加入的数据如果比root大，root的右孩子为空，就加到root的右孩子节点。</p> 
<p>4.如果新加入的数据比root小，且root的左孩子不为空，那把root的左孩子当作新ROOT，重复2，3，4，5步骤。</p> 
<p>5.如果新加入的数据比root大，且root的右孩子不为空，那把root的右孩子当作新的ROOT，重复2，3，4，5步骤。</p> 
<pre><code class="language-cpp">void AddChild(TreeNode* TT, TreeNode* node)
	{
		if(m_root == NULL)
		{
			m_root = node;
			return ;
		}
		int cmp = node-&gt;m_data &lt; TT-&gt;m_data;
		if(cmp &gt; 0) //如果数据比TT节点小，就找TT节点的左孩子比较
		{
			if(TT-&gt;m_lch == NULL)
			{
				SetLChild(TT, node);
				return;
			}
			else //如果左节点不为空，递归到左节点
			{
				AddChild(TT-&gt;m_lch, node);
				return;
			}
		}
		else  //如果数据比TT节点大，就找TT节点的右孩子比较
		{
			if(TT-&gt;m_rch == NULL)
			{
				SetRChild(TT, node);
				return;
			}
			else //如果右节点不为空，递归到左节点
			{
				AddChild(TT-&gt;m_rch, node);
				return;
			}
		}
	}
void SetLChild(TreeNode* node, TreeNode* L)
	{
		if(node == NULL)
			return;
		node-&gt;m_lch = L;
		if(L)
			L-&gt;m_father = node;
	}
	void SetRChild(TreeNode* node, TreeNode* R)
	{
		if(node == NULL)
			return;
		node-&gt;m_rch = R;
		if(R)
			R-&gt;m_father = node;
	}</code></pre> 
<h2 id="%E4%BA%8C.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">二.二叉树的遍历</h2> 
<p>二叉树的遍历是指从根节点出发，按照某种次序依次访问二叉树中所有节点，使得每个节点被访问一次且仅被访问一次。根据根节点的访问顺序有以下三种方式。</p> 
<p>前序遍历，先访问根节点，再遍历左孩子，再遍历右孩子。上图访问顺序<strong>10 7 3 1 5 20 17</strong></p> 
<p>中序遍历，先中序遍历自己的左子树，再访问根节点，然后中序遍历自己右子树。上图访问顺序<strong>1 3 5 7 10 17 20</strong></p> 
<p>后序遍历，先后序遍历自己的左子树，再后序遍历自己的右子树，再访问根节点。上图访问顺序<strong>1 5 3 7 17 20 10</strong></p> 
<p><strong>很显然一棵有序二叉树，用中序遍历就能按数据大小顺序依次输出。</strong></p> 
<p>代码利用递归方法实现很简单。</p> 
<pre><code class="language-cpp">void PreOrderVisit(TreeNode* node)
	{
		if(node == NULL)
			return;
		cout &lt;&lt; node-&gt;m_data &lt;&lt; " ";
		PreOrderVisit(node-&gt;m_lch);
		PreOrderVisit(node-&gt;m_rch);
	}
	void InOrderVisit(TreeNode* node)
	{
		if(node == NULL)
			return;
		InOrderVisit(node-&gt;m_lch);
		cout &lt;&lt; node-&gt;m_data &lt;&lt; " ";
		InOrderVisit(node-&gt;m_rch);
	}
	void PostOrderVisit(TreeNode* node)
	{
		if(node == NULL)
			return;
		PostOrderVisit(node-&gt;m_lch);
		PostOrderVisit(node-&gt;m_rch);
		cout &lt;&lt; node-&gt;m_data &lt;&lt; " ";
	}</code></pre> 
<h2 id="%E4%B8%89.%E6%94%B9%E9%80%A0%E6%A0%91%E7%BB%93%E6%9E%84">三.改造树结构</h2> 
<p>1.上述树节点存储的是int类型数据，我们使用模版TreeNode&lt;T&gt;使其能存储各种类型数据。</p> 
<p>2.上述树默认是根据int类型数据升序排序，构建的有序二叉树。我们改造成能自定义排序使用升序还是降序，如果是存储自定义数据结构的，还可以自定义比较函数。</p> 
<p>3.把树的遍历(打印输出)，改成自定义方法。</p> 
<h2 id="%E5%9B%9B.%E6%9C%89%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE">四.有序二叉树的查找</h2> 
<p>根据比较函数和排序顺序，选择左子树或者右子树进行递归遍历查找。</p> 
<pre><code class="language-cpp">TreeNode&lt;T&gt;* FindTreeNode(TreeNode&lt;T&gt;* node, T data, int sort(T, T)=NULL)
	{
		if(node == NULL)
			return NULL;
		else if(node-&gt;m_data == data)
			return node;
		
		int cmp = 0;
		if(sort!=NULL)
			cmp = sort(data, node-&gt;m_data);
		else
			cmp = data - node-&gt;m_data;
		
		if(m_ascendorder)
		{
			if(cmp &gt;= 0)
				return FindTreeNode(node-&gt;m_rch, data);
			else
				return FindTreeNode(node-&gt;m_lch, data);
		}
		else
		{
			if(cmp &gt;= 0)
				return FindTreeNode(node-&gt;m_lch, data);
			else
				return FindTreeNode(node-&gt;m_rch, data);
				
		}
		return NULL;
	}</code></pre> 
<h2 id="%E4%BA%94.%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A4">五.二叉排序树的节点删除</h2> 
<p>1.对于删除只有左子树或者右子树的节点，那很简单只需要子承父业就行。</p> 
<p>2.对于删除即有左子树又有右子树的节点，那就不太容易了，比如下图。</p> 
<p><img alt="" src="https://images2.imgbox.com/46/49/Ak2egiqc_o.jpg"></p> 
<p></p> 
<p>上面的中序遍历是29，35，36，37，<span style="color:#fe2c24;">47</span>，48，49，50，51，56，58....... ，我们可以用47的前驱节点37，或者使用后驱节点48替换47的位置。</p> 
<p>分析使用前驱节点替换方法：</p> 
<p>1.先找到前驱节点，即删除节点的第一个左孩子的最后一个右孩子。为37，设为pre。</p> 
<p>2.删除节点的右子树51，成为pre的右子树。</p> 
<p>3.pre的左子树36，过继给pre的父节点35，成为35的右子树。</p> 
<p>4.被删节点的第一个左节点35，成为pre的左孩子。</p> 
<p>5.删除节点47(node)。把node替换成pre</p> 
<pre><code class="language-cpp">	//删除节点，使用前驱节点替换方法
	//1.对于删除的节点，只有左孩子或右孩子时，很简单直接子承父业就行。
	//2.如果被删除的节点即有左孩子，又有右孩子，可以使用前驱节点替换方法，或者使用后驱节点替换方法。
	void DelTreeNode(TreeNode&lt;T&gt;* node)
	{
		if(node == NULL)
			return;
		
		if(node != m_root)
		{
			TreeNode&lt;T&gt;** pfatherchild;
			if(node-&gt;m_father-&gt;m_lch == node)
				pfatherchild = &amp;node-&gt;m_father-&gt;m_lch;
			else
				pfatherchild = &amp;node-&gt;m_father-&gt;m_rch;
			
			if(node-&gt;m_lch == NULL)//只有右支，子承父业
			{
				*pfatherchild = node-&gt;m_rch;
				if(node-&gt;m_rch)
					node-&gt;m_rch-&gt;m_father = node-&gt;m_father;
			}
			else if(node-&gt;m_rch == NULL)//只有左支，子承父业
			{
				*pfatherchild = node-&gt;m_lch;
				if(node-&gt;m_lch)
					node-&gt;m_lch-&gt;m_father = node-&gt;m_father;
				
			}
			else//即有左支，又有右支，使用中序遍历时的前驱节点替换
			{
				//第1步，找到删除节点的第一个左孩子的最右孩子，是中序遍历时node的前驱节点。
				TreeNode&lt;T&gt;* pre = node-&gt;m_lch;
				while (pre-&gt;m_rch)
					pre = pre-&gt;m_rch;
				
				//第2步，被删除节点的右支过继到pre的右孩子。
				SetRChild(pre, node-&gt;m_rch);
			
				if(pre == pre-&gt;m_father-&gt;m_rch)
				{
					//第3步，pre节点的左支过继给pre节点的父节点
					SetRChild(pre-&gt;m_father, pre-&gt;m_lch);
					//第4步，被删节点的第一个左节点，成为pre的左孩子
					SetLChild(pre, node-&gt;m_lch);
				}
				
				//第4步，node替换成pre节点
				{
					*pfatherchild = pre;
					pre-&gt;m_father = node-&gt;m_father;
				}
			}
			
		}
		else  //同样的方法对node==root时的特殊处理
		{
			TreeNode&lt;T&gt;* pre = m_root-&gt;m_lch; //找到删除节点的第一个左孩子
			if(pre)
			{
				while (pre-&gt;m_rch)
					pre = pre-&gt;m_rch;//第一个左孩子的最右孩子，就是中序遍历时node的前驱节点。
				
				if(pre == pre-&gt;m_father-&gt;m_rch)
				{
					SetRChild(pre-&gt;m_father, pre-&gt;m_lch);
					SetLChild(pre,  node-&gt;m_lch);
				}
				SetRChild(pre , node-&gt;m_rch);

				m_root = pre;
				m_root-&gt;m_father = NULL;
			}
			else //删除的是根节点，且根节点没有左子树的情况
			{
				m_root = m_root-&gt;m_rch;
				if(m_root)
					m_root-&gt;m_father = NULL;
			}
		}
		
		delete node;
	}</code></pre> 
<h2 id="%E5%85%AD.%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E4%BC%98%E5%8C%96%E6%88%90%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">六.二叉排序树优化成平衡二叉树</h2> 
<p>如果插入的数据顺序是1，2，3，4，5那么根据二叉排序树的建立过程，最后的树会是下图所示。此时查找5的话，需要遍历所有节点。为了提高查找效率，需要是它变成平衡二叉树，这样查找时间复杂度能变成O(log2N)</p> 
<p style="text-align:center;"><img alt="" height="201" src="https://images2.imgbox.com/6b/77/TOy1rRhM_o.jpg" width="221"></p> 
<h2 id="%C2%A0%E4%B8%83.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B">七.平衡二叉树的建立过程</h2> 
<p>1.平衡二叉树的特点</p> 
<p>⑴：左子树和右子树深度之差的绝对值不大于1；</p> 
<p>⑵：左子树和右子树也都是平衡二叉树。</p> 
<p>平衡因子BF(Balance Factor) ：二叉树上结点的左子树的深度减去其右子树深度称为该结点的平衡因子，因此平衡二叉树上每个结点的平衡因子只可能是-1、0和1</p> 
<p>2.平衡二叉树，插入时平衡原理</p> 
<p>在二叉排序树建立的基础上，每当插入一个新数据，计算各节点的平衡因子，如果绝对值大于1，就旋转使子树平衡。</p> 
<p></p> 
<p><img alt="" src="https://images2.imgbox.com/70/f4/ztAsPfmx_o.jpg"></p> 
<p> 3.代码实现LL型，RR型，LR型，RL型树的旋转平衡</p> 
<pre><code class="language-cpp">	//左左型树旋转,往右旋转
	void Rotate_LL(TreeNode&lt;T&gt;* root)
	{
		TreeNode&lt;T&gt;* rootf = root-&gt;m_father;
		TreeNode&lt;T&gt;* node = root-&gt;m_lch;
		if(rootf)
		{
			if(rootf-&gt;m_lch == root)
				SetLChild(rootf, node);
			else
				SetRChild(rootf, node);
		}
		else
		{
			m_root = node;
			m_root-&gt;m_father = NULL;
		}
		
		SetLChild(root, node-&gt;m_rch);
		SetRChild(node, root);
	}
	//右右型树旋转，往左旋转
	void Rotate_RR(TreeNode&lt;T&gt;* root)
	{
		
		TreeNode&lt;T&gt;* rootf = root-&gt;m_father;
		TreeNode&lt;T&gt;* node = root-&gt;m_rch;
		if(rootf)
		{
			if(rootf-&gt;m_lch == root)
				SetLChild(rootf, node);
			else
				SetRChild(rootf, node);
		}
		else
		{
			m_root = node;
			m_root-&gt;m_father = NULL;
		}
			
		SetRChild(root, node-&gt;m_lch);
		SetLChild(node, root);
	}
	//左右型树旋转
	void Rotate_LR(TreeNode&lt;T&gt;* root)
	{
		Rotate_RR(root-&gt;m_lch);
		Rotate_LL(root);
	}
	//右左型树旋转
	void Rotate_RL(TreeNode&lt;T&gt;* root)
	{
		Rotate_LL(root-&gt;m_rch);
		Rotate_RR(root);
	}</code></pre> 
<p> 4.旋转后BF值的更新</p> 
<p>当时LL型或者RR型树，旋转平衡后，TT，L的BF都变为0。当LR型树，旋转平衡后，根据原树的Lr的BF值0，1，-1这3种情况，有三种结果。RL型树同理LR树。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a7/52/JwWJb1ZE_o.jpg"></p> 
<p style="text-align:center;"> 代码实现</p> 
<pre><code class="language-cpp">	void LeftBalance(TreeNode&lt;T&gt;* TT)
	{
		assert(TT-&gt;m_bf == TreeLH);
		TreeNode&lt;T&gt;* L = TT-&gt;m_lch;
		if(L-&gt;m_bf == TreeLH) // LL型树，插在树root的左孩子的左边
		{
			TT-&gt;m_bf = TreeEH;
			L-&gt;m_bf = TreeEH;
			Rotate_LL(TT);
		}
		else if(L-&gt;m_bf == TreeRH) //LR型树，插在树root的左孩子的右边,双旋处理
		{
			TreeNode&lt;T&gt;* lr = L-&gt;m_rch;
			if(lr-&gt;m_bf == TreeLH)
			{
				TT-&gt;m_bf = TreeRH;
				L-&gt;m_bf = TreeEH;
			}
			else if(lr-&gt;m_bf == TreeEH)
			{
				TT-&gt;m_bf = TreeEH;
				L-&gt;m_bf = TreeEH;
			}
			else if(lr-&gt;m_bf == TreeRH)//
			{
				TT-&gt;m_bf = TreeEH;
				L-&gt;m_bf = TreeLH;
			}
			
			lr-&gt;m_bf = TreeEH;
			Rotate_LR(TT);
		}
		else
			assert(false);
		
	}</code></pre> 
<h2 id="%E5%85%AB.%E6%80%BB%E7%BB%93">八.总结</h2> 
<p>学习二叉树前需要熟练掌握递归。平衡二叉树的删除，和插入旋转是难点。但是只要多画图，根据图写代码还是容易分析的。指针指来指去的可能会懵圈，多些assert，自检下。</p> 
<p>附上所有源码</p> 
<pre><code class="language-cpp">#include "utility.h"

template &lt;typename T&gt;
class TreeNode
{
public:
	T m_data = 0;  //可以存储自定义的数据结构的数据
	char m_bf = 0;  //平衡二叉树每个节点的平衡因子，只能为 -1，0，1.
	int m_depth = -1; //节点所在的深度
	TreeNode* m_lch = NULL;
	TreeNode* m_rch = NULL;
	TreeNode* m_father = NULL;
};

template&lt;typename T&gt;
using  dealTreeNode = void (*)(TreeNode&lt;T&gt;* node);

template &lt;typename T&gt;
class Tree
{
public:
	~Tree()
	{
		PostOrderVisit(m_root,  [](TreeNode&lt;T&gt;* node){ //通过传人自定义遍历函数，释放所有节点。
			delete node;
		});
	}
	
	//获取树的深度
	int GetTreeDepth()
	{
		if(m_root == NULL)
			return 0;
		return GetDepth(m_root);
	}
	
	//删除节点，使用前驱节点替换方法
	//1.对于删除的节点，只有左孩子或右孩子时，很简单直接子承父业就行。
	//2.如果被删除的节点即有左孩子，又有右孩子，可以使用前驱节点替换方法，或者使用后驱节点替换方法。
	void DelTreeNode(TreeNode&lt;T&gt;* node)
	{
		if(node == NULL)
			return;
		
		if(node != m_root)
		{
			TreeNode&lt;T&gt;** pfatherchild;
			if(node-&gt;m_father-&gt;m_lch == node)
				pfatherchild = &amp;node-&gt;m_father-&gt;m_lch;
			else
				pfatherchild = &amp;node-&gt;m_father-&gt;m_rch;
			
			if(node-&gt;m_lch == NULL)//只有右支，子承父业
			{
				*pfatherchild = node-&gt;m_rch;
				if(node-&gt;m_rch)
					node-&gt;m_rch-&gt;m_father = node-&gt;m_father;
			}
			else if(node-&gt;m_rch == NULL)//只有左支，子承父业
			{
				*pfatherchild = node-&gt;m_lch;
				if(node-&gt;m_lch)
					node-&gt;m_lch-&gt;m_father = node-&gt;m_father;
				
			}
			else//即有左支，又有右支，使用中序遍历时的前驱节点替换
			{
				//第1步，找到删除节点的第一个左孩子的最右孩子，是中序遍历时node的前驱节点。
				TreeNode&lt;T&gt;* pre = node-&gt;m_lch;
				while (pre-&gt;m_rch)
					pre = pre-&gt;m_rch;
				
				//第2步，被删除节点的右支过继到pre的右孩子。
				SetRChild(pre, node-&gt;m_rch);
			
				if(pre == pre-&gt;m_father-&gt;m_rch)
				{
					//第3步，pre节点的左支过继给pre节点的父节点
					SetRChild(pre-&gt;m_father, pre-&gt;m_lch);
					//第4步，被删节点的第一个左节点，成为pre的左孩子
					SetLChild(pre, node-&gt;m_lch);
				}
				
				//第4步，node替换成pre节点
				{
					*pfatherchild = pre;
					pre-&gt;m_father = node-&gt;m_father;
				}
			}
			
		}
		else  //同样的方法对node==root时的特殊处理
		{
			TreeNode&lt;T&gt;* pre = m_root-&gt;m_lch; //找到删除节点的第一个左孩子
			if(pre)
			{
				while (pre-&gt;m_rch)
					pre = pre-&gt;m_rch;//第一个左孩子的最右孩子，就是中序遍历时node的前驱节点。
				
				if(pre == pre-&gt;m_father-&gt;m_rch)
				{
					SetRChild(pre-&gt;m_father, pre-&gt;m_lch);
					SetLChild(pre,  node-&gt;m_lch);
				}
				SetRChild(pre , node-&gt;m_rch);

				m_root = pre;
				m_root-&gt;m_father = NULL;
			}
			else //删除的是根节点，且根节点没有左子树的情况
			{
				m_root = m_root-&gt;m_rch;
				if(m_root)
					m_root-&gt;m_father = NULL;
			}
		}
		
		delete node;
	}
	void InitTree(int* pArr, int n , int sort(const T, const T) = NULL)
	{
		for(int i = 0; i &lt; n; i++)
		{
			TreeNode&lt;T&gt;* node = new TreeNode&lt;T&gt;();
			node-&gt;m_data = pArr[i];
			if(m_bavl)
				AVLAddChild(m_root, node, sort);
			else
				AddChild(m_root, node, sort);
				
		}
	}
	void InitAVLTree(int* pArr, int n, int sort(const T, const T) = NULL)
	{
		m_bavl = true;
		InitTree(pArr, n, sort);
	}
	
	TreeNode&lt;T&gt;* FindTreeNode(T data, int sort(T, T) = NULL)
	{
		return FindTreeNode(m_root, data, sort);
	}
	
	
	void PreOrderVisit(dealTreeNode&lt;T&gt; fun)
	{
		PreOrderVisit(m_root, fun);
	}
	void InOrderVisit(dealTreeNode&lt;T&gt; fun)
	{
		InOrderVisit(m_root, fun);
	}
	void PostOrderVisit(dealTreeNode&lt;T&gt; fun)
	{
		PostOrderVisit(m_root, fun);
	}
	
private:
	
	int GetDepth(TreeNode&lt;T&gt;* node)
	{
		if(node == NULL)
			return 0;
		node-&gt;m_depth = max(GetDepth(node-&gt;m_lch), GetDepth(node-&gt;m_rch)) + 1;
		return node-&gt;m_depth;
	}
	
	TreeNode&lt;T&gt;* FindTreeNode(TreeNode&lt;T&gt;* node, T data, int sort(T, T)=NULL)
	{
		if(node == NULL)
			return NULL;
		else if(node-&gt;m_data == data)
			return node;
		
		int cmp = 0;
		if(sort!=NULL)
			cmp = sort(data, node-&gt;m_data);
		else
			cmp = data - node-&gt;m_data;
		
		if(m_ascendorder)
		{
			if(cmp &gt;= 0)
				return FindTreeNode(node-&gt;m_rch, data);
			else
				return FindTreeNode(node-&gt;m_lch, data);
		}
		else
		{
			if(cmp &gt;= 0)
				return FindTreeNode(node-&gt;m_lch, data);
			else
				return FindTreeNode(node-&gt;m_rch, data);
				
		}
		return NULL;
	}

	
	void LeftBalance(TreeNode&lt;T&gt;* TT)
	{
		assert(TT-&gt;m_bf == TreeLH);
		TreeNode&lt;T&gt;* L = TT-&gt;m_lch;
		if(L-&gt;m_bf == TreeLH) // LL型树，插在树root的左孩子的左边
		{
			TT-&gt;m_bf = TreeEH;
			L-&gt;m_bf = TreeEH;
			Rotate_LL(TT);
		}
		else if(L-&gt;m_bf == TreeRH) //LR型树，插在树root的左孩子的右边,双旋处理
		{
			TreeNode&lt;T&gt;* lr = L-&gt;m_rch;
			if(lr-&gt;m_bf == TreeLH)
			{
				TT-&gt;m_bf = TreeRH;
				L-&gt;m_bf = TreeEH;
			}
			else if(lr-&gt;m_bf == TreeEH)
			{
				TT-&gt;m_bf = TreeEH;
				L-&gt;m_bf = TreeEH;
			}
			else if(lr-&gt;m_bf == TreeRH)//
			{
				TT-&gt;m_bf = TreeEH;
				L-&gt;m_bf = TreeLH;
			}
			
			lr-&gt;m_bf = TreeEH;
			Rotate_LR(TT);
		}
		else
			assert(false);
		
	}
	void RightBalance(TreeNode&lt;T&gt;* TT)
	{
		assert(TT-&gt;m_bf == TreeRH);
		TreeNode&lt;T&gt;* R = TT-&gt;m_rch;
		if(R-&gt;m_bf == TreeRH) //RR型树， 插在树root的右孩子的右边
		{
			TT-&gt;m_bf = TreeEH;
			R-&gt;m_bf = TreeEH;
			Rotate_RR(TT);
		}
		else if(R-&gt;m_bf == TreeLH)//RL型树，插在树root的右孩子的左边,双旋处理
		{
			TreeNode&lt;T&gt;* rl = R-&gt;m_lch;
			if(rl-&gt;m_bf == TreeLH)
			{
				TT-&gt;m_bf =TreeEH;
				R-&gt;m_bf = TreeRH;
				
			}
			else if(rl-&gt;m_bf == TreeEH)
			{
				TT-&gt;m_bf = TreeEH;
				R-&gt;m_bf = TreeEH;
			}
			else if(rl-&gt;m_bf == TreeRH)
			{
				TT-&gt;m_bf = TreeLH;
				R-&gt;m_bf = TreeEH;
			}
			
			rl-&gt;m_bf = TreeEH;
			Rotate_RL(TT);
		}
		else
			assert(false);
		
	}
	
	void AddChild(TreeNode&lt;T&gt;* TT, TreeNode&lt;T&gt;* node, int sort(T, T))
	{
		if(m_root == NULL)
		{
			m_root = node;
			return ;
		}
		
		int cmp = 0;
		if(sort)
			cmp = sort(node-&gt;m_data, TT-&gt;m_data);
		else
			cmp = node-&gt;m_data &lt; TT-&gt;m_data;
		
		if((m_ascendorder &amp;&amp; cmp &gt; 0) || (!m_ascendorder &amp;&amp; cmp &lt; 0))
		{
			if(TT-&gt;m_lch == NULL)
			{
				SetLChild(TT, node);
				return;
			}
			else
			{
				AddChild(TT-&gt;m_lch, node, sort);
				return;
			}
		}
		else
		{
			if(TT-&gt;m_rch == NULL)
			{
				SetRChild(TT, node);
				return;
			}
			else
			{
				AddChild(TT-&gt;m_rch, node, sort);
				return;
			}
		}
		assert(false);
	}
	
	
	//返回值是，TT的深度增加值
	int AVLAddChild(TreeNode&lt;T&gt;* TT, TreeNode&lt;T&gt;* node, int sort(T, T))
	{
		if(m_root == NULL)
		{
			m_root = node;
			m_root-&gt;m_bf = TreeEH;
			return 1;
		}
		
		int cmp = 0;
		if(sort)
			cmp = sort(node-&gt;m_data, TT-&gt;m_data);
		else
			cmp = node-&gt;m_data &lt; TT-&gt;m_data;
		
		if((m_ascendorder &amp;&amp; cmp &gt; 0) || (!m_ascendorder &amp;&amp; cmp &lt; 0))
		{
			if(TT-&gt;m_lch == NULL)
			{
				SetLChild(TT, node);
				node-&gt;m_bf = TreeEH;
				if(TT-&gt;m_rch == NULL)
				{
					assert(TT-&gt;m_bf == TreeEH);
					TT-&gt;m_bf = TreeLH;
					return 1;
				}
				else
				{
					assert(TT-&gt;m_bf == TreeRH);
					TT-&gt;m_bf = TreeEH;
					return 0;
				}
			}
			else
			{
				int ret = AVLAddChild(TT-&gt;m_lch, node, sort);
				if(ret) // 插入结果：TT的左树增加一层。
				{
					if(TT-&gt;m_bf == TreeLH)//TT本来就左树高，又在TT的左树增加1层。
					{
						LeftBalance(TT);
						return 0;
					}
					else if(TT-&gt;m_bf == TreeEH)
					{
						TT-&gt;m_bf = TreeLH;
						return 1;
					}
					else if(TT-&gt;m_bf == TreeRH)
					{
						TT-&gt;m_bf = TreeEH;
						return 0;
					}
				}
				else
					return ret; //equal return 0;
			}
		}
		else
		{
			if(TT-&gt;m_rch == NULL)
			{
				SetRChild(TT, node);
				node-&gt;m_bf = TreeEH;
				if(TT-&gt;m_lch == NULL)
				{
					assert(TT-&gt;m_bf == TreeEH);
					TT-&gt;m_bf = TreeRH;
					return 1;
				}
				else
				{
					assert(TT-&gt;m_bf==TreeLH);
					TT-&gt;m_bf = TreeEH;
					return 0;
				}
				
			}
			else
			{
				int ret = AVLAddChild(TT-&gt;m_rch, node, sort);
				if(ret)//插入结果：TT的右树增加一层。
				{
					if(TT-&gt;m_bf == TreeRH) //TT的右树高，又在右树上加一成
					{
						RightBalance(TT);
						return 0;
					}
					else if(TT-&gt;m_bf == TreeEH)
					{
						TT-&gt;m_bf = TreeRH;
						return 1;
					}
					else if(TT-&gt;m_bf == TreeLH)
					{
						TT-&gt;m_bf = TreeEH;
						return 0;
					}
				}
				else
					return ret;
			}
		}

		assert(false);
	}
	
	//前序遍历，每个节点使用函数fun访问
	void PreOrderVisit(TreeNode&lt;T&gt;* node,  dealTreeNode&lt;T&gt; fun)
	{
		if(node == NULL)
			return;
		if(fun!=NULL)
			fun(node);
		PreOrderVisit(node-&gt;m_lch, fun);
		PreOrderVisit(node-&gt;m_rch, fun);
	}
	
	//中序遍历，每个节点使用函数fun访问
	void InOrderVisit(TreeNode&lt;T&gt;* node,  dealTreeNode&lt;T&gt; fun)
	{
		if(node == NULL)
			return;
		InOrderVisit(node-&gt;m_lch, fun);
		if(fun!=NULL)
			fun(node);
		
#ifdef DEBUG //for check 
		{
			if(node-&gt;m_father!=NULL)
			{
				if(node!=m_root)
				{
					assert(node-&gt;m_father);
					assert(node-&gt;m_father != node);
					assert(node-&gt;m_lch!=node);
					assert(node-&gt;m_rch!=node);
					assert(node-&gt;m_father!=node-&gt;m_lch);
					assert(node-&gt;m_father!=node-&gt;m_rch);
				}
				else
				{
					assert(node-&gt;m_father == NULL);
					assert(node-&gt;m_lch!=node);
					assert(node-&gt;m_rch!=node);
				}
			
			}
			if(node-&gt;m_lch)
				assert(node-&gt;m_lch-&gt;m_father==node);
			if(node-&gt;m_rch)
				assert(node-&gt;m_rch-&gt;m_father==node);
		}
#endif
		InOrderVisit(node-&gt;m_rch, fun);
	}
	
	//后序遍历，每个节点使用函数fun访问
	void PostOrderVisit(TreeNode&lt;T&gt;* node,  dealTreeNode&lt;T&gt; fun)
	{
		if(node == NULL)
			return;
		PostOrderVisit(node-&gt;m_lch, fun);
		PostOrderVisit(node-&gt;m_rch, fun);
		if(fun!=NULL)
			fun(node);
	}
	
	//把L设置成node的左孩子
	void SetLChild(TreeNode&lt;T&gt;* node, TreeNode&lt;T&gt;* L)
	{
		if(node == NULL)
			return;
		node-&gt;m_lch = L;
		if(L)
			L-&gt;m_father = node;
	}
	
	//把R设置成node的右孩子
	void SetRChild(TreeNode&lt;T&gt;* node, TreeNode&lt;T&gt;* R)
	{
		if(node == NULL)
			return;
		node-&gt;m_rch = R;
		if(R)
			R-&gt;m_father = node;
	}
	//左左型树旋转,往右旋转
	void Rotate_LL(TreeNode&lt;T&gt;* root)
	{
		TreeNode&lt;T&gt;* rootf = root-&gt;m_father;
		TreeNode&lt;T&gt;* node = root-&gt;m_lch;
		if(rootf)
		{
			if(rootf-&gt;m_lch == root)
				SetLChild(rootf, node);
			else
				SetRChild(rootf, node);
		}
		else
		{
			m_root = node;
			m_root-&gt;m_father = NULL;
		}
		
		SetLChild(root, node-&gt;m_rch);
		SetRChild(node, root);
	}
	//右右型树旋转，往左旋转
	void Rotate_RR(TreeNode&lt;T&gt;* root)
	{
		
		TreeNode&lt;T&gt;* rootf = root-&gt;m_father;
		TreeNode&lt;T&gt;* node = root-&gt;m_rch;
		if(rootf)
		{
			if(rootf-&gt;m_lch == root)
				SetLChild(rootf, node);
			else
				SetRChild(rootf, node);
		}
		else
		{
			m_root = node;
			m_root-&gt;m_father = NULL;
		}
			
		SetRChild(root, node-&gt;m_lch);
		SetLChild(node, root);
	}
	//左右型树旋转
	void Rotate_LR(TreeNode&lt;T&gt;* root)
	{
		Rotate_RR(root-&gt;m_lch);
		Rotate_LL(root);
	}
	//右左型树旋转
	void Rotate_RL(TreeNode&lt;T&gt;* root)
	{
		Rotate_LL(root-&gt;m_rch);
		Rotate_RR(root);
	}
	
	TreeNode&lt;T&gt;* m_root = NULL;
	bool m_ascendorder = true; //是否升序排序
	bool m_bavl = false; //是否是平衡二叉树
	const static int TreeLH = 1;//左子树比右子树深度大1.
	const static int TreeEH = 0;//左子树和右子树深度一样.
	const static int TreeRH = -1;//右子树和子子树深度一样.
};



int main()
{	
	vector&lt;int &gt; v;
	int arr[] = {62,188,58,47,0,2,35,432,431,430,444,455,73,6,7,51,-10,1,99,37,828,88,93};
	static int allsum = 0;
	for(int i = 0 ; i &lt; arraysize(arr); ++i)
	{
		Tree&lt;double&gt; tree;
		tree.InitTree(arr, arraysize(arr));
		tree.DelTreeNode(tree.FindTreeNode(arr[i]));
		tree.InOrderVisit([](TreeNode&lt;double&gt;* node){
			cout &lt;&lt; node-&gt;m_data &lt;&lt; " ";
			allsum += node-&gt;m_data;
		});
		cout &lt;&lt; endl;
	}
	
	int sum = 0;
	for(int i = 0; i &lt;arraysize(arr); ++i)
		sum+=arr[i];
	
	assert(allsum/sum == arraysize(arr) -1);
	
	cout &lt;&lt; endl &lt;&lt; endl;
	int avltreedepth = 0;
	for(int i = 0 ; i &lt; arraysize(arr); ++i)
	{
		Tree&lt;double&gt; tree;
		tree.InitAVLTree(arr, arraysize(arr));
		tree.DelTreeNode(tree.FindTreeNode(arr[i]));
		tree.InOrderVisit([](TreeNode&lt;double&gt;* node){
			cout &lt;&lt; node-&gt;m_data &lt;&lt; " ";
			allsum += node-&gt;m_data;
		});
		cout &lt;&lt; endl;
	}

	cout &lt;&lt; endl;
	int arr1[] = {1,2,3,4,5,6,7,8};
	Tree&lt;double&gt; tree;
	tree.InitTree(arr1, arraysize(arr1));
	Tree&lt;double&gt; tree1;
	tree1.InitAVLTree(arr1, arraysize(arr1));
	cout &lt;&lt; "tree depth:" &lt;&lt; tree.GetTreeDepth() &lt;&lt; " AVLtree depth:" &lt;&lt; tree1.GetTreeDepth() &lt;&lt; endl;
	return 0;
}


</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7657d2cf0ef9d8d1eeaa6d5a56436c15/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">yolov5训练加速--一个可能忽视的细节（mmdetection也一样），为什么显卡使用率老是为0？（续）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/581f3d41319a11beeca4cec18e261da8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【BUUCTF Web】WriteUp超详细</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>