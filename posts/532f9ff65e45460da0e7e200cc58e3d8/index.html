<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MT7628移植移远EC20驱动实现4G上网功能（绝大多数使用openwrt的设备通用） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MT7628移植移远EC20驱动实现4G上网功能（绝大多数使用openwrt的设备通用）" />
<meta property="og:description" content="我的上一篇文章中完成对MT7628固件的编译，本文是在固件编译通过的基础上移植EC20驱动的，固件编译问题请参考上文。
在讲解之前先介绍移远的EC20模块，该模块是目前较为成熟的4G模块，可向安装了Windows、Linux等设备的机器提供4G上网服务，移远同类产品中还有AG35模块，这个模块我之前在AM4378上移植过，当时花费了好多时间才移植成功，其实移远产品做得也不错，同类的模块移植方法基本是一样的。
废话不多说，下面开始讲述EC20驱动在MT7628上的移植过程。
第一步：
修改源码（注意：固件必须要先编译过一轮，否则没有build_dir目录）。此步骤必须细心修改，并认真核对。以下路径中的源文件均需要修改才能使用：
/home/user/openwrt-sdk/build_dir/target-mipsel_24kec&#43;dsp_uClibc-0.9.33.2/linux-ramips_mt7628/linux-3.10.14/drivers/usb/serial/option.c
//大概在532行，添加如下代码 ...... static const struct usb_device_id option_ids[] = { #if 1 //Added by Quectel { USB_DEVICE(0x05C6, 0x9090) }, /* Quectel UC15 */ { USB_DEVICE(0x05C6, 0x9003) }, /* Quectel UC20 */ { USB_DEVICE(0x2C7C, 0x0125) }, /* Quectel EC25/EC20 R2.0 */ { USB_DEVICE(0x2C7C, 0x0121) }, /* Quectel EC21 */ { USB_DEVICE(0x05C6, 0x9215) }, /* Quectel EC20 */ { USB_DEVICE(0x2C7C, 0x0191) }, /* Quectel EG91 */ { USB_DEVICE(0x2C7C, 0x0195) }, /* Quectel EG95 */ { USB_DEVICE(0x2C7C, 0x0306) }, /* Quectel EG06/EP06/EM06 */ { USB_DEVICE(0x2C7C, 0x0296) }, /* Quectel BG96 */ #endif { USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) }, { USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) }, ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/532f9ff65e45460da0e7e200cc58e3d8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-31T12:23:59+08:00" />
<meta property="article:modified_time" content="2019-07-31T12:23:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MT7628移植移远EC20驱动实现4G上网功能（绝大多数使用openwrt的设备通用）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>我的上一篇文章中完成对MT7628固件的编译，本文是在固件编译通过的基础上移植EC20驱动的，固件编译问题请参考上文。</p> 
<p>在讲解之前先介绍移远的EC20模块，该模块是目前较为成熟的4G模块，可向安装了Windows、Linux等设备的机器提供4G上网服务，移远同类产品中还有AG35模块，这个模块我之前在AM4378上移植过，当时花费了好多时间才移植成功，其实移远产品做得也不错，同类的模块移植方法基本是一样的。</p> 
<p>废话不多说，下面开始讲述EC20驱动在MT7628上的移植过程。</p> 
<p> </p> 
<p><strong>第一步：</strong></p> 
<p>修改源码（注意：固件必须要先编译过一轮，否则没有build_dir目录）。此步骤必须细心修改，并认真核对。以下路径中的源文件均需要修改才能使用：</p> 
<p>/home/user/openwrt-sdk/build_dir/target-mipsel_24kec+dsp_uClibc-0.9.33.2/linux-ramips_mt7628/linux-3.10.14/drivers/usb/serial/option.c</p> 
<pre class="has"><code>//大概在532行，添加如下代码
......

static const struct usb_device_id option_ids[] = {

#if 1 //Added by Quectel
	{ USB_DEVICE(0x05C6, 0x9090) }, /* Quectel UC15 */ 
	{ USB_DEVICE(0x05C6, 0x9003) }, /* Quectel UC20 */ 
	{ USB_DEVICE(0x2C7C, 0x0125) }, /* Quectel EC25/EC20 R2.0 */
	{ USB_DEVICE(0x2C7C, 0x0121) }, /* Quectel EC21 */ 
	{ USB_DEVICE(0x05C6, 0x9215) }, /* Quectel EC20 */ 
	{ USB_DEVICE(0x2C7C, 0x0191) }, /* Quectel EG91 */ 
	{ USB_DEVICE(0x2C7C, 0x0195) }, /* Quectel EG95 */
	{ USB_DEVICE(0x2C7C, 0x0306) }, /* Quectel EG06/EP06/EM06 */
	{ USB_DEVICE(0x2C7C, 0x0296) }, /* Quectel BG96 */
#endif
	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
......</code></pre> 
<pre class="has"><code>//大概在1390行，插入以下代码
......

#ifdef CONFIG_PM
	.suspend           = usb_wwan_suspend,
	.resume            = usb_wwan_resume,
#if 1 //Added by Quectel
	.reset_resume = usb_wwan_resume, 
#endif

#endif
......</code></pre> 
<pre class="has"><code>//在大约1459行，插入以下代码
......

	if (dev_desc-&gt;idVendor == cpu_to_le16(SAMSUNG_VENDOR_ID) &amp;&amp;
	    dev_desc-&gt;idProduct == cpu_to_le16(SAMSUNG_PRODUCT_GT_B3730) &amp;&amp;
	    iface_desc-&gt;bInterfaceClass != USB_CLASS_CDC_DATA)
		return -ENODEV;
#if 1 //Added by Quectel
//Quectel UC20's interface 4 can be used as USB Network device
 if (serial-&gt;dev-&gt;descriptor.idVendor == cpu_to_le16(0x05C6) &amp;&amp; 
serial-&gt;dev-&gt;descriptor.idProduct == cpu_to_le16(0x9003) 
 &amp;&amp; serial-&gt;interface-&gt;cur_altsetting-&gt;desc.bInterfaceNumber &gt;= 4)return -ENODEV; 
//Quectel EC20's interface 4 can be used as USB Network device 
 if (serial-&gt;dev-&gt;descriptor.idVendor == cpu_to_le16(0x05C6) &amp;&amp; 
serial-&gt;dev-&gt;descriptor.idProduct == cpu_to_le16(0x9215) 
 &amp;&amp; serial-&gt;interface-&gt;cur_altsetting-&gt;desc.bInterfaceNumber &gt;= 4) 
 return -ENODEV; 
//Quectel EC25&amp;EC21&amp;EC20 R2.0&amp;EG91&amp;EG95&amp;EG06&amp;EP06&amp;EM06&amp;BG96's interface 4 can be 
//used as USB Network device 
 if (serial-&gt;dev-&gt;descriptor.idVendor == cpu_to_le16(0x2C7C) 
 &amp;&amp; serial-&gt;interface-&gt;cur_altsetting-&gt;desc.bInterfaceNumber &gt;= 4) 
 return -ENODEV; 
#endif
	/* Store device id so we can use it during attach. */
	usb_set_serial_data(serial, (void *)id);
......</code></pre> 
<p>/home/user/openwrt-sdk/build_dir/target-mipsel_24kec+dsp_uClibc-0.9.33.2/linux-ramips_mt7628/linux-3.10.14/drivers/usb/serial/<span style="color:#404040;">qcserial.c</span></p> 
<pre class="has"><code>//大概在81行，注释以下代码

//{USB_DEVICE(0x05c6, 0x9215)},	/* Acer Gobi 2000 Modem device (VP413) */</code></pre> 
<p>/home/user/openwrt-sdk/build_dir/target-mipsel_24kec+dsp_uClibc-0.9.33.2/linux-ramips_mt7628/linux-3.10.14/drivers/net/usb/<span style="color:#404040;">qmi_wwan.c</span></p> 
<pre class="has"><code>//大概在617行，注释以下代码

//{QMI_GOBI_DEVICE(0x05c6, 0x9215)},	/* Acer Gobi 2000 Modem device (VP413) */</code></pre> 
<pre class="has"><code>//在大概436行，插入以下代码
......

static const struct usb_device_id products[] = {
	
#if 1 //Added by Quectel
#ifndef QMI_FIXED_INTF 
/* map QMI/wwan function by a fixed interface number */ 
#define QMI_FIXED_INTF(vend, prod, num) \ 
 .match_flags = USB_DEVICE_ID_MATCH_DEVICE | 
USB_DEVICE_ID_MATCH_INT_INFO, \ 
 .idVendor = vend, \ 
 .idProduct = prod, \ 
 .bInterfaceClass = 0xff, \ 
 .bInterfaceSubClass = 0xff, \ 
 .bInterfaceProtocol = 0xff, \ 
 .driver_info = (unsigned long)&amp;qmi_wwan_force_int##num, 
#endif 
 { QMI_FIXED_INTF(0x05C6, 0x9003, 4) }, /* Quectel UC20 */ 
 { QMI_FIXED_INTF(0x2C7C, 0x0125, 4) }, /* Quectel EC25/EC20 R2.0 */
 { QMI_FIXED_INTF(0x2C7C, 0x0121, 4) }, /* Quectel EC21 */ 
{ QMI_FIXED_INTF(0x05C6, 0x9215, 4) }, /* Quectel EC20 */ 
{ QMI_FIXED_INTF(0x2C7C, 0x0191, 4) }, /* Quectel EG91 */
{ QMI_FIXED_INTF(0x2C7C, 0x0195, 4) }, /* Quectel EG95 */
{ QMI_FIXED_INTF(0x2C7C, 0x0306, 4) }, /* Quectel EG06/EP06/EM06 */
{ QMI_FIXED_INTF(0x2C7C, 0x0296, 4) }, /* Quectel BG96 */
#endif
......</code></pre> 
<pre class="has"><code>//在文件的开头处插入如下代码
......

#include &lt;linux/usb/usbnet.h&gt;
#include &lt;linux/usb/cdc-wdm.h&gt;

#if 1 //Added by Quectel 
#include &lt;linux/etherdevice.h&gt; 
struct sk_buff *qmi_wwan_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags) 
{ 
 if (dev-&gt;udev-&gt;descriptor.idVendor != cpu_to_le16(0x2C7C)) 
 return skb; 
 // Skip Ethernet header from message 
 if (skb_pull(skb, ETH_HLEN)) { 
 return skb; 
 } else { 
 dev_err(&amp;dev-&gt;intf-&gt;dev, "Packet Dropped "); 
 } 
 // Filter the packet out, release it 
 dev_kfree_skb_any(skb); 
 return NULL; 
} 
#include &lt;linux/version.h&gt; 
#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION( 3,9,1 )) 
static int qmi_wwan_rx_fixup(struct usbnet *dev, struct sk_buff *skb) 
{ 
 __be16 proto; 
 if (dev-&gt;udev-&gt;descriptor.idVendor != cpu_to_le16(0x2C7C)) 
 return 1;/* This check is no longer done by usbnet */ 
 if (skb-&gt;len &lt; dev-&gt;net-&gt;hard_header_len) 
 return 0; 
 switch (skb-&gt;data[0] &amp; 0xf0) { 
 case 0x40: 
 proto = htons(ETH_P_IP); 
 break; 
 case 0x60: 
 proto = htons(ETH_P_IPV6); 
 break; 
 case 0x00: 
 if (is_multicast_ether_addr(skb-&gt;data)) 
 return 1; 
 /* possibly bogus destination - rewrite just in case */ 
 skb_reset_mac_header(skb); 
 goto fix_dest; 
 default: 
 /* pass along other packets without modifications */ 
 return 1; 
 } 
 if (skb_headroom(skb) &lt; ETH_HLEN) 
 return 0; 
 skb_push(skb, ETH_HLEN); 
 skb_reset_mac_header(skb); 
 eth_hdr(skb)-&gt;h_proto = proto; 
 memset(eth_hdr(skb)-&gt;h_source, 0, ETH_ALEN); 
fix_dest: 
 memcpy(eth_hdr(skb)-&gt;h_dest, dev-&gt;net-&gt;dev_addr, ETH_ALEN); 
 return 1; 
} 
/* very simplistic detection of IPv4 or IPv6 headers */ 
static bool possibly_iphdr(const char *data) 
{ 
 return (data[0] &amp; 0xd0) == 0x40; 
} 
#endif 
#endif
......</code></pre> 
<pre class="has"><code>//在大概395行，插入如下代码
......

#if 1 //Added by Quectel
 if (dev-&gt;udev-&gt;descriptor.idVendor == cpu_to_le16(0x2C7C)) { 
 dev_info(&amp;intf-&gt;dev, "Quectel EC25&amp;EC21&amp;EC20 R2.0&amp;EG91&amp;EG95&amp;EG06&amp;EP06&amp;EM06&amp;BG96 work on RawIP mode\n"); 
 dev-&gt;net-&gt;flags |= IFF_NOARP; 
#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION( 3,9,1 )) 
 /* make MAC addr easily distinguishable from an IP header */ 
 if (possibly_iphdr(dev-&gt;net-&gt;dev_addr)) { 
 dev-&gt;net-&gt;dev_addr[0] |= 0x02; /* set local assignment bit */ 
 dev-&gt;net-&gt;dev_addr[0] &amp;= 0xbf; /* clear "IP" bit */ 
 } 
#endif 
 usb_control_msg( 
 interface_to_usbdev(intf), 
 usb_sndctrlpipe(interface_to_usbdev(intf), 0), 
 0x22, //USB_CDC_REQ_SET_CONTROL_LINE_STATE 
 0x21, //USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE 
 1, //active CDC DTR 
 intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber, 
 NULL, 0, 100); 
 } 
#endif
......</code></pre> 
<pre class="has"><code>//在大约504行，插入如下代码
......

static const struct driver_info	qmi_wwan_info = {
	.description	= "WWAN/QMI device",
	.flags		= FLAG_WWAN,
	.bind		= qmi_wwan_bind,
	.unbind		= qmi_wwan_unbind,
	.manage_power	= qmi_wwan_manage_power,
	.rx_fixup       = qmi_wwan_rx_fixup,
	
#if 1 //Added by Quectel 
	.tx_fixup = qmi_wwan_tx_fixup, 
#endif
......</code></pre> 
<p>/home/lusy/openwrt-sdk/build_dir/target-mipsel_24kec+dsp_uClibc-0.9.33.2/linux-ramips_mt7628/linux-3.10.14/drivers/usb/serial/<span style="color:#404040;">usb_wwan.c</span></p> 
<pre class="has"><code>//大概在460行，插入如下代码
......

usb_fill_bulk_urb(urb, serial-&gt;dev,
			  usb_sndbulkpipe(serial-&gt;dev, endpoint) | dir,
			  buf, len, callback, ctx);
#if 1 //Added by Quectel for Zero Packet
if (dir == USB_DIR_OUT) { 
 struct usb_device_descriptor *desc = &amp;serial-&gt;dev-&gt;descriptor; 
 if (desc-&gt;idVendor == cpu_to_le16(0x05C6) &amp;&amp; desc-&gt;idProduct == cpu_to_le16(0x9090)) 
urb-&gt;transfer_flags |= URB_ZERO_PACKET; 
 if (desc-&gt;idVendor == cpu_to_le16(0x05C6) &amp;&amp; desc-&gt;idProduct == cpu_to_le16(0x9003)) 
urb-&gt;transfer_flags |= URB_ZERO_PACKET; 
 if (desc-&gt;idVendor == cpu_to_le16(0x05C6) &amp;&amp; desc-&gt;idProduct == cpu_to_le16(0x9215)) 
urb-&gt;transfer_flags |= URB_ZERO_PACKET; 
 if (desc-&gt;idVendor == cpu_to_le16(0x2C7C)) 
urb-&gt;transfer_flags |= URB_ZERO_PACKET; 
} 
#endif
	return urb;
......</code></pre> 
<p> </p> 
<p><strong>第二步：</strong></p> 
<p>修改配置，在内核中添加一些选项来支持EC20。这里参考了别人的博客，网址如下：<a href="https://blog.csdn.net/hunzhangzui9837/article/details/85916965">https://blog.csdn.net/hunzhangzui9837/article/details/85916965</a></p> 
<p>#make menuconfig</p> 
<p>Kernel modules-&gt;USB Support</p> 
<p>照着图片配置就行。。。</p> 
<p><img alt="" class="has" height="718" src="https://images2.imgbox.com/c9/ca/PWgKp0qh_o.png" width="1200"></p> 
<p><img alt="" class="has" height="722" src="https://images2.imgbox.com/67/a7/FC5MsKsM_o.png" width="1200"></p> 
<p>Network-&gt;</p> 
<p>将以下选项编译进内核，但是我在我的make menuconfig中找不到wwan，先不管它，有就勾上。</p> 
<p>wwan</p> 
<p>chat</p> 
<p>ppp</p> 
<p>uqmi</p> 
<p>Utilities-&gt;</p> 
<p>将以下选项编译进内核，同样没找到comgt-ncm，不管它</p> 
<p>comgt</p> 
<p>comgt-ncm</p> 
<p>usb-modeswitch</p> 
<p>Luci-&gt;</p> 
<p>1.Collections</p> 
<p>luci</p> 
<p>3.Applications</p> 
<p>luci-app-multiwan</p> 
<p>luci-app-qos</p> 
<p>6.Protocols</p> 
<p>luci-proto-3g</p> 
<p>luci-proto-ppp</p> 
<p>全都配置完了，开始编译</p> 
<p>#make V=s</p> 
<p>没有问题，全部编译成功。</p> 
<p> </p> 
<p><strong>第三步：</strong></p> 
<p>将编译好的固件烧入开发板。固件在/home/user/openwrt-sdk/bin/ramips路径下，名称为openwrt-ramips-mt7628-mt7628-squashfs-sysupgrade.bin。</p> 
<p>启动开发板，先用</p> 
<p>#ifconfig</p> 
<p>查看一下当前ip地址，然后将ip地址复制到浏览器打开，即可通过LuCI登录板子进行配置。</p> 
<p><img alt="" class="has" height="333" src="https://images2.imgbox.com/a0/87/iFG2tMUW_o.png" width="807"></p> 
<p>选择如上图所示进入固件更新页面，进入如下页面</p> 
<p><img alt="" class="has" height="750" src="https://images2.imgbox.com/ee/c8/6iPpHeV1_o.png" width="1200"></p> 
<p>在这个页面更新固件就可以了。</p> 
<p>更新完成后，就可以将EC20通过USB插入开发板了，如果你的驱动移植成功，将会看到如下log：</p> 
<p><img alt="" class="has" height="219" src="https://images2.imgbox.com/d2/1d/eoLJTSZ2_o.png" width="851"></p> 
<p>#cd /dev</p> 
<p>查看一下是否有这几个文件。</p> 
<p><img alt="" class="has" height="464" src="https://images2.imgbox.com/74/68/fr3LD5VQ_o.png" width="757"></p> 
<p> </p> 
<p><strong>第四步：</strong></p> 
<p>怎么通过4G模块上网。先进入LuCI页面。</p> 
<p><img alt="" class="has" height="442" src="https://images2.imgbox.com/66/c8/LxZ4aWvN_o.png" width="1200"></p> 
<p>如上图，进入接口配置。这里需要添加一个接口，下图已经添加好了，我下面教大家怎么添加。</p> 
<p><img alt="" class="has" height="798" src="https://images2.imgbox.com/76/cc/8NTMcpFN_o.png" width="1200"></p> 
<p>点击Add new interface，名字自己起一个，选DHCP，选wwan0，如下图所示。</p> 
<p><img alt="" class="has" height="743" src="https://images2.imgbox.com/c7/89/AGVwDt3K_o.png" width="867"></p> 
<p>完成后记得修改一下这个接口的防火墙，如下图。</p> 
<p><img alt="" class="has" height="442" src="https://images2.imgbox.com/c2/8a/BdxD5Jhn_o.png" width="1200"></p> 
<p>保存退出，最好板子也重启一下。</p> 
<p>再次进入板子，输入</p> 
<p>#ifconfig</p> 
<p>就能看到你新加的接口了，4G网络正常的话这个接口应能获取到IP地址。</p> 
<p><img alt="" class="has" height="233" src="https://images2.imgbox.com/1a/59/BeA1lxRP_o.png" width="787"></p> 
<p>#ping www.baidu.com</p> 
<p>PING www.baidu.com (183.232.231.172): 56 data bytes<br> 64 bytes from 183.232.231.172: seq=0 ttl=53 time=131.616 ms<br> 64 bytes from 183.232.231.172: seq=1 ttl=53 time=107.725 ms<br> 64 bytes from 183.232.231.172: seq=2 ttl=53 time=112.723 ms<br> 64 bytes from 183.232.231.172: seq=3 ttl=53 time=113.865 ms</p> 
<p>OK，大功告成！</p> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cdaad498aa0b6824bc79c771529f5ddf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">eslint-disable-next-line</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/36c4d48575fbd03b14590f299bed1c28/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue 路由跳转返回上一级</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>