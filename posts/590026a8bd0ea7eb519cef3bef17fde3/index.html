<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《内部排序算法比较》 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《内部排序算法比较》" />
<meta property="og:description" content="《内部排序算法比较》 一、【问题描述】
在教科书中，各种内部排序算法的时间复杂度分析结果只给出算法的大致执行时间。试通过随机数据比较各算法的关键字比较次数和关键字移动次数，以获得直观感受
【基本要求】
（1） 对6种常用内部排序算法进行比较：冒泡排序、直接插入排序、简单选择排序、快速排序、希尔排序、堆排序
（2） 待排序的表长不小于100，其中数据要用伪随机数产生，至少用5组不同的输入数据做比较
（3） 比较指标为关键字参加的比较次数和关键字的移动次数
二、概要设计
1(可排序表的抽象数据类型定义:
ADT OrderableList{
数据对象:D={ai|ai?IntegerSet,i=1,2,„,n,n?0}
数据关系:R1={&lt;ai-1,ai&gt;|ai-1,ai?D,i=2,„,n}
基本操作:
InitList(n)
操作结果:构造一个长度为n，元素值依次为1，2，„,n的有序表。
RandomizeList(d,isInverseOrder)
操作结果:首先根据isInverseOrder为True或False,将表置为逆序或正序，然后将表进行d(0
?d?8)级随机打乱。d为0时表不打乱，d越大，打乱程度越高。
RecallList()
操作结果:恢复最后一次用RandomizeList随机打乱得到的可排序表。
ListLength()
操作结果:返回可排序表的长度。
ListEmpty()
操作结果:若可排序表为空表，则返回Ture，否则返回False。
BubbleSort( &amp;c, &amp;s)
操作结果:进行起泡排序，返回关键字比较次数c和移动次数s。
InsertSort( &amp;c, &amp;s)
操作结果:进行插入排序，返回关键字比较次数c和移动次数s。
SelectSort ( &amp;c, &amp;s)
操作结果:进行选择排序，返回关键字比较次数c和移动次数s。
QuickSort(&amp;c, &amp;s)
操作结果:进行快速排序，返回关键字比较次数c和移动次数s。
ShellSort(long &amp;c, long &amp;s)
操作结果:进行希尔排序，返回关键字比较次数c和移动次数s。
HeapSort (&amp;c, &amp;s)
操作结果:进行堆排序，返回关键字比较次数c和移动次数s。
ListTraverse(visit())
操作结果:依次对L中的每个元素调用函数visit()。 }ADT OrderableList
2(本程序包含两个模块:
1)主程序模块
void main(){
初始化;
do{
接受命令;
处理命令;
}while(“命令”～=“退出”);
}
2)可排序表单元模块——实现可排序表的抽象数据类型; 各模块之间的调用关系如下:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/590026a8bd0ea7eb519cef3bef17fde3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-12-13T19:24:18+08:00" />
<meta property="article:modified_time" content="2018-12-13T19:24:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《内部排序算法比较》</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_1"></a><strong>《内部排序算法比较》</strong></h2> 
<p>一、【问题描述】<br> 在教科书中，各种内部排序算法的时间复杂度分析结果只给出算法的大致执行时间。试通过随机数据比较各算法的关键字比较次数和关键字移动次数，以获得直观感受<br> 【基本要求】<br> （1） 对6种常用内部排序算法进行比较：冒泡排序、直接插入排序、简单选择排序、快速排序、希尔排序、堆排序<br> （2） 待排序的表长不小于100，其中数据要用伪随机数产生，至少用5组不同的输入数据做比较<br> （3） 比较指标为关键字参加的比较次数和关键字的移动次数</p> 
<p>二、概要设计<br> 1(可排序表的抽象数据类型定义:<br> ADT OrderableList{<!-- --><br> 数据对象:D={ai|ai?IntegerSet,i=1,2,„,n,n?0}<br> 数据关系:R1={&lt;ai-1,ai&gt;|ai-1,ai?D,i=2,„,n}<br> 基本操作:<br> InitList(n)<br> 操作结果:构造一个长度为n，元素值依次为1，2，„,n的有序表。<br> RandomizeList(d,isInverseOrder)<br> 操作结果:首先根据isInverseOrder为True或False,将表置为逆序或正序，然后将表进行d(0<br> ?d?8)级随机打乱。d为0时表不打乱，d越大，打乱程度越高。<br> RecallList()<br> 操作结果:恢复最后一次用RandomizeList随机打乱得到的可排序表。<br> ListLength()<br> 操作结果:返回可排序表的长度。<br> ListEmpty()<br> 操作结果:若可排序表为空表，则返回Ture，否则返回False。<br> BubbleSort( &amp;c, &amp;s)<br> 操作结果:进行起泡排序，返回关键字比较次数c和移动次数s。<br> InsertSort( &amp;c, &amp;s)<br> 操作结果:进行插入排序，返回关键字比较次数c和移动次数s。<br> SelectSort ( &amp;c, &amp;s)<br> 操作结果:进行选择排序，返回关键字比较次数c和移动次数s。<br> QuickSort(&amp;c, &amp;s)<br> 操作结果:进行快速排序，返回关键字比较次数c和移动次数s。<br> ShellSort(long &amp;c, long &amp;s)<br> 操作结果:进行希尔排序，返回关键字比较次数c和移动次数s。<br> HeapSort (&amp;c, &amp;s)<br> 操作结果:进行堆排序，返回关键字比较次数c和移动次数s。<br> ListTraverse(visit())<br> 操作结果:依次对L中的每个元素调用函数visit()。 }ADT OrderableList<br> 2(本程序包含两个模块:<br> 1)主程序模块<br> void main(){<!-- --><br> 初始化;<br> do{<!-- --><br> 接受命令;<br> 处理命令;<br> }while(“命令”～=“退出”);<br> }<br> 2)可排序表单元模块——实现可排序表的抽象数据类型; 各模块之间的调用关系如下:<br> 主程序模块<br> 可排序表单元模块<br> 三、详细设计<br> 1(根据题目要求和可排序表的基本操作特点，可排序表采用整数顺序表存储结构。</p> 
<pre><code>  //可排序表的元素类型 
    #define MAXSIZE 10000 //用作示例的顺序表的最大长度 typedef int BOOL; 
    typedef struct{ 
    int key; //关键字项 
    } RedType; //记录类型 
    typedef struct LinkList{ 
    RedType r[MAXSIZE]; 
    int Length; //顺序表长度 } LinkList; 
    int RandArray[MAXSIZE]; //内部操作 
    void RandomNum(){ 
    int i; 
    srand(20000); 
    for (i = 0; i &lt; MAXSIZE; i++) 
    RandArray[i] = (int)rand(); //构建随机序列 } 
    void InitLinkList(LinkList *L){ //建立表 
    int i; 
    memset(L, 0, sizeof(LinkList)); 
    RandomNum(); 
    for (i = 0; i &lt; MAXSIZE; i++) 
    L-&gt;r[i].key = RandArray[i]; //赋值 
    L-&gt;Length = i; 
    } 
    bool LT(int i, int j, int *CmpNum){ //比较i与j大小，返回0或1 
    (*CmpNum)++; 
    if (i &lt; j) 
    return TRUE; 
    else 
    return FALSE; 
    } 
    void Display(LinkList *L){ //存储表到SortRes.txt文件中 
    FILE *f; 
    int i; 
    if ((f = fopen("SortRes.txt", "w")) == NULL){ 
    printf("can't open file\n"); 
    exit(0); 
    } 
    for (i = 0; i &lt; L-&gt;Length; i++) 
    fprintf(f, "%d\n", L-&gt;r[i].key); 
    fclose(f); 
    } 
    //部分操作的伪码算法 
    //希尔排序 
    void ShellInsert(LinkList *L, int dk, int *CmpNum, int *ChgNum){ 
    int i, j; 
    RedType Temp; 
    for (i = dk; i &lt; L-&gt;Length; i++){ 
    if (LT(L-&gt;r[i].key, L-&gt;r[i - dk].key, CmpNum)){ 
    memcpy(&amp;Temp, &amp;L-&gt;r[i], sizeof(RedType)); 
    for (j = i - dk; j &gt;= 0 &amp;&amp; LT(Temp.key, L-&gt;r[j].key, CmpNum); j -= dk){ 
    (*ChgNum)++; 
    memcpy(&amp;L-&gt;r[j + dk], &amp;L-&gt;r[j], sizeof(RedType)); 
    } 
    memcpy(&amp;L-&gt;r[j + dk], &amp;Temp, sizeof(RedType)); 
    } 
    } 
    } 
    void ShellSort(LinkList *L, int dlta[], int t, int *CmpNum, int *ChgNum){ 
    int k; 
    for (k = 0; k &lt; t; k++) 
    ShellInsert(L, dlta[k], CmpNum, ChgNum); 
    } 
    //快速排序 
    int Partition(LinkList *L, int low, int high, int *CmpNum, int *ChgNum){ 
    RedType Temp; 
    int PivotKey; 
    memcpy(&amp;Temp, &amp;L-&gt;r[low], sizeof(RedType)); 
    PivotKey = L-&gt;r[low].key; 
    while (low &lt; high){ 
    while (low &lt; high &amp;&amp; L-&gt;r[high].key &gt;= PivotKey){ 
    high--; 
    (*CmpNum)++; 
    } 
    (*ChgNum)++; 
    memcpy(&amp;L-&gt;r[low], &amp;L-&gt;r[high], sizeof(RedType)); 
    while (low &lt; high &amp;&amp; L-&gt;r[low].key &lt;= PivotKey){ 
    low++; 
    (*CmpNum)++; 
    } 
    (*ChgNum)++; 
    memcpy(&amp;L-&gt;r[high], &amp;L-&gt;r[low], sizeof(RedType)); 
    } 
    memcpy(&amp;L-&gt;r[low], &amp;Temp, sizeof(RedType)); 
    return low; 
    } 
    void QSort(LinkList *L, int low, int high, int *CmpNum, int *ChgNum){ 
    int PivotLoc = 0; 
    if (low &lt; high){ 
    PivotLoc = Partition(L, low, high, CmpNum, ChgNum); 
    QSort(L, low, PivotLoc - 1, CmpNum, ChgNum); 
    QSort(L, PivotLoc + 1, high, CmpNum, ChgNum); 
    } 
    } 
    void QuickSort(LinkList *L, int *CmpNum, int *ChgNum){ 
    QSort(L, 0, L-&gt;Length - 1, CmpNum, ChgNum); } 
    //堆排序 
    void HeapAdjust(LinkList *L, int s, int m, int *CmpNum, int *ChgNum){ 
    RedType Temp; 
    int j = 0; 
    s++; 
    memcpy(&amp;Temp, &amp;L-&gt;r[s - 1], sizeof(RedType)); 
    for (j = 2 * s; j &lt;= m; j *= 2){ 
    if (j &lt; m &amp;&amp; LT(L-&gt;r[j - 1].key, L-&gt;r[j].key, CmpNum)) 
    ++j; 
    if (!LT(Temp.key, L-&gt;r[j - 1].key, CmpNum)) 
    break; 
    (*ChgNum)++; 
    memcpy(&amp;L-&gt;r[s - 1], &amp;L-&gt;r[j - 1], sizeof(RedType)); 
    s = j; 
    } 
    memcpy(&amp;L-&gt;r[s - 1], &amp;Temp, sizeof(RedType)); } 
    void HeapSort(LinkList *L, int *CmpNum, int *ChgNum){ 
    int i = 0; 
    RedType Temp; 
    for (i = L-&gt;Length / 2-1; i &gt;= 0; i--) 
    HeapAdjust(L, i, L-&gt;Length, CmpNum, ChgNum); 
    for (i = L-&gt;Length; i &gt; 1; i--){ 
    memcpy(&amp;Temp, &amp;L-&gt;r[0], sizeof(RedType)); 
    (*ChgNum)++; 
    memcpy(&amp;L-&gt;r[0], &amp;L-&gt;r[i - 1], sizeof(RedType)); 
    memcpy(&amp;L-&gt;r[i - 1], &amp;Temp, sizeof(RedType)); 
    HeapAdjust(L, 0, i - 1, CmpNum, ChgNum); 
    } 
    } 
    //冒泡排序 
    void BubbleSort(LinkList *L, int *CmpNum, int *ChgNum){ 
    int i, j; 
    RedType temp; 
    for (i = 1; i &lt;= MAXSIZE; i++){ 
    for (j = 1; j &lt;= MAXSIZE - i; j++){ 
    if (!LT(L-&gt;r[j].key, L-&gt;r[j + 1].key, CmpNum)){ 
    (*ChgNum)++; 
    memcpy(&amp;temp, &amp;L-&gt;r[j], sizeof(RedType)); 
    memcpy(&amp;L-&gt;r[j], &amp;L-&gt;r[j + 1], sizeof(RedType)); 
    memcpy(&amp;L-&gt;r[j + 1], &amp;temp, sizeof(RedType)); 
    } 
    } 
    } 
    } 
    //选择排序 
    int SelectMinKey(LinkList *L, int k, int *CmpNum){ 
    int Min = k; 
    for (; k &lt; L-&gt;Length; k++){ 
    if (!LT(L-&gt;r[Min].key, L-&gt;r[k].key, CmpNum)) 
    Min = k; 
    } 
    return Min; 
    } 
    void SelSort(LinkList *L, int *CmpNum, int *ChgNum){ 
    int i, j; 
    RedType temp; 
    for (i = 0; i &lt; L-&gt;Length; i++){ 
    j = SelectMinKey(L, i, CmpNum); 
    if (i != j){ 
    (*ChgNum)++; 
    memcpy(&amp;temp, &amp;L-&gt;r[i], sizeof(RedType)); 
    memcpy(&amp;L-&gt;r[i], &amp;L-&gt;r[j], sizeof(RedType)); 
    memcpy(&amp;L-&gt;r[j], &amp;temp, sizeof(RedType)); 
    } 
    } 
    } 
</code></pre> 
<p>四：调试分析：<br> <img src="https://images2.imgbox.com/b2/9f/B8mAMcFW_o.jpg" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ed/2c/RCH5vC3r_o.jpg" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ed/de/Qn7ZQIsz_o.jpg" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/50/c7/bKD6FNHh_o.jpg" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/82/fd/C5XAZ8IS_o.jpg" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/bb/ba/2ZsZ8UJG_o.jpg" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/89/4c/QnUE3jiR_o.jpg" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/cc/40/F8eaUmiz_o.jpg" alt="在这里插入图片描述"><br> 五、代码清单：</p> 
<pre><code>内部排序算法比较.cpp 
//主程序 
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;string.h&gt; 
#include &lt;time.h&gt; 
#include &lt;windows.h&gt; 
#include &lt;winbase.h&gt; 
#define MAXSIZE 5000 
#define TRUE 1 
#define FALSE 0 
typedef int BOOL; 
typedef struct{ 
int key; 
} RedType; 
typedef struct LinkList{ 
RedType r[MAXSIZE+1]; 
int Length; 
} LinkList; 
int RandArray[MAXSIZE+1]; 
void RandomNum(){ 
int i; 
srand(2000); 
for (i = 1; i &lt;= MAXSIZE; i++) 
RandArray[i] = (int)rand(); } 
void InitLinkList(LinkList *L){ 
int i; 
memset(L, 0, sizeof(LinkList)); 
RandomNum(); 
for (i = 1; i &lt;= MAXSIZE; i++) 
L-&gt;r[i].key = RandArray[i]; 
L-&gt;Length = i; 
} 
bool LT(int i, int j, int *CmpNum){ 
(*CmpNum)++; 
if (i &lt; j) 
return TRUE; 
else 
return FALSE; 
} 
void Display(LinkList *L){ 
FILE *f; 
int i; 
if ((f = fopen("SortRes.txt", "w")) == NULL){ 
printf("can't open file\n"); 
exit(0); 
} 
for (i = 0; i &lt; L-&gt;Length; i++) 
fprintf(f, "%d\n", L-&gt;r[i].key); 
fclose(f); 
} 
//希尔排序 
void ShellInsert(LinkList *L, int dk, int *CmpNum, int *ChgNum){ 
int i, j; 
RedType Temp; 
for (i = dk; i &lt; L-&gt;Length; i++){ 
if (LT(L-&gt;r[i].key, L-&gt;r[i - dk].key, CmpNum)){ 
memcpy(&amp;Temp, &amp;L-&gt;r[i], sizeof(RedType)); 
for (j = i - dk; j &gt;= 0 &amp;&amp; LT(Temp.key, L-&gt;r[j].key, CmpNum); j -= dk){ 
(*ChgNum)++; 
memcpy(&amp;L-&gt;r[j + dk], &amp;L-&gt;r[j], sizeof(RedType)); 
} 
memcpy(&amp;L-&gt;r[j + dk], &amp;Temp, sizeof(RedType)); 
} 
} 
} 
void ShellSort(LinkList *L, int dlta[], int t, int *CmpNum, int *ChgNum){ 
int k; 
for (k = 0; k &lt; t; k++) 
ShellInsert(L, dlta[k], CmpNum, ChgNum); } 
//快速排序 
int Partition(LinkList *L, int low, int high, int *CmpNum, int *ChgNum){ 
RedType Temp; 
int PivotKey; 
memcpy(&amp;Temp, &amp;L-&gt;r[low], sizeof(RedType)); 
PivotKey = L-&gt;r[low].key; 
while (low &lt; high){ 
while (low &lt; high &amp;&amp; L-&gt;r[high].key &gt;= PivotKey){ 
high--; 
(*CmpNum)++; 
} 
(*ChgNum)++; 
memcpy(&amp;L-&gt;r[low], &amp;L-&gt;r[high], sizeof(RedType)); 
while (low &lt; high &amp;&amp; L-&gt;r[low].key &lt;= PivotKey){ 
low++; 
(*CmpNum)++; 
} 
(*ChgNum)++; 
memcpy(&amp;L-&gt;r[high], &amp;L-&gt;r[low], sizeof(RedType)); 
} 
memcpy(&amp;L-&gt;r[low], &amp;Temp, sizeof(RedType)); 
return low; 
} 
void QSort(LinkList *L, int low, int high, int *CmpNum, int *ChgNum){ 
int PivotLoc = 0; 
if (low &lt; high){ 
PivotLoc = Partition(L, low, high, CmpNum, ChgNum); 
QSort(L, low, PivotLoc - 1, CmpNum, ChgNum); 
QSort(L, PivotLoc + 1, high, CmpNum, ChgNum); 
} 
} 
void QuickSort(LinkList *L, int *CmpNum, int *ChgNum){ 
QSort(L, 0, L-&gt;Length - 1, CmpNum, ChgNum); } 
//堆排序 
void HeapAdjust(LinkList *L, int s, int m, int *CmpNum, int *ChgNum){ 
RedType Temp; 
int j = 0; 
s++; 
memcpy(&amp;Temp, &amp;L-&gt;r[s - 1], sizeof(RedType)); 
for (j = 2 * s; j &lt;= m; j *= 2){ 
if (j &lt; m &amp;&amp; LT(L-&gt;r[j - 1].key, L-&gt;r[j].key, CmpNum)) 
++j; 
if (!LT(Temp.key, L-&gt;r[j - 1].key, CmpNum)) 
break; 
(*ChgNum)++; 
memcpy(&amp;L-&gt;r[s - 1], &amp;L-&gt;r[j - 1], sizeof(RedType)); 
s = j; 
} 
memcpy(&amp;L-&gt;r[s - 1], &amp;Temp, sizeof(RedType)); } 
void HeapSort(LinkList *L, int *CmpNum, int *ChgNum){ 
int i = 0; 
RedType Temp; 
for (i = L-&gt;Length / 2-1; i &gt;= 0; i--) 
HeapAdjust(L, i, L-&gt;Length, CmpNum, ChgNum); 
for (i = L-&gt;Length; i &gt; 1; i--){ 
memcpy(&amp;Temp, &amp;L-&gt;r[0], sizeof(RedType)); 
(*ChgNum)++; 
memcpy(&amp;L-&gt;r[0], &amp;L-&gt;r[i - 1], sizeof(RedType)); 
memcpy(&amp;L-&gt;r[i - 1], &amp;Temp, sizeof(RedType)); 
HeapAdjust(L, 0, i - 1, CmpNum, ChgNum); 
} 
} 
//冒泡排序 
void BubbleSort(LinkList *L, int *CmpNum, int *ChgNum){ 
int i, j; 
RedType temp; 
for (i = 1; i &lt;= MAXSIZE; i++){ 
for (j = 1; j &lt;= MAXSIZE - i; j++){ 
if (!LT(L-&gt;r[j].key, L-&gt;r[j + 1].key, CmpNum)){ 
(*ChgNum)++; 
memcpy(&amp;temp, &amp;L-&gt;r[j], sizeof(RedType)); 
memcpy(&amp;L-&gt;r[j], &amp;L-&gt;r[j + 1], sizeof(RedType)); 
memcpy(&amp;L-&gt;r[j + 1], &amp;temp, sizeof(RedType)); 
} 
} 
} 
} 
//选择排序 
int SelectMinKey(LinkList *L, int k, int *CmpNum){ 
int Min = k; 
for (; k &lt; L-&gt;Length; k++){ 
if (!LT(L-&gt;r[Min].key, L-&gt;r[k].key, CmpNum)) 
Min = k; 
} 
return Min; 
} 
void SelSort(LinkList *L, int *CmpNum, int *ChgNum){ 
int i, j; 
RedType temp; 
for (i = 0; i &lt; L-&gt;Length; i++){ 
j = SelectMinKey(L, i, CmpNum); 
if (i != j){ 
(*ChgNum)++; 
memcpy(&amp;temp, &amp;L-&gt;r[i], sizeof(RedType)); 
memcpy(&amp;L-&gt;r[i], &amp;L-&gt;r[j], sizeof(RedType)); 
memcpy(&amp;L-&gt;r[j], &amp;temp, sizeof(RedType)); 
} 
} 
} 
void SelectSort(){ 
printf("1. 插入排序\n"); 
printf("2. 希尔排序\n"); 
printf("3. 快速排序\n"); 
printf("4. 堆排序\n"); 
printf("5. 冒泡排序\n"); 
printf("6. 选择排序\n"); 
printf("7. 以上所有排序方式\n"); 
printf("8. 退出程序\n\n"); 
printf("Please Select the Operate:"); } 
void AllAbove(LinkList *L, int *CmpNum, int *ChgNum){ 
int TempTime, i,j; 
int SpendTime; 
int dlta[3] = { 
7, 3, 1 
}; 
int Indata[1] = { 
1 
}; 
for (i = 1; i &lt;= MAXSIZE; i++) 
L-&gt;r[i].key = RandArray[i]; //随机数列复位 
printf("\n插入排序:\n"); 
TempTime = (int)GetTickCount(); 
ShellSort(L, Indata, 1, &amp;CmpNum[0], &amp;ChgNum[0]); 
SpendTime = (int)GetTickCount() - TempTime; 
printf("\nCompareNumber=%d\tChageNumber=%d\tTimeSpent=%dms\n", CmpNum[0], 
ChgNum[0],SpendTime); 
for (i = 1; i &lt;= MAXSIZE; i++) 
L-&gt;r[i].key = RandArray[i]; //随机数列复位 
printf("\n希尔排序:\n"); 
TempTime = (int)GetTickCount(); 
ShellSort(L, dlta, 3, &amp;CmpNum[1], &amp;ChgNum[1]); 
SpendTime = (int)GetTickCount() - TempTime; 
printf("\nCompareNumber=%d\tChageNumber=%d\tTimeSpent=%dms\n", CmpNum[1], 
ChgNum[1],SpendTime); 
for (i = 1; i &lt;= MAXSIZE; i++) 
L-&gt;r[i].key = RandArray[i]; //随机数列复位 
printf("\n快速排序:\n"); 
TempTime = (int)GetTickCount(); 
QuickSort(L, &amp;CmpNum[2], &amp;ChgNum[2]); 
SpendTime = (int)GetTickCount() - TempTime; 
printf("\nCompareNumber=%d\tChageNumber=%d\tTimeSpent=%dms\n", CmpNum[2], 
ChgNum[2],SpendTime); 
for (i = 1; i &lt;= MAXSIZE; i++) 
L-&gt;r[i].key = RandArray[i]; //随机数列复位 
printf("\n堆排序:\n"); 
TempTime = (int)GetTickCount(); 
HeapSort(L, &amp;CmpNum[3], &amp;ChgNum[3]); 
SpendTime = (int)GetTickCount() - TempTime; 
printf("\nCompareNumber=%d\tChageNumber=%d\tTimeSpent=%dms\n", CmpNum[3], 
ChgNum[3],SpendTime); 
for (i = 1; i &lt;= MAXSIZE; i++) 
L-&gt;r[i].key = RandArray[i]; //随机数列复位 
printf("\n冒泡排序:\n"); 
TempTime = (int)GetTickCount(); 
BubbleSort(L, &amp;CmpNum[4], &amp;ChgNum[4]); 
SpendTime = (int)GetTickCount() - TempTime; 
printf("\nCompareNumber=%d\tChageNumber=%d\tTimeSpent=%dms\n", CmpNum[4], 
ChgNum[4],SpendTime); 
for (i = 1; i &lt;= MAXSIZE; i++) 
L-&gt;r[i].key = RandArray[i]; //随机数列复位 
printf("\n选择排序:\n"); 
TempTime = (int)GetTickCount(); 
SelSort(L, &amp;CmpNum[5], &amp;ChgNum[5]); 
SpendTime = (int)GetTickCount() - TempTime; 
printf("\nCompareNumber=%d\tChageNumber=%d\tTimeSpent=%dms\n", CmpNum[5], 
ChgNum[5],SpendTime); 
} 
void main(){ 
int i,j; 
int select = 0; 
int dlta[3] = {7, 3, 1}; 
int Indata[1] = {1}; 
int CmpNum[8], ChgNum[8]; 
int SpendTime = 0; 
int TempTime; 
LinkList L; 
InitLinkList(&amp;L); 
memset(CmpNum, 0, sizeof(CmpNum)); 
memset(ChgNum, 0, sizeof(ChgNum)); 
do{ 
SelectSort(); 
for (i = 0; i &lt; MAXSIZE; i++) 
L.r[i].key = RandArray[i]; //随机数列复位 
scanf("%d", &amp;select); 
switch (select){ 
case 1: 
printf("\n插入排序:\n"); 
TempTime = (int)GetTickCount(); 
ShellSort(&amp;L, Indata, 1, &amp;CmpNum[select], &amp;ChgNum[select]); 
SpendTime = (int)GetTickCount() - TempTime; 
for(i=1;i&lt;=MAXSIZE;i++){ 
printf("%5d ",L.r[i].key); 
if(++j%10==0)printf("\n"); 
} 
printf("\n\nCompareNumber=%d\tChageNumber=%d\tTimeSpent=%dms\n", 
CmpNum[select],ChgNum[select], SpendTime); 
break; 
case 2: 
printf("\n希尔排序:\n"); 
TempTime = (int)GetTickCount(); 
ShellSort(&amp;L, dlta, 3, &amp;CmpNum[select], &amp;ChgNum[select]); 
SpendTime = (int)GetTickCount() - TempTime; 
for(i=1;i&lt;=MAXSIZE;i++){ 
printf("%5d ",L.r[i].key); 
if(++j%10==0)printf("\n"); 
} 
printf("\n\nCompareNumber=%d\tChageNumber=%d\tTimeSpent=%dms\n", 
CmpNum[select],ChgNum[select], SpendTime); 
break; 
case 3: 
printf("\n快速排序:\n"); 
TempTime = (int)GetTickCount(); 
QuickSort(&amp;L, &amp;CmpNum[select], &amp;ChgNum[select]); 
SpendTime = (int)GetTickCount() - TempTime; 
for(i=1;i&lt;=MAXSIZE;i++){ 
printf("%5d ",L.r[i].key); 
if(++j%10==0)printf("\n"); 
} 
printf("\n\nCompareNumber=%d\tChageNumber=%d\tTimeSpent=%dms\n", 
CmpNum[select],ChgNum[select], SpendTime); 
break; 
case 4: 
printf("\n堆排序:\n"); 
TempTime = (int)GetTickCount(); 
HeapSort(&amp;L, &amp;CmpNum[select], &amp;ChgNum[select]); 
SpendTime = (int)GetTickCount() - TempTime; 
for(i=1;i&lt;=MAXSIZE;i++){ 
printf("%5d ",L.r[i].key); 
if(++j%10==0)printf("\n"); 
} 
printf("\n\nCompareNumber=%d\tChageNumber=%d\t\tTimeSpent=%dms\n",CmpNum[select], 
ChgNum[select], SpendTime); 
break; 
case 5: 
printf("\n冒泡排序:\n"); 
TempTime = (int)GetTickCount(); 
BubbleSort(&amp;L, &amp;CmpNum[select], &amp;ChgNum[select]); 
SpendTime = (int)GetTickCount() - TempTime; 
for(i=1;i&lt;=MAXSIZE;i++){ 
printf("%5d ",L.r[i].key); 
if(++j%10==0)printf("\n"); 
} 
printf("\n\nCompareNumber=%d\tChageNumber=%d\tTimeSpent=%dms\n", 
CmpNum[select],ChgNum[select], SpendTime); 
break; 
case 6: 
printf("\n选择排序:\n"); 
TempTime = (int)GetTickCount(); 
SelSort(&amp;L, &amp;CmpNum[select], &amp;ChgNum[select]); 
SpendTime = (int)GetTickCount() - TempTime; 
for(i=1;i&lt;=MAXSIZE;i++){ 
printf("%5d ",L.r[i].key); 
if(++j%10==0)printf("\n"); 
} 
printf("\n\nCompareNumber=%d\tChageNumber=%d\tTimeSpent=%dms\n", 
CmpNum[select],ChgNum[select], SpendTime); 
break; 
case 7: 
AllAbove(&amp;L, CmpNum, ChgNum); 
break; 
} 
} 
while (select != 8 ); 
Display(&amp;L); 
} 


</code></pre> 
<p>答疑群：675511725</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/857f970f5fca54c8e502d1b1511cac50/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java.lang.NoClassDefFoundError: Failed resolution of: Lcom/android/tools/ir/runtime/IncrementalChang</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9c58a8adbbe8131c39ccfecf7445c125/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Endnote X8激活注册信息</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>