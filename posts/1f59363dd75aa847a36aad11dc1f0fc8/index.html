<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《四》Javascript 中的引用类型 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《四》Javascript 中的引用类型" />
<meta property="og:description" content="Object 类型： 对象是用来保存多个数据的容器。
对象的组成：
属性：属性由属性名和属性值组成。方法：方法是一种特殊的属性，它的属性值是函数。 创建 Object 类型： 使用 Object 构造函数创建，可以省略 new 关键字。var obj=new Object() / /创建一个对象 obj.name=’小米’ // 创建属性 obj.run=function(){ // 创建方法 return “123” } 使用对象字面量方式创建，使用最多。var obj={ // 创建一个对象 name:’小米’, // 创建属性 run:function (){ // 创建方法 rerurn ‘123’ } } 属性： 访问对象的属性： 访问对象的属性有两种方法：
一般使用点表示法访问对象属性。但也可以使用方括号表示法访问对象属性：属性名要以字符串的形式放在方括号中。如果属性名中包含会导致语法错误的字符，或者使用的是变量名，就可以选择使用方括号表示。 console.log(person.name) console.log(person[“name”]) person[“first name”] var proppertyName=”name” console.log(person[proppertyName] === person[&#39;name&#39;]) // true 删除对象的属性 删除对象的属性是使用 delete 操作符。
var person={ name: ’Lee’ } delete person.name alert(person.name) // undefined 判断对象中是否有某属性： 判断对象中是否有某属性：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/1f59363dd75aa847a36aad11dc1f0fc8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-30T14:03:33+08:00" />
<meta property="article:modified_time" content="2023-11-30T14:03:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《四》Javascript 中的引用类型</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Object__0"></a>Object 类型：</h2> 
<p>对象是用来保存多个数据的容器。</p> 
<p>对象的组成：</p> 
<ol><li>属性：属性由属性名和属性值组成。</li><li>方法：方法是一种特殊的属性，它的属性值是函数。</li></ol> 
<h4><a id="_Object__6"></a>创建 Object 类型：</h4> 
<ol><li>使用 Object 构造函数创建，可以省略 new 关键字。<pre><code>var obj=new Object() / /创建一个对象
obj.name=’小米’ // 创建属性
obj.run=function(){ // 创建方法
      return “123”
}
</code></pre> </li><li>使用对象字面量方式创建，使用最多。<pre><code>var obj={ // 创建一个对象
    name:’小米’, // 创建属性
    run:function (){ // 创建方法
          rerurn ‘123’
    }
}
</code></pre> </li></ol> 
<h4><a id="_24"></a>属性：</h4> 
<h6><a id="_25"></a>访问对象的属性：</h6> 
<p>访问对象的属性有两种方法：</p> 
<ol><li>一般使用点表示法访问对象属性。</li><li>但也可以使用方括号表示法访问对象属性：属性名要以字符串的形式放在方括号中。如果属性名中包含会导致语法错误的字符，或者使用的是变量名，就可以选择使用方括号表示。</li></ol> 
<pre><code>console.log(person.name)
console.log(person[“name”])

person[“first name”]

var proppertyName=”name”
console.log(person[proppertyName] === person['name'])  // true
</code></pre> 
<h6><a id="_38"></a>删除对象的属性</h6> 
<p>删除对象的属性是使用 delete 操作符。</p> 
<pre><code>var person={
     name: ’Lee’
}
delete person.name
alert(person.name) // undefined
</code></pre> 
<h6><a id="_47"></a>判断对象中是否有某属性：</h6> 
<p>判断对象中是否有某属性：</p> 
<pre><code>var person = {name: 'Lee'}
person.__proto__ = {age: 18}
</code></pre> 
<ol><li>in 判断的是对象的所有属性，包括对象自身及其原型的属性。<pre><code>console.log('name' in person) // true
console.log('age' in person) // true
</code></pre> </li><li><code>obj.hasOwnProperty(property)</code>： 判断的是对象自身是否具有某个属性，不包括原型上的属性。<pre><code>console.log(person.hasOwnProperty('name')) // true
console.log(person.hasOwnProperty('age')) // false
</code></pre> </li></ol> 
<h4><a id="_63"></a>静态方法：</h4> 
<ol><li><code>Object.preventExtensions()</code> ：可以使用 <code>Object.preventExtensions()</code> 来禁止扩展对象的属性。接收一个对象作为参数。<pre><code>let person = {
	name: 'Lee',
	age: 18
}
Object.preventExtensions(person)
person.address = '广州' // 无效
console.log(person)
</code></pre> <img src="https://images2.imgbox.com/ea/cb/21SFhkCn_o.png" alt="请添加图片描述"></li><li><code>Object.seal()</code> ：可以使用 <code>Object.seal()</code> 来密封对象，接收一个对象作为参数。相当于是既调用了 <code>Object.preventExtensions()</code> 来禁止扩展对象的属性，也设置了对象中所有的属性的 <code>[[Configurable]]</code> 特性为 false 使其不可配置。<pre><code>let person = {
	name: 'Lee',
	age: 18
}
Object.seal(person)
person.address = '广州' // 无效
delete person.name // 无效
console.log(person)
</code></pre> </li><li><code>Object.freeze()</code> ：可以使用 <code>Object.freeze()</code> 来冻结对象，接收一个对象作为参数。相当于是既调用了 <code>Object.preventExtensions()</code> 来禁止扩展对象的属性，也设置了对象中所有的属性的 <code>[[Configurable]]</code> 特性为 false 使其不可配置，还设置了对象中所有的属性的 <code>[[Writable]]</code> 特性为 false 使其不可修改。<pre><code>let person = {
	name: 'Lee',
	age: 18
}
Object.freeze(person)
person.address = '广州' // 无效
person.name = 'Mary' // 无效
delete person.name // 无效
console.log(person)
</code></pre> </li></ol> 
<h2><a id="Array__98"></a>Array 类型：</h2> 
<p>数组在 JavaScript 中是一种特殊的对象。</p> 
<p>数组是一组数据的集合，具有数值下标的属性，且内部数据是有序的。</p> 
<p>数组中的项可以是任意类型。</p> 
<pre><code>var arr=[
	'Mary',
	{
	    name: 'Lee',
	    age: 18,
	},
	[1,2,3], 	
	25+25,
]

console.log(typeof arr) // object。数组也属于 Object 类型
console.log(arr instanceof Array) // true
console.log(Array.isArray(arr)) // true
</code></pre> 
<h4><a id="_Array__119"></a>创建 Array 类型：</h4> 
<ol><li>使用数组字面量的方式创建数组：使用中括号定义数组，项与项之间用逗号分隔。这种方式最常用。<pre><code>// 创建一个空数组
var arr1 = []

// 创建包含项的数组
var arr2 = ['Lee', 18]
</code></pre> </li><li>使用 new Array 构造函数的方式创建数组：小括号内可以直接分配数组的项；也可以定义数组长度，此时小括号内必须是一个数字。<pre><code>// 创建一个空数组
var arr1 = new Array()

// 创建一个数组并分配两项
var arr2 = new Array('Lee', 18)

// 创建一个长度为 4 的数组，但是 4 项都是 undefined
var arr3 = new Array(4)
</code></pre> </li></ol> 
<h4><a id="_139"></a>属性：</h4> 
<ol><li>数值下标：数组的每一项都有下标，下标是从 0 开始的，使用方括号中书写下标的形式，可以获取、修改、增加数组的任一项。 
  <blockquote> 
   <p>下标越界：JavaScript 规定，访问数组中不存在的项会返回 undefined，不会报错。</p> 
  </blockquote> <pre><code>var arr = new Array('Lee', 18)
console.log(arr[0]) // Lee。获取数组的第 1 项
arr[1] = 20 // 修改数组的第 2 项
arr[2] = 'student' // 给数组增加第 3 项
</code></pre> </li><li>length：获取数组的长度。length 不是只读的。 
  <blockquote> 
   <p>数组最多可包含 4294967295 个元素，超出会发生异常。<br> 数组最后一项的下标是数组的长度减 1。</p> 
  </blockquote> <pre><code>var arr = new Array('Lee', 18)
console.log(arr.length) // 2

var arr = new Array('Lee', 18,)
console.log(arr.length) // 2。如果最后一项是逗号，会被忽略
	
arr.length = 10 // 强制改变数组个数，以逗号扩展补充，一般不会使用
</code></pre> </li></ol> 
<h4><a id="_160"></a>方法：</h4> 
<p>方法：就是打点调用的函数。</p> 
<blockquote> 
 <p>会改变原数组的方法：<code>splice()</code>、<code>reverse()</code>、<code>sort()</code>、<code>unshift()</code>、<code>shift()</code>、<code>push()</code>、<code>pop()</code>。</p> 
</blockquote> 
<h6><a id="_163"></a>转换方法：</h6> 
<ol><li> <p><code>toString()</code>：返回由数组中每个项的字符串形式拼接成的一个以逗号分隔的字符串。不会改变原数组。</p> </li><li> <p><code>toLocaleString()</code>：返回转换为本地格式的字符串。不会改变原数组。</p> </li><li> <p><code>valueOf()</code>：返回的数组本身。不会改变原数组。</p> 
  <blockquote> 
   <p>所有对象都具有 <code>toString()</code>、<code>toLocaleString()</code>和 <code>valueOf()</code> 方法。因为所有的对象都继承自 Object，而这些方法都是 Object 的方法。</p> 
  </blockquote> <pre><code>var arr1 = [1,2,3,undefined,4]
var arr2 = arr1.valueOf()
console.log(arr2 instanceof Array) // true
</code></pre> </li><li> <p><code>join()</code>：数组转换为字符串，字符串可以由不同的分隔符连接。如果不传值或者传入undefined，则使用逗号作为分隔符。不会改变原数组。</p> 
  <blockquote> 
   <p>数组的 <code>join()</code> 方法可以使数组转为字符串；字符串的 <code>split()</code> 方法可以使字符串转为数组。</p> 
  </blockquote> <pre><code>var arr = [1,2,3]
console.log(arr.join()) // "1,2,3"
console.log(arr.join('')) // "123"

const str = "123"
console.log(str.split()) // [123]
console.log(str.split('')) // [1,2,3]
</code></pre> <p>如果数组中的某一项的值是 null 或者 undefined，那么转换方法返回的结果中以空字符串表示。</p> <pre><code>var arr=[1,2,3,undefined,4]
console.log(arr.join()) // 1,2,3,,4
</code></pre> </li></ol> 
<h6><a id="_190"></a>连接方法：</h6> 
<p><code>concat()</code>：连接多个数组，多个数组之间用逗号分隔，返回新构建的数组。不会改变原数组。</p> 
<pre><code>var arr = [1,2,3]
console.log(arr.concat([4,5,6])) // [1,2,3,4,5,6]
console.log(arr) // [1,2,3]
</code></pre> 
<h6><a id="_197"></a>截取方法：</h6> 
<p><code>slice(from,to)</code>：从下标为 from 的项开始，到下标为 to 但不包括 to 的项为止截取子数组，如果没有 to，则表示一直截取到数组末尾，返回被截取的子数组。不会改变原数组。</p> 
<pre><code>var arr=[1,2,3,4,5]
console.log(arr.slice(1,3)) // [2,3]。截取下标为【1,3）之间的元素
console.log(arr) // [1, 2, 3, 4, 5]
</code></pre> 
<p>参数允许为负数，最后一项为 -1。</p> 
<pre><code>var arr=[1,2,3,4,5]
console.log(arr.slice(1,-3)) // [2]
</code></pre> 
<p>如果结束位置小于起始位置，则返回空数组。</p> 
<pre><code>var arr=[1,2,3,4,5]
console.log(arr.slice(3,1)) // []
</code></pre> 
<h6><a id="_214"></a>删除方法：</h6> 
<p><code>splice()</code>：返回被删除的项，如果没有删除任何项，则返回一个空数组。会改变原数组。</p> 
<ol><li>删除功能：<code>splice(from, num)</code>，from 表示开始位置，num 表示元素个数。<pre><code>var arr = [1,2,3,4,5]
console.log(arr.splice(0,3)) // [1,2,3]。从下标为 0 的位置删除 3 项
console.log(arr) // [4,5]
</code></pre> </li><li>替换功能：<code>splice(from, num，string……)</code>，from 表示开始位置，num 表示元素个数，后面的参数表示要替换成的项。<pre><code>var arr=[1,2,3,4,5]
console.log(arr.splice(0, 3, 11, 22, 33, 44)) // [1,2,3]。从下标为 0 的位置开始删除 3 项后，插入要替换的值
console.log(arr) // [11, 22, 33, 44, 4, 5]
</code></pre> </li><li>插入功能：<code>splice(from, 0，string……)</code>，from 表示插入位置，0 表示不删除任何项，后面的参数表示要插入的项。<pre><code>var arr=[1,2,3,4,5]
console.log(arr.splice(1,0, 22)) // [1,2,3]。在下标为 1 的位置插入 22
console.log(arr) // [1, 22, 2, 3, 4, 5]
</code></pre> </li></ol> 
<h6><a id="_234"></a>头尾操作方法：</h6> 
<ol><li><code>unshift()</code>：为数组前端添加任意个元素，多项用逗号分隔，返回修改后数组最新的长度。会改变原数组。</li><li><code>shift()</code>：从数组前端移除第一个元素，返回被移除的元素。会改变原数组。<pre><code>var arr = ['Lee',18]

console.log(arr.unshift('student')) // 3
console.log(arr) // student Lee 18

console.log(arr.shift()) // student
console.log(arr) // Lee 18
</code></pre> </li><li><code>push()</code>：为数组末尾添加任意个元素，多项用逗号分隔，返回修改后数组的最新长度。会改变原数组。</li><li><code>pop()</code>：从数组末尾移除最后一个元素，返回被移除的元素。会改变原数组。<pre><code>var arr = ['Lee',18]

console.log(arr.push('student')) // 3
console.log(arr) // Lee 18 student

console.log(arr.pop()) // Lee
console.log(arr) // Lee 18
</code></pre> </li></ol> 
<h6><a id="_257"></a>位置方法：</h6> 
<ol><li><code>indexOf()</code>、<code>lastIndexOf()</code>：返回元素在数组中第一次出现的索引值，如果元素不存在，则返回 -1。<pre><code>var arr=[1, 2, 3, 4, 1];
console.log(arr.indexOf(1))// 0
console.log(arr.lastIndexOf(1)) // 4
</code></pre> </li><li><code>arr.includes()</code>：判断一个数组是否包含某个元素，返回值是布尔值。</li></ol> 
<h6><a id="_265"></a>排序方法：</h6> 
<ol><li><code>reverse()</code>：数组倒转，返回倒转后的数组。会改变原数组。<pre><code>var arr = [1,2,3]
console.log(arr.reverse()) // [3,2,1]
console.log(arr) // [3,2,1]
</code></pre> </li><li><code>sort(sortfunc)</code>：会调用数组中每个项的 <code>toString()</code> 方法，然后根据得到的字符串，按 ascii 字符来进行升序排列。会改变原数组。 
  <blockquote> 
   <p>即使数组中的每一项都是数值，<code>sort()</code> 方法比较的也是字符串。</p> 
  </blockquote> <pre><code>var arr=[32,12,111,444];
console.log(arr.sort()) // [111,12,32,444]
console.log(arr) // [111,12,32,444]
</code></pre> 要改变默认的 sort 行为，即按字符排序，可以自行指定排序规则函数，也就是给 <code>sort()</code> 方法传递一个比较函数作为参数参数，比较函数接收两个参数，该函数必须返回下列值之一： 如果函数中所传递的第一个参数比第二个参数小，那么返回负值；如果函数中所传递的第一个参数比第二个参数大，那么返回正值； 如果函数中所传递的第一个参数与第二个参数相等，那么返回 0。<pre><code>// 升序
function compare(a,b){
    return a-b
}
var arr = [32,12,111,444]
console.log(arr.sort(compare)) // [12,32,111,444]。sort() 方法内部做遍历，进行冒泡排序，如果两个数的差 &gt; 0，那么 2 个数就交换位置

// 降序
function compare(a,b){
        return b-a
}
</code></pre> </li></ol> 
<h6><a id="_293"></a>迭代方法:：</h6> 
<p>ECMAScript 为数组定义了 5 个迭代方法，每个方法都接收两个参数：要在每一项运行的函数和可选的运行该函数的作用域对象，函数接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。</p> 
<ol><li><code>every()</code>：对数组中的每一项运行给定函数，如果每一项都返回 true，则结果返回 true，否则返回 false。</li><li><code>some()</code>：对数组中的每一项运行给定函数，如果任一项返回 true，则结果返回 true。</li><li><code>filter()</code>：对数组中的每一项运行给定函数，返回结果为 true 的项所组成的数组。</li><li><code>map()</code>：对数组中的每一项运行给定函数，返回每次函数调用的结果所组成的数组。</li><li><code>forEach()</code>：对数组中的每一项运行给定函数，这个方法没有返回值，本质上与使用 for 循环迭代数组一样。<pre><code>var arr = [1,2,3,4,5,4,3,2,1]
var result = arr.filter(function(item,index,array){
	  return (item&gt;2)
})
console.log(result) // [3,4,5,4,3]
</code></pre> </li></ol> 
<h6><a id="_307"></a>归并方法：</h6> 
<p><code>reduce()</code>、<code>reduceRight()</code>： 迭代数组的所有项，然后构建一个最终返回的值。<code>reduce()</code> 方法从数组的第一项开始，逐个遍历到最后。<code>reduceRight()</code> 则从数组的最后一项开始，向前遍历到第一项。这两个方法都接收两个参数：在每一项上调用的函数和可选的传递给函数的初始值。</p> 
<p>传给 <code>reduce()</code> 和 <code>reduceRight()</code> 的函数接收四个参数：前一个值 prev、当前值 curr、项的索引 index 和数组对象 array。这个函数返回的任何值都会作为函数的第一个参数自动传给下一项。</p> 
<blockquote> 
 <p>当没有传入初始值时，prev 是从数组中第一个元素开始的，curr 是第二个元素。但是当传入初始值，第一个 prev 将是传入的初始值，curr 是数组中的第一个元素。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/2b/7d/sOCBcE8I_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/36/2f/BoLmmSmF_o.png" alt="在这里插入图片描述"></p> 
<pre><code>// 使用 reduce() 方法求数组中所有值之和
var values=[1,2,3,4,5]
var sum=values.reduce(function(pre,cur,index,array){
	rerurn pre+cur
})
console.log(sum) // 15
</code></pre> 
<h4><a id="_323"></a>二维数组：</h4> 
<p>二维数组：以数组作为数组项的数组。通过指定数组中的元素为数组的方式可以创建二维甚至多维数组。</p> 
<pre><code>var matrix = [
	['星期日', 'Sunday'],
	['星期一', 'Monday'],
]
consolr.log(matrix[1][0]) // 星期一
</code></pre> 
<h4><a id="_332"></a>数组与类数组:</h4> 
<ol><li>数组的特征：可以通过角标调用，如 <code>array[0]</code>；具有长度属性 length；可以通过 for 循环和 forEach 方法进行遍历。</li><li>类数组的特征：可以通过角标进行调用；具有 length 属性；也可以通过 for 循环进行遍历，但不能通过 forEach 进行遍历，因为 forEach 是数组原型链上的方法。<pre><code>var arrayLike = {
      0: 'item1',
      1: 'item2',
      2: 'item3',
      length: 3
} // 这个对象就是类数组
</code></pre> </li></ol> 
<h2><a id="Function__343"></a>Function 类型：</h2> 
<p>函数是定义一次但却可以调用任意多次的一段 JS 代码。ECMAScript 中的函数使用 function 关键字来声明，后跟函数名，小括号的参数，大括号的函数体。</p> 
<p>函数是一种特殊的对象，它和普通对象的区别是内部包含的是可运行的代码，因此可以执行。</p> 
<blockquote> 
 <p>每个函数都是 Function 类型的实例，所以函数实际上是对象。<br> 函数名是指向函数对象的指针，不会与某个函数绑定。<br> 使用不带圆括号的函数名是访问函数指针，而非调用函数。<br> 函数本身没有运行功能，必须调用才可以执行。<br> 方法就是函数，用在面向对象的时候叫做方法，单独用的时候叫做函数。<br> 函数是 JS 中的一等公民，可以赋值给变量，也可以作为函数的参数或者返回值。</p> 
</blockquote> 
<pre><code>function method(){// 没有参数的函数
   console.log('没有参数的函数')
}
method() // 直接调用函数

function method(name, age){ // 带有参数的函数。多个参数用逗号隔开
   console.log(‘带有参数的函数：名字:’ + name + ’,年龄：’ + age)
}
method('Lee'，18) // 调用函数，并传参
</code></pre> 
<h4><a id="_364"></a>声明方式:</h4> 
<ol><li>使用函数声明语法：<pre><code>function method(num1, num2){	
 	return num1+num2
}
 console.log(method(1,2))
</code></pre> </li><li>使用函数表达式： 
  <blockquote> 
   <p>函数表达式和函数声明的区别：函数表达式会变量提升。</p> 
  </blockquote> <pre><code>var add = function(num1, num2){
       return num1+num2
}
 console.log(add(1,2)
</code></pre> </li><li>使用 Function 构造函数：<pre><code>var add=new Function(‘num1’, ’num2’, ’return num1+num2’)
 console.log(add(1,2))
</code></pre> 
  <blockquote> 
   <p>不推荐这种方式，因为会导致解析两次代码，第一次解析常规 ECMAScript 代码（全部代码），第二次解析传入构造函数中的字符串，从而影响性能。</p> 
  </blockquote> </li></ol> 
<h4><a id="_386"></a>默认属性：</h4> 
<p>函数本身也是对象，因此不仅有默认的属性和方法，也可以任意添加属性和方法。</p> 
<p>默认属性：</p> 
<ol><li>name：函数名称。</li><li>length：函数本来要接收的参数的个数，其实也就是形参的个数。<pre><code>function fn(name, age, ...args) {}
fn('Lee', 18, 1.88, 160)
console.log(fn.length) // 2
</code></pre> length 属性不会将剩余参数算进去。<pre><code>function fn(name, age, ...args) {}
fn('Lee', 18, 1.88, 160)
console.log(fn.length) // 2
</code></pre> 如果给参数加上默认值，length 属性也不会将其算进去。<pre><code>function fn(name, age = 18) {}
fn('Lee', 18, 1.88, 160)
console.log(fn.length) // 1
</code></pre> </li></ol> 
<h4><a id="_409"></a>参数:</h4> 
<ol><li>把函数的返回值作为参数传递。<pre><code>function add(num1,num2){
   return num1 + num2
}
function sum(num3){
   return num3 + 10
}
var result=add(sum(10), 10)
console.log(result) // 30。sum(10)传递的是第二个函数的返回值20
</code></pre> </li><li>把函数本身作为参数传递。因为ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。<pre><code>function add(sum,num){
    return sum(num)
}
function sum(num){
   return num + 10
}
var result=add(sum, 10) // sum是一个函数
alert(result) // 返回20
</code></pre> </li></ol> 
<h4><a id="return___432"></a>return 返回值 ：</h4> 
<p>return语句如果不带有返回值，将返回undefined。</p> 
<blockquote> 
 <p>break用在循环和switch分支语句里。<br> return false的作用：阻止默认行为，取消事件冒泡，停止执行事件处理函数。</p> 
</blockquote> 
<pre><code>function method(){
   return 'Lee'；//return表示函数把字符串返回给调用部分
}                     
method() // 相当于 method()='Lee'，所以无效果
console.log(method()) // Lee
</code></pre> 
<pre><code>function method(name, age){
    return ‘名字：’ + name + ’,年龄：’ + age;
}
var strInfo = method(‘Lee’, 18) // 把返回值赋值给一个变量
console.log(strInfo)
</code></pre> 
<pre><code>function method(){
     return 10 // 函数会在执行完第一个 return 语句之后立即停止并退出，位于 return 语句之后的任何代码都永远不会被执行
     return 100
}
console.log(method()) // 10
</code></pre> 
<h4><a id="arguments__457"></a>arguments 对象：</h4> 
<p>arguments 是函数运行时自动生成的一个内部对象，是类数组对象，包含着传入函数中的所有参数。</p> 
<blockquote> 
 <p>在函数内部，有两个特殊的对象，arguments 对象和 this 对象。</p> 
</blockquote> 
<pre><code>function fn() {
	console.log(arguments)
}
fn('Lee', 18)
</code></pre> 
<p><img src="https://images2.imgbox.com/f6/18/2Qnskksu_o.png" alt="请添加图片描述"></p> 
<h6><a id="_468"></a>属性:</h6> 
<ol><li>length：传入函数的参数的个数，其实也就是实参的个数。</li><li>callee：该属性是一个指针，指向拥有这个 arguments 对象的函数。</li></ol> 
<h4><a id="this__471"></a>this 对象：</h4> 
<p>this 是函数运行时自动生成的一个内部对象。谁调用这个函数，就把谁绑定到函数内部的 this 对象上，this 对象就指向谁。</p> 
<p>有四种绑定函数中 this 对象的方式：</p> 
<pre><code>function Person() {
	console.log(this)
}
</code></pre> 
<ol><li>通过独立调用的方式默认绑定 this。<pre><code>Person() // 全局变量和全局函数都是 window 对象的属性和方法，实际上相当于 window.Person()，因此此处的 this 指向 window。但是在严格模式下（在 script 中的顶部加上 "use strict"），指向的是 undefined。
</code></pre> </li><li>通过对象调用的方式隐式绑定 this。<pre><code>var obj  = {}
obj.getPerson =  Person
obj.getPerson () // 将 Person 赋值给 obj.getPerson，也就是将 function() {console.log(this)} 赋值给  obj.getPerson，obj.getPerson = function() {console.log(this)}，通过 obj 调用 getPerson()，因此此处的 this 指向 obj
</code></pre> </li><li>通过 call、apply、bind 调用的方式显式绑定 this。<pre><code>var obj  = {}
Person.call(obj) // call、apply、bind 都是用来改变函数内部 this 的指向的，第一个参数就是 this 的指向对象，因此此处的 this 指向 obj
</code></pre> </li><li>通过 new 关键字调用的方式绑定 this。<pre><code>var p = new Person() // 通过 new 构造函数实例化一个对象，构造函数内部的 this 指向新创建的对象，因此此处的 this 指向 p
</code></pre> </li></ol> 
<p>这四种绑定函数中 this 对象方式的优先级：<code>通过 new 绑定 this</code> &gt; <code>通过 bind 调用的方式显式绑定 this</code> &gt; <code>通过 call、apply 调用的方式显式绑定 this</code> &gt; <code>通过对象调用的方式隐式绑定 this</code> &gt; <code>通过直接调用的方式默认绑定 this</code> 。谁的优先级高，同时出现时，this 会取谁的绑定方式。</p> 
<blockquote> 
 <p>在一个代码片段里， this 有可能代表不同的对象。因为 JS 可以多层嵌套代码，如果函数里面再嵌套一个函数，父函数中的 this 代表的是调用父函数的对象，子函数中的 this 代表的是调用子函数的对象。如果在子函数中想要获取父函数中的 this，可以在父函数中提前创建一个临时变量来保存父函数中的 this，子函数中就可以通过这个临时变量来获取到父函数中的 this 了。</p> 
 <pre><code>$("#btn").click(function(){
    var _this = this // 这里 this 和 _this 都代表了 "#btn" 这个对象
    $(".tr").each(function(){
         this // 在这里 this 代表的是 ".tr" 对象
         _this // 仍代表最初的对象 "#btn"
    })
})
</code></pre> 
 <p>现在通过使用 ES6 中的箭头函数已经不再需要这么操作了。</p> 
</blockquote> 
<h6><a id="callapply__bind_512"></a><code>call()</code>、<code>apply()</code> 和 <code>bind()</code>：</h6> 
<p><code>call()</code>、<code>apply()</code> 和 <code>bind()</code> 都可以用来改变函数体内部 this 的指向。它们的第一个参数要求是一个对象，是 this 的指向对象，如果不是对象，则 this 指向其基本包装类型，如果也没有基本包装类型，则 this 指向 window。其他参数是传入函数中的实参。</p> 
<pre><code>fn.call(obj, arg, arg, ...)
fn.apply(obj, [arg, arg, ...])
fn.bind(obj, arg, arg, ...)()
</code></pre> 
<p>它们之间的区别是：</p> 
<ol><li><code>bind()</code> 返回的是一个新的函数，称为绑定函数（bound function, BF），绑定函数和原函数相比，只是明确改变了内部 this 的指向，绑定函数必须调用才会执行。<pre><code>const obj = {
	name: 'Lee',
	show: function(){
	  console.log(this.name)
	}
}	
const obj1 = {
	name: 'Mary',
}
	
obj.show.call(obj1) // Mary。相当于 obj1.show()，临时让 show() 成为 obj1 的方法进行调用。
obj.show.apply(obj1) // Mary。相当于 obj1.show()，临时让 show() 成为 obj1 的方法进行调用。
const show1 = obj.show.bind(obj1) // 相当于 obj1.show()，返回一个新的绑定函数，绑定函数内部的 this 已经明确指向了 obj1，必须调用才会执行
show1() // Mary
</code></pre> </li><li><code>call()</code> 和 <code>bind() </code> 的其他参数是用逗号分隔，<code>apply()</code> 的其他参数需要放到一个数组中。<pre><code>const obj = {
  name: 'Lee',
  show: function(age){
    console.log(this.name, age)
  }
}
const obj1 = {
  name: 'Mary',
}

obj.show.call(obj1, 17) // Mary, 17
obj.show.apply(obj1, [17]) // Mary, 17
obj.show.bind(obj1, 17)() // Mary, 17
</code></pre> </li></ol> 
<p>手动实现 <code>call()</code>、<code>apply()</code> 和 <code>bind()</code>。</p> 
<pre><code>var obj = {}
function foo(name, age) {
	console.log(this, name)
}
foo.call(obj, 'Lee', 18)
foo.apply(obj, ['Lee', 18])
foo.bind(obj, 'Lee')(18)

// 模拟实现 call 方法
// 把 foo 作为一个对象，获取它的 call 方法。所有的函数都有 call 方法，因此可以得出 call 不是单独加在某个函数自身上的，而是在函数的隐式原型对象，也就是 Function 的显式原型对象上的
Function.prototype.customCall = function(thisArg, ...restArgs) {
	// 1. 边界判断
	thisArg = (thisArg === null || thisArg === undefined) ? window : Object(thisArg)
	// 2. 给 thisArg 对象添加一个 fn 属性，并将 customCall 内部的 this，也就是 foo 赋值给 fn
	thisArg.fn = this
	// 3. 使用 thisArg 调用 fn，因此 fn，也就是 foo 内部的 this 指向 thisArg，成功修改 this 指向
	thisArg.fn(...restArgs)
}
foo.customCall(obj, 'Lee', 18)

// 模拟实现 apply 方法
Function.prototype.customApply = function(thisArg, restArgs) {
	thisArg = (thisArg === null || thisArg === undefined) ? window : Object(thisArg)
	thisArg.fn = this
	thisArg.fn(...restArgs)
}
foo.customApply(obj, ['Lee', 18])

// 模拟实现 bind 方法
Function.prototype.customBind = function(thisArg, ...restArgs) {
	thisArg = (thisArg === null || thisArg === undefined) ? window : Object(thisArg)
	thisArg.fn = this

	// 需要返回一个对象，以便调用
	return (...otherArgs) =&gt; {
		thisArg.fn(...restArgs, ...otherArgs)
	}
}
foo.customBind(obj, 'Lee')(18)
</code></pre> 
<h6><a id="_this__596"></a>一些内置函数中，被作为参数传入的函数中 this 的指向：</h6> 
<p>JS 中的一些内置函数，会要求传入另外一个函数作为其参数。被传入的这些函数并不是由开发者显式调用的，而是 JS 内部帮助执行的，这些函数内部的 this 指向只能依靠经验得知。</p> 
<pre><code>setTimeout(function(){
	console.log(this) // window
}, 1000)
</code></pre> 
<pre><code>var btn = document.getElementById('btn')
btn.addEventListener('click', function(){
	console.log(this) // btn
})
</code></pre> 
<pre><code>var names = ['Lee', 'Mary']
names.forEach(function(){
	console.log(this) // window
})
</code></pre> 
<h4><a id="_615"></a>函数提升:</h4> 
<p>函数声明提升直接把整个函数提升到所在执行上下文的最顶端。通过 function 声明的函数，在声明之前就可以访问到，值为函数本身。</p> 
<blockquote> 
 <p>变量提升只提升变量名，而函数提升会提升整个函数。</p> 
</blockquote> 
<pre><code>console.log(foo)
function foo(){}

//相当于
function foo(){}
console.log(foo) // 输出函数本身
</code></pre> 
<p>函数表达式遵循的是变量提升，而不是函数提升。</p> 
<pre><code>console.log(foo)
var foo = function(){}

//相当于
var foo
console.log(foo) // 输出 undefined
foo = function(){}
</code></pre> 
<p>函数提升在变量提升上面。</p> 
<pre><code>console.log(foo) // 输出函数
var foo=10
console.log(foo)
function foo(){
    console.log(10)
} 

// 相当于：

function foo(){
    console.log(10)
}
var foo
console.log(foo) //函数提升在变量提升上面，var foo只是声明，并未赋值，因此调用上面的
foo=10
</code></pre> 
<h4><a id="_654"></a>重载:</h4> 
<p>重载就是根据参数，选择相同函数名而参数不同的函数。</p> 
<blockquote> 
 <p>ECMAscript 中的函数不具备重载功能，是因为其参数是由包含 0 个或多个值的数组来表示的。</p> 
</blockquote> 
<pre><code>function method(num,a){
     return num+100
}
function method(num){
     return num+200 // 第二个函数会把第一个函数覆盖掉
}
console.log(method(50,1)) // 250
</code></pre> 
<h4><a id="_666"></a>匿名函数：</h4> 
<p>匿名函数也就是没有名称的函数。如果单独只写一个匿名函数，是不符合语法要求会报错的，需要给匿名函数包裹一个括号，被小括号包裹的内容会被 JS 识别为一个函数表达式。</p> 
<pre><code>(function () {

})
</code></pre> 
<p>执行匿名函数，只需要后面追加括号即可，也就是立即执行函数。</p> 
<pre><code>(function () {

})()
</code></pre> 
<p>匿名函数传参与普通函数传参的方式一样，调用的时候将参数传入即可。</p> 
<pre><code>(function (str) {
	console.log(str) // '我是匿名函数的参数'
})('我是匿名函数的参数')
</code></pre> 
<p>在匿名函数内部调用一个函数，那么这个函数中的 this 对象指向全局对象 window。</p> 
<pre><code>(function () {
	fn1()
})()

function fn1() {
	console.log(this) // 指向 window
}
</code></pre> 
<h4><a id="IIFEImmediatelyInvoked_Function_Expression_695"></a>立即执行函数（IIFE、Immediately-Invoked Function Expression）：</h4> 
<p>声明一个匿名函数，并立即调用它，就叫做立即执行函数。</p> 
<h6><a id="_697"></a>写法：</h6> 
<ol><li><code>(function() {...})()</code></li><li><code>(function() {...}())</code></li><li><code> !function() {...}()</code>，！、+、-等运算符都能起到立即执行的作用。</li></ol> 
<pre><code>// 匿名函数自调用就是立即执行函数
(function () {
	console.log('我是立即执行函数')
})()
</code></pre> 
<h6><a id="_707"></a>参数：</h6> 
<p>如果立即执行函数中需要使用全局变量，可以将全局变量作为一个参数传递给立即执行函数。i 就是一个全局变量，代表的是实参，j 是 i 在立即执行函数中的形参。</p> 
<pre><code>(function(j){
	//在代码中可以使用j
})(i)
</code></pre> 
<h6><a id="_714"></a>作用：</h6> 
<ol><li>不必为函数命名。</li><li>立即执行函数会形成一个单独的作用域，定义的所有变量都会成为立即执行函数的局部变量，避免污染全局变量，而且也使得内存在执行完后能够立即释放。<pre><code>(function(){}(
  // 如果写在外部，就会多生成一个全局变量；写在立即执行函数里面，就是一个局部变量，立即执行函数执行完毕就会释放所占用的内存空间
  var num = 3
  console.log(num + 1)
))
</code></pre> </li></ol> 
<h4><a id="_724"></a>回调函数：</h4> 
<p>回调函数是一个作为参数被传递给另外一个函数的函数，它在主体函数执行完之后执行。</p> 
<blockquote> 
 <p>因为函数实际上也是一种对象，它可以存储在变量中，作为参数被传递给另一个函数。</p> 
</blockquote> 
<p>常见的回调函数有：DOM 事件回调函数、定时器回调函数、AJAX 请求回调函数。</p> 
<pre><code>function A(callback) {   
    console.log('我是主函数')
    callback()
}
function B(){
    console.log('我是回调函数'）
}
A(B) // 我是主函数 我是回调函数

document.getElementById('btn').click = function(){
	console.log('我是点击按钮')
}

setTimeout(function(){
	console.log('我是定时器')
}, 2000)
</code></pre> 
<h4><a id="Closure_748"></a>闭包（Closure）：</h4> 
<p>如果一个函数引用了外部的变量，那么，就可以说，这个函数和它周围的环境形成了一个闭包。</p> 
<pre><code>// 闭包通常是通过嵌套函数实现的。在一个函数里面嵌套了另外一个函数，并且在内层函数中引用外层函数中的变量
function fn1() {
	var n = 1
	function fn2() {
		console.log(n) // fn2 读取 fn1 内部的变量，因此形成了一个闭包
	}
	return fn2
}
var f = fn1() 
f()

function fn1() {
	var n = 1
	function fn2() {
		... // 如果 fn2 没有读取 fn1 内部的变量，不会形成闭包
	}
	return fn2
}
var f = fn1() 
f()
</code></pre> 
<pre><code>// 函数内部引用了全局变量
var str  = 'aaa';
function f3() {
	console.log(str) // // f3 读取了外部变量，因此也形成了一个闭包
}
f3()
</code></pre> 
<h6><a id="_780"></a>闭包的生命周期：</h6> 
<p>产生：在形成闭包的函数的定义被执行完就产生了，而不是在调用了这个函数后才产生。</p> 
<p>死亡：在形成闭包的函数成为垃圾对象被回收后才死亡。</p> 
<pre><code>function fn1() {
	var n = 1
	var str = 'Hello'
	var boolean = true
	function fn2() {
		console.log(n)
	}
	return fn2
}
// 执行完这行代码，闭包就已经产生了
var f = fn1()
// f 的执行上下文出栈，0xb00 在某个时刻被垃圾回收器回收。本来执行完 var f = fn1()，fn1 的执行上下文就出栈了，0xa00 就应该在某个时刻被垃圾回收器回收，但直到此刻，0xa00 还被 GO 中的 f 属性引用，因此永远都不会被销毁了，造成内存泄漏
// 针对这种情况，V8 引擎进行了一些优化，只会保留 fn1 中的 n，str、boolean 由于没有被引用到，会被删除掉，减少 0xa00 对象的大小
f() // 2

// 需要手动解除引用，等待垃圾回收器回收 0xa00 后，闭包才会死亡
f = null
</code></pre> 
<p><img src="https://images2.imgbox.com/1a/a0/K8EoFo3q_o.png" alt="请添加图片描述"></p> 
<h6><a id="_804"></a>闭包的优点和缺点：</h6> 
<p>优点：</p> 
<ol><li>让函数外部可以读取和操作函数内部的数据。</li><li>让函数内部的局部变量的值仍然保持在内存中，不会在函数调用结束后，被垃圾回收机制回收，延长了局部变量的生命周期。</li></ol> 
<p>缺点：</p> 
<ol><li>由于闭包会使得函数内部被引用的变量，在函数执行完仍然保存在内存中，造成内存泄漏，影响网页的性能，严重时甚至可能会导致内存溢出。</li><li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果把父函数当作对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，一定不要随便改变父函数内部变量的值。</li></ol> 
<h4><a id="_812"></a>递归：</h4> 
<p>递归就是在函数的内部调用其自身。</p> 
<p>递归的原理就是传递 + 回归，函数不断调用自身，直到找到终点，把结果沿着原来的路线传递，直到回到起点。</p> 
<p>递归和循环的效果是一样的，如果没有返回值，就会一直死循环下去导致发生栈溢出错误，所以必须要加退出条件。</p> 
<pre><code>function fn() {
	fn()
}

fn()
</code></pre> 
<p><img src="https://images2.imgbox.com/1c/f8/23PPqO4w_o.png" alt="在这里插入图片描述"></p> 
<p>利用递归来实现求阶乘。</p> 
<pre><code>// 4 的阶乘：
0! = 1
1! = 1
2! = 1 *2 = 2
3! = 1 *2 * 3 = 6
4! = 1 *2 * 3 * 4 = 24
</code></pre> 
<p>可以发现：4 的阶乘等于 3 的阶乘乘以 4，3 的阶乘等于 2 的阶乘乘以 3，以此类推，规律就是上一个阶乘的结果乘以当前的阶乘数。因此可以得到这样的公式：<code>factorial(n) = factorial(n -1) * n</code>，起点就是 0 的阶乘。</p> 
<pre><code>// 代码实现：
function factorial(n) {
	if (n === 0) return 1

	return n * factorial(n - 1)
}

factorial(4) // 24
</code></pre> 
<p>调用 <code>factorial(4)</code> 生成的执行上下文栈：</p> 
<ol><li>调用 <code>factorial(4)</code> ，生成 <code>factorial(4)</code> 的执行上下文并进栈 ，返回 <code>4 * factorial(3) </code>；。</li><li>接着调用 <code>factorial(3)</code> ，生成 <code>factorial(3)</code> 的执行上下文并进栈 ，返回 <code>3 * factorial(2) </code>。</li><li>接着调用 <code>factorial(2)</code> ，生成<code>factorial(2)</code> 的执行上下文并进栈 ，返回 <code>2 * factorial(1) </code>。</li><li>接着调用 <code>factorial(1)</code> ，生成 <code>factorial(1)</code> 的执行上下文并进栈 ，返回 <code>1 * factorial(0) </code>。</li><li>接着调用 <code>factorial(0)</code> ，生成<code>factorial(0)</code> 的执行上下文并进栈 ，返回计算结果 1 并出栈。</li><li><code>factorial(1)</code> 的执行上下文返回计算结果 <code>1 * 1 = 1</code> 并出栈。</li><li><code>factorial(2)</code> 的执行上下文返回计算结果 <code>1 * 2 = 2</code> 并出栈。</li><li><code>factorial(3)</code> 的执行上下文返回计算结果 <code>2 * 3 = 6</code> 并出栈。</li><li><code>factorial(4)</code> 的执行上下文返回计算结果 <code>6 * 4 = 24</code> 并出栈。</li></ol> 
<p><img src="https://images2.imgbox.com/37/82/VaH8jFnP_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_859"></a>高阶函数：</h4> 
<p>高阶函数是一个函数，它接收函数作为参数或者返回函数作为输出。</p> 
<blockquote> 
 <p>数组的 <code>forEach()</code>、<code>map()</code> 等方法就都是高阶函数。</p> 
</blockquote> 
<pre><code>function fn() {
	console.log('这是作为参数被传入的函数 fn')
}

// fn1 接收一个函数作为参数，因此是一个高阶函数
function fn1(f) {
	f() // 这是作为参数被传入的函数 fn
}
fn1(fn)
</code></pre> 
<pre><code>// fn1 返回一个函数，因此是一个高阶函数
function fn1(f) {
	return function() {
		console.log('fn1 返回一个函数作为输出')
	}
}
fn1()() // fn1 返回一个函数作为输出
</code></pre> 
<blockquote> 
 <p><code>eval()</code> 是一个特殊的内建函数，它可以将传入的字符串当做 JS 代码来执行，并且会将最后一条执行语句的结果，作为返回值。</p> 
 <pre><code>eval(`var message = 'Hello'; console.log(message)`)

var message = 'Hello'
eval(`console.log(message)`) // `eval()` 函数里也可以引用到外部变量

eval(`var message = 'Hello'`)
console.log(message) // `eval()` 函数里创建的变量，外部也可以引用到
</code></pre> 
 <p><code>eval()</code> 代码的可读性非常差；<code>eval()</code> 要执行的是一个字符串，不能被 JS 引擎优化，并且有可能在执行的过程中被可以修改，造成被攻击的风险。因此不建议在开发中使用。</p> 
</blockquote> 
<h2><a id="RegExp__895"></a>RegExp 正则表达式：</h2> 
<p>一个正则表达式是由普通字符以及特殊字符组成的字符串模式，用来与所搜素的字符串进行匹配。正则表达式并不依赖于某种编程语言，许多编程语言都支持正则表达式。</p> 
<blockquote> 
 <p>也就是说，正则表达式是用来操作字符串的。</p> 
</blockquote> 
<h4><a id="_898"></a>创建正则表达式：</h4> 
<p>正则表达式主要由两部分组成：匹配的规则 patterns 和匹配的修饰符 flags，修饰符是可选的。</p> 
<ol><li>使用字面量的方式创建：匹配的规则包含在 <code>/ /</code> 之间，匹配的修饰符在 <code>/ /</code> 后面。<pre><code>var pattern = /abc/i
</code></pre> </li><li>使用 RegExp 构造函数来创建：接收两个参数，第一个参数是匹配的规则，第二个参数是匹配的修饰符。<pre><code> var pattern = new RegExp('abc', 'i')
</code></pre> </li></ol> 
<h4><a id="_908"></a>正则表达式的组成:</h4> 
<h6><a id="_909"></a>规则：</h6> 
<ol><li> <p>字符类：是一个特殊的符号，用于匹配某些特定集中的符号。</p> 
  <ul><li><code>.</code>：匹配除了换行符之外的一个字符。</li><li><code>\d</code>：digit，匹配一个数字字符，相当于 <code>[0-9]</code>。<pre><code>/\d/：可以匹配 a1b 中的 1
</code></pre> </li><li><code>\s</code>：space，匹配一个空格字符，如空格，制符表，换行符等。</li><li><code>\w</code>：word，匹配一个英文字母，数字字符或者下划线。</li></ul> </li><li> <p>反向类：</p> 
  <ul><li><code>\D</code>：匹配一个非数字字符。</li><li><code>\S</code>：匹配一个非空格符。</li><li><code>\W</code>：匹配除 <code>\w</code> 外的任意一个字符。</li></ul> </li><li> <p>转义字符：如果要把特殊字符作为普通字符来使用，需要对其进行转义，只需要在它前面加个反斜杠。常见的需要转义的字符 <code>(</code>、<code>)</code>、<code>[</code>、<code>]</code>、<code>\</code>、<code>.</code>、<code>^</code>、<code>$</code>、<code>|</code>、<code>*</code>、<code>+</code>、<code>?</code> 等。</p> 
  <blockquote> 
   <p>斜杠 <code>/</code> 并不是一个特殊符号，但是在字面量正则表达式中也需要转义。</p> 
  </blockquote> </li><li> <p>锚点：:</p> 
  <ul><li><code>^</code>：匹配字符串的开头。<pre><code>/^g/：可以匹配 good 中的 g，但不能匹配 bag 中的 g
</code></pre> </li><li><code>$</code>：匹配字符串的结尾。<pre><code>/g$/：可以匹配 bag 中的 g，但不能匹配 good 中的 g
</code></pre> </li></ul> </li><li> <p>词边界：</p> 
  <ul><li><code>\b</code>：匹配单词的边界。只要边界不是英文字母，数字字符或者下划线，就可忽略，将其作为词边界。<pre><code>/e\b/：匹配 i love seek 中 love 的 e，但不匹配 seek 中的 e   
</code></pre> <pre><code>var str = '1abc'
var reg = /\babc/
console.log(reg.test(str)) // false

var str = '\(abc'
var reg = /\babc/
console.log(reg.test(str)) // true
</code></pre> </li><li><code>\B</code>：匹配单词的非边界。<pre><code>/e\b/：匹配 i love seek 中 seek 的 e，但不匹配 love 中的 e 
</code></pre> </li></ul> </li><li> <p>集合和范围：</p> 
  <ul><li><code>[ ]</code>：匹配方括号中字符序列的任意一个字符。其中也可以使用连字符“-”匹配指定范围内的任意字符。<pre><code>[102]：可以与 0A1B2C 中的字符 0 或 1 或 2 匹配
[0-5]：可以与 a3g02gsf91dfs4 中的 0 到 5 之间的任意数字字符匹配
</code></pre> </li><li><code>[^ ]</code>：匹配方括号中字符序列未包含的任意一个字符。其中也可以使用连字符“-”匹配不在指定范围内的任意字符。<pre><code>[^102]：可以与 0A1B2C 中的字符 A 或 B 或 C 匹配
[^a-z]：可以与 a3g02gsf91dfs4 中的不在小写字母 a 到 z 之间的任意字符匹配
</code></pre> </li></ul> </li><li> <p>量词:</p> 
  <ul><li><code>?</code>：匹配前一项 0 次或 1 次。<pre><code>/js?/：可以匹配 jscript 中的 js 或者 javascript 中的 j
</code></pre> </li><li><code> +</code>：匹配前一项 1 次或多次，但至少出现一次。<pre><code>/js+/：可以匹配 js，也可以匹配 jsssssss
</code></pre> </li><li><code>*</code>：匹配前一项任意次。</li><li><code>{n}</code>：匹配前一项 n 次，n 为非负整数。<pre><code>/o{2}/：可以匹配 book 中的 oo，也可以匹配 booook 中的任意两个连续的 oo
</code></pre> </li><li><code>{n,}</code>：匹配前一次至少 n 次。</li><li><code>{n,m}</code>：匹配前一项 n 到 m 次，n&lt;=m。</li></ul> 
  <blockquote> 
   <p>默认的匹配方式是贪婪模式，查找到匹配的内容后，会继续向后查找，一直找到最后一个匹配的内容。<br> 但是，只要在量词后面加一个 <code>?</code> 就可以启用惰性模式，只要获取到对应的内容后，就不再继续向后匹配。<br> // 贪婪模式：从第一个 《 开始，到最后一个 》，都被匹配上了<br> var message = ‘我做喜欢的三本书是：《黄金时代》、《沉默的大多数》和《人性的弱点》’<br> var fileNameReg = /《.<em>》/ig<br> console.log(message.match(fileNameReg))<br> <img src="https://images2.imgbox.com/c6/f1/ptRmDcr7_o.png" alt="请添加图片描述"><br> // 惰性模式：从《 开始，只要匹配到 》，一次匹配就结束<br> var message = ‘我做喜欢的三本书是：《黄金时代》、《沉默的大多数》和《人性的弱点》’<br> var fileNameReg = /《.</em>?》/ig<br> console.log(message.match(fileNameReg))<br> <img src="https://images2.imgbox.com/fc/6c/y8bg708z_o.png" alt="请添加图片描述"></p> 
  </blockquote> </li><li> <p>分组：</p> 
  <ul><li>捕获组：用小括号括起来。它有两个作用：一是会将括号中的内容当做一个整体；二是会将匹配到的内容作为结果数组中单独的一项。<pre><code>// 将 ava 当做整体
/j(ava)?/：可以匹配 jscript 中的 j，也可以匹配 javascript 中的 java   
</code></pre> <pre><code>var message = '我正在学 javascript'
var reg = /java/ig
console.log(reg.exec(message))
</code></pre> <img src="https://images2.imgbox.com/61/ea/KbcOqmV2_o.png" alt="请添加图片描述"><pre><code>var message = '我正在学 javascript'
var reg = /j(ava)/ig
console.log(reg.exec(message))
</code></pre> <img src="https://images2.imgbox.com/65/59/7vLRbTYb_o.png" alt="请添加图片描述"></li><li>非捕获组：用小括号括起来，在左侧小括号后面紧跟 <code>?:</code>，匹配到的内容将不会作为结果数组中单独的一项。</li><li>命名组：用小括号括起来，在左侧小括号后面紧跟 <code>?&lt;名称&gt;</code>，匹配到的内容不仅会作为结果数组中单独的一项，而且会以 <code>名称: 匹配到的内容</code> 这种 <code>key: value</code> 的形式放在返回的结果数组的 groups 中。<pre><code>var message = '我正在学 javascript'
var reg = /j(?&lt;name&gt;ava)/ig
console.log(reg.exec(message))
</code></pre> <img src="https://images2.imgbox.com/0a/af/auQsMlMr_o.png" alt="请添加图片描述"></li></ul> </li><li> <p>选择匹配符：只有一个 <code>|</code>，可以匹配指定的多个选项中的任意一项。</p> <pre><code>/(world|dream)/：可以匹配 one world one dream 中的 world 或 dream
</code></pre> </li></ol> 
<h6><a id="_1023"></a>修饰符：</h6> 
<ol><li>g：global，表示全局匹配。<pre><code>var str = '123abc123abc'
var reg = /abc/
console.log(str.replace(reg, 'Hello')) // 123Hello123abc
</code></pre> <pre><code>var str = '123abc123abc'
var reg = /abc/g
console.log(str.replace(reg, 'Hello')) // 123Hello123Hello
</code></pre> </li><li>i：ignore，表示不区分大小写。</li><li>m：multiple，表示多行匹配 。</li></ol> 
<h4><a id="_1037"></a>静态属性:</h4> 
<p>分别有一个长属性名和一个短属性名，可以通过两种方式访问。由于短属性名大多不是有效的 ECMAScript 标识符，所以要通过方括号来访问。</p> 
<ol><li>input、$_：最近一次要匹配的字符串。</li><li>lastMatch、$&amp;：最近一次的匹配项。</li><li>leftContext、$`：input 字符串中 lastMatch 之前的文本。</li><li>rightContext、$’：input 字符串中 lastMatch 之后的文本。</li><li>lastParen、$+：最近一次匹配的捕获组。<pre><code>var text=”this has been a short summer”;
var pattern=/(.)hort/g;
if(pattern.test(text)){
     alert(RegExp.$_);//this has been a short summer
     alert(RegExp.[“$`”]);//this has been a            
     alert(RegExp.[“$’”]);//summer 
     alert(RegExp.[“$&amp;”]);//short
     alert(RegExp.[“$+”]);//s
}
</code></pre> </li><li><code>RegExp.$1</code>、<code>RegExp.$2</code>…用于存储捕获组。<pre><code>var text=”this has been a short summer”;
var pattern=/(..)or(.)/g; 
alert(RegExp.$1);//sh
alert(ReExp.$2);//t
</code></pre> </li></ol> 
<h4><a id="_1062"></a>实例属性:</h4> 
<ol><li>global：返回布尔值，表示是否已设置了 g 标志。</li><li>ignoreCase：返回布尔值，表示是否已设置了 i 标志。</li><li>multiLine：返回布尔值，表示是否已设置了 m 标志。</li><li>lastIndex：返回整数，表示开始搜索下一个匹配项的字符位置，从 0 开始。</li><li>source：返回正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。</li></ol> 
<h4><a id="_1068"></a>实例方法:</h4> 
<ol><li><code>toString()</code>、<code>toLocaleString()</code>：不管创建正则表达式的方式是哪种，都会返回正则表达式的字面量形式的字符串。</li><li><code>valueOf()</code>：返回正则表达式本身。</li><li><code>test()</code>：接收一个字符串作为参数，用来判断传入的字符串是否与正则表达式的规则相匹配，返回值是布尔值。<pre><code>var reg1 = /abc/
console.log(reg1.test('abc123')) // true

var reg2 = /^abc$/
console.log(reg2.test('abc123')) // false
</code></pre> </li><li><code>exec()</code>：接收一个字符串作为参数。有匹配项的情况下，返回值是匹配项信息的数组，返回的数组是 Array 的实例，但还包含三个额外的属性：index（表示匹配项在字符串中的位置）、groups（表示分组）和 input（表示应用正则表达式的字符串）；没有匹配项的情况下，返回值是 null。 
  <blockquote> 
   <p><code>exec()</code> 方法每次只会返回一个匹配项的信息。如果不设置 g 全局修饰符，在同一个字符串上多次调用 <code>exec()</code> 将始终返回第一个匹配项的信息；如果设置了 g 全局修饰符，每次调用 <code>exec()</code> 会在字符串中继续查找新匹配项。</p> 
  </blockquote> <pre><code>var reg = /abc/
console.log(reg.exec('123abc123abc'))
</code></pre> <img src="https://images2.imgbox.com/2c/a8/kkW6aaVj_o.png" alt="请添加图片描述"></li></ol> 
<blockquote> 
 <p>正则表达式可以用于以下方法中：</p> 
 <ol><li>字符串的实例方法 <code>match()</code>、<code>matchAll()</code>、<code>replace()</code>、<code>replaceAll()</code>、<code>split()</code>、<code>search()</code> 中，传入一个正则表达式。</li><li>正则表达式的实例方法 <code>test()</code>、<code>exex()</code> 中， 传入一个字符串。</li></ol> 
</blockquote> 
<h2><a id="Date__1091"></a>Date 类型：</h2> 
<p>用于处理日期和时间。</p> 
<blockquote> 
 <p>Date 类型使用 UTC1970 年 1 月 1 日 0 时开始经过的毫秒数来保存日期，Date 类型保存的日期能够精确到 1970 年 1 月 1 日之前或之后的 285616 年。</p> 
</blockquote> 
<h6><a id="Date_1094"></a>创建Date类型:</h6> 
<p>使用 new 运算符调用 Date 构造函数。</p> 
<pre><code>var now=new Date();//创建一个日期对象。如果不传递参数，会自动把当前日期和时间保存为其初始值(获取到的是年月日时分秒)。
alert(now);//不同浏览器显示不同，所以很少直接使用
</code></pre> 
<h6><a id="_1100"></a>方法:</h6> 
<ol><li> <p>静态方法：</p> 
  <ol><li> <p>Date.parse()：接收一个表示日期的字符串参数，然后根据这个字符串返回本地时间的毫秒数。如果Date.parse()没有传入参数或者不是标准的日期格式，那么就会返回NaN。</p> 
    <blockquote> 
     <p>ECMA-262没有定义Date.parse()应该支持哪种日期格式，默认通常接收的日期格式如下：</p> 
     <ol><li>’月/日/年’，如’2/14/2017’</li><li>‘英文月名 日，年’，如’May 25,2017’</li><li>‘英文星期几 英文月名 日 年 时:分:秒 时区’，如’Tue May 25 2017 00:00:00 GMT-070’</li></ol> 
    </blockquote> </li><li> <p>Date.UTC()：返回UTC时间的毫秒数。参数有年，月(0 ~ 11),日(1 ~ 31)，时(0 ~ 23)，分(0 ~ 59)，秒(0 ~ 59)，毫秒(0~999)。只有年和月是必须的。</p> 
    <blockquote> 
     <p>UTC是世界标准时间。</p> 
    </blockquote> </li><li> <p>Date.now()：返回自 1970-1-1 00:00:00 至今所经过的毫秒数，类型为Number。</p> 
    <blockquote> 
     <p>比较两个日期大小，可以转换成毫秒数进行比较。</p> 
    </blockquote> </li></ol> </li><li> <p>通用方法：</p> 
  <ul><li>toString()<pre><code>var date = new Date();
var time =date.toString();//Tue Dec 04 2018 16:43:25 GMT+0800 (中国标准时间)
</code></pre> </li><li>toLocaleString()：返回本地格式的时间。<pre><code>var date = new Date();
var time =date.toLocaleString();//2018/12/4 下午4:44:37
</code></pre> </li><li>valueOf()：返回日期的毫秒数。<pre><code>var date = new Date();
var time =date.valueOf();//1543913115591
</code></pre> </li></ul> </li><li> <p>日期格式化方法：将日期格式化为字符串。</p> 
  <ul><li>toDateString()：返回特定格式的星期几，月，日，年的字符串。<pre><code>var date = new Date();
var time =date.toDateString();//Tue Dec 04 2018
</code></pre> </li><li>toTimeString()：返回特定格式的时，分，秒，时区字符串。<pre><code>var date = new Date();
var time =date.toTimeString();//16:34:16 GMT+0800 (中国标准时间)
</code></pre> </li><li>toLocaleDateString()：返回当地格式的星期几，月，日，年的字符串。</li><li>toLocaleTimeString()：返回当地格式的时，分，秒字符串。</li><li>toUTCString()：返回特定格式的完整的utc日期时间。</li></ul> </li><li> <p>组件方法：</p> 
  <ul><li>getTime()：获取日期的毫秒数，和valueOf()的返回值一样。</li><li>setTime()：以毫秒数设置日期。</li><li>getFullYear()：获取四位年份。</li><li>setFullYear()：设置四位年份，返回的是毫秒数。</li><li>getMonth()：获取月份（0~11），+1才是真正的月份。</li><li>setMonth()：设置月份（0~11），超过11则增加年份，返回的是毫秒数。</li><li>getDate()：获取天数（1~31）。</li><li>setDate()：设置天数（1~31），返回的是毫秒数。</li><li>getDay()：获取星期几，0表示星期日，6表示星期六。</li><li>getHours()：获取小时（0~23）。</li><li>setHours()：设置小时（0~23），传入的值超过23则增加月份中的天数，返回的是毫秒数.</li><li>getMinutes()：返回分钟（0~59）。</li><li>setMinutes()：设置分钟（0~59），返回的是毫秒数。</li><li>getSeconds()：获取秒数。</li><li>setSeconds()：设置秒数，返回的是毫秒数。</li><li>getMilliseconds()：获取毫秒。</li><li>setMilliseconds()：设置毫秒数，返回的是毫秒数。</li></ul> <pre><code>//获取7天前：
var now = new Date();//获取当前时间
var nowMs = now.getTime();//获取当前时间的毫秒数
var beforeMs =  nowMs -  1000 * 60 * 60 * 24 * parseInt(n);//前几天，n就取几，整数
var beforeDate = new Date().setTime(beforeMs );
</code></pre> </li></ol> 
<h2><a id="Math__1169"></a>Math 对象：</h2> 
<p>为保存数学公式和信息提供的一个对象，用于执行数学任务。</p> 
<blockquote> 
 <p>没有构造函数Math()，直接把Math作为对象调用其属性和方法。</p> 
</blockquote> 
<h5><a id="_1172"></a>静态属性：</h5> 
<ol><li>Math.LN10：10的自然对数。</li><li>Math.LOG2E：以2为底e的对数。</li><li>Math.LOG10E：以10 为底e的对数。</li><li>Math.SQRT1_2：1/2的平方根。</li><li>Math.SQRT2：2的平方根。</li></ol> 
<h6><a id="_1178"></a>静态方法：</h6> 
<ol><li>Math.max() ：确定一组数值中的最大值。<br> Math.min() ：确定一组数值中的最小值。<pre><code>console.log(Math.max(2,4,6,1,0)); // 6
</code></pre> </li><li>舍入方法：<br> Math.ceil()：对数进行向上取整。<br> Math.floor()：对数进行向下取整。<br> Math.round()：四舍五入。<pre><code>console.log(Math.ceil(25.1)); // 26
</code></pre> </li><li>Matn.random()：返回 0~1 之间的随机数，不包括 0 和 1。<pre><code>//得到位于 [start,end] 之间的随机整数
function select(start,end){
     var total=end-start+1;
     return Math.floor(Math.random()*total+start);
}
</code></pre> </li><li>其他方法：<br> Math.sin(x)<br> Math.cos(x)<br> Math.tan(x)<br> Math.asin(num) ：返回 num 的反正弦值。<br> Math.acos(num)<br> Math.atan(num)<br> Math.sqrt(num)：返回 num 的平方根。<br> Math.log(num)：返回 num 的自然对数。<br> Math.exp(num)：返回 e 的 num 次幂。<br> Math.pow(x,y)：返回 x 的 y 次幂。<br> Math.abs(num)：返回 num 的绝对值。</li></ol>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/976272eb1e171b0aeb155014eede3a62/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">相同的树 单值二叉树 二叉树的最大深度</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/26b08e1c85b7fdbd59e2cf26281e1fe7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">超详细！箭头函数全解，从基础到高级应用一网打尽</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>