<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;——复制构造函数和赋值运算符 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;——复制构造函数和赋值运算符" />
<meta property="og:description" content="对于Point类
显然是将b的坐标值赋值给a的坐标
Point a,b; a = b; 看下一个demo：
TextFile a, b; a.Open( &#34;FILE1.DAT&#34; ); b.Open( &#34;FILE2.DAT&#34; ); b = a; 前面的代码可能表示“将 FILE1.DAT 的内容复制到 FILE2.DAT”，也可能表示“忽略 FILE2.DAT 并使 b 成为 FILE1.DAT 的另一个句柄”。 这里的歧义需要自己去实现 复制构造函数和复制赋值运算符 来达到想要的效果。
一般的：
复制构造函数：T(const T&amp; x);
复制赋值运算符：T &amp; operator=(const T &amp; x);
如果不声明复制构造函数，编译器将为你生成 member-wise 复制构造函数。 如果不声明复制赋值运算符，编译器将为你生成 member-wise 复制赋值运算符。
对于复制构造函数，需要知道：何时调用和有何功能 何时调用：
新建一个对象并将其初始化为同类现有对象
表现形式有：
other是一个T类的对象
①T x(other);
②T x = other;
③T x = T(other);
④T *x = new T(other);" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0dcdab913b14d1ff2d8d81a1105b3850/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-10-19T15:15:39+08:00" />
<meta property="article:modified_time" content="2018-10-19T15:15:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;——复制构造函数和赋值运算符</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>对于Point类</p> 
<p>显然是将b的坐标值赋值给a的坐标</p> 
<pre class="has"><code class="language-cpp">Point a,b;
a = b;</code></pre> 
<p>看下一个demo：</p> 
<pre class="has"><code class="language-cpp">TextFile a, b;
a.Open( "FILE1.DAT" );
b.Open( "FILE2.DAT" );
b = a;</code></pre> 
<p>前面的代码可能表示“将 FILE1.DAT 的内容复制到 FILE2.DAT”，也可能表示“忽略 FILE2.DAT 并使 <code>b</code> 成为 FILE1.DAT 的另一个句柄”。 </p> 
<p>这里的歧义需要自己去实现 复制构造函数和复制赋值运算符 来达到想要的效果。</p> 
<p>一般的：</p> 
<p><strong>复制构造函数</strong>：T(const T&amp; x);</p> 
<p><strong>复制赋值运算符</strong>：T &amp; operator=(const T &amp; x);</p> 
<p>如果不声明复制构造函数，编译器将为你生成 member-wise 复制构造函数。 如果不声明复制赋值运算符，编译器将为你生成 member-wise 复制赋值运算符。</p> 
<h4>对于复制构造函数，需要知道：何时调用和有何功能</h4> 
<p>何时调用：</p> 
<p>新建一个对象并将其初始化为同类现有对象</p> 
<p>表现形式有：</p> 
<p>other是一个T类的对象</p> 
<p>①T x(other);</p> 
<p>②T x = other;</p> 
<p>③T x = T(other);</p> 
<p>④T *x = new T(other);</p> 
<p>说明：</p> 
<p>②和③：可以直接创建T类x对象，也可以创建一个临时对象将其成员的值赋给x</p> 
<p>④创建匿名对象，x是其指针。</p> 
<p>由于按值传递对象调用复制构造函数，因此应该按引用传递对象。这样可以节省调用构造函数的时间以及存储新对象的空间。</p> 
<p>一、如果没有实现复制构造函数，那么系统有隐式复制构造函数 实现的是 对象的<strong>”浅拷贝”</strong></p> 
<p>如果遇到成员变量是指针，那么两者的指针指向位置相同。</p> 
<p>当类调用析构函数时，会释放同一个地址，导致程序崩溃。</p> 
<p>二、为了避免上述问题，解决方案是实现显式复制构造函数</p> 
<p>新开辟一个相同大小的空间，利用内存（或字符串）拷贝给新开辟的空间。该方法也成<strong>“深拷贝”</strong></p> 
<p>三、一般的，如果类中包含了使用new初始化的指针成员，需要实现复制构造函数，反之则使用默认复制构造函数。</p> 
<h4>赋值运算符的功能和何时调用</h4> 
<p>一、首先初始化一个对象T x;</p> 
<p>x = other; //other是T类对象</p> 
<p>这时候调用了赋值运算符函数</p> 
<p>与复制构造函数会遇到的问题相同：数据受损。</p> 
<p>解决方法与前面类似。</p> 
<p>总结：复制构造函数在对象初始化的时候调用，之后用到“=”赋值运算符的时候调用赋值函数</p> 
<p>贴上demo：</p> 
<pre class="has"><code class="language-cpp">#include &lt;iostream&gt;  
#include &lt;string&gt;  
using namespace std;  

class Rect
{
public:
	Rect()//默认构造函数
	{
		_m_byte = NULL;
		memset(_byte, 0, sizeof(_byte));
	}
	Rect(int x, int y, int width, int height, char * byte, char * m_byte)//普通构造
		: _x(x), _y(y), _width(width), _height(height)
	{	
		strcpy(_byte, byte);
		_m_byte = new char[strlen(m_byte) + 1];//开辟空间记得+1防止数组越界
		strcpy(_m_byte, m_byte);
	}
	Rect(const Rect&amp; other)//复制构造函数
	{
		strcpy(_byte, other._byte);
		_m_byte = new char[strlen(other._m_byte) + 1];
		strcpy(_m_byte, other._m_byte);
	}
	Rect&amp; operator=(const Rect &amp; other)//赋值运算符函数
	{
		if(this == &amp;other)    //先进行判定是否相同的对象
			return *this;
		
		if(_m_byte)            //判断是否开辟过空间
			delete []_m_byte;
			
		strcpy(_byte, other._byte);
		_m_byte = new char[strlen(other._m_byte) + 1];
		strcpy(_m_byte, other._m_byte);
		return *this;

	}
	~Rect()    //析构函数 释放new出来的_m_byte 防止内存泄露
	{
		_x = 0;
		_y = 0;
		_width = 0;
		_height = 0;
		memset(_byte, 0, sizeof(_byte));
		delete []_m_byte;
		_m_byte = NULL;
	}
/********************************************************************************/
/*偷懒就直接写成共有成员了，一般是私有变量，使用get(),或set()方法提取或设置成员变量的值*/
/********************************************************************************/
	int _x;
	int _y;
	int _width;
	int _height;
	char _byte[100];
	char *_m_byte;
private:
	
};

int main()  
{  

	Rect r(1,1,1,1,"123","234");//调用普通构造
	Rect r2 = r;                //调用复制构造函数
	Rect r3;                    //调用默认构造
	r3 = r;                    //调用赋值运算符函数
	cout &lt;&lt; string(r._m_byte) &lt;&lt; endl;
	cout &lt;&lt; string(r2._m_byte) &lt;&lt; endl;
	cout &lt;&lt; string(r3._m_byte) &lt;&lt; endl;

	system("pause");
}  </code></pre> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8bf388e5e35a8c3f298abbda983ac47c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">斯坦福大学-自然语言处理入门 笔记 第九课 信息抽取（information extraction）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1110f5bc7d65d14f5f480c17536bf6b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ArcGIS将两个分离面要素合并与拆分</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>