<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法附（一）：BST、AVL树、红黑树、B树比较 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法附（一）：BST、AVL树、红黑树、B树比较" />
<meta property="og:description" content="https://blog.csdn.net/bigtree_3721/article/details/78172634 一、二叉搜索树 定义：
二叉搜索树(BST)，又称为二叉排序树，属于二叉树的一种，通过二叉树将数据组织起来，树的每个节点都包含了健值 key、数据值 data、左子节点指针、右子节点指针。其中健值 key 是最核心的部分，它的值决定了树的组织形状；数据值 data 是该节点对应的数据，有些场景可以忽略，举个例子，key 为身份证号而 data 为人名，通过身份证号找人名；左子节点指针指向左子节点；右子节点指针指向右子节点。
特点:
左右子树也分别是二叉搜索树。左子树的所有节点 key 值都小于它的根节点的 key 值。右子树的所有节点 key 值都大于他的根节点的 key 值。二叉搜索树可以为一棵空树。一般来说，树中的每个节点的 key 值都不相等，但根据需要也可以将相同的 key 值插入树中。 BST 的操作代价分析：
(1) 查找代价： 任何一个数据的查找过程都需要从根结点出发，沿某一个路径朝叶子结点前进。因此查找中数据比较次数与树的形态密切相关。
当树中每个结点左右子树高度大致相同时，树高为logN。则平均查找长度与logN成正比，查找的平均时间复杂度在O(logN)数量级上。
当先后插入的关键字有序时，BST退化成单支树结构。此时树高n。平均查找长度为(n&#43;1)/2，查找的平均时间复杂度在O(N)数量级上。
(2) 插入代价： 新结点插入到树的叶子上，完全不需要改变树中原有结点的组织结构。插入一个结点的代价与查找一个不存在的数据的代价完全相同。
(3) 删除代价： 当删除一个结点P，首先需要定位到这个结点P，这个过程需要一个查找的代价。然后稍微改变一下树的形态。如果被删除结点的左、右子树只有一个存在，则改变形态的代价仅为O(1)。如果被删除结点的左、右子树均存在，只需要将当P的左孩子的右孩子的右孩子的...的右叶子结点与P互换，在改变一些左右子树即可。因此删除操作的时间复杂度最大不会超过O(logN)。
BST效率总结 : 查找最好时间复杂度O(logN)，最坏时间复杂度O(N)。
特点：就时间复杂度来说，BST的查找与二分查找性能差不多，但是增删时BST无需移动记录，只需移动指针比顺序存储好很多;一般性能都在O（log n）。
BST退化成单支树结构，如右边顺序序列所示，此时性能和顺序存储无异。所以，使用BST树还要考虑尽可能让BST树保持左图的结构，和避免右图的结构，也就是所谓的“平衡”问题,进而引出AVL。 二、AVL树 一些详细操作参考：https://baijiahao.baidu.com/s?id=1617719367838438352&amp;wfr=spider&amp;for=pc
二叉查找树在最差情况下竟然和顺序查找效率相当，这是无法仍受的。事实也证明，当存储数据足够大的时候，树的结构对某些关键字的查找效率影响很大。当然，造成这种情况的主要原因就是BST不够平衡(左右子树高度差太大)。既然如此，那么我们就需要通过一定的算法，将不平衡树改变成平衡树。因此，AVL树就诞生了。
在AVL树中任何节点的两个儿子子树的高度最大差别为1，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下都是O(log n)（树高）。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。
引入AVL树的目的是为了提高二叉树的搜索的效率,减少树的平均搜索长度.为此,就必须每向二叉树插入一个结点时调整树的结构,使得二叉树搜索保持平衡,从而可能降低树的高度,减少的平均树的搜索长度.
定义：
AVL树，也称平衡二叉搜索树。AVL树属于二叉搜索树的一种，不同的是他通过一定机制能保证二叉搜索树的平衡，平衡的二叉搜索树的查询效率更高。
特点：
AVL树是一棵二叉搜索树。AVL树的左右子节点也是AVL树，说明可以使用一些递归操作。AVL树拥有二叉搜索树的所有基本特点。每个节点的左右子节点的高度之差的绝对值最多为1，即平衡因子为范围为[-1,1] AVL 的操作代价分析：
(1) 查找代价： AVL是严格平衡的BST（平衡因子不超过1）。那么查找过程与BST一样，只是AVL不会出现最差情况的BST(单支树)。因此查找效率最好，最坏情况都是O(logN)数量级的。
(2) 插入代价： AVL必须要保证严格平衡(|bf|&lt;=1)，那么每一次插入数据使得AVL中某些结点的平衡因子超过1就必须进行旋转操作。事实上，AVL的每一次插入结点操作最多只需要旋转1次(单旋转或双旋转)。因此，总体上插入操作的代价仍然在O(logN)级别上(插入结点需要首先查找插入的位置)。
(3) 删除代价：AVL删除结点的算法可以参见BST的删除结点，但是删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子。因此删除的代价稍微要大一些。每一次删除操作最多需要O(logN)次旋转。因此，删除操作的时间复杂度为O(logN)&#43;O(logN)=O(2logN).
二叉平衡树的严格平衡策略以牺牲建立查找结构(插入，删除操作)的代价，换来了稳定的O(logN) 的查找时间复杂度。。但同时引入的问题是删除、插入需要频繁的旋转。因此，引入了红黑树。红黑树通过节点红黑两种因子控制，即不牺牲太大的建立查找结构的代价，也能保证稳定高效的查找效率。
三、红黑树 红黑树并不追求“完全平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。红黑树能够以O(log2 n) 的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构，能够做到一步旋转之内达到平衡。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a8693f4be1c88764713ced21d045f5da/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-20T21:34:56+08:00" />
<meta property="article:modified_time" content="2019-07-20T21:34:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法附（一）：BST、AVL树、红黑树、B树比较</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4><a href="https://blog.csdn.net/bigtree_3721/article/details/78172634">https://blog.csdn.net/bigtree_3721/article/details/78172634</a></h4> 
<h4>一、二叉搜索树</h4> 
<p><strong>定义：</strong></p> 
<p>  二叉搜索树(BST)，又称为二叉排序树，属于二叉树的一种，通过二叉树将数据组织起来，树的每个节点都包含了健值 key、数据值 data、左子节点指针、右子节点指针。其中健值 key 是最核心的部分，它的值决定了树的组织形状；数据值 data 是该节点对应的数据，有些场景可以忽略，举个例子，key 为身份证号而 data 为人名，通过身份证号找人名；左子节点指针指向左子节点；右子节点指针指向右子节点。</p> 
<p><strong>特点:</strong></p> 
<ul><li>左右子树也分别是二叉搜索树。</li><li>左子树的所有节点 key 值都小于它的根节点的 key 值。</li><li>右子树的所有节点 key 值都大于他的根节点的 key 值。</li><li>二叉搜索树可以为一棵空树。</li><li>一般来说，树中的每个节点的 key 值都不相等，但根据需要也可以将相同的 key 值插入树中。</li></ul> 
<p style="text-align:center;"><img alt="" class="has" height="374" src="https://images2.imgbox.com/81/d5/EmgdHNtM_o.png" width="415"></p> 
<p><strong>BST 的操作代价分析：</strong></p> 
<p>    (1) 查找代价： 任何一个数据的查找过程都需要从根结点出发，沿某一个路径朝叶子结点前进。因此查找中数据比较次数与树的形态密切相关。</p> 
<p>         当树中每个结点左右子树高度大致相同时，树高为<span style="color:#f33b45;">logN。则平均查找长度与logN成正比，查找的平均时间复杂度在O(logN)</span>数量级上。</p> 
<p>         当先后插入的关键字有序时，BST退化成单支树结构。此时树高n。平均查找长度为(n+1)/2，查找的平均时间复杂度在<span style="color:#f33b45;">O(N)</span>数量级上。</p> 
<p>    (2) 插入代价： 新结点插入到树的叶子上，完全不需要改变树中原有结点的组织结构。插入一个结点的代价与查找一个不存在的数据的代价完全相同。</p> 
<p>    (3) 删除代价： 当删除一个结点P，首先需要定位到这个结点P，这个过程需要一个查找的代价。然后稍微改变一下树的形态。如果被删除结点的左、右子树只有一个存在，则改变形态的代价仅为O(1)。如果被删除结点的左、右子树均存在，只需要将当P的左孩子的右孩子的右孩子的...的右叶子结点与P互换，在改变一些左右子树即可。因此删除操作的时间复杂度最大不会超过O(logN)。</p> 
<p>    BST效率总结 :  查找最好时间复杂度O(logN)，最坏时间复杂度O(N)。</p> 
<p>特点：就时间复杂度来说，BST的查找与二分查找性能差不多，但是增删时BST无需移动记录，只需移动指针比顺序存储好很多;一般性能都在O（log n）。</p> 
<p style="text-align:center;"><img alt="" class="has" height="293" src="https://images2.imgbox.com/fd/93/RHDGtSyl_o.png" width="601"></p> 
<p>BST退化成单支树结构，如右边顺序序列所示，此时性能和顺序存储无异。所以，使用BST树还要考虑尽可能让BST树保持左图的结构，和避免右图的结构，也就是所谓的“平衡”问题,进而引出AVL。   </p> 
<h4>二、AVL树</h4> 
<p>一些详细操作参考：<a href="https://baijiahao.baidu.com/s?id=1617719367838438352&amp;wfr=spider&amp;for=pc" rel="nofollow">https://baijiahao.baidu.com/s?id=1617719367838438352&amp;wfr=spider&amp;for=pc</a></p> 
<p>二叉查找树在最差情况下竟然和顺序查找效率相当，这是无法仍受的。事实也证明，当存储数据足够大的时候，树的结构对某些关键字的查找效率影响很大。当然，造成这种情况的主要原因就是BST不够平衡(左右子树高度差太大)。既然如此，那么我们就需要通过一定的算法，将不平衡树改变成平衡树。因此，AVL树就诞生了。</p> 
<p>在AVL树中任何节点的两个儿子子树的高度最大差别为1，所以它也被称为高度平衡树。<span style="color:#f33b45;">查找、插入和删除在平均和最坏情况下都是O(log n)（树高）</span>。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p> 
<p>引入AVL树的目的是为了提高二叉树的搜索的效率,减少树的平均搜索长度.为此,就必须每向二叉树插入一个结点时调整树的结构,使得二叉树搜索保持平衡,从而可能降低树的高度,减少的平均树的搜索长度.</p> 
<p><strong>定义：</strong></p> 
<p>AVL树，也称平衡二叉搜索树。AVL树属于<span style="color:#e579b6;">二叉搜索树的一种</span>，不同的是他通过一定机制能保证二叉搜索树的平衡，平衡的二叉搜索树的查询效率更高。</p> 
<p><strong>特点：</strong></p> 
<ul><li><span style="color:#e579b6;">AVL树是一棵二叉搜索树。</span></li><li>AVL树的左右子节点也是AVL树，说明可以使用一些递归操作。</li><li>AVL树拥有二叉搜索树的所有基本特点。</li><li>每个节点的左右子节点的高度之差的绝对值最多为1，即平衡因子为范围为[-1,1]</li></ul> 
<p style="text-align:center;"><img alt="" class="has" height="410" src="https://images2.imgbox.com/62/71/CtVau0Ha_o.png" width="684"></p> 
<p><span style="color:#f33b45;">AVL 的操作代价分析：</span></p> 
<p>    (1) 查找代价： AVL是严格平衡的BST（平衡因子不超过1）。那么查找过程与BST一样，只是AVL不会出现最差情况的BST(单支树)。因此查找效率最好，最坏情况都是O(logN)数量级的。</p> 
<p>    (2) 插入代价： AVL必须要保证严格平衡(|bf|&lt;=1)，那么每一次插入数据使得AVL中某些结点的平衡因子超过1就必须进行旋转操作。事实上，AVL的每一次插入结点操作最多只需要旋转1次(单旋转或双旋转)。因此，总体上插入操作的代价仍然在O(logN)级别上(插入结点需要首先查找插入的位置)。</p> 
<p>    (3) 删除代价：AVL删除结点的算法可以参见BST的删除结点，但是删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子。因此删除的代价稍微要大一些。每一次删除操作最多需要O(logN)次旋转。因此，删除操作的时间复杂度为O(logN)+O(logN)=O(2logN).<br> 二叉平衡树的严格平衡策略以牺牲建立查找结构(插入，删除操作)的代价，换来了稳定的O(logN) 的查找时间复杂度。。但同时引入的问题是删除、插入需要频繁的旋转。因此，引入了红黑树。红黑树通过节点红黑两种因子控制，即不牺牲太大的建立查找结构的代价，也能保证稳定高效的查找效率。</p> 
<h4>三、红黑树</h4> 
<p>红黑树并不追求“完全平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。红黑树能够以O(log2 n) 的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构，能够做到一步旋转之内达到平衡。</p> 
<p><strong>定义：</strong></p> 
<p>红黑(Red-black)树是一种<span style="color:#e579b6;">平衡二叉搜索树</span>，它与AVL树类似，都在插入和删除操作时能通过旋转操作保持二叉查找树的平衡，以便能获得高效的查找性能。它可以在 O(logn) 时间内做查找，插入和删除等操作。</p> 
<p>对于AVL树来说，红黑树牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。</p> 
<p><strong>特点：</strong></p> 
<ul><li>节点是红色或黑色。</li><li>根节点是黑色。</li><li>每个叶节点（NIL节点）是黑色的。</li><li>每个红色节点的两个子节点都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li></ul> 
<p><strong>RBT 的操作代价分析：</strong></p> 
<p>     (1) 查找代价：由于红黑树的性质(最长路径长度不超过最短路径长度的2倍)，可以说明红黑树虽然不像AVL一样是严格平衡的，但平衡性能还是要比BST要好。其查找代价基本维持在O(logN)左右，但在最差情况下(最长路径是最短路径的2倍少1)，比AVL要略逊色一点。</p> 
<p>    (2) 插入代价：RBT插入结点时，需要旋转操作和变色操作。但由于只需要保证RBT基本平衡就可以了。因此插入结点最多只需要2次旋转，这一点和AVL的插入操作一样。虽然变色操作需要O(logN)，但是变色操作十分简单，代价很小。</p> 
<p>    (3) 删除代价：RBT的删除操作代价要比AVL要好的多，删除一个结点最多只需要3次旋转操作。</p> 
<p>    RBT 效率总结 : 查找 效率最好情况下时间复杂度为O(logN)，但在最坏情况下比AVL要差一些，但也远远好于BST。</p> 
<p>    插入和删除操作改变树的平衡性的概率要远远小于AVL（RBT不是高度平衡的）。因此需要的旋转操作的可能性要小，而且一旦需要旋转，插入一个结点最多只需要旋转2次，删除最多只需要旋转3次(小于AVL的删除操作所需要的旋转次数)。虽然变色操作的时间复杂度在O(logN)，但是实际上，这种操作由于简单所需要的代价很小。<br>  </p> 
<h4>四、B-树</h4> 
<p><strong>B-树的引入：</strong></p> 
<p>对于在内存中的查找结构而言，红黑树的效率已经非常好了(实际上很多实际应用还对RBT进行了优化)。但是如果是数据量非常大的查找呢？将这些数据全部放入内存组织成RBT结构显然是不实际的。实际上，像OS中的文件目录存储，数据库中的文件索引结构的存储.... 都不可能在内存中建立查找结构。必须在磁盘中建立好这个结构。那么在这个背景下，RBT还是一种好的选择吗？</p> 
<p>     在磁盘中组织查找结构，从任何一个结点指向其他结点都有可能读取一次磁盘数据，再将数据写入内存进行比较。大家都知道，频繁的磁盘IO操作，效率是很低下的(机械运动比电子运动要慢不知道多少)。显而易见，所有的二叉树的查找结构在磁盘中都是低效的。因此，B树很好的解决了这一个问题。</p> 
<p><strong>定义：</strong></p> 
<p> B树即平衡查找树，一般理解为平衡多路查找树，也称为B-树、B_树。是一种自平衡树状数据结构，能对存储的数据进行O(log n)的时间复杂度进行查找、插入和删除。B树一般较多用在存储系统上，比如数据库或文件系统。</p> 
<p><strong>特点：</strong></p> 
<ul><li>B树可以定义一个m值作为预定范围，即m路(阶)B树。</li><li>每个节点最多有m个孩子。</li><li>每个节点至少有ceil(m/2)个孩子，除了根节点和叶子节点外。</li><li>对于根节点，子树个数范围为[2,m]，节点内值的个数范围为[1,m-1]。</li><li>对于非根节点，节点内的值个数范围为[ceil(m/2)-1,m-1]。</li><li>根节点(非叶子节点)至少有两个孩子。</li><li>一个有k个孩子的非叶子节点包含k-1个值。</li><li>所有叶子节点在同一层。</li><li>节点内的值按照从小到大排列。</li><li>父节点的若干值作为分离值分成多个子树，左子树小于对应分离值，对应分离值小于右子树。</li></ul> 
<p><strong>    B-Tree的操作代价分析：</strong></p> 
<p>    (1) 查找代价： B-Tree作为一个平衡多路查找树(m-叉)。B树的查找分成两种：一种是从一个结点查找另一结点的地址的时候，需要定位磁盘地址(查找地址)，查找代价极高。另一种是将结点中的有序关键字序列放入内存，进行优化查找(可以用折半)，相比查找代价极低。而B树的高度很小，因此在这一背景下，B树比任何二叉结构查找树的效率都要高很多。而且B+树作为B树的变种，其查找效率更高。</p> 
<p>    (2)插入代价： B-Tree的插入会发生结点的分裂操作。当插入操作引起了s个节点的分裂时，磁盘访问的次数为h(读取搜索路径上的节点)＋2s(回写两个分裂出的新节点)＋1（回写新的根节点或插入后没有导致分裂的节点）。因此，所需要的磁盘访问次数是h+2s+1，最多可达到3h+1。因此插入的代价是很大的。</p> 
<p>    (3)删除代价：B-Tree的删除会发生结点合并操作。最坏情况下磁盘访问次数是3h＝（找到包含被删除元素需要h次<br> 读访问）+（获取第2至h层的最相邻兄弟需要h-1次读访问）+（在第3至h层的合并需要h-2次写<br> 访问）+（对修改过的根节点和第2层的两个节点进行3次写访问）</p> 
<p>   B-Tree效率总结： 由于考虑磁盘储存结构，B树的查找、删除、插入的代价都远远要小于任何二叉结构树(读写磁盘次数的降低)。<br>  </p> 
<h4>五、B+树</h4> 
<p>B+树是B~树的一种变体，在磁盘查找结构中，B+树更适合文件系统的磁盘存储结构。</p> 
<p>      结构对比： B~树是平衡多路查找树，所有结点中都包含了待查关键字的有效信息(比如文件磁盘指针)。每个结点若有n个关键字，则有n+1个指向其他结点的指针。</p> 
<p>                     B+树严格意义上说已经不是树，它的叶子结点之间也有指针链接。B+树的非终结点中并不含有关键字的信息，需要查找的关键字的全部信息都包含在叶子结点上。非终结点中只作为叶子结点关键字的索引而存在。</p> 
<p>      查找对比：1. 在相同数量的待查数据下，B+树查找过程中需要调用的磁盘IO操作要少于普通B~树。由于B树所在的磁盘存储背景下，因此B+树的查找性能要好于B~树。</p> 
<p>                     2. B+树的查找效率更加稳定，因为所有叶子结点都处于同一层中，而且查找所有关键字都必须走完从根结点到叶子结点的全部历程。因此同一颗B+树中，任何关键字的查找比较次数都是一样的。而B树就不一定了，可能查找到某一个非终结点就结束了。</p> 
<p>      插入删除对比：  B+树与B~树在插入删除操作中的效率是差不多的。</p> 
<p>      总体评价：在应用背景下，特别是文件结构存储中。B+树的应用要更多，其效率也要比B~树好。</p> 
<p><strong>定义：</strong></p> 
<p>B+树是B树的一种变体，也属于平衡多路查找树，大体结构与B树相同，包含根节点、内部节点和叶子节点。多用于数据库和操作系统的文件系统中，由于B+树内部节点不保存数据，所以能在内存中存放更多索引，增加缓存命中率。另外因为叶子节点相连遍历操作很方便，而且数据也具有顺序性，便于区间查找。</p> 
<p><strong>特点：</strong></p> 
<ul><li>B+树可以定义一个m值作为预定范围，即m路(阶)B+树。</li><li>根节点可能是叶子节点，也可能是包含两个或两个以上子节点的节点。</li><li>内部节点如果拥有k个关键字则有k+1个子节点。</li><li>非叶子节点不保存数据，只保存关键字用作索引，所有数据都保存在叶子节点中。</li><li>非叶子节点有若干子树指针，如果非叶子节点关键字为k1,k2,...kn，其中n=m-1，那么第一个子树关键字判断条件为小于k1，第二个为大于等于k1而小于k2，以此类推，最后一个为大于等于kn，总共可以划分出m个区间，即可以有m个分支。（判断条件其实没有严格的要求，只要能实现对B+树的数据进行定位划分即可，有些实现使用了m个关键字来划分区间，也是可以的）</li><li>所有叶子节点通过指针链相连，且叶子节点本身按关键字的大小从小到大顺序排列。</li><li>自然插入而不进行删除操作时，叶子节点项的个数范围为[floor(m/2),m-1]，内部节点项的个数范围为[ceil(m/2)-1,m-1]。</li><li>另外通常B+树有两个头指针，一个指向根节点一个指向关键字最小的叶子节点。</li><li>在进行删除操作时，涉及到索引节点填充因子和叶子节点填充因子，一般可设叶子节点和索引节点的填充因子都不少于50%</li></ul> 
<p>   </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/87c60497982fc532a44e23c96e27b57f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">adb logcat把之前的log信息都输出来了</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/047af2c81fd48f65ced88ea7618b6251/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Android系统源码修改】源码含有SmsManager的编译失败问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>