<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【c语言】程序环境和预处理（内功更上一层） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【c语言】程序环境和预处理（内功更上一层）" />
<meta property="og:description" content="本篇重点 程序的翻译环境
程序的执行环境
详解：C语言程序的编译&#43;链接
预定义符号介绍
预处理指令 #define
宏和函数的对比
预处理操作符#和##的介绍
命令定义
预处理指令 #include
预处理指令 #undef
条件编译
1.程序的翻译环境和执行环境 在ANSI C中的任何一种实现中，存在两个不同的环境
第一种是翻译环境，在这个环境中源代码被转换成机器可以执行的机器代码
第二种是执行环境，它用于实际执行代码
2.详解编译加链接 2.1 编译环境 组成一个程序的每个源文件通过编译过程转换成目标文件的代码。每个目标文件通过链接器捆绑在一起，形成一个单一而完整的可执行的程序。链接器同时也会引入标准C函数库中任何被该程序所用到的函数，而且它可以搜索程序员个人
的程序库，将其需要的函数也链接到程序中。 2.2 编译本身也分为几个阶段： sum.c文件
int g_val = 2016; void print(const char *str) { printf(&#34;%s\n&#34;, str); } #include &lt;stdio.h&gt; int main() { extern void print(char *str); extern int g_val; printf(&#34;%d\n&#34;, g_val); print(&#34;hello bit.\n&#34;); return 0; } test.c文件
#include &lt;stdio.h&gt; int main() { extern void print(char *str); extern int g_val; printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/544fa59f5dc17cb3a0af7925c2c820c7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-06T21:40:12+08:00" />
<meta property="article:modified_time" content="2024-01-06T21:40:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【c语言】程序环境和预处理（内功更上一层）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2></h2> 
<h2>本篇重点</h2> 
<blockquote> 
 <p>程序的翻译环境<br> 程序的执行环境<br> 详解：C语言程序的编译+链接<br> 预定义符号介绍<br> 预处理指令 #define<br> 宏和函数的对比<br> 预处理操作符#和##的介绍<br> 命令定义<br> 预处理指令 #include<br> 预处理指令 #undef<br> 条件编译</p> 
</blockquote> 
<h2>1.程序的翻译环境和执行环境</h2> 
<p>在ANSI C中的任何一种实现中，存在两个不同的环境</p> 
<blockquote> 
 <p>第一种是翻译环境，在这个环境中源代码被转换成机器可以执行的机器代码</p> 
 <p>第二种是执行环境，它用于实际执行代码</p> 
</blockquote> 
<h2>2.详解编译加链接</h2> 
<h3>2.1 编译环境</h3> 
<p><img alt="" height="776" src="https://images2.imgbox.com/6c/ad/cK29cbtZ_o.png" width="1200"></p> 
<ul><li>组成一个程序的每个源文件通过编译过程转换成目标文件的代码。</li><li>每个目标文件通过链接器捆绑在一起，形成一个单一而完整的可执行的程序。</li><li>链接器同时也会引入标准C函数库中任何被该程序所用到的函数，而且它可以搜索程序员个人<br> 的程序库，将其需要的函数也链接到程序中。</li></ul> 
<h3>2.2 编译本身也分为几个阶段：</h3> 
<p>sum.c文件</p> 
<pre><code class="language-cpp">int g_val = 2016;
void print(const char *str)
{
    printf("%s\n", str);
}
#include &lt;stdio.h&gt;
int main()
{
    extern void print(char *str);
    extern int g_val;
    printf("%d\n", g_val);
    print("hello bit.\n");
    return 0;
}

</code></pre> 
<p> test.c文件</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
    extern void print(char *str);
    extern int g_val;
    printf("%d\n", g_val);
    print("hello bit.\n");
    return 0;
}</code></pre> 
<p> <img alt="" height="631" src="https://images2.imgbox.com/85/38/Pgvhthl9_o.png" width="1200"></p> 
<p></p> 
<h3>2.3 运行环境</h3> 
<p><strong>程序执行的过程：</strong><br> 1. 程序必须载入内存中。在有操作系统的环境中：一般这个由操作系统完成。在独立的环境中，程序的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成。<br> 2. 程序的执行便开始。接着便调用main函数。<br> 3. 开始执行程序代码。这个时候程序将使用一个运行时堆栈（stack），存储函数的局部变量和返回地址。程序同时也可以使用静态（static）内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值。<br> 4. 终止程序。正常终止main函数；也有可能是意外终止。<br>  </p> 
<h2>3.预理详解</h2> 
<h3>3.1 预定义符号</h3> 
<blockquote> 
 <table><tbody><tr><td>__FILE__<br> __LINE__<br> __DATE__<br> __TIME__<br> __STDC__</td><td>//进行编译的源文件<br> //文件当前的行号<br> //文件被编译的日期<br> //文件被编译的时间<br> //如果编译器遵循ANSI C，其值为1，否则未定义</td></tr></tbody></table> 
</blockquote> 
<p>这些预定义符号都是语言内置的。 </p> 
<h3>3.2 #define</h3> 
<h4>3.2.1 #define定义标识符</h4> 
<blockquote> 
 <p>#define max 2</p> 
</blockquote> 
<p>如上就是#define定义，用来定义一个符号为另一个内容的代替，即是在我们使用这个符号时，在预处理时就会把所有的max换成定义的内容。</p> 
<p>记住不要在这串代码的最后加分号，容易发生错误。</p> 
<h4>3.2.2 #define定义宏</h4> 
<blockquote> 
 <p>#define 机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏（macro）或定义宏（define macro）。</p> 
</blockquote> 
<p> 举个例子：</p> 
<pre><code class="language-cpp">#define add(a,b)  a+b

int main()
{
    int a = 10,b = 20;
    int c;
    c = add(a,b);
    printf("%d\n",c);
    return 0;
}</code></pre> 
<p> 请看以上代码，这个结果应该是30。这是因为在预处理阶段，我们将会使add中的参数替换为10 和 20然后进行相加，最终得到30的结果，这就是宏的简单定义。</p> 
<h4>3.2.3 #define替换规则</h4> 
<blockquote> 
 <p>在程序中扩展#define定义符号和宏时，需要涉及几个步骤。<br> 1. 在调用宏时，首先对参数进行检查，看看是否包含任何由#define定义的符号。如果是，它们首先被替换。<br> 2. 替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值所替换。<br> 3. 最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上述处理过程。<br> 注意：<br> 1. 宏参数和#define 定义中可以出现其他#define定义的符号。但是对于宏，不能出现递归。<br> 2. 当预处理器搜索#define定义的符号的时候，字符串常量的内容并不被搜索。</p> 
</blockquote> 
<h4>3.2.4 #和##</h4> 
<blockquote> 
 <ul><li>使用 # ，把一个宏参数变成对应的字符串</li><li>##可以把位于它两边的符号合成一个符号,它允许宏定义从分离的文本片段创建标识符。</li></ul> 
</blockquote> 
<pre><code class="language-cpp">int i = 10;
#define PRINT(FORMAT, VALUE)  printf("the value of " #VALUE "is "FORMAT "\n", VALUE);
...
PRINT("%d", i+3);//产生了什么效果？</code></pre> 
<p> 代码中的 #VALUE 会预处理器处理为：<br> "VALUE" .<br> 最终的输出的结果应该是：</p> 
<blockquote> 
 <p>the value of i+3 is 13 </p> 
</blockquote> 
<pre><code class="language-cpp">#define ADD_TO_SUM(num, value) sum##num += value;
...
ADD_TO_SUM(5, 10);//作用是：给sum5增加10</code></pre> 
<p> 这样的连接必须产生一个合法的标识符。否则其结果就是未定义的。</p> 
<h4>3.2.5 带副作用的宏参数</h4> 
<p></p> 
<blockquote> 
 <p>当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，那么你在使用这个宏的时候就可能出现危险，导致不可预测的后果。副作用就是表达式求值的时候出现的永久性效果。</p> 
</blockquote> 
<p><br> 例如：<br> MAX宏可以证明具有副作用的参数所引起的问题。</p> 
<blockquote> 
 <p>#define MAX(a, b) ( (a) &gt; (b) ? (a) : (b) )<br> ...<br> x = 5;<br> y = 8;<br> z = MAX(x++, y++);<br> printf("x=%d y=%d z=%d\n", x, y, z);//输出的结果是什么？</p> 
</blockquote> 
<p><br> 这里我们得知道预处理器处理之后的结果是什么：</p> 
<blockquote> 
 <p>z = ( (x++) &gt; (y++) ? (x++) : (y++))；</p> 
</blockquote> 
<p><br> 所以输出的结果是：</p> 
<p></p> 
<blockquote> 
 <p>x=6 y=10 z=9</p> 
</blockquote> 
<h4>3.2.6 宏和函数对比</h4> 
<p><br><span style="color:#fe2c24;">宏通常被应用于执行简单的运算。<br> 比如在两个数中找出较大的一个。<br> 那为什么不用函数来完成这个任务？</span><br><strong>原因有二：</strong><br>         1. 用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。<br> 所以宏比函数在程序的规模和速度方面更胜一筹。<br>         2. 更为重要的是函数的参数必须声明为特定的类型。<br> 所以函数只能在类型合适的表达式上使用。反之这个宏怎可以适用于整形、长整型、浮点型等可以<br> 用于&gt;来比较的类型。<br> 宏是类型无关的。<br><strong>宏的缺点：</strong></p> 
<p><strong>        </strong>当然和函数相比宏也有劣势的地方：</p> 
<p></p> 
<blockquote> 
 <p><br>         1. 每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序的长度。<br>         2. 宏是没法调试的。</p> 
</blockquote> 
<blockquote> 
 <p>x+1;//不带副作用</p> 
 <p>x++;//带有副作用</p> 
 <p><br> #define MAX(a, b) ( (a) &gt; (b) ? (a) : (b) )<br> ...<br> x = 5;<br> y = 8;<br> z = MAX(x++, y++);<br> printf("x=%d y=%d z=%d\n", x, y, z);//输出的结果是什么？<br> z = ( (x++) &gt; (y++) ? (x++) : (y++));<br> x=6 y=10 z=9</p> 
</blockquote> 
<table><tbody><tr><td>属性</td><td>#define定义宏</td><td>函数</td></tr><tr><td>代 码 长 度</td><td>每次使用时，宏代码都会被插入到程序中。除了非常<br> 小的宏之外，程序的长度会大幅度增长</td><td>函数代码只出现于一个地方；每<br> 次使用这个函数时，都调用那个<br> 地方的同一份代码</td></tr><tr><td>执 行 速 度</td><td>更快</td><td>存在函数的调用和返回的额外开<br> 销，所以相对慢一些</td></tr><tr><td>操 作 符 优 先 级</td><td>宏参数的求值是在所有周围表达式的上下文环境里，<br> 除非加上括号，否则邻近操作符的优先级可能会产生<br> 不可预料的后果，所以建议宏在书写的时候多些括<br> 号。</td><td>函数参数只在函数调用的时候求<br> 值一次，它的结果值传递给函<br> 数。表达式的求值结果更容易预<br> 测。</td></tr><tr><td>带 有 副 作 用 的 参 数</td><td>参数可能被替换到宏体中的多个位置，所以带有副作<br> 用的参数求值可能会产生不可预料的结果。</td><td>函数参数只在传参的时候求值一<br> 次，结果更容易控制。</td></tr><tr><td>参 数 类 型</td><td>宏的参数与类型无关，只要对参数的操作是合法的，<br> 它就可以使用于任何参数类型。</td><td>函数的参数是与类型有关的，如<br> 果参数的类型不同，就需要不同<br> 的函数，即使他们执行的任务是<br> 不同的。</td></tr><tr><td>调 试</td><td>宏是不方便调试的</td><td>函数是可以逐语句调试的</td></tr><tr><td>递 归</td><td>宏是不能递归的</td><td>函数是可以递归的</td></tr></tbody></table> 
<p></p> 
<h4>3.2.7 命名约定</h4> 
<p><span style="color:#fe2c24;">        一般来讲函数的宏的使用语法很相似。所以语言本身没法帮我们区分二者。<br> 那我们平时的一个习惯是：</span></p> 
<blockquote> 
 <p>宏名全部大写</p> 
 <p>函数名不要全部大写</p> 
</blockquote> 
<h3>3.3 #undef</h3> 
<p>这条指令用于移除一个宏定义</p> 
<blockquote> 
 <p>#undef MAX</p> 
 <p>//这样可以使原来定义的叫MAX的宏移除掉，方便我们接下来再次定义同名的宏</p> 
</blockquote> 
<h3>3.4 命令行定义</h3> 
<blockquote> 
 <p>许多C 的编译器提供了一种能力，允许在命令行中定义符号。用于启动编译过程。<br> 例如：当我们根据同一个源文件要编译出不同的一个程序的不同版本的时候，这个特性有点用处。（假定某个程序中声明了一个某个长度的数组，如果机器内存有限，我们需要一个很小的数组，但是另外一个机器内存大写，我们需要一个数组能够大写。）</p> 
</blockquote> 
<h3>3.5 条件定义</h3> 
<blockquote> 
 <p>在编译一个程序的时候我们如果要将一条语句（一组语句）编译或者放弃是很方便的。因为我们有条件<br> 编译指令。</p> 
</blockquote> 
<p>比如说：</p> 
<blockquote> 
 <p>调试性的代码，删除可惜，保留又碍事，所以我们可以选择性的编译。</p> 
</blockquote> 
<p>常见的条件编译指令：</p> 
<blockquote> 
 <p>1.</p> 
 <p>#if 常量表达式</p> 
 <p>#endif<br> //常量表达式由预处理器求值。<br> 如：<br> #define __DEBUG__ 1<br> #if __DEBUG__<br> //..<br> #endif<br> 2.多个分支的条件编译<br> #if 常量表达式<br> //...<br> #elif 常量表达式<br> //...<br> #else<br> //...<br> #endif<br> 3.判断是否被定义<br> #if defined(symbol)<br> #ifdef symbol<br> #if !defined(symbol)<br> #ifndef symbol<br> 4.嵌套指令<br> #if defined(OS_UNIX)<br> #ifdef OPTION1<br> unix_version_option1();<br> #endif<br> #ifdef OPTION2<br> unix_version_option2();<br> #endif<br> #elif defined(OS_MSDOS)<br> #ifdef OPTION2<br> msdos_version_option2();<br> #endif<br> #endif</p> 
</blockquote> 
<p>总结：本章是可以增加你对计算机的理解的，内功也是很重要的，欢迎伙伴们指定不足。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ad1c4ed7d8f05441402539cb39936028/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构】栈和队列</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2a5b5ed25ea6429618e95bba996ef528/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">嵌入式（五）通信协议 | 串行异步同步 UART SPI I2C 全解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>