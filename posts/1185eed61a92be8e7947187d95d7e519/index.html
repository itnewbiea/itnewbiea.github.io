<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>css主题切换 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="css主题切换" />
<meta property="og:description" content="前端主题切换方案 提前加载所有主题样式，切换时修改类名 实现 思路：提前将所有样式文件引入，然后在切换主题是给一个公共的元素添加一个类名，通过样式的层级来覆盖原有颜色相关样式
main.js中提前引入样式文件：
import &#39;@/assets/css/dark.css&#39; import &#39;@/assets/css/green.css&#39; green.css绿色主题css文件：
body.green .content { color: #333; background-color: #c7edcc; } 原来的样式：
.content { color: #333; background-color: #fff; } 切换主题时给公共的元素添加相对应类型来覆盖原有颜色样式：
&lt;button @click=&#34;changeStyle(&#39;dark&#39;)&#34;&gt;切换成黑色主题&lt;/button&gt; &lt;button @click=&#34;changeStyle(&#39;green&#39;)&#34;&gt;切换成绿色主题&lt;/button&gt; changeStyle(color) { document.body.className = color } 优缺点 1》优点
不用重新加载样式文件，在样式切换时不会有卡顿
2》缺点：
首次就加载了所有的主题样式文件，牺牲了一点首屏时间来加载样式
一定要注意优先级的问题，主题切换的样式优先级要高于原有的才能覆盖
不是很灵活，没添加一个主题就要添加一个主题样式文件
link标签动态引入 实现 思路：也和前面一样先写好几套主题样式，然后切换时修改link标签的href属性
document.getElementById(&#39;#theme&#39;).href = &#39;green.css&#39; 优缺点 1》优点
实现了按需加载，首屏更好
2》缺点
动态加载样式文件，如果文件过大网络情况不佳的情况下可能会有加载延迟，导致样式切换不流畅
一定要注意优先级的问题，主题切换的样式优先级要高于原有的才能覆盖
不是很灵活，没添加一个主题就要添加一个主题样式文件
CSS变量&#43;类名切换 和第一种方案类似，只不过不用写那么多样式，相当于方案1的优化版
CSS定义变量 –两个短横线用于定义CSS变量
&lt;div class=&#34;origin&#34;&gt; 祖先元素 &lt;div class=&#34;father&#34;&gt; 父亲 &lt;div class=&#34;child&#34;&gt; 儿子 &lt;div class=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/1185eed61a92be8e7947187d95d7e519/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-19T22:46:12+08:00" />
<meta property="article:modified_time" content="2023-09-19T22:46:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">css主题切换</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>前端主题切换方案</h2> 
<h4><a id="_2"></a>提前加载所有主题样式，切换时修改类名</h4> 
<h5><a id="_4"></a>实现</h5> 
<p>思路：提前将所有样式文件引入，然后在切换主题是给一个公共的元素添加一个类名，通过样式的层级来覆盖原有颜色相关样式</p> 
<p>main.js中提前引入样式文件：</p> 
<pre><code>import '@/assets/css/dark.css'
import '@/assets/css/green.css'
</code></pre> 
<p>green.css绿色主题css文件：</p> 
<pre><code>body.green .content {
  color: #333;
  background-color: #c7edcc;
}
</code></pre> 
<p>原来的样式：</p> 
<pre><code>.content {
  color: #333;
  background-color: #fff;
}
</code></pre> 
<p>切换主题时给公共的元素添加相对应类型来覆盖原有颜色样式：</p> 
<pre><code>    &lt;button @click="changeStyle('dark')"&gt;切换成黑色主题&lt;/button&gt;
    &lt;button @click="changeStyle('green')"&gt;切换成绿色主题&lt;/button&gt;
    changeStyle(color) {
      document.body.className = color
    }
</code></pre> 
<h5><a id="_43"></a>优缺点</h5> 
<p>1》优点</p> 
<p>不用重新加载样式文件，在样式切换时不会有卡顿</p> 
<p>2》缺点：</p> 
<p>首次就加载了所有的主题样式文件，牺牲了一点首屏时间来加载样式</p> 
<p>一定要注意优先级的问题，主题切换的样式优先级要高于原有的才能覆盖</p> 
<p>不是很灵活，没添加一个主题就要添加一个主题样式文件</p> 
<h4><a id="link_57"></a>link标签动态引入</h4> 
<h5><a id="_59"></a>实现</h5> 
<p>思路：也和前面一样先写好几套主题样式，然后切换时修改link标签的href属性</p> 
<pre><code>document.getElementById('#theme').href = 'green.css'
</code></pre> 
<h5><a id="_67"></a>优缺点</h5> 
<p>1》优点</p> 
<p>实现了按需加载，首屏更好</p> 
<p>2》缺点</p> 
<p>动态加载样式文件，如果文件过大网络情况不佳的情况下可能会有加载延迟，导致样式切换不流畅</p> 
<p>一定要注意优先级的问题，主题切换的样式优先级要高于原有的才能覆盖</p> 
<p>不是很灵活，没添加一个主题就要添加一个主题样式文件</p> 
<h4><a id="CSS_81"></a>CSS变量+类名切换</h4> 
<p>和第一种方案类似，只不过不用写那么多样式，相当于方案1的优化版</p> 
<h5><a id="CSS_85"></a>CSS定义变量</h5> 
<p>–两个短横线用于定义CSS变量</p> 
<pre><code>    &lt;div class="origin"&gt;
      祖先元素
      &lt;div class="father"&gt;
        父亲
        &lt;div class="child"&gt;
          儿子
          &lt;div class="grandson"&gt;儿子的儿子&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;

.origin {
  background-color: var(--theme-bg);
  color: var(--theme-font);
}
.father {
  --theme-bg: yellowgreen;
  --theme-font: red;
}
.child {
  background-color: var(--theme-bg);
  color: var(--theme-font);
}
.grandson {
  background-color: var(--theme-bg);
  color: var(--theme-font);
}
</code></pre> 
<p>父元素（祖先元素）定义了css变量，子元素（后代元素）就可以通过var()来使用了</p> 
<h5><a id="var_121"></a>var()</h5> 
<p><strong>语法：</strong></p> 
<pre><code>var(&lt;custom-property-name&gt; ,&lt;declaration-value&gt;?)
</code></pre> 
<p>var()是一个css函数，可以插入一个自定义属性，用来代替非自定义属性中 值的任何部分</p> 
<p><strong>第一个参数</strong></p> 
<p>作用：要替换的自定义属性的名称</p> 
<p><strong>第二个可选参数</strong></p> 
<p>可选参数</p> 
<p>作用：用作回退值。如果第一个参数引用的自定义属性无效，则该函数将使用第二个值</p> 
<h5><a id="root_141"></a><strong>：root</strong></h5> 
<p>是一个伪类，用于匹配文档的根元素</p> 
<p>1》可以直接在里面设置样式，就相当于给html设置样式</p> 
<pre><code>​      :root {
​        background-color: #ccc;
​        padding: 0 20px;
​      }
</code></pre> 
<p>2》声明全局css变量，要以 “–” 开头，因为:root是根元素，根元素中定义变量就是全局变量啦</p> 
<pre><code>​      :root {
​        --pink-bg-color: pink;
​        --green-color: green;
​      }
</code></pre> 
<p>通过var()函数就可以使用全局css变量了</p> 
<pre><code>      .box {
        background-color: var(--main-bg-color);
        color: var(--green-color);
      }
</code></pre> 
<h5><a id="colorscheme_172"></a>color-scheme</h5> 
<p>配色方案，normal就是浏览器默认配色方案，light白天模式，dark夜间模式，写了两个就是有个按顺序的优先级</p> 
<pre><code>color-scheme: normal;
color-scheme: light;
color-scheme: dark;
color-scheme: light dark;
</code></pre> 
<p><code>color-scheme</code> 的作用范围很有限，包括表单控件、滚动条和 CSS 系统颜色（浏览器内置的颜色）的使用值</p> 
<p>可以搭配css变量等进行主题切换</p> 
<h5><a id="_187"></a>实现</h5> 
<p>思路：依然是提前将样式文件载入，切换时将指定的根元素类名更换。不过这里相对灵活的是，默认在根作用域下定义好CSS变量，只需要在不同的主题下更改CSS变量对应的取值即可</p> 
<p>具体实现：</p> 
<p>引入主题样式文件：theme.css</p> 
<pre><code>:root {
  --bg-color: #eee;
  --font-color: #333;
}
.red {
  --bg-color: #a61840;
  --font-color: #fbddc2;
}
.green {
  --bg-color: #efa5a9;
  --font-color: #ede1bc;
}
.blue {
  --bg-color: #4e3bb1;
  --font-color: #dfb9c8;
}
</code></pre> 
<p>通过var()给盒子设置颜色</p> 
<pre><code>.colorful-wrapper {
  background-color: var(--bg-color);
  color: var(--font-color);
  border-color: var(--border-color);
}
html.red {
  color-scheme: red;
}
html.green {
  color-scheme: green;
}
html.blue {
  color-scheme: blue;
}
</code></pre> 
<p>切换主题时：给根元素添加对应的类名</p> 
<pre><code>      document.documentElement.className = color
</code></pre> 
<h5><a id="_239"></a>优缺点</h5> 
<p>优点：</p> 
<p>不用重新加载样式文件，在样式切换时不会有卡顿</p> 
<p>在需要切换主题的地方利用var()绑定变量即可，不存在优先级问题</p> 
<p>新增或修改主题方便灵活，仅需新增或修改CSS变量即可，在var()绑定样式变量的地方就会自动更换</p> 
<p>缺点：</p> 
<p>首屏加载时会牺牲一些时间加载样式资源，除了IE的兼容优点问题基本上可以不用考虑兼容问题</p> 
<h4><a id="CSSsetProperty_253"></a>CSS变量+动态setProperty</h4> 
<h5><a id="setProperty_255"></a><strong>setProperty</strong></h5> 
<p>语法：</p> 
<pre><code>style.setProperty(propertyName, value, priority)
</code></pre> 
<p>propertyName:属性名</p> 
<p>value:属性值，可选参数；如果没有指定，则当作空字符串；不能直接在value后加 !import, 设置important需要使用priority来设置</p> 
<p>priority:优先级，可选参数，允许设置"important" 优先级</p> 
<p>返回值为undefined</p> 
<h5><a id="_271"></a>实现</h5> 
<p>通过：root定义全局css变量，给对应盒子设置颜色时通过var()函数将css变量值设置给对应属性</p> 
<pre><code>&lt;style&gt;
:root {
  --bg-color: #f5f5f5;
  --font-color: #333;
  --border-color: #ccc;
}
.colorful-box {
  background-color: var(--bg-color, #f5f5f5);
  color: var(--font-color, #333);
  border-color: var(--border-color, #ccc);
}
&lt;/style&gt;
</code></pre> 
<p>修改主题：通过setProperty来修改变量的值</p> 
<pre><code>export const changeTheme = function (theme, ele = document.documentElement) {
  for (let [key, value] of Object.entries(themes[theme])) {
    ele.style.setProperty(key, value)
  }
}

export const themes = {
  red: {
    '--bg-color': '#a61840',
    '--font-color': '#fbddc2',
  },
  green: {
    '--bg-color': '#efa5a9',
    '--font-color': '#ede1bc',
  },
  blue: {
    '--bg-color': '#4e3bb1',
    '--font-color': '#dfb9c8',
  },
}
</code></pre> 
<h5><a id="_315"></a>优缺点</h5> 
<p>1》优点:</p> 
<p>不用重新加载样式文件，在样式切换时不会有卡顿</p> 
<p>新增或修改主题方便灵活</p> 
<p>2》缺点：</p> 
<p>IE的兼容其他基本浏览器基本不用太考虑</p> 
<h4><a id="SASSmixin_327"></a>SASS的mixin混入+类名切换</h4> 
<p>theme.scss</p> 
<pre><code>// 白色主题
$bg-color-light: #fff;
$font-color-light: #333;
$border-color-light: #999;
$bg-image-light: url("src/images/light.png");

// 黑色主题
$bg-color-dark: #999;
$font-color-dark: #fff;
$border-color-dark: #000;
$bg-image-dark: url(src/images/dark.png");
</code></pre> 
<p>mixin.scss</p> 
<pre><code>@import "./theme.scss";
@mixin bg_image($img) {
  background-image: $img;
  [data-theme="dark"] &amp; {
    background-image: $bg-image-dark;
  }
  [data-theme="light"] &amp; {
    background-image: $bg-image-light;
  }
}

@mixin font_color($color) {
  color: $color;
  [data-theme="dark"] &amp; {
    color: $font-color-dark;
  }

  [data-theme="light"] &amp; {
    color: $font-color-light;
  }
}

@mixin border_color($color) {
  border-color: $color;
  [data-theme="dark"] &amp; {
    border-color: $border-color-dark;
  }
  [data-theme="light"] &amp; {
    border-color: $border-color-light;
  }
}

@mixin bg_color($color) {
  background-color: $color;
  [data-theme="dark"] &amp; {
    background-color: $bg-color-dark;
  }
  [data-theme="light"] &amp; {
    background-color: $bg-color-light;
  }
}
</code></pre> 
<p>vue文件中使用</p> 
<pre><code>&lt;template&gt;
  &lt;div class="wrapper"&gt;
    &lt;div&gt;
      &lt;button @click="setTheme('light')"&gt;白天模式&lt;/button&gt;
      &lt;button @click="setTheme('dark')"&gt;深夜模式&lt;/button&gt;
    &lt;/div&gt;
    &lt;div class="content"&gt;文字text&lt;/div&gt;
    &lt;div class="img"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  methods: {
    setTheme(theme) {
      document.documentElement.setAttribute("data-theme", theme);
    },
  },
};
&lt;/script&gt;
&lt;style lang="scss" scoped&gt;
@import "../assets/scss/mixin.scss";
.wrapper {
  @include bg_color($bg-color-dark);
  @include font_color($bg-color-dark);
}
.img {
  width: 800px;
  height: 400px;
  border: 1px solid red;
  @include bg_image($bg-image-dark);

}
&lt;/style&gt;
</code></pre> 
<h5><a id="_431"></a>优缺点：</h5> 
<p>优点：</p> 
<p>灵活</p> 
<p>兼容性好</p> 
<p>缺点：</p> 
<p>vue3才支持</p> 
<p>在组件上绑定了动态样式的地方都会有对应的编译成哈希化的CSS变量，而不像方案3统一地就在:root上设置（不确定在达到一定量级以后的性能）</p> 
<h4><a id="Vue3_445"></a>Vue3</h4> 
<h5><a id="_447"></a>基本使用</h5> 
<p>v-bind可以绑定data中的变量</p> 
<p>原理其实就是给元素绑定CSS变量，在绑定的数据更新时调用 CSSStyleDeclaration.setProperty 更新CSS变量值</p> 
<pre><code>const theme = {
  color: "red",
};


.box {
  color: v-bind("theme.color");
}
</code></pre> 
<h5><a id="_464"></a>优缺点：</h5> 
<p>优点：</p> 
<p>灵活，易用，切花不需要重新加载样式文件</p> 
<p>缺点：</p> 
<p>vue3才支持</p> 
<p>在组件上绑定了动态样式的地方都会有对应的编译成哈希化的CSS变量，而不像方案3统一地就在:root上设置（不确定在达到一定量级以后的性能）</p> 
<p>如果主题样式不确定，用户可自定义，使用 CSS变量+动态setProperty 最合适</p> 
<p>如果主题固定使用选择更广，大部分都是选择 CSS变量+类名切换 这种方案</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2a1fbefde91d84a1078ee243d702d8ca/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">node_fs模块常用API</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/218b767656d8c0f57f81c918b4a644b5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Lostash同步Mysql数据到Elasticsearch（四）通过kibana辅助查看同步情况</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>