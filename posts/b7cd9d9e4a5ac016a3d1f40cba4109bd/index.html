<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>A Fast Learning Algorithm for Deep Belief Nets - 论文学习 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="A Fast Learning Algorithm for Deep Belief Nets - 论文学习" />
<meta property="og:description" content="文章目录 摘要介绍互补先验一个带约束权的无限有向模型 限制玻尔兹曼机和对比散度学习一种转换表示的贪婪学习算法Some Ideas Based on DBNNonlinear Dimensionality Reduction Learning Semantic Address Space (SAS) for Fast Document RetrievalLearning Nonlinear Embeddings参考文献 摘要 explaining away现象的存在使得稠密连接、拥有多个隐藏层的深度信念网络的训练变的困难，我们提出了使用互补先验来解决这一问题。使用互补先验，我们推导出一种快速、贪婪的算法，可以每次学习深层的有向信念网络中的一层，该网络的最上面两层形成了一个无向联想记忆。该算法用于初始化一个比较慢的学习算法，使用Wake-Sleep算法进行调整网络参数。一个经过调整的三层神经网络可以对手写数字识别数据进行很好的建模。
介绍 在稠密连接的多层有向信念网络中很难根据给定的输入向量推断隐藏单元的条件分布，因此其学习是十分困难的。变分学习方法可以对其真实的分布进行简单的近似，但是这种近似效果可能很差。而且，变分学习需要同时学习所有的参数，所以当网络参数规模增长的时候，这种学习方法的扩展性很差。
我们描述了一个网络模型，它的最上面两层形成了一个无向联想记忆模块，剩下的隐藏层形成了有向无环图，用于把抽象表达转化成可观察到的变量，比如图片像素。这个混合模型有以下特点：
存在一个快速、贪婪的算法可以快速的找到一组合适的参数，即使网络拥有上百万的参数并且含有多个隐藏层；虽然学习算法是无监督的，但是可以通过学习一个同时生成数据和标签的模型来给数据打标签；存在一个微调算法可以学习得到一个生成模型，使其在MINST数据集上的表现优于判别模型；这个生成模型可以很容易的解释隐藏层中的分布表示；学习算法是局部的； 第二部分介绍了互补先验的概念，以及它如何去除了explaining away的影响，并举了一个例子。第三部分解释了为什么限制玻尔兹曼机和有约束权的无限有向网络是等价的。
第四部分介绍了一个快速的、贪婪的学习算法，一层一层的构造多层有向网络。使用变分约束展示了每当加入一个新的层，整个生成模型的效果都会提升。
第五部分展示了这个算法是如何调整权重的，这是Wake-Sleep算法的对比版本，并且不受模式平均问题的影响，使得该算法能够学习到更好的重构权重。
第六部分展示了使用该算法训练的一个三层模型在Minst数据及上的表现。
第七部分展示了当使用该模型生成数据的时候，内部神经元到底是怎么变化的。
互补先验 explaining away现象的存在是的有向信念网络的推断边的困难，在稠密连接的网络中，隐变量的后验分布是难以处理的，只有少数特殊情况例外，如混合模型或线性模型加上高斯噪声。MCMC系列的采样方法可以从这种后验分布中采样，但是非常耗时。变分方法(Neal &amp; Hinton, 1998)用更易于处理的分布近似真实后验，可以提高训练数据对数概率的下限。
complementary prior就是在第一层hidden unit上再加一层或多层Sigmoid，并且拥有和visible到hidden相反作用的weight。目的是为了抵消explaining away现象，该现象使得p(h|v)对于不同的hi不可分解。具体的原理请参照Learning Deep Architecture for AI里的数学式。写出p(h|v)之后你会发现它依赖于likelihood而这个的式子无法分解，于是这里我们假设式子里有一个先验分布，使得其乘上似然之后得到的p(h|v)能够被分解为p(hi|v)的乘积。这个先验就是complementary prior。对于一个单层SBN，其补完先验就是无数多层的SBN，且相互之间互绑weight，至于为什么是这个请看数学式。这个模型也等同于一层的RBM。
Sigmoid信念网络是一种简单的由随机二值神经元组成的网络，当其被用于生成数据时，单元i的条件概率分布如下：
p ( s i = 1 ) = 1 1 &#43; e x p ( − b i − ∑ j s j w i j ) p(s_i=1)=\frac{1}{1&#43;exp(-b_i- \sum_js_jw_{ij})} p(si​=1)=1&#43;exp(−bi​−∑j​sj​wij​)1​" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b7cd9d9e4a5ac016a3d1f40cba4109bd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-17T09:48:01+08:00" />
<meta property="article:modified_time" content="2019-04-17T09:48:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">A Fast Learning Algorithm for Deep Belief Nets - 论文学习</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_3" rel="nofollow">摘要</a></li><li><a href="#_7" rel="nofollow">介绍</a></li><li><a href="#_29" rel="nofollow">互补先验</a></li><li><ul><li><a href="#_43" rel="nofollow">一个带约束权的无限有向模型</a></li></ul> 
   </li><li><a href="#_47" rel="nofollow">限制玻尔兹曼机和对比散度学习</a></li><li><a href="#_57" rel="nofollow">一种转换表示的贪婪学习算法</a></li><li><a href="#Some_Ideas_Based_on_DBN_67" rel="nofollow">Some Ideas Based on DBN</a></li><li><ul><li><a href="#Nonlinear_Dimensionality_Reduction_69" rel="nofollow">Nonlinear Dimensionality Reduction</a></li></ul> 
   </li><li><a href="#Learning_Semantic_Address_Space_SAS_for_Fast_Document_Retrieval_77" rel="nofollow">Learning Semantic Address Space (SAS) for Fast Document Retrieval</a></li><li><a href="#Learning_Nonlinear_Embeddings_83" rel="nofollow">Learning Nonlinear Embeddings</a></li><li><a href="#_87" rel="nofollow">参考文献</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_3"></a>摘要</h3> 
<p>explaining away现象的存在使得稠密连接、拥有多个隐藏层的深度信念网络的训练变的困难，我们提出了使用互补先验来解决这一问题。使用互补先验，我们推导出一种快速、贪婪的算法，可以每次学习深层的有向信念网络中的一层，该网络的最上面两层形成了一个无向联想记忆。该算法用于初始化一个比较慢的学习算法，使用Wake-Sleep算法进行调整网络参数。一个经过调整的三层神经网络可以对手写数字识别数据进行很好的建模。</p> 
<h3><a id="_7"></a>介绍</h3> 
<p>在稠密连接的多层有向信念网络中很难根据给定的输入向量推断隐藏单元的条件分布，因此其学习是十分困难的。变分学习方法可以对其真实的分布进行简单的近似，但是这种近似效果可能很差。而且，变分学习需要同时学习所有的参数，所以当网络参数规模增长的时候，这种学习方法的扩展性很差。</p> 
<p>我们描述了一个网络模型，它的最上面两层形成了一个无向联想记忆模块，剩下的隐藏层形成了有向无环图，用于把抽象表达转化成可观察到的变量，比如图片像素。这个混合模型有以下特点：</p> 
<ol><li>存在一个快速、贪婪的算法可以快速的找到一组合适的参数，即使网络拥有上百万的参数并且含有多个隐藏层；</li><li>虽然学习算法是无监督的，但是可以通过学习一个同时生成数据和标签的模型来给数据打标签；</li><li>存在一个微调算法可以学习得到一个生成模型，使其在MINST数据集上的表现优于判别模型；</li><li>这个生成模型可以很容易的解释隐藏层中的分布表示；</li><li>学习算法是局部的；</li></ol> 
<p>第二部分介绍了互补先验的概念，以及它如何去除了explaining away的影响，并举了一个例子。第三部分解释了为什么限制玻尔兹曼机和有约束权的无限有向网络是等价的。</p> 
<p>第四部分介绍了一个快速的、贪婪的学习算法，一层一层的构造多层有向网络。使用变分约束展示了每当加入一个新的层，整个生成模型的效果都会提升。</p> 
<p>第五部分展示了这个算法是如何调整权重的，这是Wake-Sleep算法的对比版本，并且不受模式平均问题的影响，使得该算法能够学习到更好的重构权重。</p> 
<p>第六部分展示了使用该算法训练的一个三层模型在Minst数据及上的表现。</p> 
<p>第七部分展示了当使用该模型生成数据的时候，内部神经元到底是怎么变化的。</p> 
<h3><a id="_29"></a>互补先验</h3> 
<p>explaining away现象的存在是的有向信念网络的推断边的困难，在稠密连接的网络中，隐变量的后验分布是难以处理的，只有少数特殊情况例外，如混合模型或线性模型加上高斯噪声。MCMC系列的采样方法可以从这种后验分布中采样，但是非常耗时。变分方法(Neal &amp; Hinton, 1998)用更易于处理的分布近似真实后验，可以提高训练数据对数概率的下限。</p> 
<p>complementary prior就是在第一层hidden unit上再加一层或多层Sigmoid，并且拥有和visible到hidden相反作用的weight。目的是为了抵消explaining away现象，该现象使得p(h|v)对于不同的hi不可分解。具体的原理请参照Learning Deep Architecture for AI里的数学式。写出p(h|v)之后你会发现它依赖于likelihood而这个的式子无法分解，于是这里我们假设式子里有一个先验分布，使得其乘上似然之后得到的p(h|v)能够被分解为p(hi|v)的乘积。这个先验就是complementary prior。对于一个单层SBN，其补完先验就是无数多层的SBN，且相互之间互绑weight，至于为什么是这个请看数学式。这个模型也等同于一层的RBM。</p> 
<p>Sigmoid信念网络是一种简单的由随机二值神经元组成的网络，当其被用于生成数据时，单元i的条件概率分布如下：</p> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          p 
         
        
          ( 
         
         
         
           s 
          
         
           i 
          
         
        
          = 
         
        
          1 
         
        
          ) 
         
        
          = 
         
         
         
           1 
          
          
          
            1 
           
          
            + 
           
          
            e 
           
          
            x 
           
          
            p 
           
          
            ( 
           
          
            − 
           
           
           
             b 
            
           
             i 
            
           
          
            − 
           
           
           
             ∑ 
            
           
             j 
            
           
           
           
             s 
            
           
             j 
            
           
           
           
             w 
            
            
            
              i 
             
            
              j 
             
            
           
          
            ) 
           
          
         
        
       
         p(s_i=1)=\frac{1}{1+exp(-b_i- \sum_js_jw_{ij})} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.44326em; vertical-align: -1.12182em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.32144em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord mathit">e</span><span class="mord mathit">x</span><span class="mord mathit">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position: relative; top: -5e-06em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.161954em;"><span class="" style="top: -2.40029em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.435818em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathit">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathit" style="margin-right: 0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.02691em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.12182em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p> 
<p>其中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          b 
         
        
          i 
         
        
       
      
        b_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>是单元i的偏置，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          w 
         
         
         
           i 
          
         
           j 
          
         
        
       
      
        w_{ij} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.716668em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathit" style="margin-right: 0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.02691em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span></span></span></span></span>是单元i和单元j的连接权重。如果一个logistic信念网络只有一个隐藏层，那么其概率分布是所有隐藏单元的连乘。后验分布的不独立性是由来自数据中的似然项决定的。也许我们可以通过使用额外的隐藏层来创建一个“互补”的先验，从而消除在第一个隐藏层中的explaining away现象，这个“互补”的先验与那些在似然项中的先验具有完全相反的相关性。然后我们就可以获得互相独立的隐藏单元。但是我们并不清楚这个互补的先验是否存在，图三展示了一个无限的逻辑信念网络，它的权值是有限的，其中先验在每一个隐层都是互补的。使用tied weights来构造互补的优先级，这看起来像是一个使有向模型等价于无向模型的简单技巧。但是，正如我们将看到的，它导致了一种新颖且非常有效的学习算法，该算法通过逐步地将每一层的权重从更高层的权重中分离出来来工作。</p> 
<p><img src="https://images2.imgbox.com/ce/36/Zv30zaOr_o.jpg" alt="infinite logistic belief net with tied weights"></p> 
<h4><a id="_43"></a>一个带约束权的无限有向模型</h4> 
<p>在图3的无限有向网络中，我们可以通过随机初始化一个初始状态，从上到下的按照伯努利分布对单元进行激活，从而生成数据。从这一点看，它和其他的有向无环网络似乎没有什么不同，然而，与其他有向网络不同，我们可以从所有隐层的真实后验分布中取样，方法是先从可见单元上的数据向量开始，然后使用转置的权重矩阵依次推断每个隐层上的阶乘分布。在每一个隐层，我们在计算上一层的后验阶乘之前，先从后验阶乘中取样。</p> 
<h3><a id="_47"></a>限制玻尔兹曼机和对比散度学习</h3> 
<p>RBM是一个无向二部图模型，等价于一个具有约束权的无限深逻辑信念网络。RBM通过从随机状态开始并执行交替吉布斯采样，直到平衡。理论上，这需要无限次才能达到平衡。这等价于通过一个无限深的有向网络进行传播。换句话说，我们在空间展开吉布斯采样步骤。如下图所示。</p> 
<p><img src="https://images2.imgbox.com/64/7a/a4PhGDa2_o.jpg" alt="RBMs"></p> 
<p>由于受限玻尔兹曼机的特殊结构，因此可以使用一种比吉布斯采样更有效的学习算法，即对比散度（Contrastive Divergence）[Hinton, 2002]。对比散度法仅需k 步吉布斯采样。</p> 
<p><img src="https://images2.imgbox.com/cf/c4/twdw2E5z_o.png" alt="CD"></p> 
<h3><a id="_57"></a>一种转换表示的贪婪学习算法</h3> 
<p>网络的最底层为可观测变量，其它层节点都为隐变量。最顶部的两层间的连接是无向的，其他层之间的连接是有向的。下面给出了一个深度信念网络的示例。</p> 
<h3><a id="Some_Ideas_Based_on_DBN_67"></a>Some Ideas Based on DBN</h3> 
<h4><a id="Nonlinear_Dimensionality_Reduction_69"></a>Nonlinear Dimensionality Reduction</h4> 
<p>The DBN framework allows us to make nonlinear autoencoders work considerably better than widely used methods such as PCA, SVD, and LLE.</p> 
<p>The standard way to train autoencoders is to use backpropagation to reduce the reconstruction error. It is difficult, however, to optimize the weights in non-linear autoencoders that have multiple hidden layers with many million parameters. So we can use our learning algorithm to pretrain autoencoders, which can discovers useful features efficiently.</p> 
<p>The key idea is that the greedy learning algorithm will perform a good search for a good, sensible region in the parameter space. After that pretrain, we will already have a data reconstruction model. Backpropagation is better at local fine-tuning of model parameters than global search, so further train of the entire autoencoder model using backpropgation will result in a good local optimum.</p> 
<h3><a id="Learning_Semantic_Address_Space_SAS_for_Fast_Document_Retrieval_77"></a>Learning Semantic Address Space (SAS) for Fast Document Retrieval</h3> 
<p>Most of the existing text retrieval algorithms in one way or another rely on comparing a given query document to all other documents from the large document collection, retrieving the most relevant ones. So the larger the word vocabulary and the size of data collection, the longer it takes to retrieval relevant documents.</p> 
<p>The DBN framework allow us to build a model that can learn to map document into “semantic” binary code. By using learned binary code as memory address, we can learn “Semantic Address Space”. So a document can be mapped to a memory address in such a way that the documents with similar address have similar semantics. This method allows to retrieval short-list of semantically similar documents on very large document sets in time independent of the number of documents.</p> 
<h3><a id="Learning_Nonlinear_Embeddings_83"></a>Learning Nonlinear Embeddings</h3> 
<p>The DBN framework can also be used to efficiently learn a nonlinear transformation from the input space to a low-dimensional feature space, in which K-NN can perform well.</p> 
<h3><a id="_87"></a>参考文献</h3> 
<p><a href="https://blog.csdn.net/u010545732/article/details/19760497">关于DBN(深度信念网)的几点思考</a></p> 
<p><a href="http://deeplearning.net/tutorial/DBN.html#dbn" rel="nofollow">Deep Belief Networks</a></p> 
<p><a href="https://blog.csdn.net/m0_37924639/article/details/79070024">A Fast Learning Algorithm for Deep Belief Nets</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/00f35a63e49af0c699e60c53d5cf7bb3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言：求e的值。 e=1&#43;1/1! &#43;1/2! &#43;1/3! ...&#43;1/n!（for循环）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d36e58699b5d4ddf31ef681fe702c0c9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【转】SLAM 论文阅读和分类整理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>