<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GDAL源码剖析（十一）之OGR投影说明 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GDAL源码剖析（十一）之OGR投影说明" />
<meta property="og:description" content="一、简介 本文参考英文地址：http://www.gdal.org/ogr/osr_tutorial.html。
OGRSpatialReference类和OGRCoordinateTransformation类主要用来提供定义坐标系统（投影和水准面）和转换坐标。这两个类都基于OpenGIS的坐标转换说明，并且使用Well Known Text格式来进行表述坐标系统。
一些关于OpenGIS坐标系统的资料，以及空间参考坐标抽象模型文件可以在OGC（Open Geospatial Consortium）的网站上找到。GeoTIFF投影转换列表（GeoTIFF Projections Transform List）网页可以更好的帮助你理解WKT的规则，同时EPSG的网站也是很有用的资料。
二、定义地理坐标系统 坐标系统使用OGRSpatialReference类来进行封装。这里提供了数种初始化OGRSpatialReference类的方式。这里有两类主要的坐标系统，第一种是地理坐标系统（位置信息使用经纬度来表示的），第二种是投影坐标系统（比如UTM-通用横轴墨卡托投影，位置信息使用米或者英尺来表示）。
一个地理坐标系统包含的信息有一个大地基准（里面含有一个使用长半轴和扁率的倒数来表示的托球体），一个中央经线（通常是本初子午线，也就是0度经线Greenwich）, 此外还有一个角度的度量单位，使用度而不是弧度。如果含有这些信息，就可以构造一个有效的地理坐标系统。
OGRSpatialReference oSRS; oSRS.SetGeogCS( &#34;Mygeographic coordinate system&#34;, &#34;WGS_1984&#34;, &#34;My WGS84 Spheroid&#34;, SRS_WGS84_SEMIMAJOR, SRS_WGS84_INVFLATTENING, &#34;Greenwich&#34;, 0.0, &#34;degree&#34;, SRS_UA_DEGREE_CONV ); 在上面的代码中，名称为“My geographic coordinate system”，“My WGS84 Spheroid”，“Greenwich”和“degree”的并不是关键词，这些主要是用来给用户进行说明的。然而，“WGS_1984”是一个定义大地基准的关键词，注意：这里的大地基准必须是一个有效的大地基准！（这句话的意思，前面的那些字符串就是随便指定的，用来显示的，后面的WGS_1984这个位置的字符串，必须是一个有效的，不能随便命名，具体后面会说到）。
OGRSpatialReference可以使用一些常用的字符串来进行建立一个常用的坐标系统，这些字符串包括“NAD27”、“NAD83”，“WGS72”和“WGS84”等，使用的函数是SetWellKnownGeogCS()，使用方式见下面。
oSRS.SetWellKnownGeogCS( &#34;WGS84&#34; ); 而且，还可以使用EPSG数据库定义的GCS代码来定义一个地理坐标系统，如：
oSRS.SetWellKnownGeogCS( &#34;EPSG:4326&#34; ); 为了方便的和其他库进行关联，这里可以转换为OpenGIS的WKT格式。同样OGRSpatialReference可以使用一个WKT来进行初始化，或者将里面的信息导出为WKT格式。
char *pszWKT =NULL; SRS.SetWellKnownGeogCS( &#34;WGS84&#34; ); oSRS.exportToWkt( &amp;pszWKT ); printf( &#34;%s\n&#34;, pszWKT ); 上面的语句会输出下面的内容：
GEOGCS[&#34;WGS84&#34;,DATUM[&#34;WGS_1984&#34;,SPHEROID[&#34;WGS84&#34;,6378137,298.257223563,AUTHORITY[&#34;EPSG&#34;,7030]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[&#34;EPSG&#34;,6326]],PRIMEM[&#34;Greenwich&#34;,0,AUTHORITY[&#34;EPSG&#34;,8901]],UNIT[&#34;DMSH&#34;,0.0174532925199433,AUTHORITY[&#34;EPSG&#34;,9108]],AXIS[&#34;Lat&#34;,NORTH],AXIS[&#34;Long&#34;,EAST],AUTHORITY[&#34;EPSG&#34;,4326]] 将上面的字符串格式调整成更好看的样子：
GEOGCS[&#34;WGS 84&#34;, DATUM[&#34;WGS_1984&#34;, SPHEROID[&#34;WGS 84&#34;,6378137,298.257223563, AUTHORITY[&#34;EPSG&#34;,7030]], TOWGS84[0,0,0,0,0,0,0], AUTHORITY[&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/948324b9418324a593d39b5466f7071c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-05-24T21:40:00+08:00" />
<meta property="article:modified_time" content="2012-05-24T21:40:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GDAL源码剖析（十一）之OGR投影说明</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <h3><span style="color:#000099;">一、简介</span></h3> 
 <p><span style="font-size:16px;color:#000099;">本文参考英文地址：<a href="http://www.gdal.org/ogr/osr_tutorial.html" rel="nofollow">http://www.gdal.org/ogr/osr_tutorial.html</a>。</span></p> 
 <p><span style="font-size:16px;color:#000099;"><a href="http://liml/gdal/gdal-web_1.9.0/ogr/classOGRSpatialReference.html" rel="nofollow"><strong>OGRSpatialReference</strong></a>类和<a href="http://liml/gdal/gdal-web_1.9.0/ogr/classOGRCoordinateTransformation.html" rel="nofollow"><strong>OGRCoordinateTransformation</strong></a>类主要用来提供定义坐标系统（投影和水准面）和转换坐标。这两个类都基于OpenGIS的坐标转换说明，并且使用Well Known Text格式来进行表述坐标系统。</span></p> 
 <p style="background:#FFFFFF;"><span style="font-size:16px;color:#000099;">一些关于OpenGIS坐标系统的资料，以及空间参考坐标抽象模型文件可以在OGC（<a href="http://www.opengeospatial.org/" rel="nofollow">Open Geospatial Consortium</a>）的网站上找到。GeoTIFF投影转换列表（<a href="http://www.remotesensing.org/geotiff/proj_list" rel="nofollow">GeoTIFF Projections Transform List</a>）网页可以更好的帮助你理解WKT的规则，同时<a href="http://www.epsg.org/" rel="nofollow">EPSG</a>的网站也是很有用的资料。</span></p> 
 <h3><span style="color:#000099;">二、定义地理坐标系统</span></h3> 
 <p><span style="font-size:16px;color:#000099;">坐标系统使用<a href="http://liml/gdal/gdal-web_1.9.0/ogr/classOGRSpatialReference.html" rel="nofollow"><strong>OGRSpatialReference</strong></a>类来进行封装。这里提供了数种初始化<a href="http://liml/gdal/gdal-web_1.9.0/ogr/classOGRSpatialReference.html" rel="nofollow"><strong>OGRSpatialReference</strong></a>类的方式。这里有两类主要的坐标系统，第一种是地理坐标系统（位置信息使用经纬度来表示的），第二种是投影坐标系统（比如UTM-通用横轴墨卡托投影，位置信息使用米或者英尺来表示）。</span></p> 
 <p><span style="font-size:16px;color:#000099;">一个地理坐标系统包含的信息有一个大地基准（里面含有一个使用长半轴和扁率的倒数来表示的托球体），一个中央经线（通常是本初子午线，也就是0度经线Greenwich）, 此外还有一个角度的度量单位，使用度而不是弧度。如果含有这些信息，就可以构造一个有效的地理坐标系统。</span></p> 
 <p align="left"></p> 
 <pre><code class="language-cpp">OGRSpatialReference oSRS;
oSRS.SetGeogCS( "Mygeographic coordinate system",
               "WGS_1984",
               "My WGS84 Spheroid",
               SRS_WGS84_SEMIMAJOR, SRS_WGS84_INVFLATTENING,
               "Greenwich", 0.0,
                "degree", SRS_UA_DEGREE_CONV );</code></pre> 
 <p><span style="font-size:16px;color:#000099;">在上面的代码中，名称为“My geographic coordinate system”，“My WGS84 Spheroid”，“Greenwich”和“degree”的并不是关键词，这些主要是用来给用户进行说明的。然而，“WGS_1984”是一个定义大地基准的关键词，注意：这里的大地基准必须是一个有效的大地基准！（这句话的意思，前面的那些字符串就是随便指定的，用来显示的，后面的WGS_1984这个位置的字符串，必须是一个有效的，不能随便命名，具体后面会说到）。</span></p> 
 <p><span style="font-size:16px;color:#000099;"><a href="http://liml/gdal/gdal-web_1.9.0/ogr/classOGRSpatialReference.html" rel="nofollow"><strong>OGRSpatialReference</strong></a>可以使用一些常用的字符串来进行建立一个常用的坐标系统，这些字符串包括“NAD27”、“NAD83”，“WGS72”和“WGS84”等，使用的函数是SetWellKnownGeogCS()，使用方式见下面。</span></p> 
 <p align="left"></p> 
 <pre><code class="language-cpp">oSRS.SetWellKnownGeogCS( "WGS84" );</code></pre> 
 <p><span style="font-size:16px;color:#000099;">而且，还可以使用EPSG数据库定义的GCS代码来定义一个地理坐标系统，如：</span></p> 
 <p align="left"></p> 
 <pre><code class="language-cpp">oSRS.SetWellKnownGeogCS( "EPSG:4326" );</code></pre> 
 <p><span style="font-size:16px;color:#000099;">为了方便的和其他库进行关联，这里可以转换为OpenGIS的WKT格式。同样<a href="http://liml/gdal/gdal-web_1.9.0/ogr/classOGRSpatialReference.html" rel="nofollow"><strong>OGRSpatialReference</strong></a>可以使用一个WKT来进行初始化，或者将里面的信息导出为WKT格式。</span></p> 
 <p align="left"></p> 
 <pre><code class="language-cpp">char    *pszWKT =NULL;
SRS.SetWellKnownGeogCS( "WGS84" );
oSRS.exportToWkt( &amp;pszWKT );
printf( "%s\n", pszWKT );</code></pre> 
 <p><span style="font-size:16px;color:#000099;">上面的语句会输出下面的内容：</span></p> 
 <p align="left"></p> 
 <pre><code class="language-plain">GEOGCS["WGS84",DATUM["WGS_1984",SPHEROID["WGS84",6378137,298.257223563,AUTHORITY["EPSG",7030]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY["EPSG",6326]],PRIMEM["Greenwich",0,AUTHORITY["EPSG",8901]],UNIT["DMSH",0.0174532925199433,AUTHORITY["EPSG",9108]],AXIS["Lat",NORTH],AXIS["Long",EAST],AUTHORITY["EPSG",4326]]</code></pre> 
 <p><span style="font-size:16px;color:#000099;">将上面的字符串格式调整成更好看的样子：</span></p> 
 <p align="left"></p> 
 <pre><code class="language-plain">GEOGCS["WGS 84",
   DATUM["WGS_1984",
       SPHEROID["WGS 84",6378137,298.257223563,
           AUTHORITY["EPSG",7030]],
       TOWGS84[0,0,0,0,0,0,0],
       AUTHORITY["EPSG",6326]],
    PRIMEM["Greenwich",0,AUTHORITY["EPSG",8901]],
   UNIT["DMSH",0.0174532925199433,AUTHORITY["EPSG",9108]],
   AXIS["Lat",NORTH],
   AXIS["Long",EAST],
   AUTHORITY["EPSG",4326]]</code></pre> 
 <p><span style="font-size:16px;color:#000099;">函数<a href="http://liml/gdal/gdal-web_1.9.0/ogr/classOGRSpatialReference.html#b74cfc985bd05404a4c61d2d633a6343" rel="nofollow" title="Import from WKT string."><strong>OGRSpatialReference::importFromWkt()</strong></a>可以从一个WKT定义的坐标系统来构造一个<a href="http://liml/gdal/gdal-web_1.9.0/ogr/classOGRSpatialReference.html" rel="nofollow"><strong>OGRSpatialReference</strong></a>类对象。</span></p> 
 <h3><span style="color:#000099;">三、定义投影坐标系统</span></h3> 
 <p><span style="font-size:16px;color:#000099;">一个投影坐标系统（比如UTM，兰伯特等角圆锥投影等）需要建立在一个地理坐标系统之上，在投影坐标系统中，坐标点使用米或者英尺等长度单位来表示，同时也可以用经纬度的角度坐标来表示。下面将定义一个UTM的第17带的投影坐标系统，基于WGS84的大地基准椭球体。</span></p> 
 <p align="left"></p> 
 <pre><code class="language-cpp">OGRSpatialReference    oSRS;
oSRS.SetProjCS( "UTM 17(WGS84) in northern hemisphere." );
oSRS.SetWellKnownGeogCS("WGS84" );
oSRS.SetUTM( 17, TRUE );</code></pre> 
 <p><span style="font-size:16px;color:#000099;">首先调用SetProjCS()函数设置投影坐标系统的名称，然后使用函数SetWellKnownGeogCS()指定地理坐标系统，最后调用函数SetUTM()设置投影转换参数信息。完成这些工作之后就定义了一个有效的投影坐标系统。<strong>这里必须要注意定义OGRSpatialReference的顺序！</strong></span></p> 
 <p><span style="font-size:16px;color:#000099;">上面定义的投影使用WKT表示的形式如下，注意UTM17会使用横轴墨卡托的分带投影参数来表示。</span></p> 
 <p align="left"></p> 
 <pre><code class="language-plain">PROJCS["UTM 17 (WGS84) in northernhemisphere.",
   GEOGCS["WGS 84",
       DATUM["WGS_1984",
           SPHEROID["WGS 84",6378137,298.257223563,
               AUTHORITY["EPSG",7030]],
           TOWGS84[0,0,0,0,0,0,0],
           AUTHORITY["EPSG",6326]],
        PRIMEM["Greenwich",0,AUTHORITY["EPSG",8901]],
       UNIT["DMSH",0.0174532925199433,AUTHORITY["EPSG",9108]],
       AXIS["Lat",NORTH],
       AXIS["Long",EAST],
       AUTHORITY["EPSG",4326]],
   PROJECTION["Transverse_Mercator"],
   PARAMETER["latitude_of_origin",0],
   PARAMETER["central_meridian",-81],
   PARAMETER["scale_factor",0.9996],
   PARAMETER["false_easting",500000],
   PARAMETER["false_northing",0]]</code></pre> 
 <p><span style="font-size:16px;color:#000099;">这里提供了很多设置投影坐标的方法，包括SetTM()(横轴墨卡托投影), SetLCC()(兰伯特等角圆锥投影)和SetMercator()。</span></p> 
 <h3><span style="color:#000099;">四、获取坐标系统信息</span></h3> 
 <p><span style="font-size:16px;color:#000099;">一旦一个<a href="http://liml/gdal/gdal-web_1.9.0/ogr/classOGRSpatialReference.html" rel="nofollow"><strong>OGRSpatialReference</strong></a>对象进行创建，那么就可以获取里面的各种信息，比如可以使用<a href="http://liml/gdal/gdal-web_1.9.0/ogr/classOGRSpatialReference.html#1186e3473d7ac2f81ec2ca5d0c4ec027" rel="nofollow" title="Check if projected coordinate system."><strong>OGRSpatialReference::IsProjected()</strong></a>和<a href="http://liml/gdal/gdal-web_1.9.0/ogr/classOGRSpatialReference.html#764ba5d91530ad721d78ac629c0eaba8" rel="nofollow" title="Check if geographic coordinate system."><strong>OGRSpatialReference::IsGeographic()</strong></a>方法来判断坐标系统是地理坐标系统还是投影坐标系统。使用函数<a href="http://liml/gdal/gdal-web_1.9.0/ogr/classOGRSpatialReference.html#e4a85fc76fb96e5d253897d0589aea33" rel="nofollow" title="Get spheroid semi major axis."><strong>OGRSpatialReference::GetSemiMajor()</strong></a>、<a href="http://liml/gdal/gdal-web_1.9.0/ogr/classOGRSpatialReference.html#e004d56063c3dedf18bc3a8c705deacb" rel="nofollow" title="Get spheroid semi minor axis."><strong>OGRSpatialReference::GetSemiMinor()</strong></a>和<a href="http://liml/gdal/gdal-web_1.9.0/ogr/classOGRSpatialReference.html#b8e5f09148eb80ea4c8242d30591ba32" rel="nofollow" title="Get spheroid inverse flattening."><strong>OGRSpatialReference::GetInvFlattening()</strong></a>方法可以用来获取椭球体信息，分别是椭球体的长半轴，短半轴以及扁率的倒数。使用<a href="http://liml/gdal/gdal-web_1.9.0/ogr/classOGRSpatialReference.html#cc815e7bd21c1c052304368c0eefe8be" rel="nofollow" title="Fetch indicated attribute of named node."><strong>OGRSpatialReference::GetAttrValue()</strong></a>方法可以用来获取PROJCS、GEOGCS、DATUM、SPHEROID和PROJECTION的名称字符串。使用<a href="http://liml/gdal/gdal-web_1.9.0/ogr/classOGRSpatialReference.html#603c654bc0616f26c9300b3c66952cdb" rel="nofollow" title="Fetch a projection parameter value."><strong>OGRSpatialReference::GetProjParm()</strong></a>方法可以获取投影参数信息。使用<a href="http://liml/gdal/gdal-web_1.9.0/ogr/classOGRSpatialReference.html#f2821ab555a3bb2d6bb1df49d076a198" rel="nofollow" title="Fetch linear projection units."><strong>OGRSpatialReference::GetLinearUnits()</strong></a>方法可以获取长度单位类型，并将其转换为米。</span></p> 
 <p><span style="font-size:16px;color:#000099;">下面的代码是一个获取坐标系统信息的示例，摘自ogr_srs_proj4.cpp文件中。使用GetAttrValue()获取投影名称，使用GetProjParm()获取投影参数信息。GetAttrValue()函数的第一个值节点就是WKT字符串的描述信息。投影参数的宏定义（比如SRS_PP_CENTRAL_MERIDIAN）和函数GetProjParm()一起使用，可以用来获取投影的参数。更多的使用方式可以参考文件ogrspatialreference.cpp中的相关代码。</span></p> 
 <p align="left"></p> 
 <p align="left"></p> 
 <pre><code class="language-cpp">const char *pszProjection = poSRS-&gt;GetAttrValue("PROJECTION");
if( pszProjection == NULL )
{
    if( poSRS-&gt;IsGeographic() )
        sprintf(szProj4+strlen(szProj4), "+proj=longlat " );
    else
        sprintf(szProj4+strlen(szProj4), "unknown " );
}
else if(EQUAL(pszProjection,SRS_PT_CYLINDRICAL_EQUAL_AREA) )
{
    sprintf(szProj4+strlen(szProj4),
      "+proj=cea +lon_0=%.9f +lat_ts=%.9f +x_0=%.3f +y_0=%.3f ",
           poSRS-&gt;GetProjParm(SRS_PP_CENTRAL_MERIDIAN,0.0),
           poSRS-&gt;GetProjParm(SRS_PP_STANDARD_PARALLEL_1,0.0),
           poSRS-&gt;GetProjParm(SRS_PP_FALSE_EASTING,0.0),
           poSRS-&gt;GetProjParm(SRS_PP_FALSE_NORTHING,0.0));
}
...
const char *pszProjection = poSRS-&gt;GetAttrValue("PROJECTION");
if( pszProjection == NULL )
{
    if( poSRS-&gt;IsGeographic() )
        sprintf(szProj4+strlen(szProj4), "+proj=longlat " );
    else
        sprintf(szProj4+strlen(szProj4), "unknown " );
}
else if(EQUAL(pszProjection,SRS_PT_CYLINDRICAL_EQUAL_AREA) )
{
    sprintf(szProj4+strlen(szProj4),
      "+proj=cea +lon_0=%.9f +lat_ts=%.9f +x_0=%.3f +y_0=%.3f ",
           poSRS-&gt;GetProjParm(SRS_PP_CENTRAL_MERIDIAN,0.0),
           poSRS-&gt;GetProjParm(SRS_PP_STANDARD_PARALLEL_1,0.0),
           poSRS-&gt;GetProjParm(SRS_PP_FALSE_EASTING,0.0),
           poSRS-&gt;GetProjParm(SRS_PP_FALSE_NORTHING,0.0));
}
...</code></pre> 
 <h3><span style="color:#000099;">五、坐标转换</span></h3> 
 <p><span style="font-size:16px;color:#000099;"><a href="http://liml/gdal/gdal-web_1.9.0/ogr/classOGRCoordinateTransformation.html" rel="nofollow"><strong>OGRCoordinateTransformation</strong></a>类可以用来在不同的坐标系统中进行坐标转换。可以使用函数<a href="http://liml/gdal/gdal-web_1.9.0/ogr/ogr__spatialref_8h.html#ae11bd08e45cdb2e71e1d9c31f1e550f" rel="nofollow"><strong>OGRCreateCoordinateTransformation()</strong></a>创建一个新的坐标转换对象，然后使用<a href="http://liml/gdal/gdal-web_1.9.0/ogr/classOGRCoordinateTransformation.html#bf141396940b4f7b1f8118ea025d569b" rel="nofollow"><strong>OGRCoordinateTransformation::Transform()</strong></a>方法来进行坐标转换。</span></p> 
 <p align="left"></p> 
 <pre><code class="language-cpp">OGRSpatialReference oSourceSRS,oTargetSRS;
OGRCoordinateTransformation *poCT;
double                 x, y;
   
oSourceSRS.importFromEPSG(atoi(papszArgv[i+1]) );
oTargetSRS.importFromEPSG(atoi(papszArgv[i+2]) );
   
poCT = OGRCreateCoordinateTransformation(&amp;oSourceSRS,
                                         &amp;oTargetSRS );
x = atof( papszArgv[i+3] );
y = atof( papszArgv[i+4] );
   
if( poCT == NULL || !poCT-&gt;Transform( 1, &amp;x,&amp;y ) )
    printf("Transformation failed.\n" );
else
    printf("(%f,%f) -&gt; (%f,%f)\n",
            atof(papszArgv[i+3] ),
            atof(papszArgv[i+4] ),
            x, y );</code></pre> 
 <p><span style="font-size:16px;color:#000099;">一对点转换失败的原因有，首先，<a href="http://liml/gdal/gdal-web_1.9.0/ogr/ogr__spatialref_8h.html#ae11bd08e45cdb2e71e1d9c31f1e550f" rel="nofollow"><strong>OGRCreateCoordinateTransformation()</strong></a>函数执行失败，通常的原因是不知道指定的两个投影之间的转换关系。这个可能是试用了PROJ.4库不支持的投影，不同的椭球体之间的转换关系没有定义，或者是其中的一个坐标系统没有定义完全。如果函数<a href="http://liml/gdal/gdal-web_1.9.0/ogr/ogr__spatialref_8h.html#ae11bd08e45cdb2e71e1d9c31f1e550f" rel="nofollow"><strong>OGRCreateCoordinateTransformation()</strong></a> 执行失败，那么其返回值将是NULL。</span></p> 
 <p><span style="font-size:16px;color:#000099;"><a href="http://liml/gdal/gdal-web_1.9.0/ogr/classOGRCoordinateTransformation.html#bf141396940b4f7b1f8118ea025d569b" rel="nofollow"><strong>OGRCoordinateTransformation::Transform()</strong></a> 方法本身页可能执行失败。这个可能的原因也有上面的问题，或者是转换的点里面有一个以上没有定义的数字。函数Transform()执行成功是返回TRUE，如果有一个点转换失败都会返回FALSE。</span></p> 
 <p><span style="font-size:16px;color:#000099;">坐标转换也可以支持三维点的坐标转换，会自动根据不同的椭球地的基准面调整高程值。这个可以用来在不同的垂直基准面进行坐标转换。如果没有Z值，系统会认为所有的点都是在水准面上。</span></p> 
 <p><span style="font-size:16px;color:#000099;">下面的例子演示了如果从一个投影坐标系统中的点转换为该投影中的地理坐标系统中的点，将米表示的坐标转换为经纬度表示的坐标。</span></p> 
 <p align="left"></p> 
 <pre><code class="language-cpp">OGRSpatialReference   oUTM, *poLatLong;
OGRCoordinateTransformation *poTransform;
oUTM.SetProjCS("UTM 17 /WGS84");
oUTM.SetWellKnownGeogCS("WGS84" );
oUTM.SetUTM( 17 );
poLatLong = oUTM.CloneGeogCS();
 
poTransform = OGRCreateCoordinateTransformation( &amp;oUTM,poLatLong );
if( poTransform == NULL )
{
    ...
}
 
...
if( !poTransform-&gt;Transform( nPoints, x,y, z ) )
...</code></pre> 
 <h3><span style="color:#000099;">六、其他语言接口</span></h3> 
 <p><span style="font-size:16px;color:#000099;">OGR的空间参考提供了一个C语言的接口，定义在<a href="http://liml/gdal/gdal-web_1.9.0/ogr/ogr__srs__api_8h.html" rel="nofollow">ogr_srs_api.h</a>文件中，Python的接口定义在osr.py文件中。所有的接口名称和C++的接口都很相似，但是C和Python中有些方法没有进行提供。</span></p> 
 <h4><span style="color:#000099;">1、C语言接口</span></h4> 
 <p align="left"></p> 
 <pre><code class="language-cpp">typedef void *OGRSpatialReferenceH;                              
typedef void *OGRCoordinateTransformationH;
OGRSpatialReferenceH OSRNewSpatialReference( const char *);
void   OSRDestroySpatialReference( OGRSpatialReferenceH );
int    OSRReference( OGRSpatialReferenceH );
int    OSRDereference( OGRSpatialReferenceH );
OGRErr OSRImportFromEPSG( OGRSpatialReferenceH, int );
OGRErr OSRImportFromWkt( OGRSpatialReferenceH, char ** );
OGRErr OSRExportToWkt( OGRSpatialReferenceH, char ** );
OGRErr OSRSetAttrValue( OGRSpatialReferenceH hSRS, const char * pszNodePath,
                         const char *pszNewNodeValue );
const char *OSRGetAttrValue( OGRSpatialReferenceH hSRS,
                             const char * pszName, intiChild);
OGRErr OSRSetLinearUnits( OGRSpatialReferenceH, const char *, double );
double OSRGetLinearUnits( OGRSpatialReferenceH, char ** );
int    OSRIsGeographic( OGRSpatialReferenceH );
int    OSRIsProjected( OGRSpatialReferenceH );
int    OSRIsSameGeogCS( OGRSpatialReferenceH, OGRSpatialReferenceH );
int    OSRIsSame( OGRSpatialReferenceH, OGRSpatialReferenceH );
OGRErr OSRSetProjCS( OGRSpatialReferenceH hSRS, const char * pszName );
OGRErr OSRSetWellKnownGeogCS( OGRSpatialReferenceH hSRS,
                               const char * pszName );
OGRErr OSRSetGeogCS( OGRSpatialReferenceH hSRS,
                      const char * pszGeogName,
                      const char *pszDatumName,
                      const char *pszEllipsoidName,
                      double dfSemiMajor,double dfInvFlattening,
                      const char * pszPMName ,
                     double dfPMOffset ,
                      const char * pszUnits,
                      double dfConvertToRadians);
double OSRGetSemiMajor( OGRSpatialReferenceH, OGRErr * );
double OSRGetSemiMinor( OGRSpatialReferenceH, OGRErr * );
double OSRGetInvFlattening( OGRSpatialReferenceH, OGRErr * );
OGRErr OSRSetAuthority( OGRSpatialReferenceH hSRS,
                         const char *pszTargetKey,
                         const char *pszAuthority,
                         int nCode );
OGRErr OSRSetProjParm( OGRSpatialReferenceH, const char *, double );
double OSRGetProjParm( OGRSpatialReferenceH hSRS,
                        const char *pszParmName,
                        double dfDefault,
                        OGRErr * );
OGRErr OSRSetUTM( OGRSpatialReferenceH hSRS, int nZone, int bNorth );
int    OSRGetUTMZone( OGRSpatialReferenceH hSRS, int *pbNorth );
OGRCoordinateTransformationH
OCTNewCoordinateTransformation( OGRSpatialReferenceH hSourceSRS,
                                OGRSpatialReferenceHhTargetSRS );
void OCTDestroyCoordinateTransformation( OGRCoordinateTransformationH );
int OCTTransform(OGRCoordinateTransformationH hCT,
                  int nCount, double *x, double*y, double *z );</code></pre> 
 <h4><span style="color:#000099;">2、Python语言接口</span></h4> 
 <p align="left"></p> 
 <pre><code class="language-python">class osr.SpatialReference
   def __init__(self,obj=None):
   def ImportFromWkt( self, wkt ):
   def ExportToWkt(self):
   def ImportFromEPSG(self,code):
   def IsGeographic(self):
   def IsProjected(self):
   def GetAttrValue(self, name, child = 0):
   def SetAttrValue(self, name, value):
   def SetWellKnownGeogCS(self, name):
   def SetProjCS(self, name = "unnamed" ):
   def IsSameGeogCS(self, other):
   def IsSame(self, other):
   def SetLinearUnits(self, units_name, to_meters ):
   def SetUTM(self, zone, is_north = 1):
 
class CoordinateTransformation:
   def __init__(self,source,target):
   def TransformPoint(self, x, y, z = 0):
   def TransformPoints(self, points):</code></pre> 
 <h3><span style="color:#000099;">七、内部实现</span></h3> 
 <p><span style="font-size:16px;color:#000099;"><a href="http://liml/gdal/gdal-web_1.9.0/ogr/classOGRCoordinateTransformation.html" rel="nofollow">OGRCoordinateTransformation</a>依赖于<a href="http://www.remotesensing.org/proj" rel="nofollow">PROJ.4</a>库。所以要使用坐标转换的内容，GDAL必须在编译的时候绑定PROJ4才可以用来进行坐标转换。如果要使用GDAL的坐标转换，重投影相关的算法，就必须要有PROJ4库的支持，否则会转换失败。关于PROJ4的编译和GDAL绑定PROJ4的内容，请参考之前的博文。</span></p> 
</div> 
<p>转载于:https://www.cnblogs.com/xiaowangba/archive/2012/05/24/6314016.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/456dc5af88b997cb743950ad2ab015d6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux驱动修炼之道-混杂设备</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1dc4f27c4239ca99f7a2205624edefba/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;中的mutable和const</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>