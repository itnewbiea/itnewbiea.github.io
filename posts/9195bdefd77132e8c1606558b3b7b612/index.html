<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构OJ实验13-动态查找 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构OJ实验13-动态查找" />
<meta property="og:description" content="A. DS二叉排序树之创建和插入 题目描述 给出一个数据序列，建立二叉排序树，并实现插入功能。
在建立和插入操作后，都输出二叉树的先序遍历结果i
输入 第1行输入n，表示序列包含n个数据
第2行输入n个数据，都是自然数且互不相同，数据之间用空格隔开
第3行输入m，表示要插入m个数据
输入m行，每行一个要插入的数据，都是自然数且和前面的数据不等
输出 第一行输出一开始构建的二叉排序树的先序遍历结果
从第二行起，输出m行，每行输出插入一个数据到二叉排序树后的先序遍历结果
每行输出的遍历结果中，每个数据后面都带一个空格，最后一个数据也带。
样例查看模式 正常显示查看格式
输入样例1 6\n
22 33 55 66 11 44\n
3\n
77\n
50\n
10\n
输出样例1 22 11 33 55 44 66 \n
22 11 33 55 44 66 77 \n
22 11 33 55 44 50 66 77 \n
22 11 10 33 55 44 50 66 77 \n
输入样例2 6\n
33 55 22 66 11 44\n" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/9195bdefd77132e8c1606558b3b7b612/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-01T22:28:30+08:00" />
<meta property="article:modified_time" content="2024-01-01T22:28:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构OJ实验13-动态查找</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>A. DS二叉排序树之创建和插入</h3> 
<h4>题目描述</h4> 
<p>给出一个数据序列，建立二叉排序树，并实现插入功能。</p> 
<p>在建立和插入操作后，都输出二叉树的先序遍历结果i</p> 
<h4>输入</h4> 
<p>第1行输入n，表示序列包含n个数据</p> 
<p>第2行输入n个数据，都是自然数且互不相同，数据之间用空格隔开</p> 
<p>第3行输入m，表示要插入m个数据</p> 
<p>输入m行，每行一个要插入的数据，都是自然数且和前面的数据不等</p> 
<h4>输出</h4> 
<p>第一行输出一开始构建的二叉排序树的先序遍历结果</p> 
<p>从第二行起，输出m行，每行输出插入一个数据到二叉排序树后的先序遍历结果</p> 
<p>每行输出的遍历结果中，每个数据后面都带一个空格，最后一个数据也带。</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1 </h4> 
<p>6\n<br> 22 33 55 66 11 44\n<br> 3\n<br> 77\n<br> 50\n<br> 10\n</p> 
<h4>输出样例1</h4> 
<p>22 11 33 55 44 66 \n<br> 22 11 33 55 44 66 77 \n<br> 22 11 33 55 44 50 66 77 \n<br> 22 11 10 33 55 44 50 66 77 \n</p> 
<h4>输入样例2 </h4> 
<p>6\n<br> 33 55 22 66 11 44\n<br> 3\n<br> 25\n<br> 88\n<br> 50\n<br> \n</p> 
<h4>输出样例2</h4> 
<p>33 22 11 55 44 66 \n<br> 33 22 11 25 55 44 66 \n<br> 33 22 11 25 55 44 66 88 \n<br> 33 22 11 25 55 44 50 66 88 \n</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node
{
    int data;
    node *l;
    node *r;
    node(int d=0,node *ll=NULL,node *rr=NULL):
    data(d),l(ll),r(rr){}
};
class tree
{
    node *root;
    void insert_node(node *&amp;root,int d)
    {
        if(!root)
        {
            root=new node(d);
            return;
        }
        if(root-&gt;data==d)
        {
            return;
        }
        else if(root-&gt;data&gt;d)
        {
            insert_node(root-&gt;l,d);
        }
        else
        {
            insert_node(root-&gt;r,d);
        }
    }
    void delete_node(node*n)
    {
        if(!n)
        {
            return;
        }
        delete(n-&gt;l);
        delete(n-&gt;r);
        delete n;
    }
    void print(node*n)
    {
        if(!n)return;
        cout&lt;&lt;n-&gt;data&lt;&lt;" ";
        print(n-&gt;l);
        print(n-&gt;r);
    }
public:
    tree(){root=NULL;}
    ~tree(){delete_node(root);}
    void create(int x)
    {
        insert_node(root,x);
    }
    void printe()
    {
        print(root);
        cout&lt;&lt;endl;
    }
};
int main()
{
    int n;
    cin&gt;&gt;n;
    tree b;
    for(int i=0;i&lt;n;i++)
    {
        int x;
        cin&gt;&gt;x;
        b.create(x);
    }
    b.printe();
    int m;
    cin&gt;&gt;m;
    for(int i=0;i&lt;m;i++)
    {
        int x;
        cin&gt;&gt;x;
        b.create(x);
        b.printe();
    }
    return 0;
}</code></pre> 
<h3>B. DS二叉排序树之查找</h3> 
<h4>题目描述</h4> 
<p>给出一个数据序列，建立二叉排序树，并实现查找功能</p> 
<h4>输入</h4> 
<p>第1行输入n，表示首个序列包含n个数据</p> 
<p>第2行输入n个数据，都是自然数且互不相同，数据之间用空格隔开</p> 
<p>第3行输入m，表示要查找m个数据</p> 
<p>接着输入m行，每行一个要查找的数据，都是自然数</p> 
<p>以此类推输入下一个示例</p> 
<h4>输出</h4> 
<p>第一行输出有序的数据序列，对二叉排序树进行中序遍历可以得到</p> 
<p>从第二行起，输出查找结果，如果查找成功输出查找次数，如果查找失败输出-1</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1 </h4> 
<p>6\n<br> 22 33 55 66 11 44\n<br> 7\n<br> 11\n<br> 22\n<br> 33\n<br> 44\n<br> 55\n<br> 66\n<br> 77\n</p> 
<h4>输出样例1</h4> 
<p>11 22 33 44 55 66 \n<br> 2\n<br> 1\n<br> 2\n<br> 4\n<br> 3\n<br> 4\n<br> -1\n</p> 
<h4>输入样例2 </h4> 
<p>6\n<br> 33 22 55 11 66 44\n<br> 4\n<br> 88\n<br> 11\n<br> 44\n<br> 66\n</p> 
<h4>输出样例2</h4> 
<p>11 22 33 44 55 66 \n<br> -1\n<br> 3\n<br> 3\n<br> 3\n</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node
{
    int data;
    node* l;
    node* r;
    node(int d = 0, node* ll = NULL, node* rr = NULL) :
        data(d), l(ll), r(rr) {}
};
class tree
{
    node* root;
    int cnt;
    void insert_node(node*&amp; root, int d)
    {
        if (!root)
        {
            root = new node(d);
            return;
        }
        if (root-&gt;data == d)
        {
            return;
        }
        else if (root-&gt;data &gt; d)
        {
            insert_node(root-&gt;l, d);
        }
        else
        {
            insert_node(root-&gt;r, d);
        }
    }
    void delete_node(node* n)
    {
        if (!n)
        {
            return;
        }
        delete(n-&gt;l);
        delete(n-&gt;r);
        delete n;
    }
    void print(node* n)
    {
        if (!n)return;
        print(n-&gt;l);
        cout &lt;&lt; n-&gt;data &lt;&lt; " ";
        print(n-&gt;r);
    }
public:
    tree() { root = NULL,cnt=0; }
    ~tree() { delete_node(root); }
    void create(int x)
    {
        insert_node(root, x);
    }
    void printe()
    {
        print(root);
        cout &lt;&lt; endl;
    }
    int find(int d)
    {
        int cnt = 0;
        node* p = root;
        while (p)//用while
        {
            cnt++;
            if (p-&gt;data == d)
            {
                return cnt;
            }
            else if (p-&gt;data &gt; d)
            {
                p = p-&gt;l;
            }
            else
            {
                p = p-&gt;r;
            }
        }
        return -1;
    }
};
int main()
{
    int n;
    cin &gt;&gt; n;
    tree b;
    for (int i = 0; i &lt; n; i++)
    {
        int x;
        cin &gt;&gt; x;
        b.create(x);
    }
    b.printe();
    int m;
    cin &gt;&gt; m;
    for (int i = 0; i &lt; m; i++)
    {
        int x;
        cin &gt;&gt; x;
        cout &lt;&lt; b.find(x) &lt;&lt; endl;
    }
    return 0;
}</code></pre> 
<h3>C. DS二叉排序树之删除</h3> 
<h4>题目描述</h4> 
<p>给出一个数据序列，建立二叉排序树，并实现删除功能</p> 
<p>对二叉排序树进行中序遍历，可以得到有序的数据序列</p> 
<h4>输入</h4> 
<p>第一行输入t，表示有t个数据序列</p> 
<p>第二行输入n，表示首个序列包含n个数据</p> 
<p>第三行输入n个数据，都是自然数且互不相同，数据之间用空格隔开</p> 
<p>第四行输入m，表示要删除m个数据</p> 
<p>从第五行起，输入m行，每行一个要删除的数据，都是自然数</p> 
<p>以此类推输入下一个示例</p> 
<h4>输出</h4> 
<p>第一行输出有序的数据序列，对二叉排序树进行中序遍历可以得到</p> 
<p>从第二行起，输出删除第m个数据后的有序序列，输出m行</p> 
<p>以此类推输出下一个示例的结果</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1 </h4> 
<p>1\n<br> 6\n<br> 22 33 55 66 11 44\n<br> 3\n<br> 66\n<br> 22\n<br> 77\n</p> 
<h4>输出样例1</h4> 
<p>11 22 33 44 55 66 \n<br> 11 22 33 44 55 \n<br> 11 33 44 55 \n<br> 11 33 44 55 \n</p> 
<h4>提示</h4> 
<p>当删除数据不在序列中，那么删除操作等于不执行，所以输出序列不变化</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node
{
    int data;
    node *l;
    node *r;
    node(int d=0,node *ll=NULL,node *rr=NULL):
    data(d),l(ll),r(rr){}
};
class tree
{
    node *root;
    void insert_node(node *&amp;root,int d)
    {
        if(!root)
        {
            root=new node(d);
            return;
        }
        if(root-&gt;data==d)
        {
            return;
        }
        else if(root-&gt;data&gt;d)
        {
            insert_node(root-&gt;l,d);
        }
        else
        {
            insert_node(root-&gt;r,d);
        }
    }
    void delete_node(node*n)
    {
        if(!n)
        {
            return;
        }
        delete(n-&gt;l);
        delete(n-&gt;r);
        delete n;
    }
    void print(node*n)
    {
        if(!n)return;
        print(n-&gt;l);
        cout&lt;&lt;n-&gt;data&lt;&lt;" ";
        print(n-&gt;r);
    }
    void cut(node *&amp;n,int x)
    {
        if(!n)
        {
           return;
        }
        if(n-&gt;data&gt;x)
        {
            cut(n-&gt;l,x);
            return;
        }
        if(n-&gt;data&lt;x)
        {
            cut(n-&gt;r,x);
            return;
        }
        //n-&gt;data==x;
        if(n-&gt;r&amp;&amp;n-&gt;l)
        {
            node *p=n-&gt;l;
            while(p-&gt;r)
            {
                p=p-&gt;r;
            }
            n-&gt;data=p-&gt;data;//n的数据为最右最下那个数据
            cut(n-&gt;l,p-&gt;data);
            return;
        }
        node *p=n;
        if(n-&gt;l==NULL)
        {
            n=n-&gt;r;
        }
        else if(n-&gt;r==NULL)
        {
            n=n-&gt;l;
        }
        delete p;
    }
public:
    tree(){root=NULL;}
    ~tree(){delete_node(root);}
    void create(int x)
    {
        insert_node(root,x);
    }
    void printe()
    {
        print(root);
        cout&lt;&lt;endl;
    }
    int find(int d)
    {
        int cnt=0;
        node *p=root;
        while(p)
        {
            cnt++;
            if(p-&gt;data==d)
            {
                return cnt;
            }
            else if(p-&gt;data&gt;d)
            {
                p=p-&gt;l;
            }
            else
            {
                p=p-&gt;r;
            }
        }
        return -1;
    }
    void del(int x)
    {
        cut(root,x);
    }
};
int main()
{
    int t;
    cin&gt;&gt;t;
    while(t--){
        int n;
    cin&gt;&gt;n;
    tree b;
    for(int i=0;i&lt;n;i++)
    {
        int x;
        cin&gt;&gt;x;
        b.create(x);
    }
    b.printe();
    int m;
    cin&gt;&gt;m;
    for(int i=0;i&lt;m;i++)
    {
        int x;
        cin&gt;&gt;x;
        b.del(x);
        b.printe();
    }
    }
    return 0;
}</code></pre> 
<h3>D. DS查找—二叉树平衡因子</h3> 
<h4>题目描述</h4> 
<p>二叉树用数组存储，将二叉树的结点数据依次自上而下,自左至右存储到数组中，一般二叉树与完全二叉树对比，比完全二叉树缺少的结点在数组中用0来表示。</p> 
<p>计算二叉树每个结点的平衡因子，并按后序遍历的顺序输出结点的平衡因子。</p> 
<h4>输入</h4> 
<p>测试次数t</p> 
<p>每组测试数据一行，数组元素个数n，后跟n个字符，二叉树的数组存储。</p> 
<h4>输出</h4> 
<p>对每组测试数据，按后序遍历的顺序输出树中结点的平衡因子（测试数据没有空树）</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1</h4> 
<p>2\n<br> 6 ABC00D\n<br> 24 ABCD0EF0000H00000000000I\n<br> \n<br> \n</p> 
<h4>输出样例1</h4> 
<p>B 0\n<br> D 0\n<br> C 1\n<br> A -1\n<br> D 0\n<br> B 1\n<br> I 0\n<br> H 1\n<br> E 2\n<br> F 0\n<br> C 2\n<br> A -2\n</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int geth(string &amp;tree,int idx)
{
    if(tree[idx]=='0')
    return 0;
    return max(geth(tree,2*idx+1),geth(tree,2*idx+2))+1;
}
int getbalance(string &amp;tree,int idx)
{
    return geth(tree,2*idx+1)-geth(tree,2*idx+2);
}
void show(string &amp;tree,int idx)
{
    if(tree[idx]=='0')
    return;
    show(tree,idx*2+1);
    show(tree,2*idx+2);
    cout&lt;&lt;tree[idx]&lt;&lt;" "&lt;&lt;getbalance(tree,idx)&lt;&lt;endl;
}
int main()
{
    int t;
    cin&gt;&gt;t;
    while(t--)
    {
        int n;
        string tree;
        cin&gt;&gt;n&gt;&gt;tree;
        tree.append(2*n,'0');
        show(tree,0);
    }
    return 0;
}</code></pre> 
<h3>E. 搜索树判断</h3> 
<h4>题目描述</h4> 
<p>对于二叉搜索树，我们规定任一结点的左子树仅包含严格小于该结点的键值，而其右子树包含大于或等于该结点的键值。如果我们交换每个节点的左子树和右子树，得到的树叫做镜像二叉搜索树。</p> 
<p>现在我们给出一个整数键值序列，请编写程序判断该序列是否为某棵二叉搜索树或某镜像二叉搜索树的前序遍历序列，如果是，则输出对应二叉树的后序遍历序列。</p> 
<h4>输入</h4> 
<p>输入的第一行包含一个正整数N（≤1000），第二行包含N个整数，为给出的整数键值序列，数字间以空格分隔。</p> 
<h4>输出</h4> 
<p>输出的第一行首先给出判断结果，如果输入的序列是某棵二叉搜索树或某镜像二叉搜索树的前序遍历序列，则输出<code>YES</code>，否侧输出<code>NO</code>。如果判断结果是<code>YES</code>，下一行输出对应二叉树的后序遍历序列。数字间以空格分隔，但行尾不能有多余的空格。</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1 </h4> 
<p>7\n<br> 8 6 5 7 10 8 11</p> 
<h4>输出样例1</h4> 
<p>YES\n<br> 5 7 6 8 11 10 8</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node
{
    int data;
    node *l;
    node *r;
    node(int d=0,node *ll=NULL,node *rr=NULL):
    data(d),l(ll),r(rr){}
};
class tree
{
    node *root;
    vector&lt;int&gt;b;
    void insert_node(node *&amp;root,int d)
    {
        if(!root)
        {
            root=new node(d);
            return;
        }
        else if(root-&gt;data&gt;d)
        {
            insert_node(root-&gt;l,d);
        }
        else
        {
            insert_node(root-&gt;r,d);
        }
    }
    void delete_node(node*n)
    {
        if(!n)
        {
            return;
        }
        delete(n-&gt;l);
        delete(n-&gt;r);
        delete n;
    }
    void print(node*n)
    {
        if(!n)return;
        b.push_back(n-&gt;data);
        print(n-&gt;l);
        print(n-&gt;r);
    }
    void post(node *n)
    {
        if(!n)return;
        post(n-&gt;l);
        post(n-&gt;r);
        b.push_back(n-&gt;data);//b放后序列
    }
    void cut(node *&amp;n,int x)
    {
        if(!n)
        {
           return;
        }
        if(n-&gt;data&gt;x)
        {
            cut(n-&gt;l,x);
            return;
        }
        if(n-&gt;data&lt;x)
        {
            cut(n-&gt;r,x);
            return;
        }
        //n-&gt;data==x;
        if(n-&gt;r&amp;&amp;n-&gt;l)
        {
            node *p=n-&gt;l;
            while(p-&gt;r)
            {
                p=p-&gt;r;
            }
            n-&gt;data=p-&gt;data;//n的数据为最右最下那个数据
            cut(n-&gt;l,p-&gt;data);
            return;
        }
        node *p=n;
        if(n-&gt;l==NULL)
        {
            n=n-&gt;r;
        }
        else if(n-&gt;r==NULL)
        {
            n=n-&gt;l;
        }
        delete p;
    }
public:
    tree(){root=NULL;}
    ~tree(){delete_node(root),b.clear();}
    void create(int x)
    {
        insert_node(root,x);
    }
    void printe()
    {
        print(root);
    }
    int find(int d)
    {
        int cnt=0;
        node *p=root;
        while(p)
        {
            cnt++;
            if(p-&gt;data==d)
            {
                return cnt;
            }
            else if(p-&gt;data&gt;d)
            {
                p=p-&gt;l;
            }
            else
            {
                p=p-&gt;r;
            }
        }
        return -1;
    }
    void del(int x)
    {
        cut(root,x);
    }
    bool check(vector&lt;int&gt; a)
    {
        if(a.size()!=b.size())return 0;
        for(int i=0;i&lt;b.size()&amp;&amp;i&lt;a.size();i++)
        {
             if(a[i]!=b[i])return 0;
        }
        return 1;
    }
    void postshow()
    {
        b.clear();
        post(root);
        for(int i=0;i&lt;b.size();i++)
        {
            if(i)
            cout&lt;&lt;" "&lt;&lt;b[i];
            else cout&lt;&lt;b[i];
        }
        cout&lt;&lt;endl;
    }
};
int main()
{
    int n;
    cin&gt;&gt;n;
    tree b;
    vector&lt;int&gt;a;
    for(int i=0;i&lt;n;i++)
    {
        int x;
        cin&gt;&gt;x;
        b.create(x);
        a.push_back(x);
    }
    b.printe();
    if(b.check(a)==1)
    {
        cout&lt;&lt;"YES"&lt;&lt;endl;
        b.postshow();
    }
    else
    {
        cout&lt;&lt;"NO"&lt;&lt;endl;
    }
    return 0;
}</code></pre> 
<h3>F. 二叉搜索树的最近公共祖先</h3> 
<h4>题目描述</h4> 
<p>给定一棵二叉搜索树的先序遍历序列，要求你找出任意两结点的最近公共祖先结点（简称 LCA）。</p> 
<h4>输入</h4> 
<p>输入的第一行给出两个正整数：待查询的结点对数 M（≤ 1 000）和二叉搜索树中结点个数 N（≤ 10 000）。随后一行给出 N 个不同的整数，为二叉搜索树的先序遍历序列。最后 M 行，每行给出一对整数键值 U 和 V。所有键值都在整型int范围内。</p> 
<h4>输出</h4> 
<p>对每一对给定的 U 和 V，如果找到 <code>A</code> 是它们的最近公共祖先结点的键值，则在一行中输出 <code>LCA of U and V is A.</code>。但如果 U 和 V 中的一个结点是另一个结点的祖先，则在一行中输出 <code>X is an ancestor of Y.</code>，其中 <code>X</code> 是那个祖先结点的键值，<code>Y</code> 是另一个键值。如果 二叉搜索树中找不到以 U 或 V 为键值的结点，则输出 <code>ERROR: U is not found.</code> 或者 <code>ERROR: V is not found.</code>，或者 <code>ERROR: U and V are not found.</code>。</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1</h4> 
<p>6 8\n<br> 6 3 1 2 5 4 8 7\n<br> 2 5\n<br> 8 7\n<br> 1 9\n<br> 12 -3\n<br> 0 8\n<br> 99 99</p> 
<h4>输出样例1</h4> 
<p>LCA of 2 and 5 is 3.\n<br> 8 is an ancestor of 7.\n<br> ERROR: 9 is not found.\n<br> ERROR: 12 and -3 are not found.\n<br> ERROR: 0 is not found.\n<br> ERROR: 99 and 99 are not found.</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node
{
    int data;
    node *l;
    node *r;
    node(int d=0,node *ll=NULL,node *rr=NULL):
    data(d),l(ll),r(rr){}
};
class tree
{
    node *root;
    string ss;
    void insert_node(node *&amp;root,int d)
    {
        if(!root)
        {
            root=new node(d);
            return;
        }
        if(root-&gt;data==d)
        {
            return;
        }
        else if(root-&gt;data&gt;d)
        {
            insert_node(root-&gt;l,d);
        }
        else
        {
            insert_node(root-&gt;r,d);
        }
    }
    void delete_node(node*n)
    {
        if(!n)
        {
            return;
        }
        delete(n-&gt;l);
        delete(n-&gt;r);
        delete n;
    }
    node* find(int d)
    {
        int cnt=0;
        node *p=root;
        while(p)
        {
            cnt++;
            if(p-&gt;data==d)
            {
                return p;
            }
            else if(p-&gt;data&gt;d)
            {
                p=p-&gt;l;
            }
            else
            {
                p=p-&gt;r;
            }
        }
        return NULL;
    }
public:
    tree(){root=NULL;}
    ~tree(){delete_node(root);}
    void create(int x)
    {
        insert_node(root,x);
    }
    int check(int d)
    {
        node *p=find(d);
        if(p==NULL)return -1;
        return 1;
    }
    node* lca(node* root, node* p, node* q) 
    {
        if(!root) return NULL;
        if(root-&gt;data &gt; p-&gt;data &amp;&amp; root-&gt;data &gt; q-&gt;data)
        {
            return lca(root-&gt;l, p, q);
        }
        else if(root-&gt;data &lt; p-&gt;data &amp;&amp; root-&gt;data &lt; q-&gt;data)
        {
            return lca(root-&gt;r, p, q);
        }
        return root;
    }
    int pp(int x,int y)
    {
        node *p=find(x);
        node *q=find(y);
        if((p-&gt;l&amp;&amp;p-&gt;l-&gt;data==y)||(p-&gt;r&amp;&amp;p-&gt;r-&gt;data==y))
        {
            printf("%d is an ancestor of %d.\n",x,y);
            return -2;
        }
        if((q-&gt;l&amp;&amp;q-&gt;l-&gt;data==x)||(q-&gt;r&amp;&amp;q-&gt;r-&gt;data==x))
        {
            printf("%d is an ancestor of %d.\n",y,x);
            return -2;
        }
        int res=lca(root,p,q)-&gt;data;
        return res;
    }
};
int main()
{
    int m,n;
    cin&gt;&gt;m&gt;&gt;n;
    tree b;
    for(int i=0;i&lt;n;i++)
    {
        int x;
        cin&gt;&gt;x;
        b.create(x);
    }
    for(int i=0;i&lt;m;i++)
    {
        int x,y;
        cin&gt;&gt;x&gt;&gt;y;
        int idxa=b.check(x);
        int idxb=b.check(y);
        if(idxa==-1&amp;&amp;idxb==-1)
        {
            printf("ERROR: %d and %d are not found.\n",x,y);
        }
        else if(idxa==-1)
        {
            printf("ERROR: %d is not found.\n",x);
        }
        else if(idxb==-1)
        {
            printf("ERROR: %d is not found.\n",y);
        }
        else
        {
            int kk=b.pp(x,y);
            if(kk!=-2)
            printf("LCA of %d and %d is %d.\n",x,y,kk);
        }
    }
    return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/22fd5de05960beac07124afc8dcef3f2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">armbian 设置IP 修改Gateway、DNS</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/30154694573f2dd2ec115bac14795dbe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">下界通配符（? super Type）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>