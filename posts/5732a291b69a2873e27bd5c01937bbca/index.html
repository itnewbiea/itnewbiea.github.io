<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>AVI文件格式解析2 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="AVI文件格式解析2" />
<meta property="og:description" content="AVI文件格式 2011-09-04 09:51:06| 分类： H264 | 标签： |字号大中小 订阅 AVI格式是音频视频交错(Audio Video Interleaved)的英文缩写，它是Microsoft公司开发的一种符合RIFF文件规范的数字音频与视频文件格式，原先用于Microsoft Video for Windows (简称VFW)环境，现在已被Windows 95/98、OS/2等多数操作系统直接支持。AVI格式允许视频和音频交错在一起同步播放，支持256色和RLE压缩，但AVI文件并未限定压缩标准，因此，AVI文件格式只是作为控制界面上的标准，不具有兼容性，用不同压缩算法生成的AVI文件，必须使用相应的解压缩算法才能播放出来。常用的AVI播放驱动程序，主要是Microsoft Video for Windows或Windows 95/98中的Video 1，以及Intel公司的Indeo Video。
在介绍AVI文件前，我们要先来看看RIFF文件结构。AVI文件采用的是RIFF文件结构方式，RIFF（Resource Interchange File Format，资源互换文件格式）是微软公司定义的一种用于管理windows环境中多媒体数据的文件格式，波形音频wave，MIDI和数字视频AVI都采用这种格式存储。构造RIFF文件的基本单元叫做数据块（Chunk），每个数据块包含3个部分，
1、4字节的数据块标记（或者叫做数据块的ID）
2、数据块的大小
3、数据
整个RIFF文件可以看成一个数据块，其数据块ID为RIFF，称为RIFF块。一个RIFF文件中只允许存在一个RIFF块。RIFF块中包含一系列的子块，其中有一种字块的ID为&#34;LIST&#34;，称为LIST，LIST块中可以再包含一系列的子块，但除了LIST块外的其他所有的子块都不能再包含子块。
RIFF和LIST块分别比普通的数据块多一个被称为形式类型（Form Type）和列表类型（List Type）的数据域，其组成如下： 1、4字节的数据块标记（Chunk ID）
2、数据块的大小
3、4字节的形式类型或者列表类型
4、数据
下面我们看看AVI文件的结构。AVI文件是目前使用的最复杂的RIFF文件，它能同时存储同步表现的音频视频数据。AVI的RIFF块的形式类型是AVI，它包含3个子块，如下所述：
1、信息块，一个ID为&#34;hdrl&#34;的LIST块，定义AVI文件的数据格式。
2、数据块，一个ID为 &#34;movi&#34;的LIST块，包含AVI的音视频序列数据。
3、索引块，ID为 &#34;idxl&#34;的子块，定义 &#34;movi&#34;LIST块的索引数据，是可选块。
AVI文件的结构如下图所示，下面将具体介绍AVI文件的各子块构造。
1、信息块，信息块包含两个子块，即一个ID为 avih 的子块和一个ID 为 strl 的LIST块。
AVI文件结构
&#34;avih&#34;子块的内容可由如下的结构定义：
&#34;strl&#34; LIST块用于记录AVI数据流，每一种数据流都在该LIST块中占有3个子块，他们的ID分别是&#34;strh&#34;,&#34;strf&#34;, &#34;strd&#34;； &#34;strh&#34;子块由如下结构定义。 &#34;strf&#34;子块紧跟在&#34;strh&#34;子块之后，其结构视&#34;strh&#34;子块的类型而定，如下所述；如果 strh子块是视频数据流，则 strf子块的内容是一个与windows设备无关位图的BIMAPINFO结构，如下： 如果 strh子块是音频数据流，则strf子块的内容是一个WAVEFORMAT结构，如下： &#34;strd&#34;子块紧跟在strf子块后，存储供压缩驱动程序使用的参数，不一定存在，也没有固定的结构。 &#34;strl&#34; LIST块定义的AVI数据流依次将 &#34;hdrl &#34; LIST 块中的数据流头结构与&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5732a291b69a2873e27bd5c01937bbca/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-06-19T22:26:56+08:00" />
<meta property="article:modified_time" content="2012-06-19T22:26:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">AVI文件格式解析2</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 class="title pre fs1"><span class="tcnt"><span style="font-family:微软雅黑; font-size:24px">AVI文件格式</span></span>  <span class="bgc0 fc07 fw0 fs0"></span></h4> 
<p class="tdep clearfix nbw-act fc06" style="line-height:20px"><span class="pleft"><span class="blogsep">2011-09-04 09:51:06</span><span class="blogsep">|  分类：</span> <a class="fc03 m2a" title="H264" href="http://wmnmtm.blog.163.com/blog/#m=0&amp;t=1&amp;c=fks_084065092080087068084087083095087094083071081081087071" rel="nofollow"> <span style="color:#070f1f">H264</span></a> <span id="$_blogTagTitle" class="blogsep phide"> |  标签：</span><span id="$_blogTagInfo" class="fc03 phide"></span> </span><span class="pright fc07 ztag"><span class="blogsep">|</span><span id="$_fontswitch" class="zihao fc03"><span style="color:#070f1f">字号</span><span id="$_fontsTypes" class="zihaoshow  phide"><span class="zihaoc bdc0"><span class="stag"></span><span class="fc04 stag">大</span><span class="fc04 stag selected js-fcurrent fc05">中</span><span class="fc04 stag">小</span></span></span></span></span><span id="$_blog_subscribe" class="pright pnt fc03"><span class="iblock icn0 icn0-919"> </span><a class="m2a">订阅</a></span> </p> 
<div></div> 
<div class="nbw-blog-start"></div> 
<div class="bct fc05 fc11 nbw-blog ztag js-fs2"> 
 <p><wbr></wbr>AVI格式是音频视频交错(Audio Video Interleaved)的英文缩写，它是Microsoft公司开发的一种符合RIFF文件规范的数字音频与视频文件格式，原先用于Microsoft Video for Windows (简称VFW)环境，现在已被Windows 95/98、OS/2等多数操作系统直接支持。AVI格式允许视频和音频交错在一起同步播放，支持256色和RLE压缩，但AVI文件并未限定压缩标准，因此，AVI文件格式只是作为控制界面上的标准，不具有兼容性，<strong>用不同压缩算法生成的AVI文件，必须使用相应的解压缩算法才能播放出来</strong>。常用的AVI播放驱动程序，主要是Microsoft Video for Windows或Windows 95/98中的Video 1，以及Intel公司的Indeo Video。<br> 在介绍AVI文件前，我们要先来看看RIFF文件结构。AVI文件采用的是RIFF文件结构方式，RIFF（Resource Interchange File Format，资源互换文件格式）是微软公司定义的一种用于管理windows环境中多媒体数据的文件格式，波形音频wave，MIDI和数字视频AVI都采用这种格式存储。构造RIFF文件的基本单元叫做数据块（Chunk），每个数据块包含3个部分，</p> 
 <p>1、4字节的数据块标记（或者叫做数据块的ID）</p> 
 <p>2、数据块的大小</p> 
 <p>3、数据</p> 
 <p>整个RIFF文件可以看成一个数据块，其数据块ID为RIFF，称为RIFF块。一个RIFF文件中只允许存在一个RIFF块。RIFF块中包含一系列的子块，其中有一种字块的ID为"LIST"，称为LIST，LIST块中可以再包含一系列的子块，但除了LIST块外的其他所有的子块都不能再包含子块。</p> 
 <p>RIFF和LIST块分别比普通的数据块多一个被称为形式类型（Form Type）和列表类型（List Type）的数据域，其组成如下： </p> 
 <p>1、4字节的数据块标记（Chunk ID）</p> 
 <p>2、数据块的大小</p> 
 <p>3、4字节的形式类型或者列表类型</p> 
 <p>4、数据</p> 
 <p>下面我们看看AVI文件的结构。AVI文件是目前使用的最复杂的RIFF文件，它能同时存储同步表现的音频视频数据。AVI的RIFF块的形式类型是AVI，它包含3个子块，如下所述：</p> 
 <p><strong>1、信息块，一个ID为"hdrl"的LIST块，定义AVI文件的数据格式。</strong></p> 
 <p><strong>2、数据块，一个ID为 "movi"的LIST块，包含AVI的音视频序列数据。</strong></p> 
 <p><strong>3、索引块，ID为 "idxl"的子块，定义 "movi"LIST块的索引数据，是可选块。</strong></p> 
 <p>AVI文件的结构如下图所示，下面将具体介绍AVI文件的各子块构造。</p> 
 <p>1、信息块，信息块包含两个子块，即一个ID为 avih 的子块和一个ID 为 strl 的LIST块。</p> 
 <div> 
  <img alt="AVI文件格式 - 加菲 -  ." src="https://images2.imgbox.com/f5/0a/hgFErQ6D_o.jpg" style="margin:0px 10px 0px 0px"> 
 </div> 
 <p> </p> 
 <p>AVI文件结构</p> 
 <p>"avih"子块的内容可由如下的结构定义：</p> 
 <div> 
  <img alt="AVI文件格式 - 加菲 -  ." src="https://images2.imgbox.com/05/59/CWHfvzNg_o.gif" style="margin:0px 10px 0px 0px"> 
 </div> 
 <div>
     
 </div> 
 <div>
   "strl" LIST块用于记录AVI数据流，每一种数据流都在该LIST块中占有3个子块，他们的ID分别是"strh","strf", "strd"； 
 </div> 
 <div>
   "strh"子块由如下结构定义。 
 </div> 
 <div> 
  <div> 
   <img alt="AVI文件格式 - 加菲 -  ." src="https://images2.imgbox.com/d5/ef/LutHnbZ2_o.gif" style="margin:0px 10px 0px 0px"> 
  </div> 
  <div>
      
  </div> 
  <div>
    "strf"子块紧跟在"strh"子块之后，其结构视"strh"子块的类型而定，如下所述；如果 strh子块是视频数据流，则 strf子块的内容是一个与windows设备无关位图的BIMAPINFO结构，如下： 
  </div> 
  <div> 
   <div> 
    <img alt="AVI文件格式 - 加菲 -  ." src="https://images2.imgbox.com/1d/db/uyETdOnl_o.gif" style="margin:0px 10px 0px 0px"> 
   </div> 
   <div>
       
   </div> 
   <div>
     如果 strh子块是音频数据流，则strf子块的内容是一个WAVEFORMAT结构，如下： 
    <br> 
   </div> 
   <div> 
    <div> 
     <img alt="AVI文件格式 - 加菲 -  ." src="https://images2.imgbox.com/d8/e7/dqRPqebs_o.gif" style="margin:0px 10px 0px 0px"> 
    </div>   
   </div>  "strd"子块紧跟在strf子块后，存储供压缩驱动程序使用的参数，不一定存在，也没有固定的结构。 
  </div> 
  <div>
    "strl" LIST块定义的AVI数据流依次将 "hdrl " LIST 块中的数据流头结构与"movi" LIST块中的数据联系在一起，第一个数据流头结构用于数据流0，第二个用于数据流1，依次类推。 
  </div> 
  <div>
    数据块中存储视频和音频数据流，数据可直接存于 "movi" LIST块中。数据块中音视频数据按不同的字块存放，其结构如下所述， 
  </div> 
  <div>
    音频字块 
  </div> 
  <div>
    "##wb" 
  </div> 
  <div>
    Wave 数据流 
  </div> 
  <div>
    视频子块中存储DIB数据，又分为压缩或者未压缩DIB， 
  </div> 
  <div>
    "##db" 
  </div> 
  <div>
    RGB数据流 
  </div> 
  <div>
    "##dc" 
  </div> 
  <div>
    压缩的图像数据流 
  </div> 
  <div>
    看到了吧，avi文件的图像数据可以是压缩的，和非压缩格式的。对于压缩格式来说，也可采用不同的编码，也许你曾经遇到有些avi没法识别，就是因为编码方式不一样，如果没有相应的解码，你就没法识别视频数据。AVI的编码方式有很多种，比较常见的有 mpeg2，mpeg4，divx等。 
  </div> 
  <div>
    索引块，索引快包含数据块在文件中的位置索引，能提高avi文件的读写速度，其中存放着一组AVIINDEXENTRY结构数据。如下，这个块并不是必需的，也许不存在。 
  </div> 
  <div>
      
  </div> 
  <div>
    typedef struct 
   <br> { 
   <br> 　DWORD ckid; //记录数据块中子块的标记 
   <br> 　DWORD dwFlags; //表示chid所指子块的属性 
   <br> 　DWORD dwChunkOffset; //子块的相对位置 
   <br> 　DWORD dwChunkLength; //子块长度 
   <br> }; 
  </div> 
  <div>
      
  </div> 
  <div> 
   <span style="font-size:16px">现在我相信你肯定会对AVI的文件结构已经很清楚了，在介绍完了AVI文件结构后，我们就来看看如何对avi文件进行读写了，为了对avi进行读写，微软提供了一套API，总共50个函数，他们的用途主要有两类，一个是avi文件的操作，一类是数据流streams的操作。<br> <br> 　　1、打开和关闭文件<br> <br> 　　AVIFileOpen ，AVIFileAddRef， AVIFileRelease<br> <br> 　　2、从文件中读取文件信息<br> <br> 　 　通过AVIFileInfo可以获取avi文件的一些信息，这个函数返回一个AVIFILEINFO结构，通过AVIFileReadData可以用来 获取AVIFileInfo函数得不到的信息。这些信息也许不包含在文件的头部，比如拥有file的公司和个人的名称。<br> <br> 　　3、写入文件信息<br> <br> 　　可以通过AVIFileWriteData函数来写入文件的一些额外信息。<br> <br> 　　4、打开和关闭一个流<br> <br> 　　打开一个数据流就跟打开文件一样，你可以通过 AVIFileGetStream函数来打开一个数据流，这个函数创建了一个流的接口，然后在该接口中保存了一个句柄。<br> <br> 　　如果你想操作文件的某一个单独的流，你可以采用AVIStreamOpenFromFile函数，这个函数综合了AVIFileOpen和AVIFileGetStream函数。<br> <br> 　　如果你想操作文件中的多个数据流，你就要首先AVIFileOpen，然后AVIFileGetStream。<br> <br> 　　可以通过AVIStreamAddRef来增加stream接口的引用。<br> <br> 　　通过AVIStreamRelease函数来关闭数据流。这个函数用来减少streams的引用计数，当计数减少为0时，删除。<br> <br> 　　5、从流中读取数据和信息<br> <br> 　　AVIStreamInfo函数可以获取数据的一些信息，该函数返回一个AVISTREAMINFO结构，该结构包含了数据的类型压缩方法，建议的buffersize，回放的rate，以及一些description。<br> <br> 　　如果数据流还有一些其它的额外的信息，你可以通过AVIStreamReadData函数来获取。应用程序分配一个</span> 
   <a href="http://diy.yesky.com/memoery/" rel="nofollow noopener noreferrer" target="_blank"><span style="font-size:16px; color:#003399">内存</span></a> 
   <span style="font-size:16px">，传递给这个函数，然后这个函数会通过这个内存返回数据流的信息，额外的信息可能包括数据流的压缩和解压缩的方法，你可以通过AVIStreamDataSize宏来回去需要申请内存块的大小。<br> <br> 　 　可以通过AVIStreamReadFormat函数获取数据流的格式信息。这个函数通过指定的内存返回数据流的格式信息，比如对于视频流，这个 buffer包含了一个BIMAPINFO结构，对于音频流，内存块包含了WAVEFORMATEX或者PCMAVEFORMAT结构。你可以通过给 AVIStreamReadFormat传递一个空buffer就可以获取buffer的大小。也可以通过AVIStreamFormatSize宏。<br> <br> 　 　可以通过AVIStreamRead函数来返回多媒体的数据。这个函数将数据复制到应用程序提供的内存中，对于视频流，这个函数返回图像祯，对于音频 流，这个函数返回音频的sample数据。可以通过给AVIStreamRead传递一个NULL的buffer来获取需要的buffer的大小。也可以 通过AVIStreamSampleSize宏来获取buffer的大小。<br> <br> 　　有些AVI数据流句柄可能需要在启动数据流的前要做一下准 备工作，此时，我们可以调用AVIStreamBeginStreaming函数来告知AVI数据流handle来申请分配它需要的一些资源。在完毕后， 调用AVIStreamEndStreamming函数来释放资源。<br> <br> 　　6、操作压缩的视频数据<br> <br> 　　如果你要演示一祯或者几祯压缩视频图像时，你可以调用AVIStreamRead函数，将获取的数据传递给DrawDib函数来显示图像。这些函数可以显示压缩和未压缩的图像。<br> <br> 　 　AVIFile也提供了一个函数AVIStreamGetFrameOpen，来获取未压缩的视频祯，这个函数创建了内存来获取未压缩的数据。也可以通 过AVIStreamGetFrame函数来解压缩一个单独的视频祯。这个函数可以解压缩某一祯图像，然后将数据以一个BIMAPINFOHEADER结 构返回。当你调用完AVIStreamGetFrame函数后，要调用AVIStreamGetFrameClose函数释放上一个函数申请的资源。<br> <br> 　　7、根据已存在的数据流创建文件<br> <br> 　　创建一个包含多个数据流的文件的方法就是整合多个数据流，将其写入一个新文件。这些数据流可以是内存中的数据，也可以是存在于另一个文件中。<br> <br> 　 　我们可以用AVISave这个函数来build一个文件。这个函数可以创建一个文件，并且将指定的多个数据流按照指定的顺序写入文件，你也可以通过 AVISaveV函数来创建一个新的文件，这个函数的功能和AVISave的功能一样，主要区别是AVISaveV采用的数据流数组，而AVISave是 单个的数据流，多次保存。<br> <br> 　　我们可以调用AVISaveOptions函数来显示一个对话框，可以让用户来选择压缩方式。<br> <br> 　　我们可以在调用AVISave和AVISaveV函数时指定一个回调函数，用来显示avi文件的生成进度，可以让用户随时地取消生成avi文件。<br> <br> 　　我们可以调用GetSaveFileNamePreview函数来显示保存的对话框让用户选择保存的文件名。<br> <br> 　　通过AVIMakeFileFromStreams函数我们可以创建一个虚拟的文件句柄，其他的avi函数可以通过这个虚拟的文件句柄来操作文件中的数据流，操作完毕要记得调用AVIFileRelease释放。 </span> 
   <p><span style="font-size:16px"> </span></p> 
   <p><span style="font-size:16px">8、向文件写入一个数据流<br> <br> 　　我们可以通过AVIFileCreateStream函数来在一个新文件或者已经存在的文件中创建一个数据流。这个函数根据AVISTREAMINFO结构定义了新的数据流，并为新的数据流创建一个接口，返回接口的指针。<br> <br> 　　在写入新的数据前，一定要指定流的格式信息，通过AVIStreamSetFormat函数，当设置一个视频流的时候，一定要使用BIMAPINFO结构来设置，音频就用WAVEFORMAT。<br> <br> 　　然后我们就可以通过AVIStreamWrite函数将我们的多媒体数据写入数据流了。这个函数将应用程序提供的内存数据复制到指定的流。缺省的avi handler将数据写入流的最后。<br> <br> 　　如果你有其他额外的信息需要写入流，你可以调用AVIFileWriteData或者AVIStreamWriteData，最后记得在完成数据写入后，要调用AVIStreamRelease。<br> <br> 　　9、数据流中的祯的位置<br> <br> 　　寻找起始祯：<br> <br> 　 　可以通过AVIStreamStart函数来获取第一祯包含的sample number。也可以通过AVIStreamInfo函数来获取这个信息，这个函数的AVISTREAMINFO结构中包含了dwStart，可以通过 AVIStreamStartTime宏来获取第一个sample。<br> <br> 　　可以通过AVIStreamLength函数来获取流的长度。这个函数返回流中的sample的数目。也可以通过AVIStreamInfo函数来获取这些信息，可以通过AVIStreamLengthTime宏来获取流的长度，毫秒。<br> <br> 　 　在视频流中，一个sample对应着一祯图像，所以，有时这些sample中没有视频数据，如果你调用AVIStreamRead函数来数据，可能返回 NULL，也可以通过AVIStreamFindSample通过指定FIND_ANY标志来查找指定的sample。<br> <br> 　　查找关键祯<br> <br> 　　通过AVIStreamFindSample函数查找符合要寻找的sample，然后可以通过下面的宏判断是否关键祯。<br> <br> 　　在time和sample间互相切换。<br> <br> 　　AVIStreamSampleToTime这个函数可以将smaple转换成毫秒。对于视频，这个值代表的是这个祯开始播放的时间。<br> <br> 　　在了解了上面的知识后，我们对avi的文件结构以及如何操作avi文件心里就明白了，下面我们可以开始我们的编程了。我们要做两件事情：<br> <br> 　　1、如何将一组静态的bmp位图合成一个avi的视频文件；<br> <br> 　　2、如何将一个未压缩的avi文件解析成一幅幅位图。<br> <br> 　　示例程序界面如下：<br> <br> </span></p> 
   <div> 
    <img alt="AVI文件格式 - 加菲 -  ." src="https://images2.imgbox.com/e4/09/gpunpdvt_o.jpg" style="margin:0px 10px 0px 0px"> 
   </div> 
   <div>
       
   </div> 
   <div>
       
   </div> 
   <p> 下面的函数演示了如何将一个文件夹下面的所有bmp文件都保存为一个avi文件，函数的第一个参数是要生成的AVI的文件名，第二个参数是存放bmp文件的文件夹名，这个函数会枚举该文件夹下的所有bmp文件，合成一个AVI文件。<br> <br> </p> 
   <table border="1" width="90%" bgcolor="#e3e3e3" align="center"><tbody><tr><td><span style="font-size:16px">void Cbmp2aviDlg::AVItoBmp(CString strAVIFileName, CString strBmpDir)<br> {<!-- --><br> 　// TODO: 在此添加控件通知处理程序代码<br> 　AVIFileInit();<br> 　PAVIFILE avi;<br> 　int res="AVIFileOpen"(&amp;avi, strAVIFileName, OF_READ, NULL);<br> 　int n = GetLastError();<br> 　if (res!=AVIERR_OK)<br> 　{<!-- --><br> 　　//an error occures<br> 　　if (avi!=NULL)<br> 　　　AVIFileRelease(avi);<br> 　　return ;<br> 　}<br> 　AVIFILEINFO avi_info;<br> 　AVIFileInfo(avi, &amp;avi_info, sizeof(AVIFILEINFO));<br> 　PAVISTREAM pStream;<br> 　res=AVIFileGetStream(avi, &amp;pStream, streamtypeVIDEO /*video stream*/, <br> 　　　0 /*first stream*/);<br> 　if (res!=AVIERR_OK)<br> 　{<!-- --><br> 　　if (pStream!=NULL)<br> 　　　AVIStreamRelease(pStream);<br> 　　　AVIFileExit();<br> 　　return ;<br> 　}<br> <br> 　//do some task with the stream<br> 　int iNumFrames;<br> 　int iFirstFrame;<br> 　iFirstFrame=AVIStreamStart(pStream);<br> 　if (iFirstFrame==-1)<br> 　{<!-- --><br> 　　//Error getteing the frame inside the stream<br> 　　if (pStream!=NULL)<br> 　　　AVIStreamRelease(pStream);<br> 　　AVIFileExit();<br> 　　return ;<br> 　}<br> 　iNumFrames=AVIStreamLength(pStream);<br> 　if (iNumFrames==-1)<br> 　{<!-- --><br> 　　//Error getteing the number of frames inside the stream<br> 　　if (pStream!=NULL)<br> 　　　AVIStreamRelease(pStream);<br> 　　AVIFileExit();<br> 　　return ;<br> 　}<br> <br> 　//getting bitmap from frame<br> 　BITMAPINFOHEADER bih;<br> 　ZeroMemory(&amp;bih, sizeof(BITMAPINFOHEADER));<br> <br> 　bih.biBitCount=24; //24 bit per pixel<br> 　bih.biClrImportant=0;<br> 　bih.biClrUsed = 0;<br> 　bih.biCompression = BI_RGB;<br> 　bih.biPlanes = 1;<br> 　bih.biSize = 40;<br> 　bih.biXPelsPerMeter = 0;<br> 　bih.biYPelsPerMeter = 0;<br> 　//calculate total size of RGBQUAD scanlines (DWORD aligned)<br> 　bih.biSizeImage = (((bih.biWidth * 3) + 3) &amp; 0xFFFC) * bih.biHeight ;<br> <br> 　PGETFRAME pFrame;<br> 　pFrame=AVIStreamGetFrameOpen(pStream, NULL );<br> <br> 　AVISTREAMINFO streaminfo;<br> 　AVIStreamInfo(pStream,&amp;streaminfo,sizeof(AVISTREAMINFO));<br> <br> 　//Get the first frame<br> 　BITMAPINFOHEADER bih2;<br> 　long lsize = sizeof(bih2);<br> 　int index="0";<br> 　for (int i="iFirstFrame"; i&lt;iNumFrames; i++)<br> 　{<!-- --><br> 　　index= i-iFirstFrame;<br> 　　BYTE* pDIB = (BYTE*) AVIStreamGetFrame(pFrame, index); //<br> 　　AVIStreamReadFormat(pStream,index,&amp;bih2,&amp;lsize);<br> 　　BITMAPFILEHEADER stFileHdr;<br> <br> 　　BYTE* Bits="new" BYTE[bih2.biSizeImage];<br> 　　AVIStreamRead(pStream,index,1,Bits,bih2.biSizeImage,NULL,NULL);<br> 　　//RtlMoveMemory(Bits, pDIB + sizeof(BITMAPINFOHEADER), bih2.biSizeImage);<br> <br> 　　bih2.biClrUsed =0;<br> 　　stFileHdr.bfOffBits=sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER);<br> 　　stFileHdr.bfSize=sizeof(BITMAPFILEHEADER);<br> 　　stFileHdr.bfType=0x4d42; <br> <br> 　　CString FileName;<br> 　　FileName.Format("Frame-%05d.bmp", index);<br> 　　CString strtemp = strBmpDir;<br> 　　strtemp += "\\";<br> 　　strtemp += FileName;<br> 　　FILE* fp=_tfopen(strtemp ,_T("wb"));<br> 　　fwrite(&amp;stFileHdr,1,sizeof(BITMAPFILEHEADER),fp);<br> 　　fwrite(&amp;bih2,1,sizeof(BITMAPINFOHEADER),fp);<br> 　　int ff = fwrite(Bits,1,bih2.biSizeImage,fp);<br> 　　int e = GetLastError();<br> 　　fclose(fp);<br> 　　/<br> 　　delete Bits;<br> 　　//CreateFromPackedDIBPointer(pDIB, index);<br> 　}<br> <br> 　AVIStreamGetFrameClose(pFrame);<br> <br> 　//close the stream after finishing the task<br> 　if (pStream!=NULL)<br> 　　AVIStreamRelease(pStream);<br> 　AVIFileExit();<br> }</span></td></tr></tbody></table> 
   <span style="font-size:16px"><br> 　　下面的这个函数演示了如何将AVI文件中的每一桢图像单独取出来，保存为bmp文件。函数的头一个参数是avi文件名，第二个参数是存放bmp文件的文件夹。<br> <br> </span> 
   <table border="1" width="90%" bgcolor="#e3e3e3" align="center"><tbody><tr><td><span style="font-size:16px">//生成avi<br> void Cbmp2aviDlg::BMPtoAVI(CString szAVIName, CString strBmpDir)<br> {<!-- --><br> 　CFileFind finder;<br> 　strBmpDir += _T("\\*.*"); <br> 　AVIFileInit(); <br> 　AVISTREAMINFO strhdr;<br> 　PAVIFILE pfile;<br> 　PAVISTREAM ps; <br> 　int nFrames =0; <br> 　HRESULT hr; <br> <br> 　BOOL bFind = finder.FindFile(strBmpDir);<br> 　while(bFind)<br> 　{<!-- --><br> 　　bFind = finder.FindNextFile();<br> 　　if(!finder.IsDots() &amp;&amp; !finder.IsDirectory())<br> 　　{<!-- --><br> 　　　CString str = finder.GetFilePath();<br> 　　　FILE *fp = fopen(str,"rb");<br> 　　　BITMAPFILEHEADER bmpFileHdr;<br> 　　　BITMAPINFOHEADER bmpInfoHdr;<br> 　　　fseek( fp,0,SEEK_SET);<br> 　　　fread(&amp;bmpFileHdr,sizeof(BITMAPFILEHEADER),1, fp);<br> 　　　fread(&amp;bmpInfoHdr,sizeof(BITMAPINFOHEADER),1, fp);<br> <br> 　　　BYTE *tmp_buf = NULL;<br> 　　　if(nFrames ==0 )<br> 　　　{<!-- --><br> 　　　　AVIFileOpen(&amp;pfile,szAviName,OF_WRITE | OF_CREATE,NULL);<br> 　　　　_fmemset(&amp;strhdr, 0, sizeof(strhdr));<br> 　　　　strhdr.fccType = streamtypeVIDEO;// stream type<br> 　　　　strhdr.fccHandler = 0;<br> 　　　　strhdr.dwScale = 1;<br> 　　　　strhdr.dwRate = 15; // 15 fps<br> 　　　　strhdr.dwSuggestedBufferSize = bmpInfoHdr.biSizeImage ;<br> 　　　　SetRect(&amp;strhdr.rcFrame, 0, 0, bmpInfoHdr.biWidth, bmpInfoHdr.biHeight);<br> <br> 　　　　// And create the stream;<br> 　　　　hr = AVIFileCreateStream(pfile,&amp;ps,&amp;strhdr); <br> 　　　　// hr = AVIStreamSetFormat(ps,nFrames,&amp;bmpInfoHdr,sizeof(bmpInfoHdr));<br> 　　　}<br> 　　　tmp_buf = new BYTE[bmpInfoHdr.biWidth * bmpInfoHdr.biHeight * 3];<br> 　　　fread(tmp_buf, 1, bmpInfoHdr.biWidth * bmpInfoHdr.biHeight * 3, fp);<br> 　　　hr = AVIStreamSetFormat(ps,nFrames,&amp;bmpInfoHdr,sizeof(bmpInfoHdr));<br> 　　　hr = AVIStreamWrite(ps, // stream pointer<br> 　　　　　　nFrames , // time of this frame<br> 　　　　　　1, // number to write<br> 　　　　　　(LPBYTE) tmp_buf,<br> 　　　　　　bmpInfoHdr.biSizeImage , // size of this frame<br> 　　　　　　AVIIF_KEYFRAME, // flags....<br> 　　　　　　NULL,<br> 　　　　　　NULL);<br> <br> 　　　nFrames ++; <br> 　　　fclose(fp);<br> 　　}<br> 　}<br> <br> 　AVIStreamClose(ps);<br> <br> 　if(pfile != NULL)<br> 　　AVIFileRelease(pfile);<br> 　AVIFileExit();<br> }</span></td></tr></tbody></table> 
   <span style="font-size:16px"><br> 　　<strong>结束语：</strong><br> <br> 　 　以上代码在 vc 6.0 和windows xp平台调试通过。这两个函数你可以直接在你的程序中使用，更详细的代码可以参见随着本文附上的示例源码。这里我要指出的是，这个AVI文件和bmp互相 转换过程中，avi中的视频数据都是存放的是没有压缩的数据，如果你要分解AVI文件是经过压缩编码，比如，DVSD，MPEG4编码，首先你要采用相应 的解码器对视频数据解码，然后将解码过的数据保存为bmp文件。好了，关于avi文件的介绍就到这里结束了. </span> 
   <p></p> 
  </div> 
  <div>
      
  </div> 
  <div> 
   <p>typedef struct {<!-- --></p> 
   <p>    DWORD fccType;       </p> 
   <p>    DWORD fccHandler; </p> 
   <p>    DWORD dwFlags; </p> 
   <p>    DWORD dwCaps; </p> 
   <p>    WORD wPriority; </p> 
   <p>    WORD wLanguage; </p> 
   <p>    DWORD dwScale; </p> 
   <p>    DWORD dwRate; </p> 
   <p>    DWORD dwStart; </p> 
   <p>    DWORD dwLength; </p> 
   <p>    DWORD dwInitialFrames; </p> 
   <p>    DWORD dwSuggestedBufferSize; </p> 
   <p>    DWORD dwQuality; </p> 
   <p>    DWORD dwSampleSize; </p> 
   <p>    RECT rcFrame; </p> 
   <p>    DWORD dwEditCount; </p> 
   <p>    DWORD dwFormatChangeCount; </p> 
   <p>    TCHAR szName[64]; </p> 
   <p>} AVISTREAMINFO</p> 
  </div> 
 </div> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/239a708a4b6f57b452d8e42da2cd8734/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python 与IronPython 简介与资源</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3e0f8263b42257d5201ff3628819af9c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">OpenInventor zoom in &amp; zoom out实现方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>