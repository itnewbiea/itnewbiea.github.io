<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>03-LoadRunner常见问题及实现 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="03-LoadRunner常见问题及实现" />
<meta property="og:description" content="1. 常见问题 1.1. 日志查看 1) 打开扩展日志，勾选runtimesettings---&gt;log--&gt;always send messages和extendedlog；
2) 使用lr_output_message,lr_error_message,lr_log_message函数打印日志；
3) 查看mdrv.log和output.txt文件。
1.2. 造成HTTP－500错误 1) 运行的用户数过多，对服务器造成的压力过大，服务器无法响应，则报HTTP500错误。减小用户数或者场景持续时间；
2) 该做关联的地方没有去做关联，则报HTTP500错误。进行手工或者自动关联；
3) 录制时请求的页面、图片等，在回放的时候服务器找不到，则报HTTP500错误，若该页面无关紧要，则可以在脚本中注释掉；
4) 参数化时的取值有问题，则报HTTP500错误。可将参数化列表中的数值，拿到实际应用系统中进行测试，可排除问题；
5) 更换了应用服务器（中间件的更换，如tomcat、websphere、jboss等），还是利用原先录制的脚本去运行，则很可能报HTTP500错误。因为各种应用服务器处理的机制不一样，所录制的脚本也不一样，解决办法只有重新录制脚本；
6) Windows xp2 与ISS组件不兼容，则有可能导致HTTP500错误。对ISS组件进行调整后问题解决；
1.3. 解决数据库查询结果过大，导致录制失败 c:\windows或者c:\winnt目录下寻找vugen.ini文件，修改
[SQLOracleInspector]
CmdSize=100000 （C:\ProgramFiles\HP\LoadRunner\config）
LR默认查询的数据大小为：55000，如果你一次性查询数据超过此范围的话，你可以修改此选项
其中不同协议的数据修改节为：
ODBC - [ODBCInspector]
Ctlib - [SQLCTLibInspector]
Dblib - [SQLDBLibInspector]
Informix - [SQLInspector]
DB2 - [DB2CLIInspector] 1.4. 将connect()中的密文改为明文 修改vugen.ini文件中
[LRDCodeGeneration]
AutoPasswordEncryption=OFF
1.5. 添加并运用附加变量 通过选择【Rum-timeSetting】&gt;【General】&gt;【Additional attributes】项，添加需要的参数
代码如下：
Action()
{
LPCSTRhost;
host= lr_get_attrib_string(&#34;hostname&#34;);
lr_output_message(&#34;附加变量:%s&#34;,host);
return0;
}" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/be2afde3a9cf534781fcbb585bb40498/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-01-21T10:07:37+08:00" />
<meta property="article:modified_time" content="2015-01-21T10:07:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">03-LoadRunner常见问题及实现</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.  常见问题</h2> 
<h3>1.1. 日志查看</h3> 
<p>1)   打开扩展日志，勾选runtimesettings---&gt;log--&gt;always send messages和extendedlog；</p> 
<p>2)   使用lr_output_message,lr_error_message,lr_log_message函数打印日志；</p> 
<p>3)   查看mdrv.log和output.txt文件。</p> 
<h3>1.2. 造成HTTP－500错误</h3> 
<p>1)   运行的用户数过多，对服务器造成的压力过大，服务器无法响应，则报HTTP500错误。减小用户数或者场景持续时间；</p> 
<p>2)   该做关联的地方没有去做关联，则报HTTP500错误。进行手工或者自动关联；</p> 
<p>3)   录制时请求的页面、图片等，在回放的时候服务器找不到，则报HTTP500错误，若该页面无关紧要，则可以在脚本中注释掉；</p> 
<p>4)   参数化时的取值有问题，则报HTTP500错误。可将参数化列表中的数值，拿到实际应用系统中进行测试，可排除问题；</p> 
<p>5)   更换了应用服务器（中间件的更换，如tomcat、websphere、jboss等），还是利用原先录制的脚本去运行，则很可能报HTTP500错误。因为各种应用服务器处理的机制不一样，所录制的脚本也不一样，解决办法只有重新录制脚本；</p> 
<p>6)   Windows xp2 与ISS组件不兼容，则有可能导致HTTP500错误。对ISS组件进行调整后问题解决；</p> 
<h3>1.3. 解决数据库查询结果过大，导致录制失败</h3> 
<p>c:\windows或者c:\winnt目录下寻找vugen.ini文件，修改</p> 
<p>[SQLOracleInspector]</p> 
<p>CmdSize=100000 </p> 
<p><em>（C:\ProgramFiles\HP\LoadRunner\config）</em></p> 
<p>LR默认查询的数据大小为：55000，如果你一次性查询数据超过此范围的话，你可以修改此选项</p> 
<p>其中不同协议的数据修改节为：</p> 
<p>ODBC - [ODBCInspector]</p> 
<p>Ctlib - [SQLCTLibInspector]</p> 
<p>Dblib - [SQLDBLibInspector]</p> 
<p>Informix - [SQLInspector]</p> 
<p>DB2 - [DB2CLIInspector] </p> 
<h3>1.4. 将connect()中的密文改为明文</h3> 
<p>修改vugen.ini文件中</p> 
<p>[LRDCodeGeneration]</p> 
<p>AutoPasswordEncryption=OFF</p> 
<h3>1.5. 添加并运用附加变量</h3> 
<p>通过选择【Rum-timeSetting】&gt;【General】&gt;【Additional attributes】项，添加需要的参数</p> 
<p></p> 
<p> </p> 
<p>代码如下：</p> 
<p>Action()</p> 
<p>{<!-- --></p> 
<p>       LPCSTRhost;</p> 
<p>       host= lr_get_attrib_string("hostname");</p> 
<p>       lr_output_message("附加变量:%s",host);</p> 
<p>       return0;</p> 
<p>}</p> 
<p> </p> 
<p>通过mdrv命令行输入相应的参数：</p> 
<p align="left">Mdrv.exe-usr <em>D:\LR_WORK\additional_test\additional_test.usr</em> -out <em>D:\LR_WORK\additional_test\out</em>-hostname <em>testhost</em></p> 
<h3>1.6. 线程和进程运行方式不同点</h3> 
<p align="left">1)       线程方式只限于协议是线程安全的</p> 
<p align="left">2)       按线程运行vuser，controller为每50个vuser（默认）仅启动一个mdrv.exe实例。</p> 
<p align="left">l  QTWeb.lrp中添加MaxThreadPerProcess=vuser</p> 
<h3>1.7. 如何理解return的返回值</h3> 
<p align="left">Return标识一个过程的结束，返回大于等于0都表示成功，反之失败。</p> 
<h3>1.8. 按顺序执行多个场景</h3> 
<p>编辑一个bat文件，如下：</p> 
<p> </p> 
<p>   SET LR_PATH="D:\Mercury\LoadRunner\bin\wlrun.exe"</p> 
<p>%LR_PATH%\wlrun.exe -TestPath "E:\Test\Scenario01.lrs"-Run</p> 
<p>   %LR_PATH%\wlrun.exe -TestPath "E:\Test\Scenario02.lrs" -Run</p> 
<p>%LR_PATH%\wlrun.exe -TestPath "E:\Test\Scenario03.lrs"-Run</p> 
<p> </p> 
<p>TestPath ：  场景的路径</p> 
<p>Run ：运行场景，将输入信息存储到output.txt文件中，并关闭control</p> 
<p>InvokeAnalysis ：指示LR在场景执行完后调用analysis，没有指定该参数将使用场景默认设置</p> 
<p>Resultname ：完整结束路径</p> 
<p>Resultcleanname ： 结果名</p> 
<p>Resultlocation ：结果目录</p> 
<h3>1.9. 场景执行中超时设置</h3> 
<p>【Run-TimeSetting】&gt;【internet protocol】&gt;【Perferences】&gt;【options】</p> 
<p>1)       错误timeout( seconds) exceeded while attempting to establish connectionto host……</p> 
<p>增加HTTP-request connect timeout</p> 
<p>2)       错误timeout exceeded while waiting to receive data fo url “http……</p> 
<p>增加HTTP-request receive timeout</p> 
<p>3)       错误 download timeout has expired……</p> 
<p>增加 Stepdownload timeout(sec)</p> 
<h3>1.10.  设置域权限的登录</h3> 
<p>当网站使用了基于windows认证方式的权限访问机制，对于操作过程中，弹出的登录窗口，LR录制不到登录信息。</p> 
<p>Web_set_proxy(“127.0.0.1:8080”); //设置代理</p> 
<p>web_set_user("tomcat","tomcat","192.168.0.228:8006");//设置登录信息</p> 
<h3>1.11.  loadrunner面向目标场景设计</h3> 
<p><strong>Virtual Users Goal</strong></p> 
<p>如果需要测试多少人可以同时运行Web 应用，那么推荐定义Virtual Users Goal。运行定</p> 
<p>义该目标类型的场景和运行Manual 类型的场景类似。</p> 
<p><strong>Hits per Second</strong></p> 
<p>如果衡量的是系统的负载处理能力，推荐定义目标类型为：Hitsper Second、Pages per</p> 
<p>Minute 或者Transactionsper Second，这些类型都需要指定一个虚拟用户的最小值和最大值的范围。</p> 
<p><strong>Transactions Response Time</strong></p> 
<p>如果想知道在多少用户并发访问网站时，事务的响应时间达到性能指标说明书中规定响应时间的最大值，那么推荐使用Transactions Response Time 类型。指定需要测试的事务的名称，虚拟用户数量的最小值和最大值，还有预先定义好的事务的响应时间。</p> 
<p><strong>理解各种类型</strong></p> 
<p>如果你定义的类型是 Pages per Minute、Hits/Transactions per Second，Controller 首先用最小用户数除以定义的目标，得到一个值，然后确定每个用户应该达到的hits/transactions或者pages per minute，然后controller 开始按照以下的策略加载用户：</p> 
<p>1)  如果选择的是自动的加载虚拟用户，LoadRunner 会首先加载50个用户。如果定义的最大用户数小于50，LoadRunner 就会一次加载所有的虚拟用户。</p> 
<p>2)  如果选择的是在场景运行一段时间后达到目标，LoadRunner 就会尝试在定义的这段时间内达到目标，根据时间限制和计算出的每个用户的hits、transactions 或者pages，LoadRunner 确定第一批加载多少用户。</p> 
<p>3)  如果选择的是按照一定的阶段达到目标（也就是先在x 长时间内达到ypages/hits，然后再达到下一个目标），LoadRunner 计算每个用户应该达到的数字后，再确定第一批加载多少用户。</p> 
<p>每加载一批用户后，LoadRunner 会判断是否达到这批用户的目标。如果这批用户的目</p> 
<p>标没有达到，LoadRunner 重新计算每一个用户应该达到的目标数字后，重新调整下一批加</p> 
<p>载用户的数量。默认情况下，LoadRunner 每两分钟加载一批用户。</p> 
<p>如果 Controller 加载了最多数量的用户还没有达到预定的目标，LoadRunner 会重新计算</p> 
<p>每个用户的目标，然后同时运行最大数量的用户，尝试达到预定的目标。</p> 
<h3>1.12.  详解lr参数表中的参数分配规则</h3> 
<div align="center"> 
 <table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p align="left">Select next row</p> </td><td> <p align="left">Update value on</p> </td><td> <p align="left"> </p> </td></tr><tr><td rowspan="3"> <p align="left"> </p> <p align="left">Sequential</p> </td><td> <p align="left">Each iteration</p> </td><td> <p align="left">每次执行Action时，参数值改变。</p> <p align="left">每个Vuser的参数取值都一样。</p> </td></tr><tr><td> <p align="left">Each occurrence</p> </td><td> <p align="left">每次取参数时，参数值改变。</p> <p align="left">每个Vuser的参数取值都一样。</p> </td></tr><tr><td> <p align="left">Once</p> </td><td> <p align="left">唯一</p> </td></tr><tr><td> <p align="left">Random</p> </td><td> <p align="left"> </p> </td><td> <p align="left">自由选取参数</p> </td></tr><tr><td rowspan="3"> <p align="left"> </p> <p align="left"> </p> <p align="left"> </p> <p align="left">Unique</p> </td><td> <p align="left">Each iteration</p> </td><td> <p align="left">每次执行Action时，参数值改变。</p> <p align="left">在Allocate Vuser values in the Controller中</p> <p align="left">可选择“自动”和“手动”分配。</p> <p align="left">“自动”分配把参数平均分给每个Vuser。</p> <p align="left">Controller中edit schedule中run until comletion:按照循环次数先分配第一个VU（例如设置的循环次数为3，那分配给第一个VU 3个参数值），然后接下来的3个参数值分配给第二个VU,依次类推…...</p> <p align="left">“手动”分配时，参数不够的话，压力<u><span style="color:blue"><a target="_blank" href="http://i.cn.yahoo.com/ealin99/blog/p_59/#;#;" rel="nofollow noopener noreferrer"><strong><span style="color:blue">测试</span></strong></a></span></u>时会报错。</p> </td></tr><tr><td> <p align="left">Each occurrence</p> </td><td> <p align="left">每次取参数时，参数值改变。</p> <p align="left">只有“手动”分配。参数不够，测试时报错。</p> </td></tr><tr><td> <p align="left">Once</p> </td><td> <p align="left">唯一</p> </td></tr><tr><td rowspan="3"> <p align="left"> </p> <p align="left">When out of values</p> </td><td> <p align="left">Abort Vuser</p> </td><td> <p align="left">结束Vuser</p> </td></tr><tr><td> <p align="left">Continue in a cyclic manner</p> </td><td> <p align="left">使用同样的循环样式继续</p> </td></tr><tr><td> <p align="left">Continue with last value</p> </td><td> <p align="left">使用最后一个参数值继续</p> </td></tr></tbody></table> 
</div> 
<p align="left">注释：</p> 
<p align="left">iteration: 在Run-time Settings中对Number of Iterations进行设置，即每次运行脚本时，Action反复执行的次数。</p> 
<p align="left">occurrence:在一个Action中出现2次以上的同一个参数表。</p> 
<p align="left">Updatevalue on <br> --Each Occurrence：只要发现该参数就重新取值（用于各处引用参数都不相关时）<br> --Each iteration：每次反复都要取新值（各个并发会共享同一个值，用于多次引用参数且相关的情况） <br> --Once：在所有的反复中都使用同一个值（仅在场景初始化时产生一次，在一个场景中的所有并发和所有反复的值都相同）</p> 
<p align="left">注意：</p> 
<p align="left">当在脚本中使用lr_message ，lr_ouput_message输出参数值时，例如lr_message(“result=%s”,lr_eval_string(“{NewParam}”),参数表也会给这个语句中的{NewParam}分配一个参数值。</p> 
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td> <p align="center">Select next row</p> </td><td> <p align="center">Update Value on</p> </td><td> <p align="center">实际运行结果</p> </td></tr><tr><td> <p align="center">sequential</p> </td><td> <p align="center">each iteration</p> </td><td> <p align="left">在某次循环中所有用户取值相同。<br> 所有用户第一次循环取第一行值，第二次循环取第二行值</p> </td></tr><tr><td> <p align="center"> </p> </td><td> <p align="center">each occurrence</p> </td><td> <p align="left">在某次循环中或者脚本中使用参数的地方，所有用户取值相同。<br> 脚本中出现要使用参数的话，参数值就更新一次，循环一次值再更新一次。</p> </td></tr><tr><td> <p align="center"> </p> </td><td> <p align="center">once</p> </td><td> <p align="left">在所有的循环中所有用户取值相同。<br> 所有的用户所有的循环中，只用一个值（即参数中的第一行值）</p> </td></tr><tr><td> <p align="center">random</p> </td><td> <p align="center">each iteration</p> </td><td> <p align="left">不同的用户，在不同的循环次数中，随机取值</p> </td></tr><tr><td> <p align="center"> </p> </td><td> <p align="center">each occurrence</p> </td><td> <p align="left">不同的用户，脚本中出现要使用参数的话，随机取值一次，循环一次再随机取值一次</p> </td></tr><tr><td> <p align="center"> </p> </td><td> <p align="center">once</p> </td><td> <p align="left">不同的用户，不管循环多少次，只随机取值一次。</p> </td></tr><tr><td> <p align="center">unique</p> </td><td> <p align="center">each iteration</p> </td><td> <p align="left">若选择手工自配参数，那LR按照每用户几个参数先分配参数，然后进行循环。 <br> 若选择自动分配参数：<br> Controller中edit schedule中run until comletion:按照循环次数先分配第一个VU（例如设置的循环次数为3，那分配给第一个VU 3个参数值），然后接下来的3个参数值分配给第二个VU,依次类推…...<br> Controller中edit schedule中run for:若选择自动分配，LR将按照用户数均分参数，剩余的参数不使用。</p> </td></tr><tr><td> <p align="center"> </p> </td><td> <p align="center">each occurrence</p> </td><td> <p align="left">只能手工分配用户，给每个用户分配好X个参数后，在脚本中有参数的地方，就使用已经分配好的X个参数。</p> </td></tr><tr><td> <p align="center"> </p> </td><td> <p align="center">once</p> </td><td> <p align="left">按照用户数分配给每个用户分配一个参数而已。以后的循环这个用户就使用这一个参数</p> </td></tr></tbody></table> 
<p> </p> 
<h3>1.13.  关于思考时间</h3> 
<p>1)  virtual user generator（脚本录制与设置）</p> 
<p>       1、在录制脚本的时候LoadRunner会自动记录录制者在录制软件系统时实际操作的思考时间，并在系统中以lr_thingk_time(x);函数表现。这里的思考时间如登录操作：LoadRunner打开了登录界面后开始记录思考时间，包括录制者输入用户名，密码；或去干其他事。直到录制者点击登录按钮，整个这段时间都被LoadRunner记录为思考时间。</p> 
<p>       2、回放录制脚本时，在Vuser-&gt;Run-time Setting-&gt;ThinkTime设置回放脚本时思考时间的使用。</p> 
<p>             lgnore think time：忽略脚本中的思考时间。</p> 
<p>             As recorded：根据脚本中实际的思考时间进行回放。</p> 
<p>             Multiply recorded think time by：将录制的思考时间乘以一个系数，系数在后面设置。</p> 
<p>             Use random percentage of recordedthink time：随机获取思考时间，指定一个最小值和一个最大值，可设置Think Time值的范围，通过指定Think Time的范围，取其中的一个随机数的值来回放脚本。</p> 
<p>　　例如，如果Think Time参数为4，并且指定最小值为该值的50%，而最大值为该值的150%，则Think Time的最小值为2（50%），而最大值为6（150%）。</p> 
<p>              Limit think time to：忽略脚本中的思考时间，执行这里设置的思考时间。</p> 
<p>注意：如果这里不对思考时间进行设置，也就是默认忽略思考时间的话只影响回放脚本时操作，不影响场景执行的时候。只有对思考时间进行了设置，场景执行时才会有效。</p> 
<p> </p> 
<p>2)  Controller（场景设置与执行）</p> 
<p>        1、场景设置中没有对思考时间的设置，如果在脚本设置中设置了思考时间那么场景会按设置的思考时间执行，如果脚本设置中默认忽略思考时间，那么在执行场景时LoadRunner会默认按录制时的思考时间执行，事务响应时间中包括了思考时间。</p> 
<p> </p> 
<p>3)  Analysis（结果分析）</p> 
<p>         1、结果分析中可以对思考时间进行设置，是否在事务响应时间中添加思考时间或是去掉思考时间。</p> 
<p>         2、设置是否计算思考时间：File-&gt;set GlobalFilter中选择Think Time设置项，将lncludethink time值去掉勾选。这样分析中会自动将思考时间去除，这样更清楚，明确的分析系统事物的响应时。</p> 
<p> </p> 
<p><em>Think Time，从业务角度来看，这个时间指用户进行操作时每个请求之间的时间间隔，而在做新能测试时，为了模拟这样的时间间隔，引入了思考时间这个概念，来更加真实的模拟用户的操作。在吞吐量这个公式中F=VU* R / T说明吞吐量F是VU数量、每个用户发出的请求数R和时间T的函数，而其中的R又可以用时间T和用户思考时间TS来计算：R = T / TS  下面给出一个计算思考时间的一般步骤： </em></p> 
<p><em>A、首先计算出系统的并发用户数 C=nL / T     F=R×C </em></p> 
<p><em>B、统计出系统平均的吞吐量     F=VU * R / T     R×C = VU * R / T </em></p> 
<p><em>C、统计出平均每个用户发出的请求数量  R=u*C*T/VU </em></p> 
<p><em>D、根据公式计算出思考时间 TS=T/R </em> </p> 
<h2>2.   WebService接口测试</h2> 
<h3>2.1. 基于webservice协议录制</h3> 
<p>1)       新建脚本选择webservice协议</p> 
<p>2)       添加服务</p> 
<p></p> 
<p>3)       录制测试脚本</p> 
<p></p> 
<p>4)       参数化qqCode</p> 
<p>       web_service_call("StepName=qqCheckOnline_101",</p> 
<p>              "SOAPMethod=qqOnlineWebService|qqOnlineWebServiceSoap|qqCheckOnline",</p> 
<p>              "ResponseParam=response",</p> 
<p>              "Service=qqOnlineWebService",</p> 
<p>              "ExpectedResponse=SoapResult",</p> 
<p>              "Snapshot=t1359010300.inf",</p> 
<p>              BEGIN_ARGUMENTS,</p> 
<p>              "qqCode=<strong><span style="color:blue">584075421</span></strong>",</p> 
<p>              END_ARGUMENTS,</p> 
<p>              BEGIN_RESULT,</p> 
<p>              "qqCheckOnlineResult=Param_qqCheckOnlineResult",</p> 
<p>              END_RESULT,</p> 
<p>              LAST);</p> 
<p>       lr_output_message(lr_eval_string("\n基于webservice_call方式QQ状态 = {Param_qqCheckOnlineResult}"));</p> 
<h3>2.2. 基于SOAP请求编写脚本</h3> 
<p>1)       查看发布的接口说明</p> 
<p></p> 
<p>2)       导入保存的XML文件</p> 
<p></p> 
<p>3)       添加请求头，生成脚本</p> 
<p>       web_add_header("POST","/webservices/qqOnlineWebService.asmxHTTP/1.1");</p> 
<p>       web_add_header("Host","www.webxml.com.cn");</p> 
<p>       web_add_header("Content-Type","text/xml;charset=utf-8");</p> 
<p>l  SOAPAction要填写全路径http://WebXml.com.cn/qqCheckOnline</p> 
<h3>2.3. 基于HTTP协议</h3> 
<p>l  注意添加请求头</p> 
<p>       web_add_header("Host","www.webxml.com.cn");</p> 
<p>       web_add_header("Content-Type","text/xml; charset=utf-8");</p> 
<p>       web_add_header("Accept","application/soap+xml, application/dime,multipart/related, text/*");</p> 
<p>       web_add_header("SOAPAction","http://WebXml.com.cn/qqCheckOnline");</p> 
<h3>2.4. 获取返回XML文件中的值</h3> 
<p>l  使用<strong>lr_xml_get_values()函数</strong></p> 
<p><em>char * xml_input =<br> "&lt;acme_org&gt;"<br>      " &lt;accounts_dept&gt;"<br>           "&lt;employee&gt;"<br>                " &lt;name&gt;JohnSmith&lt;/name&gt;"<br>               "&lt;cubicle&gt;227&lt;/cubicle&gt;"<br>                "&lt;extension&gt;2145&lt;/extension&gt;"<br>           "&lt;/employee&gt;"<br>      "&lt;/accounts_dept&gt;"<br>      "&lt;engineering_dept&gt;"<br>           "&lt;employee&gt;"<br>                "&lt;name&gt;SueJones&lt;/name&gt;"<br>               "&lt;extension&gt;2375&lt;/extension&gt;"<br>           "&lt;/employee&gt;"<br>      "&lt;/engineering_dept&gt;"<br> "&lt;/acme_org&gt;";</em></p> 
<p><br> Action() {<!-- --><br>      int i, NumOfValues;<br>      char buf[64];<br>      lr_save_string(xml_input,"XML_Input_Param"); <br>      NumOfValues= <strong><span style="color:blue">lr_xml_get_values</span></strong>("XML={XML_Input_Param}",<br>          "ValueParam=OutputParam",<br>           "Query=/acme_org/*/employee/extension",<br>           "SelectAll=yes", LAST);<br>      for ( i = 0; i &lt; NumOfValues;i++) {<!-- --><br>           sprintf (buf, "Retrievedvalue %d : {OutputParam_%d}", i+1, i+1);<br>          lr_output_message(lr_eval_string(buf));<br>      }<br>      return 0;</p> 
<h2>3.   服务器监控</h2> 
<h3>3.1. 监控windows系统：</h3> 
<p>1.   监视连接前的准备工作</p> 
<p>        1）进入被监视windows系统，开启以下二个服务Remote Procedure Call(RPC) 和Remote RegistryService (开始—)运行 中输入services.msc，开启对应服务即可)。</p> 
<p>        2）在被监视的WINDOWS机器上:右击我的电脑,选择管理-&gt;共享文件夹-&gt;共享 在这里面要有C$这个共享文件夹 (要是没有自己手动加上)。</p> 
<p>        3）在安装LR的机器上，开始—》运行，输入 \\被监视机器IP\C$ 然后输入管理员帐号和密码,如果能看到被监视机器的C盘了,就说明你得到了那台机器的管理员权限,可以使用LR去连接了。（LR要连接WINDOWS机器进行监视要有管理员帐号和密码才行。）</p> 
<p>    问题：在执行步骤3）时，输入 \\被监视机器IP\C$，出现不能以administrator身份访问被监控系统（若采用这种方式用LR对其监控的话，会提示：“找不到网络路径”）的情况，现象就是用户名输入框是灰色的，并且默认用户是guest。</p> 
<p>    解决办法：这是安全策略的设置问题（管理工具 -&gt; 本地安全策略 -&gt; 安全选项 -&gt; "网络访问：本地帐户的共享和安全模式"）。默认情况下，XP的访问方式是"仅来宾"的方式，如果你访问它，当然就固定为Guest来访问，而guest账户没有监控的权限，所以要把访问方式改为“经典”模式，这样就可以以administrator的身份登陆了。修改后，再次执行步骤3），输入管理员用户名和密码，就可以访问被监控机器C盘了</p> 
<p>    若这样都不行的话（可能是其它问题引起的），那只好采取别的方法了。在服务器的机子上，通过windows自带的“性能日志和警报”下的“计数器日志”中新增加一个监控日志（管理工具—）性能—）性能日志和警报），配置好日志，也能监控服务器的cpu、memory、disk等计数器。当然，这种方法就不是用LR来监控了。</p> 
<p>2.   用LR监视windows的步骤</p> 
<p>    在controller 中，Windows Resources窗口中右击鼠标选择Add Measurements，添加被监控windows的IP地址，选择所属系统，然后选择需要监控的指标就可以开始监控了。</p> 
<h3>3.2. 监控linux</h3> 
<p>1.  准备工作</p> 
<p>   可以通过两种方法验证服务器上是否配置了rstatd守护程序：</p> 
<p>    ①使用rup命令，它用于报告计算机的各种统计信息，其中就包括rstatd的配置信息。使用命令rup 10.130.61.203,此处10.130.61.203是要监视的linux/Unix服务器的Ip，如果该命令返回相关的统计信息。则表示已经配置并且激活了rstatd守护进程；若未返回有意义的统计信息，或者出现一条错误报告，则表示rstatd守护进程尚未被配置或有问题。</p> 
<p>    ②使用find命令</p> 
<p>#find / -name rpc.rstatd,该命令用于查找系统中是否存在rpc.rstatd文件，如果没有，说明系统没有安装rstatd守护程序。</p> 
<p>    如果服务器上没有安装rstatd程序（一般来说LINUX都没有安装），需要下载一个包才有这个服务,包名字是rpc.rstatd-4.0.1.tar.gz. 这是一个源码,需要编译,下载并安装rstatd（可以在http://sourceforge.net/projects/rstatd这个地址下载）</p> 
<p>下载后，开始安装，安装步骤如下：</p> 
<p>tar -xzvf  rpc.rstatd-4.0.1.tar.gz</p> 
<p>cd  rpc.rstatd-4.0.1/</p> 
<p>./configure  —配置操作</p> 
<p>make —进行编译</p> 
<p>make install —开始安装</p> 
<p>rpc.rstatd —启动rstatd进程</p> 
<p> </p> 
<p>2.  安装完成后配置rstatd 目标守护进程xinetd,它的主配置文件是/etc/xinetd.conf ,它里面内容是一些如下的基本信息：</p> 
<p>#</p> 
<p># xinetd.conf</p> 
<p>#</p> 
<p># Copyright (c) 1998-2001 SuSEGmbH Nuernberg, Germany.</p> 
<p># Copyright (c) 2002 SuSE LinuxAG, Nuernberg, Germany.</p> 
<p>#</p> 
<p>defaults</p> 
<p>{<!-- --></p> 
<p>        log_type        = FILE /var/log/xinetd.log</p> 
<p>        log_on_success  = HOST EXIT DURATION</p> 
<p>        log_on_failure  = HOST ATTEMPT</p> 
<p>#        only_from       = localhost</p> 
<p>        instances       = 30</p> 
<p>        cps             = 50 10</p> 
<p>#</p> 
<p># The specification of aninterface is interesting, if we are on a firewall.</p> 
<p># For example, if you only wantto provide services from an internal</p> 
<p># network interface, you mayspecify your internal interfaces IP-Address.</p> 
<p>#</p> 
<p>#       interface       = 127.0.0.1</p> 
<p>}</p> 
<p>includedir /etc/xinetd.d</p> 
<p>我们这里需要修改的是/etc/xinetd.d/下的三个conf文件 rlogin ,rsh,rexec 这三个配置文件,打这三个文件里的disable = yes都改成 disable = no ( disabled 用在默认的 {} 中 禁止服务)或是把# default: off都设置成 on 这个的意思就是在xinetd启动的时候默认都启动上面的三个服务!</p> 
<p> 说明：我自己在配置时，没有disable = yes这项，我就将# default: off改为：default: on，重启后(cd /etc/init.d/     ./xinetd restart）通过netstat -an |grep 514查看，没有返回。然后，我就手动在三个文件中最后一行加入disable = no，再重启xinetd，再使用netstat -an |grep 514查看，得到tcp 0 0 0.0.0.0:5140.0.0.0:* LISTEN结果，表明rsh服务器已经启动。</p> 
<p>     只要保证Linux机器上的进程里有rstatd和xinetd这二个服务就可以用LR去监视了</p> 
<p><strong>两点小的技巧:</strong></p> 
<p>①检查是否启动: rsh server 监听的TCP 是514。</p> 
<p>[root@mg04 root]# netstat -an|grep 514</p> 
<p>tcp 0 0 0.0.0.0:5140.0.0.0:* LISTEN</p> 
<p>如果能看到514在监听说明rsh服务器已经启动。</p> 
<p>②检查是否启动: rstatd</p> 
<p>输入命令: rpcinfo -p</p> 
<p>如果能看到类似如下信息：</p> 
<p>程序 版本 协议 端口</p> 
<p>100001    5  udp    937  rstatd</p> 
<p>100001    4   udp    937 rstatd</p> 
<p>100001    3  udp    937  rstatd</p> 
<p>100001    2  udp    937  rstatd</p> 
<p>100001    1  udp    937  rstatd</p> 
<p>那就说明rstatd服务启动了,(当然这里也可以用ps ax代替)</p> 
<p>③重起xinetd方法：</p> 
<p>在suse linux如下操作：</p> 
<p>cd /etc/init.d/</p> 
<p>./xinetd restart</p> 
<p>看到网上有的地方说使用如下命令：</p> 
<p># service xinetd reload</p> 
<p># /sbin/service xinetd rstart </p> 
<p>不知道是在什么系统用的。</p> 
<p>④安装rsh，和rsh-server两个服务包方法 </p> 
<p>a. 卸载rsh </p> 
<p># rpm –qrsh----------查看版本号 </p> 
<p># rpm -e 版本号---------卸载该版本。 </p> 
<p>b．安装 </p> 
<p># rpm –ivhrsh-0.17-14.i386.rpm rsh-server-0.17-14.i386.rpm </p> 
<p>⑤在启动rpc.rstatd时，会报错“Cannot register service: RPC: Unable to receive; errno = Ctionrefused”。 </p> 
<p>解决方法如下： </p> 
<p># /etc/init.d ./portmap start </p> 
<p># /etc/init.d ./nfs start </p> 
<p>然后再次启动rpc.rstatd就好了。 </p> 
<p>最后，在controller中，将UNIX resources拖放到右边窗口里面，右击鼠标选择AddMeasurements，添加被监控linux的IP地址，然后选择需要监控的指标就可以了。</p> 
<h3>3.3. 监控UNIX</h3> 
<p>lr监控UNIX ，UNIX先启动一rstatd服务 </p> 
<p>以下是在IBM AIX系统中启动rstatd服务的方法：</p> 
<p>1.  使用telnet以root用户的身份登录入AIX系统</p> 
<p>2.  在命令行提示符下输入：vi /etc/inetd.conf</p> 
<p>3.  查找rstatd，找到#rstatd  sunrpc_udp udp  wait  root /usr/sbin/rpc.rstatd rstatd 100001 1-3</p> 
<p>4.  将#去掉，保存修改结果</p> 
<p>5.  命令提示符下输入：refresh –s inetd 重新启动服务。</p> 
<p><strong>注：</strong>在HP UNIX系统上编辑完inetd.conf后，重启inetd服务需要输入inetd -c</p> 
<p>UNIX上也可以用rup命令查看rstatd程序是否被配置并激活</p> 
<p>若rstatd程序已经运行，重启时，先查看进程ps -ef |grep inet，然后杀掉进程，再refresh –s inetd进行重启</p> 
<h2>4.   虚拟IP</h2> 
<p>1)       虚拟IP</p> 
<p></p> 
<p></p> 
<p>2)  启用场景中的虚拟IP</p> 
<p></p> 
<p>启用成功后controller状态栏显示</p> 
<p>虚拟IP失败可能的处理方法：</p> 
<p>l  脚本RTS设置线程或者进程的运行方式跟场景中mutlilple IP address mode的方式不一致；</p> 
<p>l  LR机器不能使用动态IP；</p> 
<p>l  多网段时需要在服务器上添加路由，并验证虚拟的IP是否ping的通。</p> 
<p> </p> 
<h2>5.   LR数据库操作</h2> 
<h3>5.1. 基于WebService协议</h3> 
<p>lr_db_connect();  建议数据库连接</p> 
<p>lr_db_executeSQLStatement();   执行SQL语句</p> 
<p>lr_db_dataset_action();  操作数据集</p> 
<p>lr_db_getvalue();   检查数据</p> 
<p>lr_db_disconnect();  释放连接</p> 
<h3>5.2. 基于oracle2-tier协议录制</h3> 
<h3>5.3. 在C语言的使用Pro*C/C++, oci，oracleClient</h3> 
<h2>6.   HTML-based模式和URL-based模式的区别</h2> 
<p></p> 
<p><strong>HTML：</strong></p> 
<p>HTML-mode录制是缺省也是推荐的录制模式。它录制当前网页中的HTML动作。在录制会话过程中不会录制所有的资源。在回放时，HTML-mode脚本积极地解析返回的信息来获得要下载的资源。</p> 
<p>HTML-based 方式对每个页面录制形成一条语句，对LoadRunner来说，在该模式下，访问一个页面，首先会与服务器之间建立一个连接获取页面的内容，然后从页面中分解得到其他的元素（component），然后建立几个连接分别获取相应的元素。</p> 
<p>HTML-mode是亦称上下文敏感方式因为它只能在先前请求的结果的上下文之内执行。由于许多的HTTP 请求数据都是从内存中取出来的,所以语句必须在正确的前个请求之后执行。</p> 
<p>HTML-mode录制的优点是：<br> 1.资源从内存中取出且在回放时下载。因此，脚本比其他的录制方式更小且更容易阅读。<br> 2.由于只有较少的硬编码脚本，因此只有较少的动态数值需要关联。<br> 3.可以插入图片检查之类的语句以检查结果是否正确。<br> 4.因为HTML模式回放时需要积极地解析返回的信息,因此它可能会比其他录制模式更加占用资源。然而,HTML模式record/replay有相当大的改善,使得差异最小化且微不足道。 </p> 
<p><strong>URL：</strong></p> 
<p>URL-mode选项指导VuGen录制来自server的所有的请求和资源。它自动录制每一个HTTP资源为URL的步骤。这种录制模式甚至抓取非HTML应用程序，例如applets和非浏览器的应用程序。</p> 
<p>URL-based 方式将每条客户端发出的请求录制成一条语句，对LoadRunner来说，在该模式下，一条语句只建立一个到服务器的连接，LoadRunner提供了web_concurrent_start和web_concurrent_end函数模拟HTML-based的工作方式。<br> <strong>如何决定选择何种录制方式：</strong></p> 
<p>1)  基于浏览器的应用程序推荐使用HTML-BasedScript。</p> 
<p>2)  不是基于浏览器的应用程序推荐使用URL-BasedScript。</p> 
<p>3)  如果基于浏览器的应用程序中包含了JavaScript，applet等并且该脚本向服务器产生了请求，比如DataGrid的分页按钮等，也要使用URL-Based Script方式录制。</p> 
<p>4)  基于浏览器的应用程序中使用了HTTPS安全协议，使用URL-Based Script方式录制。</p> 
<p>5)  录制过程中不要使用浏览器的“后退”功能，LoadRunner对其支持不太好。</p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f247ea04c3dd12b07e049cab3ef7cefd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">jquery中如何以逗号分割字符串</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f10b24b2da0663769e72cbb5878aa5c3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">安卓开发中Theme.AppCompat.Light的解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>