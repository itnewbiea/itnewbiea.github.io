<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue的状态管理器：Vuex - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue的状态管理器：Vuex" />
<meta property="og:description" content="欢迎大家访问我的个人网站 - Sunday俱乐部
这一章我们来学习Vuex，如果要学习好Vuex那么最最重要的就是要知道Vuex是干嘛的，我们为什么需要Vuex。因为对于Vuex来说，它的使用方式非常简单，知识点也不多。Vuex唯一的难点就是很多人无法理解它。所以在本章我们会着重的讲解Vuex的作用，我们为什么需要它，在理解了这些之后，我们再去学习Vuex的使用就会水到渠成了。
状态管理 我们直接来看这一段代码：
&lt;div id=&#34;app&#34;&gt; &lt;com-1&gt;&lt;/com-1&gt; &lt;com-2&gt;&lt;/com-2&gt; &lt;/div&gt; &lt;script type=&#34;text/x-template&#34; id=&#34;com-1&#34;&gt; &lt;div&gt; &lt;input type=&#34;button&#34; @click=&#34;addCount&#34; value=&#34;count&#43;&#43;&#34;&gt; &lt;/div&gt; &lt;/script&gt; &lt;script type=&#34;text/x-template&#34; id=&#34;com-2&#34;&gt; &lt;div&gt; count: {{count}} &lt;/div&gt; &lt;/script&gt; &lt;script&gt; Vue.component(&#39;com-1&#39;, { template: &#39;#com-1&#39;, data: function () { return { count: 0 } }, methods: { addCount: function () { this.count &#43;= 1; } } }); Vue.component(&#39;com-2&#39;, { template: &#39;#com-2&#39;, data: function () { return { count: 0 } }, }); var vm = new Vue({ el: &#39;#app&#39;, }); &lt;/script&gt; 复制代码 在这段代码中，我们期望能够通过点击com-1中的count&#43;&#43;按钮来改变com-2中的count，使其每点击一下自加一。基于这个需求我们应该如何去实现呢？基于我们现在所学到的知识，一共有两种解决办法，我们来看一下。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8e712e337c1e0b2e2995051a5560eb79/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-30T03:46:28+08:00" />
<meta property="article:modified_time" content="2018-08-30T03:46:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue的状态管理器：Vuex</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article-content"> 
 <p><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.lgdsunday.club%2F" rel="nofollow">欢迎大家访问我的个人网站 - Sunday俱乐部</a></p> 
 <hr> 
 <p>这一章我们来学习<a href="https://link.juejin.im?target=https%3A%2F%2Fvuex.vuejs.org%2Fzh%2Finstallation.html" rel="nofollow">Vuex</a>，如果要学习好<a href="https://link.juejin.im?target=https%3A%2F%2Fvuex.vuejs.org%2Fzh%2Finstallation.html" rel="nofollow">Vuex</a>那么最最重要的就是要知道<code>Vuex</code>是干嘛的，我们为什么需要<code>Vuex</code>。因为对于<code>Vuex</code>来说，它的使用方式非常简单，知识点也不多。<code>Vuex</code>唯一的难点就是很多人无法理解它。所以在本章我们会着重的讲解<code>Vuex</code>的作用，我们为什么需要它，在理解了这些之后，我们再去学习<code>Vuex</code>的使用就会水到渠成了。</p> 
 <h3 class="heading">状态管理</h3> 
 <p>我们直接来看这一段代码：</p> 
 <pre><code class="hljs bash copyable">&lt;div id=<span class="hljs-string">"app"</span>&gt;
    &lt;com-1&gt;&lt;/com-1&gt;
    &lt;com-2&gt;&lt;/com-2&gt;
&lt;/div&gt;

&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/x-template"</span> id=<span class="hljs-string">"com-1"</span>&gt;
    &lt;div&gt;
        &lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">"button"</span> @click=<span class="hljs-string">"addCount"</span> value=<span class="hljs-string">"count++"</span>&gt;
    &lt;/div&gt;
&lt;/script&gt;

&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/x-template"</span> id=<span class="hljs-string">"com-2"</span>&gt;
    &lt;div&gt;
        count: {<!-- -->{count}}
    &lt;/div&gt;
&lt;/script&gt;

&lt;script&gt;

    Vue.component(<span class="hljs-string">'com-1'</span>, {
        template: <span class="hljs-string">'#com-1'</span>,
        data: <span class="hljs-function"><span class="hljs-title">function</span></span> () {
            <span class="hljs-built_in">return</span> {
                count: 0
            }
        },
        methods: {
            addCount: <span class="hljs-function"><span class="hljs-title">function</span></span> () {
                this.count += 1;
            }
        }
    });

    Vue.component(<span class="hljs-string">'com-2'</span>, {
        template: <span class="hljs-string">'#com-2'</span>,
        data: <span class="hljs-function"><span class="hljs-title">function</span></span> () {
            <span class="hljs-built_in">return</span> {
                count: 0
            }
        },
    });


    var vm = new Vue({
        el: <span class="hljs-string">'#app'</span>,

    });
&lt;/script&gt;
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>在这段代码中，我们期望能够通过点击<code>com-1</code>中的<code>count++</code>按钮来改变<code>com-2</code>中的<code>count</code>，使其每点击一下自加一。基于这个需求我们应该如何去实现呢？基于我们现在所学到的知识，一共有两种解决办法，我们来看一下。</p> 
 <p>第一种解决方案就是：<strong>通过组件传参的方式</strong>。我们知道在<code>Vue</code>中，兄弟组件是没有办法进行传参操作的，那么按照我们现在所学到的知识，如果希望通过组件间传参的方式解决这个问题，那么就需要对我们的<code>html</code>结构进行一下修改，我们看下面的代码：</p> 
 <pre><code class="hljs bash copyable">&lt;div id=<span class="hljs-string">"app"</span>&gt;
    &lt;com-1&gt;&lt;/com-1&gt;  
&lt;/div&gt;

&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/x-template"</span> id=<span class="hljs-string">"com-1"</span>&gt;
    &lt;div&gt;
        &lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">"button"</span> @click=<span class="hljs-string">"addCount"</span> value=<span class="hljs-string">"count++"</span>&gt;
        &lt;com-2 v-bind:count=<span class="hljs-string">"count"</span>&gt;&lt;/com-2&gt;
    &lt;/div&gt;
&lt;/script&gt;

&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/x-template"</span> id=<span class="hljs-string">"com-2"</span>&gt;
    &lt;div&gt;
        count: {<!-- -->{count}}
    &lt;/div&gt;
&lt;/script&gt;

&lt;script&gt;
    Vue.component(<span class="hljs-string">'com-1'</span>, {
        template: <span class="hljs-string">'#com-1'</span>,
        data: <span class="hljs-function"><span class="hljs-title">function</span></span> () {
            <span class="hljs-built_in">return</span> {
                count: 0
            }
        },
        methods: {
            addCount: <span class="hljs-function"><span class="hljs-title">function</span></span> () {
                this.count += 1;
            }
        }
    });

    Vue.component(<span class="hljs-string">'com-2'</span>, {
        template: <span class="hljs-string">'#com-2'</span>,
        props: {
            count: 0
        }
    });

    var vm = new Vue({
        el: <span class="hljs-string">'#app'</span>
    });
&lt;/script&gt;
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>在上面的代码中我们把<code>com-2</code>变成了<code>com-1</code>的一个子组件，当我们点击<code>count++</code>按钮的时候，我们通过<code>props</code>向<code>com-2</code>中传递了<code>count</code>的值，我们在学习组件的时候学习过 <strong>当我们使用<code>prop</code>进行参数传递的时候，父组件数据的改变会影响子组件</strong> 。这样，我们在<code>com-1</code>中<code>count</code>的变化就会在<code>com-2</code>中被展示出来。</p> 
 <p>在我们的<code>Demo</code>事例中，通过这种方法来维护<code>count</code>的状态未尝不可。不过大家想一下，在我们的实际项目中各个组件的层级会变得非常复杂，同时对于这种数据的状态管理如果都通过这种组件之间传参的方式来进行解决的话，则会变得非常难以维护。那么我们就会想有没有其他的方式可以解决这个问题？那就是采用<strong>全局状态管理</strong>的方法。</p> 
 <p>我们看一下下面的代码：</p> 
 <pre><code class="hljs bash copyable">&lt;div id=<span class="hljs-string">"app"</span>&gt;
    &lt;com-1&gt;&lt;/com-1&gt;
    &lt;com-2&gt;&lt;/com-2&gt;
&lt;/div&gt;

&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/x-template"</span> id=<span class="hljs-string">"com-1"</span>&gt;
    &lt;div&gt;
        &lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">"button"</span> @click=<span class="hljs-string">"addCount"</span> value=<span class="hljs-string">"count++"</span>&gt;
    &lt;/div&gt;
&lt;/script&gt;

&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/x-template"</span> id=<span class="hljs-string">"com-2"</span>&gt;
    &lt;div&gt;
        count: {<!-- -->{count}}
    &lt;/div&gt;
&lt;/script&gt;

&lt;script&gt;
    var store = {
        count: 0
    };

    Vue.component(<span class="hljs-string">'com-1'</span>, {
        template: <span class="hljs-string">'#com-1'</span>,
        data: <span class="hljs-function"><span class="hljs-title">function</span></span> () {
            <span class="hljs-built_in">return</span> store
        },
        methods: {
            addCount: <span class="hljs-function"><span class="hljs-title">function</span></span> () {
                this.count += 1;
            }
        }
    });

    Vue.component(<span class="hljs-string">'com-2'</span>, {
        template: <span class="hljs-string">'#com-2'</span>,
        data: <span class="hljs-function"><span class="hljs-title">function</span></span> () {
            <span class="hljs-built_in">return</span> store
        },
    });

    var vm = new Vue({
        el: <span class="hljs-string">'#app'</span>,
    });
&lt;/script&gt;
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>我们看到在上面的代码中我们维护了一个<code>store</code>对象，用作两个组件中原始数据对象的实际来源 <strong>当访问数据对象时，一个 Vue 实例（组件实例）只是简单的代理访问。</strong> 所以，如果你有一处需要被多个实例间共享的状态，可以简单地通过维护一份数据来实现共享。现在当 <code>store</code> 发生变化，<code>com-1</code>和<code>com-2</code> 都将自动的更新引用它们的视图。从而达到了我们需求，当我们在<code>com-1</code>中点击<code>count++</code>的时候在<code>com-2</code>中展示<code>count</code>的值。</p> 
 <p>但是对我们现在的代码来说，依然存在一个非常致命的问题，那就是 <strong>在任何时间，我们应用中的任何部分，在任何数据改变后，都不会留下变更过的记录。<strong>这在我们想要进行代码调试的时候，将会变成一个噩梦。所以我们可以采用一个简单的</strong>store模式</strong>来解决这个问题：</p> 
 <pre><code class="hljs bash copyable">&lt;div id=<span class="hljs-string">"app"</span>&gt;
    &lt;com-1&gt;&lt;/com-1&gt;
    &lt;com-2&gt;&lt;/com-2&gt;
&lt;/div&gt;

&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/x-template"</span> id=<span class="hljs-string">"com-1"</span>&gt;
    &lt;div&gt;
        &lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">"button"</span> @click=<span class="hljs-string">"addCount"</span> value=<span class="hljs-string">"count++"</span>&gt;
    &lt;/div&gt;
&lt;/script&gt;

&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/x-template"</span> id=<span class="hljs-string">"com-2"</span>&gt;
    &lt;div&gt;
        count: {<!-- -->{sharedState.count}}
    &lt;/div&gt;
&lt;/script&gt;

&lt;script&gt;
    var store = {
        debug: <span class="hljs-literal">true</span>,
        // 数据 / 状态
        state: {
            count: 0
        },
        // state的变化要通过mutation来进行
        mutation: {
            addCount: <span class="hljs-keyword">function</span> (state) {
                <span class="hljs-keyword">if</span> (store.debug) console.log(<span class="hljs-string">'调用addCount方法，count自加1'</span>);
                state.count += 1;
            }
        }
    };

    Vue.component(<span class="hljs-string">'com-1'</span>, {
        template: <span class="hljs-string">'#com-1'</span>,
        data: <span class="hljs-function"><span class="hljs-title">function</span></span> () {
            <span class="hljs-built_in">return</span> {
                // 私有数据
                privateState: {

                },
                // 共同数据
                sharedState: store.state
            }
        },
        methods: {
            addCount: <span class="hljs-function"><span class="hljs-title">function</span></span> () {
                // 调用
                store.mutation.addCount(store.state);
            }
        }
    });

    Vue.component(<span class="hljs-string">'com-2'</span>, {
        template: <span class="hljs-string">'#com-2'</span>,
        data: <span class="hljs-function"><span class="hljs-title">function</span></span> () {
            <span class="hljs-built_in">return</span> {
                // 私有数据
                privateState: {

                },
                // 共同数据
                sharedState: store.state
            }
        },
    });

    var vm = new Vue({
        el: <span class="hljs-string">'#app'</span>,
    });
&lt;/script&gt;
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>在上面的代码中我们为<code>store</code>增加了<code>debug、state、mutation</code>三个属性，<code>state</code>是<code>store</code>对象中所有状态数据的描述，当<code>state</code>中的数据想要发生改变的时候都要通过<code>mutation</code>来进行。比如我们的<code>count++</code>的点击事件，则是通过调用<code>store.mutation.addCount</code>方法进行，以此来记录<strong>数据的改变。</strong></p> 
 <p>这样的一种方式在<code>Vue</code>中被称为**<code>store</code>模式**，我们使用**<code>store</code>模式<strong>作为我们整个项目的</strong>状态管理器**，但是当我们的项目变得越来越大，越来越复杂的时候，我们更需要一个更加专业，更加全面的<strong>状态管理器</strong>，那么这个<strong>状态管理器</strong>就是<code>Vuex</code>。</p> 
 <h3 class="heading">Vuex</h3> 
 <p><code>Vuex</code>继承了<code>store模式</code>的思想，并做了更多的扩展，提供了更多的功能。我们先来看一下<code>Vuex</code>的定义：</p> 
 <blockquote> 
  <p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。致力于管理项目中所有公用数据的状态。</p> 
 </blockquote> 
 <p>我们参照上面的几个例子，是不是对<code>Vuex</code>的定义更加容易理解。<code>Vuex</code>是在<code>store模式</code>上的扩展，它们拥有相同的思想。我们看一下<code>Vuex</code>中的核心功能。</p> 
 <blockquote> 
  <p>1、State ：<code>Vuex</code>中的 “ 唯一数据源 ” 2、Getter ：<code>Vuex</code> 中的计算属性，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 3、Mutation ：更改<code>Vuex</code>中数据的唯一方式，就是通过<code>mutation</code>进行修改，只支持同步操作。就像我们上面的例子一样。 4、Action ：当我们需要异步更改数据时，通过 <code>Action</code> 提交的是 <code>mutation</code>，而不是直接变更状态。 5、Module ： 由于<code>Vuex</code>使用单一状态树，应用的所有状态会集中到一个比较大的对象。<code>Vuex</code> 允许我们将 <code>store</code> 分割成模块（<code>module</code>）。每个模块拥有自己的 <code>state、mutation、action、getter</code>甚至是嵌套子模块——从上至下进行同样方式的分割。</p> 
 </blockquote> 
 <p>由前面的例子我们也可以看出，我们不希望<code>state</code>中的状态被直接改变（虽然我们可以这么做），而是期望把<code>Mutation</code>作为改变<code>state</code>的唯一方式，而当我们必须要通过异步来改变状态的时候，我们期望使用<code>action</code>来提交<code>mutaion</code>用于改变状态。大家思考一下<code>Vuex</code>为什么要这么去设计呢？</p> 
 <p>在<code>Vuex</code>中说白了，任何的操作都是围绕<code>state</code>来进行的，<code>Vuex</code>是<strong>状态管理器</strong>，作用就是管理<code>state</code>中的状态，其他提供的所有功能<code>Getter、Mutation、Action</code>都是为了能够更好的管理<code>state</code>，而之所以设计成期望通过<code>Mutation</code>改变状态，是因为我们期望**所有状态的变化都是有迹可循的！**我们通过一个图示来看一下<code>Vuex</code>的设计流程（图示来自<a href="https://link.juejin.im?target=https%3A%2F%2Fvuex.vuejs.org%2Fzh%2F" rel="nofollow">Vuex官网</a>）：</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p>图示完美的解释了<code>Vuex</code>的执行流程：我们在<code>Vue</code>的组件中提交<code>Dispatch</code>操作，用以操作对应的<code>Actions</code>方法，然后在<code>Actions</code>的方法中，通过提交<code>Commit</code>操作调用对应的<code>Mutation</code>方法来修改对应的状态<code>State</code>，最后<code>State</code>的改变被渲染到我们的组件中。这就是<code>Vuex</code>的整个核心流程，我们通过一段代码来描述一下：</p> 
 <pre><code class="hljs bash copyable">&lt;div id=<span class="hljs-string">"app"</span>&gt;
    &lt;com-1&gt;&lt;/com-1&gt;
    &lt;com-2&gt;&lt;/com-2&gt;
&lt;/div&gt;

&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/x-template"</span> id=<span class="hljs-string">"com-1"</span>&gt;
    &lt;div&gt;
        &lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">"button"</span> @click=<span class="hljs-string">"addCount"</span> value=<span class="hljs-string">"count++"</span>&gt;
    &lt;/div&gt;
&lt;/script&gt;

&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/x-template"</span> id=<span class="hljs-string">"com-2"</span>&gt;
    &lt;div&gt;
        count: {<!-- -->{this.<span class="hljs-variable">$store</span>.state.count}}
    &lt;/div&gt;
&lt;/script&gt;

&lt;script&gt;
    /**
     * 声明一个Vuex实例，这个实例全局只有一个
     * */
    const store = new Vuex.Store({
        state: {
            count: 1
        },
        mutations: {
            /**
             * Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (<span class="hljs-built_in">type</span>) 
             * 和 一个 回调函数 (handler)。
             * 这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：
             * */
            increment (state, num) {
                // 变更状态
                state.count += num;
            }
        },
        actions: {
            /**
             * Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，
             * 因此你可以调用 context.commit 提交一个 mutation，
             * 或者通过 context.state 和 context.getters 来获取 state 和 getters。
             * 但是 context 对象并！不！等！于！store 实例本身
             * */
            increment (context, num) {
                // 延迟1秒提交commit操作
                <span class="hljs-built_in">set</span>Timeout(<span class="hljs-function"><span class="hljs-title">function</span></span> () {
                    /**
                     * 你不能直接调用一个 mutation handler。
                     * 这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。
                     * ”要唤醒一个 mutation handler，你需要以相应的 <span class="hljs-built_in">type</span> 调用 store.commit 方法.
                     * 你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）。
                     * 或者我们也可以通过 对象风格的提交方式：
                     * store.commit({
                            <span class="hljs-built_in">type</span>: <span class="hljs-string">'increment'</span>,
                            num: 1
                        })
                       这种情况下我们将在 mutation 中接收到一个对象
                     * */
                    context.commit(<span class="hljs-string">'increment'</span>, num)
                }, 1000);
            }
        }
    })

    Vue.component(<span class="hljs-string">'com-1'</span>, {
        template: <span class="hljs-string">'#com-1'</span>,
        methods: {
            addCount: <span class="hljs-function"><span class="hljs-title">function</span></span> () {
                /**
                 * 我们可以直接向 store.dispatch 传入额外的参数，即 action 的 载荷（payload）。
                 * 或者我们也可以通过 对象风格的提交方式：
                 * store.dispatch({
                        <span class="hljs-built_in">type</span>: <span class="hljs-string">'increment'</span>,
                        num: 1
                    })
                    这种情况下我们将在 action 中接收到一个对象
                 * */
                this.<span class="hljs-variable">$store</span>.dispatch(<span class="hljs-string">'increment'</span>, 1);
            }
        }
    });

    Vue.component(<span class="hljs-string">'com-2'</span>, {
        template: <span class="hljs-string">'#com-2'</span>,
    });

    var vm = new Vue({
        el: <span class="hljs-string">'#app'</span>,
        store , // 等同于 store:store
    });
&lt;/script&gt;
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>在上面的代码中，我们首先通过<code>new Vuex.Store</code>去声明了一个<code>Vuex</code>的实例<code>store</code> ，当我们点击<code>count++</code>按钮的时候，调用<code>this.$store.dispatch('increment', 1);</code>其实是调用了<code>Vuex</code>中<code>actions</code>中定义的<code>increment</code>方法，在这个方法中我们声明了一个<code>setTimeout</code>，指定在1秒钟之后执行<code>context.commit('increment', num)</code>方法，调用<code>mutation</code>的<code>increment</code>方法，然后我们在<code>mutation</code>的<code>increment</code>方法中修改了<code>state</code>中的<code>count</code>的值，使其<code>state.count += num;</code>。这样的一个执行流程就是我们<code>Vuex</code>中所提倡的执行方法，也是我们上方图示中所描述的执行流程。</p> 
 <p>我们知道<code>state、mutaion、action</code>是整个<code>Vuex</code>最核心的内容，在它们之外，<code>Getter、Module</code>也是我们必须要了解的内容。我们看下面的代码：</p> 
 <pre><code class="hljs bash copyable">...
&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/x-template"</span> id=<span class="hljs-string">"com-2"</span>&gt;
   &lt;div&gt;
       &lt;!-- 我们将要通过模块的路径来调整 state的命名 --&gt;
       &lt;p&gt;count: {<!-- -->{this.<span class="hljs-variable">$store</span>.state.a.count}}&lt;/p&gt;
       &lt;!-- Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值： --&gt;
       &lt;p&gt;doubleCount: {<!-- -->{this.<span class="hljs-variable">$store</span>.getters.doubleCount}}&lt;/p&gt;
   &lt;/div&gt;
&lt;/script&gt;

&lt;script&gt;
   /**
    * 声明一个Vuex模块
    * 默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的
    * ——这样使得多个模块能够对同一 mutation 或 action 作出响应。
    * 而 state 则是模块的局部状态对象！
    * 
    *    如果希望你的模块具有更高的封装度和复用性，
    *    你可以通过添加 namespaced: <span class="hljs-literal">true</span> 的方式使其成为带命名空间的模块。
    *    当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。
    * */
   const moduleA = {
       // namespaced: <span class="hljs-literal">true</span>,
       state: {
           count: 1
       },
       getters: {
          /**
            * Getter 接受两个参数，
            * 第一为：state 状态对象
            * 第二位：其他的 getter 
            * */
           doubleCount: <span class="hljs-keyword">function</span> (state, getters) {
               console.log(<span class="hljs-string">'getters.count: '</span> + getters.count);
               <span class="hljs-built_in">return</span> state.count * 2;
           },
           count: <span class="hljs-keyword">function</span> (state) {
               <span class="hljs-built_in">return</span> state.count;
           },
       },
       mutations: {
           increment (state, num) {
               // 这里的 `state` 对象是模块的局部状态
               state.count += num;
           }
       },
       ...
   };

   /**
    * 声明一个Vuex实例，这个实例全局只有一个
    * */
   const store = new Vuex.Store({
       modules: {
           a: moduleA
       }
   });
   ...
&lt;/script&gt;
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>在上面的代码中，我们只贴出了关键性代码，我们把<code>Vuex</code>进行了模块化的区分，提供了<code>moduleA</code>用以描述<code>state、getters、mutations</code>等，具体的作用在上面的代码中有详细的注释，我们这里就不在过多叙述了。</p> 
 <h3 class="heading">总结</h3> 
 <p>在本章的内容中，我们并没有一头扎进<code>Vuex</code>的细节中，因为对<code>Vuex</code>来说，它的具体使用方式比较容易，只要我们能够理解它的本质作用，它的执行流程那么在我们使用<code>Vuex</code>的时候就会水到渠成。</p> 
 <p>除去我们讲到的<code>Vuex</code>的核心功能之外，<code>Vuex</code>还提供了一些其他的功能，比如<code>plugins插件</code>，这些内容在<a href="https://link.juejin.im?target=https%3A%2F%2Fvuex.vuejs.org%2Fzh%2Finstallation.html" rel="nofollow">Vuex官网</a>中介绍的非常清楚，我们这里就不想在进行重复介绍了。</p> 
 <hr> 
 <p>前端技术日新月异，每一种新的思想出现，都代表了一种技术的跃进、架构的变化，那么对于目前的前端技术而言，MVVM 的思想已经可以代表当今前端领域的前沿思想理念，Angular、React、Vue 等基于 MVVM 思想的具体实现框架，也成为了人们争相学习的一个热点。而 Vue 作为其中唯一没有大公司支持但却能与它们并驾齐驱并且隐隐有超越同类的趋势，不得不说这种增长让人感到惊奇。</p> 
 <p>本系列课程内容将会带领大家由浅入深的学习 Vue 的基础知识，了解 Vue 的源码设计和实现原理，和大家一起看一下尤雨溪先生的编程思想、架构设计以及如何进行代码实现。本系列课程内容主要分为三大部分：</p> 
 <blockquote> 
  <p><code>Vue</code> 的基础知识：在这一部分将学习 Vue 的基础语法及其源码的实现。例如，<code>Vue</code> 的生命周期钩子如何设计？当声明了一个 <code>directive</code> 时，<code>Vue</code> 究竟执行了什么？为什么只有通过 <code>vue.set</code> 函数才能为响应式对象添加响应式属性？如果我们自己要实现一个响应式的框架的话，应该如何下手、如何思考等。 <code>Vue</code>的周边生态：在这一部分将学习 <code>Vue</code> 的周边生态圈，包括有哪些 <code>UI</code> 库可以和 <code>Vue</code> 配合快速构建界面、如何使用 <code>vue-router</code>构建前端路由、如何使用 <code>Vuex</code> 进行状态管理、如何使用 <code>Axios</code> 进行网络请求、如何使用 <code>Webpack</code>、使用 <code>vue-cli</code> 构建出的项目里的各种配置有什么意义？ 项目实战：在这一部分将会通过一个有意思的自动对话系统来进行项目实战，争取通过这个小项目把学到的知识点进行一个整合。</p> 
 </blockquote> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
</div> 
<p>转载于:https://juejin.im/post/5b87687d51882542ec199f95</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3d25183144186b64f1284263af93f332/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">bugku——过狗一句话（奇淫技巧）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1922d2ad8f81ef17f6682817f6bed7e0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">虚拟机拷贝文件到U盘(VMware Workstation 14)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>