<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言之整型提升 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言之整型提升" />
<meta property="og:description" content="文章目录 1 有可能出现的问题2 产生以上问题的原因（整型提升）3 整型提升的过程4 整型提升示例5 总结 1 有可能出现的问题 代码如下
#include &lt;stdio.h&gt; int main () { int a = -1; unsigned int b = 1; if (a &lt; b) { printf(&#34;a &lt; b&#34;); } else { printf(&#34;a &gt;= b&#34;); } return 0; } 运行结果
2 产生以上问题的原因（整型提升） 在表达式计算时，各种整型首先要提升为int类型，如果int类型不足以表示则要提升为unsigned int类型；然后执行表达式的运算。
**为什么要使用整型提升：**表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器的长度。因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。简单来说就是为了在计算中有更快的速度。
3 整型提升的过程 1. 有符号整数的整型提升：高位补充符号位 char var1 = -1； 负数在内存中以补码的形式存储，且char类型占一个字节，即8bit 故变量 var1 的二进制补码为1111 1111 整型提升之后，高位补充符号位1，int为32bit提升后为1111 1111 1111 1111 1111 1111 1111 1111 char var1 = 1； 正数的补码和原码相同，同理可得变量var1的二进制补码为 0000 0001 整型提升之后，高位补充符号位0，提升后为0000 0000 0000 0000 0000 0000 0000 0001 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/02c4eaaa12b988a1b4dbf95844d1e1de/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-30T15:15:22+08:00" />
<meta property="article:modified_time" content="2023-12-30T15:15:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言之整型提升</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1__3" rel="nofollow">1 有可能出现的问题</a></li><li><a href="#2__29" rel="nofollow">2 产生以上问题的原因（整型提升）</a></li><li><a href="#3__39" rel="nofollow">3 整型提升的过程</a></li><li><a href="#4__62" rel="nofollow">4 整型提升示例</a></li><li><a href="#5___93" rel="nofollow">5 总结</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="1__3"></a>1 有可能出现的问题</h2> 
<p><strong>代码如下</strong></p> 
<pre><code class="prism language-C">#include &lt;stdio.h&gt;

int main ()
{
  int a = -1;
  unsigned int b = 1;
  if (a &lt; b) {
    printf("a &lt; b");
  } else {
    printf("a &gt;= b");
  }
  
  
  return 0;
}
</code></pre> 
<p><strong>运行结果</strong><br> <img src="https://images2.imgbox.com/df/89/oPvpcE8k_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="2__29"></a>2 产生以上问题的原因（整型提升）</h2> 
<p><em>在表达式计算时，各种整型首先要提升为int类型，如果int类型不足以表示则要提升为unsigned int类型；然后执行表达式的运算。</em></p> 
<p>**为什么要使用整型提升：**表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的<a href="https://baike.baidu.com/item/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/283978?fromModule=lemma_inlink" rel="nofollow">通用寄存器</a>的长度。因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。<strong>简单来说就是为了在计算中有更快的速度。</strong></p> 
<h2><a id="3__39"></a>3 整型提升的过程</h2> 
<pre><code class="prism language-c"><span class="token number">1.</span> 有符号整数的整型提升：高位补充符号位

<span class="token keyword">char</span> var1 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>；

负数在内存中以补码的形式存储，且<span class="token keyword">char</span>类型占一个字节，即<span class="token number">8</span>bit

故变量 var1 的二进制补码为<span class="token number">1111</span>   <span class="token number">1111</span>

整型提升之后，高位补充符号位<span class="token number">1</span>，<span class="token keyword">int</span>为<span class="token number">32</span>bit提升后为<span class="token number">1111</span>    <span class="token number">1111</span>    <span class="token number">1111</span>    <span class="token number">1111</span>    <span class="token number">1111</span>    <span class="token number">1111</span>    <span class="token number">1111</span>    <span class="token number">1111</span>

<span class="token keyword">char</span> var1 <span class="token operator">=</span> <span class="token number">1</span>；

正数的补码和原码相同，同理可得变量var1的二进制补码为 <span class="token number">0000</span>  <span class="token number">0001</span>

整型提升之后，高位补充符号位<span class="token number">0</span>，提升后为<span class="token number">0000</span>    <span class="token number">0000</span>    <span class="token number">0000</span>    <span class="token number">0000</span>    <span class="token number">0000</span>    <span class="token number">0000</span>    <span class="token number">0000</span>    <span class="token number">0001</span>

<span class="token number">2.</span> 无符号整数的整型提升：高位补<span class="token number">0</span>即可
</code></pre> 
<h2><a id="4__62"></a>4 整型提升示例</h2> 
<p><strong>基础知识：</strong> 补码的编码规则是:符号位0表示正,1表示负,正数的补码等于原码,负数的补码等于反码末位加1。</p> 
<pre><code class="prism language-C">#include &lt;stdio.h&gt;

/*
思路：
  a补码：1111  1111
  b补码：1100  0111
  整型提升后(按照32bit)：
  a补码：1111  1111    1111  1111    1111  1111    1111  1111   
  b补码：1111  1111    1111  1111    1111  1111    1100  0111
  相加之后  ==  (a + b)补码
         1111  1111    1111  1111    1111  1111    1100  0110
  转化为原码后
         1000  0000    0000  0000    0000  0000    0011  101058
  最终打印的值为 -58
  
 */
int main() {
  char a = -1;
  char b = 199;
  char c = a + b;
  printf("%d", c);
  return 0;
  
}
</code></pre> 
<h2><a id="5___93"></a>5 总结</h2> 
<p>在C语言中，当表达式中包含不及int大小的变量时，编译器会自动将其提升为整型，因此需要特别注意这种情况。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f35ff29fbc4347d033f9e73482464139/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">tcpdump出现permission denied</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6fefe341769ab1139f220f411cde1609/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">信息网络协议基础_IP移动网络管理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>