<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux select 进程阻塞,程序中用sleep和select阻塞休眠的区别 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux select 进程阻塞,程序中用sleep和select阻塞休眠的区别" />
<meta property="og:description" content="程序调用sleep就是放弃cpu执行，进入阻塞状态，但是sleep的秒数过后，有可能有很多进程或线程在竞争cpu，而且优先级都比当前程序高，导致当先进程或线程无法立即执行，这是导致sleep不准确的一个原因。
gnu里介绍sleep:
The function sleep gives a simple way to make the program wait for a short interval. If your program doesn’t use signals (except to terminate), then you can expect sleep to wait reliably throughout the specified interval. Otherwise, sleep can return sooner if a signal arrives; if you want to wait for a given interval regardless of signals, use select (see Waiting for I/O) and don’t specify any descriptors to wait for." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/644d6d215a143914044d73148f6c1ea0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-09T08:28:03+08:00" />
<meta property="article:modified_time" content="2021-05-09T08:28:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux select 进程阻塞,程序中用sleep和select阻塞休眠的区别</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>程序调用sleep就是放弃cpu执行，进入阻塞状态，但是sleep的秒数过后，有可能有很多进程或线程在竞争cpu，而且优先级都比当前程序高，导致当先进程或线程无法立即执行，这是导致sleep不准确的一个原因。</p> 
 <p>gnu里介绍sleep:</p> 
 <p>The function sleep gives a simple way to make the program wait for a short interval. If your program doesn’t use signals (except to terminate), then you can expect sleep to wait reliably throughout the specified interval. Otherwise, sleep can return sooner if a signal arrives; if you want to wait for a given interval regardless of signals, use select (see Waiting for I/O) and don’t specify any descriptors to wait for.</p> 
 <p>Resist the temptation to implement a sleep for a fixed amount of time by using the return value of sleep, when nonzero, to call sleep again. This will work with a certain amount of accuracy as long as signals arrive infrequently. But each signal can cause the eventual wakeup time to be off by an additional second or so. Suppose a few signals happen to arrive in rapid succession by bad luck—there is no limit on how much this could shorten or lengthen the wait.</p> 
 <p>Instead, compute the calendar time at which the program should stop waiting, and keep trying to wait until that calendar time. This won’t be off by more than a second. With just a little more work, you can use select and make the waiting period quite accurate. (Of course, heavy system load can cause additional unavoidable delays—unless the machine is dedicated to one application, there is no way you can avoid this.)</p> 
 <p>On some systems, sleep can do strange things if your program uses SIGALRM explicitly. Even if SIGALRM signals are being ignored or blocked when sleep is called, sleep might return prematurely on delivery of a SIGALRM signal. If you have established a handler for SIGALRM signals and a SIGALRM signal is delivered while the process is sleeping, the action taken might be just to cause sleep to return instead of invoking your handler. And, if sleep is interrupted by delivery of a signal whose handler requests an alarm or alters the handling of SIGALRM, this handler and sleep will interfere.</p> 
 <p>On GNU systems, it is safe to use sleep and SIGALRM in the same program, because sleep does not work by means of SIGALRM.</p> 
 <p>有的系统使用alarm,pause或sigsuspend来实现sleep，这样使sleep受到SIGALRM信号影响。各个系统的sleep版本不一。</p> 
 <p>ldd --version能看到libc版本，gnu的sleep已经不依靠SIGALRM实现，所以SIGALRM对sleep没有影响。</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/54bf770c590b392b0914aefc259d8319/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2021-05-08</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/07c178dd38ab6d0995b49daf6128de3e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">从土木零基础转行数据挖掘和算法的过程与办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>