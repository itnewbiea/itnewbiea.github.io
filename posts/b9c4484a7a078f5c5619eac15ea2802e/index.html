<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>手撕AVL_二叉平衡树(图文并茂) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="手撕AVL_二叉平衡树(图文并茂)" />
<meta property="og:description" content="目录
前言
一 . AVL树的概念
二 . AVL树节点的定义
三 . AVL树的插入
1.插入节点
2.调节负载因子
四 . AVL树的旋转
1.左单旋
2.左右双旋
五 . AVL树性能分析
总结
前言 大家好,今天带大加手撕AVL树的插入
一 . AVL树的概念 二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将退化为单支树，查找元素相当于在顺序表中搜索元素，效率低下。因此，两位俄罗斯的数学家G.M.Adelson-Velskii和E.M.Landis在1962年 发明了一种解决上述问题的方法：当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)，即可降低树的高度，从而减少平均搜索长度。 一棵AVL树或者是空树，或者是具有以下性质的二叉搜索树：
它的左右子树都是AVL树左右子树高度之差(简称平衡因子)的绝对值不超过1(-1/0/1) 如果一棵二叉搜索树是高度平衡的，它就是AVL树。如果它有n个结点，其高度可保持在搜索时间复杂度。
二 . AVL树节点的定义 为了AVL树实现简单，AVL树节点在定义时维护一个平衡因子，具体节点定义如下：
static class TreeNode{ int val; int bf; // 平衡因子 -&gt; 当前节点的平衡因子=右子树高度-左子树的高度 TreeNode left;// 节点的左孩子 TreeNode right;// 节点的右孩子 TreeNode parent;// 节点的双亲 public TreeNode(int val){ this.val = val; } } 注意： 当前节点的平衡因子=右子树高度-左子树的高度。但是，不是每棵树，都必须有平衡因子，这只是其中的一种实现 方式。
三 . AVL树的插入 AVL树就是在二叉搜索树的基础上引入了平衡因子，因此AVL树也可以看成是二叉搜索树。那么AVL树的插入过程可 以分为两步：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b9c4484a7a078f5c5619eac15ea2802e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-25T20:24:25+08:00" />
<meta property="article:modified_time" content="2023-11-25T20:24:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">手撕AVL_二叉平衡树(图文并茂)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E4%B8%80%20.%C2%A0AVL%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E4%B8%80%20.%C2%A0AVL%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">一 . AVL树的概念</a></p> 
<p id="%E4%BA%8C%20.%20AVL%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%20.%20AVL%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">二 . AVL树节点的定义</a></p> 
<p id="%E4%B8%89%20.%20AVL%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5-toc" style="margin-left:0px;"><a href="#%E4%B8%89%20.%20AVL%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5" rel="nofollow">三 . AVL树的插入</a></p> 
<p id="1.%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9-toc" style="margin-left:40px;"><a href="#1.%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9" rel="nofollow">1.插入节点</a></p> 
<p id="2.%E8%B0%83%E8%8A%82%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90-toc" style="margin-left:40px;"><a href="#2.%E8%B0%83%E8%8A%82%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90" rel="nofollow">2.调节负载因子</a></p> 
<p id="%E5%9B%9B%20.%20AVL%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%20.%20AVL%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC" rel="nofollow">四 . AVL树的旋转</a></p> 
<p id="1.%E5%B7%A6%E5%8D%95%E6%97%8B-toc" style="margin-left:40px;"><a href="#1.%E5%B7%A6%E5%8D%95%E6%97%8B" rel="nofollow">1.左单旋</a></p> 
<p id="2.%E5%B7%A6%E5%8F%B3%E5%8F%8C%E6%97%8B-toc" style="margin-left:40px;"><a href="#2.%E5%B7%A6%E5%8F%B3%E5%8F%8C%E6%97%8B" rel="nofollow">2.左右双旋</a></p> 
<p id="%E4%BA%94%20.%20AVL%E6%A0%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#%E4%BA%94%20.%20AVL%E6%A0%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90" rel="nofollow">五 . AVL树性能分析</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<hr> 
<h2 id="%E5%89%8D%E8%A8%80"><a id="_7"></a>前言</h2> 
<blockquote> 
 <p>大家好,今天带大加手撕AVL树的插入</p> 
</blockquote> 
<hr> 
<h2 id="%E4%B8%80%20.%C2%A0AVL%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><strong style="color:#4f4f4f;font-size:24px;font-weight:bold;">一 . </strong>AVL树的概念</h2> 
<p>二叉搜索树虽可以缩短查找的效率，但<strong>如果数据有序或接近有序二叉搜索树将退化为单支树</strong>，<strong>查找元素相当于在顺序表中搜索元素，效率低下</strong>。因此，两位俄罗斯的数学家G.M.Adelson-Velskii和E.M.Landis在1962年 发明了一种解决上述问题的方法：<strong>当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)</strong>，即可降低树的高度，从而减少平均搜索长度。 一棵AVL树或者是空树，或者是具有以下性质的二叉搜索树：</p> 
<ul><li>它的左右子树都是AVL树</li><li>左右子树高度之差(简称平衡因子)的绝对值不超过1(-1/0/1)</li></ul> 
<p><img alt="" height="493" src="https://images2.imgbox.com/27/f2/sqGssB3d_o.png" width="742"></p> 
<p>如果一棵二叉搜索树是高度平衡的，它就是AVL树。如果它有n个结点，其高度可保持在<img alt="O(log2n)" class="mathcode" src="https://images2.imgbox.com/b1/50/7cJ9Yr77_o.png">搜索时间复杂度<img alt="O(log2n)" class="mathcode" src="https://images2.imgbox.com/d2/af/nHUm6AlK_o.png">。</p> 
<hr> 
<h2 id="%E4%BA%8C%20.%20AVL%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%9A%E4%B9%89">二 . AVL树节点的定义</h2> 
<p>为了AVL树实现简单，AVL树节点在定义时维护一个平衡因子，具体节点定义如下：</p> 
<blockquote> 
 <pre>static class TreeNode{
    int val;
    int bf; // 平衡因子 -&gt; 当前节点的平衡因子=右子树高度-左子树的高度
    TreeNode left;// 节点的左孩子
    TreeNode right;// 节点的右孩子
    TreeNode parent;// 节点的双亲
    public TreeNode(int val){
        this.val = val;
    }
}</pre> 
</blockquote> 
<p><strong>注意</strong>： 当前节点的平衡因子=右子树高度-左子树的高度。但是，不是每棵树，都必须有平衡因子，这只是其中的一种实现 方式。</p> 
<hr> 
<h2 id="%E4%B8%89%20.%20AVL%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5">三 . AVL树的插入</h2> 
<p>AVL树就是在二叉搜索树的基础上引入了平衡因子，因此AVL树也可以看成是二叉搜索树。那么AVL树的插入过程可 以分为两步：</p> 
<pre><strong>1.二分查找树的形式进行插入</strong>
while(){
      1.1 当前节点的val小于待插入节点的val -&gt; 往右边迭代
      1.2 当前节点的val大于待插入节点的val -&gt; 往左边迭代
      1.3 当前节点的val等于待插入节点的val -&gt; 不允许插入
    }
      1.4 正式插入节点

<strong>2.调节平衡因子</strong>
    2.1 如果当前节点是父节点的左节点 parent.bf++
    2.2 如果当前节点是父节点的右节点 parent.bf--;
    2.3 根据parent.bf判断是否需要继续向上调整
        2.3.1 如果parent.bf == 0 表示当前树平衡
        2.3.2 如果parent.bf == (1 || -1) 当前子树平衡,子树上面的情况未知,主要向上进行调整
        2.3.3 如果parent.bf == (2 || -2) 需要进行旋转,根据不同的情况,采取不同的旋转策略</pre> 
<hr> 
<h3 id="1.%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9">1.插入节点</h3> 
<p>本来还想偷个懒的,发现二叉搜索树没有写,这就没办法了,一步一步来吧</p> 
<p>假如我们需要在下面avl树中插入节点10</p> 
<p><strong>parent</strong>: 表示当前遍历到的节点的父节点 初始值为<strong>null</strong></p> 
<p><strong>child:</strong> 表示当前遍历到的节点 初始值为root 即 5号节点</p> 
<p><img alt="" height="737" src="https://images2.imgbox.com/59/99/ft82oDFU_o.png" width="1200"></p> 
<p><img alt="" height="596" src="https://images2.imgbox.com/be/2d/lIKRriQd_o.png" width="1200"></p> 
<p><img alt="" height="440" src="https://images2.imgbox.com/04/7b/6cefPBpV_o.png" width="1200"></p> 
<p><img alt="" height="620" src="https://images2.imgbox.com/45/42/tta6nBiS_o.png" width="1200"></p> 
<p>1.4 正式插入节点</p> 
<p><img alt="" height="641" src="https://images2.imgbox.com/05/e3/gygEtaOs_o.png" width="1200"></p> 
<p>给出部分代码</p> 
<pre><code class="language-java">        TreeNode parent = null;
        TreeNode child = root;

        // 1.二分查找树的插入
        while(child != null){
            if(child.val &gt; val){ //
                // 往左边插入
                parent = child;
                child = child.left;
            }else if(child.val &lt; val){
                // 往右边插入
                parent = child;
                child= child.right;
            }else{
                // 树中已经存在该节点,不允许插入
                return false;
            }
        }

        // 节点正式插入
        if(parent.val &gt; val){
            parent.left = node;
        }else{
            parent.right = node;
        }
        node.parent = parent;
        child = node;</code></pre> 
<p>至此第一步完美结束.我们开始第二大步调节平衡因子</p> 
<h3 id="2.%E8%B0%83%E8%8A%82%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90">2.调节负载因子</h3> 
<p>负载因子的调节和二叉树的旋转可以说是平衡树的核心了,但是只要理解透了,就是随便写,毫无难度!</p> 
<ul><li>2.1 如果当前节点是父节点的左节点 parent.bf++</li><li>2.2 如果当前节点是父节点的右节点 parent.bf--;</li></ul> 
<p><img alt="" height="676" src="https://images2.imgbox.com/92/76/tnG4qg6o_o.png" width="1200"></p> 
<p>此时如果我们插入的元素使10,那parent.bf == 1</p> 
<p>2.3.2 如果parent.bf == (1 || -1) <strong>当前子树平衡</strong>,<strong>子树上面的情况未知,需要向上进行调整</strong></p> 
<p>以9为根节点的子树确实是平衡了,但是上面的子树我们并不清楚,可能平衡也可能不平衡,上面的两个都是不平衡的,我们来看一个平衡的例子</p> 
<p><img alt="" height="774" src="https://images2.imgbox.com/41/d5/mDOdzuq1_o.png" width="1200"></p> 
<p>上面的意思是<span style="color:#fe2c24;"><strong>当前子树平衡</strong>,<strong>子树上面的情况未知,需要向上进行调整</strong></span>我们只知道以parent为根节点的子树的情况,并不清楚上面的情况</p> 
<p>再次回到上面插入10的例子中,根据2.3.2可知需要向上调整</p> 
<p><img alt="" height="920" src="https://images2.imgbox.com/2e/94/yi87BOAP_o.png" width="1200"></p> 
<p>2.3.3 如果parent.bf == (2 || -2) 需要进行旋转,根据不同的情况,采取不同的旋转策略</p> 
<p>到这就是开始旋转了</p> 
<p>旋转一共分为四种,表示四种不同的情况,我先把这四种旋转应用的情况列举出来,具体如何旋转等到下面会细说</p> 
<p>1.左单旋 </p> 
<p><img alt="" height="865" src="https://images2.imgbox.com/22/81/6uqyLNSh_o.png" width="1200"></p> 
<p>2.右单旋</p> 
<p><img alt="" height="826" src="https://images2.imgbox.com/f0/68/4HBOYn3J_o.png" width="1200"></p> 
<p>3.左右双旋</p> 
<p><img alt="" height="579" src="https://images2.imgbox.com/65/1b/WMTINj2Y_o.png" width="1200"></p> 
<p>4.右左双旋</p> 
<p><img alt="" height="565" src="https://images2.imgbox.com/1e/fb/He2x1zFK_o.png" width="1200"></p> 
<p>这四种旋转就是AVL树最核心的地方了,相比大家也看出来了,在神魔情况下用哪一种旋转,我都用蓝圈圈起来了,这里来总结一下</p> 
<p>1.如果 <strong>parent.bf</strong> 和 <strong>child.bf</strong> 都是<strong>正数</strong>,那么应该进行<strong>左单旋</strong>(<span style="color:#fe2c24;"><strong>同正左旋</strong></span>)</p> 
<p>2.如果 <strong>parent.bf</strong> 和 <strong>child.bf</strong> 都是<strong>负数</strong>,那么应该进行<strong>右单旋</strong>(<span style="color:#fe2c24;"><strong>同异右旋</strong></span>)</p> 
<p>3.如果 parent.bf 为正 child.bf为负 ,右左双旋</p> 
<p>4.如果parent.bf为负  child.bf 为正 ,左右双旋</p> 
<p>记的话估计不太好记,但是有一点一定可以记住,<span style="color:#fe2c24;">同单异双</span>(同号单旋,异号双旋),大家还是重在理解</p> 
<hr> 
<p>给出部分代码</p> 
<pre><code class="language-java">        // 2.调节平衡因子
        while(parent != null){
            // 先看child是parent的左还是右,判断bf是++还是--
            if(child == parent.right){
                // child是parent的左树 bf++
                parent.bf++;
            }else{
                // child是parent的右树 bf++
                parent.bf--;
            }

            // 根据parent的负载因子判断是否需要继续向上调整 bf[-1,0,1]
            if(parent.bf == 0){
                // 当前子树平衡代表上面的也已经平衡
                break;
            }else if(parent.bf == 1 || parent.bf == -1){
                // 上面的树不一定平衡,继续向上调整
                child = parent;
                parent = parent.parent;
            }else {
                if (parent.bf == 2) {
                    if (child.bf == 1) {
                        // 左单旋
                        rotateLeft(parent);

                    } else if (child.bf == -1) {
                        // 右左双旋
                        rotateRL(parent);
                    }
                } else {
                    if (child.bf == -1) {
                        // 右单旋
                        rotateRight(parent);
                    } else if (child.bf == 1) {
                        // 左右双旋
                        rotateLR(parent);
                    }
                }
                // 上述代码走完平衡!!
                break;
            }
        }</code></pre> 
<p>下面就是真正写旋转的代码了,我会带着大家实现一个单旋和一个双旋,剩下的就是照着葫芦画瓢,相比大家应该没什么问题</p> 
<hr> 
<h2 id="%E5%9B%9B%20.%20AVL%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC">四 . AVL树的旋转</h2> 
<h3 id="1.%E5%B7%A6%E5%8D%95%E6%97%8B">1.左单旋</h3> 
<p>我们先定义变量,不需要为了节省空间搞成parent.parent.left.right.left 举个例子,实际上没有这么多嵌套</p> 
<p><img alt="" height="770" src="https://images2.imgbox.com/f7/e2/vP2BqIO7_o.png" width="886"></p> 
<p>现在来想一个问题: 如果60往上提,那以40为根节点的子树该放在哪? 想清楚这个问题,那么恭喜你</p> 
<p>你完全有能力去手撕后面的代码,即使一些细节你考虑不到! 不要往下看,自己想想吧,下面的图会有助于大家理解的</p> 
<p><img alt="" height="480" src="https://images2.imgbox.com/cb/c7/eVUGqUlb_o.png" width="795"></p> 
<p>首先要明白一个问题,60提上去之后成为了这颗子树的根节点,根据二叉搜索树的性质,40应该放在60的左侧,答案依然明了,30的左子树指向60的左子树</p> 
<p><img alt="" height="463" src="https://images2.imgbox.com/1d/30/9FPKu5Jo_o.png" width="695"></p> 
<p>到这里已经可以手撕一部分代码了</p> 
<p><img alt="" height="926" src="https://images2.imgbox.com/83/4f/fwK1V646_o.png" width="1200"></p> 
<p>以为到这里就忘了吗? nonono 在这里发出灵魂三问</p> 
<p>1. 30是否还有父节点? 如果有的话不改变指向的话会怎么样?</p> 
<p>2.subRL有没有可能为空? 如果为空会不会发生空指针异常?</p> 
<p>3.parent有没有可能为root?</p> 
<p>都是一些细节问题,直接给出代码,大家自行理解,理解不了评论区留言</p> 
<pre><code class="language-java">private void rotateLeft(TreeNode parent) {
        // 定义变量
        TreeNode subR = parent.right;
        TreeNode subRL = subR.left;

        // 保存parent的父节点 问题1
        TreeNode pParent = parent.parent;
        
        // 问题2 增加空指针判断
        if(subRL != null) subRL.parent = parent;
        parent.right = subRL;
        subR.left = parent;
        parent.parent = subR;

        // 问题3 增加判断
        if(parent == root){
            root = subR;
            root.parent = null;
        }else{
            if(pParent.left == parent){
                pParent.left = subR;
            }else{
                pParent.right = subR;
            }
            subR.parent = pParent;
        }
        // 根据图示修改平衡因子
        parent.bf = subR.bf = 0;
    }</code></pre> 
<p>右旋</p> 
<pre><code class="language-java">public void rotateRight(TreeNode parent){
        TreeNode subL = parent.left;
        TreeNode subLR = subL.right;

        TreeNode pParent = parent.parent;
        if(subLR != null) subLR.parent = parent;
        parent.parent = subL;
        parent.left = subLR;
        subL.right = parent;

        if(parent == root){
            // 当前的parent是根节点
            root = subL;
            root.parent = null;
        }else{
            if(pParent.left == parent){
                pParent.left = subL;
            }else{
                pParent.right = subL;
            }
            subL.parent = pParent;
        }
        parent.bf = subL.bf = 0;
    }</code></pre> 
<h3 id="2.%E5%B7%A6%E5%8F%B3%E5%8F%8C%E6%97%8B">2.左右双旋</h3> 
<p><img alt="" height="560" src="https://images2.imgbox.com/a6/c8/12IwPz9O_o.png" width="1200"></p> 
<p><img alt="" height="645" src="https://images2.imgbox.com/3c/2b/xD2LYL5l_o.png" width="1200"></p> 
<p>左右双旋无非就是经过两次旋转,只要单旋搞清楚了,双旋完全没有难度,值的一提的是,平衡因子的修改需要根据subLR.bf来进行判断,除此之外,没有其他的细节了</p> 
<pre><code class="language-java">    /*
    * 右左双旋
    * */
    private void rotateRL(TreeNode parent) {
        TreeNode subR = parent.right;
        TreeNode subRL = subR.left;
        int bf = subRL.bf;

        rotateRight(subR);
        rotateLeft(parent);

        if(bf == -1){
            parent.bf = subRL.bf = 0;
            subR.bf = 1;
        }else{
            subRL.bf= subR.bf = 0;
            parent .bf = -1;
        }
    }

    /*
    * 左右双旋
    * */
    private void rotateLR(TreeNode parent) {
        TreeNode subL = parent.left;
        TreeNode subLR = subL.right;

        int bf = subLR.bf;
        
        rotateLeft(subL);
        rotateRight(parent);

        if(bf == -1){
            subL.bf = subLR.bf = 0;
            parent.bf = -1;
        }else{
            subL.bf = -1;
            subLR.bf = parent.bf = 0;
        }

    }</code></pre> 
<p>最后来验证一下是否成功,主要是根据中序遍历的结果是否有序和左右子树的高度差不超过一来进行验证</p> 
<p><img alt="" height="941" src="https://images2.imgbox.com/e0/f1/jwdtqVq6_o.png" width="1020"></p> 
<hr> 
<h2 id="%E4%BA%94%20.%20AVL%E6%A0%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">五 . AVL树性能分析</h2> 
<p>AVL树是一棵绝对平衡的二叉搜索树，其要求每个节点的左右子树高度差的绝对值都不超过1，这样可以保证查询 时高效的时间复杂度，即 <img alt="O(log2n)" class="mathcode" src="https://images2.imgbox.com/cc/b5/elh1zbmE_o.png">。但是如果要对AVL树做一些结构修改的操作，性能非常低下，比如：插入时要 维护其绝对平衡，旋转的次数比较多，更差的是在删除时，有可能一直要让旋转持续到根的位置。因此：如果<strong>需要 一种查询高效且有序的数据结构，而且数据的个数为静态的(即不会改变)，可以考虑AVL树，但一个结构经常修 改，就不太适合</strong>。</p> 
<hr> 
<h2 id="%E6%80%BB%E7%BB%93"><a id="_45"></a>总结</h2> 
<p>大家多多理解,我们下一篇博客见</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5fea089a1c96596c72b0c655cfe898c5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">番外篇Diffusion&amp;Stable Diffusion扩散模型与稳定扩散模型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c08a91e8a49dc9ad59995dfbb3a84f8c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">李宏毅机器学习第十八周周报GAN2</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>