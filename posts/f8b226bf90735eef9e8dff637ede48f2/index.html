<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>实验5 二叉树的应用程序设计 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="实验5 二叉树的应用程序设计" />
<meta property="og:description" content="实验预备知识：
1．掌握二叉树的创建和遍历算法。
2．掌握哈夫曼编码原理。
一、实验目的 1．进一步掌握二叉树的存储结构和相应算法。
2．掌握哈夫曼树树的创建和哈夫曼编码。
二、实验环境 ⒈ 硬件：每个学生需配备计算机一台。操作系统：Windows。
⒉ 软件：Windows操作系统&#43;Visual C&#43;&#43;。 三、实验要求 1．要求采用二叉链表作为存储结构，完成哈夫曼树的创建。
2．输出对应数据的哈夫曼编码，并求出平均编码长度。
四、实验内容 1．在自己的U盘的“学号&#43;姓名”文件夹中创建“实验5”文件夹，本次实验的所有程序和数据都要求存储到本文件夹中。
2．现在某电报公司假设有10字符进行编码，这10个字符的使用频率如下表所示，请创建哈夫曼树。
A
B
C
D
E
F
G
H
I
J
19
18
16
14
12
8
6
4
2
1
编写函数求出A~J的哈夫曼编码。 #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;map&gt; using namespace std; struct Node { char data; // 字符 int freq; // 频率 Node* left; Node* right; Node(char d, int f) : data(d), freq(f), left(nullptr), right(nullptr) {} // 这里的Node(char d, int f) : data(d), freq(f), left(nullptr), right(nullptr) {} // 是一个构造函数，用于创建Node对象并进行初始化。 // 它采用了成员初始化列表的方式，将传入的参数d和f分别赋值给data和freq成员变量， // 并将left和right指针初始化为nullptr（空指针）。 //使用成员初始化列表的方式可以提高代码的效率和可读性。 // 在构造函数体中，如果需要对成员变量进行赋值， // 需要使用赋值运算符，这会导致多余的内存分配和拷贝操作。 // 而使用成员初始化列表可以直接对成员变量进行初始化， // 避免了这些额外的操作，从而提高了代码的效率。 //就相当于java的构造函数 }; struct Compare { bool operator()(Node* a, Node* b) { return a-&gt;freq &gt; b-&gt;freq; } }; //权值越大，在树的前面越小，就是最优的路径解 // 创建哈夫曼树 Node* createHuffmanTree(map&lt;char, int&gt;&amp; freqMap) { priority_queue&lt;Node*, vector&lt;Node*&gt;, Compare&gt; pq;//排序 //这个容器相当于是队列的容器，是其中里面的， //是队列中存放的空间为容器。 //插入数据的步骤,导入数据和排序 for (const auto&amp; pair : freqMap) { Node* node = new Node(pair." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f8b226bf90735eef9e8dff637ede48f2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-26T20:22:23+08:00" />
<meta property="article:modified_time" content="2023-10-26T20:22:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">实验5 二叉树的应用程序设计</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="text-align:center;"></h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">实验预备知识：</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">1</span><span style="color:#000000;">．掌握二叉树的创建和遍历算法。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">2</span><span style="color:#000000;">．掌握</span><span style="color:#000000;">哈夫曼</span><span style="color:#000000;">编码原理。</span></p> 
<h3 style="text-align:justify;"><strong><span style="color:#000000;">一、实验目的</span></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">1．进一步掌握二叉树的存储结构和相应算法。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">2．掌握</span><span style="color:#000000;">哈夫曼</span><span style="color:#000000;">树树的创建和</span><span style="color:#000000;">哈夫曼</span><span style="color:#000000;">编码。</span></p> 
<h3 style="text-align:justify;"><strong><span style="color:#000000;">二、实验环境</span></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">⒈ 硬件：每个学生需配备计算机一台。操作系统：</span><span style="color:#000000;">Windows</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">⒉ 软件：</span><span style="color:#000000;">Windows</span><span style="color:#000000;">操作系统+</span><span style="color:#000000;">Visual C++。</span> </p> 
<h3 style="text-align:justify;"><strong><span style="color:#000000;">三、实验要求</span></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">1．要求采用二叉链表作为</span><span style="color:#000000;">存储</span><span style="color:#000000;">结构，完成</span><span style="color:#000000;">哈夫曼</span><span style="color:#000000;">树的创建。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">2．输出对应数据的</span><span style="color:#000000;">哈夫曼</span><span style="color:#000000;">编码，并求出平均编码长度。</span></p> 
<h3 style="text-align:justify;"><strong><span style="color:#000000;">四、实验内容</span></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">1．</span><span style="color:#000000;">在自己的U盘的“</span><span style="color:#000000;">学号+姓名</span><span style="color:#000000;">”文件夹中创建“实验</span><span style="color:#000000;">5</span><span style="color:#000000;">”文件夹，本次实验的所有程序和数据都要求存储到本文件夹中。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">2．现在某电报公司假设有10字符进行编码，这10个字符的使用频率如下表所示，请创建</span><span style="color:#000000;">哈夫曼</span><span style="color:#000000;">树。</span></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:43.8pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">A</span></p> </td><td style="vertical-align:top;width:43.8pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">B</span></p> </td><td style="vertical-align:top;width:43.8pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">C</span></p> </td><td style="vertical-align:top;width:43.8pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">D</span></p> </td><td style="vertical-align:top;width:43.8pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">E</span></p> </td><td style="vertical-align:top;width:43.8pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">F</span></p> </td><td style="vertical-align:top;width:43.85pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">G</span></p> </td><td style="vertical-align:top;width:43.85pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">H</span></p> </td><td style="vertical-align:top;width:43.85pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">I</span></p> </td><td style="vertical-align:top;width:43.85pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">J</span></p> </td></tr><tr><td style="vertical-align:top;width:43.8pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">19</span></p> </td><td style="vertical-align:top;width:43.8pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">18</span></p> </td><td style="vertical-align:top;width:43.8pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">16</span></p> </td><td style="vertical-align:top;width:43.8pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">14</span></p> </td><td style="vertical-align:top;width:43.8pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">12</span></p> </td><td style="vertical-align:top;width:43.8pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">8</span></p> </td><td style="vertical-align:top;width:43.85pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">6</span></p> </td><td style="vertical-align:top;width:43.85pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">4</span></p> </td><td style="vertical-align:top;width:43.85pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">2</span></p> </td><td style="vertical-align:top;width:43.85pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">1</span></p> </td></tr></tbody></table> 
<ol><li style="text-align:justify;"><span style="color:#000000;">编写函数求出A~J的</span><span style="color:#000000;">哈夫曼</span><span style="color:#000000;">编码。</span></li></ol> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;map&gt;
using namespace std;

struct Node {
    char data; // 字符
    int freq; // 频率
    Node* left;
    Node* right;

    Node(char d, int f) : data(d), freq(f), left(nullptr), right(nullptr) {}


//    这里的Node(char d, int f) : data(d), freq(f), left(nullptr), right(nullptr) {}
// 是一个构造函数，用于创建Node对象并进行初始化。
//        它采用了成员初始化列表的方式，将传入的参数d和f分别赋值给data和freq成员变量，
// 并将left和right指针初始化为nullptr（空指针）。
//使用成员初始化列表的方式可以提高代码的效率和可读性。
//        在构造函数体中，如果需要对成员变量进行赋值，
// 需要使用赋值运算符，这会导致多余的内存分配和拷贝操作。
//        而使用成员初始化列表可以直接对成员变量进行初始化，
// 避免了这些额外的操作，从而提高了代码的效率。

    //就相当于java的构造函数
        
};

struct Compare {
    bool operator()(Node* a, Node* b) {
        return a-&gt;freq &gt; b-&gt;freq;   
    }
};
//权值越大，在树的前面越小，就是最优的路径解


// 创建哈夫曼树
Node* createHuffmanTree(map&lt;char, int&gt;&amp; freqMap) {
    priority_queue&lt;Node*, vector&lt;Node*&gt;, Compare&gt; pq;//排序
    //这个容器相当于是队列的容器，是其中里面的，
    //是队列中存放的空间为容器。


    //插入数据的步骤,导入数据和排序
    for (const auto&amp; pair : freqMap) {
        Node* node = new Node(pair.first, pair.second);


        //    for (const auto&amp; pair : freqMap) { ... } 是 C++11 引入的一种新的循环语法，
        // 叫做基于范围的 for 循环（range - based for loop）。
        //
        //        在这个循环中，freqMap 是你要遍历的容器，c
        // onst auto&amp; pair 是每次迭代时从 freqMap 中取出的元素。
        //
        //        解释一下 const auto&amp; pair：
        //
        //        auto 是 C++11 引入的一种新的类型推断机制。
        // 编译器会自动推断 pair 的类型，你不需要显式地指定。
        //        在这个例子中，freqMap 是一个 map&lt;char, int&gt; 类型的容器，
        // 所以 pair 的类型会被推断为 pair&lt;const char, int&gt;。
        //
        //        const 表示这个变量是常量，你不能修改它的值。
        // 这是一种好的编程习惯，因为它可以防止你在循环中意外地修改了 pair 的值。
        //
        //        &amp; 表示引用。如果没有&amp; ，那么每次迭代时，
        // 都会从 freqMap 中复制一个元素到 pair。
        //如果 pair 的类型很大，那么这将会是一个很耗时的操作。
        // 但是有了&amp; ，pair 就是 freqMap 中元素的一个引用，不会发生复制，可以提高代码的效率。


   /*     new Node(pair.first, pair.second) 这部分代码调用了 Node 类的构造函数，
            创建一个新的 Node 对象。这个构造函数接受两个参数：pair.first 和 pair.second。
            在这个上下文中，pair 是 freqMap 中的一个元素，它是一个键值对。
            pair.first 是字符（char 类型），pair.second 是该字符的频率（int 类型）。*/

        pq.push(node);//插入
    }

    //开始构建哈夫曼树
    while (pq.size() &gt; 1) {
        Node* left = pq.top();
        pq.pop();
        Node* right = pq.top();
        pq.pop();

        Node* parent = new Node('$', left-&gt;freq + right-&gt;freq); // 虚拟节点
        //这里的$只是随便找了个字符充当字符的位置，没什么特殊意义
        //核心是为了合成根节点

        parent-&gt;left = left;
        parent-&gt;right = right;
        //这两步就是为了连接后面的数据的
        //返回的只是根节点，但是后面节点的遍历和数据都存在left和right节点中

        pq.push(parent);
    }

    return pq.top();//最后size为1时，一定是根节点

}

// 遍历哈夫曼树获取编码
void getHuffmanCodes(Node* root, string code, map&lt;char, string&gt;&amp; huffmanCodes) {
    if (root == nullptr) {
        return;
    }

    if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) { // 叶子节点
        huffmanCodes[root-&gt;data] = code;
        //获取编码关键步骤
    }

    getHuffmanCodes(root-&gt;left, code + "0", huffmanCodes);
    getHuffmanCodes(root-&gt;right, code + "1", huffmanCodes);
}

// 输出哈夫曼编码
void printHuffmanCodes(map&lt;char, string&gt;&amp; huffmanCodes) {
    for (const auto&amp; pair : huffmanCodes) {
        cout &lt;&lt; pair.first &lt;&lt; ": " &lt;&lt; pair.second &lt;&lt; endl;
        //      char                   string
    }
}

// 计算平均编码长度
float getAverageCodeLength(map&lt;char, int&gt;&amp; freqMap, map&lt;char, string&gt;&amp; huffmanCodes) {
    float totalFreq = 0;
    float totalCodeLen = 0;

    for (const auto&amp; pair : freqMap) {
        totalFreq += pair.second;
        totalCodeLen += pair.second * huffmanCodes[pair.first].length();
        //频率*单个字符的编码长度
        //huffmanCodes[pair.first]其实就是huffmanCodes的pair.second
        //只不过我们现在在按照freqMap循环.
        //而他们的pair.first是相同的
        //其实本质上来说,
        //freqMap用于存放频率
        //huffmanCodes用于存放编码
    }

    return totalCodeLen / totalFreq;
}

int main() {
    map&lt;char, int&gt; freqMap = {
        {'A', 19},
        {'B', 18},
        {'C', 16},
        {'D', 14},
        {'E', 12},
        {'F', 8},
        {'G', 6},
        {'H', 4},
        {'I', 2},
        {'J', 1}
    };//原始数据

    Node* root = createHuffmanTree(freqMap);
    //哈夫曼树的根节点，里面包括整个哈夫曼树

    map&lt;char, string&gt; huffmanCodes;//这个是用来获取哈夫曼树编码的哈希表
    getHuffmanCodes(root, "", huffmanCodes);

    cout &lt;&lt; "Huffman Codes:" &lt;&lt; endl;
    printHuffmanCodes(huffmanCodes);

    float averageCodeLength = getAverageCodeLength(freqMap, huffmanCodes);
    cout &lt;&lt; "Average Code Length: " &lt;&lt; averageCodeLength &lt;&lt; endl;

    return 0;
}
</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/36d6ea390c5465568dc4317d93eb4a13/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux 中RabbitMQ 常用命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/db04f425abf99e8ccfc3ba2e348e96de/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">match-case的使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>