<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【深度学习】OpenCV——阈值操作和图像上的运算 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【深度学习】OpenCV——阈值操作和图像上的运算" />
<meta property="og:description" content="目录
1 阀值操作
1.1 简单阀值
1.2 OTSU二值化
1.3 自适应阀值
2 图像上的运算
2.1 加减法
2.2 图像混合
2.3 按位运算
1 阀值操作 1.1 简单阀值 像素值高于阈值时，我们给这个像素赋予一个新值（可能是白色），否则我们给它赋予另外一种颜色（也许是黑色）。这个函数就是cv2.threshold(src, thresh, maxval, type[, dst]) 第一个参数就是原图像，原图像应该是灰度图。第二个参数就是用来对像素值进行分类的阈值。第三个参数就是当像素值高于（有时是小于）阈值时应该被赋予的新的像素值。OpenCV提供了多种不同的阈值方法，这是有第四个参数来决定的。这些方法包括：【博客——图像阈值处理cv2.threshold()函数】
cv2.THRESH_BINARY || cv2.THRESH_BINARY_INV || cv2.THRESH_TRUNC || cv2.THRESH_TOZERO || cv2.THRESH_TOZERO_INV
&#34;&#34;&#34; Python阀值操作 &#34;&#34;&#34; import cv2 import numpy as np from matplotlib import pyplot as plt img = cv2.imread(&#39;5.jpg&#39;) img_Gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) &#34;&#34;&#34; 将大于127小于等于255的值设为255，其余设为0 &#34;&#34;&#34; ret,thresh1 = cv2.threshold(img,127,255,cv2.THRESH_BINARY) &#34;&#34;&#34; 将大于127小于等于255的值设为0，其余设为255 &#34;&#34;&#34; ret,thresh2 = cv2.threshold(img,127,255,cv2.THRESH_BINARY_INV) &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2f97f75d9543e7097c4e5028cce46abc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-04T21:00:23+08:00" />
<meta property="article:modified_time" content="2020-12-04T21:00:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【深度学习】OpenCV——阈值操作和图像上的运算</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="5%C2%A0%E9%98%80%E5%80%BC%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#5%C2%A0%E9%98%80%E5%80%BC%E6%93%8D%E4%BD%9C" rel="nofollow">1 阀值操作</a></p> 
<p id="5.1%20%E7%AE%80%E5%8D%95%E9%98%80%E5%80%BC-toc" style="margin-left:40px;"><a href="#5.1%20%E7%AE%80%E5%8D%95%E9%98%80%E5%80%BC" rel="nofollow">1.1 简单阀值</a></p> 
<p id="5.1%C2%A0OTSU%E4%BA%8C%E5%80%BC%E5%8C%96-toc" style="margin-left:40px;"><a href="#5.1%C2%A0OTSU%E4%BA%8C%E5%80%BC%E5%8C%96" rel="nofollow">1.2 OTSU二值化</a></p> 
<p id="5.2%20%E8%87%AA%E9%80%82%E5%BA%94%E9%98%80%E5%80%BC-toc" style="margin-left:40px;"><a href="#5.2%20%E8%87%AA%E9%80%82%E5%BA%94%E9%98%80%E5%80%BC" rel="nofollow">1.3 自适应阀值</a></p> 
<p id="6%20%E5%9B%BE%E5%83%8F%E4%B8%8A%E7%9A%84%E8%BF%90%E7%AE%97-toc" style="margin-left:0px;"><a href="#6%20%E5%9B%BE%E5%83%8F%E4%B8%8A%E7%9A%84%E8%BF%90%E7%AE%97" rel="nofollow">2 图像上的运算</a></p> 
<p id="6.1%20%E5%8A%A0%E5%87%8F%E6%B3%95-toc" style="margin-left:40px;"><a href="#6.1%20%E5%8A%A0%E5%87%8F%E6%B3%95" rel="nofollow">2.1 加减法</a></p> 
<p id="6.2%C2%A0%C2%A0%E5%9B%BE%E5%83%8F%E6%B7%B7%E5%90%88-toc" style="margin-left:40px;"><a href="#6.2%C2%A0%C2%A0%E5%9B%BE%E5%83%8F%E6%B7%B7%E5%90%88" rel="nofollow">2.2  图像混合</a></p> 
<p id="6.3%20%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97-toc" style="margin-left:40px;"><a href="#6.3%20%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97" rel="nofollow">2.3 按位运算</a></p> 
<hr id="hr-toc"> 
<h2 id="5%C2%A0%E9%98%80%E5%80%BC%E6%93%8D%E4%BD%9C">1 <strong>阀值操作</strong></h2> 
<h3 id="5.1%20%E7%AE%80%E5%8D%95%E9%98%80%E5%80%BC">1.1 简单<strong>阀值</strong></h3> 
<p style="text-indent:33px;">像素值高于阈值时，我们给这个像素赋予一个新值（可能是白色），否则我们给它赋予另外一种颜色（也许是黑色）。这个函数就是<strong>cv2.threshold(src, thresh, maxval, type[, dst]) </strong>第一个参数就是原图像，原图像应该是灰度图。第二个参数就是用来对像素值进行分类的阈值。第三个参数就是当像素值高于（有时是小于）阈值时应该被赋予的新的像素值。OpenCV提供了多种不同的阈值方法，这是有第四个参数来决定的。这些方法包括：<a href="https://blog.csdn.net/a19990412/article/details/81172426">【博客——图像阈值处理cv2.threshold()函数】</a></p> 
<p style="text-indent:33px;">cv2.THRESH_BINARY<strong> <span style="color:#f33b45;">||</span></strong> cv2.THRESH_BINARY_INV <strong><span style="color:#f33b45;">||</span></strong> cv2.THRESH_TRUNC <strong><span style="color:#f33b45;">|| </span></strong>cv2.THRESH_TOZERO<strong> <span style="color:#f33b45;">||</span></strong> cv2.THRESH_TOZERO_INV</p> 
<p style="text-indent:33px;"><img alt="" height="309" src="https://images2.imgbox.com/fe/04/MKk3sy8Y_o.png" width="418"></p> 
<pre><code class="language-python">""" Python阀值操作 """
import cv2 
import numpy as np 
from matplotlib import pyplot as plt 

img = cv2.imread('5.jpg') 
img_Gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)

""" 将大于127小于等于255的值设为255，其余设为0 """
ret,thresh1 = cv2.threshold(img,127,255,cv2.THRESH_BINARY) 

""" 将大于127小于等于255的值设为0，其余设为255 """
ret,thresh2 = cv2.threshold(img,127,255,cv2.THRESH_BINARY_INV) 

""" 将大于127小于等于255的值设为255，其余设为不变"""
ret,thresh3 = cv2.threshold(img,127,255,cv2.THRESH_TRUNC) 

""" 将大于127小于等于255的值不变，其余设为0 """
ret,thresh4 = cv2.threshold(img,127,255,cv2.THRESH_TOZERO) 

""" 将大于127小于等于255的值设为0，其余不变 """
ret,thresh5 = cv2.threshold(img,127,255,cv2.THRESH_TOZERO_INV) 
titles = ['Original Image','BINARY','BINARY_INV','TRUNC','TOZERO','TOZERO_INV'] 
images = [img_Gray, thresh1, thresh2, thresh3, thresh4, thresh5] 

for i in range(6):
    plt.subplot(2,3,i+1)
    plt.imshow(images[i],'gray') 
    plt.title(titles[i])         
    plt.xticks([]),plt.yticks([])
plt.show()</code></pre> 
<p style="text-indent:33px;"><img alt="" height="392" src="https://images2.imgbox.com/c4/71/TSiiKj9P_o.png" width="450"></p> 
<h3 id="5.1%C2%A0OTSU%E4%BA%8C%E5%80%BC%E5%8C%96"><strong>1.2 OTSU</strong><strong>二值化 </strong></h3> 
<p style="text-indent:33px;">由OTSU算子寻找全局最佳的阀值。<a href="https://blog.csdn.net/on2way/article/details/46812121?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160647037619724813262010%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160647037619724813262010&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-13-46812121.pc_search_result_no_baidu_js&amp;utm_term=Python%20%E4%B8%8Bopencv%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0&amp;spm=1018.2118.3001.4449">【博客 — Python下opencv使用笔记（四）（图像的阈值处理）】</a></p> 
<pre><code class="language-python">import cv2
img = cv2.imread("..\Image\SpongeBobSquarePants.jpg") """ 读取图片 """
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)          """ 将图片转为灰度图 """
ret, binary = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU) """ 将初始阀值设为0，由算法去寻找全局最佳的阀值 """
cv2.imshow("gray",gray)
cv2.imshow('binary', binary)
cv2.waitKey(0)</code></pre> 
<p style="text-indent:33px;"><img alt="" height="245" src="https://images2.imgbox.com/6f/0c/YPhhRoFI_o.png" width="793"></p> 
<h3 id="5.2%20%E8%87%AA%E9%80%82%E5%BA%94%E9%98%80%E5%80%BC"><strong>1.3 自适应阀值</strong></h3> 
<p style="text-indent:33px;">前面的部分我们使用是全局阈值，整幅图像采用同一个数作为阈值。当时这种方法并不适应与所有情况，尤其是当同一幅图像上的不同部分的具有不同亮度时。这种情况下我们需要采用自适应阈值。此时的阈值是根据图像上的每一个小区域计算与其对应的阈值。因此在同一幅图像上的不同区域采用的是不同的阈值，从而使我们能在亮度不同的情况下得到更好的结果。这种方法需要我们指定三个参数，返回值只有一个。</p> 
<ul><li>Adaptive Method- 指定计算阈值的方法。</li></ul> 
<p style="text-indent:33px;">cv2.ADPTIVE_THRESH_MEAN_C：阈值取自相邻区域的平均值</p> 
<p style="text-indent:33px;">cv2.ADPTIVE_THRESH_GAUSSIAN_C：阈值取值相邻区域的加权和，权重为一个高斯窗口。</p> 
<ul><li>Block Size - 邻域大小（用来计算阈值的区域大小）。</li><li>C - 这就是是一个常数，阈值就等于的平均值或者加权平均值减去这个常数</li></ul> 
<pre><code class="language-python">""" Python自适应阀值 """
import cv2 
import numpy as np 
from matplotlib import pyplot as plt 

img = cv2.imread('4.jpg', 0) 
img = cv2.GaussianBlur(img, (5, 5), 0) 

ret, th1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY) 
th2 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 2)
th3 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2) 

titles = ['Original Image', 'Global Thresholding (v = 127)', 'Adaptive Mean Thresholding', 'Adaptive Gaussian Thresholding'] 
images = [img, th1, th2, th3] 

for i in range(4): 
    plt.subplot(2, 2, i + 1), plt.imshow(images[i], 'gray') 
    plt.title(titles[i]) 
    plt.xticks([]), plt.yticks([]) 
plt.show()</code></pre> 
<p style="text-indent:33px;"><img alt="" height="302" src="https://images2.imgbox.com/c5/96/oX8DlsHF_o.png" width="405"></p> 
<h2 id="6%20%E5%9B%BE%E5%83%8F%E4%B8%8A%E7%9A%84%E8%BF%90%E7%AE%97"><strong>2 图像上的运算 </strong></h2> 
<h3 id="6.1%20%E5%8A%A0%E5%87%8F%E6%B3%95"><strong>2.1 加减法 </strong></h3> 
<pre><code class="language-python">""" Python """
import cv2 
import numpy as np 

x = np.uint8([245]) """ 非uint8数据类型只是普通加法 """
y = np.uint8([255])

print(cv2.add(x, y))        """ x + y 打印结果：[[255]] """

print(cv2.subtract(x,y))    """ x - y 打印结果：[[0]] """</code></pre> 
<h3 id="6.2%C2%A0%C2%A0%E5%9B%BE%E5%83%8F%E6%B7%B7%E5%90%88">2.2  <strong>图像混合</strong></h3> 
<p>这其实也是加法，但是不同的是两幅图像的权重不同，这就会给人一种混合或者透明的感觉。图像混合 的计算公式如下： g(x)=(1−\alpha) f_{0} (x) + \alpha f_{1} (x)</p> 
<p>通过修改 α 的值（0 → 1），可以实现非常多的混合。 现在我们把两幅图混合在一起。第一幅图的权重是 0.7，第二幅图的权重是 0.3。函数 cv2.addWeighted() 可以按下面的公式对图片进行混合操作。 dst = α · img1 + β · img2 + γ 这里 γ 的取值为 0。</p> 
<pre><code class="language-python">""" Python """
import cv2
""" 两张图片大小需要一样：同w、同h、同通道数 """
dog_img = cv2.imread("../Image/dog.jpg")
dog_img = cv2.resize(dog_img,(960,540))

bg_img = cv2.imread("../Image/bg.jpg")
bg_img = cv2.resize(bg_img,(960,540))

print(dog_img.shape, bg_img.shape) """ 打印结果：(540, 960, 3) (540, 960, 3) """
cv2.imshow("dog ", dog_img)
cv2.imshow("bg ", bg_img)

_img = cv2.addWeighted(dog_img, 0.7, bg_img, 0.2,gamma=0)
cv2.imshow("_img", _img)
cv2.waitKey(0)
cv2.destroyAllWindows()</code></pre> 
<p><span style="color:#f33b45;"><strong>下图红字为截图时添加。</strong></span> </p> 
<p style="text-indent:33px;"><img alt="" height="557" src="https://images2.imgbox.com/ae/d2/pGkqTME3_o.png" width="993"></p> 
<p style="text-indent:33px;"> </p> 
<h3 id="6.3%20%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97">2.3 按位运算</h3> 
<p>这里包括的按位操作有：AND，OR，NOT，XOR 等。当我们提取图像的一部分，选择非矩形 ROI 时这些操作会很有用。<a href="https://blog.csdn.net/yunyuehu/article/details/5408446">【博客 — 与、或、非、异或】</a></p> 
<pre><code class="language-python">import cv2 

img1 = cv2.imread('1.jpg') 
img2 = cv2.imread('9.jpg') 

rows, cols, channels = img2.shape 
roi = img1[0:rows, 0:cols]
img2gray = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY) 
ret, mask = cv2.threshold(img2gray, 10, 255, cv2.THRESH_BINARY) 

mask_inv = cv2.bitwise_not(mask) 
# cv2.imshow("mask_inv",mask_inv) 

""" 按照mask进行镂空操作 """
img1_bg = cv2.bitwise_and(roi, roi, mask=mask_inv) 
# cv2.imshow("img1_bg",img1_bg) 

img2_fg = cv2.bitwise_and(img2, img2, mask=mask) 
# cv2.imshow("img2_fg",img2_fg) 

dst = cv2.add(img1_bg, img2_fg) 
img1[0:rows, 0:cols] = dst 
cv2.imshow('res', img1) 
cv2.waitKey(0)</code></pre> 
<blockquote> 
 <p>作者：阳一子</p> 
 <p>本文地址：<a href="https://blog.csdn.net/qq_279033270/article/details/110235905">https://blog.csdn.net/qq_279033270/article/details/110235905</a></p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/36d3d9bd95465f4bba63895af410b44a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Fletcher校验和算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f1e0e68a4865a271c6cbf68ff01f6994/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">XAML语言基本介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>