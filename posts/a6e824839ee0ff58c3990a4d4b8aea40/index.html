<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>面试官：说说常见的排序算法有哪些？区别？ - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="面试官：说说常见的排序算法有哪些？区别？" />
<meta property="og:description" content="一、是什么 排序是程序开发中非常常见的操作，对一组任意的数据元素经过排序操作后，就可以把他们变成一组一定规则排序的有序序列
排序算法属于算法中的一种，而且是覆盖范围极小的一种，彻底掌握排序算法对程序开发是有很大的帮助的
对于排序算法的好坏衡量，主要是从时间复杂度、空间复杂度、稳定性
时间复杂度、空间复杂度前面已经讲过，这里主要看看稳定性的定义
稳定性指的是假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变
即在原序列中，r[i] = r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的
二、有哪些 常见的算法排序算法有：
冒泡排序
选择排序
插入排序
归并排序
快速排序
冒泡排序 一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来
思路如下：
比较相邻的元素，如果第一个比第二个大，就交换它们两个
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数
针对所有的元素重复以上的步骤，除了最后一个
重复上述步骤，直到没有任何一堆数字需要比较
选择排序 选择排序是一种简单直观的排序算法，它也是一种交换排序算法
无论什么数据进去都是 O(n²)的时间复杂度。所以用到它的时候，数据规模越小越好
唯一的好处是不占用额外的内存存储空间
思路如下：
在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
重复第二步，直到所有元素均排序完毕
插入排序
插入排序是一种简单直观的排序算法
它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入
解决思路如下：
把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的
从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）
重复上述过程直到最后一个元素被插入有序子数组中
归并排序 归并排序是建立在归并操作上的一种有效的排序算法
该算法是采用分治法的一个非常典型的应用
将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序
解决思路如下：
申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
设定两个指针，最初位置分别为两个已经排序序列的起始位置
比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
重复步骤3直到某一指针到达序列尾
将另一序列剩下的所有元素直接复制到合并序列尾
快速排序 快速排序是对冒泡排序算法的一种改进，基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小
再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列
解决思路如下：
从数列中挑出一个元素，称为&#34;基准&#34;（pivot）
重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作
递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序
三、区别 除了上述的排序算法之外，还存在其他的排序算法，例如希尔排序、堆排序等等......
区别如下图所示：
参考文献 https://www.runoob.com/w3cnote/bubble-sort.html
http://www.x-lab.info/post/sort-algorithm/" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a6e824839ee0ff58c3990a4d4b8aea40/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-30T08:31:00+08:00" />
<meta property="article:modified_time" content="2021-09-30T08:31:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">面试官：说说常见的排序算法有哪些？区别？</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align:left;"><img src="https://images2.imgbox.com/0c/81/Q4jYWjcJ_o.png" alt="d6ee2dd65b5816474b4b0669aaf66a35.png"></p> 
 <h3>一、是什么</h3> 
 <p>排序是程序开发中非常常见的操作，对一组任意的数据元素经过排序操作后，就可以把他们变成一组一定规则排序的有序序列</p> 
 <p>排序算法属于算法中的一种，而且是覆盖范围极小的一种，彻底掌握排序算法对程序开发是有很大的帮助的</p> 
 <p>对于排序算法的好坏衡量，主要是从时间复杂度、空间复杂度、稳定性</p> 
 <p>时间复杂度、空间复杂度前面已经讲过，这里主要看看稳定性的定义</p> 
 <p>稳定性指的是假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变</p> 
 <p>即在原序列中，r[i] = r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的</p> 
 <h3>二、有哪些</h3> 
 <p>常见的算法排序算法有：</p> 
 <ul><li><p>冒泡排序</p></li><li><p>选择排序</p></li><li><p>插入排序</p></li><li><p>归并排序</p></li><li><p>快速排序</p></li></ul> 
 <h4>冒泡排序</h4> 
 <p>一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来</p> 
 <p>思路如下：</p> 
 <ul><li><p>比较相邻的元素，如果第一个比第二个大，就交换它们两个</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个</p></li><li><p>重复上述步骤，直到没有任何一堆数字需要比较</p></li></ul> 
 <img src="https://images2.imgbox.com/e2/5a/EZM0YxOX_o.png" alt="b97e53473a7c87d441757c2166719f64.png"> 
 <h4>选择排序</h4> 
 <p>选择排序是一种简单直观的排序算法，它也是一种交换排序算法</p> 
 <p>无论什么数据进去都是 <code>O(n²)</code>的时间复杂度。所以用到它的时候，数据规模越小越好</p> 
 <p>唯一的好处是不占用额外的内存存储空间</p> 
 <p>思路如下：</p> 
 <ul><li><p>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</p></li><li><p>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p></li><li><p>重复第二步，直到所有元素均排序完毕</p></li></ul> 
 <img src="https://images2.imgbox.com/46/4d/YvlMKsW1_o.png" alt="4569bbb941d0b66db226197094280fa3.png"> 
 <h4>插入排序<br></h4> 
 <p>插入排序是一种简单直观的排序算法</p> 
 <p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p> 
 <p>解决思路如下：</p> 
 <ul><li><p>把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的</p></li><li><p>从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p></li><li><p>重复上述过程直到最后一个元素被插入有序子数组中</p></li></ul> 
 <img src="https://images2.imgbox.com/cd/57/qAnVBc9j_o.gif" alt="0e2e74b47d5ddcb663cadb7b8a239ac1.gif"> 
 <h4>归并排序</h4> 
 <p>归并排序是建立在归并操作上的一种有效的排序算法</p> 
 <p>该算法是采用分治法的一个非常典型的应用</p> 
 <p>将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序</p> 
 <p>解决思路如下：</p> 
 <ul><li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</p></li><li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置</p></li><li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</p></li><li><p>重复步骤3直到某一指针到达序列尾</p></li><li><p>将另一序列剩下的所有元素直接复制到合并序列尾</p></li></ul> 
 <img src="https://images2.imgbox.com/6d/a1/qMmJPadX_o.png" alt="f12198f41db7f9267aa66b5ce0d0829a.png"> 
 <h4>快速排序</h4> 
 <p>快速排序是对冒泡排序算法的一种改进，基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小</p> 
 <p>再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列</p> 
 <p>解决思路如下：</p> 
 <ul><li><p>从数列中挑出一个元素，称为"基准"（pivot）</p></li><li><p>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作</p></li><li><p>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序</p></li></ul> 
 <img src="https://images2.imgbox.com/ca/4a/AQS5W7GZ_o.png" alt="5f8be78baee2309a31a1144cc2bc16c9.png"> 
 <h3>三、区别</h3> 
 <p>除了上述的排序算法之外，还存在其他的排序算法，例如希尔排序、堆排序等等......</p> 
 <p>区别如下图所示：</p> 
 <img src="https://images2.imgbox.com/3b/cc/IRLw0AW5_o.png" alt="8fa597671e35a40297ffa6cc94135c8e.png"> 
 <h3>参考文献</h3> 
 <ul><li><p>https://www.runoob.com/w3cnote/bubble-sort.html</p></li><li><p>http://www.x-lab.info/post/sort-algorithm/</p></li><li><p>https://zhuanlan.zhihu.com/p/42586566</p></li></ul> 
 <p style="text-align:center;">--The End--<br></p> 
 <p style="text-align:center;">系列正在更新：10/18</p> 
 <p style="text-align:center;">点击下方卡片解锁更多</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/29/d2/Y8Hcpymg_o.png" alt="706353f4c48bbe27c6773ecbfeeb99d5.png"></p> 
 <p style="text-align:center;">创作不易，星标、点赞、在看 三连支持</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f6d6fd7de77dc7bd6a4f99d5f496c33e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nginx_location</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/962f3cab14417956cacd2f4fb446d744/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于STM32的电子琴音乐播放器设计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>