<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>#1079 : 离散化&#43;线段树 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="#1079 : 离散化&#43;线段树" />
<meta property="og:description" content="时间限制: 10000ms 单点时限: 1000ms 内存限制: 256MB 描述 小Hi和小Ho在回国之后，重新过起了朝7晚5的学生生活，当然了，他们还是在一直学习着各种算法~
这天小Hi和小Ho所在的学校举办社团文化节，各大社团都在宣传栏上贴起了海报，但是贴来贴去，有些海报就会被其他社团的海报所遮挡住。看到这个场景，小Hi便产生了这样的一个疑问——最后到底能有几张海报还能被看见呢？
于是小Ho肩负起了解决这个问题的责任：因为宣传栏和海报的高度都是一样的，所以宣传栏可以被视作长度为L的一段区间，且有N张海报按照顺序依次贴在了宣传栏上，其中第i张海报贴住的范围可以用一段区间[a_i, b_i]表示，其中a_i, b_i均为属于[0, L]的整数，而一张海报能被看到当且仅当存在长度大于0的一部分没有被后来贴的海报所遮挡住。那么问题就来了：究竟有几张海报能被看到呢？
提示一：正确的认识信息量
提示二：小Hi大讲堂之线段树的节点意义
输入 每个测试点（输入文件）有且仅有一组测试数据。
每组测试数据的第1行为两个整数N和L，分别表示总共贴上的海报数量和宣传栏的宽度。
每组测试数据的第2-N&#43;1行，按照贴上去的先后顺序，每行描述一张海报，其中第i&#43;1行为两个整数a_i, b_i，表示第i张海报所贴的区间为[a_i, b_i]。
对于100%的数据，满足N&lt;=10^5，L&lt;=10^9，0&lt;=a_i&lt;b_i&lt;=L。
输出 对于每组测试数据，输出一个整数Ans，表示总共有多少张海报能被看到。
样例输入 5 10 4 10 0 2 1 6 5 9 3 4样例输出 5 离散化&#43;线段树。线段树的经典应用题（染色）。离散化的处理也是关键。
重点是建树是要注意叶子节点是（l,l&#43;1）而不是（l,l）
模板是用的是上篇
#include &lt;iostream&gt; #include &lt;string.h&gt; #include &lt;cstdio&gt; #include &lt;string&gt; #include &lt;map&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; #include &lt;set&gt; #include &lt;math.h&gt; using namespace std; #define pow2(x) (1&lt;&lt;x) #define lg2(x) (log(x*1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6fa4f4ddc013e39d178cba277b7d72f2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-04-02T16:24:39+08:00" />
<meta property="article:modified_time" content="2018-04-02T16:24:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">#1079 : 离散化&#43;线段树</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<div class="limit" style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);"> 
 <div>
   时间限制: 
  <span style="margin-left:10px;">10000ms</span> 
 </div> 
 <div>
   单点时限: 
  <span style="margin-left:10px;">1000ms</span> 
 </div> 
 <div>
   内存限制: 
  <span style="margin-left:10px;">256MB</span> 
 </div> 
</div> 
<div> 
 <h5 style="line-height:1.1;color:inherit;margin-top:10px;margin-bottom:10px;font-size:18px;">描述</h5> 
 <p style="margin-bottom:10px;">小Hi和小Ho在回国之后，重新过起了朝7晚5的学生生活，当然了，他们还是在一直学习着各种算法~</p> 
 <p style="margin-bottom:10px;">这天小Hi和小Ho所在的学校举办社团文化节，各大社团都在宣传栏上贴起了海报，但是贴来贴去，有些海报就会被其他社团的海报所遮挡住。看到这个场景，小Hi便产生了这样的一个疑问——最后到底能有几张海报还能被看见呢？</p> 
 <p style="margin-bottom:10px;">于是小Ho肩负起了解决这个问题的责任：因为宣传栏和海报的高度都是一样的，所以宣传栏可以被视作长度为L的一段区间，且有N张海报按照顺序依次贴在了宣传栏上，其中第i张海报贴住的范围可以用一段区间[a_i, b_i]表示，其中a_i, b_i均为属于[0, L]的整数，而一张海报能被看到当且仅当存在长度大于0的一部分没有被后来贴的海报所遮挡住。那么问题就来了：究竟有几张海报能被看到呢？</p> 
 <p style="margin-bottom:10px;"><a href="http://hihocoder.com/problemset/problem/1079?sid=1300224#" rel="nofollow" style="background:0px 0px;color:rgb(66,139,202);">提示一：正确的认识信息量</a></p> 
 <p style="margin-bottom:10px;"></p> 
 <p style="margin-bottom:10px;"><a href="http://hihocoder.com/problemset/problem/1079?sid=1300224#" rel="nofollow" style="background:0px 0px;color:rgb(66,139,202);">提示二：小Hi大讲堂之线段树的节点意义</a></p> 
 <p style="margin-bottom:10px;"></p> 
 <h5 style="line-height:1.1;color:inherit;margin-top:10px;margin-bottom:10px;font-size:18px;">输入</h5> 
 <p style="margin-bottom:10px;">每个测试点（输入文件）有且仅有一组测试数据。</p> 
 <p style="margin-bottom:10px;">每组测试数据的第1行为两个整数N和L，分别表示总共贴上的海报数量和宣传栏的宽度。</p> 
 <p style="margin-bottom:10px;">每组测试数据的第2-N+1行，按照贴上去的先后顺序，每行描述一张海报，其中第i+1行为两个整数a_i, b_i，表示第i张海报所贴的区间为[a_i, b_i]。</p> 
 <p style="margin-bottom:10px;">对于100%的数据，满足N&lt;=10^5，L&lt;=10^9，0&lt;=a_i&lt;b_i&lt;=L。</p> 
 <h5 style="line-height:1.1;color:inherit;margin-top:10px;margin-bottom:10px;font-size:18px;">输出</h5> 
 <p style="margin-bottom:10px;">对于每组测试数据，输出一个整数Ans，表示总共有多少张海报能被看到。</p> 
</div>样例输入 
<pre style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;white-space:pre-wrap;padding:9.5px;margin-bottom:10px;line-height:1.42857;color:rgb(51,51,51);background-color:rgb(245,245,245);border:1px solid rgb(204,204,204);">5 10
4 10
0 2
1 6
5 9
3 4</pre>样例输出 
<pre style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;white-space:pre-wrap;padding:9.5px;margin-bottom:10px;line-height:1.42857;color:rgb(51,51,51);background-color:rgb(245,245,245);border:1px solid rgb(204,204,204);">5</pre> 
<br> 
<p>离散化+线段树。线段树的经典应用题（染色）。离散化的处理也是关键。</p> 
<p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">重点是建树是要注意叶子节点是（l,l+1）而不是（l,l）</span></p> 
<p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">模板是用的是上篇</span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;math.h&gt;
using namespace std;
#define pow2(x) (1&lt;&lt;x)
#define lg2(x) (log(x*1.0)/log(2.0))

const int maxnode = 4*100005;  
int num,col;
int a[100010],b[1000010],c[200020];
map&lt;int,int&gt;mp;
int vis[800080];
int ans;
int _sum, _min, _max, op, qL, qR, v;  

struct IntervalTree {  
	int sumv[maxnode], minv[maxnode], maxv[maxnode], setv[maxnode];  

	// 维护信息  
	void maintain(int o, int L, int R) {  
		int lc = o*2, rc = o*2+1;  
		if(R &gt; L) {  
			sumv[o] = sumv[lc] + sumv[rc];  
			minv[o] = min(minv[lc], minv[rc]);  
			maxv[o] = max(maxv[lc], maxv[rc]);  
		}  
		if(setv[o] &gt;= 0) { minv[o] = maxv[o] = setv[o]; sumv[o] = setv[o] * (R-L+1); }  
	}  

	// 标记传递  
	void pushdown(int o) {  
		int lc = o*2, rc = o*2+1;  
		if(setv[o] &gt;= 0) { //本结点有标记才传递。注意本题中set值非负，所以-1代表没有标记  
			setv[lc] = setv[rc] = setv[o];  
			setv[o] = -1; // 清除本结点标记  
		}  
	}  

	void update(int o, int L, int R) {  
		int lc = o*2, rc = o*2+1;  
		if(qL &lt;= L &amp;&amp; qR &gt;= R) { // 标记修改  
			setv[o] = v;    
			//maintain(o, L, R);  
			return;
		}
		if(L+1==R) 
		{
			//maintain(o, L, R);  
			return;
		}
		pushdown(o);  
		int M = L + (R-L)/2;  
		if(qL &lt;= M) update(lc, L, M); else maintain(lc, L, M);  
		if(qR &gt;=M) update(rc, M, R); else maintain(rc, M, R);  
		//maintain(o, L, R);  
	}  

  void query(int o, int L, int R) {  
		if(setv[o] &gt;= 0&amp;&amp;!vis[setv[o]]) {  
			vis[setv[o]]=1;
			ans++;
			return;
		}
		if(L+1==R)
		{
			return;
		}
		pushdown(o);
		int M = L + (R-L)/2;  
		query(o*2, L, M);  
		query(o*2+1, M, R);    
	}  
};  

const int INF = 1000000000;  

IntervalTree tree;  

int main() {  
	int n, m;  
	while(scanf("%d%d", &amp;n,&amp;m) == 2) {  
		ans=0;
		memset(&amp;tree, 0, sizeof(tree));  
		memset(tree.setv, -1, sizeof(tree.setv));  
		memset(vis,0,sizeof(vis));
		//tree.setv[1] = 0;  
		num=1;
		col=0;
		for(int i=0;i&lt;n;i++)
		{
			scanf("%d%d",&amp;a[i],&amp;b[i]);
			c[i&lt;&lt;1]=a[i];
			c[i&lt;&lt;1|1]=b[i];
		}
		sort(c,c+2*n);
		for(int i=0;i&lt;2*n;i++)//去重离散化
		{
			if(!mp[c[i]])
			{
				mp[c[i]]=num;
				num++;
			}
		}
		for(int i=0;i&lt;n;i++)
		{
			qL=mp[a[i]];
			qR=mp[b[i]];
			v=col++;
			tree.update(1,1,num-1);
		}
		tree.query(1,1,num-1);
		cout&lt;&lt;ans&lt;&lt;endl;
	}  
	return 0;  
}

</code></pre> 
<br>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f80b86d31b6b8fb2b12ae643d8b8f1c9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Redis（9.2）—— 哨兵的安装和部署</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f24df83507705a566675528065a62aff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2018最新版spark面试题及答案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>