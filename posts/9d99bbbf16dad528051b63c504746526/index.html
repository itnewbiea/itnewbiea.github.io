<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>结构体 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="结构体" />
<meta property="og:description" content="1.什么是结构体？
结构体就是类似于名片（一个公司为员工做的统一样式的模板的名片，里面包含名字，职务，电话等，但内容是空的，等员工调用时才输入内容，分配空间）形式的数据结合体，可以把它理解为一种由用户自定义的特殊的复合型的“数据类型”，在这个复合型的数据类型中可以包含多个基本类型，我们可以把它当成一个整体来操作。
总结：结构体是多种类型的数据的集合；
结构体是一种由用户自定义的特殊的复合型的“数据类型”；
结构体类似于用于制作统一样式名片的空白模板，或图纸。
2.结构体的声明：
结构体的声明是一种“数据类型”的声明，并不是定义对象（变量）实体。
struct Student 是结构体Student这个复合型“数据类型”的类型名，其使用方式如同表示 int 。
3.结构体对象的定义及初始化
结构体的声明只是定义了一种数据类型，并没有定义实体对象，并没有为其分配空间；
结构体变量的定义和基本类型变量的定义是一样的 ： 类型名&#43;变量名；
结构体变量可以在定义的同时对成员进行初始化赋值，把各个结构体成员的初始值依次排列在花括号中，并用逗号隔开。例如： struct Student { //声明结构体 Student
char name[12];
char sex[3];
}tony={&#34;Tony&#34;,&#34;男&#34;}; //定义结构体对象tony并初始化
4.结构体对象成员的访问
结构体变量是由结构体成员变量组成的变量集合体，并且像数组一样存储在连续的内存空间中，因而可以单独访问其中的成员变量；访问结构体成员变量时用“.”，称为句点运算符，具体形式为“对象名.成员名”
在设计一个结构体时，不能给结构体中的成员变量赋值，不会给结构体分配空间，相当于它只是个图纸。举个例子：
struct student //student为结构体名，struct student 是结构体类型名；
{ //属性//数据成员描述；
char s_id[10];
char s_name[10];
char s_sex[8]; int s_age; //不能给age,id,等赋值；
} // 在这里设计的结构体不会开辟空间，
int main()
{
struct student s1; //在这里才给s1开辟空间；
}
比较数组和结构体： 相同：1.都是用花括号初始化；例如：struct student s1={ &#34;007&#34;,&#34;longgege&#34;,&#34;man&#34;,&#34;20&#34;}; a[10]={1,2};
2.初始化时 未初始化的值数组与结构体都一律赋0值；
不同：1.数组名代表的是数组的首地址，而结构体名代表他本身；
2.结构体变量可以相互初始化，例如：struct student s2=s1;（前提条件是两个结构体变量类型相同）,但是数组不能,因为地址不能相互赋值，一个地址不能被改变。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/9d99bbbf16dad528051b63c504746526/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-25T18:05:52+08:00" />
<meta property="article:modified_time" content="2021-11-25T18:05:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">结构体</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.什么是结构体？</p> 
<p>结构体就是类似于名片（一个公司为员工做的统一样式的模板的名片，里面包含名字，职务，电话等，但内容是空的，等员工调用时才输入内容，分配空间）形式的数据结合体，可以把它理解为一种由用户自定义的特殊的复合型的“数据类型”，在这个复合型的数据类型中可以包含多个基本类型，我们可以把它当成一个整体来操作。</p> 
<p>总结：结构体是多种类型的数据的集合；</p> 
<p>           结构体是一种由用户自定义的特殊的复合型的“数据类型”；</p> 
<p>           结构体类似于用于制作统一样式名片的空白模板，或图纸。</p> 
<p>2.结构体的声明：</p> 
<p>结构体的声明是一种“数据类型”的声明，并不是定义对象（变量）实体。</p> 
<p>struct Student 是结构体Student这个复合型“数据类型”的类型名，其使用方式如同表示 int 。</p> 
<p>3.结构体对象的定义及初始化</p> 
<p>结构体的声明只是定义了一种数据类型，并没有定义实体对象，并没有为其分配空间；</p> 
<p>结构体变量的定义和基本类型变量的定义是一样的 ： 类型名+变量名；</p> 
<p>结构体变量可以在定义的同时对成员进行初始化赋值，把各个结构体成员的初始值依次排列在花括号中，并用逗号隔开。例如： struct Student {            //声明结构体 Student</p> 
<p>                                                  char name[12];</p> 
<p>                                                  char sex[3];</p> 
<p>                                             }tony={"Tony","男"};       //定义结构体对象tony并初始化</p> 
<p>4.结构体对象成员的访问</p> 
<p>结构体变量是由结构体成员变量组成的变量集合体，并且像数组一样存储在连续的内存空间中，因而可以单独访问其中的成员变量；访问结构体成员变量时用“.”，称为句点运算符，具体形式为“对象名.成员名”</p> 
<p>在设计一个结构体时，不能给结构体中的成员变量赋值，不会给结构体分配空间，相当于它只是个图纸。举个例子：</p> 
<p>struct student                       //student为结构体名，struct student 是结构体类型名；</p> 
<p>{                                           //属性//数据成员描述；</p> 
<p>      char s_id[10];</p> 
<p>      char s_name[10];</p> 
<p>      char s_sex[8];            </p> 
<p>      int s_age;                        //不能给age,id,等赋值；</p> 
<p>}                                        //     在这里设计的结构体不会开辟空间，</p> 
<p>int main()</p> 
<p>{<!-- --></p> 
<p>struct student s1;              //在这里才给s1开辟空间；</p> 
<p>}</p> 
<p>比较数组和结构体：  </p> 
<p>相同：1.都是用花括号初始化；例如：struct student s1={ "007","longgege","man","20"}; a[10]={1,2};</p> 
<p>           2.初始化时 未初始化的值数组与结构体都一律赋0值；</p> 
<p>不同：1.数组名代表的是数组的首地址，而结构体名代表他本身；</p> 
<p>           2.结构体变量可以相互初始化，例如：struct student s2=s1;（前提条件是两个结构体变量类型相同）,但是数组不能,因为地址不能相互赋值，一个地址不能被改变。</p> 
<p>结构体的存储</p> 
<p>对于存储变量地址对齐的问题，计算结构体大小的3条规则：</p> 
<p>1.结构体变量的首地址必须是结构体变量中“最大基本类型成员所占的字节数”的整数倍。</p> 
<p>2.结构体变量中的每个成员对于结构体首地址的偏移量，都是该成员基本类型所占字节数的整数倍。</p> 
<p>3.结构体变量的总大小必须是结构体变量中“最大基本类型所占字节数的”整数倍。</p> 
<p>注：在计算结构体变量大小时，数组和嵌套结构体变量都拆成基本类型后再来计算。</p> 
<p>例如：</p> 
<p><img alt="" height="374" src="https://images2.imgbox.com/27/a8/6AwCjpe3_o.png" width="333"></p> 
<p>它的大小我第一次计算错误的原因就是把嵌套的结构体当作是一个基本类型</p> 
<p>即 ：  10+8=18-&gt;24(嵌套结构体的整数倍）+12=36+8=44;</p> 
<p>改正： 10+8=18-&gt;20(嵌套结构体中最大基本类型为int型）+12=32+8=40（该结构体中最大基本类型为double 型，40是它的整数倍，所以该结构体变量大小为40bit）。 </p> 
<p>为什么要理解字节对齐问题：</p> 
<p>（1）内存大小的基本单位是字节（byte),从理论上来讲可以从任意地址访问变量，但是实际上,cpu并非逐字节读写内存，而是以2，4，或8的倍数的字节块来读写内存，因此就会对基本类型数据的地址做出一些限制，即他的地址必须是2，4或8的倍数的字节。那么就要求各种类型和数据按照一定的规则在空间上排列，这就是对齐；</p> 
<p>（2）有些平台每次都都是从偶地址开始，如果一个int型（假设为32为系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要读两个周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据，显然在读取效率上下降很多；</p> 
<p>（3）由于不同平台对齐方式可能不同，如此一来，同样的结构体在不同平台的大小可能不同，在无意识的情况下互相发送的数据可能发生错乱；</p> 
<p>解决办法：指定对齐值</p> 
<p>预处理指令 #pragma pack(n) 可以改变默认对齐数。n的取值是,1,2,4,8,16。</p> 
<p>指定对齐值后 偏移量和总大小都是根据对齐值来计算，例如：</p> 
<p>#pragma pack(1)</p> 
<p>struct node</p> 
<p>{<!-- --></p> 
<p>    char a;</p> 
<p>    int b;</p> 
<p>    short c;</p> 
<p>};</p> 
<p>#pragma pack()   //#pragma pack(n) 需要以#pragma pack()作结束，表示该种对齐方式到此为止。</p> 
<p>那么这个结构体大小为 1+4+2=7；</p> 
<p>若在VS中默认的对齐值计算：1-&gt;4+4=8+2=10-&gt;12 所以不同的对齐值计算出的结构体大小是不同的。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9cf586ff27186f9c453c01ae8dba71a0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">js实现一个简单的发布订阅模式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2780c209f6c3ca99c4e3c4e2481040d1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VS2019_C&#43;&#43;_Opencv视觉库配置教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>