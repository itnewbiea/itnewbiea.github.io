<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>pod进阶版(1) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="pod进阶版(1)" />
<meta property="og:description" content="pod的相关知识 k8s的pad重启策略: Always deployment的yaml文件只能是Always pod的yaml三种模式都可以。
Onfailure:只有异常退出状态码非0才会重启。正常退出不重启。
Never：非正常退出和非正常退出都不重启。
容器的退出了pod才会重启。
pod可以有多个容器，只要有一个容器退出，整个pod都会重启，pod内的所有容器都会重启。
docekr的重启策略： docker的默认策略是Never。
on-failure：非正常退出，才会重启容器。
always：只要容器退出都会重启。
unless-stopped：只要退出就会重启，docker守护进程时已经停止的容器，不会重启。
单机部署：docker就够用了
集群化部署：k8s部署
yaml模板文件快速生成的三种方式 可以生成pod、service、deployment等yaml文件
1、手写
2、对已有资源进行导出
kubectl get deployments.apps nginx -o yaml &gt; /opt/lyw.yaml 3、通过api的组件，使对象不执行命令生成文件
kubectl create deployment nginx1 --image=nginx:1.22 --dry-run=client -o yaml &gt; /opt/test1.yaml --dry-run=client 只是调用api的对象不执行命令 pod的状态： pod状态简述说明说明pending挂起状态 pod已被创建，但是尚未被分配到运行的node节点
（原因：节点资源不够或等待其他pod节点调度）
running运行中pod已经被分配到了node节点，pod内部的所有容器都已经启动，运行状态正常，稳定。completed 成功运行完毕并退出容器内部的进程运行完毕，正常退出，没有发生错误。successdedfaild运行错误并退出 pod中的容器非正常退出，发生了错误。
需要通过查看详细和日志来定位问题。
Unkown未知 由于某些原因，k8s集群无法获取pod的状态。
APIserver出了问题
terminating在终止中 这个pod正在被删除，里面的容器正在终止。
终止过程中，资源回收、垃圾清理、以及终止过程中需要执行的命令。
crashloopbackoffpod当中的容器退出，kubelet正在重启imagepullbackoff正在重试拉取镜像errimagepull 镜像拉取出错
（1、网速太慢 2、镜像名字写错了 3、镜像仓库挂了）
Evictepod被驱赶（node节点的资源不足部署pod，或者是资源不足，kubelet自动选择一个pod驱逐。） pod内的容器使用节点资源的限制： 1、request：需要的资源
2、limit 最高占用系统多少资源
limit需要多少，最多也只能占用这么多
两个限制(cpu、内存): cpu ：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/aadf3adb2e861bca772d0e7cb999c7af/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-05T11:59:03+08:00" />
<meta property="article:modified_time" content="2024-01-05T11:59:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">pod进阶版(1)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>pod的相关知识</h2> 
<h3>k8s的pad重启策略:</h3> 
<p>Always deployment的yaml文件只能是Always pod的yaml三种模式都可以。<br> Onfailure:只有异常退出状态码非0才会重启。正常退出不重启。<br> Never：非正常退出和非正常退出都不重启。<br> 容器的退出了pod才会重启。<br> pod可以有多个容器，只要有一个容器退出，整个pod都会重启，pod内的所有容器都会重启。</p> 
<h3><br> docekr的重启策略：</h3> 
<p>docker的默认策略是Never。<br> on-failure：非正常退出，才会重启容器。<br> always：只要容器退出都会重启。<br> unless-stopped：只要退出就会重启，docker守护进程时已经停止的容器，不会重启。</p> 
<p><br> 单机部署：docker就够用了<br> 集群化部署：k8s部署</p> 
<p></p> 
<h2>yaml模板文件快速生成的三种方式</h2> 
<p>可以生成pod、service、deployment等yaml文件</p> 
<p>1、手写</p> 
<p>2、对已有资源进行导出</p> 
<pre><code>kubectl get deployments.apps nginx -o yaml &gt; /opt/lyw.yaml</code></pre> 
<p>3、通过api的组件，使对象不执行命令生成文件</p> 
<pre><code class="language-bash">kubectl create deployment nginx1 --image=nginx:1.22 --dry-run=client -o yaml &gt;  /opt/test1.yaml
--dry-run=client 只是调用api的对象不执行命令</code></pre> 
<h2>pod的状态：</h2> 
<table border="1" cellpadding="1" cellspacing="1" style="width:700px;"><tbody><tr><td style="text-align:center;width:128px;">pod状态</td><td style="text-align:center;width:131px;">简述说明</td><td style="text-align:center;width:508px;">说明</td></tr><tr><td style="text-align:center;width:128px;">pending</td><td style="text-align:center;width:131px;">挂起状态</td><td style="width:508px;"> <p>pod已被创建，但是尚未被分配到运行的node节点</p> <p>（原因：节点资源不够或等待其他pod节点调度）</p> </td></tr><tr><td style="text-align:center;width:128px;">running</td><td style="text-align:center;width:131px;">运行中</td><td style="width:508px;">pod已经被分配到了node节点，pod内部的所有容器都已经启动，运行状态正常，稳定。</td></tr><tr><td style="text-align:center;width:128px;">completed </td><td colspan="1" rowspan="2" style="text-align:center;width:131px;">成功运行完毕并退出</td><td colspan="1" rowspan="2" style="width:508px;">容器内部的进程运行完毕，正常退出，没有发生错误。</td></tr><tr><td style="text-align:center;width:128px;">successded</td></tr><tr><td style="text-align:center;width:128px;">faild</td><td style="text-align:center;width:131px;">运行错误并退出</td><td style="width:508px;"> <p>pod中的容器非正常退出，发生了错误。</p> <p>需要通过查看详细和日志来定位问题。</p> </td></tr><tr><td style="text-align:center;width:128px;">Unkown</td><td style="text-align:center;width:131px;">未知</td><td style="width:508px;"> <p>由于某些原因，k8s集群无法获取pod的状态。</p> <p>APIserver出了问题</p> </td></tr><tr><td style="text-align:center;width:128px;">terminating</td><td style="text-align:center;width:131px;">在终止中</td><td style="width:508px;"> <p>这个pod正在被删除，里面的容器正在终止。</p> <p>终止过程中，资源回收、垃圾清理、以及终止过程中需要执行的命令。</p> </td></tr><tr><td style="text-align:center;width:128px;">crashloopbackoff</td><td colspan="2" rowspan="1" style="width:570px;">pod当中的容器退出，kubelet正在重启</td></tr><tr><td style="text-align:center;width:128px;">imagepullbackoff</td><td colspan="2" rowspan="1" style="width:570px;">正在重试拉取镜像</td></tr><tr><td style="text-align:center;width:128px;">errimagepull</td><td colspan="2" rowspan="1" style="width:570px;"> <p>镜像拉取出错</p> <p>（1、网速太慢  2、镜像名字写错了  3、镜像仓库挂了）</p> </td></tr><tr><td style="text-align:center;width:128px;">Evicte</td><td colspan="2" rowspan="1" style="width:570px;">pod被驱赶（node节点的资源不足部署pod，或者是资源不足，kubelet自动选择一个pod驱逐。）</td></tr></tbody></table> 
<h3>pod内的容器使用节点资源的限制：</h3> 
<p>1、request：需要的资源<br> 2、limit    最高占用系统多少资源<br>    limit需要多少，最多也只能占用这么多</p> 
<h4>两个限制(cpu、内存):</h4> 
<p><strong>cpu ：</strong><br>     cpu的个数限制：<br>     1 2 0.5 0.2 0.3  1：可以占用1个cpu  0.1是最小单位（要么整数，要么就是小数点后只能跟一位）<br>    cpu时间分片原理：<br>         cpu时间分片: 通过周期性的轮流分配cpu时间给各个进程。多个进程可以在cpu上交替，在k8s中就是占用cpu的比率，单位：m（millicores）100m是最小单位（等于0.1）<br> 内存：Ki 字节   Mi-mb   Gi-gb  Ti-tb</p> 
<pre><code class="language-bash">apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: centos
  name: centos
spec:
  replicas: 1
  selector:
    matchLabels:
      app: centos
  template:
    metadata:
      labels:
        app: centos
    spec:
      containers:
      - image: centos:7
        name: centos
        imagePullPolicy: Never
        command: ["/bin/bash","-c","sleep 3600"]
        resources:
          requests:
            memory: "256Mi"
            cpu: "0.5"
          limits:
            memory: "1Gi"
            cpu: "1"
#在创建pod时，一定要给容器做资源限制。</code></pre> 
<p><img alt="" height="505" src="https://images2.imgbox.com/38/b1/u1wWJxkZ_o.png" width="1049"></p> 
<h4>k8s怎么设置拉取镜像的策略：</h4> 
<p>镜像默认策略：<br><strong>IfnotPresent</strong>: 如果本地镜像有，就不拉取，本地没有才会去镜像仓库拉取。默认策略<br><strong>Always</strong>: 不论镜像是否存在，创建时(重启) 都会重新拉取镜像<br><strong>Never</strong>:  仅仅使用本地镜像，不进行拉取镜像</p> 
<p>如果涉及到外部部署，默认策略 (事前要把docker的镜像导入到目标主机)<br> Always：一般不用</p> 
<p><img alt="" height="683" src="https://images2.imgbox.com/02/53/LBSspuzF_o.png" width="973"></p> 
<h2>pod探针</h2> 
<h3><strong>pod的容器健康检查------探针</strong></h3> 
<p>探针probe、k8s对容器的定期检查，诊断。</p> 
<h3>探针的三种规则：</h3> 
<h4></h4> 
<h4>存活探针</h4> 
<p>livenessProbe 探测容器是否正常运行，如果发现探测失败，会杀容器，容器会根据重启策略来决定是否重启，不是杀掉pod。livenessProbe 杀死容器重启。</p> 
<p>所有的探针策略伴随整个pod的生命周期。</p> 
<p></p> 
<h4>就绪探针</h4> 
<p>探测容器是否进入ready状态，并做好接受请求的准备。探测失败 READY 0/1 没有进入ready状态。</p> 
<p>service会把这个资源对象的端点从当中踢出，service也不会把请求转发到这个pod。</p> 
<p></p> 
<h4>启动探针</h4> 
<p>只是在容器的启动后进行检测，容器内的应用是否启动成功，在启动探测成功之前，所有的探针都处于禁用状态，但是，一旦启动探针结束，后续的操作不再收启动探针影响。</p> 
<p>在一个容器当中的可以有多个探针。启动探针:只在容器启动时探测。</p> 
<p></p> 
<h3>Probe的检查方法：</h3> 
<p><strong>1、exec探针:</strong>  在容器内部执行命令,如果命令的返回码是0，表示成功。<br> 适用于需要在容器内部自定义命令来检查容器的健康情况。</p> 
<p><strong>2、httpGet：</strong>对指定ip+端口的容器发送一个httpget的请求。响应状态码大于等于200,小于400都是成功。<br> 适用于检查容器是否能响应http的请求，web容器（nginx，tomcat）</p> 
<p><strong>3、tcpSocket：</strong>端口，对指定端口上的容器的ip地址进行tcp检查（三次握手），端口打开，认为探测成功。<br> 检查特定端口的监听状态。<br> 类似于 telnet 192.168.10.10:80</p> 
<p>诊断结果：<br> 1、成功 容器通过了，正常运行<br> 2、失败 存活探针将会重启<br> 3、未知状态 </p> 
<p></p> 
<h4>exec探针</h4> 
<pre><code class="language-bash">apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: centos
  name: centos
spec:
  replicas: 1
  selector:
    matchLabels:
      app: centos
  template:
    metadata:
      labels:
        app: centos
    spec:
      containers:
      - image: centos:7
        name: centos
        imagePullPolicy: Never
        command: ["/bin/bash","-c","touch /opt/123.txt; sleep 3600"]
        livenessProbe:
          exec:
            command: ["/usr/bin/test","-e","/opt/123.txt"]
          initialDelaySeconds: 3
#核心指标;表示容器启动之后多少秒来进行探测，时间不要设置的太短，可能会导致无效的探测
          periodSeconds: 2
#核心指标;表示探针探测的间隔时间。每隔多少秒进行检查。根据应用的延迟敏感度,这个应用非常重要，是核心组件。
          failureThreshold: 2
#核心指标;表示如果探测失败，失败几次之后，把容器标记为不健康。
          successThreshold: 1
#表示只要成功一次就标记为就绪，标记为健康，ready。只能为1
          timeoutSeconds: 1
#表示每次探测的超时时间，就是探测这个过程耗时，小于间隔时间，在这个秒数没必须完成探测。</code></pre> 
<p><img alt="" height="585" src="https://images2.imgbox.com/c2/69/KvzJnd5L_o.png" width="1104"></p> 
<p></p> 
<h4></h4> 
<h4></h4> 
<h4></h4> 
<h4></h4> 
<h4>httpGet探针</h4> 
<pre><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  labels:
    run: nginx1
  name: nginx1
spec:
  containers:
  - image: nginx:1.22
    name: nginx1
    livenessProbe:
      httpGet:
        port: 80
        path: /index.html
      initialDelaySeconds: 4
      periodSeconds: 2</code></pre> 
<p>正常示范</p> 
<p><img alt="" height="328" src="https://images2.imgbox.com/5e/d9/YbVOFEh1_o.png" width="1047"></p> 
<p>错误示范1</p> 
<p><img alt="" height="339" src="https://images2.imgbox.com/2f/87/sgB7NeSP_o.png" width="1200"></p> 
<p>错误示范2</p> 
<p><img alt="" height="524" src="https://images2.imgbox.com/4f/ce/icVCroth_o.png" width="1200"></p> 
<p></p> 
<h4>tcpSocket探针</h4> 
<pre><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  labels:
    run: nginx1
  name: nginx1
spec:
  containers:
  - image: nginx:1.22
    name: nginx1
    livenessProbe:
      tcpSocket:
        port: 81
      initialDelaySeconds: 4
      periodSeconds: 2</code></pre> 
<p><img alt="" height="420" src="https://images2.imgbox.com/9f/aa/MGt9hBmN_o.png" width="1053"></p> 
<h4>总结</h4> 
<p>探针:<br> 存活探针:检测失败之后，会杀死容器，然后重启。<br> 探针将伴随整个容器的生命周期<br> exec 相当于执行了一个shell命令: 容器里面执行<br> shell命令执行成功:<br> 返回码:0表示成功<br> 成功一次就是探测成功</p> 
<p><br> httpGet：对web容器发起get请求，可以添加path，指定访问的资源。返回码大于等于200 小于400 之内算成功</p> 
<p>tcpSocket：相当于telnet，指定的容器监听端口是否打开。是否能和指定的容器监听端口进行通信。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bc662aa734ca02c26bbca70fa1f21055/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AI时代Python金融大数据分析实战：ChatGPT让金融大数据分析插上翅膀</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/17e9f6592e22f0d891763f8f2667d963/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MYSQL多种提权方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>