<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;/C&#43;&#43;11中头文件functional的使用 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;/C&#43;&#43;11中头文件functional的使用" />
<meta property="og:description" content="&lt;functional&gt;是C&#43;&#43;标准库中的一个头文件，定义了C&#43;&#43;标准中多个用于表示函数对象(function object)的类模板，包括算法操作、比较操作、逻辑操作；以及用于绑定函数对象的实参值的绑定器(binder)。这些类模板的实例是具有函数调用运算符(function call operator)的C&#43;&#43;类，这些类的实例可以如同函数一样调用。不必写新的函数对象，而仅是组合预定义的函数对象与函数对象适配器(function object adaptor)，就可以执行非常复杂的操作。
std::bind：将一个或多个参数绑定到函数对象，更详细的用法可参考 http://blog.csdn.net/fengbingchun/article/details/52613910 ；
std::is_bind_expression:用于判断指定表达式是否为std::bind函数返回的结果类型；
std::reference_wrapper：类模板，用于包装对一个实例的引用，它是可拷贝和可赋值的；
std::ref：构造一个适当的std::reference_wrapper类型的对象来保存对elem(实例对象)的引用；
std::cref：构造一个适当的std::reference_wrapper类型的对象来保存对elem(实例对象)的const 引用；
std::mem_fn：将成员函数转换为函数对象；
std::not1：返回一个对谓词(一元函数)的结果取反的函数对象；
std::not2：返回一个对二元谓词(二元函数)的结果取反的函数对象；
std::unary_negate：一元谓词对象类，其调用时把另一个一元谓词的返回值取反；
std::binary_negate：二元谓词对象类，其调用时把另一个二元谓词的返回值取反；
std::function：类模版，是一种通用、多态的函数封装。std::function的实例可以对任何可以调用的目标实体进行存储、复制、和调用操作，这些目标实体包括普通函数、Lambda表达式、函数指针、以及其它函数对象等，更详细的用法可参考 http://blog.csdn.net/fengbingchun/article/details/52562918 ；
std::and：二元谓词对象类, x&amp; y；
std::or：二元谓词对象类, x |y；
std::xor：二元谓词对象类， x ^y；
std::plus：二元谓词对象类, x &#43;y；
std::minus：二元谓词对象类, x -y；
std::multiplies：二元谓词对象类, x *y；
std::divides：二元谓词对象类, x /y；
std::modulus：二元谓词对象类, x %y；
std::negate：一元谓词对象类, -x；
std::equal_to: 二元谓词对象类, x ==y；
std::not_equal_to:二元谓词对象类, x != y；
std::greater: 二元谓词对象类, x &gt;y；
std::less: 二元谓词对象类, x &lt;y；
std::greater_equal:二元谓词对象类, x &gt;= y；
std::less_equal:二元谓词对象类, x &lt;= y；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6860d00b97d091afd41dba075c1883f5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-09-16T21:32:30+08:00" />
<meta property="article:modified_time" content="2017-09-16T21:32:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;/C&#43;&#43;11中头文件functional的使用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>&lt;functional&gt;是C++标准库中的一个头文件，定义了C++标准中多个用于表示函数对象(function object)的类模板，包括算法操作、比较操作、逻辑操作；以及用于绑定函数对象的实参值的绑定器(binder)。这些类模板的实例是具有函数调用运算符(function call operator)的C++类，这些类的实例可以如同函数一样调用。不必写新的函数对象，而仅是组合预定义的函数对象与函数对象适配器(function object adaptor)，就可以执行非常复杂的操作。</p> 
<p>std::bind：将一个或多个参数绑定到函数对象，更详细的用法可参考  <a href="http://blog.csdn.net/fengbingchun/article/details/52613910">http://blog.csdn.net/fengbingchun/article/details/52613910</a>  ；</p> 
<p>std::is_bind_expression:用于判断指定表达式是否为std::bind函数返回的结果类型；</p> 
<p>std::reference_wrapper：类模板，用于包装对一个实例的引用，它是可拷贝和可赋值的；</p> 
<p>std::ref：构造一个适当的std::reference_wrapper类型的对象来保存对elem(实例对象)的引用；</p> 
<p>std::cref：构造一个适当的std::reference_wrapper类型的对象来保存对elem(实例对象)的const 引用；</p> 
<p>std::mem_fn：将成员函数转换为函数对象；</p> 
<p>std::not1：返回一个对谓词(一元函数)的结果取反的函数对象；</p> 
<p>std::not2：返回一个对二元谓词(二元函数)的结果取反的函数对象；</p> 
<p>std::unary_negate：一元谓词对象类，其调用时把另一个一元谓词的返回值取反；</p> 
<p>std::binary_negate：二元谓词对象类，其调用时把另一个二元谓词的返回值取反；</p> 
<p>std::function：类模版，是一种通用、多态的函数封装。std::function的实例可以对任何可以调用的目标实体进行存储、复制、和调用操作，这些目标实体包括普通函数、Lambda表达式、函数指针、以及其它函数对象等，更详细的用法可参考  <a href="http://blog.csdn.net/fengbingchun/article/details/52562918">http://blog.csdn.net/fengbingchun/article/details/52562918</a> ；</p> 
<p>std::and：二元谓词对象类, x&amp; y；</p> 
<p>std::or：二元谓词对象类, x |y；</p> 
<p>std::xor：二元谓词对象类， x ^y；</p> 
<p>std::plus：二元谓词对象类, x +y；</p> 
<p>std::minus：二元谓词对象类, x -y；</p> 
<p>std::multiplies：二元谓词对象类, x *y；</p> 
<p>std::divides：二元谓词对象类, x /y；</p> 
<p>std::modulus：二元谓词对象类, x %y；</p> 
<p>std::negate：一元谓词对象类,  -x；</p> 
<p>std::equal_to: 二元谓词对象类, x ==y；</p> 
<p>std::not_equal_to:二元谓词对象类, x != y；</p> 
<p>std::greater: 二元谓词对象类, x &gt;y；</p> 
<p>std::less: 二元谓词对象类, x &lt;y；</p> 
<p>std::greater_equal:二元谓词对象类, x &gt;= y；</p> 
<p>std::less_equal:二元谓词对象类, x &lt;= y；</p> 
<p>std::logical_and:二元谓词对象类, x &amp;&amp; y；</p> 
<p>std::logical_or:二元谓词对象类, x || y；</p> 
<p>std::logical_not:一元谓词对象类, !x；</p> 
<p>std::bad_function_call：这是一个被抛出的异常类，用于表示被调用的函数对象为空；</p> 
<p>std::hash：一元函数对象类，用于定义标准库使用的默认散列函数；</p> 
<p>std::placeholders：命名空间，该命名空间声明一个未指定数量的对象：_1，_2，_3，...，用于在函数std::bind的调用中指定占位符；</p> 
<p>std::is_placeholder：用于判断指定表达式是否为std::placeholders中定义的placeholder类型。</p> 
<p>C++11中也废弃了一些旧式的函数对象。</p> 
<p>下面是从其它文章中copy的&lt;functional&gt;测试代码，详细内容介绍可以参考对应的reference：</p> 
<p> </p> 
<pre class="has"><code class="language-cpp">#include "functional.hpp"
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iterator&gt;
#include &lt;numeric&gt;
#include &lt;string&gt;

// reference: http://www.cplusplus.com/reference/functional/

namespace functional_ {
///
// a function: (also works with function object: std::divides&lt;double&gt; my_divide;)
static double my_divide(double x, double y) { return x / y; }

struct MyPair {
	double a, b;
	double multiply() { return a*b; }
};

int test_functional_bind()
{
	using namespace std::placeholders;    // adds visibility of _1, _2, _3,...

	// binding functions:
	auto fn_five = std::bind(my_divide, 10, 2);               // returns 10/2
	std::cout &lt;&lt; fn_five() &lt;&lt; '\n';                           // 5

	auto fn_half = std::bind(my_divide, _1, 2);               // returns x/2
	std::cout &lt;&lt; fn_half(10) &lt;&lt; '\n';                         // 5

	auto fn_invert = std::bind(my_divide, _2, _1);            // returns y/x
	std::cout &lt;&lt; fn_invert(10, 2) &lt;&lt; '\n';                    // 0.2

	auto fn_rounding = std::bind&lt;int&gt;(my_divide, _1, _2);     // returns int(x/y)
	std::cout &lt;&lt; fn_rounding(10, 3) &lt;&lt; '\n';                  // 3

	MyPair ten_two{ 10, 2 };

	// binding members:
	auto bound_member_fn = std::bind(&amp;MyPair::multiply, _1); // returns x.multiply()
	std::cout &lt;&lt; bound_member_fn(ten_two) &lt;&lt; '\n';           // 20

	auto bound_member_data = std::bind(&amp;MyPair::a, ten_two); // returns ten_two.a
	std::cout &lt;&lt; bound_member_data() &lt;&lt; '\n';                // 10

	return 0;
}

//
int test_functional_cref()
{
	int foo(10);

	auto bar = std::cref(foo);
	std::cout &lt;&lt; bar &lt;&lt; '\n'; // 10

	++foo;
	std::cout &lt;&lt; bar &lt;&lt; '\n'; // 11

	return 0;
}

/
int test_functional_ref()
{
	int foo(10);

	auto bar = std::ref(foo);
	std::cout &lt;&lt; bar &lt;&lt; '\n'; // 10

	++bar;
	std::cout &lt;&lt; foo &lt;&lt; '\n'; // 11
	std::cout &lt;&lt; bar &lt;&lt; '\n'; // 11

	return 0;
}

//
struct int_holder {
	int value;
	int triple() { return value * 3; }
};

int test_functional_mem_fn()
{
	int_holder five{ 5 };

	// call member directly:
	std::cout &lt;&lt; five.triple() &lt;&lt; '\n'; // 15

	// same as above using a mem_fn:
	auto triple = std::mem_fn(&amp;int_holder::triple);
	std::cout &lt;&lt; triple(five) &lt;&lt; '\n'; // 15

	return 0;
}

//
struct IsOdd {
	bool operator() (const int&amp; x) const { return x % 2 == 1; }
	typedef int argument_type;
};

int test_functional_not1()
{
	int values[] = { 1, 2, 3, 4, 5 };
	int cx = std::count_if(values, values + 5, std::not1(IsOdd()));
	std::cout &lt;&lt; "There are " &lt;&lt; cx &lt;&lt; " elements with even values.\n"; // 2

	return 0;
}


int test_functional_not2()
{
	int foo[] = { 10, 20, 30, 40, 50 };
	int bar[] = { 0, 15, 30, 45, 60 };
	std::pair&lt;int*, int*&gt; firstmatch, firstmismatch;
	firstmismatch = std::mismatch(foo, foo + 5, bar, std::equal_to&lt;int&gt;());
	firstmatch = std::mismatch(foo, foo + 5, bar, std::not2(std::equal_to&lt;int&gt;()));
	std::cout &lt;&lt; "First mismatch in bar is " &lt;&lt; *firstmismatch.second &lt;&lt; '\n'; // 0
	std::cout &lt;&lt; "First match in bar is " &lt;&lt; *firstmatch.second &lt;&lt; '\n'; // 30

	return 0;
}

//
int test_functional_binary_negate()
{
	std::equal_to&lt;int&gt; equality;
	std::binary_negate &lt; std::equal_to&lt;int&gt; &gt; nonequality(equality);
	int foo[] = { 10, 20, 30, 40, 50 };
	int bar[] = { 0, 15, 30, 45, 60 };

	std::pair&lt;int*, int*&gt; firstmatch, firstmismatch;
	firstmismatch = std::mismatch(foo, foo + 5, bar, equality);
	firstmatch = std::mismatch(foo, foo + 5, bar, nonequality);
	std::cout &lt;&lt; "First mismatch in bar is " &lt;&lt; *firstmismatch.second &lt;&lt; "\n"; // 0
	std::cout &lt;&lt; "First match in bar is " &lt;&lt; *firstmatch.second &lt;&lt; "\n"; // 30

	return 0;
}


struct IsOdd_class {
	bool operator() (const int&amp; x) const { return x % 2 == 1; }
	typedef int argument_type;
} IsOdd_object;

int test_functional_unary_negate()
{
	std::unary_negate&lt;IsOdd_class&gt; IsEven_object(IsOdd_object);
	int values[] = { 1, 2, 3, 4, 5 };
	int cx;
	cx = std::count_if(values, values + 5, IsEven_object);
	std::cout &lt;&lt; "There are " &lt;&lt; cx &lt;&lt; " elements with even values.\n"; // 2

	return 0;
}


// a function:
static int half(int x) { return x / 2; }

// a function object class:
struct third_t {
	int operator()(int x) { return x / 3; }
};

// a class with data members:
struct MyValue {
	int value;
	int fifth() { return value / 5; }
};

int test_functional_function()
{
	std::function&lt;int(int)&gt; fn1 = half;                       // function
	std::function&lt;int(int)&gt; fn2 = ½                      // function pointer
	std::function&lt;int(int)&gt; fn3 = third_t();                  // function object
	std::function&lt;int(int)&gt; fn4 = [](int x){return x / 4; };  // lambda expression
	std::function&lt;int(int)&gt; fn5 = std::negate&lt;int&gt;();         // standard function object

	std::cout &lt;&lt; "fn1(60): " &lt;&lt; fn1(60) &lt;&lt; '\n'; // 30
	std::cout &lt;&lt; "fn2(60): " &lt;&lt; fn2(60) &lt;&lt; '\n'; // 30
	std::cout &lt;&lt; "fn3(60): " &lt;&lt; fn3(60) &lt;&lt; '\n'; // 20
	std::cout &lt;&lt; "fn4(60): " &lt;&lt; fn4(60) &lt;&lt; '\n'; // 15
	std::cout &lt;&lt; "fn5(60): " &lt;&lt; fn5(60) &lt;&lt; '\n'; // -06

	// stuff with members:
	std::function&lt;int(MyValue)&gt; value = &amp;MyValue::value;  // pointer to data member
	std::function&lt;int(MyValue)&gt; fifth = &amp;MyValue::fifth;  // pointer to member function

	MyValue sixty{ 60 };

	std::cout &lt;&lt; "value(sixty): " &lt;&lt; value(sixty) &lt;&lt; '\n'; // 60
	std::cout &lt;&lt; "fifth(sixty): " &lt;&lt; fifth(sixty) &lt;&lt; '\n'; // 12

	return 0;
}


int test_functional_reference_wrapper()
{
	int a(10), b(20), c(30);

	// an array of "references":
	std::reference_wrapper&lt;int&gt; refs[] = { a, b, c };

	std::cout &lt;&lt; "refs:";
	for (int&amp; x : refs) std::cout &lt;&lt; ' ' &lt;&lt; x; // 10 20 30
	std::cout &lt;&lt; '\n';

	return 0;
}

//
int test_functional_bit()
{
{
	int values[] = { 100, 200, 300, 400, 500 };
	int masks[] = { 0xf, 0xf, 0xf, 255, 255 };
	int results[5];

	std::transform(values, std::end(values), masks, results, std::bit_and&lt;int&gt;());

	std::cout &lt;&lt; "results:";
	for (const int&amp; x : results)
		std::cout &lt;&lt; ' ' &lt;&lt; x; // 4 8 12 144 244
	std::cout &lt;&lt; '\n';
}

{
	int flags[] = { 1, 2, 4, 8, 16, 32, 64, 128 };
	int acc = std::accumulate(flags, std::end(flags), 0, std::bit_or&lt;int&gt;());
	std::cout &lt;&lt; "accumulated: " &lt;&lt; acc &lt;&lt; '\n'; // 255
}

{
	int flags[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	int acc = std::accumulate(flags, std::end(flags), 0, std::bit_xor&lt;int&gt;());
	std::cout &lt;&lt; "xor: " &lt;&lt; acc &lt;&lt; '\n'; // 11
}

	return 0;
}

//
int test_functional_arithmetic()
{
{
	int first[] = { 1, 2, 3, 4, 5 };
	int second[] = { 10, 20, 30, 40, 50 };
	int results[5];
	std::transform(first, first + 5, second, results, std::plus&lt;int&gt;());
	for (int i = 0; i&lt;5; i++)
		std::cout &lt;&lt; results[i] &lt;&lt; ' '; // 11 22 33 44 55
	std::cout &lt;&lt; '\n';
}

{
	int numbers[] = { 10, 20, 30 };
	int result;
	result = std::accumulate(numbers, numbers + 3, 100, std::minus&lt;int&gt;());
	std::cout &lt;&lt; "The result of 100-10-20-30 is " &lt;&lt; result &lt;&lt; ".\n"; // 40
}

{
	int numbers[9];
	int factorials[9];
	for (int i = 0; i&lt;9; i++) numbers[i] = i + 1;
	std::partial_sum(numbers, numbers + 9, factorials, std::multiplies&lt;int&gt;());
	for (int i = 0; i&lt;9; i++)
		std::cout &lt;&lt; numbers[i] &lt;&lt; "! is " &lt;&lt; factorials[i] &lt;&lt; '\n'; // 1 2 6 24 120 720 5040 40320 362880
}

{
	int first[] = { 10, 40, 90, 40, 10 };
	int second[] = { 1, 2, 3, 4, 5 };
	int results[5];
	std::transform(first, first + 5, second, results, std::divides&lt;int&gt;());
	for (int i = 0; i&lt;5; i++)
		std::cout &lt;&lt; results[i] &lt;&lt; ' '; // 10 20 30 10 2
	std::cout &lt;&lt; '\n';
}

{
	int numbers[] = { 1, 2, 3, 4, 5 };
	int remainders[5];
	std::transform(numbers, numbers + 5, remainders, std::bind2nd(std::modulus&lt;int&gt;(), 2));
	for (int i = 0; i &lt; 5; i++)
		std::cout &lt;&lt; numbers[i] &lt;&lt; " is " &lt;&lt; (remainders[i] == 0 ? "even" : "odd") &lt;&lt; '\n';
}

{
	int numbers[] = { 10, -20, 30, -40, 50 };
	std::transform(numbers, numbers + 5, numbers, std::negate&lt;int&gt;());
	for (int i = 0; i&lt;5; i++)
		std::cout &lt;&lt; numbers[i] &lt;&lt; ' '; // -10 20 -30 40 -50
	std::cout &lt;&lt; '\n';
}

	return 0;
}

///
int test_functional_compare()
{
{
	std::pair&lt;int*, int*&gt; ptiter;
	int foo[] = { 10, 20, 30, 40, 50 };
	int bar[] = { 10, 20, 40, 80, 160 };
	ptiter = std::mismatch(foo, foo + 5, bar, std::equal_to&lt;int&gt;());
	std::cout &lt;&lt; "First mismatching pair is: " &lt;&lt; *ptiter.first; // 30
	std::cout &lt;&lt; " and " &lt;&lt; *ptiter.second &lt;&lt; '\n'; // 40
}

{
	int numbers[] = { 10, 10, 10, 20, 20 };
	int* pt = std::adjacent_find(numbers, numbers + 5, std::not_equal_to&lt;int&gt;()) + 1;
	std::cout &lt;&lt; "The first different element is " &lt;&lt; *pt &lt;&lt; '\n'; // 20
}

{
	int numbers[] = { 20, 40, 50, 10, 30 };
	std::sort(numbers, numbers + 5, std::greater&lt;int&gt;());
	for (int i = 0; i&lt;5; i++)
		std::cout &lt;&lt; numbers[i] &lt;&lt; ' '; // 50 40 30 20 10
	std::cout &lt;&lt; '\n';
}

{
	int foo[] = { 10, 20, 5, 15, 25 };
	int bar[] = { 15, 10, 20 };
	std::sort(foo, foo + 5, std::less&lt;int&gt;());  // 5 10 15 20 25
	std::sort(bar, bar + 3, std::less&lt;int&gt;());  //   10 15 20
	if (std::includes(foo, foo + 5, bar, bar + 3, std::less&lt;int&gt;()))
		std::cout &lt;&lt; "foo includes bar.\n"; // foo includes bar
}

{
	int numbers[] = { 20, -30, 10, -40, 0 };
	int cx = std::count_if(numbers, numbers + 5, std::bind2nd(std::greater_equal&lt;int&gt;(), 0));
	std::cout &lt;&lt; "There are " &lt;&lt; cx &lt;&lt; " non-negative elements.\n"; // 3
}

{
	int numbers[] = { 25, 50, 75, 100, 125 };
	int cx = std::count_if(numbers, numbers + 5, std::bind2nd(std::less_equal&lt;int&gt;(), 100));
	std::cout &lt;&lt; "There are " &lt;&lt; cx &lt;&lt; " elements lower than or equal to 100.\n"; // 4
}

	return 0;
}

///
int test_functional_logical()
{
{
	bool foo[] = { true, false, true, false };
	bool bar[] = { true, true, false, false };
	bool result[4];
	std::transform(foo, foo + 4, bar, result, std::logical_and&lt;bool&gt;());
	std::cout &lt;&lt; std::boolalpha &lt;&lt; "Logical AND:\n";
	for (int i = 0; i&lt;4; i++)
		std::cout &lt;&lt; foo[i] &lt;&lt; " AND " &lt;&lt; bar[i] &lt;&lt; " = " &lt;&lt; result[i] &lt;&lt; "\n"; // true false false false
}

{
	bool foo[] = { true, false, true, false };
	bool bar[] = { true, true, false, false };
	bool result[4];
	std::transform(foo, foo + 4, bar, result, std::logical_or&lt;bool&gt;());
	std::cout &lt;&lt; std::boolalpha &lt;&lt; "Logical OR:\n";
	for (int i = 0; i&lt;4; i++)
		std::cout &lt;&lt; foo[i] &lt;&lt; " OR " &lt;&lt; bar[i] &lt;&lt; " = " &lt;&lt; result[i] &lt;&lt; "\n"; // true true true false
}

{
	bool values[] = { true, false };
	bool result[2];
	std::transform(values, values + 2, result, std::logical_not&lt;bool&gt;());
	std::cout &lt;&lt; std::boolalpha &lt;&lt; "Logical NOT:\n";
	for (int i = 0; i&lt;2; i++)
		std::cout &lt;&lt; "NOT " &lt;&lt; values[i] &lt;&lt; " = " &lt;&lt; result[i] &lt;&lt; "\n"; // false true
}

	return 0;
}


int test_functional_bad_function_call()
{
	std::function&lt;int(int, int)&gt; foo = std::plus&lt;int&gt;();
	std::function&lt;int(int, int)&gt; bar;

	try {
		std::cout &lt;&lt; foo(10, 20) &lt;&lt; '\n'; // 30
		std::cout &lt;&lt; bar(10, 20) &lt;&lt; '\n';
	} catch (std::bad_function_call&amp; e)
	{
		std::cout &lt;&lt; "ERROR: Bad function call\n"; // ERROR: Bad function call
	}

	return 0;
}

//
int test_functional_hash()
{
	char nts1[] = "Test";
	char nts2[] = "Test";
	std::string str1(nts1);
	std::string str2(nts2);

	std::hash&lt;char*&gt; ptr_hash;
	std::hash&lt;std::string&gt; str_hash;

	std::cout &lt;&lt; "same hashes:\n" &lt;&lt; std::boolalpha;
	std::cout &lt;&lt; "nts1 and nts2: " &lt;&lt; (ptr_hash(nts1) == ptr_hash(nts2)) &lt;&lt; '\n'; // false
	std::cout &lt;&lt; "str1 and str2: " &lt;&lt; (str_hash(str1) == str_hash(str2)) &lt;&lt; '\n'; // true

	return 0;
}

/
int test_functional_is_bind_expression()
{
	using namespace std::placeholders;  // introduces _1
	auto increase_int = std::bind(std::plus&lt;int&gt;(), _1, 1);

	std::cout &lt;&lt; std::boolalpha;
	std::cout &lt;&lt; std::is_bind_expression&lt;decltype(increase_int)&gt;::value &lt;&lt; '\n'; // true

	return 0;
}

/
int test_functional_is_placeholder()
{
	using namespace std::placeholders;  // introduces _1

	std::cout &lt;&lt; std::is_placeholder&lt;decltype(_1)&gt;::value &lt;&lt; '\n'; // 1
	std::cout &lt;&lt; std::is_placeholder&lt;decltype(_2)&gt;::value &lt;&lt; '\n'; // 2
	std::cout &lt;&lt; std::is_placeholder&lt;int&gt;::value &lt;&lt; '\n'; // 0

	return 0;
}

} // namespace functional_</code></pre> 
<p><br><strong>GitHub</strong>： <a href="https://github.com/fengbingchun/Messy_Test">https://github.com/fengbingchun/Messy_Test</a></p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/341a5112542a3d11d47b68580f62e9a7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c&#43;&#43; 静态库与动态库</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/36d94d08e6b3ab8bb9b8628208f7a884/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">maven项目test报错Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>