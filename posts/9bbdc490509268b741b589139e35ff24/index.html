<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基础篇（二）：内存屏障是什么 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基础篇（二）：内存屏障是什么" />
<meta property="og:description" content="目录 前置知识：内存屏障什么是内存屏障作用内存屏障的分类1. 强制读取/刷新主内存的屏障强制刷新主内存：Load屏障强制读取主内存：Store屏障总结 2. 禁止指令重排序的屏障LoadLoad屏障StoreStore屏障LoadStore屏障StoreLoad屏障以StoreStore屏障和StoreLoad屏障举个例子 前置知识：内存屏障 什么是内存屏障 内存屏障是一种指令，无论是在JAVA内存模型还是CPU层次，都是有具体的指令对应的，是一种特殊的指令。
作用 这种指令具有屏障的作用，所谓屏障，也就是类似关卡，类似栅栏，具有隔离的作用。
内存屏障的分类 强制读取主内存，强制刷新主内存的内存屏障，叫做Load屏障和Store屏障禁止指令重排序的内存屏障，有四个分别叫做LoadLoad屏障、StoreStore屏障、LoadStore屏障、StoreLoad屏障 1. 强制读取/刷新主内存的屏障 Load屏障：执行读取数据的时候，强制每次都从主内存读取最新的值。
Store屏障：每次执行修改数据的时候，强制刷新回主内存。
强制刷新主内存：Load屏障 如上图所示：在工作内存的变量名、变量的值之前有一道关卡或者栅栏，导致变量 i 获取不到工作内存中的值，所以每次只好主内存重新加载咯。
强制读取主内存：Store屏障 如上图所示，每次执行assign指令将数据变更之后，后面都会紧紧跟着一个Store屏障，让你立刻刷新到主内存。
总结 只要加了Load屏障，相当于加了一个栅栏，不管工作内存是否有数据，都是从主内存读取数据。只要加了Store屏障，具有强制作用，进行assign操作将变量更改了之后，立刻将变量刷新到主内存
2. 禁止指令重排序的屏障 LoadLoad屏障 序列：load1指令 LoadLoad屏障 load2指令
作用：在load1指令和load2指令之间加上 LoadLoad屏障，强制先执行load1指令再执行load2指令；load1指令和load2指令不能进行重排序（LoadLoad屏障 前面load指令禁止和屏障后面的load指令进行重排序）。
StoreStore屏障 序列：store1指令 StoreStore屏障 store2指令
作用：在store1指令和store2指令之间加上StoreStore屏障，强制先执行store1指令再执行store2指令；store1指令不能和store2指令进行重排序（StoreStore屏障 前面的store指令禁止和屏障后面的store指令进行重排序）
LoadStore屏障 序列：load1指令 LoadStore屏障 store2指令
作用：在load1指令和store2指令之前加上LoadStore屏障，强制先执行load1指令再执行store2指令；load1指令和store2执行不能重排序（LoadStore屏障 前面的load执行禁止和屏障后面的store指令进行重排序）
StoreLoad屏障 序列：store1指令 StoreLoad屏障 load2指令
作用：在store1指令和load2指令之间加上StoreLoad屏障，强制先执行store1指令再执行load2指令；
store1指令和load2指令执行不能重排序（StoreLoad屏障 前面的Store指令禁止和屏障后面的Store/Load指令进行重排）
以StoreStore屏障和StoreLoad屏障举个例子 （1）有三个区域分别是区域1、区域2、区域3
（2）区域1和区域2加了 StoreStore屏障，这样区域1和区域2的Store指令就被隔离开来，不能重排了
（3）区域2和区域3加了StoreLoad屏障，这样区域2和区域3的Store指令、Load指令就被隔离开来，不能重排了
（3）就相当于搞了个栅栏，禁止各个区域之间的指令跳来跳去的，否则就会导致乱序执行" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/9bbdc490509268b741b589139e35ff24/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-10T14:11:43+08:00" />
<meta property="article:modified_time" content="2023-02-10T14:11:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基础篇（二）：内存屏障是什么</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">前置知识：内存屏障</a></li><li><ul><li><a href="#_2" rel="nofollow">什么是内存屏障</a></li><li><a href="#_4" rel="nofollow">作用</a></li><li><a href="#_6" rel="nofollow">内存屏障的分类</a></li><li><ul><li><a href="#1__9" rel="nofollow">1. 强制读取/刷新主内存的屏障</a></li><li><ul><li><a href="#Load_13" rel="nofollow">强制刷新主内存：Load屏障</a></li><li><a href="#Store_16" rel="nofollow">强制读取主内存：Store屏障</a></li><li><a href="#_19" rel="nofollow">总结</a></li></ul> 
    </li><li><a href="#2__21" rel="nofollow">2. 禁止指令重排序的屏障</a></li><li><ul><li><a href="#LoadLoad_22" rel="nofollow">LoadLoad屏障</a></li><li><a href="#StoreStore_27" rel="nofollow">StoreStore屏障</a></li><li><a href="#LoadStore_32" rel="nofollow">LoadStore屏障</a></li><li><a href="#StoreLoad_37" rel="nofollow">StoreLoad屏障</a></li><li><a href="#StoreStoreStoreLoad_42" rel="nofollow">以StoreStore屏障和StoreLoad屏障举个例子</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>前置知识：内存屏障</h2> 
<h3><a id="_2"></a>什么是内存屏障</h3> 
<p>内存屏障是一种指令，无论是在JAVA内存模型还是CPU层次，都是有具体的指令对应的，是一种特殊的指令。</p> 
<h3><a id="_4"></a>作用</h3> 
<p>这种指令具有屏障的作用，所谓屏障，也就是类似关卡，类似栅栏，具有隔离的作用。</p> 
<h3><a id="_6"></a>内存屏障的分类</h3> 
<ol><li>强制读取主内存，强制刷新主内存的内存屏障，叫做Load屏障和Store屏障</li><li>禁止指令重排序的内存屏障，有四个分别叫做LoadLoad屏障、StoreStore屏障、LoadStore屏障、StoreLoad屏障</li></ol> 
<h4><a id="1__9"></a>1. 强制读取/刷新主内存的屏障</h4> 
<p>Load屏障：执行读取数据的时候，强制每次都从主内存读取最新的值。<br> Store屏障：每次执行修改数据的时候，强制刷新回主内存。</p> 
<h5><a id="Load_13"></a>强制刷新主内存：Load屏障</h5> 
<p><img src="https://images2.imgbox.com/36/7c/pzy0X9Kb_o.png" alt="在这里插入图片描述"><br> 如上图所示：在工作内存的变量名、变量的值之前有一道关卡或者栅栏，导致变量 i 获取不到工作内存中的值，所以每次只好主内存重新加载咯。</p> 
<h5><a id="Store_16"></a>强制读取主内存：Store屏障</h5> 
<p><img src="https://images2.imgbox.com/3a/35/owwch5As_o.png" alt="在这里插入图片描述"><br> 如上图所示，每次执行assign指令将数据变更之后，后面都会紧紧跟着一个Store屏障，让你立刻刷新到主内存。</p> 
<h5><a id="_19"></a>总结</h5> 
<p>只要加了Load屏障，相当于加了一个栅栏，不管工作内存是否有数据，都是从主内存读取数据。只要加了Store屏障，具有强制作用，进行assign操作将变量更改了之后，立刻将变量刷新到主内存</p> 
<h4><a id="2__21"></a>2. 禁止指令重排序的屏障</h4> 
<h5><a id="LoadLoad_22"></a>LoadLoad屏障</h5> 
<p>序列：load1指令 LoadLoad屏障 load2指令</p> 
<p>作用：在load1指令和load2指令之间加上 LoadLoad屏障，强制先执行load1指令再执行load2指令；load1指令和load2指令不能进行重排序（LoadLoad屏障 前面load指令禁止和屏障后面的load指令进行重排序）。</p> 
<h5><a id="StoreStore_27"></a>StoreStore屏障</h5> 
<p>序列：store1指令 StoreStore屏障 store2指令</p> 
<p>作用：在store1指令和store2指令之间加上StoreStore屏障，强制先执行store1指令再执行store2指令；store1指令不能和store2指令进行重排序（StoreStore屏障 前面的store指令禁止和屏障后面的store指令进行重排序）</p> 
<h5><a id="LoadStore_32"></a>LoadStore屏障</h5> 
<p>序列：load1指令 LoadStore屏障 store2指令</p> 
<p>作用：在load1指令和store2指令之前加上LoadStore屏障，强制先执行load1指令再执行store2指令；load1指令和store2执行不能重排序（LoadStore屏障 前面的load执行禁止和屏障后面的store指令进行重排序）</p> 
<h5><a id="StoreLoad_37"></a>StoreLoad屏障</h5> 
<p>序列：store1指令 StoreLoad屏障 load2指令</p> 
<p>作用：在store1指令和load2指令之间加上StoreLoad屏障，强制先执行store1指令再执行load2指令；<br> store1指令和load2指令执行不能重排序（StoreLoad屏障 前面的Store指令禁止和屏障后面的Store/Load指令进行重排）</p> 
<h5><a id="StoreStoreStoreLoad_42"></a>以StoreStore屏障和StoreLoad屏障举个例子</h5> 
<p><img src="https://images2.imgbox.com/38/f3/Eh9o1jph_o.png" alt="在这里插入图片描述"><br> （1）有三个区域分别是区域1、区域2、区域3<br> （2）区域1和区域2加了 StoreStore屏障，这样区域1和区域2的Store指令就被隔离开来，不能重排了<br> （3）区域2和区域3加了StoreLoad屏障，这样区域2和区域3的Store指令、Load指令就被隔离开来，不能重排了<br> （3）就相当于搞了个栅栏，禁止各个区域之间的指令跳来跳去的，否则就会导致乱序执行</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bdcb04c649397954f04111621b2d7868/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">hive outline</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f6861776e54b57447c01cd498d844502/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C#编程，异步中的等待处理Task.Delay</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>