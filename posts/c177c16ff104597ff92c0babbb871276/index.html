<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第一个例子：使用 Sorter 接口排序 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第一个例子：使用 Sorter 接口排序" />
<meta property="og:description" content="简介 一个很好的例子是来自标准库的 sort 包，要对一组数字或字符串排序，只需要实现三个方法：反映元素个数的 Len()方法、比较第 i 和 j 个元素的 Less(i, j) 方法以及交换第 i 和 j 个元素的 Swap(i, j) 方法。 排序函数的算法只会使用到这三个方法（可以使用任何排序算法来实现，此处我们使用冒泡排序）：
func Sort(data Sorter) { for pass := 1; pass &lt; data.Len(); pass&#43;&#43; { for i := 0;i &lt; data.Len() - pass; i&#43;&#43; { if data.Less(i&#43;1, i) { data.Swap(i, i &#43; 1) } } } } Sort 函数接收一个接口类型参数：Sorter ，它声明了这些方法：
type Sorter interface { Len() int Less(i, j int) bool Swap(i, j int) } 参数中的 int 是待排序序列长度的类型，而不是说要排序的对象一定要是一组 int。i 和 j 表示元素的整型索引，长度也是整型的。 现在如果我们想对一个 int 数组进行排序，所有必须做的事情就是：为数组定一个类型并在它上面实现 Sorter 接口的方法：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c177c16ff104597ff92c0babbb871276/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-04-07T00:24:15+08:00" />
<meta property="article:modified_time" content="2018-04-07T00:24:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第一个例子：使用 Sorter 接口排序</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="简介">简介</h3> 
<blockquote> 
 <p>一个很好的例子是来自标准库的 sort 包，要对一组数字或字符串排序，只需要实现三个方法：反映元素个数的 Len()方法、比较第 i 和 j 个元素的 Less(i, j) 方法以及交换第 i 和 j 个元素的 Swap(i, j) 方法。 <br> 排序函数的算法只会使用到这三个方法（可以使用任何排序算法来实现，此处我们使用冒泡排序）：</p> 
</blockquote> 
<pre class="prettyprint"><code class=" hljs haskell"><span class="hljs-title">func</span> <span class="hljs-type">Sort</span>(<span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">Sorter</span>) <span class="hljs-container">{
    <span class="hljs-title">for</span> <span class="hljs-title">pass</span> := 1; <span class="hljs-title">pass</span> &lt; <span class="hljs-title">data</span>.<span class="hljs-type">Len</span>(); <span class="hljs-title">pass</span>++ {
        <span class="hljs-title">for</span> <span class="hljs-title">i</span> := 0;<span class="hljs-title">i</span> &lt; <span class="hljs-title">data</span>.<span class="hljs-type">Len</span>() - <span class="hljs-title">pass</span>; <span class="hljs-title">i</span>++ {
            <span class="hljs-title">if</span> <span class="hljs-title">data</span>.<span class="hljs-type">Less</span>(<span class="hljs-title">i</span>+1, <span class="hljs-title">i</span>) {
                <span class="hljs-title">data</span>.<span class="hljs-type">Swap</span>(<span class="hljs-title">i</span>, <span class="hljs-title">i</span> + 1)
            }</span></span>
        }
    }
}</code></pre> 
<p>Sort 函数接收一个接口类型参数：Sorter ，它声明了这些方法：</p> 
<pre class="prettyprint"><code class=" hljs haskell"><span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Sorter</span> interface <span class="hljs-container">{
    <span class="hljs-type">Len</span>() <span class="hljs-title">int</span>
    <span class="hljs-type">Less</span>(<span class="hljs-title">i</span>, <span class="hljs-title">j</span> <span class="hljs-title">int</span>) <span class="hljs-title">bool</span>
    <span class="hljs-type">Swap</span>(<span class="hljs-title">i</span>, <span class="hljs-title">j</span> <span class="hljs-title">int</span>)
}</span></span></code></pre> 
<p>参数中的 int 是待排序序列长度的类型，而不是说要排序的对象一定要是一组 int。i 和 j 表示元素的整型索引，长度也是整型的。 <br> 现在如果我们想对一个 int 数组进行排序，所有必须做的事情就是：为数组定一个类型并在它上面实现 Sorter 接口的方法：</p> 
<pre class="prettyprint"><code class=" hljs go">
<span class="hljs-keyword">type</span> IntArray []<span class="hljs-typename">int</span>
<span class="hljs-keyword">func</span> (p IntArray) Len() <span class="hljs-typename">int</span>           { <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(p) }
<span class="hljs-keyword">func</span> (p IntArray) Less(i, j <span class="hljs-typename">int</span>) <span class="hljs-typename">bool</span> { <span class="hljs-keyword">return</span> p[i] &lt; p[j] }
<span class="hljs-keyword">func</span> (p IntArray) Swap(i, j <span class="hljs-typename">int</span>)      { p[i], p[j] = p[j], p[i] }</code></pre> 
<p>下面是调用排序函数的一个具体例子：</p> 
<pre class="prettyprint"><code class=" hljs haskell"><span class="hljs-typedef"><span class="hljs-keyword">data</span> := []int<span class="hljs-container">{74, 59, 238, -784, 9845, 959, 905, 0, 0, 42, 7586, -5467984, 7586}</span></span>
<span class="hljs-title">a</span> := sort.<span class="hljs-type">IntArray</span>(<span class="hljs-typedef"><span class="hljs-keyword">data</span>) //conversion to <span class="hljs-keyword">type</span> <span class="hljs-type">IntArray</span> from package sort</span>
<span class="hljs-title">sort</span>.<span class="hljs-type">Sort</span>(a)</code></pre> 
<p>同样的原理，排序函数可以用于一个浮点型数组，一个字符串数组，或者一个表示每周各天的结构体 dayArray.</p> 
<pre class="prettyprint"><code class=" hljs go"><span class="hljs-keyword">package</span> sort

<span class="hljs-keyword">type</span> Sorter <span class="hljs-keyword">interface</span> {
    Len() <span class="hljs-typename">int</span>
    Less(i, j <span class="hljs-typename">int</span>) <span class="hljs-typename">bool</span>
    Swap(i, j <span class="hljs-typename">int</span>)
}

<span class="hljs-keyword">func</span> Sort(data Sorter) {
    <span class="hljs-keyword">for</span> pass :=<span class="hljs-number"> 1</span>; pass &lt; data.Len(); pass++ {
        <span class="hljs-keyword">for</span> i :=<span class="hljs-number"> 0</span>; i &lt; data.Len()-pass; i++ {
            <span class="hljs-keyword">if</span> data.Less(i<span class="hljs-number">+1</span>, i) {
                data.Swap(i, i<span class="hljs-number">+1</span>)
            }
        }
    }
}

<span class="hljs-keyword">func</span> IsSorted(data Sorter) <span class="hljs-typename">bool</span> {
    n := data.Len()
    <span class="hljs-keyword">for</span> i := n -<span class="hljs-number"> 1</span>; i &gt;<span class="hljs-number"> 0</span>; i-- {
        <span class="hljs-keyword">if</span> data.Less(i, i<span class="hljs-number">-1</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-constant">false</span>
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-constant">true</span>
}

<span class="hljs-comment">// Convenience types for common cases</span>
<span class="hljs-keyword">type</span> IntArray []<span class="hljs-typename">int</span>

<span class="hljs-keyword">func</span> (p IntArray) Len() <span class="hljs-typename">int</span>           { <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(p) }
<span class="hljs-keyword">func</span> (p IntArray) Less(i, j <span class="hljs-typename">int</span>) <span class="hljs-typename">bool</span> { <span class="hljs-keyword">return</span> p[i] &lt; p[j] }
<span class="hljs-keyword">func</span> (p IntArray) Swap(i, j <span class="hljs-typename">int</span>)      { p[i], p[j] = p[j], p[i] }

<span class="hljs-keyword">type</span> StringArray []<span class="hljs-typename">string</span>

<span class="hljs-keyword">func</span> (p StringArray) Len() <span class="hljs-typename">int</span>           { <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(p) }
<span class="hljs-keyword">func</span> (p StringArray) Less(i, j <span class="hljs-typename">int</span>) <span class="hljs-typename">bool</span> { <span class="hljs-keyword">return</span> p[i] &lt; p[j] }
<span class="hljs-keyword">func</span> (p StringArray) Swap(i, j <span class="hljs-typename">int</span>)      { p[i], p[j] = p[j], p[i] }

<span class="hljs-comment">// Convenience wrappers for common cases</span>
<span class="hljs-keyword">func</span> SortInts(a []<span class="hljs-typename">int</span>)       { Sort(IntArray(a)) }
<span class="hljs-keyword">func</span> SortStrings(a []<span class="hljs-typename">string</span>) { Sort(StringArray(a)) }

<span class="hljs-keyword">func</span> IntsAreSorted(a []<span class="hljs-typename">int</span>) <span class="hljs-typename">bool</span>       { <span class="hljs-keyword">return</span> IsSorted(IntArray(a)) }
<span class="hljs-keyword">func</span> StringsAreSorted(a []<span class="hljs-typename">string</span>) <span class="hljs-typename">bool</span> { <span class="hljs-keyword">return</span> IsSorted(StringArray(a)) }</code></pre> 
<pre class="prettyprint"><code class=" hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"./sort"</span>
    <span class="hljs-string">"fmt"</span>
)

<span class="hljs-keyword">func</span> ints() {
    data := []<span class="hljs-typename">int</span><span class="hljs-number">{74</span>,<span class="hljs-number"> 59</span>,<span class="hljs-number"> 238</span>,<span class="hljs-number"> -784</span>,<span class="hljs-number"> 9845</span>,<span class="hljs-number"> 959</span>,<span class="hljs-number"> 905</span>,<span class="hljs-number"> 0</span>,<span class="hljs-number"> 0</span>,<span class="hljs-number"> 42</span>,<span class="hljs-number"> 7586</span>,<span class="hljs-number"> -5467984</span>,<span class="hljs-number"> 7586</span>}
    a := sort.IntArray(data) <span class="hljs-comment">//conversion to type IntArray</span>
    sort.Sort(a)
    <span class="hljs-keyword">if</span> !sort.IsSorted(a) {
        <span class="hljs-built_in">panic</span>(<span class="hljs-string">"fails"</span>)
    }
    fmt.Printf(<span class="hljs-string">"The sorted array is: %v\n"</span>, a)
}

<span class="hljs-keyword">func</span> strings() {
    data := []<span class="hljs-typename">string</span>{<!-- --><span class="hljs-string">"monday"</span>, <span class="hljs-string">"friday"</span>, <span class="hljs-string">"tuesday"</span>, <span class="hljs-string">"wednesday"</span>, <span class="hljs-string">"sunday"</span>, <span class="hljs-string">"thursday"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"saturday"</span>}
    a := sort.StringArray(data)
    sort.Sort(a)
    <span class="hljs-keyword">if</span> !sort.IsSorted(a) {
        <span class="hljs-built_in">panic</span>(<span class="hljs-string">"fail"</span>)
    }
    fmt.Printf(<span class="hljs-string">"The sorted array is: %v\n"</span>, a)
}

<span class="hljs-keyword">type</span> day <span class="hljs-keyword">struct</span> {
    num       <span class="hljs-typename">int</span>
    shortName <span class="hljs-typename">string</span>
    longName  <span class="hljs-typename">string</span>
}

<span class="hljs-keyword">type</span> dayArray <span class="hljs-keyword">struct</span> {
    data []*day
}

<span class="hljs-keyword">func</span> (p *dayArray) Len() <span class="hljs-typename">int</span>           { <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(p.data) }
<span class="hljs-keyword">func</span> (p *dayArray) Less(i, j <span class="hljs-typename">int</span>) <span class="hljs-typename">bool</span> { <span class="hljs-keyword">return</span> p.data[i].num &lt; p.data[j].num }
<span class="hljs-keyword">func</span> (p *dayArray) Swap(i, j <span class="hljs-typename">int</span>)      { p.data[i], p.data[j] = p.data[j], p.data[i] }

<span class="hljs-keyword">func</span> days() {
    Sunday    := day<span class="hljs-number">{0</span>, <span class="hljs-string">"SUN"</span>, <span class="hljs-string">"Sunday"</span>}
    Monday    := day<span class="hljs-number">{1</span>, <span class="hljs-string">"MON"</span>, <span class="hljs-string">"Monday"</span>}
    Tuesday   := day<span class="hljs-number">{2</span>, <span class="hljs-string">"TUE"</span>, <span class="hljs-string">"Tuesday"</span>}
    Wednesday := day<span class="hljs-number">{3</span>, <span class="hljs-string">"WED"</span>, <span class="hljs-string">"Wednesday"</span>}
    Thursday  := day<span class="hljs-number">{4</span>, <span class="hljs-string">"THU"</span>, <span class="hljs-string">"Thursday"</span>}
    Friday    := day<span class="hljs-number">{5</span>, <span class="hljs-string">"FRI"</span>, <span class="hljs-string">"Friday"</span>}
    Saturday  := day<span class="hljs-number">{6</span>, <span class="hljs-string">"SAT"</span>, <span class="hljs-string">"Saturday"</span>}
    data := []*day{&amp;Tuesday, &amp;Thursday, &amp;Wednesday, &amp;Sunday, &amp;Monday, &amp;Friday, &amp;Saturday}
    a := dayArray{data}
    sort.Sort(&amp;a)
    <span class="hljs-keyword">if</span> !sort.IsSorted(&amp;a) {
        <span class="hljs-built_in">panic</span>(<span class="hljs-string">"fail"</span>)
    }
    <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> data {
        fmt.Printf(<span class="hljs-string">"%s "</span>, d.longName)
    }
    fmt.Printf(<span class="hljs-string">"\n"</span>)
}

<span class="hljs-keyword">func</span> main() {
    ints()
    strings()
    days()
}</code></pre> 
<p>输出：</p> 
<pre class="prettyprint"><code class=" hljs mathematica">The sorted array is: [-<span class="hljs-number">5467984</span> -<span class="hljs-number">784</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">42</span> <span class="hljs-number">59</span> <span class="hljs-number">74</span> <span class="hljs-number">238</span> <span class="hljs-number">905</span> <span class="hljs-number">959</span> <span class="hljs-number">7586</span> <span class="hljs-number">7586</span> <span class="hljs-number">9845</span>]
The sorted array is: [ friday monday saturday sunday thursday tuesday wednesday]
<span class="hljs-keyword">Sunday</span> <span class="hljs-keyword">Monday</span> <span class="hljs-keyword">Tuesday</span> <span class="hljs-keyword">Wednesday</span> <span class="hljs-keyword">Thursday</span> <span class="hljs-keyword">Friday</span> <span class="hljs-keyword">Saturday</span> </code></pre> 
<h3 id="备注">备注：</h3> 
<blockquote> 
 <p>panic(“fail”) 用于停止处于在非正常情况下的程序（详细请参考 第13章），当然也可以先打印一条信息，然后调用 <br> os.Exit(1) 来停止程序。 <br> 上面的例子帮助我们进一步了解了接口的意义和使用方式。对于基本类型的排序，标准库已经提供了相关的排序函数，所以不需要我们再重复造轮子了。对于一般性的排序，sort <br> 包定义了一个接口：</p> 
</blockquote> 
<pre class="prettyprint"><code class=" hljs haskell"><span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Interface</span> interface <span class="hljs-container">{
    <span class="hljs-type">Len</span>() <span class="hljs-title">int</span>
    <span class="hljs-type">Less</span>(<span class="hljs-title">i</span>, <span class="hljs-title">j</span> <span class="hljs-title">int</span>) <span class="hljs-title">bool</span>
    <span class="hljs-type">Swap</span>(<span class="hljs-title">i</span>, <span class="hljs-title">j</span> <span class="hljs-title">int</span>)
}</span></span></code></pre> 
<blockquote> 
 <p>这个接口总结了需要用于排序的抽象方法，函数 Sort(data Interface) 用来对此类对象进行排序，可以用它们来实现对其他数据（非基本类型）进行排序。在上面的例子中，我们也是这么做的，不仅可以对 int 和 string 序列进行排序，也可以对用户自定义类型 dayArray 进行排序。</p> 
</blockquote> 
<h3 id="转载地址">转载地址</h3> 
<p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.7.md">https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.7.md</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6919639f31bf5f14ba4af23b4d0dc8b4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一道全排列算法题目</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a9274ea812382f040b34284c3fd1ae42/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">win10美化工具全套详细解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>