<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>操作系统——进程管理的功能 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="操作系统——进程管理的功能" />
<meta property="og:description" content="一. 进程控制 1. 什么是进程控制？ 进程控制是进程管理中的最基本的功能，主要包括创建新进程、终止已完成的进程、将因发生异常情况而无法继续运行的进程置于阻塞状态、负责进程运行中的状态转换功能。
简单来说：进程控制就是要实现进程状态的转换
2. 如何实现进程控制呢？ 3. 进程的切换需要修改PCB的内容，并放到相应的队列中去，假如没有修改PCB中的状态标志就把PCB放入到某个队列中去了，这种情况特别危险，怎么避免呢？ 4. 进程控制原语做了哪些事情呢？ 5. 进程创建 6. 进程终止 7. 进程的阻塞与唤醒 8. 进程的挂起和激活 9. 进程的切换 二. 进程通信 在网络环境的应用领域主流的进程通信实现机制：客户机-服务器系统
1. 什么是进程通信呢？ 2. 共享存储 3. 管道通信 4. 消息传递 三. 处理机调度 1. 什么是调度 在多道程序系统中，调度的实质是一种资源分配。
处理机调度就是对处理机资源进行分配。
2. 处理机调度的层次 在多道批处理系统中，一个作业从提交到获得处理机执行，直至作业运行完毕，可能需要经历多级处理机调度
注：作业和进程的区别
作业（Job）是一个总任务，进程（Process）是总任务中的各个子项。 例如：课室大扫除是一项总任务，它是一个作业； 而其中擦桌子、扫地是各个子任务，擦桌子需要多次执行（每桌子执行一次），扫地只需要执行一次，这些就是在作业中调度的进程。 (1). 高级调度 1. 什么是作业 作业（job）：是一个比程序更为广泛的概念，他不仅包含了通常的程序和数据，而且还应配有一份作业说明书，系统根据说明书对程序的运行进行控制。在批处理系统中，是以作业为基本单位从外存调入内存
作业步：在作业运行期间，每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤才能得到结果。 我们把其中的每一个加工步骤称为一个作业步，各作业步相互联系，上一个作业的输出是下一个作业的输入。 例如：一个典型作业分为：编译作业步、链接装配作业步、运行作业步 2. 作业里面含有什么？ 程序
数据
作业说明书
作业控制块（Job control block，JCB）
作业控制块是作业说明书在系统中生成的一张表格， 在多道批处理系统中，它是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息 3. 作业运行的三个阶段 收容阶段运行阶段完成阶段 4. 作业调度的主要任务 根据JCB中的信息，检查系统中的资源能否满足作业对资源的需求，以及按照一定的调度算法，从外存的后备队列选取某些作业调入内存，并为它们创建进程、分配资源。然后再将新创建的进程排在就绪队列上等待调度。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f6e49c50b4731cbd2c7ab02120563a77/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-16T21:47:29+08:00" />
<meta property="article:modified_time" content="2020-08-16T21:47:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">操作系统——进程管理的功能</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="__0"></a>一. 进程控制</h2> 
<p><img src="https://images2.imgbox.com/00/58/5UY3gM4q_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1__4"></a>1. 什么是进程控制？</h3> 
<p>进程控制是进程管理中的最基本的功能，主要包括创建新进程、终止已完成的进程、将因发生异常情况而无法继续运行的进程置于阻塞状态、负责进程运行中的状态转换功能。</p> 
<p>简单来说：进程控制就是要实现进程状态的转换</p> 
<h3><a id="2__9"></a>2. 如何实现进程控制呢？</h3> 
<p><img src="https://images2.imgbox.com/c2/02/KY2nIadt_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3_PCBPCBPCB_11"></a>3. 进程的切换需要修改PCB的内容，并放到相应的队列中去，假如没有修改PCB中的状态标志就把PCB放入到某个队列中去了，这种情况特别危险，怎么避免呢？</h3> 
<p><img src="https://images2.imgbox.com/0b/80/XYcEVQij_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4__13"></a>4. 进程控制原语做了哪些事情呢？</h3> 
<p><img src="https://images2.imgbox.com/07/a6/LOH5UrZ4_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5__15"></a>5. 进程创建</h3> 
<p><img src="https://images2.imgbox.com/dc/32/KrBnzh1O_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="6__19"></a>6. 进程终止</h3> 
<p><img src="https://images2.imgbox.com/47/bf/RqdE002g_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="7__21"></a>7. 进程的阻塞与唤醒</h3> 
<p><img src="https://images2.imgbox.com/f0/0f/Qj1rKkiS_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="8__24"></a>8. 进程的挂起和激活</h3> 
<p><img src="https://images2.imgbox.com/25/b1/POg0QCjJ_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="9__27"></a>9. 进程的切换</h3> 
<p><img src="https://images2.imgbox.com/fe/af/tV2s7MRv_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c3/09/pBxMeb89_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="__31"></a>二. 进程通信</h2> 
<p><img src="https://images2.imgbox.com/d1/58/7YVisRqv_o.png" alt="在这里插入图片描述"><br> 在网络环境的应用领域主流的进程通信实现机制：客户机-服务器系统<br> <img src="https://images2.imgbox.com/6b/7f/NQ6PQfAX_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1__37"></a>1. 什么是进程通信呢？</h3> 
<p><img src="https://images2.imgbox.com/34/8e/UYNibZ79_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2__39"></a>2. 共享存储</h3> 
<p><img src="https://images2.imgbox.com/b1/37/MwcRRZE1_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3__41"></a>3. 管道通信</h3> 
<p><img src="https://images2.imgbox.com/ea/36/8vYmAsIS_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4__43"></a>4. 消息传递</h3> 
<p><img src="https://images2.imgbox.com/c8/4f/kiw2h15P_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="__45"></a>三. 处理机调度</h2> 
<p><img src="https://images2.imgbox.com/c0/9a/DX38Y4fu_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1__48"></a>1. 什么是调度</h3> 
<p><img src="https://images2.imgbox.com/91/fe/EZRlwJNI_o.png" alt="在这里插入图片描述"><br> 在多道程序系统中，调度的实质是一种资源分配。</p> 
<p>处理机调度就是对处理机资源进行分配。</p> 
<h3><a id="2__54"></a>2. 处理机调度的层次</h3> 
<blockquote> 
 <p>在多道批处理系统中，一个作业从提交到获得处理机执行，直至作业运行完毕，可能需要经历多级处理机调度</p> 
</blockquote> 
<p>注：作业和进程的区别</p> 
<pre><code>作业（Job）是一个总任务，进程（Process）是总任务中的各个子项。
例如：课室大扫除是一项总任务，它是一个作业；
	  而其中擦桌子、扫地是各个子任务，擦桌子需要多次执行（每桌子执行一次），扫地只需要执行一次，这些就是在作业中调度的进程。
</code></pre> 
<h4><a id="1__64"></a>(1). 高级调度</h4> 
<p><img src="https://images2.imgbox.com/1d/c6/DQuVgKkv_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1__67"></a>1. 什么是作业</h5> 
<p>作业（job）：是一个比程序更为广泛的概念，他不仅包含了通常的程序和数据，而且还应配有一份作业说明书，系统根据说明书对程序的运行进行控制。在批处理系统中，是以作业为基本单位从外存调入内存</p> 
<pre><code>作业步：在作业运行期间，每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤才能得到结果。
我们把其中的每一个加工步骤称为一个作业步，各作业步相互联系，上一个作业的输出是下一个作业的输入。

例如：一个典型作业分为：编译作业步、链接装配作业步、运行作业步
</code></pre> 
<h5><a id="2__75"></a>2. 作业里面含有什么？</h5> 
<ol><li> <p>程序</p> </li><li> <p>数据</p> </li><li> <p>作业说明书</p> </li><li> <p>作业控制块（Job control block，JCB）</p> <pre><code> 作业控制块是作业说明书在系统中生成的一张表格，
 在多道批处理系统中，它是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息
</code></pre> </li></ol> 
<h5><a id="3__84"></a>3. 作业运行的三个阶段</h5> 
<ol><li>收容阶段</li><li>运行阶段</li><li>完成阶段</li></ol> 
<h5><a id="4__89"></a>4. 作业调度的主要任务</h5> 
<p>根据JCB中的信息，检查系统中的资源能否满足作业对资源的需求，以及按照一定的调度算法，从外存的后备队列选取某些作业调入内存，并为它们创建进程、分配资源。然后再将新创建的进程排在就绪队列上等待调度。</p> 
<h4><a id="2__92"></a>(2). 中级调度</h4> 
<p><img src="https://images2.imgbox.com/b6/f6/vZpCXYrm_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3__94"></a>(3). 低级调度</h4> 
<p><img src="https://images2.imgbox.com/9a/d4/I7DPrpah_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b2/27/rqEDO88B_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1__97"></a>1. 进程调度的时机是什么？</h5> 
<p><img src="https://images2.imgbox.com/7d/cc/mAeQwxiA_o.png" alt="在这里插入图片描述"><br> 用一个例题来解释：为什么进程在操作系统内核程序临界区中不能进行进程调度<br> <img src="https://images2.imgbox.com/82/14/kQkXGJkw_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2__101"></a>2. 进程调度的方式</h5> 
<blockquote> 
 <p>在有的操作系统中，只允许进程主动放弃处理机，而不允许进程在运行的时候被迫的倍剥夺资源。<br> 有的操作系统中，进程可以主动的放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）</p> 
</blockquote> 
<p>这样我们可以根据当前运行的进程是否可以被强行剥夺处理机资源这个问题我们引出<br> 进程调度的方式：<br> <img src="https://images2.imgbox.com/54/13/QjgOzFXG_o.png" alt="在这里插入图片描述"><br> 注：</p> 
<ol><li> <p>非抢占方式</p> <p>采用了非抢占调度方式之后，还会引起进程调度的因素就只有以下几种情况</p> <pre><code> 正在执行的进程运行完毕，或因发生某事件而使其无法继续运行
 正在执行中的进程因提出I/O请求而暂停执行
 在进程通信或同步过程中，执行了某种原语操作，如block原语
</code></pre> <p>非抢占方式不能用于分时和大多数实时操作系统</p> </li><li> <p>抢占方式</p> <p>抢占不是任意的，而是有一定的规则</p> <pre><code> 优先级原则
 短进程有限原则
 时间片原则
</code></pre> </li></ol> 
<h5><a id="3__128"></a>3. 进程切换的过程</h5> 
<p>既然选择了一个进程要为他分配处理机的话，我们怎么进行进程切换呢？</p> 
<p><img src="https://images2.imgbox.com/dc/8a/TnwjdPjS_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="4__132"></a>4. 进程调度实现机制</h5> 
<p><img src="https://images2.imgbox.com/29/02/I7uLAafl_o.png" alt="在这里插入图片描述"><br> 为了实现进程调度，在进程调度机制中，应具备如下三个基本部分：</p> 
<ol><li> <p>排队器</p> <pre><code> 为了提高进程调度的效率，应事先将系统中所有就绪进程按照一定的策略排列成一个或多个队列
</code></pre> </li><li> <p>分派器</p> <pre><code> 依据进程调度程序所选定的进程，将其从就绪队列中选取出来，
 然后进行从分派器到新选出进程间的上下文切换，将处理机分配给新进程
</code></pre> </li><li> <p>上下文切换器</p> <pre><code> 对处理机进程切换操作
 第一：保存当前进程上下文
 第二：移除分派车程序的上下文，把新的进程的CPU现场信息装入处理机
</code></pre> </li></ol> 
<h4><a id="4__150"></a>4. 三种层次的比较</h4> 
<p><img src="https://images2.imgbox.com/7c/87/8BSzy2La_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3__153"></a>3. 调度算法</h3> 
<h4><a id="1__154"></a>1. 调度算法的评价指标</h4> 
<p><img src="https://images2.imgbox.com/47/4c/dimecckI_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1_CPU_156"></a>(1). CPU的利用率</h5> 
<p><img src="https://images2.imgbox.com/40/55/kcizyjjm_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2__158"></a>(2). 系统吞吐量</h5> 
<p><img src="https://images2.imgbox.com/f5/a7/0YxwcBLW_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3__160"></a>(3). 周转时间</h5> 
<p><img src="https://images2.imgbox.com/c7/a8/YPN00Hk6_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/71/96/V00mvvON_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="4__164"></a>(4). 等待时间</h5> 
<p><img src="https://images2.imgbox.com/69/c9/xphaTX6g_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="5__166"></a>(5). 响应时间</h5> 
<p><img src="https://images2.imgbox.com/22/a4/jkxwNiHi_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2__168"></a>2. 调度算法举例①（早期批处理系统使用的算法，交互性差）</h4> 
<p><img src="https://images2.imgbox.com/86/fc/joqksUpc_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1_FCFS_First_Come_First_Server_170"></a>(1). 先来先服务（FCFS, First Come First Server）</h5> 
<p><img src="https://images2.imgbox.com/a9/d6/WAezBnrW_o.png" alt="在这里插入图片描述"><br> 举例：<br> <img src="https://images2.imgbox.com/2c/19/dB1rrJv8_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_SJFShortest_Job_Frist_175"></a>(2). 短作业优先（SJF，Shortest Job Frist）</h5> 
<p><img src="https://images2.imgbox.com/75/7f/RbeDrdkd_o.png" alt="在这里插入图片描述"><br> 举例1：非抢占式短进程优先（SPF，Shortest Process Frist）<br> <img src="https://images2.imgbox.com/e2/ca/uy4WCkoc_o.png" alt="在这里插入图片描述"><br> 举例2：最短进程优先算法的抢占式版本是最短剩余时间优先（Shortest Remaining Time Next， SRTN)算法<br> <img src="https://images2.imgbox.com/ed/cd/NpqZtHah_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/04/c0/52viptkz_o.png" alt="在这里插入图片描述"><br> 短作业优先算法注意的小细节<br> <img src="https://images2.imgbox.com/da/4e/RtMI7qhj_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3_HRRNHighest_Response_Ratio_Next_184"></a>(3). 高响应比优先（HRRN，Highest Response Ratio Next）</h5> 
<p>从FCFS和FJS两种算法来思考，得出一个新的算法<br> <img src="https://images2.imgbox.com/34/e7/UeysDgJP_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/09/cd/Mx2VfUUl_o.png" alt="在这里插入图片描述"><br> 举例：<br> <img src="https://images2.imgbox.com/ed/c9/rgNqhGNV_o.png" alt="在这里插入图片描述"><br> 三种算法的比较<br> <img src="https://images2.imgbox.com/bd/63/sdj6gEZO_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3__193"></a>3. 调度算法举例②（适合用于交互式系统）</h4> 
<h5><a id="1_RR_Round_Robin_194"></a>(1). 时间片轮转（RR, Round Robin）</h5> 
<p><img src="https://images2.imgbox.com/fe/00/zhHIw2oD_o.png" alt="在这里插入图片描述"><br> 举例1：时间片轮转调度算法（时间片为2）<br> <img src="https://images2.imgbox.com/2e/9e/uxo49qga_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e8/95/4ba0N5lq_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/aa/52/HDx9QNXR_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f9/88/4Z1DR9kP_o.png" alt="在这里插入图片描述"><br> 举例1：时间片轮转调度算法（时间片为5）<br> <img src="https://images2.imgbox.com/47/dc/X7M5Sa2z_o.png" alt="在这里插入图片描述"><br> 注：时间轮转调度算法的时间片不能太大或太小<br> <img src="https://images2.imgbox.com/a2/c7/kjEr1dwx_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/20/70/BJIlqSfz_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2__206"></a>(2). 优先级调度算法</h5> 
<p><img src="https://images2.imgbox.com/f6/b3/wN1t8f5g_o.png" alt="在这里插入图片描述"><br> 举例1：非抢占式优先级调度算法<br> <img src="https://images2.imgbox.com/dd/43/T8ReFs9L_o.png" alt="在这里插入图片描述"><br> 举例2：抢占式优先级调度算法<br> <img src="https://images2.imgbox.com/29/d3/oqvJYdf9_o.png" alt="在这里插入图片描述"><br> 注：补充一些知识<br> <img src="https://images2.imgbox.com/0d/e9/OBaqFfeY_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3_Multileved_feedback_queue_214"></a>(3). 多级反馈队列（Multileved feedback queue）调度算法</h5> 
<p><img src="https://images2.imgbox.com/05/db/arE795DD_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f3/6a/5Zo7DIUQ_o.png" alt="在这里插入图片描述"></p> 
<p>举例：多级反馈队列调度算法的规则<br> <img src="https://images2.imgbox.com/4c/3b/Ib4Lir9c_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/83/7d/lEwj7MJb_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/45/1a/yYaMUisE_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/80/2c/BaMpIu8t_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/97/ee/IWxH2duU_o.png" alt="在这里插入图片描述"><br> 三种算法总结：</p> 
<p><img src="https://images2.imgbox.com/dd/35/qxspTrfr_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="__228"></a>四. 进程同步和进程互斥</h2> 
<p><img src="https://images2.imgbox.com/86/7b/OF8Glyb0_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1__232"></a>1. 什么是进程同步</h3> 
<blockquote> 
 <p>在OS中引入进程之后，一方面可以使系统中的多道程序并发执行，这不仅能有效的改善资源利用率，还可以显著提高系统吞吐量，但是另一方面却使系统变得更加复杂<br> 如果不能采取有效措施，对多个进程的运行进行妥善管理，这些进程对系统资源的无序争夺对系统造成混乱。使每次处理结果都存在不确定性，即不可再现性</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/73/7d/rM1R9sYa_o.png" alt="在这里插入图片描述"><br> 进程同步的目标：对多个进程在执行次序上进行协调，使并发执行的进程能按照一定规则共享系统资源，进行相互合作，使程序的执行具有可再现性</p> 
<h3><a id="2__240"></a>2. 什么是进程互斥</h3> 
<blockquote> 
 <p>注：许多硬件资源如：打印机、磁带机等都属于临界资源，各进程间应采取互斥方式，实现对这种资源的共享</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/15/13/7BlqhUBQ_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>注：不论是硬件临界资源还是软件临界资源，多个进程必须互斥的对他进行访问<br> 人们把在每个进程值访问临界资源的那段代码称为临界区<br> 如果能够保证各进程互斥的进入临界区，就可以实现对临界资源的互斥访问</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/d3/11/JekIYSbP_o.png" alt="在这里插入图片描述"></p> 
<p>如果一个进程暂时不能进入临界区，那么该进程是否应该一直占着处理机？该进程有没有可能一直进不了临界区？<br> <img src="https://images2.imgbox.com/af/4e/bLhjpNpb_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3__255"></a>3. 如何实现进程互斥呢？</h3> 
<h4><a id="1__256"></a>(1). 进程互斥的软件实现方法</h4> 
<p><img src="https://images2.imgbox.com/52/08/8w0PgIWo_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_258"></a>方法一：单标志法</h5> 
<p><img src="https://images2.imgbox.com/13/24/XtLGEd93_o.png" alt="在这里插入图片描述"><br> 缺点：<br> <img src="https://images2.imgbox.com/e4/44/BugcbVs9_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_262"></a>方法二：双标志先检查法</h5> 
<p><img src="https://images2.imgbox.com/d1/8b/1YJkUx0J_o.png" alt="在这里插入图片描述"><br> 缺点：<br> <img src="https://images2.imgbox.com/44/83/qmXY7UJU_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_266"></a>方法三：双标志后检查法</h5> 
<p><img src="https://images2.imgbox.com/b7/8c/rct1wPFs_o.png" alt="在这里插入图片描述"></p> 
<p>缺点：<br> <img src="https://images2.imgbox.com/77/f5/r4uX6eNF_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Peterson_272"></a>方法四：Peterson算法</h5> 
<p><img src="https://images2.imgbox.com/c7/d4/4TwYDCOn_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c3/a0/pkux0uZ7_o.png" alt="在这里插入图片描述"><br> 缺点：<br> <img src="https://images2.imgbox.com/41/a3/92d5VXqT_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2__277"></a>(2). 进程互斥的硬件实现方法</h4> 
<p><img src="https://images2.imgbox.com/59/bd/8tHBPNMi_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_280"></a>方法一：中断屏蔽方法</h5> 
<p><img src="https://images2.imgbox.com/41/1e/ZhPnoMsh_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Test_and_Set_282"></a>方法二：Test and Set指令</h5> 
<p><img src="https://images2.imgbox.com/b5/12/GQYpQ9xn_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Swap_284"></a>方法三：Swap指令</h5> 
<p><img src="https://images2.imgbox.com/67/e3/0REVygRS_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4__286"></a>4. 如何更好的实现进程同步和互斥呢？</h3> 
<p><img src="https://images2.imgbox.com/df/90/pWXUnUEh_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1__288"></a>1. 什么是信号量？</h4> 
<p><img src="https://images2.imgbox.com/f4/f0/sSrnNc5F_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2__290"></a>2. 有哪些信号量机制？</h4> 
<blockquote> 
 <p>信号量机制主要有：整型信号量机制、记录型信号量机制、AND信号量机制、信号量集机制<br> 而我们主要介绍以下两种：整型信号量机制、记录型信号量机制</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/51/2e/qIO6Apz1_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1__297"></a>(1). 整型信号量</h5> 
<p><img src="https://images2.imgbox.com/8b/0d/7vhocKvw_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2__299"></a>(2). 记录型信号量</h5> 
<p><img src="https://images2.imgbox.com/77/9b/mJ9ZUItQ_o.png" alt="在这里插入图片描述"><br> <strong>举例1：</strong></p> 
<p>初始状态：<br> <img src="https://images2.imgbox.com/10/b8/DwIFmFLO_o.png" alt="在这里插入图片描述"><br> 一开始CPU为进程P0服务：<br> <img src="https://images2.imgbox.com/11/fc/jIln8xTN_o.png" alt="在这里插入图片描述"><br> 之后CPU切换到P1进程，为P1进程服务：<br> <img src="https://images2.imgbox.com/b2/96/hgMvDc7Z_o.png" alt="在这里插入图片描述"><br> 然后CPU再为P2进程服务，此时没有打印机资源了，P2进程执行了block原语，进入等待队列<br> <img src="https://images2.imgbox.com/30/53/QwxaZvTt_o.png" alt="在这里插入图片描述"><br> 接下来，CPU转向了P3进程，为P3进程服务，同样在执行wait原语的时候，发现没有资源，主动执行block原语，进入等待队列队尾<br> <img src="https://images2.imgbox.com/91/ba/bm8s23yd_o.png" alt="在这里插入图片描述"></p> 
<p>然后CPU又转向了P0，为P0进行服务，P0使用完打印机之后，执行signal原语，在signal原语里面又执行力wakeup原语，用来唤醒等待队列队头的进程<br> <img src="https://images2.imgbox.com/71/0a/kdC0wTMX_o.png" alt="在这里插入图片描述"><br> P0进程执行完之后，CPU又为P2进程进行服务，P2就可以使用打印机资源，同时进行signal原语，唤醒P3进程<br> <img src="https://images2.imgbox.com/63/e1/NYA1hhXd_o.png" alt="在这里插入图片描述"><br> 然后CPU又为P1进程服务，此时value加一之后大于0了，说明等待队列没有进程在等待了，所有就不需要执行wakeuo原语<br> <img src="https://images2.imgbox.com/23/db/2dydhZXx_o.png" alt="在这里插入图片描述"><br> 最后CPU转到P3进程，为之服务，P3顺利执行到结束，系统回收打印机资源<br> <img src="https://images2.imgbox.com/18/d1/d8UbKmeG_o.png" alt="在这里插入图片描述"><br> <strong>总结：</strong><br> <img src="https://images2.imgbox.com/d1/92/8KspTPgT_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3_AND_325"></a>(3). AND型信号量</h5> 
<h5><a id="4__326"></a>(4). 信号量集机制</h5> 
<h4><a id="3__328"></a>3. 如何使用信号量机制实现进程同步、互斥、前驱关系？</h4> 
<p><img src="https://images2.imgbox.com/48/9d/DjG6GteA_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1__331"></a>(1). 利用信号量实现进程互斥</h5> 
<p><img src="https://images2.imgbox.com/5b/3b/3R7TT8M2_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2__333"></a>(2). 利用信号量实现进程同步</h5> 
<p><img src="https://images2.imgbox.com/72/89/Jjwit4Yw_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/60/7e/ZT6VbhBR_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3__336"></a>(3). 利用信号量实现前驱关系</h5> 
<p><img src="https://images2.imgbox.com/72/95/Z89KcXHy_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5__338"></a>5. 经典进程同步、互斥问题</h3> 
<h4><a id="1__339"></a>(1). 生产者消费者问题</h4> 
<p><img src="https://images2.imgbox.com/5a/b9/TJsbRYjk_o.png" alt="在这里插入图片描述"><br> 当缓冲区当中有一个或者大于一个的空闲空间，此时就可以唤醒生产者进程，让他从阻塞态重新回到就绪队列<br> <img src="https://images2.imgbox.com/84/a2/2Rluo2jy_o.png" alt="在这里插入图片描述"><br> 当消费者进程取空了缓冲区之后，消费者进程就会被阻塞<br> <img src="https://images2.imgbox.com/fc/8a/jg4PeOsA_o.png" alt="在这里插入图片描述"><br> 然后到生产者进程重新向缓冲区放数据的时候，消费者才会被唤醒，重新回到就绪队列<br> <img src="https://images2.imgbox.com/0d/43/vCz2HRPn_o.png" alt="在这里插入图片描述"><br> 注：缓存区时临界资源，各进程必须互斥的访问<br> 因为：如果我们系统中出现了两个生产者进程，此时生成者进程发现缓存区每个地方都是空的，可以进行放数据，一个生产者在某一个地方放数据<br> <img src="https://images2.imgbox.com/cd/bf/cA2we0qW_o.png" alt="在这里插入图片描述"><br> 在并发的环境下，另一个生成者也在同样一个地方放数据，导致前者数据被后者数据覆盖的情况<br> <img src="https://images2.imgbox.com/11/b5/iYFjMNBf_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>如何用信号量机制(P、V操作)实现生产者、消费者进程的这些功能呢？</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/cb/41/vypGkkcH_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3c/2f/A1nRqy1d_o.png" alt="在这里插入图片描述"></p> 
<p>设置初始信号量<br> <img src="https://images2.imgbox.com/e6/cf/JMvZM9RE_o.png" alt="在这里插入图片描述"><br> 具体的代码实现<br> <img src="https://images2.imgbox.com/5e/63/PJliFABB_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a6/1b/gPOWekYu_o.png" alt="在这里插入图片描述"><br> 能否改变相邻P、V操作顺序呢？<br> <img src="https://images2.imgbox.com/0d/5b/ePQObHAU_o.png" alt="在这里插入图片描述"><br> 注：生产者生产一个产品和消费者消费一个产品操作能否放到互斥信号量P、V操作之内？<br> 逻辑上没有问题，从缓冲区取出一个产品，紧接着就使用产品<br> 但是这就导致了临界区代码量变大，消费者在访问临界区就需要耗费更长的时间，若此时也有别的进程想要访问临界区的话，它是会被阻塞的，使得进程之间的并发度降低。<br> 所以这两步代码不建议放到临界区之间</p> 
<p><img src="https://images2.imgbox.com/d2/4b/5U3B3612_o.png" alt="在这里插入图片描述"><br> 生产者消费者问题总结：</p> 
<p><img src="https://images2.imgbox.com/ab/4a/9lEtDmIZ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2__375"></a>(2). 多生产者-多消费者问题</h4> 
<p><img src="https://images2.imgbox.com/02/79/OfNigUiX_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/bf/3a/rgrLHeD6_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/01/89/ZFhADfTP_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/26/03/aiAWr7Li_o.png" alt="在这里插入图片描述"><br> 代码实现</p> 
<p><img src="https://images2.imgbox.com/c5/c6/3HMqnGfP_o.png" alt="在这里插入图片描述"><br> 可以不用互斥信号量吗？<br> <img src="https://images2.imgbox.com/48/ab/7BPcgJGK_o.png" alt="在这里插入图片描述"><br> 结论：即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象<br> 原因在于：本题的缓冲区大小为1，在任何时刻，Apple、orange、plate三个同步信号量中最多只有一个，因此在任何时候，最多只有一个进程的P操作，不会被阻塞，并顺利的进入临界区</p> 
<p><img src="https://images2.imgbox.com/79/7d/1GFEsNTS_o.png" alt="在这里插入图片描述"><br> 总结：<br> <img src="https://images2.imgbox.com/d9/53/hOYq5r3F_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8e/e6/dpAKxWFl_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3__392"></a>(3). 吸烟者问题</h4> 
<p><img src="https://images2.imgbox.com/eb/0f/bCMeMp67_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/da/82/yVdCt2Js_o.png" alt="在这里插入图片描述"><br> 设置信号量<br> <img src="https://images2.imgbox.com/f2/15/QpO0mUrl_o.png" alt="在这里插入图片描述"><br> 代码实现：<br> <img src="https://images2.imgbox.com/03/bf/UmWewI3N_o.png" alt="在这里插入图片描述"><br> 是否需要设置一个专门的互斥信号量？<br> 缓存区大小为1，同一时刻，四个同步信号量中至多有一个值为1，不用设置互斥信号量</p> 
<p>总结：<br> <img src="https://images2.imgbox.com/2c/7a/Z3uBhfQe_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4__405"></a>(4). 读者-写者问题</h4> 
<p><img src="https://images2.imgbox.com/a1/56/xoeSWIhZ_o.png" alt="在这里插入图片描述"><br> 如果两个写进程同时访问共享文件的话，两个写进程同时发现一块空闲空间，进而相继写入，会导致第二个写进程把第一个写进程数据覆盖了<br> <img src="https://images2.imgbox.com/4c/65/7GVddCqR_o.png" alt="在这里插入图片描述"><br> 问题分析<br> <img src="https://images2.imgbox.com/34/71/NHnsyxLz_o.png" alt="在这里插入图片描述"><br> 代码实现<br> <img src="https://images2.imgbox.com/dd/3e/nSdNwssA_o.png" alt="在这里插入图片描述"><br> 解决方法：<br> <img src="https://images2.imgbox.com/6c/c9/818MejHX_o.png" alt="在这里插入图片描述"><br> 此方法任然存在潜在问题：只要有读进程还在读，写进程就要一直阻塞等待，可能饿死，因此这种算法中，读进程是优先的</p> 
<p>解决方法：<br> <img src="https://images2.imgbox.com/c2/98/BbfAFlsg_o.png" alt="在这里插入图片描述"><br> 总结：<br> <img src="https://images2.imgbox.com/22/01/6dr8abfQ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="5__421"></a>(5). 哲学家进餐问题</h4> 
<p><img src="https://images2.imgbox.com/da/72/goENn04W_o.png" alt="在这里插入图片描述"><br> 方法一：<br> <img src="https://images2.imgbox.com/23/65/92tt9Rwr_o.png" alt="在这里插入图片描述"><br> 出现的问题：产生死锁<br> <img src="https://images2.imgbox.com/11/2c/Zf9EZeVJ_o.png" alt="在这里插入图片描述"><br> 如何防止死锁的发生呢？</p> 
<ol><li> <p>方案一：<br> <img src="https://images2.imgbox.com/ef/c0/1oI9QzoF_o.png" alt="在这里插入图片描述"></p> </li><li> <p>方案二：<br> <img src="https://images2.imgbox.com/49/98/725LEOSe_o.png" alt="在这里插入图片描述"></p> </li><li> <p>方案三：<br> <img src="https://images2.imgbox.com/19/50/2CbyUUe8_o.png" alt="在这里插入图片描述"></p> <p>代码实现</p> <p>情况1：0号哲学家，拿了左边的筷子，此时若进程切换为2号，但2号在进行mutex操作时，会被阻塞，直到0号哲学家拿到右边的筷子，并进行V（mutex）之后，2号才会被激活，执行下面代码，拿起左边和右边筷子<br> <img src="https://images2.imgbox.com/e8/6a/P03KfKYe_o.png" alt="在这里插入图片描述"></p> <p>情况2：一开始0号，拿起了左边和右边筷子正在吃饭，此时1号也想拿起筷子，没有被mutex阻塞，但是左边还没有筷子，会发生阻塞，此时调度为2号，但是2号会被mutex阻塞，即使2号两边都有筷子<br> <img src="https://images2.imgbox.com/50/ff/0OFMrk2o_o.png" alt="在这里插入图片描述"></p> <p>情况3：一开0号拿来左边和右边的筷子进行吃饭，当调度为4号，4号拿起了左边的筷子，但是右边没有筷子，发生阻塞<br> 因此这种方法并不能保证只有两边的筷子都可以使用时，才允许哲学家拿起筷子<br> <img src="https://images2.imgbox.com/14/00/AcEezZmp_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b1/d2/VJyPfpSn_o.png" alt="在这里插入图片描述"></p> </li></ol> 
<p>总结：<br> <img src="https://images2.imgbox.com/b8/dd/KfiNk12E_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5__450"></a>5. 管程</h3> 
<p><img src="https://images2.imgbox.com/a0/12/S6mCDA26_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1__452"></a>(1). 为什么要引入管程</h4> 
<blockquote> 
 <p>虽然信号量机制是一种既方便、又有效的进程同步机制，但每个要访问临界资源的进程都必须自备同步操作wait(S)、signal(S)。这就使得大量的同步操作分散在各个进程中，这不仅给系统的管理带来麻烦，还会因同步操作使用不当而导致系统死锁</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/b5/1d/Rpxdm43R_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2__457"></a>(2). 管程的定义和基本特征</h4> 
<blockquote> 
 <p>官方定义：代表共享资源的数据结构以及由对该共享资源结构实施操作的一组过程所组成的资源管理程序共同构成了一个操作系统的资源管理模块，称之为管程<br> Hansan为管程下定义：一个管程定义了一个数据结构和能为并发进程所执行的一组操作，这组操作能同步进程和改善管程中的数据结构</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/20/d3/0Zol8eHz_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3__465"></a>(3). 用管程解决生产者消费者问题</h4> 
<p><img src="https://images2.imgbox.com/66/d5/IwYFcwsi_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3f/13/Zx8XKF95_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4_Java__468"></a>(4). Java 中类似于管程的机制</h4> 
<p><img src="https://images2.imgbox.com/7f/15/XS820vJo_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="5__470"></a>(5). 总结</h4> 
<p><img src="https://images2.imgbox.com/e9/f7/XTd4Cqvd_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="6__472"></a>6. 死锁</h3> 
<p><img src="https://images2.imgbox.com/81/f3/yTUGbkhk_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1_Deadlock_475"></a>(1). 什么是死锁（Deadlock）</h4> 
<blockquote> 
 <p>如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/d1/71/rpeAri9p_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2__480"></a>(2). 死锁、饥饿、死循环的区别</h4> 
<p><img src="https://images2.imgbox.com/32/4a/e6f64UpJ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3__482"></a>(3). 死锁产生的必要条件</h4> 
<p><img src="https://images2.imgbox.com/a4/0e/cRF62922_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4__484"></a>(4). 什么时候会发生死锁</h4> 
<p><img src="https://images2.imgbox.com/64/0d/1NrRZvZF_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="5__486"></a>(5). 死锁的处理策略</h4> 
<p><img src="https://images2.imgbox.com/fc/f4/bkEV2MSg_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/98/b1/1sEvXBbP_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1__490"></a>1. 预防死锁</h5> 
<p><img src="https://images2.imgbox.com/68/b5/cHsoIffh_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/d0/53/i7Ip0ZON_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6d/1e/PujMhneN_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6d/a5/trZYT0HH_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ac/50/H9DSXCp3_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2__498"></a>2. 避免死锁</h5> 
<p><img src="https://images2.imgbox.com/b4/a3/q2pcyYES_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/62/e3/W8a6xvun_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/56/19/akQi4Jc6_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/39/e9/hpsoAzHS_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4d/80/kcMAYlDg_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6b/2a/dSv0Egpx_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f7/15/5vuJOmQZ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/5f/65/7HxB9zTR_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/07/2f/icSAiQ5T_o.png" alt="在这里插入图片描述"><br> 找不到安全序列的例子<br> <img src="https://images2.imgbox.com/3b/b2/JiwyLtno_o.png" alt="在这里插入图片描述"><br> 用代码实现银行家算法<br> <img src="https://images2.imgbox.com/7e/8d/pW1m2v49_o.png" alt="在这里插入图片描述"><br> 银行家算法步骤<br> <img src="https://images2.imgbox.com/d1/69/Kl9JXK5m_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3__515"></a>3. 死锁的检测和解除</h5> 
<p><img src="https://images2.imgbox.com/32/d9/HTIf04Tf_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/20/3f/wMFfi72K_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a4/9b/5MjsIGOQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/60/1b/tPWl9Xbw_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8e/73/xHcuZgsg_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/cc/32/uqfpqxyo_o.png" alt="在这里插入图片描述"><br> 总结：<br> <img src="https://images2.imgbox.com/49/cb/hnXEkOmg_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/586d67d093708aae98efb97f6c195b13/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python程序日志_如何在python应用程序中实现日志记录</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7ca75c27242d03de55a75b2b8d96ff53/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">怎样区分充分性、必要性？如何辨别条件？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>