<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker 命令（新手上路） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker 命令（新手上路）" />
<meta property="og:description" content="查看命令 命令解释docker ps查看正在运行的容器docker ps -a查看所有已经创建的容器docker images列出镜像列表docker container ls效果同ps命令(加-a效果同) docker ps 详细参数 -a :显示所有的容器，包括未运行的。 ​ -f :根据条件过滤显示的内容。 ​ --format :指定返回值的模板文件。 ​ -l :显示最近创建的容器。 ​ -n :列出最近创建的n个容器。 ​ --no-trunc :不截断输出。 ​ -q :静默模式，只显示容器编号。 ​ -s :显示总的文件大小。 docker images 详细参数 -a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）； ​ --digests :显示镜像的摘要信息； ​ -f :显示满足条件的镜像； ​ --format :指定返回值的模板文件； ​ --no-trunc :显示完整的镜像信息； ​ -q :只显示镜像ID。 删除命令 命令解释docker rm删除容器docker rmi删除镜像 docker rm 详细参数 -f :强制删除一个运行中的容器 ​ -l :移除容器间的网络连接，而非容器本身 ​ -v :-v 删除与容器关联的卷 docker rmi 详细参数 -f :强制删除； ​ --no-prune :不移除该镜像的过程镜像，默认移除 宿-主操作 命令解释docker cp容器与主机之间的数据拷贝 docker cp 实例 docker cp nginx:/www /tmp/ #将nginx容器的/www 拷贝到本地/tmp下 生命周期 命令解释docker start启动容器docker stop停止容器docker restart重启容器docker exec在运行的容器中执行命令docker run创建一个新的容器并运行一个命令 docker exec 详细参数 -d :分离模式: 在后台运行 ​ -i :即使没有附加也保持STDIN 打开 ​ -t :分配一个伪终端 ​ #实例 docker exec -it nginx /bin/bash docker run 详细参数 -i, --interactive=false 打开STDIN，用于控制台交互 -t, --tty=false 分配tty设备，该可以支持终端登录，默认为false -d, --detach=false 指定容器运行于前台还是后台，默认为false -u, --user=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f846baa88dd7ed1e418c78fc69e652b1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-25T10:29:05+08:00" />
<meta property="article:modified_time" content="2023-07-25T10:29:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker 命令（新手上路）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>查看命令</h2> 
<table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>docker ps</td><td>查看正在运行的容器</td></tr><tr><td>docker ps -a</td><td>查看所有已经创建的容器</td></tr><tr><td>docker images</td><td>列出镜像列表</td></tr><tr><td>docker container ls</td><td>效果同ps命令(加-a效果同)</td></tr></tbody></table> 
<h4>docker ps 详细参数</h4> 
<pre>-a :显示所有的容器，包括未运行的。
​
-f :根据条件过滤显示的内容。
​
--format :指定返回值的模板文件。
​
-l :显示最近创建的容器。
​
-n :列出最近创建的n个容器。
​
--no-trunc :不截断输出。
​
-q :静默模式，只显示容器编号。
​
-s :显示总的文件大小。</pre> 
<h4>docker images 详细参数</h4> 
<pre>-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；
​
--digests :显示镜像的摘要信息；
​
-f :显示满足条件的镜像；
​
--format :指定返回值的模板文件；
​
--no-trunc :显示完整的镜像信息；
​
-q :只显示镜像ID。</pre> 
<h3>删除命令</h3> 
<table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>docker rm</td><td>删除容器</td></tr><tr><td>docker rmi</td><td>删除镜像</td></tr></tbody></table> 
<h4>docker rm 详细参数</h4> 
<pre>-f :强制删除一个运行中的容器
​
-l :移除容器间的网络连接，而非容器本身
​
-v :-v 删除与容器关联的卷</pre> 
<h4>docker rmi 详细参数</h4> 
<pre>-f :强制删除；
​
--no-prune :不移除该镜像的过程镜像，默认移除</pre> 
<h3>宿-主操作</h3> 
<table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>docker cp</td><td>容器与主机之间的数据拷贝</td></tr></tbody></table> 
<h4>docker cp 实例</h4> 
<pre>docker cp  nginx:/www /tmp/    #将nginx容器的/www 拷贝到本地/tmp下</pre> 
<p></p> 
<h3>生命周期</h3> 
<table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>docker start</td><td>启动容器</td></tr><tr><td>docker stop</td><td>停止容器</td></tr><tr><td>docker restart</td><td>重启容器</td></tr><tr><td>docker exec</td><td>在运行的容器中执行命令</td></tr><tr><td>docker run</td><td>创建一个新的容器并运行一个命令</td></tr></tbody></table> 
<h4>docker exec 详细参数</h4> 
<pre>-d :分离模式: 在后台运行
​
-i :即使没有附加也保持STDIN 打开
​
-t :分配一个伪终端
​
#实例
docker exec -it nginx /bin/bash</pre> 
<h4>docker run 详细参数</h4> 
<pre>-i, --interactive=false   打开STDIN，用于控制台交互
-t, --tty=false            分配tty设备，该可以支持终端登录，默认为false
-d, --detach=false         指定容器运行于前台还是后台，默认为false
-u, --user=""              指定容器的用户
-a, --attach=[]            登录容器（必须是以docker run -d启动的容器）
-w, --workdir=""           指定容器的工作目录
-c, --cpu-shares=0        设置容器CPU权重，在CPU共享场景使用
-e, --env=[]               指定环境变量，容器中可以使用该环境变量
-m, --memory=""            指定容器的内存上限
-P, --publish-all=false    指定容器暴露的端口
-p, --publish=[]           指定容器暴露的端口
-h, --hostname=""          指定容器的主机名
-v, --volume=[]            给容器挂载存储卷，挂载到容器的某个目录    顺序：主机：容器
--volumes-from=[]          给容器挂载其他容器上的卷，挂载到容器的某个目录
--cap-add=[]               添加权限，权限清单详见：http://linux.die.net/man/7/capabilities
--cap-drop=[]              删除权限，权限清单详见：http://linux.die.net/man/7/capabilities
--cidfile=""               运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法
--cpuset=""                设置容器可以使用哪些CPU，此参数可以用来容器独占CPU
--device=[]                添加主机设备给容器，相当于设备直通
--dns=[]                   指定容器的dns服务器
--dns-search=[]            指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件
--entrypoint=""            覆盖image的入口点
--env-file=[]              指定环境变量文件，文件格式为每行一个环境变量
--expose=[]                指定容器暴露的端口，即修改镜像的暴露端口
--link=[]                  指定容器间的关联，使用其他容器的IP、env等信息
--lxc-conf=[]              指定容器的配置文件，只有在指定--exec-driver=lxc时使用
--name=""                  指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字
--net="bridge"             容器网络设置:
                            bridge 使用docker daemon指定的网桥
                            host    //容器使用主机的网络
                            container:NAME_or_ID  &gt;//使用其他容器的网路，共享IP和PORT等网络资源
                            none 容器使用自己的网络（类似--net=bridge），但是不进行配置
--privileged=false         指定容器是否为特权容器，特权容器拥有所有的capabilities
--restart="no"             指定容器停止后的重启策略:
                            no：容器退出时不重启
                            on-failure：容器故障退出（返回值非零）时重启
                            always：容器退出时总是重启
--rm=false                 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)
--sig-proxy=true           设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理</pre> 
<h3>镜像仓库</h3> 
<table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>docker pull</td><td>拉取镜像</td></tr><tr><td>docker search</td><td>从Docker Hub查找镜像</td></tr></tbody></table> 
<h3>docker环境信息</h3> 
<table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>docker info</td><td>查看docker系统信息</td></tr><tr><td>docker version</td><td>显示 Docker 版本信息</td></tr></tbody></table>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/66f6fefbf3425436a52b82803a3bec1f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android开发：通过Tesseract第三方库实现OCR</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/05968846f13a66a33b2e5805f4ce19d1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Cilium系列-4-Cilium本地路由</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>