<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JVM相关面试题 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JVM相关面试题" />
<meta property="og:description" content="文章目录 说一下 JVM 的主要组成部分及其作用？说一下 JVM 运行时数据区 ？JVM中哪些是线程共享区 ？说一下堆栈的区别？队列和栈是什么？有什么区别？说一下类装载的执行过程？什么是类加载器 ? Java中有哪些类加载器?描述一下JVM加载Class文件的原理机制 ？JVM 的双亲委派机制？怎么确定⼀个对象到底是不是垃圾？什么是STW ？JVM中的永久代中会发生垃圾回收吗 ？Java会存在内存泄漏吗？请简单描述 ？Finalize 遗言对程序的弊端 ？说一下 JVM 有哪些垃圾回收算法 ？说一下 JVM 有哪些垃圾回收器 ？详细介绍一下 CMS 垃圾回收器 ？新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别 ？简述分代垃圾回收器是怎么工作的 ？⼀个对象从加载到JVM，再到被GC清除，都经历了什么过程 ？简述Java内存分配与回收策率以及Minor GC和Major GC ？JVM参数有哪些 ？常用的 JVM 调优的参数都有哪些 ？常用的 JVM 调优的参数都有哪些？你们项目如何排查 JVM 问题？说一下 JVM 调优的工具？ 说一下 JVM 的主要组成部分及其作用？ JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。
Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到
Runtime data area中的method area。
Execution engine（执行引擎）：执行classes中的指令。
Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。
Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。
说一下 JVM 运行时数据区 ？ 程序计数器：当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址，线程私有。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8c8326079754639828f94cb00dcd736c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-26T09:27:47+08:00" />
<meta property="article:modified_time" content="2023-04-26T09:27:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JVM相关面试题</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_JVM__2" rel="nofollow">说一下 JVM 的主要组成部分及其作用？</a></li><li><a href="#_JVM___15" rel="nofollow">说一下 JVM 运行时数据区 ？</a></li><li><a href="#JVM__30" rel="nofollow">JVM中哪些是线程共享区 ？</a></li><li><a href="#_36" rel="nofollow">说一下堆栈的区别？</a></li><li><a href="#_47" rel="nofollow">队列和栈是什么？有什么区别？</a></li><li><a href="#_58" rel="nofollow">说一下类装载的执行过程？</a></li><li><a href="#__Java_67" rel="nofollow">什么是类加载器 ? Java中有哪些类加载器?</a></li><li><a href="#JVMClass__73" rel="nofollow">描述一下JVM加载Class文件的原理机制 ？</a></li><li><a href="#JVM__83" rel="nofollow">JVM 的双亲委派机制？</a></li><li><a href="#_104" rel="nofollow">怎么确定⼀个对象到底是不是垃圾？</a></li><li><a href="#STW__113" rel="nofollow">什么是STW ？</a></li><li><a href="#JVM__117" rel="nofollow">JVM中的永久代中会发生垃圾回收吗 ？</a></li><li><a href="#Java__122" rel="nofollow">Java会存在内存泄漏吗？请简单描述 ？</a></li><li><a href="#Finalize___128" rel="nofollow">Finalize 遗言对程序的弊端 ？</a></li><li><a href="#_JVM___132" rel="nofollow">说一下 JVM 有哪些垃圾回收算法 ？</a></li><li><a href="#_JVM___180" rel="nofollow">说一下 JVM 有哪些垃圾回收器 ？</a></li><li><a href="#_CMS___206" rel="nofollow">详细介绍一下 CMS 垃圾回收器 ？</a></li><li><a href="#__215" rel="nofollow">新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别 ？</a></li><li><a href="#__223" rel="nofollow">简述分代垃圾回收器是怎么工作的 ？</a></li><li><a href="#JVMGC__238" rel="nofollow">⼀个对象从加载到JVM，再到被GC清除，都经历了什么过程 ？</a></li><li><a href="#JavaMinor_GCMajor_GC__247" rel="nofollow">简述Java内存分配与回收策率以及Minor GC和Major GC ？</a></li><li><a href="#JVM__283" rel="nofollow">JVM参数有哪些 ？</a></li><li><a href="#_JVM___289" rel="nofollow">常用的 JVM 调优的参数都有哪些 ？</a></li><li><a href="#_JVM__304" rel="nofollow">常用的 JVM 调优的参数都有哪些？</a></li><li><a href="#_JVM__314" rel="nofollow">你们项目如何排查 JVM 问题？</a></li><li><a href="#_JVM__336" rel="nofollow">说一下 JVM 调优的工具？</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_JVM__2"></a>说一下 JVM 的主要组成部分及其作用？</h3> 
<p><img src="https://images2.imgbox.com/ca/6d/lCpOUGiB_o.png" alt="在这里插入图片描述"></p> 
<p>JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。<br> Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到<br> Runtime data area中的method area。<br> Execution engine（执行引擎）：执行classes中的指令。<br> Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。<br> Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</p> 
<h3><a id="_JVM___15"></a>说一下 JVM 运行时数据区 ？</h3> 
<p><img src="https://images2.imgbox.com/b1/87/5sNrbozR_o.png" alt="在这里插入图片描述"><br> 程序计数器：当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址，线程私有。</p> 
<p>Java虚拟栈：存放基本数据类型、对象的引用、方法出口等，线程私有。</p> 
<p>Native方法栈：和虚拟栈相似，只不过它服务于Native方法，线程私有。</p> 
<p>Java堆：java内存最大的一块，所有对象实例、数组都存放在java堆，GC回收的地方，线程共享。</p> 
<p>方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。（即永久带），回收目标主要是常量池的回收和类型的卸载，各线程共享</p> 
<h3><a id="JVM__30"></a>JVM中哪些是线程共享区 ？</h3> 
<p>堆区和⽅法区是所有线程共享的，栈、本地⽅法栈、程序计数器是每个线程独有的</p> 
<p><img src="https://images2.imgbox.com/2d/53/M4MvGyvi_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_36"></a>说一下堆栈的区别？</h3> 
<p>物理地址<br> 堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有<br> 各种算法。比如，标记-消除，复制，标记-压缩，分代。<br> 栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。<br> 内存分配<br> 堆因为是不连续的，所以分配的内存是在 运行期 确认的，因此大小不固定。一般堆大小远远大于栈。<br> 栈是连续的，所以分配的内存大小要在 编译期 就确认，大小是固定的。<br> 存放的内容<br> 堆存放的是对象的实例和数组。因此该区更关注的是数据的存储<br> 栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。</p> 
<h3><a id="_47"></a>队列和栈是什么？有什么区别？</h3> 
<p>队列和栈都是被用来预存储数据的。<br> 操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为<br> 出栈。<br> 可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈<br> 顶进行的，无法对栈底直接进行操作。<br> 操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的<br> 成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈<br> 为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元<br> 素，而最先插入的被放在栈的底部，要到最后才能删除。</p> 
<h3><a id="_58"></a>说一下类装载的执行过程？</h3> 
<p>类装载分为以下 5 个步骤：<br> 加载：根据全限定类名找到相应的 class 文件然后导入；<br> 验证：检查加载的 class 文件的正确性；<br> 准备：给类中的静态变量分配内存空间；<br> 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直<br> 接引用直接指向内存中的地址；<br> 初始化：对静态变量和静态代码块执行初始化工作。</p> 
<h3><a id="__Java_67"></a>什么是类加载器 ? Java中有哪些类加载器?</h3> 
<p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。<br> JDK⾃带有三个类加载器：bootstrap ClassLoader、ExtClassLoader、AppClassLoader。<br> BootStrapClassLoader是ExtClassLoader的⽗类加载器，默认负责加载%JAVA_HOME%lib下的jar包和class⽂件。<br> ExtClassLoader是AppClassLoader的⽗类加载器，负责加载%JAVA_HOME%/lib/ext⽂件夹下的jar包和class类。<br> AppClassLoader是⾃定义类加载器的⽗类，负责加载classpath下的类⽂件。</p> 
<h3><a id="JVMClass__73"></a>描述一下JVM加载Class文件的原理机制 ？</h3> 
<p>Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就<br> 是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐<br> 式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。<br> 类装载方式，有两种 ：<br> 1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到<br> jvm中，<br> 2.显式装载， 通过class.forname()等方法，显式加载需要的类<br> Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是<br> 基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p> 
<h3><a id="JVM__83"></a>JVM 的双亲委派机制？</h3> 
<p>JVM 中存在三个默认的类加载器<br> BootStrapClassLoader<br> ExtClassLoader<br> AppClassLoader<br> AppClassLoader 的父类加载器是 ExtClassLoader,ExtClaasLoader 的父类加载是BootStrapClassLoader<br> <img src="https://images2.imgbox.com/22/4b/ml0nSeBI_o.png" alt="在这里插入图片描述"></p> 
<p>JVM 在加载一个类时,会调用 AppClassLoader 的 loadClass 方法来加载这个类，<br> 不过在这个方法中会先使用 ExtClassLoader 的 loadClass 方法来加载类,同样<br> ExtClassLoader 的 LoadClass 方法中会先使用 BootStrapClassLoader 来加载类<br> 如果 BootStrapClass 加载到就成功了,如果没有加载到，那么 ExtClassLoader<br> 就会自己尝试加载类，如果没有加载到，那么则会由 AppClassLoader 来加载类。<br> 所以，双亲委派机制指的是，JVM 在加载类时会委派给 Ext 和 BootStrap 进行加载<br> 如果没有加载得到，才由自己加载。</p> 
<h3><a id="_104"></a>怎么确定⼀个对象到底是不是垃圾？</h3> 
<ol><li>引⽤计数算法： 这种⽅式是给堆内存当中的每个对象记录⼀个引⽤个数。引⽤个数为0的就认为是<br> 垃圾。这是早期JDK中使⽤的⽅式。引⽤计数⽆法解决循环引⽤的问题。</li><li>可达性算法： 这种⽅式是在内存中，从根对象向下⼀直找引⽤，找到的对象就不是垃圾，没找到的<br> 对象就是垃圾。</li></ol> 
<h3><a id="STW__113"></a>什么是STW ？</h3> 
<p>STW: Stop-The-World，是在垃圾回收算法执⾏过程当中，需要将JVM内存冻结的⼀种状态。在STW<br> 状态下，JAVA的所有线程都是停⽌执⾏的-GC线程除外，native⽅法可以执⾏，但是，不能与JVM交<br> 互。GC各种算法优化的重点，就是减少STW，同时这也是JVM调优的重点。</p> 
<h3><a id="JVM__117"></a>JVM中的永久代中会发生垃圾回收吗 ？</h3> 
<p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如<br> 果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小<br> 对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区<br> (译者注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)</p> 
<h3><a id="Java__122"></a>Java会存在内存泄漏吗？请简单描述 ？</h3> 
<p>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制<br> 的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。<br> 但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的<br> 对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为<br> 长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。</p> 
<h3><a id="Finalize___128"></a>Finalize 遗言对程序的弊端 ？</h3> 
<p>最重要的是 Finalize 遗言方法无法保证 finalize（）一定能够正常执行<br> 也无法保证在执行结束之后才回收对象<br> 所以依赖 finalize（）完成核心内容是不现实的</p> 
<h3><a id="_JVM___132"></a>说一下 JVM 有哪些垃圾回收算法 ？</h3> 
<blockquote> 
 <p><strong>标记-清除算法：</strong> 标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。<br> <strong>标记-整理算法：</strong> 标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的 内存。<br> <strong>复制算法：</strong> 按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。<br> <strong>分代算法：</strong> 根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用 复制算法，老年代采用标记整理算法。</p> 
</blockquote> 
<p><strong>标记-清除算法</strong><br> 标记无用对象，然后进行清除回收。<br> 标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：<br> 标记阶段：标记出可以回收的对象。<br> 清除阶段：回收被标记的对象所占用的空间。<br> 标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法的基础上进行改进的。<br> 优点：实现简单，不需要对象进行移动。<br> 缺点：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。<br> 标记-清除算法的执行的过程如下图所示<br> <img src="https://images2.imgbox.com/ec/5a/xqTgKxkH_o.png" alt="在这里插入图片描述"></p> 
<p><strong>复制算法</strong><br> 为了解决标记-清除算法的效率不高的问题，产生了复制算法。它把内存空间划为两个相等的区域，每<br> 次只使用其中一个区域。垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后<br> 将当前使用的区域的可回收的对象进行回收。<br> 优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。<br> 缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。<br> 复制算法的执行过程如下图所示<br> <img src="https://images2.imgbox.com/32/c8/n1mMm80y_o.png" alt="在这里插入图片描述"></p> 
<p><strong>标记-整理算法</strong></p> 
<p>在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年代的对象存活率会较<br> 高，这样会有较多的复制操作，导致效率变低。标记-清除算法可以应用在老年代中，但是它效率不<br> 高，在内存回收后容易产生大量内存碎片。因此就出现了一种标记-整理算法（Mark-Compact）算法，<br> 与标记-整理算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑<br> 的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边。<br> 优点：解决了标记-清理算法存在的内存碎片问题。<br> 缺点：仍需要进行局部对象移动，一定程度上降低了效率。<br> 标记-整理算法的执行过程如下图所示</p> 
<p>在这里插入图片描述</p> 
<p><strong>分代收集算法</strong></p> 
<p>当前商业虚拟机都采用分代收集的垃圾收集算法。分代收集算法，顾名思义是根据对象的存活周期将内<br> 存划分为几块。一般包括年轻代、老年代 和 永久代，如图所示：<br> <img src="https://images2.imgbox.com/09/84/E4SZj1VZ_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_JVM___180"></a>说一下 JVM 有哪些垃圾回收器 ？</h3> 
<p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7种<br> 作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回<br> 收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收<br> 集器之间的连线表示它们可以搭配使用。</p> 
<p><img src="https://images2.imgbox.com/89/88/ilSUgoaI_o.png" alt="在这里插入图片描述"></p> 
<p>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；<br> ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU<br> 环境下有着比Serial更好的表现；<br> Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量<br> = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程<br> 序的运算任务，适合后台应用等对交互相应要求不高的场景；<br> Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；<br> Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器<br> 的老年代版本；<br> CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收<br> 停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。<br> G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新<br> 收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同<br> 于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种<br> 收集器回收的范围仅限于新生代或老年代。</p> 
<h3><a id="_CMS___206"></a>详细介绍一下 CMS 垃圾回收器 ？</h3> 
<p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾<br> 回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-<br> XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。<br> CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足<br> 程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行<br> 垃圾清除，此时的性能将会被降低。</p> 
<h3><a id="__215"></a>新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别 ？</h3> 
<p>新生代回收器：Serial、ParNew、Parallel Scavenge<br> 老年代回收器：Serial Old、Parallel Old、CMS<br> 整堆回收器：G1<br> 新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回<br> 收器一般采用的是标记-整理的算法进行垃圾回收。</p> 
<h3><a id="__223"></a>简述分代垃圾回收器是怎么工作的 ？</h3> 
<p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是<br> 2/3。<br> 新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占<br> 比是 8:1:1，它的执行流程如下：<br> 把 Eden + From Survivor 存活的对象放入 To Survivor 区；<br> 清空 Eden 和 From Survivor 分区；<br> From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From<br> Survivor。<br> 每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是<br> 15）时，升级为老生代。大对象也会直接进入老生代。<br> 老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循<br> 环往复就构成了整个分代垃圾回收的整体执行流程。</p> 
<h3><a id="JVMGC__238"></a>⼀个对象从加载到JVM，再到被GC清除，都经历了什么过程 ？</h3> 
<ol><li>⾸先把字节码⽂件内容加载到⽅法区</li><li>然后再根据类信息在堆区创建对象</li><li>对象⾸先会分配在堆区中年轻代的Eden区，经过⼀次Minor GC后，对象如果存活，就会进⼊<br> Suvivor 区。在后续的每次Minor GC中，如果对象⼀直存活，就会在 Suvivor 区来回拷⻉，每移动<br> ⼀次，年龄加1</li><li>当年龄超过15后，对象依然存活，对象就会进⼊⽼年代</li><li>如果经过Full GC，被标记为垃圾对象，那么就会被GC线程清理掉</li></ol> 
<h3><a id="JavaMinor_GCMajor_GC__247"></a>简述Java内存分配与回收策率以及Minor GC和Major GC ？</h3> 
<p>所谓自动内存管理，最终要解决的也就是内存分配和内存回收两个问题。前面我们介绍了内存回收，这<br> 里我们再来聊聊内存分配。<br> 对象的内存分配通常是在 Java 堆上分配（随着虚拟机优化技术的诞生，某些场景下也会在栈上分配，<br> 后面会详细介绍），对象主要分配在新生代的 Eden 区，如果启动了本地线程缓冲，将按照线程优先在<br> TLAB 上分配。少数情况下也会直接在老年代上分配。总的来说分配规则不是百分百固定的，其细节取<br> 决于哪一种垃圾收集器组合以及虚拟机相关参数有关，但是虚拟机对于内存的分配还是会遵循以下几种<br> 「普世」规则：</p> 
<p><strong>对象优先在 Eden 区分配</strong></p> 
<p>多数情况，对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发<br> 起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内<br> 存。<br> 这里我们提到 Minor GC，如果你仔细观察过 GC 日常，通常我们还能从日志中发现 Major GC/Full<br> GC。<br> Minor GC 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所有 Minor GC 非常频<br> 繁，一般回收速度也非常快；<br> Major GC/Full GC 是指发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。<br> Major GC 的速度通常会比 Minor GC 慢 10 倍以上。</p> 
<p><strong>大对象直接进入老年代</strong></p> 
<p>所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间<br> 的情况下提前触发 GC 以获取足够的连续空间来安置新对象。<br> 前面我们介绍过新生代使用的是标记-清除算法来处理垃圾回收的，如果大对象直接在新生代分配就会<br> 导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分<br> 配。</p> 
<p><strong>长期存活对象将进入老年代</strong></p> 
<p>虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对<br> 象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，<br> 并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区<br> 中每「熬过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代。</p> 
<h3><a id="JVM__283"></a>JVM参数有哪些 ？</h3> 
<p>JVM参数⼤致可以分为三类：</p> 
<ol><li>标注指令： -开头，这些是所有的HotSpot都⽀持的参数。可以⽤java -help 打印出来。</li><li>⾮标准指令： -X开头，这些指令通常是跟特定的HotSpot版本对应的。可以⽤java -X 打印出来。</li><li>不稳定参数： -XX 开头，这⼀类参数是跟特定HotSpot版本对应的，并且变化⾮常⼤。</li></ol> 
<h3><a id="_JVM___289"></a>常用的 JVM 调优的参数都有哪些 ？</h3> 
<p>-Xms2g：初始化推大小为 2g；<br> -Xmx2g：堆最大内存为 2g；<br> -XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；<br> -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；<br> –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br> -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br> -XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br> -XX:+PrintGC：开启打印 gc 信息；<br> -XX:+PrintGCDetails：打印 gc 详细信息。<br> 进行监控；<br> jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的<br> 变化、gc 变化等。</p> 
<h3><a id="_JVM__304"></a>常用的 JVM 调优的参数都有哪些？</h3> 
<p>-Xms2g：初始化推大小为 2g；<br> -Xmx2g：堆最大内存为 2g；<br> -XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；<br> -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；<br> –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br> -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br> -XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br> -XX:+PrintGC：开启打印 gc 信息；<br> -XX:+PrintGCDetails：打印 gc 详细信息。</p> 
<h3><a id="_JVM__314"></a>你们项目如何排查 JVM 问题？</h3> 
<p>对于还在正常运行的系统</p> 
<ol><li>可以使用 jmap 来查看 jvm 各个区域的使用情况</li><li>可以使用 jstack 来查看线程的运行情况，比如哪些线程阻塞，是否发生死锁</li><li>可以通过 jstat 命令来查看垃圾回收的情况，特别是 fullgc，如果发现 fullgc 比较繁琐<br> 那么就要进行调优了。</li><li>通过各个命令的结果，或者 jvisualvm 等工具来进行分析。</li><li>首先,初步猜测频繁发送 fullgc 的原因，如果频繁发生 fullgc 但是又一直没有内存溢出，<br> 那么表示 fullgc 实际上是回收了很多对象了,所以这些对象最好能在 younggc 的过程就直接<br> 回收掉,避免这些对象进入老年代,对于这种情况，就要考虑这些存活时间不长的对象是不是<br> 比较大，导致年轻代放不下，直接进入老年代，尝试加大年轻代的大小，如果改完之后 fullgc<br> 减小，则证明修改有效。</li><li>同时，还可以找到占用 cpu 最多的线程，定位到具体的方法，优化这个方法的执行。<br> 看是否能避免某些对象的创建。<br> 对于已经发生 OOM 的系统<br> 一般生产系统中都会设置当系统发生 OOM 时，生成当时的 dump 文件</li><li>我们可以利用 jsisualvm 等工具来分析 dump 文件。</li><li>根据 dump 文件找到异常的实例对象，和异常的线程（占用 cpu 高）定位到具体的代码。<br> 然后再进行详细的分析和调试。<br> 总之，调优不是一蹴而就的，需要分析、推理、实践、总结、再分析最后定位到具体的问题。</li></ol> 
<h3><a id="_JVM__336"></a>说一下 JVM 调优的工具？</h3> 
<p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视<br> 图监控工具。<br> jconsole：用于对 JVM 中的内存、线程和类等进行监控；<br> jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的<br> 变化、gc 变化等。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c96e14ef8b8492aebafc90f60ec7dd2e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL相关面试题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/952a0232114777aab7211ff8a1f80d51/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring相关面试题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>