<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;大一基础知识 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;大一基础知识" />
<meta property="og:description" content="目录
一、程序控制
①输入输出
Ⅰ.cin&amp;cout
Ⅱ.scanf&amp;printf
②运算与符号
Ⅰ常用数学函数#include
Ⅱ.数据类型转换
③控制结构
④函数
Ⅰ.函数定义
Ⅱ函数使用
二、数据结构
①一维数组
排序与查找
②多维数组
③指针
Ⅰ字符，指针运算
Ⅱ字符串函数#include
Ⅲ指针参数与动态内存
④结构:struct
⑤链表
三、文件操作
Ⅰ基本文件输入输出
Ⅱ文件指针
四、类和对象
①类的创建和使用
②静态成员
③构造函数
④类的复合
⑤This指针
⑥友元
Ⅰ友元函数
Ⅱ友元类
五、运算符重载
①原理
②方式
Ⅰ成员函数重载
Ⅱ友元函数重载
③单目与双目运算符重载
Ⅰ单目（目表示操作数）
Ⅱ流插入和流提取运算符的重载
Ⅲ双目
Ⅳ类型转化
六、继承派生多态
①继承
Ⅰ成员函数的重定义
Ⅱ类指针
②多态
Ⅰ虚函数
Ⅱ抽象基类与纯虚函数
Ⅲ虚析构函数
③STL
Ⅰ动态学生信息管理https://www.educoder.net/tasks/p4imnbvy/887783/ok8rac4vzhbx?coursesId=p4imnbvy
Ⅱ还原键盘输入https://www.educoder.net/tasks/p4imnbvy/887783/yf2swgkio7ma?coursesId=p4imnbvy
一、程序控制 ①输入输出 Ⅰ.cin&amp;cout 流操作算子 #include&lt;iomanip&gt;
setbase(n),进制，n=8,10,16
setprecision(n)，浮点数精度设置为n
setw(n),域宽n，小于n空位填充，大于n输出所有
setiosflags(long),long,流格式状态标志
#include &lt;iostream&gt; #include&lt;iomanip&gt; #include&lt;string&gt; using namespace std; int main() { //setbase(n),进制，n=8,10,16 int a = 1000; cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/69dccb52e16d2ae868027105bda5e929/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-03T16:01:20+08:00" />
<meta property="article:modified_time" content="2023-07-03T16:01:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;大一基础知识</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6" rel="nofollow">一、程序控制</a></p> 
<p id="%E2%91%A0%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-toc" style="margin-left:40px;"><a href="#%E2%91%A0%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA" rel="nofollow">①输入输出</a></p> 
<p id="%E2%85%A0.cin%26cout-toc" style="margin-left:80px;"><a href="#%E2%85%A0.cin%26cout" rel="nofollow">Ⅰ.cin&amp;cout</a></p> 
<p id="%E2%85%A1.scanf%26printf-toc" style="margin-left:80px;"><a href="#%E2%85%A1.scanf%26printf" rel="nofollow">Ⅱ.scanf&amp;printf</a></p> 
<p id="%E2%91%A1%E8%BF%90%E7%AE%97%E4%B8%8E%E7%AC%A6%E5%8F%B7-toc" style="margin-left:40px;"><a href="#%E2%91%A1%E8%BF%90%E7%AE%97%E4%B8%8E%E7%AC%A6%E5%8F%B7" rel="nofollow">②运算与符号</a></p> 
<p id="%E2%85%A0%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0%23include%3Cmath.h%3E-toc" style="margin-left:80px;"><a href="#%E2%85%A0%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0%23include%3Cmath.h%3E" rel="nofollow">Ⅰ常用数学函数#include</a></p> 
<p id="%E2%85%A1.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-toc" style="margin-left:80px;"><a href="#%E2%85%A1.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" rel="nofollow">Ⅱ.数据类型转换</a></p> 
<p id="%E2%91%A2%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#%E2%91%A2%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84" rel="nofollow">③控制结构</a></p> 
<p id="%E2%91%A3%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E2%91%A3%E5%87%BD%E6%95%B0" rel="nofollow">④函数</a></p> 
<p id="%E2%85%A0.%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#%E2%85%A0.%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89" rel="nofollow">Ⅰ.函数定义</a></p> 
<p id="%E2%85%A1%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#%E2%85%A1%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8" rel="nofollow">Ⅱ函数使用</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">二、数据结构</a></p> 
<p id="%E2%91%A0%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#%E2%91%A0%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84" rel="nofollow">①一维数组</a></p> 
<p id="%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE" rel="nofollow">排序与查找</a></p> 
<p id="%E2%91%A1%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#%E2%91%A1%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84" rel="nofollow">②多维数组</a></p> 
<p id="%E2%91%A2%E6%8C%87%E9%92%88-toc" style="margin-left:40px;"><a href="#%E2%91%A2%E6%8C%87%E9%92%88" rel="nofollow">③指针</a></p> 
<p id="%E2%85%A0%E5%AD%97%E7%AC%A6%EF%BC%8C%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97-toc" style="margin-left:80px;"><a href="#%E2%85%A0%E5%AD%97%E7%AC%A6%EF%BC%8C%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97" rel="nofollow">Ⅰ字符，指针运算</a></p> 
<p id="%E2%85%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%23include%3Cstring.h%3E-toc" style="margin-left:80px;"><a href="#%E2%85%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%23include%3Cstring.h%3E" rel="nofollow">Ⅱ字符串函数#include</a></p> 
<p id="%E2%85%A2%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0%E4%B8%8E%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98-toc" style="margin-left:80px;"><a href="#%E2%85%A2%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0%E4%B8%8E%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98" rel="nofollow">Ⅲ指针参数与动态内存</a></p> 
<p id="%E2%91%A3%E7%BB%93%E6%9E%84%3Astruct-toc" style="margin-left:40px;"><a href="#%E2%91%A3%E7%BB%93%E6%9E%84%3Astruct" rel="nofollow">④结构:struct</a></p> 
<p id="%E2%91%A4%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#%E2%91%A4%E9%93%BE%E8%A1%A8" rel="nofollow">⑤链表</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C" rel="nofollow">三、文件操作</a></p> 
<p id="%E2%85%A0%E5%9F%BA%E6%9C%AC%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-toc" style="margin-left:80px;"><a href="#%E2%85%A0%E5%9F%BA%E6%9C%AC%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA" rel="nofollow">Ⅰ基本文件输入输出</a></p> 
<p id="%E2%85%A1%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88-toc" style="margin-left:80px;"><a href="#%E2%85%A1%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88" rel="nofollow">Ⅱ文件指针</a></p> 
<p id="%E5%9B%9B%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1" rel="nofollow">四、类和对象</a></p> 
<p id="%E2%91%A0%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E2%91%A0%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8" rel="nofollow">①类的创建和使用</a></p> 
<p id="%E2%91%A1%E9%9D%99%E6%80%81%E6%88%90%E5%91%98-toc" style="margin-left:40px;"><a href="#%E2%91%A1%E9%9D%99%E6%80%81%E6%88%90%E5%91%98" rel="nofollow">②静态成员</a></p> 
<p id="%E2%91%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E2%91%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">③构造函数</a></p> 
<p id="%E2%91%A3%E7%B1%BB%E7%9A%84%E5%A4%8D%E5%90%88-toc" style="margin-left:40px;"><a href="#%E2%91%A3%E7%B1%BB%E7%9A%84%E5%A4%8D%E5%90%88" rel="nofollow">④类的复合</a></p> 
<p id="%E2%91%A4This%E6%8C%87%E9%92%88-toc" style="margin-left:40px;"><a href="#%E2%91%A4This%E6%8C%87%E9%92%88" rel="nofollow">⑤This指针</a></p> 
<p id="%E2%91%A5%E5%8F%8B%E5%85%83-toc" style="margin-left:40px;"><a href="#%E2%91%A5%E5%8F%8B%E5%85%83" rel="nofollow">⑥友元</a></p> 
<p id="%E2%85%A0%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E2%85%A0%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0" rel="nofollow">Ⅰ友元函数</a></p> 
<p id="%E2%85%A1%E5%8F%8B%E5%85%83%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%E2%85%A1%E5%8F%8B%E5%85%83%E7%B1%BB" rel="nofollow">Ⅱ友元类</a></p> 
<p id="%E4%BA%94%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" rel="nofollow">五、运算符重载</a></p> 
<p id="%E2%91%A0%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#%E2%91%A0%E5%8E%9F%E7%90%86" rel="nofollow">①原理</a></p> 
<p id="%E2%91%A1%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E2%91%A1%E6%96%B9%E5%BC%8F" rel="nofollow">②方式</a></p> 
<p id="%E2%85%A0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><a href="#%E2%85%A0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD" rel="nofollow">Ⅰ成员函数重载</a></p> 
<p id="%E2%85%A1%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><a href="#%E2%85%A1%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD" rel="nofollow">Ⅱ友元函数重载</a></p> 
<p id="%E2%91%A2%E5%8D%95%E7%9B%AE%E4%B8%8E%E5%8F%8C%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:40px;"><a href="#%E2%91%A2%E5%8D%95%E7%9B%AE%E4%B8%8E%E5%8F%8C%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" rel="nofollow">③单目与双目运算符重载</a></p> 
<p id="%E2%85%A0%E5%8D%95%E7%9B%AE%EF%BC%88%E7%9B%AE%E8%A1%A8%E7%A4%BA%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E2%85%A0%E5%8D%95%E7%9B%AE%EF%BC%88%E7%9B%AE%E8%A1%A8%E7%A4%BA%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%89" rel="nofollow">Ⅰ单目（目表示操作数）</a></p> 
<p id="%E2%85%A1%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><a href="#%E2%85%A1%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD" rel="nofollow">Ⅱ流插入和流提取运算符的重载</a></p> 
<p id="%E2%85%A2%E5%8F%8C%E7%9B%AE-toc" style="margin-left:80px;"><a href="#%E2%85%A2%E5%8F%8C%E7%9B%AE" rel="nofollow">Ⅲ双目</a></p> 
<p id="%E2%85%A3%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96-toc" style="margin-left:80px;"><a href="#%E2%85%A3%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96" rel="nofollow">Ⅳ类型转化</a></p> 
<p id="%E5%85%AD%E3%80%81%E7%BB%A7%E6%89%BF%E6%B4%BE%E7%94%9F%E5%A4%9A%E6%80%81-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E7%BB%A7%E6%89%BF%E6%B4%BE%E7%94%9F%E5%A4%9A%E6%80%81" rel="nofollow">六、继承派生多态</a></p> 
<p id="%E2%91%A0%E7%BB%A7%E6%89%BF-toc" style="margin-left:40px;"><a href="#%E2%91%A0%E7%BB%A7%E6%89%BF" rel="nofollow">①继承</a></p> 
<p id="%E2%85%A0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#%E2%85%A0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E5%AE%9A%E4%B9%89" rel="nofollow">Ⅰ成员函数的重定义</a></p> 
<p id="%E2%85%A1%E7%B1%BB%E6%8C%87%E9%92%88-toc" style="margin-left:80px;"><a href="#%E2%85%A1%E7%B1%BB%E6%8C%87%E9%92%88" rel="nofollow">Ⅱ类指针</a></p> 
<p id="%E2%91%A1%E5%A4%9A%E6%80%81-toc" style="margin-left:40px;"><a href="#%E2%91%A1%E5%A4%9A%E6%80%81" rel="nofollow">②多态</a></p> 
<p id="%E2%85%A0%E8%99%9A%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E2%85%A0%E8%99%9A%E5%87%BD%E6%95%B0" rel="nofollow">Ⅰ虚函数</a></p> 
<p id="%E2%85%A1%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E2%85%A1%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0" rel="nofollow">Ⅱ抽象基类与纯虚函数</a></p> 
<p id="%E2%85%A2%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E2%85%A2%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0" rel="nofollow">Ⅲ虚析构函数</a></p> 
<p id="%E2%91%A2STL-toc" style="margin-left:40px;"><a href="#%E2%91%A2STL" rel="nofollow">③STL</a></p> 
<p id="%E2%85%A0%E5%8A%A8%E6%80%81%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86https%3A%2F%2Fwww.educoder.net%2Ftasks%2Fp4imnbvy%2F887783%2Fok8rac4vzhbx%3FcoursesId%3Dp4imnbvy-toc" style="margin-left:80px;"><a href="#%E2%85%A0%E5%8A%A8%E6%80%81%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86https%3A%2F%2Fwww.educoder.net%2Ftasks%2Fp4imnbvy%2F887783%2Fok8rac4vzhbx%3FcoursesId%3Dp4imnbvy" rel="nofollow">Ⅰ动态学生信息管理https://www.educoder.net/tasks/p4imnbvy/887783/ok8rac4vzhbx?coursesId=p4imnbvy</a></p> 
<p id="%E2%85%A1%E8%BF%98%E5%8E%9F%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5https%3A%2F%2Fwww.educoder.net%2Ftasks%2Fp4imnbvy%2F887783%2Fyf2swgkio7ma%3FcoursesId%3Dp4imnbvy-toc" style="margin-left:80px;"><a href="#%E2%85%A1%E8%BF%98%E5%8E%9F%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5https%3A%2F%2Fwww.educoder.net%2Ftasks%2Fp4imnbvy%2F887783%2Fyf2swgkio7ma%3FcoursesId%3Dp4imnbvy" rel="nofollow">Ⅱ还原键盘输入https://www.educoder.net/tasks/p4imnbvy/887783/yf2swgkio7ma?coursesId=p4imnbvy</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6">一、程序控制</h2> 
<h3 id="%E2%91%A0%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">①输入输出</h3> 
<h4 id="%E2%85%A0.cin%26cout">Ⅰ.cin&amp;cout</h4> 
<p><strong>流操作算子 #include&lt;iomanip&gt;</strong></p> 
<blockquote> 
 <p><strong>setbase(n),进制，n=8,10,16<br> setprecision(n)，浮点数精度设置为n<br> setw(n),域宽n，小于n空位填充，大于n输出所有<br> setiosflags(long),long,流格式状态标志</strong></p> 
</blockquote> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
	//setbase(n),进制，n=8,10,16
	int a = 1000;
	cout &lt;&lt; "oct(八进制)："&lt;&lt;setbase(8) &lt;&lt; a&lt;&lt;" "&lt;&lt;oct &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; "hex(十六进制)：" &lt;&lt; setbase(16) &lt;&lt; a &lt;&lt; " " &lt;&lt; hex &lt;&lt; a &lt;&lt; endl;

	//setprecision(n)，浮点数精度设置为n
	double b = log(2);
	cout &lt;&lt; dec &lt;&lt; b &lt;&lt; " 保留两位小数：" &lt;&lt; setprecision(2) &lt;&lt; b &lt;&lt; endl;

	//setw(n),域宽n，小于n空位填充，大于n输出所有
	cout &lt;&lt; setw(5) &lt;&lt; "域宽为5:" &lt;&lt; "1234" &lt;&lt; endl;
	cout &lt;&lt; setw(5) &lt;&lt; "域宽为5:" &lt;&lt; "hello,world!" &lt;&lt; endl;

	//setiosflags(long),long,流格式状态标志
	//ios::left/right/internal 左对齐，右对齐，符号左对齐数值右对齐
	//ios::showpos 显示正负号
	//ios::scientific 科学计数显示浮点数
    //ios::showpoint 显示小数点
	double c = 1010.234;
	cout &lt;&lt; c &lt;&lt; "科学技术显示浮点数并显示正负号：" &lt;&lt; setiosflags(ios::showpos | ios::scientific) &lt;&lt; c&lt;&lt;endl;

	return 0;
}

out:

oct(八进制)：1750 1750
hex(十六进制)：3e8 3e8
0.693147 保留两位小数：0.69
域宽为5:1234
域宽为5:hello,world!
1e+03科学技术显示浮点数并显示正负号：+1.01e+03
</code></pre> 
<p><strong>其他流输入输出</strong></p> 
<blockquote> 
 <p>cin.get(char) 抽取下一个字符<br> cin.peek() 读取下一个字符<br> cin.putbact(char) 将字符写入输入流的开头<br> cin.ingnore(int, char) 忽略前面int个或char及其之前的字符<br> cin.getline(char*, int, char) 最多读取前面n个字符或读取到char截止</p> 
</blockquote> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
	string line;

	//getline(cin,str)
	//cin.get(char) 抽取一个字符
	char gch;
	cin.get(gch);
	getline(cin, line);//getline抽取整行的输入流
	cout &lt;&lt; "cin.get()抽取的字符是：" &lt;&lt; gch&lt;&lt;endl;
	cout &lt;&lt; "cin.get()抽取后的输入流为：" &lt;&lt; line &lt;&lt; endl&lt;&lt;endl;

	//cin.peek() 读取下一个字符
	char pch;
	pch=cin.peek();
	getline(cin, line);
	cout &lt;&lt;"cin.peek()预览的下一个字符是："&lt;&lt;pch&lt;&lt;endl;
	cout &lt;&lt; "cin.peek()预览后的输入流为：" &lt;&lt;line&lt;&lt; endl&lt;&lt;endl;

	//cin.putback(char) 将字符写入输入流的开头
	cin.putback('A');
	getline(cin, line);
	cout &lt;&lt; "cin.putback('A')操作后的输入流：" &lt;&lt; line &lt;&lt; endl&lt;&lt;endl;

	//cin.ingnore(int,char) 忽略前面int个或char及其之前的字符
	cin.ignore(3, 'o');
	getline(cin, line);
	cout &lt;&lt; "cin.ignore(3, 'o'): " &lt;&lt;line&lt;&lt; endl&lt;&lt;endl;
	cin.ignore(3, 'o');
	getline(cin, line);
	cout &lt;&lt; "cin.ignore(3, 'o'): " &lt;&lt;line&lt;&lt; endl&lt;&lt;endl;

	//cin.getline(char*,int,char) 最多读取前面n个字符或读取到char截止,若输入流有剩余则继续操作
	char cs[5];
	cin.getline(cs, 5, 'l');
	cout &lt;&lt; "cin.getline(cs, 5, 'l'): " &lt;&lt; cs &lt;&lt; endl&lt;&lt;endl;
	getline(cin, line);

	cin.getline(cs, 5, 'l');
	cout &lt;&lt; "cin.getline(cs, 5, 'l'): " &lt;&lt; cs&lt;&lt; endl&lt;&lt;endl;
	getline(cin, line);
	return 0;
}

out:

qwer
cin.get()抽取的字符是：q
cin.get()抽取后的输入流为：wer

qwer
cin.peek()预览的下一个字符是：q
cin.peek()预览后的输入流为：qwer

qwer
cin.putback('A')操作后的输入流：Aqwer

qwerty
cin.ignore(3, 'o'): rty

qoerty
cin.ignore(3, 'o'): erty

hello
cin.getline(cs, 5, 'l'): he

heeeee
cin.getline(cs, 5, 'l'): heee</code></pre> 
<h4 id="%E2%85%A1.scanf%26printf">Ⅱ.scanf&amp;printf</h4> 
<p><strong>格式化输入输出#include&lt;stdio.h&gt;</strong></p> 
<blockquote> 
 <p>printf(&lt;格式化控制&gt;,&lt;参数列表&gt;)<br> scanf(&lt;宽度&gt;,&lt;转换说明符&gt;)</p> 
</blockquote> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;string&gt;
#include&lt;stdio.h&gt;
using namespace std;
int main()
{
	//printf(&lt;格式化控制&gt;,&lt;参数列表&gt;)
	//&lt;标志&gt;：-左对齐，+显示符号，0用0填充域宽
	//&lt;域宽&gt;：小于域宽空白填充，大于按照实际输出
	//&lt;精度&gt;：整数：至少输出的数字个数，少的0补前面，字符串：输出最大长度
	//&lt;转换说明符&gt;：数据转换类型
	double num =-123.456;
	printf("%+015.5f\n", num);//0：缺项补0，15：域宽，5：精度

	//scanf(&lt;宽度&gt;,&lt;转换说明符&gt;)
	char c;
	int d;
	scanf("%3c%3d",&amp;c,&amp;d);
	cout &lt;&lt; "c: " &lt;&lt; c &lt;&lt; endl&lt;&lt;"d: "&lt;&lt;d&lt;&lt;endl;
}

out:

-00000123.45600
qes132245
c: q
d: 132</code></pre> 
<h3 id="%E2%91%A1%E8%BF%90%E7%AE%97%E4%B8%8E%E7%AC%A6%E5%8F%B7">②运算与符号</h3> 
<h4 id="%E2%85%A0%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0%23include%3Cmath.h%3E">Ⅰ常用数学函数#include&lt;math.h&gt;</h4> 
<blockquote> 
 <p>abs<br> ceil 向上取整<br> exp(x) e^x<br> floor 向下取整<br> pow(x,y) x^y<br> log 以e为底数<br> log10 以10为底数</p> 
</blockquote> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;string&gt;
#include&lt;stdio.h&gt;

using namespace std;
int main()
{
	cout &lt;&lt;"abs(-1)="&lt;&lt; abs(-1) &lt;&lt; endl;
	cout &lt;&lt; "ceil(0.5)="&lt;&lt;ceil(0.5) &lt;&lt; endl;
	cout &lt;&lt; "exp(0.1)="&lt;&lt;exp(0.1) &lt;&lt; endl;
	cout &lt;&lt; "floor(0.5)="&lt;&lt;floor(0.5) &lt;&lt; endl;
	cout &lt;&lt; "pow(2, 3)="&lt;&lt;pow(2, 3) &lt;&lt; endl;
	cout &lt;&lt; "log(10)="&lt;&lt;log(10) &lt;&lt; endl;
	cout &lt;&lt;"log10(10)="&lt;&lt; log10(10) &lt;&lt; endl;

	return 0;
}
out:

abs(-1) = 1
ceil(0.5) = 1
exp(0.1) = 1.10517
floor(0.5) = 0
pow(2, 3) = 8
log(10) = 2.30259
log10(10) = 1</code></pre> 
<h4 id="%E2%85%A1.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">Ⅱ.数据类型转换</h4> 
<blockquote> 
 <p>隐式转换<br> 显式转换<br> ASCII码与BOOL<br> 运算符<br> 三目运算符：&lt;1&gt; ? &lt;2&gt; : &lt;3&gt;</p> 
</blockquote> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;string&gt;
#include&lt;stdio.h&gt;
using namespace std;
int main()
{
	//隐式转换
	int e = 3;
	double f = e + 3.12;

	//显式转换
	cout &lt;&lt; "double(3/2)="&lt;&lt;double(3 / 2) &lt;&lt; endl;//运算后再转换为double
	cout &lt;&lt; "double(3.0/2)=" &lt;&lt; double(3.0 / 2) &lt;&lt; endl;
	cout &lt;&lt; "(double)3/2=" &lt;&lt; (double)3 / 2 &lt;&lt; endl;//所有数据先转换为doble再运算

	//ASCII码与BOOL
	cout &lt;&lt; "int('a')=" &lt;&lt; int('a') &lt;&lt; endl;
	cout &lt;&lt; "int(true)=" &lt;&lt; int(true) &lt;&lt; endl;
	cout &lt;&lt; "char(97)=" &lt;&lt; char(97) &lt;&lt; endl;
	cout&lt;&lt;"(char)(97+256)="&lt;&lt;(char)(97 + 256) &lt;&lt; endl; //char占一个字节，256溢出不计

	//运算符
	//+,-,*,/,%
	//==,&lt;=,&gt;=,!=
	//&amp;&amp;,||,!
	//&amp;,|,~,^,&lt;&lt;,&gt;&gt;:按位与，按位或，按位取反，按位异或，左右移位

	//三目运算符：&lt;1&gt;?&lt;2&gt;:&lt;3&gt;
	//if&lt;1&gt;则&lt;2&gt;;else &lt;3&gt;
	int a = 1, b = 2, c = 3;
	a &gt; b ? a = b : a = c;
	cout &lt;&lt; a;

	return 0;
}
out:

double(3/2)=1
double(3.0/2)=1.5
(double)3/2=1.5
int('a')=97
int(true)=1
char(97)=a
(char)(97+256)=a
3</code></pre> 
<h3 id="%E2%91%A2%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84">③控制结构</h3> 
<blockquote> 
 <p>两个数的值交换<br> 三个数的排序<br> switch - case-break - defalut</p> 
 <p>方便跳出多重循环</p> 
</blockquote> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;string&gt;
#include&lt;stdio.h&gt;
using namespace std;
int main()
{
	//两个数的值交换
	int e = 1, f = 2;
	int t = e;
	e = f;
	f = t;

	//三个数的排序
	int a = 1, b = 2, c = 3;
	int maxab = a &gt; b ? a : b;
	int minab = a + b - maxab;
	int max = maxab &gt; c ? maxab : c;
	int temp = (maxab + c) - max;
	int min = temp &gt; minab ? minab : temp;
	cout &lt;&lt; "max:" &lt;&lt; max &lt;&lt; "\n" &lt;&lt; "mid:" &lt;&lt; (a + b + c) - max - min &lt;&lt; endl&lt;&lt;"min:"&lt;&lt;min&lt;&lt;endl;

	//switch-case-break-defalut
	int flag = 1;
	while (flag)
	{
		int command;
		cin &gt;&gt; command;
		switch (command)
		{
			case 1:
				cout &lt;&lt; "1号任务" &lt;&lt; endl;
				break;//不能缺少break语句
			case 2:
				cout &lt;&lt; "2号任务" &lt;&lt; endl;
				break;
			case 0:
				flag = 0;
				break;
			default:
				cout &lt;&lt; "你干嘛" &lt;&lt; endl;
		}
	}

    //goto 方便跳出多重循环
	for (int i = 1; i &lt; 10; i++)
	{
		for (int j = 1; j &lt; 10; j++)
		{
			for (int k = 1; k &lt; 10; k++)
			{
				if (3*i + 4 * j + 5 * k == 100)
				{
					printf("i=%d,j=%d,k=%d是3*i+4*j+5*k=100的解\n", i, j, k);
					goto flag1;
				}
			}
		}
	}
	flag1:
		cout&lt;&lt;"flag1";
	return 0;
}
out:

max:3
mid:2
min:1
1
1号任务
4
你干嘛
0
i=8,j=9,k=8是3*i+4*j+5*k=100的解
flag1</code></pre> 
<h3 id="%E2%91%A3%E5%87%BD%E6%95%B0">④函数</h3> 
<h4 id="%E2%85%A0.%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89">Ⅰ.函数定义</h4> 
<blockquote> 
 <p>函数头放前面，具体定义放后面，增强可读性</p> 
</blockquote> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;string&gt;
#include&lt;stdio.h&gt;
using namespace std;

//&lt;返回类型&gt;&lt;函数名字&gt;(&lt;参数列表&gt;){&lt;语句&gt;}
bool isprime(int n);//函数头放前面，具体定义放后面，增强可读性
void goldbach(int n);

int main()
{
	cout &lt;&lt; "15~30的偶数哥德巴赫猜想验证\n";
	for (int i = 16; i &lt;= 30; i+=2)
	{
		goldbach(i);
		cout &lt;&lt; endl;
	}
	return 0;
}

// function library
bool isprime(int n) //判断是否为素数
{
	int c = 1;
	for (int i = 2; i &lt;= n; i++)
	{
		if (n % i == 0)
		{
			c++;
		}
	}
	return c == 2 ? true : false;
}
void goldbach(int n)
{
	for (int i = 2; i &lt; n / 2 + 1; i++)
	{
		if (isprime(i) &amp;&amp; isprime(n - i))
		{
			printf("%d=%d+%d", n, i, n - i);
			break;
		}
	}
}
out:

15~30哥德巴赫猜想验证
16 = 3 + 13
18 = 5 + 13
20 = 3 + 17
22 = 3 + 19
24 = 5 + 19
26 = 3 + 23
28 = 5 + 23
30 = 7 + 23</code></pre> 
<h4 id="%E2%85%A1%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8">Ⅱ函数使用</h4> 
<blockquote> 
 <p>传值<br> 传引用<br> 函数重载,函数名字可相同，但传参类型个数或顺序不同<br> 作用域：块作用域，{}, 全局作用<br> 存储类别：auto, static.(auto现在已经被淘汰了, 函数内直接定义即可)</p> 
 <p>递归函数：汉诺塔问题</p> 
</blockquote> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;string&gt;
#include&lt;stdio.h&gt;
using namespace std;

int a = 1;
double max(double x, double y);
void swap(double&amp; x, double&amp; y);
int max(int x, int y);
void storeauto(int &amp;x, int &amp;y);
void storesta(int&amp; x, int&amp; y);
void hannuo(int n, char s, char m, char t);//n:规模，s:源柱，m:辅柱,t:目标柱

int main()
{
	//传值
	double x = 1.1, y = 2.2;

	//传引用
	printf("x=%.1f,y=%.1f\t", x, y); 
	swap(x, y);//这里不用写(&amp;x,&amp;y)
	printf("after swapping \tx=%.1f,y=%.1f\n", x, y);
	
	//函数重载,函数名字可相同，但传参类型个数或顺序不同
	int r = 1, s = 2;
	cout &lt;&lt; max(r, s)&lt;&lt;endl;

	//作用域：块作用域，{},全局作用
	{int a=1; cout &lt;&lt;"块1：a="&lt;&lt; a &lt;&lt; endl; };
	{int a = 2; cout &lt;&lt;"块2：a="&lt;&lt; a &lt;&lt; endl; };
	cout &lt;&lt; "全局：a=" &lt;&lt; a &lt;&lt; endl;

	//存储类别：auto,static.(auto现在已经被淘汰了,函数内直接定义即可)
	int q = 2, w = 4;
	printf("q=%d,w=%d\n", q, w);
	for (int i = 1; i &lt;= 2;i++)
	{
		storeauto(q, w);
		printf("storeauto(q,w)调用%d次后,q=%d,w=%d\n", i, q, w);
	}
	cout &lt;&lt; endl;
	printf("q=%d,w=%d\n", q, w);
	for (int i = 1; i &lt;= 2; i++)
	{
		storesta(q, w);
		printf("storesta(q,w)调用%d次后,q=%d,w=%d\n", i, q, w);
	}

	//汉诺塔问题
	hannuo(3, 'A', 'C', 'B');

	return 0;
}

// function library
double max(double x, double y)
{
	return x &lt; y ? y : x;
}
void swap(double&amp; x, double&amp; y)
{
	double temp=x;
	x = y;
	y = temp;
}
int max(int x, int y)
{
	return x &lt; y ? y : x;
}
void storeauto(int &amp;x, int &amp;y)
{
	int j=1;//auto int j=0;
	x += j;
	y += j;
	j++;
}
void storesta(int&amp; x, int&amp; y)
{
	static int j =1;//auto int j=0;
	x += j;
	y += j;
	j++;
}
void hannuo(int n, char s, char m, char t)
{
	if (n == 1)
	{
		cout &lt;&lt; s &lt;&lt;"-&gt;" &lt;&lt; t &lt;&lt; endl;
	}
	else
	{
		hannuo(n - 1, s, t, m);//n-1个盘子移到辅柱
		cout &lt;&lt; s &lt;&lt; "-&gt;" &lt;&lt; t &lt;&lt; endl;//最后一个移到目标柱
		hannuo(n - 1, m, s, t);//辅柱变为源柱
	}
}
out:

x=1.1,y=2.2     after swapping  x=2.2,y=1.1
2
块1：a=1
块2：a=2
全局：a=1
q=2,w=4
storeauto(q,w)调用1次后,q=3,w=5
storeauto(q,w)调用2次后,q=4,w=6

q=4,w=6
storesta(q,w)调用1次后,q=5,w=7
storesta(q,w)调用2次后,q=7,w=9
A-&gt;B
A-&gt;C
B-&gt;C
A-&gt;B
C-&gt;A
C-&gt;B
A-&gt;B</code></pre> 
<h2 id="%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">二、数据结构</h2> 
<h3 id="%E2%91%A0%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">①一维数组</h3> 
<h4 id="%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE"><strong>排序与查找</strong></h4> 
<blockquote> 
 <p><strong>一维数组 a[n], n是数据个数<br> 排序 交换（每次找到都交换），选择（先找最值再交换），快排<br> 内置函数#include&lt;algorithm&gt;<br> 查找：二分查找</strong></p> 
</blockquote> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;string&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;

void quick_sort(int a[], int start, int end);//快排自定义
int binary_search(vector&lt;int&gt;&amp; nums, int target);

int main()
{
	//一维数组 a[n],n是数据个数
	int d[4]; //大小是常量值
	int b[] = { 1,2,3,4 };//根据数目确定大小
	float c[5] = { 1.2 };//缺省值0
	
	//排序 交换（每次找到都交换），选择（先找最值再交换），快排
	//交换排序
	int a[10] = { 1,2,3,5,6,8,10,9,7,4 };
	for (int i = 0; i &lt; 10 - 1; i++)
	{
		for (int j = i+1; j &lt; 10; j++)
		{
			if (a[i] &gt; a[j]) 
			{
				int temp = a[i];
				a[i] = a[j];
				a[j] = temp;
			}
		}
	}
	cout &lt;&lt; "交换排序结果：";
	for (int i = 0; i &lt; 10; i++) 
	{
		cout &lt;&lt; a[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
	//选择排序
	for (int i = 0; i &lt; 10 - 1; i++)
	{
		int min = i;
		for (int j = i + 1; j &lt; 10; j++)
		{
			if (a[j] &lt; a[i])
			{
				min = j;
			}
		}
		if (i != min)
		{
			int temp = a[i];
			a[i] = a[min];
			a[min] = a[i];
		}
	}
	cout &lt;&lt; "选择排序结果：";
	for (int i = 0; i &lt; 10; i++)
	{
		cout &lt;&lt; a[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
	//快排
	quick_sort(a, 0, 10- 1);
	cout &lt;&lt; "快排结果：";
	for (int i = 0; i &lt; 10; i++)
	{
		cout &lt;&lt; a[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
	//内置函数#include&lt;algorithm&gt;
	sort(a, a + 10, greater&lt;int&gt;());//左闭右开，greater,降序,int 类型，默认为升序

	//查找：二分查找
	vector&lt;int&gt; nums = { 1, 3, 5, 7, 9, 11, 13, 15, 17 };
	int target = 11;

	int index = binary_search(nums, target);
	if (index == -1) {
		cout &lt;&lt; "Target not found" &lt;&lt; endl;
	}
	else {
		cout &lt;&lt; "Target found at index " &lt;&lt; index &lt;&lt; endl;
	}

	return 0;
}

// function library
void quick_sort(int a[], int start, int end)
{
	if (start &gt;= end) {
		return;
	}

	int pivot = a[start];
	int left = start + 1, right = end;

	while (left &lt;= right) {
		if (a[left] &lt; pivot &amp;&amp; a[right] &gt; pivot) {
			swap(a[left], a[right]);
			left++;
			right--;
		}
		if (a[left] &gt;= pivot) {
			left++;
		}
		if (a[right] &lt;= pivot) {
			right--;
		}
	}

	swap(a[start], a[right]);
	quick_sort(a, start, right - 1);
	quick_sort(a, right + 1, end);
}
int binary_search(vector&lt;int&gt;&amp; nums, int target) 
{
	int left = 0, right = nums.size() - 1;

	while (left &lt;= right) {
		int mid = left + (right - left) / 2;
		if (nums[mid] == target) {
			return mid;
		}
		else if (nums[mid] &lt; target) {
			left = mid + 1;
		}
		else {
			right = mid - 1;
		}
	}

	return -1;
}
out:

交换排序结果：1 2 3 4 5 6 7 8 9 10
选择排序结果：1 2 3 4 5 6 7 8 9 10
快排结果：10 9 8 7 6 5 4 3 2 1
Target found at index 5</code></pre> 
<h3 id="%E2%91%A1%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">②多维数组</h3> 
<blockquote> 
 <p>初始化 a[m][n], m行n列，按行连续储存<br> 作为函数参数, 指定数组的每一维的大小</p> 
</blockquote> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;string&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;

int sum(int arr[][3], int rows, int cols);

int main()
{
	//多维数组 初始化 a[m][n],m行n列，按行连续储存
	int a[2][2] = { {2},{2,3} };//缺省值为0
	int b[2][2] = { 1,2,3};//按行读入
	int c[][2] = { {1,2},{1} };//只能省略第一维

	//多维数组 作为函数参数
	//由于多维数组的内存布局是连续的，因此在将多维数组作为形参传递时，必须指定数组的每一维的大小
	int arr[2][3] = { {1, 2, 3}, {4, 5, 6} };
	int s = sum(arr, 2, 3);
	cout &lt;&lt; "The sum of the array is: " &lt;&lt; s &lt;&lt; endl;

	return 0;
}

// function library
int sum(int arr[][3], int rows, int cols)
{
	int s = 0;
	for (int i = 0; i &lt; rows; ++i) {
		for (int j = 0; j &lt; cols; ++j) {
			s += arr[i][j];
		}
	}
	return s;
}
out:

The sum of the array is : 21
</code></pre> 
<h3 id="%E2%91%A2%E6%8C%87%E9%92%88">③指针</h3> 
<h4 id="%E2%85%A0%E5%AD%97%E7%AC%A6%EF%BC%8C%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97">Ⅰ字符，指针运算</h4> 
<blockquote> 
 <p>加密问题<br> 二维字符数组<br> 指针运算：&amp; 地址运算* 复引用 + -算术运算 前移后移，计算距离，关系运算，赋值<br> 指针操作数组<br> 指针数组：数组存放指针</p> 
</blockquote> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;string&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;

int main()
{
	//加密问题
	char a[10];
	cin &gt;&gt; a;
	int l = 0;
	while (a[l] != '\0')
	{
		a[l] = a[l] + 'A' - 'a'+3;
		l++;
	}
	cout &lt;&lt; "输入字符串长度为：" &lt;&lt; l &lt;&lt; "\t加密后为：" &lt;&lt; a &lt;&lt; endl;

	//二维字符数组
	char s[2][10];
	cin &gt;&gt; s[0] &gt;&gt; s[1];
	cout &lt;&lt; s[0] &lt;&lt; endl &lt;&lt; s[1] &lt;&lt; endl;

	//指针运算：&amp;地址运算 *复引用 +-算术运算 前移后移，计算距离，关系运算，赋值
	//&amp; 地址运算
	int* yptr;
	int y = 5;
	yptr = &amp;y;//得到指向y的指针
	//*复引用
	int* p1, * p2;//同时定义两个指针都要打*
	int y1 = 2, y2 = 3;
	p1 = &amp;y1;
	p2 = &amp;y2;
	*p1 += 1;
	printf("y1=%d,y2=%d\n*p1=%d,*p2=%d\n", y1, y2, *p1, *p2);
	//+-算术运算 前移后移，计算距离
	cout &lt;&lt; "p1-p2=" &lt;&lt; p1 - p2 &lt;&lt; endl;
	//关系运算
	cout &lt;&lt; "p1&lt;p2?" &lt;&lt; bool(p1 &lt; p2) &lt;&lt; endl;
	//赋值,不同类型需要类型转换
	float f = 0.1;
	int* d = (int*)&amp;f;
	cout &lt;&lt; "int* d = (int*)&amp;f,*d=" &lt;&lt; *d &lt;&lt; endl;//d的输出并不是0，涉及到浮点数的存储方式和类型转换

	//指针操作数组
	int arr1[5] = { 1, 2, 3, 4, 5 };
	int* pa = arr1;
	for (int i = 0; i &lt; 5; ++i) {
		cout &lt;&lt; *pa &lt;&lt; " ";
		pa++;
	}

	cout &lt;&lt; endl;

	//指针数组：数组存放指针
	const char *gender[3][10] = {"man","women","other"};
	cout &lt;&lt; "*gender[0]="&lt;&lt; * gender[0] &lt;&lt; endl;
	return 0;
}

// function library
out:
helloworld
输入字符串长度为：10    加密后为：KHOORZRUOG
hello world
hello
world
y1 = 3, y2 = 3
* p1 = 3, *p2 = 3
p1 - p2 = -8
p1 &lt; p2 ? 1
	int* d = (int*)&amp;f, *d = 1036831949
	1 2 3 4 5
	* gender[0] = man</code></pre> 
<h4 id="%E2%85%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%23include%3Cstring.h%3E">Ⅱ字符串函数#include&lt;string.h&gt;</h4> 
<blockquote> 
 <p>int strlen(const char*) 计算字符串长度<br> char* strcpy(char* dest, const char* src) 将src指向的空间复制到dest<br> char* strcat(char* dest, const char* src) 将src指向的空间连接到dest之后<br> int strcmp(const char* s1, const char* s2)    逐一比较字典序，s1 &lt; s2返回1<br> char* strchr(const char* s, int c) 在s中查找第一个对应ASCII码为c的字符并返回位置，否则返回NULL<br> 综合应用 : countstring(const chat* s1, const char* s2)，查找子串s2在s1中的出现次数</p> 
</blockquote> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;string.h&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;

int countstring(const char* s1, const char* s2);

int main()
{
	//int strlen(const char*) 计算字符串长度
	const char* c1 = "hello world";
	char c2[] = "hello world"; //两种初始化方式
	cout &lt;&lt; "strlen(c1)=" &lt;&lt; strlen(c1) &lt;&lt; "\tstrlen(c2)=" &lt;&lt; strlen(c2) &lt;&lt; endl;

	//char* strcpy(char* dest,const char* src) 将src指向的空间复制到dest
	char a[20]="hello", b[20] = "world";
	strcpy(a, b);//a原来有的内容不会保留
	cout &lt;&lt; "strcpy(a, b),a=" &lt;&lt; a &lt;&lt; endl;

	//char* strcat(char* dest,const char* src) 将src指向的空间连接到dest之后
	strcat(a, b);//拼接在一起
	cout &lt;&lt; "strcat(a, b),a=" &lt;&lt; a &lt;&lt; endl;

	//int strcmp(const char* s1,const char* s2)	逐一比较字典序，s1&lt;s2返回1
	char s1[] = "abc", s2[] = "abb";//按照字典，谁在前面谁大
	cout &lt;&lt; "strcmp(s1,s2)=" &lt;&lt; strcmp(s1, s2) &lt;&lt; endl;

	//char* strchr(const char* s,int c) 在s中查找第一个对应ASCII码为c的字符并返回位置，否则返回NULL
	cout &lt;&lt; "strchr(s1,'b')返回：" &lt;&lt; strchr(s1, 'b') &lt;&lt; endl;
	if (strchr(s1, 'd') == NULL)
	{
		cout &lt;&lt; "strchr(s1, 'd') == NULL" &lt;&lt; endl;
	}

	//char* strstr(const char* s1,const char* s2) 在s1中查找s2出现的首位置并返回，否则返回NULL
	char s3[] = "abcdefabcdef", s4[] = "cd";
	cout &lt;&lt; "strstr(s3, s4)：" &lt;&lt; strstr(s3, s4) &lt;&lt; endl;

	//综合应用:countstring(const chat* s1,const char* s2)，查找子串s2在s1中的出现次数
	char s5[] = "abcdefhabcewfhabcmkknabc", s6[] = "abc";
	printf("\"%s\"在\"%s\"中出现的次数为：%d\n", s6, s5, countstring(s5, s6));

	return 0;
}

// function library
int countstring(const char* s1, const char* s2)
{
	int count = 0, l = strlen(s2);
	const char* p = s1;
	while ((p = strstr(p, s2)) != NULL) {
		count++;
		p += l;
	}
	return count;
}
out:

strlen(c1) = 11   strlen(c2) = 11
strcpy(a, b), a = world
strcat(a, b), a = worldworld
strcmp(s1, s2) = 1
strchr(s1, 'b')返回：bc
strchr(s1, 'd') == NULL
strstr(s3, s4)：cdefabcdef
"abc"在"abcdefhabcewfhabcmkknabc"中出现的次数为：4</code></pre> 
<h4 id="%E2%85%A2%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0%E4%B8%8E%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98">Ⅲ指针参数与动态内存</h4> 
<blockquote> 
 <p>const与指针<br> 动态分布：new&amp; delete, malloc&amp; free</p> 
</blockquote> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;string.h&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;

int main()
{
	//const与指针
	const int* p1; // 指向常量的非常量指针
	int a = 1;
	p1 = &amp;a; // OK，p1指向a，但不能通过p1修改a的值
	int b = 2;
	p1 = &amp;b; // OK，p1指向b，但不能通过p1修改b的值
	int* const p2 = &amp;a; // 指向非常量的常量指针
	*p2 = 3; // OK，可以通过p2修改a的值
	int c = 4;
	// p2 = &amp;c; // ERROR，p2是常量指针，不能改变指向的对象
	const int* const p3 = &amp;b; // 指向常量的常量指针
	// *p3 = 5; // ERROR，不能通过p3修改b的值
	int d = 6;
	// p3 = &amp;d; // ERROR，p3是常量指针，不能改变指向的对象
	
	//动态分布：new&amp;delete,malloc&amp;free
	int x; //数组的长度
	cin &gt;&gt; x;//运行时才能确定x的值
	float* scores = new float[x];
	cout &lt;&lt;"分配的内存空间长度："&lt;&lt; sizeof(float) * x &lt;&lt; endl;
	delete[]scores;//及时释放，防止内存泄露，建议每次new就直接写delete

	int* s = (int*)malloc(sizeof(int) * 4);
	for (int i = 0; i &lt; 4; i++)
	{
		cin &gt;&gt; s[i];
	}
	for (int i = 0; i &lt; 4; i++)
	{
		cout &lt;&lt; s[i] &lt;&lt; " ";
	}
	free(s);

	return 0;
}

// function library
out:

5
分配的内存空间长度：20
1
2
3
4
1 2 3 4</code></pre> 
<h3 id="%E2%91%A3%E7%BB%93%E6%9E%84%3Astruct">④结构:struct</h3> 
<blockquote> 
 <p>定义与声明<br> 初始化<br> 结构与函数</p> 
</blockquote> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;string.h&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;

//定义与声明
struct birthday
{
	int year;
	int month;
	int day;
};
struct lifting
{
	char name[20];
	float weight;
	birthday date;//可以包含其他strcut
	lifting* a;//可以是指向本结构类型的指针
}lift1,lift2;//声明两个变量
void print(lifting* l);

int main()
{
	//初始化
	lift1 = { "张三",57,{2005,1,13},&amp;lift2 };//lift1.a指向lift2
	lifting* p1 = &amp;lift1;
	//p1-&gt;name = "张三";这里不能直接修改
	strcpy(p1-&gt;name, "李四"); // 使用strcpy函数修改name的值
	cout &lt;&lt; lift1.name;
	cout &lt;&lt; "生日为：" &lt;&lt; lift1.date.year&lt;&lt;" "&lt;&lt; lift1.date.month&lt;&lt;" "&lt;&lt; lift1.date.day&lt;&lt;endl;
	
	//结构与函数：结构变量的成员是普通变量，可作为函数的参数或返回值
	print(p1);

	return 0;
}

// function library
void print(lifting* l)
{
	cout &lt;&lt; "姓名："&lt;&lt;l-&gt;name &lt;&lt; endl &lt;&lt;"体重："&lt;&lt; l-&gt;weight&lt;&lt;endl;
}
out:

李四生日为：2005 1 13
姓名：李四
体重：57</code></pre> 
<h3 id="%E2%91%A4%E9%93%BE%E8%A1%A8">⑤链表</h3> 
<blockquote> 
 <p>node* insertTail(node* h, node* t) //尾部插入<br> node* insertHead(node* h, node* t)//头部插入<br> node* insertSort(node* h, node* t) //从小到大插入<br> node* search(node* h, int num) //查找指定节点<br> node* delAt(node* h, int i)//删除指定位置节点<br> node* delHas(node* h, int n) //删除含有指定元素的节点<br> int listLength(node* h)//计算链表长度</p> 
</blockquote> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;string.h&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;

struct node 
{
	int data;
	node* next;
};
node* insertTail(node* h, node* t) //尾部插入
{
    if (h == nullptr) 
    {
        return t;// 如果当前链表为空，直接将待插入结点作为链表头并返回
    }
    node* p = h;
    while (p-&gt;next != nullptr) {
        p = p-&gt;next; // 找到链表的最后一个结点
    }
    p-&gt;next = t;// 将链表的最后一个结点的next指针指向待插入结点
    return h;
}
node* insertHead(node* h, node* t)//头部插入
{
    if (h == nullptr)
    {
        return t;
    }
    t-&gt;next = h;
    return t;
}
node* insertSort(node* h, node* t) //从小到大插入
{
    if (h == NULL) 
    { 
        t-&gt;next = NULL;// 空链表，直接将结点t插入
        return t;
    }
    if (t-&gt;data &lt;= h-&gt;data) 
    { 
        t-&gt;next = h;// 将结点t插入链表头
        return t;
    }
    node* p = h;
    while (p-&gt;next != NULL &amp;&amp; p-&gt;next-&gt;data &lt; t-&gt;data) {
        p = p-&gt;next;
    }
    t-&gt;next = p-&gt;next;
    p-&gt;next = t;
    return h;
}
node* search(node* h, int num) //查找指定节点
{
    if (h == NULL)// 空链表
    { 
        return NULL;
    }
    node* p = h;
    while (p != NULL) {
        if (p-&gt;data == num) {
            return p;
        }
        p = p-&gt;next;
    }
    return NULL; // 循环结束，未找到该结点
}
node* delAt(node* h, int i)//删除指定位置节点
{
    int num = 0;
    node* p = h;
    while (p-&gt;next != nullptr)
    {
        num++;
        p = p-&gt;next;
    }
    if (i == 0)
    {
        return h-&gt;next;
    }
    else if (i &gt; num)
    {
        return h;
    }
    else
    {
        node* t = h;
        node* m = h;
        for (int j = 0; j &lt; i; j++)
        {
            t = m;
            m = t-&gt;next;
        }
        t-&gt;next = m-&gt;next;
        return h;
    }
}
node* delHas(node* h, int n) //删除含有指定元素的节点
{
    if (h == NULL)  // 空链表
    {
        return h;
    }
    if (h-&gt;data == n) 
    { 
        node* p = h;
        h = h-&gt;next;// 删除头结点
        free(p);//释放原来头节点的内存
        return h;
    }
    node* p = h;
    while (p-&gt;next != NULL &amp;&amp; p-&gt;next-&gt;data != n) 
    { 
        p = p-&gt;next;// 找到要删除结点的前驱结点
    }
    if (p-&gt;next == NULL) 
    { 
        return h;// 要删除的结点不存在
    }
    node* q = p-&gt;next; // 被删除结点
    p-&gt;next = q-&gt;next; // 将被删除结点从链表中删除
    free(q);//释放内存

    return h;
}
int listLength(node* h)//计算链表长度
{
    int c = 0;
    while (h != nullptr)
    {
        c++;
        h = h-&gt;next;
    }
    return c;
}</code></pre> 
<h2 id="%E4%B8%89%E3%80%81%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C">三、文件操作</h2> 
<h4 id="%E2%85%A0%E5%9F%BA%E6%9C%AC%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">Ⅰ基本文件输入输出</h4> 
<blockquote> 
 <p>打开文件 ios::in打开供读取，out打开供写入, app打开写入末尾<br> 输入输出<br> example：文本操作与二进制操作</p> 
</blockquote> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include&lt;fstream&gt;
using namespace std;

struct person
{
	char name[16];
	int number;
}me={"zhangsan",20220001},t,r;
int main()
{
	/*
	//打开文件 ios:: in打开供读取，out打开供写入,app打开写入末尾
	ofstream ofs;
	ofs.open("f1.txt", ios::out);
	//或者：ofstream ofs("f1.txt",ios::out)
	//关闭
	ofs.close();

	//输入输出
	ifstream ifs("f1.txt", ios::in);
	int n;
	ifs &gt;&gt; n;
	ifs.close();
	ofstream ofs("f1.txt", ios::out);
	int n = 123;
	ofs &lt;&lt; n; ofs.close();

	//块输入输出 ifstram&amp;read,ofstream&amp;write
	ifstream ifs("f1.txt", ios::in);
	int n;
	ifs.read((char*)&amp;n, sizeof(int));
	ifs.close();
	ofstream ofs("f1.txt", ios::out);
	int n = 123;
	ofs.write((char*)&amp;n, sizeof(n)); ofs.close();
	*/

	//example
	//文本操作
	ofstream f("a.txt", ios::out);
	f &lt;&lt; me.name &lt;&lt; " " &lt;&lt; me.number &lt;&lt; endl;
	f.close();
	ifstream f1("a.txt", ios::in);
	f1 &gt;&gt; t.name &gt;&gt; t.number;
	f1.close();
	cout &lt;&lt; t.name &lt;&lt; " " &lt;&lt; t.number &lt;&lt; endl;
	//二进制操作
	ofstream g("b.txt", ios::out|ios::binary);
	g.write((char*)&amp;me, sizeof(me));
	g.close();
	ifstream g1("b.txt", ios::in |ios::binary);
	g1.read((char*)&amp;r, sizeof(r));
	g1.close();
	cout &lt;&lt; r.name &lt;&lt; " " &lt;&lt; r.number &lt;&lt; endl;



	return 0;
}

// function library
out:
zhangsan 20220001
zhangsan 20220001</code></pre> 
<h4 id="%E2%85%A1%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88">Ⅱ文件指针</h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include&lt;fstream&gt;
using namespace std;

struct date
{
	int year, month, day;
};

int main()
{
	//seekg(streamoff off,ios::seek_dir dir) 读文件时修改FP
	//seekp(streamoff off,ios::seek_dir dir) 写文件时修改FP
	//off:偏移量，单位字节 dir:位置常量,ios:: beg起始,cur当前,end结尾

	//example
	int i,n;
	cin &gt;&gt; n;
	date* t=new date[n]; //动态分配内存
	for (i = 0; i &lt;n; i++)
	{
		t[i].year = 1900 + i;
		t[i].month = i % 12 + 1;
		t[i].day = 1;
	}
	ofstream fout("a.dat", ios::out | ios::binary);
	fout.write((char*)t, sizeof(date)*n);//这里t是指针，要写整个数组的大小
	fout.close();
	date t20, t50;
	ifstream fin("a.dat", ios::in | ios::binary);
	fin.seekg((sizeof(date) * 19, ios::beg));//指针便宜量
	fin.read((char*)&amp;t20, sizeof(date));
	fin.seekg(sizeof(date) * 29, ios::cur);
	fin.read((char*)&amp;t50, sizeof(date));
	fin.close();
	cout &lt;&lt; t20.year &lt;&lt; "-" &lt;&lt; t20.month &lt;&lt; "-" &lt;&lt; t20.day &lt;&lt; endl;
	cout &lt;&lt; t50.year &lt;&lt; "-" &lt;&lt; t50.month &lt;&lt; "-" &lt;&lt; t50.day &lt;&lt; endl;

	return 0;
}

// function library
out:
51
1900 - 1 - 1
1930 - 7 - 1</code></pre> 
<h2 id="%E5%9B%9B%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1">四、类和对象</h2> 
<h3 id="%E2%91%A0%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8">①类的创建和使用</h3> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

//类和对象
class complex
{
public:
    complex(double r = 0, double i = 0)
    {
        real = r;
        imag = i;
    }
    ~complex() {};//析构函数，撤销对象时自动调用
    complex mul(complex x)
    {
        double r = real * x.real - imag * x.imag;
        double i = real * x.imag + imag * x.real;
        return complex(r, i);
    }
    complex add(complex x)
    {
        return complex(real + x.real, imag + x.imag);
    }

    void output()
    {
        if (imag &gt;= 0)
        {
            cout &lt;&lt; "(" &lt;&lt; real &lt;&lt; "+" &lt;&lt; imag &lt;&lt; "i)" &lt;&lt; endl;
        }
        else
        {
            cout &lt;&lt; "(" &lt;&lt; real &lt;&lt; imag &lt;&lt; "i)" &lt;&lt; endl;
        }
    }
private:
    double real, imag;
};

int main()
{
    complex a(1.2, 2.3), b(5, -6.7), c, d;
    c = a.add(b); d = a.mul(b);
    c.output();
    d.output();
    return 0;
}
out:
(6.2 - 4.4i)
(21.41 + 3.46i)</code></pre> 
<h3 id="%E2%91%A1%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">②静态成员</h3> 
<blockquote> 
 <p>静态成员的声明：static<br> 访问静态成员：对象名 / 对象引用 + 点操作符号，classname + ::，类指针 + 箭头<br> 作用域与析构函数</p> 
</blockquote> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

//静态成员的声明：static
class book
{
public:
    book(const char* bookname);
    ~book();//析构函数
    static int getbooknum();//静态成员函数只能访问静态成员
private:
    char name[50];//书名
    static int booknum;//静态数据，不依赖对象而存在
};

//访问静态成员：对象名/对象引用+点操作符号，classname+::，类指针+箭头
book::book(const char* bookname)
{
    strcpy(this-&gt;name, bookname);//类指针+箭头
    booknum++;//对象产生，booknum增加
}
book::~book()
{
    booknum--;//对象撤销时，booknum减少
}
int book::booknum = 0;//初始化类的静态成员
int book::getbooknum()
{
    return booknum;
}
int main()
{
    cout &lt;&lt; "Thers is " &lt;&lt; book::getbooknum() &lt;&lt; " book." &lt;&lt; endl;
    {//块1
        book one("C++程序设计");//创建一个对象
        cout &lt;&lt; "After book one created,there is " &lt;&lt; one.getbooknum() &lt;&lt; " book." &lt;&lt; endl;//对象名+.
        {//块2
            book two("Python程序设计");
            cout &lt;&lt; "After book two created,there are " &lt;&lt; two.getbooknum() &lt;&lt; " books." &lt;&lt; endl;
        }//块2结束，自动撤销two(作用域)
        cout &lt;&lt; "After book two destroyed,there is " &lt;&lt; one.getbooknum() &lt;&lt; " book." &lt;&lt; endl;
    }//块1结束，自动撤销one
    cout &lt;&lt; "After book one destroyed,there is " &lt;&lt; book::getbooknum() &lt;&lt; " book." &lt;&lt; endl;
    return 0;
}

out:

Thers is 0 book.
After book one created,there is 1 book.
After book two created,there are 2 books.
After book two destroyed,there is 1 book.
After book one destroyed,there is 0 book.</code></pre> 
<h3 id="%E2%91%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">③构造函数</h3> 
<blockquote> 
 <p>带默认参数的构造函数<br> 复制构造函数（创建信息相同的对象）</p> 
</blockquote> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

class circle
{
public:
    //带默认参数的构造函数
    circle(double a = 5.0, double b = 5.0, double c = 5.0)//每个参数的类型都要写清楚
    {
        x = a;
        y = b;
        c &gt; 0 ? r = c : r = 5.0;//三目运算符
    }
    //复制构造函数（创建信息相同的对象）
    circle(circle&amp; c)
    {
        x = c.x; y = c.y; r = c.r;
    }
    ~circle() {};
    void print(circle &amp;c);
private:
    double x, y, r;
};
void circle::print(circle&amp; c)
{
    cout &lt;&lt; "x=" &lt;&lt; c.x &lt;&lt; "\ty=" &lt;&lt; c.y &lt;&lt; "\tr=" &lt;&lt; c.r&lt;&lt;endl;
}
int main()
{
    {
        circle a;//参数被设定为默认参数
        circle b(1.0);//只传第一个参数
        circle c(4.0, 5.0, 6.0);
        circle d(c);
        cout &lt;&lt; "a:"; a.print(a);
        cout &lt;&lt; "b:"; b.print(b);
        cout &lt;&lt; "c:"; c.print(c);
        cout &lt;&lt; "d:"; b.print(d);
    }
    return 0;
}
out:
a:x = 5   y = 5     r = 5
b : x = 1   y = 5     r = 5
c : x = 4   y = 5     r = 6
d : x = 4   y = 5     r = 6</code></pre> 
<h3 id="%E2%91%A3%E7%B1%BB%E7%9A%84%E5%A4%8D%E5%90%88">④类的复合</h3> 
<blockquote> 
 <p>成员对象在包含它的对象之前被建立<br> 成员函数的构造函数被大对象的构造函数调用<br> 大对象的成员函数对成员对象来说依然是外部函数，需要遵循访问规则，注意调用格式</p> 
</blockquote> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;
#define pi 3.14
class circle
{
public:
    //带默认参数的构造函数
    circle(double a = 5.0, double b = 5.0, double c = 5.0);//每个参数的类型都要写清楚
    ~circle();
    double area();
    void print();
private:
    double x, y, r;
};
//function library
circle::circle(double a, double b, double c)
{
    x = a;
    y = b;
    c &gt; 0 ? r = c : r = 5.0;
    cout &lt;&lt; "circle object start:x=" &lt;&lt; x &lt;&lt; "\ty=" &lt;&lt; y &lt;&lt; "\tr=" &lt;&lt; r &lt;&lt; endl;
}
circle::~circle()
{
    cout &lt;&lt; "circle object end:x=" &lt;&lt; x &lt;&lt; "\ty=" &lt;&lt; y &lt;&lt; "\tr=" &lt;&lt; r &lt;&lt; endl;
}
double circle::area()
{
    return pi * r * r;
}
void circle::print()
{
    cout &lt;&lt; "x=" &lt;&lt; x &lt;&lt; "\ty=" &lt;&lt; y &lt;&lt; "\tr=" &lt;&lt; r;
}
//创建column类
class column
{
public:
    column(double h = 5.0, double a = 5.0, double b = 5.0, double c = 5.0);
    ~column();
    double volume();
private:
    circle circle;//数据成员
    double height;
};
column::column(double h, double a, double b, double c)
    :circle(a, b, c)//为数据成员circle调用其构造函数，初始化列表
{
    h &gt; 0 ? height = h : height = 5.0;
    cout &lt;&lt; "coulumn object start : height = " &lt;&lt; height &lt;&lt; ",";
    circle.print();
    cout &lt;&lt; endl;
}
double column::volume()
{
    return height * circle.area();
}
column::~column()
{
    cout &lt;&lt; "column object end:height=" &lt;&lt; height &lt;&lt; ",";
    circle.print();
    cout &lt;&lt; endl;
}
int main()
{
    column obj(2.3, 3.4, 4.5, 5.6);
    cout &lt;&lt; "The volume of obj is" &lt;&lt; obj.volume() &lt;&lt; endl;
    return 0;
}
out:

circle object start : x = 3.4       y = 4.5   r = 5.6
coulumn object start : height = 2.3, x = 3.4       y = 4.5   r = 5.6
The volume of obj is226.482
column object end : height = 2.3, x = 3.4      y = 4.5   r = 5.6
circle object end : x = 3.4 y = 4.5   r = 5.6</code></pre> 
<h3 id="%E2%91%A4This%E6%8C%87%E9%92%88">⑤This指针</h3> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;
/*
class test
{
public:
    test(int n = 0)
    {
        data = n;//直接访问
    }
    void print()
    {
        cout &lt;&lt; "data=" &lt;&lt; this-&gt;data &lt;&lt; endl;//使用this指针访问
    }
private:
    int data;
};
*/
//静态成员函数没有维护this，访问非静态数据成员需要this
class test
{
public:
    test(int n = 0) { data = n; }
    test&amp; setdata(int n)//返回值类型
    {
        data = n;
        return *this;
    }
    void print()
    {
        cout &lt;&lt; "data=" &lt;&lt; data &lt;&lt; "!" &lt;&lt; endl;
    }
private:
    int data;
};
int main()
{
    test obj;
    cout &lt;&lt; "obj: ";
    obj.setdata(100).print();//函数连续调用，因为setdata返回的是test&amp;类型
    return 0;
}
out:

obj: data=100!</code></pre> 
<h3 id="%E2%91%A5%E5%8F%8B%E5%85%83">⑥友元</h3> 
<h4 id="%E2%85%A0%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0">Ⅰ友元函数</h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;
//友元函数具有访问类的所有成员的权限，friend+函数原型
class triangle
{
    friend void seta(triangle&amp; t, int n);//声明友元函数
public:
    triangle(int x = 5, int y = 5, int z = 5);
    void print();
private:
    int a, b, c;
};
triangle::triangle(int x, int y, int z)
{
    if (x + y &gt; z &amp;&amp; x + z &gt; y &amp;&amp; y + z &gt; x)
    {
        a = x; b = y; c = z;
    }
    else
    {
        a = b = c = 5;
    }
}
void triangle::print()
{
    cout &lt;&lt; "triangle:" &lt;&lt; a &lt;&lt; "," &lt;&lt; b &lt;&lt; "," &lt;&lt; c &lt;&lt; endl;
}
void seta(triangle&amp; t, int n)
{
    t.a = n;//访问对象的私有成员
}
int main()
{
    triangle t;
    t.print();
    seta(t, 10);
    t.print();
    return 0;
}
out:

triangle:5, 5, 5
triangle : 10, 5, 5</code></pre> 
<h4 id="%E2%85%A1%E5%8F%8B%E5%85%83%E7%B1%BB">Ⅱ友元类</h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;
//一个类的友元类所有成员函数都有访问类的所有成员的权限,friend+class+类名
//友元的声明是单方面不传递的
class B;
class A
{
public:
    void setB(B&amp; b, int m);
    void print(B&amp; b);
};
class B
{
    friend class A;//声明友元，A可以访问B中所有成员
private:
    int data;
};
void A::setB(B&amp; b, int m)
{
    b.data = m;
}
void A::print(B&amp; b)
{
    //访问私有成员
    cout &lt;&lt; "Thea private data of class B:" &lt;&lt; b.data &lt;&lt; endl;
}
int main()
{
    A a;
    B b;
    a.setB(b, 10);//调用A的成员函数修改类B的对象b的私有数据
    a.print(b);//调用A的成员函数访问b的私有数据
    
    return 0;
}
out:
Thea private data of class B :10</code></pre> 
<h2 id="%E4%BA%94%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">五、运算符重载</h2> 
<h3 id="%E2%91%A0%E5%8E%9F%E7%90%86">①原理</h3> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;
//操作预定义数据对象的方式，自定义的对象操作方式，operator&lt;运算符&gt;
//.,*,::,?:,sizeof 不能被重载
class complex
{
public:
    complex(double = 0.0, double = 0.0);
    complex operator+(const complex&amp;)const;//常量成员函数，即该函数不会修改类的任何成员变量。
    complex&amp; operator=(const complex&amp;);
    void print() const;
private:
    double real;
    double imaginary;
};
complex::complex(double r, double i)
{
    real = r; imaginary = i;
}
complex complex::operator+(const complex&amp; operand2)const
{
    complex sum;
    sum.real = real + operand2.real;
    sum.imaginary = imaginary + operand2.imaginary;
    return sum;
}
complex&amp; complex::operator=(const complex&amp; right)
{
    real = right.real;
    imaginary = right.imaginary;
    return *this;
}
void complex::print()const
{
    cout &lt;&lt; "(" &lt;&lt; real &lt;&lt; "," &lt;&lt; imaginary &lt;&lt; ")";
}
int main()
{
    complex x, y(4.3, 8.2), z(3.3, 1.1);
    x = y + z;//x.operator=(y.operator+(z));赋值运算符
    cout &lt;&lt; "x=y+z:\n";
    x.print();
    cout &lt;&lt; "="; y.print();
    cout &lt;&lt; "+"; z.print();
    cout &lt;&lt; endl;
    return 0;
}
out:

x = y + z :
    (7.6, 9.3) = (4.3, 8.2) + (3.3, 1.1)</code></pre> 
<h3 id="%E2%91%A1%E6%96%B9%E5%BC%8F">②方式</h3> 
<h4 id="%E2%85%A0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">Ⅰ成员函数重载</h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;
//成员函数方式重载运算符
//重载！为成员函数
class mystring
{
public:
    mystring(const char* m = NULL);//默认构造函数
    ~mystring();
    //运算符重载成员函数原型
    bool operator!();
private:
    char* str;
};
mystring::mystring(const char* m)
{
    if (m == NULL)
    {
        str == NULL;
    }
    else
    {
        int len = strlen(m) + 1;//留一个放"\0"
        str = new char[len];
        strcpy_s(str, len, m);
    }
}
mystring::~mystring()
{
    if (str != NULL)
        delete[]str;
}
//实现运算符重载函数
bool mystring::operator!()
{
    if (str == NULL || strlen(str) == 0)
        return true;
    return false;
}
int main()
{
    mystring s1, s2("some string");
    if (!s1)
        cout &lt;&lt; "s1 is NULL!" &lt;&lt; endl;
    else
        cout &lt;&lt; "s1 is not NULL!" &lt;&lt; endl;
    if (!s2)
        cout &lt;&lt; "s2 is NULL!" &lt;&lt; endl;
    else
        cout &lt;&lt; "s2 is not NULL!" &lt;&lt; endl;
    return 0;
}
out:

s1 is NULL!
s2 is not NULL!</code></pre> 
<h4 id="%E2%85%A1%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">Ⅱ友元函数重载</h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

class mystring
{
public:
    mystring(const char* m = NULL);//默认构造函数
    ~mystring();
    friend bool operator!(mystring&amp;s);
private:
    char* str;
};
mystring::mystring(const char* m)
{
    if (m == NULL)
    {
        str == NULL;
    }
    else
    {
        int len = strlen(m) + 1;//留一个放"\0"
        str = new char[len];
        strcpy_s(str, len, m);
    }
}
mystring::~mystring()
{
    if (str != NULL)
        delete[]str;
}
//实现运算符重载函数
bool operator!(mystring&amp; s)
{
    if (s.str == NULL || strlen(s.str) == 0)
        return true;
    return false;
}
int main()
{
    mystring s1, s2("some string");
    if (!s1)
        cout &lt;&lt; "s1 is NULL!" &lt;&lt; endl;
    else
        cout &lt;&lt; "s1 is not NULL!" &lt;&lt; endl;
    if (!s2)
        cout &lt;&lt; "s2 is NULL!" &lt;&lt; endl;
    else
        cout &lt;&lt; "s2 is not NULL!" &lt;&lt; endl;
    return 0;
}
out:

s1 is NULL!
s2 is not NULL!</code></pre> 
<h3 id="%E2%91%A2%E5%8D%95%E7%9B%AE%E4%B8%8E%E5%8F%8C%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">③单目与双目运算符重载</h3> 
<h4 id="%E2%85%A0%E5%8D%95%E7%9B%AE%EF%BC%88%E7%9B%AE%E8%A1%A8%E7%A4%BA%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%89">Ⅰ单目（目表示操作数）</h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

//重载运算符前自增++，返回值*this，类型complex&amp;
class complex
{
public:
    complex(double = 0.0, double = 0.0);
    complex&amp; operator++();//成员函数形式
    void print()const;
private:
    double real;
    double imaginary;
};
complex::complex(double r, double i)
{
    real = r;
    imaginary = i;
}
void complex::print()const
{
    cout &lt;&lt; "(" &lt;&lt; real &lt;&lt; "," &lt;&lt; imaginary &lt;&lt; ")";
}
complex&amp; complex::operator++()
{
    this-&gt;real += 1;
    return *this;
}
int main()
{
    complex y(4.3, 8.2), x;
    x = ++y;//x=y.operator++()
    cout &lt;&lt; "y:"; y.print();
    cout &lt;&lt; "\tx:"; x.print();
    cout &lt;&lt; endl;
    return 0;
}
out:

y:(5.3,8.2)     x:(5.3,8.2)</code></pre> 
<h4 id="%E2%85%A1%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD">Ⅱ流插入和流提取运算符的重载</h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

//如何实现用cout输出自定义类型的对象,重载&lt;&lt;和&gt;&gt;
class mystring
{
    //重载流插入和流提取函数
    friend ostream&amp; operator&lt;&lt;(ostream&amp; output, mystring&amp; s);
    friend istream&amp; operator&gt;&gt;(istream&amp; input, mystring&amp; s);
public:
    mystring(const char* m = NULL);
    ~mystring();
private:
    char* str;
};
mystring::mystring(const char* m)
{
    if (m == NULL)
        str == NULL;
    else
    {
        int len = strlen(m) + 1;
        str = new char[len];
        strcpy_s(str, len, m);
    }
}
mystring::~mystring()
{
    if (str != NULL)
        delete[]str;
}
//定义运算符&lt;&lt;重载函数
ostream&amp; operator&lt;&lt;(ostream&amp; output, mystring&amp; s)
{
    output &lt;&lt; s.str;
    return output;
}
//定义运算符&gt;&gt;重载函数
istream&amp; operator&gt;&gt;(istream&amp; input, mystring&amp; s)
{
    char temp[1000];
    cin &gt;&gt; temp;
    if (s.str)delete[]s.str;//释放内存
    int len = strlen(temp) + 1;//"\0"
    s.str = new char[len];
    strcpy_s(s.str, len, temp);
    return input;
}
int main()
{
    mystring s1, s2;
    cout &lt;&lt; "Please input two strings" &lt;&lt; endl;
    cin &gt;&gt; s1 &gt;&gt; s2;
    cout &lt;&lt; "Output is:" &lt;&lt; endl;
    cout &lt;&lt; "s1——" &lt;&lt; s1 &lt;&lt; endl &lt;&lt; "s2——" &lt;&lt; s2 &lt;&lt; endl;
    return 0;
}
output:

Please input two strings
dager
fewre
Output is :
s1——dager
s2——fewre</code></pre> 
<h4 id="%E2%85%A2%E5%8F%8C%E7%9B%AE">Ⅲ双目</h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

//友元函数重载运算符+=
class mystring
{
    friend mystring&amp; operator+=(mystring&amp; x, mystring&amp; y);
public:
    mystring(const char* m = NULL);
    ~mystring();
    void print() const;
private:
    char* str;
};
mystring::mystring(const char* m)
{
    if (m == NULL)
        str == NULL;
    else
    {
        int len = strlen(m) + 1;
        str = new char[len];
        strcpy_s(str, len, m);
    }
}
mystring::~mystring()
{
    if (str != NULL)
        delete[]str;
}
void mystring::print()const
{
    cout &lt;&lt; str&lt;&lt;endl;
}
mystring&amp; operator+=(mystring&amp; x, mystring&amp; y)
{
    int len = strlen(x.str) + strlen(y.str) + 1;
    char* temp = new char[len];
    strcpy_s(temp, len, x.str);
    strcat_s(temp, len, y.str);
    delete[]x.str;
    x.str = temp;
    return x;
}
int main()
{
    mystring s1("hello"), s2("world");
    s1 += s2;
    s1.print();
    return 0;
}
output:
helloworld

</code></pre> 
<h4 id="%E2%85%A3%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96">Ⅳ类型转化</h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;
//类型转换，必须是类的非静态成员函数，不是友元函数，不能指定返回类型（其实已经指定了）
//operator+类型名 (int)obj等价于obj.operator int()
class Fraction {
private:
    int numerator;
    int denominator;

public:
    Fraction(int num, int den) : numerator(num), denominator(den) {}

    // 将 Fraction 类型转换为 double 类型
    operator double() const {
        return (double)numerator / denominator;
    }
};
int main()
{
    Fraction f(3, 4);
    double d = f; // 将 Fraction 类型转换为 double 类型
    cout &lt;&lt; d &lt;&lt; endl;
    return 0;
}
out:
0.75</code></pre> 
<h2 id="%E5%85%AD%E3%80%81%E7%BB%A7%E6%89%BF%E6%B4%BE%E7%94%9F%E5%A4%9A%E6%80%81">六、继承派生多态</h2> 
<h3 id="%E2%91%A0%E7%BB%A7%E6%89%BF">①继承</h3> 
<h4 id="%E2%85%A0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E5%AE%9A%E4%B9%89">Ⅰ成员函数的重定义</h4> 
<pre><code class="language-cpp">
#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;
//派生类重定义基类成员函数
class child
{
public:
    void showinfo()
    {
        cout &lt;&lt; "I'm child" &lt;&lt; endl;
    }
};
class parent:public child
{
public:
    void showinfo()
    {
        child::showinfo();
        cout &lt;&lt; "I'm parent" &lt;&lt; endl;
    }
};
int main()
{
    parent p;
    p.showinfo();
    return 0;
}
out:
I'm child
I'm parent</code></pre> 
<h4 id="%E2%85%A1%E7%B1%BB%E6%8C%87%E9%92%88">Ⅱ类指针</h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;
//类指针
class media
{
public:
    media(const char* n, const char* c);
    ~media();
    const char* getname();
    const char* getcompany();
private:
    char* name;
    char* company;
};
media::media(const char* n, const char* c)
{
    name = new char[strlen(n) + 1];
    strcpy(name, n);
    company = new char[strlen(c) + 1];
    strcpy(company, c);
}
media::~media()
{
    if (name != NULL) delete[]name;
    if (company != NULL) delete[]company;
}
const char* media::getname()
{
    return name;
}
const char* media::getcompany()
{
    return company;
}
class audiomedia :public media
{
public:
    audiomedia(const char* n, const char* c, const char* s);
    ~audiomedia();
    const char* getsinger();
private:
    char* singer;
};
audiomedia::audiomedia(const char* n, const char* c, const char* s) :media(n, c)//调用基类的构造函数
{
    singer = new char[strlen(s) + 1];
    strcpy(singer, s);
}
audiomedia::~audiomedia()
{
    if (singer != NULL) delete[]singer;
}
const char* audiomedia::getsinger()
{
    return singer;
}
int main()
{
    media medium("slumdog millionaire", "celador films");
    audiomedia audio("the color of my love", "columbia", "celine dion");
    media* mptr;
    mptr = &amp;medium;
    cout &lt;&lt; "Accessing media object through meida*" &lt;&lt; endl;
    cout &lt;&lt; "name:" &lt;&lt; mptr-&gt;getname() &lt;&lt; endl;
    cout &lt;&lt; "company:" &lt;&lt; mptr-&gt;getcompany() &lt;&lt; endl;
    mptr = &amp;audio;
    cout &lt;&lt; "Accessing auidomedia object through media*" &lt;&lt; endl;
    cout &lt;&lt; "name:" &lt;&lt; mptr-&gt;getname() &lt;&lt; endl;
    cout &lt;&lt; "company:" &lt;&lt; mptr-&gt;getcompany() &lt;&lt; endl;
    cout &lt;&lt; "singer:" &lt;&lt; ((audiomedia*)mptr)-&gt;getsinger()&lt;&lt;endl;//强制类型转换
    return 0;
}
out:
Accessing media object through meida*
name : slumdog millionaire
company : celador films
Accessing auidomedia object through media*
name : the color of my love
company : columbia
singer : celine dion
</code></pre> 
<h3 id="%E2%91%A1%E5%A4%9A%E6%80%81">②多态</h3> 
<h4 id="%E2%85%A0%E8%99%9A%E5%87%BD%E6%95%B0">Ⅰ虚函数</h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

class media
{
public:
    media(const char* n, const char* c);
    ~media();
    virtual void showinfo();
private:
    char* name;
    char* company;
};
media::media(const char* n, const char* c)
{
    name = new char[strlen(n) + 1];
    strcpy(name, n);
    company = new char[strlen(c) + 1];
    strcpy(company, c);
}
media::~media()
{
    if (name != NULL) delete[]name;
    if (company != NULL) delete[]company;
}
void media::showinfo()
{
    cout &lt;&lt; "name:" &lt;&lt; name &lt;&lt; endl;
    cout &lt;&lt; "company:" &lt;&lt; company &lt;&lt; endl;
}
class audiomedia :public media
{
public:
    audiomedia(const char* n, const char* c, const char* s);
    ~audiomedia();
    void showinfo();
private:
    char* singer;
};
audiomedia::audiomedia(const char* n, const char* c, const char* s) :media(n, c)//调用基类的构造函数
{
    singer = new char[strlen(s) + 1];
    strcpy(singer, s);
}
audiomedia::~audiomedia()
{
    if (singer != NULL) delete[]singer;
}
void audiomedia::showinfo()
{
    media::showinfo();//调用被重定义的函数
    cout &lt;&lt; "singer:" &lt;&lt; singer &lt;&lt;endl;
}
int main()
{
    media* mptr;
    media medium("slumdog millionaire", "celador films");
    audiomedia audio("the color of my love", "columbia", "celine dion");
    mptr = &amp;medium;
    mptr-&gt;showinfo();//基类指针指向基类对象
    cout &lt;&lt; endl;//基类指针调用成员函数，动态绑定
    mptr = &amp;audio;//基类指针指向派生类对象
    mptr-&gt;showinfo();//基类指针调用成员函数，动态绑定
    return 0;
}
name:slumdog millionaire
company : celador films

name : the color of my love
company : columbia
singer : celine dion
</code></pre> 
<h4 id="%E2%85%A1%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0">Ⅱ抽象基类与纯虚函数</h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#define PI 3.14
using namespace std;
//纯虚函数：没有函数体，初始化为0
//抽象类，包含纯虚函数不能实例化对象
class shape//抽象基类
{
public:
    virtual double area()const = 0;
    virtual void show()const = 0;
};
class circle :public shape
{
public:
    circle(double = 0.0, double = 0.0, double = 1.0);
    double area()const;
    void show()const;
private:
    double x, y;
    double r;
};
circle::circle(double a, double b, double c)
{
    x = a; y = b; r = c;
}
double circle::area()const
{
    return PI * r * r;
}
void circle::show()const
{
    cout &lt;&lt; "I'm a circle:";
}
class rectangle :public shape
{
public:
    rectangle(double = 1.0, double = 1.0);
    double area()const;
    void show()const;
private:
    double length;
    double width;
};
rectangle::rectangle(double a, double b)
{
    length = a; width = b;
}
double rectangle::area()const
{
    return length * width;
}
void rectangle::show()const
{
    cout &lt;&lt; "I'm a rectangle:";
}
void callarea(shape&amp;obj)
{
    obj.show();
    cout &lt;&lt; "area=" &lt;&lt; obj.area() &lt;&lt; endl;
}
int main()
{
    circle cir(0.0, 0.0, 2.5);
    rectangle rec(2.4, 5.3);
    callarea(cir);
    callarea(rec);
    return 0;
}
out:
I'm a circle:area=19.625
I'm a rectangle:area=12.72</code></pre> 
<h4 id="%E2%85%A2%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">Ⅲ虚析构函数</h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cstring&gt;
#define PI 3.14
using namespace std;
class employee
{
public:
    employee()
    {
        cout &lt;&lt; "Employee begin!" &lt;&lt; endl;
    }
    virtual ~employee()
    {
        cout &lt;&lt; "Employee end!" &lt;&lt; endl;
    }
};
class programmer :public employee
{
public:
    programmer(char* str)
    {
        cout &lt;&lt; "Programmer begin!" &lt;&lt; endl;
        name = new char[strlen(str) + 1];
        strcpy(name, str);
    }
    ~programmer()
    {
        delete[]name;
        cout &lt;&lt; "programmer end!" &lt;&lt; endl;
    }
private:
    char* name;
};
class accountant :public employee
{
public:
    accountant(int n)
    {
        cout &lt;&lt; "accountant begin!" &lt;&lt; endl;
        age = n;
    }
    ~accountant()
    {
        cout &lt;&lt; "accountant end!" &lt;&lt; endl;
    }
private:
    int age;
};

int main()
{
    int no;
    employee* ptr[100], * tptr;//声明储存雇员信息的数组
    int Enum = 0;
    char name[100];
    int age;
    for (int i = 0; i &lt; 100; i++)
    {
        ptr[i] = NULL;
    }
    cout &lt;&lt; "Input employees' info:" &lt;&lt; endl;
    cout &lt;&lt; "1---Programmer" &lt;&lt; endl
        &lt;&lt; "2---Accoutant" &lt;&lt; endl
        &lt;&lt; "0--exit" &lt;&lt; endl;
    cin &gt;&gt; no;
    while (no)
    {
        switch (no)
        {
        case 1:
            cout &lt;&lt; "Input name:";
            cin &gt;&gt; name;
            tptr = new programmer(name);
            ptr[Enum++] = tptr;
            break;
        case 2:
            cout &lt;&lt; "Input age:";
            cin &gt;&gt; age;
            tptr = new accountant(age);
            ptr[Enum++] = tptr;
            break;
        default:
            cout &lt;&lt; "It's over" &lt;&lt; endl;
        };
        cout &lt;&lt; "Input another employee's info:" &lt;&lt; endl;
        cout &lt;&lt; "1---Programmer" &lt;&lt; endl
            &lt;&lt; "2---Accountant" &lt;&lt; endl
            &lt;&lt; "0---exit" &lt;&lt; endl;
        cin &gt;&gt; no;
    }
    //撤销所有对象
    for (int i = 0; i &lt; Enum; i++)
    {
        delete ptr[i];
    }
    return 0;
}
out:
Input employees' info:
1-- - Programmer
2-- - Accoutant
0--exit
1
Input name : swx
Employee begin!
Programmer begin!
Input another employee's info:
1-- - Programmer
2-- - Accountant
0-- - exit
2
Input age : 12
Employee begin!
accountant begin!
Input another employee's info:
1-- - Programmer
2-- - Accountant
0-- - exit
0
programmer end!
Employee end!
accountant end!
Employee end!</code></pre> 
<h3 id="%E2%91%A2STL">③STL</h3> 
<h4 id="%E2%85%A0%E5%8A%A8%E6%80%81%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86https%3A%2F%2Fwww.educoder.net%2Ftasks%2Fp4imnbvy%2F887783%2Fok8rac4vzhbx%3FcoursesId%3Dp4imnbvy">Ⅰ动态学生信息管理<a class="link-info" href="https://www.educoder.net/tasks/p4imnbvy/887783/ok8rac4vzhbx?coursesId=p4imnbvy" rel="nofollow" title="https://www.educoder.net/tasks/p4imnbvy/887783/ok8rac4vzhbx?coursesId=p4imnbvy">https://www.educoder.net/tasks/p4imnbvy/887783/ok8rac4vzhbx?coursesId=p4imnbvy</a></h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
using namespace std;

class Student {
public:
    string name;
    int score;

    Student(string n, int s) {
        name = n;
        score = s;
    }
};

vector&lt;Student&gt; studentTable;

void addOrUpdateRecord(string name, int score)
{
    bool found = false;
    for (int i = 0; i &lt; studentTable.size(); i++) {
        if (studentTable[i].name == name) {
            studentTable[i].score = score;
            found = true;
            break;
        }
    }
    if (!found) {
        Student newStudent(name, score);
        studentTable.push_back(newStudent);
    }
}

void deleteRecord(string name) {
    for (int i = 0; i &lt; studentTable.size(); i++) {
        if (studentTable[i].name == name) {
            studentTable.erase(studentTable.begin() + i);
            break;
        }
    }
}

void printTable() {
    if (studentTable.empty()) {
        cout &lt;&lt; "[空]" &lt;&lt; endl;
    }
    else {
        for (int i = 0; i &lt; studentTable.size(); i++) {
            cout &lt;&lt; studentTable[i].name &lt;&lt; " " &lt;&lt; studentTable[i].score &lt;&lt; endl;
        }
    }
}

bool compareScore(Student s1, Student s2) {
    return s1.score &gt; s2.score;
}

void sortTable() {
    sort(studentTable.begin(), studentTable.end(), compareScore);
}
int main()
{
    string input;
    while (getline(cin, input)) {
        if (input[0] == 'A') {
            char name[10];
            int score;
            sscanf(input.c_str(), "A %s %d", name, &amp;score);
            addOrUpdateRecord(name, score);
        }
        else if (input[0] == 'R') {
            char name[10];
            sscanf(input.c_str(), "R %s", name);
            deleteRecord(name);
        }
        else if (input[0] == 'P') {
            printTable();
        }
        else if (input[0] == 'S') {
            sortTable();
        }
    }
}</code></pre> 
<h4 id="%E2%85%A1%E8%BF%98%E5%8E%9F%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5https%3A%2F%2Fwww.educoder.net%2Ftasks%2Fp4imnbvy%2F887783%2Fyf2swgkio7ma%3FcoursesId%3Dp4imnbvy">Ⅱ还原键盘输入<a class="link-info" href="https://www.educoder.net/tasks/p4imnbvy/887783/yf2swgkio7ma?coursesId=p4imnbvy" rel="nofollow" title="https://www.educoder.net/tasks/p4imnbvy/887783/yf2swgkio7ma?coursesId=p4imnbvy">https://www.educoder.net/tasks/p4imnbvy/887783/yf2swgkio7ma?coursesId=p4imnbvy</a></h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;list&gt;
using namespace std;

int main()
{
    //读取输入，解析并输出复原后的输出
    string input;
    string output;

    while (getline(cin, input)) {
        list&lt;char&gt; chars;
        auto it = chars.begin();

        for (char c : input) {
            if (c == '&lt;') {
                if (it != chars.begin()) {
                    it--;
                }
            }
            else if (c == '&gt;') {
                if (it != chars.end()) {
                    it++;
                }
            }
            else if (c == '[') {
                it = chars.begin();
            }
            else if (c == ']') {
                it = chars.end();
            }
            else {
                it = chars.insert(it, c);
                it++;
            }
        }

        for (char c : chars) {
            output += c;
        }
        cout &lt;&lt; output &lt;&lt; endl;
        output.clear();
    }

    return 0;
}
</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/68d301326621421228692fea3d457899/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux安装ErLang语言（图文教程详细版）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6a6437a9b20029f7eb440da654f6712e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用Python构造ARIMA模型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>