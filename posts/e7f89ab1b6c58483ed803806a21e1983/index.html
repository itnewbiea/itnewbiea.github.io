<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis 缓存中间件 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis 缓存中间件" />
<meta property="og:description" content="Redis 缓存中间件 文章目录 Redis 缓存中间件为什么需要缓存中间件？Redis 简介特性单线程 Redis存储机制Snapshot 工作原理AOF 工作原理存储模式性能和安全数据结构及使用场景String 字符串Hash 哈希List 列表Set 集合ZSET 有序集合 技术总结REFERENCES 手机用户请横屏获取最佳阅读体验，REFERENCES中是本文参考的链接，如需要链接和更多资源，可以关注公众号后回复『知识星球』加入并获取长期知识分享服务。
为什么需要缓存中间件？ 一个网站演变的过程中，用户量的增加引起了并发量提高，如果不做处理，则频繁的查询数据库，结果是页面显示的慢，服务器、数据库不堪重负。如果网站页面所展示的数据的更新不是特别频繁，想提高页面显示的速度，减轻服务器的负担，此时应该考虑使用缓存。
所以，缓存是介于应用程序和物理数据源之间，其作用是为了降低应用程序对物理数据源访问的频次，从而提高了应用的运行性能。缓存内的数据是对物理数据源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件会同步缓存和物理数据源的数据。
使用缓存有一个原则：越高层次的缓存效果越好。 推荐使用页面缓存。
Redis 简介 redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)和zset(有序集合)、Hash(哈希类型的映射表)。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。
在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。
Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，Python，Ruby，Perl，PHP客户端，使用很方便。
特性 速度快
数据存在内存中
C语言编写，5W 行代码
单线程数据模型
持久化
多种数据结构
支持多种编辑语言
功能丰富
主从复制（数据一致性）
高可用
哨兵模式 单线程 为什么这么快？
纯内存操作
非阻塞IO
避免线程切换和竞态消耗
如何使用？
拒绝长（慢）命令，如 keys、flushall。
一次只运行一个命令
Redis存储机制 Redis存储机制分成两种 Snapshot和 AOF。无论是哪种机制，Redis都是将数据存储在内存中。
Snapshot 工作原理 是将数据先存储在内存，然后当数据累计达到某些设定的伐值的时候，就会触发一次DUMP操作，将变化的数据一次性写入数据文件（RDB文件）。
AOF 工作原理 是将数据也是先存在内存，但是在存储的时候会使用调用 fsync 来完成对本次写操作的日志记录，这个日志揭露文件其实是一个基于 Redis 网络交互协议的文本文件。AOF 调用 fsync 也不是说全部都是无阻塞的，在某些系统上可能出现 fsync 阻塞进程的情况，对于这种情况可以通过配置修改，但默认情况不要修改。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e7f89ab1b6c58483ed803806a21e1983/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-28T23:30:00+08:00" />
<meta property="article:modified_time" content="2022-05-28T23:30:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis 缓存中间件</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Redis__0"></a>Redis 缓存中间件</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Redis__0" rel="nofollow">Redis 缓存中间件</a></li><li><ul><li><a href="#_5" rel="nofollow">为什么需要缓存中间件？</a></li><li><a href="#Redis__13" rel="nofollow">Redis 简介</a></li><li><ul><li><a href="#_21" rel="nofollow">特性</a></li><li><a href="#_45" rel="nofollow">单线程</a></li></ul> 
   </li><li><a href="#Redis_61" rel="nofollow">Redis存储机制</a></li><li><ul><li><a href="#Snapshot__65" rel="nofollow">Snapshot 工作原理</a></li><li><a href="#AOF__69" rel="nofollow">AOF 工作原理</a></li><li><a href="#_76" rel="nofollow">存储模式性能和安全</a></li><li><a href="#_99" rel="nofollow">数据结构及使用场景</a></li><li><ul><li><a href="#String__108" rel="nofollow">String 字符串</a></li><li><a href="#Hash__114" rel="nofollow">Hash 哈希</a></li><li><a href="#List__146" rel="nofollow">List 列表</a></li><li><a href="#Set__178" rel="nofollow">Set 集合</a></li><li><a href="#ZSET__208" rel="nofollow">ZSET 有序集合</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_243" rel="nofollow">技术总结</a></li><li><a href="#REFERENCES_246" rel="nofollow">REFERENCES</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<blockquote> 
 <p>手机用户请<code>横屏</code>获取最佳阅读体验，<code>REFERENCES</code>中是本文参考的链接，如需要链接和更多资源，可以关注公众号后回复『知识星球』加入并获取长期知识分享服务。</p> 
</blockquote> 
<h3><a id="_5"></a>为什么需要缓存中间件？</h3> 
<p>一个网站演变的过程中，用户量的增加引起了并发量提高，如果不做处理，则频繁的查询数据库，结果是页面显示的慢，服务器、数据库不堪重负。如果网站页面所展示的数据的更新不是特别频繁，想提高页面显示的速度，减轻服务器的负担，此时应该考虑使用缓存。</p> 
<p>所以，缓存是介于应用程序和物理数据源之间，其作用是为了降低应用程序对物理数据源访问的频次，从而提高了应用的运行性能。缓存内的数据是对物理数据源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件会同步缓存和物理数据源的数据。</p> 
<p>使用缓存有一个原则：<strong>越高层次的缓存效果越好</strong>。 推荐使用页面缓存。</p> 
<h3><a id="Redis__13"></a>Redis 简介</h3> 
<p>redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)和zset(有序集合)、Hash(哈希类型的映射表)。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p> 
<p>在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p> 
<p>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，Python，Ruby，Perl，PHP客户端，使用很方便。</p> 
<h4><a id="_21"></a>特性</h4> 
<blockquote> 
 <p>速度快</p> 
</blockquote> 
<ul><li> <p>数据存在内存中</p> </li><li> <p>C语言编写，5W 行代码</p> </li><li> <p>单线程数据模型</p> </li></ul> 
<blockquote> 
 <p>持久化</p> 
</blockquote> 
<ul><li> <p>多种数据结构</p> </li><li> <p>支持多种编辑语言</p> </li><li> <p>功能丰富</p> </li><li> <p>主从复制（数据一致性）</p> </li></ul> 
<blockquote> 
 <p>高可用</p> 
</blockquote> 
<ul><li>哨兵模式</li></ul> 
<h4><a id="_45"></a>单线程</h4> 
<blockquote> 
 <p>为什么这么快？</p> 
</blockquote> 
<ul><li> <p>纯内存操作</p> </li><li> <p>非阻塞IO</p> </li><li> <p>避免线程切换和竞态消耗</p> </li></ul> 
<blockquote> 
 <p>如何使用？</p> 
</blockquote> 
<ul><li> <p>拒绝长（慢）命令，如 keys、flushall。</p> </li><li> <p>一次只运行一个命令</p> </li></ul> 
<h3><a id="Redis_61"></a>Redis存储机制</h3> 
<blockquote> 
 <p>Redis存储机制分成两种 Snapshot和 AOF。无论是哪种机制，Redis都是将数据存储在内存中。</p> 
</blockquote> 
<h4><a id="Snapshot__65"></a>Snapshot 工作原理</h4> 
<p>是将数据先存储在内存，然后当数据累计达到某些设定的伐值的时候，就会触发一次DUMP操作，将变化的数据一次性写入数据文件（RDB文件）。</p> 
<h4><a id="AOF__69"></a>AOF 工作原理</h4> 
<p>是将数据也是先存在内存，但是在存储的时候会使用调用 fsync 来完成对本次写操作的日志记录，这个日志揭露文件其实是一个基于 Redis 网络交互协议的文本文件。AOF 调用 fsync 也不是说全部都是无阻塞的，在某些系统上可能出现 fsync 阻塞进程的情况，对于这种情况可以通过配置修改，但默认情况不要修改。</p> 
<ul><li>AOF 最关键的配置就是关于调用 fsync 追加日志文件的频率，有两种预设频率，always 每次记录进来都添加，everysecond 每秒添加一次。两个配置各有所长。</li><li>由于是采用日志追加的方式来持久化数据，所以引出了第二个日志的概念：rewrite。</li></ul> 
<h4><a id="_76"></a>存储模式性能和安全</h4> 
<blockquote> 
 <p>性能</p> 
</blockquote> 
<p>Snapshot 方式的性能是要明显高于 AOF 方式的，原因有两点：</p> 
<ul><li>采用2进制方式存储数据，数据文件比较小，加载快速。</li><li>存储的时候是按照配置中的 save 策略来存储，每次都是聚合很多数据批量存储，写入的效率很好。</li></ul> 
<p>而 AOF 则一般都是工作在实时存储或者准实时模式下。相对来说存储的频率高，效率却偏低。</p> 
<blockquote> 
 <p>数据安全</p> 
</blockquote> 
<p>AOF 数据安全性高于 Snapshot 存储，原因：</p> 
<p>Snapshot 存储是基于累计批量的思想，也就是说在允许的情况下，累计的数据越多那么写入效率也就越高，但数据的累计是靠时间的积累完成的，那么如果在长时间数据不写入 RDB，但 Redis 又遇到了崩溃，那么没有写入的数据就无法恢复了，但是 AOF 方式偏偏相反，根据 AOF 配置的存储频率的策略可以做到最少的数据丢失和较高的数据恢复能力。<br> 说完了性能和安全，这里不得不提的就是在 Redis 中的 Rewrite 的功能，AOF 的存储是按照记录日志的方式去工作的，那么成千上万的数据插入必然导致日志文件的扩大，Redis这个时候会根据配置合理触发Rewrite操作，所谓 Rewrite 就是将日志文件中的所有数据都重新写到另外一个新的日志文件中，但是不同的是，对于老日志文件中对于Key的多次操作，只保留最终的值的那次操作记录到日志文件中，从而缩小日志文件的大小。这里有两个配置需要注意：</p> 
<ul><li><code>auto-aof-rewrite-percentage 100</code> （当前写入日志文件的大小占到初始日志文件大小的某个百分比时触发Rewrite）</li><li><code>auto-aof-rewrite-min-size 64mb</code> （本次Rewrite最小的写入数据）</li></ul> 
<p>两个条件需要同时满足。</p> 
<h4><a id="_99"></a>数据结构及使用场景</h4> 
<p><img src="https://images2.imgbox.com/5e/18/i1PO4ep7_o.png" alt="数据结构"></p> 
<blockquote> 
 <p>存储</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/79/95/hMxTGLfq_o.png" alt="存储"></p> 
<h5><a id="String__108"></a>String 字符串</h5> 
<blockquote> 
 <p>缓存、计数器、分布式锁、分布式ID</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/61/eb/UlzoAmCM_o.png" alt="计数"></p> 
<h5><a id="Hash__114"></a>Hash 哈希</h5> 
<blockquote> 
 <p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p> 
 <p>Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。</p> 
</blockquote> 
<ul><li>存储用户信息</li><li>存储用户主页访问量</li></ul> 
<p><img src="https://images2.imgbox.com/bf/06/rzmnJPQs_o.png" alt="用户信息存储"></p> 
<p><img src="https://images2.imgbox.com/e1/87/X9VYOkXJ_o.png" alt="K-V 存储"></p> 
<table><thead><tr><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/redis/hashes-hdel.html" rel="nofollow">HDEL key field1 field2</a> 删除一个或多个哈希表字段</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/hashes-hexists.html" rel="nofollow">HEXISTS key field</a> 查看哈希表 key 中，指定的字段是否存在。</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/hashes-hget.html" rel="nofollow">HGET key field</a> 获取存储在哈希表中指定字段的值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/hashes-hgetall.html" rel="nofollow">HGETALL key</a> 获取在哈希表中指定 key 的所有字段和值</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/hashes-hincrby.html" rel="nofollow">HINCRBY key field increment</a> 为哈希表 key 中的指定字段的整数值加上增量 increment 。</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/hashes-hincrbyfloat.html" rel="nofollow">HINCRBYFLOAT key field increment</a> 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/hashes-hkeys.html" rel="nofollow">HKEYS key</a> 获取所有哈希表中的字段</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/hashes-hlen.html" rel="nofollow">HLEN key</a> 获取哈希表中字段的数量</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/hashes-hmget.html" rel="nofollow">HMGET key field1 field2</a> 获取所有给定字段的值</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/hashes-hmset.html" rel="nofollow">HMSET key field1 value1 field2 value2 </a> 同时将多个 field-value (域-值)对设置到哈希表 key 中。</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/hashes-hset.html" rel="nofollow">HSET key field value</a> 将哈希表 key 中的字段 field 的值设为 value 。</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/hashes-hsetnx.html" rel="nofollow">HSETNX key field value</a> 只有在字段 field 不存在时，设置哈希表字段的值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/hashes-hvals.html" rel="nofollow">HVALS key</a> 获取哈希表中所有值。</td></tr><tr><td align="left">[HSCAN key cursor <a href="https://www.runoob.com/redis/hashes-hscan.html" rel="nofollow">MATCH pattern] [COUNT count]</a> 迭代哈希表中的键值对。</td></tr></tbody></table> 
<h5><a id="List__146"></a>List 列表</h5> 
<blockquote> 
 <p>List 类型是用来存储多个有序的字符串的，列表当中的每一个字符看做一个元素，一个列表当中可以存储有一个或者多个元素，redis 的 List 支持存储 <code>2^32 -1</code>个元素。</p> 
 <ul><li>redis 可以从列表的两端进行插入（push）和弹出（pop）元素</li><li>支持读取指定范围的元素集，或者读取指定下标的元素等操作。</li></ul> 
 <p>redis 列表是一种比较灵活的链表数据结构，它可以充当队列或者栈的角色。</p> 
</blockquote> 
<ul><li>消息队列：reids 的链表结构，可以轻松实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计。比如：数据的生产者可以通过 lpush 命令从左边插入数据，多个数据消费者，可以使用 brpop 命令阻塞的“抢”列表尾部的数据。</li><li>文章列表或者数据分页展示的应用：比如，我们常用的博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，而且当文章多时，都需要分页展示，这时可以考虑使用redis的列表，列表不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能。大大提高查询效率。</li></ul> 
<table><thead><tr><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/redis/lists-blpop.html" rel="nofollow">BLPOP key1 key2 timeout</a> 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/lists-brpop.html" rel="nofollow">BRPOP key1 key2 timeout</a> 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/lists-brpoplpush.html" rel="nofollow">BRPOPLPUSH source destination timeout</a> 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/lists-lindex.html" rel="nofollow">LINDEX key index</a> 通过索引获取列表中的元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/lists-linsert.html" rel="nofollow">LINSERT key BEFORE|AFTER pivot value</a> 在列表的元素前或者后插入元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/lists-llen.html" rel="nofollow">LLEN key</a> 获取列表长度</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/lists-lpop.html" rel="nofollow">LPOP key</a> 移出并获取列表的第一个元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/lists-lpush.html" rel="nofollow">LPUSH key value1 value2</a> 将一个或多个值插入到列表头部</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/lists-lpushx.html" rel="nofollow">LPUSHX key value</a> 将一个值插入到已存在的列表头部</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/lists-lrange.html" rel="nofollow">LRANGE key start stop</a> 获取列表指定范围内的元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/lists-lrem.html" rel="nofollow">LREM key count value</a> 移除列表元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/lists-lset.html" rel="nofollow">LSET key index value</a> 通过索引设置列表元素的值</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/lists-ltrim.html" rel="nofollow">LTRIM key start stop</a> 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/lists-rpop.html" rel="nofollow">RPOP key</a> 移除列表的最后一个元素，返回值为移除的元素。</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/lists-rpoplpush.html" rel="nofollow">RPOPLPUSH source destination</a> 移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/lists-rpush.html" rel="nofollow">RPUSH key value1 value2</a> 在列表中添加一个或多个值</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/lists-rpushx.html" rel="nofollow">RPUSHX key value</a> 为已存在的列表添加值</td></tr></tbody></table> 
<h5><a id="Set__178"></a>Set 集合</h5> 
<blockquote> 
 <p>集合类型的数据结构，那么集合类型就比较适合用于聚合分类。</p> 
 <p>redis 集合（Set）类型和 List 列表类型类似，都可以用来存储多个字符串元素的集合。但是和 List 不同的是 Set 集合当中不允许重复的元素。而且 Set 集合当中元素是<code>没有顺序的，不存在元素下标</code>。</p> 
 <p>redis 的 Set 类型是使用哈希表构造的，因此复杂度是O(1)，它支持集合内的增删改查，并且支持多个集合间的交集、并集、差集操作。可以利用这些集合操作，解决程序开发过程当中很多数据集合间的问题。</p> 
</blockquote> 
<ul><li>标签：比如我们博客网站常常使用到的兴趣标签，把一个个有着相同爱好，关注类似内容的用户利用一个标签把他们进行归并。</li><li>共同好友功能，共同喜好，或者可以引申到二度好友之类的扩展应用。</li><li>统计网站的独立IP。利用set集合当中元素不唯一性，可以快速实时统计访问网站的独立IP。</li></ul> 
<table><thead><tr><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/redis/sets-sadd.html" rel="nofollow">SADD key member1 member2</a> 向集合添加一个或多个成员</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sets-scard.html" rel="nofollow">SCARD key</a> 获取集合的成员数</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sets-sdiff.html" rel="nofollow">SDIFF key1 key2</a> 返回第一个集合与其他集合之间的差异。</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sets-sdiffstore.html" rel="nofollow">SDIFFSTORE destination key1 key2</a> 返回给定所有集合的差集并存储在 destination 中</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sets-sinter.html" rel="nofollow">SINTER key1 key2</a> 返回给定所有集合的交集</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sets-sinterstore.html" rel="nofollow">SINTERSTORE destination key1 key2</a> 返回给定所有集合的交集并存储在 destination 中</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sets-sismember.html" rel="nofollow">SISMEMBER key member</a> 判断 member 元素是否是集合 key 的成员</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sets-smembers.html" rel="nofollow">SMEMBERS key</a> 返回集合中的所有成员</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sets-smove.html" rel="nofollow">SMOVE source destination member</a> 将 member 元素从 source 集合移动到 destination 集合</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sets-spop.html" rel="nofollow">SPOP key</a> 移除并返回集合中的一个随机元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sets-srandmember.html" rel="nofollow">SRANDMEMBER key count</a> 返回集合中一个或多个随机数</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sets-srem.html" rel="nofollow">SREM key member1 member2</a> 移除集合中一个或多个成员</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sets-sunion.html" rel="nofollow">SUNION key1 key2</a> 返回所有给定集合的并集</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sets-sunionstore.html" rel="nofollow">SUNIONSTORE destination key1 key2</a> 所有给定集合的并集存储在 destination 集合中</td></tr><tr><td align="left">[SSCAN key cursor <a href="https://www.runoob.com/redis/sets-sscan.html" rel="nofollow">MATCH pattern] [COUNT count]</a> 迭代集合中的元素</td></tr></tbody></table> 
<h5><a id="ZSET__208"></a>ZSET 有序集合</h5> 
<blockquote> 
 <p>redis 有序集合也是集合类型的一部分，所以它保留了集合中元素不能重复的特性，但是不同的是，有序集合给每个元素多设置了一个分数，利用该分数作为排序的依据。</p> 
 <p>有序集合可以利用分数进行从小到大的排序。虽然有序集合的成员是唯一的,但是分数(score)却可以重复。就比如在一个班中，学生的学号是唯一的，但是每科成绩却是可以一样的，redis 可以利用有序集合存储学生成绩快速做成绩排名功能。</p> 
</blockquote> 
<p>有序集合的使用场景与集合类似，但是 set 集合不是自动有序的，而sorted set可以利用分数进行成员间的排序，而且是插入时就排序好。所以当你需要一个有序且不重复的集合列表时，就可以选择 sorted set 数据结构作为选择方案。</p> 
<ul><li> <p>排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。</p> </li><li> <p>用 sorted set 来做带权重的队列，比如普通消息的 score 为 1，重要消息的 score为 2，然后工作线程可以选择按 score 的倒序来获取工作任务。让重要的任务优先执行。</p> </li></ul> 
<table><thead><tr><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zadd.html" rel="nofollow">ZADD key score1 member1 score2 member2</a> 向有序集合添加一个或多个成员，或者更新已存在成员的分数</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zcard.html" rel="nofollow">ZCARD key</a> 获取有序集合的成员数</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zcount.html" rel="nofollow">ZCOUNT key min max</a> 计算在有序集合中指定区间分数的成员数</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zincrby.html" rel="nofollow">ZINCRBY key increment member</a> 有序集合中对指定成员的分数加上增量 increment</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zinterstore.html" rel="nofollow">ZINTERSTORE destination numkeys key key …</a> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zlexcount.html" rel="nofollow">ZLEXCOUNT key min max</a> 在有序集合中计算指定字典区间内成员数量</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zrange.html" rel="nofollow">ZRANGE key start stop WITHSCORES</a> 通过索引区间返回有序集合指定区间内的成员</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zrangebylex.html" rel="nofollow">ZRANGEBYLEX key min max LIMIT offset count</a> 通过字典区间返回有序集合的成员</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zrangebyscore.html" rel="nofollow">ZRANGEBYSCORE key min max WITHSCORES LIMIT</a> 通过分数返回有序集合指定区间内的成员</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zrank.html" rel="nofollow">ZRANK key member</a> 返回有序集合中指定成员的索引</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zrem.html" rel="nofollow">ZREM key member member …</a> 移除有序集合中的一个或多个成员</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zremrangebylex.html" rel="nofollow">ZREMRANGEBYLEX key min max</a> 移除有序集合中给定的字典区间的所有成员</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zremrangebyrank.html" rel="nofollow">ZREMRANGEBYRANK key start stop</a> 移除有序集合中给定的排名区间的所有成员</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zremrangebyscore.html" rel="nofollow">ZREMRANGEBYSCORE key min max</a> 移除有序集合中给定的分数区间的所有成员</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zrevrange.html" rel="nofollow">ZREVRANGE key start stop WITHSCORES</a> 返回有序集中指定区间内的成员，通过索引，分数从高到低</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zrevrangebyscore.html" rel="nofollow">ZREVRANGEBYSCORE key max min WITHSCORES</a> 返回有序集中指定分数区间内的成员，分数从高到低排序</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zrevrank.html" rel="nofollow">ZREVRANK key member</a> 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zscore.html" rel="nofollow">ZSCORE key member</a> 返回有序集中，成员的分数值</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zunionstore.html" rel="nofollow">ZUNIONSTORE destination numkeys key key …</a> 计算给定的一个或多个有序集的并集，并存储在新的 key 中</td></tr><tr><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zscan.html" rel="nofollow">ZSCAN key cursor MATCH pattern COUNT count</a> 迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table> 
<h3><a id="_243"></a>技术总结</h3> 
<p>文本介绍了 Redis 的两种存储模式，AOF 和 Snapshot，简要分析他们的区别和应用场景后，介绍了常用的数据结构和对应支撑的场景。</p> 
<h3><a id="REFERENCES_246"></a>REFERENCES</h3> 
<ul><li> <p><a href="https://www.oraclejsq.com/redisjc/040101720.html" rel="nofollow">redis 集合（set）类型的使用和应用场景</a></p> </li><li> <p><a href="https://www.oraclejsq.com/redisjc/040101722.html" rel="nofollow">redis有序集合（sorted set）详解和应用场景</a></p> </li></ul> 
<p><img src="https://images2.imgbox.com/e1/83/drTkkF8H_o.png" alt="架构探险之道"><br> <em>整理不易，如果觉得有帮助的话，欢迎点击<strong>收藏</strong>和<strong>在看</strong>，顺便帮小编点点<strong>广告</strong>哦，感谢 <sup>_</sup>！</em></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/38fc93d541bd47e3cf0ffaf5bb709c10/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue-router路由跳转与打开新窗口</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bd77cee62ea302b3dd510edeec1da5cf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于Maven新建项目本地仓库恢复默认地址的完美解方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>