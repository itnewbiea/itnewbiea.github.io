<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python中的映射类型详解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python中的映射类型详解" />
<meta property="og:description" content="泛映射类型 collections.abc模块中有Mapping和MutableMapping这两个抽象基类,它们的作用事为dict和其他类似的类型定义形式接口
非抽象映射类型一般不会直接继承这些抽象基类,它们会直接对dict或者是collections.UserDict进行扩展.这些抽象基类的主要作用事作为形式化的文档,它们定义了构建一个映射类型所需要的最基本的接口.然后它们还可以跟isinstance一起被用来判定某个数据是不是广义上的映射类型:
from collections.abc import Mapping, MutableMapping
标准库里的所有映射类型都是利用dict来实现的,因此它们有个共同的限制,即只有&lt;可散列的&gt;数据类型才能用作这些映射里的键.
什么是可散列的数据类型?
如果一个对象是可散列的,那么在这个对象的生命周期中,它的散列值是不变的,而且这个对象需要实现__hash__()方法.
另外可散列对象还要有__eq__()方法,这样才能跟其他键作比较.如果两个可散列对象是相等的,那么它们的散列值一定是一样的.
原子不可变数据类型(str,bytes和数值类型)都是可散列类型,frozenset也是可散列的,因为根据其定义,frozenset里只能容纳可散列类型.
元组的话,只有当一个元组包含的所有元素都是可散列类型的情况下,它才是可散列的.
tt = (1, 2, (30, 40)) print(hash(tt)) # 8027212646858338501 tl = (1, 2, [30, 40]) # print(hash(tl)) # TypeError: unhashable type: &#39;list&#39; tf = (1, 2, frozenset([30, 40])) print(hash(tf)) # 985328935373711578 一般来讲,用户自定义的类型的对象都是可散列的,散列值就是它们的id()函数的返回值,所以所有这些对象在比较的时候都是不相等的.
如果一个对象实现了__eq__方法,并且在方法中用到了这个对象的内部状态的话,那么只有当所有这些内部状态都是不可变的情况下,这个对象踩死可散列的.
&#39;&#39;&#39; 遇到问题没人解答？小编创建了一个Python学习交流QQ群：531509025 寻找有志同道合的小伙伴，互帮互助,群里还有不错的视频学习教程和PDF电子书！ &#39;&#39;&#39; class A: def __init__(self, a_): self.a = a_ class B: def __init__(self, a_): self.a = a_ def __hash__(self): return hash(self." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/1d240efc2b34cd925c8ab63aa69e5074/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-18T13:50:11+08:00" />
<meta property="article:modified_time" content="2020-07-18T13:50:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python中的映射类型详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h5><a id="_0"></a>泛映射类型</h5> 
<p>collections.abc模块中有Mapping和MutableMapping这两个抽象基类,它们的作用事为dict和其他类似的类型定义形式接口<br> 非抽象映射类型一般不会直接继承这些抽象基类,它们会直接对dict或者是collections.UserDict进行扩展.这些抽象基类的主要作用事作为形式化的文档,它们定义了构建一个映射类型所需要的最基本的接口.然后它们还可以跟isinstance一起被用来判定某个数据是不是广义上的映射类型:</p> 
<p>from collections.abc import Mapping, MutableMapping</p> 
<p>标准库里的所有映射类型都是利用dict来实现的,因此它们有个共同的限制,即只有&lt;可散列的&gt;数据类型才能用作这些映射里的键.</p> 
<p><strong>什么是可散列的数据类型?</strong></p> 
<p>如果一个对象是可散列的,那么在这个对象的生命周期中,它的散列值是不变的,而且这个对象需要实现__hash__()方法.</p> 
<p>另外可散列对象还要有__eq__()方法,这样才能跟其他键作比较.如果两个可散列对象是相等的,那么它们的散列值一定是一样的.</p> 
<p>原子不可变数据类型(str,bytes和数值类型)都是可散列类型,frozenset也是可散列的,因为根据其定义,frozenset里只能容纳可散列类型.</p> 
<p>元组的话,只有当一个元组包含的所有元素都是可散列类型的情况下,它才是可散列的.</p> 
<pre><code class="prism language-python">tt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">hash</span><span class="token punctuation">(</span>tt<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 8027212646858338501</span>
tl <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment"># print(hash(tl))  # TypeError: unhashable type: 'list'</span>
tf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token builtin">frozenset</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">hash</span><span class="token punctuation">(</span>tf<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 985328935373711578</span>
</code></pre> 
<p>一般来讲,用户自定义的类型的对象都是可散列的,散列值就是它们的id()函数的返回值,所以所有这些对象在比较的时候都是不相等的.</p> 
<p>如果一个对象实现了__eq__方法,并且在方法中用到了这个对象的内部状态的话,那么只有当所有这些内部状态都是不可变的情况下,这个对象踩死可散列的.</p> 
<pre><code class="prism language-python"><span class="token triple-quoted-string string">'''
遇到问题没人解答？小编创建了一个Python学习交流QQ群：531509025
寻找有志同道合的小伙伴，互帮互助,群里还有不错的视频学习教程和PDF电子书！
'''</span>
<span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a_<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>a <span class="token operator">=</span> a_


<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a_<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>a <span class="token operator">=</span> a_

    <span class="token keyword">def</span> <span class="token function">__hash__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token builtin">hash</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>a<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">__eq__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token builtin">hash</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">hash</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span>


a1 <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
a2 <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">hash</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># -9223371857585079499</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">hash</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 179269859620</span>

b1 <span class="token operator">=</span> B<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
b2 <span class="token operator">=</span> B<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">hash</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 1</span>
<span class="token comment"># print(hash(b2))  # TypeError: unhashable type: 'list'</span>

<span class="token comment"># 根据这些定义,字典提供了很多种构造方法.</span>
a <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span>one<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> two<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> three<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>
b <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span>
c <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token builtin">zip</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
d <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'one'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'two'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'three'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
e <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b <span class="token operator">==</span> c <span class="token operator">==</span> d <span class="token operator">==</span> e<span class="token punctuation">)</span>
</code></pre> 
<h5><a id="_70"></a>字典推导式</h5> 
<p>字典推导可以从任何以键值对作为元素的可迭代对象中构建出字典</p> 
<pre><code class="prism language-python">STUDENTS <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">(</span><span class="token string">"孙悟空"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token string">"猪八戒"</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token string">"沙和尚"</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token string">"二郎神"</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token string">"哪吒"</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token string">"诸葛亮"</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>
student <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>name<span class="token punctuation">:</span> number <span class="token keyword">for</span> name<span class="token punctuation">,</span> number <span class="token keyword">in</span> STUDENTS<span class="token punctuation">}</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span>  <span class="token comment"># {'孙悟空': 100, '猪八戒': 90, '沙和尚': 80, '二郎神': 70, '哪吒': 60, '诸葛亮': 50}</span>
student2 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>name<span class="token punctuation">:</span> number <span class="token keyword">for</span> name<span class="token punctuation">,</span> number <span class="token keyword">in</span> student<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> number <span class="token operator">&gt;</span> <span class="token number">60</span><span class="token punctuation">}</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>student2<span class="token punctuation">)</span>  <span class="token comment"># {'孙悟空': 100, '猪八戒': 90, '沙和尚': 80, '二郎神': 70}</span>
</code></pre> 
<h5><a id="_86"></a>常见的映射方法</h5> 
<p>dict.update(m, [**kargs])方法处理参数m的方式,是典型的’鸭子类型’,函数首先检查m是否有keys方法,如果有,那么update函数就把它当作映射对象来处理.</p> 
<p>否则,函数会退一步,转而把m当作包含了键值对(key, value)元素的迭代器.python里大多数映射类型的构造方法都采用了类似的逻辑,因此你既可以用一个映射对象来新建一个映射对象,也可以用包含(key, value)元素的可迭代对象来初始化一个映射对象.</p> 
<pre><code class="prism language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span>  <span class="token comment"># {'孙悟空': 100, '猪八戒': 90, '沙和尚': 80, '二郎神': 70, '哪吒': 60, '诸葛亮': 50}</span>
student<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token string">"小白龙"</span><span class="token punctuation">:</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token string">"唐僧"</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span>  <span class="token comment"># {'孙悟空': 100, '猪八戒': 90, '沙和尚': 80, '二郎神': 70, '哪吒': 60, '诸葛亮': 50, '小白龙': 80, '唐僧': 90}</span>
student<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"李世民"</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"朱元璋"</span><span class="token punctuation">,</span> <span class="token number">85</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment"># {'孙悟空': 100, '猪八戒': 90, '沙和尚': 80, '二郎神': 70, '哪吒': 60, '诸葛亮': 50, '小白龙': 80, '唐僧': 90, '李世民': 90, '朱元璋': 85}</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span>
</code></pre> 
<h5><a id="setdefault_100"></a>用setdefault处理找不到的键</h5> 
<p>当字典d[k]不能找到正确的键的时候,Python会抛出异常,这个行为符合Python所信奉的’快速失败’哲学.</p> 
<p>也许每个Python程序员都知道可以用d.get(k, default)来代替d[k],给找不到的键一个默认的返回值.这比处理KeyError要方便不少.</p> 
<p>但是要更新某个键对应的值的时候,不管用__getitem__还是get都会不自然,而且效率低.</p> 
<p><strong>例1</strong></p> 
<pre><code class="prism language-python"><span class="token triple-quoted-string string">'''
遇到问题没人解答？小编创建了一个Python学习交流QQ群：531509025
寻找有志同道合的小伙伴，互帮互助,群里还有不错的视频学习教程和PDF电子书！
'''</span>
<span class="token keyword">import</span> re

WORD_RE <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span>r<span class="token string">'\w+'</span><span class="token punctuation">)</span>
index <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'./word'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fp<span class="token punctuation">:</span>
    <span class="token keyword">for</span> line_no<span class="token punctuation">,</span> line <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># re.finditer(string) 返回string中所有与pattern相匹配的全部字串，返回形式为迭代器。</span>
        <span class="token keyword">for</span> match <span class="token keyword">in</span> WORD_RE<span class="token punctuation">.</span>finditer<span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">:</span>
            word <span class="token operator">=</span> match<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 匹配到的单词</span>
            column_no <span class="token operator">=</span> match<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>  <span class="token comment"># 单词首字目所在的位置,从1开始</span>
            location <span class="token operator">=</span> <span class="token punctuation">(</span>line_no<span class="token punctuation">,</span> column_no<span class="token punctuation">)</span>  <span class="token comment"># (行号, 列号)</span>
            <span class="token comment"># 这其实是一种很不好的实现,这样写只是为了证明论点</span>
            occurrences <span class="token operator">=</span> index<span class="token punctuation">.</span>get<span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 提取word出现的情况,如果还没有它的记录,返回[].</span>
            occurrences<span class="token punctuation">.</span>append<span class="token punctuation">(</span>location<span class="token punctuation">)</span>  <span class="token comment"># 把单词出现的位置添加到列表的后面.</span>
            index<span class="token punctuation">[</span>word<span class="token punctuation">]</span> <span class="token operator">=</span> occurrences  <span class="token comment"># 把新的列表放回字典中,这又牵扯到一次查询操作.</span>
    <span class="token comment"># 以字母顺序打印出结果</span>
    <span class="token comment"># sorted函数的key=参数没有调用str.upper,而是把这个方法的引用传递给sorted函数,这样在排序的时候,单词会被规范成统一格式.</span>
    <span class="token keyword">for</span> word <span class="token keyword">in</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">.</span>upper<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 将方法用作一等函数</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> index<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token punctuation">)</span>

index_ <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'./word'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fp<span class="token punctuation">:</span>
    <span class="token keyword">for</span> line_no<span class="token punctuation">,</span> line <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> match <span class="token keyword">in</span> WORD_RE<span class="token punctuation">.</span>finditer<span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">:</span>
            word <span class="token operator">=</span> match<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span>
            column_no <span class="token operator">=</span> match<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
            location <span class="token operator">=</span> <span class="token punctuation">(</span>line_no<span class="token punctuation">,</span> column_no<span class="token punctuation">)</span>
            index_<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>location<span class="token punctuation">)</span>
    <span class="token keyword">for</span> word <span class="token keyword">in</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>index_<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">.</span>upper<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> index_<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<p>dict.setdefault(key, []).append(new_value)</p> 
<p>获取单词的出现情况列表,如果单词不存在,把单词和一个空列表放进映射,然后返回这个空列表,这样就能在不进行第二次查找的情况下更新列表了.</p> 
<p>也就是说,和下面的代码效果一样</p> 
<pre><code class="prism language-python"><span class="token keyword">if</span> key <span class="token operator">not</span> <span class="token keyword">in</span> <span class="token builtin">dict</span><span class="token punctuation">:</span>
    <span class="token builtin">dict</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">dict</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>new_value<span class="token punctuation">)</span>
</code></pre> 
<p>只不过,后者至少要进行两次键查询,如果键不存在的话,就是三次.而setdefault只需要一次就可以完成整个操作</p> 
<h5><a id="_161"></a>映射的弹性键查询</h5> 
<p>有时候为了方便起见,就算某个键在映射里不存在,我们也希望在通过这个键读取值的时候能得到一个默认值.有两个途径能帮我们达到这个目的,一个是通过defaultdict这个类型而不是普通的dict,另一个是给自己定义一个dict的子类,然后再子类中实现__missing__方法.</p> 
<p>在用户创建defalutdict对象的时候,就需要给它配置一个为找不到的键创造默认值的方法.<br> 具体而言,在实例化一个defaultdict的时候,需要给构造方法提供一个可调用对象,这个可调用对象会在__getitem__碰到找不到的键的时候被调用,让__getitem__返回某种默认值</p> 
<p>比如,我们新建了这样一个字典:dd = defaultdict(list),如果键’new-key’在dd中还不存在的话,表达式dd[‘new-key’]会按照以下的步骤来执行:</p> 
<p>1.调用list()来建立一个新列表<br> 2.把这个新列表作为值,'new-key’作为它的键,放到dd中<br> 3.返回这个列表的引用</p> 
<p>而这个用来生成默认值的可调用对象存放在名为default_factory的实例属性中</p> 
<pre><code class="prism language-python"><span class="token triple-quoted-string string">'''
遇到问题没人解答？小编创建了一个Python学习交流QQ群：531509025
寻找有志同道合的小伙伴，互帮互助,群里还有不错的视频学习教程和PDF电子书！
'''</span>
<span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict

<span class="token comment"># 把list构造方法作为default_factory来创建一个defaultdict</span>
index_dd <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">)</span>

<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'./word'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fp<span class="token punctuation">:</span>
    <span class="token keyword">for</span> line_no<span class="token punctuation">,</span> line <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> match <span class="token keyword">in</span> WORD_RE<span class="token punctuation">.</span>finditer<span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">:</span>
            word <span class="token operator">=</span> match<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span>
            column_no <span class="token operator">=</span> match<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
            location <span class="token operator">=</span> <span class="token punctuation">(</span>line_no<span class="token punctuation">,</span> column_no<span class="token punctuation">)</span>
            <span class="token triple-quoted-string string">"""
            如果index_dd并没有word记录,那么default_factory会被调用,为查询步到的键创造一个值.
            这个值在这里是一个空列表,然后这个空列表会被赋值给index_dd[word],继而被当作返回值返回.
            因此.append(location)操作总能成功
            """</span>
            index_dd<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>location<span class="token punctuation">)</span>
    <span class="token keyword">for</span> word <span class="token keyword">in</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>index_<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">.</span>upper<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> index_dd<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<p>如果在创建defaultdict的时候没有指定default_factory,查询不存在的键会触发KeyError<br> defaultdict里的default_factory只会在__getitem__里被调用,在其他的方法里完全不会发挥作用.<br> 比如dd[k]这个表达式会调用default_factory创造某个默认值,而dd.get(k)则会返回None</p> 
<p>所有这一切背后的功臣其实是特殊方法__missing__.它会在defaultdict遇到找不到的键的时候调用default_factory,而实际上这个特性是所有映射类型都可以选择去支持的.</p> 
<p>所有的映射类型在处理找不到的键的时候,都会牵扯到__missing__方法.这也是这个方法被称作’'missing的原因.</p> 
<p>虽然基类dict没有定义这个方法,但是dict是知道有这个东西存在的.也就是说,如果有一个类继承了dict,然后这个继承类提供了__missing__方法,那么在__getitem__碰到找不到的键的时候,Python就会自动调用它,而不是抛出KeyError异常.</p> 
<p>__missing__方法只会被__getitem__调用,对get或者__contains__这些方法的使用没有影响.</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">StrKeyDict</span><span class="token punctuation">(</span><span class="token builtin">dict</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 继承dict</span>
    <span class="token triple-quoted-string string">"""
    如果要自定义一个映射类型,更合适的策略其实是继承collections.UserDict类.这里我们从dict继承,
    只是为了演示__missing__是如何被dict.__getitem__调用的
    """</span>

    <span class="token keyword">def</span> <span class="token function">__missing__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        为什么isinstance(key, str)是必须的?
        如果没有这个测试,当str(key)不是一个存在的键,代码就会陷入无限递归.这是因为__missing__的最后一行中的self[str(key)]会调用
        __getitem__,而这个str(key)又不存在,于是__missing__又会被调用.
        """</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 如果找不到的键本身就是字符串,那就抛出KeyError异常</span>
            <span class="token keyword">raise</span> KeyError<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        <span class="token comment"># 如果找不到的键不是字符串,那么就把它转换成字符串再进行查找</span>
        <span class="token keyword">return</span> self<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span>

    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        get方法把查找工作用self[key]的形式委托给__getitem__,这样在宣布查找失败之前,还能通过__missing__再给某个键一个机会
        """</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> self<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
        <span class="token keyword">except</span> KeyError<span class="token punctuation">:</span>
            <span class="token comment"># 如果抛出KeyError,那么说明__missing__也失败了,于是返回default.</span>
            <span class="token keyword">return</span> default

    <span class="token keyword">def</span> <span class="token function">__contains__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        为了保持一致性,__contains__方法也是必须的.这是因为k in d这个操作会调用它,但是我们从dict继承到的__contains__方法[不会]在找不到键的时候
        调用__missing__方法.__contains__里还有个细节,就是我们这里没有用更具Python风格的方式--item in self--来检验是否存在,因为那也会导致
        __contains__被递归调用,为了避免这一情况,这里采取了更显式的方法,直接在这个self.keys()里查询.

        像k in my_dict.keys()这种操作在Python3中是很快的,而且即便映射类型对象很庞大也没关系.这因为dict.keys()的返回值是一个"视图".
        视图就像一个集合,而且跟字典类似的是,在视图里查找一个元素的速度很快.
        Python2中的dict.keys()返回的则是一个列表,它在处理体积大的对象的时候效率不会太高,因为k in my_list操作需要扫描整个列表.
        """</span>
        <span class="token comment"># 先安装传入键的原本的值来查找,如果没找到,再用str()方法把键转换成字符串再查找一次.</span>
        <span class="token keyword">return</span> item <span class="token keyword">in</span> self<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token builtin">str</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span>


d <span class="token operator">=</span> StrKeyDict<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token string">'2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># two</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># four</span>
<span class="token comment"># print(d[1])  # KeyError: '1'</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># two</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># four</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># None</span>

<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">in</span> d<span class="token punctuation">)</span>  <span class="token comment"># True</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">in</span> d<span class="token punctuation">)</span>  <span class="token comment"># False</span>
</code></pre> 
<h5><a id="_267"></a>字典的变种</h5> 
<pre><code class="prism language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> OrderedDict<span class="token punctuation">,</span> ChainMap<span class="token punctuation">,</span> Counter<span class="token punctuation">,</span> UserDict
</code></pre> 
<p><strong>collections.OrderedDict</strong></p> 
<p>这个类型在添加键的时候会保持顺序,因此键的迭代次序总是一致的.OrderedDict的popitem方法默认删除并返回的是字典里的最后一个元素.</p> 
<p>但是如果像my_dict.popitem(last=False)这样调用它,那么它删除并返回第一个被添加进去的元素.</p> 
<p><strong>collections.ChainMap</strong></p> 
<p>该类型可以容纳数个不同的映射对象,然后在进行键查找操作的时候,这些对象会被当作一个整体被逐个查找,直到键被找到为止.</p> 
<p>这个功能在给有嵌套作用域的语言做解释器的时候很有用,可以用一个映射对象来代表一个作用域的上下文.</p> 
<p>例如下面这个Python变量查询规则:</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> builtins

py_lookup <span class="token operator">=</span> ChainMap<span class="token punctuation">(</span><span class="token builtin">locals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">globals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">vars</span><span class="token punctuation">(</span>builtins<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token triple-quoted-string string">"""
collections.Counter
这个映射类型会给键准备一个整数计数器.每次更新一个键的时候都会增加这个计数器.所以这个类型可以用来给可散列列表对象计数,
或者是当成多重集来用--多重集合就是集合里的元素可以出现不止一次.Counter实现了+和-运算符用来合并记录,还有像most_common([n])这类很有用的方法.
most_common([n])会按照次序返回映射里最常见的n个键和它们的计数.
下面的小例子利用Counter来计算单词中各个字母出现的次数:
"""</span>
ct <span class="token operator">=</span> Counter<span class="token punctuation">(</span><span class="token string">'abracadabra'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>ct<span class="token punctuation">)</span>  <span class="token comment"># Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})</span>
ct<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token string">'aaaaazzz'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>ct<span class="token punctuation">)</span>  <span class="token comment"># Counter({'a': 10, 'z': 3, 'b': 2, 'r': 2, 'c': 1, 'd': 1})</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>ct<span class="token punctuation">.</span>most_common<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># [('a', 10), ('z', 3)]</span>
</code></pre> 
<p><strong>collections.UserDict</strong></p> 
<p>这个类其实就是把标准的dict用纯Python又实现了一遍.跟前三者不同,UserDict是让用户继承写子类的.下面就来试试:</p> 
<p>就创造自定义映射类型来说,以UserDict为基类,总比以普通的dict为基类要来得方便.这体现在,我们能够改进上面的StrKeyDict类,使得所有的键都存储为字符串类型.</p> 
<p>而更倾向于从UserDict而不是从dict继承的主要原因是,后者有时会在某些方法的实现上走一些捷径,导致我们不得不在它的子类中重写这些方法,但是UserDict就不会带来这些问题.</p> 
<p>另外一个需要注意的地方是UserDict并不是dict的子类,但是UserDict有一个叫做data的属性,是dict的实例,这个属性实际上是UserDict最终存储数据的地方.</p> 
<p>这样做的好处是,比起上面的例子,UserDict的子类就能在实现__setitem__的时候避免不必要的递归,也可以让__contains__里的代码更简洁.</p> 
<p>下面的雷子不但把所有的键都以字符串的形式存储,还能处理一些创建或者更新实例时包含非字符串类型的键这类意外情况.</p> 
<pre><code class="prism language-python"><span class="token triple-quoted-string string">'''
遇到问题没人解答？小编创建了一个Python学习交流QQ群：531509025
寻找有志同道合的小伙伴，互帮互助,群里还有不错的视频学习教程和PDF电子书！
'''</span>
<span class="token keyword">class</span> <span class="token class-name">StrKeyDict_U</span><span class="token punctuation">(</span>UserDict<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># StrKeyDict_U是对UserDict的拓展</span>
    <span class="token keyword">def</span> <span class="token function">__missing__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">raise</span> KeyError<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span>

    <span class="token keyword">def</span> <span class="token function">__setitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 把所有的键都转换成字符串.由于把具体的实现委托给了self.data属性,这个方法写起来也不难.</span>
        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> value

    <span class="token keyword">def</span> <span class="token function">__contains__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 这里可以放心假设所有已经存储的键都是字符串.</span>
        <span class="token comment"># 并且可以直接在self.data上查询</span>
        <span class="token keyword">return</span> <span class="token builtin">str</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>data
</code></pre> 
<p>因为UserDict继承的是MutableMapping,所以StrKeyDict_U里剩下的那些映射类型的方法都是从UserDict、MutableMapping和Mapping这些超类继承来的.</p> 
<p>特别是最后的Mapping类,它虽然是一个抽象基类(ABC),但它却提供了好几个实用的方法.</p> 
<p><strong>MutableMapping.update</strong></p> 
<p>这个方法不但可以为我们所直接利用,它还用在__init__里,然构造方法可以利用出入的各种参数(其他映射类型、元素是(key, value)对的可迭代对象和键值参数)来新建实例.因为这个方法在背后是用self[key] = value来添加新值的,所以它其实是在使用我们的__setitem__方法</p> 
<p><strong>Mapping.get</strong></p> 
<p>在StrKeyDict中,我们不得不改写get方法,好让它的表现跟__getitem__一致.而在StrKeyDict_U中就没有这个必要了,因为它继承了Mapping.get方法,这个方法的实现方式跟StrKeyDict.get是一模一样的.</p> 
<h5><a id="_351"></a>不可变映射类型</h5> 
<p>标准库里的所有映射类型都是可变的,但是有时候我们需要限制用户的修改从Python3.3开始,types模块中引入了一个封装类名叫MappingProxyType.如果给这个类一个映射,它会返回一个只读的映射视图.</p> 
<p>虽然是个只读视图,但是它是动态的.这意味着如果对原映射做出了改动,我们通过这个视图可以观察到,但是无法通过这个视图对原映射做修改.</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> types <span class="token keyword">import</span> MappingProxyType
d <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token string">'A'</span><span class="token punctuation">}</span>
d_proxy <span class="token operator">=</span> MappingProxyType<span class="token punctuation">(</span>d<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>d_proxy<span class="token punctuation">)</span>  <span class="token comment"># {1: 'A'}</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>d_proxy<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># A   d中的内容可以通过d_proxy看到</span>
<span class="token comment"># 但是通过d_proxy并不能做任何修改</span>
<span class="token comment"># d_proxy[2] = 'X'  # TypeError: 'mappingproxy' object does not support item assignment</span>
d<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">8</span>
<span class="token comment"># d_proxy是动态的,也就是说对d所做的任何改动都会反馈到它的上面</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>d_proxy<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 8</span>
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f5bc578138ebf6a2c8c5ac5ca6ed69dd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IntelliJ Idea 注释模板</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9b90e08e761785512b498875186ca9d1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">学习笔记之Linux学习（一）：Linux安装以及目录介绍、Xshell终端的安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>