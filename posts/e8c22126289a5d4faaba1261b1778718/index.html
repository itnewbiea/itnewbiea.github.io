<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>网易电话面试经验——C  游戏服务器开发 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="网易电话面试经验——C  游戏服务器开发" />
<meta property="og:description" content="项目
服务器架构
C&#43;&#43;基础
1.深拷贝和浅拷贝的区别
默认拷贝构造函数实现的是浅拷贝，浅拷贝只拷贝指针本身，不拷贝指针指向的数据内容
浅拷贝一般情况下没有问题，但类成员出现指针时，会导致指针悬挂
2.C&#43;&#43;多态如何体现
3.vector内部实现，clear会释放vector的内存吗，如何释放vector等内存
要点: size，capacity，clear()只是将size改为0
释放内存的方法：
//方法一:可以使用swap用临时变量交换释放 vector&lt;int&gt;().swap(xx); //方法二:采取缩小容量至size()大小 clear(); shrink_to_fit(); 4.vector和list的区别
5.如何实现vector头部插入（deque：双端队列）
6.智能指针
unique_ptr、shared_ptr
使用智能指针的原因:
1）智能指针能够帮助我们处理资源泄露问题；
2）它也能够帮我们处理空悬指针的问题；
3）它还能够帮我们处理比较隐晦的由异常造成的资源泄露。
7.析构函数能否抛出异常
析构函数不能，也不应该抛出异常
C&#43;&#43;异常处理模型最大的特点和优势就是对C&#43;&#43;中的面向对象提供了最强大的无缝支持。那么如果对象在运行期间出现了异常，C&#43;&#43;异常处理模型有责任清除那些由于出现异常所导致的已经失效了的对象(也即对象超出了它原来的作用域)，并释放对象原来所分配的资源， 这就是调用这些对象的析构函数来完成释放资源的任务，所以从这个意义上说，析构函数已经变成了异常处理的一部分。
1）如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。
2）通常异常发生时，c&#43;&#43;的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。
网络
1.TCP与UDP的最大区别
2.TCP的三次握手过程
3.TCP三次握手如果服务器没有收到最后一次握手会怎么样
当Client端收到Server的SYN&#43;ACK应答后，其状态变为ESTABLISHED，并发送ACK包给Server，如果此时ACK在网络中丢失，那么Server端该TCP连接的状态为SYN_RECV，并且依次等待3秒、6秒、12秒后重新发送SYN&#43;ACK包，以便Client重新发送ACK包。
Server重发SYN&#43;ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5。
如果重发指定次数后，仍然未收到ACK应答，那么一段时间后，Server自动关闭这个连接。
但是Client认为这个连接已经建立，如果Client端向Server写数据，Server端将以RST包响应，方能感知到Server的错误
4.四次挥手如何处理大量的TIME_WAIT
5.多路复用网络模型
算法
1.正整数n以内的最大素数
2.最长递增子序列" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e8c22126289a5d4faaba1261b1778718/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-24T10:12:35+08:00" />
<meta property="article:modified_time" content="2019-10-24T10:12:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">网易电话面试经验——C  游戏服务器开发</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>项目</strong></p> 
</blockquote> 
<p><strong>服务器架构</strong></p> 
<blockquote> 
 <p><strong>C++基础</strong></p> 
</blockquote> 
<p><strong>1.深拷贝和浅拷贝的区别</strong></p> 
<p>    默认拷贝构造函数实现的是浅拷贝，浅拷贝只拷贝指针本身，不拷贝指针指向的数据内容</p> 
<p>    浅拷贝一般情况下没有问题，但类成员出现指针时，会导致指针悬挂</p> 
<p><img alt="" class="has" height="599" src="https://images2.imgbox.com/6c/a0/Rt9NmuTK_o.png" width="828"></p> 
<p><strong>2.C++多态如何体现</strong></p> 
<p><strong>3.vector内部实现，clear会释放vector的内存吗，如何释放vector等内存</strong></p> 
<p>    要点: size，capacity，clear()只是将size改为0</p> 
<p>    释放内存的方法：</p> 
<pre class="has"><code class="language-cpp">//方法一:可以使用swap用临时变量交换释放

vector&lt;int&gt;().swap(xx);

//方法二:采取缩小容量至size()大小

clear();

shrink_to_fit();</code></pre> 
<p><strong>4.vector和list的区别</strong></p> 
<p><strong>5.如何实现vector头部插入（deque：双端队列）</strong></p> 
<p><strong>6.智能指针</strong></p> 
<p>    unique_ptr、shared_ptr</p> 
<p>    使用智能指针的原因:</p> 
<p>       1）智能指针能够帮助我们处理资源泄露问题；</p> 
<p>       2）它也能够帮我们处理空悬指针的问题；</p> 
<p>       3）它还能够帮我们处理比较隐晦的由异常造成的资源泄露。</p> 
<p><strong>7.析构函数能否抛出异常</strong></p> 
<p>    析构函数不能，也不应该抛出异常</p> 
<p>    C++异常处理模型最大的特点和优势就是对C++中的面向对象提供了最强大的无缝支持。那么如果对象在运行期间出现了异常，C++异常处理模型有责任清除那些由于出现异常所导致的已经失效了的对象(也即对象超出了它原来的作用域)，并释放对象原来所分配的资源， 这就是调用这些对象的析构函数来完成释放资源的任务，所以从这个意义上说，析构函数已经变成了异常处理的一部分。</p> 
<p>    1）如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。</p> 
<p>    2）通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。</p> 
<blockquote> 
 <p><strong>网络</strong></p> 
</blockquote> 
<p><strong>1.TCP与UDP的最大区别</strong></p> 
<p><strong>2.TCP的三次握手过程</strong></p> 
<p><strong>3.TCP三次握手如果服务器没有收到最后一次握手会怎么样</strong></p> 
<p>    当Client端收到Server的SYN+ACK应答后，其状态变为ESTABLISHED，并发送ACK包给Server，如果此时ACK在网络中丢失，那么Server端该TCP连接的状态为SYN_RECV，并且依次等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。</p> 
<p>    Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5。</p> 
<p>    如果重发指定次数后，仍然未收到ACK应答，那么一段时间后，Server自动关闭这个连接。</p> 
<p>    但是Client认为这个连接已经建立，如果Client端向Server写数据，Server端将以RST包响应，方能感知到Server的错误</p> 
<p><strong>4.四次挥手如何处理大量的TIME_WAIT</strong></p> 
<p><strong>5.多路复用网络模型</strong></p> 
<blockquote> 
 <p><strong>算法</strong></p> 
</blockquote> 
<p><strong>1.正整数n以内的最大素数</strong></p> 
<p><strong>2.最长递增子序列</strong></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f03b50fc136471290f25597675798961/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">利用ARIMA模型对时间序列进行分析的经典案例（详细代码）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/18651f6fcd22406ab7a46c5481b987b6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">程序员的节日</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>