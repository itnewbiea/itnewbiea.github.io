<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>从零开始丨INDEMIND双目视觉惯性模组ROS平台ORB-SLAM教程及记录 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="从零开始丨INDEMIND双目视觉惯性模组ROS平台ORB-SLAM教程及记录" />
<meta property="og:description" content="本文涉及很多代码及文字，排版、文字错误请见谅。
阅读时间预计30分钟
本文涉及图像、数据均由INDEMIND双目视觉惯性模组采集
文章涉及所有代码修改皆已上传至Github，大家自行修改后可对比参照
下载链接：Github
文章目录 一：环境介绍二：下载SDK及ORB-SLAM源码三：修改源码1 . 源码路径2 . 修改stereo_euroc.cc文件1）将其橙色区域改成2）添加时间转换函数3）删除LoadImages函数4）添加回调函数imagelCallback5）添加show_ORB函数6）ros初始化7）删除 LoadImages函数 3 . 新建FileYaml.h文件4 . 新建FileYaml.cc文件5 . 修改CMakeLists.txt文件1)2）3）4）5） 6. 编译1） 7. 执行1）2）3） 一：环境介绍 系统：Ubuntu 16.04 ROS
ORB依赖库：Pangolin、OpenCV、Eigen3、DBoW2、g2o,ros
二：下载SDK及ORB-SLAM源码 下载地址：
SDK：http://indemind.cn/sdk.html
ORB-SLAM：https://github.com/raulmur/ORB_SLAM2
三：修改源码 1 . 源码路径 下载好SDK之后，进入SDK-Linux/demo_ros/src目录。将下载好源码的放在该目录下，并对其改名，改为 ORB_SLAM
2 . 修改stereo_euroc.cc文件 进入ORB_SLAM2/Examples/Stereo目录下，修改stereo_euroc.cc文件。
1）将其橙色区域改成 代码如下：
#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;fstream&gt; #include&lt;iomanip&gt; #include&lt;chrono&gt; #include&lt;opencv2/core/core.hpp&gt; #include&lt;System.h&gt; #include &#34;ros/ros.h&#34; #include &lt;cv_bridge/cv_bridge.h&gt; #include &lt;sensor_msgs/Image.h&gt; #include &#34;std_msgs/String.h&#34; #include &#34;FileYaml.h&#34; #include &lt;queue&gt; #include &lt;mutex&gt; #include &lt;thread&gt; #include &lt;condition_variable&gt; using namespace std; ros::Subscriber image_l_sub; ros::Subscriber image_r_sub; int image_l_count = 0; queue&lt;cv::Mat&gt; que_image_l; queue&lt;cv::Mat&gt; que_image_r; queue&lt;long double&gt; que_stamp; std::mutex limage_mutex; std::mutex rimage_mutex; std::condition_variable left_data_cond; std::condition_variable right_data_cond; // std::lock_guard&lt;std::mutex&gt;lock(rimage_mutex); // std::thread show_thread{show_image}; //visualization thread // show_thread." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/20294d780a3fe1e38be8befc6c44b02d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-18T11:25:26+08:00" />
<meta property="article:modified_time" content="2019-03-18T11:25:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从零开始丨INDEMIND双目视觉惯性模组ROS平台ORB-SLAM教程及记录</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><em>本文涉及很多代码及文字，排版、文字错误请见谅。<br> 阅读时间预计30分钟<br> 本文涉及图像、数据均由INDEMIND双目视觉惯性模组采集</em></p> 
<p><strong>文章涉及所有代码修改皆已上传至Github，大家自行修改后可对比参照<br> 下载链接：<a href="https://github.com/INDEMINDtech/ORB-SLAM2-">Github</a></strong></p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_9" rel="nofollow">一：环境介绍</a></li><li><a href="#SDKORBSLAM_18" rel="nofollow">二：下载SDK及ORB-SLAM源码</a></li><li><a href="#_26" rel="nofollow">三：修改源码</a></li><li><ul><li><ul><li><ul><li><a href="#1___28" rel="nofollow">1 . 源码路径</a></li><li><a href="#2__stereo_euroccc_33" rel="nofollow">2 . 修改stereo_euroc.cc文件</a></li><li><ul><li><ul><li><a href="#1_43" rel="nofollow">1）将其橙色区域改成</a></li><li><a href="#2_90" rel="nofollow">2）添加时间转换函数</a></li><li><a href="#3LoadImages_111" rel="nofollow">3）删除LoadImages函数</a></li><li><a href="#4imagelCallback_113" rel="nofollow">4）添加回调函数imagelCallback</a></li><li><a href="#5show_ORB_152" rel="nofollow">5）添加show_ORB函数</a></li><li><a href="#6ros_223" rel="nofollow">6）ros初始化</a></li><li><a href="#7_LoadImages_285" rel="nofollow">7）删除 LoadImages函数</a></li></ul> 
     </li></ul> 
     </li><li><a href="#3__FileYamlh_289" rel="nofollow">3 . 新建FileYaml.h文件</a></li><li><a href="#4__FileYamlcc_428" rel="nofollow">4 . 新建FileYaml.cc文件</a></li><li><a href="#5__CMakeListstxt_539" rel="nofollow">5 . 修改CMakeLists.txt文件</a></li><li><ul><li><ul><li><a href="#1_545" rel="nofollow">1)</a></li><li><a href="#2_593" rel="nofollow">2）</a></li><li><a href="#3_612" rel="nofollow">3）</a></li><li><a href="#4_641" rel="nofollow">4）</a></li><li><a href="#5_656" rel="nofollow">5）</a></li></ul> 
     </li></ul> 
     </li><li><a href="#6__719" rel="nofollow">6. 编译</a></li><li><ul><li><ul><li><a href="#1_720" rel="nofollow">1）</a></li></ul> 
     </li></ul> 
     </li><li><a href="#7__726" rel="nofollow">7. 执行</a></li><li><ul><li><ul><li><a href="#1_727" rel="nofollow">1）</a></li><li><a href="#2_731" rel="nofollow">2）</a></li><li><a href="#3_744" rel="nofollow">3）</a></li></ul> 
     </li></ul> 
    </li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_9"></a>一：环境介绍</h2> 
<p>系统：Ubuntu 16.04 ROS</p> 
<p>ORB依赖库：Pangolin、OpenCV、Eigen3、DBoW2、g2o,ros</p> 
<h2><a id="SDKORBSLAM_18"></a>二：下载SDK及ORB-SLAM源码</h2> 
<p>下载地址：</p> 
<p>SDK：<a href="http://indemind.cn/sdk.html" rel="nofollow">http://indemind.cn/sdk.html</a></p> 
<p>ORB-SLAM：<a href="https://github.com/raulmur/ORB_SLAM2">https://github.com/raulmur/ORB_SLAM2</a></p> 
<h2><a id="_26"></a>三：修改源码</h2> 
<h5><a id="1___28"></a>1 . 源码路径</h5> 
<p>下载好SDK之后，进入SDK-Linux/demo_ros/src目录。将下载好源码的放在该目录下，并对其改名，改为 ORB_SLAM</p> 
<p><img src="https://images2.imgbox.com/bc/4d/gKRoJP3u_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2__stereo_euroccc_33"></a>2 . 修改stereo_euroc.cc文件</h5> 
<p>进入ORB_SLAM2/Examples/Stereo目录下，修改stereo_euroc.cc文件。</p> 
<p><img src="https://images2.imgbox.com/a4/dc/BAEapvZo_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="1_43"></a>1）将其橙色区域改成</h6> 
<p><img src="https://images2.imgbox.com/27/5e/8cjqhHmF_o.png" alt="在这里插入图片描述"></p> 
<p>代码如下：</p> 
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;fstream&gt;
#include&lt;iomanip&gt;
#include&lt;chrono&gt;
#include&lt;opencv2/core/core.hpp&gt;
#include&lt;System.h&gt;
#include "ros/ros.h"
#include &lt;cv_bridge/cv_bridge.h&gt;
#include &lt;sensor_msgs/Image.h&gt;
#include "std_msgs/String.h"
#include "FileYaml.h"
#include &lt;queue&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;condition_variable&gt;
using namespace std;
ros::Subscriber image_l_sub;
ros::Subscriber image_r_sub;
 
int image_l_count = 0;
queue&lt;cv::Mat&gt; que_image_l;
queue&lt;cv::Mat&gt; que_image_r;
queue&lt;long double&gt; que_stamp;
 
std::mutex limage_mutex;
std::mutex rimage_mutex;
std::condition_variable left_data_cond;
std::condition_variable right_data_cond;
//    std::lock_guard&lt;std::mutex&gt;lock(rimage_mutex);
//    std::thread show_thread{show_image}; //visualization thread
//    show_thread.detach();
 
cv::Mat imLeft;
cv::Mat imRight;
ros::Time ros_stamp;
long double stamp;
</code></pre> 
<p>修改后如下：</p> 
<p><img src="https://images2.imgbox.com/52/97/h5pzO33u_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="2_90"></a>2）添加时间转换函数</h6> 
<p>在代码，long double stamp;后添加时间转换函数</p> 
<pre><code>
long double time_tranform(int64_t time)
{
   
//取后13位
int b = time/1e13;
int64_t temp = b * 1e13;
int64_t c = time - temp;
   
//小数点后9位
long double d = c / 1e9;
return d;
}
</code></pre> 
<p>修改后如下：</p> 
<p><img src="https://images2.imgbox.com/01/b1/hKg2ds8j_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="3LoadImages_111"></a>3）删除LoadImages函数</h6> 
<p><img src="https://images2.imgbox.com/62/65/vC3rvEpM_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="4imagelCallback_113"></a>4）添加回调函数imagelCallback</h6> 
<p>在time_tranform和main函数之间添加左图回调函数imagelCallback，添加右图回调函数imagerCallback，以及一些变量的定义</p> 
<p><img src="https://images2.imgbox.com/53/8d/OI5sixis_o.png" alt="在这里插入图片描述"><br> 代码如下：</p> 
<pre><code>
//image_l回调函数
void imagelCallback(const sensor_msgs::ImageConstPtr&amp;msg)
{
   cv_bridge::CvImagePtr cv_ptr;
   cv_ptr = cv_bridge::toCvCopy(msg, "mono8");
   cv_ptr-&gt;image.copyTo(imLeft);
   image_l_count = cv_ptr-&gt;header.seq;
   ros_stamp = cv_ptr-&gt;header.stamp;
std::lock_guard&lt;std::mutex&gt; lock_l(limage_mutex);
   stamp = time_tranform(ros_stamp.toNSec());
//cout&lt;&lt;"ros_stamp: "&lt;&lt;ros_stamp&lt;&lt;endl;
   que_image_l.push(imLeft);
   que_stamp.push(stamp);
}
//image_r回调函数
void imagerCallback(const sensor_msgs::ImageConstPtr&amp;msg)
{
   cv_bridge::CvImagePtr cv_ptr;
   cv_ptr = cv_bridge::toCvCopy(msg, "mono8");
   cv_ptr-&gt;image.copyTo(imRight);
std::lock_guard&lt;std::mutex&gt; lock_r(rimage_mutex);
   que_image_r.push(imRight);
}
Camera_Other_Parameter vecCamerasParam;
cv::Mat M1l,M2l,M1r,M2r;
cv::Mat data_left;
cv::Mat data_right;
long double frame_time;
cv::Mat imLeftRect, imRightRect;

</code></pre> 
<h6><a id="5show_ORB_152"></a>5）添加show_ORB函数</h6> 
<p>在cv::Mat imLeftRect, imRightRect;之后，添加show_ORB函数，用于获取图像数据和时间，以及启动ORB的功能</p> 
<p><img src="https://images2.imgbox.com/96/98/BwGYuNTp_o.png" alt="在这里插入图片描述"><br> 代码如下：</p> 
<pre><code>void show_ORB()
{
//-----------------ORB_SLAM2 Init---------------------------------------------
const string param1_ORBvoc = "Vocabulary/ORBvoc.txt";
    
const string param3_ORByaml = "Examples/Stereo/EuRoC.yaml";
    
    
    ORB_SLAM2::System SLAM(param1_ORBvoc,param3_ORByaml,ORB_SLAM2::System::STEREO,true);
std::this_thread::sleep_for(std::chrono::milliseconds(500));
while(true)
    {
std::this_thread::sleep_for(std::chrono::milliseconds(30));
std::unique_lock&lt;std::mutex&gt; lock_l(limage_mutex);
        data_left = que_image_l.front();
  frame_time = que_stamp.front();
  que_image_l.pop();
  que_stamp.pop();
  lock_l.unlock();
std::unique_lock&lt;std::mutex&gt; lock_r(rimage_mutex);
        data_right = que_image_r.front();
  que_image_r.pop();
  lock_r.unlock();
//   cout.precision(13);
//  cout&lt;&lt;"frame: "&lt;&lt;frame_time&lt;&lt;endl;
  
  cv::resize(data_left,data_left,cv::Size(vecCamerasParam.cols,vecCamerasParam.rows));
  cv::resize(data_right,data_right,cv::Size(vecCamerasParam.cols,vecCamerasParam.rows));
  cv::remap(data_left,imLeftRect,M1l,M2l,cv::INTER_LINEAR);
        cv::remap(data_right,imRightRect,M1r,M2r,cv::INTER_LINEAR);
#ifdef COMPILEDWITHC11
std::chrono::steady_clock::time_point t1 = std::chrono::steady_clock::now();
#else
std::chrono::monotonic_clock::time_point t1 = std::chrono::monotonic_clock::now();
#endif
  SLAM.TrackStereo(imLeftRect,imRightRect,frame_time);
#ifdef COMPILEDWITHC11
std::chrono::steady_clock::time_point t2 = std::chrono::steady_clock::now();
#else
std::chrono::monotonic_clock::time_point t2 = std::chrono::monotonic_clock::now();
#endif
double ttrack= std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt; &gt;(t2 - t1).count();
  
// Wait to load the next frame
double T = 0;
            T = que_stamp.front() - frame_time;

if(ttrack &lt; T)
            usleep((T-ttrack)*1e6);
  
/*  
  cv::imshow("left",data_left);
  cv::imshow("right",data_right);
  cv::waitKey(1);*/
    }
// Stop all threads
    SLAM.Shutdown();
// Save camera trajectory
    SLAM.SaveTrajectoryTUM("CameraTrajectory.txt");
</code></pre> 
<p>修改后如下：</p> 
<p><img src="https://images2.imgbox.com/69/83/Rrm8soeW_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="6ros_223"></a>6）ros初始化</h6> 
<p>将main函数内的内容全部删除，在main函数内添加ros初始化，读取配置文件，去畸变，获取参数，校正，ORB_SLAM的启动</p> 
<p><img src="https://images2.imgbox.com/d1/19/eotKk9jU_o.png" alt="在这里插入图片描述"><br> 代码如下：</p> 
<pre><code>
 ros::init(argc,argv,"ORB_SLAM2");
    ros::NodeHandle n;
    image_l_sub = n.subscribe("/module/image_left",100,imagelCallback);
    image_r_sub = n.subscribe("/module/image_right", 100,imagerCallback);
    
    
const char *param2_SDKyaml =  "/home/indemind/u/SDK-Linux-ros/lib/1604/headset.yaml";
    readConfig(param2_SDKyaml,vecCamerasParam);
//-----------------fisheye rectify---------------------------------------------
    cv::Mat Q;
    
if(vecCamerasParam.K_l.empty() || vecCamerasParam.K_r.empty() || vecCamerasParam.P_l.empty() || vecCamerasParam.P_r.empty() || vecCamerasParam.R_l.empty() ||
      vecCamerasParam.R_r.empty() || vecCamerasParam.D_l.empty() || vecCamerasParam.D_r.empty() || vecCamerasParam.rows==0 || vecCamerasParam.cols==0)
    {
cerr &lt;&lt; "ERROR: Calibration parameters to rectify stereo are missing!" &lt;&lt; endl;
return -1;
    }
    
    cv::fisheye::initUndistortRectifyMap(vecCamerasParam.K_l,vecCamerasParam.D_l,vecCamerasParam.R_l,vecCamerasParam.P_l.rowRange(0,3).colRange(0,3),
           cv::Size(vecCamerasParam.cols,vecCamerasParam.rows),CV_32FC1,M1l,M2l);
    cv::fisheye::initUndistortRectifyMap(vecCamerasParam.K_r,vecCamerasParam.D_r,vecCamerasParam.R_r,vecCamerasParam.P_r.rowRange(0,3).colRange(0,3),
           cv::Size(vecCamerasParam.cols,vecCamerasParam.rows),CV_32FC1,M1r,M2r);
cout &lt;&lt; "the P_l of initUndistortRectifyMap after" &lt;&lt; endl;
for(int i = 0;i &lt; 3;++i)
for(int j = 0;j &lt; 3;++j)
      {
double *ptr = vecCamerasParam.P_l.ptr&lt;double&gt;(i,j);
cout &lt;&lt; *ptr&lt;&lt;endl;
      }

cout &lt;&lt; "the P_r of initUndistortRectifyMap after" &lt;&lt; endl;
for(int i = 0;i &lt; 3;++i)
for(int j = 0;j &lt; 3;++j)
      {
double *ptr = vecCamerasParam.P_r.ptr&lt;double&gt;(i,j);
cout &lt;&lt; *ptr&lt;&lt;endl;
      }
    cv::stereoRectify(vecCamerasParam.K_l,vecCamerasParam.D_l,vecCamerasParam.K_r,vecCamerasParam.D_r,cv::Size(vecCamerasParam.cols,vecCamerasParam.rows),
          vecCamerasParam.R,vecCamerasParam.t,vecCamerasParam.R_l,vecCamerasParam.R_r,vecCamerasParam.P_l,vecCamerasParam.P_r,Q,cv::CALIB_ZERO_DISPARITY,0);

  
//-----------------fisheye end---------------------------------------------
std::thread show_thread{show_ORB}; //visualization thread
        

    show_thread.detach();
    ros::spin();
    

return 0;
</code></pre> 
<p>修改后如下：<br> <img src="https://images2.imgbox.com/a0/a2/EFhDzfn8_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="7_LoadImages_285"></a>7）删除 LoadImages函数</h6> 
<p><img src="https://images2.imgbox.com/8e/a3/PbBpRm4p_o.png" alt="在这里插入图片描述"><br> <strong>文件修改完成！</strong></p> 
<h5><a id="3__FileYamlh_289"></a>3 . 新建FileYaml.h文件</h5> 
<p>进入SDK-Linux/demo_ros/src/ORB_SLAM2/include目录下，新建FileYaml.h文件，将下列代码填入文件：</p> 
<pre><code>
#ifndef _FILEYAML_H
#define _FILEYAML_H


#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

#include &lt;opencv/cv.h&gt;
#include &lt;opencv2/calib3d.hpp&gt;
#include &lt;opencv2/features2d/features2d.hpp&gt;
#include&lt;opencv2/opencv.hpp&gt;

#include &lt;Eigen/Core&gt;
#include &lt;opencv2/core/eigen.hpp&gt;

#include &lt;sophus/so3.h&gt;
#include &lt;sophus/se3.h&gt;
#include &lt;chrono&gt;
using namespace cv;
using namespace Eigen;
using namespace Sophus;

using cv::FileStorage;
using cv::FileNode;
struct Camera
{
    Eigen::Matrix4d T_SC;
    Eigen::Vector2d imageDimension;
    Eigen::VectorXd distortionCoefficients;
    Eigen::Vector2d focalLength;
    Eigen::Vector2d principalPoint;
std::string distortionType;

    Camera() :
            T_SC(Eigen::Matrix4d::Identity()),
            imageDimension(Eigen::Vector2d(1280, 800)),
            distortionCoefficients(Eigen::Vector2d(0, 0)),
            focalLength(Eigen::Vector2d(700, 700)),
            principalPoint(Eigen::Vector2d(640, 400)),
            distortionType("equidistant")
    {

    }

void write(FileStorage&amp; fs) const //Write serialization for this class
{
        fs &lt;&lt; "{:";

        fs &lt;&lt; "T_SC";
        fs &lt;&lt; "[:";
for (int i = 0; i &lt; 4; i++)
        {
for (int j = 0; j &lt; 4; j++)
            {
                fs &lt;&lt; T_SC(i, j);
            }
        }
        fs &lt;&lt; "]";
        fs &lt;&lt; "image_dimension";
        fs &lt;&lt; "[:";
        fs &lt;&lt; imageDimension(0) &lt;&lt; imageDimension(1);
        fs &lt;&lt; "]";

        fs &lt;&lt; "distortion_coefficients";
        fs &lt;&lt; "[:";
for (int i = 0; i &lt; distortionCoefficients.rows(); i++)
        {
            fs &lt;&lt; distortionCoefficients(i);
        }
        fs &lt;&lt; "]";

        fs &lt;&lt; "distortion_type" &lt;&lt; distortionType;

        fs &lt;&lt; "focal_length";
        fs &lt;&lt; "[:";
        fs &lt;&lt; focalLength(0) &lt;&lt; focalLength(1);
        fs &lt;&lt; "]";

        fs &lt;&lt; "principal_point";
        fs &lt;&lt; "[:";
        fs &lt;&lt; principalPoint(0) &lt;&lt; principalPoint(1);
        fs &lt;&lt; "]";

        fs &lt;&lt; "}";
    }

void read(const FileNode&amp; node)  //Read serialization for this class
{
        cv::FileNode T_SC_node = node["T_SC"];
        cv::FileNode imageDimensionNode = node["image_dimension"];
        cv::FileNode distortionCoefficientNode = node["distortion_coefficients"];
        cv::FileNode focalLengthNode = node["focal_length"];
        cv::FileNode principalPointNode = node["principal_point"];

// extrinsics
        T_SC &lt;&lt; T_SC_node[0], T_SC_node[1], T_SC_node[2], T_SC_node[3], T_SC_node[4], T_SC_node[5], T_SC_node[6], T_SC_node[7], T_SC_node[8], T_SC_node[9], T_SC_node[10], T_SC_node[11], T_SC_node[12], T_SC_node[13], T_SC_node[14], T_SC_node[15];

        imageDimension &lt;&lt; imageDimensionNode[0], imageDimensionNode[1];
        distortionCoefficients.resize(distortionCoefficientNode.size());
for (size_t i = 0; i&lt;distortionCoefficientNode.size(); ++i) {
            distortionCoefficients[i] = distortionCoefficientNode[i];
        }
        focalLength &lt;&lt; focalLengthNode[0], focalLengthNode[1];
        principalPoint &lt;&lt; principalPointNode[0], principalPointNode[1];
        distortionType = (std::string)(node["distortion_type"]);
    }
};

struct Camera_Other_Parameter
{
    Mat K_l;
    Mat K_r;
    Mat D_l;
    Mat D_r;
    Mat R_l;
    Mat R_r;
    Mat P_l;
    Mat P_r;
    Mat R;
    Mat t;
int cols;    //图像宽
int rows;    //图像高
};

void readConfig(const char *yamlPath,Camera_Other_Parameter &amp;vecCamerasOtherParam);


#endif

</code></pre> 
<p><strong>注：该文件为读取文件的头文件</strong></p> 
<h5><a id="4__FileYamlcc_428"></a>4 . 新建FileYaml.cc文件</h5> 
<p>进入SDK-Linux/demo_ros/src/ORB_SLAM2/src目录下，新建FileYaml.cc文件，将下列代码填入文件：</p> 
<pre><code>#include "FileYaml.h"


static void write(FileStorage&amp; fs, const std::string&amp;, const Camera&amp; x)
{
     x.write(fs);
}

static void read(const FileNode&amp; node, Camera&amp; x, const Camera&amp; default_value = Camera())
{
if (node.empty())
        x = default_value;
else
        x.read(node);
}

void readConfig(const char *yamlPath,Camera_Other_Parameter &amp;vecCamerasOtherParam)
{
std::vector&lt;Camera&gt; vecCameras;
    cv::FileStorage fin(yamlPath, cv::FileStorage::READ);
if(!fin.isOpened())
    {
cerr &lt;&lt; endl &lt;&lt; "Failed to load readConfig yamlPath " &lt;&lt; endl;
return ;
    }
      
    cv::FileNode cameras_node = fin["cameras"];
/*    
    cv::FileNode Rl_node = fin["Rl"];
    cv::FileNode Rr_node = fin["Rr"];
    cv::FileNode Pl_node = fin["Pl"];
    cv::FileNode Pr_node = fin["Pr"];
    cv::FileNode Kl_node = fin["Kl"];
    cv::FileNode Kr_node = fin["Kr"];
    cv::FileNode Dl_node = fin["Dl"];
    cv::FileNode Dr_node = fin["Dr"];*/
    
    fin["Rl"] &gt;&gt; vecCamerasOtherParam.R_l;
    fin["Rr"] &gt;&gt; vecCamerasOtherParam.R_r;
    fin["Pl"] &gt;&gt; vecCamerasOtherParam.P_l;
    fin["Pr"] &gt;&gt; vecCamerasOtherParam.P_r;
    fin["Kl"] &gt;&gt; vecCamerasOtherParam.K_l;
    fin["Kr"] &gt;&gt; vecCamerasOtherParam.K_r;
    fin["Dl"] &gt;&gt; vecCamerasOtherParam.D_l;
    fin["Dr"] &gt;&gt; vecCamerasOtherParam.D_r;

/*
    vecCamerasOtherParam.R_l = Rl_node.mat();
    vecCamerasOtherParam.R_r = Rr_node.mat();
    vecCamerasOtherParam.P_l = Pl_node.mat();
    vecCamerasOtherParam.P_r = Pr_node.mat();
    vecCamerasOtherParam.K_l = Kl_node.mat();
    vecCamerasOtherParam.K_r = Kr_node.mat();
    vecCamerasOtherParam.D_l = Dl_node.mat();
    vecCamerasOtherParam.D_r = Dr_node.mat();*/

for (cv::FileNodeIterator it = cameras_node.begin(); it != cameras_node.end(); it++)
    {
        Camera camera;
        (*it) &gt;&gt; camera;
        vecCameras.push_back(camera);
    }

//obtain col &amp; row
    vecCamerasOtherParam.cols = vecCameras[0].imageDimension(0);
    vecCamerasOtherParam.rows = vecCameras[0].imageDimension(1);
//obtain R &amp; t
    Eigen::Matrix4d T_SC_left;
    Eigen::Matrix4d T_SC_right;
    T_SC_left  = vecCameras[0].T_SC;
    T_SC_right = vecCameras[1].T_SC;
SE3 T_SC_l(T_SC_left.topLeftCorner(3,3),T_SC_left.topRightCorner(3,1));
SE3 T_SC_r(T_SC_right.topLeftCorner(3,3),T_SC_right.topRightCorner(3,1));
    SE3 Tcl_cr = T_SC_l.inverse()*T_SC_r;
    SE3 Tcr_cl = T_SC_r.inverse()*T_SC_l;
    Matrix3d R = Tcr_cl.rotation_matrix();
    Vector3d t = Tcr_cl.translation();
    
//Eigen tranfer to array
double * R_ptr= new double[R.size()];
double *t_ptr = new double[t.size()];
    Map&lt;MatrixXd&gt;(R_ptr, R.rows(), R.cols()) = R;
    Map&lt;MatrixXd&gt;(t_ptr, t.rows(), t.cols()) = t;
cout&lt;&lt;"R_matrix"&lt;&lt;endl;
double R_matrix[3][3];
for(int i = 0;i &lt; 3;i++)
for(int j = 0;j&lt;3;j++)
      {
//transpose
    R_matrix[j][i] = R_ptr[i+j*3];
cout&lt;&lt;R_matrix[j][i]&lt;&lt;endl;
      }
       
cout&lt;&lt;"t_matrix"&lt;&lt;endl;
double t_matrix[3];
for(int i = 0;i &lt; 3;i++)
    {
  t_matrix[i] = t_ptr[i];
cout&lt;&lt;t_matrix[i]&lt;&lt;endl;
    }
    vecCamerasOtherParam.R = cv::Mat(3,3,CV_64FC1,R_matrix);
    vecCamerasOtherParam.t = cv::Mat(3,1,CV_64FC1,t_matrix);
}

</code></pre> 
<p><strong>注：该文件为读取文件的源文件</strong></p> 
<h5><a id="5__CMakeListstxt_539"></a>5 . 修改CMakeLists.txt文件</h5> 
<p>进入SDK-Linux/demo_ros/src目录下，修改CMakeLists.txt文件</p> 
<p>将ORB中的CMakeLists.txt添加到SDK的CMakeLists.txt下，修改如下：</p> 
<h6><a id="1_545"></a>1)</h6> 
<p>在add_compile_options(-std=c++11)后面添加</p> 
<pre><code>
IF(NOT CMAKE_BUILD_TYPE)
SET(CMAKE_BUILD_TYPE Release)
ENDIF()

MESSAGE("Build type: " ${CMAKE_BUILD_TYPE})

set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS}  -Wall  -O3 -march=native ")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall   -O3 -march=native")

# Check C++11 or C++0x support
include(CheckCXXCompilerFlag)
CHECK_CXX_COMPILER_FLAG("-std=c++11" COMPILER_SUPPORTS_CXX11)
CHECK_CXX_COMPILER_FLAG("-std=c++0x" COMPILER_SUPPORTS_CXX0X)
if(COMPILER_SUPPORTS_CXX11)
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
   add_definitions(-DCOMPILEDWITHC11)
   message(STATUS "Using flag -std=c++11.")
elseif(COMPILER_SUPPORTS_CXX0X)
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++0x")
   add_definitions(-DCOMPILEDWITHC0X)
   message(STATUS "Using flag -std=c++0x.")
else()
   message(FATAL_ERROR "The compiler ${CMAKE_CXX_COMPILER} has no C++11 support. Please use a different C++ compiler.")
endif()

LIST(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake_modules)

find_package(OpenCV 3.0 QUIET)
if(NOT OpenCV_FOUND)
   find_package(OpenCV 2.4.3 QUIET)
if(NOT OpenCV_FOUND)
      message(FATAL_ERROR "OpenCV &gt; 2.4.3 not found.")
   endif()
endif()

#find_package(Eigen3 3.1.0 REQUIRED)
find_package(Pangolin REQUIRED)

</code></pre> 
<p>修改后如下：</p> 
<p><img src="https://images2.imgbox.com/73/a2/WB9jrczL_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="2_593"></a>2）</h6> 
<p><img src="https://images2.imgbox.com/f1/bc/Ypt4WQhu_o.png" alt="在这里插入图片描述"></p> 
<pre><code>
#Eigen
include_directories("/usr/include/eigen3")
#Sophus
find_package(Sophus REQUIRED)
include_directories( ${Sophus_INCLUDE_DIRS})
include_directories(
${PROJECT_SOURCE_DIR}
${PROJECT_SOURCE_DIR}/ORB_SLAM/include
${PROJECT_SOURCE_DIR}/ORB_SLAM
#${EIGEN3_INCLUDE_DIR}
${Pangolin_INCLUDE_DIRS}
)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/lib)
</code></pre> 
<h6><a id="3_612"></a>3）</h6> 
<p><img src="https://images2.imgbox.com/f2/ab/WYm3uRg2_o.png" alt="在这里插入图片描述"></p> 
<pre><code>
add_library(${PROJECT_NAME} SHARED
ORB_SLAM/src/FileYaml.cc
ORB_SLAM/src/System.cc
ORB_SLAM/src/Tracking.cc
ORB_SLAM/src/LocalMapping.cc
ORB_SLAM/src/LoopClosing.cc
ORB_SLAM/src/ORBextractor.cc
ORB_SLAM/src/ORBmatcher.cc
ORB_SLAM/src/FrameDrawer.cc
ORB_SLAM/src/Converter.cc
ORB_SLAM/src/MapPoint.cc
ORB_SLAM/src/KeyFrame.cc
ORB_SLAM/src/Map.cc
ORB_SLAM/src/MapDrawer.cc
ORB_SLAM/src/Optimizer.cc
ORB_SLAM/src/PnPsolver.cc
ORB_SLAM/src/Frame.cc
ORB_SLAM/src/KeyFrameDatabase.cc
ORB_SLAM/src/Sim3Solver.cc
ORB_SLAM/src/Initializer.cc
ORB_SLAM/src/Viewer.cc

</code></pre> 
<h6><a id="4_641"></a>4）</h6> 
<p><img src="https://images2.imgbox.com/90/fd/7h8qFRi1_o.png" alt="在这里插入图片描述"><br> 将其修改为：</p> 
<pre><code>target_link_libraries(${PROJECT_NAME}
${OpenCV_LIBS}
#${EIGEN3_LIBS}
${Pangolin_LIBRARIES}
${Sophus_LIBRARIES}
${PROJECT_SOURCE_DIR}/ORB_SLAM/Thirdparty/DBoW2/lib/libDBoW2.so
${PROJECT_SOURCE_DIR}/ORB_SLAM/Thirdparty/g2o/lib/libg2o.so
)

</code></pre> 
<h6><a id="5_656"></a>5）</h6> 
<p>完成4）操作后，在其后添加：</p> 
<pre><code>set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/ORB_SLAM/Examples/RGB-D)

add_executable(rgbd_tum
ORB_SLAM/Examples/RGB-D/rgbd_tum.cc)
target_link_libraries(rgbd_tum ${PROJECT_NAME}
${Sophus_LIBRARIES})
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/ORB_SLAM/Examples/Stereo)

add_executable(stereo_kitti
ORB_SLAM/Examples/Stereo/stereo_kitti.cc)
target_link_libraries(stereo_kitti ${PROJECT_NAME}
${Sophus_LIBRARIES})

add_executable(stereo_euroc
ORB_SLAM/Examples/Stereo/stereo_euroc.cc)
add_dependencies(stereo_euroc ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})
target_link_libraries(stereo_euroc ${PROJECT_NAME}
${Sophus_LIBRARIES}
${catkin_LIBRARIES})

add_executable(module_driver src/camera_driver.cpp)
add_dependencies(module_driver ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})
target_link_libraries(module_driver
${PROJECT_SOURCE_DIR}/../../lib/1604/libindem.so
${catkin_LIBRARIES}
${PROJECT_SOURCE_DIR}/../../lib/1604/libboost_filesystem.so.1.58.0
${PROJECT_SOURCE_DIR}/../../lib/1604/libboost_system.so.1.58.0
${PROJECT_SOURCE_DIR}/../../lib/1604/libg3logger.so.1.3.0-0
${PROJECT_SOURCE_DIR}/../../lib/1604/libnanomsg.so.5
${PROJECT_SOURCE_DIR}/../../lib/1604/libopencv_core.so.3.4
${PROJECT_SOURCE_DIR}/../../lib/1604/libopencv_imgproc.so.3.4
${PROJECT_SOURCE_DIR}/../../lib/1604/libopencv_videoio.so.3.4
  pthread
  stdc++fs
  dl
)

set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/ORB_SLAM/Examples/Monocular)

add_executable(mono_tum
ORB_SLAM/Examples/Monocular/mono_tum.cc)
target_link_libraries(mono_tum
${Sophus_LIBRARIES}
${PROJECT_NAME})

add_executable(mono_kitti
ORB_SLAM/Examples/Monocular/mono_kitti.cc)
target_link_libraries(mono_kitti
${Sophus_LIBRARIES}
${PROJECT_NAME})

add_executable(mono_euroc
ORB_SLAM/Examples/Monocular/mono_euroc.cc)
target_link_libraries(mono_euroc
${Sophus_LIBRARIES}
${PROJECT_NAME})
</code></pre> 
<p><strong>CMakeLists.txt修改完毕</strong></p> 
<h5><a id="6__719"></a>6. 编译</h5> 
<h6><a id="1_720"></a>1）</h6> 
<p>安装INDEMIND SDK，教程请查看：<a href="https://blog.csdn.net/weixin_43922139/article/details/85159973">开讲啦丨INDEMIND双目惯性模组运行ORB-SLAM算法示例</a></p> 
<p>进入SDK-Linux/demo_ros目录下，执行catkin_make命令，结果如下</p> 
<p><img src="https://images2.imgbox.com/b7/8b/fwyuG5rF_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="7__726"></a>7. 执行</h5> 
<h6><a id="1_727"></a>1）</h6> 
<p>新打开一个shell，执行roscore命令，如下图<br> <img src="https://images2.imgbox.com/48/fe/08FJZXS8_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="2_731"></a>2）</h6> 
<p>进入SDK-Linux/lib/1604目录下，执行</p> 
<pre><code>
sudo -s，sudo chmod 777 ./run.sh
</code></pre> 
<p>之后执行</p> 
<pre><code>./run.sh
</code></pre> 
<h6><a id="3_744"></a>3）</h6> 
<p>进入SDK-Linux/demo_ros/src/ORB_SLAM目录下，执行./Examples/Stereo/stereo_euroc命令</p> 
<p><img src="https://images2.imgbox.com/43/bd/58jvTW87_o.png" alt="在这里插入图片描述"></p> 
<p><strong>注意：此时，将获得去畸变之后的参数，把下列参数写入到SDK-Linux/demo_ros/src/ORB_SLAM/src/Tracking.cc文件中，如下图</strong></p> 
<pre><code>
float fx = 597.935;
float fy = 597.935;
float cx = 476.987;
float cy = 442.158;
</code></pre> 
<p><img src="https://images2.imgbox.com/b3/f6/ox9KUyPx_o.png" alt="在这里插入图片描述"></p> 
<p>最后，再次编译，并执行，即可得到实时ORB</p> 
<p>Demo连接：<a href="https://v.qq.com/x/page/i0849bgkr93.html" rel="nofollow">腾讯视频</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3a3cb7a7013589efc29b5e4d478fcc64/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">NAS 详细搭建方案 - 安装Emby</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a161dec1559c8d3d221fc4f3539d5a04/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Canvas render mode 设置为World Space不响应事件问题排查</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>