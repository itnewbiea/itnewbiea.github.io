<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>操作系统：进程地址空间 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="操作系统：进程地址空间" />
<meta property="og:description" content="操作系统在管理内存时，每个进程都有一个独立的进程地址空间，进程地址空间的地址为虚拟地址，对于32位操作系统，该虚拟地址空间为2^32=4GB。其中0-3G是用户空间，3G-4G是内核空间。但4G的地址空间是不存在的，也就是我们所说的虚拟内存空间。进程在执行的时候，看到和使用的内存地址都是虚拟地址。
操作系统通过MMU部件将进程使用的虚拟地址转换为物理地址。进程使用虚拟内存中的地址，由操作系统协助相关硬件，把它“转换”成真正的物理地址。虚拟地址通过页表(Page Table)映射到物理内存，页表由操作系统维护并被处理器引用。内核空间在页表中拥有较高特权级，因此用户态程序试图访问这些页时会导致一个页错误(page fault)。在Linux中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。内核代码和数据总是可寻址，随时准备处理中断和系统调用。与此相反，用户模式地址空间的映射随进程切换的发生而不断变化。 地址空间是一个非负整数地址的有序集合。｛0， 1， 2，……｝ 如果地址空间中的整数是连续的，那么我们说他是一个线性地址空间。在一个带虚拟内存的系统中，CPU从一个有N = 2^n个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间。 一个系统还有一个物理地址空间，对应于系统中物理内存的M个字节。 地址空间的概念是很重要的，因为它清楚地区分了数据对象（字节）和它们的属性（地址）。允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟内存的基本思想。主存中的每字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。
虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。 VM系统通过将虚拟内存分割为称为虚拟页的大小固定的块来处理这个问题。每个虚拟页的大小为P=2^pz字节。类似的，物理内存被分割为物理页，大小也为P字节（物理页也被称为页帧）。 关于堆和栈
1） 数据结构的栈和堆
首先在数据结构上要知道堆栈，虽然我们这么称呼它，但实际上堆栈是两种数据结构：堆和栈。
堆和栈都是一种数据项按序排列的数据结构。
栈就像装数据的桶或箱子，堆像一棵倒过来的树 从栈说起，它是一种具有后进先出性质的数据结构，也就是说后存放的先取。先存放的后取。 而堆就不同了。堆是一种经过排序的树形数据结构。每一个结点都有一个值。
通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大）。且根结点的两个子树也是一个堆。因为堆的这个特性，经常使用来实现优先队列，堆的存取是随意。
2） 内存分配中的栈和堆 内存中的栈区处于相对较高的地址以地址的增长方向为上的话，栈地址是向下增长的。栈中分配局部变量空间。堆区是向上增长的用于分配程序猿申请的内存空间。另外还有静态 区是分配静态变量，全局变量空间的；仅仅读区是分配常量和程序代码空间的；以及其它一些分区。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6eaf0484440083481ef6c1d06df12747/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-20T21:26:13+08:00" />
<meta property="article:modified_time" content="2018-08-20T21:26:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">操作系统：进程地址空间</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>操作系统在管理内存时，每个进程都有一个独立的进程地址空间，进程地址空间的地址为虚拟地址，对于32位操作系统，该虚拟地址空间为2^32=4GB。其中0-3G是用户空间，3G-4G是内核空间。但4G的地址空间是不存在的，也就是我们所说的虚拟内存空间。进程在执行的时候，看到和使用的内存地址都是虚拟地址。</p> 
<p>操作系统通过MMU部件将进程使用的虚拟地址转换为物理地址。进程使用虚拟内存中的地址，由操作系统协助相关硬件，把它“转换”成真正的物理地址。虚拟地址通过页表(Page Table)映射到物理内存，页表由操作系统维护并被处理器引用。内核空间在页表中拥有较高特权级，因此用户态程序试图访问这些页时会导致一个页错误(page fault)。在Linux中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。内核代码和数据总是可寻址，随时准备处理中断和系统调用。与此相反，用户模式地址空间的映射随进程切换的发生而不断变化。 <br> <img src="https://images2.imgbox.com/c6/74/64nqZzim_o.jpg" alt="图" title=""></p> 
<p>地址空间是一个非负整数地址的有序集合。｛0， 1， 2，……｝ <br> 如果地址空间中的整数是连续的，那么我们说他是一个线性地址空间。在一个带虚拟内存的系统中，CPU从一个有N = 2^n个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间。 <br> 一个系统还有一个物理地址空间，对应于系统中物理内存的M个字节。 <br> 地址空间的概念是很重要的，因为它清楚地区分了数据对象（字节）和它们的属性（地址）。允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟内存的基本思想。主存中的每字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p> 
<p>虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。 <br> VM系统通过将虚拟内存分割为称为虚拟页的大小固定的块来处理这个问题。每个虚拟页的大小为P=2^pz字节。类似的，物理内存被分割为物理页，大小也为P字节（物理页也被称为页帧）。 <br> <img src="https://images2.imgbox.com/ec/40/vSVJSSrT_o.jpg" alt="一个VM系统" title=""></p> 
<p>关于堆和栈</p> 
<p>1） 数据结构的栈和堆</p> 
<p>首先在数据结构上要知道堆栈，虽然我们这么称呼它，但实际上堆栈是两种数据结构：堆和栈。</p> 
<p>堆和栈都是一种数据项按序排列的数据结构。</p> 
<p>栈就像装数据的桶或箱子，堆像一棵倒过来的树 <br> 从栈说起，它是一种具有后进先出性质的数据结构，也就是说后存放的先取。先存放的后取。 <br> 而堆就不同了。堆是一种经过排序的树形数据结构。每一个结点都有一个值。</p> 
<p>通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大）。且根结点的两个子树也是一个堆。因为堆的这个特性，经常使用来实现优先队列，堆的存取是随意。</p> 
<p>2） 内存分配中的栈和堆 <br> 内存中的栈区处于相对较高的地址以地址的增长方向为上的话，栈地址是向下增长的。栈中分配局部变量空间。堆区是向上增长的用于分配程序猿申请的内存空间。另外还有静态 <br> 区是分配静态变量，全局变量空间的；仅仅读区是分配常量和程序代码空间的；以及其它一些分区。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ed3b9c9fdd8e88eff41f4a5d0df5ed80/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Selenium启动Firefox示例(python版)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b44a63a8494fe7a1db60fe0b3fdbd307/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">turtle库的使用(笔记)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>