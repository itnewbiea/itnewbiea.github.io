<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>如何在 Ubuntu 20.04 上设置 SSH 密钥 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="如何在 Ubuntu 20.04 上设置 SSH 密钥" />
<meta property="og:description" content="前些天发现了一个人工智能学习网站，通俗易懂，风趣幽默，最重要的屌图甚多，忍不住分享一下给大家。点击跳转到网站。
如何在 Ubuntu 20.04 上设置 SSH 密钥 介绍 SSH（即安全外壳）是一种加密协议，用于管理服务器并与服务器通信。使用 Ubuntu 服务器时，我们将大部分时间花在通过 SSH 连接到服务器的终端会话上。
下来将重点关注为 Ubuntu 20.04 安装设置 SSH 密钥，SSH 密钥提供了一种安全的登录服务器的方式。
第 1 步 — 创建密钥对 第一步是在客户端计算机（通常是个人计算机）上创建密钥对：
ssh-keygen 默认情况下，最新版本ssh-keygen将创建一个 3072 位 RSA 密钥对，这对于大多数用例来说足够安全（也可以选择传入标志-b 4096来创建更大的 4096 位密钥）。
输入命令后，应该看到以下输出：
OutputGenerating public/private rsa key pair. Enter file in which to save the key (/your_home/.ssh/id_rsa): 按 Enter 键将密钥对保存到.ssh/主目录的子目录中，或指定备用路径。
如果之前已经生成了 SSH 密钥对，可能会看到以下提示：
Output/home/your_home/.ssh/id_rsa already exists. Overwrite (y/n)? 如果选择覆盖磁盘上的密钥，将无法再使用以前的密钥进行身份验证。选择“是”时要非常小心，因为这是一个无法逆转的破坏性过程。
然后应该看到以下提示：
OutputEnter passphrase (empty for no passphrase): 可以选择在此处输入安全密码，强烈建议这样做。密码增加了额外的安全层，以防止未经授权的用户登录。要了解有关安全性的更多信息，请参阅：如何在 Linux 服务器上配置基于 SSH 密钥的身份验证。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ba92b202c8a7933d1334c894cb8e6ae5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-03T14:52:08+08:00" />
<meta property="article:modified_time" content="2024-01-03T14:52:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何在 Ubuntu 20.04 上设置 SSH 密钥</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>前些天发现了一个人工智能学习网站，通俗易懂，风趣幽默，最重要的屌图甚多，忍不住分享一下给大家。<a href="https://www.captainbed.cn/timi" rel="nofollow">点击跳转到网站</a>。</p> 
<h2><a id="_Ubuntu_2004__SSH__1"></a>如何在 Ubuntu 20.04 上设置 SSH 密钥</h2> 
<h4><a id="_3"></a>介绍</h4> 
<p>SSH（即安全外壳）是一种加密协议，用于管理服务器并与服务器通信。使用 Ubuntu 服务器时，我们将大部分时间花在通过 SSH 连接到服务器的终端会话上。</p> 
<p>下来将重点关注为 Ubuntu 20.04 安装设置 SSH 密钥，SSH 密钥提供了一种安全的登录服务器的方式。</p> 
<h3><a id="_1____9"></a>第 1 步 — 创建密钥对</h3> 
<p>第一步是在客户端计算机（通常是个人计算机）上创建密钥对：</p> 
<pre><code class="prism language-bash">ssh-keygen
</code></pre> 
<p>默认情况下，最新版本<code>ssh-keygen</code>将创建一个 3072 位 RSA 密钥对，这对于大多数用例来说足够安全（也可以选择传入标志<code>-b 4096</code>来创建更大的 4096 位密钥）。</p> 
<p>输入命令后，应该看到以下输出：</p> 
<pre><code>OutputGenerating public/private rsa key pair.
Enter file in which to save the key (/your_home/.ssh/id_rsa):
</code></pre> 
<p>按 Enter 键将密钥对保存到<code>.ssh/</code>主目录的子目录中，或指定备用路径。</p> 
<p>如果之前已经生成了 SSH 密钥对，可能会看到以下提示：</p> 
<pre><code>Output/home/your_home/.ssh/id_rsa already exists.
Overwrite (y/n)?
</code></pre> 
<p>如果选择覆盖磁盘上的密钥，将<strong>无法</strong>再使用以前的密钥进行身份验证。选择“是”时要非常小心，因为这是一个无法逆转的破坏性过程。</p> 
<p>然后应该看到以下提示：</p> 
<pre><code>OutputEnter passphrase (empty for no passphrase):
</code></pre> 
<p>可以选择在此处输入安全密码，强烈建议这样做。密码增加了额外的安全层，以防止未经授权的用户登录。要了解有关安全性的更多信息，请参阅：<a href="https://blog.csdn.net/qq_35241329/article/details/135363718?spm=1001.2014.3001.5501">如何在 Linux 服务器上配置基于 SSH 密钥的身份验证</a>。</p> 
<p>然后应该看到类似于以下内容的输出：</p> 
<pre><code>OutputYour identification has been saved in /your_home/.ssh/id_rsa
Your public key has been saved in /your_home/.ssh/id_rsa.pub
The key fingerprint is:
SHA256:/hk7MJ5n5aiqdfTVUZr+2Qt+qCiS7BIm5Iv0dxrc3ks user@host
The key's randomart image is:
+---[RSA 3072]----+
|                .|
|               + |
|              +  |
| .           o . |
|o       S   . o  |
| + o. .oo. ..  .o|
|o = oooooEo+ ...o|
|.. o *o+=.*+o....|
|    =+=ooB=o.... |
+----[SHA256]-----+
</code></pre> 
<p>现在拥有可用于进行身份验证的公钥和私钥。下一步是将公钥放在服务器上，以便可以使用基于 SSH 密钥的身份验证进行登录。</p> 
<h3><a id="_2____Ubuntu__68"></a>第 2 步 — 将公钥复制到 Ubuntu 服务器</h3> 
<p>将公钥复制到 Ubuntu 主机的最快方法是使用名为<code>ssh-copy-id</code> 的实用程序。由于其简单性，强烈推荐此方法（如果可用）。如果客户端计算机上没有<code>ssh-copy-id</code>可用的密钥，可以使用通过基于密码的 SSH 进行复制，或手动复制密钥。</p> 
<h4><a id="sshcopyid_72"></a>使用复制公钥<code>ssh-copy-id</code></h4> 
<p>该<code>ssh-copy-id</code>工具默认包含在许多操作系统中，因此可以在本地系统上使用它。这个的前提是必须已经具有对服务器的基于密码的 SSH 访问权限。</p> 
<p>首先将SSH 公钥复制到该帐户。</p> 
<pre><code class="prism language-bash">ssh-copy-id username@remote_host
</code></pre> 
<p>会看到以下消息：</p> 
<pre><code>OutputThe authenticity of host '203.0.113.1 (203.0.113.1)' can't be established.
ECDSA key fingerprint is fd:fd:d4:f9:77:fe:73:84:e1:55:00:ad:d6:6d:22:fe.
Are you sure you want to continue connecting (yes/no)? yes
</code></pre> 
<p>这意味着本地计算机无法识别远程主机。这在第一次连接到新主机时发生。输入“是”并按<code>ENTER</code>继续。</p> 
<p>接下来，该实用程序将扫描本地帐户以查找我们之前创建的密钥。当它找到密钥时，它会提示输入远程用户帐户的密码：</p> 
<pre><code>Output/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
username@203.0.113.1's password:
</code></pre> 
<p>输入密码（出于安全目的，输入内容不会显示）并按<code>ENTER</code>。该实用程序将使用我们提供的密码连接到远程主机上的帐户。然后，它会将我们的密钥内容复制到远程帐户主目录中名为<code>~/.ssh``authorized_keys</code> 的<code>~/.ssh/id_rsa.pub</code>文件中。</p> 
<p>应该看到以下输出：</p> 
<pre><code>OutputNumber of key(s) added: 1

Now try logging into the machine, with:   "ssh 'username@203.0.113.1'"
and check to make sure that only the key(s) you wanted were added.
</code></pre> 
<p>此时，<code>id_rsa.pub</code>密钥已上传到远程帐户。</p> 
<h4><a id="_SSH__113"></a>使用 SSH 复制公钥</h4> 
<p>如果没有<code>ssh-copy-id</code>可用的帐户，但可以通过基于密码的 SSH 访问服务器上的帐户，则可以使用传统的 SSH 方法上传密钥。</p> 
<p>首先需要通过使用<code>cat</code>命令读取本地计算机上的公共 SSH 密钥的内容并通过管道将其通过 SSH 连接传输到远程服务器来完成此操作。</p> 
<p>其次确保该<code>~/.ssh</code>目录存在并且在我们正在使用的帐户下具有正确的权限。</p> 
<p>然后，我们可以将通过管道传输的内容输出到<code>authorized_keys</code>该目录中调用的文件中。我们将使用<code>&gt;&gt;</code>重定向符号附加内容而不是覆盖它。这将使我们能够添加密钥而不会破坏之前添加的密钥。</p> 
<p>完整的命令如下所示：</p> 
<pre><code class="prism language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub <span class="token operator">|</span> <span class="token function">ssh</span> username@remote_host <span class="token string">"mkdir -p ~/.ssh &amp;&amp; touch ~/.ssh/authorized_keys &amp;&amp; chmod -R go= ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys"</span>
</code></pre> 
<p>会看到以下消息：</p> 
<pre><code>OutputThe authenticity of host '203.0.113.1 (203.0.113.1)' can't be established.
ECDSA key fingerprint is fd:fd:d4:f9:77:fe:73:84:e1:55:00:ad:d6:6d:22:fe.
Are you sure you want to continue connecting (yes/no)? yes
</code></pre> 
<p>这意味着本地计算机无法识别远程主机。这将在第一次连接到新主机时发生。键入<code>yes</code>并按<code>ENTER</code>继续。</p> 
<p>之后，系统应该提示输入远程用户帐户密码：</p> 
<pre><code>Outputusername@203.0.113.1's password:
</code></pre> 
<p>输入密码后，密钥内容将被复制到远程用户帐户的文件<code>id_rsa.pub</code>末尾。</p> 
<h4><a id="_147"></a>手动复制公钥</h4> 
<p>如果没有可用的基于密码的 SSH 访问服务器，则必须手动完成上述过程。</p> 
<p>要显示密钥的内容<code>id_rsa.pub</code>，请在本地计算机中输入以下内容：</p> 
<pre><code class="prism language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub
</code></pre> 
<p>应如下所示：</p> 
<pre><code>Outputssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCqql6MzstZYh1TmWWv11q5O3pISj2ZFl9HgH1JLknLLx44+tXfJ7mIrKNxOOwxIxvcBF8PXSYvobFYEZjGIVCEAjrUzLiIxbyCoxVyle7Q+bqgZ8SeeM8wzytsY+dVGcBxF6N4JS+zVk5eMcV385gG3Y6ON3EG112n6d+SMXY0OEBIcO6x+PnUSGHrSgpBgX7Ks1r7xqFa7heJLLt2wWwkARptX7udSq05paBhcpB0pHtA1Rfz3K2B+ZVIpSDfki9UVKzT8JUmwW6NNzSgxUfQHGwnW7kj4jp4AT0VZk3ADw497M2G/12N0PPB5CnhHf7ovgy6nL1ikrygTKRFmNZISvAcywB9GVqNAVE+ZHDSCuURNsAInVzgYo9xgJDW8wUw2o8U77+xiFxgI5QSZX3Iq7YLMgeksaO4rBJEa54k8m5wEiEE1nUhLuJ0X/vh2xPff6SQ1BL/zkOhvJCACK6Vb15mDOeCSq54Cr7kvS46itMosi/uS66+PujOO+xt/2FWYepz6ZlN70bRly57Q06J+ZJoc9FfBCbCyYH7U/ASsmY095ywPsBo1XQ9PqhnN1/YOorJ068foQDNVpm146mUpILVxmq41Cj55YKHEazXGsdBIbXWhcrRf4G2fJLRcGUr9q8/lERo9oxRm5JFX6TCmj6kmiFqv+Ow9gI0x8GvaQ== demo@test
</code></pre> 
<p>访问远程主机。</p> 
<p>一旦可以访问远程服务器上的帐户，我们应该确保该<code>~/.ssh</code>目录存在。如果需要，此命令将创建目录，如果目录已存在，则不执行任何操作：</p> 
<pre><code class="prism language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> ~/.ssh
</code></pre> 
<p>下来创建或修改<code>authorized_keys</code>此目录中的文件。可以将文件的内容添加<code>id_rsa.pub</code>到文件末尾<code>authorized_keys</code>，并根据需要使用以下命令创建文件：</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">echo</span> public_key_string <span class="token operator">&gt;&gt;</span> ~/.ssh/authorized_keys
</code></pre> 
<p>最后，确保<code>~/.ssh</code>目录和<code>authorized_keys</code>文件具有适当的权限集：</p> 
<pre><code class="prism language-bash"><span class="token function">chmod</span> <span class="token parameter variable">-R</span> <span class="token assign-left variable">go</span><span class="token operator">=</span> ~/.ssh
</code></pre> 
<p>上面的命令会递归地删除该<code>~/.ssh/</code>目录的所有“组”和“其他”权限。</p> 
<p>如果使用<strong>root</strong>帐户为用户帐户设置密钥，那么该<code>~/.ssh</code>目录属于用户而不是<strong>root</strong>也很重要：</p> 
<pre><code class="prism language-bash"><span class="token function">chown</span> <span class="token parameter variable">-R</span> sammy:sammy ~/.ssh
</code></pre> 
<p>现在可以尝试使用 Ubuntu 服务器进行无密码身份验证。</p> 
<h3><a id="_3____SSH__Ubuntu__193"></a>第 3 步 — 使用 SSH 密钥对 Ubuntu 服务器进行身份验证</h3> 
<p>开始登录：</p> 
<pre><code class="prism language-bash"><span class="token function">ssh</span> username@remote_host
</code></pre> 
<p>如果第一次连接到该主机（如果使用了上面的最后一种方法），可能会看到如下内容：</p> 
<pre><code>OutputThe authenticity of host '203.0.113.1 (203.0.113.1)' can't be established.
ECDSA key fingerprint is fd:fd:d4:f9:77:fe:73:84:e1:55:00:ad:d6:6d:22:fe.
Are you sure you want to continue connecting (yes/no)? yes
</code></pre> 
<p>这意味着本地计算机无法识别远程主机。键入“是”，然后按<code>ENTER</code>继续。</p> 
<p>如果没有提供私钥密码，将立即登录。如果在创建密钥时为私钥提供了密码，系统将提示输入密码。身份验证后，应使用 Ubuntu 服务器上配置的帐户打开一个新的 shell 会话。</p> 
<h3><a id="_4____213"></a>第 4 步 — 在服务器上禁用密码身份验证</h3> 
<p><strong>在完成本步骤之前，请确保已为此服务器上的root</strong>帐户配置基于 SSH 密钥的身份验证，或者最好已为此服务器上的非 root 帐户配置基于 SSH 密钥的身份验证。具有权限的服务器<code>sudo</code>。此步骤将锁定基于密码的登录，因此确保我们仍然能够获得管理访问权限至关重要。否则，一首凉凉送给你~</p> 
<p>确认远程帐户具有管理权限后，请使用 SSH 密钥以<strong>root</strong>身份或使用具有<code>sudo</code>权限的帐户登录远程服务器。然后，打开 SSH 守护进程的配置文件：</p> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">nano</span> /etc/ssh/sshd_config
</code></pre> 
<p>在文件内，搜索名为<code>PasswordAuthentication</code> 的指令。该行可以在行首用<code>#</code>注释掉。通过删除 <code>#</code>取消注释该行，并将值设置为<code>no</code>。这将禁止使用帐户密码通过 SSH 登录：</p> 
<p>/etc/ssh/sshd_config</p> 
<pre><code>. . .
PasswordAuthentication no
. . .
</code></pre> 
<p>完成后按 保存并关闭文件<code>CTRL+X</code>，然后<code>Y</code>按 确认保存文件，最后<code>ENTER</code>退出 nano。要实际激活这些更改，我们需要重新启动<code>sshd</code>服务：</p> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> systemctl restart <span class="token function">ssh</span>
</code></pre> 
<p>作为预防措施，请在关闭当前会话之前打开一个新的终端窗口并测试 SSH 服务是否正常运行：</p> 
<pre><code class="prism language-bash"><span class="token function">ssh</span> username@remote_host
</code></pre> 
<p>验证 SSH 服务正常运行后，就可以安全地关闭所有当前服务器会话。</p> 
<p>Ubuntu 服务器上的 SSH 守护程序现在仅响应基于 SSH 密钥的身份验证。基于密码的登录已被禁用。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c3bd4bf6b2f52df10c0b1452b3c56a9a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IRS通信仿真第一篇</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3dd5c7ecedfba15d12f8379d6586754c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[Java]判断一个矩阵是另一个矩阵的子矩阵</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>