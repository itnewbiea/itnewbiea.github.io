<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>WPF使用Microsoft.Toolkit.Mvvm框架记录 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="WPF使用Microsoft.Toolkit.Mvvm框架记录" />
<meta property="og:description" content="前言
为了解决WPF UI与程序逻辑之间得到解耦，所以使用Microsoft.Toolkit.Mvvm框架来实现，说真的开发逻辑真的有些不适应，不过理解就好。框架大体支持ICommand、IMessenger等。
什么是MVVM? MVVM是Model-View-ViewModel的简写。它本质上就是MVC （Model-View- Controller）的改进版。即模型-视图-视图模型。分别定义如下：
【模型】指的是后端传递的数据。【视图】指的是所看到的页面。【视图模型】mvvm模式的核心，它是连接view和model的桥梁。它有两个方向： 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。 MVVM示意图如下所示
一、导入包
二、使用框架实现
&lt;Window x:Class=&#34;myMVVM.MainWindow&#34; xmlns=&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34; xmlns:x=&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34; xmlns:d=&#34;http://schemas.microsoft.com/expression/blend/2008&#34; xmlns:mc=&#34;http://schemas.openxmlformats.org/markup-compatibility/2006&#34; xmlns:local=&#34;clr-namespace:myMVVM&#34; mc:Ignorable=&#34;d&#34; Title=&#34;MainWindow&#34; Height=&#34;450&#34; Width=&#34;800&#34;&gt; &lt;Grid&gt; &lt;TextBox HorizontalAlignment=&#34;Left&#34; Margin=&#34;145,52,0,0&#34; TextWrapping=&#34;Wrap&#34; Text=&#34;{Binding Name}&#34; VerticalAlignment=&#34;Top&#34; Width=&#34;517&#34; Height=&#34;189&#34;/&gt; &lt;Button Content=&#34;Button&#34; HorizontalAlignment=&#34;Left&#34; Margin=&#34;245,294,0,0&#34; VerticalAlignment=&#34;Top&#34; Height=&#34;72&#34; Width=&#34;278&#34; Command=&#34;{Binding ShowCommand}&#34;/&gt; &lt;/Grid&gt; &lt;/Window&gt; using Microsoft.Toolkit.Mvvm.Messaging; using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows; using System.Windows.Controls; using System.Windows.Data; using System.Windows.Documents; using System.Windows.Input; using System.Windows.Media; using System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/21ff48f52a4054ee0103764516ff0070/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-16T10:15:32+08:00" />
<meta property="article:modified_time" content="2022-11-16T10:15:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">WPF使用Microsoft.Toolkit.Mvvm框架记录</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>前言</strong></p> 
<p>为了解决WPF UI与程序逻辑之间得到解耦，所以使用Microsoft.Toolkit.Mvvm框架来实现，说真的开发逻辑真的有些不适应，不过理解就好。框架大体支持ICommand、IMessenger等。</p> 
<h3>什么是MVVM?</h3> 
<p>MVVM是Model-View-ViewModel的简写。它本质上就是MVC （Model-View- Controller）的改进版。即模型-视图-视图模型。分别定义如下：</p> 
<ul><li>【模型】指的是后端传递的数据。</li><li>【视图】指的是所看到的页面。</li><li>【视图模型】mvvm模式的核心，它是连接view和model的桥梁。它有两个方向： 
  <ul><li>一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。</li><li>二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。</li></ul></li></ul> 
<p>MVVM示意图如下所示</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/06/da/hk2RYfoI_o.png"></p> 
<p><strong>一、导入包</strong></p> 
<p><img alt="" height="1040" src="https://images2.imgbox.com/ba/24/0bc8zCzX_o.png" width="1200"></p> 
<p> <img alt="" height="362" src="https://images2.imgbox.com/f2/e8/diuS9iW1_o.png" width="368"></p> 
<p></p> 
<p><strong> 二、使用框架实现</strong></p> 
<p><img alt="" height="682" src="https://images2.imgbox.com/90/87/6B4W97Iv_o.png" width="1200"></p> 
<p></p> 
<pre><code class="language-cs">&lt;Window x:Class="myMVVM.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:myMVVM"
        mc:Ignorable="d"
        Title="MainWindow" Height="450" Width="800"&gt;
    &lt;Grid&gt;
        &lt;TextBox HorizontalAlignment="Left" Margin="145,52,0,0" TextWrapping="Wrap" Text="{Binding Name}" VerticalAlignment="Top" Width="517" Height="189"/&gt;
        &lt;Button Content="Button" HorizontalAlignment="Left" Margin="245,294,0,0" VerticalAlignment="Top" Height="72" Width="278" Command="{Binding ShowCommand}"/&gt;

    &lt;/Grid&gt;
&lt;/Window&gt;
</code></pre> 
<p><img alt="" height="1040" src="https://images2.imgbox.com/6a/e4/MG9EZV42_o.png" width="1200"></p> 
<p></p> 
<pre><code class="language-cs">using Microsoft.Toolkit.Mvvm.Messaging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace myMVVM
{
    /// &lt;summary&gt;
    /// Interaction logic for MainWindow.xaml
    /// &lt;/summary&gt;
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
            this.DataContext = new MainViewModel();
            WeakReferenceMessenger.Default.Register&lt;string, string&gt;(this, "Token1", (s, val) =&gt;
            {
                MessageBox.Show(val);
            });
        }

    }
}
</code></pre> 
<p> <img alt="" height="1040" src="https://images2.imgbox.com/89/bc/FVzF48k5_o.png" width="1200"></p> 
<p></p> 
<pre><code class="language-cs">using Microsoft.Toolkit.Mvvm.ComponentModel;
using Microsoft.Toolkit.Mvvm.Input;
using Microsoft.Toolkit.Mvvm.Messaging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;

namespace myMVVM
{
    internal class MainViewModel: ObservableObject
    {
        /// &lt;summary&gt;
        /// 供前端的Command命令Binding调用
        /// &lt;/summary&gt;
        public RelayCommand ShowCommand { get; set; }
        public MainViewModel()
        {
            ShowCommand = new RelayCommand(Show);
        }
        private string name;
        public string Name
        {
            get { return name; }
            set { name = value; OnPropertyChanged(); }
        }
        private string title;
        public string Title
        {
            get { return title; }
            set { title = value; OnPropertyChanged(); }
        }

        public void Show()
        {
            Title = "你点击了按钮 this is Title";
            Name = "你点击了按钮  this is Name";
            MessageBox.Show(Name);
            WeakReferenceMessenger.Default.Send&lt;string, string&gt;(Title, "Token1");
        }
    }
}
</code></pre> 
<p><img alt="" height="450" src="https://images2.imgbox.com/7b/99/yviMQqLt_o.png" width="800"></p> 
<p> <img alt="" height="450" src="https://images2.imgbox.com/ca/c1/j0FKQifF_o.png" width="800"></p> 
<p></p> 
<p><strong>总结：</strong></p> 
<p>这样当我们的业务代码逻辑变更时就不用考虑ui的修改，需要习惯这个逻辑。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d130b61af72c172ce79d75e40c4583f1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">git删除远程仓库上已提交的文件/文件夹</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/677a37fce91e45b2f829f344aac700f3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue在history mode模式下页面刷新出现了Cannot GET</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>