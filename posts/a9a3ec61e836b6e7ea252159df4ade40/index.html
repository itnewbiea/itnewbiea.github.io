<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>proto3默认值与可选项 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="proto3默认值与可选项" />
<meta property="og:description" content="proto3特性 proto3相较于proto2支持更多语言但在语法上更为简洁。去除了一些复杂的语法和特性，更强调约定而弱化语法。
删​​除原始值字段的presence字段逻辑，删除required字段以及删除默认值。这使得proto3更容易实现如在Android Java，Objective C或 Go 等语言中的开放式结构化表示。移除unknown关键字.去掉extensions类型，使用Any新标准类型替换。针对未知枚举值的固定语法.增加maps(主要指代码生成支持map)添加一组用于表示时间，动态数据等的标准类型。替换二进制编码的明确 JSON编码 问题提出 不可否认由于proto3在语法上进行了大量简化，使得proto格式无论是在友好性上、还是灵活性上都有了大幅提升。但是由于删除了presence、required及默认值这些内容，导致proto结构中的所有字段都成了optional（可选字段）类型。这在实际使用过程出现了如下问题：
结构化数据缺失、显示不全，默认值都当成了不存在（not present)。对外提供的数据上报时，不便于对数据的分析和使用。对内服务调试时，不便于问题跟踪和定位;无法验证业务逻辑上数据构造的正确性，如果是默认值不清楚数据构造时到底是否赋过值。 Introducing a new keyword or reusing an existing keyword to support field presence in proto3 will complicate protobuf semantics. We believe it will lead to confusion and misuse, which defeats the purpose of removing field presence in proto3.
at the moment we recommend users to design their proto3 protos without relying on field presence.
问题解决 1、wrappers方案 方案介绍" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a9a3ec61e836b6e7ea252159df4ade40/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-26T00:03:58+08:00" />
<meta property="article:modified_time" content="2020-08-26T00:03:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">proto3默认值与可选项</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>proto3特性</h4> 
<p>proto3相较于proto2支持更多语言但在语法上更为简洁。去除了一些复杂的语法和特性，更强调约定而弱化语法。</p> 
<ol><li>删​​除原始值字段的presence字段逻辑，删除required字段以及删除默认值。这使得proto3更容易实现如在Android Java，Objective C或 Go 等语言中的开放式结构化表示。</li><li>移除unknown关键字.</li><li>去掉extensions类型，使用Any新标准类型替换。</li><li>针对未知枚举值的固定语法.</li><li>增加maps(主要指代码生成支持map)</li><li>添加一组用于表示时间，动态数据等的标准类型。</li><li>替换二进制编码的明确 JSON编码</li></ol> 
<h3>问题提出</h3> 
<p>不可否认由于proto3在语法上进行了大量简化，使得proto格式无论是在友好性上、还是灵活性上都有了大幅提升。但是由于删除了presence、required及默认值这些内容，导致proto结构中的所有字段都成了optional（可选字段）类型。这在实际使用过程出现了如下问题：</p> 
<ol><li>结构化数据缺失、显示不全，默认值都当成了不存在（not present)。对外提供的数据上报时，不便于对数据的分析和使用。对内服务调试时，不便于问题跟踪和定位;</li><li>无法验证业务逻辑上数据构造的正确性，如果是默认值不清楚数据构造时到底是否赋过值。</li></ol> 
<p>Introducing a new keyword or reusing an existing keyword to support field presence in proto3 will complicate protobuf semantics. We believe it will lead to confusion and misuse, which defeats the purpose of removing field presence in proto3.</p> 
<p>at the moment we recommend users to design their proto3 protos without relying on field presence.</p> 
<p> </p> 
<h3>问题解决</h3> 
<h4>1、wrappers方案</h4> 
<p>方案介绍</p> 
<p>经过研究发现google已经意识到这个问题，采取了一些补救方法—提供wrappers包。该包位于github.com/golang/protobuf/ptypes/wrappers/wrappers.proto，proto文件中包含以下消息类型：</p> 
<ol><li>DoubleValue</li><li>FloatValue</li><li>Int64Value</li><li>UInt64Value</li><li>Int32Value</li><li>UInt32Value</li><li>BoolValue</li><li>StringValue</li><li>BytesValue</li></ol> 
<p>以Int32Value为例，其包装方法如下：</p> 
<pre><code>// Wrapper message for `int32`.
//
// The JSON representation for `Int32Value` is JSON number.
message Int32Value {
  // The int32 value.
  int32 value = 1;
}</code></pre> 
<p>示例</p> 
<pre><code>import "google/protobuf/wrappers.proto";

message Test {
  google.protobuf.Int32Value a = 1;
}</code></pre> 
<p>优缺点：</p> 
<p><strong>优点</strong>：描述简洁清晰 </p> 
<p><strong>缺点：</strong> 使用该方案会使结构变大，每在一个字段使用都会增加2个字节。</p> 
<p> </p> 
<h4>2、oneof方案</h4> 
<p>方案介绍</p> 
<p>另外还可以使用oneof来达到目的，oneof与数据结构联合体（UNION）有点类似，一次最多只有一个字段有效，一般是为了节省存储空间。针对本文所遇到的问题则是将需要处理的字段通过oneof进行包装。</p> 
<p>示例</p> 
<pre><code>message Test {
  oneof a_oneof {
    int32 a = 1;
  }
}</code></pre> 
<pre>可以使用test.getAOneofCase()来检查a是否被设置。</pre> 
<p>优缺点</p> 
<p><strong>优点：</strong>向后兼容proto2</p> 
<p> <strong>缺点：</strong> 不能使用在repeated类型字段</p> 
<p> </p> 
<h4>3、自定义nullable方案</h4> 
<p>方案介绍</p> 
<p>该方案主要通过实现一个自定义的nullable关键字来解决字段是否能够为空的问题。 修改详细可参考： https://github.com/criteo-forks/protobuf/commit/8298aff178ccffd0c7c99806e714d0f14f40faf8</p> 
<p>示例</p> 
<pre><code>message Test {
  nullable int32 a = 1;
}</code></pre> 
<p>优缺点</p> 
<p>优点：描述简洁清晰 </p> 
<p><strong>缺点：</strong></p> 
<ol><li>自定义的关键字不利于版本升级更新</li><li>需要修改源代码</li><li>与proto3版本的本意冲突（使得proto语义复杂化）</li></ol> 
<p> </p> 
<h4>4、map方案</h4> 
<p>方案介绍</p> 
<p>还有人通过map&lt;int32,bool&gt;来解决问题，每当一个字段被设置时，bool值则被设置为true（默认值也是）。另外如果设置的不是默认值时，还需要在每个字段的setter方法中增加hasXXX方法。详情参见：https://github.com/google/protobuf/issues/2684</p> 
<p>示例</p> 
<pre><code>message Test {
  map&lt;int32, bool&gt; a = 1;
}</code></pre> 
<p>优缺点</p> 
<p>优点：</p> 
<ol><li>结构的增大会比wrapper方案小得多</li><li>向后兼容proto2 </li></ol> 
<p><strong>缺点：</strong></p> 
<ol><li>写法不够简介</li><li>map的key值只能是整形和字符串</li><li>需要修改setter的实现</li></ol> 
<p> </p> 
<h3>总结</h3> 
<p><strong>优先推荐使用wrapper方案，我们项目中也使用的这种方案</strong>，如果对消息结构大小敏感则优先采用oneof方案。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bc5051e719be8a564f9cb78aa702e362/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用Screenfull库来实现全屏效果</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/db5feb9af3d985b40280ee5269f17e4f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">超全面的后端开发C/C&#43;&#43;面经整理分享含详细参考答案 包括简历分享</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>