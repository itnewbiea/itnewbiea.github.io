<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>进程调度算法的模拟 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="进程调度算法的模拟" />
<meta property="og:description" content="加深对进程概念的理解，明确进程和程序的区别
先写一个名为“schedule.c”的文件
内容如下
#include &#34;stdio.h&#34; #include &lt;stdlib.h&gt; #define getpch(type) (type*)malloc(sizeof(type)) struct pcb { /* 定义进程控制块PCB */ char name[10]; //进程名 char state; //进程状态：&#34;W&#34;-就绪态，&#34;R&#34;-运行态 int nice; //进程优先级 int ntime; //需要运行时间 int rtime; //已经运行的时间 struct pcb* link; }*ready=NULL,*p; typedef struct pcb PCB; char sort() /* 建立对进程进行优先级排列函数，优先数大者优先*/ { PCB *first, *second; int insert=0; if((ready==NULL)||((p-&gt;nice)&gt;(ready-&gt;nice)))/*优先级最大者,插入队首*/ { p-&gt;link=ready; ready=p; } else /* 进程比较优先级,插入适当的位置中*/ { first=ready; second=first-&gt;link; while(second!=NULL) { if((p-&gt;nice)&gt;(second-&gt;nice)) /*若插入进程比当前进程优先数大,*/ { /*插入到当前进程前面*/ p-&gt;link=second; first-&gt;link=p; second=NULL; insert=1; } else /* 插入进程优先数最低,则插入到队尾*/ { first=first-&gt;link; second=second-&gt;link; } } if(insert==0) first-&gt;link=p; } } char input() /* 建立进程控制块函数*/ { int i,num; printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/005999f1262241b2286a8ec2ddb5f105/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-05T18:10:27+08:00" />
<meta property="article:modified_time" content="2023-04-05T18:10:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">进程调度算法的模拟</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0;text-align:justify;">加深对进程概念的理解，明确进程和程序的区别</p> 
<p style="margin-left:0;text-align:justify;">先写一个名为“schedule.c”的文件</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="417" src="https://images2.imgbox.com/5d/b0/ZOE0W0Pb_o.png" width="788"></p> 
<p style="margin-left:0;text-align:justify;">内容如下</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="507" src="https://images2.imgbox.com/a9/fa/R0u5Z5aQ_o.png" width="720"></p> 
<pre><code class="language-cs">#include "stdio.h"
#include &lt;stdlib.h&gt;
#define getpch(type) (type*)malloc(sizeof(type))

struct pcb { /* 定义进程控制块PCB */
  char name[10]; //进程名
  char state;    //进程状态："W"-就绪态，"R"-运行态
  int nice;      //进程优先级
  int ntime;     //需要运行时间
  int rtime;     //已经运行的时间
  struct pcb* link;
}*ready=NULL,*p;
typedef struct pcb PCB;

char sort() /* 建立对进程进行优先级排列函数，优先数大者优先*/
{
  PCB *first, *second;
  int insert=0;
  if((ready==NULL)||((p-&gt;nice)&gt;(ready-&gt;nice)))/*优先级最大者,插入队首*/
  {
    p-&gt;link=ready;
    ready=p;
  }
  else /* 进程比较优先级,插入适当的位置中*/
  {
    first=ready;
    second=first-&gt;link;
    while(second!=NULL)
    {
      if((p-&gt;nice)&gt;(second-&gt;nice)) /*若插入进程比当前进程优先数大,*/
      { /*插入到当前进程前面*/
        p-&gt;link=second;
        first-&gt;link=p;
        second=NULL;
        insert=1;
      }
      else /* 插入进程优先数最低,则插入到队尾*/
      {
        first=first-&gt;link;
        second=second-&gt;link;
      }
    }
    if(insert==0) first-&gt;link=p;
  }
}

char input() /* 建立进程控制块函数*/
{
  int i,num;
  printf("\n 请输入被调度的进程数目：");
  scanf("%d",&amp;num);
  for(i=0;i&lt;num;i++)
  {
    printf("\n 进程号No.%d:",i);
    p=getpch(PCB);
    printf("\n 输入进程名:");
    scanf("%s",p-&gt;name);
    printf(" 输入进程优先数:");
    scanf("%d",&amp;p-&gt;nice);
    printf(" 输入进程运行时间:");
    scanf("%d",&amp;p-&gt;ntime);
    printf("\n");
    p-&gt;rtime=0;
    p-&gt;state='W';
    p-&gt;link=NULL;
    sort(); /* 调用sort函数*/
  }
}

int space()
{
  int l=0; PCB* pr=ready;
  while(pr!=NULL)
  {
    l++;
    pr=pr-&gt;link;
  }
  return(l);
}

char disp(PCB * pr) /*建立进程显示函数,用于显示当前进程*/
{
  printf("\n qname \t state \t nice \tndtime\truntime \n");
  printf("%s\t",pr-&gt;name);
  printf("%c\t",pr-&gt;state);
  printf("%d\t",pr-&gt;nice);
  printf("%d\t",pr-&gt;ntime);
  printf("%d\t",pr-&gt;rtime);
  printf("\n");
}

char check() /* 建立进程查看函数 */
{
  PCB* pr;
  printf("\n **** 当前正在运行的进程是:%s",p-&gt;name); /*显示当前运行进程*/
  disp(p);
  pr=ready;
  if (pr!=NULL)
    printf("\n ****当前就绪队列状态为:"); /*显示就绪队列状态*/
  else
    printf("\n ****当前就绪队列状态为: 空\n"); /*显示就绪队列状态为空*/
  while(pr!=NULL)
  {
    disp(pr);
    pr=pr-&gt;link;
  }
}

char destroy() /*建立进程撤消函数(进程运行结束,撤消进程)*/
{
  printf(" 进程 [%s] 已完成.\n",p-&gt;name);
  free(p);
}
 
char running() /* 建立进程就绪函数(进程运行时间到,置就绪状态*/
{
  (p-&gt;rtime)++;
  if(p-&gt;rtime==p-&gt;ntime)
  destroy(); /* 调用destroy函数*/
  else
  {
    (p-&gt;nice)--;
    p-&gt;state='W';
    sort(); /*调用sort函数*/
  }
}

int main() /*主函数*/
{
  int len,h=0;
  char ch;
  input();
  len=space();
  while((len!=0)&amp;&amp;(ready!=NULL))
  {
    ch=getchar();
    h++;
    printf("\n The execute number:%d \n",h);
    p=ready;
    ready=p-&gt;link;
    p-&gt;link=NULL;
    p-&gt;state='R';
    check();
    running();
    printf("\n按任一键继续......");
    ch=getchar();
  }
  printf("\n\n 所有进程已经运行完成！\n");
  ch=getchar();
}
</code></pre> 
<p style="margin-left:0;text-align:justify;">然后用“gcc -o schedule schedule.c”得到可执行文件</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="417" src="https://images2.imgbox.com/ee/7c/c3Unx9Z1_o.png" width="788"></p> 
<p style="margin-left:0;text-align:justify;">用“./schedule”执行schedule得到如下</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="490" src="https://images2.imgbox.com/3b/11/PJFxNtTi_o.png" width="758"></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="516" src="https://images2.imgbox.com/43/17/JykZFkA9_o.png" width="727"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/33eb9d5cb74904d64b19e69a8f9dc01c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">11.图-有向图</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/91074a4f9bd6aa19822ed033d526ce15/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java实现Base64编码以及原理详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>