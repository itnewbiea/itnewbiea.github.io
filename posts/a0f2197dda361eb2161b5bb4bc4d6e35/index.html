<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Oracle数据库中的多表关联查询 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Oracle数据库中的多表关联查询" />
<meta property="og:description" content="多表关联查询：在实际开发中，每个表的信息都不是独立的，而是若干个表之间存在一定的联系，如果用户查询某一个表的信息时，可能需要查询关联表的信息，这就是多表关联查询。
1.查询语句的执行顺序
from&gt;where&gt;group by&gt;having&gt;select&gt;order by
2.表的别名：在多表关联查询时，如果多个表存在相同的列，，则必须使用表名来限定列的引用，当查询语句越来越复杂，每次输入表名会使得sql语句过于臃肿，这时就可以使用别名来代替原来的表名了。
语法：table_name 别名
列的别名也是如此。
如：select e.ename 名字,e.deptno,d.dname 名字 from emp e,dept d;
3.多表关联查询：根据连接条件的不同分为很多种。
①交叉连接：不需要任何连接条件的连接，执行结果是一个笛卡尔积，即将原表的记录数相乘，这种连接方式，将表2中的每一条记录都和表1中的每条记录连接一次。
如：表1中的4条记录，表2中的5条记录，交叉连接后有4*5=20条记录。
注：此种连接方式产生的结果集冗余度高，很少使用。
语法：select 查询列 from 表1 [别名] , 表2 [别名];
例:select ename,empno,e.deptno,d.deptno,dname from emp e,dept d;
②内连接：内连接是使用频率最高的连接查询
内连接的实现方式：
1）使用inner join关键字来实现，其中inner可以省略，使用这种方式，需要在from子句后面定义一个on子句来指定连接条件。
语法：select 查询列 from 表1 [别名] [inner] join 表2 [别名] on 连接条件；
例：select e.*,d.* from emp e join dept d on e.deptno=d.deptno;
2）使用where子句来连接
语法：select 查询列 from 表1 [别名],表2 [别名] where 连接条件;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a0f2197dda361eb2161b5bb4bc4d6e35/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-08T08:55:08+08:00" />
<meta property="article:modified_time" content="2022-09-08T08:55:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Oracle数据库中的多表关联查询</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>多表关联查询：在实际开发中，每个表的信息都不是独立的，而是若干个表之间存在一定的联系，如果用户查询某一个表的信息时，可能需要查询关联表的信息，这就是多表关联查询。</p> 
<p>1.查询语句的执行顺序</p> 
<p>from&gt;where&gt;group by&gt;having&gt;select&gt;order by</p> 
<p>2.表的别名：在多表关联查询时，如果多个表存在相同的列，，则必须使用表名来限定列的引用，当查询语句越来越复杂，每次输入表名会使得sql语句过于臃肿，这时就可以使用别名来代替原来的表名了。</p> 
<p>语法：table_name  别名</p> 
<p>列的别名也是如此。</p> 
<p>如：select e.ename 名字,e.deptno,d.dname 名字 from emp e,dept d;</p> 
<p>3.多表关联查询：根据连接条件的不同分为很多种。</p> 
<p>①交叉连接：不需要任何连接条件的连接，执行结果是一个笛卡尔积，即将原表的记录数相乘，这种连接方式，将表2中的每一条记录都和表1中的每条记录连接一次。</p> 
<p>如：表1中的4条记录，表2中的5条记录，交叉连接后有4*5=20条记录。</p> 
<p>注：此种连接方式产生的结果集冗余度高，很少使用。</p> 
<p>语法：select 查询列 from 表1 [别名] , 表2 [别名];</p> 
<p>例:select ename,empno,e.deptno,d.deptno,dname from emp e,dept d;</p> 
<p>②内连接：内连接是使用频率最高的连接查询</p> 
<p>内连接的实现方式：</p> 
<p>1）使用inner join关键字来实现，其中inner可以省略，使用这种方式，需要在from子句后面定义一个on子句来指定连接条件。</p> 
<p>语法：select 查询列 from 表1 [别名] [inner] join 表2 [别名] on 连接条件；</p> 
<p>例：select e.*,d.* from emp e join dept d on e.deptno=d.deptno;</p> 
<p>2）使用where子句来连接</p> 
<p>语法：select 查询列 from 表1 [别名],表2 [别名] where 连接条件;</p> 
<p>例：select e.*,d.* from emp e,dept d where e.deptno=d.deptno;</p> 
<p>内连接的结果集：先将表1的第一行记录拿出来，然后从关扫描表2，将符合连接条件的记录和表1的第一行记录连接，并且放到结果集，然后将表1的第二行记录拿出来，重复操作。</p> 
<p>③外连接：在内连接的基础上，将某个表中不符合连接条件的记录也加入到结果集。</p> 
<p>1）左外连接：除了内连接的结果外，还会把左表中不符合连接条件的记录也放到结果集中，而右表不符合连接条件的数据的位置用null填充。</p> 
<p>语法：select 查询列 from 表1 [别名] left [outer] join 表2 [别名] on 连接条件；</p> 
<p>例：select e.*,d* from dept d left join emp on e.depno=d.deptno;</p> 
<p>2）右外连接：除了内连接的结果外，还会把右表中不符合连接条件的记录也放到结果集来，而左表中不符合连接条件的数据的位置用null填充。</p> 
<p>语法：select 查询内容 from 表1 [别名] right [outer] join 表2 [别名] on 连接条件;</p> 
<p>例：select e.*,d.* from dept d right join emp e on e.deptno = d.deptno;</p> 
<p>3）完全外连接：除了内连接的结果外，还会把左右两张表中不符合连接条件的记录都会放到结果集，而两边表中不符合连接条件的数据的位置用null填充。</p> 
<p>语法：select 查询内容 from 表1 [别名] full [outer] join 表2 [别名] on 连接条件;</p> 
<p>例：select e.*,d.* from dept d full join emp e on e.deptno = d.deptno;</p> 
<p>外连接用where子句表示：<br> select 查询内容 from 表1 [别名],表2 [别名] where 表1列(+)=表2列;</p> 
<p>注：连接条件哪边的表用null填充，哪边的列就加上(+)<br> 如：select e.*,d.* from emp e,dept d where e.deptno(+)=d.deptno;</p> 
<p>④自然连接<br> 在查询多个表中的数据时，会将第一个表中和第二个表中具有相同名称的列自动连接，如果两个表中的某一个列名称相同，则数据库就会尝试使用这两个列进行连接，但是如果数据类型或者长度不同，则会把数据类型隐式转换，若转化失败，则报错。</p> 
<p>使用关键字natural join进行连接<br> 语法：select 查询内容 from 表1 natural join 表2;<br> 例：select empno,ename,job,dname from emp e natural join dept d;<br> 注：当相连接的两个列列名不同时，只能使用内连接，而如果两个列的列名相同，则可以使用自然连接和内连接。</p> 
<p>⑤自连接<br> 当表中某一列可以作为该表的外键，则可以把该列作为连接条件，实现自连接。</p> 
<p>例：查询所有管理者的名字和他所管理的下属员工的名字。<br> select e1.ename 下属员工,e2.ename 管理者 from emp e1 left join emp e2 on e1.mgr = e2.empno;</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/26fcc04facef62813632f4908ba8f10a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android屏幕适配</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/25bccbe8cdfd8e6b7c0d140e064d8b1d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">docker cp报错no such directory</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>