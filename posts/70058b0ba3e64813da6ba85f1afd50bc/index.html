<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用OpenCV通过摄像头捕获实时视频并探测人脸 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用OpenCV通过摄像头捕获实时视频并探测人脸" />
<meta property="og:description" content="在Opencv初接触，图片的基本操作这篇手记中，我介绍了一些图片的基本操作，视频可以看作是一帧一帧的图片，因此图片操作其实是视频操作的基础，这篇手记就来讲讲OpenCV中的视频操作，并实现一个用笔记本自带的摄像头探测人脸的小功能，最后会把人脸提取出来并保存，作为后续用卷积神经网络进行人脸识别的训练数据。
本地视频读取
OpenCV中是通过创建一个VideoCapture对象来捕获视频，这里先以读取和播放本地视频为例：
import cv2 cap = cv2.VideoCapture(&#39;clementi sonatina in f major, op. 36 no. 4.mp4&#39;) # 注意这里视频放在当前工作目录下，VideoCapture的参数就是视频文件名 while(cap.isOpened()): # isOpened方法判断视频是否成功打开 ret, frame = cap.read() # read方法返回一个表示视频是否正确读取的布尔值和一帧图像 gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # 这里用cvtColor（cvt就是convert的缩写）方法进行色彩空间的转换，这里是从BGR空间转换到灰度空间 cv2.imshow(&#39;frame&#39;, gray) # 通过imshow显示一帧图像 if cv2.waitKey(1) &amp; 0xFF == ord(&#39;q&#39;): # 一帧显示一毫秒，通过上面的while循环不断地显示下一帧，从而形成动态的视频；按q键退出循环，关闭视频。 break cap.release() cv2.destroyAllWindows() 通过笔记本摄像头捕获实时视频流
通过上面读取本地视频的代码，可以理解OpenCV中显示视频的原理就是通过循环不断显示下一帧图像从而得到动态的视频，下面，只需改变VideoCapture的参数就可以捕获笔记本电脑摄像头的实时视频流：
import cv2 #引入cv2，也就是引入opencv的一些包和处理类，不然下面的一些操作都无法完成 #打开摄像头的方法，window_name为显示窗口名，video_id为你设备摄像头的id，默认为0或-1，如果引用usb可能会改变为1，等 def openvideo(window_name ,video_id): cv2.namedWindow(window_name) # 创建一个窗口 cap=cv2.VideoCapture(video_id) # 获取摄像头 while cap.isOpened(): ok,frame=cap.read() # ok表示摄像头读取状态，frame表示摄像头读取的图像 if not ok : break cv2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/70058b0ba3e64813da6ba85f1afd50bc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-20T10:36:00+08:00" />
<meta property="article:modified_time" content="2018-08-20T10:36:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用OpenCV通过摄像头捕获实时视频并探测人脸</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>在<a href="https://www.imooc.com/article/51083" rel="nofollow">Opencv初接触，图片的基本操作</a>这篇手记中，我介绍了一些图片的基本操作，视频可以看作是一帧一帧的图片，因此图片操作其实是视频操作的基础，这篇手记就来讲讲OpenCV中的视频操作，并实现一个用笔记本自带的摄像头探测人脸的小功能，最后会把人脸提取出来并保存，作为后续用卷积神经网络进行人脸识别的训练数据。</p> 
 <p>本地视频读取</p> 
 <p>OpenCV中是通过创建一个<code>VideoCapture</code>对象来捕获视频，这里先以读取和播放本地视频为例：</p> 
 <pre class="prettyprint"><code><span class="kwd">import<span class="pln"> cv2

cap <span class="pun">=<span class="pln"> cv2<span class="pun">.<span class="typ">VideoCapture<span class="pun">(<span class="str">'clementi sonatina in f major, op. 36 no. 4.mp4'<span class="pun">)<span class="pln"> <span class="com"># 注意这里视频放在当前工作目录下，VideoCapture的参数就是视频文件名<span class="pln"> <span class="kwd">while<span class="pun">(<span class="pln">cap<span class="pun">.<span class="pln">isOpened<span class="pun">()):<span class="pln"> <span class="com"># isOpened方法判断视频是否成功打开<span class="pln"> ret<span class="pun">,<span class="pln"> frame <span class="pun">=<span class="pln"> cap<span class="pun">.<span class="pln">read<span class="pun">()<span class="pln"> <span class="com"># read方法返回一个表示视频是否正确读取的布尔值和一帧图像<span class="pln"> gray <span class="pun">=<span class="pln"> cv2<span class="pun">.<span class="pln">cvtColor<span class="pun">(<span class="pln">frame<span class="pun">,<span class="pln"> cv2<span class="pun">.<span class="pln">COLOR_BGR2GRAY<span class="pun">)<span class="pln"> <span class="com"># 这里用cvtColor（cvt就是convert的缩写）方法进行色彩空间的转换，这里是从BGR空间转换到灰度空间<span class="pln"> cv2<span class="pun">.<span class="pln">imshow<span class="pun">(<span class="str">'frame'<span class="pun">,<span class="pln"> gray<span class="pun">)<span class="pln"> <span class="com"># 通过imshow显示一帧图像<span class="pln"> <span class="kwd">if<span class="pln"> cv2<span class="pun">.<span class="pln">waitKey<span class="pun">(<span class="lit">1<span class="pun">)<span class="pln"> <span class="pun">&amp;<span class="pln"> <span class="lit">0xFF<span class="pln"> <span class="pun">==<span class="pln"> ord<span class="pun">(<span class="str">'q'<span class="pun">):<span class="pln"> <span class="com"># 一帧显示一毫秒，通过上面的while循环不断地显示下一帧，从而形成动态的视频；按q键退出循环，关闭视频。<span class="pln"> <span class="kwd">break<span class="pln"> cap<span class="pun">.<span class="pln">release<span class="pun">()<span class="pln"> cv2<span class="pun">.<span class="pln">destroyAllWindows<span class="pun">()</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre> 
 <p>通过笔记本摄像头捕获实时视频流</p> 
 <p>通过上面读取本地视频的代码，可以理解OpenCV中显示视频的原理就是通过循环不断显示下一帧图像从而得到动态的视频，下面，只需改变<code>VideoCapture</code>的参数就可以捕获笔记本电脑摄像头的实时视频流：</p> 
 <pre class="prettyprint"><code><span class="kwd">import<span class="pln"> cv2    <span class="com">#引入cv2，也就是引入opencv的一些包和处理类，不然下面的一些操作都无法完成<span class="pln">

<span class="com">#打开摄像头的方法，window_name为显示窗口名，video_id为你设备摄像头的id，默认为0或-1，如果引用usb可能会改变为1，等<span class="pln"> <span class="kwd">def<span class="pln"> openvideo<span class="pun">(<span class="pln">window_name <span class="pun">,<span class="pln">video_id<span class="pun">):<span class="pln"> cv2<span class="pun">.<span class="pln">namedWindow<span class="pun">(<span class="pln">window_name<span class="pun">)<span class="pln"> <span class="com"># 创建一个窗口<span class="pln"> cap<span class="pun">=<span class="pln">cv2<span class="pun">.<span class="typ">VideoCapture<span class="pun">(<span class="pln">video_id<span class="pun">)<span class="pln"> <span class="com"># 获取摄像头<span class="pln"> <span class="kwd">while<span class="pln"> cap<span class="pun">.<span class="pln">isOpened<span class="pun">():<span class="pln"> ok<span class="pun">,<span class="pln">frame<span class="pun">=<span class="pln">cap<span class="pun">.<span class="pln">read<span class="pun">()<span class="pln"> <span class="com"># ok表示摄像头读取状态，frame表示摄像头读取的图像<span class="pln"> <span class="kwd">if<span class="pln"> <span class="kwd">not<span class="pln"> ok <span class="pun">:<span class="pln"> <span class="kwd">break<span class="pln"> cv2<span class="pun">.<span class="pln">imshow<span class="pun">(<span class="pln">window_name<span class="pun">,<span class="pln">frame<span class="pun">)<span class="pln"> <span class="com"># 将图像矩阵显示在一个窗口中<span class="pln"> c<span class="pun">=<span class="pln">cv2<span class="pun">.<span class="pln">waitKey<span class="pun">(<span class="lit">10<span class="pun">)<span class="pln"> <span class="com"># 等待10ms，10ms内没有按键操作就进入下一次while循环，从而得到10ms一帧的效果，waitKey返回在键盘上按的键<span class="pln"> <span class="kwd">if<span class="pln"> c <span class="pun">&amp;<span class="pln"> <span class="lit">0xFF<span class="pun">==<span class="pln">ord<span class="pun">(<span class="str">'q'<span class="pun">):<span class="pln"> <span class="com"># 按键q后break<span class="pln"> <span class="kwd">break<span class="pln"> <span class="com"># 释放资源<span class="pln"> cap<span class="pun">.<span class="pln">release<span class="pun">()<span class="pln"> cv2<span class="pun">.<span class="pln">destroyWindow<span class="pun">(<span class="pln">window_name<span class="pun">)<span class="pln"> <span class="kwd">print<span class="pun">(<span class="str">"cam closed"<span class="pun">)<span class="pln"> <span class="com"># 主程序调用方法运行<span class="pln"> <span class="kwd">if<span class="pln"> __name__ <span class="pun">==<span class="pln"> <span class="str">'__main__'<span class="pun">:<span class="pln"> <span class="com"># __name__ 是当前模块名，当模块被直接运行时模块名为 __main__ 。这句话的意思就是，当模块被直接运行时，以下代码块将被运行，当模块是被导入时，代码块不被运行。<span class="pln"> <span class="kwd">print<span class="pln"> <span class="pun">(<span class="str">'open camera...'<span class="pun">)<span class="pln"> openvideo<span class="pun">(<span class="str">'mycam'<span class="pln"> <span class="pun">,<span class="lit">0<span class="pun">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre> 
 <p>从实时视频流中探测人脸</p> 
 <p>如果你跟着上面的代码成功运行到了这一步，应该已经可以在打开的摄像头窗口里看到自己的脸了，下面要做的就是从里面探测到你的脸了：</p> 
 <pre class="prettyprint"><code><span class="kwd">import<span class="pln">  cv2

<span class="kwd">def<span class="pln"> facedetect<span class="pun">(<span class="pln">windowname<span class="pun">,<span class="pln">camera_id<span class="pun">):<span class="pln"> <span class="com">#命名和打开摄像头<span class="pln"> cv2<span class="pun">.<span class="pln">namedWindow<span class="pun">(<span class="pln">windowname<span class="pun">)<span class="pln"> <span class="com"># 创建一个已windowname为名字的窗口<span class="pln"> cap<span class="pun">=<span class="pln">cv2<span class="pun">.<span class="typ">VideoCapture<span class="pun">(<span class="pln">camera_id<span class="pun">)<span class="pln"> <span class="com"># camera_id为设备摄像头的id，默认是0，如果有usb摄像头可能会变为1<span class="pln"> <span class="com"># Face Detection using Haar Cascades http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_objdetect/py_face_detection/py_face_detection.html?highlight=cascadeclassifier<span class="pln"> classfier<span class="pun">=<span class="pln">cv2<span class="pun">.<span class="typ">CascadeClassifier<span class="pun">(<span class="str">'haarcascade_frontalface_alt2.xml'<span class="pun">)<span class="pln"> <span class="com"># 加载分类器，分类器位置可以自行更改，注意这里用opencv库文件夹下的绝对路径也不行，在库文件夹里找到这个文件复制到这个程序的同目录下，参考：https://blog.csdn.net/GAN_player/article/details/77993872<span class="pln"> color<span class="pun">=(<span class="lit">0<span class="pun">,<span class="lit">225<span class="pun">,<span class="lit">0<span class="pun">)<span class="com">#人脸框的颜色，采用rgb模型，这里表示g取255，为绿色框<span class="pln"> <span class="kwd">while<span class="pln"> cap<span class="pun">.<span class="pln">isOpened<span class="pun">():<span class="pln"> ok<span class="pun">,<span class="pln">frame<span class="pun">=<span class="pln">cap<span class="pun">.<span class="pln">read<span class="pun">()<span class="pln"> <span class="com"># 读取一帧数据，ok表示摄像头读取状态，frame表示摄像头读取的图像矩阵mat类型<span class="pln"> <span class="kwd">if<span class="pln"> <span class="kwd">not<span class="pln"> ok<span class="pun">:<span class="pln"> <span class="kwd">break<span class="pln"> <span class="com"># 灰度化在后面检测时可以降低计算量，cvtColor changing colorspace<span class="pln"> gray<span class="pun">=<span class="pln">cv2<span class="pun">.<span class="pln">cvtColor<span class="pun">(<span class="pln">frame<span class="pun">,<span class="pln">cv2<span class="pun">.<span class="pln">COLOR_BGR2GRAY<span class="pun">)<span class="com">#图像灰度化，cv2.cvtColor(input_image, flag) where flag determines the type of conversion.</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre> 
 <p>这一部分代码在前面捕获实时视频流的基础上加载了OpenCV所提供的用于对象检测的分类器，注意分类器文件haarcascade_frontalface_alt2.xml可以在OpenCV包文件夹下找到，要放到当前工作目录下才能使用，这个分类器就是用来探测人脸的，在探测到人脸后，我们要在视频窗口中把人脸部分框出来，<code>color</code>变量就用来指定框的颜色，接着我们就来看看得到人脸框的代码：</p> 
 <pre class="prettyprint"><code><span class="pln">        <span class="com"># detectMultiScale完成人脸探测工作，returns the positions of detected faces as Rect(x,y,w,h)，x、y是左上角起始坐标，h、w是高和宽<span class="pln">
        <span class="com"># grey是要识别的图像数据，scaleFactor图像缩放比例，可以理解为同一个物体与相机距离不同，其大小亦不同，必须将其缩放到一定大小才方便识别，该参数指定每次缩放的比例<span class="pln"> faceRects<span class="pun">=<span class="pln">classfier<span class="pun">.<span class="pln">detectMultiScale<span class="pun">(<span class="pln">gray<span class="pun">,<span class="pln">scaleFactor<span class="pun">=<span class="lit">1.2<span class="pun">,<span class="pln">minNeighbors<span class="pun">=<span class="lit">3<span class="pun">,<span class="pln">minSize<span class="pun">=(<span class="lit">32<span class="pun">,<span class="lit">32<span class="pun">))<span class="pln"> <span class="com"># 利用分类器检测灰度图像中的人脸矩阵数，1.2和3分别为图片缩放比例和需要检测的有效点数<span class="pln"> <span class="kwd">if<span class="pln"> len<span class="pun">(<span class="pln">faceRects<span class="pun">)&gt;<span class="lit">0<span class="pun">:<span class="com">#大于0则检测到人脸 <span class="pln"> <span class="kwd">for<span class="pln"> faceRect <span class="kwd">in<span class="pln"> faceRects<span class="pun">:<span class="com"># 可能检测到多个人脸，用for循环单独框出每一张人脸<span class="pln"> x<span class="pun">,<span class="pln">y<span class="pun">,<span class="pln">w<span class="pun">,<span class="pln">h<span class="pun">=<span class="pln">faceRect<span class="com">#获取框的左上的坐标，框的长宽<span class="pln"> <span class="com"># cv2.rectangle()完成画框的工作，这里外扩了10个像素以框出比人脸稍大一点的区域，从而得到相对完整一点的人脸图像；cv2.rectangle()函数的最后两个参数一个用于指定矩形边框的颜色，一个用于指定矩形边框线条的粗细程度。<span class="pln"> cv2<span class="pun">.<span class="pln">rectangle<span class="pun">(<span class="pln">frame<span class="pun">,(<span class="pln">x<span class="pun">-<span class="lit">10<span class="pun">,<span class="pln">y<span class="pun">-<span class="lit">10<span class="pun">),(<span class="pln">x<span class="pun">+<span class="pln">w<span class="pun">-<span class="lit">10<span class="pun">,<span class="pln">y<span class="pun">+<span class="pln">h<span class="pun">-<span class="lit">10<span class="pun">),<span class="pln">color<span class="pun">,<span class="lit">2<span class="pun">)<span class="pln"> cv2<span class="pun">.<span class="pln">imshow<span class="pun">(<span class="pln">windowname<span class="pun">,<span class="pln">frame<span class="pun">)<span class="pln"> <span class="com"># 显示图像<span class="pln"> c<span class="pun">=<span class="pln">cv2<span class="pun">.<span class="pln">waitKey<span class="pun">(<span class="lit">10<span class="pun">)<span class="pln"> <span class="kwd">if<span class="pln"> c<span class="pun">&amp;<span class="lit">0xFF<span class="pun">==<span class="pln">ord<span class="pun">(<span class="str">'q'<span class="pun">):<span class="pln"> <span class="com"># 退出条件<span class="pln"> <span class="kwd">break<span class="pln"> cap<span class="pun">.<span class="pln">release<span class="pun">()<span class="com">#释放摄像头并销毁所有窗口<span class="pln"> cv2<span class="pun">.<span class="pln">destroyAllWindows<span class="pun">()<span class="pln"> <span class="kwd">if<span class="pln"> __name__ <span class="pun">==<span class="pln"> <span class="str">'__main__'<span class="pun">:<span class="com">#主程序<span class="pln"> <span class="kwd">print<span class="pln"> <span class="pun">(<span class="str">'face detecting... '<span class="pun">)<span class="pln"> facedetect<span class="pun">(<span class="str">'facedetect'<span class="pun">,<span class="lit">0<span class="pun">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre> 
 <p>现在，运行上面的程序，应该就能在视频窗口里看到你的脸被绿色的框框起来了，下一步我们要把框出来的人脸保存下来。</p> 
 <p>保存人脸图像数据</p> 
 <p>上面的程序里我们已经得到了人脸区域的起始坐标和宽高，只需利用<a href="https://www.imooc.com/article/51083" rel="nofollow">Opencv初接触，图片的基本操作</a>这篇手记中提到的访问图片特定像素和区域的方法把这一区域单独拿出来存成图片就行了，这里的关键代码是：</p> 
 <pre class="prettyprint"><code><span class="pln">image <span class="pun">=<span class="pln"> frame<span class="pun">[<span class="pln">y<span class="pun">:<span class="pln">y<span class="pun">+<span class="pln">h<span class="pun">,<span class="pln"> x<span class="pun">:<span class="pln">x<span class="pun">+<span class="pln">w<span class="pun">]<span class="pln"> <span class="com"># 将当前帧含人脸部分保存为图片，注意这里存的还是彩色图片，前面检测时灰度化是为了降低计算量；这里访问的是从y位开始到y+h-1位<span class="pln"> cv2<span class="pun">.<span class="pln">imwrite<span class="pun">(<span class="pln">image_name<span class="pun">,<span class="pln"> image<span class="pun">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre> 
 <p>最后给出捕获笔记本摄像头探测人脸并存储人脸图片程序的完整代码，这也是这个人脸识别项目中的第一部分功能：</p> 
 <pre class="prettyprint"><code><span class="kwd">import<span class="pln"> cv2

<span class="kwd">def<span class="pln"> getTrainingData<span class="pun">(<span class="pln">window_name<span class="pun">,<span class="pln"> camera_id<span class="pun">,<span class="pln"> path_name<span class="pun">,<span class="pln"> max_num<span class="pun">):<span class="pln"> <span class="com"># path_name是图片存储目录，max_num是需要捕捉的图片数量<span class="pln"> cv2<span class="pun">.<span class="pln">namedWindow<span class="pun">(<span class="pln">window_name<span class="pun">)<span class="pln"> <span class="com"># 创建窗口<span class="pln"> cap <span class="pun">=<span class="pln"> cv2<span class="pun">.<span class="typ">VideoCapture<span class="pun">(<span class="pln">camera_id<span class="pun">)<span class="pln"> <span class="com"># 打开摄像头<span class="pln"> classifier <span class="pun">=<span class="pln"> cv2<span class="pun">.<span class="typ">CascadeClassifier<span class="pun">(<span class="str">'haarcascade_frontalface_alt2.xml'<span class="pun">)<span class="pln"> <span class="com"># 加载分类器<span class="pln"> color <span class="pun">=<span class="pln"> <span class="pun">(<span class="lit">0<span class="pun">,<span class="lit">255<span class="pun">,<span class="lit">0<span class="pun">)<span class="pln"> <span class="com"># 人脸矩形框的颜色<span class="pln"> num <span class="pun">=<span class="pln"> <span class="lit">0<span class="pln"> <span class="com"># 记录存储的图片数量<span class="pln"> <span class="kwd">while<span class="pln"> cap<span class="pun">.<span class="pln">isOpened<span class="pun">():<span class="pln"> ok<span class="pun">,<span class="pln"> frame <span class="pun">=<span class="pln"> cap<span class="pun">.<span class="pln">read<span class="pun">()<span class="pln"> <span class="kwd">if<span class="pln"> <span class="kwd">not<span class="pln"> ok<span class="pun">:<span class="pln"> <span class="kwd">break<span class="pln"> gray <span class="pun">=<span class="pln"> cv2<span class="pun">.<span class="pln">cvtColor<span class="pun">(<span class="pln">frame<span class="pun">,<span class="pln"> cv2<span class="pun">.<span class="pln">COLOR_BGR2GRAY<span class="pun">)<span class="pln"> <span class="com"># 灰度化<span class="pln"> faceRects<span class="pun">=<span class="pln">classifier<span class="pun">.<span class="pln">detectMultiScale<span class="pun">(<span class="pln">gray<span class="pun">,<span class="pln">scaleFactor<span class="pun">=<span class="lit">1.2<span class="pun">,<span class="pln">minNeighbors<span class="pun">=<span class="lit">3<span class="pun">,<span class="pln">minSize<span class="pun">=(<span class="lit">32<span class="pun">,<span class="lit">32<span class="pun">))<span class="pln"> <span class="kwd">if<span class="pln"> len<span class="pun">(<span class="pln">faceRects<span class="pun">)<span class="pln"> <span class="pun">&gt;<span class="pln"> <span class="lit">0<span class="pun">:<span class="pln"> <span class="kwd">for<span class="pln"> faceRect <span class="kwd">in<span class="pln"> faceRects<span class="pun">:<span class="pln"> x<span class="pun">,<span class="pln">y<span class="pun">,<span class="pln">w<span class="pun">,<span class="pln">h <span class="pun">=<span class="pln"> faceRect <span class="com"># 捕捉到的图片的名字，这里用到了格式化字符串的输出<span class="pln"> image_name <span class="pun">=<span class="pln"> <span class="str">'%s%d.jpg'<span class="pln"> <span class="pun">%<span class="pln"> <span class="pun">(<span class="pln">path_name<span class="pun">,<span class="pln"> num<span class="pun">)<span class="pln"> <span class="com"># 注意这里图片名一定要加上扩展名，否则后面imwrite的时候会报错：could not find a writer for the specified extension in function cv::imwrite_ 参考：https://stackoverflow.com/questions/9868963/cvimwrite-could-not-find-a-writer-for-the-specified-extension<span class="pln"> image <span class="pun">=<span class="pln"> frame<span class="pun">[<span class="pln">y<span class="pun">:<span class="pln">y<span class="pun">+<span class="pln">h<span class="pun">,<span class="pln"> x<span class="pun">:<span class="pln">x<span class="pun">+<span class="pln">w<span class="pun">]<span class="pln"> <span class="com"># 将当前帧含人脸部分保存为图片，注意这里存的还是彩色图片，前面检测时灰度化是为了降低计算量；这里访问的是从y位开始到y+h-1位<span class="pln"> cv2<span class="pun">.<span class="pln">imwrite<span class="pun">(<span class="pln">image_name<span class="pun">,<span class="pln"> image<span class="pun">)<span class="pln"> num <span class="pun">+=<span class="pln"> <span class="lit">1<span class="pln"> <span class="com"># 超过指定最大保存数量则退出循环<span class="pln"> <span class="kwd">if<span class="pln"> num <span class="pun">&gt;<span class="pln"> max_num<span class="pun">:<span class="pln"> <span class="kwd">break<span class="pln"> cv2<span class="pun">.<span class="pln">rectangle<span class="pun">(<span class="pln">frame<span class="pun">,<span class="pln"> <span class="pun">(<span class="pln">x<span class="pun">,<span class="pln">y<span class="pun">),<span class="pln"> <span class="pun">(<span class="pln">x<span class="pun">+<span class="pln">w<span class="pun">,<span class="pln">y<span class="pun">+<span class="pln">h<span class="pun">),<span class="pln"> color<span class="pun">,<span class="pln"> <span class="lit">2<span class="pun">)<span class="pln"> <span class="com"># 画出矩形框<span class="pln"> font <span class="pun">=<span class="pln"> cv2<span class="pun">.<span class="pln">FONT_HERSHEY_SIMPLEX <span class="com"># 获取内置字体<span class="pln"> cv2<span class="pun">.<span class="pln">putText<span class="pun">(<span class="pln">frame<span class="pun">,<span class="pln"> <span class="pun">(<span class="str">'%d'<span class="pun">%<span class="pln">num<span class="pun">),<span class="pln"> <span class="pun">(</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre> 
</div> 
<p>转载于:https://www.cnblogs.com/xyou/p/9504184.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0478f16cea93bfa94e364e2cffaaa4ff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">The slave I/O thread stops because master and slave have equal MySQL server UUIDs;</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e0811a65ad7b23487c0acb00dae5cbd5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">String index out of range: 100 报错详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>