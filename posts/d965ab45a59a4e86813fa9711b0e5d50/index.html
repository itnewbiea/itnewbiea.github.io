<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>关于“Python”的核心知识点整理大全28 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="关于“Python”的核心知识点整理大全28" />
<meta property="og:description" content="目录
11.1.5 添加新测试
11.2 测试类
11.2.1 各种断言方法
unittestModule中的断言方法：
​编辑11.2.2 一个要测试的类
survey.py
language_survey.py
11.2.3 测试 AnonymousSurvey 类
test_survey.py
往期快速传送门👆（在文章最后）：
感谢大家的支持！欢迎订阅收藏！专栏将持续更新！
11.1.5 添加新测试 确定get_formatted_name()又能正确地处理简单的姓名后，我们再编写一个测试，用于测试 包含中间名的姓名。为此，我们在NamesTestCase类中再添加一个方法：
import unittest from name_function import get_formatted_name class NamesTestCase(unittest.TestCase): &#34;&#34;&#34;测试name_function.py &#34;&#34;&#34; def test_first_last_name(self): &#34;&#34;&#34;能够正确地处理像Janis Joplin这样的姓名吗？&#34;&#34;&#34; formatted_name = get_formatted_name(&#39;janis&#39;, &#39;joplin&#39;) self.assertEqual(formatted_name, &#39;Janis Joplin&#39;) def test_first_last_middle_name(self): &#34;&#34;&#34;能够正确地处理像Wolfgang Amadeus Mozart这样的姓名吗？&#34;&#34;&#34; 1 formatted_name = get_formatted_name( &#39;wolfgang&#39;, &#39;mozart&#39;, &#39;amadeus&#39;) self.assertEqual(formatted_name, &#39;Wolfgang Amadeus Mozart&#39;) unittest.main() 我们将这个方法命名为test_first_last_middle_name()。方法名必须以test_打头，这样它才 会在我们运行test_name_function.py时自动运行。这个方法名清楚地指出了它测试的是get_ formatted_name()的哪个行为，这样，如果该测试未通过，我们就会马上知道受影响的是哪种类 型的姓名。在TestCase类中使用很长的方法名是可以的；这些方法的名称必须是描述性的，这才 能让你明白测试未通过时的输出；这些方法由Python自动调用，你根本不用编写调用它们的代码。
为测试函数get_formatted_name()，我们使用名、姓和中间名调用它（见1），再使用 assertEqual()检查返回的姓名是否与预期的姓名（名、中间名和姓）一致。我们再次运行 test_name_function.py时，两个测试都通过了：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d965ab45a59a4e86813fa9711b0e5d50/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-19T00:15:00+08:00" />
<meta property="article:modified_time" content="2023-12-19T00:15:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">关于“Python”的核心知识点整理大全28</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="11.1.5%20%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#11.1.5%20%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%B5%8B%E8%AF%95" rel="nofollow">11.1.5 添加新测试</a></p> 
<p id="11.2%20%E6%B5%8B%E8%AF%95%E7%B1%BB-toc" style="margin-left:40px;"><a href="#11.2%20%E6%B5%8B%E8%AF%95%E7%B1%BB" rel="nofollow">11.2 测试类</a></p> 
<p id="11.2.1%20%E5%90%84%E7%A7%8D%E6%96%AD%E8%A8%80%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#11.2.1%20%E5%90%84%E7%A7%8D%E6%96%AD%E8%A8%80%E6%96%B9%E6%B3%95" rel="nofollow">11.2.1 各种断言方法</a></p> 
<p id="%C2%A0unittestModule%E4%B8%AD%E7%9A%84%E6%96%AD%E8%A8%80%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0unittestModule%E4%B8%AD%E7%9A%84%E6%96%AD%E8%A8%80%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow"> unittestModule中的断言方法：</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%9111.2.2%20%E4%B8%80%E4%B8%AA%E8%A6%81%E6%B5%8B%E8%AF%95%E7%9A%84%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%9111.2.2%20%E4%B8%80%E4%B8%AA%E8%A6%81%E6%B5%8B%E8%AF%95%E7%9A%84%E7%B1%BB" rel="nofollow">​编辑11.2.2 一个要测试的类</a></p> 
<p id="survey.py-toc" style="margin-left:120px;"><a href="#survey.py" rel="nofollow">survey.py</a></p> 
<p id="language_survey.py-toc" style="margin-left:120px;"><a href="#language_survey.py" rel="nofollow">language_survey.py</a></p> 
<p id="11.2.3%20%E6%B5%8B%E8%AF%95%20AnonymousSurvey%20%E7%B1%BB-toc" style="margin-left:80px;"><a href="#11.2.3%20%E6%B5%8B%E8%AF%95%20AnonymousSurvey%20%E7%B1%BB" rel="nofollow">11.2.3 测试 AnonymousSurvey 类</a></p> 
<p id="test_survey.py-toc" style="margin-left:120px;"><a href="#test_survey.py" rel="nofollow">test_survey.py</a></p> 
<p id="%E5%BE%80%E6%9C%9F%E5%BF%AB%E9%80%9F%E4%BC%A0%E9%80%81%E9%97%A8%F0%9F%91%86%EF%BC%88%E5%9C%A8%E6%96%87%E7%AB%A0%E6%9C%80%E5%90%8E%EF%BC%89%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%BE%80%E6%9C%9F%E5%BF%AB%E9%80%9F%E4%BC%A0%E9%80%81%E9%97%A8%F0%9F%91%86%EF%BC%88%E5%9C%A8%E6%96%87%E7%AB%A0%E6%9C%80%E5%90%8E%EF%BC%89%EF%BC%9A" rel="nofollow">往期快速传送门👆（在文章最后）：</a></p> 
<p id="%E6%84%9F%E8%B0%A2%E5%A4%A7%E5%AE%B6%E7%9A%84%E6%94%AF%E6%8C%81%EF%BC%81%E6%AC%A2%E8%BF%8E%E8%AE%A2%E9%98%85%E6%94%B6%E8%97%8F%EF%BC%81%E4%B8%93%E6%A0%8F%E5%B0%86%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%81-toc" style="margin-left:0px;"><a href="#%E6%84%9F%E8%B0%A2%E5%A4%A7%E5%AE%B6%E7%9A%84%E6%94%AF%E6%8C%81%EF%BC%81%E6%AC%A2%E8%BF%8E%E8%AE%A2%E9%98%85%E6%94%B6%E8%97%8F%EF%BC%81%E4%B8%93%E6%A0%8F%E5%B0%86%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%81" rel="nofollow">感谢大家的支持！欢迎订阅收藏！专栏将持续更新！</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p style="text-align:center;"><img alt="" height="234" src="https://images2.imgbox.com/e1/2d/n4oM3YDX_o.png" width="373"></p> 
<h3 id="11.1.5%20%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%B5%8B%E8%AF%95" style="text-align:center;">11.1.5 添加新测试</h3> 
<blockquote> 
 <p style="text-align:center;">确定get_formatted_name()又能正确地处理简单的姓名后，我们再编写一个测试，用于测试 包含中间名的姓名。为此，我们在NamesTestCase类中再添加一个方法：</p> 
</blockquote> 
<pre><code class="language-python">import unittest
from name_function import get_formatted_name
class NamesTestCase(unittest.TestCase):
 """测试name_function.py """
 def test_first_last_name(self):
 """能够正确地处理像Janis Joplin这样的姓名吗？"""
 formatted_name = get_formatted_name('janis', 'joplin')
 self.assertEqual(formatted_name, 'Janis Joplin')
 def test_first_last_middle_name(self):
 """能够正确地处理像Wolfgang Amadeus Mozart这样的姓名吗？"""
1 formatted_name = get_formatted_name(
 'wolfgang', 'mozart', 'amadeus')
 self.assertEqual(formatted_name, 'Wolfgang Amadeus Mozart')
unittest.main()</code></pre> 
<blockquote> 
 <p style="text-align:center;">我们将这个方法命名为test_first_last_middle_name()。方法名必须以test_打头，这样它才 会在我们运行test_name_function.py时自动运行。这个方法名清楚地指出了它测试的是get_ formatted_name()的哪个行为，这样，如果该测试未通过，我们就会马上知道受影响的是哪种类 型的姓名。在TestCase类中使用很长的方法名是可以的；这些方法的名称必须是描述性的，这才 能让你明白测试未通过时的输出；这些方法由Python自动调用，你根本不用编写调用它们的代码。</p> 
 <p style="text-align:center;">为测试函数get_formatted_name()，我们使用名、姓和中间名调用它（见1），再使用 assertEqual()检查返回的姓名是否与预期的姓名（名、中间名和姓）一致。我们再次运行 test_name_function.py时，两个测试都通过了：</p> 
</blockquote> 
<pre><code class="language-python">..
----------------------------------------------------------------------
Ran 2 tests in 0.000s
OK</code></pre> 
<blockquote> 
 <p style="text-align:center;">太好了！现在我们知道，这个函数又能正确地处理像Janis Joplin这样的姓名了，我们还深信 它也能够正确地处理像Wolfgang Amadeus Mozart这样的姓名。</p> 
</blockquote> 
<h3 id="11.2%20%E6%B5%8B%E8%AF%95%E7%B1%BB" style="text-align:center;">11.2 测试类</h3> 
<blockquote> 
 <p style="text-align:center;">在本章前半部分，你编写了针对单个函数的测试，下面来编写针对类的测试。很多程序中都 会用到类，因此能够证明你的类能够正确地工作会大有裨益。如果针对类的测试通过了，你就能 确信对类所做的改进没有意外地破坏其原有的行为。</p> 
</blockquote> 
<h4 id="11.2.1%20%E5%90%84%E7%A7%8D%E6%96%AD%E8%A8%80%E6%96%B9%E6%B3%95" style="text-align:center;">11.2.1 各种断言方法</h4> 
<blockquote> 
 <p style="text-align:center;">Python在unittest.TestCase类中提供了很多断言方法。前面说过，断言方法检查你认为应 该满足的条件是否确实满足。如果该条件确实满足，你对程序行为的假设就得到了确认，你就可 以确信其中没有错误。如果你认为应该满足的条件实际上并不满足，Python将引发异常。 表11-1描述了6个常用的断言方法。使用这些方法可核实返回的值等于或不等于预期的值、 返回的值为True或False、返回的值在列表中或不在列表中。你只能在继承unittest.TestCase的 类中使用这些方法，下面来看看如何在测试类时使用其中的一个。</p> 
</blockquote> 
<h3 id="%C2%A0unittestModule%E4%B8%AD%E7%9A%84%E6%96%AD%E8%A8%80%E6%96%B9%E6%B3%95%EF%BC%9A" style="text-align:center;"> unittestModule中的断言方法：</h3> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%9111.2.2%20%E4%B8%80%E4%B8%AA%E8%A6%81%E6%B5%8B%E8%AF%95%E7%9A%84%E7%B1%BB" style="text-align:center;"><img alt="" height="333" src="https://images2.imgbox.com/34/cf/Tf0zfY6J_o.png" width="1129">11.2.2 一个要测试的类</h4> 
<blockquote> 
 <p style="text-align:center;">类的测试与函数的测试相似——你所做的大部分工作都是测试类中方法的行为，但存在一些 不同之处，下面来编写一个类进行测试。来看一个帮助管理匿名调查的类：</p> 
 <h5 id="survey.py" style="text-align:center;">survey.py</h5> 
</blockquote> 
<pre><code class="language-python">class AnonymousSurvey():
 """收集匿名调查问卷的答案"""
1 def __init__(self, question):
 """存储一个问题，并为存储答案做准备"""
 self.question = question
 self.responses = []
2 def show_question(self):
 """显示调查问卷"""
 print(question)
3 def store_response(self, new_response):
 """存储单份调查答卷"""
 self.responses.append(new_response)
4 def show_results(self):
 """显示收集到的所有答卷"""
 print("Survey results:")
 for response in responses:
 print('- ' + response)</code></pre> 
<blockquote> 
 <p style="text-align:center;">这个类首先存储了一个你指定的调查问题（见1），并创建了一个空列表，用于存储答案。 这个类包含打印调查问题的方法（见2）、在答案列表中添加新答案的方法（见3）以及将存储 在列表中的答案都打印出来的方法（见4）。要创建这个类的实例，只需提供一个问题即可。有 了表示调查的实例后，就可使用show_question()来显示其中的问题，可使用store_response()来 存储答案，并使用show_results()来显示调查结果。 为证明AnonymousSurvey类能够正确地工作，我们来编写一个使用它的程序：</p> 
 <h5 id="language_survey.py" style="text-align:center;">language_survey.py</h5> 
</blockquote> 
<pre><code class="language-python">from survey import AnonymousSurvey
#定义一个问题，并创建一个表示调查的AnonymousSurvey对象
question = "What language did you first learn to speak?"
my_survey = AnonymousSurvey(question)
#显示问题并存储答案
my_survey.show_question()
print("Enter 'q' at any time to quit.\n")
while True:
 response = input("Language: ")
 if response == 'q': 
break
 my_survey.store_response(response)
# 显示调查结果
print("\nThank you to everyone who participated in the survey!")
my_survey.show_results() </code></pre> 
<blockquote> 
 <p style="text-align:center;">这个程序定义了一个问题（"What language did you first learn to speak? "），并使用这个 问题创建了一个AnonymousSurvey对象。接下来，这个程序调用show_question()来显示问题，并 提示用户输入答案。收到每个答案的同时将其存储起来。用户输入所有答案（输入q要求退出） 后，调用show_results()来打印调查结果：</p> 
</blockquote> 
<pre><code class="language-python">What language did you first learn to speak?
Enter 'q' at any time to quit.
Language: English
Language: Spanish
Language: English
Language: Mandarin
Language: q
Thank you to everyone who participated in the survey!
Survey results:
- English
- Spanish
- English
- Mandarin </code></pre> 
<blockquote> 
 <p style="text-align:center;">AnonymousSurvey类可用于进行简单的匿名调查。假设我们将它放在了模块survey中，并想进 行改进：让每位用户都可输入多个答案；编写一个方法，它只列出不同的答案，并指出每个答案 出现了多少次；再编写一个类，用于管理非匿名调查。 进行上述修改存在风险，可能会影响AnonymousSurvey类的当前行为。例如，允许每位用户输 入多个答案时，可能不小心修改了处理单个答案的方式。要确认在开发这个模块时没有破坏既有 行为，可以编写针对这个类的测试。</p> 
</blockquote> 
<h4 id="11.2.3%20%E6%B5%8B%E8%AF%95%20AnonymousSurvey%20%E7%B1%BB" style="text-align:center;">11.2.3 测试 AnonymousSurvey 类</h4> 
<blockquote> 
 <p style="text-align:center;">下面来编写一个测试，对AnonymousSurvey类的行为的一个方面进行验证：如果用户面对调查 问题时只提供了一个答案，这个答案也能被妥善地存储。为此，我们将在这个答案被存储后，使 用方法assertIn()来核实它包含在答案列表中：</p> 
 <h5 id="test_survey.py" style="text-align:center;">test_survey.py</h5> 
</blockquote> 
<pre><code class="language-python">import unittest
from survey import AnonymousSurvey
1 class TestAnonmyousSurvey(unittest.TestCase):
 """针对AnonymousSurvey类的测试"""
2 def test_store_single_response(self):
 """测试单个答案会被妥善地存储"""
 question = "What language did you first learn to speak?"
3 my_survey = AnonymousSurvey(question)
 my_survey.store_response('English')
4 self.assertIn('English', my_survey.responses)
unittest.main()</code></pre> 
<blockquote> 
 <p style="text-align:center;">我们首先导入了模块unittest以及要测试的类AnonymousSurvey。我们将测试用例命名为 TestAnonymousSurvey，它也继承了unittest.TestCase（见1）。第一个测试方法验证调查问题的 单个答案被存储后，会包含在调查结果列表中。对于这个方法，一个不错的描述性名称是 test_store_single_response()（见2）。如果这个测试未通过，我们就能通过输出中的方法名得 知，在存储单个调查答案方面存在问题。</p> 
 <p style="text-align:center;">要测试类的行为，需要创建其实例。在3处，我们使用问题"What language did you first learn to speak?"创建了一个名为my_survey的实例，然后使用方法store_response()存储了单个答案 English。接下来，我们检查English是否包含在列表my_survey.responses中，以核实这个答案是 否被妥善地存储了（见4）。 当我们运行test_survey.py时，测试通过了：</p> 
</blockquote> 
<pre><code class="language-python">.
----------------------------------------------------------------------
Ran 1 test in 0.001s
OK</code></pre> 
<blockquote> 
 <p style="text-align:center;">这很好，但只能收集一个答案的调查用途不大。下面来核实用户提供三个答案时，它们也将 被妥善地存储。为此，我们在TestAnonymousSurvey中再添加一个方法：</p> 
</blockquote> 
<pre><code class="language-python">import unittest
from survey import AnonymousSurvey
class TestAnonymousSurvey(unittest.TestCase):
 """针对AnonymousSurvey类的测试"""
 def test_store_single_response(self):
 """测试单个答案会被妥善地存储"""
 --snip--
 def test_store_three_responses(self):
 """测试三个答案会被妥善地存储"""
 question = "What language did you first learn to speak?"
 my_survey = AnonymousSurvey(question)
1 responses = ['English', 'Spanish', 'Mandarin']
 for response in responses: 
 my_survey.store_response(response)
2 for response in responses:
 self.assertIn(response, my_survey.responses)
unittest.main()</code></pre> 
<blockquote> 
 <p style="text-align:center;">我们将这个方法命名为test_store_three_responses()，并像test_store_single_response() 一样，在其中创建一个调查对象。我们定义了一个包含三个不同答案的列表（见1），再对其中 每个答案都调用store_response()。存储这些答案后，我们使用一个循环来确认每个答案都包含 在my_survey.responses中（见2）。</p> 
 <p style="text-align:center;">我们再次运行test_survey.py时，两个测试（针对单个答案的测试和针对三个答案的测试）都 通过了：</p> 
</blockquote> 
<pre><code class="language-python">..
----------------------------------------------------------------------
Ran 2 tests in 0.000s
OK</code></pre> 
<blockquote> 
 <p style="text-align:center;">前述做法的效果很好，但这些测试有些重复的地方。下面使用unittest的另一项功能来提高 它们的效率。</p> 
</blockquote> 
<p style="text-align:center;"><a href="https://blog.csdn.net/lzy302810/article/details/135043856?spm=1001.2014.3001.5501" title="关于“Python”的核心知识点整理大全25-CSDN博客">关于“Python”的核心知识点整理大全25-CSDN博客</a></p> 
<p style="text-align:center;"><a href="https://blog.csdn.net/lzy302810/article/details/134917938?spm=1001.2014.3001.5501" title="关于“Python”的核心知识点整理大全12-CSDN博客">关于“Python”的核心知识点整理大全12-CSDN博客</a></p> 
<h2 id="%E5%BE%80%E6%9C%9F%E5%BF%AB%E9%80%9F%E4%BC%A0%E9%80%81%E9%97%A8%F0%9F%91%86%EF%BC%88%E5%9C%A8%E6%96%87%E7%AB%A0%E6%9C%80%E5%90%8E%EF%BC%89%EF%BC%9A" style="text-align:center;">往期快速传送门👆（在文章最后）：</h2> 
<h2 id="%E6%84%9F%E8%B0%A2%E5%A4%A7%E5%AE%B6%E7%9A%84%E6%94%AF%E6%8C%81%EF%BC%81%E6%AC%A2%E8%BF%8E%E8%AE%A2%E9%98%85%E6%94%B6%E8%97%8F%EF%BC%81%E4%B8%93%E6%A0%8F%E5%B0%86%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%81" style="text-align:center;"><a name="t6"></a><a name="t8"></a><a name="t10"></a><a name="t13"></a><a name="t11"></a>感谢大家的支持！欢迎订阅收藏！专栏将持续更新！</h2>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a9a7741587e59d21ea2d58d2cffe5fbd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">github超时解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/07105e7e51405094208773a524b41d48/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">cfa一级考生复习经验分享系列（六）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>