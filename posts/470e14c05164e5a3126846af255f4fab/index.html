<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>batchnormlization、layer normalization通俗理解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="batchnormlization、layer normalization通俗理解" />
<meta property="og:description" content="本文用举例的方式通俗地讲解了batchnormlization原理，是我觉得比较好理解的方式，比单纯公式好懂得多。
总体功能 将相同channel（特征）的数据进行归一化处理，也就是平移和缩放，让所有特征的量纲（特征值波动范围）差不多一致，可以让所有特征都能发挥作用，满足了glorot条件，有利于训练。
比如我一个特征A的值在0~255之间波动，另一个特征B的值0~1之间波动，那么我的模型去学习A特征带来loss减小的收益是远高于B特征的，因为A特征量纲比较大，对loss的影响也经常B大，模型会致力于去学习A特征，可以使loss降低地更快，带来地收益高，就导致B特征得不到充足的学习，导致最终结果变得不好。
光说可能太过抽象了，我们来举一个例子就好理解多了：实际上处理也就两步 比如我有一个batch（B）中有两张图像，每一张图像由RGB三个特征图组成(这一维度也叫channel即C)，图像宽度为W高度为H，
那么一轮输入的size即为：
（B,C,W,H）也就是(2,3,W,H)
我们此时要归一化的话，按channel分为3组（传入batchnorm的数据的第二维默认为channel，所以RGB其实就是不同的特征，想让谁作为特征就放在第二维），每一组都是
（B,1,W,H） --》三张图像的R特征
（B,1,W,H） --》三张图像的G特征
（B,1,W,H） --》三张图像的B特征
处理第一步：进行z-score放缩 作用：将输入数据的均值平移至0点，并将输入数据的方差放缩至1
接着上面的例子：
比如对于R特征，我有（B,1,W,H）也就是B*W*H个点是属于R特征的(B个图每个图都有一个R特征图，每张图上有W*H个点，所以就是B*W*H个点是属于R特征的)
求这B*W*H个点的均值，对应上图的式子1
求这B*W*H个点的方差，对应上图的式子2
B*W*H个点同时减去均值，再除以方差的根号，对应上图的式子3，这步就是在归一化，z-score放缩。
对G和B特征也是同理
处理第二步：带参数的平移放缩 作用：第二阶段相当于在零均值的基础上再进行小规模的变换使其能适应模型，γ和β是属于模型的参数（也就是可以随着反向传播和梯度下降进行跟新的参数，require_grad=True），是可以跟着向前和向后的传播来进行修改的，能够达到生成一个适应模型的修正变换
公式：
new_x=γ*x&#43;β
x是每一个元素
接着第一步：
我们经过第一步，的到了处理过后的RGB特征，总体数据还是（B,C,W,H）
为（B,1,W,H） --》三张图像的R特征 分配1个γ1和β1
（B,1,W,H） --》三张图像的G特征 分配1个γ2和β2
（B,1,W,H） --》三张图像的B特征 分配1个γ3和β3
以R为例子，B*W*H个点同时乘以相同的γ1，再加上相同的β1，即可得到放缩后的结果，γ1和β1都是数，不是数组，比如γ1为3，β1为2。
对G和B特征也是同理
至此bn的操作就完成了 我们可以得出一些结论 1.bn对属于相同的特征的值做加减乘除操作都是都是相同的，比如n1，n2都属于特征1，比如n1&#43;100，n2也必须加上100，n1除以100，n2也必须除以100，这才能保证特征的一个整体分布不会被打乱，也就是各个特征间的相对位置不能有变化。
2.bn层并不会改变输入数据的size，因为只是对数据做了平移和放缩，也就是仿射变换
3.操作的两步本质都是平移和放缩，是一样的
4.第一步C组均值和方差，第二步有C组γ和β，官网也有提到
γ and β are learnable parameter vectors of size C (where C is the number of features or channels of the input)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/470e14c05164e5a3126846af255f4fab/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-26T17:14:48+08:00" />
<meta property="article:modified_time" content="2023-04-26T17:14:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">batchnormlization、layer normalization通俗理解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> 本文用举例的方式通俗地讲解了batchnormlization原理，是我觉得比较好理解的方式，比单纯公式好懂得多。</p> 
<p></p> 
<h2>总体功能</h2> 
<p><strong>将相同channel（特征）的数据</strong>进行归一化处理，也就是平移和缩放，让所有特征的量纲（特征值波动范围）差不多一致，可以让所有特征都能发挥作用，满足了glorot条件，有利于训练。</p> 
<p>比如我一个特征A的值在0~255之间波动，另一个特征B的值0~1之间波动，那么我的模型去学习A特征带来loss减小的收益是远高于B特征的，因为A特征量纲比较大，对loss的影响也经常B大，模型会致力于去学习A特征，可以使loss降低地更快，带来地收益高，就导致B特征得不到充足的学习，导致最终结果变得不好。</p> 
<p></p> 
<h3><strong>光说可能太过抽象了，我们来举一个例子就好理解多了：实际上处理也就两步</strong></h3> 
<p></p> 
<p>比如我有一个batch（B）中有两张图像，每一张图像由RGB三个特征图组成(这一维度也叫channel即C)，图像宽度为W高度为H，</p> 
<p>那么一轮输入的size即为：</p> 
<p>（B,C,W,H）也就是(2,3,W,H)</p> 
<p></p> 
<p>我们此时要归一化的话，按channel分为3组（传入batchnorm的数据的第二维默认为channel，所以RGB其实就是不同的特征，想让谁作为特征就放在第二维），每一组都是</p> 
<p>（B,1,W,H） --》三张图像的R特征</p> 
<p>（B,1,W,H） --》三张图像的G特征</p> 
<p>（B,1,W,H） --》三张图像的B特征</p> 
<p></p> 
<h4>处理第一步：进行z-score放缩</h4> 
<p><strong>作用：</strong>将输入数据的均值平移至0点，并将输入数据的方差放缩至1</p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/7f/e8/Tn88cl2f_o.png" width="255"></p> 
<p> 接着上面的例子：</p> 
<p>比如对于R特征，我有（B,1,W,H）也就是B*W*H个点是属于R特征的(B个图每个图都有一个R特征图，每张图上有W*H个点，所以就是B*W*H个点是属于R特征的)</p> 
<p>求这B*W*H个点的均值，对应上图的式子1</p> 
<p>求这B*W*H个点的方差，对应上图的式子2</p> 
<p></p> 
<p>B*W*H个点同时减去均值，再除以方差的根号，对应上图的式子3，这步就是在归一化，z-score放缩。</p> 
<p>对G和B特征也是同理</p> 
<p></p> 
<h4>处理第二步：带参数的平移放缩</h4> 
<p><strong>作用：</strong>第二阶段相当于在零均值的基础上再进行小规模的变换使其能适应模型，<strong>γ和β是属于模型的参数（也就是可以随着反向传播和梯度下降进行跟新的参数，require_grad=True）</strong>，是可以跟着向前和向后的传播来进行修改的，<strong>能够达到生成一个适应模型的修正变换</strong></p> 
<p>公式：<br>         new_x=γ*x+β</p> 
<p>x是每一个元素</p> 
<p><strong>  接着第一步：</strong></p> 
<p>我们经过第一步，的到了处理过后的RGB特征，总体数据还是（B,C,W,H）</p> 
<p>为（B,1,W,H） --》三张图像的R特征 分配1个γ1和β1</p> 
<p>（B,1,W,H） --》三张图像的G特征 分配1个γ2和β2</p> 
<p>（B,1,W,H） --》三张图像的B特征 分配1个γ3和β3</p> 
<p>以R为例子，<strong>B*W*H个点同时乘以相同的γ1，再加上相同的β1</strong>，即可得到放缩后的结果，γ1和β1都是数，不是数组，比如γ1为3，β1为2。</p> 
<p>对G和B特征也是同理</p> 
<p></p> 
<h4>至此bn的操作就完成了</h4> 
<p></p> 
<h4><span style="color:#fe2c24;">我们可以得出一些结论</span></h4> 
<p><span style="color:#ff9900;">1.bn对属于<strong>相同的特征的值</strong>做加减乘除操作都是都是相同的，比如n1，n2都属于特征1，比如n1+100，n2也必须加上100，n1除以100，n2也必须除以100，这才能保证特征的一个整体分布不会被打乱，也就是各个特征间的相对位置不能有变化。</span></p> 
<p><span style="color:#ff9900;">2.bn层并不会改变输入数据的size，因为只是对数据做了平移和放缩，也就是仿射变换</span></p> 
<p><span style="color:#ff9900;">3.操作的两步本质都是平移和放缩，是一样的</span></p> 
<p><span style="color:#ff9900;">4.第一步C组均值和方差，第二步有C组γ和β，官网也有提到</span></p> 
<blockquote> 
 <p>γ and β are learnable parameter vectors of size C (where C is the number of features or channels of the input).</p> 
 <p>γ和β是大小为C的可学习参数向量（其中C是输入的特征或通道的数量）。</p> 
</blockquote> 
<h2></h2> 
<h2> pytorch的batchnorm的1d，2d，3d的区别</h2> 
<p><span style="color:#0d0016;"><strong>可处理的数据维度不同</strong>：</span></p> 
<p><strong><span style="color:#0d0016;">1d</span></strong></p> 
<ul><li> <p>Input: (N, C)(N,C) or (N, C, L)(N,C,L), where NN is the batch size, CC is the number of features or channels, and LL is the sequence length</p> </li><li> <p>Output: (N, C)(N,C) or (N, C, L)(N,C,L) (same shape as input)</p> </li></ul> 
<p></p> 
<p><strong>2d</strong></p> 
<ul><li> <p>Input: (N, C, H, W)(N,C,H,W)</p> </li><li> <p>Output: (N, C, H, W)(N,C,H,W) (same shape as input)</p> </li></ul> 
<p>3d</p> 
<p>以此类推</p> 
<p>都是以N为1个样本单位，也就是参加bn的数量为N，如果第一维为batch_size那就意思是以他为单位进行归一化。</p> 
<p>maxpool和bn有很多相似之处，比如1d，2d，3d，1d就是channel后面还有0维或者1维，2d就是后面还有两维，以此类推。</p> 
<p></p> 
<p></p> 
<h2><a id="batchnorm_7"></a>batchnorm的参数</h2> 
<blockquote> 
 <p><span style="color:#262626;"><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;">torch.nn. </span></span></span><span style="color:#262626;"><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;">BatchNorm2d</span></span></span><span style="color:#262626;"> ( </span><em><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;">num_features</span></span></em> ,<em><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;"> eps </span></span><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;">= </span></span><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;">1e05</span></span></em> ,<em><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;"> </span></span></em></p> 
 <p><em><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;">momentum </span></span><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;">= </span></span><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;">0.1</span></span></em> ,<em><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;"> affine </span></span><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;">= </span></span><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;">True</span></span></em> ,<em><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;"> track_running_stats </span></span><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;">= </span></span><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;">True</span></span></em> ,<em><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;"> </span></span></em></p> 
 <p><em><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;">device </span></span><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;">= </span></span><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;">None</span></span></em> ,<em><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;"> dtype </span></span><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;">= </span></span><span style="color:#6c6c6d;"><span style="background-color:#f3f4f7;">None</span></span></em><span style="color:#262626;"> )</span></p> 
</blockquote> 
<h4><strong>num_features：</strong></h4> 
<p>最重要的参数当然还是num_features也就是特征的数量(一共有多少特征)，搭配卷积使用时，先卷积后bn，那当然是和out_channel相同。</p> 
<p></p> 
<h4><a id="_10"></a><strong>affine ：</strong></h4> 
<p>是否加入第二阶段，也就是是否使用γ和β再生产对角矩阵进行仿射变换</p> 
<p></p> 
<h4> momentum：默认0.1</h4> 
<p>在计算running_mean/var时会用到，用sample_var 无偏和上一轮的running_mean/var来合成新的running_mean/var，momentum是这次的样本值，一般要epoch越大，momentum要越小，降低后面的波动幅度，增加稳定性。<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/19/f5/vDRWfUCl_o.png"></p> 
<p> 注意点：</p> 
<p><img alt="" height="233" src="https://images2.imgbox.com/b2/21/Jmg9udJi_o.png" width="1200"></p> 
<p> 也就是不同于传统优化器类中使用的动量和传统的动量概念，这里的动量是momentum是乘在新值上面的，在本文中就是momentum*running_mean/var，而传统动量中这个参数momentum应该是乘以上一轮的running_mean/var的.</p> 
<p></p> 
<p><strong>eps：默认 1e-5</strong></p> 
<p><img alt="" height="112" src="https://images2.imgbox.com/af/0d/WGbs9qbW_o.png" width="262"></p> 
<p> 就是这个数</p> 
<p><br><strong>track_running_stats：</strong></p> 
<p><strong>如官方文档所说</strong></p> 
<p>如果track_running_stats被设置为False，那么这个层就不会保留运行估计值，而在评估时也会使用批量统计。</p> 
<p>首先是moudle.training 参数</p> 
<p>这个参数是由model.train()或model.eval()决定的，当调用model.train()，则所有模型的training参数都会变为True，这个参数会搭配batchnorm和dropout来使用。</p> 
<p><img alt="" height="226" src="https://images2.imgbox.com/43/2d/4u5rR4FN_o.png" width="706"></p> 
<p></p> 
<p><strong>训练阶段：</strong></p> 
<p>当track_running_stats=True，running_mean和running_var会跟踪不同batch数据的mean和variance，但是仍然是用每个batch的mean和variance做normalization<br> 当track_running_stats=False，此时running_mean和running_var不跟踪不同batch数据的statistics，但是仍然用每个batch的mean和variance做normalization</p> 
<p><br><strong>测试阶段：</strong></p> 
<p>当track_running_stats=True，则使用训练阶段跟踪估计的running_mean和running_var做normalization<br> 当track_running_stats=False，训练阶段没有跟踪不同batch数据的statistics，因此使用每个batch的mean和variance做normalization<br>  </p> 
<p><strong>总结：track_running_stats这个参数就是一直使用默认的True参数就完事了，这种才是正常的使用方法</strong></p> 
<p><a class="link-info" href="https://blog.csdn.net/qq_40728667/article/details/121865517" title="track_running_stats教程">track_running_stats教程</a></p> 
<p><a class="link-info" href="https://www.cnblogs.com/jins-note/p/13440772.html" rel="nofollow" title="track_running_stats教程带trainning">track_running_stats教程带trainning</a></p> 
<h2></h2> 
<h2>layer normalization</h2> 
<h3>batch normalization与layer normalization的区别</h3> 
<h4><strong>二者做归一化的数据不同</strong></h4> 
<p>举例：</p> 
<p><strong><code>layer normalization比如我有数据(3,4,5),</code>normalized_shape为(4,5)，<code>那么我使用layer normalization有3个均值和方差，一个batch里的所有元素共用1个均值和方差。</code></strong></p> 
<p></p> 
<h4>二者效果的差别</h4> 
<p>LN比BN效果更好，</p> 
<p>BN比LN计算更快</p> 
<p></p> 
<h3>过程：</h3> 
<p>同batchnorm，第一步也是进行0均值化，第二部进行仿射变换，这里是逐元素的仿射变换，与batchnorm不同。</p> 
<p></p> 
<h3><strong><code>参数：</code></strong></h3> 
<blockquote> 
 <p><em>CLASS</em>torch.nn.LayerNorm(<em>normalized_shape</em>, <em>eps=1e-05</em>, <em>elementwise_affine=True</em>, <em>device=None</em>, <em>dtype=None</em>)</p> 
</blockquote> 
<p><strong>1.normalized_shape</strong> (<a href="https://docs.python.org/3/library/functions.html#int" rel="nofollow" title="int">int</a><em> or </em><a href="https://docs.python.org/3/library/stdtypes.html#list" rel="nofollow" title="list">list</a><em> or </em><em>torch.Size</em>) </p> 
<p>后面的哪些维度作为一个整体进行归一化</p> 
<p><strong>normalized_shape</strong> 必须是shape的后几维度，比如：<br> 我有(N, C, H, W)，那么我输入可以为[N,C,H,W],[C,H,W],[H,W],[W]</p> 
<p>如果为[N,C,H,W]那么就是所有的元素一起归一化，1均值，1方差</p> 
<p>[C,H,W]分为N个单位进行归一化，N均值，N方差，是图像领域常用的归一化手段。此时</p> 
<p></p> 
<p>也可以填入数字，数字的话只能是最后一维，如填入W，w=input.shape[-1]</p> 
<p></p> 
<p><strong>2.elementwise_affine</strong></p> 
<p>进行逐元素的仿射变换，每个元素都有自己独立的γ和β，公式还是<br>         new_x=γ*x+β</p> 
<h2><a id="batchnorm1d2d3d_4"></a></h2> 
<p></p> 
<p></p> 
<h2><a id="_11"></a>（可读）归一化与仿射变换的关系</h2> 
<p><a href="https://www.zhihu.com/question/20666664" rel="nofollow" title="仿射变换教程">仿射变换教程</a><br><strong>线性变换：</strong><span style="color:#fe2c24;"> <strong>就是矩阵乘法(这点很重要)</strong></span></p> 
<p><strong>数据平移：矩阵加减法</strong><br><strong>仿射变换</strong>：线性变换（矩阵乘法）+平移（矩阵加减法），式子如下图)。对于数据的仿射变换并<strong>不会影响数据分布</strong></p> 
<p><strong>归一化是仿射变换的特例：</strong> 归一化是一个特征同时加上某个数，且同时乘以某个数，此<strong>时的线性变换矩阵为对角矩阵</strong>，除了对角线其他位置元素都为0，可以保证每一列都乘以某一个数，且其他特征无法对特征造成影响，因为权重都为0。</p> 
<p><br><strong>普通放射变换：</strong> 普通放射变换的变换矩阵就不一定是对角矩阵了，意味着不同的特征可能发生权重相加的交互，但本质上还是线性变换，数据特征得分布都是不变的</p> 
<p>归一化实际上是一种特殊的仿射变换,仿射变换又通过线性层，线性层是仿射变换，conv1d，conv2d不是仿射变换。</p> 
<p><img alt="放射变换实际上就是conv，linear在做的事，携程new_x=x*a+b" src="https://images2.imgbox.com/1d/50/mWPSqwzX_o.png"><br><span style="color:#fe2c24;">归一化时w为对角矩阵，可以保证每一列的乘以的值是一样的（对角矩阵等于对batch的相同位置的逐元素相乘）</span><br><span style="color:#fe2c24;">线性层时w可不为对角矩阵，都是进行仿射变换</span></p> 
<p><strong>将归一化看成特殊的线性层，线性层就是pytorch中的仿射变换的实现方式</strong></p> 
<p>      <strong>  bn的两个阶段：第一阶段和第二阶段实际都是逐元素乘法和加法，可以用对角矩阵来实现，当然也可以直接逐元素相乘不用对角矩阵都是一个道理。</strong><br>  </p> 
<p></p> 
<p></p> 
<p></p> 
<h2><a id="varvar_36"></a>什么时候用到无偏估计的var，什么时候用到有偏估计的var</h2> 
<p>这里的var算的是一个batch的var，也就是方差，1个特征1个var，组成var的1行n列的矩阵<br> 有三个var要辨析：<br> sample_var 无偏<br> sample_var 有偏<br> running_var<br> 其实无偏估计的var就是对整体也就是所有数据的猜测，有偏则是对样本内数据方差的精确计算。<br> 这也就比较好理解下面了：<br><strong>sample_var 有偏</strong>:在对这一轮的样本进行Z-zero归一化时，使用的是有偏的var进行归一化</p> 
<p><strong>sample_var 无偏</strong>:无偏用于计算running_var ，就是不断地修改优化所有样本的var，所以每一个batch的无偏用来猜测整体的var，通过每个batch的预测的整合来达到对所有样本var的估计。</p> 
<p><strong>running_var</strong>：即所有样本的var的在目前的估计，会随着bn层的使用（对batch的sample_var 无偏的计算）而不断更新。</p> 
<h2><a id="momentum_50"></a></h2> 
<p></p> 
<h2>SYNCBATCHNORM</h2> 
<p><a class="link-info" href="https://zhuanlan.zhihu.com/p/555881100" rel="nofollow" title="https://zhuanlan.zhihu.com/p/555881100">https://zhuanlan.zhihu.com/p/555881100</a></p> 
<p>我对SYNCBATCHNORM的理解实际上就还是batchnorm，只不过数据都分散开了，比如我有4个GPU，每个GPU batchsize为2，那么我计算batchnorm其实是按batchsize为8进行计算的，也就是8个batch合体计算，就是这么直接。</p> 
<p>使用convert_sync_batchnorm成员函数可以将所有batchnorm转换为同步。</p> 
<p>我觉得利用这个特性数据同步可以有更大的发展空间，不用再为bn层烦恼</p> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/851214ad4b5806dd96d55d43712a62c8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在Java中 如何快速向Redis导入上百万key数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/55862a6937e48add811deda85d75eda9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何将网址批量生成二维码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>