<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>QT延时/等待怎么写？阻塞延时/不阻塞延时/耗时代码的处理 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="QT延时/等待怎么写？阻塞延时/不阻塞延时/耗时代码的处理" />
<meta property="og:description" content="参考链接：
https://blog.csdn.net/yanche521/article/details/50977301
https://www.cnblogs.com/-wang-cheng/p/4973021.html
一、阻塞型延时 阻塞的原理就是：在延时期间，本线程的事件循环得不到执行。
1、QThread类的sleep() 最简单的延时方法就是使用QThread类的sleep(n)、msleep(n)、usleep(n)，这几个函数的不良后果就是，GUI会在延时的时间段内失去响应，界面卡死，所以，这三个函数一般用在非GUI线程中。
QThread::msleep(50);//阻塞延时50ms 2、使用定时器：死等 void Delay_MSec_Suspend(unsigned int msec) { QTime _Timer = QTime::currentTime().addMSecs(msec); while( QTime::currentTime() &lt; _Timer ); } 二、非阻塞延时 原理无非就是利用事件循环，有两种原理：
1、处理本线程的事件循环 在等待中，不断强制进入当前线程的事件循环，这样可以把堵塞的事件都处理掉，从而避免程序卡死
void Delay_MSec(unsigned int msec) { QTime _Timer = QTime::currentTime().addMSecs(msec); while( QTime::currentTime() &lt; _Timer ) QCoreApplication::processEvents(QEventLoop::AllEvents, 100); QCoreApplication::processEvents(QEventLoop::AllEvents, 100);//这条语句能够使程序在while等待期间，去处理一下本线程的事件循环，处理事件循环最多100ms必须返回本语句，如果提前处理完毕，则立即返回这条语句。这也就导致了该Delay_MSec函数的定时误差可能高达100ms。
2、使用子事件循环 创建子事件循环，在子事件循环中，父事件循环仍然是可以执行的
void Delay_MSec(unsigned int msec) { QEventLoop loop;//定义一个新的事件循环 QTimer::singleShot(msec, &amp;loop, SLOT(quit()));//创建单次定时器，槽函数为事件循环的退出函数 loop.exec();//事件循环开始执行，程序会卡在这里，直到定时时间到，本循环被退出 } 三、耗时代码的处理 假设有这样的应用情景：点击某个button之后，需要读入并处理一幅图像，需要耗时20秒才能处理完。
在这20s内，GUI会失去效应，界面上的任何元素都无法被点击，这种情况应该怎么办？方法有两种：1、用另一个线程去处理这个耗时任务；2、在耗时任务中，不断地去处理本线程的事件循环，以保证GUI的及时响应。
这里重点说一下第2种，参考https://blog.csdn.net/dbzhang800/article/details/6554104
for(i=0; i &lt; 1000000; i&#43;&#43;) { //QCoreApplication::processEvents(QEventLoop::AllEvents); //去处理本线程的事件循环，避免本线程被堵塞 QCoreApplication::processEvents(QEventLoop::AllEvents, 5);//如果不够频繁，可以增加第二参数来缓解卡顿 for(j=0; j &lt; 1000000; j&#43;&#43;) { //QCoreApplication::processEvents(QEventLoop::AllEvents);//处理事件循环，不建议放在这里，可能过于频繁 doSomeThing(); } } 一般来说，processEvents()不宜被调用的过于频繁，也不宜被调用的不够频繁。过于频繁的话，一方面会使线程的响应更好，但另一方面会导致原本就耗时的任务变得更加耗时；不够频繁的话，显然可能会使GUI线程的响应变差，例如每500ms才被调用一次，那么GUI的事件循环就只能500ms才被处理一次，当然，这个问题可以通过设定processEvents()的第二个形参略微得到缓解，更好的做法是，保证被调的周期&lt;200ms（再小一些更好，看程序需求），这样不至于肉眼可见的卡顿。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0ed0278455ab2183af4bf3504b3f28ed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-27T21:40:59+08:00" />
<meta property="article:modified_time" content="2018-05-27T21:40:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">QT延时/等待怎么写？阻塞延时/不阻塞延时/耗时代码的处理</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:28px;"><strong>参考链接：</strong></span></p> 
<p>https://blog.csdn.net/yanche521/article/details/50977301</p> 
<p>https://www.cnblogs.com/-wang-cheng/p/4973021.html<br></p> 
<h6>一、阻塞型延时</h6> 
<p>阻塞的原理就是：在延时期间，本线程的事件循环得不到执行。</p> 
<h6>1、QThread类的sleep()</h6> 
<p>最简单的延时方法就是使用QThread类的sleep(n)、msleep(n)、usleep(n)，这几个函数的不良后果就是，GUI会在延时的时间段内失去响应，界面卡死，所以，这三个函数一般用在非GUI线程中。</p> 
<pre><code class="language-cpp">QThread::msleep(50);//阻塞延时50ms</code></pre> 
<h6>2、使用定时器：死等</h6> 
<pre><code class="language-cpp">void Delay_MSec_Suspend(unsigned int msec)
{    
    QTime _Timer = QTime::currentTime().addMSecs(msec);
    while( QTime::currentTime() &lt; _Timer );
}</code></pre> 
<h6>二、非阻塞延时</h6> 
<p>原理无非就是利用事件循环，有两种原理：</p> 
<h6>1、处理本线程的事件循环</h6> 
<p>在等待中，不断强制进入当前线程的事件循环，这样可以把堵塞的事件都处理掉，从而避免程序卡死</p> 
<pre><code class="language-html">void Delay_MSec(unsigned int msec)
{
    QTime _Timer = QTime::currentTime().addMSecs(msec);
    while( QTime::currentTime() &lt; _Timer )
        QCoreApplication::processEvents(QEventLoop::AllEvents, 100);</code></pre> 
<p>QCoreApplication::processEvents(QEventLoop::AllEvents, 100);//这条语句能够使程序在while等待期间，去处理一下本线程的事件循环，处理事件循环最多100ms必须返回本语句，如果提前处理完毕，则立即返回这条语句。这也就导致了该Delay_MSec函数的定时误差可能高达100ms。</p> 
<h6>2、使用子事件循环</h6> 
<p>创建子事件循环，在子事件循环中，父事件循环仍然是可以执行的</p> 
<pre><code class="language-cpp">void Delay_MSec(unsigned int msec)
{
    QEventLoop loop;//定义一个新的事件循环
    QTimer::singleShot(msec, &amp;loop, SLOT(quit()));//创建单次定时器，槽函数为事件循环的退出函数
    loop.exec();//事件循环开始执行，程序会卡在这里，直到定时时间到，本循环被退出
}</code></pre> 
<h6>三、耗时代码的处理</h6> 
<p>假设有这样的应用情景：点击某个button之后，需要读入并处理一幅图像，需要耗时20秒才能处理完。</p> 
<p>在这20s内，GUI会失去效应，界面上的任何元素都无法被点击，这种情况应该怎么办？方法有两种：1、用另一个线程去处理这个耗时任务；2、在耗时任务中，不断地去处理本线程的事件循环，以保证GUI的及时响应。</p> 
<p>这里重点说一下第2种，参考https://blog.csdn.net/dbzhang800/article/details/6554104</p> 
<pre><code class="language-cpp">for(i=0; i &lt; 1000000; i++)
{
    //QCoreApplication::processEvents(QEventLoop::AllEvents);    //去处理本线程的事件循环，避免本线程被堵塞
    QCoreApplication::processEvents(QEventLoop::AllEvents, 5);//如果不够频繁，可以增加第二参数来缓解卡顿

    for(j=0; j &lt; 1000000; j++)
    {
        //QCoreApplication::processEvents(QEventLoop::AllEvents);//处理事件循环，不建议放在这里，可能过于频繁
        doSomeThing();
    }
}</code></pre> 
<p>一般来说，processEvents()不宜被调用的过于频繁，也不宜被调用的不够频繁。过于频繁的话，一方面会使线程的响应更好，但另一方面会导致原本就耗时的任务变得更加耗时；不够频繁的话，显然可能会使GUI线程的响应变差，例如每500ms才被调用一次，那么GUI的事件循环就只能500ms才被处理一次，当然，这个问题可以通过设定processEvents()的第二个形参略微得到缓解，更好的做法是，保证被调的周期&lt;200ms（再小一些更好，看程序需求），这样不至于肉眼可见的卡顿。</p> 
<p>副作用：（特别注意！）</p> 
<p>1、在点击按钮之后，这个20s的耗时任务开始执行，尚未执行完毕时，我们点击了GUI的关闭按钮，那么GUI会立即消失，但是这个耗时任务仍然会在后台执行，直到执行完毕，进程才会退出。<span style="color:#ff0000;">解决办法</span>：重写关闭事件，在关闭事件的函数中直接结束进程。</p> 
<p>2、在点击按钮之后，这个20s的耗时任务开始执行，执行到第5秒时，我们再次点击了这个按钮，那么QT又会执行一个新的20s任务，这个新任务完成后，又会接着把第一个20s任务从上次被打断的第5秒继续执行。如果这个任务是可重入的，后果仅仅是被执行了两遍，如果任务不可重入，那情况就彻底糟糕了。<span style="color:#ff0000;">解决办法</span>：点击按钮后把这个按钮disable掉，执行完再enable</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/224b699a5973fb21aa8f080f027b65fa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">可编辑div的一些方法总结（一）复制文字去除标签和样式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f2c98a11991c3c5c87ba3757551318e1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">android studio 真机调试链接不上或者offline，adb.exe被占用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>