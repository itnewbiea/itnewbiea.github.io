<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[MySQL]如何选择合适的分布式主键方案 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[MySQL]如何选择合适的分布式主键方案" />
<meta property="og:description" content="文章目录 分布式主键是什么？什么情况下使用分布式主键？几种合适的分布式主键方案分布式主键的应用 分布式主键是什么？ 我们知道分布式，也知道主键，可将两个词组合起来“分布式主键”，又是什么呢？
分布式主键是一种用于在分布式系统中唯一标识数据的方案。在分布式系统中，数据通常被分散存储在不同的节点上，为了保证数据的唯一性和一致性，需要为每个数据分配一个唯一的标识符，即分布式主键。
分布式主键可以是任何可以唯一标识数据的值，比如UUID、数据库自增主键、分布式ID生成器等。分布式主键的选择需要考虑数据分布均匀性、唯一性、可排序性、易于生成和管理、性能和可扩展性等因素。使用分布式主键可以帮助分布式系统实现数据的唯一性和一致性，避免数据冲突和重复，同时也方便数据的查询和管理。
什么情况下使用分布式主键？ 选择合适的分布式主键方案需要考虑以下几个因素：
1. 数据分布均匀性： 分布式主键要能够让数据在不同节点之间均匀分布，避免数据倾斜问题。
2. 唯一性： 分布式主键要保证每个节点生成的主键都是唯一的，避免主键冲突问题。
3. 可排序性： 分布式主键要能够支持按照时间顺序进行排序，方便数据的查询和分析。
4. 易于生成和管理： 分布式主键的生成和管理应该是简单可靠的，不会给系统带来额外的负担。
5. 性能和可扩展性： 分布式主键的生成和查询应该具备高性能和可扩展性，能够满足系统的高并发和大规模数据存储需求。
几种合适的分布式主键方案 基于以上因素，可以选择以下几种分布式主键方案：
1. 数据库自增主键： 使用数据库自增主键可以保证唯一性和数据分布均匀性，且易于生成和管理，但是无法按时间排序，且在分布式环境下需要考虑主键生成的并发问题。
2. UUID： 使用UUID作为分布式主键可以保证唯一性和数据分布均匀性，但是无法按时间排序，且由于UUID长度较长，可能会影响性能和存储空间。
3. 雪花算法： 雪花算法可以生成唯一的、有序的分布式主键，适合按时间排序的场景，但是需要保证时钟的同步性，且在高并发场景下可能会出现冲突问题。
4. 分布式ID生成器： 使用分布式ID生成器（如Twitter的Snowflake）可以生成唯一的、有序的分布式主键，同时支持按时间排序，且具备高性能和可扩展性，但是需要保证时钟的同步性，且需要考虑分布式环境下的负载均衡和故障恢复等问题。
补充：雪花算法（了解）
雪花算法（Snowflake）是一种分布式唯一ID生成算法，由Twitter公司开发。它可以生成唯一的、有序的64位ID，其中包括一个41位的时间戳（精确到毫秒级）、10位的机器标识符和12位的序列号。
具体来说，雪花算法的64位ID格式：| 1位 | 41位时间戳（毫秒级） | 10位机器标识符 | 12位序列号 |
其中，1位为符号位，固定为0；41位时间戳可以支持69年的时间范围；10位机器标识符可以支持1024台机器；12位序列号可以支持每台机器每毫秒产生4096个ID。
雪花算法的核心思想是将64位ID按照时间戳、机器标识符和序列号进行拼接，保证每个ID都是唯一的、有序的。具体生成过程如下：1. 获取当前时间戳，精确到毫秒级。2. 将时间戳左移22位，将机器标识符左移12位。3. 生成一个序列号，如果当前毫秒内的序列号已经达到4096个，那么等待下一毫秒再生成序列号。4. 将时间戳、机器标识符和序列号进行拼接，得到一个64位的唯一ID。
雪花算法的优点是生成的ID有序、唯一、可排序，且可以满足高并发场景下的需求。但是需要注意的是，由于雪花算法依赖于机器标识符和时间戳，因此需要保证每台机器的时钟同步性，避免时钟回拨等问题；同时需要考虑分布式环境下的负载均衡和故障恢复等问题。
此外，还有两种也比较不错的方案：Redis生成ID和zookeeper生成唯一ID。
Redis生成ID：
Redis生成ID需要保证每个ID都是唯一的，否则会出现主键冲突问题。
Redis生成ID需要考虑并发问题，如果多个客户端同时请求生成ID，需要保证生成的ID是唯一的。
Redis生成ID需要考虑性能问题，如果Redis负载过高，可能会影响ID生成的性能。
Redis生成ID需要考虑可扩展性问题，如果需要支持更高的并发和更大规模的数据存储，需要考虑Redis集群化部署和数据分片等问题。
综上所述，Redis生成ID可以作为一种分布式主键的方案，但需要根据具体业务场景进行调整和优化。如果需要保证更高的性能和可扩展性，可以考虑使用分布式ID生成器（如雪花算法）等更专业的方案。
zookeeper生成唯一ID：
zookeeper生成唯一ID核心思想是利用zookeeper的节点顺序特性来生成唯一的ID。
具体来说，生成唯一ID的流程如下：
在zookeeper上创建一个持久节点，用于存储ID的基础值，比如初始值为0。
当需要生成唯一ID时，客户端在zookeeper上创建一个临时顺序节点，节点名称为“ID-”，并将持久节点的值加1，并将加1后的值作为节点的数据。
客户端可以通过监视zookeeper上的节点变化来获取生成的唯一ID。
由于zookeeper的节点顺序特性，每个客户端创建的临时顺序节点的名称是唯一的、有序的，因此可以通过节点名称来生成唯一ID。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c7bd9a25e51dd2652f8422e1bef5e46f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-28T14:27:52+08:00" />
<meta property="article:modified_time" content="2023-03-28T14:27:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[MySQL]如何选择合适的分布式主键方案</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_2" rel="nofollow">分布式主键是什么？</a></li><li><a href="#_9" rel="nofollow">什么情况下使用分布式主键？</a></li><li><a href="#_22" rel="nofollow">几种合适的分布式主键方案</a></li><li><a href="#_82" rel="nofollow">分布式主键的应用</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_2"></a>分布式主键是什么？</h2> 
<blockquote> 
 <p>        我们知道分布式，也知道主键，可将两个词组合起来“分布式主键”，又是什么呢？</p> 
</blockquote> 
<p>        分布式主键是一种用于在分布式系统中唯一标识数据的方案。在分布式系统中，数据通常被分散存储在不同的节点上，为了保证数据的唯一性和一致性，需要为每个数据分配一个唯一的标识符，即分布式主键。</p> 
<p>        分布式主键可以是任何可以唯一标识数据的值，比如UUID、数据库自增主键、分布式ID生成器等。分布式主键的选择需要考虑数据分布均匀性、唯一性、可排序性、易于生成和管理、性能和可扩展性等因素。使用分布式主键可以帮助分布式系统实现数据的唯一性和一致性，避免数据冲突和重复，同时也方便数据的查询和管理。</p> 
<h2><a id="_9"></a>什么情况下使用分布式主键？</h2> 
<p>        选择合适的分布式主键方案需要考虑以下几个因素：</p> 
<p>        1. <strong>数据分布均匀性：</strong> 分布式主键要能够让数据在不同节点之间均匀分布，避免数据倾斜问题。</p> 
<p>        2. <strong>唯一性：</strong> 分布式主键要保证每个节点生成的主键都是唯一的，避免主键冲突问题。</p> 
<p>        3. <strong>可排序性：</strong> 分布式主键要能够支持按照时间顺序进行排序，方便数据的查询和分析。</p> 
<p>        4. <strong>易于生成和管理：</strong> 分布式主键的生成和管理应该是简单可靠的，不会给系统带来额外的负担。</p> 
<p>        5. <strong>性能和可扩展性：</strong> 分布式主键的生成和查询应该具备高性能和可扩展性，能够满足系统的高并发和大规模数据存储需求。</p> 
<h2><a id="_22"></a>几种合适的分布式主键方案</h2> 
<p>        基于以上因素，可以选择以下几种分布式主键方案：</p> 
<p>        1. <strong>数据库自增主键：</strong> 使用数据库自增主键可以保证唯一性和数据分布均匀性，且易于生成和管理，但是无法按时间排序，且在分布式环境下需要考虑主键生成的并发问题。</p> 
<p>        2. <strong>UUID：</strong> 使用UUID作为分布式主键可以保证唯一性和数据分布均匀性，但是无法按时间排序，且由于UUID长度较长，可能会影响性能和存储空间。</p> 
<p>        3. <strong>雪花算法：</strong> 雪花算法可以生成唯一的、有序的分布式主键，适合按时间排序的场景，但是需要保证时钟的同步性，且在高并发场景下可能会出现冲突问题。</p> 
<p>        4. <strong>分布式ID生成器：</strong> 使用分布式ID生成器（如Twitter的Snowflake）可以生成唯一的、有序的分布式主键，同时支持按时间排序，且具备高性能和可扩展性，但是需要保证时钟的同步性，且需要考虑分布式环境下的负载均衡和故障恢复等问题。</p> 
<hr> 
<p><strong>补充：雪花算法（了解）</strong><br> 雪花算法（Snowflake）是一种分布式唯一ID生成算法，由Twitter公司开发。它可以生成唯一的、有序的64位ID，其中包括一个41位的时间戳（精确到毫秒级）、10位的机器标识符和12位的序列号。<br> 具体来说，雪花算法的64位ID格式：| 1位 | 41位时间戳（毫秒级） | 10位机器标识符 | 12位序列号 |<br> 其中，1位为符号位，固定为0；41位时间戳可以支持69年的时间范围；10位机器标识符可以支持1024台机器；12位序列号可以支持每台机器每毫秒产生4096个ID。</p> 
<p>雪花算法的核心思想是将64位ID按照时间戳、机器标识符和序列号进行拼接，保证每个ID都是唯一的、有序的。具体生成过程如下：1. 获取当前时间戳，精确到毫秒级。2. 将时间戳左移22位，将机器标识符左移12位。3. 生成一个序列号，如果当前毫秒内的序列号已经达到4096个，那么等待下一毫秒再生成序列号。4. 将时间戳、机器标识符和序列号进行拼接，得到一个64位的唯一ID。</p> 
<p>雪花算法的优点是生成的ID有序、唯一、可排序，且可以满足高并发场景下的需求。但是需要注意的是，由于雪花算法依赖于机器标识符和时间戳，因此需要保证每台机器的时钟同步性，避免时钟回拨等问题；同时需要考虑分布式环境下的负载均衡和故障恢复等问题。</p> 
<hr> 
<p>        此外，还有两种也比较不错的方案：Redis生成ID和zookeeper生成唯一ID。</p> 
<p><strong>Redis生成ID：</strong></p> 
<ol><li> <p>Redis生成ID需要保证每个ID都是唯一的，否则会出现主键冲突问题。</p> </li><li> <p>Redis生成ID需要考虑并发问题，如果多个客户端同时请求生成ID，需要保证生成的ID是唯一的。</p> </li><li> <p>Redis生成ID需要考虑性能问题，如果Redis负载过高，可能会影响ID生成的性能。</p> </li><li> <p>Redis生成ID需要考虑可扩展性问题，如果需要支持更高的并发和更大规模的数据存储，需要考虑Redis集群化部署和数据分片等问题。</p> </li></ol> 
<p>综上所述，Redis生成ID可以作为一种分布式主键的方案，但需要根据具体业务场景进行调整和优化。如果需要保证更高的性能和可扩展性，可以考虑使用分布式ID生成器（如雪花算法）等更专业的方案。</p> 
<p><strong>zookeeper生成唯一ID：</strong></p> 
<blockquote> 
 <p>zookeeper生成唯一ID核心思想是利用zookeeper的节点顺序特性来生成唯一的ID。</p> 
</blockquote> 
<p>具体来说，生成唯一ID的流程如下：</p> 
<ol><li> <p>在zookeeper上创建一个持久节点，用于存储ID的基础值，比如初始值为0。</p> </li><li> <p>当需要生成唯一ID时，客户端在zookeeper上创建一个临时顺序节点，节点名称为“ID-”，并将持久节点的值加1，并将加1后的值作为节点的数据。</p> </li><li> <p>客户端可以通过监视zookeeper上的节点变化来获取生成的唯一ID。</p> </li><li> <p>由于zookeeper的节点顺序特性，每个客户端创建的临时顺序节点的名称是唯一的、有序的，因此可以通过节点名称来生成唯一ID。</p> </li></ol> 
<p>利用zookeeper生成唯一ID的优点是实现简单、可靠性高，可以满足高并发场景下的需求，但需要注意以下几点：</p> 
<ol><li> <p>需要保证zookeeper的可用性和性能，否则可能会影响ID的生成和查询。</p> </li><li> <p>需要考虑并发问题，如果多个客户端同时请求生成ID，需要保证生成的ID是唯一的。</p> </li><li> <p>需要考虑可扩展性问题，如果需要支持更高的并发和更大规模的数据存储，需要考虑zookeeper集群化部署和数据分片等问题。</p> </li></ol> 
<p>综上所述，利用zookeeper生成唯一ID可以作为一种分布式主键的方案，但需要根据具体业务场景进行调整和优化。如果需要保证更高的性能和可扩展性，可以考虑使用分布式ID生成器（如雪花算法）等更专业的方案。</p> 
<h2><a id="_82"></a>分布式主键的应用</h2> 
<blockquote> 
 <p>        分布式主键不仅运用在<strong>分布式数据库</strong>（每个数据节点需要分配一个唯一的标识符来标识自己所存储的数据，以便于数据的查询和管理）中，还会在分布式缓存、分布式文件系统、分布式消息队列、分布式事务、分布式日志系统等中应用，应用场景还是非常广泛的。</p> 
</blockquote> 
<ol><li> <p><strong>分布式缓存：</strong> 在分布式缓存中，每个缓存数据需要分配一个唯一的标识符来标识自己所对应的数据，以便于缓存数据的查询和管理。</p> </li><li> <p><strong>分布式文件系统：</strong> 在分布式文件系统中，每个文件需要分配一个唯一的标识符来标识自己所对应的文件，以便于文件的查询和管理。</p> </li><li> <p><strong>分布式消息队列：</strong> 在分布式消息队列中，每个消息需要分配一个唯一的标识符来标识自己所对应的消息，以便于消息的查询和管理。</p> </li><li> <p><strong>分布式事务：</strong> 在分布式事务中，需要对多个数据节点进行操作，为了保证事务的一致性，需要为每个数据节点分配一个唯一的标识符来标识自己所对应的数据。</p> </li><li> <p><strong>分布式日志系统：</strong> 在分布式日志系统中，每个日志需要分配一个唯一的标识符来标识自己所对应的日志，以便于日志的查询和管理。</p> </li></ol>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d79c305a66a20caefc9a321d266b9c2b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【学习记录】镭神32线激光雷达ROS下运行fromRosMsg()报错 Failed to find match for field “intensity“ 问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cf52165a9e3e164e3489fd85d24bcc83/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux-磁盘挂载</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>