<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C语言】计算机是如何存储整数和小数的？ - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C语言】计算机是如何存储整数和小数的？" />
<meta property="og:description" content="文章目录 前言一、正整数和0二、负整数三、小数1、定点数（1）什么是定点数（2）表示精度（3）表示范围（4）优缺点 2、浮点数（1）什么是浮点数（2）将小数转为浮点数（3）浮点数在计算机中的存储格式（4）浮点数中的指数部分如何存入计算机（5）表示精度（6）表示范围（7）优缺点 四、答疑1、定点数表示法已经被淘汰了吗？2、为什么说整数的存储其实也是用定点数存储格式？3、硬件FPU单元 参考资料 前言 一条数轴上的数可以分为整数和小数，整数包括正整数、负整数和0，小数也包括正小数和负小数。
人类借助&#34;&#43;“、”-“、”.&#34;、&#34;0~9&#34;等符号以及约定俗成的摆放顺序来表示和存储不同的数字。
但计算机只认识0和1，要想在计算机中表示和存储不同的数字，就需要借助一套完整的存储规则。
对于不同类型的数字，存储规则也是不一样的。
一、正整数和0 正整数和0在计算机中的表示方法最为简单，就是转化的二进制数本身。
如3在计算机中就表示为0000_0011。
二、负整数 先说答案，负整数在计算机中采用补码表示。
转化过程：
先取得负整数绝对值的二进制形式（注意符号位为1），得到原码，按位取反（符号位不用管）得到反码，再加1即可得到补码。
举一个例子：
-7的原码为1000_0111，反码为1111_1000，补码为1111_1001。
问：为什么负数要以这样的形式存储在计算机中呢？
答：为了方便进行数值运算。如要实现-7&#43;3 = -4，
在计算机中是这样进行的：
1111_1001 &#43; 0000_0011 = 1111_1100
而-4的原码为1000_0100，反码为1111_1011，补码为1111_1100，这样就跟上面的计算结果相吻合了。
而如果不用补码，假设用1000_0111表示-7，其中左边第一位为符号位，那进行如下计算：
1000_0111 &#43; 0000_0011 = 1000_1010，结果并不能表示-4。
这里涉及补码向十进制的转换，反过来就行：
-4的补码为1111_1100，先减一，为1111_1011，按位取反为1000_0100，即-4的原码。
三、小数 先说答案，现代计算机采用浮点数的方式保存小数。
但早期的计算机使用定点数的方式保存小数。
1、定点数 （1）什么是定点数 注意：定点数不是指一类数字，而是指一种小数在计算机中的存储方法。
定点数就是指小数点位置不动的小数存储方式。
定点数存储法其实就是将小数直接转化为二进制存储在计算机中。这跟正整数和0的存储方法是一样的，其实正整数和0也是按照定点数的方式存储的，只是此时小数部分全为0省略了而已。
如用8bit空间存储定点数，约定前4位为整数部分，后4位为小数部分。很显然这样小数点的位置就固定在了第3位和第4位之间。
这样做的好处就在于能一眼看出所要表示的数字。
比如这里就能一眼看出所要表达的小数为1011.0111
转化为十进制就是：
现在我们来分析定点数表示法的精度和范围。
（2）表示精度 首先精度在这里就是表示数学上的准确数值与计算机中实际存储的数值的误差。
为了说明这个误差有时候是不可避免的，我举一个例子：
数学上的π是一个无限不循环小数，要存储它理论上需要一块无限大的空间，但这是不可能的，计算机的存储空间是有限的，因此只能存储π的近似值，由此误差就产生了。
以上面的8bit空间为例，其中4位表示小数，因此这种情况下精度是1/16，即0.0625。
这里结合之前写的博文【科普】精度和分辨率的区别与联系
可以知道，由于没有系统误差，因此这里的精度等价于分辨率。
这样就好理解了，4位小数的分辨率就是1/16。
（3）表示范围 如上所述的8bit空间可以存储的最大数字为1111_1111=8&#43;4&#43;2&#43;1&#43;1/2&#43;1/4&#43;1/8&#43;1/16=15.9375
最小可以表示的正数为0000_0001=1/16=0.0625。
（4）优缺点 优点：
——简单易懂：定点数表示法相对于其他复杂的表示方法（如浮点数）来说更加简单和直观，易于理解和实现。
——固定精度：定点数具有固定的位数来表示整数和小数部分，因此精度是固定的。这在某些应用中可能是有益的，可以保持一致的精度。
——运算速度快：相比于浮点数运算，定点数运算通常更加高效，因为定点数的运算只涉及整数运算，无需处理浮点数的特殊规则。
缺点：
——固定精度：虽然固定精度是定点数的一个优点，但在某些情况下也可能成为缺点。当处理非常大或非常小的数值时，固定的精度可能不足以保持所需的准确性，导致舍入误差。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/fc3f14b4ac3ea6bb5a69e3ecd416ea90/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-29T22:21:38+08:00" />
<meta property="article:modified_time" content="2023-06-29T22:21:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C语言】计算机是如何存储整数和小数的？</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_5" rel="nofollow">前言</a></li><li><a href="#0_16" rel="nofollow">一、正整数和0</a></li><li><a href="#_22" rel="nofollow">二、负整数</a></li><li><a href="#_49" rel="nofollow">三、小数</a></li><li><ul><li><a href="#1_54" rel="nofollow">1、定点数</a></li><li><ul><li><a href="#1_56" rel="nofollow">（1）什么是定点数</a></li><li><a href="#2_76" rel="nofollow">（2）表示精度</a></li><li><a href="#3_91" rel="nofollow">（3）表示范围</a></li><li><a href="#4_96" rel="nofollow">（4）优缺点</a></li></ul> 
   </li><li><a href="#2_132" rel="nofollow">2、浮点数</a></li><li><ul><li><a href="#1_133" rel="nofollow">（1）什么是浮点数</a></li><li><a href="#2_145" rel="nofollow">（2）将小数转为浮点数</a></li><li><a href="#3_160" rel="nofollow">（3）浮点数在计算机中的存储格式</a></li><li><a href="#4_173" rel="nofollow">（4）浮点数中的指数部分如何存入计算机</a></li><li><a href="#5_206" rel="nofollow">（5）表示精度</a></li><li><a href="#6_225" rel="nofollow">（6）表示范围</a></li><li><a href="#7_302" rel="nofollow">（7）优缺点</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_331" rel="nofollow">四、答疑</a></li><li><ul><li><a href="#1_332" rel="nofollow">1、定点数表示法已经被淘汰了吗？</a></li><li><a href="#2_336" rel="nofollow">2、为什么说整数的存储其实也是用定点数存储格式？</a></li><li><a href="#3FPU_347" rel="nofollow">3、硬件FPU单元</a></li></ul> 
  </li><li><a href="#_358" rel="nofollow">参考资料</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_5"></a>前言</h2> 
<p>一条数轴上的数可以分为整数和小数，整数包括正整数、负整数和0，小数也包括正小数和负小数。</p> 
<p>人类借助"+“、”-“、”."、"0~9"等符号以及约定俗成的摆放顺序来表示和存储不同的数字。</p> 
<p>但计算机只认识0和1，要想在计算机中表示和存储不同的数字，就需要借助一套完整的存储规则。</p> 
<p>对于不同类型的数字，存储规则也是不一样的。</p> 
<hr> 
<h2><a id="0_16"></a>一、正整数和0</h2> 
<p><font color="red"><strong>正整数和0在计算机中的表示方法最为简单，就是转化的二进制数本身。</strong></font></p> 
<p>如3在计算机中就表示为0000_0011。</p> 
<h2><a id="_22"></a>二、负整数</h2> 
<p>先说答案，<font color="red"><strong>负整数在计算机中采用补码表示。</strong></font></p> 
<p><code>转化过程：</code><br> 先取得负整数绝对值的二进制形式（注意符号位为1），得到原码，按位取反（符号位不用管）得到反码，再加1即可得到补码。</p> 
<p><code>举一个例子：</code><br> -7的原码为1000_0111，反码为1111_1000，补码为1111_1001。</p> 
<p><code>问：</code>为什么负数要以这样的形式存储在计算机中呢？</p> 
<p><code>答：</code>为了方便进行数值运算。如要实现-7+3 = -4，</p> 
<p>在计算机中是这样进行的：</p> 
<p>1111_1001 + 0000_0011 = 1111_1100</p> 
<p>而-4的原码为1000_0100，反码为1111_1011，补码为1111_1100，这样就跟上面的计算结果相吻合了。</p> 
<p>而如果不用补码，假设用1000_0111表示-7，其中左边第一位为符号位，那进行如下计算：</p> 
<p>1000_0111 + 0000_0011 = 1000_1010，结果并不能表示-4。</p> 
<p>这里涉及补码向十进制的转换，反过来就行：</p> 
<p>-4的补码为1111_1100，先减一，为1111_1011，按位取反为1000_0100，即-4的原码。</p> 
<h2><a id="_49"></a>三、小数</h2> 
<p>先说答案，<font color="red">现代计算机采用浮点数的方式保存小数。</font></p> 
<p>但早期的计算机使用定点数的方式保存小数。</p> 
<h3><a id="1_54"></a>1、定点数</h3> 
<h4><a id="1_56"></a>（1）什么是定点数</h4> 
<blockquote> 
 <p>注意：定点数不是指一类数字，而是指一种小数在计算机中的存储方法。</p> 
</blockquote> 
<p><font color="red"><strong>定点数就是指小数点位置不动的小数存储方式。</strong></font></p> 
<p>定点数存储法其实就是将小数直接转化为二进制存储在计算机中。这跟正整数和0的存储方法是一样的，其实正整数和0也是按照定点数的方式存储的，只是此时小数部分全为0省略了而已。</p> 
<p>如用8bit空间存储定点数，约定前4位为整数部分，后4位为小数部分。很显然这样小数点的位置就固定在了第3位和第4位之间。<br> <img src="https://images2.imgbox.com/5a/cf/htD8YLLG_o.png" alt="在这里插入图片描述"></p> 
<p>这样做的好处就在于能一眼看出所要表示的数字。</p> 
<p>比如这里就能一眼看出所要表达的小数为1011.0111</p> 
<p>转化为十进制就是：<br> <img src="https://images2.imgbox.com/54/ad/QGsTs6YP_o.png" alt="在这里插入图片描述"></p> 
<p>现在我们来分析定点数表示法的精度和范围。</p> 
<h4><a id="2_76"></a>（2）表示精度</h4> 
<p>首先精度在这里就是表示数学上的准确数值与计算机中实际存储的数值的误差。</p> 
<p>为了说明这个误差有时候是不可避免的，我举一个例子：</p> 
<p>数学上的π是一个无限不循环小数，要存储它理论上需要一块无限大的空间，但这是不可能的，计算机的存储空间是有限的，因此只能存储π的近似值，由此误差就产生了。</p> 
<p>以上面的8bit空间为例，其中4位表示小数，因此这种情况下精度是1/16，即0.0625。</p> 
<p>这里结合之前写的博文<a href="https://blog.csdn.net/qq_40130613/article/details/125944672">【科普】精度和分辨率的区别与联系</a></p> 
<p>可以知道，由于没有系统误差，<strong>因此这里的精度等价于分辨率。</strong></p> 
<p>这样就好理解了，4位小数的分辨率就是1/16。</p> 
<h4><a id="3_91"></a>（3）表示范围</h4> 
<p>如上所述的8bit空间可以存储的最大数字为1111_1111=8+4+2+1+1/2+1/4+1/8+1/16=15.9375</p> 
<p>最小可以表示的正数为0000_0001=1/16=0.0625。</p> 
<h4><a id="4_96"></a>（4）优缺点</h4> 
<p><code>优点：</code></p> 
<p>——<strong>简单易懂</strong>：定点数表示法相对于其他复杂的表示方法（如浮点数）来说更加简单和直观，易于理解和实现。</p> 
<p>——固定精度：定点数具有固定的位数来表示整数和小数部分，因此精度是固定的。这在某些应用中可能是有益的，可以保持一致的精度。</p> 
<p>——<strong>运算速度快</strong>：相比于浮点数运算，定点数运算通常更加高效，因为定点数的运算只涉及整数运算，无需处理浮点数的特殊规则。</p> 
<p><code>缺点：</code></p> 
<p>——固定精度：虽然固定精度是定点数的一个优点，但在某些情况下也可能成为缺点。当处理非常大或非常小的数值时，固定的精度可能不足以保持所需的准确性，导致舍入误差。</p> 
<p>——<strong>难以表示极小或极大的数值</strong>：定点数通常不适用于表示极小或极大的数值范围。对于超出表示范围的数值，定点数无法准确表示，因此需要使用更高精度的表示方法。</p> 
<p><code>这里可以举一个例子：</code></p> 
<p>普朗克长度约等于1.6x10^-35米，即0.00000000000000000000000000000000016m，用定点数表示为（也就是转化为二进制）：</p> 
<blockquote> 
 <p>0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011010100101011010010110110111111110000111101000001111。</p> 
</blockquote> 
<p>大约需要20多个字节才能存储得下。</p> 
<p>地球的质量5.965×10²⁴kg，即59650000000000000000000000千克，用定点数表示为（也就是转化为二进制）：</p> 
<blockquote> 
 <p>11000101010111011000001111101010111100011100110010101101011101010000000000000000000000</p> 
</blockquote> 
<p>需要十几个字节才能存储得下。</p> 
<p>注意：这里用了一个整数的例子，既在说明极大的数字用定点数方式存储的缺点，也在说明整数也可以用定点数表示，只是此时全部位都用来表示整数。</p> 
<p>可以发现在表示极大或极小的数字时，定点法非常消耗存储空间。</p> 
<p>为了解决上述问题，更复杂的浮点数诞生了。</p> 
<h3><a id="2_132"></a>2、浮点数</h3> 
<h4><a id="1_133"></a>（1）什么是浮点数</h4> 
<blockquote> 
 <p>跟定点数一样，浮点数也不是指一类数字，它指的是一种小数在计算机中的存储方法。</p> 
</blockquote> 
<p><font color="red"><strong>浮点数就是指小数点位置会变动的小数存储方式。</strong></font></p> 
<p>浮点数表示法跟科学计数法很相似：<br> <img src="https://images2.imgbox.com/cc/29/kFLrp4id_o.png" alt="在这里插入图片描述"><br> Float：要表示的小数<br> s：符号位，1表示负数，0表示正数<br> M：尾数<br> E：指数</p> 
<h4><a id="2_145"></a>（2）将小数转为浮点数</h4> 
<p><code>举两个例子：</code></p> 
<p>–将15.625转化为浮点数<br> 首先将其转化为二进制1111.101（这其实就是定点数表示法）<br> 用浮点形式表示为:<br> <img src="https://images2.imgbox.com/f1/d9/mlHSXU8F_o.png" alt="在这里插入图片描述"></p> 
<p>–将0.01875转化为浮点数<br> 首先将其转化为二进为0.0011<br> 用浮点形式表示为:<br> <img src="https://images2.imgbox.com/3b/ef/xmhlRudT_o.png" alt="在这里插入图片描述"></p> 
<p><font color="red">可以看到小数点位置发生了变动，因此称为浮点数，浮即浮动，点即小数点</font></p> 
<h4><a id="3_160"></a>（3）浮点数在计算机中的存储格式</h4> 
<p>要存储一个浮点数，需要存储三个东西：符号、指数和尾数。</p> 
<p>这里C语言提供了两种浮点数封装格式：float和double<br> <img src="https://images2.imgbox.com/db/05/Ea1P1RiF_o.png" alt="在这里插入图片描述"></p> 
<p>其中符号位为0就表示正数，符号位为1就表示负数。</p> 
<p>通过上面的例子可以发现尾数取值范围为 [1,2），也就是说尾数的整数部分一定为1，这样就没必要浪费空间存储整数部分了。对于1.111101只要存储后面的111101就行。<strong>因此计算机真正存储的只是尾数的后半部分。</strong></p> 
<p>指数部分可能为正数也可能为负数，如果再添加一个符号位按照补码的方式存储未免过于繁琐，这里聪明的科学家设计了一个巧妙的方法。</p> 
<h4><a id="4_173"></a>（4）浮点数中的指数部分如何存入计算机</h4> 
<p>先说答案，以float为例，在存入指数前，先加上127，这样即使指数为负数，加上127后也会变为正数。这样就不用再用补码表示负数了。</p> 
<p>因此，读取指数时也要先减去127。</p> 
<p><code>举2个例子：</code></p> 
<p>15.625浮点形式为:<br> <img src="https://images2.imgbox.com/e4/78/adgZCpoL_o.png" alt="在这里插入图片描述"><br> 符号位为0，尾数为1.111101，只存储后面的111101，指数部分为3，加上127后为130，其二进制为1000_0010。</p> 
<p>因此15.625在计算机中的最终存储格式为0_10000010_11110100000000000000000。</p> 
<p>0.01875浮点形式为:<br> <img src="https://images2.imgbox.com/75/2d/xTQ9WHNl_o.png" alt="在这里插入图片描述"><br> 符号位为0，尾数为1.1，只存储后面的1，指数部分为-3，加上127后为124，其二进制为0111_1100。</p> 
<p>因此0.01875在计算机中的最终存储格式为0_01111100_10000000000000000000000。</p> 
<p><code>问</code>：为什么要加上127？<br> <code>答</code>：这个偏移值是按照下式计算的：<br> <img src="https://images2.imgbox.com/d6/19/9khgCc2l_o.png" alt="在这里插入图片描述"></p> 
<p>如float的指数占用8bit，那么其偏移值就是<br> <img src="https://images2.imgbox.com/13/cd/f5GzXI72_o.png" alt="在这里插入图片描述"></p> 
<p>而double的指数占用11bit，其偏移值为<br> <img src="https://images2.imgbox.com/be/fc/UzsEX6Gl_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>到此，我们可以发现，计算机中存储的尾数并不是真正的尾数；存储的指数也并不是真正的指数。</p> 
</blockquote> 
<h4><a id="5_206"></a>（5）表示精度</h4> 
<p>这里以0.35举例对比一下两种表示法的精度</p> 
<p>用32bit来存储0.35，规定1位为整数部分，其余为小数部分，用定点法表示为0.0101100110011001100110011001100，再转回来就是0.34999999962747097，依然存在误差 0.00000000037252903。</p> 
<p>将0.35首先转化为浮点数形式：1.01100110011001100110011001100*2^（-2），如果是float格式（同样是32bit），则尾数部分只能截取01100110011001100110011，指数部分为-2+127=125，即0111_1101<br> 因此0.35的float格式为0_0111_1101_01100110011001100110011</p> 
<p>再将其转化为十进制为1.01100110011001100110011*2^(-2)，即0.3499999940395355，误差为0.0000000059604645，比用定点法表示的误差略大。</p> 
<p>因此可以得出结论</p> 
<p><font color="red">同样的存储空间，浮点数相比定点数的表示精度更低。</font></p> 
<font color="red"> <p><font color="red">这也就是浮点数能表示更大范围数字所付出的代价。</font></p><font color="red"> <p><font color="red">也就是说使用相同存储空间，定点数精度较高，但范围小；浮点数范围大，但精度较低。凡是皆有代价，不是吗？</font></p><font color="red"> <h4><a id="6_225"></a>（6）表示范围</h4> <p>在float的内存分布中，指数部分占据8位，可以表示0~255，由于进行了偏移，因此可以表示负数，能表示的指数范围为-127 ~ 128。</p> <p>真的吗？</p> <p>float实际只能存入的指数范围为-126 ~ 127。因为指数部分全为1或全为0用于表示其他特殊情况了。</p> <p><img src="https://images2.imgbox.com/13/cd/lqzrD8Zf_o.png" alt="在这里插入图片描述"></p> <p>1）规格化的值<br> 一般情况下，即指数在(0,255)范围内时，转化规则为：</p> 
   <blockquote> 
    <p>真实的尾数=1.存储的尾数<br> 真实的指数=指数部分-偏移值</p> 
   </blockquote> <p>因此规格化的值能表示的范围为：<br> <img src="https://images2.imgbox.com/e3/29/E0wMjUHU_o.png" alt="在这里插入图片描述"></p> <p>其中1.11…11中一共有24个1。</p> <p>2）非规格化的值<br> 当指数位全为0时，转化规则发生了变化：</p> 
   <blockquote> 
    <p>真实的尾数=0.存储的尾数<br> 真实的指数=1-偏移值</p> 
   </blockquote> <p>当尾数的所有二进制位都为 0 时，整个浮点数的值就为 0：<br> 如果符号 sign 为 0，则表示 +0；<br> 如果符号 sign 为 1，则表示 -0。</p> <p>因此非规格化的值能表示的范围为：<br> <img src="https://images2.imgbox.com/f5/0f/vVH9pBLm_o.png" alt="在这里插入图片描述"></p> <p>这里有必要解释一下</p> <p>偏移值为127，因此真实的指数为1-127=-126</p> <p>指数部分是不变的，变的只有尾数部分，真实的尾数范围为0~0.11…11</p> <p>因此非规格化的值能表示的范围为：<br> <img src="https://images2.imgbox.com/21/4c/JjGRVQ8B_o.png" alt="在这里插入图片描述"><br> 非规格化的值能表示的最接近0的值为：</p> <p><img src="https://images2.imgbox.com/35/5f/KKiYsxcb_o.png" alt="在这里插入图片描述"></p> <p>即<img src="https://images2.imgbox.com/a4/3d/alDMOFTW_o.png" alt="在这里插入图片描述"></p> <p>3）无穷大<br> 当指数全为1，且尾数部分为0，则表示无穷大。</p> <p>s=0表示正无穷；s=1表示负无穷</p> <p>4）NaN<br> 当指数全为1，且尾数部分不为0，则表示是一个无效的数字NaN。</p> <p>从上面的讨论可以看出，float的整体表示范围为：<br> 0~+∞</p> <p>其中规格化的值的表示范围为：<br> <img src="https://images2.imgbox.com/cc/b2/S9GBezcp_o.png" alt="在这里插入图片描述"><br> 即：<br> <img src="https://images2.imgbox.com/f3/59/dhb9LT7Q_o.png" alt="在这里插入图片描述"></p> <p>非规格化的值表示范围为：<br> <img src="https://images2.imgbox.com/5b/49/pkJGqIhT_o.png" alt="在这里插入图片描述"><br> 其中1.11…11*2^(-127)略小于 2 ^ (-126)</p> <p>当符号位为1时，float表示负数，此时float表示的数字范围为<br> -∞~ 0</p> <p>同样，double能表示的数字范围为：<br> <img src="https://images2.imgbox.com/9e/92/XuT7WOL4_o.png" alt="在这里插入图片描述"></p> <h4><a id="7_302"></a>（7）优缺点</h4> <p><code>优点：</code></p> <p>——大范围：浮点数表示法可以表示非常大和非常小的数值范围，例如可以表示非常大的天文数字和非常小的微观粒子。<br> ——硬件支持：现代计算机硬件对浮点数运算进行了优化，可以高效地执行浮点数计算。</p> <p><code>缺点：</code><br> ——精度损失：相同存储空间，定点数精度更高<br> ——舍入误差：由于尾数位数的限制，进行浮点数计算时可能会发生舍入误差，特别是在连续的浮点数运算中，舍入误差可能逐渐积累导致结果偏离预期。<br> ——复杂度和成本：浮点数计算的硬件实现相对复杂，同时存储和处理浮点数所需的内存和计算资源也更多，相比于定点数来说更加昂贵。</p> <p><code>同样举上面的例子：</code></p> <p>普朗克长度约等于1.6x10^-35米，用二进制表示为：</p> 
   <blockquote> 
    <p>1.010101000100100001001001001100101101001011100111001*2^(-116)</p> 
   </blockquote> <p>由于float尾数最多只能存23位，因此尾数存储01010100010010000100100，指数为-116，加上127为11，即0000_1011，因此普朗克长度的float存储形式为：</p> 
   <blockquote> 
    <p>0_0000_1011_01010100010010000100100</p> 
   </blockquote> <p>我们只用了32bit就存储了如此小的一个数，相比用定点数存储方式空间消耗量缩小了5倍以上。</p> <p>但细心的读者也发现了，由于位数限制我在存储尾数的时候做了舍入，由此也造成了舍入误差。</p> <p>其实除了部分以5结尾的小数外（如0.5，0.125），大部分小数都无法精确存储，0.35都不能精确存储。</p> <h2><a id="_331"></a>四、答疑</h2> <h3><a id="1_332"></a>1、定点数表示法已经被淘汰了吗？</h3> <p>定点数表示法在某些嵌入式系统、数字信号处理、特定硬件平台和低功耗设备等领域仍有应用，没有完全被浮点数表示法取代。</p> <h3><a id="2_336"></a>2、为什么说整数的存储其实也是用定点数存储格式？</h3> <p>对于short、int、 long这样的整数，我们可以将它们视为没有小数部分的定点数，即小数部分为零，小数点在末尾。这样，整数的存储可以看作是定点数存储格式的特例。</p> <p>这样数字在计算机中的存储格式可以这样划分：</p> <p><font color="red">整数采用定点数格式存储；小数采用浮点数格式存储。</font></p> <p>也正是因为浮点数和小数紧紧绑定在一起，因此可以视浮点数和小数这两个概念是等价的，可以不用区分。</p> <p>但严格上来说，浮点数是小数在计算机中的存储格式。</p> <h3><a id="3FPU_347"></a>3、硬件FPU单元</h3> <p>硬件浮点单元（Floating-Point Unit，FPU）是一种在计算机处理器中集成的硬件组件，专门用于执行浮点数运算。FPU提供了硬件级别的浮点数运算指令集和计算单元，能够高效地执行浮点数的加减乘除、平方根、取整等运算。</p> <p>高级芯片中集成有FPU，如Intel的Core系列和AMD的Ryzen系列、智能手机SOC、GPU芯片、FPGA芯片、高端型号的STM32微控制器（如STM32F4和STM32H7系列）。</p> <p>对于不带硬件FPU的STM32芯片，仍然可以进行浮点数运算，但是需要使用软件库来模拟浮点数运算，这被称为软件浮点数库。软件浮点数库通过软件算法实现浮点数运算，但相比硬件浮点单元，其性能较低。</p> 
   <hr> <h2><a id="_358"></a>参考资料</h2> <p>1、<a href="https://fishc.com.cn/thread-67214-1-1.html" rel="nofollow">https://fishc.com.cn/thread-67214-1-1.html</a><br> 2、<a href="http://c.biancheng.net/view/vip_1764.html" rel="nofollow">http://c.biancheng.net/view/vip_1764.html</a><br> 3、二进制小数转十进制<a href="https://jisuan5.com/binary-to-decimal/" rel="nofollow">https://jisuan5.com/binary-to-decimal/</a></p> </font></font></font>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4a7f792d69c7199d7958d47237e2c44f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在Android Studio 中运行React Native 项目</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ca42b498b87d164c856f420736262fbe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">1.天气预报数据爬取</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>