<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【股票价格走势预测】数据挖掘实验一 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【股票价格走势预测】数据挖掘实验一" />
<meta property="og:description" content="I、项目任务要求 任务描述：由于直接的经济利益，股票价格预测一直吸引着有兴趣投资股票市场和股票交易所的人。它也是金融界的一个重要研究课题。然而股票市场收益预测是一个非常复杂的问题，取决于公司财务状况和国家政策等诸多因素。主要任务要求如下： 可选用爬虫工具或其它方法制作数据集 使用Quandl模块，引用其平台数据建立股票价格趋势预测模型(线性回归、支持向量机回归、决策树)以预测精度来评估预测模型的拟合能力结果分析 参考资料网站：基于线性回归的股票预测（scikit-learn） II、数据集描述（10） 数据集包含两支股票（GOOGL、AAPL）的历史股价数据，其中特征属性包括：
‘Adj. Open’: 股票的开盘价格，经过调整后的价格。‘Adj. High’: 股票的最高价格，经过调整后的价格。‘Adj. Low’: 股票的最低价格，经过调整后的价格。‘Adj. Close’: 股票的收盘价格，经过调整后的价格。‘Adj. Volume’: 股票的交易量，经过调整后的交易量。‘Ex-Dividend’: 不带股息（忽略）补充数据（构造新数列）： ‘HL_PCT’: 最高价和收盘价之间的百分比变化‘PCT_change’: 开盘价和收盘价之间的百分比变化‘label’: 待预测的股票价格，是 ‘Adj. Close’ 列向前移动了一定百分比行数的结果。 数据集中的记录数取决于获取的历史数据的时间段，每一行代表一天的数据。
III、主要算法原理及模型评价方法陈述（15分） 项目中涉及的主要算法是线性回归（Linear Regression）和支持向量机回归（Support Vector Machine Regression，SVM Regression）。
以下是算法原理的简要描述：
线性回归：
线性回归是一种监督学习算法，用于建立输入特征和输出目标之间的线性关系模型。在这个项目中，线性回归用于训练模型来预测股票的价格（&#39;label’列），使用历史股价和交易量等特征作为输入。线性回归模型寻找一条最佳拟合直线，使得预测值与实际值之间的平方误差最小化。 支持向量机回归：
支持向量机回归是一种监督学习算法，用于建立输入特征和输出目标之间的非线性关系模型。本项目中，SVM回归也可以用于预测股票价格。它通过将输入数据映射到高维空间，找到一个最佳的超平面，以最小化预测误差。 决策树
决策树模型是一种用于分类和回归任务的机器学习模型，它模仿了人类在面对决策问题时的思维方式，通过一系列的决策规则来进行预测和分类。决策树模型是一种可解释性强的模型，通常用于以下两种情况：
分类问题：决策树可以用于将数据样本划分到不同的类别中。在分类问题中，每个叶子节点代表一个类别，而每个非叶子节点代表一个特征或属性上的决策规则。数据样本从根节点开始，依次按照规则向下移动，最终到达一个叶子节点，从而确定其所属的类别。回归问题：除了用于分类，决策树也可以用于回归任务，即预测连续数值的输出。在这种情况下，每个叶子节点仍然代表一个数值，但是非叶子节点的决策规则会将数据样本分配到不同的子节点，最终产生一个回归值。 决策树的构建过程通常分为以下几个步骤：
特征选择：选择最佳的特征来作为每个非叶子节点的决策规则。通常使用不同的评估指标（如信息增益、基尼不纯度等）来确定哪个特征最适合用于分割数据。数据分割：根据选定的特征，将数据集划分为不同的子集。每个子集对应于不同的特征取值或范围。递归构建：对每个子集递归地应用上述步骤，构建子树，直到达到停止条件。停止条件可以是达到最大深度、样本数不足或其他预定义条件。叶子节点标记：为每个叶子节点分配一个类别（分类问题）或一个数值（回归问题）。剪枝（可选）：决策树可能会过度拟合训练数据，为了提高泛化能力，可以对树进行剪枝，即删除一些分支。 决策树模型的优点包括易于理解和解释、对缺失值不敏感、能够处理数值和分类特征、适用于大规模数据等。然而，它也容易过拟合训练数据，因此通常需要采用剪枝等技术来改进模型的泛化性能。决策树模型的一种常见变体是随机森林，它通过组合多个决策树来提高性能和稳定性。
模型评价方法：
在项目中，使用了以下模型评价方法来评估模型性能：
训练集和测试集拆分：数据集被分成训练集和测试集，以便评估模型的泛化性能。R-squared（R²）：用于衡量模型对实际数据的拟合程度，值范围在0到1之间，越接近1表示拟合越好。可视化分析：通过绘制股票价格和预测结果的图表来可视化分析模型的表现。 IV、代码实现（45分） import quandl from sklearn import preprocessing import math import numpy as np from sklearn import model_selection, svm from sklearn.linear_model import LinearRegression import matplotlib." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8f2ffac3ff5858435f0c5094123e6c27/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-22T11:12:13+08:00" />
<meta property="article:modified_time" content="2023-09-22T11:12:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【股票价格走势预测】数据挖掘实验一</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="I_0"></a>I、项目任务要求</h2> 
<ul><li>任务描述：由于直接的经济利益，股票价格预测一直吸引着有兴趣投资股票市场和股票交易所的人。它也是金融界的一个重要研究课题。然而股票市场收益预测是一个非常复杂的问题，取决于公司财务状况和国家政策等诸多因素。</li><li>主要任务要求如下： 
  <ul><li><s>可选用爬虫工具或其它方法制作数据集</s> 使用Quandl模块，引用其平台数据</li><li>建立股票价格趋势预测模型(线性回归、支持向量机回归、决策树)</li><li>以预测精度来评估预测模型的拟合能力</li><li>结果分析</li></ul> </li><li>参考资料网站：<a href="https://blog.csdn.net/qq_42433311/article/details/121382417">基于线性回归的股票预测（scikit-learn）</a></li></ul> 
<hr> 
<h2><a id="II10_10"></a>II、数据集描述（10）</h2> 
<p>数据集包含两支股票（GOOGL、AAPL）的历史股价数据，其中特征属性包括：</p> 
<ul><li>‘Adj. Open’: 股票的开盘价格，经过调整后的价格。</li><li>‘Adj. High’: 股票的最高价格，经过调整后的价格。</li><li>‘Adj. Low’: 股票的最低价格，经过调整后的价格。</li><li>‘Adj. Close’: 股票的收盘价格，经过调整后的价格。</li><li>‘Adj. Volume’: 股票的交易量，经过调整后的交易量。</li><li>‘Ex-Dividend’: 不带股息（忽略）</li><li>补充数据（构造新数列）： 
  <ul><li>‘HL_PCT’: 最高价和收盘价之间的百分比变化</li><li>‘PCT_change’: 开盘价和收盘价之间的百分比变化</li><li>‘label’: 待预测的股票价格，是 ‘Adj. Close’ 列向前移动了一定百分比行数的结果。</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/fb/86/KGzwpubz_o.png" alt="在这里插入图片描述" width="700"><br> 数据集中的记录数取决于获取的历史数据的时间段，每一行代表一天的数据。</p> 
<hr> 
<h2><a id="III15_28"></a>III、主要算法原理及模型评价方法陈述（15分）</h2> 
<p>项目中涉及的主要算法是线性回归（Linear Regression）和支持向量机回归（Support Vector Machine Regression，SVM Regression）。<br> 以下是算法原理的简要描述：</p> 
<p><strong>线性回归</strong>：</p> 
<ul><li>线性回归是一种监督学习算法，用于建立输入特征和输出目标之间的线性关系模型。在这个项目中，线性回归用于训练模型来预测股票的价格（'label’列），使用历史股价和交易量等特征作为输入。</li><li>线性回归模型寻找一条最佳拟合直线，使得预测值与实际值之间的平方误差最小化。</li></ul> 
<p><strong>支持向量机回归</strong>：</p> 
<ul><li>支持向量机回归是一种监督学习算法，用于建立输入特征和输出目标之间的非线性关系模型。</li><li>本项目中，SVM回归也可以用于预测股票价格。它通过将输入数据映射到高维空间，找到一个最佳的超平面，以最小化预测误差。</li></ul> 
<p><strong>决策树</strong></p> 
<p>决策树模型是一种用于分类和回归任务的机器学习模型，它模仿了人类在面对决策问题时的思维方式，通过一系列的决策规则来进行预测和分类。决策树模型是一种可解释性强的模型，通常用于以下两种情况：</p> 
<ul><li>分类问题：决策树可以用于将数据样本划分到不同的类别中。在分类问题中，每个叶子节点代表一个类别，而每个非叶子节点代表一个特征或属性上的决策规则。数据样本从根节点开始，依次按照规则向下移动，最终到达一个叶子节点，从而确定其所属的类别。</li><li>回归问题：除了用于分类，决策树也可以用于回归任务，即预测连续数值的输出。在这种情况下，每个叶子节点仍然代表一个数值，但是非叶子节点的决策规则会将数据样本分配到不同的子节点，最终产生一个回归值。</li></ul> 
<p>决策树的构建过程通常分为以下几个步骤：</p> 
<ul><li>特征选择：选择最佳的特征来作为每个非叶子节点的决策规则。通常使用不同的评估指标（如信息增益、基尼不纯度等）来确定哪个特征最适合用于分割数据。</li><li>数据分割：根据选定的特征，将数据集划分为不同的子集。每个子集对应于不同的特征取值或范围。</li><li>递归构建：对每个子集递归地应用上述步骤，构建子树，直到达到停止条件。停止条件可以是达到最大深度、样本数不足或其他预定义条件。</li><li>叶子节点标记：为每个叶子节点分配一个类别（分类问题）或一个数值（回归问题）。</li><li>剪枝（可选）：决策树可能会过度拟合训练数据，为了提高泛化能力，可以对树进行剪枝，即删除一些分支。</li></ul> 
<p>决策树模型的优点包括易于理解和解释、对缺失值不敏感、能够处理数值和分类特征、适用于大规模数据等。然而，它也容易过拟合训练数据，因此通常需要采用剪枝等技术来改进模型的泛化性能。决策树模型的一种常见变体是随机森林，它通过组合多个决策树来提高性能和稳定性。</p> 
<p><strong>模型评价方法</strong>：</p> 
<p>在项目中，使用了以下模型评价方法来评估模型性能：</p> 
<ul><li>训练集和测试集拆分：数据集被分成训练集和测试集，以便评估模型的泛化性能。</li><li>R-squared（R²）：用于衡量模型对实际数据的拟合程度，值范围在0到1之间，越接近1表示拟合越好。</li><li>可视化分析：通过绘制股票价格和预测结果的图表来可视化分析模型的表现。</li></ul> 
<hr> 
<h2><a id="IV45_67"></a>IV、代码实现（45分）</h2> 
<pre><code class="prism language-python"><span class="token keyword">import</span> quandl
<span class="token keyword">from</span> sklearn <span class="token keyword">import</span> preprocessing
<span class="token keyword">import</span> math
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np

<span class="token keyword">from</span> sklearn <span class="token keyword">import</span> model_selection<span class="token punctuation">,</span> svm
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> LinearRegression

<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt
<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> style
<span class="token keyword">import</span> datetime

<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>tree <span class="token keyword">import</span> DecisionTreeRegressor

<span class="token comment"># Todo: 获取股票数据GOOGL、AAPL</span>
<span class="token comment"># df = quandl.get('WIKI/GOOGL')</span>
df <span class="token operator">=</span> quandl<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'WIKI/AAPL'</span><span class="token punctuation">)</span>
<span class="token comment"># print(df)</span>

<span class="token comment"># Todo: 定义预测列变量</span>
<span class="token comment"># todo: 定义预测天数、特征、处理异常值、生成X，y</span>
<span class="token comment"># 定义预测列变量，存放研究对象的标签名</span>
forecast_col <span class="token operator">=</span> <span class="token string">'Adj. Close'</span>

<span class="token comment"># 定义预测天数，这里设置为所有数据量长度的1%</span>
forecast_out <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span>ceil<span class="token punctuation">(</span><span class="token number">0.01</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>df<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----------定义の预测天数----------"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>forecast_out<span class="token punctuation">)</span>

<span class="token comment"># 只用到df中的下面几个字段</span>
df <span class="token operator">=</span> df<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'Adj. Open'</span><span class="token punctuation">,</span> <span class="token string">'Adj. High'</span><span class="token punctuation">,</span> <span class="token string">'Adj. Low'</span><span class="token punctuation">,</span> <span class="token string">'Adj. Close'</span><span class="token punctuation">,</span> <span class="token string">'Adj. Volume'</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

<span class="token comment"># 构造两个新列</span>
df<span class="token punctuation">[</span><span class="token string">'HL_PCT'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>df<span class="token punctuation">[</span><span class="token string">'Adj. High'</span><span class="token punctuation">]</span> <span class="token operator">-</span> df<span class="token punctuation">[</span><span class="token string">'Adj. Close'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> df<span class="token punctuation">[</span><span class="token string">'Adj. Close'</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">100.0</span>
df<span class="token punctuation">[</span><span class="token string">'PCT_change'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>df<span class="token punctuation">[</span><span class="token string">'Adj. Close'</span><span class="token punctuation">]</span> <span class="token operator">-</span> df<span class="token punctuation">[</span><span class="token string">'Adj. Open'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> df<span class="token punctuation">[</span><span class="token string">'Adj. Open'</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">100.0</span>
<span class="token comment"># 真正用到的特征</span>
df <span class="token operator">=</span> df<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'Adj. Close'</span><span class="token punctuation">,</span> <span class="token string">'HL_PCT'</span><span class="token punctuation">,</span> <span class="token string">'PCT_change'</span><span class="token punctuation">,</span> <span class="token string">'Adj. Volume'</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

<span class="token comment"># 处理空值，这里设置为-99999</span>
df<span class="token punctuation">.</span>fillna<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">99999</span><span class="token punctuation">,</span> inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>

<span class="token comment"># label代表预测结果，通过让Adj. Close列的数据往前移动1%行来表示</span>
df<span class="token punctuation">[</span><span class="token string">'label'</span><span class="token punctuation">]</span> <span class="token operator">=</span> df<span class="token punctuation">[</span>forecast_col<span class="token punctuation">]</span><span class="token punctuation">.</span>shift<span class="token punctuation">(</span><span class="token operator">-</span>forecast_out<span class="token punctuation">)</span>
<span class="token comment"># 生成在模型中使用的数据X,y,以及预测时用到的数据X_lately</span>
X <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>df<span class="token punctuation">.</span>drop<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'label'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
X <span class="token operator">=</span> preprocessing<span class="token punctuation">.</span>scale<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
<span class="token comment"># 上面生成的label列时留下的最后1%行的数据，这些行并没有label 数据，用作预测时用到的输入数据</span>
X_lately <span class="token operator">=</span> X<span class="token punctuation">[</span><span class="token operator">-</span>forecast_out<span class="token punctuation">:</span><span class="token punctuation">]</span>

X <span class="token operator">=</span> X<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span>forecast_out<span class="token punctuation">]</span>
<span class="token comment"># 抛弃label列中为空的那些行</span>
df<span class="token punctuation">.</span>dropna<span class="token punctuation">(</span>inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
y <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>df<span class="token punctuation">[</span><span class="token string">'label'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----------预测股票价格的特征变量X----------"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----------预测的目标变量y----------"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----------用于预测的输入数据X_lately----------"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>X_lately<span class="token punctuation">)</span>


<span class="token comment"># Todo: 线性回归分析</span>
<span class="token comment"># 先把X，y数据分成两部份，训练和测试</span>
X_train<span class="token punctuation">,</span> X_test<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> y_test <span class="token operator">=</span> model_selection<span class="token punctuation">.</span>train_test_split<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">)</span>
<span class="token comment"># 生成线性回归对象</span>
clf <span class="token operator">=</span> LinearRegression<span class="token punctuation">(</span>n_jobs<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token comment"># 开始训练</span>
clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>
<span class="token comment"># 进行预测</span>
foreca_set <span class="token operator">=</span> clf<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X_lately<span class="token punctuation">)</span>
<span class="token comment"># 用测试数据评估准确性</span>
accuracy <span class="token operator">=</span> clf<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_test<span class="token punctuation">,</span> y_test<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----------线性回归-预测---------"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>foreca_set<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---------线性回归-准确性---------"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>accuracy<span class="token punctuation">)</span>

<span class="token comment"># Todo: 支持向量机回归分析</span>
<span class="token comment"># 支持向量机回归分析</span>
clf_svm <span class="token operator">=</span> svm<span class="token punctuation">.</span>SVR<span class="token punctuation">(</span>kernel<span class="token operator">=</span><span class="token string">'linear'</span><span class="token punctuation">)</span>
<span class="token comment"># 开始训练支持向量机回归模型</span>
clf_svm<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>
<span class="token comment"># 用测试数据评估支持向量机回归模型准确性</span>
accuracy_svm <span class="token operator">=</span> clf_svm<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_test<span class="token punctuation">,</span> y_test<span class="token punctuation">)</span>
<span class="token comment"># 进行支持向量机回归模型的预测</span>
forecast_set_svm <span class="token operator">=</span> clf_svm<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X_lately<span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----------支持向量机-预测---------"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>forecast_set_svm<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---------支持向量机-准确性---------"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>accuracy_svm<span class="token punctuation">)</span>

<span class="token comment"># 决策树回归模型</span>
clf_tree <span class="token operator">=</span> DecisionTreeRegressor<span class="token punctuation">(</span><span class="token punctuation">)</span>
clf_tree<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>
accuracy_tree <span class="token operator">=</span> clf_tree<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_test<span class="token punctuation">,</span> y_test<span class="token punctuation">)</span>
forecast_set_tree <span class="token operator">=</span> clf_tree<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X_lately<span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----------决策树-预测---------"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>forecast_set_tree<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---------决策树-准确性---------"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>accuracy_tree<span class="token punctuation">)</span>

<span class="token comment"># Todo: 可视化展示</span>
<span class="token comment"># 修改matplotlib样式</span>
style<span class="token punctuation">.</span>use<span class="token punctuation">(</span><span class="token string">'ggplot'</span><span class="token punctuation">)</span>
one_day <span class="token operator">=</span> <span class="token number">86400</span>
<span class="token comment"># 在df中新建Forecast列，用于存放预测结果的数据</span>
df<span class="token punctuation">[</span><span class="token string">'Forecast'</span><span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>nan
<span class="token comment"># 取df最后一行的时间索引</span>
last_date <span class="token operator">=</span> df<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>name
last_unix <span class="token operator">=</span> last_date<span class="token punctuation">.</span>timestamp<span class="token punctuation">(</span><span class="token punctuation">)</span>
next_unix <span class="token operator">=</span> last_unix <span class="token operator">+</span> one_day
<span class="token comment"># 遍历预测结果，用它向df中追加行</span>

<span class="token keyword">for</span> i <span class="token keyword">in</span> foreca_set<span class="token punctuation">:</span>
    next_date <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>fromtimestamp<span class="token punctuation">(</span>next_unix<span class="token punctuation">)</span>
    next_unix <span class="token operator">+=</span> one_day
    <span class="token comment"># [np.nan  for _ in range(len(df.columns)-1)]生成不包含Forecast字段的列表</span>
    <span class="token comment"># 而[i]是只包含Forecast字段的列表</span>
    <span class="token comment"># 拼在一起组成新行，按日期追加到df下面</span>
    df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>next_date<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>np<span class="token punctuation">.</span>nan <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>df<span class="token punctuation">.</span>columns<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span>i<span class="token punctuation">]</span>
<span class="token comment"># 绘图</span>
df<span class="token punctuation">[</span><span class="token string">'Adj. Close'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">)</span>
df<span class="token punctuation">[</span><span class="token string">'Forecast'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Date'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Price'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>x_train：代表训练数据集的输入特征，即训练图像数据。<br> x_test：代表测试数据集的输入特征，即测试图像数据。<br> y_train：代表训练数据集的目标标签，即训练图像对应的类别。<br> y_test：代表测试数据集的目标标签，即测试图像对应的类别。</p> 
<hr> 
<h2><a id="V15_210"></a>V、运行结果截图（15分）</h2> 
<p><img src="https://images2.imgbox.com/6b/5c/MA7NOkmL_o.png" alt="在这里插入图片描述" width="900"></p> 
<p><img src="https://images2.imgbox.com/f4/09/VZs5F8Oe_o.png" alt="在这里插入图片描述" width="900"><br> <img src="https://images2.imgbox.com/fe/30/C8mHlGAZ_o.png" alt="在这里插入图片描述" width="900"><br> <img src="https://images2.imgbox.com/34/85/NeRVGlqG_o.png" alt="在这里插入图片描述" width="900"></p> 
<ul><li>可视化展示（线性回归-苹果）<br> <img src="https://images2.imgbox.com/12/e9/plLlpZMA_o.png" alt="在这里插入图片描述" width="700"></li></ul> 
<hr> 
<h2><a id="VI15_220"></a>VI、结果分析（15分）</h2> 
<p>项目的主要目标是预测股票价格，并通过模型评价方法来评估预测的准确性。<br> 最终的结果分析包括以下几个方面：</p> 
<p><strong>模型准确性</strong>：</p> 
<ul><li>通过使用模型评价方法（例如R-squared）来评估模型在测试集上的准确性。较高的R-squared值表示模型对实际数据的拟合较好。</li></ul> 
<p><strong>可视化分析</strong>：</p> 
<ul><li>通过绘制股票价格和预测结果的图表，可以直观地观察模型的预测效果。如果预测曲线与实际股价曲线趋势相符，说明模型在一定程度上成功预测了股票价格。</li></ul> 
<p><strong>时间序列分析</strong>：</p> 
<ul><li>通过时间序列分析，可以观察模型是否能够捕捉到股票价格的趋势和波动。这有助于确定模型在不同市场情况下的表现如何。</li></ul> 
<p>综合这些分析结果，可以评估模型的预测能力和泛化性能，以确定模型是否适合用于股票价格预测以及在实际交易中的应用潜力。</p> 
<hr> 
<h2><a id="VII_237"></a>VII、小组分工及贡献比</h2>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/24a9a2d5d074313fd46796c518cf283d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Unity报错NotSupportedException: Encoding 936 data could not be found.</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f2211a50f90cb78a6159c0904b40f8df/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue使用样式穿透</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>