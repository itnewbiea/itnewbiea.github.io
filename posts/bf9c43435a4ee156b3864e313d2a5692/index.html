<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#--序列化和反序列化 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#--序列化和反序列化" />
<meta property="og:description" content="序列化是指将对象转换成字节流，从而存储对象或将对象传输到内存、数据库或文件的过程。 它的主要用途是保存对象的状态，以便能够在需要时重新创建对象。 反向过程称为“反序列化”。
序列化的工作原理
下图展示了序列化的整个过程。
对象序列化
若要序列化对象，需要具有要序列化的对象、包含已序列化对象的一个流，以及一个 Formatter。
将 SerializableAttribute 特性应用于某个类型，以指示此类型的实例可以被序列化，具体做法在类之前加[Serializable]。
如果想让类中的某个字段不可序列化，请应用 NonSerializedAttribute 特性，具体做法在字段之前加[NonSerialized]。
C#代码实现：
using System; using System.IO; using System.Runtime.Serialization.Formatters.Binary; namespace NetFrame { public class SerializeUtil { /// &lt;summary&gt; /// 对象序列化 /// &lt;/summary&gt; /// &lt;param name=&#34;value&#34;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static byte[] Encode(object value) { //创建编码解码的内存流对象 MemoryStream ms = new MemoryStream(); //二进制流序列化对象 BinaryFormatter bw = new BinaryFormatter(); //将obj对象序列化成二进制数据 写入到 内存流 bw.Serialize(ms, value); byte[] result = new byte[ms.Length]; //将流数据 拷贝到结果数组 Buffer." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/bf9c43435a4ee156b3864e313d2a5692/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-15T17:37:54+08:00" />
<meta property="article:modified_time" content="2018-05-15T17:37:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#--序列化和反序列化</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>序列化是指将对象转换成字节流，从而存储对象或将对象传输到内存、数据库或文件的过程。 它的主要用途是保存对象的状态，以便能够在需要时重新创建对象。 反向过程称为“反序列化”。</p> 
<p><br><span style="font-size:24px;">序列化的工作原理<br></span><br></p> 
<p>下图展示了序列化的整个过程。</p> 
<p><img src="https://images2.imgbox.com/cc/a1/Yq3rQpL9_o.gif" alt=""><br></p> 
<p><br></p> 
<p><span style="font-size:18px;">对象序列化</span></p> 
<p>若要序列化对象，需要具有要序列化的对象、包含已序列化对象的一个流，以及一个 Formatter。<br></p> 
<p>将 SerializableAttribute 特性应用于某个类型，以指示此类型的实例可以被序列化，具体做法在类之前加[Serializable]。<br></p> 
<p>如果想让类中的某个字段不可序列化，请应用 NonSerializedAttribute 特性，具体做法在字段之前加[NonSerialized]。</p> 
<p></p> 
<p>C#代码实现：</p> 
<pre><code class="language-csharp">using System;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;

namespace NetFrame
{
    public class SerializeUtil
    {
        /// &lt;summary&gt;
        /// 对象序列化
        /// &lt;/summary&gt;
        /// &lt;param name="value"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static byte[] Encode(object value)
        {
            //创建编码解码的内存流对象
            MemoryStream ms = new MemoryStream();
            //二进制流序列化对象
            BinaryFormatter bw = new BinaryFormatter();
            //将obj对象序列化成二进制数据 写入到 内存流
            bw.Serialize(ms, value);
            byte[] result = new byte[ms.Length];
            //将流数据 拷贝到结果数组
            Buffer.BlockCopy(ms.GetBuffer(), 0, result, 0, (int)ms.Length);
            ms.Close();
            return result;
        }

        /// &lt;summary&gt;
        /// 反序列化对象
        /// &lt;/summary&gt;
        /// &lt;param name="value"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static object Decode(byte[] value)
        {
            //创建编码解码的内存流对象 并将需要反序列化的数据写入其中
            MemoryStream ms = new MemoryStream(value);
            //二进制流序列化对象
            BinaryFormatter bw = new BinaryFormatter();
            //将流数据反序列化为obj对象
            object result = bw.Deserialize(ms);
            ms.Close();
            return result;
        }
    }
}
</code></pre> 
<br> 
<p><span style="font-size:18px;">二进制和 XML 序列化</span></p> 
<p><span style="font-size:16px;">二进制序列化使用二进制编码来生成精简的序列化以供使用，如基于存储或套接字的网络流。</span><br></p> 
<p><span style="font-size:16px;">XML 序列化将对象的公共字段和属性或方法的参数和返回值序列化成符合特定 XML 架构定义语言 (XSD) 文档要求的 XML 流。<br></span></p> 
<p><span style="font-size:16px;">首先写一个需要序列化的类：</span></p> 
<pre><code class="language-csharp">[Serializable]
public class ConfigMD5Data
{
    public string fileName;
    public string excelMD5;
    public List&lt;string&gt; binaryMD5List;
    public List&lt;string&gt; classNameList;
    public List&lt;string&gt; typeNameList;
    [NonSerialized]
    public bool md5Changed;
    [NonSerialized]
    public bool classNameChanged;
    [NonSerialized]
    public bool binaryChanged;
}

[Serializable]
public class ConfigMD5
{
    public List&lt;ConfigMD5Data&gt; m_ConfigMD5List = new List&lt;ConfigMD5Data&gt;();
}</code></pre> 
<br> 
<p><span style="font-size:16px;">二进制序列化的C#实现：</span></p> 
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;

namespace StructScript
{
    class BinaryFormatterTest
    {
        private static string m_ConfigMD5Path1;
        private static ConfigMD5 m_ConfigList;

        private static void Main(string[] args)
        {
            m_ConfigMD5Path1 = "config.bytes";
            m_ConfigList = new ConfigMD5();
            for (int i = 0; i &lt; 5; i++)
            {
                ConfigMD5Data data = new ConfigMD5Data();
                data.fileName = "test" + i;
                m_ConfigList.m_ConfigMD5List.Add(data);
            }
            Serialize();
            Deserialize();
            Console.ReadLine();
        }

        private static void Serialize()
        {
            FileStream fs = new FileStream(m_ConfigMD5Path1, FileMode.Create);
            BinaryFormatter formatter = new BinaryFormatter();
            try
            {
                formatter.Serialize(fs, m_ConfigList);
            }
            catch (SerializationException e)
            {
                Console.WriteLine("Failed to serialize. Reason: " + e.Message);
            }
            finally
            {
                fs.Close();
            }
        }

        private static void Deserialize()
        {
            if (File.Exists(m_ConfigMD5Path1))
            {
                FileStream fs = new FileStream(m_ConfigMD5Path1, FileMode.Open);
                try
                {
                    BinaryFormatter formatter = new BinaryFormatter();
                    m_ConfigList = formatter.Deserialize(fs) as ConfigMD5;
                    int count = m_ConfigList.m_ConfigMD5List.Count;
                    for (int i = 0; i &lt; count; i++)
                    {
                        ConfigMD5Data data = m_ConfigList.m_ConfigMD5List[i];
                        Console.WriteLine(data.fileName);
                    }
                }
                catch (SerializationException e)
                {
                    Console.WriteLine("Failed to deserialize. Reason: " + e.Message);
                }
                finally
                {
                    fs.Close();
                }
            }
        }

        [Serializable]
        public class ConfigMD5Data
        {
            public string fileName;
            public string excelMD5;
            public List&lt;string&gt; binaryMD5List;
            public List&lt;string&gt; classNameList;
            public List&lt;string&gt; typeNameList;
            [NonSerialized]
            public bool md5Changed;
            [NonSerialized]
            public bool classNameChanged;
            [NonSerialized]
            public bool binaryChanged;
        }

        [Serializable]
        public class ConfigMD5
        {
            public List&lt;ConfigMD5Data&gt; m_ConfigMD5List = new List&lt;ConfigMD5Data&gt;();
        }
    }
}
</code></pre> 
<br> 
<p>输出结果：</p> 
<p><img src="https://images2.imgbox.com/dc/a7/IvrIoZEf_o.png" alt=""><br></p> 
<p>Xml序列化C#实现：</p> 
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml.Serialization;

namespace StructScript
{
    public class XmlFormatterTest
    {
        private static string m_ConfigMD5Path;
        private static ConfigMD5 m_ConfigList;

        private static void Main(string[] args)
        {
            m_ConfigMD5Path = "config.xml";
            m_ConfigList = new ConfigMD5();
            for (int i = 0; i &lt; 5; i++)
            {
                ConfigMD5Data data = new ConfigMD5Data();
                data.fileName = "test" + i;
                m_ConfigList.m_ConfigMD5List.Add(data);
            }
            SaveXml();
            LoadXml();
            Console.ReadLine();
        }

        public static bool SaveXml()
        {
            DeleteFile(m_ConfigMD5Path);
            using (StreamWriter sw = new StreamWriter(m_ConfigMD5Path, false, Encoding.UTF8))
            {
                XmlSerializer serializer = new XmlSerializer(typeof(ConfigMD5));
                try
                {
                    serializer.Serialize(sw, m_ConfigList);
                }
                catch (Exception e)
                {
                    Console.WriteLine("Load ConfigMD5 fail, error: " + e.Message);
                }
            }
            return true;
        }

        public static bool DeleteFile(string filePath)
        {
            if (File.Exists(filePath))
            {
                File.Delete(filePath);
                return true;
            }
            return false;
        }

        public static void LoadXml()
        {
            if (File.Exists(m_ConfigMD5Path))
            {
                try
                {
                    using (StreamReader sr = new StreamReader(m_ConfigMD5Path, Encoding.UTF8))
                    {
                        XmlSerializer serializer = new XmlSerializer(typeof(ConfigMD5));
                        m_ConfigList = serializer.Deserialize(sr) as ConfigMD5;
                        int count = m_ConfigList.m_ConfigMD5List.Count;
                        for (int i = 0; i &lt; count; i++)
                        {
                            ConfigMD5Data data = m_ConfigList.m_ConfigMD5List[i];
                            Console.WriteLine(data.fileName);
                        }
                    }
                }
                catch (Exception e)
                {
                    Console.WriteLine("Load ConfigMD5 fail, error: " + e.Message);
                }
            }
        }

        [Serializable]
        public class ConfigMD5Data
        {
            public string fileName;
            public string excelMD5;
            public List&lt;string&gt; binaryMD5List;
            public List&lt;string&gt; classNameList;
            public List&lt;string&gt; typeNameList;
            [NonSerialized]
            public bool md5Changed;
            [NonSerialized]
            public bool classNameChanged;
            [NonSerialized]
            public bool binaryChanged;
        }

        [Serializable]
        public class ConfigMD5
        {
            public List&lt;ConfigMD5Data&gt; m_ConfigMD5List = new List&lt;ConfigMD5Data&gt;();
        }
    }
}
</code></pre> 
<p>输出结果：</p> 
<p><img src="https://images2.imgbox.com/44/2f/B8vzOGhI_o.png" style="margin-bottom:0px;" alt=""><br></p> 
<div> 
 <br> 
</div> 
<p>总结：</p> 
<p>在二进制序列化中，所有成员（包括只读成员）都会被序列化，且性能也会有所提升。 XML 序列化可提高代码可读性，以及对象共享和使用的灵活性，从而实现互操作性。<br></p> 
<p><span style="font-size:18px;"><br></span></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d84badf4d04f9ab74a55f49e3fecad9c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">response设置响应头，解决跨域请求问题，No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/897c1ae4857c5a99459975b6f798c5bf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在服务器端如何获取tomcat中部署的所有项目的项目名称?</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>