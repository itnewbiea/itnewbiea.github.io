<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Knative 核心概念介绍：Build、Serving 和 Eventing 三大核心组件 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Knative 核心概念介绍：Build、Serving 和 Eventing 三大核心组件" />
<meta property="og:description" content="作者 | 阿里云智能事业群高级开发工程师 元毅
划重点
初识 Knative: 跨平台的 Serverless 编排框架 让我们对于 Knative 有了初步了解，Knative 主要由 Build、Serving 和 Eventing 三大核心组件构成。Knative 正是依靠这三个核心组件，驱动着 Knative 这艘 Serverless 巨轮前行，本文就来分别介绍一下这三个核心组件。
Build
Knative Build 是基于现有的 Kubernetes 能力之上，提供的一套标准化、可移植、可复用的容器镜像构建方式。通过在 Kubernetes 上运行复杂的构建任务，Knative Build 使你不必再单独开发和重复这些镜像构建过程， 从而通过系统化、工程化的方式，减少了镜像构建时间及成本。
Build 通过 Kubernetes 自定义资源定义(CRD)实现。 通过 Build 你可以自定义一个从运行到结束的构建流程。例如，可以使用 Knative Build 来获取、构建和打包代码。Build 具备以下功能：
支持 Source 源挂载，目前支持的 Source 源包括：
* git 代码仓库
* 任意容器镜像
支持通过 BuildTemplate 创建可重复执行构建的模板
支持 K8s ServiceAccount 身份验证
典型的 Build 示意图：
虽然目前 Knative Build 并不提供完整的独立 CI/CD 解决方案，但它却提供了一个底层的构建模块，用户可单独使用该构建模块在大型系统中实现集成和利用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a6565506cc3acdae4d630677d7b6c3eb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-05-29T17:39:31+08:00" />
<meta property="article:modified_time" content="2019-05-29T17:39:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Knative 核心概念介绍：Build、Serving 和 Eventing 三大核心组件</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="preview-main"> 
 <p></p> 
 <img src="https://images2.imgbox.com/8d/80/NccpeRKH_o.jpg" alt="bb"> 
 <p style="font-size:11px;color:rgb(51,51,51);line-height:15px;">作者 | 阿里云智能事业群高级开发工程师 元毅</p> 
 <p style="color:rgb(12,34,62);line-height:20px;"><strong><span style="letter-spacing:.5px;font-size:12px;color:rgb(2,30,170);">划重点</span></strong></p> 
 <p style="color:rgb(12,34,62);line-height:20px;"><span style="color:rgb(62,62,62);letter-spacing:.5px;font-size:12px;"><br></span></p> 
 <p style="color:rgb(12,34,62);line-height:20px;"><span style="color:rgb(62,62,62);letter-spacing:.5px;font-size:12px;">初识 Knative:  跨平台的 Serverless 编排框架 让我们对于 Knative 有了初步了解，Knative 主要由 Build、Serving 和 Eventing 三大核心组件构成。Knative 正是依靠这三个核心组件，驱动着 Knative 这艘 Serverless 巨轮前行，本文就来分别介绍一下这三个核心组件。</span></p> 
 <p><br></p> 
 <p style="clear:both;min-height:1em;color:rgb(51,51,51);font-size:17px;text-align:center;"><img src="https://images2.imgbox.com/24/f2/1tojLp2E_o.jpg" alt="bb"><br></p> 
 <p style="clear:both;min-height:1em;color:rgb(51,51,51);font-size:17px;text-align:center;"><strong><span style="color:rgb(2,30,170);">Build</span></strong></p> 
 <p></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">Knative Build 是基于现有的 Kubernetes 能力之上，提供的一套标准化、可移植、可复用的容器镜像构建方式。通过在 Kubernetes 上运行复杂的构建任务，Knative Build 使你不必再单独开发和重复这些镜像构建过程， 从而通过系统化、工程化的方式，减少了镜像构建时间及成本。</p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">Build 通过 Kubernetes 自定义资源定义(CRD)实现。 通过 Build 你可以自定义一个从运行到结束的构建流程。例如，可以使用 Knative Build 来获取、构建和打包代码。Build 具备以下功能：</p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <ul class="list-paddingleft-2" style="list-style-type:disc;"><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">支持 Source 源挂载，目前支持的 Source 源包括：</p><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><span style="text-indent:2em;font-family:'-apple-system-font', BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei UI', 'Microsoft YaHei', Arial, sans-serif;">* git 代码仓库</span></p><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><span style="text-indent:2em;font-family:'-apple-system-font', BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei UI', 'Microsoft YaHei', Arial, sans-serif;"></span><span style="text-indent:2em;font-family:'-apple-system-font', BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei UI', 'Microsoft YaHei', Arial, sans-serif;">* 任意容器镜像</span></p></li><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">支持通过 BuildTemplate 创建可重复执行构建的模板</p></li><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">支持 K8s ServiceAccount 身份验证</p></li></ul> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">典型的 Build 示意图：<br></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><img src="https://images2.imgbox.com/f2/ca/bqTXEnfu_o.jpg" alt="bb"></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">虽然目前 Knative Build 并不提供完整的独立 CI/CD 解决方案，但它却提供了一个底层的构建模块，用户可单独使用该构建模块在大型系统中实现集成和利用。</p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <p></p> 
 <p style="clear:both;min-height:1em;color:rgb(51,51,51);font-size:17px;text-align:center;"><img src="https://images2.imgbox.com/b7/4d/JtN3QwEb_o.jpg" alt="bb"><br></p> 
 <p style="clear:both;min-height:1em;color:rgb(51,51,51);font-size:17px;text-align:center;"><strong><span style="color:rgb(2,30,170);">Serving</span></strong></p> 
 <p></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">Knative 作为 Severless 框架最终是用来提供服务的， 那么 Knative Serving 应运而生。<br><br>Knative Serving 构建于 Kubernetes 和 Istio 之上，为  Serverless 应用提供部署和服务支持。其特性如下：</p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <ul class="list-paddingleft-2" style="list-style-type:disc;"><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">快速部署 Serverless 容器</p></li><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">支持自动扩缩容和缩至为 0 实例</p></li><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">基于 Istio 组件，提供路由和网络编程</p></li><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">支持部署快照</p></li></ul> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">Knative Serving 中定义了以下 CRD 资源：</p> 
 <ul class="list-paddingleft-2" style="list-style-type:disc;"><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">Service: 自动管理工作负载整个生命周期。负责创建 Route、Configuration 以及 Revision 资源。通过 Service 可以指定路由流量使用最新的 Revision 还是固定的 Revision</p></li><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">Route：负责映射网络端点到一个或多个 Revision。可以通过多种方式管理流量，包括灰度流量和重命名路由</p></li><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">Configuration: 负责保持 Deployment 的期望状态，提供了代码和配置之间清晰的分离，并遵循应用开发的 12 要素。修改一次 Configuration 产生一个 Revision</p></li><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">Revision：Revision 资源是对工作负载进行的每个修改的代码和配置的时间点快照。Revision 是不可变对象，可以长期保留</p></li></ul> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">资源关系图：<br><br></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><img src="https://images2.imgbox.com/dc/bf/yweXiFPA_o.jpg" alt="bb"></p> 
 <p></p> 
 <p style="clear:both;min-height:1em;color:rgb(51,51,51);font-size:17px;text-align:center;"><br></p> 
 <p style="clear:both;min-height:1em;color:rgb(51,51,51);font-size:17px;text-align:center;"><img src="https://images2.imgbox.com/4c/bc/0OZ2XU9i_o.jpg" alt="bb"><br></p> 
 <p style="clear:both;min-height:1em;color:rgb(51,51,51);font-size:17px;text-align:center;"><strong><span style="color:rgb(2,30,170);">Eventing</span></strong></p> 
 <p></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">Knative Eventing 旨在满足云原生开发中通用需求, 以提供可组合的方式绑定事件源和事件消费者。其设计目标：</p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <ul class="list-paddingleft-2" style="list-style-type:disc;"><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">Knative Eventing 提供的服务是松散耦合，可独立开发和部署。服务可跨平台使用（如 Kubernetes, VMs, SaaS 或者 FaaS）</p></li><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">事件的生产者和事件的消费者是相互独立的。任何事件的生产者（事件源）可以先于事件的消费者监听之前产生事件，同样事件的消费者可以先于事件产生之前监听事件</p></li><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">支持第三方的服务对接该 Eventing 系统</p></li><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">确保跨服务的互操作性</p></li></ul> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">事件处理示意图：<br><br></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><img src="https://images2.imgbox.com/57/b7/pw1VKhdS_o.jpg" alt="bb"></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">如上图所示，Eventing 主要由事件源（Event Source）、事件处理（Flow）以及事件消费者（Event Consumer）三部分构成。</p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <p></p> 
 <strong style="color:rgb(51,51,51);font-size:17px;letter-spacing:1px;text-align:justify;"><span style="font-size:15px;color:rgb(2,30,170);">事件源（Event Source）</span></strong> 
 <strong style="color:rgb(51,51,51);font-size:17px;letter-spacing:1px;text-align:justify;"><span style="font-size:15px;color:rgb(2,30,170);"></span></strong> 
 <p></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">当前支持以下几种类型的事件源：</p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <ul class="list-paddingleft-2" style="list-style-type:disc;"><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">ApiserverSource：每次创建或更新 Kubernetes 资源时，ApiserverSource 都会触发一个新事件</p></li><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">GitHubSource：GitHub 操作时，GitHubSource 会触发一个新事件</p></li><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">GcpPubSubSource： GCP 云平台 Pub/Sub 服务会触发一个新事件</p></li><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">AwsSqsSource：Aws 云平台 SQS 服务会触发一个新事件</p></li><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">ContainerSource: ContainerSource 将实例化一个容器，通过该容器产生事件</p></li><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">CronJobSource: 通过 CronJob 产生事件</p></li><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">KafkaSource: 接收 Kafka 事件并触发一个新事件</p></li><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">CamelSource: 接收 Camel 相关组件事件并触发一个新事件</p></li></ul> 
 <p></p> 
 <strong style="color:rgb(51,51,51);font-size:17px;letter-spacing:1px;text-align:justify;"><span style="font-size:15px;color:rgb(2,30,170);"><br></span></strong> 
 <strong style="color:rgb(51,51,51);font-size:17px;letter-spacing:1px;text-align:justify;"><span style="font-size:15px;color:rgb(2,30,170);">事件接收/转发（Flow）</span></strong> 
 <strong style="color:rgb(51,51,51);font-size:17px;letter-spacing:1px;text-align:justify;"><span style="font-size:15px;color:rgb(2,30,170);"></span></strong> 
 <p></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">当前 Knative 支持如下事件接收处理：</p> 
 <ul class="list-paddingleft-2" style="list-style-type:disc;"><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">直接事件接收</p><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">通过事件源直接转发到单一事件消费者。支持直接调用 Knative Service 或者 Kubernetes Service 进行消费处理。这样的场景下，如果调用的服务不可用，事件源负责重试机制处理</p></li><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">通过事件通道(Channel)以及事件订阅(Subscriptions)转发事件处理</p><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">这样的情况下，可以通过 Channel 保证事件不丢失并进行缓冲处理，通过 Subscriptions 订阅事件以满足多个消费端处理</p></li><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">通过 brokers 和 triggers 支持事件消费及过滤机制</p></li></ul> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">从 v0.5 开始，Knative Eventing 定义 Broker 和 Trigger 对象，实现了对事件进行过滤（亦如通过 ingress 和 ingress controller 对网络流量的过滤一样）通过定义 Broker 创建 Channel，通过 Trigger 创建 Channel 的订阅（subscription），并产生事件过滤规则。</p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <p></p> 
 <strong style="color:rgb(51,51,51);font-size:17px;letter-spacing:1px;text-align:justify;"><span style="font-size:15px;color:rgb(2,30,170);">事件消费者（Event Consumer）</span></strong> 
 <strong style="color:rgb(51,51,51);font-size:17px;letter-spacing:1px;text-align:justify;"><span style="font-size:15px;color:rgb(2,30,170);"></span></strong> 
 <p></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">为了满足将事件发送到不同类型的服务进行消费， Knative Eventing 通过多个 k8s 资源定义了两个通用的接口：</p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <ul class="list-paddingleft-2" style="list-style-type:disc;"><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">Addressable 接口提供可用于事件接收和发送的 HTTP 请求地址，并通过status.address.hostname字段定义。作为一种特殊情况，Kubernetes Service 对象也可以实现 Addressable 接口</p></li><li><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">Callable 接口接收通过 HTTP 传递的事件并转换事件。可以按照处理来自外部事件源事件的相同方式，对这些返回的事件做进一步处理</p><p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p></li></ul> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">当前 Knative 支持通过 Knative Service 或者 Kubernetes Service 进行消费事件。</p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><span style="font-family:'-apple-system-font', BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei UI', 'Microsoft YaHei', Arial, sans-serif;"><br></span></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><span style="font-family:'-apple-system-font', BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei UI', 'Microsoft YaHei', Arial, sans-serif;">另外针对事件消费者，如何事先知道哪些事件可以被消费？ Knative Eventing 在最新的 0.6 版本中提供 Registry 事件注册机制, 这样事件消费者就可以事先通过 Registry 获得哪些 Broker 中的事件类型可以被消费。</span></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <p></p> 
 <p style="clear:both;min-height:1em;color:rgb(51,51,51);font-size:17px;text-align:center;"><img src="https://images2.imgbox.com/b7/d9/DcscfIrM_o.jpg" alt="bb"><br></p> 
 <p style="clear:both;min-height:1em;color:rgb(51,51,51);font-size:17px;text-align:center;"><strong><span style="color:rgb(2,30,170);">总结</span></strong></p> 
 <p></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <p style="text-align:justify;color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">Knative 使用 Build 提供云原生“从源代码到容器”的镜像构建能力，通过 Serving 部署容器并提供通用的服务模型，同时以 Eventing 提供事件全局订阅、传递和管理能力，实现事件驱动。这就是 Knative 呈现给我们的标准 Serverless 编排框架。</p> 
 <p></p> 
 <strong style="letter-spacing:1px;"><span style="font-size:15px;color:rgb(2,30,170);"><br></span></strong> 
 <p style="text-align:center;"><img title="动态黑色音符" src="https://images2.imgbox.com/e5/a1/gmoMM942_o.jpg" alt="bb"></p> 
 <p style="text-align:center;"><span style="color:rgb(2,30,170);font-size:17px;"><strong>Knative 系列文章</strong></span></p> 
 <p style="color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;"><br></p> 
 <p style="color:rgb(62,62,62);letter-spacing:.5px;font-size:15px;line-height:1.75;">阿里巴巴云原生公众号将推出一系列的文章由浅入深的来介绍 Knative 的使用以及剖析其内部实现。<br><br></p> 
 <p style="text-align:left;"><span style="font-size:15px;"><strong><span style="color:rgb(2,30,170);"><strong style="font-size:15px;text-align:left;"><span style="color:rgb(2,30,170);">Knative 系列文章目录</span></strong></span></strong></span></p> 
 <p><br></p> 
 <ul class="list-paddingleft-2" style="margin-left:3px;"><li><p style="line-height:1.75em;"><a href="http://mp.weixin.qq.com/s?__biz=MzUzNzYxNjAzMg==&amp;mid=2247485184&amp;idx=1&amp;sn=85b04ae8fdb8fb9b647090db474387dd&amp;chksm=fae50ccfcd9285d9578015baec3f4c182e397bdc671a301d080a23a147f7b752fda651f26993&amp;scene=21#wechat_redirect" rel="nofollow"><span style="font-size:15px;letter-spacing:.5px;">初识 Knative</span></a></p></li><li><p style="line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;">Knative 入门</span></p><p style="line-height:1.75em;"><span style="letter-spacing:.5px;font-size:12px;">* Knative 核心概念介绍：Build、Serving 和 Eventing 三大核心组件</span></p></li><li><p style="line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;font-family:'-apple-system-font', BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei UI', 'Microsoft YaHei', Arial, sans-serif;">Knative 基本功能深入剖析</span></p></li><li><p style="line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;">Knative 高级功能深入剖析</span></p></li><li><p style="line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;">Knative 边界、理念<br></span></p></li><li><p style="line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;">Knative 最佳实践<br></span></p></li><li><p style="line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;">Knative 案例</span></p></li><li><p style="line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;">Knative 源码解读</span></p></li><li><p style="line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;">Knative 社区</span></p></li></ul> 
 <p></p> 
 <p style="clear:both;"></p> 
 <p class="translate"> 来自 “ ITPUB博客 ” ，链接：http://blog.itpub.net/31555606/viewspace-2646111/，如需转载，请注明出处，否则将追究法律责任。 </p> 
</div> 
<p>转载于:http://blog.itpub.net/31555606/viewspace-2646111/</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bbd7a33a90a3f7394803f17e1df6e894/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决 aka com.chaozh.iReader:style/Theme.AppCompat.Light.NoActionBar) not found.</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/88acdd260aac4ffc60e53922650051b3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">UmiJS CDN 部署之 publicPath</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>