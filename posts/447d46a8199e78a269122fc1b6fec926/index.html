<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>otsu阈值分割算法原理_大津法---OTSU算法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="otsu阈值分割算法原理_大津法---OTSU算法" />
<meta property="og:description" content="简介：
大津法(OTSU)是一种确定图像二值化分割阈值的算法，由日本学者大津于1979年提出。从大津法的原理上来讲，该方法又称作最大类间方差法，因为按照大津法求得的阈值进行图像二值化分割后，前景与背景图像的类间方差最大(何为类间方差？原理中有介绍)。
OTSU算法
OTSU算法也称最大类间差法，有时也称之为大津算法，由大津于1979年提出，被认为是图像分割中阈值选取的最佳算法，计算简单，不受图像亮度和对比度的影响，因此在数字图像处理上得到了广泛的应用。它是按图像的灰度特性,将图像分成背景和前景两部分。因方差是灰度分布均匀性的一种度量,背景和前景之间的类间方差越大,说明构成图像的两部分的差别越大,当部分前景错分为背景或部分背景错分为前景都会导致两部分差别变小。因此,使类间方差最大的分割意味着错分概率最小。
原理：
对于图像I(x,y)，前景(即目标)和背景的分割阈值记作T，属于前景的像素点数占整幅图像的比例记为ω0，其平均灰度μ0；背景像素点数占整幅图像的比例为ω1，其平均灰度为μ1。图像的总平均灰度记为μ，类间方差记为g。
假设图像的背景较暗，并且图像的大小为M×N，图像中像素的灰度值小于阈值T的像素个数记作N0，像素灰度大于阈值T的像素个数记作N1，则有：
ω0=N0/ M×N (1)
ω1=N1/ M×N (2)
N0&#43;N1=M×N (3)
ω0&#43;ω1=1　(4)
μ=ω0*μ0&#43;ω1*μ1 (5)
g=ω0(μ0-μ)^2&#43;ω1(μ1-μ)^2 (6)
将式(5)代入式(6),得到等价公式:
g=ω0ω1(μ0-μ1)^2 (7)　这就是类间方差
采用遍历的方法得到使类间方差g最大的阈值T,即为所求。
matlab函数：
matlab中函数graythresh既是使用大津法求得分割阈值Ｔ。用法如下：
T = graythresh(img);
BW = im2bw(img,T);
大津法的形象理解：
对于直方图有两个峰值的图像，大津法求得的Ｔ近似等于两个峰值之间的低谷。
imhist(img);
T = graythresh(img);
如下图为图像的直方图，使大津法求得的Ｔ＝0.5294，转换在［0,255］之间为134.9970，只好是两个峰值之间低谷的位置。
OpenCV的二值化操作中，有一种“大津阈值处理”的方法，使用函数cvThreshold(image,image2,0,255,CV_THRESH_OTSU) 实现，该函数就会使用大律法OTSU得到的全局自适应阈值来进行二值化图片，而参数中的threshold不再起作用。
以下是一段在OpenCV中实现的C语言程序，即一个使用OTSU算法提取图像阈值的函数，输入参数为一个图像指针，返回分割该图像的最佳阈值。
其中的变量说明：当分割的阈值为t时
w0为背景像素点占整幅图像的比例
u0为w0平均灰度
w1为前景像素点占整幅图像的比例
u1为w1平均灰度
u为整幅图像的平均灰度
公式:g = w0*pow((u-u0),2) &#43; w1*pow((u-u1),2)
int MyAutoFocusDll::otsuThreshold(IplImage *frame)
{const int GrayScale = 256;int width = frame-&gt;width;int height = frame-&gt;height;intpixelCount[GrayScale];floatpixelPro[GrayScale];int i, j, pixelSum = width * height, threshold = 0;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/447d46a8199e78a269122fc1b6fec926/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-23T07:00:57+08:00" />
<meta property="article:modified_time" content="2020-12-23T07:00:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">otsu阈值分割算法原理_大津法---OTSU算法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>简介：</p> 
 <p>大津法(OTSU)是一种确定图像二值化分割阈值的算法，由日本学者大津于1979年提出。从大津法的原理上来讲，该方法又称作最大类间方差法，因为按照大津法求得的阈值进行图像二值化分割后，前景与背景图像的类间方差最大(何为类间方差？原理中有介绍)。</p> 
 <p>OTSU算法</p> 
 <p>OTSU算法也称最大类间差法，有时也称之为大津算法，由大津于1979年提出，被认为是图像分割中阈值选取的最佳算法，计算简单，不受图像亮度和对比度的影响，因此在数字图像处理上得到了广泛的应用。它是按图像的灰度特性,将图像分成背景和前景两部分。因方差是灰度分布均匀性的一种度量,背景和前景之间的类间方差越大,说明构成图像的两部分的差别越大,当部分前景错分为背景或部分背景错分为前景都会导致两部分差别变小。因此,使类间方差最大的分割意味着错分概率最小。</p> 
 <p>原理：</p> 
 <p>对于图像I(x,y)，前景(即目标)和背景的分割阈值记作T，属于前景的像素点数占整幅图像的比例记为ω0，其平均灰度μ0；背景像素点数占整幅图像的比例为ω1，其平均灰度为μ1。图像的总平均灰度记为μ，类间方差记为g。</p> 
 <p>假设图像的背景较暗，并且图像的大小为M×N，图像中像素的灰度值小于阈值T的像素个数记作N0，像素灰度大于阈值T的像素个数记作N1，则有：</p> 
 <p>ω0=N0/ M×N (1)</p> 
 <p>ω1=N1/ M×N (2)</p> 
 <p>N0+N1=M×N (3)</p> 
 <p>ω0+ω1=1　　　 (4)</p> 
 <p>μ=ω0*μ0+ω1*μ1 (5)</p> 
 <p>g=ω0(μ0-μ)^2+ω1(μ1-μ)^2 (6)</p> 
 <p>将式(5)代入式(6),得到等价公式:</p> 
 <p>g=ω0ω1(μ0-μ1)^2 　　 (7)　这就是类间方差</p> 
 <p>采用遍历的方法得到使类间方差g最大的阈值T,即为所求。</p> 
 <p>matlab函数：</p> 
 <p>matlab中函数graythresh既是使用大津法求得分割阈值Ｔ。用法如下：</p> 
 <p>T = graythresh(img);</p> 
 <p>BW = im2bw(img,T);</p> 
 <p>大津法的形象理解：</p> 
 <p>对于直方图有两个峰值的图像，大津法求得的Ｔ近似等于两个峰值之间的低谷。</p> 
 <p>imhist(img);</p> 
 <p>T = graythresh(img);</p> 
 <p>如下图为图像的直方图，使大津法求得的Ｔ＝0.5294，转换在［0,255］之间为134.9970，只好是两个峰值之间低谷的位置。</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>OpenCV的二值化操作中，有一种“大津阈值处理”的方法，使用函数cvThreshold(image,image2,0,255,CV_THRESH_OTSU) 实现，该函数就会使用大律法OTSU得到的全局自适应阈值来进行二值化图片，而参数中的threshold不再起作用。</p> 
 <p>以下是一段在OpenCV中实现的C语言程序，即一个使用OTSU算法提取图像阈值的函数，输入参数为一个图像指针，返回分割该图像的最佳阈值。</p> 
 <p>其中的变量说明：当分割的阈值为t时</p> 
 <p>w0为背景像素点占整幅图像的比例</p> 
 <p>u0为w0平均灰度</p> 
 <p>w1为前景像素点占整幅图像的比例</p> 
 <p>u1为w1平均灰度</p> 
 <p>u为整幅图像的平均灰度</p> 
 <p>公式:g = w0*pow((u-u0),2) + w1*pow((u-u1),2)</p> 
 <p>int MyAutoFocusDll::otsuThreshold(IplImage *frame)</p> 
 <p>{const int GrayScale = 256;int width = frame-&gt;width;int height = frame-&gt;height;intpixelCount[GrayScale];floatpixelPro[GrayScale];int i, j, pixelSum = width * height, threshold = 0;</p> 
 <p>uchar* data = (uchar*)frame-&gt;imageData; //指向像素数据的指针</p> 
 <p>for (i = 0; i &lt; GrayScale; i++)</p> 
 <p>{<!-- --></p> 
 <p>pixelCount[i]= 0;</p> 
 <p>pixelPro[i]= 0;</p> 
 <p>}//统计灰度级中每个像素在整幅图像中的个数</p> 
 <p>for (i = 0; i &lt; height; i++)</p> 
 <p>{for (j = 0; j &lt; width; j++)</p> 
 <p>{<!-- --></p> 
 <p>pixelCount[(int)data[i * width + j]]++; //将像素值作为计数数组的下标</p> 
 <p>}</p> 
 <p>}//计算每个像素在整幅图像中的比例</p> 
 <p>float maxPro = 0.0;int kk = 0;for (i = 0; i &lt; GrayScale; i++)</p> 
 <p>{<!-- --></p> 
 <p>pixelPro[i]= (float)pixelCount[i] /pixelSum;if (pixelPro[i] &gt;maxPro)</p> 
 <p>{<!-- --></p> 
 <p>maxPro=pixelPro[i];</p> 
 <p>kk=i;</p> 
 <p>}</p> 
 <p>}//遍历灰度级[0,255]</p> 
 <p>float w0, w1, u0tmp, u1tmp, u0, u1, u, deltaTmp, deltaMax = 0;for (i = 0; i &lt; GrayScale; i++) //i作为阈值</p> 
 <p>{<!-- --></p> 
 <p>w0= w1 = u0tmp = u1tmp = u0 = u1 = u = deltaTmp = 0;for (j = 0; j &lt; GrayScale; j++)</p> 
 <p>{if (j &lt;= i) //背景部分</p> 
 <p>{<!-- --></p> 
 <p>w0+=pixelPro[j];</p> 
 <p>u0tmp+= j *pixelPro[j];</p> 
 <p>}else //前景部分</p> 
 <p>{<!-- --></p> 
 <p>w1+=pixelPro[j];</p> 
 <p>u1tmp+= j *pixelPro[j];</p> 
 <p>}</p> 
 <p>}</p> 
 <p>u0= u0tmp /w0;</p> 
 <p>u1= u1tmp /w1;</p> 
 <p>u= u0tmp +u1tmp;</p> 
 <p>deltaTmp= w0 * pow((u0 - u), 2) + w1 * pow((u1 - u), 2);if (deltaTmp &gt;deltaMax)</p> 
 <p>{<!-- --></p> 
 <p>deltaMax=deltaTmp;</p> 
 <p>threshold=i;</p> 
 <p>}</p> 
 <p>}returnthreshold;</p> 
 <p>}</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/42fb6ef56e7c9c7776b373945eea83cc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue如何输出一个值_怎么在控制台打印出来data里想要的数据？  Vue</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/daa7c4c7b797f6cc93410a98c28a497f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">12 个 GitHub 上超火的 JavaScript 奇技淫巧项目，找到写 JavaScript 的灵感！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>