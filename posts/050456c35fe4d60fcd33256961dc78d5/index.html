<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>cgo的几种使用方式 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="cgo的几种使用方式" />
<meta property="og:description" content="最简单的CGO程序 //cgo.go package main import &#34;C&#34; func main(){ println(&#34;hello cgo&#34;) } 上述代码是一个完整的CGO程序，通过import &#34;C&#34;语句启动了CGO特性，go build命令会在编译和链接阶段启动gcc编译器
源码方式调用C函数 cgoTest.h
void SayHello(const char* s); cgoTest.c
#include &lt;stdio.h&gt; #include &#34;cgoTest.h&#34; void SayHello(const char* s) { puts(s); } main.go
package main /* #include &lt;cgoTest.h&gt; */ import &#34;C&#34; func main(){ C.SayHello(C.CString(&#34;Hello world\n&#34;)) } 上述.c文件也可以是.cpp文件，前提是编译时需要g&#43;&#43;
cgoTest.cpp
#include &lt;iostream&gt; extern &#34;C&#34; { #include &#34;cgo01.h&#34; } void SayHello(const char* s) { std::cout &lt;&lt; s; } 上述.c和.cpp的不同实现都实现了SayHello函数，说明解放了函数的实现者，那如果是这种情况，可不可以使用go实现SayHello函数呢？
答案是可以的，这种技术也称为面向C语言接口(.h中的接口声明)的编程技术，该技术不仅仅可以解放函数的实现者，同时也可以简化函数的使用者。
cgoTest.go
package main import &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/050456c35fe4d60fcd33256961dc78d5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-24T15:41:24+08:00" />
<meta property="article:modified_time" content="2021-06-24T15:41:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">cgo的几种使用方式</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="CGO_1"></a>最简单的CGO程序</h3> 
<pre><code class="prism language-go"><span class="token comment">//cgo.go</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"C"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello cgo"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上述代码是一个完整的CGO程序，通过<code>import "C"</code>语句启动了CGO特性，<code>go build</code>命令会在编译和链接阶段启动gcc编译器</p> 
<h3><a id="C_16"></a>源码方式调用C函数</h3> 
<p>cgoTest.h</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>cgoTest.c</p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"cgoTest.h"</span></span>

<span class="token keyword">void</span> <span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">puts</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>main.go</p> 
<pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token comment">/*
#include &lt;cgoTest.h&gt;
 */</span>
<span class="token keyword">import</span> <span class="token string">"C"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	C<span class="token punctuation">.</span><span class="token function">SayHello</span><span class="token punctuation">(</span>C<span class="token punctuation">.</span><span class="token function">CString</span><span class="token punctuation">(</span><span class="token string">"Hello world\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上述.c文件也可以是.cpp文件，前提是编译时需要g++</p> 
<p>cgoTest.cpp</p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"cgo01.h"</span></span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上述.c和.cpp的不同实现都实现了SayHello函数，说明解放了函数的实现者，那如果是这种情况，可不可以使用go实现SayHello函数呢？</p> 
<p>答案是可以的，这种技术也称为面向C语言接口(.h中的接口声明)的编程技术，该技术不仅仅可以解放函数的实现者，同时也可以简化函数的使用者。</p> 
<p>cgoTest.go</p> 
<pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"C"</span>

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token comment">//export SayHello</span>
<span class="token keyword">func</span> <span class="token function">SayHello</span><span class="token punctuation">(</span>s <span class="token operator">*</span>C<span class="token punctuation">.</span>char<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>C<span class="token punctuation">.</span><span class="token function">GoString</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">//注意：这里是C.GoString</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>注意：</code>上述main.go文件在使用C函数CString后在程序退出前没有释放C.CString创建的字符串会导致内存泄漏，但是对于这个小程序来说，这样是没有问题的，因为程序推出后操作系统会自动回收程序的所有资源</p> 
<p>改进后的main.go代码</p> 
<pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token comment">/*
#include &lt;cgoTest.h&gt;
#include &lt;stdlib.h&gt;
 */</span>
<span class="token keyword">import</span> <span class="token string">"C"</span>
<span class="token keyword">import</span> <span class="token string">"unsafe"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	cs <span class="token operator">:=</span> C<span class="token punctuation">.</span><span class="token function">CString</span><span class="token punctuation">(</span><span class="token string">"CPP Hello world\n"</span><span class="token punctuation">)</span>
	C<span class="token punctuation">.</span><span class="token function">SayHello</span><span class="token punctuation">(</span>cs<span class="token punctuation">)</span>
	C<span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>cs<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当然也有其他方法可以避免这种麻烦的情况出现，而且只需要一个go文件就可以实现面向C语言的编程</p> 
<p>main.go (只有这一个文件)</p> 
<pre><code class="prism language-go"><span class="token comment">//+build go1.10</span>
<span class="token keyword">package</span> main

<span class="token comment">//void SayHello(_GoString_ s); //Go1.10中CGO新增的预定义C语言类型，用来表示Go语言字符串</span>
<span class="token keyword">import</span> <span class="token string">"C"</span>
<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token comment">//export SayHello</span>
<span class="token keyword">func</span> <span class="token function">SayHello</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">//注意这里变量类型为Go 中的string</span>
	fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	C<span class="token punctuation">.</span><span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token string">"Hello CGO\n"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面代码执行时先从Go语言的main函数开始，到CGO自动生成的C语言版本SayHello桥接函数，最后到Go语言环境的SayHello函数，是不是有一种合久必分、分久必合的感觉，这也是CGO编程的精华所在。</p> 
<h3><a id="_129"></a>内部机制</h3> 
<p>如果在一个go文件中出现了<code>import "C"</code> 指令则表示将调用cgo命令生成的对应的中间文件，下图是cgo生成的中间文件的示意图：</p> 
<p><img src="https://images2.imgbox.com/a1/3e/ArKpOo0F_o.png" alt="img"></p> 
<p>在保证<code>go build</code> 没问题的情况下执行如下命令就可以生成中间文件</p> 
<pre><code class="prism language-shell">go tool cgo main.go
</code></pre> 
<p>生成的中间文件在_obj目录下</p> 
<p>为了在C语言中使用Go语言定义的函数，我们需要将Go代码编译为一个C静态库</p> 
<pre><code class="prism language-shell">go build -buildmode<span class="token operator">=</span>c-archive -o SayHello.a  cgoTest.go
</code></pre> 
<p>如果没有错误的话，会生成一个SayHello.a静态库和SayHello.h头文件</p> 
<p>既然提到了静态库的生成，顺便也说一下Go生成C动态库</p> 
<pre><code class="prism language-shell">go build -buildmode<span class="token operator">=</span>c-shared -o SayHello.so cgoTest.go
</code></pre> 
<h3><a id="_157"></a>编译和链接参数</h3> 
<p>编译和链接参数是每一个C/C++程序员需要经常面对的问题。构建每一个C/C++应用均需要经过编译和链接两个步骤，CGO也是如此</p> 
<h4><a id="CFLAGSCPPFLAGSCXXFLAGS_161"></a>编译参数：CFLAGS/CPPFLAGS/CXXFLAGS</h4> 
<p>编译参数主要是头文件的检索路径，预定义的宏等参数。理论上来说C和C++是完全独立的两个编程语言，它们可以有着自己独立的编译参数。 但是因为C++语言对C语言做了深度兼容，甚至可以将C++理解为C语言的超集，因此C和C++语言之间又会共享很多编译参数。 因此CGO提供了CFLAGS/CPPFLAGS/CXXFLAGS三种参数，其中CFLAGS对应C语言编译参数(以.c后缀名)、 CPPFLAGS对应C/C++ 代码编译参数(.c,.cc,.cpp,.cxx)、CXXFLAGS对应纯C++编译参数(.cc,.cpp,*.cxx)</p> 
<h4><a id="LDFLAGS_165"></a>链接参数：LDFLAGS</h4> 
<p>链接参数主要包含要链接库的检索目录和要链接库的名字。因为历史遗留问题，链接库不支持相对路径，我们必须为链接库指定绝对路径。 cgo 中的 ${SRCDIR} 为当前目录的绝对路径。经过编译后的C和C++目标文件格式是一样的，因此LDFLAGS对应C/C++共同的链接参数</p> 
<p>CGO在使用C/C++资源的时候一般有三种形式：直接使用源码；链接静态库；链接动态库。直接使用源码就是在import "C"之前的注释部分包含C代码，或者在当前包中包含C/C++源文件。链接静态库和动态库的方式比较类似，都是通过在LDFLAGS选项指定要链接的库方式链接</p> 
<h3><a id="C_171"></a>通过静态库的方式调用C函数</h3> 
<p>如果CGO中引入的C/C++资源有代码而且代码规模也比较小，直接使用源码是最理想的方式，但很多时候我们并没有源代码，或者从C/C++源代码开始构建的过程异常复杂，这种时候使用C静态库也是一个不错的选择。静态库因为是静态链接，最终的目标程序并不会产生额外的运行时依赖，也不会出现动态库特有的跨运行时资源管理的错误。不过静态库对链接阶段会有一定要求：静态库一般包含了全部的代码，里面会有大量的符号，如果不同静态库之间出现了符号冲突则会导致链接的失败</p> 
<p>假设<code>dirname</code> 下有filename.c文件和filename.h文件，则生成静态库的命令为</p> 
<pre><code class="prism language-shell">$ <span class="token function">cd</span> ./dirname
$ gcc -c -o filename.o filename.c
$ ar rcs libfilename.a filename.o
</code></pre> 
<p>使用静态库中的C函数</p> 
<pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token comment">//#cgo CFLAGS: -I./dirname</span>
<span class="token comment">//#cgo LDFLAGS: -L${SRCDIR}/dirname -lfilename</span>
<span class="token comment">//</span>
<span class="token comment">//#include "filename.h"</span>
<span class="token keyword">import</span> <span class="token string">"C"</span>
<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>C<span class="token punctuation">.</span><span class="token function">filename_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="C_200"></a>通过动态库的方式调用C函数</h3> 
<p>动态库出现的初衷是对于相同的库，多个进程可以共享同一个，以节省内存和磁盘资源。但是在磁盘和内存已经白菜价的今天，这两个作用已经显得微不足道了，那么除此之外动态库还有哪些存在的价值呢？从库开发角度来说，动态库可以隔离不同动态库之间的关系，减少链接时出现符号冲突的风险。而且对于windows等平台，动态库是跨越VC和GCC不同编译器平台的唯一的可行方式</p> 
<p>动态库的生成</p> 
<pre><code class="prism language-shell">gcc -shared -o libfinename.so filename.c
</code></pre> 
<p>对于CGO 来说，使用动态库和静态库是一样的</p> 
<pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token comment">//#cgo CFLAGS: -I./dirname</span>
<span class="token comment">//#cgo LDFLAGS: -L${SRCDIR}/dirname -lfilename</span>
<span class="token comment">//</span>
<span class="token comment">//#include "filename.h"</span>
<span class="token keyword">import</span> <span class="token string">"C"</span>
<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>C<span class="token punctuation">.</span><span class="token function">filename_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5147d9b0e4cd7e93f6e1f9c464b139a9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">U-Net 3&#43;: 全尺度的跳跃连接的 UNet</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6d2b38305b837ce01ca96e657b09b814/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Access to XMLHttpRequest at ‘http://localhost:8080/VXApplets/UserInfoService/login‘ from origin ‘htt</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>