<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>springboot启动原理分析 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="springboot启动原理分析" />
<meta property="og:description" content="文章目录 一、 前言二、 @SpringBootApplication原理解析1. @SpringBootApplication组合注解剖析2. @SpringBootConfiguration3. @ComponentScan4. @EnableAutoConfiguration 三、 SpringApplication.run()原理解析1. 创建SpringApplicaiton1.1 获取应用类型1.2 获取初始化器1.3 获取初监听器1.4 定位main方法 2. 调用run方法2.1 run方法代码总览2.2 监听器2.3 引入注解2.4内置tomcat 三. springboot总结3.1 springboot原理3.2 springboot启动流程 一、 前言 我们启动一个springboot项目，最简单的就是配置一个springboot启动类，然后运行即可
@SpringBootApplication public class SpringBoot { public static void main(String[] args) { SpringApplication.run(SpringBoot.class, args); } } 通过上面的代码，我们可以看出springboot启动的关键主要有两个地方，第一个就是@SpringBootApplication注解，第二个就是 SpringApplication.run(SpringBoot.class, args);这个方法，那么他们内部究竟是如何运作的呢？
二、 @SpringBootApplication原理解析 1. @SpringBootApplication组合注解剖析 首先，我们直接追踪@SpringBootApplication的源码，可以看到其实@SpringBootApplication是一个组合注解，他分别是由底下这些注解组成。
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/1557b0562eaa086171b4dbd8aa6325b9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-16T15:57:43+08:00" />
<meta property="article:modified_time" content="2022-02-16T15:57:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">springboot启动原理分析</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#__2" rel="nofollow">一、 前言</a></li><li><a href="#_SpringBootApplication_16" rel="nofollow">二、 @SpringBootApplication原理解析</a></li><li><ul><li><ul><li><a href="#1__SpringBootApplication_17" rel="nofollow">1. @SpringBootApplication组合注解剖析</a></li><li><a href="#2_SpringBootConfiguration_52" rel="nofollow">2. @SpringBootConfiguration</a></li><li><a href="#3_ComponentScan_90" rel="nofollow">3. @ComponentScan</a></li><li><a href="#4_EnableAutoConfiguration_120" rel="nofollow">4. @EnableAutoConfiguration</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_SpringApplicationrun_167" rel="nofollow">三、 SpringApplication.run()原理解析</a></li><li><ul><li><ul><li><a href="#1_SpringApplicaiton_175" rel="nofollow">1. 创建SpringApplicaiton</a></li><li><ul><li><ul><li><a href="#11%09_200" rel="nofollow">1.1 获取应用类型</a></li><li><a href="#12%09_215" rel="nofollow">1.2 获取初始化器</a></li><li><a href="#13%09_237" rel="nofollow">1.3 获取初监听器</a></li><li><a href="#14%09main_255" rel="nofollow">1.4 定位main方法</a></li></ul> 
     </li></ul> 
     </li><li><a href="#2_run_276" rel="nofollow">2. 调用run方法</a></li><li><ul><li><ul><li><a href="#21_run_278" rel="nofollow">2.1 run方法代码总览</a></li><li><a href="#22__341" rel="nofollow">2.2 监听器</a></li><li><a href="#23__534" rel="nofollow">2.3 引入注解</a></li><li><a href="#24tomcat_698" rel="nofollow">2.4内置tomcat</a></li></ul> 
     </li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#_springboot_728" rel="nofollow">三. springboot总结</a></li><li><ul><li><ul><li><a href="#31_springboot_729" rel="nofollow">3.1 springboot原理</a></li><li><a href="#32_springboot_731" rel="nofollow">3.2 springboot启动流程</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="__2"></a>一、 前言</h3> 
<p>我们启动一个springboot项目，最简单的就是配置一个springboot启动类，然后运行即可</p> 
<pre><code>@SpringBootApplication
public class SpringBoot {
	public static void main(String[] args) {
		SpringApplication.run(SpringBoot.class, args);
	}
}
</code></pre> 
<p>通过上面的代码，我们可以看出springboot启动的关键主要有两个地方，第一个就是<code>@SpringBootApplication</code>注解，第二个就是 <code>SpringApplication.run(SpringBoot.class, args);</code>这个方法，那么他们内部究竟是如何运作的呢？</p> 
<h3><a id="_SpringBootApplication_16"></a>二、 @SpringBootApplication原理解析</h3> 
<h5><a id="1__SpringBootApplication_17"></a>1. @SpringBootApplication组合注解剖析</h5> 
<p>首先，我们直接追踪<code>@SpringBootApplication</code>的源码，可以看到其实<code>@SpringBootApplication</code>是一个组合注解，他分别是由底下这些注解组成。</p> 
<pre><code>@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
</code></pre> 
<p>这些注解虽然看起来很多，但是除去元注解，真正起作用的注解只有以下三个注解：</p> 
<pre><code>@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan
</code></pre> 
<p>那这三个注解是有啥用？其实在Spring Boot 1.2版之前，或者我们初学者刚开始接触springboot时，都还没开始使用<code>@SpringBootApplication</code>这个注解，而是使用以上三个注解启动项目。如果有兴趣的，也可以手动敲敲代码，就会发现这样也可以正常启动项目!</p> 
<pre><code>@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan
public class SpringBoot {
	public static void main(String[] args) {
		SpringApplication.run(SpringBoot.class, args);
	}
}
</code></pre> 
<p>所以说这三个注解才是背后的大佬，<code>@SpringBootApplication</code>只是个空壳子。接下来，我来说明下这三个注解各自的作用。</p> 
<h5><a id="2_SpringBootConfiguration_52"></a>2. @SpringBootConfiguration</h5> 
<p>同样，我们跟踪下<code>@SpringBootConfiguration</code>的源代码，看下他由哪些注解组成</p> 
<pre><code>@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration
</code></pre> 
<p>可以看到，除去元注解，剩下的<code>@Configuration</code>注解我相信大家应该都很熟了！我们springboot为什么可以去除xml配置，靠的就是<code>@Configuration</code>这个注解。所以，它的作用就是将当前类申明为配置类，同时还可以使用<code>@bean</code>注解将类以方法的形式实例化到spring容器，而方法名就是实例名，看下代码你就懂了！</p> 
<pre><code>@Configuration
public class TokenAutoConfiguration {
	@Bean
	public TokenService tokenService() {
		return new TokenService();
	}
}
</code></pre> 
<p>作用等同于xml配置文件的</p> 
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:cache="http://www.springframework.org/schema/cache" xmlns:mvc="http://www.springframework.org/schema/mvc"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd 
	 					http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.1.xsd 
	 					http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd
	 					http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd
	 					http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd "&gt;
    &lt;!--实例化bean--&gt;
  &lt;bean id="tokenService" class="TokenService"&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre> 
<h5><a id="3_ComponentScan_90"></a>3. @ComponentScan</h5> 
<p>我们先说下<code>@ComponentScan</code>作用。他的作用就是扫描当前包以及子包，将有<code>@Component</code>，<code>@Controller</code>，<code>@Service</code>，<code>@Repository</code>等注解的类注册到容器中，以便调用。<br> 注：大家第一眼见到@ComponentScan这个注解的时候是否有点眼熟？之前，一些传统框架用xml配置文件配置的时候，一般都会使用<code>&lt;context:component-scan&gt;</code>来扫描包。以下两中写法的效果是相同的`</p> 
<pre><code>@Configuration
@ComponentScan(basePackages="XXX")
public class SpringBoot {

}

</code></pre> 
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:cache="http://www.springframework.org/schema/cache" xmlns:mvc="http://www.springframework.org/schema/mvc"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd 
	 					http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.1.xsd 
	 					http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd
	 					http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd
	 					http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd "&gt;

	&lt;!-- 扫描需要被调用的注解文件包 --&gt;
	&lt;context:component-scan base-package="XXX"&gt;&lt;/context:component-scan&gt;
&lt;/beans&gt;
</code></pre> 
<p>注：如果<code>@ComponentScan</code>不指定<code>basePackages</code>，那么默认扫描当前包以及其子包，而<code>@SpringBootApplication</code>里的<code>@ComponentScan</code>就是默认扫描，所以我们一般都是把springboot启动类放在最外层，以便扫描所有的类。</p> 
<h5><a id="4_EnableAutoConfiguration_120"></a>4. @EnableAutoConfiguration</h5> 
<p>这里先总结下<code>@EnableAutoConfiguration</code>的工作原理，大家后面看的应该会更清晰：<br> 它主要就是通过内部的方法，扫描<code>classpath</code>的<code>META-INF/spring.factories</code>配置文件（key-value），将其中的<br> <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 对应的配置项实例化并且注册到<code>spring</code>容器。</p> 
<p>ok，我们同样打开<code>@EnableAutoConfiguration</code>源码，可以发现他是由以下几个注解组成的</p> 
<pre><code>@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(AutoConfigurationImportSelector.class)
</code></pre> 
<p>除去元注解，主要注解就是<code>@AutoConfigurationPackage</code>和<code>@Import(AutoConfigurationImportSelector.class)</code><br> 我们springboot项目为什么可以自动载入应用程序所需的bean？就是因为这个神奇的注解<code>@Import</code>。那么这个<code>@Import</code>怎么这么牛皮？没关系！我们一步一步的看下去！<br> 首先我们先进入<code>AutoConfigurationImportSelector</code>类，可以看到他有一个方法<code>selectImports()</code>，<br> <img src="https://images2.imgbox.com/83/3b/LFW11Q9a_o.png" alt="在这里插入图片描述"><br> 继续跟踪，进入<code>getAutoConfigurationEntry()</code>方法</p> 
<pre><code>List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);
</code></pre> 
<p>可以看到这里有个<code>List</code>集合，那这个<code>List</code>集合又是干嘛的？没事，我们继续跟踪<code>getCandidateConfigurations()</code>方法！<br> <img src="https://images2.imgbox.com/1a/16/eWIObqba_o.png" alt="在这里插入图片描述"></p> 
<p>可以看到这里有个方法</p> 
<pre><code>SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),getBeanClassLoader());
</code></pre> 
<p>这个方法的作用就是读取<code>classpath</code>下的<code>META-INF/spring.factories</code>文件的配置，将key为 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 对应的配置项读取出来，通过反射机制实例化为配置文件，然后注入spring容器。</p> 
<p>注：假如你想要实例化一堆<code>bean</code>，可以通过配置文件先将这些<code>bean</code>实例化到容器，等其他项目调用时，在<code>spring.factories</code>中写入这个配置文件的路径即可！我前面的文章有这个例子<a href="https://blog.csdn.net/weixin_40496191/article/details/109065430">https://blog.csdn.net/weixin_40496191/article/details/109065430</a><br> 主要是实现自己创建的starter依赖包，然后由其他项目引入使用，这是我的<code>spring.factories</code>文件</p> 
<pre><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=zzk.config.TokenAutoConfiguration
</code></pre> 
<p>然后直接在SpringFactoriesLoader.loadFactoryNames;这个方法后面打个断点，可以在返回的集合里找到我们自定义的配置文件路径！<br> <img src="https://images2.imgbox.com/5b/12/nwZrFMBv_o.png" alt="在这里插入图片描述"></p> 
<p>说明成功引入我们自定义的依赖包！</p> 
<h3><a id="_SpringApplicationrun_167"></a>三、 SpringApplication.run()原理解析</h3> 
<p><code>SpringApplication.run()</code>原理相对于前面注解的原理，会稍微麻烦点，为了方便我会适当贴出一些注解代码。<br> 首先我们点击查看run方法的源码</p> 
<p><img src="https://images2.imgbox.com/76/9d/2TCG1329_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b2/92/dmXaT8d6_o.png" alt="在这里插入图片描述"><br> 可以看出，其实<code>SpringApplication.run()</code>包括两个部分，一部分就是创建<code>SpringApplicaiton</code>实例，另一部分就是调用<code>run()</code>方法，那他们又是怎么运行的？</p> 
<h5><a id="1_SpringApplicaiton_175"></a>1. 创建SpringApplicaiton</h5> 
<p>继续跟踪SpringApplication实例的源码<br> <img src="https://images2.imgbox.com/c1/85/wyE4TQpb_o.png" alt="在这里插入图片描述"><br> 继续跟踪进入，到如下这个方法中</p> 
<pre><code>@SuppressWarnings({ "unchecked", "rawtypes" })
public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) {
	this.resourceLoader = resourceLoader;
	Assert.notNull(primarySources, "PrimarySources must not be null");
	this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));
	//获取应用类型
	this.webApplicationType = WebApplicationType.deduceFromClasspath();
	//获取所有初始化器
	setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
	//获取所有监听器
	setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
	//定位main方法
	this.mainApplicationClass = deduceMainApplicationClass();
}

</code></pre> 
<p>springboot在创建<code>SpringApplicaiton</code>实例的时候，主要是做了以上四个事情，ok，继续拆分一一讲解!</p> 
<h6><a id="11%09_200"></a>1.1 获取应用类型</h6> 
<p>跟踪deduceFromClasspath方法<br> <img src="https://images2.imgbox.com/63/ef/rwSuwqV0_o.png" alt="在这里插入图片描述"><br> 从返回结果我们可以看出应用类型一共有三种，分别是<br> <code>NONE</code>： 非web应用，即不会启动服务器<br> <code>SERVLET</code>： 基于servlet的web应用<br> <code>REACTIVE</code>： 响应式web应用（暂未接触过）</p> 
<p>判断一共涉及四个常量：<br> <code>WEBFLUX_INDICATOR_CLASS</code><br> <code>WEBMVC_INDICATOR_CLASS</code><br> <code>JERSEY_INDICATOR_CLASS</code><br> <code>SERVLET_INDICATOR_CLASSES</code></p> 
<p>springboot在初始化容器的时候，会对以上四个常量所对应的class进行判断，看看他们是否存在，从而返回应用类型！至于常量代表哪些class，大家可以自己跟踪看看，也在当前类中！</p> 
<h6><a id="12%09_215"></a>1.2 获取初始化器</h6> 
<p>跟踪进入<code>getSpringFactoriesInstances</code>方法</p> 
<pre><code>	private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) {
		return getSpringFactoriesInstances(type, new Class&lt;?&gt;[] {});
	}
	
	private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) {
		ClassLoader classLoader = getClassLoader();
		// Use names and ensure unique to protect against duplicates
		//获取所有初始化器的名称集合
		Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));
		//根据名称集合实例化这些初始化器
		List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);
		//排序		
		AnnotationAwareOrderComparator.sort(instances);
		return instances;
	}
</code></pre> 
<p>从代码可以看出是在<code>META-INF/spring.factories</code>配置文件里获取初始化器，然后实例化、排序后再设置到<code>initializers</code>属性中。</p> 
<h6><a id="13%09_237"></a>1.3 获取初监听器</h6> 
<p>同样跟踪源码，发现其实监听器和初始化的操作是基本一样的</p> 
<pre><code>private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) {
		return getSpringFactoriesInstances(type, new Class&lt;?&gt;[] {});
	}

	private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) {
		ClassLoader classLoader = getClassLoader();
		// Use names and ensure unique to protect against duplicates
		Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));
		List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);
		AnnotationAwareOrderComparator.sort(instances);
		return instances;
	}
</code></pre> 
<p>这里就不多做解释了！</p> 
<h6><a id="14%09main_255"></a>1.4 定位main方法</h6> 
<p>跟踪源码进入<code>deduceMainApplicationClass</code>方法</p> 
<pre><code>private Class&lt;?&gt; deduceMainApplicationClass() {
		try {
		    //通过创建运行时异常的方式获取栈
			StackTraceElement[] stackTrace = new RuntimeException().getStackTrace();
			//遍历获取main方法所在的类并且返回
			for (StackTraceElement stackTraceElement : stackTrace) {
				if ("main".equals(stackTraceElement.getMethodName())) {
					return Class.forName(stackTraceElement.getClassName());
				}
			}
		}
		catch (ClassNotFoundException ex) {
			// Swallow and continue
		}
		return null;
	}
</code></pre> 
<h5><a id="2_run_276"></a>2. 调用run方法</h5> 
<h6><a id="21_run_278"></a>2.1 run方法代码总览</h6> 
<pre><code>// 开启计时类进行计时
		StopWatch stopWatch = new StopWatch();
		stopWatch.start();
		//声明应用上下文
		ConfigurableApplicationContext context = null;
		// 记录sprongboot启动异常日志
		Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();
		//设置系统java.awt.headless属性，默认为true(跟踪代码可以看到)
		configureHeadlessProperty();
		// 获取监听器，它的作用是为后期一些环境参数进行赋值，就是加载配置文件
		// 获取到org.springframework.boot.context.event.EventPublishingRunListener
		// implements SpringApplicationRunListener
		SpringApplicationRunListeners listeners = getRunListeners(args);
		//********* 遍历调用监听器，表示监听器已经开始初始化容器**********
		listeners.starting();
		try {
			// 将args包装厂ApplicationArguments类
			ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
			// ********监听器开始对对环境参数进行赋值***********
			ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);
			configureIgnoreBeanInfo(environment);
			//打印banner图，就是我们springboot启动时，前面几行图形
			Banner printedBanner = printBanner(environment);
			// 初始化上下文对象AnnotationConfigServletWebServerApplicationContext
			context = createApplicationContext();
			// 异常采集
			exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,
					new Class[] { ConfigurableApplicationContext.class }, context);
			// 部署上下文
			prepareContext(context, environment, listeners, applicationArguments, printedBanner);
			// springbootApplication生效
			// 刷新上下文
			refreshContext(context);
			//刷新后的方法，空方法，给用户自定义重写
			afterRefresh(context, applicationArguments);
			//结束计时
			stopWatch.stop();
			//输出日志记录执行主类名、时间信息
			if (this.logStartupInfo) {
				new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
			}
			//********* 使用广播和回调机制告诉监听者springboot容器已经启动化成功**********
			listeners.started(context);
			//做一些调整顺序操作
			callRunners(context, applicationArguments);
		} catch (Throwable ex) {
			handleRunFailure(context, ex, exceptionReporters, listeners);
			throw new IllegalStateException(ex);
		}

		try {
			//********* 使用广播和回调机制告诉已经可以运行springboot了**********
			listeners.running(context);
		} catch (Throwable ex) {
			handleRunFailure(context, ex, exceptionReporters, null);
			throw new IllegalStateException(ex);
		}
		//返回上下文
		return context;
</code></pre> 
<h6><a id="22__341"></a>2.2 监听器</h6> 
<p>1.跟踪监听器==&gt;EventPublishingRunListener<br> <code>run</code>方法代码总览在这里面，<code>listeners</code>出现了很多次，调用了<code>start</code>，<code>running</code>等方法。这时候你可能会问，那他们又有什么区别呢？首先，我们先跟踪源码看看这个<code>listeners</code>到底是什么玩意儿…<br> 我们进入<code>getRunListeners</code>方法，可以看到</p> 
<pre><code>private SpringApplicationRunListeners getRunListeners(String[] args) {
		Class&lt;?&gt;[] types = new Class&lt;?&gt;[] { SpringApplication.class, String[].class };
		return new SpringApplicationRunListeners(logger,
				getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));
	}
</code></pre> 
<p><code>getSpringFactoriesInstances</code>方法大家看了前面的现在应该知道了，这段代码的意思就是要去所有的<code>META-INF</code>文件下的<code>spring.factorie</code>寻找关于<code>key</code>为<code>SpringApplicationRunListener</code>的<code>value</code>配置，ok，那我们找找，可以发现在这里存在<br> <img src="https://images2.imgbox.com/37/30/aOvOmTL5_o.png" alt="在这里插入图片描述"><br> 看样子这个方法最后返回的是<code>org.springframework.boot.context.event.EventPublishingRunListener</code>这个类，那我们就打开这个类看看是啥。<br> <img src="https://images2.imgbox.com/0e/1d/gtbTwXNr_o.png" alt="在这里插入图片描述"><br> 这个方法它实现了<code>SpringApplicationRunListener</code>接口，那么，这个接口是干啥的呢？没错，他就是用来加载我们配置文件用的。接下来我弄个简单的例子，大家就知道怎么用了。</p> 
<p>2.EventPublishingRunListener接口举例<br> 主要实现自定义监听器并且读取我们配置文件内容，先献上我的文件结构<br> <img src="https://images2.imgbox.com/e4/09/oyBlNKgh_o.png" alt="在这里插入图片描述"></p> 
<p>创建一个<code>maven</code>项目，<code>pom</code>配置只需要添加<code>web</code>依赖即可</p> 
<pre><code>&lt;parent&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
		&lt;version&gt;2.1.8.RELEASE&lt;/version&gt;
  &lt;/parent&gt;
  &lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
  &lt;build&gt;
</code></pre> 
<p>在<code>resource</code>自定义配置文件<code>my.properties</code></p> 
<pre><code>tzr.name=zzk
</code></pre> 
<p>自定义监听器，这里主要是对<code>starting</code>、<code>environmentPrepared</code>、<code>started</code>、<code>running</code>方法进行实现</p> 
<pre><code>package zzk;

import java.io.IOException;
import java.util.Properties;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.SpringApplicationRunListener;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.core.Ordered;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.MutablePropertySources;
import org.springframework.core.env.PropertiesPropertySource;
import org.springframework.core.env.PropertySource;
/**
 * 集成监听器加载我们的配置文件
 * @author zhanzhk
 *
 */
public class MyListener implements SpringApplicationRunListener,Ordered {

	private SpringApplication application;
	private String[] args;
	
	
	@Override
	public void starting() {
		System.out.println("表示准备开始使用监听器");

	}

	public MyListener(SpringApplication application, String[] args) {
		this.application = application;
		this.args = args;
	}
	
	@Override
	public void environmentPrepared(ConfigurableEnvironment environment) {
		System.out.println("表示已经开始读取配置文件");
		//配置文件到程序，再然后放入springboot容器
		Properties properties=new Properties();
		try {
			//读取properties容器
			properties.load(this.getClass().getClassLoader().getResourceAsStream("my.properties"));
			//读取名字为my
			PropertySource propertySource=new PropertiesPropertySource("my",properties) ;
			//加载资源到springboot容器
			MutablePropertySources propertySources=environment.getPropertySources();
			propertySources.addLast(propertySource);
			//换种思路，如果你配置文件是放在网络上，可以直接读取放入我们的项目中
		
		} catch (IOException e) {
			System.out.println("出错");
		}

	}

	@Override
	public void contextPrepared(ConfigurableApplicationContext context) {
		// TODO Auto-generated method stub

	}

	@Override
	public void contextLoaded(ConfigurableApplicationContext context) {
		// TODO Auto-generated method stub

	}

	@Override
	public void started(ConfigurableApplicationContext context) {
		System.out.println("表示初始化容器已经结束");

	}

	@Override
	public void running(ConfigurableApplicationContext context) {
		System.out.println("表示可以使用springboot了");
	}

	@Override
	public void failed(ConfigurableApplicationContext context, Throwable exception) {
		// TODO Auto-generated method stub

	}

	//读取优先级
	@Override
	public int getOrder() {
		// TODO Auto-generated method stub
		return -1;
	}

}

</code></pre> 
<p>然后编写controller文件对我们的配置参数进行调用</p> 
<pre><code>package zzk.controller;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class Application {

	@Value("${tzr.name}")
	private String name;

	@RequestMapping("test")
	@ResponseBody
	public String test() {
		String x = name;
		return x;
	}
}

</code></pre> 
<p>ok，那我们自定义的监听器<code>springboot</code>程序又是如何获取的？前面我们代码里讲过了，它主要是读取<code>META-INF</code>底下的<code>spring.factories</code>文件，然后获取监听器，ok那就简单了，我们直接照着<code>EventPublishingRunListener</code>一样在resource增加<code>METAA_INF/spring.factories</code>文件</p> 
<pre><code>org.springframework.boot.SpringApplicationRunListener=\
zzk.MyListener
</code></pre> 
<p>最后设置spring启动器</p> 
<pre><code>package zzk;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Springboot {
	public static void main(String[] args) {
		SpringApplication.run(Springboot.class, args);
	}
}

</code></pre> 
<p>启动！可以看到启动信息<br> <img src="https://images2.imgbox.com/2c/44/zjHfGHO0_o.png" alt="在这里插入图片描述"><br> 然后我们再调用<code>controller</code>方法<br> <img src="https://images2.imgbox.com/53/53/1USRtXoi_o.png" alt="在这里插入图片描述"><br> 成功读取我们自定义的配置文件，现在再回头看看run方法，是不是就清晰了！</p> 
<h6><a id="23__534"></a>2.3 引入注解</h6> 
<p><code>springboot</code>的启动分为两部分，一部分是注解，一部分是<code>SpringApplication.run(Springboot.class, args)</code>，那么我们的注解又是如何嵌入到程序中呢？靠的就是<code>refreshContext</code>方法，同理，我们跟踪源码进入<code>refreshContext</code>方法</p> 
<p><img src="https://images2.imgbox.com/48/93/t1vb32Be_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/9b/c5/nJASvalM_o.png" alt="在这里插入图片描述"></p> 
<pre><code>@Override
	public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			//  准备这个上下文来刷新。
			prepareRefresh();

			// 告诉子类刷新内部bean工厂。
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			//  准备bean在此上下文中使用。
			prepareBeanFactory(beanFactory);

			try {
				//  允许在上下文子类中对bean工厂进行后处理。
				postProcessBeanFactory(beanFactory);

				//  调用在上下文中注册为bean的工厂处理器。
				invokeBeanFactoryPostProcessors(beanFactory);

				//  注册拦截bean创建的bean处理器。
				registerBeanPostProcessors(beanFactory);

				//  初始化此上下文的消息源。
				initMessageSource();

				//  为此上下文初始化事件多播。
				initApplicationEventMulticaster();

				//  在特定的上下文子类中初始化其他特殊bean。
				onRefresh();

				//  检查侦听器bean并注册它们。
				registerListeners();

				//  实例化所有剩余的(非拉齐-init)单例。
				finishBeanFactoryInitialization(beanFactory);

				//  最后一步：发布相应事件.
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn("Exception encountered during context initialization - " +
							"cancelling refresh attempt: " + ex);
				}

				//  销毁已经创建的单例以避免悬空资源。
				destroyBeans();

				//  重置“actiove”标志。
				cancelRefresh(ex);

				// 向调用者传播异常。
				throw ex;
			}

			finally {
				//  重置Spring核心中常见的内省缓存，因为我们可能不再需要单例bean的元数据了。。。
				resetCommonCaches();
			}
		}
	}
</code></pre> 
<p>到这里，就可以看到一系列bean的操作，继续跟踪进入<code>invokeBeanFactoryPostProcessors</code>（调用在上下文中注册为<code>bean</code>的工厂处理器）方法<br> <img src="https://images2.imgbox.com/64/aa/jCnbVcYJ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/13/d5/FOhNbi4g_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8a/6f/oU6U1kMj_o.png" alt="在这里插入图片描述"><br> 进入<code>ConfigurationClassParser</code>这个类后，方法调用也是挺绕的，这里就不深究了…进入这个类主要是想看下它的一些方法，因为对于<code>springboot</code>注解的引用就是在这个类进行的，比如<code>doProcessConfigurationClass</code>：</p> 
<pre><code>    @Nullable
	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
			throws IOException {

		if (configClass.getMetadata().isAnnotated(Component.class.getName())) {
			// Recursively process any member (nested) classes first
			processMemberClasses(configClass, sourceClass);
		}

		//处理 @PropertySource 注解
		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), PropertySources.class,
				org.springframework.context.annotation.PropertySource.class)) {
			if (this.environment instanceof ConfigurableEnvironment) {
				processPropertySource(propertySource);
			}
			else {
				logger.info("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +
						"]. Reason: Environment must implement ConfigurableEnvironment");
			}
		}

		// 处理 @ComponentScan 注解
		Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
		if (!componentScans.isEmpty() &amp;&amp;
				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
			for (AnnotationAttributes componentScan : componentScans) {
				// The config class is annotated with @ComponentScan -&gt; perform the scan immediately
				Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
				// Check the set of scanned definitions for any further config classes and parse recursively if needed
				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
					BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
					if (bdCand == null) {
						bdCand = holder.getBeanDefinition();
					}
					if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
						parse(bdCand.getBeanClassName(), holder.getBeanName());
					}
				}
			}
		}

		 
		 //处理 @Import 注解
		processImports(configClass, sourceClass, getImports(sourceClass), true);

		
		//处理 @ImportResource 注解
		AnnotationAttributes importResource =
				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
		if (importResource != null) {
			String[] resources = importResource.getStringArray("locations");
			Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass("reader");
			for (String resource : resources) {
				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
				configClass.addImportedResource(resolvedResource, readerClass);
			}
		}

		//处理 @Bean 注解
		Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
		for (MethodMetadata methodMetadata : beanMethods) {
			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
		}

		// Process default methods on interfaces
		processInterfaces(configClass, sourceClass);

		// Process superclass, if any
		if (sourceClass.getMetadata().hasSuperClass()) {
			String superclass = sourceClass.getMetadata().getSuperClassName();
			if (superclass != null &amp;&amp; !superclass.startsWith("java") &amp;&amp;
					!this.knownSuperclasses.containsKey(superclass)) {
				this.knownSuperclasses.put(superclass, configClass);
				// Superclass found, return its annotation metadata and recurse
				return sourceClass.getSuperClass();
			}
		}

		// No superclass -&gt; processing is complete
		return null;
	}
</code></pre> 
<p>ok，过…下一个</p> 
<h6><a id="24tomcat_698"></a>2.4内置tomcat</h6> 
<p>其实，内置<code>tomcat</code>应该要归在<code>refreshContext</code>讲的，因为tomcat就是在注解引入的类中生成的，而<code>refreshContext</code>可以引入注解。不过为了更清楚，这里分开吧。前面说了，我们<code>refreshContext</code>是刷新上下文，那如果想要知道上下文中是否存在生成<code>tomcat</code>的类，我们直接去最后返回的上下文中找对应的类即可！<br> ok，我们在<code>main</code>方法写获取上下文的代码，并且打印出对应的name</p> 
<pre><code>package zzk;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;

@SpringBootApplication
public class Springboot {
	public static void main(String[] args) {
		ConfigurableApplicationContext configurableApplicationContext = SpringApplication.run(Springboot.class, args);
		String[] xs = configurableApplicationContext.getBeanDefinitionNames();
		for (String x : xs) {
			System.out.println(x);
		}

	}
}

</code></pre> 
<p>直接启动，可以看到有<code>org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration</code>这个类<img src="https://images2.imgbox.com/af/0e/k0Jo6TlC_o.png" alt="在这里插入图片描述"><br> ok，我们点开这个类，跟踪源码<br> <img src="https://images2.imgbox.com/99/57/0NsunMyj_o.png" alt="在这里插入图片描述"><br> 我们知道，<code>springboot</code>其实有三种内容服务器，分别是<code>Tomcat，Jetty，Undertow</code>。默认内置<code>tomcat</code>，。我们继续跟踪<code>EmbeddedTomcat.class</code><img src="https://images2.imgbox.com/ae/f4/oz2PdA57_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d2/23/wc6lwfIp_o.png" alt="在这里插入图片描述"><br> 可以看到，其实这里的tomcat服务器是内部通过java代码实现的。到这里，<code>run()</code>方法就算结束了。如果后续想深入了解的可以自己看看源码。其实，<code>run()</code>方法总结起来并不多，大方向无非是配置环境参数，引入注解刷新上下文。其他的一些捕获异常、计时操作都是非重点操作。</p> 
<h3><a id="_springboot_728"></a>三. springboot总结</h3> 
<h5><a id="31_springboot_729"></a>3.1 springboot原理</h5> 
<p>包装spring核心注解，使用springmvc无xml进行启动，通过自定义starter和maven依赖简化开发代码，开发者能够快速整合第三方框架，通过java语言内嵌入tomcat</p> 
<h5><a id="32_springboot_731"></a>3.2 springboot启动流程</h5> 
<pre><code>--------------------------------创建springbootApplication对象---------------------------------------------
1. 创建springbootApplication对象springboot容器初始化操作
2. 获取当前应用的启动类型。
	注1：通过判断当前classpath是否加载servlet类，返回servlet web启动方式。
	注2：webApplicationType三种类型：
		1.reactive：响应式启动（spring5新特性）
		2.none:即不嵌入web容器启动（springboot放在外部服务器运行 ）
		3.servlet:基于web容器进行启动
3. 读取springboot下的META-INFO/spring.factories文件，获取对应的ApplicationContextInitializer装配到集合
4. 读取springboot下的META-INFO/spring.factories文件，获取对应的ApplicationListener装配到集合
5. mainApplicationClass，获取当前运行的主函数
6. 
------------------调用springbootApplication对象的run方法，实现启动，返回当前容器的上下文----------------------------------------------
7. 调用run方法启动
8. StopWatch stopWatch = new StopWatch()，记录项目启动时间
9. getRunListeners，读取META-INF/spring.factores，将SpringApplicationRunListeners类型存到集合中
10. listeners.starting();循环调用starting方法
11. prepareEnvironment(listeners, applicationArguments);将配置文件读取到容器中
		读取多数据源：classpath:/,classpath:/config/,file:./,file:./config/底下。其中classpath是读取编译后的，file是读取编译前的
		支持yml，yaml，xml，properties
12. Banner printedBanner = printBanner(environment);开始打印banner图，就是sprongboot启动最开头的图案
13. 初始化AnnotationConfigServletWebServerApplicationContext对象
14. 刷新上下文，调用注解，refreshContext(context);
15. 创建tomcat
16. 加载springmvc
17. 刷新后的方法，空方法，给用户自定义重写afterRefresh（）
18. stopWatch.stop();结束计时
19. 使用广播和回调机制告诉监听者springboot容器已经启动化成功，listeners.started(context);
20. 使用广播和回调机制告诉监听者springboot容器已经启动化成功，listeners.started(context);
21. 返回上下文

</code></pre> 
<p>注：该原理、流程由每特教育&amp;&amp;蚂蚁课堂余老师总结！</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9d6891508a4c2ed1706447f65bfa1119/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">1、1、2、3、5、8、13、21、34求第n位数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/531a57c61d9a42d22fca127f4c427330/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">专精特新品类定义及申报奖励重点介绍，补贴20-100万</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>