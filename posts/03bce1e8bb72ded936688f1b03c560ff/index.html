<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android 设备 设置adb自动监听tcp 5555端口，重启有效 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android 设备 设置adb自动监听tcp 5555端口，重启有效" />
<meta property="og:description" content="Android 设备调试有两种连线方式:有线和无线;
有线是通过USB导线连接android设备和电脑端,无线方式是通过连接WIFI,通过TCP的方式,连接设备和电脑端,一般用 5555端口;
有线的调节,只需要打开调试模式基本就可以了,无线连接方式比有线多一步操作,就是需要先通过usb导线连接后,adb 命令行:adb tcpip 5555 开启tcp 连接5555端口;
正常过程是这样的,但是日常开发的时候经常遇到,没有带线,没有笔记本备用,设备不在身边(在隔壁)的情况,设备每次重启都会关闭tcp 555端口,不可能每次都需要拿着电脑/导线去设备前调试,而且,公司没有给我配置笔记本```
这个情况下,就需要设置adb 自动监听5555端口,而且需要重启有效,
说明 : 该情况适用于 root 的设备;
1.adb 查看root权限 我们先通过导线连接设备,通过adb 命令判断,命令行输入 adb shell，#代表已经root过，$代表没有root权限;
(还好还好,我们的屏/设备 属于root过的设备,具有root权限)
2.修改文件 修改/default.prop或者/system/build.prop文件
//添加这一行 service.adb.tcp.port=5555 文件后可以添加这一行
但是你会发现/system 文件夹是只读权限的.
你可以通过如下的命令查看该文件权限;
adb shell ls -l /system 这个是我修改后的,你可以看看你的;
要修改build.prop文件,是修改不了的,所以需要解决的是如何修改;
3.Android9.0挂载system文件夹读写 我们知道在Android系统中，system文件夹一般都是只读属性，不管你是root用户还是普通权限用户，所以在开发中，如果我们想要访问和修改system文件夹下的内容的话就需要获取system文件夹的写属性，而因为Android版本的变化，在不同版本下system文件夹修改读写属性的方式也有较大的区别。
Android 8.0以下版本 第一步:要得到system分区的全名 adb shell mount rootfs / rootfs ro 0 0 tmpfs /dev tmpfs rw,mode=755 0 0 devpts /dev/pts devpts rw,mode=600 0 0 proc /proc proc rw 0 0 sysfs /sys sysfs rw 0 0 tmpfs /sqlite_stmt_journals tmpfs rw,size=4096k 0 0 none /dev/cpuctl cgroup rw,cpu 0 0 /dev/block/mtdblock0 /system yaffs2 ro 0 0 /dev/block/mtdblock1 /data yaffs2 rw,nosuid,nodev 0 0 /dev/block/mtdblock2 /cache yaffs2 rw,nosuid,nodev 0 0 /dev/block//vold/179:0 /sdcard vfat rw,dirsync,nosuid,nodev,noexec,uid=1000,gid=1015,fmask=0702,dmask=0702,allow_utime=0020,codepage=cp437,iocharset=iso8859-1,shortname=mixed,utf8,errors=remount-ro 0 0 从/dev/block/mtdblock0 /system yaffs2 ro 0 0 部分可以看得出/system的权限是ro即是read only。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/03bce1e8bb72ded936688f1b03c560ff/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-07T17:53:35+08:00" />
<meta property="article:modified_time" content="2023-08-07T17:53:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android 设备 设置adb自动监听tcp 5555端口，重启有效</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Android 设备调试有两种连线方式:有线和无线;</p> 
<p>有线是通过USB导线连接android设备和电脑端,无线方式是通过连接WIFI,通过TCP的方式,连接设备和电脑端,一般用 5555端口;</p> 
<p>有线的调节,只需要打开调试模式基本就可以了,无线连接方式比有线多一步操作,就是需要先通过usb导线连接后,adb 命令行:adb tcpip 5555  开启tcp 连接5555端口;</p> 
<p>正常过程是这样的,但是日常开发的时候经常遇到,没有带线,没有笔记本备用,设备不在身边(在隔壁)的情况,设备每次重启都会关闭tcp 555端口,不可能每次都需要拿着电脑/导线去设备前调试,而且,公司没有给我配置笔记本```</p> 
<p><img alt="" height="184" src="https://images2.imgbox.com/31/51/TIjIBcg4_o.jpg" width="189"></p> 
<p>这个情况下,就需要设置adb 自动监听5555端口,而且需要重启有效,</p> 
<p>说明 : 该情况适用于 root 的设备;</p> 
<h4>1.adb 查看root权限</h4> 
<p>我们先通过导线连接设备,通过adb 命令判断,命令行输入 adb shell，#代表已经root过，$代表没有root权限;</p> 
<p>(还好还好,我们的屏/设备 属于root过的设备,具有root权限)</p> 
<h4>2.修改文件</h4> 
<p>修改/default.prop或者/system/build.prop文件</p> 
<pre><code>//添加这一行
service.adb.tcp.port=5555</code></pre> 
<p>文件后可以添加这一行</p> 
<p>但是你会发现/system 文件夹是只读权限的.</p> 
<p><img alt="" height="337" src="https://images2.imgbox.com/db/5f/CWohSFBs_o.png" width="479"></p> 
<p>你可以通过如下的命令查看该文件权限;</p> 
<pre><code>adb shell ls -l /system</code></pre> 
<p>这个是我修改后的,你可以看看你的;</p> 
<p>要修改build.prop文件,是修改不了的,所以需要解决的是如何修改;</p> 
<p><img alt="" height="91" src="https://images2.imgbox.com/75/d4/OltAZJLU_o.jpg" width="87"></p> 
<h4>3.Android9.0挂载system文件夹读写</h4> 
<p>我们知道在Android系统中，system文件夹一般都是只读属性，不管你是root用户还是普通权限用户，所以在开发中，如果我们想要访问和修改system文件夹下的内容的话就需要获取system文件夹的写属性，而因为Android版本的变化，在不同版本下system文件夹修改读写属性的方式也有较大的区别。</p> 
<h5><br> Android 8.0以下版本</h5> 
<h6>第一步:要得到system分区的全名</h6> 
<pre><code>adb shell 
mount 
rootfs / rootfs ro 0 0 
tmpfs /dev tmpfs rw,mode=755 0 0 
devpts /dev/pts devpts rw,mode=600 0 0 
proc /proc proc rw 0 0 
sysfs /sys sysfs rw 0 0 
tmpfs /sqlite_stmt_journals tmpfs rw,size=4096k 0 0 
none /dev/cpuctl cgroup rw,cpu 0 0 
/dev/block/mtdblock0 /system yaffs2 ro 0 0 
/dev/block/mtdblock1 /data yaffs2 rw,nosuid,nodev 0 0 
/dev/block/mtdblock2 /cache yaffs2 rw,nosuid,nodev 0 0 
/dev/block//vold/179:0 /sdcard vfat rw,dirsync,nosuid,nodev,noexec,uid=1000,gid=1015,fmask=0702,dmask=0702,allow_utime=0020,codepage=cp437,iocharset=iso8859-1,shortname=mixed,utf8,errors=remount-ro 0 0 
</code></pre> 
<p>从/dev/block/mtdblock0 /system yaffs2 ro 0 0 部分可以看得出/system的权限是ro即是read only。</p> 
<h6>第二步:根据名称重新挂载</h6> 
<pre><code>mount -o remount /dev/block/mtdblock0 /system 
mount 
rootfs / rootfs ro 0 0 
tmpfs /dev tmpfs rw,mode=755 0 0 
devpts /dev/pts devpts rw,mode=600 0 0 
proc /proc proc rw 0 0 
sysfs /sys sysfs rw 0 0 
tmpfs /sqlite_stmt_journals tmpfs rw,size=4096k 0 0 
none /dev/cpuctl cgroup rw,cpu 0 0 
/dev/block/mtdblock0 /system yaffs2 rw 0 0 
/dev/block/mtdblock1 /data yaffs2 rw,nosuid,nodev 0 0 
/dev/block/mtdblock2 /cache yaffs2 rw,nosuid,nodev 0 0 
/dev/block//vold/179:0 /sdcard vfat rw,dirsync,nosuid,nodev,noexec,uid=1000,gid=1015,fmask=0702,dmask=0702,allow_utime=0020,codepage=cp437,iocharset=iso8859-1,shortname=mixed,utf8,errors=remount-ro 0 0
</code></pre> 
<p>可以看到/dev/block/mtdblock0 /system yaffs2 rw 0 0，/system拥有rw的权限。</p> 
<p>如果要改回去ro权限的话，执行：</p> 
<pre><code>mount -o remount,ro /dev/block/mtdblock0 /system </code></pre> 
<p>当/system 目录为读写权限后，就可以随意删除或者替换系统应用了。</p> 
<p></p> 
<h5>Android 8.0以上版本</h5> 
<p>在Android8.0以上通过以上mount命令，你会发现找不到/system代表的节点和拥有的权限信息，这是因为Android8.0之后谷歌加入了A/B system的特性，system分区跟ramdisk分区打包在一起，因此系统起来之后也就不存在system分区了，而是直接把system镜像挂载到/根目录上。所以/proc/mounts文件中没有包含/system的权限信息，此时如果使用上面的命令：<br>  </p> 
<pre><code>mount -o remount,rw /system </code></pre> 
<p>重新挂载/system分区会报错：</p> 
<pre><code>mount: '/system' not in /proc/mounts</code></pre> 
<p>因此使用这条命令是不可行的，需要使用下述的命令：</p> 
<pre><code>mount -o remount -o rw /</code></pre> 
<p>使用这条命令可以临时挂载上/system文件夹，直到下一次重启。<br> 其实为什么root用户会出现/system文件夹无权限写的情况的话，主要原因是/system所属的用户组不是root，而是system用户组，所以需要重新挂载。<br> 当然上面方法不能挂载/system目录的话而且提示“’/dev/root’ is read-only”的话，那么是因为你的设备开启了avb，此时就只能通过下面的方式完全重新挂载整个系统(当然,我暂时没遇到这个情况,大家可以留意一下)：<br>  </p> 
<pre><code>adb root
adb disable-verity
adb remount</code></pre> 
<p>如果adb disable-verity提示需要解锁OEM的话，那么还需要先解锁OEM：</p> 
<pre><code>adb reboot fastboot
fastboot oem unlock
fastboot reboot</code></pre> 
<p>提示解锁成功的话，重新执行命令就不会报错了。</p> 
<h4>4.再修改/system/build.prop</h4> 
<p>这个时候你就只可以直接操作/system文件夹下的文件了, adb pull,adb push 都可以用了,不过有没有办法可以在android shell中编辑这些文件(比如Linux shell中的vim编辑器)呢,</p> 
<p>我看到有个文件说你可以用cat命令,好吧</p> 
<p>您可以使用以下方法创建文本</p> 
<pre><code> $ cat &gt; filename.txt
</code></pre> 
<p>您可以使用以下方法向文本文件添加行:</p> 
<pre><code> $ cat &gt;&gt; filename.txt
</code></pre> 
<p>两个命令都可以使用终止<code>ctrl-D</code>.</p> 
<p>大家也可以试一下,这个也行,cat file文件还可以查看内容~~~</p> 
<p>当然,我最后用的还是adb pull到本地,修改后直接adb push~</p> 
<p><img alt="" height="118" src="https://images2.imgbox.com/d7/d3/LjBJ6gIv_o.jpg" width="124"></p> 
<p></p> 
<h4>5.测试一下</h4> 
<p>这个时候直接新开一个命令窗口,直接adb connect IP:5555,好吧,我尝试的第一次没反应,然后我直接adb  reboot,重启之后重新adb connect IP:5555,竟然真的成功了!然后我重新关机重启,还是可以的,</p> 
<h4>6.收尾操作</h4> 
<p>为了设备安全,我们功能完成之后别忘了恢复只读权限</p> 
<pre><code>//设置可读写权限
# mount -o rw,remount /system

//恢复只可读
# mount -o ro,remount /system</code></pre> 
<p>至此,就算结束了,重启手机还是会生效的</p> 
<h4>7.代码实现(还未实现)</h4> 
<p>下面是我打算用代码/程序实现该功能的草稿,下面的函数方法去实现(主要方法)</p> 
<pre><code>public void openPort5555()
{
    try 
    {
        String cmds[] = {
            "setprop service.adb.tcp.port 5555",
            "stop adbd",
            "start adbd"
        };
        for (int i = 0; i &lt; cmds.length; i++)
        {
            java.lang.Process process = Runtime.getRuntime().exec(cmds[i]);
            int exitCode = process.waitFor();
            if (exitCode != 0) 
            {
                throw new java.io.IOException("Command exited with " + exitCode);
            }
        }
        Toast.makeText(this, "Listening on port 55555...", Toast.LENGTH_LONG).show();
    } 
    catch (Exception ex) 
    {
        ex.printStackTrace();
        Toast.makeText(this, "An error has occurred: " + ex, Toast.LENGTH_LONG).show();
        
    }
}</code></pre> 
<p>大家可以尝试一下;</p> 
<p></p> 
<h4>8.drwxrwxrwx</h4> 
<blockquote> 
 <p>前面的 d 表示这是一个文件夹，后面的 rwxrwxrwx 则表示文件夹的权限：</p> 
 <p>第 1 个字符表示文件类型（d 表示目录，- 表示普通文件）<br> 第 2~4 个字符表示文件所有者的权限（rwx 表示可读、可写、可执行）<br> 第 5~7 个字符表示文件所在组的权限（rwx 表示可读、可写、可执行）<br> 第 8~10 个字符表示其他用户的权限（rwx 表示可读、可写、可执行）<br> 在这个例子中，文件夹 /sdcard/myfolder 的权限为可读、可写、可执行，无论是文件所有者、文件所在组还是其他用户。</p> 
 <p>在 Linux 系统中，文件和目录都有属主（owner）和属组（group）。</p> 
 <p>文件所有者（owner）指的是文件或目录的拥有者，拥有者有最高的权限，可以对文件或目录进行任何操作。</p> 
 <p>文件所在组（group）指的是文件或目录所属的组，该组中的用户具有一定的权限，能对文件或目录进行特定的操作。</p> 
 <p>其他用户指的是除了文件所有者和文件所在组的其他用户，这些用户通常拥有最低的权限，只能进行特定的操作。</p> 
 <p>Linux 系统中的文件和目录权限是以用户身份和用户组身份来区分的，每个文件或目录都有三组权限，分别是文件所有者的权限、文件所在组的权限和其他用户的权限。</p> 
</blockquote> 
<p>第8项 属于水文字的,大家了解一下知识点就可以了,关于第7项,之后我会再继续尝试一下实现的;</p> 
<p><img alt="" height="102" src="https://images2.imgbox.com/78/97/J9QFHayE_o.png" width="100"></p> 
<p></p> 
<p>参考资料:</p> 
<p>https://blog.csdn.net/baidu_38661691/article/details/107481148<br> https://blog.csdn.net/u013168615/article/details/128560120</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/35fe38a5c5705cd1683361faa1f67568/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JavaOpenCV相似度计算基础教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/508311ef65a6b888c67d706744b7fe56/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">个人开发中常见单词拼错错误纠正</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>