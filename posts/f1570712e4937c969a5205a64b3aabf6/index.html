<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Pytest——Fixture夹具的使用 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Pytest——Fixture夹具的使用" />
<meta property="og:description" content="一、什么是Fixture 在测试开展的过程中，会需要考虑到测试前的准备工作，以及测试后的释放操作行为。这些在Pytest中，会通过Fixture的方式来实现。如果说在运行pytest的测试用例的时候，需要调用一些数据来实现测试行为，这些数据可以通过Fixture来生成。Fixture也叫夹具。
二、Fixture的基本应用 2.1单个Fixture的使用 1. Fixture在pytest之中都是基于装饰器的形态来实现的。@pytest.fixture
2. fixture是对函数进行定义的操作。使用fixture非常简单，只需要将fixture当做参数传入函数即可
3. 在pytest中，调用Fixture直接通过函数的名称即可。
4. 一个pytest中可以定义非常多个fixture，来满足到不同的用例的需要。
首先定义一个构造函数，定义一个fixture,返回human对象。调用fixture生成数据内容，可以生成一个man. class Human: #定义一个构造函数 def __init__(self,name): self.name = name #定义一个fixture,返回一个human对象，名字叫做man @pytest.fixture def man(): return Human(&#39;man&#39;) #调用fixture生成的数据内容 def test_function(man): print(man.name) if __name__ == &#39;__main__&#39;: pytest.main([&#39;-s&#39;]) 查看结果：
2.2多个Fixture的使用 在unitTest中，一般只有一个前置条件，但是在pytest可以有多个夹具，也就是fixture
class Human: #定义一个构造函数 def __init__(self,name): self.name = name #定义一个fixture,返回一个human对象，名字叫做man @pytest.fixture def man(): return Human(&#39;man&#39;) @pytest.fixture def woman(): return Human(&#39;woman&#39;) # 定义一个调用fixture的fixture @pytest.fixture def people(man, woman): return [man, woman] #调用fixture生成的数据内容 def test_function_01(man): print(man." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f1570712e4937c969a5205a64b3aabf6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-01T17:57:09+08:00" />
<meta property="article:modified_time" content="2024-01-01T17:57:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Pytest——Fixture夹具的使用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、什么是Fixture</h3> 
<p>在测试开展的过程中，会需要考虑到测试前的准备工作，以及测试后的释放操作行为。这些在Pytest中，会通过Fixture的方式来实现。如果说在运行pytest的测试用例的时候，需要调用一些数据来实现测试行为，这些数据可以通过Fixture来生成。<strong>Fixture也叫夹具</strong>。</p> 
<hr> 
<h3>二、Fixture的基本应用 </h3> 
<h3>2.1单个Fixture的使用</h3> 
<blockquote> 
 <p>1. Fixture在pytest之中都是基于装饰器的形态来实现的。@pytest.fixture</p> 
 <p>2. fixture是对函数进行定义的操作。使用fixture非常简单，<span style="color:#fe2c24;">只需要将fixture当做参数传入函数即可</span></p> 
 <p>3. 在pytest中，调用Fixture直接通过函数的名称即可。</p> 
 <p>4. 一个pytest中可以定义非常多个fixture，来满足到不同的用例的需要。</p> 
</blockquote> 
<p>首先定义一个构造函数，定义一个fixture,返回human对象。调用fixture生成数据内容，可以生成一个man. </p> 
<pre><code>class Human:
    #定义一个构造函数
    def __init__(self,name):
        self.name = name
   

#定义一个fixture,返回一个human对象，名字叫做man
@pytest.fixture
def man():
    return Human('man')
#调用fixture生成的数据内容
def test_function(man):
    print(man.name)

if __name__ == '__main__':
    pytest.main(['-s'])</code></pre> 
<p> 查看结果：</p> 
<p><img alt="" height="420" src="https://images2.imgbox.com/cf/fc/LqOfE9f1_o.png" width="1056"></p> 
<p>  </p> 
<hr> 
<h3>2.2多个Fixture的使用 </h3> 
<p>在unitTest中，一般只有一个前置条件，但是在pytest可以有多个夹具，也就是fixture</p> 
<pre><code>class Human:
    #定义一个构造函数
    def __init__(self,name):
        self.name = name
   
#定义一个fixture,返回一个human对象，名字叫做man
@pytest.fixture
def man():
    return Human('man')

@pytest.fixture
def woman():
    return Human('woman')


# 定义一个调用fixture的fixture
@pytest.fixture
def people(man, woman):
    return [man, woman]

#调用fixture生成的数据内容
def test_function_01(man):
    print(man.name)

def test_function_02(woman):
    print(woman.name)
</code></pre> 
<p>不同函数可以引用不同夹具，所以这里可以打印出man和woman的名字</p> 
<p><img alt="" height="520" src="https://images2.imgbox.com/16/eb/j3Kwq50b_o.png" width="1200"></p> 
<hr> 
<h3>2.3Fixture中引用Fixture的使用 </h3> 
<p>在pytest中甚至可以在夹具中引用夹具 ，通过一个统一的类，来管理夹具。并且来满足不同测试用例的需求。</p> 
<pre><code>class Human:
    #定义一个构造函数
    def __init__(self,name):
        self.name = name
    #定义类的比较规则
    def __eq__(self, other):
       return self.name == other.name

#定义一个fixture,返回一个human对象，名字叫做man
@pytest.fixture
def man():
    return Human('man')

@pytest.fixture
def woman():
    return Human('woman')


# 定义一个调用fixture的fixture
@pytest.fixture
def people(man, woman):
    return [man, woman]


 def test_function_03(people):
   for p in people:
       print(p.name)</code></pre> 
<p> 依然能打印出man和woman：</p> 
<p><img alt="" height="472" src="https://images2.imgbox.com/d6/e0/diA7tcSo_o.png" width="1196"></p> 
<hr> 
<h3> 三、Fixture的运行机制</h3> 
<blockquote> 
 <p>1. fixture缓存机制，在用例之中，fixture可以被多次请求，在pytest之中，fixture第一次被请求后， 如果有返回值，则后续继续调用该fixture的时候，会调用第一次生成的值，而不会再重新运行。</p> 
 <p>2. autouse可以实现让定义了autouse的fixture在每一个测试用例执行前都调用此fixture，就不需要在 每一个测试用例之中都传入该fixture作为参数，减少了不必要的操作行为</p> 
 <p>3. 报错机制：fixture本身是属于我们自定义的函数，所以在运行过程中也会存在有出现报错的风险。</p> 
 <p>在实际 运行过程中，很有可能因为关联的fixture导致了一系列不可预见的问题产生。</p> 
 <p>在pytest之中，如果说与用例相关联的fixture出现了报错，pytest会将当前用例停止执行，并标记为 错误状态。要记得，错误状态不是failed状态，所以并不能表示用例是不通过的。只能够说明是用例关联 的fixture出现了问题，用例本身没有发现任何错误。 所以要明白，在fixture的设计的时候，需要尽可能减少fixture之间的依赖关系，避免因为一个fixture 出现问题导致大批fixture失效。</p> 
</blockquote> 
<h3> 3.1Fixture缓存机制</h3> 
<p>fixture缓存机制，在用例之中，fixture可以被多次请求，在pytest之中，fixture第一次被请求后， 如果有返回值，则后续继续调用该fixture的时候，会调用第一次生成的值，而不会再重新运行。</p> 
<pre><code>import pytest

@pytest.fixture
def first():
    return 'a'
@pytest.fixture
def second():
    return []
@pytest.fixture
def third(first,second):
    return second.append(first)

def test_function(first,second,third):
    print(first)
    print(second)

if __name__ == '__main__':
    pytest.main(['-s'])</code></pre> 
<blockquote> 
 <p>这里first夹具，是返回'a'的操作，second夹具是返回空[]的操作，third夹具是将'a'放入空[]的操作。</p> 
 <p>打印first和second中按理说应该打印'a'和[],但是打印出了['a']。主要是由于test_function()测试用例</p> 
 <p>中，传入了third夹具，已经存在['a']的缓存。所以在打印second的时候，可以直接打印出['a']。</p> 
</blockquote> 
<hr> 
<h3> 3.2autouse参数的使用</h3> 
<p>在unitTest中,如果每个测试用例都会用到某些前置条件或者后置条件，可以通过setUp或者tearDown实现。pytest中也可以通过fixture来实现一些前置和后置条件的处理。但是在每个测试用例都传入fixture不方便，可以使用autouse来解决这个问题。</p> 
<p><span style="color:#fe2c24;">autouse可以实现让定义了autouse的fixture在每一个测试用例执行前都调用此fixture</span>，就不需要在 每一个测试用例之中都传入该fixture作为参数，减少了不必要的操作行为</p> 
<pre><code>
import pytest

@pytest.fixture
def first():
    return 'a'
@pytest.fixture
def second():
    return []
@pytest.fixture(autouse=True)
def third(first,second):
    return second.append(first)

def test_function(first,second):
    print(first)
    print(second)

if __name__ == '__main__':
    pytest.main(['-s'])
    </code></pre> 
<blockquote> 
 <p>在third夹具中定义了autouse参数,设置为True。在测试用例test_function中并没有调用third 夹具，理论上打印second是不会打印出['a']的。但是由于antouse，autouse的fixture在每一个测试用例执行前都调用此fixture，所以third夹具运行之后，second就变成了['a'],所以打印结果是['a']。</p> 
</blockquote> 
<hr> 
<h3>3.3Fixture报错机制</h3> 
<p>报错机制：fixture本身是属于我们自定义的函数，所以在运行过程中也会存在有出现报错的风险。在实际 运行过程中，很有可能因为关联的fixture导致了一系列不可预见的问题产生。 </p> 
<p> <span style="color:#fe2c24;">在pytest之中，如果说与用例相关联的fixture出现了报错，pytest会将当前用例停止执行，并标记为 错误状态。</span></p> 
<p> 错误状态不是failed状态，所以并不能表示用例是不通过的。只能够说明是用例关联 的fixture出现了问题，用例本身没有发现任何错误。</p> 
<pre><code>@pytest.fixture
def first():
    return 1/0
#这是一个会报错的fixture
def test_function(first):
    print('这是test_function')
#这是一个会报错的测试用例
def test_function_01():
    1/0

if __name__ == '__main__':
    pytest.main()
</code></pre> 
<p> 两个测试用例，一个是调用了会报错的fixture，一个是会报错的测试用例。调用了会报错的fixture运行结果是error,会报错的测试用例运行结果是error。<img alt="" height="802" src="https://images2.imgbox.com/fb/27/TPiF6QT4_o.png" width="1200"></p> 
<hr> 
<h3>3.4Fixture的setup操作</h3> 
<p> 这是fixture的setup操作：<br>         pytest启动运行会生成对应的<span style="color:#fe2c24;">session对象</span>，本次执行的所有内容都会存放到session当中。<br>         所以setup分级：<br>             session -&gt; module -&gt; class -&gt; function<br>         所有的setup定级需要在fixture之中传入一个参数，叫做scope，默认为function<br>         session级别的setup需要在conftest.py文件中进行定义。 </p> 
<pre><code>#定义函数级别的setup
import pytest

# 定义函数级别的setup
@pytest.fixture(scope='function')
def function():
    print('this is function level')
# 定义class级别的setup
@pytest.fixture(scope='class')
def class_():
    print('this is class level')
# 定义py文件级别的setup
@pytest.fixture(scope='module')
def module():
    print('this is module level')
    
def test_function(function):
    print('这是test_function')
if __name__ == '__main__':
    pytest.main(['-sv'])
</code></pre> 
<p> 通过不同的参数，就可以实现不同级别的setup的实现。</p> 
<hr> 
<h3 style="background-color:transparent;">3.5Fixture的teardown操作</h3> 
<h4>3.5.1实现方法一<span style="color:#0d0016;"> ：关键字yield</span></h4> 
<p> 可以通过Fixture来实现teardown的操作。通过调用<span style="color:#fe2c24;">关键字yield</span>实现teardown的操作需要 函数中有return的关键字。通过调用return，结束函数的运行，并返回一个对象。 <strong><span style="color:#956fe7;">函数中的yield是迭代器，在函数运行的时候，如果需要返回一个对象，但同时又需要函数能够继续运行</span>。</strong> yield实现的teardown只能满足基本的需求，如果说Fixture在运行的时候报错了，yield就相对不会友好了。</p> 
<pre><code>import pytest

@pytest.fixture(scope='function')
def first():
    print('this is setup')
    yield
    print('this is teardown')

def test_function(first):
    print('this is a test_case')</code></pre> 
<p> 基于以上描述，可以知道应该先执行yield的代码，再执行测试用例，然后再执行yield后面的代码，观察运行结果，符合推理。</p> 
<p><img alt="" height="602" src="https://images2.imgbox.com/d0/d2/Rhl7nR81_o.png" width="1200"></p> 
<p> teardown只能满足基本的需求，如果说Fixture在运行的时候报错了，yield就相对不会友好了。</p> 
<hr> 
<p></p> 
<h4>3.5.2实现方法二  ：定义requests.addfinalizer</h4> 
<p>通过在Fixture中<span style="color:#fe2c24;">定义requests.addfinalizer</span>来实现。 此方法是通过<strong>在Fixture中进行注册</strong>的行为，来让程序运行结束时调用，实现teardown的相关操作。为了 避免因为Fixture报错，导致的代码无法正常运行，所以建议teardown的内容写在函数的最开始的位置。 </p> 
<pre><code># 基于request.addfinalizer实现的teardown：request是固定写法，名称不能改变
@pytest.fixture
def second(request):
    #实现teardown的内容
    def second_finalizer():
        print('this is a finalizer')
    #注册teardown函数，实现fixture的teardown操作
    request.addfinalizer(second_finalizer)
    #正常定义setup行为
    print('this is a setup')
def test_function(second):
    print('this is a test_case')</code></pre> 
<p>将teardown内容定义成一个类似装饰器的函数，通过在Fixture中<span style="color:#fe2c24;">定义requests.addfinalizer</span><span style="color:#0d0016;">将函数注册</span>来实现。查看结果:<img alt="" height="556" src="https://images2.imgbox.com/b0/f8/OEeuRbS6_o.png" width="1062"></p> 
<hr> 
<h3>3.6 fixture参数的传入</h3> 
<p>fixture在特定场景下需要进行参数的传入。来实现Fixture代码的正常运行。<br> 通过<span style="color:#fe2c24;">装饰器parametrize</span>实现。</p> 
<p><span style="color:#fe2c24;">通过request参数来接收fixture中可能传入的参数内容，定义参数，传入到fixture之中</span>，一定要记得添加indirect参数为True，意思就是将参数名称识别为fixture</p> 
<pre><code class="hljs"># 定义参数，传入到fixture之中，一定要记得添加indirect参数为True，意思就是将参数名称识别为fixture
@pytest.mark.parametrize('login', [{'by': 'id', 'value': 'kw', 'txt': 'hcc'}], indirect=True)
@pytest.mark.parametrize('data', 'a')
def test_function(login, data):
    # login.find_element('id', 'su').click()


# 通过request参数来接收fixture中可能传入的参数内容
# request可以接收任何格式的参数，不管是常用数据类型还是通过文件传入
@pytest.fixture
def login(request):
     print(data)</code></pre> 
<p> </p> 
<h3>3.7 conftest——fixture统一管理</h3> 
<pre>conftest.py文件的文件名是固定的，不能够修改。否则pytest会找不到，他相当于是一个Fixture的仓库，专门存放工程中的Fixture内容。便于在测试过程中
进行有效的统一管理和维护。
</pre> 
<blockquote> 
 <pre>1. conftest.py文件的作用范围是文件所在的当前文件夹以及子文件夹。如果想要在整个工程都生效，则需要放到工程的根路径下。
2. conftest.py本身是pytest已定义好的，所以修改名称之后，pytest无法再找到你所设定文件，从而读取文件内容会失败。
    conftest.py<strong>是专门用来管理Fixture的文件</strong>。可以在conftest.py文件中将需要的Fixture全部定义好，<span style="color:#fe2c24;"><strong>在测试用例文件中，直接通过Fixture的名字来实现对它内容的调用。</strong></span>
3. 在conftest.py中定义的Fixture内容，可以在有效范围内被其他的测试用例所直接调用。不需要再进行额外的定义了。
4. conftest.py文件本身属于hook函数类型，我们也可以在这个文件中编写其他的hook函数。实现对pytest已有功能的增强。
5. session级别的Fixture必须要在conftest.py文件中定义。</pre> 
</blockquote> 
<hr> 
<h3>3.8 ini文件 </h3> 
<pre>文件是专门用来配置pytest的使用，如果要定义<u><strong>pytest相关的全局配置</strong></u>，都会使用这个文件来实现。
该文件推荐放在工程的根路径下。
<span style="color:#fe2c24;">pytest.ini的名称是固定写法</span>，无法被更改。如果输入的指令在pytest.ini文件中已经定义了。
则新的指令会覆盖旧的指令。配置文件都是key:value形式。
</pre> 
<pre><code>[pytest]
# 定义mark标签
markers =
    hcc: 这是hcc的标签
    xzl: 这是xzl的标签
#将所有xfail装饰器的strict参数修改为指定的默认值。
xfail_strict = True
# 设置用例读取路径以及文件以及文件名称等相关的读取配置
testpaths = ./
python_files = test_*.py
python_classes = test_*
python_functions = test_*

# 执行指令
addopts = -s -v -m xzl

# 日志：在pytest之中，本身有定义日志记录的功能，我们可以在每次执行测试用例的时候，添加日志的记录。
#   在pytest中日志只能覆盖，不能追加
log_cli = True
log_cli_level = DEBUG
log_cli_date_format = %Y-%m-%d-%H:%M:%S
log_cli_format = %(levelname)s-%(asctime)s-%(filename)s-%(module)s-%(funcName)s-%(lineno)s:%(message)s
log_file = test.log</code></pre> 
<pre>涉及到全局的变量，只要在ini文件中进行更改即可。
 </pre> 
<h3></h3> 
<pre></pre> 
<h3></h3> 
<h3></h3> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/817ea1bf4cc8dfdfb917ea77c81af91f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【STM32】STM32学习笔记-TIM输入捕获(17)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8f8b1aad4a1c2b5af7317639e1ed1105/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">听GPT 讲Rust源代码--library/alloc</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>