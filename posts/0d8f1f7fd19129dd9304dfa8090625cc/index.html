<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>acwing蓝桥杯c&#43;&#43;A/B组辅导课--第六讲双指针、BFS与图论 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="acwing蓝桥杯c&#43;&#43;A/B组辅导课--第六讲双指针、BFS与图论" />
<meta property="og:description" content="1.日志统计 法1： 用双指针i,j枚举时间段，如果i-j&gt;=d，就将超出范围的cnt[]--，且j&#43;&#43;，这样就会始终有一个长度为d的区间
vector&lt;int&gt; f[t] 记录了在t时刻里获赞的所有编号
#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e5&#43;10; vector&lt;int&gt; f[N];//f[t]记录了所有在t时刻获赞的编号 int cnt[N];//cnt[id]表示id的获赞数,是动态的,超过了时间长度d会-- bool st[N];//st[id]判断编号id是不是热帖 int main() { int n,d,k; cin&gt;&gt;n&gt;&gt;d&gt;&gt;k; for(int i=0;i&lt;n;i&#43;&#43;) { int ts,id; cin&gt;&gt;ts&gt;&gt;id; f[ts].push_back(id); } for(int i=0,j=0;i&lt;=1e5;i&#43;&#43;)//i,j维护一个长度为d的时间区间 { if(i-j&gt;=d)//长度超过d了,原来j时刻的那些获赞就会-- { for(auto x:f[j]) { cnt[x]--; } j&#43;&#43;; } for(auto x:f[i])//遍历所有在i时刻获赞的编号 { cnt[x]&#43;&#43;; if(cnt[x]&gt;=k) st[x]=true;//如果长度一旦&gt;=k,就说明曾经是热帖 } } for(int i=0;i&lt;N;i&#43;&#43;) { if(st[i]) cout&lt;&lt;i&lt;&lt;endl; } return 0; } 法2： pair&lt;int，int&gt; logs记录 ，获赞时刻和id" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0d8f1f7fd19129dd9304dfa8090625cc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-20T09:25:03+08:00" />
<meta property="article:modified_time" content="2022-03-20T09:25:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">acwing蓝桥杯c&#43;&#43;A/B组辅导课--第六讲双指针、BFS与图论</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.日志统计</h2> 
<p></p> 
<h3>法1：</h3> 
<p>用双指针i,j枚举时间段，如果i-j&gt;=d，就将超出范围的cnt[]--，且j++，这样就会始终有一个长度为d的区间</p> 
<p>vector&lt;int&gt; f[t] 记录了在t时刻里获赞的所有编号</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 1e5+10;
vector&lt;int&gt; f[N];//f[t]记录了所有在t时刻获赞的编号
int cnt[N];//cnt[id]表示id的获赞数,是动态的,超过了时间长度d会--
bool st[N];//st[id]判断编号id是不是热帖
int main()
{
    int n,d,k;
    cin&gt;&gt;n&gt;&gt;d&gt;&gt;k;
    for(int i=0;i&lt;n;i++)
    {
        int ts,id;
        cin&gt;&gt;ts&gt;&gt;id;
        f[ts].push_back(id);
    }
    for(int i=0,j=0;i&lt;=1e5;i++)//i,j维护一个长度为d的时间区间
    {
        if(i-j&gt;=d)//长度超过d了,原来j时刻的那些获赞就会--
        {
            for(auto x:f[j])
            {
                cnt[x]--;
            }
            j++;
        }
        for(auto x:f[i])//遍历所有在i时刻获赞的编号
        {
            cnt[x]++;
            if(cnt[x]&gt;=k) st[x]=true;//如果长度一旦&gt;=k,就说明曾经是热帖
        }
    }
    for(int i=0;i&lt;N;i++)
    {
        if(st[i]) cout&lt;&lt;i&lt;&lt;endl;
    }
    return 0;
}</code></pre> 
<h3>法2：</h3> 
<p>pair&lt;int，int&gt; logs记录 ，获赞时刻和id</p> 
<p>将所有logs排个序，pair会按照先first再second的顺序排，即先按时刻排序，时刻相同再按编号排序。枚举所有的logs记录，i在前j在后，是两条记录，如果这两条记录的时间跨度&gt;=d了，则cnt[logs[j].id]--，j往后走，直到两条记录的时间跨度&lt;d。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 1e5+10;
int n,d,k;
typedef pair&lt;int, int&gt; PII;
#define x first
#define y second
PII logs[N];//记录每条获赞记录的时刻和编号
int cnt[N];//记录每条记录的当前的获赞数量,动态变化,一旦时间跨度&gt;=d就--
bool st[N];//记录是否是热帖

int main()
{
    cin&gt;&gt;n&gt;&gt;d&gt;&gt;k;
    for(int i=0;i&lt;n;i++)
    {
        int ts,id;
        cin&gt;&gt;ts&gt;&gt;id;
        logs[i]={ts,id};
    }
    sort(logs,logs+n);
    for(int i=0,j=0;i&lt;n;i++)//枚举每两条时间跨度&lt;d的记录
    {
        while(logs[i].x-logs[j].x&gt;=d)
        {
            cnt[logs[j].y]--;
            j++;
        }
        cnt[logs[i].y]++;
        if(cnt[logs[i].y]&gt;=k)
        {
            st[logs[i].y]=true;
        }
    }
    for(int i=0;i&lt;N;i++)
    {
        if(st[i]) cout&lt;&lt;i&lt;&lt;endl;
    }
    return 0;
}</code></pre> 
<h3>2.献给阿尔吉侬的花束</h3> 
<p>板子题，直接看代码注释即可</p> 
<pre><code class="language-cpp">/*
从起点S开始走,走到E结束,看看最短距离,由于有障碍物的阻隔,可能会走不到E点
*/
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
using namespace std;
#define x first
#define y second
typedef pair&lt;int, int&gt; PII;
const int N = 210;
char g[N][N];
int dist[N][N];//dist(i,j)表示(i,j)到起点的距离
int n,m;

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

int bfs(int sx,int sy,int ex,int ey)
{
    memset(dist,-1,sizeof dist);//dist为-1表示还没更新或者根本到不了
    dist[sx][sy]=0;
    queue&lt;PII&gt; q;
    q.push({sx,sy});
    
    while(q.size())
    {
        PII t=q.front();
        q.pop();
        
        for(int i=0;i&lt;4;i++)
        {
            int x=t.x+dx[i],y=t.y+dy[i];
            if(x&lt;0||x&gt;=n||y&lt;0||y&gt;=m) continue;
            if(g[x][y]=='#') continue;
            if(dist[x][y]!=-1) continue;
            
            dist[x][y]=dist[t.x][t.y]+1;
            if(x==ex&amp;y==ey) return dist[x][y];
            q.push({x,y});
        }
    }
    return -1;
}
int main()
{
    int T;
    cin&gt;&gt;T;
    while(T--)
    {
        cin&gt;&gt;n&gt;&gt;m;
        for(int i=0;i&lt;n;i++) cin&gt;&gt;g[i];
        //找起点终点
        int sx,sy,ex,ey;
        for(int i=0;i&lt;n;i++)
        {
            for(int j=0;j&lt;m;j++)
            {
                if(g[i][j]=='S') sx=i,sy=j;
                if(g[i][j]=='E') ex=i,ey=j;
            }
        }
        int d=bfs(sx,sy,ex,ey);
        if(d==-1) cout&lt;&lt;"oop!"&lt;&lt;endl;
        else cout&lt;&lt;d&lt;&lt;endl;
    }
    return 0;
}</code></pre> 
<h2> 3.红与黑</h2> 
<h3>1.dfs代码</h3> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 25;
int n,m;
char g[N][N];
bool st[N][N];

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

int dfs(int x,int y)
{
    int cnt=1;
    st[x][y]=true;
    for(int i=0;i&lt;4;i++)
    {
        int a=x+dx[i],b=y+dy[i];
        if(a&gt;=0 &amp;&amp; a&lt;m &amp;&amp; b&gt;=0 &amp;&amp; b&lt;n &amp;&amp; g[a][b]=='.' &amp;&amp; !st[a][b]) 
        {
            cnt+=dfs(a,b);
        }
    }
    return cnt;
}
int main()
{
    while (cin&gt;&gt;n&gt;&gt;m,m||n)
    {
        for(int i=0;i&lt;m;i++) cin&gt;&gt;g[i];
    
        //找起点
        int sx,sy;
        for(int i=0;i&lt;m;i++)
        {
            for(int j=0;j&lt;n;j++)
            {
                if(g[i][j]=='@') 
                {
                    sx=i;
                    sy=j;
                    break;
                }
            }
        }
        memset(st, 0, sizeof st);//记得每次结束后更新st
        cout&lt;&lt;dfs(sx,sy)&lt;&lt;endl;
    }
    return 0;
}</code></pre> 
<h3>2.bfs代码</h3> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
using namespace std;
typedef pair&lt;int, int&gt; PII;
#define x first
#define y second
const int N = 25;
int n,m;
char g[N][N];
bool st[N][N];
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

int bfs(int sx,int sy)
{
    int ans=1;
    queue&lt;PII&gt; q;
    q.push({sx,sy});
    st[sx][sy]=true;
    
    while(q.size())
    {
        PII t=q.front();
        
        q.pop();
        
        for(int i=0;i&lt;4;i++)
        {
            int a=t.x+dx[i],b=t.y+dy[i];
            if(a&lt;0||a&gt;=m||b&lt;0||b&gt;=n) continue;
            if(g[a][b]=='#') continue;
            if(st[a][b]) continue;
            ans++;
            q.push({a,b});
            st[a][b]=true;
        }
    }
    return ans;
}
int main()
{
    while(cin&gt;&gt;n&gt;&gt;m,n||m)
    {
        for(int i=0;i&lt;m;i++) cin&gt;&gt;g[i];
        int sx,sy;
        for(int i=0;i&lt;m;i++)
        {
            for(int j=0;j&lt;n;j++)
            {
                if(g[i][j]=='@')
                {
                    sx=i;
                    sy=j;
                    break;
                }
            }
        }
        cout&lt;&lt;bfs(sx,sy)&lt;&lt;endl;
        memset(st,0,sizeof st);
    }
    return 0;
}</code></pre> 
<h2>4.交换瓶子</h2> 
<p>置换群法:</p> 
<p>每个瓶子向它应该在的位置连一条边</p> 
<p><img alt="" height="401" src="https://images2.imgbox.com/58/91/yoFeadtz_o.png" width="1095"></p> 
<p>如图所示 瓶子3应该在位置3,当前位置3放的是瓶子2,所以3和2之间连边</p> 
<p>瓶子1应该在位置1，但现在位置1放的是瓶子3，所以1和3连边</p> 
<p>瓶子2本应该放在位置2，但现在位置2放的是瓶子1，所以2和1连边</p> 
<p>4，5同理</p> 
<p>一共n个点，连n条边 </p> 
<p> 当前图的性质 n个点，n条边，每个点出度入度都为1</p> 
<p>这样的图必然是一堆环，称为一个置换</p> 
<p></p> 
<p>我们希望最终变成的是n个自环，每个点指向自己</p> 
<p>初始环k个。终点环n个</p> 
<p></p> 
<p><strong>情况1：交换同一个环内的点</strong></p> 
<p>环外的点没有任何变化</p> 
<p>环内会裂开成俩环（这是因为两个点的出边改变了），环的数量+1</p> 
<p>如图：交换1,3</p> 
<p><img alt="" height="256" src="https://images2.imgbox.com/07/4d/ATUOSM0J_o.png" width="925"></p> 
<p><strong>情况2：交换不同环内的点 </strong></p> 
<p><img alt="" height="314" src="https://images2.imgbox.com/fe/e1/eaEwDn0f_o.png" width="904"></p> 
<p>结果会是将两个环合并</p> 
<p> 综上：</p> 
<p>我们每次操作都会是把两个环合并成1个或者是把一个环分裂</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 10010;
bool st[N];//找环
int b[N];
int n;
int main()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++) cin&gt;&gt;b[i];
    int cnt=0;
    for(int i=1;i&lt;=n;i++)
    {
        if(!st[i])//在一个新的环里面
        {
            cnt++;
            for(int j=i;!st[j];j=b[j])//j指向的是j位置的这个瓶子b[j]
            {
                st[j]=true;
            }
        }
    }
    cout&lt;&lt;n-cnt&lt;&lt;endl;
    return 0;
}</code></pre> 
<p>成2个</p> 
<p>初始k个环，最终n个环，每次操作最多增加一个环，所以最少n-k次操作</p> 
<h2>5.完全二叉树的权值</h2> 
<p>完全二叉树:<br> 第i层的开头下标是2^(i-1)次方,结尾是2^i-1</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 1e5+10;
int a[N];
int Log[N];

int main()
{
    int n;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];
    long long maxv=-1e18;
    int i=1,d=1;
    int ans=1;
    while(i&lt;=n)
    {
        long long s=0;
        while(i &lt;= ((1&lt;&lt;d)-1))
        {
            s+=a[i];
            i++;
        }
        if(s&gt;maxv) 
        {
            maxv=s;
            ans=d;
        }
        d++;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}</code></pre> 
<h2>6.地牢大师</h2> 
<p>和之前的题一样,只不过从2维变成了3维<br> 结构体存坐标(x,y,z)<br> 先找起点,终点,用bfs搜索路径</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
using namespace std;
const int N = 110;
char g[N][N][N];
int dist[N][N][N];//存储(x,y,z)到起点的最短距离
int dx[6]={1,-1,0,0,0,0};
int dy[6]={0,0,1,-1,0,0};
int dz[6]={0,0,0,0,1,-1};
struct Point{
    int x,y,z;
};
int l,r,c;

int bfs(Point start,Point end)
{
    memset(dist,-1,sizeof dist);//dist为-1说明还没更新,或者有阻挡到不了
    dist[start.x][start.y][start.z]=0;
    queue&lt;Point&gt; q;
    q.push(start);
    while(q.size())
    {
        Point t=q.front();
        q.pop();
        for(int i=0;i&lt;6;i++)
        {
            int x=t.x+dx[i],y=t.y+dy[i],z=t.z+dz[i];
            if(x&lt;0||x&gt;=l||y&lt;0||y&gt;=r||z&lt;0||z&gt;=c) continue;
            if(g[x][y][z]=='#') continue;
            if(dist[x][y][z]!=-1) continue;
            dist[x][y][z]=dist[t.x][t.y][t.z]+1;
            if(x==end.x&amp;&amp;y==end.y&amp;&amp;z==end.z) return dist[x][y][z];
            q.push({x,y,z});
        }
    }
    return -1;
}
int main()
{
    Point start,end;
    while(cin&gt;&gt;l&gt;&gt;r&gt;&gt;c,l||r||c)
    {
        for(int i=0;i&lt;l;i++)
        {
            for(int j=0;j&lt;r;j++)
            {
                for(int k=0;k&lt;c;k++)
                {
                    cin&gt;&gt;g[i][j][k];
                    if(g[i][j][k]=='S') start={i,j,k};
                    else if(g[i][j][k]=='E') end={i,j,k};
                }
            }
        }
        if(bfs(start,end)==-1) cout&lt;&lt;"Trapped!"&lt;&lt;endl;
        else cout&lt;&lt;"Escaped in "&lt;&lt;bfs(start,end)&lt;&lt;" minute(s)."&lt;&lt;endl;
    }
    return 0;
}</code></pre> 
<h2>7.全球变暖 </h2> 
<p>用1个total来记录连通块中点的个数<br> 用1个bound来记录被淹没的点的数量(一个点周围有'.'即被淹没)<br> 如果bound==total则这个岛屿全部被淹没掉</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
using namespace std;
const int N = 1010;
typedef pair&lt;int, int&gt; PII;
#define x first
#define y second
int n;
char g[N][N];
bool st[N][N];//此处st标记已经遍历过的陆地'#'
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

void bfs(int x,int y,int&amp; total,int&amp; bound)
{
    queue&lt;PII&gt; q;
    q.push({x,y});
    st[x][y]=true;
    
    while(q.size())
    {
        PII t=q.front();
        q.pop();
        total++;//记录连通块中点的个数
        bool flag=false;//表示这个岛屿是否被淹没
        
        for(int i=0;i&lt;4;i++)
        {
            int x=t.x+dx[i],y=t.y+dy[i];
            if(x&lt;0||x&gt;=n||y&lt;0||y&gt;=n) continue;
            if(g[x][y]=='.')//周围这个点是大海,标记一下已沉没
            {
                flag=true;
                continue;
            }
            if(st[x][y]) continue;//如果周围这个点是陆地,且已经遍历过,就不用放在q中
            q.push({x,y});
            st[x][y]=true;
        }
        if(flag) bound++;
    }
}

int main()
{
    cin&gt;&gt;n;
    int res=0;
    for(int i=0;i&lt;n;i++) cin&gt;&gt;g[i];
    
    for(int i=0;i&lt;n;i++)
    {
        for(int j=0;j&lt;n;j++)
        {
            if(g[i][j]=='#'&amp;&amp;!st[i][j])
            {
                int total=0,bound=0;
                bfs(i,j,total,bound);
                //cout&lt;&lt;total&lt;&lt;" "&lt;&lt;bound&lt;&lt;endl;
                if(total==bound) res++;
            }
        }
    }
    cout&lt;&lt;res&lt;&lt;endl;
    return 0;
}</code></pre> 
<h2>8.大臣的旅费</h2> 
<p>求树的直径：</p> 
<p>方法:</p> 
<p>1.任取一点x</p> 
<p>2.找到距离x最远的点y</p> 
<p>3.从y开始再进行一次搜索，找到距离y最远的点，此点距离y的距离就是直径</p> 
<p></p> 
<p>因为y是距离x最远的点，首先它一定是个端点</p> 
<p>证明:y一定是树的直径上的端点</p> 
<p>假设y不是树的直径的端点：</p> 
<p>如下两种情况：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e2/0a/93QSixRk_o.png"></p> 
<h3>情况1：</h3> 
<p>xy这个路径不是树的直径但与树的直径uv有交点</p> 
<p>因为y是距离x最远的点,所以边4+边1&gt;边2+边1,所以边4&gt;边1</p> 
<p>所以边4+边3&gt;边2+边3=uv=树的直径</p> 
<p>所以存在&gt;树的直径的边，显然不可能</p> 
<h3>情况2:</h3> 
<p>xy这个路径不是树的直径且与树的直径uv没有交点</p> 
<p>y是距离x最远的点,所以边3+边5&lt;边2</p> 
<p>所以边5&lt;边2  所以边5&lt;边2+边3</p> 
<p>所以边2+边3+边4&gt;边5+边4=树的直径</p> 
<p>所以存在&gt;树的直径的边，显然不可能</p> 
<p></p> 
<p>因为y是直径一端的端点，所以第二遍距离y点最远的距离就是树的直径的距离</p> 
<p></p> 
<p>最终树的直径是dist的话花费就是</p> 
<p>(1+10)+(2+10)+(3+10)+...+(dist+10)</p> 
<p>=10*dist+(1+dist)*dist/2</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
typedef long long LL;
const int N = 1e5+10,M = 2*N;
int h[N],e[M],ne[M],w[M],idx;
int n;
int dist[N];

void add(int a,int b,int c)
{
    e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
}
void dfs(int u,int distance,int father)
{
    dist[u]=distance;
    for(int i=h[u];i!=-1;i=ne[i])
    {
        int j=e[i];
        if(j!=father)
        {
            dfs(j,distance+w[i],u);
        }
    }
}
int main()
{
    memset(h, -1, sizeof h);
    cin&gt;&gt;n;
    for(int i=0;i&lt;n-1;i++)
    {
        int a,b,c;
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
        add(a, b, c);
        add(b ,a, c);
    }
    int u=1;
    dfs(u,0,-1);
    for(int i=2;i&lt;=n;i++)
    {
        if(dist[i]&gt;dist[u]) u=i;
    }
    dfs(u,0,-1);
    for(int i=1;i&lt;=n;i++)
    {
        if(dist[i]&gt;dist[u]) u=i;
    }
    printf("%lld",dist[u]*10+(LL)(dist[u]+1)*dist[u]/2);
    return 0;
}</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4e128eaeb5c400618b910b7f8003bb41/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Ubuntu解决网络连接优先级</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1feaba9b3b151dd6f19d300858861b26/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c#考试，答题系统制作（窗体）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>