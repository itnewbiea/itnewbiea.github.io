<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;学习笔记 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;学习笔记" />
<meta property="og:description" content="C&#43;&#43;学习笔记 一 .C与C&#43;&#43;区别1.1 const与常量const与指针 1.2 引用（别名）*引用与const 1.3 默认值参数1.4 内联函数1.5 函数重载1.6 C与C&#43;&#43;函数的互相调用1.7 函数摸板数组引用与函数模板 1.8 new与malloc1.9命名空间*C&#43;&#43;中的右值引用 二.面向对象2.1 面向对象2.2 this 指针const与成员方法 2.3构造函数构造函数的类型转化 拷贝构造函数2.4析构函数友元=运算符重载（）运算符重载缺省函数 2.5 C&#43;&#43;中的权限静态成员变量与静态成员方法 三 . 继承与多态3.1继承：同名问题属性同名方法同名 赋值兼容规则 3.2 多态动多态虚函数vftable(虚表)虚表指针_vfptr RTTI菱形继承与虚继承 纯虚函数与抽象类 一 .C与C&#43;&#43;区别 C&#43;&#43;的介绍：
C&#43;&#43;是一种计算机高级程序设计语言，由C语言扩展升级而产生，最早于1979年由本贾尼·斯特劳斯特卢普在AT&amp;T贝尔工作室研发。
C&#43;&#43;既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。C&#43;&#43;擅长面向对象程序设计的同时，还可以进行基于过程的程序设计。
C&#43;&#43;拥有计算机运行的实用性特征，同时还致力于提高大规模程序的编程质量与程序设计语言的问题描述能力。 (来源百度百科)
从上述介绍中，我们可以提炼出：
- C&#43;&#43;是对C语言的扩展升级 -----------&gt;&gt; C的多数特性和语法规则在C&#43;&#43;中依然适用。
- C&#43;&#43;是一个面向对象的程序设计语言-----------&gt;&gt; 相对于面向方法的C语言，C&#43;&#43;语言提出了面向对象的设计思想与 类 Class的概念
除此以外，为了方便封装各种抽象的数据类型，C&#43;&#43;提供了功能强大的STL库，该库中有封装好的各种常用数据结构；同时，C&#43;&#43;也提供了template类模板的方法，通过template，我们可以创造一个类模板或函数模板，再通过提供不同类型的数据，使其产生处理对应数据类型的模板类与模板函数，这样极大提高了C&#43;&#43;代码的复用性与可移植性。
因此，可以说 C&#43;&#43; = C &#43; Class &#43; STL &#43; Template
1.1 const与常量 在原来的认识中，被const修饰的量其值不可被更改，我们称这样不可被修改的量为常量。但在C语言中，有些变量即使被const修饰，但在某些情况下其值仍可被修改，如下例：
const int b = 10; int* p = (int)&amp;b;	//通过强制类型转换，p可以获取b的地址 *p = 20; //通过修改*p来修改b的值 printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/fa1546d38bdba1034b2d464bdb80aba1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-07T11:03:45+08:00" />
<meta property="article:modified_time" content="2022-09-07T11:03:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;学习笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>C++学习笔记</h4> 
 <ul><li><a href="#_CC_3" rel="nofollow">一 .C与C++区别</a></li><li><ul><li><a href="#11_const_16" rel="nofollow">1.1 const与常量</a></li><li><ul><li><a href="#const_37" rel="nofollow">const与指针</a></li></ul> 
   </li><li><a href="#12__84" rel="nofollow">1.2 引用（别名）</a></li><li><ul><li><a href="#const_129" rel="nofollow">*引用与const</a></li></ul> 
   </li><li><a href="#13__215" rel="nofollow">1.3 默认值参数</a></li><li><a href="#14__259" rel="nofollow">1.4 内联函数</a></li><li><a href="#15__318" rel="nofollow">1.5 函数重载</a></li><li><a href="#16_CC_369" rel="nofollow">1.6 C与C++函数的互相调用</a></li><li><a href="#17__385" rel="nofollow">1.7 函数摸板</a></li><li><ul><li><a href="#_470" rel="nofollow">数组引用与函数模板</a></li></ul> 
   </li><li><a href="#18_newmalloc_476" rel="nofollow">1.8 new与malloc</a></li><li><a href="#19_498" rel="nofollow">1.9命名空间</a></li><li><a href="#C_532" rel="nofollow">*C++中的右值引用</a></li></ul> 
  </li><li><a href="#_540" rel="nofollow">二.面向对象</a></li><li><ul><li><a href="#21__541" rel="nofollow">2.1 面向对象</a></li><li><a href="#22_this__592" rel="nofollow">2.2 this 指针</a></li><li><ul><li><a href="#const_618" rel="nofollow">const与成员方法</a></li></ul> 
   </li><li><a href="#23_626" rel="nofollow">2.3构造函数</a></li><li><ul><li><a href="#_681" rel="nofollow">构造函数的类型转化</a></li></ul> 
   </li><li><a href="#_696" rel="nofollow">拷贝构造函数</a></li><li><a href="#24_757" rel="nofollow">2.4析构函数</a></li><li><a href="#_768" rel="nofollow">友元</a></li><li><ul><li><a href="#_863" rel="nofollow">=运算符重载</a></li><li><a href="#_908" rel="nofollow">（）运算符重载</a></li><li><a href="#_962" rel="nofollow">缺省函数</a></li></ul> 
   </li><li><a href="#25_C_1102" rel="nofollow">2.5 C++中的权限</a></li><li><ul><li><a href="#_1140" rel="nofollow">静态成员变量与静态成员方法</a></li></ul> 
  </li></ul> 
  </li><li><a href="#___1261" rel="nofollow">三 . 继承与多态</a></li><li><ul><li><a href="#31_1275" rel="nofollow">3.1继承：</a></li><li><ul><li><a href="#_1324" rel="nofollow">同名问题</a></li><li><ul><li><a href="#_1325" rel="nofollow">属性同名</a></li><li><a href="#_1358" rel="nofollow">方法同名</a></li></ul> 
    </li><li><a href="#_1397" rel="nofollow">赋值兼容规则</a></li></ul> 
   </li><li><a href="#32__1402" rel="nofollow">3.2 多态</a></li><li><ul><li><a href="#_1412" rel="nofollow">动多态</a></li><li><a href="#_1430" rel="nofollow">虚函数</a></li><li><a href="#vftable_1451" rel="nofollow">vftable(虚表)</a></li><li><ul><li><a href="#_vfptr_1488" rel="nofollow">虚表指针_vfptr</a></li></ul> 
   </li></ul> 
   </li><li><a href="#RTTI_1527" rel="nofollow">RTTI</a></li><li><ul><li><a href="#_1548" rel="nofollow">菱形继承与虚继承</a></li></ul> 
   </li><li><a href="#_1606" rel="nofollow">纯虚函数与抽象类</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_CC_3"></a>一 .C与C++区别</h2> 
<p>C++的介绍：</p> 
<blockquote> 
 <p>C++是一种计算机高级程序设计语言，由<strong>C语言扩展升级</strong>而产生，最早于1979年由本贾尼·斯特劳斯特卢普在AT&amp;T贝尔工作室研发。<br> C++既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的<strong>面向对象的程序设计</strong>。C++擅长面向对象程序设计的同时，还可以进行基于过程的程序设计。<br> C++拥有计算机运行的实用性特征，同时还致力于提高大规模程序的编程质量与程序设计语言的问题描述能力。 (来源百度百科)</p> 
</blockquote> 
<p>从上述介绍中，我们可以提炼出：<br> - <em>C++是对C语言的扩展升级</em> -----------&gt;&gt; C的多数特性和语法规则在C++中依然适用。<br> - <em>C++是一个面向对象的程序设计语言</em>-----------&gt;&gt; 相对于面向方法的C语言，C++语言提出了面向对象的设计思想与 <strong>类 Class</strong>的概念</p> 
<p>除此以外，为了方便封装各种抽象的数据类型，C++提供了功能强大的<strong>STL库</strong>，该库中有封装好的各种常用数据结构；同时，C++也提供了<strong>template类模板</strong>的方法，通过template，我们可以创造一个类模板或函数模板，再通过提供不同类型的数据，使其产生处理对应数据类型的模板类与模板函数，这样极大提高了C++代码的复用性与可移植性。</p> 
<p>因此，可以说 <strong>C++ = C + Class + STL + Template</strong></p> 
<h3><a id="11_const_16"></a>1.1 const与常量</h3> 
<p>在原来的认识中，被const修饰的量其值不可被更改，我们称这样不可被修改的量为<strong>常量</strong>。但在C语言中，有些变量即使被const修饰，但在某些情况下其值仍可被修改，如下例：</p> 
<pre><code class="prism language-c">	<span class="token keyword">const</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>b<span class="token punctuation">;</span>	<span class="token comment">//通过强制类型转换，p可以获取b的地址</span>
	<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>       		<span class="token comment">//通过修改*p来修改b的值</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"b = %d  ,*p = %d \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 结果为 b = 20， *p = 20；</span>
</code></pre> 
<p>因此，c语言中的const修饰的值仍可被改变，我们称这样的值为 <em>常变量</em> 而非常量。</p> 
<p>而在C++ 中，由const修饰的量为常量，其值在任何情况下均不可被修改；此外，常量还具有如下特性：</p> 
<ul><li> <p>在<strong>编译期</strong>常量的值被直接写入到常量的声明点；因此常量必须初始化。（在c++编译规则中）</p> </li><li> <p>常量的初始化必须使用常量， 如果使用变量给const修饰的量初始化，则该量（const ）会退化成常变量；如：</p> </li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span>；
<span class="token keyword">const</span> <span class="token keyword">int</span> c <span class="token operator">=</span> b；<span class="token comment">//此时c退化为常变量，其值可被修改</span>
</code></pre> 
<h4><a id="const_37"></a>const与指针</h4> 
<pre><code class="prism language-cpp">	<span class="token keyword">int</span> a <span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">//const修饰了int（即p1指针指向的是一个const int类型变量的地址），因此不可通过p1改变a的值</span>
	<span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">//const修饰指针p2，因此指针p2的值（即指向的地址）不可改变</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p3 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">//p3兼具以上两种特性</span>
</code></pre> 
<pre><code class="prism language-cpp">	<span class="token keyword">int</span> a <span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>

<span class="token comment">// 以下3语句均可编译通过</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span> 
	<span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p3 <span class="token operator">=</span> p1<span class="token punctuation">;</span> 
	<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p4 <span class="token operator">=</span> p1<span class="token punctuation">;</span> 
</code></pre> 
<p>被const修饰的指针与其他被const修饰的指针互相赋值时——</p> 
<pre><code class="prism language-cpp"><span class="token comment">//例1</span>

<span class="token keyword">int</span> a <span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token comment">//const修饰了int，因此通过P对a只可读而不可写 （因为a为const int类型，为常量）</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token operator">*</span> p0 <span class="token operator">=</span>p<span class="token punctuation">;</span> <span class="token comment">// 编译不通过，p0可读可写，能力发生扩展</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> p1 <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">//通过</span>
<span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p2 <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">//不通过，p2仍可读可写</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p3 <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment">//通过</span>
</code></pre> 
<pre><code class="prism language-cpp"><span class="token comment">//例2</span>

<span class="token keyword">int</span> a <span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token comment">//通过P对a可读可写；只是p的指向不可改变</span>
<span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token operator">*</span> p0 <span class="token operator">=</span>p<span class="token punctuation">;</span> <span class="token comment">// 编译通过</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> p1 <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">//通过，p1只可读，能力收缩是允许的</span>
<span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p2 <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">//通过</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p3 <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment">//通过</span>
</code></pre> 
<h3><a id="12__84"></a>1.2 引用（别名）</h3> 
<p>从语法层面讲 — 引用是对同一空间所起的不同名称<br> 在系统底层来看，引用仍然是由指针实现的（*const）</p> 
<p>对数组的引用：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> ar<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token punctuation">{<!-- --></span> <span class="token number">12</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">56</span><span class="token punctuation">,</span><span class="token number">67</span><span class="token punctuation">,</span><span class="token number">78</span><span class="token punctuation">,</span><span class="token number">89</span><span class="token punctuation">,</span><span class="token number">99</span><span class="token punctuation">,</span><span class="token number">100</span> <span class="token punctuation">}</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> a <span class="token operator">=</span> ar<span class="token punctuation">;</span>             <span class="token comment">//错误</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> ar<span class="token punctuation">;</span>       <span class="token comment">//正确（同时给出 变量类型 与 个数）</span>
</code></pre> 
<p>当函数返回值为引用时：：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span> <span class="token punctuation">;</span>
   <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">funref</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//编译为int * const funref（）</span>
<span class="token punctuation">(</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">20</span> <span class="token punctuation">;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>   <span class="token comment">//编译为return &amp;a；注意，此处返回值为a的地址</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token function">fun</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token function">funref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//避免如此编程，函数返回值为&amp;a，此处编译为int y = *funref（）；对局部变量进行引用返回可能访问随机值（访问将亡值地址可能读取错误数据）</span>

<span class="token keyword">int</span><span class="token operator">&amp;</span> z <span class="token operator">=</span> <span class="token function">funref</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>   <span class="token comment">//同上</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当变量生存期不受函数影响（如static，全局变量，堆空间申请 ）时，可以以引用方式返回（即避免访问临时量的空间）</p> 
<p>当函数返回值为对象的引用时；系统会在<strong>该函数区</strong>通过拷贝构造函数构建一个临时对象，因此返回数据可能受到侵扰；</p> 
<p><strong>若返回值为对象class，无名对象会直接构建在主函数空间内</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span><span class="token operator">&amp;</span>  a（）
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token keyword">class</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//此处返回无名对象</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="const_129"></a>*引用与const</h4> 
<p>例1：：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&amp;</span>pref1 <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">//通过，按照从右向左结合的规则解释，pref1首先为一个引用（&amp;），其后pref1为一个指针的引用（*），且为整形（int）指针的引用；因此 pref1为p的别名</span>

<span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token operator">*</span>pref2 <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">//不通过，此处解释为pref2为一个指针（*），其指向为一个引用（&amp;）；语法规则上错误，不认为引用具有地址</span>
</code></pre> 
<p>例2：：</p> 
<pre><code class="prism language-cpp">
<span class="token keyword">int</span> a <span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>s <span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&amp;</span>p1 <span class="token operator">=</span>s<span class="token punctuation">;</span> <span class="token comment">// 编译通过</span>

<span class="token comment">//不同的编译器可能不允许下列部分指针的声明</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&amp;</span>p2 <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">//通过,但不可修改*p2的值（*s的值仍可修改），修改p2的指向时，s的指向也会发生变化</span>
<span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>p3 <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">//通过，但不可修改p3的指向，仅当s的指向改变时，p3指向改变</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>p4 <span class="token operator">=</span> s<span class="token punctuation">;</span><span class="token comment">//通过</span>
</code></pre> 
<p>例3：：</p> 
<pre><code class="prism language-cpp">
<span class="token keyword">int</span> a <span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>s <span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&amp;</span>p1 <span class="token operator">=</span>s<span class="token punctuation">;</span> <span class="token comment">// 错误，能力扩展（s可读不可写，p1可读可写）</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&amp;</span>p2 <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">//通过</span>
<span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>p3 <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">//错误</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>p4 <span class="token operator">=</span> s<span class="token punctuation">;</span><span class="token comment">//通过</span>
</code></pre> 
<p>例4：：</p> 
<pre><code class="prism language-cpp">
<span class="token keyword">int</span> a <span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> s <span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&amp;</span>p1 <span class="token operator">=</span>s<span class="token punctuation">;</span> <span class="token comment">//错误，p1修改会导致s修改</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&amp;</span>p2 <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">//错误</span>
<span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>p3 <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">//正确</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>p4 <span class="token operator">=</span> s<span class="token punctuation">;</span><span class="token comment">//正确</span>
</code></pre> 
<p>总结：普通引用可以用常引用与普通引用，产量只能用常引用</p> 
<p><strong>引用的底层实现是一个指针</strong><br> 在编译期，引用会自动替换为底层指针的解引用</p> 
<pre><code class="prism language-cpp"><span class="token comment">//a,*p,x,y是同一空间</span>
<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token comment">//void fun(int * const a)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
    a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment">//底层以指针形式处理 *a = 100</span>
    <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> <span class="token operator">&amp;</span>y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// int * const y = &amp;x;</span>
    <span class="token function">fun</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fun</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>引用为什么要初始化？</strong></p> 
<ul><li>在编译期，引用需要替换为解引用</li></ul> 
<p><strong>引用初始化后为什么无法被改变？</strong></p> 
<ul><li>在编译期被替换为解引用；其实现为 *const</li></ul> 
<p>当引用一个不可以取地址的量时，使用常引用；</p> 
<p>临时量都有常量属性</p> 
<h3><a id="13__215"></a>1.3 默认值参数</h3> 
<p>在函数声明或定义时，给定参数默认值。</p> 
<p>如果实参传递时不为形参传值，会按默认值赋值。</p> 
<pre><code class="prism language-c">
 <span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">,</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment">// 默认值参数</span>
 <span class="token punctuation">{<!-- --></span>
	 count <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	 count <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	 count <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 
 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>	 
	 <span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正确，此时fun中a=1，b=2，c=10</span>
	 <span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//错误，需依次赋值</span>
	 <span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正确，此时fun中a=1，b=3，c=4</span>
	 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

</code></pre> 
<p><em>注意：</em><br> a.参数默认值在<mark>编译期</mark>生成指令时，直接生成入参指令。<br> 因此，默认值只可传递常量。（变量在编译期无法获取变量值。）<br> 因此，默认值只在本文件生效。（编译只针对单文件）</p> 
<p>b.默认值只可从右向左依次设置默认值。不能跳过。<br> 可通过以下方式连续设置默认值。</p> 
<pre><code class="prism language-c"> <span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">,</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment">// 默认值参数</span>
 <span class="token punctuation">{<!-- --></span>
	 count <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	 count <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	 count <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token comment">// 默认值参数</span>
</code></pre> 
<p>c.默认值参数在同一作用域中不可多次赋值。</p> 
<h3><a id="14__259"></a>1.4 内联函数</h3> 
<p>1）内联函数的使用是为了解决 频繁调用小函数而大量<mark>消耗栈空间</mark> 的问题</p> 
<p>因此可将其视为“空间换时间”的一种办法</p> 
<blockquote> 
 <p>消耗栈空间：这里主要指现场保护与恢复，开辟栈帧，及栈帧回退的时间</p> 
</blockquote> 
<blockquote> 
 <ul><li>正常函数在调用时—<br> 1 .传参<br> 2 . call fun //调函数<br> 3 .开辟栈帧<br> 4 .返回值返回<br> 5 .栈帧回退<br> 6.参数清除</li></ul> 
</blockquote> 
<p>2）内敛函数调用</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> c <span class="token operator">=</span> b <span class="token operator">+</span> a<span class="token punctuation">;</span>	
<span class="token punctuation">}</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">,</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	
	<span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//普通函数</span>
	<span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>   <span class="token comment">//内敛函数，编译期在调用点展开</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>3）inline不总是展开<br> 在debug版本（调试版本）下与常规函数无差异，不展开；<br> 在release版本（发行版本）下使用，该函数会在调用点展开（编译时期）；</p> 
<p><em>注意</em><br> a. 递归函数无法被展开<br> （编译时无法获取变量值，因而无法实现终止条件）；</p> 
<p>b. inline只是对系统<strong>建议</strong>将该函数处理为内联函数，在函数体过大（如行数大于5）或过于复杂（存在循环结构，if语句等）时，编译器会将其视为普通函数处理；少部分编译器甚至会报错</p> 
<p>c. inline在debug版本生成的是local符号,只在本地可见；如果处理为内联之后在release版本不生成符号，直接在调用点展开。</p> 
<table><thead><tr><th>函数</th><th>展开</th><th>调试</th><th>类型安全校验</th><th>栈帧的开辟</th><th>可见性</th><th>符号</th></tr></thead><tbody><tr><td>宏函数</td><td>预编译时期在调用点展开</td><td>无法调试</td><td>无</td><td>无</td><td>单文件可见</td><td>不生成</td></tr><tr><td>static函数</td><td>不展开</td><td>可调试</td><td>有</td><td>有</td><td>单文件可见</td><td>生成local符号</td></tr><tr><td>内联函数</td><td>debug版本不展开，release版本（在编译阶段时）于调用点展开</td><td>可调试</td><td>有</td><td>debug版本有栈帧开辟；release版本没有栈帧开辟</td><td>单文件可见</td><td>debug版本生产local符号，release版本不生成符号</td></tr><tr><td>普通函数</td><td>不展开</td><td>可调试</td><td>有</td><td>有</td><td>多文件可见</td><td>生成global符号</td></tr></tbody></table> 
<blockquote> 
 <p><strong>符号</strong>：<br> 所有的数据都会生成符号；指令中只有函数名会生成符号<br> 分为——1 .全局符号 <strong>global</strong> 符号 2.局部符号 <strong>local</strong> 符号<br> 只有本文件可见</p> 
</blockquote> 
<p>因为内敛函数会进行类型检查与安全检查，可将其视为更安全的宏</p> 
<h3><a id="15__318"></a>1.5 函数重载</h3> 
<p>在了解重载机制前，我们应当先了解C++是以<strong>函数原型</strong>来区分不同函数</p> 
<blockquote> 
 <p>函数的原型 包括函数返回类型，函数名，形参列表（参数个数，类型，顺序）</p> 
</blockquote> 
<p><strong>函数重载</strong>：函数名相同，参数列表不同。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">Max</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> <span class="token function">Max</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span><span class="token keyword">double</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实现了Max函数的重载</span>
</code></pre> 
<p><em>注意</em>：函数重载仅以<strong>参数列表</strong>作为重载判断条件，<strong>返回类型不同不构成重载！</strong><br> 不以返回类型区分的原因：</p> 
<ul><li>调用时产生二义性</li><li>（对上一点的补充）在调用时各函数均符合其调用规则，此时便无法调用</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">Max</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> <span class="token function">Max</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//仅是返回类型不同，非重载函数</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//···</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token function">Max</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//错误，调用具有二义性，系统无从判断应当调用那个函数</span>
	<span class="token comment">//···</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>另外值得注意的是，即便可以通过参数个数不同实现函数重载，但在某些设置默认值的情况下依然会因为产生二义性而错误，如下面的情况：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span>

<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">,</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//设置默认值参数</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//错误，产生二义性</span>
    <span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//正确</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>函数重载是在编译时期决定的调用哪一个函数——这是C++<strong>静多态</strong>特性的一种表现</p> 
<p>C++能进行函数重载的原因——编译时使用了重命名规则—即 <em>名字粉碎</em> 技术</p> 
<h3><a id="16_CC_369"></a>1.6 C与C++函数的互相调用</h3> 
<p>C++调用C<br> 使用extern “C”</p> 
<pre><code class="prism language-cpp"><span class="token comment">//使用C语言的方法编译下面代码</span>
<span class="token keyword">extern</span> “C”  <span class="token keyword">int</span>  <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//···；</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>C调用C++<br> 在C工程中添加实现的C++文件，写C++函数作为中间层,用中间层调用需要的C++函数，需要自实现的C++函数产生C语言符号，之后使用C语言调用。</p> 
<h3><a id="17__385"></a>1.7 函数摸板</h3> 
<pre><code class="prism language-cpp"><span class="token comment">//函数模板</span>
<span class="token comment">//此处T仅作标识符用，可替换为任意字符</span>
<span class="token comment">//也可写作 template&lt;class T&gt;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   T tmp <span class="token operator">=</span> a<span class="token punctuation">;</span>
   a <span class="token operator">=</span> b<span class="token punctuation">;</span>
   b <span class="token operator">=</span> tmp<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
   <span class="token keyword">double</span> da <span class="token operator">=</span> <span class="token number">12.33</span><span class="token punctuation">,</span> db <span class="token operator">=</span> <span class="token number">23.23</span><span class="token punctuation">;</span>
   <span class="token keyword">char</span> ch1 <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">,</span>ch2 <span class="token operator">=</span> <span class="token char">'b'</span><span class="token punctuation">;</span>

   <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//判断a，b为int类型，swap函数模板生成与之对应的模板函数</span>
   <span class="token function">swap</span><span class="token punctuation">(</span>da<span class="token punctuation">,</span>bb<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">swap</span><span class="token punctuation">(</span>ch1<span class="token punctuation">,</span>ch2<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">//  自定类型（struct）也可以调用函数摸板</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>函数模板类型的推断发生在编译时期</p> 
<p>注意* 函数摸板的实现不能理解为简单的替换<br> 如在上例中</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>···<span class="token punctuation">}</span>

<span class="token keyword">int</span> main（）
<span class="token punctuation">{<!-- --></span>
  ···
  <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>类型转换的实现并非为宏的替换-<code>swap（int&amp; a,int&amp; b）</code><br> 而是使用类型重命名规则（根据实参推演出形参-函数模板生成的函数称为模板函数）<br> <code>typedef int Type</code><br> <code>void swap&lt;int&gt; (Type&amp; a,Type&amp; b)</code><br> 函数模板生成模板函数，其关系如同class与其实例的关系，后者由前者生成<br> 例2：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span>T a<span class="token punctuation">)</span> <span class="token comment">//完全泛化</span>
<span class="token punctuation">{<!-- --></span>
  T x，y<span class="token punctuation">;</span>
cout<span class="token operator">&lt;&lt;</span> <span class="token string">"T type : "</span><span class="token operator">&lt;&lt;</span><span class="token keyword">typeid</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

cout<span class="token operator">&lt;&lt;</span> <span class="token string">"a type :"</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl <span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span>T<span class="token operator">*</span> a<span class="token punctuation">)</span> <span class="token comment">//部分泛化</span>
<span class="token punctuation">{<!-- --></span>
  T x，y<span class="token punctuation">;</span>
cout<span class="token operator">&lt;&lt;</span> <span class="token string">"T type : "</span><span class="token operator">&lt;&lt;</span><span class="token keyword">typeid</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

cout<span class="token operator">&lt;&lt;</span> <span class="token string">"a type :"</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl <span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">10</span> <span class="token punctuation">;</span>
  <span class="token function">fun1</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//无法编译通过，fun1作为部分泛化仅接受指针</span>
  <span class="token function">fun1</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//同上</span>
  <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//T推演为int</span>
  <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//T推演为const int</span>
  <span class="token function">fun</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//T推演为int类型</span>
  <span class="token function">fun</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//T推演为int*</span>
  <span class="token function">fun</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//T推演为int</span>
  <span class="token function">fun</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">//T推演为const int *</span>
  
  <span class="token keyword">int</span><span class="token operator">*</span> xp <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> yp <span class="token operator">=</span> <span class="token operator">&amp;</span>y<span class="token punctuation">;</span>
  <span class="token function">fun</span><span class="token punctuation">(</span>xp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//T 推演为int*</span>
  <span class="token function">fun</span><span class="token punctuation">(</span>yp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//T 推演为const int*</span>
<span class="token punctuation">}</span>

</code></pre> 
<h4><a id="_470"></a>数组引用与函数模板</h4> 
<p><img src="https://images2.imgbox.com/3d/b1/255DnCBl_o.png" alt="在这里插入图片描述"></p> 
<ul><li>在处理时，函数模板创建多个函数</li><li>非类型变量在编译时即会被替换，所以其并非一个变量,在此处可看作是宏替换</li></ul> 
<h3><a id="18_newmalloc_476"></a>1.8 new与malloc</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    ip <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span> <span class="token comment">// 在堆区申请一个整形空间</span>
    <span class="token operator">*</span>ip <span class="token operator">=</span> <span class="token number">100</span>；
    <span class="token keyword">delete</span> ip； <span class="token comment">//释放空间</span>
    ip <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
     
    ip <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//申请n个整形空间</span>
    <span class="token comment">//申请对象数组时需要默认值参数或缺省构造函数</span>
    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span>ip； <span class="token comment">//释放连续申请的空间</span>
    ip <span class="token operator">=</span> <span class="token constant">NULL</span>；
<span class="token punctuation">}</span>
</code></pre> 
<p>区别：<br> malloc申请失败需要自行判断；<code>if（ip == NULL）</code><br> new申请失败会抛出异常 throw bad_allloc<br> 用<code>ip = new(nothrow) int[n]</code>表明不需要抛出异常，申请失败时赋值为空</p> 
<p>若数组空间内对象为自设类型，delete会连续调用该对象的析构函数；对于系统内设类型，free与delete在使用上无差别</p> 
<h3><a id="19_498"></a>1.9命名空间</h3> 
<p>using namespace std；<br> 命名空间用来解决全局变量名污染问题（名字重复）<br> 如在工程A与工程B中均定义了函数fun；<br> 在主函数调用时会产生二义性，此时使用命名空间：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>···<span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">//假设该函数定义在工程A中</span>
<span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>···<span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">//假设该函数定义在工程B中</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//错误，二义性</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>做如下修改：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> A
<span class="token punctuation">{<!-- --></span>
   <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>···<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">namespace</span> B
<span class="token punctuation">{<!-- --></span>
   <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>···<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//此处::为作用域解析符</span>
    <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="C_532"></a>*C++中的右值引用</h3> 
<p><a href="https://blog.csdn.net/qq_53307983/article/details/123455025">C++中的右值引用</a></p> 
<h2><a id="_540"></a>二.面向对象</h2> 
<h3><a id="21__541"></a>2.1 面向对象</h3> 
<p>对象即是现实世界中某个具体的物理实体在计算机逻辑中的映射和体现</p> 
<p><strong>类</strong> <strong>class</strong> ：是一组相关的<strong>属性</strong>（变量）与<strong>行为</strong>（方法）的集合，是一个抽象概念设计的产物。<br> c++中，类是一种数据类型</p> 
<ul><li>成员变量是对象的属性，属性的值确定对象的状态。</li><li>成员函数是对象的方法，确定对象的行为。</li></ul> 
<p>面向对象三大特性：<strong>封装 继承 多态</strong> （抽象）</p> 
<p>类的设计：</p> 
<pre><code class="prism language-cpp"><span class="token comment">//class为数据类型说明符</span>
<span class="token keyword">class</span> <span class="token class-name">student</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">bool</span> sex<span class="token punctuation">;</span>
     <span class="token keyword">void</span> <span class="token function">set_age</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">private</span>：
      <span class="token keyword">int</span> Age<span class="token punctuation">;</span>
     <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//对象方法的类外声明（此时函数明与参数列表需相同）</span>
<span class="token keyword">void</span> student<span class="token double-colon punctuation">::</span><span class="token function">set_age</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   Age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   student c1<span class="token punctuation">;</span><span class="token comment">//创建对象</span>
   c1<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//合法</span>
   c1<span class="token punctuation">.</span>Age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//错误，不可访问private成员</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如成员可见性不进行设置，默认为private<br> private与protected体现了类具有<strong>封装性</strong></p> 
<p>一般将变量设置为private，方法设置为public；<br> 这样，就仅可靠对外的接口来改变变量的值</p> 
<ul><li>注意，空的类大小为1而非0（用来让系统标识类在系统空间中的位置）</li></ul> 
<p>在创建多个对象时，不同对象的属性存放于不同区域；全局对象存放于数据区，在函数内部定义则为栈区，用new构建则为堆区</p> 
<p>而方法只在代码区创建一次，同个对象的不同实例共用</p> 
<p>在方法调用时，系统为分辨调动的主体–因而引入this指针的概念：</p> 
<h3><a id="22_this__592"></a>2.2 this 指针</h3> 
<p>编译器对类型的编译为以下三步：<br> 1.识别函数属性<br> 2.函数原型（非函数体部分）的识别<br> 3.改写<br> 如在上例的<code>void studvent::set_age(int age) </code>会被改写为<code>void studvent::set_age(stuent* const this，int age) </code>，这样，在多个实例调用方法时会再进行以下改写</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  student s1<span class="token punctuation">,</span>s2<span class="token punctuation">;</span>
  
  s1<span class="token punctuation">.</span><span class="token function">set_age</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//改写为set_age(&amp;s1,2);</span>
 
  s2<span class="token punctuation">.</span><span class="token function">set_age</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//改写为set_age(&amp;s2，2);</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在c++默认的调用约定<code>thiscall</code>下，this指针的值是通过ecx来传递的，如在<code>s1.set_age(2)</code>中，首先先将s1的地址[s1]传递给ecx<code>lea ecx,[s1]</code>，之后进入函数内部，ecx中的值传递给this指针 <code>mov [this],ecx</code><em>/如使用c的调用约定<code>cdecl</code>，则是以入栈的形式实现<code>push eax</code>/</em></p> 
<p>（在编译时自动入参）<br> 1.是指向本对象的指针；其存在于成员函数内，而非对象内，只有在调用成员方法时产生this指针</p> 
<p>2.普通成员方法的第一个参数，默认加上this指针；</p> 
<p>3.在普通成员方法内只用到普通成员的地方，加上this指针的解引用 this-&gt;<br> 4.在调用成员方法时，加上参数this指针</p> 
<h4><a id="const_618"></a>const与成员方法</h4> 
<p>如对于成员函数 <code>int get_num()</code>在其之前增加const<code>const int get_num()</code>是说明该函数返回值为常量；<br> 在其之后增加const<code>int get_num() const</code>则是声明此方法为常方法，常方法内只能对对象进行读取，而无法写入（即无法修改）</p> 
<p>注意，常对象<code>如const student s1</code>调用普通方法会报错——普通方法的this指针（student * const this）无法指向常对象（能力扩展）。因此，常对象只可指向常方法。/·普通方法不受限制·/</p> 
<h3><a id="23_626"></a>2.3构造函数</h3> 
<p>当所有成员属性可见性<strong>皆为</strong>public时，可直接用{···}对对象进行初始化：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">pointer</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">int</span> row<span class="token punctuation">;</span>
     <span class="token keyword">int</span> col<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   pointer p <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>一个对象的数据成员多为私有的，要对它们进行初始化，必须用一个公有函数来进行。同时这个函数应该在且仅在定义对象时自动执行一次。称为<strong>构造函数(constructor)</strong> 。</p> 
<p><strong>构造函数的用途:1）创建对象，2)初始化对象中的属性，3）类型转换。</strong></p> 
<p><strong>初始化列表</strong><br> 只有构造函数有初始化列表<br> 必须初始化的成员放在初始化列表<br> 在本对象构造之前需要完成的动作必须放在初始化列表中<br> 从const 成员 必须放在初始化列表中<br> const方法<br> 常对象只能调用常方法（this指针不匹配） – 构造，析构，重载不受影响<br> 常方法中只能调用常方法 – 静态函数不影响</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Int</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> val<span class="token punctuation">;</span>

  <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">Int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  <span class="token comment">//缺省构造函数</span>
     <span class="token function">Int</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>  <span class="token comment">//构造函数重载</span>
     <span class="token punctuation">{<!-- --></span>
        val<span class="token operator">=</span> x<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   Int p1（<span class="token number">1</span>）<span class="token punctuation">;</span>  <span class="token comment">// 创建对象并初始化</span>
   Int p2；          <span class="token comment">//调用缺省构造函数</span>
   Int <span class="token function">p3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；     <span class="token comment">//无法构造对象，系统理解为函数声明</span>

   p2<span class="token punctuation">.</span><span class="token function">Int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">// 错误，构造函数仅可由系统调用，对象无法调用</span>
   
   <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
   p1 <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// 类型转化（隐式转换）</span>
   
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_681"></a>构造函数的类型转化</h4> 
<p>类型转化只适用于单参的构造函数</p> 
<p>上例中，系统先b的值创建一个临时对象，然后将临时对象的值赋给p1；</p> 
<p>要防止隐式转换可以通过在构造函数前添加<code>explicit</code>关键字实现，此时实现类型转换需要用强制类型转换（也称显式转换），如 <code>p1 = （Int）b</code></p> 
<p>构造函数使用时–<br> 1.对象进行构造时时默认调用的函数，在对象生存周期内（由系统）只调用一次<br> 2.函数名与类名一致<br> 3.构造函数无函数返回类型说明；但实际上构造函数有返回值，为其创建的对象<br> 4.可重载<br> 5.未定义时，系统默认生成一个默认构造函数（除 this 指针外，没有参数的构造函数）</p> 
<h3><a id="_696"></a>拷贝构造函数</h3> 
<p>1.当使用一个已存在的对象为另一个对象赋值时，自动调用的成员方法<br> 2.如果自己不实现，自动生成一个浅拷贝的等号运算符重载函数<br> 3.防止自赋值<br> 4.防止内存泄漏<br> 5.防止浅拷贝<br> 在建立对象时可用同一类的另一个对象来初始化该对象的存储空间，这时所用的构造函数称为<strong>拷贝构造函数(Copy Constructor).</strong><br> 这个拷贝过程只需要拷贝数据成员，函数成员是共用的。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">int</span> value <span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  
  <span class="token function">object</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">valuc</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
  <span class="token operator">~</span><span class="token function">object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
  
  <span class="token comment">//拷贝构造函数</span>
  <span class="token comment">//使用引用的原因——防止死递归</span>
  <span class="token comment">//无返回值</span>
  <span class="token comment">//也可让参数为常对象引用 </span>
  <span class="token function">object</span><span class="token punctuation">(</span>object<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span>：value（obj<span class="token punctuation">.</span>val）
   <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//下例中将构造5次对象</span>
object <span class="token function">fun</span><span class="token punctuation">(</span>object obj<span class="token punctuation">)</span> <span class="token comment">//3</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">int</span> val <span class="token operator">=</span> obj<span class="token punctuation">.</span><span class="token function">Getvalue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  object <span class="token function">obja</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//4</span>
  <span class="token keyword">return</span> obja<span class="token punctuation">;</span>    <span class="token comment">//5  构建临时对象——调用拷贝构造</span>
<span class="token punctuation">}</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span>
<span class="token punctuation">{<!-- --></span>
object <span class="token function">obja</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">//1</span>
object <span class="token function">objb</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2  调用构造函数</span>
objy <span class="token operator">=</span> fun（obja）；

<span class="token keyword">return</span> <span class="token number">0</span> ；
<span class="token punctuation">}</span>
</code></pre> 
<p>为避免函数的多次构建，可以将参数改为引用形式——即<code>object fun(object&amp; obj) </code>;</p> 
<p>有时,为了避免obj对象被错误修改，也可以加上const关键字—<code>object fun(const object&amp; obj)</code></p> 
<p>1.用一个已存在的对象为另一个正在生成的对象初始化的时候自动调用的成员方法；<br> 2.应当预防浅拷贝<br> 3.如果未自己实现，则生成一个浅拷贝的拷贝构造函数<br> 4.使用引用；以防死递归(重复创建新对象)</p> 
<p>总结:</p> 
<blockquote> 
 <p>拷贝构造函数的参数——采用引用。如果把一个真实的类对象作为参数传递到拷贝构造函数，会引起无穷递归。在类中如果没有显式给出拷贝构造函数时，则C++编译器自动给出一个缺省的拷贝构造f函数。如果有程序设计者定义的构造函数（包括拷贝构造函数)，则按函数重载的规律，调用合适的构造函数。</p> 
</blockquote> 
<p>浅拷贝 – 直接为指针赋值 （不常用）<br> 深拷贝 – 重新申请内存并将数据传入</p> 
<h3><a id="24_757"></a>2.4析构函数</h3> 
<p>当一个对象的生命周期结束时，C++会自动调用一个成员函数注销该对象，这个成员函数叫做**析构函数(destructor) **</p> 
<p>析构函数–<br> 1.对象生存周期满之后系统会自动调用，也可由对象主动调动<br> 2.~ + 对象名；如person类的析构函数为 ~person（）<br> 3.<strong>在栈帧中，先构造的函数后析构；</strong><br> 4.未实现时，调用默认析构函数（该函数什么都不做）<br> 5.一个类中只有一个析构函数<br> 6.析构函数无函数返回类型说明；是否有返回值取决于编译器</p> 
<h3><a id="_768"></a>友元</h3> 
<p>为了在类外访问其内部成员，将要注册的函数/成员/类前添加<code>friend</code>关键字并将其声明添加进类内，使其可访问类的内部成员</p> 
<p>友元不具有自反性<br> 友元不具有传递性<br> 友元不具有继承性</p> 
<p>实现方式<br> 1.函数友元</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token number">0</span>bject<span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">value</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    <span class="token keyword">friend</span> ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> out，<span class="token keyword">const</span> Object<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token comment">//声明为友元函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> out，<span class="token keyword">const</span> Object<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  out <span class="token operator">&lt;&lt;</span> obj<span class="token punctuation">.</span>value<span class="token punctuation">;</span> <span class="token comment">//友元函数可以访问类的private成员</span>
  <span class="token keyword">return</span> out<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
Object <span class="token function">obja</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cout<span class="token operator">&lt;&lt;</span> obja <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>2.成员函数友元</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">;</span> <span class="token comment">//构造base前需要对object对象声明</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> sum<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">sum</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">fun</span> <span class="token punctuation">(</span>Object<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">0bject</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> value<span class="token punctuation">;</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token number">0</span>bject<span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">value</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token number">0</span>
  <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token class-name">Base</span><span class="token double-colon punctuation">::</span><span class="token function">fun</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//base的成员函数声明为友元函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token class-name">Base</span><span class="token double-colon punctuation">::</span><span class="token function">fun</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  obj<span class="token punctuation">.</span>value <span class="token operator">=</span> obj<span class="token punctuation">.</span>value <span class="token operator">+</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>3.类友元</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">;</span> <span class="token comment">//构造base前需要对object对象声明</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">;</span> <span class="token comment">//Object注册为Base的友元函数</span>
<span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> sum<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">sum</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">fun</span> <span class="token punctuation">(</span>Object<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">0bject</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">;</span> <span class="token comment">//Base注册为Object的友元类，base类可以访问Object的成员</span>
<span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> value<span class="token punctuation">;</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token number">0</span>bject<span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">value</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token number">0</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//函数的类外实现</span>
<span class="token keyword">void</span> <span class="token class-name">Base</span><span class="token double-colon punctuation">::</span><span class="token function">fun</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
···
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token class-name">Base</span><span class="token double-colon punctuation">::</span><span class="token function">print</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
···
<span class="token punctuation">}</span>


</code></pre> 
<h4><a id="_863"></a>=运算符重载</h4> 
<p>在运算符前添加关键词operator</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">person</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> age<span class="token punctuation">;</span>
	<span class="token keyword">int</span> sex<span class="token punctuation">;</span>	
	
	<span class="token function">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_age <span class="token operator">=</span> src<span class="token punctuation">.</span>_age<span class="token punctuation">;</span>
		_sex <span class="token operator">=</span> src<span class="token punctuation">.</span>sex<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">//运算符重载</span>
	<span class="token comment">//以引用返回，因为this的生命周期大于operator=，可以以引用方式返回，从而避免了构建临时对象</span>
	person<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> person<span class="token operator">&amp;</span> src<span class="token punctuation">)</span> <span class="token keyword">const</span>
	<span class="token punctuation">{<!-- --></span>	
	    <span class="token comment">// 防止自符值</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> ！<span class="token operator">=</span> <span class="token operator">&amp;</span>src<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>  	
	    <span class="token keyword">this</span><span class="token operator">-&gt;</span>age <span class="token operator">=</span> src<span class="token punctuation">.</span>age<span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>
        <span class="token comment">//返回*this，可以实现连续赋值</span>
        <span class="token comment">//如person1 = per2 = per3</span>
         <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span> <span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> 


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	person <span class="token function">p1</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	person p4<span class="token punctuation">;</span>
	
	p4 <span class="token operator">=</span> p2<span class="token punctuation">;</span><span class="token comment">//编译如下：p4 = p4.operator(p2);</span>
	       <span class="token comment">//         operator(&amp;p2,p2);</span>
	
	
	<span class="token keyword">return</span> <span class="token number">0</span>；
<span class="token punctuation">}</span>

</code></pre> 
<h4><a id="_908"></a>（）运算符重载</h4> 
<p>对类型转换符（）的重载，能使得对某些class的操作更加方便。<br> 例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Int</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">private</span><span class="token operator">:</span>
     <span class="token keyword">int</span> val<span class="token punctuation">;</span>

  <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token function">Int</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
     
     <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
     <span class="token punctuation">{<!-- --></span>
       <span class="token keyword">return</span> val<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   Int <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
   a <span class="token operator">&lt;</span> b<span class="token punctuation">;</span>   <span class="token comment">//系统此处调用（）</span>
   
   <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
   a <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">//同上</span>
   
<span class="token punctuation">}</span>
</code></pre> 
<p>例2：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Add</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token comment">//易变关键字mutable，使得声明变量在常方法中也可以被改变</span>
  <span class="token keyword">mutable</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
  Add（<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span>）<span class="token operator">:</span><span class="token function">value</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
  itn <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token keyword">const</span>
  <span class="token punctuation">{<!-- --></span>
     value <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
     <span class="token keyword">return</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

   
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span>）
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span>b <span class="token operator">=</span> <span class="token number">20</span>，c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  Add add<span class="token punctuation">;</span>
  c <span class="token operator">=</span> <span class="token function">add</span> <span class="token punctuation">(</span>a，b<span class="token punctuation">)</span>；<span class="token comment">//仿函数</span>
  <span class="token comment">//无异于c = add.operator()(a，b);</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_962"></a>缺省函数</h4> 
<p>注意，当以下函数未自行构建时，系统会自动提供缺省函数<br> <img src="https://images2.imgbox.com/3c/b8/7QAiC14W_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/91/79/xMMVnvxI_o.png" alt="在这里插入图片描述"></p> 
<p>例：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">object</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
   <span class="token keyword">int</span> num<span class="token punctuation">;</span>
   <span class="token keyword">int</span> ar<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">:</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">object</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">num</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">-</span> <span class="token number">0</span><span class="token operator">:</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
       ar<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  object <span class="token function">obja</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  object <span class="token function">objb</span><span class="token punctuation">(</span>obja<span class="token punctuation">)</span><span class="token punctuation">;</span>
  object <span class="token function">objc</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  objc <span class="token operator">=</span> obja<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


</code></pre> 
<p>自建的拷贝与赋值重载如下</p> 
<pre><code class="prism language-cpp"><span class="token comment">//拷贝</span>
<span class="token function">object</span> <span class="token punctuation">(</span><span class="token keyword">const</span> object<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">num</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>num<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token operator">:</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
       ar<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">.</span>ar<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
  
 <span class="token comment">//赋值</span>
 object<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> object<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>obj<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
     num <span class="token operator">=</span> obj<span class="token punctuation">.</span>num<span class="token punctuation">;</span>
     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token operator">:</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     <span class="token punctuation">{<!-- --></span>
        ar<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">.</span>ar<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token keyword">return</span><span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre> 
<p>注意：如果未自己构建，且赋值的类为<em>简单类型</em>，系统所构建的缺省函数不会有函数调用过程，而只是简单的赋值。</p> 
<blockquote> 
 <p>简单类型：不具有继承关系，不具有虚函数，成员均为基本数据类型</p> 
</blockquote> 
<p>如在<code> objc = obja</code>中，系统只是获取obja的地址，并将其中的数据依次赋值给objc中对应的空间</p> 
<p>例2：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">int</span> num <span class="token punctuation">;</span>
  <span class="token keyword">int</span><span class="token operator">*</span> ip<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
   <span class="token function">Object</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">num</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span>
     ip <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">sizcof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">;</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     <span class="token punctuation">{<!-- --></span>
        ip<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> val <span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token operator">~</span><span class="token function">Objcct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token function">free</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ip <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>；

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  Object <span class="token function">obja</span><span class="token punctuation">(</span><span class="token number">5</span>，<span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Object <span class="token function">objb</span><span class="token punctuation">(</span>obja<span class="token punctuation">)</span><span class="token punctuation">;</span>
  Object <span class="token function">objc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  objc <span class="token operator">=</span> obja <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在该例中，执行<code> objc = obja</code>，若未构建赋值运算符重载函数，系统会将objc中的num赋值以obja中的num；同时，objc中的ip指针则会被赋值为obja中ip的值（即两个指针指向同一片空间），这并不是我们想要的结果。</p> 
<p>因此需要自建赋值运算符重载函数</p> 
<p>自建的拷贝与赋值重载如下</p> 
<pre><code class="prism language-cpp"><span class="token comment">//拷贝</span>
<span class="token function">object</span> <span class="token punctuation">(</span><span class="token keyword">const</span> object<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">num</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>num<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
     ip <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">sizcof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>num<span class="token punctuation">)</span> <span class="token punctuation">;</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     <span class="token punctuation">{<!-- --></span>
        ip<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">.</span>ip<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

  
 <span class="token comment">//赋值</span>
 object<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> object<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>obj<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
     num <span class="token operator">=</span> obj<span class="token punctuation">.</span>num<span class="token punctuation">;</span>
     ip <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">sizcof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>num<span class="token punctuation">)</span> <span class="token punctuation">;</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     <span class="token punctuation">{<!-- --></span>
        ip<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">.</span>ip<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token keyword">return</span><span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre> 
<p>小结:</p> 
<ul><li>1.运算符重载函数的函数名必须为关键字<strong>operator</strong>加一个合法的运算符。在调用该函数时，将右操作数作为函数的实参。</li><li>2.当用类的成员函数实现运算符的重载时，运算符重载函数的参数（当为双目运算符时)为一个或(当为单目算符时）没有。运算符的左操作数一定是对象，因为重载的运算符是该对象的成员函数，而右操作数是该函数的参数。</li><li>3．单目运算符“++”和“- -”存在前置与后置问题。<br> 前置“++”格式为:<br> class:operator++(){…}<br> 而后置“+＋”格式为:<br> class:operator++(int){…}<br> 后置“++”中的参数int仅用作区分，并无实际意义，可以给一个变量名，也可以不给变量名。</li><li> 
  <ol start="4"><li>当返回值为自身（*this）时，函数重载以引用方式返回（如=，前置++，+=）；返回值为临时量时，以值得形式返回（如+，后置++，）</li></ol> </li></ul> 
<h3><a id="25_C_1102"></a>2.5 C++中的权限</h3> 
<p><strong>private私有的</strong><br> 类内部可使用，其他地方不可调用<br> 不做设置时，class中权限默认为<strong>private</strong></p> 
<blockquote> 
 <p><strong>权限选择</strong>：对外界必须提供时，定义在public中；其他情况定义在private中；<br> 成员属性定义在private，外部需调用时仅提供接口；为防止改动，接口定义时使用const<br> struct同样可定义一个类；其中默认权限为public</p> 
</blockquote> 
<p>初始化 –<br> 赋值 –</p> 
<p><strong>哪些成员方法写成常方法</strong><br> 1.如果成员方法内不要改动成员，并且没有对外暴露成员引用||指针，就可以写成常方法；<br> 2.如果成员内部不需要改动成员，但是会对外暴露成员引用或是指针；则写成两个成员方法（const方法与非const方法）<br> 3.如果成员方法内部需要改动成员，则写为普通方法</p> 
<pre><code class="prism language-cpp">Person（）
<span class="token punctuation">{<!-- --></span>
：_sex（<span class="token number">1</span>）<span class="token comment">//初始化列表</span>
<span class="token punctuation">}</span>

Person（<span class="token keyword">const</span>）
<span class="token punctuation">{<!-- --></span>
：_sex（<span class="token number">1</span>）<span class="token comment">//初始化列表</span>
<span class="token punctuation">}</span>

<span class="token comment">//此const修饰this指针；等效于 const *  this </span>
Person（）<span class="token keyword">const</span>
<span class="token punctuation">{<!-- --></span>
：_sex（<span class="token number">1</span>）<span class="token comment">//初始化列表</span>
<span class="token punctuation">}</span>

</code></pre> 
<h4><a id="_1140"></a>静态成员变量与静态成员方法</h4> 
<ul><li>静态量存储在数据段</li><li>一个类的不同实例共用一个静态成员，并且其不占用类实体的空间</li><li>需要在类外进行初始化</li><li>必须在类外的.cpp文件中初始化，且只能初始化一次（在.h文件初始化会使每次调用都会初始化）</li><li>静态成员方法访问不依赖this指针，<br> 只能使用静态成员变量（因为其不依赖this指针）</li><li>派生类共享使用基类的静态成员变量</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">0bject</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
<span class="token comment">//常见静态成员可见性设为private</span>
 <span class="token keyword">static</span> <span class="token keyword">int</span> num<span class="token punctuation">;</span> <span class="token comment">//静态成员不能在类内初始化</span>
 <span class="token keyword">int</span>  test<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  T value<span class="token punctuation">;</span>
  <span class="token function">Object</span><span class="token punctuation">(</span>T x <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">value</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
  <span class="token comment">//静态成员函数，static并非修饰其返回值，而是表面函数不使用this指针，因此该函数只可访问静态成员，并且此函数无法声明为const方法</span>
  <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    num<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//T，静态方法只可访问静态成员</span>
    test<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//F，无this指针无法访问非静态成员</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>

<span class="token keyword">int</span> Object<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//静态成员的类外初始化，注意，初始化语句并非函数内的执行语句，因此，即便 num可见性为private，该语句依然正常执行</span>


<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Object</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
   <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span> 
       num <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
  <span class="token punctuation">{<!-- --></span>
    num <span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//static成员不依靠this指针访问，因此即便方法为常方法，num依旧可以被修改</span>
   cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base:num:"</span> <span class="token operator">&lt;&lt;</span>num <span class="token operator">&lt;&lt;</span>endl <span class="token punctuation">;</span> 
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Object</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
   <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
  <span class="token punctuation">{<!-- --></span>
      num <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> 
 <span class="token punctuation">{<!-- --></span> 
   cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Test: "</span> <span class="token operator">&lt;&lt;</span>num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> 
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  Base b1<span class="token punctuation">,</span>b2<span class="token punctuation">;</span>
  Test t1<span class="token punctuation">,</span>t2<span class="token punctuation">;</span>

  b1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//</span>
  t1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>例1：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token operator">:</span>
  <span class="token keyword">int</span> value<span class="token punctuation">;</span>
  <span class="token keyword">static</span> Object obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>注意，该class是可以编译通过的，static Object obj只有一份且存在于数据区，为各Object实体所共用，单独的Object实体内只含有value属性，所以不存在重复构建的问题</p> 
<p><strong>例2.1：static成员在单例模式中的应用</strong><br> <strong>单例模式</strong>：创建对象时，只创建一个对象</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> value<span class="token punctuation">;</span>
  <span class="token keyword">static</span> Object instance<span class="token punctuation">;</span>
  
    <span class="token comment">//构造函数设为私有，使其无法被外部函数调用</span>
   <span class="token function">Object</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">valuc</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
 <span class="token comment">//将拷贝构造与=重载函数delete（弃用）</span>
  <span class="token function">Object</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Object<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
  Object<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Object<span class="token operator">&amp;</span> ob<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
  
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token comment">//通过一个public函数提供接口来实现外部对类内唯一对象static Object instance的访问</span>
<span class="token comment">//注意，只能以&amp;的方式返回，因为值返回所使用的拷贝构造函数（返回时构建临时对象会调用拷贝构造函数）已经被delete</span>
  <span class="token keyword">static</span> Object<span class="token operator">&amp;</span> <span class="token function">GotTnstance</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
 
Object <span class="token class-name">Object</span><span class="token double-colon punctuation">::</span> <span class="token function">instance</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//static 对象的类外初始化</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  Object <span class="token function">obj</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//F,外部函数不可调用构造函数</span>
  Object<span class="token operator">&amp;</span> obja <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token double-colon punctuation">::</span><span class="token function">GotTnstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//T</span>
  Object<span class="token operator">&amp;</span> bojb <span class="token operator">=</span> obja<span class="token punctuation">.</span><span class="token function">GotTnstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//T,obja与objb所引用的是同一个对象</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>此例中所实现的单例模式称为线程安全（对象构建时的线程安全）</p> 
<h2><a id="___1261"></a>三 . 继承与多态</h2> 
<p>**继承(inheritance)**机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能。这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构。体现了由简单到复杂的认识过程。</p> 
<p>**多态性(polymorphism)**是考虑在不同层次的类中，以及在同一类中，同名的成员函数之间的关系问题。函数的重载，运算符的重载，属于编译时的多态性(也称为早绑定)。以虚基类为基础的运行时的多态性是面向对象程序设计的标志性特征(也称为晚绑定)。</p> 
<p>类与类之间的关系：</p> 
<ol><li>嵌套 --类中声明其他类</li><li>代理 --类的接口时另一个类接口的子集（一个类的功能需要另一个类实现）</li><li>友元 –</li><li>属于 --一个类是另一个类的一部分</li><li>组合 –</li><li>继承 –</li></ol> 
<h3><a id="31_1275"></a>3.1继承：</h3> 
<p>被继承的类称为<strong>基类</strong>；<br> 新产生的类称为<strong>派生类</strong>；</p> 
<p>继承时会有基类的属性；<br> 派生类无法访问基类的私有成员；<br> 不论继承权限如何，派生类总能访问<strong>隐藏基类</strong>对象的public与protected成员；<br> 如在派生类内创建基类对象，则只可访问其public成员</p> 
<p>public继承反应了现实中 <strong>“is a”</strong> 的关系</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">fish</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span><span class="token operator">:</span>
	string name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">GoldFish</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">fish</span>  <span class="token comment">//此处的public为继承权限  缺省时为private继承</span></span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span><span class="token operator">:</span>
	string color<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	GoldFish gfish<span class="token punctuation">;</span>
    gfish<span class="token punctuation">.</span>name <span class="token operator">=</span><span class="token string">"jinyu"</span><span class="token punctuation">;</span>
	gfisn<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">"gold"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<table><thead><tr><th>/</th><th>自身类</th><th>子类</th><th>外界</th></tr></thead><tbody><tr><td>public</td><td>1</td><td>1</td><td>1</td></tr><tr><td>protected</td><td>1</td><td>1</td><td>0</td></tr><tr><td>private</td><td>1</td><td>0</td><td>0</td></tr></tbody></table> 
<p>派生类对象构建时先构建其基类-产生对象时，派生类含有隐藏基类对象</p> 
<p>继承权限：<br> <code>class GoldFish:public fish</code>中的<strong>public</strong>为继承权限</p> 
<ul><li>子类继承的父类成员在自身类内不能高于“继承权限”</li><li>子类的构造函数优先构造父类再构造子类</li><li>执行子类的析构函数时优先析构子类再析构父类</li></ul> 
<p>父类的构造需要传参时，则必须写于初始化列表中</p> 
<h4><a id="_1324"></a>同名问题</h4> 
<h5><a id="_1325"></a>属性同名</h5> 
<p><strong>同名隐藏</strong>-若派生类对象某一属性与基类重名，则会<strong>隐藏</strong> 基类的同名属性；要对其访问需要使用作用域解析符<code>::</code></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{<!-- --></span>
<span class="token comment">//若声明派生类为基类的友元friend class B;则派生类可访问基类所有成员</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">int</span> ax<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">ax</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> ax<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
   <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">ax</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
   <span class="token keyword">void</span> <span class="token function">fun</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   ax <span class="token operator">=</span> <span class="token number">100</span> <span class="token punctuation">;</span>
   <span class="token comment">//可以typedef A Base；</span>
   <span class="token comment">//从而Base::ax = 200;</span>
   A<span class="token double-colon punctuation">::</span>ax <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    B b<span class="token punctuation">;</span>
    b<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<h5><a id="_1358"></a>方法同名</h5> 
<p>同样对其使用作用域解析符<code>::</code></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">int</span> ax<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">ax</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">fun</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   ax <span class="token operator">=</span> <span class="token number">100</span> <span class="token punctuation">;</span>
   A<span class="token double-colon punctuation">::</span>ax <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> ax<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
   <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">ax</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
   <span class="token keyword">void</span> <span class="token function">fun</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   ax <span class="token operator">=</span> <span class="token number">100</span> <span class="token punctuation">;</span>
   A<span class="token double-colon punctuation">::</span>ax <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    B b<span class="token punctuation">;</span>
    b<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    b<span class="token punctuation">.</span><span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>注意，仅可在public继承下可实现；private或protected继承下的隐藏基类在外部函数（main）中无法被访问</li></ul> 
<h4><a id="_1397"></a>赋值兼容规则</h4> 
<p>在任何需要基类对象的地方都可以用公有派生类的对象来代替，这条规则称<strong>赋值兼容规则</strong>。它包括以下情况:C++面向对象编程中一条重要的规则是:公有继承意味着“是一个”。一定要牢牢记住这条规则。<br> 1.派生类的对象可以赋值给基类的对象，这时是把派生类对象中从对应基类中继承来的隐藏对象赋值给基类对象。反过来不行，因为派生类的新成员无值可赋。<br> 2．可以将一个派生类的对象的地址赋给其基类的指针变量，但只能通过这个指针访问派生类中由基类继承来的隐藏对象，不能访问派生类中的新成员。同样也不能反过来做。<br> 3.派生类对象可以初始化基类的引用。引用是别名，但这个别名只能包含派生类对象中的由基类继承来的隐藏对象。</p> 
<h3><a id="32__1402"></a>3.2 多态</h3> 
<p>多态分为静多态与动多态</p> 
<p>相对于发生在编译期的静多态，动多态发生在运行期；这也是两者的主要区别</p> 
<table><thead><tr><th></th><th>时期</th><th>例子</th></tr></thead><tbody><tr><td>静多态</td><td>编译期</td><td>摸板，函数重载</td></tr><tr><td>动多态</td><td>运行期</td><td>虚函数</td></tr></tbody></table> 
<h4><a id="_1412"></a>动多态</h4> 
<p>动多态的产生条件：<br> 使用指针或是引用调用虚函数 ，且对象需是一个完整的对象</p> 
<blockquote> 
 <p>完整的对象是指 构造函数执行完毕，析构函数未执行的实例</p> 
</blockquote> 
<p><strong>即动多态是通过继承（public继承）、虚函数(virtual)、指针（-&gt;&amp; virtual）来实现。（缺一不可）</strong></p> 
<p>动多态的调用过程：</p> 
<ol><li>使用指针或者引用调用虚函数</li><li>在对象中找到vfptr</li><li>根据vfptr找到vftable</li><li>在vftable中找到要调用的函数</li><li>调用</li></ol> 
<h4><a id="_1430"></a>虚函数</h4> 
<p>virtual<br> 虚函数具有传递性</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">object</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
   <span class="token keyword">virtual</span> object <span class="token operator">*</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span>


<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Object</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> Base <span class="token operator">*</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> 
<span class="token punctuation">;</span>
</code></pre> 
<h4><a id="vftable_1451"></a>vftable(虚表)</h4> 
<p>· vftable什么时候产生？于何处存储？<br> 编译期；rodata段（只读数据段）</p> 
<p>class中有虚函数就会创建虚表；<br> 虚表存储各虚函数的函数指针；</p> 
<p>编译时，编译器若发现派生类对象有基类的同名函数，则会发生同名覆盖，虚表中的函数指针被替换；</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span> 
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">value</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">derive</span>  <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span> <span class="token keyword">int</span> sum<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token function">derive</span>  <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">base</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">,</span> <span class="token function">sum</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  derive  <span class="token function">derive</span>  <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//大小为12个字节，8（sum，value）+ 4 （虚表指针vfptr）</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>为了调用虚表中的函数指针，每个有虚函数的类都会额外开辟4个字节来存储一个虚指针_vfptr，用其来索引向自己类的虚表；</p> 
<h5><a id="_vfptr_1488"></a>虚表指针_vfptr</h5> 
<p>_vfptr在构造时候写入对象的存储空间，其用来指向该类的vftable</p> 
<p><strong>一个类的虚表只有一份</strong><br> 虚表指针存在于派生类对象的隐藏基类中</p> 
<p>如在上例中，创建derive对象时，首先调用base的构造函数创建隐藏base类；因其有虚函数，编译器同时创建虚表指针_vfptr，使其指向base的虚表；之后构建derive，对所有vftable中的同名函数进行<code>同名覆盖</code>，同时，该派生类中的虚表指针改为指向derive的虚表；</p> 
<p>即-父类中的虚函数会被子类中相同的函数覆盖；该过程发生于子类在构建时的虚函数表中</p> 
<ul><li> <p>什么情况下析构函数需写成需虚函数？<br> 当存在父类指针指向堆上的子类对象时，则需把父类的虚构函数写成虚函数**</p> </li><li> <p>构造函数能不能写成虚函数<br> 不能，构造函数是虚表创建的前提，而virtual函数的构造需要用到虚表</p> </li><li> <p>静态函数能不能写成虚函数<br> 不能；静态函数不依赖于对象，从而无法产生动多态</p> </li><li> <p>析构函数能不能写成虚函数<br> 能，当基类析构函数声明为虚函数时，其派生类析构函数自动带有virtual声明<br> 析构函数会reset虚表，当derive的析构函数执行完成后，_vfptr会重置指向base的虚表，从而执行base的析构函数；</p> </li><li> <p>虚函数能否写为内敛函数<br> 不能，虚函数在编译期需要将函数指针放入vftable；内敛函数在编译期展开；在release版本中没有地址</p> </li></ul> 
<p>类的编译顺序<br> 先编译类名<br> 再编译成员名<br> 再编译成员函数</p> 
<h3><a id="RTTI_1527"></a>RTTI</h3> 
<p>vftable = RTTI + 函数指针</p> 
<pre><code class="prism language-cpp">
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	
	
	<span class="token comment">//dynamic_cast&lt;type_name&gt; 父类指针强转子类指针的专用类型指针，</span>
	<span class="token comment">//于vftable的RTTI中寻找type_name类型的</span>
	<span class="token comment">//1.必须有RTTI，2.父类指针指向的对象中的RTTI确实是子类</span>
	Derive <span class="token operator">*</span>pd <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Derive<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_1548"></a>菱形继承与虚继承</h4> 
<p>菱形继承<br> ——该继承会导致造成公共基类在派生类对象中存在多个实例<br> <img src="https://images2.imgbox.com/7b/61/OXwH5xWa_o.png" alt="在这里插入图片描述"></p> 
<p>使用虚继承来解决菱形继承问题</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">int</span> value<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token function">Object</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">value</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">derive</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">Object</span><span class="token comment">//虚继承</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">int</span> num<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">num</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>，<span class="token function">Object</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">Object</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">int</span> sum<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">sum</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>，<span class="token function">Object</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Det</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">base</span><span class="token punctuation">,</span><span class="token keyword">public</span> <span class="token class-name">Test</span></span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
<span class="token keyword">int</span> total<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token function">Det</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">total</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">base</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Test</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Object</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  det <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>d1内存分配图如下<br> <img src="https://images2.imgbox.com/86/dd/rBCq6fVo_o.png" alt="在这里插入图片描述"><br> object首先被创建</p> 
<p>被虚继承的类称为虚基类；</p> 
<p>虚基类在派生类对象中存放于vbtable中；</p> 
<p>虚基类在派生类中被构造时，在原本存储该基类对象的位置上创建一个指针，来指向虚基类实例的位置；</p> 
<p>从而保证虚基类在派生类中只会有一个实例存在</p> 
<p>虚基类在派生类构造时会被直接当作父类继承</p> 
<h3><a id="_1606"></a>纯虚函数与抽象类</h3> 
<p>virtual void add() = 0；<br> base的纯虚函数实现依靠derive；<br> 纯虚函数是为给派生类提供接口；</p> 
<p>有纯虚函数的类叫做抽象类<br> 抽象类不能用来实例化对象，出于该目的，也常将抽象类的构造函数声明为protect权限；</p> 
<p>要求限制子类必须覆盖某个接口</p> 
<pre><code class="prism language-cpp">
<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//纯虚函数</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> main
<span class="token punctuation">{<!-- --></span>
   A a<span class="token punctuation">;</span>
   
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4926c86cc5091dede6700878e9f1b8e9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Ubuntu下搭建伪分布式从0开始安装Hive详细教程（从JDK安装、Hadoop搭建开始）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d83c68feb0e303dd62053621a1b62435/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">认识---static在c&#43;&#43;里到底干点啥？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>