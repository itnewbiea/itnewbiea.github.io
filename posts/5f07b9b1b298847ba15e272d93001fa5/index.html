<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux通配符和正则表达式深层解析... - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux通配符和正则表达式深层解析..." />
<meta property="og:description" content="目录：
(一)了解通配符和正则的作用
(二)通配符的使用
(三)正则表达式的使用
(四)扩展正则表达式的使用
(一)了解通配符和正则的作用
(1.1)在我们日常的工作中，我们都会使用到通配符或者正则表达式。通配符是一种特殊语句，主要有星号(*)和问号(?)，用来模糊搜索文件。当查找文件夹时，可以使用它来代替一个或多个真正字符；当不知道真正字符或者懒得输入完整名字时，常常使用通配符代替一个或多个真正的字符。正则表达式是计算机科学的一个概念，正则表达式通常被用来检索、替换那些符合某个模式的文本，正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。
(1.2)不管是通配符还是正则表达式，其功能都是实现模糊匹配，用来匹配某一类东西，并不是匹配具体的某一个值。通配符一般用于shell中，正则表达式一般用于其他语言。
(二)通配符的使用
(2.1)首先第一个是“[]”中括号[list]，匹配的是list中的任意单一字符。例如a[xyz]b，a与b之间必须也只能有一个字符，但只能是x或y或z，如：axb，ayb，azb
(2.2)第二个是“[c1-c2]”，用来表示字符的范围，匹配c1-c2的任意单一字符，如[0-9]或[a-z]。例如“a[0-9]b”表示的是0到9之间必须也只能有一个字符，如：a0b、a1b、a2b、a3b、a4b、a5b、a6b、a7b、a8b、a9b
注意：如果我们需要匹配的是单个字母，且不分大小写，则我们可以使用“[a-zA-Z]”来进行表示。
(2.3)第三个是“[!c1-c2]或[^c1-c2]”，匹配的是不在c1-c2的任意字符。例如a[!0-9]b，a[^0-9]b表示a与b之间只有一个字符，并且不是数字0-9之间的字符，符合要求的有：acb、adb
(2.4)示例：我们在vms002主机上创建一个rh124目录，然后在rh124目录中创建相关的文件：11111、a111、a_111、a22、lwang、lWang、rh124。接着我们查询第一个字符时a到z之间的，第二个字符是非数字的，后面的字符都是任意的。
# mkdir rh124
# touch 11111 a111 a_111 a22 lwang lWang rh124
# ls [a-z][^0-9]*---查询第一个字符时a到z之间的，第二个字符是非数字的，后面的字符都是任意的
(2.5)示例：接着我们的需求是在rh124目录下找到格式为第一个字符是a到z之间，第二个字符是a或者“-”或者z三个字符中的任意一个，后面的字符是任意的。这样我们就可以符合要求的文件名a-1
# touch a-1
# ls [a-z][a-z]*
(2.6)第四个是精确指定字符的大小写“[[:upper:]]”、“[[:lower:]]”，由于我们使用[a-z]的时候可能会匹配出a到z和A到Z之间的字符，大小写并不能精确匹配，所以我们可以使用“[[:upper:]]”表示纯大写的字符，我们可以使用“[[:lower:]]”表示纯小写的字符。
# ls [[:upper:]]*---查询所有纯大写字目开头的文件名
# ls [[:lower:]]*---查询所有纯小写字母开头的文件名
(2.7)当然第四个精确指定字符中还是有其他表示特定字符的方式的：“[[:alpha:]]”表示的是只匹配字母，“[[:alnum:]]”表示的是匹配字母和数字，“[[:digit:]]”表示的是匹配纯数字。
(2.8)示例：现在我们的系统中没有marry用户，我们首先创建一个marry用户，并且指定在根下创建marry的家目录(图1-5)。然后我们将marry家目录删除，此时我们切换到marry用户后发现由于没有家目录，所以切换后是异常的状态(图1-6)，此时我们在/etc/default/useradd配置文件中，查询到用户家目录的模板文件在/etc/skel的目录中(图1-7)，我们将/etc/skel中的所有模板文件都拷贝到marry家目录下，并修改了属主和属组的相关信息，此时便可以正常的进行marry用户的切换了(图1-8)。
# useradd -d /marry marry---创建一个marry用户，并且指定在根下创建marry的家目录
# rm -rf /marry/---删除marry的家目录
# vim /etc/default/useradd---查询/etc/default/目录下的useradd文件
# cp -a /etc/skel/.[^.]* /marry/---将/etc/skel/目录下的所有以“.”开头，第二个字符由于是“[]”所以必须要存在而且是非“.”号，后面跟任意字符的文件全部拷贝到/marry家目录下，skel表示骨架、框架(图1-8)
# chown -R marry.marry /marry/---修改/marry家目录的所有者和所属组都为marry(图1-8)
(2.9)第五个是“?”问号，匹配的是任意一个字符。例如在rh124目录中，我们查询“[a-z]????”，表示的是查询第一个字符是字母构成，后面会有四个任意的字符构成的文件名。
注意：“?”问号是不能匹配到表示隐藏文件的“.”点号的。即表示如果现在系统中有“.aa”文件，我们使用“???”是不能匹配出这个隐藏文件的，如果我们想要匹配出这类隐藏文件则应该开启全局通配符处理。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5f07b9b1b298847ba15e272d93001fa5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-28T11:13:49+08:00" />
<meta property="article:modified_time" content="2023-04-28T11:13:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux通配符和正则表达式深层解析...</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <div> 
 <p>目录：</p> 
 <p>(一)了解通配符和正则的作用</p> 
 <p>(二)通配符的使用</p> 
 <p>(三)<a href="https://so.csdn.net/so/search?q=%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" rel="noopener noreferrer">正则表达式</a>的使用</p> 
 <p>(四)扩展正则表达式的使用</p> 
 <p>(一)了解通配符和正则的作用</p> 
 <p>(1.1)在我们日常的工作中，我们都会使用到通配符或者正则表达式。通配符是一种特殊语句，主要有星号(*)和问号(?)，用来模糊搜索文件。当查找文件夹时，可以使用它来代替一个或多个真正字符；当不知道真正字符或者懒得输入完整名字时，常常使用通配符代替一个或多个真正的字符。正则表达式是计算机科学的一个概念，正则表达式通常被用来检索、替换那些符合某个模式的文本，正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p> 
 <p>(1.2)不管是通配符还是正则表达式，其功能都是实现模糊匹配，用来匹配某一类东西，并不是匹配具体的某一个值。通配符一般用于shell中，正则表达式一般用于其他语言。</p> 
 <p>(二)通配符的使用</p> 
 <p>(2.1)首先第一个是“[]”中括号[list]，匹配的是list中的任意单一字符。例如a[xyz]b，a与b之间必须也只能有一个字符，但只能是x或y或z，如：axb，ayb，azb</p> 
 <p>(2.2)第二个是“[c1-c2]”，用来表示字符的范围，匹配c1-c2的任意单一字符，如[0-9]或[a-z]。例如“a[0-9]b”表示的是0到9之间必须也只能有一个字符，如：a0b、a1b、a2b、a3b、a4b、a5b、a6b、a7b、a8b、a9b</p> 
 <p>注意：如果我们需要匹配的是单个字母，且不分大小写，则我们可以使用“[a-zA-Z]”来进行表示。</p> 
 <p>(2.3)第三个是“[!c1-c2]或[^c1-c2]”，匹配的是不在c1-c2的任意字符。例如a[!0-9]b，a[^0-9]b表示a与b之间只有一个字符，并且不是数字0-9之间的字符，符合要求的有：acb、adb</p> 
 <p>(2.4)示例：我们在vms002主机上创建一个rh124目录，然后在rh124目录中创建相关的文件：11111、a111、a_111、a22、lwang、lWang、rh124。接着我们查询第一个字符时a到z之间的，第二个字符是非数字的，后面的字符都是任意的。</p> 
 <p># mkdir rh124</p> 
 <p># touch 11111 a111 a_111 a22 lwang lWang rh124</p> 
 <p># ls [a-z][^0-9]*---查询第一个字符时a到z之间的，第二个字符是非数字的，后面的字符都是任意的</p> 
 <p align="center"><img src="https://images2.imgbox.com/34/47/1gc189OC_o.png" alt="acbd93cad9a511805a3fdf62c19736b1.png"></p> 
 <p align="center"><img src="https://images2.imgbox.com/9a/1c/TWkyamuP_o.png" alt="3889cbc7c4134f1e1310b8052f786b72.png"></p> 
 <p>(2.5)示例：接着我们的需求是在rh124目录下找到格式为第一个字符是a到z之间，第二个字符是a或者“-”或者z三个字符中的任意一个，后面的字符是任意的。这样我们就可以符合要求的文件名a-1</p> 
 <p># touch a-1</p> 
 <p># ls [a-z][a-z]*</p> 
 <p align="center"><img src="https://images2.imgbox.com/12/f0/kN09tx2A_o.png" alt="159bd4661742d539220305eebeea389d.png"></p> 
 <p>(2.6)第四个是精确指定字符的大小写“[[:upper:]]”、“[[:lower:]]”，由于我们使用[a-z]的时候可能会匹配出a到z和A到Z之间的字符，大小写并不能精确匹配，所以我们可以使用“[[:upper:]]”表示纯大写的字符，我们可以使用“[[:lower:]]”表示纯小写的字符。</p> 
 <p># ls [[:upper:]]*---查询所有纯大写字目开头的文件名</p> 
 <p># ls [[:lower:]]*---查询所有纯小写字母开头的文件名</p> 
 <p align="center"><img src="https://images2.imgbox.com/5e/84/R7uWtIzv_o.png" alt="2c0355109ae9fd7b974933689c281069.png"></p> 
 <p>(2.7)当然第四个精确指定字符中还是有其他表示特定字符的方式的：“[[:alpha:]]”表示的是只匹配字母，“[[:alnum:]]”表示的是匹配字母和数字，“[[:digit:]]”表示的是匹配纯数字。</p> 
 <p>(2.8)示例：现在我们的系统中没有marry用户，我们首先创建一个marry用户，并且指定在根下创建marry的家目录(图1-5)。然后我们将marry家目录删除，此时我们切换到marry用户后发现由于没有家目录，所以切换后是异常的状态(图1-6)，此时我们在/etc/default/useradd配置文件中，查询到用户家目录的模板文件在/etc/skel的目录中(图1-7)，我们将/etc/skel中的所有模板文件都拷贝到marry家目录下，并修改了属主和属组的相关信息，此时便可以正常的进行marry用户的切换了(图1-8)。</p> 
 <p># useradd -d /marry marry---创建一个marry用户，并且指定在根下创建marry的家目录</p> 
 <p># rm -rf /marry/---删除marry的家目录</p> 
 <p># vim /etc/default/useradd---查询/etc/default/目录下的useradd文件</p> 
 <p># cp -a /etc/skel/.[^.]* /marry/---将/etc/skel/目录下的所有以“.”开头，第二个字符由于是“[]”所以必须要存在而且是非“.”号，后面跟任意字符的文件全部拷贝到/marry家目录下，skel表示骨架、框架(图1-8)</p> 
 <p># chown -R marry.marry /marry/---修改/marry家目录的所有者和所属组都为marry(图1-8)</p> 
 <p align="center"><img src="https://images2.imgbox.com/31/a4/T4D7i1z8_o.png" alt="9b4420e0695df4a1719ec89697cfaf90.png"></p> 
 <p align="center"><img src="https://images2.imgbox.com/68/2d/ybbtJDQE_o.png" alt="c4bc092989cd31151ed18c63b9a90ee0.png"></p> 
 <p align="center"><img src="https://images2.imgbox.com/56/2f/QTlo8der_o.png" alt="9e9ee0d38609bd1425a5536e68d79983.png"></p> 
 <p align="center"><img src="https://images2.imgbox.com/35/70/OD6OAKZt_o.png" alt="a347f95932ec323ff306e00cf9fdf2ee.png"></p> 
 <p>(2.9)第五个是“?”问号，匹配的是任意一个字符。例如在rh124目录中，我们查询“[a-z]????”，表示的是查询第一个字符是字母构成，后面会有四个任意的字符构成的文件名。</p> 
 <p>注意：“?”问号是不能匹配到表示隐藏文件的“.”点号的。即表示如果现在系统中有“.aa”文件，我们使用“???”是不能匹配出这个隐藏文件的，如果我们想要匹配出这类隐藏文件则应该开启全局通配符处理。</p> 
 <p># ls [a-z]????---查询第一个字符是字母构成，后面会有四个任意的字符构成的文件名</p> 
 <p align="center"><img src="https://images2.imgbox.com/12/d6/Him8G4P3_o.png" alt="2b366c9d1b1c3f3e4914fcceb633d1fa.png"></p> 
 <p>(2.10)第六个是“*”星号，表示匹配任意长度的任意字符。例如我们将所有文件名以a字母开头，且后面是任意字符的文件都删除掉</p> 
 <p># touch aaa bb cc aa2---创建如下的四个文件</p> 
 <p># rm -rf a*---将所有文件名以a字母开头，后面是任意字符的文件都删除掉</p> 
 <p align="center"><img src="https://images2.imgbox.com/c3/79/A9oX3NmE_o.png" alt="acf88457bb6876694118fe4ea84024a3.png"></p> 
 <p>(2.11)第七个是“\”反斜线，表示转义符，有时候我们在当前系统中安装vsftp软件的时候我们可能会使用“# yum install vsftp*”进行安装，但是由于我们在执行系统命令的时候，首先是在shell进程中运行然后才到达YUM仓库中去进行相关的软件包查找工作。即我们在执行“vsftp*”的时候，shell会首先对“vsftp*”进行shell解析，查找当前目录中是否有符合“vsftp*”格式的文件，如果现在我们的当前目录中存在着一个文件vsftp123，则此时shell会将“vsftp*”解析成“vsftp123”，然后再到YUM仓库中去查找“vsftp123”的软件包进行安装，而这样的情况并不是我们所希望的。所以我们在shell中执行安装软件包的命令时，一般是建议使用转义符“# yum install vsftp\*”这样的格式进行安装是比较好的，这样就可以防止shell对我们所使用的通配符进行解析的情况产生。</p> 
 <p># yum install vsftp\*---使用转义符对通配符进行转义，防止shell对通配符进行解析</p> 
 <p># yum install 'vsftp*'---也可以使用单引号来进行转义，防止shell对通配符进行解析</p> 
 <p>(2.12)需要注意的是，我们在创建文件的时候，文件名是不可能包含“/”的，因为有“/”就是代表创建了一个目录。</p> 
 <p># touch rh124/cc---此时“rh124/cc”并不是表示一个文件名，而是表示在rh124/目录下创建一个cc文件</p> 
 <p align="center"><img src="https://images2.imgbox.com/4b/1b/nYgw27vg_o.png" alt="b0beda450b60145bf5cecb7f013e1c79.png"></p> 
 <p>(三)正则表达式的使用</p> 
 <p>(3.1)正则表达式是用来匹配字符串的，针对文件内容的文本过滤工具，大都用到正则表达式，如vim、grep、awk、sed等。正则表达式和我们上面说的通配符实现的效果都是一样的，是为了实现查询信息的模糊匹配。</p> 
 <p>(3.2)第一个“^”表示开头，例如我们先将/etc/passwd文件拷贝到当前目录中，然后查询passwd文件中以root字符开头的行，此时可以使用“^”来进行标识。</p> 
 <p># grep ^root passwd</p> 
 <p align="center"><img src="https://images2.imgbox.com/39/5a/l2brGuRz_o.png" alt="028e0f167861d0d8f0cef4681e1bf327.png"></p> 
 <p>(3.3)第二个“$”表示行末，我们先将passwd文件中的相关行进行设计一下，然后查找每一行行末是“bash”字符的行。</p> 
 <p># grep bash$ passwd---查询行末字符是bash字符的所有行</p> 
 <p align="center"><img src="https://images2.imgbox.com/30/66/bZL5O1cd_o.png" alt="2a5a52629318a5203a3d19ebbef4643d.png"></p> 
 <p align="center"><img src="https://images2.imgbox.com/24/dc/WEk8n9pi_o.png" alt="05bb9c388eb7aaa15acf7e5752c60346.png"></p> 
 <p>(3.4)第三个“\</p> 
 <p># grep '\</p> 
 <p># grep '\btom' aa.txt---查询以tom字符开头的所有行</p> 
 <p align="center"><img src="https://images2.imgbox.com/75/f3/Fkwg6I35_o.png" alt="04a2f1c45268f4a3e81c99a5a91051a3.png"></p> 
 <p align="center"><img src="https://images2.imgbox.com/86/35/waK1y3gP_o.png" alt="a1299ae53db9f93074f4d3c2d0ace459.png"></p> 
 <p>(3.5)第四个“\&gt;”或者“\b”表示锚定的是单词的末尾，在aa.txt文件中，我们查询“tom\&gt;”以tom字符结束的所有行(图1-17)。如果我们希望查询出所有以tom为单词独立存在的行时，我们可以同时使用“\”符号(图1-18)。</p> 
 <p># grep 'tom\&gt;' aa.txt---查询“tom\&gt;”以tom字符结束的所有行</p> 
 <p># grep 'tom\b' aa.txt---查询“tom\b”以tom字符结束的所有行</p> 
 <p># grep '\' aa.txt---查询出所有以tom为单词独立存在的行</p> 
 <p># grep '\btom\b' aa.txt ---查询出所有以tom为单词独立存在的行</p> 
 <p align="center"><img src="https://images2.imgbox.com/f0/bf/xFWzZKrf_o.png" alt="9b23bb9595c9564e50f9ac6ab6e97bc6.png"></p> 
 <p align="center"><img src="https://images2.imgbox.com/86/e8/smQgyrVI_o.png" alt="c6abf0da288bfacb18cce994751807fa.png"></p> 
 <p>(3.6)示例：现在我们希望查询SELinux中对端口设置的上下文信息，如果需要过滤具体的端口号的信息，则可以使用“\”来指定独立的单词信息，例如过滤出只包含80端口上下文的行，如果我们只是使用“grep 80”过滤出的信息是不正确的(图1-19)，我们应该使用“grep '\&lt;80\&gt;'”才是正确的(图1-20)。</p> 
 <p># semanage port -l | grep 80---查询当前系统中所有包含80端口上下文的信息</p> 
 <p># semanage port -l | grep '\&lt;80\&gt;'---查询当前系统中只含有80端口上下文的信息行</p> 
 <p align="center"><img src="https://images2.imgbox.com/4b/5c/lEWA19zV_o.png" alt="1ff9aed3bfd08b0719f83d609a0194bc.png"></p> 
 <p align="center"><img src="https://images2.imgbox.com/20/f1/0rhHrjAx_o.png" alt="12f9958248cb15b4313cea84944087b4.png"></p> 
 <p>(3.7)第五个“.”表示单个任意字符，和通配符中的“?”问号的意义一致。例如我们想要匹配出aa.txt文件中to单词后跟任意一个字符的所有符合要求的行(图1-21)。如果我们希望“.”符号没有模糊查询的意思，就代表它本身的字符的意思，则我们可以使用“\”作为转义符，这样就可以直接查询出包含“to.”字样的行(图1-22)。</p> 
 <p># grep 'to.' aa.txt---查询出所有符合to单词后还会跟一个任意字符的行</p> 
 <p># grep 'to\.' aa.txt---使用转义符，直接查询包含“to.”字符的行</p> 
 <p align="center"><img src="https://images2.imgbox.com/51/60/ZusXuPb8_o.png" alt="f772252ed87a7ad03660c09224209857.png"></p> 
 <p align="center"><img src="https://images2.imgbox.com/33/08/RFa4Sxfg_o.png" alt="7bfc9388b2a6bd6093958a6e06b2d865.png"></p> 
 <p>(3.8)第六个“[]”，表示的是匹配指定范围内的任意单个字符。</p> 
 <p>(3.9)第七个“[^]”，表示的是匹配指定范围外的任意单个字符。</p> 
 <p>(3.10)分组概念</p> 
 <p>(3.10.1)第八个“<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-1-Frame" tabindex="0"><span class="math" id="MathJax-Span-1"><span class="mrow" id="MathJax-Span-2"></span></span><span class="MJX_Assistive_MathML"></span></span>{2}\.\'</p> 
 <p align="center"><img src="https://images2.imgbox.com/61/d2/oSQjiUFr_o.png" alt="880ec607169c86290e51fc8013873fdd.png"></p> 
 <p>(4.9)一般我们在表示正则表达式中表达式的部分的时候是建议加上单引号将表达式引起来的。如果我们在系统中如果原先存在一个toz文件名的文件，此时我们对表达式不加单引号的情况下，首先会将查询的“to?”发送到shell中进行shell解析，此时sehll会对应“to?”在系统中查找并解析成“toz”，然后再将“toz”发送到egrep中进行解析，此时在aa.txt文件中是查询不出来任何信息的。所以一般是需要将表示正则表达式中表达式的部分的时候是建议加上单引号这样可以防止shell解析的情况发生。</p> 
 <p># egrep 'to?' aa.txt---查询aa.txt中to单词后出现一个任意字符，这个任意字符出现0次或者1次</p> 
 <p># egrep to\? aa.txt---和以上使用单引号的效果一致</p> 
 <p align="center"><img src="https://images2.imgbox.com/07/ad/tj3YsQXt_o.png" alt="1b8a229e080a205a642ab0f34b0ad61b.png"></p> 
 <p>—————— 本文至此结束，感谢阅读 ——————</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9f653bf58fe1fe5b20fc1b7d6688438f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据科学与机器学习案例之WiFi定位系统的位置预测</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7a678cf626658e533683fbadc2aa8836/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">NLP中的对抗训练</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>