<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis主从复制（八） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis主从复制（八）" />
<meta property="og:description" content=" 前言：之前写到在系统中集成Redis之后，可以减少对数据库的访问量，从而增加系统的并发量，但是单个Redis的性能终究是有限的，在系统业务量不断增大的时候，单节点的Redis的并发量很容易就达到上限，这种时候就需要引入Redis的主从复制模式（读写分离模式，一般搭配哨兵机制一起使用）。
一、主从复制模式 在单节点Redis的基础上，再扩展Redis节点，选择其中一台作为主节点，其余的Redis节点就是从节点，主节点主要负责数据的写入，从节点负责读数据请求，主节点会复制自身的数据到从节点。
主从复制原理： 首先进行全量更新
slave服务器向master发送psync命令，告诉master我需要同步数据了。master接收到psync命令后会进行BGSAVE命令生成RDB文件快照，同时将此刻起的写命令记录在缓存区。master生RDB成完后，会将RDB文件发送给slave。slave接收到RDB文件后会载入内存，并且将数据库状态变更为master在执行BGSAVE时的状态一致。master会发送保存在缓冲区里的所有写命令slave执行这些写命令。 运行过程中进行增量更新
在master全量数据同步到slave之后，如果再有写命令进到master，在master执行完该写命令之后，会把这条写命令发送给所有slave节点，增量更新可以把master看作是redis的客户端，slave看作是redis的服务端：
例如：用户先向master发送一条写命令：set name shanxi，master在执行完这条命令之后，会向所有slave发送这条写命令，slave接收到之后，会在本地执行set name shanxi。
主从模式：一主一从、一主二从（常用）、树状模式（当有多个从节点时，这种模式会降低主节点的同步压力）
一般不推荐一个主节点对应多个从节点，一来会占用内网的带宽，二来主节点的同步压力也会很大。
二、主从复制模式配置 首先删除从节点的rdb和aof文件，以防出现影响。
在配置主从复制的时候，只需要配置从节点即可，不需要对主节点进行配置。
修改redis的配置文件：
################################# REPLICATION ################################# # 配置所属主节点的地址与端口 slaveof 192.168.40.41 6379 # 配置所属主节点的认证密码 masterauth 123456 # 配置从节点为只读模式，默认配置，不需要进行修改 slave-read-only yes 注意：使用主从复制模式后，master必须开启持久化，否则master宕机重启以后会把从节点的数据清空
三、查看与测试 1、主从配置好之后，重启redis，然后进入到redis的客户端（redis-cli命令进入），在客户端输入info replication命令可以看到主从相关信息，在主节点输入该命令可以看到如下信息：
从节点输入info replication命令会看到如下信息：
2、测试
在主节点执行一些写命令，然后在从节点使用get命令看是否能获取到主节点写入的值。 主节点执行：set name 10087
从节点执行：get name（从节点可以获取到10087）
在从节点执行写命令，会报不允许写入错误停掉一台从节点，然后在主节点执行一些写的命令，然后再次启动这台停掉的从节点，会发现在停机（或宕机）期间主节点写入的数据都被同步了进来 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d464b002868791401343e2fdbe7200e0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-11T17:04:04+08:00" />
<meta property="article:modified_time" content="2020-09-11T17:04:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis主从复制（八）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>前言</strong>：之前写到在系统中集成Redis之后，可以减少对数据库的访问量，从而增加系统的并发量，但是单个Redis的性能终究是有限的，在系统业务量不断增大的时候，单节点的Redis的并发量很容易就达到上限，这种时候就需要引入Redis的主从复制模式（读写分离模式，一般搭配哨兵机制一起使用）。</p> 
<h2>一、主从复制模式</h2> 
<p style="text-indent:33px;">在单节点Redis的基础上，再扩展Redis节点，选择其中一台作为主节点，其余的Redis节点就是从节点，主节点主要负责数据的写入，从节点负责读数据请求，主节点会复制自身的数据到从节点。</p> 
<p style="text-align:center;"><img alt="" height="392" src="https://images2.imgbox.com/87/72/XpWv9ZoU_o.png" width="700"></p> 
<h3><strong>主从复制原理：</strong></h3> 
<p> </p> 
<p><strong>首先进行全量更新</strong></p> 
<p style="text-align:center;"><img alt="" height="382" src="https://images2.imgbox.com/8b/b2/LXQSIMmN_o.png" width="700"></p> 
<p style="text-indent:33px;"> </p> 
<ul><li>slave服务器向master发送psync命令，告诉master我需要同步数据了。</li><li>master接收到psync命令后会进行BGSAVE命令生成RDB文件快照，同时将此刻起的写命令记录在缓存区。</li><li>master生RDB成完后，会将RDB文件发送给slave。</li><li>slave接收到RDB文件后会载入内存，并且将数据库状态变更为master在执行BGSAVE时的状态一致。</li><li>master会发送保存在缓冲区里的所有写命令</li><li>slave执行这些写命令。</li></ul> 
<p> </p> 
<p><strong>运行过程中进行增量更新</strong></p> 
<p style="text-indent:33px;">在master全量数据同步到slave之后，如果再有写命令进到master，在master执行完该写命令之后，会把这条写命令发送给所有slave节点，增量更新可以把master看作是redis的客户端，slave看作是redis的服务端：</p> 
<p>例如：用户先向master发送一条写命令：set name shanxi，master在执行完这条命令之后，会向所有slave发送这条写命令，slave接收到之后，会在本地执行set name shanxi。</p> 
<p> </p> 
<p><strong>主从模式</strong>：一主一从、一主二从（常用）、树状模式（当有多个从节点时，这种模式会降低主节点的同步压力）</p> 
<p>一般不推荐一个主节点对应多个从节点，一来会占用内网的带宽，二来主节点的同步压力也会很大。</p> 
<p> </p> 
<h2>二、主从复制模式配置</h2> 
<p style="text-indent:33px;">首先删除从节点的rdb和aof文件，以防出现影响。</p> 
<p style="text-indent:33px;">在配置主从复制的时候，只需要配置从节点即可，不需要对主节点进行配置。</p> 
<p style="text-indent:33px;">修改redis的配置文件：</p> 
<pre><code>################################# REPLICATION #################################

# 配置所属主节点的地址与端口
slaveof 192.168.40.41 6379

# 配置所属主节点的认证密码
masterauth 123456

# 配置从节点为只读模式，默认配置，不需要进行修改
slave-read-only yes</code></pre> 
<p>注意：使用主从复制模式后，master必须开启持久化，否则master宕机重启以后会把从节点的数据清空</p> 
<h2>三、查看与测试</h2> 
<p>1、主从配置好之后，重启redis，然后进入到redis的客户端（redis-cli命令进入），在客户端输入info replication命令可以看到主从相关信息，在主节点输入该命令可以看到如下信息：</p> 
<p><img alt="" height="287" src="https://images2.imgbox.com/01/5f/6oPpl8T7_o.png" width="626"></p> 
<p>从节点输入info replication命令会看到如下信息：</p> 
<p><img alt="" height="411" src="https://images2.imgbox.com/c7/4e/v4Udguwe_o.png" width="550"></p> 
<p> 2、测试</p> 
<ul><li>在主节点执行一些写命令，然后在从节点使用get命令看是否能获取到主节点写入的值。</li></ul> 
<p style="text-indent:33px;">主节点执行：set name 10087</p> 
<p style="text-indent:33px;">从节点执行：get name（从节点可以获取到10087）</p> 
<ul><li>在从节点执行写命令，会报不允许写入错误</li><li>停掉一台从节点，然后在主节点执行一些写的命令，然后再次启动这台停掉的从节点，会发现在停机（或宕机）期间主节点写入的数据都被同步了进来</li></ul> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e8abdc49fa05d68096a2f0b378fed027/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue  Itea软件里直接npm run build 报错npm ERR！ missing script :build</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0bb1e4ee36c4f5a9212497d497f8a4e0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java 的浅拷贝与深拷贝详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>