<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Edit Distance - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Edit Distance" />
<meta property="og:description" content="Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)
You have the following 3 operations permitted on a word:
a) Insert a character
b) Delete a character
c) Replace a character
编辑距离，非常经典的二维DP题目，也是传说中的双序列问题。
首先定义最优解的表示，f[i][j]表示将word1前i 个字符转化为word2前j个字符需要的step数目(注意为了方便处理初始值，f[0][0] = 0表示空串的最小编辑距离，之后定义最优解之间的转换状态, 即：
f[i][j] = min(f[i][j-1]&#43;1,f[i-1][j]&#43;1,f[i-1][j-1]) (word1[i-1]==word2[j-1])
f[i][j] = min(f[i][j-1]&#43;1,f[i-1][j]&#43;1,f[i-1][j-1]&#43;1) (word1[i-1]!=word2[j-1])
注意在f[i][j-1],f[i-1][j],f[i-1][j-1]都是可以经过1步或者0步到达f[i][j]的子状态(增加word2[j-1],删除word1[i-1],替换(或者不替换)得到f[i][j]。
这种直接的解法代码如下：
class Solution(object): def minDistance(self, word1, word2): &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4ea788fecea704ebf4e902f29893d113/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-03T04:34:22+08:00" />
<meta property="article:modified_time" content="2019-07-03T04:34:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Edit Distance</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of steps required to convert <em>word1</em> to <em>word2</em>. (each operation is counted as 1 step.)</p> 
 <p>You have the following 3 operations permitted on a word:</p> 
 <p>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p> 
 <p>编辑距离，非常经典的二维DP题目，也是传说中的双序列问题。</p> 
 <p>首先定义最优解的表示，f[i][j]表示将word1前i 个字符转化为word2前j个字符需要的step数目(注意为了方便处理初始值，f[0][0] = 0表示空串的最小编辑距离，之后定义最优解之间的转换状态, 即：</p> 
 <p>f[i][j] = min(f[i][j-1]+1,f[i-1][j]+1,f[i-1][j-1]) (word1[i-1]==word2[j-1])</p> 
 <p>f[i][j] = min(f[i][j-1]+1,f[i-1][j]+1,f[i-1][j-1]+1) (word1[i-1]!=word2[j-1])</p> 
 <p>注意在f[i][j-1],f[i-1][j],f[i-1][j-1]都是可以经过1步或者0步到达f[i][j]的子状态(增加word2[j-1],删除word1[i-1],替换(或者不替换)得到f[i][j]。</p> 
 <p>这种直接的解法代码如下：</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">class</span><span style="color:#000000;"> Solution(object):
    </span><span style="color:#0000ff;">def</span><span style="color:#000000;"> minDistance(self, word1, word2):
        </span><span style="color:#800000;">"""</span><span style="color:#800000;">
        :type word1: str
        :type word2: str
        :rtype: int
        </span><span style="color:#800000;">"""</span>
        <span style="color:#0000ff;">if</span> <span style="color:#0000ff;">not</span> word1 <span style="color:#0000ff;">and</span> <span style="color:#0000ff;">not</span><span style="color:#000000;"> word2:
            </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> 0
        l1 </span>=<span style="color:#000000;"> len(word1)
        l2 </span>=<span style="color:#000000;"> len(word2)
        res </span>= [[0 <span style="color:#0000ff;">for</span> i <span style="color:#0000ff;">in</span> xrange(l2+1)] <span style="color:#0000ff;">for</span> j <span style="color:#0000ff;">in</span> xrange(l1+1<span style="color:#000000;">)]
        </span><span style="color:#0000ff;">for</span> i <span style="color:#0000ff;">in</span> xrange(1,l1+1<span style="color:#000000;">):
            res[i][0] </span>=<span style="color:#000000;"> i
        </span><span style="color:#0000ff;">for</span> j <span style="color:#0000ff;">in</span> xrange(1,l2+1<span style="color:#000000;">):
            res[0][j] </span>=<span style="color:#000000;"> j
            
        </span><span style="color:#0000ff;">for</span> i <span style="color:#0000ff;">in</span> xrange(1,l1+1<span style="color:#000000;">):
            </span><span style="color:#0000ff;">for</span> j <span style="color:#0000ff;">in</span> xrange(1,l2+1<span style="color:#000000;">):
                res[i][j] </span>= min(res[i-1][j],res[i][j-1])+1
                <span style="color:#0000ff;">if</span> word1[i-1] == word2[j-1<span style="color:#000000;">]:
                    res[i][j] </span>= min(res[i][j],res[i-1][j-1<span style="color:#000000;">])
                </span><span style="color:#0000ff;">else</span><span style="color:#000000;">:
                    res[i][j] </span>= min(res[i][j],res[i-1][j-1]+1<span style="color:#000000;">)
        </span><span style="color:#0000ff;">return</span> res[l1][l2]</pre> 
 </div> 
 <p>可以发现这种解法时间复杂度是O(mn),空间复杂度也为O(mn)，但是实际计算转换状态时，只需要f[i-1][j],f[i][j-1],f[i-1][j-1]三个值，可以使用之前多次使用的滑动数组（滚动数组来解决）。因为在矩阵每一行从左到右处理，所以如果用一个数组res表示处理到j时，res[j-1]已经更新为f[i][j-1]，res[j]还没更新为f[i-1][j-1]，唯一需要解决的是res[i-1][j-1]。一个好的办法是使用一个单独的变量pre保存res[i-1][j-1]。在每次更新res[j]时先把 res[j]的历史值存储下来，作为下一次更新要使用的f[i-1][j-1]。另外为了减小空间复杂度可以使res为比较短的单词的长度加1，另外上述代码的三次min可以减少为1次min,即提前对f[i-1][j-1]的情况进行处理，代码如下：</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">class</span><span style="color:#000000;"> Solution(object):
    </span><span style="color:#0000ff;">def</span><span style="color:#000000;"> minDistance(self, word1, word2):
        </span><span style="color:#800000;">"""</span><span style="color:#800000;">
        :type word1: str
        :type word2: str
        :rtype: int
        </span><span style="color:#800000;">"""</span>
        <span style="color:#0000ff;">if</span> <span style="color:#0000ff;">not</span> word1 <span style="color:#0000ff;">and</span> <span style="color:#0000ff;">not</span><span style="color:#000000;"> word2:
            </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> 0
        l1 </span>=<span style="color:#000000;"> len(word1)
        l2 </span>=<span style="color:#000000;"> len(word2)
        
        </span><span style="color:#0000ff;">if</span> l1 &lt;= l2: <span style="color:#008000;">#</span><span style="color:#008000;">word1 have the max len</span>
            word1,word2 =<span style="color:#000000;"> word2,word1
            l1,l2 </span>=<span style="color:#000000;"> l2,l1
        res </span>= range(l2+1<span style="color:#000000;">)
          
        </span><span style="color:#0000ff;">for</span> i <span style="color:#0000ff;">in</span> xrange(1,l1+1<span style="color:#000000;">):
            pre </span>=<span style="color:#000000;"> res[0]
            res[0] </span>=<span style="color:#000000;"> i
            </span><span style="color:#0000ff;">for</span> j <span style="color:#0000ff;">in</span> xrange(1,l2+1<span style="color:#000000;">):
                tmp </span>=<span style="color:#000000;"> res[j]    ＃缓存f[i-1][j-1]
                </span><span style="color:#0000ff;">if</span> word1[i-1] != word2[j-1<span style="color:#000000;">]:  ＃提前处理
                    pre </span>+= 1<span style="color:#000000;">
                res[j] </span>= min(res[j-1]+1,res[j]+1<span style="color:#000000;">,pre) 
                pre </span>=<span style="color:#000000;"> tmp
                
        </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> res[l2]
        </span></pre> 
 </div> 
 <p> 这道题不少人直接使用f[i][j]=f[i-1][j-1](word1[i-1][j-1])和f[i][j]= min(f[i-1][j],f[i][j-1],f[i-1][j-1]+1)这种格式，但是前者的正确性证明我还没有看到特别好的解释。需要后续再想想。</p> 
 <p>简易版本滚动数组优化：</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">class</span><span style="color:#000000;"> Solution(object):
    </span><span style="color:#0000ff;">def</span><span style="color:#000000;"> minDistance(self, word1, word2):
        </span><span style="color:#800000;">"""</span><span style="color:#800000;">
        :type word1: str
        :type word2: str
        :rtype: int
        </span><span style="color:#800000;">"""</span>
        <span style="color:#0000ff;">if</span> len(word1) == 0 <span style="color:#0000ff;">or</span> len(word2) ==<span style="color:#000000;"> 0:
            </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> max(len(word1), len(word2))
        m </span>=<span style="color:#000000;"> len(word1)
        n </span>=<span style="color:#000000;"> len(word2)
        dp </span>= [[0] * (n+1) <span style="color:#0000ff;">for</span> i <span style="color:#0000ff;">in</span> xrange(2<span style="color:#000000;">)]
        </span><span style="color:#0000ff;">for</span> i <span style="color:#0000ff;">in</span> xrange(1, n+1<span style="color:#000000;">):
            dp[0][i] </span>=<span style="color:#000000;"> i

        </span><span style="color:#0000ff;">for</span> i <span style="color:#0000ff;">in</span> xrange(1, m+1<span style="color:#000000;">):
            dp[i</span>%2][0] =<span style="color:#000000;"> i
            </span><span style="color:#0000ff;">for</span> j <span style="color:#0000ff;">in</span> xrange(1, n+1<span style="color:#000000;">):
                </span><span style="color:#0000ff;">if</span> word1[i-1] == word2[j-1<span style="color:#000000;">]:
                    dp[i</span>%2][j] = min([dp[(i-1)%2][j]+1, dp[i%2][j-1]+1, dp[(i-1)%2][j-1<span style="color:#000000;">]])
                </span><span style="color:#0000ff;">else</span><span style="color:#000000;">:
                    dp[i</span>%2][j] = min([dp[(i-1)%2][j]+1, dp[i%2][j-1]+1, dp[(i-1)%2][j-1]+1<span style="color:#000000;">])            
        </span><span style="color:#0000ff;">return</span> dp[m%2][n]            </pre> 
 </div> 
 <p> </p> 
</div> 
<p>转载于:https://www.cnblogs.com/sherylwang/p/5522983.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9321566d8f60aec6843a02ed9de79e29/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何获得Oracle系统性能统计？ Oracle大型数据库系统在AIXUNIX上的实战详解 集中讨论 14...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a12e284531d6f7f84ca8d7100180a620/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Permutations II</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>