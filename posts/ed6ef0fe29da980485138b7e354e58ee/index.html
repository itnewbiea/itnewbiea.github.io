<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;作业 实验7继承与派生 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;作业 实验7继承与派生" />
<meta property="og:description" content="1 题目描述 定义一个 Lingjian 类，拥有整型的数据成员 Weight 和静态数据成员 AllWeights（初始化为 0），每定义一个对象时， 在AllWeights 中增加该零件的重量 Weight；在析构函数中减去 Weight；静态成员函数 GetAllWeights（）获取AllWeights。设计程序，定义两个对象之后， 输出类的 AllWeights。其中 Weight 是通过成员函数输入对单个零件重量赋值。
源代码 #include &lt;iostream&gt; using namespace std; class Lingjian { private: int Weight; static int AllWeights; public: static int GetAllWeights() { cout &lt;&lt; AllWeights &lt;&lt; endl; } Lingjian(int weight) { Weight = weight; AllWeights &#43;= Weight; } ~Lingjian() { AllWeights -= Weight; } }; int Lingjian::AllWeights = 0; int main() { int a,b; cin&gt;&gt; a&gt;&gt; b; Lingjian P1(a),P2(b); Lingjian::GetAllWeights() ; return 0; } 2 题目描述 定义狮子 Lion与老虎 Tiger 两个类，二者都有 weight 私有整型属性，定义二者的一个友元函数totalWeight(参数表)，计算二者的重量和。设计程序，定义狮子与老虎两个对象之后，调用 totalWeight(参数表)，计算二者的重量和，然后输出。其中狮子与老虎的 Weight 是在各自的类成员函数中读数赋值。 源代码 #include &lt;iostream&gt; using namespace std; class Tiger; class Lion; class Lion { private: int Weight; public: Lion(int weight) { Weight = weight; } friend int totalWeight(Lion &amp;P1,Tiger &amp;P2); }; class Tiger { private: int Weight; public: Tiger(int weight) { Weight = weight; } friend int totalWeight(Lion &amp;P1,Tiger &amp;P2); }; int totalWeight(Lion &amp;P1,Tiger &amp;P2) { cout &lt;&lt; (P1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ed6ef0fe29da980485138b7e354e58ee/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-09T18:06:17+08:00" />
<meta property="article:modified_time" content="2023-01-09T18:06:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;作业 实验7继承与派生</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h2 style="">1</h2> 
 <h5 style="">题目描述</h5> 
 <p style="text-align:left;">定义一个 Lingjian 类，拥有整型的数据成员 Weight 和静态数据成员 AllWeights（初始化为 0），每定义一个对象时， 在AllWeights 中增加该零件的重量 Weight；在析构函数中减去 Weight；静态成员函数 GetAllWeights（）获取AllWeights。设计程序，定义两个对象之后， 输出类的 AllWeights。其中 Weight 是通过成员函数输入对单个零件重量赋值。</p> 
 <h5 style="text-align:left;"> 源代码</h5> 
 <pre class="kdocs-c-like"><code class="language-c-like">#include &lt;iostream&gt;
using namespace std;
 
class Lingjian
{
    private:
    int Weight;
    static int AllWeights;
    public:
    static int GetAllWeights()
    {
        cout &lt;&lt; AllWeights &lt;&lt; endl;
        }
         
    Lingjian(int weight)
    {
        Weight = weight;
        AllWeights += Weight;
        }   
         
        ~Lingjian()
   {
    AllWeights -= Weight;
   }
};
int Lingjian::AllWeights = 0;
 
int main()
{
     
    int a,b;
    cin&gt;&gt; a&gt;&gt; b;
    Lingjian P1(a),P2(b);
    Lingjian::GetAllWeights() ;
    return 0;
     
}

</code></pre> 
 <h2 style="">2</h2> 
 <h5 style="">题目描述</h5> 
 <p style="text-align:left;">定义狮子 Lion与老虎 Tiger 两个类，二者都有 weight 私有整型属性，定义二者的一个友元函数totalWeight(参数表)，计算二者的重量和。设计程序，定义狮子与老虎两个对象之后，调用 totalWeight(参数表)，计算二者的重量和，然后输出。其中狮子与老虎的 Weight 是在各自的类成员函数中读数赋值。 </p> 
 <h5 style="">源代码</h5> 
 <pre class="kdocs-c-like"><code class="language-c-like">#include &lt;iostream&gt;
using namespace std;
 
class Tiger;
class Lion;
 
class Lion
{
    private:
    int Weight;
    public:
        Lion(int weight)
        {
            Weight = weight;
        }
        friend int  totalWeight(Lion &amp;P1,Tiger &amp;P2);
};
 
class Tiger
{
    private:
    int Weight;
    public:
    Tiger(int weight)
        {
            Weight = weight;
        }
        friend int  totalWeight(Lion &amp;P1,Tiger &amp;P2);
         
};
 
int totalWeight(Lion &amp;P1,Tiger &amp;P2)
{
  cout &lt;&lt; (P1.Weight + P2.Weight); 
}
 
int main()
{
     
    int l,t;
    cin &gt;&gt; l &gt;&gt;t;
    Lion P1(l);
    Tiger P2(t);
    totalWeight(P1,P2);
    return 0;
}

</code></pre> 
 <h2 style="">3</h2> 
 <h5 style="">题目描述</h5> 
 <p style="text-align:left;">集合是由一个或多个确定的元素所构成的整体。集合的运算有并、交、相对补等。</p> 
 <p style="text-align:left;">集合A和集合B的交集：由属于A且属于B的相同元素组成的集合。</p> 
 <p style="text-align:left;">集合A和集合B的并集：由所有属于集合A或属于集合B的元素所组成的集合。</p> 
 <p style="text-align:left;">集合B关于集合A的相对补集，记做A-B：由属于A而不属于B的元素组成的集合。</p> 
 <p style="text-align:left;">假设集合A={10，20，30}，集合B={1，10，50，8}。则A与B的并是{10，20，30,1,50,8}，A与B的交是{10}，B关于A的相对补集是{20,30}。</p> 
 <p style="text-align:left;">定义整数集合类CSet，属性包括：集合中的元素个数n，整型指针data存储集合中的元素。</p> 
 <p style="text-align:left;">主函数输入集合A、B的数据，计算集合的并、交、相对补。</p> 
 <p style="text-align:left;">可根据题目，为CSet类添加需要的成员函数。</p> 
 <p style="text-align:left;">方法有：重载输出，按样例格式输出集合中的元素。</p> 
 <p style="text-align:left;">重载+运算符，求集合A和集合B的并集，并返回结果集合。 重载-运算符，求集合B关于集合A的相对补集，并返回结果集合。 重载*运算符，求集合A和集合B的交集，并返回结果集合。</p> 
 <h5 style="">源代码</h5> 
 <pre class="kdocs-c-like"><code class="language-c-like">#include&lt;iostream&gt;
using namespace std;
  
class CSet
{
    public:
        CSet(){}
        CSet(int n1,int *p)
        {
            n=n1;
            for(int i=0;i&lt;n;i++)
                data[i]=p[i];
        }
        void display()
        {
            for(int j=0;j&lt;n;j++)
               {
         
                cout&lt;&lt;data[j]&lt;&lt;" ";
                    } 
                cout&lt;&lt;endl;
        }
         CSet operator + (CSet &amp;b);
         CSet operator - (CSet &amp;b);
         CSet operator * (CSet &amp;b);
        
    private:
        int n;
        int data[100];
};
 
CSet CSet::operator - (CSet &amp;b)
{
    int i=0;
    int a[100];
    for(int j=0;j&lt;n;j++)
    {
        int flag=0;
        for(int k=0;k&lt;b.n;k++)
        {
            if(data[j]==b.data[k])
            {
                flag=0;
                break;
            }
            else
                flag=1;
        }
         
        if(flag==1)
        {
            a[i]=data[j];
            i++;
        }
    }
     CSet c(i,a);
   return c;
}
  
CSet CSet::operator * (CSet &amp;b)
{
    int i=0;
    int mm[100];
    for(int j=0;j&lt;n;j++)
    {
        for(int k=0;k&lt;b.n;k++)
        {
            if(data[j]==b.data[k])
            {
                mm[i]=data[j];
                i++;
                break;
            }
        }
    }
    CSet c(i,mm);
    return c;
}
  
CSet CSet::operator +(CSet &amp;b)
{
    int i = 0;
    int a[100];
int g[100] = {0};
int h = b.n;
for(int j = 0; j &lt; h; j++)
g[j] = b.data[j];
 
    for(int k=0;k&lt;n;k++)
    {
        for(int j=0;j&lt;h;j++)
        {
             if(data[k]==g[j])
            {
                for(j; j &lt; h;j++)
                g[j] = g[j+1];
                h--;
                break;
            }
           
        } 
    }
    int d = 0;
    for(d ; d&lt; n;d++)
    a[d] = data[d];
 
    for(int j = 0;j&lt; h;j++)
    {
        a[d] = g[j];
        d++;
    }
     
   CSet c(d,a);
    return c;
}
  
int main()
{
    int t,n1,n2;
    cin&gt;&gt;t;
      
    for(int i=0;i&lt;t;i++)
    {
         
        cin&gt;&gt;n1;
        int p1[n1] = {0};
        for(int j=0;j&lt;n1;j++)
            {cin&gt;&gt;p1[j];
            }
        CSet A(n1,p1);  
             
        cin&gt;&gt;n2;
        int p2[n2] = {0};
        for(int j=0;j&lt;n2;j++)
            cin&gt;&gt;p2[j];
        CSet B(n2,p2);
          
        cout&lt;&lt;"A:";
        A.display();
        cout&lt;&lt;"B:";
       B.display();   
           
       CSet C=A+B;
       cout&lt;&lt;"A+B:";       
       C.display();
        
       CSet D=A*B;
        cout&lt;&lt;"A*B:";
        D.display();  
              
         CSet e=A-B;
        CSet f=B-A;
        CSet g=e+f;
     cout&lt;&lt;"(A-B)+(B-A):";
      g.display();
      cout &lt;&lt; endl;
    }
    return 0;
}

</code></pre> 
 <h2 style="">4</h2> 
 <h5 style="">题目描述</h5> 
 <p style="text-align:left;">要求定义一个基类Point，它有两个私有的float型数据成员X,Y;一个构造函数用于对数据成员初始化；有一个成员函数void Move(float xOff, float yOff)实现分别对X,Y值的改变，其中参数xOff和yOff分别代表偏移量。另外两个成员函数GetX() 、GetY()分别返回X和Y的值。</p> 
 <p style="text-align:left;">Rectangle类是基类Point的公有派生类。它增加了两个float型的私有数据成员W,H; 增加了两个成员函数float GetH() 、float GetW()分别返回W和H的值；并定义了自己的构造函数，实现对各个数据成员的初始化。</p> 
 <p style="text-align:left;">编写主函数main()根据以下的输入输出提示，完成整个程序。</p> 
 <h5 style="">源代码</h5> 
 <pre class="kdocs-c-like"><code class="language-c-like">#include &lt;iostream&gt;
using namespace std;
 
class Point
{
    private:
        float X,Y;
    public:
        Point(float x,float y)
        {
            X=x;
            Y=y;
        }
        void Move(float xOff, float yOff)
        {
            X+=xOff;
            Y+=yOff;
        }
        float GetX()
        {
            return X;
        }
        float GetY()
        {
            return Y;
        }
};
 
class Rectangle:public Point
{
    private:
    float W, H;
    public:
        Rectangle(float X,float Y,float W,float H):Point(X, Y)
        {
            this-&gt;W = W;
            this-&gt;H = H;
        }
        float GetH() 
        {
            return H;
        }
        float GetW()
        {
            return W;
        }
     
};
 
int main()
{
    float X,Y,W,H,xOff,yOff;
    cin &gt;&gt; X &gt;&gt; Y &gt;&gt; W &gt;&gt; H &gt;&gt; xOff &gt;&gt;yOff;
    Rectangle P(X,Y,W,H);
    P.Move(xOff,yOff);
    cout &lt;&lt; P.GetX()  &lt;&lt; " "&lt;&lt; P.GetY() &lt;&lt; " "&lt;&lt; P.GetW() &lt;&lt; " "&lt;&lt; P.GetH() ;
    return 0;
     
}
</code></pre> 
 <h2 style="">5</h2> 
 <h5 style="">题目描述</h5> 
 <p style="text-align:left;">定义一个基类Person，它有3个protected的数据成员：姓名name(char *类型)、性别 sex(char类型)、年龄age(int类型)；一个构造函数用于对数据成员初始化；有一个成员函数show()用于输出数据成员的信息。</p> 
 <p style="text-align:left;">创建Person类的公有派生类Employee，增加两个数据成员 基本工资 basicSalary（int类型） 请假天数leaveDays（int型）；为它定义初始化成员信息的构造函数，和显示数据成员信息的成员函数show()。</p> 
 <h5 style="text-align:left;"> 源代码</h5> 
 <pre class="kdocs-c-like"><code class="language-c-like">#include &lt;iostream&gt; 
#include &lt;string.h&gt;
using namespace std;
 
class Person
{
    protected:
        char name[30];
        //char *name[30];
        char sex;
        int age;
    public:
        Person(char*Name,char Sex,int Age)
        {
            strcpy(name,Name);
            sex = Sex;
            age = Age;
        }
        void show()
        {
            cout &lt;&lt; "name:" &lt;&lt; name &lt;&lt;endl;
            cout &lt;&lt; "age:" &lt;&lt; age &lt;&lt; endl;
            cout &lt;&lt; "sex:" &lt;&lt; sex &lt;&lt; endl;
        }
};
 
class Employee:Person
{
    private:
        int basicSalary,leaveDays;
    public:
        Employee(char*Name,char Sex,int Age,int BasicSalary,int LeaveDays):Person(Name,Sex,Age)
        {
            basicSalary = BasicSalary;
            leaveDays = LeaveDays;
        }
        void show()
        {
            Person::show() ;
            cout &lt;&lt; "basicSalary:" &lt;&lt; basicSalary &lt;&lt; endl;
            cout &lt;&lt; "leavedays:" &lt;&lt; leaveDays &lt;&lt; endl;
        }
};
 
 int main()
 {
    char s;
    int a,b,l;
    char name[30];
    cin&gt;&gt; name &gt;&gt; s &gt;&gt; a &gt;&gt; b &gt;&gt; l;
    Employee P(name,s,a,b,l);
    P.show() ;
    return 0;
  } 
</code></pre> 
 <p style=""></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d6cd6effa999cfff05c2a03cbae00b7d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python：结构化模式匹配 match case</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/00a30f5679435aea4bffb3e2040398c1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">倒计时js</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>