<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>webrtc拥塞控制算法对比-GCC vs BBR vs PCC - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="webrtc拥塞控制算法对比-GCC vs BBR vs PCC" />
<meta property="og:description" content="1.前言 现有集成在webrtc中的拥塞控制算法有三种, 分别是: 谷歌自研发的gcc, 谷歌自研发的BBR算法, 斯坦福大学提出的基于机器学习凸优化的PCC算法. 本文将探讨一下三个算法的区别和优缺点。
2.背景 迈聆会议从17年到现在, 一直使用的是基于谷歌的gcc算法自研的Omcc算法(optimization of Mindlinker in network congestion controller), 经过这么多年的优化, 在现有表现上已经可以在大部分网络场景下准确预估带宽. Omcc算法已经可以做到抗50%丢包, 抗800ms抖动, 抗2s延时, 在300k-10mbps带宽范围下也可以准确预估带宽值, 在保障低延时的情况下, 能够尽可能提高带宽利用率。
本文将讨论webrtc自带的三种算法的优缺点, 并给出部分测试报告。
3.GCC算法 gcc算法是webrtc默认的算法. 其具体原理本文不再赘述, 已经有各种参考资料去详细讲解了gcc算法的原理.
3.1 gcc算法优点 灵敏度高, 能够及时响应, 提前避免拥塞. 基于抖动和基于丢包的预估值可以很好的预测网络拥塞.
3.2 现有GCC算法所面临的问题和难点 1.带宽对发送数据量的强相关
对于GCC算法, 其网络模型是依靠丢包和抖动去检测网络的拥塞, 从而及时响应网络的动态变化. 原版的GCC算法所能允许的丢包非常小, 丢包大于10%就断崖式下跌带宽. 所能允许的抖动和延时也不高. 通过我们现在的优化之后, 丢包上限达到了50%, 延时增长不是那么敏感, 抗抖动范围也会更高. 但这样带来的结果是, 在带宽预估的稳定性和准确性上面很难做好. GCC算法的逻辑是和数据发送量强相关的, 网络好时发送量多, 带宽预估才会上去. 发送100kbps的码率, 带宽预估很难超过200kbps. 此外, 现有有些发送逻辑是需要去降低发送量, 从而给用户节省带宽的, 比如桌面共享场景下静止画面和动态画面数据量可以从20kbps波动到4mbps.剧烈波动的发送量导致在某些场景下带宽预估的剧烈波动. 波动这么剧烈的场景下, 怎样在既保持带宽预估稳定的同时又不降低发送量呢, 此问题在现有webrtc的策略下很难去解决.
2.带宽恢复速度
GCC算法的核心是慢升快降, 在网络拥塞的时候指数下降带宽, 在网络恢复后, 龟速上涨带宽. 带宽缓慢恢复对于网络来说是一件好事, 但是, 低带宽恢复高带宽需要非常多的时间, 对用户体验不太好." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/84422744aecb299ca57f5a5c95289b92/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-01T15:43:38+08:00" />
<meta property="article:modified_time" content="2023-03-01T15:43:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">webrtc拥塞控制算法对比-GCC vs BBR vs PCC</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">1.前言</span></h3> 
 <hr> 
 <p style="text-align:null;">现有集成在webrtc中的拥塞控制算法有三种, 分别是: 谷歌自研发的gcc, 谷歌自研发的BBR算法, 斯坦福大学提出的基于机器学习凸优化的PCC算法. 本文将探讨一下三个算法的区别和优缺点。</p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2.背景</span></h3> 
 <hr> 
 <p style="text-align:null;">迈聆会议从17年到现在, 一直使用的是基于谷歌的gcc算法自研的Omcc算法(optimization of Mindlinker in network congestion controller), 经过这么多年的优化, 在现有表现上已经可以在大部分网络场景下准确预估带宽. Omcc算法已经可以做到抗50%丢包, 抗800ms抖动, 抗2s延时, 在300k-10mbps带宽范围下也可以准确预估带宽值, 在保障低延时的情况下, 能够尽可能提高带宽利用率。</p> 
 <p style="text-align:null;">本文将讨论webrtc自带的三种算法的优缺点, 并给出部分测试报告。</p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3.GCC算法</span></h3> 
 <hr> 
 <p style="text-align:null;">gcc算法是webrtc默认的算法. 其具体原理本文不再赘述, 已经有各种参考资料去详细讲解了gcc算法的原理.</p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3.1 gcc算法优点</span></h4> 
 <p style="text-align:null;">灵敏度高, 能够及时响应, 提前避免拥塞. 基于抖动和基于丢包的预估值可以很好的预测网络拥塞.</p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3.2 现有GCC算法所面临的问题和难点</span></h4> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1.带宽对发送数据量的强相关</span></p> 
 <p style="text-align:null;">对于GCC算法, 其<span class="kdocs-bold" style="font-weight:bold;">网络模型</span>是依靠丢包和抖动去检测网络的拥塞, 从而及时响应网络的动态变化. 原版的GCC算法所能允许的丢包非常小, 丢包大于10%就断崖式下跌带宽. 所能允许的抖动和延时也不高. 通过我们现在的优化之后, 丢包上限达到了50%, 延时增长不是那么敏感, 抗抖动范围也会更高. 但这样带来的结果是, 在带宽预估的稳定性和准确性上面很难做好. GCC算法的逻辑是和数据发送量强相关的, 网络好时发送量多, 带宽预估才会上去. 发送100kbps的码率, 带宽预估很难超过200kbps. 此外, 现有有些发送逻辑是需要去降低发送量, 从而给用户节省带宽的, 比如桌面共享场景下静止画面和动态画面数据量可以从20kbps波动到4mbps.剧烈波动的发送量导致在某些场景下带宽预估的剧烈波动. 波动这么剧烈的场景下, 怎样在既保持带宽预估稳定的同时又不降低发送量呢, 此问题在现有webrtc的策略下很难去解决.</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2.带宽恢复速度</span></p> 
 <p style="text-align:null;">GCC算法的核心是慢升快降, 在网络拥塞的时候指数下降带宽, 在网络恢复后, 龟速上涨带宽. 带宽缓慢恢复对于网络来说是一件好事, 但是, 低带宽恢复高带宽需要非常多的时间, 对用户体验不太好. 此外我们有全面放慢带宽上涨的速率, 用于维持在带宽限制场景下的带宽稳定性. 现在的带宽从300kbps上涨到3mbps需要1min, 上涨到6mbps需要90s. 这个问题现无法在算法层面去解决, 如果增加恢复速度后会更容易导致一些场景下带宽高估和带宽波动. <span class="kdocs-bold" style="font-weight:bold;">恢复速度和带宽稳定两者当前算法很难做到兼容.</span></p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">3.带宽准确性</span></p> 
 <p style="text-align:null;">GCC算法在带宽准确性方面还是存在一个硬问题, 首先GCC算法中, 带宽稳定性要和发送码率准确性强相关, 和丢包率和延时又是强相关, GCC算法对网络拥塞很敏感, 稍微的拥塞就会导致带宽波动, 且波动范围挺大的. 如果要适应高抖动高延时等网络变化场景, GCC原生算法会很容易下降到不可接受的范围. 在一些固定丢包场景下GCC是带宽准确性会变得非常差.</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">4.带宽稳定性</span></p> 
 <p style="text-align:null;">稳定性方面是一个很难去优化的点, 本来带宽就是动态变化, 而且还是比较频繁的, 在限制带宽场景下, 带宽容忍一些上下波动. 但是这个波动范围不能偏离太多, 下图是我们在测试时原生GCC算法的波动情况, 如图波动范围会变化非常大</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:17.432432%;height:0;"> 
    <img src="https://images2.imgbox.com/d2/32/iRkl363z_o.png" style="margin-left:;display:block;width:740px;margin-top:-17.432432%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">服务端限制1.5mbps带宽限制后的波动</p> 
 <p style="text-align:null;"></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:717px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:17.852161%;height:0;"> 
    <img src="https://images2.imgbox.com/cb/76/mqiGzVH6_o.png" style="margin-left:;display:block;width:717px;margin-top:-17.852161%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">客户端限制1.5mbps带宽限制后的波动</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">5.4G弱网环境</span></p> 
 <p style="text-align:null;">在4G弱网场景下, 延时会变得很大, 且和发送量相关, 没有丢包, 这种网络模型属于肥长管道形网络, GCC算法在此场景中会变得非常迟钝, 因为网络中没有丢包, 网络延时平滑增长, 且抖动很小. 导致基于抖动计算的带宽值会变得非常迟钝. 无法准确预估出低延时下的带宽值.</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:45.675674%;height:0;"> 
    <img src="https://images2.imgbox.com/ec/13/nz9hRFaM_o.png" style="margin-left:;display:block;width:740px;margin-top:-45.675674%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">4G弱网场景下发送数据量太多后, 延时会变得非常非常大, 却不会出现网络丢包</p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.BBR算法</span></h3> 
 <hr> 
 <p style="text-align:null;">BBR核心思路就是通过调整发送量去探测到网络的最大带宽和最小延时. 最大带宽通过发送超过网络容量的数据去获取, 当增加发送量后延时也开始增加时, 此时就是最大带宽. 最小延时通过发送低于网络容量的数据去计算, 当降低发送量后延时不降低时, 此时的RTT就是最小延时. 找到下图的理想点, 也就是BDP, 就是我们现在可以发送的最大带宽.</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:621px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:69.40419%;height:0;"> 
    <img src="https://images2.imgbox.com/65/75/R0c9NGxS_o.png" style="margin-left:;display:block;width:621px;margin-top:-69.40419%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">BBR算法网络模型</p> 
 <p style="text-align:null;">BBR设置了一个状态机用于不断获取当前变化网络的最小RTT和最大带宽, 但是探测BDP的过程只占整个周期的2%, 98%的场景是用于以正常速率去传输的. 毫无疑问, <span class="kdocs-bold" style="font-weight:bold;">BBR天生就可以解决限制带宽场景下的带宽预估稳定性和准确性问题</span>, 针对4G网络这种肥长网络模型也有对应的策略. 而且其带宽预估的准确性会很好. 但是发送数据的强相关性还是个问题, BBR在类似桌面共享这种场景下的发送码率变化剧烈的场景下估计适应性不会很好.</p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.1 BBR算法的缺点</span></h4> 
 <p style="text-align:null;">\1. 收敛速度慢\2. 抗丢包能力不足\3. ProbeRTT状态只发送四个包, 不适合低延时流媒体应用\4. 发送码率周期性波动\5. 上下行RTT和Loss相互影响(估计是有潜在bug)</p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.2 BBR算法的优点</span></h4> 
 <p style="text-align:null;">a. Probe_RTT 阶段的隐藏弱化b. 上行网络丢包带宽补偿c. 上行网络RTT突变以及高Jitter场景优化d. 下行链路抖动以及丢包的优化e. Padding流量的优化f. 快速上探机制的实现</p> 
 <p style="text-align:null;">测试webrtc中BBR的表现, 在带宽准确性和稳定性方面和上面描述的一致, 延时和抖动适应也都没问题, 抗持续丢包在25%左右.</p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">5.PCC算法</span></h3> 
 <hr> 
 <p style="text-align:null;">PCC的目标是开发一种性能明显优于TCP传统算法的传输协议, 且保持一定的实际可部署性. 这种性能的改进是根据各种网络设置的吞吐量和各种公平的度量来衡量的. 其和以往传统的基于网络事件(丢包变化或者延时变化或者抖动变化之类)的hardwired-mapping硬连接映射不同, 是基于更广泛的网络条件来实时作出发送速率决策. 其具有网络学习的能力. 这一点是传统网络所不具备的;</p> 
 <p style="text-align:null;">PCC通过在执行期间不断以不同的速率发送数据进行<span class="kdocs-bold" style="font-weight:bold;">A/B测试</span>去测量网络. 最终的目的是通过目标函数去进行凸优化, 从而找到全局最优解, 并以此速率去运行. <span class="kdocs-bold" style="font-weight:bold;">对比PCC和BBR, 两者都是类似A/B测试去测量网络, BBR使用网络白盒建模的方式去转换表现测量, PCC使用黑盒机制, 在特定速率发送时去观察表现矩阵以及效用函数, 来调整发送策略.</span></p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">5.1 PCC的优点</span></h4> 
 <p style="text-align:null;">* 在2018年发明的pcc变种-vivace算法测试性能要好于BBR, 尤其是在抗丢包性能上.</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:717px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:83.960945%;height:0;"> 
    <img src="https://images2.imgbox.com/cd/59/1CS77ELF_o.png" style="margin-left:;display:block;width:717px;margin-top:-83.960945%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:717px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:75.732216%;height:0;"> 
    <img src="https://images2.imgbox.com/60/5e/ma4kToL5_o.png" style="margin-left:;display:block;width:717px;margin-top:-75.732216%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">算法考虑的参数有延时和丢包, 可以适应更多场景下的网络环境</p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">5.2 PCC的缺点</span></h4> 
 <p style="text-align:null;">\1. <span class="kdocs-bold" style="font-weight:bold;">算法太新了</span>, 现在还处于理论实现的地步, 业界并没有什么实际的应用.\2. webrtc中的pcc算法存在各种问题, 且使用起来效果非常不好.\3. 目标函数采用的观测变量是rtt, 所以还是会存在上下行相互影响的场景, 需要花更多的时间去专门优化.</p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">6.附录</span></h3> 
 <hr> 
 <p style="text-align:null;">网损场景中测试WebRTC中的GCC, BBR, PCC算法效果:</p> 
 <p style="text-align:left;">· 测试环境:</p> 
 <p style="text-align:left;"> ○ Windows, 编译webrtc的p2p demo, 对等连接</p> 
 <p style="text-align:left;"> ○ 网损控制使用ATC去设置</p> 
 <p style="text-align:left;"> ○ 有线连接</p> 
 <p style="text-align:left;">· 网损场景设置:</p> 
 <p style="text-align:left;"> ○ 带宽限制: 500kbps 1mbps 2mbps</p> 
 <p style="text-align:left;"> ○ 丢包限制: 10% 20%</p> 
 <p style="text-align:left;"> ○ 延时限制: 100ms 200ms</p> 
 <p style="text-align:left;"> ○ 抖动限制: 100ms 200ms</p> 
 <p style="text-align:left;"> ○ 混合网损模拟A: 1mbps+10%+100ms延时</p> 
 <p style="text-align:left;"> ○ 混合网损模拟B: 10%+100ms延时+100ms抖动</p> 
 <p style="text-align:null;">测试结果</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:717px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:19.246862%;height:0;"> 
    <img src="https://images2.imgbox.com/18/da/j9EEWIyU_o.png" style="margin-left:;display:block;width:717px;margin-top:-19.246862%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">原文<a class="kdocs-link" style="color:#0A6CFF;" href="https://zhuanlan.zhihu.com/p/448850999" rel="nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/448850999</a></p> 
 <p style=""></p> 
 <p style="text-align:left;"><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">★文末名片可以免费领取音视频开发学习资料，内容包括（FFmpeg ，webRTC ，rtmp ，hls ，rtsp ，ffplay ，srs）以及音视频学习路线图等等。</span></span></p> 
 <p style="text-align:left;"><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">见下方!↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ec15e95cfe2861567bbb1ed7d38c89a4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端项目部署更新后，不清缓存也能得到最新静态资源文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0cc9c1bc4263044c5c35ebc4d51a3f05/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用docker发布.net应用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>