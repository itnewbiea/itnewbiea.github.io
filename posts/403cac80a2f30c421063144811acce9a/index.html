<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>说一说will-change - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="说一说will-change" />
<meta property="og:description" content="一、will-change是做什么的呢 CSS 是用来描述结构化文档（如HTML、XML）怎样渲染的语言。
CSS渲染器在渲染属性前，会有个准备的过程。有些属性需要css渲染器事先做很多准备才能实现渲染。这就容易导致页面出现卡顿，交互体验不好等问题。
如果设置了 will-change 属性，那么浏览器就可以提前知道哪些元素的属性将会改变，提前做好准备。待需要改变元素的时机到来时，就可以立刻实现它们。从而避免卡顿等问题。
例如，使用 3D Transforms 让元素在屏幕上移动时，此元素和它的上下文会被提到另一个“层”，独立于其它元素被渲染。这样那些不变的元素就能避免被重复渲染。这可以显著提高性能。
然而，将元素提取到一个新层，相对来说是代价较高的操作。这可能使 transform 动画延迟几百毫秒。
二、怎么用呢 下面是一个使用脚本应用 will-change 属性的例子：
var el = document.getElementById(&#39;element&#39;); // 当鼠标移动到该元素上时给该元素设置 will-change 属性 el.addEventListener(&#39;mouseenter&#39;, hintBrowser); // 当 CSS 动画结束后清除 will-change 属性 el.addEventListener(&#39;animationEnd&#39;, removeHint); function hintBrowser() { // 填写上那些你知道的，会在 CSS 动画中发生改变的 CSS 属性名们 this.style.willChange = &#39;transform, opacity&#39;; } function removeHint() { this.style.willChange = &#39;auto&#39;; } 语法说明 Formal syntax: auto | &lt;animateable-feature&gt;# &lt;animateable-feature&gt; = scroll-position | contents | &lt;custom-ident&gt; will-change: auto will-change: scroll-position will-change: contents will-change: transform // &lt;custom-ident&gt; 的例子 will-change: opacity // &lt;custom-ident&gt; 的例子 will-change: left, top // &lt;animateable-feature&gt; 的例子 will-change: unset will-change: initial will-change: inherit auto 浏览器会根据情况，自行进行优化。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/403cac80a2f30c421063144811acce9a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-19T08:45:00+08:00" />
<meta property="article:modified_time" content="2021-02-19T08:45:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">说一说will-change</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p><img src="https://images2.imgbox.com/19/ae/s61kXM1k_o.png"><br></p> 
 <h3>一、will-change是做什么的呢</h3> 
 <p>CSS 是用来描述结构化文档（如HTML、XML）怎样渲染的语言。</p> 
 <p>CSS渲染器在渲染属性前，会有个准备的过程。有些属性需要css渲染器事先做很多准备才能实现渲染。这就容易导致页面出现卡顿，交互体验不好等问题。</p> 
 <p>如果设置了 will-change 属性，那么浏览器就可以提前知道哪些元素的属性将会改变，提前做好准备。待需要改变元素的时机到来时，就可以立刻实现它们。从而避免卡顿等问题。</p> 
 <blockquote> 
  <p style="text-align: justify">例如，使用 3D Transforms 让元素在屏幕上移动时，此元素和它的上下文会被提到另一个“层”，独立于其它元素被渲染。这样那些不变的元素就能避免被重复渲染。这可以显著提高性能。</p> 
 </blockquote> 
 <p>然而，将元素提取到一个新层，相对来说是代价较高的操作。这可能使 transform 动画延迟几百毫秒。</p> 
 <h3>二、怎么用呢</h3> 
 <p>下面是一个使用脚本应用 will-change 属性的例子：</p> 
 <blockquote> 
  <pre class="has"><code class="language-php">var el = document.getElementById('element');
// 当鼠标移动到该元素上时给该元素设置 will-change 属性
el.addEventListener('mouseenter', hintBrowser);
// 当 CSS 动画结束后清除 will-change 属性
el.addEventListener('animationEnd', removeHint);
function hintBrowser() {
// 填写上那些你知道的，会在 CSS 动画中发生改变的 CSS 属性名们
this.style.willChange = 'transform, opacity';
}
function removeHint() {
this.style.willChange = 'auto';
}
</code></pre> 
 </blockquote> 
 <h4>语法说明</h4> 
 <blockquote> 
  <pre class="has"><code class="language-php">Formal syntax: auto | &lt;animateable-feature&gt;#
&lt;animateable-feature&gt; = scroll-position | contents | &lt;custom-ident&gt;
</code></pre> 
 </blockquote> 
 <blockquote> 
  <pre class="has"><code class="language-php">will-change: auto
will-change: scroll-position
will-change: contents
will-change: transform // &lt;custom-ident&gt; 的例子
will-change: opacity // &lt;custom-ident&gt; 的例子
will-change: left, top // &lt;animateable-feature&gt; 的例子
will-change: unset
will-change: initial
will-change: inherit
</code></pre> 
 </blockquote> 
 <h5>auto</h5> 
 <p>浏览器会根据情况，自行进行优化。</p> 
 <h5>scroll-position</h5> 
 <p>表示开发者将要改变元素的滚动位置。</p> 
 <blockquote> 
  <p style="text-align: justify">例如，浏览器通常仅呈现可滚动元素“滚动窗口”中的内容。而某些内容超过该窗口。如设置了此值，浏览器将扩展呈现“滚动窗口”周围的内容，从而顺利地进行更长、更快的滚动。</p> 
 </blockquote> 
 <h5>content</h5> 
 <p>表示开发者将要改变元素的内容。</p> 
 <blockquote> 
  <p style="text-align: justify">例如，浏览器常将大部分不经常改变的元素缓存下来。但如果一个元素的内容不断发生改变，那么产生和维护这个缓存就是在浪费时间。此属性值可以减少浏览器对元素的缓存，或者完全避免缓存。变为从始至终都重新渲染元素。</p> 
 </blockquote> 
 <p>注意：这个值会被应用到它所声明元素的子节点。在文档树较高的节点上使用，可能会对页面性能造成很大的影响。尽量在文档树最末端使用。</p> 
 <h5>&lt;custom-ident&gt;</h5> 
 <p>表示开发者将要改变的元素属性。如果给定的值是缩写，则默认被扩展全。</p> 
 <blockquote> 
  <p style="text-align: justify">例如，设置 will-change: background 将会被补全 background 的所有属性 will-change: background-image, background-position, ...</p> 
 </blockquote> 
 <h3>三、使用时须注意的几点</h3> 
 <h6><strong>1、不要在过多的属性和元素上使用 will-change</strong></h6> 
 <blockquote> 
  <pre class="has"><code class="language-php">* { will-change: transform, opacity /*, ...*/; }
</code></pre> 
 </blockquote> 
 <p>你可能会觉得这么做不错，就可以优化一切属性了。</p> 
 <p>其实并非如此。</p> 
 <p>will-change 可能会引发一些十分耗费资源的优化措施。如果像上边这样给所有元素都添加，可能会使页面变慢，甚至崩溃。</p> 
 <h6><strong>2、在元素属性变化完成后最好移除 will-change 属性</strong></h6> 
 <p>有些情况，可以不移除。</p> 
 <p>比如，给页面中少量的元素使用 will-change 属性能使交互体验更好。</p> 
 <blockquote> 
  <pre class="has"><code class="language-php">body &gt; .sidebar {
will-change: transform;
/*当鼠标移动到侧边栏时，会有滑动效果*/
}
</code></pre> 
 </blockquote> 
 <p>因为只在很少的元素上使用，所以它所能产生的副作用可以忽略不计。</p> 
 <p>当变化很频繁时也可以不移除。例如，鼠标移动产生的变化，或者持续存在的动画效果。此时设置 will-change 属性，其实就是在提示浏览器，这些元素会持续或有规律的发生变化，要保持对它们的优化。</p> 
 <blockquote> 
  <pre class="has"><code class="language-php">.cats-flying-around-the-screen {
will-change: left, top;
}
</code></pre> 
 </blockquote> 
 <h6><br></h6> 
 <h6><strong>3、给 will-change 属性足够的时间做准备</strong></h6> 
 <p>如果在动画开始的那一刻才添加 will-change 属性，是没有优化效果的。一些优化是需要充分的准备时间的.如果没有足够的时间，那 will-change 所能提高的性能也就无从谈起。所以要找到添加 will-change 属性的时机。</p> 
 <blockquote> 
  <p style="text-align: justify">比如，当一个元素被点击时发生变化。那么就可以在 hover 事件上设置 will-change 属性。这能给浏览器提供大概200毫秒准备时间。因为相较之下，人类的响应速度较慢。这可以通过脚本或者简单的CSS来实现。</p> 
 </blockquote> 
 <blockquote> 
  <pre class="has"><code class="language-php">.element { transition: opacity .2s; opacity: 1; }
.element:hover { will-change: opacity; }
.element:active { opacity: .3; }
</code></pre> 
 </blockquote> 
 <p>如果变化是发生在触发 hover 事件时，上边的做法就无法起到优化作用了。但还是可以找到恰当的时机的。比如在祖先元素上设置 will-change 属性，就可以给浏览器预留足够的准备时间。</p> 
 <blockquote> 
  <pre class="has"><code class="language-php">.element { transition: opacity .2s; opacity: 1; }
.container:hover &gt; .element { will-change: opacity; }
.element:hover { opacity: .3; }
</code></pre> 
 </blockquote> 
 <h4>兼容性一览</h4> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/59/90/LBl43sho_o.png"></p> 
 <h4>参考资料</h4> 
 <p>[1] CSS Will Change Module Level 1: https://www.w3.org/TR/css-will-change-1/#propdef-will-change</p> 
 <p>[2] MDN will-change 中文版: https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change</p> 
 <p style="text-align: center"><br>最后</p> 
 <ul><li><p>欢迎加我微信(winty230)，拉你进技术群，长期交流学习...<br></p></li><li><p>欢迎关注「前端Q」,认真学前端，做个专业的技术人...</p></li></ul> 
 <p><img src="https://images2.imgbox.com/6f/0d/0kUgjedN_o.png"></p> 
 <p><img src="https://images2.imgbox.com/ff/7a/Vp2nR7HV_o.png"></p> 
 <p>点个<strong>在看</strong>支持我吧</p> 
 <p><img src="https://images2.imgbox.com/e4/86/OeK9qP6P_o.png"></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8e07aaac5e804adb4c2cdf4bf89132fc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">openocd目录,OpenOCD一次调试多个设备</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d19f223e242181db1c5cc48cabc9263a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用EPPlus实现Excel导出功能</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>