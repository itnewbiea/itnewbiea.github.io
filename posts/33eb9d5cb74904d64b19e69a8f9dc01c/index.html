<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>11.图-有向图 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="11.图-有向图" />
<meta property="og:description" content="目录
一、有向图。 二、拓扑排序。
（1）检测有向图中是否有环。
（2）基于深度优先的顶点排序（拓扑排序）。
（3）拓扑排序。
三、加权有向图。
（1）加权有向边。 （2）加权有向图。
四、最短路径-Dijstra算法。 一、有向图。 package 图的入门.有向图; import 线性表.线性表_队列.Queue; public class Digraph { //顶点数目 private final int V; //边的数目 private int E; //邻接表 private Queue&lt;Integer&gt;[] adj; public Digraph(int V){ //初始化顶点数量 this.V = V; //初始化边的数量 this.E = 0; //初始化邻接表 this.adj = new Queue[V]; for (int i = 0; i &lt; adj.length; i&#43;&#43;) { adj[i] = new Queue&lt;&gt;(); } } //获取顶点数目 public int V(){ return V; } //获取边的数目 public int E(){ return E; } //向有向图中添加一条边v-》w public void addEdge(int v,int w){ //只需要让顶点w出现在顶点v的邻接表中，因为边是有方向的，最终顶点v的邻接表中存储的相邻顶点的含义是：v-》其他顶点 adj[v]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/33eb9d5cb74904d64b19e69a8f9dc01c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-05T18:04:21+08:00" />
<meta property="article:modified_time" content="2023-04-05T18:04:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">11.图-有向图</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%9C%89%E5%90%91%E5%9B%BE%E3%80%82%C2%A0" rel="nofollow">一、有向图。 </a></p> 
<p style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E3%80%82" rel="nofollow">二、拓扑排序。</a></p> 
<p style="margin-left:40px;"><a href="#%EF%BC%881%EF%BC%89%E6%A3%80%E6%B5%8B%E6%9C%89%E5%90%91%E5%9B%BE%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%E3%80%82" rel="nofollow">（1）检测有向图中是否有环。</a></p> 
<p style="margin-left:40px;"><a href="#%C2%A0%EF%BC%882%EF%BC%89%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E7%9A%84%E9%A1%B6%E7%82%B9%E6%8E%92%E5%BA%8F%EF%BC%88%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%89%E3%80%82" rel="nofollow"> （2）基于深度优先的顶点排序（拓扑排序）。</a></p> 
<p style="margin-left:40px;"><a href="#%EF%BC%883%EF%BC%89%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E3%80%82" rel="nofollow">（3）拓扑排序。</a></p> 
<p style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%8A%A0%E6%9D%83%E6%9C%89%E5%90%91%E5%9B%BE%E3%80%82" rel="nofollow">三、加权有向图。</a></p> 
<p style="margin-left:40px;"><a href="#%EF%BC%881%EF%BC%89%E5%8A%A0%E6%9D%83%E6%9C%89%E5%90%91%E8%BE%B9%E3%80%82%C2%A0" rel="nofollow">（1）加权有向边。 </a></p> 
<p style="margin-left:40px;"><a href="#%EF%BC%882%EF%BC%89%E5%8A%A0%E6%9D%83%E6%9C%89%E5%90%91%E5%9B%BE%E3%80%82" rel="nofollow">（2）加权有向图。</a></p> 
<p style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-Dijstra%E7%AE%97%E6%B3%95%E3%80%82%C2%A0" rel="nofollow">四、最短路径-Dijstra算法。 </a></p> 
<hr> 
<p> </p> 
<h2>一、有向图。 </h2> 
<p><img src="https://images2.imgbox.com/a2/93/yl2fsZDq_o.png" alt="73d727fc62724e7b8d57d29a713919bf.png"></p> 
<pre><code class="language-java">package 图的入门.有向图;

import 线性表.线性表_队列.Queue;

public class Digraph {
    //顶点数目
    private final int V;
    //边的数目
    private int E;
    //邻接表
    private Queue&lt;Integer&gt;[] adj;

    public Digraph(int V){
        //初始化顶点数量
        this.V = V;
        //初始化边的数量
        this.E = 0;
        //初始化邻接表
        this.adj = new Queue[V];
        for (int i = 0; i &lt; adj.length; i++) {
            adj[i] = new Queue&lt;&gt;();
        }
    }

    //获取顶点数目
    public int V(){
        return V;
    }

    //获取边的数目
    public int E(){
        return E;
    }

    //向有向图中添加一条边v-》w
    public void addEdge(int v,int w){
        //只需要让顶点w出现在顶点v的邻接表中，因为边是有方向的，最终顶点v的邻接表中存储的相邻顶点的含义是：v-》其他顶点
        adj[v].enqueue(w);
        E++;
    }

    //获取由v指出的边所连接的所有顶点
    public Queue&lt;Integer&gt; adj(int v){
        return adj[v];
    }

    //获取该图的反向图
    private Digraph reverse(){
        //创建有向图对象
        Digraph r = new Digraph(V);

        for (int v = 0; v &lt; V; v++) {//原图中表示的是由顶点v-》w的边
            //获取由该顶点v指出的所有边
            for (Integer w : adj[v]) {
                r.addEdge(w,v);//w-&gt;v
            }
        }
        return reverse();
    }
}
</code></pre> 
<h2>二、拓扑排序。</h2> 
<p><img src="https://images2.imgbox.com/16/19/X2qMqhrZ_o.png" alt="5f1ddf3df8ac49e48df864d7b1ab10e1.png"></p> 
<h3>（1）检测有向图中是否有环。</h3> 
<p><img src="https://images2.imgbox.com/00/d2/J3wRWLle_o.png" alt="7c18a91b7ff74d6c8689a2f3f45266ee.png"></p> 
<pre><code class="language-java">package 图的入门.有向图.图_拓扑排序_检测有向环;

import 图的入门.有向图.Digraph;

public class DirectedCycle {
    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //记录图中是否有环
    private boolean hasCycle;
    //索引代表顶点，使用栈的思想，记录当前顶点有没有已经处于正在搜索的有向路径上
    private boolean[] onStack;

    //创建一个检测环对象，检测图G中是否有环
    public DirectedCycle(Digraph G){
        //初始化marked数组
        this.marked = new boolean[G.V()];
        //初始化hasCycle
        this.hasCycle = false;
        //初始化onStack数组
        this.onStack = new boolean[G.V()];//基本数据类型都有默认值，这里默认全部为false，引用类型数据默认是null

        //找到图中每一个顶点，让每一个顶点作为人口，调用一次dfs进行搜索v
        for (int v = 0; v &lt; G.V(); v++) {
            //判断如果当前结点还没有搜索过(一个连通子图中有一个调用dfs就足够了，但是图不一定就全部相通（连通图），可能有很多连通子图)，则调用dfs进行搜索
            if (!marked[v]){
                dfs(G,v);
            }
        }
    }

    //基于深度优先搜索，检测图G中是否有环
    private void dfs(Digraph G,int v){
        //把顶点v表示为已搜索
        marked[v] = true;
        //把当前顶点进栈
        onStack[v] = true;
        //进行深度搜索
        /**
         * 重点注意：这里的增强遍历其实不是拿出就删除了（因为这里是记录结点，然后指向下一个结点，是链表的使用），所以可以一直使用
         * 如果是调用dequeue()方法，那么就会删除
         */
        for (Integer w : G.adj(v)) {
            //如果当前顶点w没有被搜索过，则继续递归调用dfs方法完成深度优先搜索
            if (!marked[w]){
                dfs(G,w);
            }
            //判断当前顶点w是否已经在栈中，如果已经在栈中，证明当前顶点之前处于正在搜索的状态，那么现在又要搜索一次，证明检测到环了
            if (onStack[w]){
                hasCycle = true;
                return;
            }
        }
        //把当前顶点出栈
        onStack[v] = false;
    }

    //判断当前有向图G中是否有环
    public boolean hasCycle(){
        return hasCycle;
    }
}
</code></pre> 
<h3> （2）基于深度优先的顶点排序（拓扑排序）。</h3> 
<p><img src="https://images2.imgbox.com/9a/cb/giKmcUA4_o.png" alt="99adf1800178425fbb3c59a23191fab7.png"></p> 
<pre><code class="language-java">package 图的入门.有向图.图_拓扑排序_顶点排序;

import 图的入门.有向图.Digraph;
import 线性表.线性表_栈.Stack;

public class DepthFirstOrder {
    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //使用栈，存储顶点序列
    private Stack&lt;Integer&gt; reversePost;

    //创建一个检测环对象，检测图G中是否有环
    public DepthFirstOrder(Digraph G){
        //初始化marked数组
        this.marked = new boolean[G.V()];
        //初始化reversePost栈
        this.reversePost = new Stack&lt;&gt;();

        //遍历图中每一个顶点，让每个顶点作为入口，完成一次深度优先搜索
        for (int v = 0; v &lt; G.V(); v++) {
            if (!marked[v]){
                dfs(G,v);
            }
        }
    }

    //基于深度优先搜索，检测图G中是否有环
    private void dfs(Digraph G,int v){
        //标记当前v已经被搜索
        marked[v] = true;
        //通过循环深度搜索顶点v
        for (Integer w : G.adj(v)) {
            if (!marked[w]){
                dfs(G,w);
            }
        }
        //让顶点v进栈
        reversePost.push(v);
    }

    //获取顶点线性序列
    public Stack&lt;Integer&gt; reversePost(){
        return reversePost;
    }

}
</code></pre> 
<h3>（3）拓扑排序。</h3> 
<p><img src="https://images2.imgbox.com/ee/25/ZZVIah4J_o.png" alt="e9644b7d52a4477e8de35624b8a3e851.png"></p> 
<p> </p> 
<pre><code class="language-java">package 图的入门.有向图.图_拓扑排序;

import 图的入门.有向图.Digraph;
import 图的入门.有向图.图_拓扑排序_检测有向环.DirectedCycle;
import 图的入门.有向图.图_拓扑排序_顶点排序.DepthFirstOrder;
import 线性表.线性表_栈.Stack;

public class TopoLogical {
    //顶点的拓扑排序
    private Stack&lt;Integer&gt; order;

    //构造拓扑排序对象
    public TopoLogical(Digraph G){
        /**
         * 虽然下面创建的两个对象都从同一个队列中取出数据
         * 但是使用的是增强for遍历，不会影响队列里面的数据
         */
        //创建一个检测有向环的对象
        DirectedCycle cycle = new DirectedCycle(G);
        //判断G图中有没有环，如果没有环，则进行顶点排序：创建一个顶点排序对象
        if (!cycle.hasCycle()){
            DepthFirstOrder depthFirstOrder = new DepthFirstOrder(G);
            order = depthFirstOrder.reversePost();
        }
    }

    //判断G图是否有环
    private boolean isCycle(){
        return order == null;
    }

    //获取拓扑排序的所有顶点
    public Stack&lt;Integer&gt; order(){
        return order;
    }
}
</code></pre> 
<p>测试代码：</p> 
<pre><code class="language-java">package 图的入门.有向图.图_拓扑排序;

import 图的入门.有向图.Digraph;
import 线性表.线性表_栈.Stack;

public class TopoLogicalTest {
    public static void main(String[] args) {
        //准备有向图
        Digraph digraph = new Digraph(6);
        digraph.addEdge(0,2);
        digraph.addEdge(0,3);
        digraph.addEdge(2,4);
        digraph.addEdge(3,4);
        digraph.addEdge(4,5);
        digraph.addEdge(1,3);
        //通过TopoLogical对象对有向图中的顶点进行排序
        TopoLogical topoLogical = new TopoLogical(digraph);
        //获取顶点的线性序列进行打印
        Stack&lt;Integer&gt; order = topoLogical.order();
        StringBuilder sb = new StringBuilder();
        for (Integer w : order) {
            sb.append(w+"-&gt;");
        }
        String str = sb.toString();
        int index = str.lastIndexOf("-&gt;");
        str = str.substring(0, index);
        System.out.println(str);
    }
}
</code></pre> 
<h2>三、加权有向图。</h2> 
<h3>（1）加权有向边。 </h3> 
<p><img src="https://images2.imgbox.com/08/45/W8Wz1LRc_o.png" alt="a503bd82d3544042a944ccce057d746d.png"></p> 
<pre><code class="language-java">package 图的入门.有向图.加权有向图;

public class DirectedEdge {
    private final int v;//起点
    private final int w;//终点
    private final double weight;//当前边的权重

    //通过顶点v和w，以及权重weight值构造一个边对象
    public DirectedEdge(int v,int w,double weight){
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    //获取边的权重值
    public double weight(){
        return weight;
    }

    //获取有向边的起点
    public int from(){
        return v;
    }

    //获取有向边的终点
    public int to(){
        return w;
    }
}
</code></pre> 
<h3>（2）加权有向图。</h3> 
<pre><code class="language-java">package 图的入门.有向图.加权有向图;

import 线性表.线性表_队列.Queue;

public class EdgeWeightedDigraph {
    //顶点总数
    private final int V;
    //边的总数
    private int E;
    //邻接表
    private Queue&lt;DirectedEdge&gt;[] adj;
    
    //创建一个含有V个顶点的空加权有向图
    public EdgeWeightedDigraph(int V){
        //初始化顶点数量
        this.V = V;
        //初始化边的数量
        this.E = 0;
        //初始化邻接表
        this.adj = new Queue[V];

        for (int i = 0; i &lt; adj.length; i++) {
            adj[i] = new Queue&lt;&gt;();
        }
    }
    
    //获取图中顶点的数量
    public int V(){
        return V;
    }
    
    //获取图中边的数量
    public int E(){
        return E;
    }
    
    //向加权有向图中添加一条边e
    public void addEdge(DirectedEdge e){
        //边e是有方向的，所以只需要让e出现在起点的邻接表中即可
        int v = e.from();
        adj[v].enqueue(e);
        E++;
    }
    
    //获取由顶点v指出的所有的边
    public Queue&lt;DirectedEdge&gt; adj(int v){
        return adj[v];
    }
    
    //获取加权有向图的所有边
    public Queue&lt;DirectedEdge&gt; edges(){
        //遍历图中的每一个顶点，得到该顶点的邻接表，遍历得到每一条边，添加到队列中返回即可
        Queue&lt;DirectedEdge&gt; allEdges = new Queue&lt;&gt;();
        for (int v = 0; v &lt; V; v++) {
            for (DirectedEdge e : adj[v]) {
                allEdges.enqueue(e);
            }
        }
        return allEdges;
    }
    
}
</code></pre> 
<h2>四、最短路径-Dijstra算法。 </h2> 
<p>最小生成树是连接所有的顶点，而最短路径是起点到终点，是一条路径，不需要连接所有顶点，只需要部分顶点。</p> 
<p><img src="https://images2.imgbox.com/ed/13/NnW7hd36_o.png" alt="003151bd70994f37b46c85799fc12d77.png"></p> 
<p><img src="https://images2.imgbox.com/61/9b/HLcLQw2f_o.png" alt="b8afbc0c29fd430882c4941ed9506116.png"></p> 
<pre><code class="language-java">package 图的入门.有向图.最短路径_Dijstra算法;

import 优先队列.IndexMinPrioirityQueue;
import 图的入门.有向图.加权有向图.DirectedEdge;
import 图的入门.有向图.加权有向图.EdgeWeightedDigraph;
import 线性表.线性表_队列.Queue;

public class DijstraSP {
    //索引代表顶点，值表示从顶点s到当前顶点的最短路径上的最后一条边
    private DirectedEdge[] edgeTo;
    //索引代表顶点，值从顶点s到当前顶点的最短路径的总权重
    private double[] distTo;
    //存放树中顶点与非树中顶点之间的有向横切边
    private IndexMinPrioirityQueue&lt;Double&gt; pq;

    //根据一副加权有向图G和顶点s，创建一个计算顶点s的最短路径树对象
    public DijstraSP(EdgeWeightedDigraph G,int s){
        //初始化edgeTo
        this.edgeTo = new DirectedEdge[G.V()];
        //初始化distTo
        this.distTo = new double[G.V()];
        for (int i = 0; i &lt; distTo.length; i++) {
            distTo[i] = Double.POSITIVE_INFINITY;//double类型的最大值
        }
        //初始化pq
        this.pq = new IndexMinPrioirityQueue&lt;&gt;(G.V());

        //找到图G中以顶点s为起点的最短路径树
        //默认让顶点s进入最短路径树中
        distTo[s] = 0.0;
        pq.insert(s,0.0);
        //遍历pq
        while (!pq.isEmpty()){
            relax(G,pq.delMin());
        }
    }

    //松弛图G中的顶点v
    private void relax(EdgeWeightedDigraph G,int v){
        for (DirectedEdge edge : G.adj(v)) {
            //获取到该边的终点w
            int w = edge.to();
            //通过松弛技术，判断从起点s到顶点w的最短路径是否需要先从顶点s到顶点v，然后再由顶点v到顶点w
            if (distTo[v] + edge.weight() &lt; distTo[w]){//这一步已经将已存在最短路径中的顶点排除了，进不来
                distTo[w] = distTo[v] + edge.weight();
                edgeTo[w] = edge;
                //判断pq中是否已经存在顶点w，如果存在，则更新权重，如果不存在，则支架添加
                if (pq.contains(w)){
                    pq.changeItem(w,distTo[w]);
                }else {
                    pq.insert(w,distTo[w]);
                }
            }
        }
    }

    //获取从顶点s到顶点v的最短路径的总权重
    public double distTo(int v){
        return distTo[v];
    }

    //判断从顶点s到顶点v是否可通达
    public boolean hasPathTo(int v){
        return edgeTo[v] != null;
        //也可以这样
//        return distTo[v] &lt; Double.POSITIVE_INFINITY;
    }

    //查询从起点s到顶点v的最短路径中所有的边
    public Queue&lt;DirectedEdge&gt; pathTo(int v){
        //判断从顶点s到顶点v是否可达，如果不可达，直接返回null
        if (!hasPathTo(v)){
            return null;
        }
        //创建队列对象
        Queue&lt;DirectedEdge&gt; allEdges = new Queue&lt;&gt;();
        while (true){
            DirectedEdge e = edgeTo[v];
            if (e == null){
                break;
            }
            allEdges.enqueue(e);
            v = e.from();
        }
        return allEdges;
    }
}
</code></pre> 
<pre><code class="language-java">package 图的入门.有向图.最短路径_Dijstra算法;

import 图的入门.有向图.加权有向图.DirectedEdge;
import 图的入门.有向图.加权有向图.EdgeWeightedDigraph;
import 线性表.线性表_队列.Queue;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class DijstraSPTest {
    public static void main(String[] args) throws IOException {
        //创建一副加权有向图
        BufferedReader br = new BufferedReader(new InputStreamReader(DijstraSPTest.class.getClassLoader().getResourceAsStream("min_route_test.txt")));
        int total = Integer.parseInt(br.readLine());
        EdgeWeightedDigraph G = new EdgeWeightedDigraph(total);
        int edgeNubers = Integer.parseInt(br.readLine());
        for (int i = 0; i &lt; edgeNubers; i++) {
            String line = br.readLine();
            String[] str = line.split(" ");
            int v = Integer.parseInt(str[0]);
            int w = Integer.parseInt(str[1]);
            double weight = Double.parseDouble(str[2]);
            //创建加权有向边
            DirectedEdge edge = new DirectedEdge(v, w, weight);
            G.addEdge(edge);
        }
        //创建DijstraSP对象，查找最短路径树
        DijstraSP dijstraSP = new DijstraSP(G, 0);
        //查找最短路径,0-&gt;6的最短路径
        Queue&lt;DirectedEdge&gt; edges = dijstraSP.pathTo(6);
        //遍历打印
        for (DirectedEdge edge : edges) {
            System.out.println(edge.from()+"-&gt;"+edge.to()+" :: "+edge.weight());
        }
    }
}
</code></pre> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a435eb09890967e20e6571a940cb0641/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机图形学 | 探秘造型技术</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/005999f1262241b2286a8ec2ddb5f105/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">进程调度算法的模拟</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>