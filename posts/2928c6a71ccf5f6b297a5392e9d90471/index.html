<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于RV1126移植Sony imx585 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于RV1126移植Sony imx585" />
<meta property="og:description" content="查看RV1126SDK内的sensor驱动，发现可以直接用的型号并不多，在实际项目实现的过程中，还是需要调试新的sensor，因此记录一下调试过程，之后的Sony系列都可以套用这个过程来实现。
首先确保硬件供电正常，另外i2c地址、时钟、上拉电阻等都要检查好，确保硬件没问题
在SDK/kernel/driver/media/i2c/ 下有相机sensor的驱动，都是在Linux框架下的，所以可以随便找一个索尼的驱动，在此基础上改。
在此之前要先修改设备树，设备树里主要定义了sensor的i2c地址，时钟频率，供电，复位的gpio、相机模组名、port节点的链接关系、date-lanes等
这里要按照自己原理图的定义去修改，另外ucam0_out节点链接到了mipi_in_ucam0，又链接到了rkcif-&gt;isp，因为对camera流的链接要求各不相同，此处不详细写出
&amp;i2c1 { status = &#34;okay&#34;; clock-frequency = &lt;400000&gt;; imx585: imx585@37 { compatible = &#34;sony,imx585&#34;; reg = &lt;0x37&gt;; clocks = &lt;&amp;cru 103&gt;; clock-names = &#34;xvclk&#34;; power-domains = &lt;&amp;power 9&gt;; pinctrl-names = &#34;rockchip,camera_default&#34;; pinctrl-0 = &lt;&amp;mipicsi_clk0&gt;; avdd-supply = &lt;&amp;vcc3v3_sys&gt;; dovdd-supply = &lt;&amp;vcc_1v8&gt;; dvdd-supply = &lt;&amp;vcc_dvdd&gt;; reset-gpios = &lt;&amp;gpio1 28 1&gt;; rockchip,camera-module-index = &lt;1&gt;; rockchip,camera-module-facing = &#34;front&#34;; rockchip,camera-module-name = &#34;YT10092&#34;; rockchip,camera-module-lens-name = &#34;IR0147-60IRC-8M-F20&#34;; ir-cut = &lt;&amp;cam_ircut0&gt;; port { ucam_out0: endpoint { remote-endpoint = &lt;&amp;mipi_in_ucam0&gt;; data-lanes = &lt;1 2 3 4&gt;; }; }; }; }; 在~/workspace/RV1126SDK/kernel/drivers/media/i2c下编辑Makefile，添加编译输出" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2928c6a71ccf5f6b297a5392e9d90471/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-27T13:59:32+08:00" />
<meta property="article:modified_time" content="2023-10-27T13:59:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于RV1126移植Sony imx585</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>查看RV1126SDK内的sensor驱动，发现可以直接用的型号并不多，在实际项目实现的过程中，还是需要调试新的sensor，因此记录一下调试过程，之后的Sony系列都可以套用这个过程来实现。</p> 
<p></p> 
<p>首先确保硬件供电正常，另外i2c地址、时钟、上拉电阻等都要检查好，确保硬件没问题</p> 
<p>在SDK/kernel/driver/media/i2c/ 下有相机sensor的驱动，都是在Linux框架下的，所以可以随便找一个索尼的驱动，在此基础上改。</p> 
<p>在此之前要先修改设备树，设备树里主要定义了sensor的i2c地址，时钟频率，供电，复位的gpio、相机模组名、port节点的链接关系、date-lanes等</p> 
<p>这里要按照自己原理图的定义去修改，另外ucam0_out节点链接到了mipi_in_ucam0，又链接到了rkcif-&gt;isp，因为对camera流的链接要求各不相同，此处不详细写出</p> 
<pre><code>&amp;i2c1 {
    status = "okay";
    clock-frequency = &lt;400000&gt;;

    imx585: imx585@37 {
        compatible = "sony,imx585";
        reg = &lt;0x37&gt;;
        clocks = &lt;&amp;cru 103&gt;;
        clock-names = "xvclk";
        power-domains = &lt;&amp;power 9&gt;;
        pinctrl-names = "rockchip,camera_default";
        pinctrl-0 = &lt;&amp;mipicsi_clk0&gt;;
        avdd-supply = &lt;&amp;vcc3v3_sys&gt;;
        dovdd-supply = &lt;&amp;vcc_1v8&gt;;
        dvdd-supply = &lt;&amp;vcc_dvdd&gt;;
        reset-gpios = &lt;&amp;gpio1 28 1&gt;;
        rockchip,camera-module-index = &lt;1&gt;;
        rockchip,camera-module-facing = "front";
        rockchip,camera-module-name = "YT10092";
        rockchip,camera-module-lens-name = "IR0147-60IRC-8M-F20";
        ir-cut = &lt;&amp;cam_ircut0&gt;;
        port {
            ucam_out0: endpoint {
                remote-endpoint = &lt;&amp;mipi_in_ucam0&gt;;
                data-lanes = &lt;1 2 3 4&gt;;
            };
        };
    };

};</code></pre> 
<p>在~/workspace/RV1126SDK/kernel/drivers/media/i2c下编辑Makefile，添加编译输出</p> 
<pre><code>obj-$(CONFIG_VIDEO_IMX585) += imx585.o</code></pre> 
<p>在~/workspace/RV1126SDK/kernel/drivers/media/i2c下编辑Kconfig，添加编译配置</p> 
<pre><code>config VIDEO_IMX585
        tristate "Sony IMX585 sensor support"
        depends on I2C &amp;&amp; VIDEO_V4L2 &amp;&amp; VIDEO_V4L2_SUBDEV_API
        depends on MEDIA_CAMERA_SUPPORT
        help
          This is a Video4Linux2 sensor driver for the Sony
          IMX585 camera.

          To compile this driver as a module, choose M here: the
          module will be called imx585.</code></pre> 
<p>编辑~/workspace/RV1126SDK/kernel/arch/arm/configs/rv1126_defconfig，打开IMX585编译选项</p> 
<pre><code>CONFIG_VIDEO_IMX585=y</code></pre> 
<p></p> 
<p>以上配置完成后，连接SoC与sensor，i2c应该是通的，但是用i2c工具测试，设备并没有挂载上，重复多次检查硬件确保硬件正常</p> 
<p></p> 
<p><span style="color:#4da8ee;">1、分析驱动源码</span></p> 
<p>首先进入probe函数</p> 
<p>通过<strong>of_property_read_u32</strong>获取设备树节点信息，以下代码为获取设备树内的相机模组名、hdr参数等</p> 
<pre><code>ret = of_property_read_u32(node, RKMODULE_CAMERA_MODULE_INDEX,
               &amp;imx585-&gt;module_index);
ret |= of_property_read_string(node, RKMODULE_CAMERA_MODULE_FACING,
                   &amp;imx585-&gt;module_facing);
ret |= of_property_read_string(node, RKMODULE_CAMERA_MODULE_NAME,
                   &amp;imx585-&gt;module_name);
ret |= of_property_read_string(node, RKMODULE_CAMERA_LENS_NAME,
                   &amp;imx585-&gt;len_name);
ret = of_property_read_u32(node, OF_CAMERA_HDR_MODE, &amp;hdr_mode);</code></pre> 
<p>获取imx585的工作模式，寄存器值可以通过Sony的手册获取，保密问题此处省略</p> 
<pre><code>imx585-&gt;client = client;
imx585-&gt;cfg_num = ARRAY_SIZE(supported_modes);
for (i = 0; i &lt; imx585-&gt;cfg_num; i++) {
    if (hdr_mode == supported_modes[i].hdr_mode) {
        imx585-&gt;cur_mode = &amp;supported_modes[i];
        break;
    }
}
    
在非HDR模式时，默认匹配为supported_modes[0]
{
    .bus_fmt = MEDIA_BUS_FMT_SGBRG10_1X10,
    .width = 3864,
    .height = 2192,
    .max_fps = {
        .numerator = 10000,
        .denominator = 300000,
    },
    .exp_def = 0x08ca - 0x08,
    .hts_def = 0x044c * IMX585_4LANES * 2,
    .vts_def = 0x08ca,
    .global_reg_list = imx585_global_10bit_3864x2192_regs,
    .reg_list = imx585_linear_10bit_3864x2192_891M_regs,
    .hdr_mode = NO_HDR,
    .mipi_freq_idx = 1,
    .bpp = 10,
}

因此需要设置imx585_global_10bit_3864x2192_regs和imx585_linear_10bit_3864x2192_891M_regs这两个寄存器
寄存器值可以通过Sony寄存器手册获取，参照寄存器表，以设置不同的工作模式

static __maybe_unused const struct regval imx585_global_10bit_3864x2192_regs[] = {
    ***************
    {REG_NULL, 0x00},
};

static __maybe_unused const struct regval imx585_linear_10bit_3864x2192_891M_regs[] = {
    **************
    {REG_NULL, 0x00},
};</code></pre> 
<p>获取设备树内reset、power、pinctrl信息</p> 
<pre><code>    imx585-&gt;reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_ASIS);
    if (IS_ERR(imx585-&gt;reset_gpio))
        dev_warn(dev, "Failed to get reset-gpios\n");
    imx585-&gt;power_gpio = devm_gpiod_get(dev, "power", GPIOD_ASIS);
    if (IS_ERR(imx585-&gt;power_gpio))
        dev_warn(dev, "Failed to get power-gpios\n");
    imx585-&gt;pinctrl = devm_pinctrl_get(dev);</code></pre> 
<p>获取power信息</p> 
<pre><code>ret = imx585_configure_regulators(imx585);
if (ret) {
    dev_err(dev, "Failed to get power regulators\n");
    return ret;
}

查看imx585_configure_regulators函数最后可以定位到下面的结构体的power信息
static const char * const imx585_supply_names[] = {
    "dvdd",     /* Digital core power */
    "dovdd",    /* Digital I/O power */
    "avdd",     /* Analog power */
};</code></pre> 
<p><strong>imx585_initialize_controls</strong>用于创建v4l2的控件，进入可以看到新建了exposure_max,、vblank_def、pixel_rate、h_blank等内容</p> 
<p><strong>__imx585_power_on</strong>用于使能设备，进入函数可以看到在里面设置了power_gpio和reset引脚的输出方向</p> 
<p><strong>imx585_check_sensor_id</strong>用于检测sensor，在此函数内进行了复位后寄存器值的检查，用于确认连接的sensor是否正确</p> 
<pre><code>    sd = &amp;imx585-&gt;subdev;
    v4l2_i2c_subdev_init(sd, client, &amp;imx585_subdev_ops);
    ret = imx585_initialize_controls(imx585);
    if (ret)
        goto err_destroy_mutex;

    ret = __imx585_power_on(imx585);
    if (ret)
        goto err_free_handler;

    ret = imx585_check_sensor_id(imx585, client);
    if (ret)
        goto err_power_off;</code></pre> 
<p>通过内核log，最后将问题确认到了<strong>imx585_check_sensor_id</strong>函数，在imx415和imx715中，检验的寄存器和寄存器值都是一样的，</p> 
<p>改成imx585后，因为其与imx415、imx715的寄存器不一样，因此在check_sensor的时候就会报错，导致sensor不能启动，i2c就不通。</p> 
<p>通过<strong>imx585_read_reg</strong>获取<strong>IMX585_REG_CHIP_ID</strong>寄存器的值，id即为读取的<strong>IMX585_REG_CHIP_ID</strong>寄存器内的值，使其与CHIP_ID比较，如果正确，则确定sensor是imx585，因此在选择此寄存器时，要选择寄存器表中最能体现为imx585的寄存器。</p> 
<pre><code>static int imx585_check_sensor_id(struct imx585 *imx585,
                  struct i2c_client *client)
{
    struct device *dev = &amp;imx585-&gt;client-&gt;dev;
    u32 id = 0;
    int ret;

    if (imx585-&gt;is_thunderboot) {
        dev_info(dev, "Enable thunderboot mode, skip sensor id check\n");
        return 0;
    }

    ret = imx585_read_reg(client, IMX585_REG_CHIP_ID,
                  IMX585_REG_VALUE_08BIT, &amp;id);
    if (id != CHIP_ID) {
        dev_err(dev, "Unexpected sensor id(%06x), ret(%d)\n", id, ret);
        return -ENODEV;
    }

    dev_info(dev, "Detected imx585 id %06x\n", CHIP_ID);

    return 0;
}</code></pre> 
<p>i2c读寄存器时，要创建两个msg，第一个msg用于存要读的寄存器信息，第二个msg用于存获取的寄存器信息</p> 
<p><strong>cpu_to_be16</strong>将i2c地址由小端存储改为大端存储。</p> 
<pre><code>/* Read registers up to 4 at a time */
static int imx585_read_reg(struct i2c_client *client, u16 reg, unsigned int len,
               u32 *val)
{
    struct i2c_msg msgs[2];
    u8 *data_be_p;
    __be32 data_be = 0;
    __be16 reg_addr_be = cpu_to_be16(reg);
    int ret;

    if (len &gt; 4 || !len)
        return -EINVAL;

    data_be_p = (u8 *)&amp;data_be;
    /* Write register address */
    msgs[0].addr = client-&gt;addr;
    msgs[0].flags = 0;
    msgs[0].len = 2;
    msgs[0].buf = (u8 *)&amp;reg_addr_be;

    /* Read data from register */
    msgs[1].addr = client-&gt;addr;
    msgs[1].flags = I2C_M_RD;
    msgs[1].len = len;
    msgs[1].buf = &amp;data_be_p[4 - len];

    ret = i2c_transfer(client-&gt;adapter, msgs, ARRAY_SIZE(msgs));
    if (ret != ARRAY_SIZE(msgs))
        return -EIO;

    *val = be32_to_cpu(data_be);

    return 0;
}</code></pre> 
<p>设置的校验寄存器及复位后的初始化值</p> 
<pre><code>/* TODO: Get the real chip id from reg */
#define CHIP_ID             0x32
#define IMX585_REG_CHIP_ID      0x30DC</code></pre> 
<p>修改完后重新编译驱动烧录测试，使用i2c工具检测，可以看到设备0x37处为UU，设备成功挂载</p> 
<p>修改宏定义部分寄存器值</p> 
<pre><code>#define IMX585_LF_GAIN_REG_H        0x306D
#define IMX585_LF_GAIN_REG_L        0x306C


#define IMX585_VTS_REG_L        0x3028
#define IMX585_VTS_REG_M        0x3029
#define IMX585_VTS_REG_H        0x302A</code></pre> 
<p>在驱动内修改<strong>INCK</strong>和<strong>Data Rate</strong></p> 
<pre><code>#define IMX585_XVCLK_FREQ_74M       74250000

usleep_range(10 * 1000, 20 * 1000);
ret = clk_set_rate(imx585-&gt;xvclk, IMX585_XVCLK_FREQ_74M);


static const s64 link_freq_items[] = {
    MIPI_FREQ_297M,
    MIPI_FREQ_446M,
    MIPI_FREQ_743M,
    MIPI_FREQ_891M,
};</code></pre> 
<p>接镜头测试，发现画面整体偏红，但黑色区域是正常的，因此考虑应该是Bayer格式的RGB排列问题，改为SRGGB10--&gt; .bus_fmt = MEDIA_BUS_FMT_SGBRG10_1X10，画面正常。</p> 
<p></p> 
<p><span style="color:#4da8ee;">2、总结</span></p> 
<p>因此移植一个新sensor可以总结为：</p> 
<p>1）确认硬件连接，确认io口及供电正确</p> 
<p>2）修改设备树，确认sensor的i2c地址，时钟频率，供电，复位的gpio、相机模组名、port节点的链接关系、date-lanes等</p> 
<p>3）修改驱动内初始化寄存器值，check_id，INCK、Data Rate等，要与实际参数对应上</p> 
<p>4）检查sensor的Bayer排列格式，不同的sensor排列方式不一样，此处设置不对画面会出现异常</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d06929c3653924b56f3641c4998c9499/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux脚本开机自启</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5ac474b3d465f7061854e02acb7b6a54/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;模板类用作参数传递</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>