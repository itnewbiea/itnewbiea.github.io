<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>应用于前端的自然断点法：wasm应用示例 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="应用于前端的自然断点法：wasm应用示例" />
<meta property="og:description" content="某月某日，虾神本虾接到了这样一个需求，前端获取数据之后，在渲染之前，要对数据进行分类，分类的方法可以选择常用几种，例如等距法、自然断点法、标准差分类法等……
问：为什么要在前端？这种功能不是一般都是在后台实现的么？虽然JavaScript号称能够重写一切，但是这种写算法的事情，本身不是它的领域啊。
答：前端的数据来源可能是很多不同的系统，组合之后得到的，不一定来源于一个系统或者一个库表，如果让后台做，前后台之间的数据传递就太繁杂了，所以甲方想在前端把这事情给做了，再说： 所以呢，虾神你不是做算法的么？来来来，帮忙给写一个……
虽然我手动写过自然断点法的计算方法，但是我不会JavaScript啊……你要不让我先花两个月，学习一下JavaScript？
虽然自然断点的算法还是比较简单的，我也写过：（见以前的文章：） 但是对于这种造轮子的活动，我一般是努力拒绝的：
所以我果断的把Python推荐给了他，毕竟Python里面已经有好几个身经百战的自然断点法的实现了，然后就毫无意外被拍回来了……
好吧，作为码农，不能说不行……我虽然不会写JavaScript，但是我会写Rust啊……好巧不巧，Rust写的wasm，就正好能在前端用。
首先简单介绍一下wasm
wasm: WebAssembly的简写，是一种新型的浏览器端代码：
用JavaScript的运行原理来说，它实际上是在JS的编译器中动态编译，然后在JS的VM中执行的，那么wasm可以让C/C&#43;&#43;/Rust一类的高性能编译语言，转换成一种称之为IR的虚拟指令集，在需要的时候，在转换成JS VM可以运行的机器指令：
这种IR的编译指令，能够最大化的利用客户端的底层(如CPU\内存\显卡等)硬件，所以很多时候，比原生态的JavaScript性能更高。
2019年的时候，wasm就已经正式成为了W3C标准，成为了Web开发的“第四门语言”
有关wasm的其他介绍，大家有兴趣的可以查阅其他资料，反正一句话：这玩意儿就是一个可以运行在前端浏览器上的编译级语言功能。
所以，我们就可以利用一些Rust写的东西，编译成JS可以用的脚本了。
秉承着有的轮子，我们就不用自己去造的原则，首先我们去看看Rust的官方仓库crates.io里面，有没有我们需要的东西：
很快，我告诉你，真的很快啊，就让我找到了这个东西：
然后就简单了——
我们直接去全球最大的同性交友网站gayhub……阿不，github，把这个包clone下来（或者你直接下载zip，然后解压也行），因为作者已经把所有的wasm相关代码都写好，所以你只需要运行编译打包就可以了，注意，官方文档上说-features如下：
wasm-pack build --release -- -features js 在我这里最新的Rust版本里面已经不好使了，直接编译为web就行，命令行如下：
wasm-pack build --release target web 然后看着cargo自动安装一堆东西，自动下载一堆东西，自动编译一堆东西，直到显示：
然后可以了，我们可以看见，在工程根目录下，会得到一个pkg包，里面有我们需要的wasm文件：
其中，index.html是调用的示例文件，搞前端的同学一眼就明白：
然后我们启动一个小http服务器，就可以看见效果了，我这里启动的是python自带的http服务器：
打开浏览器，F12看console:
我们可以简单解析一下这个工程（如果你Rust没有基础也没有兴趣，就可以跳过这一部分了），首先在src/jenks.rs文件中，写了一个函数，做了算法的实现：
//src/jenks.rs pub fn get_jenks_breaks&lt;T: ToPrimitive&gt;(num_bins: usize, data: &amp;[T]) -&gt; Vec&lt;f64&gt; { //jenks的算法见文章开头的链接，这里不解释了 //这里的就是用Rust把jenks的实现过程写了一遍。 } 这个函数在Rust工程里面是可以直接用的了，我们可以在下面写一个测试方法，来看看效果：
但是我们要在前端调用它，所以必须还要封装成wasm，所以还需要一个对外封装的接口： src/wasm.rs： 前面的#[wasm_bindgen]特性，就是声明该方法，是一个wasm的绑定，这样这个方法编译之后，就可以被前端调用了。
#[wasm_bindgen] pub fn get_jenks_breaks(no_bins: usize, data: &amp;[f64]) -&gt; Box&lt;[f64]&gt; { let breaks = crate::jenks::get_jenks_breaks(no_bins, data); breaks." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/1af06105e240c8a4c8700846fa7c21b2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-27T11:02:14+08:00" />
<meta property="article:modified_time" content="2023-12-27T11:02:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">应用于前端的自然断点法：wasm应用示例</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>某月某日，虾神本虾接到了这样一个需求，前端获取数据之后，在渲染之前，要对数据进行分类，分类的方法可以选择常用几种，例如等距法、自然断点法、标准差分类法等……</p> 
<p>问：为什么要在前端？这种功能不是一般都是在后台实现的么？虽然JavaScript号称能够重写一切，但是这种写算法的事情，本身不是它的领域啊。</p> 
<p>答：前端的数据来源可能是很多不同的系统，组合之后得到的，不一定来源于一个系统或者一个库表，如果让后台做，前后台之间的数据传递就太繁杂了，所以甲方想在前端把这事情给做了，再说： </p> 
<p class="img-center"><img alt="img" height="388" src="https://images2.imgbox.com/98/9d/uDOBGXeM_o.png" width="572"></p> 
<p>所以呢，虾神你不是做算法的么？来来来，帮忙给写一个……</p> 
<p>虽然我手动写过自然断点法的计算方法，但是我不会JavaScript啊……你要不让我先花两个月，学习一下JavaScript？</p> 
<p></p> 
<p class="img-center"><img alt="img" height="267" src="https://images2.imgbox.com/e3/08/qa9DZvAn_o.jpg" width="263"></p> 
<p>虽然自然断点的算法还是比较简单的，我也写过：（见以前的文章：） 但是对于这种造轮子的活动，我一般是努力拒绝的：</p> 
<p></p> 
<p class="img-center"><img alt="img" height="213" src="https://images2.imgbox.com/89/a8/2cE2KUAo_o.jpg" width="197"></p> 
<p>所以我果断的把<code>Python</code>推荐给了他，毕竟Python里面已经有好几个身经百战的自然断点法的实现了，然后就毫无意外被拍回来了……</p> 
<p></p> 
<p class="img-center"><img alt="img" height="195" src="https://images2.imgbox.com/e7/b2/HrwkcEil_o.png" width="238"></p> 
<p>好吧，作为码农，不能说不行……我虽然不会写JavaScript，但是我会写Rust啊……好巧不巧，Rust写的wasm，就正好能在前端用。</p> 
<p>首先简单介绍一下wasm</p> 
<p>wasm: WebAssembly的简写，是一种新型的浏览器端代码：</p> 
<p></p> 
<p class="img-center"><img alt="img" height="737" src="https://images2.imgbox.com/ed/b3/cD8ZvefD_o.png" width="1200"></p> 
<p>用JavaScript的运行原理来说，它实际上是在JS的编译器中动态编译，然后在JS的VM中执行的，那么wasm可以让C/C++/Rust一类的高性能编译语言，转换成一种称之为IR的虚拟指令集，在需要的时候，在转换成JS VM可以运行的机器指令：</p> 
<p></p> 
<p class="img-center"><img alt="img" height="737" src="https://images2.imgbox.com/90/91/BOyTMSgN_o.png" width="1200"></p> 
<p>这种IR的编译指令，能够最大化的利用客户端的底层(如CPU\内存\显卡等)硬件，所以很多时候，比原生态的JavaScript性能更高。</p> 
<p></p> 
<p class="img-center"><img alt="img" height="690" src="https://images2.imgbox.com/94/86/pVibFkqO_o.png" width="1200"></p> 
<p>2019年的时候，wasm就已经正式成为了W3C标准，成为了Web开发的“<strong>第四门语言</strong>”</p> 
<p></p> 
<p class="img-center"><img alt="img" height="671" src="https://images2.imgbox.com/69/06/Ghg45UyL_o.png" width="1200"></p> 
<p>有关wasm的其他介绍，大家有兴趣的可以查阅其他资料，反正一句话：这玩意儿就是一个可以运行在前端浏览器上的编译级语言功能。</p> 
<p>所以，我们就可以利用一些Rust写的东西，编译成JS可以用的脚本了。</p> 
<p>秉承着有的轮子，我们就不用自己去造的原则，首先我们去看看Rust的官方仓库crates.io里面，有没有我们需要的东西：</p> 
<p>很快，我告诉你，真的很快啊，就让我找到了这个东西：</p> 
<p></p> 
<p class="img-center"><img alt="img" height="796" src="https://images2.imgbox.com/13/57/uhqcaTM8_o.png" width="938"></p> 
<p>然后就简单了——</p> 
<p>我们直接去全球最大的同性交友网站gayhub……阿不，github，把这个包clone下来（或者你直接下载zip，然后解压也行），因为作者已经把所有的wasm相关代码都写好，所以你只需要运行编译打包就可以了，注意，官方文档上说-features如下：</p> 
<pre>wasm-pack build --release -- -features js</pre> 
<p>在我这里最新的Rust版本里面已经不好使了，直接编译为web就行，命令行如下：</p> 
<pre>wasm-pack build --release target web</pre> 
<p>然后看着cargo自动安装一堆东西，自动下载一堆东西，自动编译一堆东西，直到显示：</p> 
<p></p> 
<p class="img-center"><img alt="img" height="553" src="https://images2.imgbox.com/73/9a/W34Lygro_o.png" width="960"></p> 
<p>然后可以了，我们可以看见，在工程根目录下，会得到一个pkg包，里面有我们需要的wasm文件：</p> 
<p></p> 
<p class="img-center"><img alt="img" height="309" src="https://images2.imgbox.com/bc/bd/EDLWVM0k_o.png" width="566"></p> 
<p>其中，index.html是调用的示例文件，搞前端的同学一眼就明白：</p> 
<p></p> 
<p class="img-center"><img alt="img" height="785" src="https://images2.imgbox.com/27/74/oflCdTuz_o.png" width="1200"></p> 
<p>然后我们启动一个小http服务器，就可以看见效果了，我这里启动的是python自带的http服务器：</p> 
<p></p> 
<p class="img-center"><img alt="img" height="336" src="https://images2.imgbox.com/f5/3e/sNyKFyn7_o.png" width="898"></p> 
<p>打开浏览器，F12看console:</p> 
<p></p> 
<p class="img-center"><img alt="img" height="933" src="https://images2.imgbox.com/7d/5b/WIjPqmsL_o.png" width="1120"></p> 
<p>我们可以简单解析一下这个工程（如果你Rust没有基础也没有兴趣，就可以跳过这一部分了），首先在src/jenks.rs文件中，写了一个函数，做了算法的实现：</p> 
<pre>//src/jenks.rs

pub fn get_jenks_breaks&lt;T: ToPrimitive&gt;(num_bins: usize, data: &amp;[T]) -&gt; Vec&lt;f64&gt; {
    //jenks的算法见文章开头的链接，这里不解释了
    //这里的就是用Rust把jenks的实现过程写了一遍。
}
</pre> 
<p>这个函数在Rust工程里面是可以直接用的了，我们可以在下面写一个测试方法，来看看效果：</p> 
<p></p> 
<p class="img-center"><img alt="img" height="524" src="https://images2.imgbox.com/db/d4/0qp6i28l_o.png" width="755"></p> 
<p>但是我们要在前端调用它，所以必须还要封装成wasm，所以还需要一个对外封装的接口： src/wasm.rs： 前面的<code>#[wasm_bindgen]</code>特性，就是声明该方法，是一个wasm的绑定，这样这个方法编译之后，就可以被前端调用了。</p> 
<pre>#[wasm_bindgen]
pub fn get_jenks_breaks(no_bins: usize, data: &amp;[f64]) -&gt; Box&lt;[f64]&gt; {
    let breaks = crate::jenks::get_jenks_breaks(no_bins, data);
    breaks.into_boxed_slice()
}</pre> 
<p>接下去，编译完成之后，会生成.wasm文件，这个文件是一个二进制的文件：</p> 
<p></p> 
<p class="img-center"><img alt="img" height="473" src="https://images2.imgbox.com/bc/1a/61jjpvJ2_o.png" width="831"></p> 
<p>也就是我们前面说的IR（中间过程）文件。</p> 
<p>然后前端需要调用的话，还得将它给调度到JS VM里面去，所以Rust的wasm工具包还会编译出方便前端调用的js/ts接口：</p> 
<p></p> 
<p class="img-center"><img alt="img" height="542" src="https://images2.imgbox.com/38/7c/we0OYUzg_o.png" width="883"></p> 
<p>这样，你就得到了一个标准的Javascript接口，那么前端同学要调用，就没有任何的难度了……</p> 
<p>至此，一个用后台高性能编译型语言编写的算法，就完成了前端封装和调用。</p> 
<p>如果你有兴趣研究一下webassembly的话，这个例子我觉得可以当成hello world还好懂……起码你不用写一行代码，而具体里面的技术细节，有兴趣的同学可以查阅：</p> 
<p><a href="https://gitee.com/link?target=https%3A%2F%2Fwebassembly.org%2F" rel="nofollow" title="https://webassembly.org/">https://webassembly.org/</a></p> 
<p><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWebAssembly" rel="nofollow" title="https://developer.mozilla.org/zh-CN/docs/WebAssembly">https://developer.mozilla.org/zh-CN/docs/WebAssembly</a></p> 
<p>打完收工……</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/879adbbebcbd3b3023aa7c8b98df12c0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">腾讯混元大模型(待续)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b5d811e567cc40fd9899b6dc3215ad6b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java基础系列(十一) this关键字</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>