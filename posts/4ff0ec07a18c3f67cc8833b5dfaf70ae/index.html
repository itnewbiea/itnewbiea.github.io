<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构：树详解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构：树详解" />
<meta property="og:description" content="创建二叉树 给出了完整的先序遍历序列，子树为空用’#’表示，所以这样我们在通过先序遍历序列创建二叉树时我们直到先序遍历序列是先进行根结点，然后左子树最后右子树的顺序进行遍历的，所以对于完整的先序遍历序列我们可以直到先序遍历序列中第一个元素是二叉树的根结点，如果第二个元素不为’#’，那么这个代表二叉树有左孩子，而且左孩子的值为先序遍历序列的第二个元素的值，依次类推，根据二叉树的完整先序遍历序列我们可以直到每一个结点是否为空，这样我们就能够采取递归形式进行二叉树的创建：
创建过程的图示为如下：
最终我们得到的树如下图所示：
有了上面的思路我们可以写出如下代码：
void InitBinaryTree(char *p, int *length, struct BinaryTreeNode **root){ if(p[*length]!=0){ if(p[*length]!=&#39;#&#39;){ *root = (struct BinaryTreeNode *)malloc(sizeof(struct BinaryTreeNode)); (*root)-&gt;val = p[*length]; (*root)-&gt;left = NULL; (*root)-&gt;right = NULL; (*length)&#43;&#43;; InitBinaryTree(p, length, &amp;(*root)-&gt;left); InitBinaryTree(p, length, &amp;(*root)-&gt;right);	}else{ (*length)&#43;&#43;; } } } 这就是通过树的完整前序遍历序列创建二叉树的过程。
下面我们来进行实现二叉树的前序遍历、中序遍历与后序遍历，前序遍历是指先根结点再左子树最后右子树，中序遍历是先左子树然后根结点最后右子树，后序遍历是先左子树然后右子树最后根结点，这种遍历可以通过递归进行实现，在每次递归中所在结点不为NULL就说明结点有值，我们需要遍历这一个结点的左子树与右子树，也就是递归截至的条件是root==NULL;有了这样的思路前序遍历与中序遍历，与后序遍历就只是根结点的访问顺序发生改变，我们可以写出下面的三种遍历的代码：
前序遍历：
//本函数实现二叉树的前序遍历功能 void preOrderTraversal(struct BinaryTreeNode *root){ if(root!=NULL){ printf(&#34;%c &#34;, root-&gt;val); preOrderTraversal(root-&gt;left); preOrderTraversal(root-&gt;right);	} } 中序遍历：
//本函数实现二叉树的中序遍历功能 void inOrderTraversal(struct BinaryTreeNode *root){ if(root!=NULL){ inOrderTraversal(root-&gt;left); printf(&#34;%c &#34;, root-&gt;val); inOrderTraversal(root-&gt;right);	} } 后序遍历：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4ff0ec07a18c3f67cc8833b5dfaf70ae/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-06T22:14:51+08:00" />
<meta property="article:modified_time" content="2024-01-06T22:14:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构：树详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>创建二叉树</h3> 
<p>给出了完整的先序遍历序列，子树为空用’#’表示，所以这样我们在通过先序遍历序列创建二叉树时我们直到先序遍历序列是先进行根结点，然后左子树最后右子树的顺序进行遍历的，所以对于完整的先序遍历序列我们可以直到先序遍历序列中第一个元素是二叉树的根结点，如果第二个元素不为’#’，那么这个代表二叉树有左孩子，而且左孩子的值为先序遍历序列的第二个元素的值，依次类推，根据二叉树的完整先序遍历序列我们可以直到每一个结点是否为空，这样我们就能够采取递归形式进行二叉树的创建：<br> 创建过程的图示为如下：<br> <img src="https://images2.imgbox.com/83/68/RRXFpsLZ_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/98/2c/W4iNw61G_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/49/6a/07wkEMcV_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/45/03/lSYHxJun_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/40/57/2d7hG0LY_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/97/79/4Y4So083_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/8e/27/ChLBRLX3_o.png" alt="在这里插入图片描述"></p> 
<p>最终我们得到的树如下图所示：<br> <img src="https://images2.imgbox.com/f6/92/t5kr0HZe_o.png" alt="在这里插入图片描述"></p> 
<p>有了上面的思路我们可以写出如下代码：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">InitBinaryTree</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>length<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span><span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token operator">*</span>length<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token operator">*</span>length<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token char">'#'</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token operator">*</span>root <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">(</span><span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token operator">-&gt;</span>val <span class="token operator">=</span> p<span class="token punctuation">[</span><span class="token operator">*</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">(</span><span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
			<span class="token punctuation">(</span><span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
			<span class="token punctuation">(</span><span class="token operator">*</span>length<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token function">InitBinaryTree</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> length<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">InitBinaryTree</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> length<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>	
		<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
			<span class="token punctuation">(</span><span class="token operator">*</span>length<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这就是通过树的完整前序遍历序列创建二叉树的过程。<br> 下面我们来进行实现二叉树的前序遍历、中序遍历与后序遍历，前序遍历是指先根结点再左子树最后右子树，中序遍历是先左子树然后根结点最后右子树，后序遍历是先左子树然后右子树最后根结点，这种遍历可以通过递归进行实现，在每次递归中所在结点不为NULL就说明结点有值，我们需要遍历这一个结点的左子树与右子树，也就是递归截至的条件是root==NULL;有了这样的思路前序遍历与中序遍历，与后序遍历就只是根结点的访问顺序发生改变，我们可以写出下面的三种遍历的代码：<br> 前序遍历：</p> 
<pre><code class="prism language-c"><span class="token comment">//本函数实现二叉树的前序遍历功能</span>
<span class="token keyword">void</span> <span class="token function">preOrderTraversal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">preOrderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">preOrderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>中序遍历：</p> 
<pre><code class="prism language-c"><span class="token comment">//本函数实现二叉树的中序遍历功能</span>
<span class="token keyword">void</span> <span class="token function">inOrderTraversal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">inOrderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">inOrderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>后序遍历：</p> 
<pre><code class="prism language-c"><span class="token comment">// 本函数实现二叉树的后序遍历功能</span>
<span class="token keyword">void</span> <span class="token function">postOrderTraversal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">postOrderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">postOrderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>就以上面的建立的二叉树为例查看一下该二叉树的前序遍历序列、中序遍历序列、后序遍历序列。<br> 二叉树的前序遍历序列应为：<br> <img src="https://images2.imgbox.com/62/d0/yUYRBrty_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/0e/f5/OcCd6e8R_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/4c/6a/KHEVJFq8_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/09/15/4LyxJOcq_o.png" alt="在这里插入图片描述"></p> 
<p>中序遍历序列应为：<br> <img src="https://images2.imgbox.com/7e/0a/M7ofnM1C_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/9e/fa/ORz582BJ_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/e7/06/du29lYlT_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/3d/e8/txyQET75_o.png" alt="在这里插入图片描述"></p> 
<p>后序遍历序列应为：<br> <img src="https://images2.imgbox.com/9a/f5/X5cpnKJK_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/13/25/A1tUmnOY_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/e7/e3/36OiUph6_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/78/c4/dFK3acF2_o.png" alt="在这里插入图片描述"></p> 
<p>我们来运行一下看看结果是否正确：<br> <img src="https://images2.imgbox.com/77/db/3G1kB5cx_o.png" alt="在这里插入图片描述"><br> 可以看出结果确实正确。<br> 至此关于二叉树的内容已经全部实现，接下来实现哈夫曼树以及编码操作，题目中给出了’a’ ‘b’ ‘c’ ‘d’以及其对应出现的次数分别是7、5、2、4，出现次数多的字母编码要尽可能的短，我们可以利用哈夫曼树来实现对应的操作，哈夫曼树是为每个结点增加一个权值，权值大的结点离根要尽可能的近，我们就可以将所有的字符视作只有一个根结点的树，将结点权值小的两个子树进行合成组成一颗新树，两个子树的权值之和作为新树的权值，这一颗新树与剩余的所有树组成一个新的集合，然后从中选取两个树进行上述过程，如此重复下去，直到剩下一棵树，这棵树就是哈夫曼树。图示如下：<br> <img src="https://images2.imgbox.com/8e/14/cV075U1b_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/01/cb/sBKOufrz_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/3d/78/IvaWxeOa_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/a2/bb/bIJdrMe2_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/b2/7a/v7iYzRJ7_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/bd/3d/vxOyHhdx_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/60/5d/j5oLtA2Q_o.png" alt="在这里插入图片描述"></p> 
<p>如此进行下去最后只剩下一棵树：<br> <img src="https://images2.imgbox.com/e6/33/d4L6Iv0b_o.png" alt="在这里插入图片描述"></p> 
<p>这就是哈夫曼树，所以只需要将字母出现的次数作为权值，按照上述规则我们就能够生成一颗哈夫曼树。代码如下：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> weight<span class="token punctuation">;</span>
	<span class="token keyword">char</span> val<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span> left<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//对子树按照权值进行降序排列，这样只操作最后面的两棵树就行了</span>
<span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span><span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-&gt;</span>weight<span class="token operator">&lt;</span>p<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>weight<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
				<span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span> t <span class="token operator">=</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
				p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				p<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//创建哈夫曼树</span>
<span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span> <span class="token function">InitHuffmanTree</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span><span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span> root <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>length<span class="token operator">!=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">sort</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
		root<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">*</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		root<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">*</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        root<span class="token operator">-&gt;</span>val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		root<span class="token operator">-&gt;</span>weight <span class="token operator">=</span> p<span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>weight<span class="token operator">+</span>p<span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>weight<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		p<span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> root<span class="token punctuation">;</span>
		root <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		length <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	root<span class="token operator">-&gt;</span>left <span class="token operator">=</span> p<span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	root<span class="token operator">-&gt;</span>right <span class="token operator">=</span> p<span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	root<span class="token operator">-&gt;</span>weight <span class="token operator">=</span> p<span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>weight<span class="token operator">+</span>p<span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>weight<span class="token punctuation">;</span>
	<span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//前序遍历</span>
<span class="token keyword">void</span> <span class="token function">preOrderTraversal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> root<span class="token operator">-&gt;</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">preOrderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">preOrderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//中序遍历</span>
<span class="token keyword">void</span> <span class="token function">inOrderTraversal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">inOrderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> root<span class="token operator">-&gt;</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">inOrderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> n<span class="token punctuation">;</span>
	<span class="token keyword">char</span> code<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请问你有多少个字符需要进行编码:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请按顺序输入字符与其出现的次数。\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入字符:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入字符出现的次数:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请确认你刚才输入的信息：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"字符%c,出现%d次\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>val<span class="token punctuation">,</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span> root <span class="token operator">=</span> <span class="token function">InitHuffmanTree</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"此哈夫曼树的权值前序序列为："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">preOrderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n此哈夫曼树的中序序列为:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">inOrderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/98/f0/l011ejm8_o.png" alt="在这里插入图片描述"></p> 
<p>根据权值的前序序列与中序序列可以建立如下二叉树：<br> <img src="https://images2.imgbox.com/9b/be/4hfy46YV_o.png" alt="在这里插入图片描述"></p> 
<p>因为出现在叶子结点的才是字符，所以我们可以直到权值为7的结点时’a’，权值为4的结点是’d’，权值为2的结点是’c’,权值为5的结点时’b’，即如下图所示：<br> <img src="https://images2.imgbox.com/84/df/gW63SJcr_o.png" alt="在这里插入图片描述"></p> 
<p>按照哈夫曼树的建立规则进行手动建树，可以建出以下这个树:<br> <img src="https://images2.imgbox.com/be/af/BKnqrx4D_o.png" alt="在这里插入图片描述"></p> 
<p>可以看出这两棵树是等价的，只不过是左右孩子交换了下顺序，也就是说明了程序是正确的。接下来就是进行哈夫曼编码了。<br> 向左为0，向右为1进行编码，进行二进制编码，可以写出下面的代码：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">HuffmanCode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">BinaryTreeNode</span> <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">char</span> n<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token comment">//p用来存储编好的编码</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">switch</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">case</span> <span class="token char">'a'</span><span class="token operator">:</span>	
			<span class="token keyword">case</span> <span class="token char">'b'</span><span class="token operator">:</span>
			<span class="token keyword">case</span> <span class="token char">'c'</span><span class="token operator">:</span>
			<span class="token keyword">case</span> <span class="token char">'d'</span><span class="token operator">:</span>
				<span class="token keyword">int</span> i<span class="token punctuation">;</span>
				<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
					p<span class="token punctuation">[</span>root<span class="token operator">-&gt;</span>val<span class="token operator">-</span><span class="token char">'a'</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>n<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				p<span class="token punctuation">[</span>root<span class="token operator">-&gt;</span>val<span class="token operator">-</span><span class="token char">'a'</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token char">'\0'</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		n<span class="token punctuation">[</span>length<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'0'</span><span class="token punctuation">;</span>
		n<span class="token punctuation">[</span>length<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token function">HuffmanCode</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> n<span class="token punctuation">,</span> p<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
		length<span class="token operator">--</span><span class="token punctuation">;</span>
		n<span class="token punctuation">[</span>length<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'1'</span><span class="token punctuation">;</span>
		n<span class="token punctuation">[</span>length<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token function">HuffmanCode</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> n<span class="token punctuation">,</span> p<span class="token punctuation">,</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>对上面的树进行编码<br> <img src="https://images2.imgbox.com/5c/a9/lstuxdiI_o.png" alt="在这里插入图片描述"></p> 
<p>运行结果：<br> <img src="https://images2.imgbox.com/10/f5/4BygKJI5_o.png" alt="在这里插入图片描述"></p> 
<p>可以看到确实生成了哈夫曼编码。<br> <font color="red"><br> 如果有什么地方讲的不好或者讲错的地方欢迎大家指出来，如果我所讲的对你们有帮助不要忘了点赞、收藏、关注哦！</font><br> <font color="red"><br> 我是你们的好伙伴apprentice_eye</font><br> <font color="red"><br> 一个致力于让知识变的易懂的博主。<br> </font></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2a5b5ed25ea6429618e95bba996ef528/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">嵌入式（五）通信协议 | 串行异步同步 UART SPI I2C 全解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/819497935ba26890889a2a1a91aa6388/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">神经网络-搭建小实战和Sequential的使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>