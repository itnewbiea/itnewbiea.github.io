<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL第一讲：程序员必须精通的MySQL索引规范 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySQL第一讲：程序员必须精通的MySQL索引规范" />
<meta property="og:description" content="索引（Index）是帮助MySQL高效获取数据的数据结构。数据库系统维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。
文章目录 1、类型（三种）2、规范(10余条)CheckListAction1 、三个字段联合索引时，如果中间的字段使用了范围查询或者模糊查询，最后一个字段还会用到索引么？Action2、在order by时，索引是如何使用的？Action3、新建一张表，如何界定其索引的数量，有没有选择或者公式Action4、字符串如何加索引，能不能再详细介绍下字符串前缀索引Action5、什么是覆盖索引？ 1、类型（三种） 主键索引名为 pk_字段名； 唯一索引名为 uk_字段名； 普通索引名则为 idx_字段名 。
说明： pk_ 即 primary key； uk_ 即 unique key
2、规范(10余条) 序号规范说明例子1【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明 显的； 另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生节能环保打标表 UNIQUE INDEX uk_config_brand_spec_auth(config_id, brand_id, specification(255), auth_code(255)) USING BTREE, 区划限价设置表(牧谦) CREATE UNIQUE INDEX uni_district ON db_item.zcy_district_category_price (category_id,config_id,district_id);2【强制】超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致； 多表关联查询时，保证被关联的字段需要有索引。 即使双表 join 也要注意表索引、 SQL 性能。商品库不存在join3【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定属性值表 create index idx_name on db_item.parana_property_value (name(100))4【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引属性值表 INDEX idx_name(name(20)) USING BTREE SQL：AND name LIKE CONCAT(#{name},‘%’)5【推荐】如果有 order by的场景，请注意利用索引的有序性。 order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort(文件排序)的情况，影响查询性能。正例： where a=?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8405dcf0edf502ae4bd7fd3eeb9c3d6a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-11T15:01:35+08:00" />
<meta property="article:modified_time" content="2023-10-11T15:01:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL第一讲：程序员必须精通的MySQL索引规范</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>索引（Index）是帮助MySQL高效获取数据的数据结构。数据库系统维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#1_3" rel="nofollow">1、类型（三种）</a></li><li><a href="#210_6" rel="nofollow">2、规范(10余条)</a></li><li><a href="#CheckList_21" rel="nofollow">CheckList</a></li><li><ul><li><a href="#Action1__22" rel="nofollow">Action1 、三个字段联合索引时，如果中间的字段使用了范围查询或者模糊查询，最后一个字段还会用到索引么？</a></li><li><a href="#Action2order_by_25" rel="nofollow">Action2、在order by时，索引是如何使用的？</a></li><li><a href="#Action3_28" rel="nofollow">Action3、新建一张表，如何界定其索引的数量，有没有选择或者公式</a></li><li><a href="#Action4_31" rel="nofollow">Action4、字符串如何加索引，能不能再详细介绍下字符串前缀索引</a></li><li><a href="#Action5_35" rel="nofollow">Action5、什么是覆盖索引？</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1_3"></a>1、类型（三种）</h3> 
<p><strong>主键索引名为 pk_字段名； 唯一索引名为 uk_字段名； 普通索引名则为 idx_字段名 。</strong><br> 说明： <mark>pk_ 即 primary key； uk_ 即 unique key</mark></p> 
<h3><a id="210_6"></a>2、规范(10余条)</h3> 
<table><thead><tr><th>序号</th><th>规范</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>1</td><td><strong>【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引</strong>。</td><td>不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明 显的； 另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生</td><td><strong>节能环保打标表</strong> UNIQUE INDEX <code>uk_config_brand_spec_auth</code>(<code>config_id</code>, <code>brand_id</code>, <code>specification</code>(255), <code>auth_code</code>(255)) USING BTREE, <strong>区划限价设置表(牧谦)</strong> CREATE UNIQUE INDEX uni_district ON db_item.zcy_district_category_price (category_id,config_id,district_id);</td></tr><tr><td>2</td><td><strong>【强制】超过三个表禁止 join。</strong></td><td>需要 join 的字段，数据类型必须绝对一致； 多表关联查询时，保证被关联的字段需要有索引。 即使双表 join 也要注意表索引、 SQL 性能。</td><td>商品库不存在join</td></tr><tr><td>3</td><td><strong>【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可</strong></td><td>索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定</td><td>属性值表 create index idx_name on db_item.parana_property_value (name(100))</td></tr><tr><td>4</td><td>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</td><td>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引</td><td>属性值表 INDEX <code>idx_name</code>(<code>name</code>(20)) USING BTREE SQL：AND <code>name</code> LIKE CONCAT(#{name},‘%’)</td></tr><tr><td>5</td><td>【推荐】如果有 order by的场景，请注意利用索引的有序性。 order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort(文件排序)的情况，影响查询性能。</td><td>正例： where a=? and b=? order by c; 索引： a_b_c 反例： 索引中有范围查找，那么索引有序性无法利用，如： WHERE a&gt;10 ORDER BY b; 索引a_b 无法排序。</td><td>spu库(奕铭)：IDX_category_status_createdAt(category_id,status,created_at) sql：WHERE category_id = 4619 and <code>status</code> = 3 order by created_at DESC LIMIT 0, 500</td></tr><tr><td>6</td><td>【推荐】利用覆盖索引来进行查询操作，避免回表。覆盖索引：</td><td>如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。</td><td>能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用 explain 的结果， extra 列会出现： using index。</td></tr><tr><td>7</td><td>【推荐】利用延迟关联或者子查询优化超多分页场景。</td><td>MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写</td><td>先快速定位需要获取的 id 段，然后再关联：SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</td></tr><tr><td>8</td><td>【推荐】 SQL 性能优化的目标：至少要达到 range 级别， 要求是 ref 级别， 如果可以是consts最好</td><td>1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。2） ref 指的是使用普通的索引（normal index） 。3） range 对索引进行范围检索</td><td>反例：explain 表的结果， type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫</td></tr><tr><td>9</td><td>【推荐】建组合索引的时候，区分度最高的在最左边。</td><td>存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如： where c&gt;? and d=? 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列， 即索引 idx_d_c。</td><td>如果 where a=? and b=? ，如果 a 列的几乎接近于唯一值，那么只需要单建 idx_a索引即可。5.7提供自动顺序优化**</td></tr><tr><td>10</td><td>【推荐】 防止因字段类型不同造成的隐式转换， 导致索引失效</td><td>例子：</td><td></td></tr><tr><td>11</td><td>【参考】创建索引时避免有如下极端误解</td><td>1） <strong>宁滥勿缺。 认为一个查询就需要建一个索引。</strong> <strong>2） 宁缺勿滥。 认为索引会消耗空间、严重拖慢更新和新增速度。</strong> 3） <strong>抵制惟一索引。 认为业务的惟一性一律需要在应用层通过“先查后插”方式解决</strong>。</td><td>唯一索引踩坑：</td></tr></tbody></table> 
<h3><a id="CheckList_21"></a>CheckList</h3> 
<h4><a id="Action1__22"></a>Action1 、三个字段联合索引时，如果中间的字段使用了范围查询或者模糊查询，最后一个字段还会用到索引么？</h4> 
<blockquote> 
 <p>用得到</p> 
</blockquote> 
<h4><a id="Action2order_by_25"></a>Action2、在order by时，索引是如何使用的？</h4> 
<blockquote> 
 <p>使用了 filesort 模式</p> 
</blockquote> 
<h4><a id="Action3_28"></a>Action3、新建一张表，如何界定其索引的数量，有没有选择或者公式</h4> 
<blockquote> 
 <p>根据业务场景选择，不要遗漏索引，索引也不是越多越好</p> 
</blockquote> 
<h4><a id="Action4_31"></a>Action4、字符串如何加索引，能不能再详细介绍下字符串前缀索引</h4> 
<blockquote> 
 <p>使用某个字段中字符串的前几个字符建立索引。<br> 前缀索引优化为什么需要优化？索引文件是存储在磁盘中的，而磁盘中最小分配单元是页，通常一个页的默认大小为 16KB，减小索引字段大小，可以增加一个页中存储的索引项，有效提高索引的查询速度</p> 
</blockquote> 
<h4><a id="Action5_35"></a>Action5、什么是覆盖索引？</h4> 
<blockquote> 
 <p><code>select ID from T where k between 3 and 5</code>，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，<strong>索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引</strong>。<br> 具体见这篇文章：<a href="https://blog.csdn.net/qq_28959087/article/details/103555488">MySQL第二讲：MySQL索引原理</a></p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5b96366f16379f4346c6a8b375aa58b9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【前端】前端页面直接根据URL链接生成二维码【亲测可用】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4aa5416bf87bca7e6f4e01f343779036/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JUC第六讲：二面阿里竟然败在了 volatile 关键字上</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>