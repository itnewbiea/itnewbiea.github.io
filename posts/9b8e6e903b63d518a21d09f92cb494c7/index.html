<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mysql基础用法_MySQL基本用法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="mysql基础用法_MySQL基本用法" />
<meta property="og:description" content="以下内容的一些总结
create，alter，drop，show， 用于 表/数据库
DDL CRUD后都要加database/databases/table/tables
select database(); -DOS窗口中查询当前正在使用的数据库，使用用use。
表中数据的增加用insert into，修改update，删除delete这两个一般加上限定条件WHERE
DQL中NULL不能用“==” 等运算符判读，需要使用IS/IS NOT
where与hanving限定的区别，在分组查询中，where限定是在分组之前，不满足条件不参与分组，having限定是在分组之后，不满足条件不会被查询出来。
where 后不能进行聚合函数的判断，having可以
修改表，进行数据项约束：
alter table 表名 modify 列名 数据类型 NOT NULL;
mysql中，唯一约束限定的列的值可以有多个null
删除特例
删除主键约束：ALTER TABLE stu DROP PRIMARY KEY;
删除唯一约束：ALTER TABLE stu DROP INDEX 列名;
select now(); 查看mysql系统时间。和当前时间做对比
set global time_zone = &#39;&#43;8:00&#39;;设置时区更改为东八区
flush privileges; 刷新权限
MySQL数据库软件卸载
卸载
去mysql的安装目录找到my.ini文件
复制 datadir=&#34;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&#34;
卸载MySQL
删除C:/ProgramData目录下的MySQL文件夹。
配置
MySQL服务启动
手动。
cmd--&gt; services.msc 打开服务的窗口
使用管理员打开cmd
net start mysql : 启动mysql的服务" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/9b8e6e903b63d518a21d09f92cb494c7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-19T07:07:36+08:00" />
<meta property="article:modified_time" content="2021-01-19T07:07:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mysql基础用法_MySQL基本用法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>以下内容的一些总结</p> 
 <p>create，alter，drop，show， 用于 表/数据库</p> 
 <p>DDL CRUD后都要加database/databases/table/tables</p> 
 <p>select database(); -DOS窗口中查询当前正在使用的数据库，使用用use。</p> 
 <p>表中数据的增加用insert into，修改update，删除delete这两个一般加上限定条件WHERE</p> 
 <p>DQL中NULL不能用“==” 等运算符判读，需要使用IS/IS NOT</p> 
 <p>where与hanving限定的区别，在分组查询中，where限定是在分组之前，不满足条件不参与分组，having限定是在分组之后，不满足条件不会被查询出来。</p> 
 <p>where 后不能进行聚合函数的判断，having可以</p> 
 <p>修改表，进行数据项约束：</p> 
 <p>alter table 表名 modify 列名 数据类型 NOT NULL;</p> 
 <p>mysql中，唯一约束限定的列的值可以有多个null</p> 
 <p>删除特例</p> 
 <p>删除主键约束：ALTER TABLE stu DROP PRIMARY KEY;</p> 
 <p>删除唯一约束：ALTER TABLE stu DROP INDEX 列名;</p> 
 <p>select now(); 查看mysql系统时间。和当前时间做对比</p> 
 <p>set global time_zone = '+8:00';设置时区更改为东八区</p> 
 <p>flush privileges; 刷新权限</p> 
 <p>MySQL数据库软件卸载</p> 
 <p>卸载</p> 
 <p>去mysql的安装目录找到my.ini文件</p> 
 <p>复制 datadir="C:/ProgramData/MySQL/MySQL Server 5.5/Data/"</p> 
 <p>卸载MySQL</p> 
 <p>删除C:/ProgramData目录下的MySQL文件夹。</p> 
 <p>配置</p> 
 <p>MySQL服务启动</p> 
 <p>手动。</p> 
 <p>cmd--&gt; services.msc 打开服务的窗口</p> 
 <p>使用管理员打开cmd</p> 
 <p>net start mysql : 启动mysql的服务</p> 
 <p>net stop mysql:关闭mysql服务</p> 
 <p>MySQL登录</p> 
 <p>mysql -uroot -p密码</p> 
 <p>mysql -hip -uroot -p连接目标的密码</p> 
 <p>mysql --host=ip --user=root --password=连接目标的密码</p> 
 <p>MySQL退出</p> 
 <p>exit</p> 
 <p>quit</p> 
 <p>MySQL目录结构</p> 
 <p>MySQL安装目录：basedir="D:/develop/MySQL/"</p> 
 <p>配置文件 my.ini</p> 
 <p>MySQL数据目录：datadir="C:/ProgramData/MySQL/MySQL Server 5.5/Data/"</p> 
 <p>几个概念</p> 
 <p>数据库：文件夹</p> 
 <p>表：文件</p> 
 <p>数据：数据</p> 
 <p>客户端图形化工具：SQLYog</p> 
 <p>SQL</p> 
 <p>什么是SQL？</p> 
 <p>Structured Query Language：结构化查询语言</p> 
 <p>其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。</p> 
 <p>SQL通用语法</p> 
 <p>SQL 语句可以单行或多行书写，以分号结尾。</p> 
 <p>可使用空格和缩进来增强语句的可读性。</p> 
 <p>MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。</p> 
 <p>3 种注释</p> 
 <p>单行注释: -- 注释内容 或 # 注释内容(mysql 特有)</p> 
 <p>多行注释: /* 注释 */</p> 
 <p>SQL分类</p> 
 <p>DDL(Data Definition Language)数据定义语言</p> 
 <p>用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等</p> 
 <p>DML(Data Manipulation Language)数据操作语言</p> 
 <p>用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等</p> 
 <p>DQL(Data Query Language)数据查询语言</p> 
 <p>用来查询数据库中表的记录(数据)。关键字：select, where 等</p> 
 <p>DCL(Data Control Language)数据控制语言(了解)</p> 
 <p>用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</p> 
 <p>DDL:操作数据库</p> 
 <p>操作数据库：CRUD</p> 
 <p>C(Create):创建</p> 
 <p>创建数据库：</p> 
 <p>create database 数据库名称;</p> 
 <p>创建数据库，判断不存在，再创建：</p> 
 <p>create database if not exists 数据库名称;</p> 
 <p>创建数据库，并指定字符集</p> 
 <p>create database 数据库名称 character set 字符集名;</p> 
 <p>练习： 创建db4数据库，判断是否存在，并制定字符集为gbk</p> 
 <p>* create database if not exists db4 character set gbk;</p> 
 <p>R(Retrieve)：查询</p> 
 <p>查询所有数据库的名称:</p> 
 <p>show databases;</p> 
 <p>查询某个数据库的字符集:查询某个数据库的创建语句</p> 
 <p>show create database 数据库名称;</p> 
 <p>U(Update):修改</p> 
 <p>修改数据库的字符集</p> 
 <p>alter database 数据库名称 character set 字符集名称;</p> 
 <p>D(Delete):删除</p> 
 <p>删除数据库</p> 
 <p>drop database 数据库名称;</p> 
 <p>判断数据库存在，存在再删除</p> 
 <p>drop database if exists 数据库名称;</p> 
 <p>使用数据库</p> 
 <p>查询当前正在使用的数据库名称</p> 
 <p>select database();</p> 
 <p>使用数据库</p> 
 <p>use 数据库名称;</p> 
 <p>DDL操作表</p> 
 <p>C(Create):创建</p> 
 <p>语法：</p> 
 <p>create table 表名(</p> 
 <p>列名1 数据类型1,</p> 
 <p>列名2 数据类型2,</p> 
 <p>....</p> 
 <p>列名n 数据类型n</p> 
 <p>);</p> 
 <p>注意：最后一列，不需要加逗号(,)</p> 
 <p>数据库类型：</p> 
 <p>int：整数类型</p> 
 <p>age int,</p> 
 <p>double:小数类型</p> 
 <p>score double(5,2)</p> 
 <p>date:日期，只包含年月日，yyyy-MM-dd</p> 
 <p>datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss</p> 
 <p>timestamp:时间错类型包含年月日时分秒 yyyy-MM-dd HH:mm:ss</p> 
 <p>如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋</p> 
 <p>varchar：字符串</p> 
 <p>name varchar(20):姓名最大20个字符</p> 
 <p>zhangsan 8个字符 张三 2个字符</p> 
 <p>创建表</p> 
 <p>create table student(</p> 
 <p>id int,</p> 
 <p>name varchar(32),</p> 
 <p>age int ,</p> 
 <p>score double(4,1),</p> 
 <p>birthday date,</p> 
 <p>insert_time timestamp</p> 
 <p>);</p> 
 <p>复制表：</p> 
 <p>create table 表名 like 被复制的表名;</p> 
 <p>R(Retrieve)：查询</p> 
 <p>查询某个数据库中所有的表名称</p> 
 <p>show tables;</p> 
 <p>查询表的结构，字段名，字段属性等</p> 
 <p>desc 表名;</p> 
 <p>U(Update):修改</p> 
 <p>修改表名</p> 
 <p>alter table 表名 rename to 新的表名;</p> 
 <p>修改表的字符集</p> 
 <p>alter table 表名 character set 字符集名称;</p> 
 <p>添加一列</p> 
 <p>alter table 表名 add 列名 数据类型;</p> 
 <p>修改列名称 类型</p> 
 <p>alter table 表名 change 列名 新列重命名 新数据类型;</p> 
 <p>alter table 表名 modify 列名 新数据类型;</p> 
 <p>删除列</p> 
 <p>alter table 表名 drop 列名;</p> 
 <p>修改表的字段值为主键</p> 
 <p>ALTER TABLE student ADD PRIMARY KEY(id);</p> 
 <p>D(Delete):删除</p> 
 <p>drop table 表名;</p> 
 <p>drop table if exists 表名 ;</p> 
 <p>表的约束</p> 
 <p>理解：对数据进行限定，保证数据的正确性，有效性、完整性</p> 
 <p>分类：</p> 
 <p>主键约束：primary key</p> 
 <p>非空约束：not null</p> 
 <p>唯一约束：unique</p> 
 <p>外键约束：foreign key</p> 
 <p>非空约束：not null</p> 
 <p>值不能为null</p> 
 <p>创建表时添加约束</p> 
 <p>CREATE TABLE stu(</p> 
 <p>id INT,</p> 
 <p>NAME VARCHAR(20) NOT NULL -- name为非空</p> 
 <p>);</p> 
 <p>创建表完后，添加非空约束</p> 
 <p>ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;</p> 
 <p>删除name的非空约束</p> 
 <p>ALTER TABLE stu MODIFY NAME VARCHAR(20);</p> 
 <p>唯一约束：unique</p> 
 <p>值不能重复</p> 
 <p>创建表时，添加唯一约束</p> 
 <p>CREATE TABLE stu(</p> 
 <p>id INT,</p> 
 <p>phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束</p> 
 <p>);</p> 
 <p>-- * 注意mysql中，唯一约束限定的列的值可以有多个null</p> 
 <p>删除唯一约束</p> 
 <p>ALTER TABLE stu DROP INDEX phone_number;</p> 
 <p>在创建表后，添加唯一约束</p> 
 <p>ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;</p> 
 <p>主键约束：primary key。</p> 
 <p>注意：</p> 
 <p>含义：非空且唯一</p> 
 <p>一张表只能有一个字段为主键</p> 
 <p>主键就是表中记录的唯一标识</p> 
 <p>在创建表时，添加主键约束</p> 
 <p>create table stu(</p> 
 <p>id int primary key,-- 给id添加主键约束</p> 
 <p>name varchar(20)</p> 
 <p>);</p> 
 <p>删除主键</p> 
 <p>-- 错误 alter table stu modify id int ;</p> 
 <p>ALTER TABLE stu DROP PRIMARY KEY;</p> 
 <p>创建完表后，添加主键</p> 
 <p>ALTER TABLE stu MODIFY id INT PRIMARY KEY;</p> 
 <p>自动增长：</p> 
 <p>概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长</p> 
 <p>在创建表时，添加主键约束，并且完成主键自增长</p> 
 <p>create table stu(</p> 
 <p>id int primary key auto_increment,-- 给id添加主键约束</p> 
 <p>name varchar(20)</p> 
 <p>);</p> 
 <p>删除自动增长</p> 
 <p>ALTER TABLE stu MODIFY id INT;</p> 
 <p>添加自动增长</p> 
 <p>ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;</p> 
 <p>注意：自动增长也可以自定义赋值，然后自动增长从自定义赋值开始</p> 
 <p>外键约束：foreign key</p> 
 <p>让表于表产生关系，从而保证数据的正确性。</p> 
 <p>在创建表时，可以添加外键</p> 
 <p>语法：create table 表名(</p> 
 <p>....</p> 
 <p>外键列</p> 
 <p>constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)</p> 
 <p>);</p> 
 <p>删除外键</p> 
 <p>ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</p> 
 <p>创建表之后，添加外键</p> 
 <p>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);</p> 
 <p>级联操作</p> 
 <p>添加级联操作 - 修改外键所在表的主键会同步更新</p> 
 <p>语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称</p> 
 <p>FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ;</p> 
 <p>--删除外键所在表的一条记录，当前表相应的外键所在记录同步删除(危险)</p> 
 <p>语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称</p> 
 <p>FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE;</p> 
 <p>分类：</p> 
 <p>级联更新：ON UPDATE CASCADE</p> 
 <p>级联删除：ON DELETE CASCADE</p> 
 <p>DML：增删改表中数据</p> 
 <p>添加数据：</p> 
 <p>语法：</p> 
 <p>insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n),(...);</p> 
 <p>注意：</p> 
 <p>列名和值要一一对应。</p> 
 <p>如果表名后，不定义列名，则默认给所有列添加值</p> 
 <p>insert into 表名 values(值1,值2,...值n);</p> 
 <p>除了数字类型，其他类型需要使用引号(单双都可以)引起来</p> 
 <p>删除数据：</p> 
 <p>语法：</p> 
 <p>delete from 表名 [where 条件]</p> 
 <p>注意：</p> 
 <p>如果不加条件，则删除表中所有记录。</p> 
 <p>如果要删除所有记录</p> 
 <p>delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作</p> 
 <p>TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。</p> 
 <p>修改数据：</p> 
 <p>语法：</p> 
 <p>update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];</p> 
 <p>注意：</p> 
 <p>如果不加任何条件，则会将表中所有记录全部修改。</p> 
 <p>DQL：查询表中的记录</p> 
 <p>select * from 表名; -查询表中所有数据</p> 
 <p>语法：</p> 
 <p>select</p> 
 <p>字段列表，有几个显示几列</p> 
 <p>from</p> 
 <p>表名列表</p> 
 <p>where</p> 
 <p>条件列表</p> 
 <p>group by</p> 
 <p>分组字段</p> 
 <p>having</p> 
 <p>分组之后的条件</p> 
 <p>order by</p> 
 <p>排序</p> 
 <p>limit</p> 
 <p>分页限定</p> 
 <p>基础查询</p> 
 <p>多个字段的查询</p> 
 <p>select 字段名1，字段名2... from 表名；</p> 
 <p>注意：</p> 
 <p>如果查询所有字段，则可以使用*来替代字段列表。</p> 
 <p>去除重复(若有多个字段，保证多个字段的结果集完全一样)：</p> 
 <p>select distinct 字段 from 表名;</p> 
 <p>计算列</p> 
 <p>一般可以使用四则运算计算一些列的值。(一般只会进行数值型的计算)</p> 
 <p>ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null</p> 
 <p>表达式1：哪个字段需要判断是否为null</p> 
 <p>如果该字段为null后的替换值。</p> 
 <p>SELECT NAME,math,English,math+IFNULL(English,0) FROM student;</p> 
 <p>起别名：</p> 
 <p>as：as也可以省略</p> 
 <p>条件查询</p> 
 <p>where子句后跟条件</p> 
 <p>运算符</p> 
 <p>" &gt; " 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;</p> 
 <p>BETWEEN...AND 与 &amp;&amp;</p> 
 <p>IN( 集合) 与 OR</p> 
 <p>LIKE：模糊查询</p> 
 <p>占位符：</p> 
 <p>_:单个任意字符</p> 
 <p>%：多个任意字符</p> 
 <p>IS NULL</p> 
 <p>and 或 &amp;&amp;</p> 
 <p>or 或 ||</p> 
 <p>not 或 !</p> 
 <p>-- 查询年龄大于20岁</p> 
 <p>SELECT * FROM student WHERE age &gt; 20;</p> 
 <p>-- 查询年龄等于20岁</p> 
 <p>SELECT * FROM student WHERE age = 20;</p> 
 <p>-- 查询年龄不等于20岁</p> 
 <p>SELECT * FROM student WHERE age != 20;</p> 
 <p>SELECT * FROM student WHERE age &lt;&gt; 20;</p> 
 <p>-- 查询年龄大于等于20 小于等于30</p> 
 <p>SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30;</p> 
 <p>SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30;</p> 
 <p>SELECT * FROM student WHERE age BETWEEN 20 AND 30;</p> 
 <p>-- 查询年龄22岁，18岁，25岁的信息</p> 
 <p>SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25</p> 
 <p>SELECT * FROM student WHERE age IN (22,18,25);</p> 
 <p>-- 查询英语成绩为null</p> 
 <p>SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = (!=) 判断</p> 
 <p>SELECT * FROM student WHERE english IS NULL;</p> 
 <p>-- 查询英语成绩不为null</p> 
 <p>SELECT * FROM student WHERE english IS NOT NULL;</p> 
 <p>-- 查询姓马的有哪些？ like</p> 
 <p>SELECT * FROM student WHERE NAME LIKE '马%';</p> 
 <p>-- 查询姓名第二个字是化的人</p> 
 <p>SELECT * FROM student WHERE NAME LIKE "_化%";</p> 
 <p>-- 查询姓名是3个字的人</p> 
 <p>SELECT * FROM student WHERE NAME LIKE '___';</p> 
 <p>-- 查询姓名中包含德的人</p> 
 <p>SELECT * FROM student WHERE NAME LIKE '%德%';</p> 
 <p>排序查询</p> 
 <p>语法: order by 字句</p> 
 <p>格式：order by 排序字段1,字段2,... 排序方式1,排序2...</p> 
 <p>默认升序:ASC</p> 
 <p>SELECT NAME FROM student</p> 
 <p>ORDER BY age ASC;</p> 
 <p>降序 - DESC</p> 
 <p>练习，先按数学成绩排，若成绩相同，再按英语成绩</p> 
 <p>SELECT NAME FROM student</p> 
 <p>ORDER BY math ASC,English ASC;</p> 
 <p>聚合函数</p> 
 <p>理解：将一列数据作为一个整体，进行纵向(Y轴)的计算。</p> 
 <p>MySql中的聚合函数：</p> 
 <p>count：计算某字段数据个数，不包括NULL，实际为表中记录数</p> 
 <p>格式：Count(字段名)</p> 
 <p>SELECT COUNT(NAME) AS 人数</p> 
 <p>FROM student;</p> 
 <p>加上NULL的个数:1. 用非空字段主键 2.count(*) 3.如下</p> 
 <p>SELECT COUNT(IFNULL(NAME,0) AS 人数</p> 
 <p>FROM student;</p> 
 <p>max：计算最大</p> 
 <p>min：计算最小</p> 
 <p>avg：计算平均</p> 
 <p>分组查询</p> 
 <p>理解：把具有相同特征(字段)的一行(记录)当成整体来查询</p> 
 <p>语法：group by</p> 
 <p>注意；由于分组，select 后应为聚合函数或分组字段(by后的字段)否则没有任何意义。</p> 
 <p>练习：按照性别分组，分别查询男和女的人数，聚合函数的字段使用主确保非NULL</p> 
 <p>SELECT sex,COUNT(学号) AS 人数</p> 
 <p>FROM student</p> 
 <p>GROUP BY sex;</p> 
 <p>练习：选择满足条件的记录参与分组，由字段进行筛选,如下查询姓王男的人数和女的人数</p> 
 <p>SELECT sex,COUNT(学号) AS 人数</p> 
 <p>FROM student</p> 
 <p>WHERE name = "王"</p> 
 <p>GROUP BY sex;</p> 
 <p>HAVING练习：分别查询男和女分数在平均分以上的人数，且只显示人数于2的那一类</p> 
 <p>SELECT sex,COUNT(id) AS 人数</p> 
 <p>FROM student</p> 
 <p>WHERE score &gt;(</p> 
 <p>SELECT AVG(score)</p> 
 <p>FROM student</p> 
 <p>)</p> 
 <p>GROUP BY sex HAVING COUNT(id) &gt; 2;</p> 
 <p>分页查询</p> 
 <p>语法：limit 开始的索引，每页查询的条数</p> 
 <p>练习：显示第一页，每页显示三条</p> 
 <p>SELECT * FROM student LIMIT 0,3;</p> 
 <p>索引位置=(当前页数码-1)*显示条数</p> 
 <p>显示第1，2，3条记录，3为显示条数</p> 
 <p>分页操作在不同语言中操作方式不一样</p> 
 <p>多表查询</p> 
 <p>select * from 表1,表2; -查询出来的为笛卡尔积，有冗余</p> 
 <p>内连接查询</p> 
 <p>隐式内连接：使用where条件消除无用数据</p> 
 <p>例子：</p> 
 <p>-- 查询所有员工信息和对应的部门信息</p> 
 <p>SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;</p> 
 <p>-- 查询员工表的名称，性别。部门表的名称</p> 
 <p>SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;</p> 
 <p>-- 用别名</p> 
 <p>SELECT</p> 
 <p>t1.name, -- 员工表的姓名</p> 
 <p>t1.gender,-- 员工表的性别</p> 
 <p>t2.name -- 部门表的名称</p> 
 <p>FROM</p> 
 <p>emp t1, -- 别名t1</p> 
 <p>dept t2t1 -- 别名t2</p> 
 <p>WHERE</p> 
 <p>t1.`dept_id` = t2.`id`;</p> 
 <p>显式内连接：</p> 
 <p>语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件</p> 
 <p>例如：</p> 
 <p>SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;</p> 
 <p>SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;</p> 
 <p>外链接查询：</p> 
 <p>左外连接：</p> 
 <p>语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；</p> 
 <p>查询的是左表所有数据以及其交集部分(On后边的条件，含null，隐式内连接查询不显示链接为null的数据)。</p> 
 <p>例子：-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称</p> 
 <p>SELECT t1.*,t2.`name`</p> 
 <p>FROM emp t1 LEFT JOIN</p> 
 <p>dept t2 ON t1.`dept_id` = t2.`id`;</p> 
 <p>-- 其中t1为左表，t2为右表</p> 
 <p>右外连接：</p> 
 <p>语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；</p> 
 <p>查询的是右表所有数据以及其交集部分。</p> 
 <p>例子：</p> 
 <p>SELECT *</p> 
 <p>FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`;</p> 
 <p>子查询：</p> 
 <p>概念：查询中嵌套查询，称嵌套查询为子查询。</p> 
 <p>-- 查询工资最高的员工信息</p> 
 <p>-- 1 查询最高的工资是多少 9000</p> 
 <p>SELECT MAX(salary) FROM emp;</p> 
 <p>-- 2 查询员工信息，并且工资等于9000的</p> 
 <p>SELECT * FROM emp WHERE emp.`salary` = 9000;</p> 
 <p>-- 一条sql就完成这个操作。子查询</p> 
 <p>SELECT * FROM emp WHERE emp.`salary` = (SELECT MA(salary) FROM emp);</p> 
 <p>子查询不同情况</p> 
 <p>子查询的结果是单行单列的：</p> 
 <p>子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =</p> 
 <p>-- 查询员工工资小于平均工资的人</p> 
 <p>SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);</p> 
 <p>子查询的结果是多行单列的：</p> 
 <p>子查询可以作为条件，使用运算符in来判断</p> 
 <p>-- 查询'财务部'和'市场部'所有的员工信息</p> 
 <p>SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部';</p> 
 <p>SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;</p> 
 <p>-- 子查询</p> 
 <p>SELECT *</p> 
 <p>FROM emp</p> 
 <p>WHERE dept_id IN</p> 
 <p>(SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部');</p> 
 <p>子查询的结果是多行多列的：</p> 
 <p>子查询可以作为一张虚拟表参与查询</p> 
 <p>-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息</p> 
 <p>-- 子查询</p> 
 <p>SELECT *</p> 
 <p>FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; '2011-11-11') t2</p> 
 <p>WHERE t1.id = t2.dept_id;</p> 
 <p>-- 普通内连接</p> 
 <p>SELECT * FROM emp t1,dept t2</p> 
 <p>WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt; '2011-11-11'</p> 
 <p>DCL：用户权限管理</p> 
 <p>DCL：管理用户，授权，一般由DBA来完成</p> 
 <p>管理用户</p> 
 <p>添加用户：</p> 
 <p>语法：CREATE USER '用户名'@'主机名(若为%，网络上的任意主机都可以访问)' IDENTIFIED BY '密码';</p> 
 <p>删除用户：</p> 
 <p>语法：DROP USER '用户名'@'主机名';</p> 
 <p>修改用户密码：</p> 
 <p>-- 第一种</p> 
 <p>UPDATE USER SET PASSWORD = PASSWORD('新密码') WHERE USER = '用户名';</p> 
 <p>UPDATE USER SET PASSWORD = PASSWORD('abc') WHERE USER = 'lisi';</p> 
 <p>-- 第二种</p> 
 <p>SET PASSWORD FOR '用户名'@'主机名' = PASSWORD('新密码');</p> 
 <p>SET PASSWORD FOR 'root'@'localhost' = PASSWORD('123');</p> 
 <p>mysql中忘记了root用户的密码：</p> 
 <p>cmd -- &gt; net stop mysql 停止mysql服务</p> 
 <p>需要以管理员身份运行该cmd</p> 
 <p>使用无验证方式启动mysql服务： mysqld --skip-grant-tables</p> 
 <p>打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功</p> 
 <p>use mysql;</p> 
 <p>update user set password = password('你的新密码') where user = 'root';</p> 
 <p>关闭两个窗口</p> 
 <p>打开任务管理器，手动结束mysqld.exe 的进程</p> 
 <p>启动mysql服务：net start mysql</p> 
 <p>使用新密码登录。</p> 
 <p>查询用户：</p> 
 <p>-- 1. 切换到mysql数据库</p> 
 <p>USE myql;</p> 
 <p>-- 2. 查询user表</p> 
 <p>SELECT * FROM USER;</p> 
 <p>通配符： % 表示可以在任意主机使用用户登录数据库</p> 
 <p>权限管理：</p> 
 <p>查询权限：</p> 
 <p>-- 查询权限</p> 
 <p>SHOW GRANTS FOR '用户名'@'主机名';</p> 
 <p>SHOW GRANTS FOR 'lisi'@'%';</p> 
 <p>授予权限：</p> 
 <p>-- 授予权限,权限列表有SELECT，DELETE，UPDATE</p> 
 <p>grant 权限列表 on 数据库名.表名 to '用户名'@'主机名';</p> 
 <p>-- 若授予所有权限，则为ALL</p> 
 <p>-- 给张三用户授予所有权限，在任意数据库任意表(*.*)上</p> 
 <p>GRANT ALL ON *.* TO 'zhangsan'@'localhost';</p> 
 <p>撤销权限：</p> 
 <p>-- 撤销权限：</p> 
 <p>revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名';</p> 
 <p>-- 撤销修改权限</p> 
 <p>REVOKE UPDATE ON db3.`account` FROM 'lisi'@'%';</p> 
 <p>事务</p> 
 <p>事务的基本介绍</p> 
 <p>概念：</p> 
 <p>如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。</p> 
 <p>操作：</p> 
 <p>开启事务： start transaction;</p> 
 <p>回滚：rollback;</p> 
 <p>提交：commit;</p> 
 <p>例子：资金转账</p> 
 <p>-- 创建一张账户表</p> 
 <p>CREATE TABLE account (</p> 
 <p>id INT PRIMARY KEY AUTO_INCREMENT,</p> 
 <p>NAME VARCHAR(10),</p> 
 <p>balance DOUBLE</p> 
 <p>);</p> 
 <p>-- 添加数据</p> 
 <p>INSERT INTO account (NAME, balance) VALUES ('zhangsan', 1000), ('lisi', 1000);</p> 
 <p>-- 张三给李四转账 500 元</p> 
 <p>-- 0. 开启事务</p> 
 <p>START TRANSACTION;</p> 
 <p>-- 1. 张三账户 -500</p> 
 <p>UPDATE account SET balance = balance - 500 WHERE NAME = 'zhangsan';</p> 
 <p>-- 2. 李四账户 +500</p> 
 <p>-- 若在这出错了...会回滚</p> 
 <p>UPDATE account SET balance = balance + 500 WHERE NAME = 'lisi';</p> 
 <p>-- 发现执行没有问题，提交事务，若没有提交事务会自动回滚</p> 
 <p>COMMIT;</p> 
 <p>-- 发现出问题了，回滚事务</p> 
 <p>ROLLBACK;</p> 
 <p>MySQL数据库中事务默认自动提交</p> 
 <p>事务提交的两种方式：</p> 
 <p>自动提交：</p> 
 <p>mysql就是自动提交的，不开启事务自动提交</p> 
 <p>一条DML(增删改)语句会自动提交一次事务。</p> 
 <p>手动提交：</p> 
 <p>需要先开启事务，再提交(commit)</p> 
 <p>Oracle 数据库默认是手动提交事务</p> 
 <p>修改事务的默认提交方式：</p> 
 <p>查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交 0 代表手动提交</p> 
 <p>修改默认提交方式： set @@autocommit = 0;</p> 
 <p>事务的四大特征：</p> 
 <p>原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。</p> 
 <p>持久性：当事务提交或回滚后，数据库会持久化的保存数据。</p> 
 <p>隔离性：多个事务之间。相互独立。</p> 
 <p>一致性：事务操作前后，数据总量(例如总金额)不变</p> 
 <p>事务的隔离级别</p> 
 <p>概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。</p> 
 <p>存在问题：</p> 
 <p>脏读：一个事务，读取到另一个事务中没有提交的数据</p> 
 <p>不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。</p> 
 <p>幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。</p> 
 <p>隔离级别：</p> 
 <p>read uncommitted：读未提交</p> 
 <p>产生的问题：脏读、不可重复读、幻读</p> 
 <p>read committed：读已提交 (Oracle)</p> 
 <p>产生的问题：不可重复读、幻读</p> 
 <p>repeatable read：可重复读 (MySQL默认)</p> 
 <p>产生的问题：幻读</p> 
 <p>serializable：串行化(锁表，另一个事务查询表的时候会等待，只有正在使用表的事务提交以后，另一个事务的查询才会被执行)</p> 
 <p>可以解决所有的问题</p> 
 <p>注意：隔离级别从小到大安全性越来越高，但是效率越来越低</p> 
 <p>数据库查询隔离级别：</p> 
 <p>select @@tx_isolation;</p> 
 <p>数据库设置隔离级别：</p> 
 <p>set global transaction isolation level 级别字符串;</p> 
 <p>演示：</p> 
 <p>-- 设置隔离级别</p> 
 <p>set global transaction isolation level read uncommitted;</p> 
 <p>-- 打开两个窗口开启事务，第一个窗口update修改数据，另一个窗口查询读到未提交(commit)的数据(数据改变)，出现脏读</p> 
 <p>-- 然后再第一个事务rollback(转账撤销)，另一个窗口再查询发现数据还原，即不可重复度问题</p> 
 <p>-- 解决脏读方案：</p> 
 <p>set global transaction isolation level read committed;</p> 
 <p>-- 第一个窗口修改了数据，第二个窗口查询发现数据没有改变</p> 
 <p>-- 此时第一个窗口commit，第二个窗口查询发现数据改变，同一个事务查询的数据不一样出现不可重复读问题</p> 
 <p>-- 解决脏读和不可重复读问题</p> 
 <p>set global transaction isolation level repeatable read;</p> 
 <p>-- 第一个窗口的事务提交改变，不影响第二个窗口事务的数据查询，只有在第二个窗口也提交事务后，方可正确查询数据</p> 
 <p>-- 开启事务</p> 
 <p>start transaction;</p> 
 <p>-- 转账操作</p> 
 <p>update account set balance = balance - 500 where id = 1;</p> 
 <p>update account set balance = balance + 500 where id = 2;</p> 
 <p>数据库的设计</p> 
 <p>多表之间的关系</p> 
 <p>分类：</p> 
 <p>一对一(了解)：</p> 
 <p>如：人和身份证</p> 
 <p>分析：一个人只有一个身份证，一个身份证只能对应一个人</p> 
 <p>一对多(多对一)：</p> 
 <p>如：部门和员工</p> 
 <p>分析：一个部门有多个员工，一个员工只能对应一个部门</p> 
 <p>多对多：</p> 
 <p>如：学生和课程</p> 
 <p>分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择</p> 
 <p>实现关系：</p> 
 <p>一对多(多对一)：</p> 
 <p>如：部门和员工</p> 
 <p>实现方式：在多的一方建立外键，指向一的一方的主键。</p> 
 <p>多对多：</p> 
 <p>如：学生和课程</p> 
 <p>实现方式：多对多关系实现需要借助第三张中间表。表至少包含两个字段，这两个字段作为第三张表的外键别指向两张表的主键</p> 
 <p>一对一(很少用)：</p> 
 <p>如：人和身份证</p> 
 <p>实现方式：一对一关系实现，可以在任意一方添加外键指向另一方的主键，外键需要约束为UNIQUE</p> 
 <p>案例</p> 
 <p align="center"><img src="https://images2.imgbox.com/3c/8c/qya7feol_o.png" alt="5cc21c73f7eb358db3768c6a936d01d4.png"></p> 
 <p align="center"><img src="https://images2.imgbox.com/1f/cb/gn96xMuB_o.png" alt="ed47c68960f543639d831efe6cad323f.png"></p> 
 <p>-- 创建旅游线路分类表 tab_category</p> 
 <p>-- cid 旅游线路分类主键，自动增长</p> 
 <p>-- cname 旅游线路分类名称非空，唯一，字符串 100</p> 
 <p>CREATE TABLE tab_category (</p> 
 <p>cid INT PRIMARY KEY AUTO_INCREMENT,</p> 
 <p>cname VARCHAR(100) NOT NULL UNIQUE</p> 
 <p>);</p> 
 <p>-- 创建旅游线路表 tab_route</p> 
 <p>/*</p> 
 <p>rid 旅游线路主键，自动增长</p> 
 <p>rname 旅游线路名称非空，唯一，字符串 100</p> 
 <p>price 价格</p> 
 <p>rdate 上架时间，日期类型</p> 
 <p>cid 外键，所属分类</p> 
 <p>*/</p> 
 <p>CREATE TABLE tab_route(</p> 
 <p>rid INT PRIMARY KEY AUTO_INCREMENT,</p> 
 <p>rname VARCHAR(100) NOT NULL UNIQUE,</p> 
 <p>price DOUBLE,</p> 
 <p>rdate DATE,</p> 
 <p>cid INT,</p> 
 <p>FOREIGN KEY (cid) REFERENCES tab_category(cid)</p> 
 <p>);</p> 
 <p>/*创建用户表 tab_user</p> 
 <p>uid 用户主键，自增长</p> 
 <p>username 用户名长度 100，唯一，非空</p> 
 <p>password 密码长度 30，非空</p> 
 <p>name 真实姓名长度 100</p> 
 <p>birthday 生日</p> 
 <p>sex 性别，定长字符串 1</p> 
 <p>telephone 手机号，字符串 11</p> 
 <p>email 邮箱，字符串长度 100</p> 
 <p>*/</p> 
 <p>CREATE TABLE tab_user (</p> 
 <p>uid INT PRIMARY KEY AUTO_INCREMENT,</p> 
 <p>username VARCHAR(100) UNIQUE NOT NULL,</p> 
 <p>PASSWORD VARCHAR(30) NOT NULL,</p> 
 <p>NAME VARCHAR(100),</p> 
 <p>birthday DATE,</p> 
 <p>sex CHAR(1) DEFAULT '男',</p> 
 <p>telephone VARCHAR(11),</p> 
 <p>email VARCHAR(100)</p> 
 <p>);</p> 
 <p>/*</p> 
 <p>创建收藏表 tab_favorite</p> 
 <p>rid 旅游线路 id，外键</p> 
 <p>date 收藏时间</p> 
 <p>uid 用户 id，外键</p> 
 <p>rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏个线路两次</p> 
 <p>*/</p> 
 <p>CREATE TABLE tab_favorite (</p> 
 <p>rid INT, -- 线路id</p> 
 <p>DATE DATETIME,</p> 
 <p>uid INT, -- 用户id</p> 
 <p>-- 创建复合主键</p> 
 <p>PRIMARY KEY(rid,uid), -- 联合主键</p> 
 <p>FOREIGN KEY (rid) REFERENCES tab_route(rid),</p> 
 <p>FOREIGN KEY(uid) REFERENCES tab_user(uid)</p> 
 <p>);</p> 
 <p>数据库设计的范式</p> 
 <p>概念：</p> 
 <p>设计数据库时，需要遵循的一些规范。要遵循后边的范式求，必须先遵循前边的所有范式要求。</p> 
 <p>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式据库冗余越小。</p> 
 <p>目前关系数据库有六种范式：第一范式(1NF)、第二范式(2NF)、第三式(3NF)、巴斯-科德范式(BCNF)、第四范式(4NF)和第五范式(5NF又称完美范式)。</p> 
 <p>分类：</p> 
 <p>第一范式(1NF)：每一列都是不可分割的原子数据项</p> 
 <p>第二范式(2NF)：在1NF的基础上，非码属性必须完全依赖于码(1NF基础上消除非主属性对主码的部分函数依赖)</p> 
 <p>几个概念：</p> 
 <p>函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A</p> 
 <p>例如：学号--&gt;姓名。 (学号，课程名称) --&gt; 分数</p> 
 <p>完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中“所有”的属性值。</p> 
 <p>例如：(学号，课程名称) --&gt; 分数</p> 
 <p>部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中“某一些值”即可。</p> 
 <p>例如：(学号，课程名称) -- &gt; 姓名</p> 
 <p>学号就可以决定姓名</p> 
 <p>传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性(属性组)的值可以确定唯一C属性的值，则称 C 传递函数依赖于A</p> 
 <p>例如：学号--&gt;系名，系名--&gt;系主任</p> 
 <p>码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码</p> 
 <p>例如：该表中码为：(学号，课程名称)</p> 
 <p>主属性：码属性组中的所有属性</p> 
 <p>非主属性：除过码属性组的属性</p> 
 <p>第三范式(3NF)：在2NF基础上，任何非主属性不依赖于其它非主属(在2NF基础上消除传递依赖)</p> 
 <p>具体实现如下</p> 
 <p>元数据</p> 
 <p align="center"><img src="https://images2.imgbox.com/34/99/ZNpWORF5_o.png" alt="96641f2a4631ccdb68f008453ffafd07.png"></p> 
 <p>经1NF规范后 -保证了原子性</p> 
 <p align="center"><img src="https://images2.imgbox.com/97/21/nZ5X5t7D_o.png" alt="2d940533a1cc159b150602c55ca845ac.png"></p> 
 <p>经2NF规范后 -消除部分依赖(拆分表)</p> 
 <p>此处主属性为(学号，课程名称)</p> 
 <p>规范后删除了冗余数据</p> 
 <p align="center"><img src="https://images2.imgbox.com/cb/f6/iijFHTDW_o.png" alt="bf7f3704b7df5b691a96338ac609ad46.png"></p> 
 <p>经3NF规范后 -消除传递依赖(继续拆分)</p> 
 <p align="center"><img src="https://images2.imgbox.com/d2/ba/6ZPPC2T0_o.png" alt="d4f8b40693ed493f7b52008dec527e72.png"></p> 
 <p>数据库的备份和还原 - 一般由DBA来完成</p> 
 <p>命令行操作</p> 
 <p>语法：</p> 
 <p>备份格式： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径</p> 
 <p>还原：</p> 
 <p>登录数据库 - mysql -uroot -p密码</p> 
 <p>创建数据库 - create database 数据库名称;</p> 
 <p>使用数据库 - use 数据库名称;</p> 
 <p>执行文件。</p> 
 <p>语法格式：source 文件路径</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/be54ffa6efe68b2785299304ba30b264/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysql服务器端按照显示无权限安装_mysql数据库安装、启动及权限设置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/af05454fe2908b64ed49856611a41f06/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql xa 实现_MySQL 中基于 XA 实现的分布式事务</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>