<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HTTP网络相关知识 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HTTP网络相关知识" />
<meta property="og:description" content="@1 第一步：
URI(统一资源标识符)= URL（统一资源定位符）&#43;URN（统一资源名称）；
@2 传输协议：
HTTP: 超文本传输协议
HTTPS: HTTP &#43; SSL（加密证书）相对于http传输会更加安全
FTP: 文件的传输 上传工具 资源共享 域名：域名是外网IP一个标识，相对于IP来说牢记比较困难，域名会更加便捷。
端口号：0-65535，每个端口号对应统一服务器 中不用的项目，默认http:80, https:443.
编码问题，如果url对应参数存在中文特殊字符等，传递的时候会解析出错，这时候需要编码
encodeURL / decodeURL ; (适合解析url所有的)， encodeURLComponent / decodeURLComponent ; 适合解析url特殊字符中的
@3 强缓存与协商缓存
强缓存：
http/1.1 Cache-Control max-age = 259200 http/1.0 Exprices Sun, 15 May 2022 20:14:22 存在问题， 如果本地有缓存， 然而服务器更新了资源如何保障客户端获取最新的？
这个时候我们可以把 css js 最缓存，但是不能对 html 页面 做缓存。因为html页面是渲染的入
口，其他资源在渲染解析HTML的时候再去请求的。
协商缓存: 哪怕本地有缓存也要和服务器进行协商
第一次请求页面，本地没有缓存，向服务器发送请求，如果需要设置协商缓存，在响应头返
回相对应的字段。【last-modified 记录资源最后一次更新的时候】【Etag 记录资源最后一次
更新的标识】，客户端浏览器看到标识，会把标识和资源全部做缓存。
第二次向服务器发送请求的时候也是会重新发送的，会把协商缓存存储的标识和资源通过
【if-modified-since/if-None-math】传递给服务器，服务器如果返回的304则说明资源没有更
新，从本地缓存中获取就可以了。 如果资源更新了，则返回200，使用服务器新的资源，同
时把最新的资源缓存起来。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/de572f5390d25d01a9de7d230e15d603/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-05T14:24:47+08:00" />
<meta property="article:modified_time" content="2024-01-05T14:24:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HTTP网络相关知识</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>@1 第一步：<br>         URI(统一资源标识符)= URL（统一资源定位符）+URN（统一资源名称）；<br> @2 传输协议：<br>         HTTP: 超文本传输协议<br>         HTTPS: HTTP + SSL（加密证书）相对于http传输会更加安全<br>         FTP: 文件的传输 上传工具 资源共享 <br>         域名：域名是外网IP一个标识，相对于IP来说牢记比较困难，域名会更加便捷。<br>         端口号：0-65535，每个端口号对应统一服务器 中不用的项目，默认http:80, https:443.<br>         编码问题，如果url对应参数存在中文特殊字符等，传递的时候会解析出错，这时候需要编码<br>         encodeURL / decodeURL ; (适合解析url所有的)， <br>         encodeURLComponent / decodeURLComponent ;  适合解析url特殊字符中的</p> 
<p> @3 强缓存与协商缓存<br>         强缓存：<br>         http/1.1 Cache-Control  max-age = 259200 <br>         http/1.0 Exprices  Sun, 15 May 2022 20:14:22 <br>         存在问题， 如果本地有缓存， 然而服务器更新了资源如何保障客户端获取最新的？<br>         这个时候我们可以把 css js 最缓存，但是不能对 html 页面 做缓存。因为html页面是渲染的入<br>         口，其他资源在渲染解析HTML的时候再去请求的。<br>         协商缓存: 哪怕本地有缓存也要和服务器进行协商<br>         第一次请求页面，本地没有缓存，向服务器发送请求，如果需要设置协商缓存，在响应头返<br>         回相对应的字段。【last-modified 记录资源最后一次更新的时候】【Etag 记录资源最后一次<br>         更新的标识】，客户端浏览器看到标识，会把标识和资源全部做缓存。<br>         第二次向服务器发送请求的时候也是会重新发送的，会把协商缓存存储的标识和资源通过<br>         【if-modified-since/if-None-math】传递给服务器，服务器如果返回的304则说明资源没有更<br>         新，从本地缓存中获取就可以了。 如果资源更新了，则返回200，使用服务器新的资源，同<br>         时把最新的资源缓存起来。<br>         真实项目开发中，建议HTML页面采用协商缓存，其他界面采用协商和强缓存。</p> 
<p>@4 数据缓存：前端开发者对于不常更新的数据做本地缓存。<br>         本地缓存分类：<br>         1 localStorage: 持久化存储，内存5M，默认和服务器没有关系。手动设置有效期。<br>         2 cookie：具有时间性，存储内存4KB, 如果不跨越的情况下，每次请求会自动把cookie携带<br>         给服务器，造成请求慢<br>         3 sessionStorage：浏览器关闭或者页面刷新 缓存清除。<br><br> @5 DNS域名解析：<br>         浏览器输入URL地址之后，会去DNS服务器寻找对于的外网ip，找到服务器。<br>         DNS解析也会有缓存【谷歌浏览器缓存在1min】<br>         前端优化： 尽可能减少DNS解析的次数（也就是所有的资源 部署到相同的服务器）<br>         真实项目中：不会部署到同一服务器中，【web服务器 图片服务器 数据服务器】<br>         解决方法、DNS预解析，利用&lt;link&gt;&lt;/link&gt;的异步性。在GUI渲染的过程中 同时解析域名。<br><br> @6 TCP三次握手【客户端与服务器建立一个稳定的传输通道】<br>         TCP:稳定可靠，经过三次握手确定传输稳定性 消耗时间久 常规业务都用他。<br>         UDP:快速传递，省略三次握手，存在丢包的情况。<br><br> @7 数据传输：<br>         http请求报文：请求体 请求起始行 请求主体<br>         http响应报文：响应头 响应起始行 响应主体<br><br> @8 TCP的四次挥手，【断开用户端和服务器的链接】<br>         http1.1版本默认开启了Connection:keep-alive长链接，当前请求数据传输完成后不会断开链<br>         接，下次请求会基于这个传输通道继续，减少了tcp三次握手，四次挥手的问题。<br><br> @9  性能优化总结:<br>         1 利用缓存： 协商缓存 强缓存  本地存储<br>         2 DNS优化： 分服务部署，采用DNS预解析<br>         3 Tcp三握四挥，采用Conenction:keep-alive <br>         4 数据传输： 服务器开启GZIP压缩，大数据分批次请求，减少HTTP请求次数 CDN采用分布<br>         式, 骨架屏 图片延迟加载 <br>         <br>         <br>         </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c595c02744f58a03047dc83593caec2e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【React系列】ES6学习笔记（四）module、编程风格</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/80b8f755519e00989319153a04027466/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python爬取天气数据及可视化分析！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>