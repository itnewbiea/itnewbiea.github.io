<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>中文NER方法总结 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="中文NER方法总结" />
<meta property="og:description" content="中文NER方法总结 ​ 中文命名实体识别主要有四大主流算法，序列标注，指针网络，多头标注，片段排列。
1. 四大抽取算法 1.1 序列标注 ​ 最简单的softmax&#43;CE的方法，是一种token级别的分类任务。这种方法最简单，但没有考虑到标签之间的关系。仅仅在特征提取时，上后文是有联系的，每个时刻分类时，互不相关，这样就会出现很不合理的预测，如BB等。
在每一个位置使用softmax进行 2 C &#43; 1 2C&#43;1 2C&#43;1分类（如果使用BIO标注格式的话，C为类别总数）。
​ 基于CRF的模型在softmax&#43;CE上做改进，预测时会考虑标签之间的联系。CRF也存在局限性，序列标注表示为线性链的条件随机场。仅仅假设相邻的两个节点存在联系，不相邻节点时条件无关的（也就是马尔科夫随机场定义中的局部/全局的马尔科夫性）。在前端网络考虑各时刻token的关联性，在crf考虑标签的关联性，两部分分开。
1.2 指针网络 对每个span的start和end进行标记，如果是多片段抽取就转化成L个2分类（L为序列长度）。如果涉及多标签可以转化成层叠式指针网络（C个指针网络，C为类别总数）。
单片段抽取 如果每个输入只有一个片段需要抽取，只需要设计两个L分类的输出分别预测start_ids和end_ids。将每个位置看做一个类别。使用softmax 搭建两个L分类。
多片段抽取-sigmoid 如果一句话有多个片段需要抽取（同样的每个位置看做是一个类别），那么start和end都要分得多个标签上，也就是多任务分类。将softmax改为sigmoid即可。序列的每个位置都做0-1二分类。
多标签抽取 上面的情形都是只有一种标签需要抽取，如上面的部位，如果同时需要抽取多个标签，则需要在序列每个token位置做 C &#43; 1 C&#43;1 C&#43;1分类（C表示总类别数）。
1.3 多头标注 多头标注(multi-head)构建一个 L × L × ( C &#43; 1 ) L\times L\times (C&#43;1) L×L×(C&#43;1)的span矩阵(C类外加None)。如下图， s p a n { 呼 } { 枢 } = 1 span\{呼\}\{枢\}=1 span{呼}{枢}=1表示[呼吸中枢]是一个部位实体。 s p a n { 呼 } { 累 } = 2 span\{呼\}\{累\}=2 span{呼}{累}=2表示[呼吸中枢受累]是一个症状实体。多头标注的重点在于如何构造span矩阵，如何解决0-1标签稀疏问题。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c8ab31075ac969b23716e67fedc56314/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-02T19:17:46+08:00" />
<meta property="article:modified_time" content="2023-08-02T19:17:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">中文NER方法总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="NER_0"></a>中文NER方法总结</h2> 
<p>​ 中文命名实体识别主要有四大主流算法，序列标注，指针网络，多头标注，片段排列。</p> 
<h3><a id="1__4"></a>1. 四大抽取算法</h3> 
<h4><a id="11__6"></a>1.1 序列标注</h4> 
<p>​ 最简单的softmax+CE的方法，是一种token级别的分类任务。这种方法最简单，但没有考虑到标签之间的关系。仅仅在特征提取时，上后文是有联系的，每个时刻分类时，互不相关，这样就会出现很不合理的预测，如BB等。</p> 
<p><img src="https://images2.imgbox.com/22/c3/zV5MldID_o.png" alt="在这里插入图片描述"></p> 
<p>在每一个位置使用softmax进行<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
         C 
        
       
         + 
        
       
         1 
        
       
      
        2C+1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>分类（如果使用BIO标注格式的话，C为类别总数）。</p> 
<p>​ 基于CRF的模型在softmax+CE上做改进，预测时会考虑标签之间的联系。CRF也存在局限性，序列标注表示为线性链的条件随机场。仅仅假设相邻的两个节点存在联系，不相邻节点时条件无关的（也就是马尔科夫随机场定义中的局部/全局的马尔科夫性）。在前端网络考虑各时刻token的关联性，在crf考虑标签的关联性，两部分分开。</p> 
<h4><a id="12__17"></a>1.2 指针网络</h4> 
<p>对每个span的start和end进行标记，如果是多片段抽取就转化成L个2分类（L为序列长度）。如果涉及多标签可以转化成层叠式指针网络（C个指针网络，C为类别总数）。</p> 
<h5><a id="_21"></a>单片段抽取</h5> 
<p>如果每个输入只有一个片段需要抽取，只需要设计两个L分类的输出分别预测start_ids和end_ids。将每个位置看做一个类别。使用softmax 搭建两个L分类。</p> 
<p><img src="https://images2.imgbox.com/84/5f/yesuddkL_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="sigmoid_28"></a>多片段抽取-sigmoid</h5> 
<p>如果一句话有多个片段需要抽取（同样的每个位置看做是一个类别），那么start和end都要分得多个标签上，也就是多任务分类。将softmax改为sigmoid即可。序列的每个位置都做0-1二分类。<br> <img src="https://images2.imgbox.com/4d/36/barWXJjm_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_33"></a>多标签抽取</h5> 
<p>上面的情形都是只有一种标签需要抽取，如上面的部位，如果同时需要抽取多个标签，则需要在序列每个token位置做<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         C 
        
       
         + 
        
       
         1 
        
       
      
        C+1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>分类（C表示总类别数）。<br> <img src="https://images2.imgbox.com/75/05/q89hazvc_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="13___39"></a>1.3 多头标注</h4> 
<p>多头标注(multi-head)构建一个<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         L 
        
       
         × 
        
       
         L 
        
       
         × 
        
       
         ( 
        
       
         C 
        
       
         + 
        
       
         1 
        
       
         ) 
        
       
      
        L\times L\times (C+1) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>的span矩阵(C类外加None)。如下图，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
         p 
        
       
         a 
        
       
         n 
        
       
         { 
        
       
         呼 
        
       
         } 
        
       
         { 
        
       
         枢 
        
       
         } 
        
       
         = 
        
       
         1 
        
       
      
        span\{呼\}\{枢\}=1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal">an</span><span class="mopen">{<!-- --></span><span class="mord cjk_fallback">呼</span><span class="mclose">}</span><span class="mopen">{<!-- --></span><span class="mord cjk_fallback">枢</span><span class="mclose">}</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>表示[呼吸中枢]是一个部位实体。<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
         p 
        
       
         a 
        
       
         n 
        
       
         { 
        
       
         呼 
        
       
         } 
        
       
         { 
        
       
         累 
        
       
         } 
        
       
         = 
        
       
         2 
        
       
      
        span\{呼\}\{累\}=2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal">an</span><span class="mopen">{<!-- --></span><span class="mord cjk_fallback">呼</span><span class="mclose">}</span><span class="mopen">{<!-- --></span><span class="mord cjk_fallback">累</span><span class="mclose">}</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span></span></span></span>表示[呼吸中枢受累]是一个症状实体。多头标注的重点在于<strong>如何构造span矩阵</strong>，如何<strong>解决0-1标签稀疏问题</strong>。</p> 
<p><img src="https://images2.imgbox.com/ad/5a/BrvBgjEb_o.png" alt="在这里插入图片描述"></p> 
<p>ACL2020的《Named Entity Recognition as Dependency Parsing》采取Biaffine机制构造Span矩阵；</p> 
<h4><a id="14__47"></a>1.4 片段排列</h4> 
<p>简单粗暴的枚举法，枚举所有可能，并对每种可能进行分类。对有长度为L的序列。共有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         L 
        
       
         ( 
        
       
         L 
        
       
         + 
        
       
         1 
        
       
         ) 
        
       
         / 
        
       
         2 
        
       
      
        L(L+1)/2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span></span>种片段排列。分别对每一个片段进行分类。</p> 
<p><img src="https://images2.imgbox.com/9e/ba/5NiAapqL_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_Nested_NER_54"></a>2. Nested NER</h3> 
<p>实体嵌套是NER要解决的一大难题。多头标注和片段排列的方法天然的就支持嵌套实体的抽取，序列标注和span的方法做微小调整后也可以实现嵌套实体抽取。</p> 
<h4><a id="21___58"></a>2.1 序列标注-多标签分类</h4> 
<p>序列标注是对序列每个token位置进行多分类预测。只需要将多分类改为多标签分类即可。</p> 
<p><img src="https://images2.imgbox.com/c2/50/OH92O8nY_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="22__65"></a>2.2 指针网络</h4> 
<h5><a id="_67"></a>层叠式指针网络</h5> 
<p><img src="https://images2.imgbox.com/fb/3a/Ryqq5CC2_o.png" alt="在这里插入图片描述"></p> 
<p>层叠式指针网络即C个针织网络。每个预测一个类别。</p> 
<h5><a id="MRCQA_74"></a>MRC-QA+指针标注</h5> 
<p><img src="https://images2.imgbox.com/19/81/JNAIDJvi_o.png" alt="在这里插入图片描述"></p> 
<p>使用MRC阅读理解的方式进行抽取，构造每个实体的解释作为该类实体的query，需要抽取的原始文本作为passage上下文。预测该实体在passage中的位置。</p> 
<pre><code>"ORG":"找出公司，商业机构，社会组织等组织机构",
"LOC":"找出国家，城市，山川等抽象或具体的地点",
"PER":"找出真实和虚构的人名"
</code></pre> 
<p>1、相较于序列标注的方法，MRC的好处在于引入了query这个先验知识。比如对于LOC类别，我们构造这样的query：找出国家，城市，山川等抽象或具体的地点。模型通过attention机制，对于query中的国家，城市，山川词汇学习到了地点的关注信息，加入到passage中的实体信息捕捉中。</p> 
<p>2、很好的解决了实体嵌套问题，同时论文还提出了loss:span_loss（据测试效果不好）。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f0373a8dce6ff5920475a25eb8910349/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【LSTM分类】基于注意力机制的卷积神经网络结合长短记忆神经网络CNN-LSTM-attention实现数据分类附matlab代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bbca27187a8eb6f1e22cf6b21598fbe4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Transformer</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>