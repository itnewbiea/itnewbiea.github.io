<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>关于求解最长公共子序列的两种思路 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="关于求解最长公共子序列的两种思路" />
<meta property="og:description" content="一、题目描述
求取两个给定序列的最长子序列，仅需要求取出其中一个最长子序列即可。
比如序列 X 为 ABCBDAB ，序列 Y 为 BDCABA，则其公共最长子序列之一为 BCBA（可能不唯一）。
关于求解所有最长公共子序列的思路可以移步我的另一篇博文：
https://blog.csdn.net/qq_40697071/article/details/89059844
二、解题思路
这道题的解法一般来说有两种思路，第一种就是普通的暴力穷举法，即对每一种情况都进行列举，然后将两个序列的子序列从头到尾的全部进行比较，因为对于一个序列若其所含元素的数量为 m 时，其所具有的子集的数量为 2^m，然后对于其中每一个子集与另一个序列进行比较时的时间复杂度为 O(n)，因此可以计算出穷举法的时间复杂度为 O(n^(2^m))，这种时间复杂度可以说是很可怕了，所以我们不采取这种解法。
另一种解法是通过使用是用动态规划的思路来进行求解，求解的过程类似于 0、1背包问题，其主要的思路是从后向前对两个序列进行判断，因为当我们从后向前进行判断的时候，只存在两种情况，即两个序列的最后元素相等，或者不相等，假如两个序列的最后一个元素相等，那么就是说最后这个元素肯定是其最长公共子序列的最后一个元素，所以将其记录，然后两个序列同时抛弃最后一个元素。假如两个序列的最后元素不相等，那么就再分两种情况，一种是第一个序列抛弃最后一个元素然后在与第二个序列进行比较，另一种是第二个序列抛弃最后一个元素然后再与第一个元素进行比较，之后的过程其实就是一个重复之前操作的过程。
通过上面的思路，其实我们已经可以大致确定这道题的一个解题的思路，而且我们可以发现这个解法其实就是一种动态规划的思想，即对之前已经计算出来的结果进行保存，后面的计算可以直接依赖于之前的计算结果，这样的话我们可以将两个序列抽象为一个二位数组，行为一个序列，列为一个序列，每个点对应的是从开头到当前为止最长的公共子序列长度，这样的话对于每一个点，假如当前其所对应的在两个序列中的元素相等，即为上面说的第一种情况，那么我们就可以直接使用其西北角的已经计算出来的值加一，相当于直接在之前最长公共子序列的长度加一就可以，反之，假如当前的位置在两个序列中对应的元素不相等，那么就直接取其上方值或者左方值中的最大值即可，因为其上方值和左方值分别对应着上面的第二种情况中的两种情况，即当两个序列的最后一个元素不相等的时候，中间一个序列不动，另一个抛弃尾元素，当两个都这样操作后，取其最大值即可。
之后就是对于这种思路的两种实现方式，一种是使用两个数组，即一个数组保存上述的数据，另一个数组则用来进行标志保存，第二数组的目的是为了最后去求取最长的公共子序列，注意，对于上面的解法也就是单个数组的时候，数组中保存的仅仅是当前位置所对应的最长公共子序列，我们还需要通过另一个方法来确定最后的子序列。用标志数组进行保存的目的是记录当前最长子序列的对于上一步的选择，是直接加一还是抛弃一个尾元素，然后再通过从数组的右下角向左上角递归求解，来求得最后的最长公共子序列。
在上面一种解法中，我们需要创建两个数组，但其实通过思考，我们发现其实只通过一个数组就可以完全满足我们的需要，即当当前位置的上方和当前位置的最长公共子序列长度相等时，我们就默认选择向上走，而不相等的时候就可以认为当前元素为两个序列的一个公共元素，所以直接添加即可。需要注意的是，对于第一个数组初始化，我们应当默认多创建一行和一列，来便于对两个序列的首元素进行判断。
三、代码实现
// 思路一：利用标志数组求解 #include &lt;iostream&gt; // 根据标志数组求解最长公共子序列 void printLcs(vector&lt;char&gt; charArray, vector&lt;vector&lt;int&gt;&gt; recordRoadArray, int row, int col){ if(row == 0 || col == 0) return; if(recordRoadArray[row][col] == 1){ printLcs(charArray, recordRoadArray, row-1, col-1); cout &lt;&lt; charArray[row-1]; }else if(recordRoadArray[row][col] == 2) printLcs(charArray, recordRoadArray, row-1, col); else printLcs(charArray, recordRoadArray, row, col-1); } // 求解标志数组和整理动态规划数组 void lcsLength(vector&lt;char&gt; firstCharArray, vector&lt;char&gt; secondCharArray, int rowLength, int colLength){ vector&lt;vector&lt;int&gt;&gt; recordArray = vector&lt;vector&lt;int&gt;&gt;(rowLength, vector&lt;int&gt;(colLength, 0)); vector&lt;vector&lt;int&gt;&gt; recordRoadArray = vector&lt;vector&lt;int&gt;&gt;(rowLength, vector&lt;int&gt;(colLength, 0)); for(int i = 1; i &lt; rowLength; &#43;&#43;i) for(int j = 1; j &lt; colLength; &#43;&#43;j){ if(firstCharArray[i-1] == secondCharArray[j-1]){ recordArray[i][j] = recordArray[i-1][j-1] &#43; 1; recordRoadArray[i][j] = 1; }else if(recordArray[i-1][j] &gt;= recordArray[i][j-1]){ recordArray[i][j] = recordArray[i-1][j]; recordRoadArray[i][j] = 2; }else{ recordArray[i][j] = recordArray[i][j-1]; recordRoadArray[i][j] = 3; } } printLcs(firstCharArray, recordRoadArray, rowLength-1, colLength-1); } int main() { vector&lt;char&gt; firstCharArray = {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;B&#39;, &#39;D&#39;, &#39;A&#39;, &#39;B&#39;}; vector&lt;char&gt; secondCharArray = {&#39;B&#39;, &#39;D&#39;, &#39;C&#39;, &#39;A&#39;, &#39;B&#39;, &#39;A&#39;}; lcsLength(firstCharArray, secondCharArray, firstCharArray." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/007b73421f93a73b715b19d6dd632c8b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-27T21:46:55+08:00" />
<meta property="article:modified_time" content="2019-03-27T21:46:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">关于求解最长公共子序列的两种思路</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>一、题目描述</strong></p> 
<p style="text-indent:50px;">求取两个给定序列的最长子序列，仅需要求取出其中一个最长子序列即可。</p> 
<p style="text-indent:50px;">比如序列 X 为 ABCBDAB ，序列 Y 为 BDCABA，则其公共最长子序列之一为 BCBA（可能不唯一）。</p> 
<p style="text-indent:50px;">关于求解<strong>所有</strong>最长公共子序列的思路可以移步我的另一篇博文：</p> 
<p style="text-indent:50px;"><a href="https://blog.csdn.net/qq_40697071/article/details/89059844">https://blog.csdn.net/qq_40697071/article/details/89059844</a></p> 
<p><strong>二、解题思路</strong></p> 
<p style="text-indent:50px;">这道题的解法一般来说有两种思路，第一种就是普通的暴力穷举法，即对每一种情况都进行列举，然后将两个序列的子序列从头到尾的全部进行比较，因为对于一个序列若其所含元素的数量为 m 时，其所具有的子集的数量为 2^m，然后对于其中每一个子集与另一个序列进行比较时的时间复杂度为 O(n)，因此可以计算出穷举法的时间复杂度为 O(n^(2^m))，这种时间复杂度可以说是很可怕了，所以我们不采取这种解法。</p> 
<p style="text-indent:50px;">另一种解法是通过使用是用动态规划的思路来进行求解，求解的过程类似于 0、1背包问题，其主要的思路是从后向前对两个序列进行判断，因为当我们从后向前进行判断的时候，只存在两种情况，即两个序列的最后元素相等，或者不相等，假如两个序列的最后一个元素相等，那么就是说最后这个元素肯定是其最长公共子序列的最后一个元素，所以将其记录，然后两个序列同时抛弃最后一个元素。假如两个序列的最后元素不相等，那么就再分两种情况，一种是第一个序列抛弃最后一个元素然后在与第二个序列进行比较，另一种是第二个序列抛弃最后一个元素然后再与第一个元素进行比较，之后的过程其实就是一个重复之前操作的过程。</p> 
<p style="text-indent:50px;">通过上面的思路，其实我们已经可以大致确定这道题的一个解题的思路，而且我们可以发现这个解法其实就是一种动态规划的思想，即对之前已经计算出来的结果进行保存，后面的计算可以直接依赖于之前的计算结果，这样的话我们可以将两个序列抽象为一个二位数组，行为一个序列，列为一个序列，每个点对应的是从开头到当前为止最长的公共子序列长度，这样的话对于每一个点，假如当前其所对应的在两个序列中的元素相等，即为上面说的第一种情况，那么我们就可以直接使用其西北角的已经计算出来的值加一，相当于直接在之前最长公共子序列的长度加一就可以，反之，假如当前的位置在两个序列中对应的元素不相等，那么就直接取其上方值或者左方值中的最大值即可，因为其上方值和左方值分别对应着上面的第二种情况中的两种情况，即当两个序列的最后一个元素不相等的时候，中间一个序列不动，另一个抛弃尾元素，当两个都这样操作后，取其最大值即可。</p> 
<p style="text-align:center;"><img alt="" class="has" height="181" src="https://images2.imgbox.com/3b/d9/8JVcUKZb_o.png" width="780"></p> 
<p style="text-indent:50px;">之后就是对于这种思路的两种实现方式，一种是使用两个数组，即一个数组保存上述的数据，另一个数组则用来进行标志保存，第二数组的目的是为了最后去求取最长的公共子序列，注意，对于上面的解法也就是单个数组的时候，数组中保存的仅仅是当前位置所对应的最长公共子序列，我们还需要通过另一个方法来确定最后的子序列。用标志数组进行保存的目的是记录当前最长子序列的对于上一步的选择，是直接加一还是抛弃一个尾元素，然后再通过从数组的右下角向左上角递归求解，来求得最后的最长公共子序列。</p> 
<p style="text-indent:50px;">在上面一种解法中，我们需要创建两个数组，但其实通过思考，我们发现其实只通过一个数组就可以完全满足我们的需要，即当当前位置的上方和当前位置的最长公共子序列长度相等时，我们就默认选择向上走，而不相等的时候就可以认为当前元素为两个序列的一个公共元素，所以直接添加即可。需要注意的是，对于第一个数组初始化，我们应当默认多创建一行和一列，来便于对两个序列的首元素进行判断。</p> 
<p style="text-align:center;"><img alt="" class="has" height="404" src="https://images2.imgbox.com/ba/77/wz8U3Pnf_o.png" width="368"></p> 
<p><strong>三、代码实现</strong></p> 
<pre class="has"><code class="language-cpp">// 思路一：利用标志数组求解
#include &lt;iostream&gt;

// 根据标志数组求解最长公共子序列
void printLcs(vector&lt;char&gt; charArray, vector&lt;vector&lt;int&gt;&gt; recordRoadArray, int row, int col){
    
    if(row == 0 || col == 0)
        return;
    
    if(recordRoadArray[row][col] == 1){
        printLcs(charArray, recordRoadArray, row-1, col-1);
        cout &lt;&lt; charArray[row-1];
    }else if(recordRoadArray[row][col] == 2)
        printLcs(charArray, recordRoadArray, row-1, col);
    else
        printLcs(charArray, recordRoadArray, row, col-1);
}

// 求解标志数组和整理动态规划数组
void lcsLength(vector&lt;char&gt; firstCharArray, vector&lt;char&gt; secondCharArray, int rowLength, int colLength){
    
    vector&lt;vector&lt;int&gt;&gt; recordArray = vector&lt;vector&lt;int&gt;&gt;(rowLength, vector&lt;int&gt;(colLength, 0));
    vector&lt;vector&lt;int&gt;&gt; recordRoadArray = vector&lt;vector&lt;int&gt;&gt;(rowLength, vector&lt;int&gt;(colLength, 0));
    
    for(int i = 1; i &lt; rowLength; ++i)
        for(int j = 1; j &lt; colLength; ++j){
            if(firstCharArray[i-1] == secondCharArray[j-1]){
                recordArray[i][j] = recordArray[i-1][j-1] + 1;
                recordRoadArray[i][j] = 1;
            }else if(recordArray[i-1][j] &gt;= recordArray[i][j-1]){
                recordArray[i][j] = recordArray[i-1][j];
                recordRoadArray[i][j] = 2;
            }else{
                recordArray[i][j] = recordArray[i][j-1];
                recordRoadArray[i][j] = 3;
            }
        }
    
    printLcs(firstCharArray, recordRoadArray, rowLength-1, colLength-1);        
}

int main() {
    
    vector&lt;char&gt; firstCharArray = {'A', 'B', 'C', 'B', 'D', 'A', 'B'};
    vector&lt;char&gt; secondCharArray = {'B', 'D', 'C', 'A', 'B', 'A'};
    
    lcsLength(firstCharArray, secondCharArray, firstCharArray.size()+1, secondCharArray.size()+1);    
}</code></pre> 
<pre class="has"><code class="language-cpp">// 思路二：只使用一个数组来进行求解
#include &lt;iostream&gt;

void printLcs(vector&lt;char&gt; charArray, vector&lt;vector&lt;int&gt;&gt; recordArray, int row, int col){
    
    if(row == 0 || col == 0)
        return;
    
    if(recordArray[row][col] != recordArray[row-1][col]){
        printLcs(charArray, recordArray, row-1, col-1);
        cout &lt;&lt; charArray[row-1];
    }else
        printLcs(charArray, recordArray, row-1, col);
}

void lcsLength(vector&lt;char&gt; firstCharArray, vector&lt;char&gt; secondCharArray, int rowLength, int colLength){
    
    vector&lt;vector&lt;int&gt;&gt; recordArray = vector&lt;vector&lt;int&gt;&gt;(rowLength, vector&lt;int&gt;(colLength, 0));
    
    for(int i = 1; i &lt; rowLength; ++i)
        for(int j = 1; j &lt; colLength; ++j){
            if(firstCharArray[i-1] == secondCharArray[j-1])
                recordArray[i][j] = recordArray[i-1][j-1] + 1;
            else if(recordArray[i-1][j] &gt;= recordArray[i][j-1])
                recordArray[i][j] = recordArray[i-1][j];
            else
                recordArray[i][j] = recordArray[i][j-1];
            
        }
    
    printLcs(firstCharArray, recordArray, rowLength-1, colLength-1);        
}

int main() {
    
    vector&lt;char&gt; firstCharArray = {'A', 'B', 'C', 'B', 'D', 'A', 'B'};
    vector&lt;char&gt; secondCharArray = {'B', 'D', 'C', 'A', 'B', 'A'};
    
    lcsLength(firstCharArray, secondCharArray, firstCharArray.size()+1, secondCharArray.size()+1);    
}</code></pre> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b0a53e3e506f16f74b96816bac5dcc4e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Ulimit配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/352c9e1fc72a3a367db9cce2346dc0b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">推荐一个学shell超级好的网站，写的详细很不错</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>