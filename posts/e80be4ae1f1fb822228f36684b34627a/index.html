<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构OJ实验12-静态查找 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构OJ实验12-静态查找" />
<meta property="og:description" content="A. DS静态查找之顺序查找 题目描述 给出一个队列和要查找的数值，找出数值在队列中的位置，队列位置从1开始
要求使用带哨兵的顺序查找算法
输入 第一行输入n，表示队列有n个数据
第二行输入n个数据，都是正整数，用空格隔开
第三行输入t，表示有t个要查找的数值
第四行起，输入t个数值，输入t行
输出 每行输出一个要查找的数值在队列的位置，如果查找不成功，输出字符串error
样例查看模式 正常显示查看格式
输入样例1 8\n
33 66 22 88 11 27 44 55\n
3\n
22\n
11\n
99\n
输出样例1 3\n
5\n
error\n
AC代码 #include&lt;bits/stdc&#43;&#43;.h&gt; using namespace std; int main() { int n; cin&gt;&gt;n; vector&lt;int&gt;v(n&#43;1); for(int i=1;i&lt;=n;i&#43;&#43;) { cin&gt;&gt;v[i]; } int m; cin&gt;&gt;m; while(m--) { int x; cin&gt;&gt;x; int k=n; while(k) { if(v[k]==x) { break; } k--; } if(k) { cout&lt;&lt;k&lt;&lt;endl; } else { cout&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e80be4ae1f1fb822228f36684b34627a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-01T21:16:38+08:00" />
<meta property="article:modified_time" content="2024-01-01T21:16:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构OJ实验12-静态查找</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>A. DS静态查找之顺序查找</h3> 
<h4>题目描述</h4> 
<p>给出一个队列和要查找的数值，找出数值在队列中的位置，队列位置从1开始</p> 
<p>要求使用带哨兵的顺序查找算法</p> 
<h4>输入</h4> 
<p>第一行输入n，表示队列有n个数据<br> 第二行输入n个数据，都是正整数，用空格隔开<br> 第三行输入t，表示有t个要查找的数值<br> 第四行起，输入t个数值，输入t行</p> 
<h4>输出</h4> 
<p>每行输出一个要查找的数值在队列的位置，如果查找不成功，输出字符串error</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1 </h4> 
<p>8\n<br> 33 66 22 88 11 27 44 55\n<br> 3\n<br> 22\n<br> 11\n<br> 99\n</p> 
<h4>输出样例1</h4> 
<p>3\n<br> 5\n<br> error\n</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int n;
    cin&gt;&gt;n;
    vector&lt;int&gt;v(n+1);
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;v[i];
    }
    int m;
    cin&gt;&gt;m;
    while(m--)
    {
        int x;
        cin&gt;&gt;x;
        int k=n;
        while(k)
        {
            if(v[k]==x)
            {
                break;
            }
            k--;
        }
        if(k)
        {
            cout&lt;&lt;k&lt;&lt;endl;
        }
        else
        {
            cout&lt;&lt;"error"&lt;&lt;endl;
        }
    }
    return 0;
}</code></pre> 
<h3>B. DS静态查找之折半查找</h3> 
<h4>题目描述</h4> 
<p>给出一个队列和要查找的数值，找出数值在队列中的位置，队列位置从1开始</p> 
<p>要求使用折半查找算法</p> 
<h4>输入</h4> 
<p>第一行输入n，表示队列有n个数据<br> 第二行输入n个数据，都是正整数，用空格隔开<br> 第三行输入t，表示有t个要查找的数值<br> 第四行起，输入t个数值，输入t行</p> 
<h4>输出</h4> 
<p>每行输出一个要查找的数值在队列的位置，如果查找不成功，输出字符串error</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1 </h4> 
<p>8\n<br> 11 22 33 44 55 66 77 88\n<br> 3\n<br> 22\n<br> 88\n<br> 99\n</p> 
<h4>输出样例1</h4> 
<p>2\n<br> 8\n<br> error\n</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
const int N = 1e5;
int a[N];
int n;
bool flag = 0;
void find(int l, int r,int k)
{
	if (l &gt; r)return;
	int mid = (l + r) / 2;
	if (a[mid] == k)
	{
		flag = 1;
		cout &lt;&lt; mid &lt;&lt; endl;
		return;
	}
	else if (a[mid] &lt; k)
	{
		find(mid + 1, r, k);
	}
	else
	{
		find(l, mid - 1, k);
	}
}
int main()
{
	cin &gt;&gt; n;
	for (int i = 1; i &lt;= n; i++)
	{
		cin &gt;&gt; a[i];
	}
	int k;
	cin &gt;&gt; k;
	while (k--)
	{
		flag = 0;
		int x;
		cin &gt;&gt; x;
		find(1,n,x);
		if (!flag)cout &lt;&lt; "error" &lt;&lt; endl;
	}
	return 0;
}</code></pre> 
<h3>C. DS静态查找之顺序索引查找</h3> 
<h4>题目描述</h4> 
<p>给出一个队列和要查找的数值，找出数值在队列中的位置，队列位置从1开始</p> 
<p>要求使用顺序索引查找算法，其中索引表查找和块内查找都采用不带哨兵、从头开始的顺序查找方法。</p> 
<h4>输入</h4> 
<p>第一行输入n，表示主表有n个数据<br> 第二行输入n个数据，都是正整数，用空格隔开<br> 第三行输入k，表示主表划分为k个块，k也是索引表的长度<br> 第四行输入k个数据，表示索引表中每个块的最大值<br> 第五行输入t，表示有t个要查找的数值<br> 第六行起，输入t个数值，输入t行</p> 
<h4>输出</h4> 
<p>每行输出一个要查找的数值在队列的位置和查找次数，数据之间用短划线隔开，如果查找不成功，输出字符串error</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1 </h4> 
<p>18\n<br> 22 12 13 8 9 20 33 42 44 38 24 48 60 58 74 57 86 53\n<br> 3\n<br> 22 48 86\n<br> 6\n<br> 13\n<br> 5\n<br> 48\n<br> 40\n<br> 53\n<br> 90\n</p> 
<h4>输出样例1</h4> 
<p>3-4\n<br> error\n<br> 12-8\n<br> error\n<br> 18-9\n<br> error\n</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int n;
    cin &gt;&gt; n;
    vector&lt;int&gt;v(n);
    for (int i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; v[i];
    }
    int k;
    cin &gt;&gt; k;
    vector&lt;int&gt;index(k);
    for (int i = 0; i &lt; k; i++)
    {
        cin &gt;&gt; index[i];//每一块中的最大值
    }
    int t;
    cin &gt;&gt; t;
    while (t--)
    {
        int x;
        cin &gt;&gt; x;
        int idx = -1;
        int cnt = 0;
        for (int i = 0; i &lt; k; i++)
        {
            cnt++;//查找次数加加
            if (x &lt;= index[i])//一定在index[i]这个块里！
            {
                idx = i;
                break;
            }
        }
        if (idx == -1)
        {
            cout &lt;&lt; "error" &lt;&lt; endl;
            continue;
        }
        bool ok = 0;
        //两块之间的间隔是n/k!!
        //范围是一块的头到另一块的头！
        for (int i = idx * (n/k); i &lt; (idx+1)*(n/k); i++)
        {
            cnt++;
            if (x == v[i])
            {
                ok = 1;
                cout &lt;&lt; i + 1 &lt;&lt; "-" &lt;&lt; cnt &lt;&lt; endl;
                break;
            }
        }
        if (!ok)
        {
            cout &lt;&lt; "error" &lt;&lt; endl;
        }
    }
    return 0;
}</code></pre> 
<h3>D. DS查找——折半查找求平方根</h3> 
<h4>题目描述</h4> 
<p>假定输入<code>y</code>是整数，我们用折半查找来找这个平方根。在从0到<code>y</code>之间必定有一个取值是<code>y</code>的平方根，如果我们查找的数<code>x</code>比<code>y</code>的平方根小，则x2&lt;y，如果我们查找的数<code>x</code>比<code>y</code>的平方根大，则x2&gt;y，我们可以据此缩小查找范围，当我们查找的数足够准确时（比如满足|x2-y|&lt;0.00001），就可以认为找到了<code>y</code>的平方根。</p> 
<p>比如求5的平方根x，则x一定满足0&lt;=x&lt;=5，取x为(5+0)/2=2.5，因为2.5的平方为6.25&gt;5，所以x一定小于2.5，也即x满足0&lt;=x&lt;=2.5，取x为1.25，以此类推</p> 
<table><thead><tr><th>X的范围</th><th>X的取值</th><th>x2</th><th>x2-y</th></tr></thead><tbody><tr><td>0</td><td>5</td><td>2.5</td><td>6.25</td><td>1.25</td></tr><tr><td>0</td><td>2.5</td><td>1.25</td><td>1.5625</td><td>-3.4375</td></tr><tr><td>1.25</td><td>2.5</td><td>1.875</td><td>3.515625</td><td>-1.484375</td></tr><tr><td>1.875</td><td>2.5</td><td>2.1875</td><td>4.78515625</td><td>-0.21484375</td></tr><tr><td>2.1875</td><td>2.5</td><td>2.34375</td><td>5.4931640625</td><td>0.4931640625</td></tr><tr><td>2.1875</td><td>2.34375</td><td>2.265625</td><td>5.133056640625</td><td>0.133056640625</td></tr><tr><td>2.1875</td><td>2.265625</td><td>2.2265625</td><td>…</td><td>…</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table> 
<p>最后求得5的平方根为2.236</p> 
<p>温馨提示： 计算过程中为确保精确性，计算变量的类型都用double</p> 
<p>保留小数位数的输出，C语言参考格式printf("%.3lf\n",x) ；C++参考cout&lt;&lt;fixed&lt;&lt;setprecision(3)&lt;&lt;x&lt;&lt;endl;（要包含头文件Iomanip）</p> 
<p>程序框架参考平时练习中折半查找的方法</p> 
<h4>输入</h4> 
<p>第1行输入一个整数n(&lt;100)，表示有n个数</p> 
<p>从第2行起到第n+1行输入n个整数</p> 
<h4>输出</h4> 
<p>输出n个数的平方根，精确到小数点后三位。</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1 </h4> 
<p>2\n<br> 13\n<br> 5\n</p> 
<h4>输出样例1</h4> 
<p>3.606\n<br> 2.236</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int n;
    cin&gt;&gt;n;
    while(n--)
    {
        double x;
        cin&gt;&gt;x;
        double l=1,r=x;
        bool ok=0;
        while(r-l&gt;=0.00000001)
        {
            double mid=(l+r)/2;
            if(abs(mid*mid-x)&lt;=0.0000001)
            {
                printf("%.3lf\n",mid);
                break;
            }
            else if(mid*mid-x&gt;0.00000001)
            {
                r=mid;
            }
            else
            {
                l=mid;
            }
        }
    }
    return 0;
}</code></pre> 
<h3>E. 两个有序序列的中位数</h3> 
<h4>题目描述</h4> 
<p>已知有两个等长的非降序序列S1, S2, 设计函数求S1与S2并集的中位数。有序序列A​0​​,A​1​​,⋯,A​N−1​​的中位数指A​(N−1)/2​​的值,即第⌊(N+1)/2⌋个数（A​0​​为第1个数）。</p> 
<p>只需考虑中位数唯一的情况</p> 
<h4>输入</h4> 
<p>输入分三行。第一行给出序列的公共长度N（0&lt;N≤100000），随后每行输入一个序列的信息，即N个非降序排列的整数。数字用空格间隔。</p> 
<h4>输出</h4> 
<p>在一行中输出两个输入序列的并集序列的中位数。</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1 </h4> 
<p>5\n<br> 1 3 5 7 9\n<br> 2 3 4 5 6</p> 
<h4>输出样例1</h4> 
<p>4</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
// 1 3 5 7 9
// 2 3 4 5 6
// 1 2 3 3 4 5 5 6 7 9
int main()
{
    int n;
    cin&gt;&gt;n;
    vector&lt;int&gt;v(2*n);
    for(int i=0;i&lt;2*n;i++)
    {
        cin&gt;&gt;v[i];
    }
    sort(v.begin(),v.end());
    cout&lt;&lt;v[n-1]&lt;&lt;endl;
    return 0;
}</code></pre> 
<h3>F. 链表的有序构建和查找</h3> 
<h4>题目描述</h4> 
<p>单链表结点的存储结构包含两部分：数据、下一结点指针（默认为空）。</p> 
<p>单链表包含头结点，存储实际数据的结点位置从1开始。</p> 
<p>现输入一批无序的整数队列，编写程序完成以下要求</p> 
<p>1）构建单链表并且把数据按递增顺序插入到链表中，并且统计非空指针发生变化的次数。</p> 
<p>例如在初始只包含头结点的单链表中，依次插入3和2</p> 
<p>当把3插入时，是头结点的next指针发生变化，初始头结点的next指针是空的，现在指向3的结点，所以不计入指针变化次数。</p> 
<p>当把2插入时，它是插入到头结点和3结点之间，这时候头结点的next指针从指向3变成指向2，因此这次计入指针变化次数。</p> 
<p>总之，如果是把一个空的next指针指向新的结点，则不计入变化次数；如果是把一个非空next指针修改指向新结点则计入变化次数。</p> 
<p>2）实现对单链表的元素查找。输入一个链表位置，返回该位置对应的数据。如果位置非法则输出提示信息，看样例。</p> 
<p>要求：必须使用单链表结构实现上述要求，并且不能用第三方算法库或容器类对象</p> 
<h4>输入</h4> 
<p>第一行：第一个数字n表示样本数目，其后跟n个样本。</p> 
<p>第二行：查找测试次数m 后跟m个待查找的位置。</p> 
<h4>输出</h4> 
<p>第一行输出构建链表过程中，非空指针变化的总次数，格式看样本</p> 
<p>第二行输出单链表创建后，从头到尾依次输出链表中元素数据</p> 
<p>第三行到第n+1行，对每个查找位置，若结点存在，输出结点数据；否则输出error</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1 </h4> 
<p>6 1 8 5 2 4 3\n<br> 4 0 2 10 6\n</p> 
<h4>输出样例1</h4> 
<p>非空指针变化4次\n<br> 1 2 3 4 5 8\n<br> error\n<br> 2\n<br> error\n<br> 8\n</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
struct node
{
    int data;
    node* next;
    node()
    {
        next = NULL;
    }
};
class linkk
{
    node* head;
    int n;
    int cnt;
public:
    linkk()
    {
        n = 0;
        cnt = 0;
        head = new node;
    }
    void insert(int x)
    {
        node* temp = new node;
        temp-&gt;data = x;
        temp-&gt;next = NULL;
        node* s = new node;
        s = head;
        while (1)
        {
            if (s-&gt;next == NULL)//直接插在后面
            {
                s-&gt;next = temp;
                break;
            }
            if (s-&gt;next-&gt;data &gt; x)
            {
                cnt++;//指针变化次数
                temp-&gt;next = s-&gt;next;
                s-&gt;next = temp;
                break;
            }
            s = s-&gt;next;//注意！
        }
        n++;
    }
    void display()
    {
        cout &lt;&lt; "非空指针变化" &lt;&lt; cnt &lt;&lt; "次" &lt;&lt; endl;
        node* k = new node;
        k = head;
        for (int i = 0; i &lt; n - 1; i++)
        {
            k = k-&gt;next;
            cout &lt;&lt; k-&gt;data &lt;&lt; " ";
        }
        k = k-&gt;next;
        cout &lt;&lt; k-&gt;data &lt;&lt; endl;
    }
    int find(int x)
    {
        node* s = new node;
        s = head;
        if (x &gt; n || x &lt;= 0)
        {
            return -1;
        }
        for (int i = 0; i &lt; x; i++)
        {
            s = s-&gt;next;
        }
        return s-&gt;data;
    }
};
int main()
{
    int nn;
    cin &gt;&gt; nn;
    linkk ll;
    for (int i = 0; i &lt; nn; i++)
    {
        int x;
        cin &gt;&gt; x;
        ll.insert(x);
    }
    ll.display();
    int m;
    cin &gt;&gt; m;
    while (m--)
    {
        int x;
        cin &gt;&gt; x;
        if (ll.find(x) != -1)
        {
            cout &lt;&lt; ll.find(x) &lt;&lt; endl;
        }
        else
        {
            cout &lt;&lt; "error" &lt;&lt; endl;
        }
    }
    return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f42399e3e948c38f0f4cea7b0b54729d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C Primer Plus第六版 学习笔记】 第十六章 C预处理器和C库</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2eb30e1ba62c64c8f73de1ed44b2bbf0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">汽车驾驶的基础知识，驾照考试的科目练习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>