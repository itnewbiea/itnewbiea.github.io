<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编排流程/规则，编排本身也需要很深的逻辑思考 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="编排流程/规则，编排本身也需要很深的逻辑思考" />
<meta property="og:description" content="什么是流程/规则编排？ 所谓编排，就是让已有的节点通过不同的组织方式完成不同的需求。
首先，我们需要对既有业务做一定程度的抽象，以一个例子开始：
一个简单的国庆节充值活动：
活动时间 10.1-10.7
充值≥100 元，送 5 元余额
充值≥50 元，送 10 积分，10.5 之后开始
不叠加送， 即充 100 元只送 5 元余额不会叠加再送 10 积分
当充值发生时，我们拥有：充值用户-uid，充值金额-cost，充值时间-time
再有一些制作好的抽象节点，如：
判断充值≥100 的条件节点 ScoreFlow-100，cost≥100 返回 true，否则返回 false判断充值≥50 的条件节点 ScoreFlow-50，cost≥50 返回 true，否则返回 false发放 5 元余额的结果节点 AmountResult，结果也可以有返回，比如正常发放了返回 true，库存不足了等原因导致的没有发放(不是
error)，可以返回 false发放 10 元积分的结果节点 PointResult 那么，为什么要编排，如何编排才是最优的？
为什么要编排？ **屏蔽代码影响：**比如编排者只需要知道 AmountResult 是发放余额的节点，然后在适当的位置运行这个节点即可，不需要关心真实的代码逻辑
**提升效率：**结合可视化给非研发人员编排实现业务逻辑，支持动态修改与生效配置，比如充值条件 100 元改成 200，结合可视化工具直接修改，解放研发，提升生产效率
如何编排？ 流程图式编排 脑海里最先出现的编排方式，也是最常见的编排方式
执行树式编排 When X Then Y
以上两种基本代表了传统的编排思想，在简单的例子下，看起来也是非常直观，但，当变动发生时，尤其是需要灵活调整的场景，他们的表现又如何呢？
变动 ①简单配置修改 充值 100 元改成 80 吧，10 积分变 20 积分吧，时间改成 10." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/11aa79870df3809f9c2888560a215e5b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-08T17:01:41+08:00" />
<meta property="article:modified_time" content="2022-10-08T17:01:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">编排流程/规则，编排本身也需要很深的逻辑思考</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>什么是流程/规则编排？</h3> 
<p><strong>所谓编排，就是让已有的节点通过不同的组织方式完成不同的需求。</strong></p> 
<p>首先，我们需要对既有业务做一定程度的抽象，以一个例子开始：<br> 一个简单的国庆节充值活动：</p> 
<p><strong>活动时间 10.1-10.7</strong><br> <strong>充值≥100 元，送 5 元余额</strong><br> <strong>充值≥50 元，送 10 积分，10.5 之后开始</strong></p> 
<p><strong>不叠加送，</strong> 即充 100 元只送 5 元余额不会叠加再送 10 积分</p> 
<p>当充值发生时，我们拥有：<strong>充值用户-uid，充值金额-cost，充值时间-time</strong><br> 再有一些制作好的抽象节点，如：</p> 
<ul><li>判断充值≥100 的条件节点 ScoreFlow-100，cost≥100 返回 true，否则返回 false</li><li>判断充值≥50 的条件节点 ScoreFlow-50，cost≥50 返回 true，否则返回 false</li><li>发放 5 元余额的结果节点 AmountResult，结果也可以有返回，比如正常发放了返回 true，库存不足了等原因导致的没有发放(不是<br> error)，可以返回 false</li><li>发放 10 元积分的结果节点 PointResult</li></ul> 
<p><strong>那么，为什么要编排，如何编排才是最优的？</strong></p> 
<h3><a id="_24"></a>为什么要编排？</h3> 
<p>**屏蔽代码影响：**比如编排者只需要知道 AmountResult 是发放余额的节点，然后在适当的位置运行这个节点即可，不需要关心真实的代码逻辑</p> 
<p>**提升效率：**结合可视化给非研发人员编排实现业务逻辑，支持动态修改与生效配置，比如充值条件 100 元改成 200，结合可视化工具直接修改，解放研发，提升生产效率</p> 
<h3><a id="_29"></a>如何编排？</h3> 
<h4><a id="_30"></a>流程图式编排</h4> 
<p><img src="https://images2.imgbox.com/22/57/qEGMqTMH_o.png" alt="在这里插入图片描述"><br> 脑海里最先出现的编排方式，也是最常见的编排方式</p> 
<h4><a id="_34"></a>执行树式编排</h4> 
<p><strong>When X Then Y</strong><br> <img src="https://images2.imgbox.com/ce/69/h00a40pY_o.png" alt="在这里插入图片描述"><br> 以上两种基本代表了传统的编排思想，在简单的例子下，看起来也是非常直观，但，当变动发生时，尤其是需要灵活调整的场景，他们的表现又如何呢？</p> 
<h3><a id="_39"></a>变动</h3> 
<h6><a id="_41"></a>①简单配置修改</h6> 
<p>充值 100 元改成 80 吧，10 积分变 20 积分吧，时间改成 10.9 号结束吧（**微微一笑，**毕竟我费了这么大劲，终于体现到价值了！）</p> 
<h6><a id="_44"></a>②简单逻辑变动</h6> 
<p>用户参与积极性不高啊，去掉不叠加送吧，都送（**稍加思索，**费几个脑细胞挪一挪还是可以的，怎么也比改代码再上线强吧！）</p> 
<h6><a id="_47"></a>③进阶逻辑变动</h6> 
<p>5元余额不能送太多，设置个库存100个吧，对了，库存不足了充100元还是得送10积分的哈（**卒…**早知道还不如硬编码了）</p> 
<p>真实线上变动只会更离谱，流程图式和执行树式实现的主要缺点在于，牵一发而动全身，改动一个节点需要瞻前顾后，如果考虑不到位，很容易弄错，现实的活动内容要比例子复杂的多，时间线也是多条，考虑到这，再加上使用学习框架的成本，往往得不偿失，到头来发现还不如硬编码</p> 
<p><strong>那么，有没有更好的编排逻辑？</strong></p> 
<h3><a id="ice_54"></a>ice是如何编排的</h3> 
<p><img src="https://images2.imgbox.com/50/5a/cpQkcI9L_o.png" alt="在这里插入图片描述"><br> 如图，ice使用关系节点作为逻辑传递的桥梁，用树图方式呈现逻辑</p> 
<h5><a id="_58"></a>关系节点(逻辑节点)</h5> 
<p>控制业务流转，如：</p> 
<p><strong>AND：</strong> 从上到下执行子节点，遇到第一个false中断并返回false，全部为true则返回true，类似于 Java 的 &amp;&amp;<br> <strong>ANY：</strong> 从上到下执行子节点，遇到第一个True中断并返回true，全部为false则返回false，类似于 Java 的 ||<br> <strong>ALL：</strong> 从上到下执行所有子节点</p> 
<h5><a id="_65"></a>叶子节点(业务节点)</h5> 
<p>真正做事情的节点，如：</p> 
<p><strong>Flow：</strong> 一些条件与规则节点，如ScoreFlow<br> <strong>Result：</strong> 一些结果性质的节点，如AmountResult，PointResult<br> <strong>None：</strong> 一些不会干预流程的节点，如下文会介绍到的TimeChangeNone</p> 
<h5><a id="_72"></a>执行流程</h5> 
<p>图中，如果10月4日，充值100元，则执行流程为：</p> 
<ol><li>从根节点开始，先执行ANY</li><li>充值时间在ANY生效时间内，继续执行</li><li>ANY有两个子节点，先执行第一个子节点AND</li><li>AND有两个子节点，先执行第一个子节点ScoreFlow-100</li><li>ScoreFlow-100判断并返回true</li><li>AND接收到true，继续向下执行AmountResult</li><li>AmountResult发放余额并返回true</li><li>AND子节点执行完毕，接收到两个true，自己也返回true</li><li>ANY接收到true，不再继续执行子节点并返回true</li></ol> 
<p>可以看到，之前需要剥离出的时间，已经融合到各个节点上了，把时间配置还给节点，如果没到执行时间，如发放积分的节点 10月5日之后才生效，那么在 10月5日之前，可以理解为这个节点不存在</p> 
<h5><a id="_86"></a>变动的解决</h5> 
<p>对于<strong>①</strong>直接修改节点配置就可以</p> 
<p>对于<strong>②</strong>直接把ANY 改成 ALL 即可(叠加送与不叠加送的逻辑在这个节点上，属于这个节点的逻辑就该由这个节点去解决)</p> 
<p>对于<strong>③</strong>由于库存的不足，相当于没有给用户发放，则 AmountResult 返回 false，流程还会继续向下执行，不用做任何更改</p> 
<p>再加一个棘手的问题，当时间线复杂时，测试工作以及测试并发要怎么做？</p> 
<p>一个 10月1日开始的活动，一定是在 10月1日之前开发上线完毕，如我在 9月15日要怎么去测试一个10月1日开始的活动？在 ice 中，只需要稍微修改一下：<br> <img src="https://images2.imgbox.com/18/c4/032ujAgq_o.png" alt="在这里插入图片描述"><br> 增加了个子节点TimeChangeNone（用于更改测试环境请求里的充值时间，可以改成任意想要的测试时间）</p> 
<h3><a id="_100"></a>特性</h3> 
<p>为什么这么编排呢？为什么这样就能解决这些变动与问题呢？</p> 
<p>其实，就是使用树形结构解耦，流程图式和执行树式实现在改动逻辑的时候，需要瞻前顾后，但是 ice 不需要，ice 的业务逻辑都在本节点上，每一个节点都可以代表单一逻辑，比如我改不叠加送变成叠加送这一逻辑就只限制在那个 ANY 节点逻辑上，只要把它改成我想要的逻辑即可，至于子节点有哪些，不用特别在意，节点之间通过上下文传递信息，每个节点执行完的后续流程不需要自己指定</p> 
<p>因为自己执行完后的执行流程不再由自己掌控，还可以做到对象级别的复用：<br> <img src="https://images2.imgbox.com/46/34/hYNZx616_o.png" alt="在这里插入图片描述"><br> 如图，参与活动这里用到的 TimeChangeNone，如果现在还有个 H5 页面需要做呈现，不同的呈现也与时间相关，怎么办？只需要在呈现活动这里使用同一个节点对象(在ice后台配置中为同id节点)，更改其中一个，另一个也会被更新(因为他们是同一个对象，不存在多个复用节点同步问题)，避免了到处修改时间</p> 
<h3><a id="Code_110"></a>Code</h3> 
<p>Talk is cheap. Show me the code…</p> 
<p><strong>官方文档：</strong><a href="http://waitmoon.com/zh/" rel="nofollow">http://waitmoon.com/zh/</a></p> 
<p><strong>GitHub：</strong><a href="https://github.com/zjn-zjn/ice">https://github.com/zjn-zjn/ice</a></p> 
<p><strong>Gitee：</strong><a href="https://gitee.com/waitmoon/ice" rel="nofollow">https://gitee.com/waitmoon/ice</a></p> 
<p>有更好想法或者更多应用场景或者想一起探讨的小伙伴~ 欢迎交流~</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/88b5f334de0bec3efa25c0f839f3be45/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">二重积分的复化Simpson方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a94a1946f2a764a964b6831b2bfadfe1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Flink&#43;ice 实现可视化规则编排与灵活配置(Demo)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>