<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>10个你需要知道的SpringBoot参数验证的技巧 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="10个你需要知道的SpringBoot参数验证的技巧" />
<meta property="og:description" content="前言 参数验证很重要，是平时开发环节中不可少的一部分，但是我想很多后端同事会偷懒，干脆不错，这样很可能给系统的稳定性和安全性带来严重的危害。那么在Spring Boot应用中如何做好参数校验工作呢，本文提供了10个小技巧，你知道几个呢？
1.使用验证注解 Spring Boot 提供了内置的验证注解，可以帮助简单、快速地对输入字段进行验证，例如检查 null 或空字段、强制执行长度限制、使用正则表达式验证模式以及验证电子邮件地址。
一些最常用的验证注释包括：
@NotNull：指定字段不能为空。@NotEmpty：指定列表字段不能为空。@NotBlank：指定字符串字段不得为空或仅包含空格。@Min 和 @Max：指定数字字段的最小值和最大值。@Pattern：指定字符串字段必须匹配的正则表达式模式。@Email：指定字符串字段必须是有效的电子邮件地址。 具体用法参考下面例子：
public class User { @NotNull private Long id; @NotBlank @Size(min = 2, max = 50) private String firstName; @NotBlank @Size(min = 2, max = 50) private String lastName; @Email private String email; @NotNull @Min(18) @Max(99) private Integer age; @NotEmpty private List&lt;String&gt; hobbies; @Pattern(regexp = &#34;[A-Z]{2}\d{4}&#34;) private String employeeId; 复制代码 2 使用自定义验证注解 虽然 Spring Boot 的内置验证注释很有用，但它们可能无法涵盖所有情况。如果有特殊参数验证的场景，可以使用 Spring 的 JSR 303 验证框架创建自定义验证注释。自定义注解可以让你的的验证逻辑更具可重用性和可维护性。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/1aa6bbf46e89258649e06362504bb462/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-31T13:03:47+08:00" />
<meta property="article:modified_time" content="2023-03-31T13:03:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">10个你需要知道的SpringBoot参数验证的技巧</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>前言</h3> 
<p>参数验证很重要，是平时开发环节中不可少的一部分，但是我想很多后端同事会偷懒，干脆不错，这样很可能给系统的稳定性和安全性带来严重的危害。那么在Spring Boot应用中如何做好参数校验工作呢，本文提供了10个小技巧，你知道几个呢？</p> 
<h3>1.使用验证注解</h3> 
<p><code>Spring Boot </code>提供了内置的验证注解，可以帮助简单、快速地对输入字段进行验证，例如检查 null 或空字段、强制执行长度限制、使用正则表达式验证模式以及验证电子邮件地址。</p> 
<p>一些最常用的验证注释包括：</p> 
<ul><li><code>@NotNull</code>：指定字段不能为空。</li><li><code>@NotEmpty</code>：指定列表字段不能为空。</li><li><code>@NotBlank</code>：指定字符串字段不得为空或仅包含空格。</li><li><code>@Min</code> 和 <code>@Max</code>：指定数字字段的最小值和最大值。</li><li><code>@Pattern</code>：指定字符串字段必须匹配的正则表达式模式。</li><li><code>@Email</code>：指定字符串字段必须是有效的电子邮件地址。</li></ul> 
<p>具体用法参考下面例子：</p> 
<pre><code>public class User {
    @NotNull
    private Long id;

    @NotBlank
    @Size(min = 2, max = 50)
    private String firstName;

    @NotBlank
    @Size(min = 2, max = 50)
    private String lastName;

    @Email
    private String email;

    @NotNull
    @Min(18)
    @Max(99)
    private Integer age;

    @NotEmpty
    private List&lt;String&gt; hobbies;

    @Pattern(regexp = "[A-Z]{2}\d{4}")
    private String employeeId;
复制代码</code></pre> 
<h3>2 使用自定义验证注解</h3> 
<p>虽然 Spring Boot 的内置验证注释很有用，但它们可能无法涵盖所有情况。如果有特殊参数验证的场景，可以使用 Spring 的 JSR 303 验证框架创建自定义验证注释。自定义注解可以让你的的验证逻辑更具可重用性和可维护性。</p> 
<p>假设我们有一个应用程序，用户可以在其中创建帖子。每个帖子都应该有一个标题和一个正文，并且标题在所有帖子中应该是唯一的。虽然 Spring Boot 提供了用于检查字段是否为空的内置验证注释，但它没有提供用于检查唯一性的内置验证注释。在这种情况下，我们可以创建一个自定义验证注解来处理这种情况。</p> 
<p>首先，我们创建自定义约束注解<code>UniqueTitle</code> ：</p> 
<pre><code>@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = UniqueTitleValidator.class)
public @interface UniqueTitle {
    String message() default "Title must be unique";

    Class&lt;?&gt;[] groups() default {};

    Class&lt;? extends Payload&gt;[] payload() default {};
}
复制代码</code></pre> 
<p>接下来，我们创建一个<code>PostRepository</code>接口，目的是从数据库中检索帖子：</p> 
<pre><code>public interface PostRepository extends JpaRepository&lt;Post, Long&gt; {
    Post findByTitle(String title);
}
复制代码</code></pre> 
<p>然后我们需要定义验证器类 <code>UniqueTitleValidator</code>，如下所示：</p> 
<pre><code>@Component
public class UniqueTitleValidator implements ConstraintValidator&lt;UniqueTitle, String&gt; {

    @Autowired
    private PostRepository postRepository;

    @Override
    public boolean isValid(String title, ConstraintValidatorContext context) {
        if (title == null) {
            return true;
        }
        return Objects.isNull(postRepository.findByTitle(title));
    }
}
复制代码</code></pre> 
<p><code>UniqueTitleValidator</code>实现了<code>ConstraintValidator</code>接口，它有两个泛型类型：第一个是自定义注解<code>UniqueTitle</code>，第二个是正在验证的字段类型（在本例中为<code>String</code>). 我们还自动装配了<code>PostRepository</code> 类以从数据库中检索帖子。</p> 
<p><code>isValid()</code>方法通过查询 <code>PostRepository</code> 来检查 <code>title</code> 是否为 null 或者它是否是唯一的。如果 <code>title</code> 为 null 或唯一，则验证成功，并返回 true。</p> 
<p>定义了自定义验证注释和验证器类后，我们现在可以使用它来验证 Spring Boot 应用程序中的帖子标题：</p> 
<pre><code>public class Post {
    @UniqueTitle
    private String title;

    @NotNull
    private String body;
}
复制代码</code></pre> 
<p>我们已将 <code>@UniqueTitle</code> 注释应用于 <code>Post</code> 类中的 <code>title</code> 变量。验证此字段时，这将触发 <code>UniqueTitleValidator</code> 类中定义的验证逻辑。</p> 
<h3>3 在服务器端验证</h3> 
<p>除了前端或者客户端做了验证意外，服务器端验证输入是至关重要的。它可以确保在处理或存储任何恶意或格式错误的数据之前将其捕获，这对于应用程序的安全性和稳定性至关重要。</p> 
<p>假设我们有一个允许用户创建新帐户的 <code>REST</code> 端点。端点需要一个包含用户用户名和密码的 JSON 请求体。为确保输入有效，我们可以创建一个 DTO（数据传输对象）类并将验证注释应用于其字段：</p> 
<pre><code>public class UserDTO {

    @NotBlank
    private String username;

    @NotBlank
    private String password;
}
复制代码</code></pre> 
<p>我们使用<code>@NotBlank</code>注解来确保<code>username</code>和<code>password</code>字段不为空或 null。</p> 
<p>接下来，我们可以创建一个控制器方法来处理 HTTP POST 请求并在创建新用户之前验证输入：</p> 
<pre><code>@RestController
@RequestMapping("/users")
@Validated
public class UserController {
    @Autowired
    private UserService userService;

    @PostMapping
    public ResponseEntity&lt;String&gt; createUser(@Valid @RequestBody UserDTO userDto) {
        userService.createUser(userDto);
        return ResponseEntity.status(HttpStatus.CREATED).body("User created successfully");
    }
}
复制代码</code></pre> 
<p>我们使用 Spring 的<code>@Validated</code>注解来启用方法级验证，我们还将 <code>@Valid</code> 注释应用于 <code>userDto</code> 参数以触发验证过程。</p> 
<h3>4 提供有意义的错误信息</h3> 
<p>当验证失败时，必须提供清晰简洁的错误消息来描述出了什么问题以及如何修复它。</p> 
<p>这是一个示例，如果我们有一个允许用户创建新用户的 <code>RESTful API</code>。我们要确保姓名和电子邮件地址字段不为空，年龄在 18 到 99 岁之间，除了这些字段，如果用户尝试使用重复的“用户名”创建帐户，我们还会提供明确的错误消息或“电子邮件”。</p> 
<p>为此，我们可以定义一个带有必要验证注释的模型类 User，如下所示：</p> 
<pre><code>public class User {

    @NotBlank(message = "用户名不能为空")
    private String name;

    @NotBlank(message = "Email不能为空")
    @Email(message = "无效的Emaild地址")
    private String email;

    @NotNull(message = "年龄不能为空")
    @Min(value = 18, message = "年龄必须大于18")
    @Max(value = 99, message = "年龄必须小于99")
    private Integer age;
}
复制代码</code></pre> 
<ul><li>我们使用 message属性为每个验证注释提供了自定义错误消息。</li></ul> 
<p>接下来，在我们的 Spring 控制器中，我们可以处理表单提交并使用 <code>@Valid</code> 注释验证用户输入：</p> 
<pre><code>@RestController
@RequestMapping("/users")
public class UserController {
    @Autowired
    private UserService userService;

    @PostMapping
    public ResponseEntity&lt;String&gt; createUser(@Valid @RequestBody User user, BindingResult result) {
        if (result.hasErrors()) {
            List&lt;String&gt; errorMessages = result.getAllErrors().stream()
                    .map(DefaultMessageSourceResolvable::getDefaultMessage)
                    .collect(Collectors.toList());
            return ResponseEntity.badRequest().body(errorMessages.toString());
        }

        // save the user to the database using UserService
        userService.saveUser(user);

        return ResponseEntity.status(HttpStatus.CREATED).body("User created successfully");
    }
}
复制代码</code></pre> 
<ul><li>我们使用 <code>@Valid</code> 注释来触发 <code>User</code> 对象的验证，并使用 <code>BindingResult</code> 对象来捕获任何验证错误。</li></ul> 
<h3>5 将 i18n 用于错误消息</h3> 
<p>如果你的应用程序支持多种语言，则必须使用国际化 (i18n) 以用户首选语言显示错误消息。</p> 
<p>以下是在 Spring Boot 应用程序中使用 i18n 处理错误消息的示例</p> 
<ol><li>首先，在资源目录下创建一个包含默认错误消息的 <code>messages.properties</code> 文件</li></ol> 
<pre><code># messages.properties
user.name.required=Name is required.
user.email.invalid=Invalid email format.
user.age.invalid=Age must be a number between 18 and 99.
复制代码</code></pre> 
<ol><li>接下来，为每种支持的语言创建一个 <code>messages_xx.properties</code> 文件，例如，中文的 <code>messages_zh_CN.properties</code>。</li></ol> 
<pre><code>user.name.required=名称不能为空.
user.email.invalid=无效的email格式.
user.age.invalid=年龄必须在18到99岁之间.
复制代码</code></pre> 
<ol><li>然后，更新您的验证注释以使用本地化的错误消息</li></ol> 
<pre><code>public class User {
    @NotNull(message = "{user.id.required}")
    private Long id;

    @NotBlank(message = "{user.name.required}")
    private String name;

    @Email(message = "{user.email.invalid}")
    private String email;

    @NotNull(message = "{user.age.required}")
    @Min(value = 18, message = "{user.age.invalid}")
    @Max(value = 99, message = "{user.age.invalid}")
    private Integer age;
}
复制代码</code></pre> 
<ol><li>最后，在 Spring 配置文件中配置 <code>MessageSource bean</code> 以加载 <code>i18n</code> 消息文件</li></ol> 
<pre><code>@Configuration
public class AppConfig {
    @Bean
    public MessageSource messageSource() {
        ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
        messageSource.setBasename("messages");
        messageSource.setDefaultEncoding("UTF-8");
        return messageSource;
    }

    @Bean
    public LocalValidatorFactoryBean validator() {
        LocalValidatorFactoryBean validatorFactoryBean = new LocalValidatorFactoryBean();
        validatorFactoryBean.setValidationMessageSource(messageSource());
        return validatorFactoryBean;
    }
}
复制代码</code></pre> 
<ol><li>现在，当发生验证错误时，错误消息将根据随请求发送的“Accept-Language”标头以用户的首选语言显示。</li></ol> 
<h3>6 使用分组验证</h3> 
<p>验证组是 Spring Boot 验证框架的一个强大功能，允许您根据其他输入值或应用程序状态应用条件验证规则。</p> 
<p>现在有一个包含三个字段的<code>User</code>类的情况下：<code>firstName</code>、<code>lastName</code>和<code>email</code>。我们要确保如果 <code>email</code> 字段为空，则 <code>firstName</code> 或 <code>lastName</code> 字段必须非空。否则，所有三个字段都应该正常验证。</p> 
<p>为此，我们将定义两个验证组：<code>EmailNotEmpty</code> 和 <code>Default</code>。<code>EmailNotEmpty</code> 组将包含当 <code>email</code> 字段不为空时的验证规则，而 <code>Default</code> 组将包含所有三个字段的正常验证规则。</p> 
<ol><li>创建带有验证组的 <code>User</code> 类</li></ol> 
<pre><code>public class User {
    @NotBlank(groups = Default.class)
    private String firstName;

    @NotBlank(groups = Default.class)
    private String lastName;

    @Email(groups = EmailNotEmpty.class)
    private String email;

    // getters and setters omitted for brevity
    public interface EmailNotEmpty {}
    public interface Default {}
}
复制代码</code></pre> 
<ul><li>请注意，我们在<code>User</code>类中定义了两个接口，<code>EmailNotEmpty</code>和 <code>Default</code>。这些将作为我们的验证组。</li></ul> 
<ol><li>接下来，我们更新<code>Controller</code>使用这些验证组</li></ol> 
<pre><code>@RestController
@RequestMapping("/users")
@Validated
public class UserController {
    public ResponseEntity&lt;String&gt; createUser(
            @Validated({org.example.model.ex6.User.EmailNotEmpty.class}) @RequestBody User userWithEmail,
            @Validated({User.Default.class}) @RequestBody User userWithoutEmail)
    {
        // Create the user and return a success response
       
    }
}
复制代码</code></pre> 
<ul><li>我们已将<code>@Validated</code>注释添加到我们的控制器，表明我们想要使用验证组。我们还更新了 <code>createUser</code> 方法，将两个 <code>User</code> 对象作为输入，一个在 <code>email</code> 字段不为空时使用，另一个在它为空时使用。</li><li><code>@Validated</code> 注释用于指定将哪个验证组应用于每个 <code>User</code> 对象。对于 <code>userWithEmail</code> 参数，我们指定了 <code>EmailNotEmpty</code> 组，而对于 <code>userWithoutEmail</code> 参数，我们指定了 <code>Default</code> 组。</li></ul> 
<ol><li>进行这些更改后，现在将根据“电子邮件”字段是否为空对“用户”类进行不同的验证。如果为空，则 <code>firstName</code> 或 <code>lastName</code> 字段必须非空。否则，所有三个字段都将正常验证。</li></ol> 
<h3>7 对复杂逻辑使用跨域验证</h3> 
<p>如果需要验证跨多个字段的复杂输入规则，可以使用跨字段验证来保持验证逻辑的组织性和可维护性。跨字段验证可确保所有输入值均有效且彼此一致，从而防止出现意外行为。</p> 
<p>假设我们有一个表单，用户可以在其中输入任务的开始日期和结束日期，并且我们希望确保结束日期不早于开始日期。我们可以使用跨域验证来实现这一点。</p> 
<ol><li>首先，我们定义一个自定义验证注解<code>EndDateAfterStartDate</code>：</li></ol> 
<pre><code>@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = EndDateAfterStartDateValidator.class)
public @interface EndDateAfterStartDate {
    String message() default "End date must be after start date";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}
复制代码</code></pre> 
<ol><li>然后，我们创建验证器<code>EndDateAfterStartDateValidator</code>：</li></ol> 
<pre><code>public class EndDateAfterStartDateValidator implements ConstraintValidator&lt;EndDateAfterStartDate, TaskForm&gt; {
    @Override
    public boolean isValid(TaskForm taskForm, ConstraintValidatorContext context) {
        if (taskForm.getStartDate() == null || taskForm.getEndDate() == null) {
            return true;
        }

        return taskForm.getEndDate().isAfter(taskForm.getStartDate());
    }
}
复制代码</code></pre> 
<ol><li>最后，我们将<code>EndDateAfterStartDate</code>注释应用于我们的表单对象<code>TaskForm</code>：</li></ol> 
<pre><code>@EndDateAfterStartDate
public class TaskForm {
    @NotNull
    @DateTimeFormat(pattern = "yyyy-MM-dd")
    private LocalDate startDate;

    @NotNull
    @DateTimeFormat(pattern = "yyyy-MM-dd")
    private LocalDate endDate;
}
复制代码</code></pre> 
<p>现在，当用户提交表单时，验证框架将自动检查结束日期是否晚于开始日期，如果不是，则提供有意义的错误消息。</p> 
<h3>8 对验证错误使用异常处理</h3> 
<p>可以使用异常处理<code>ExceptionHandler</code>来统一捕获和处理验证错误。</p> 
<p>以下是如何在 Spring Boot 中使用异常处理来处理验证错误的示例：</p> 
<pre><code>@RestControllerAdvice
public class RestExceptionHandler extends ResponseEntityExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    protected ResponseEntity&lt;Object&gt; handleMethodArgumentNotValid(MethodArgumentNotValidException ex,
                                                                  HttpHeaders headers, HttpStatus status,
                                                                  WebRequest request) {
        Map&lt;String, Object&gt; body = new LinkedHashMap&lt;&gt;();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", status.value());

        // Get all errors
        List&lt;String&gt; errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(x -&gt; x.getDefaultMessage())
                .collect(Collectors.toList());

        body.put("errors", errors);

        return new ResponseEntity&lt;&gt;(body, headers, status);
    }
}
复制代码</code></pre> 
<p>在这里，我们创建了一个用 <code>@RestControllerAdvice</code> 注解的 <code>RestExceptionHandler</code> 类来处理我们的 REST API 抛出的异常。然后我们创建一个用<code> @ExceptionHandler </code>注解的方法来处理在验证失败时抛出的 <code>MethodArgumentNotValidException</code>。</p> 
<p>在处理程序方法中，我们创建了一个 <code>Map</code> 对象来保存错误响应的详细信息，包括时间戳、HTTP 状态代码和错误消息列表。我们使用 <code>MethodArgumentNotValidException</code> 对象的 <code>getBindingResult()</code> 方法获取所有验证错误并将它们添加到错误消息列表中。</p> 
<p>最后，我们返回一个包含错误响应详细信息的<code>ResponseEntity</code>对象，包括作为响应主体的错误消息列表、HTTP 标头和 HTTP 状态代码。</p> 
<p>有了这个异常处理代码，我们的 REST API 抛出的任何验证错误都将被捕获并以结构化和有意义的格式返回给用户，从而更容易理解和解决问题。</p> 
<h3>9 测试你的验证逻辑</h3> 
<p>需要为你的验证逻辑编写单元测试，以帮助确保它正常工作。</p> 
<pre><code>@DataJpaTest
public class UserValidationTest {

    @Autowired
    private TestEntityManager entityManager;

    @Autowired
    private Validator validator;

    @Test
    public void testValidation() {
        User user = new User();
        user.setFirstName("John");
        user.setLastName("Doe");
        user.setEmail("invalid email");

        Set&lt;ConstraintViolation&lt;User&gt;&gt; violations = validator.validate(user);

        assertEquals(1, violations.size());
        assertEquals("must be a well-formed email address", violations.iterator().next().getMessage());
    }
}
复制代码</code></pre> 
<p>我们使用 JUnit 5 编写一个测试来验证具有无效电子邮件地址的“用户”对象。然后我们使用 <code>Validator</code> 接口来验证 <code>User</code> 对象并检查是否返回了预期的验证错误。</p> 
<h3>10 考虑客户端验证</h3> 
<p>客户端验证可以通过向用户提供即时反馈并减少对服务器的请求数量来改善用户体验。但是，不应依赖它作为验证输入的唯一方法。客户端验证很容易被绕过或操纵，因此必须在服务器端验证输入，以确保安全性和数据完整性。</p> 
<p></p> 
<h3>总结</h3> 
<p>有效的验证对于任何 Web 应用程序的稳定性和安全性都是必不可少的。Spring Boot 提供了一套工具和库来简化验证逻辑并使其更易于维护。通过遵循本文中讨论的最佳实践，您可以确保您的验证组件有效并提供出色的用户体验。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b0851b885dc9a4f2b224dfe23b734e50/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端面试题整理（Vue篇）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/79acf5d77cf0542fd75d779753a389c7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MongoDB统一数据查询钩子</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>