<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>sprintf 的详细用法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="sprintf 的详细用法" />
<meta property="og:description" content="sprintf 的详细用法
----转自网络
在将各种类型的数据构造成字符串时， sprintf 的强大功能很少会让你失望。由于 sprintf 跟 printf 在用法上几乎一样，只是打印的目的地不同而已，前者打印到字符串中，后者则直接在命令行上输出。这也导致 sprintf 比 printf 有用得多。 sprintf 是个变参函数，定义如下： int sprintf( char *buffer, const char *format [, argument] ... );
除了前两个参数类型固定外，后面可以接任意多个参数。而它的精华，显然就在第二个参数： 格式化字符串上。 printf 和 sprintf 都使用格式化字符串来指定串的格式，在格式串内部使用一些以“ % ”开头的格式说明符（ format specifications ）来占据一个位置，在后边的变参列表中提供相应的变量，最终函数就会用相应位置的变量来替代那个说明符，产生一个调用者想要的字符串。 格式化数字字符串
sprintf 最常见的应用之一莫过于把整数打印到字符串中，所以， spritnf 在大多数场合可以替代 itoa 。 如： // 把整数 123 打印成一个字符串保存在 s 中。 sprintf(s, &#34;%d&#34;, 123); // 产生 &#34;123&#34;
可以指定宽度，不足的左边补空格： sprintf(s, &#34;%8d%8d&#34;, 123, 4567); // 产生： &#34; 123 4567&#34;
当然也可以左对齐： sprintf(s, &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/da909a42b988937f706627c03f1c4e6e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2007-06-14T23:06:00+08:00" />
<meta property="article:modified_time" content="2007-06-14T23:06:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">sprintf 的详细用法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>                             sprintf 的详细用法</p> 
<p>                                          ----转自网络</p> 
<div> 
 <span style="FONT-SIZE: 9.5pt">    在将各种类型的数据构造成字符串时，</span> 
 <span style="FONT-SIZE: 9.5pt">sprintf </span> 
 <span style="FONT-SIZE: 9.5pt">的强大功能很少会让你失望。由于</span> 
 <span style="FONT-SIZE: 9.5pt">sprintf </span> 
 <span style="FONT-SIZE: 9.5pt">跟</span> 
 <span style="FONT-SIZE: 9.5pt">printf </span> 
 <span style="FONT-SIZE: 9.5pt">在用法上几乎一样，只是打印的目的地不同而已，前者打印到字符串中，后者则直接在命令行上输出。这也导致</span> 
 <span style="FONT-SIZE: 9.5pt">sprintf </span> 
 <span style="FONT-SIZE: 9.5pt">比</span> 
 <span style="FONT-SIZE: 9.5pt">printf </span> 
 <span style="FONT-SIZE: 9.5pt">有用得多。</span> 
</div> 
<div> 
 <span style="FONT-SIZE: 9.5pt">sprintf </span> 
 <span style="FONT-SIZE: 9.5pt">是个变参函数，定义如下：</span> 
 <span style="FONT-SIZE: 9.5pt"><br><strong>int sprintf( char *buffer, const char *format [, argument] ... );</strong><br></span> 
 <span style="FONT-SIZE: 9.5pt">除了前两个参数类型固定外，后面可以接任意多个参数。而它的精华，显然就在第二个参数：</span> 
 <span style="FONT-SIZE: 9.5pt"><br></span> 
 <span style="FONT-SIZE: 9.5pt">格式化字符串上。</span> 
 <span style="FONT-SIZE: 9.5pt"><br>printf </span> 
 <span style="FONT-SIZE: 9.5pt">和</span> 
 <span style="FONT-SIZE: 9.5pt">sprintf </span> 
 <span style="FONT-SIZE: 9.5pt">都使用格式化字符串来指定串的格式，在格式串内部使用一些以“</span> 
 <span style="FONT-SIZE: 9.5pt">%</span> 
 <span style="FONT-SIZE: 9.5pt">”开头的格式说明符（</span> 
 <span style="FONT-SIZE: 9.5pt">format specifications</span> 
 <span style="FONT-SIZE: 9.5pt">）来占据一个位置，在后边的变参列表中提供相应的变量，最终函数就会用相应位置的变量来替代那个说明符，产生一个调用者想要的字符串。</span> 
</div> 
<div> 
 <span style="FONT-SIZE: 9.5pt">    </span> 
</div> 
<div> 
 <span style="FONT-SIZE: 9.5pt"></span> 
</div> 
<div> 
 <span style="FONT-SIZE: 9.5pt"></span> 
</div> 
<div> 
 <strong>格式化数字字符串<br></strong> 
 <span style="FONT-SIZE: 9.5pt">sprintf </span> 
 <span style="FONT-SIZE: 9.5pt">最常见的应用之一莫过于把整数打印到字符串中，所以，</span> 
 <span style="FONT-SIZE: 9.5pt">spritnf </span> 
 <span style="FONT-SIZE: 9.5pt">在大多数场合可以替代</span> 
 <span style="FONT-SIZE: 9.5pt">itoa</span> 
 <span style="FONT-SIZE: 9.5pt">。</span> 
</div> 
<div> 
 <span style="FONT-SIZE: 9.5pt">如：</span> 
 <span style="FONT-SIZE: 9.5pt"><br>//</span> 
 <span style="FONT-SIZE: 9.5pt">把整数</span> 
 <span style="FONT-SIZE: 9.5pt">123 </span> 
 <span style="FONT-SIZE: 9.5pt">打印成一个字符串保存在</span> 
 <span style="FONT-SIZE: 9.5pt">s </span> 
 <span style="FONT-SIZE: 9.5pt">中。</span> 
 <span style="FONT-SIZE: 9.5pt"><br>sprintf(s, "%d", 123); //</span> 
 <span style="FONT-SIZE: 9.5pt">产生</span> 
 <span style="FONT-SIZE: 9.5pt">"123"<br></span> 
 <span style="FONT-SIZE: 9.5pt">可以指定宽度，不足的左边补空格：</span> 
 <span style="FONT-SIZE: 9.5pt"><br>sprintf(s, "%8d%8d", 123, 4567); //</span> 
 <span style="FONT-SIZE: 9.5pt">产生：</span> 
 <span style="FONT-SIZE: 9.5pt">" 123 4567"<br></span> 
 <span style="FONT-SIZE: 9.5pt">当然也可以左对齐：</span> 
 <span style="FONT-SIZE: 9.5pt"><br>sprintf(s, "%-8d%8d", 123, 4567); //</span> 
 <span style="FONT-SIZE: 9.5pt">产生：</span> 
 <span style="FONT-SIZE: 9.5pt">"123 4567"<br></span> 
 <span style="FONT-SIZE: 9.5pt">也可以按照</span> 
 <span style="FONT-SIZE: 9.5pt">16 </span> 
 <span style="FONT-SIZE: 9.5pt">进制打印：</span> 
 <span style="FONT-SIZE: 9.5pt"><br>sprintf(s, "%8x", 4567); //</span> 
 <span style="FONT-SIZE: 9.5pt">小写</span> 
 <span style="FONT-SIZE: 9.5pt">16 </span> 
 <span style="FONT-SIZE: 9.5pt">进制，宽度占</span> 
 <span style="FONT-SIZE: 9.5pt">8 </span> 
 <span style="FONT-SIZE: 9.5pt">个位置，右对齐</span> 
 <span style="FONT-SIZE: 9.5pt"><br>sprintf(s, "%-8X", 4568); //</span> 
 <span style="FONT-SIZE: 9.5pt">大写</span> 
 <span style="FONT-SIZE: 9.5pt">16 </span> 
 <span style="FONT-SIZE: 9.5pt">进制，宽度占</span> 
 <span style="FONT-SIZE: 9.5pt">8 </span> 
 <span style="FONT-SIZE: 9.5pt">个位置，左对齐</span> 
</div> 
<div> 
 <span style="FONT-SIZE: 9.5pt">这样，一个整数的</span> 
 <span style="FONT-SIZE: 9.5pt">16 </span> 
 <span style="FONT-SIZE: 9.5pt">进制字符串就很容易得到，但我们在打印</span> 
 <span style="FONT-SIZE: 9.5pt">16 </span> 
 <span style="FONT-SIZE: 9.5pt">进制内容时，通常想要一种左边补</span> 
 <span style="FONT-SIZE: 9.5pt">0 </span> 
 <span style="FONT-SIZE: 9.5pt">的等宽格式，那该怎么做呢？很简单，在表示宽度的数字前面加个</span> 
 <span style="FONT-SIZE: 9.5pt">0 </span> 
 <span style="FONT-SIZE: 9.5pt">就可以了。</span> 
 <span style="FONT-SIZE: 9.5pt"><br>sprintf(s, "%08X", 4567); //</span> 
 <span style="FONT-SIZE: 9.5pt">产生：</span> 
 <span style="FONT-SIZE: 9.5pt">"000011D7"<br></span> 
 <span style="FONT-SIZE: 9.5pt">上面以”</span> 
 <span style="FONT-SIZE: 9.5pt">%d</span> 
 <span style="FONT-SIZE: 9.5pt">”进行的</span> 
 <span style="FONT-SIZE: 9.5pt">10 </span> 
 <span style="FONT-SIZE: 9.5pt">进制打印同样也可以使用这种左边补</span> 
 <span style="FONT-SIZE: 9.5pt">0 </span> 
 <span style="FONT-SIZE: 9.5pt">的方式。</span> 
</div> 
<div> 
 <span style="FONT-SIZE: 9.5pt"><br></span> 
 <span style="FONT-SIZE: 9.5pt">这里要注意一个符号扩展的问题：比如，假如我们想打印短整数（</span> 
 <span style="FONT-SIZE: 9.5pt">short</span> 
 <span style="FONT-SIZE: 9.5pt">）</span> 
 <span style="FONT-SIZE: 9.5pt">-1 </span> 
 <span style="FONT-SIZE: 9.5pt">的内存</span> 
 <span style="FONT-SIZE: 9.5pt">16 </span> 
 <span style="FONT-SIZE: 9.5pt">进制表示形式，在</span> 
 <span style="FONT-SIZE: 9.5pt">Win32 </span> 
 <span style="FONT-SIZE: 9.5pt">平台上，一个</span> 
 <span style="FONT-SIZE: 9.5pt">short </span> 
 <span style="FONT-SIZE: 9.5pt">型占</span> 
 <span style="FONT-SIZE: 9.5pt">2 </span> 
 <span style="FONT-SIZE: 9.5pt">个字节，所以我们自然希望用</span> 
 <span style="FONT-SIZE: 9.5pt">4 </span> 
 <span style="FONT-SIZE: 9.5pt">个</span> 
 <span style="FONT-SIZE: 9.5pt">16 </span> 
 <span style="FONT-SIZE: 9.5pt">进制数字来打印它：</span> 
 <span style="FONT-SIZE: 9.5pt"><br>short si = -1;<br>sprintf(s, "%04X", si);<br></span> 
 <span style="FONT-SIZE: 9.5pt">产生“</span> 
 <span style="FONT-SIZE: 9.5pt">FFFFFFFF</span> 
 <span style="FONT-SIZE: 9.5pt">”，怎么回事？因为</span> 
 <span style="FONT-SIZE: 9.5pt">spritnf </span> 
 <span style="FONT-SIZE: 9.5pt">是个变参函数，除了前面两个参数之外，后面的参数都不是类型安全的，函数更没有办法仅仅通过一个“</span> 
 <span style="FONT-SIZE: 9.5pt">%X</span> 
 <span style="FONT-SIZE: 9.5pt">”就能得知当初函数调用前参数压栈时被压进来的到底是个</span> 
 <span style="FONT-SIZE: 9.5pt">4 </span> 
 <span style="FONT-SIZE: 9.5pt">字节的整数还是个</span> 
 <span style="FONT-SIZE: 9.5pt">2 </span> 
 <span style="FONT-SIZE: 9.5pt">字节的短整数，所以采取了统一</span> 
 <span style="FONT-SIZE: 9.5pt">4 </span> 
 <span style="FONT-SIZE: 9.5pt">字节的处理方式，导致参数压栈时做了符号扩展，扩展成了</span> 
 <span style="FONT-SIZE: 9.5pt">32 </span> 
 <span style="FONT-SIZE: 9.5pt">位的整数</span> 
 <span style="FONT-SIZE: 9.5pt">-1</span> 
 <span style="FONT-SIZE: 9.5pt">，打印时</span> 
 <span style="FONT-SIZE: 9.5pt">4 </span> 
 <span style="FONT-SIZE: 9.5pt">个位置不够了，就把</span> 
 <span style="FONT-SIZE: 9.5pt">32 </span> 
 <span style="FONT-SIZE: 9.5pt">位整数</span> 
 <span style="FONT-SIZE: 9.5pt">-1 </span> 
 <span style="FONT-SIZE: 9.5pt">的</span> 
 <span style="FONT-SIZE: 9.5pt">8 </span> 
 <span style="FONT-SIZE: 9.5pt">位</span> 
 <span style="FONT-SIZE: 9.5pt">16 </span> 
 <span style="FONT-SIZE: 9.5pt">进制都打印出来了。</span> 
</div> 
<div> 
 <span style="FONT-SIZE: 9.5pt">如果你想看</span> 
 <span style="FONT-SIZE: 9.5pt">si </span> 
 <span style="FONT-SIZE: 9.5pt">的本来面目，那么就应该让编译器做</span> 
 <span style="FONT-SIZE: 9.5pt">0 </span> 
 <span style="FONT-SIZE: 9.5pt">扩展而不是符号扩展（扩展时二进制左边补</span> 
 <span style="FONT-SIZE: 9.5pt">0 </span> 
 <span style="FONT-SIZE: 9.5pt">而不是补符号位）：</span> 
 <span style="FONT-SIZE: 9.5pt"><br>sprintf(s, "%04X", (unsigned short)si);<br></span> 
 <span style="FONT-SIZE: 9.5pt">就可以了。或者：</span> 
 <span style="FONT-SIZE: 9.5pt"><br>unsigned short si = -1;<br>sprintf(s, "%04X", si); </span> 
</div> 
<span style="FONT-SIZE: 9.5pt"> 
 <div> 
  <span lang="EN-US" style="FONT-SIZE: 9.5pt; FONT-FAMILY: Verdana; mso-fareast-font-family: 宋体; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA">sprintf </span> 
  <span style="FONT-SIZE: 9.5pt; FONT-FAMILY: 宋体; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">和</span> 
  <span lang="EN-US" style="FONT-SIZE: 9.5pt; FONT-FAMILY: Verdana; mso-fareast-font-family: 宋体; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA">printf </span> 
  <span style="FONT-SIZE: 9.5pt; FONT-FAMILY: 宋体; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">还可以按</span> 
  <span lang="EN-US" style="FONT-SIZE: 9.5pt; FONT-FAMILY: Verdana; mso-fareast-font-family: 宋体; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA">8 </span> 
  <span style="FONT-SIZE: 9.5pt; FONT-FAMILY: 宋体; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">进制打印整数字符串，使用”</span> 
  <span lang="EN-US" style="FONT-SIZE: 9.5pt; FONT-FAMILY: Verdana; mso-fareast-font-family: 宋体; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA">%o</span> 
  <span style="FONT-SIZE: 9.5pt; FONT-FAMILY: 宋体; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">”。注意</span> 
  <span lang="EN-US" style="FONT-SIZE: 9.5pt; FONT-FAMILY: Verdana; mso-fareast-font-family: 宋体; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA">8 </span> 
  <span style="FONT-SIZE: 9.5pt; FONT-FAMILY: 宋体; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">进制和</span> 
  <span lang="EN-US" style="FONT-SIZE: 9.5pt; FONT-FAMILY: Verdana; mso-fareast-font-family: 宋体; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA">16 </span> 
  <span style="FONT-SIZE: 9.5pt; FONT-FAMILY: 宋体; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">进制都不会打</span> 
  <span lang="EN-US" style="FONT-SIZE: 9.5pt; FONT-FAMILY: Verdana; mso-fareast-font-family: 宋体; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA"><br></span> 
  <span style="FONT-SIZE: 9.5pt; FONT-FAMILY: 宋体; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">印出负数，都是无符号的，实际上也就是变量的内部编码的直接的</span> 
  <span lang="EN-US" style="FONT-SIZE: 9.5pt; FONT-FAMILY: Verdana; mso-fareast-font-family: 宋体; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA">16 </span> 
  <span style="FONT-SIZE: 9.5pt; FONT-FAMILY: 宋体; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">进制或</span> 
  <span lang="EN-US" style="FONT-SIZE: 9.5pt; FONT-FAMILY: Verdana; mso-fareast-font-family: 宋体; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA">8 </span> 
  <span style="FONT-SIZE: 9.5pt; FONT-FAMILY: 宋体; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">进制表示。</span> 
 </div> 
 <div> 
  <span style="FONT-SIZE: 9.5pt; FONT-FAMILY: 宋体; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">  </span> 
 </div> 
 <div> 
  <span style="FONT-SIZE: 9.5pt; FONT-FAMILY: 宋体; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana"></span> 
 </div> 
 <div> 
  <span style="FONT-SIZE: 9.5pt"></span> 
 </div> 
 <div> 
  <strong>控制浮点数打印格式<br></strong> 
  <span style="FONT-SIZE: 9.5pt">浮点数的打印和格式控制是</span> 
  <span style="FONT-SIZE: 9.5pt">sprintf </span> 
  <span style="FONT-SIZE: 9.5pt">的又一大常用功能，浮点数使用格式符”</span> 
  <span style="FONT-SIZE: 9.5pt">%f</span> 
  <span style="FONT-SIZE: 9.5pt">”控制，默认保留小数点后</span> 
  <span style="FONT-SIZE: 9.5pt">6 </span> 
  <span style="FONT-SIZE: 9.5pt">位数字，比如：</span> 
  <span style="FONT-SIZE: 9.5pt"><br>sprintf(s, "%f", 3.1415926); //</span> 
  <span style="FONT-SIZE: 9.5pt">产生</span> 
  <span style="FONT-SIZE: 9.5pt">"3.141593"<br></span> 
  <span style="FONT-SIZE: 9.5pt">但有时我们希望自己控制打印的宽度和小数位数，这时就应该使用：”</span> 
  <span style="FONT-SIZE: 9.5pt">%m.nf</span> 
  <span style="FONT-SIZE: 9.5pt">”格式，其中</span> 
  <span style="FONT-SIZE: 9.5pt">m </span> 
  <span style="FONT-SIZE: 9.5pt">表示打印的宽度，</span> 
  <span style="FONT-SIZE: 9.5pt">n </span> 
  <span style="FONT-SIZE: 9.5pt">表示小数点后的位数。比如：</span> 
  <span style="FONT-SIZE: 9.5pt"><br>sprintf(s, "%10.3f", 3.1415626); //</span> 
  <span style="FONT-SIZE: 9.5pt">产生：</span> 
  <span style="FONT-SIZE: 9.5pt">" 3.142"<br>sprintf(s, "%-10.3f", 3.1415626); //</span> 
  <span style="FONT-SIZE: 9.5pt">产生：</span> 
  <span style="FONT-SIZE: 9.5pt">"3.142 "<br>sprintf(s, "%.3f", 3.1415626); //</span> 
  <span style="FONT-SIZE: 9.5pt">不指定总宽度，产生：</span> 
  <span style="FONT-SIZE: 9.5pt">"3.142"</span> 
 </div> 
 <div> 
  <span style="FONT-SIZE: 9.5pt">注意一个问题，你猜</span> 
  <span style="FONT-SIZE: 9.5pt"><br>int i = 100;<br>sprintf(s, "%.2f", i);<br></span> 
  <span style="FONT-SIZE: 9.5pt">会打出什么东东来？“</span> 
  <span style="FONT-SIZE: 9.5pt">100.00</span> 
  <span style="FONT-SIZE: 9.5pt">”？对吗？自己试试就知道了，同时也试试下面这个：</span> 
  <span style="FONT-SIZE: 9.5pt"><br>sprintf(s, "%.2f", (double)i);<br></span> 
  <span style="FONT-SIZE: 9.5pt">第一个打出来的肯定不是正确结果，原因跟前面提到的一样，参数压栈时调用者并不知道跟</span> 
  <span style="FONT-SIZE: 9.5pt">i</span> 
  <span style="FONT-SIZE: 9.5pt">相对应的格式控制符是个”</span> 
  <span style="FONT-SIZE: 9.5pt">%f</span> 
  <span style="FONT-SIZE: 9.5pt">”。而函数执行时函数本身则并不知道当年被压入栈里的是个整数，于是可怜的保存整数</span> 
  <span style="FONT-SIZE: 9.5pt">i </span> 
  <span style="FONT-SIZE: 9.5pt">的那</span> 
  <span style="FONT-SIZE: 9.5pt">4 </span> 
  <span style="FONT-SIZE: 9.5pt">个字节就被不由分说地强行作为浮点数格式来解释了，整个乱套了。不过，如果有人有兴趣使用手工编码一个浮点数，那么倒可以使用这种方法来检验一下你手工编排的结果是否正确。</span> 
 </div> 
 <div> 
  <span style="FONT-SIZE: 9.5pt">  </span> 
 </div> 
 <div> 
  <span style="FONT-SIZE: 9.5pt"></span> 
 </div> 
 <div> 
  <span style="FONT-SIZE: 9.5pt"></span> 
 </div> 
 <div> 
  <strong><span style="FONT-SIZE: 9.5pt">字符</span><span style="FONT-SIZE: 9.5pt">/Ascii </span></strong> 
  <strong>码对照<br></strong> 
  <span style="FONT-SIZE: 9.5pt">我们知道，在</span> 
  <span style="FONT-SIZE: 9.5pt">C/C++</span> 
  <span style="FONT-SIZE: 9.5pt">语言中，</span> 
  <span style="FONT-SIZE: 9.5pt">char </span> 
  <span style="FONT-SIZE: 9.5pt">也是一种普通的</span> 
  <span style="FONT-SIZE: 9.5pt">scalable </span> 
  <span style="FONT-SIZE: 9.5pt">类型，除了字长之外，它与</span> 
  <span style="FONT-SIZE: 9.5pt">short</span> 
  <span style="FONT-SIZE: 9.5pt">，</span> 
  <span style="FONT-SIZE: 9.5pt"><br>int</span> 
  <span style="FONT-SIZE: 9.5pt">，</span> 
  <span style="FONT-SIZE: 9.5pt">long </span> 
  <span style="FONT-SIZE: 9.5pt">这些类型没有本质区别，只不过被大家习惯用来表示字符和字符串而已。（或许当年该把</span> 
  <span style="FONT-SIZE: 9.5pt"><br></span> 
  <span style="FONT-SIZE: 9.5pt">这个类型叫做“</span> 
  <span style="FONT-SIZE: 9.5pt">byte</span> 
  <span style="FONT-SIZE: 9.5pt">”，然后现在就可以根据实际情况，使用</span> 
  <span style="FONT-SIZE: 9.5pt">byte </span> 
  <span style="FONT-SIZE: 9.5pt">或</span> 
  <span style="FONT-SIZE: 9.5pt">short </span> 
  <span style="FONT-SIZE: 9.5pt">来把</span> 
  <span style="FONT-SIZE: 9.5pt">char </span> 
  <span style="FONT-SIZE: 9.5pt">通过</span> 
  <span style="FONT-SIZE: 9.5pt">typedef </span> 
  <span style="FONT-SIZE: 9.5pt">定义出来，这样更合适些）于是，使用”</span> 
  <span style="FONT-SIZE: 9.5pt">%d</span> 
  <span style="FONT-SIZE: 9.5pt">”或者”</span> 
  <span style="FONT-SIZE: 9.5pt">%x</span> 
  <span style="FONT-SIZE: 9.5pt">”打印一个字符，便能得出它的</span> 
  <span style="FONT-SIZE: 9.5pt">10 </span> 
  <span style="FONT-SIZE: 9.5pt">进制或</span> 
  <span style="FONT-SIZE: 9.5pt">16 </span> 
  <span style="FONT-SIZE: 9.5pt">进制的</span> 
  <span style="FONT-SIZE: 9.5pt">ASCII </span> 
  <span style="FONT-SIZE: 9.5pt">码；反过来，使用”</span> 
  <span style="FONT-SIZE: 9.5pt">%c</span> 
  <span style="FONT-SIZE: 9.5pt">”打印一个整数，便可以看到它所对应的</span> 
  <span style="FONT-SIZE: 9.5pt">ASCII </span> 
  <span style="FONT-SIZE: 9.5pt">字符。以下程序段把所有可见字符的</span> 
  <span style="FONT-SIZE: 9.5pt">ASCII </span> 
  <span style="FONT-SIZE: 9.5pt">码对照表打印到屏幕上（这里采用</span> 
  <span style="FONT-SIZE: 9.5pt">printf</span> 
  <span style="FONT-SIZE: 9.5pt">，注意”</span> 
  <span style="FONT-SIZE: 9.5pt">#</span> 
  <span style="FONT-SIZE: 9.5pt">”与”</span> 
  <span style="FONT-SIZE: 9.5pt">%X</span> 
  <span style="FONT-SIZE: 9.5pt">”合用时自动为</span> 
  <span style="FONT-SIZE: 9.5pt">16 </span> 
  <span style="FONT-SIZE: 9.5pt">进制数增加”</span> 
  <span style="FONT-SIZE: 9.5pt">0X</span> 
  <span style="FONT-SIZE: 9.5pt">”前缀）：</span> 
  <span style="FONT-SIZE: 9.5pt"><br>for(int i = 32; i &lt; 127; i++) {<!-- --><br>printf("[ %c ]: %3d 0x%#04X<br>", i, i, i);<br>} </span> 
 </div> 
 <div> 
  <span style="FONT-SIZE: 9.5pt"><br></span> 
  <span style="FONT-SIZE: 9.5pt"><strong>连接字符串</strong></span> 
  <span style="FONT-SIZE: 9.5pt"><br>sprintf </span> 
  <span style="FONT-SIZE: 9.5pt">的格式控制串中既然可以插入各种东西，并最终把它们“连成一串”，自然也就能够连接字符串，从而在许多场合可以替代</span> 
  <span style="FONT-SIZE: 9.5pt">strcat</span> 
  <span style="FONT-SIZE: 9.5pt">，但</span> 
  <span style="FONT-SIZE: 9.5pt">sprintf </span> 
  <span style="FONT-SIZE: 9.5pt">能够一次连接多个字符串（自然也可以同时在它们中间插入别的内容，总之非常灵活）。比如：</span> 
  <span style="FONT-SIZE: 9.5pt"><br>char* who = "I";<br>char* whom = "CSDN";<br>sprintf(s, "%s love %s.", who, whom); //</span> 
  <span style="FONT-SIZE: 9.5pt">产生：</span> 
  <span style="FONT-SIZE: 9.5pt">"I love CSDN. "<br>strcat </span> 
  <span style="FONT-SIZE: 9.5pt">只能连接字符串（一段以’’结尾的字符数组或叫做字符缓冲，</span> 
  <span style="FONT-SIZE: 9.5pt">null-terminated-string</span> 
  <span style="FONT-SIZE: 9.5pt">），但有时我们有两段字符缓冲区，他们并不是以’’结尾。比如许多从第三方库函数中返回的字符数组，从硬件或者网络传输中读进来的字符流，它们未必每一段字符序列后面都有个相应的’’来结尾。如果直接连接，不管是</span> 
  <span style="FONT-SIZE: 9.5pt">sprintf </span> 
  <span style="FONT-SIZE: 9.5pt">还是</span> 
  <span style="FONT-SIZE: 9.5pt">strcat </span> 
  <span style="FONT-SIZE: 9.5pt">肯定会导致非法内存操作，而</span> 
  <span style="FONT-SIZE: 9.5pt">strncat </span> 
  <span style="FONT-SIZE: 9.5pt">也至少要求第一个参数是个</span> 
  <span style="FONT-SIZE: 9.5pt">null-terminated-string</span> 
  <span style="FONT-SIZE: 9.5pt">，那该怎么办呢？我们自然会想起前面介绍打印整数和浮点数时可以指定宽度，字符串也一样的。比如：</span> 
  <span style="FONT-SIZE: 9.5pt"><br>char a1[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};<br>char a2[] = {'H', 'I', 'J', 'K', 'L', 'M', 'N'};<br></span> 
  <span style="FONT-SIZE: 9.5pt">如果：</span> 
  <span style="FONT-SIZE: 9.5pt"><br>sprintf(s, "%s%s", a1, a2); //Don't do that!<br></span> 
  <span style="FONT-SIZE: 9.5pt">十有八九要出问题了。是否可以改成：</span> 
  <span style="FONT-SIZE: 9.5pt"><br>sprintf(s, "%7s%7s", a1, a2);<br></span> 
  <span style="FONT-SIZE: 9.5pt">也没好到哪儿去，正确的应该是：</span> 
  <span style="FONT-SIZE: 9.5pt"><br>sprintf(s, "%.7s%.7s", a1, a2);//</span> 
  <span style="FONT-SIZE: 9.5pt">产生：</span> 
  <span style="FONT-SIZE: 9.5pt">"ABCDEFGHIJKLMN"<br></span> 
  <span style="FONT-SIZE: 9.5pt">这可以类比打印浮点数的”</span> 
  <span style="FONT-SIZE: 9.5pt">%m.nf</span> 
  <span style="FONT-SIZE: 9.5pt">”，在”</span> 
  <span style="FONT-SIZE: 9.5pt">%m.ns</span> 
  <span style="FONT-SIZE: 9.5pt">”中，</span> 
  <span style="FONT-SIZE: 9.5pt">m </span> 
  <span style="FONT-SIZE: 9.5pt">表示占用宽度（字符串长度不足时补空格，超出了则按照实际宽度打印），</span> 
  <span style="FONT-SIZE: 9.5pt">n </span> 
  <span style="FONT-SIZE: 9.5pt">才表示从相应的字符串中最多取用的字符数。通常在打印字符串时</span> 
  <span style="FONT-SIZE: 9.5pt">m </span> 
  <span style="FONT-SIZE: 9.5pt">没什么大用，还是点号后面的</span> 
  <span style="FONT-SIZE: 9.5pt">n </span> 
  <span style="FONT-SIZE: 9.5pt">用的多。自然，也可以前后都只取部分字符：</span> 
  <span style="FONT-SIZE: 9.5pt"><br>sprintf(s, "%.6s%.5s", a1, a2);//</span> 
  <span style="FONT-SIZE: 9.5pt">产生：</span> 
  <span style="FONT-SIZE: 9.5pt">"ABCDEFHIJKL"<br></span> 
  <span style="FONT-SIZE: 9.5pt">在许多时候，我们或许还希望这些格式控制符中用以指定长度信息的数字是动态的，而不是静态指定的，因为许多时候，程序要到运行时才会清楚到底需要取字符数组中的几个字符，这种动态的宽度</span> 
  <span style="FONT-SIZE: 9.5pt">/</span> 
  <span style="FONT-SIZE: 9.5pt">精度设置功能在</span> 
  <span style="FONT-SIZE: 9.5pt">sprintf </span> 
  <span style="FONT-SIZE: 9.5pt">的实现中也被考虑到了，</span> 
  <span style="FONT-SIZE: 9.5pt">sprintf </span> 
  <span style="FONT-SIZE: 9.5pt">采用”</span> 
  <span style="FONT-SIZE: 9.5pt">*</span> 
  <span style="FONT-SIZE: 9.5pt">”来占用一个本来需要一个指定宽度或精度的常数数字的位置，同样，而实际的宽度或精度就可以和其它被打印的变量一样被提供出来，于是，上面的例子可以变成：</span> 
  <span style="FONT-SIZE: 9.5pt"><br>sprintf(s, "%.*s%.*s", 7, a1, 7, a2);<br></span> 
  <span style="FONT-SIZE: 9.5pt">或者：</span> 
  <span style="FONT-SIZE: 9.5pt"><br>sprintf(s, "%.*s%.*s", sizeof(a1), a1, sizeof(a2), a2);<br></span> 
  <span style="FONT-SIZE: 9.5pt">实际上，前面介绍的打印字符、整数、浮点数等都可以动态指定那些常量值，比如：</span> 
  <span style="FONT-SIZE: 9.5pt"><br>sprintf(s, "%-*d", 4, 'A'); //</span> 
  <span style="FONT-SIZE: 9.5pt">产生</span> 
  <span style="FONT-SIZE: 9.5pt">"65 "<br>sprintf(s, "%#0*X", 8, 128); //</span> 
  <span style="FONT-SIZE: 9.5pt">产生</span> 
  <span style="FONT-SIZE: 9.5pt">"0X000080"</span> 
  <span style="FONT-SIZE: 9.5pt">，</span> 
  <span style="FONT-SIZE: 9.5pt">"#"</span> 
  <span style="FONT-SIZE: 9.5pt">产生</span> 
  <span style="FONT-SIZE: 9.5pt">0X<br>sprintf(s, "%*.*f", 10, 2, 3.1415926); //</span> 
  <span style="FONT-SIZE: 9.5pt">产生</span> 
  <span style="FONT-SIZE: 9.5pt">" 3.14" </span> 
 </div> 
 <div> 
  <span style="FONT-SIZE: 9.5pt"><br></span> 
  <strong>打印地址信息<br></strong> 
  <span style="FONT-SIZE: 9.5pt">有时调试程序时，我们可能想查看某些变量或者成员的地址，由于地址或者指针也不过是个</span> 
  <span style="FONT-SIZE: 9.5pt">32 </span> 
  <span style="FONT-SIZE: 9.5pt">位的数，你完全可以使用打印无符号整数的”</span> 
  <span style="FONT-SIZE: 9.5pt">%u</span> 
  <span style="FONT-SIZE: 9.5pt">”把他们打印出来：</span> 
  <span style="FONT-SIZE: 9.5pt"><br>sprintf(s, "%u", &amp;i);<br></span> 
  <span style="FONT-SIZE: 9.5pt">不过通常人们还是喜欢使用</span> 
  <span style="FONT-SIZE: 9.5pt">16 </span> 
  <span style="FONT-SIZE: 9.5pt">进制而不是</span> 
  <span style="FONT-SIZE: 9.5pt">10 </span> 
  <span style="FONT-SIZE: 9.5pt">进制来显示一个地址：</span> 
  <span style="FONT-SIZE: 9.5pt"><br>sprintf(s, "%08X", &amp;i);<br></span> 
  <span style="FONT-SIZE: 9.5pt">然而，这些都是间接的方法，对于地址打印，</span> 
  <span style="FONT-SIZE: 9.5pt">sprintf </span> 
  <span style="FONT-SIZE: 9.5pt">提供了专门的”</span> 
  <span style="FONT-SIZE: 9.5pt">%p</span> 
  <span style="FONT-SIZE: 9.5pt">”：</span> 
  <span style="FONT-SIZE: 9.5pt"><br>sprintf(s, "%p", &amp;i);<br></span> 
  <span style="FONT-SIZE: 9.5pt">我觉得它实际上就相当于：</span> 
  <span style="FONT-SIZE: 9.5pt"><br>sprintf(s, "%0*x", 2 * sizeof(void *), &amp;i);<br></span> 
  <span style="FONT-SIZE: 9.5pt">利用</span> 
  <span style="FONT-SIZE: 9.5pt">sprintf </span> 
  <span style="FONT-SIZE: 9.5pt">的返回值</span> 
  <span style="FONT-SIZE: 9.5pt"><br></span> 
  <span style="FONT-SIZE: 9.5pt">较少有人注意</span> 
  <span style="FONT-SIZE: 9.5pt">printf/sprintf </span> 
  <span style="FONT-SIZE: 9.5pt">函数的返回值，但有时它却是有用的，</span> 
  <span style="FONT-SIZE: 9.5pt">spritnf </span> 
  <span style="FONT-SIZE: 9.5pt">返回了本次函数调用最终打印到字符缓冲区中的字符数目。也就是说每当一次</span> 
  <span style="FONT-SIZE: 9.5pt">sprinf </span> 
  <span style="FONT-SIZE: 9.5pt">调用结束以后，你无须再调用一次</span> 
  <span style="FONT-SIZE: 9.5pt">strlen </span> 
  <span style="FONT-SIZE: 9.5pt">便已经知道了结果字符串的长度。如：</span> 
  <span style="FONT-SIZE: 9.5pt"><br>int len = sprintf(s, "%d", i);<br></span> 
  <span style="FONT-SIZE: 9.5pt">对于正整数来说，</span> 
  <span style="FONT-SIZE: 9.5pt">len </span> 
  <span style="FONT-SIZE: 9.5pt">便等于整数</span> 
  <span style="FONT-SIZE: 9.5pt">i </span> 
  <span style="FONT-SIZE: 9.5pt">的</span> 
  <span style="FONT-SIZE: 9.5pt">10 </span> 
  <span style="FONT-SIZE: 9.5pt">进制位数。</span> 
  <span style="FONT-SIZE: 9.5pt"><br></span> 
  <span style="FONT-SIZE: 9.5pt">下面的是个完整的例子，产生</span> 
  <span style="FONT-SIZE: 9.5pt">10 </span> 
  <span style="FONT-SIZE: 9.5pt">个</span> 
  <span style="FONT-SIZE: 9.5pt">[0, 100)</span> 
  <span style="FONT-SIZE: 9.5pt">之间的随机数，并将他们打印到一个字符数组</span> 
  <span style="FONT-SIZE: 9.5pt">s </span> 
  <span style="FONT-SIZE: 9.5pt">中，</span> 
  <span style="FONT-SIZE: 9.5pt"><br></span> 
  <span style="FONT-SIZE: 9.5pt">以逗号分隔开。</span> 
  <span style="FONT-SIZE: 9.5pt"><br>#include <br>#include <br>#include <br>int main() {<!-- --><br>srand(time(0));<br>char s[64];<br>int offset = 0;<br>for(int i = 0; i &lt; 10; i++) {<!-- --><br>offset += sprintf(s + offset, "%d,", rand() % 100);<br>}<br>s[offset - 1] = '<br>';//</span> 
  <span style="FONT-SIZE: 9.5pt">将最后一个逗号换成换行符。</span> 
  <span style="FONT-SIZE: 9.5pt"><br>printf(s);<br>return 0;<br>}<br></span> 
  <span style="FONT-SIZE: 9.5pt">设想当你从数据库中取出一条记录，然后希望把他们的各个字段按照某种规则连接成一个字符串时，就可以使用这种方法，从理论上讲，他应该比不断的</span> 
  <span style="FONT-SIZE: 9.5pt">strcat </span> 
  <span style="FONT-SIZE: 9.5pt">效率高，因为</span> 
  <span style="FONT-SIZE: 9.5pt">strcat </span> 
  <span style="FONT-SIZE: 9.5pt">每次调用都需要先找到最后的那个’’的位置，而在上面给出的例子中，我们每次都利用</span> 
  <span style="FONT-SIZE: 9.5pt">sprintf </span> 
  <span style="FONT-SIZE: 9.5pt">返回值把这个位置直接记下来了。</span> 
 </div> 
 <div> 
  <span style="FONT-SIZE: 9.5pt"><br></span> 
  <strong><span style="FONT-SIZE: 9.5pt">使用</span><span style="FONT-SIZE: 9.5pt">sprintf </span><span style="FONT-SIZE: 9.5pt">的常见问题</span></strong> 
  <span style="FONT-SIZE: 9.5pt"><br>sprintf </span> 
  <span style="FONT-SIZE: 9.5pt">是个变参函数，使用时经常出问题，而且只要出问题通常就是能导致程序崩溃的内存访问错误，但好在由</span> 
  <span style="FONT-SIZE: 9.5pt">sprintf </span> 
  <span style="FONT-SIZE: 9.5pt">误用导致的问题虽然严重，却很容易找出，无非就是那么几种情况，通常用眼睛再把出错的代码多看几眼就看出来了。</span> 
 </div> 
 <div> 
  <span style="FONT-SIZE: 9.5pt"><br></span> 
  <span style="FONT-SIZE: 9.5pt">缓冲区溢出</span> 
  <span style="FONT-SIZE: 9.5pt"><br></span> 
  <span style="FONT-SIZE: 9.5pt">第一个参数的长度太短了，没的说，给个大点的地方吧。当然也可能是后面的参数的问题，建议变参对应一定要细心，而打印字符串时，尽量使用”</span> 
  <span style="FONT-SIZE: 9.5pt">%.ns</span> 
  <span style="FONT-SIZE: 9.5pt">”的形式指定最大字符数。</span> 
 </div> 
 <div> 
  <span style="FONT-SIZE: 9.5pt"><br></span> 
  <span style="FONT-SIZE: 9.5pt">忘记了第一个参数</span> 
  <span style="FONT-SIZE: 9.5pt"><br></span> 
  <span style="FONT-SIZE: 9.5pt">低级得不能再低级问题，用</span> 
  <span style="FONT-SIZE: 9.5pt">printf </span> 
  <span style="FONT-SIZE: 9.5pt">用得太惯了。</span> 
  <span style="FONT-SIZE: 9.5pt">//</span> 
  <span style="FONT-SIZE: 9.5pt">偶就常犯。：。（</span> 
 </div> 
 <div> 
  <span style="FONT-SIZE: 9.5pt"><br></span> 
  <span style="FONT-SIZE: 9.5pt">变参对应出问题</span> 
  <span style="FONT-SIZE: 9.5pt"><br></span> 
  <span style="FONT-SIZE: 9.5pt">通常是忘记了提供对应某个格式符的变参，导致以后的参数统统错位，检查检查吧。尤其是对应”</span> 
  <span style="FONT-SIZE: 9.5pt">*</span> 
  <span style="FONT-SIZE: 9.5pt">”的那些参数，都提供了吗？不要把一个整数对应一个”</span> 
  <span style="FONT-SIZE: 9.5pt">%s</span> 
  <span style="FONT-SIZE: 9.5pt">”，编译器会觉得你欺她太甚了（编译器是</span> 
  <span style="FONT-SIZE: 9.5pt">obj </span> 
  <span style="FONT-SIZE: 9.5pt">和</span> 
  <span style="FONT-SIZE: 9.5pt">exe </span> 
  <span style="FONT-SIZE: 9.5pt">的妈妈，应该是个女的，</span> 
  <span style="FONT-SIZE: 9.5pt">:P</span> 
  <span style="FONT-SIZE: 9.5pt">）。</span> 
 </div> 
 <div> 
  <span style="FONT-SIZE: 9.5pt">strftime<br>sprnitf </span> 
  <span style="FONT-SIZE: 9.5pt">还有个不错的表妹：</span> 
  <span style="FONT-SIZE: 9.5pt">strftime</span> 
  <span style="FONT-SIZE: 9.5pt">，专门用于格式化时间字符串的，用法跟她表哥很像，也是一大堆格式控制符，只是毕竟小姑娘家心细，她还要调用者指定缓冲区的最大长度，可能是为了在出现问题时可以推卸责任吧。这里举个例子：</span> 
  <span style="FONT-SIZE: 9.5pt"><br>time_t t = time(0);<br>//</span> 
  <span style="FONT-SIZE: 9.5pt">产生</span> 
  <span style="FONT-SIZE: 9.5pt">"YYYY-MM-DD hh:mm:ss"</span> 
  <span style="FONT-SIZE: 9.5pt">格式的字符串。</span> 
  <span style="FONT-SIZE: 9.5pt"><br>char s[32];<br>strftime(s, sizeof(s), "%Y-%m-%d %H:%M:%S", localtime(&amp;t));<br>sprintf </span> 
  <span style="FONT-SIZE: 9.5pt">在</span> 
  <span style="FONT-SIZE: 9.5pt">MFC </span> 
  <span style="FONT-SIZE: 9.5pt">中也能找到他的知音：</span> 
  <span style="FONT-SIZE: 9.5pt">CString::Format</span> 
  <span style="FONT-SIZE: 9.5pt">，</span> 
  <span style="FONT-SIZE: 9.5pt">strftime </span> 
  <span style="FONT-SIZE: 9.5pt">在</span> 
  <span style="FONT-SIZE: 9.5pt">MFC </span> 
  <span style="FONT-SIZE: 9.5pt">中自然也有她的同道：</span> 
  <span style="FONT-SIZE: 9.5pt"><br>CTime::Format</span> 
  <span style="FONT-SIZE: 9.5pt">，这一对由于从面向对象哪里得到了赞助，用以写出的代码更觉优雅。</span> 
 </div> 
 <div>
     
 </div> </span> 
<span style="FONT-SIZE: 9.5pt">和</span> 
<span style="FONT-SIZE: 9.5pt">printf </span> 
<span style="FONT-SIZE: 9.5pt">还可以按</span> 
<span style="FONT-SIZE: 9.5pt">8 </span> 
<span style="FONT-SIZE: 9.5pt">进制打印整数字符串，使用”</span> 
<span style="FONT-SIZE: 9.5pt">%o</span> 
<span style="FONT-SIZE: 9.5pt">”。注意</span> 
<span style="FONT-SIZE: 9.5pt">8 </span> 
<span style="FONT-SIZE: 9.5pt">进制和</span> 
<span style="FONT-SIZE: 9.5pt">16 </span> 
<span style="FONT-SIZE: 9.5pt">进制都不会打</span> 
<span style="FONT-SIZE: 9.5pt"><br></span> 
<span style="FONT-SIZE: 9.5pt">印出负数，都是无符号的，实际上也就是变量的内部编码的直接的</span> 
<span style="FONT-SIZE: 9.5pt">16 </span> 
<span style="FONT-SIZE: 9.5pt">进制或</span> 
<span style="FONT-SIZE: 9.5pt">8 </span> 
<span style="FONT-SIZE: 9.5pt">进制表示。</span>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f77882156f1a08df97a46950c649912d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SharpMap AjaxMapControl 中 Zoomin/Zoomout 操作时冻结问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a6b61bdde03fbb9578537f238138bbfd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">通过早期测试弥补不规范软件开发带来的风险</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>