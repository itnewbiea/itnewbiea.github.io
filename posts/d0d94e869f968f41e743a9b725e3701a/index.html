<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>在ReactJS中正确修改状态数组 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="在ReactJS中正确修改状态数组" />
<meta property="og:description" content="本文翻译自：Correct modification of state arrays in ReactJS
I want to add an element to the end of a state array, is this the correct way to do it? 我想在state数组的末尾添加一个元素，这是正确的方法吗？ this.state.arrayvar.push(newelement); this.setState({arrayvar:this.state.arrayvar}); I am concerned that modifying the array in-place with push might cause trouble - is it safe? 我担心通过push就地修改数组可能会引起麻烦-是否安全？ The alternative of making a copy of the array, and setState ing that seems wasteful. 复制数组和setState替代方法似乎很浪费。 #1楼 参考：https://stackoom.com/question/1m9h9/在ReactJS中正确修改状态数组
#2楼 The React docs says: React文档说： Treat this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d0d94e869f968f41e743a9b725e3701a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-06T10:04:31+08:00" />
<meta property="article:modified_time" content="2020-06-06T10:04:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">在ReactJS中正确修改状态数组</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本文翻译自：<a href="https://oldbug.net/q/1m9h9/Correct-modification-of-state-arrays-in-ReactJS" rel="nofollow">Correct modification of state arrays in ReactJS</a></p> 
<p> <i>I want to add an element to the end of a <code>state</code> array, is this the correct way to do it?</i> <b>我想在<code>state</code>数组的末尾添加一个元素，这是正确的方法吗？</b> </p> 
<pre><code>this.state.arrayvar.push(newelement);
this.setState({arrayvar:this.state.arrayvar});
</code></pre> 
<p> <i>I am concerned that modifying the array in-place with <code>push</code> might cause trouble - is it safe?</i> <b>我担心通过<code>push</code>就地修改数组可能会引起麻烦-是否安全？</b> </p> 
<p> <i>The alternative of making a copy of the array, and <code>setState</code> ing that seems wasteful.</i> <b>复制数组和<code>setState</code>替代方法似乎很浪费。</b> </p> 
<hr> 
<h4>#1楼</h4> 
<p>参考：<a href="https://stackoom.com/question/1m9h9/%E5%9C%A8ReactJS%E4%B8%AD%E6%AD%A3%E7%A1%AE%E4%BF%AE%E6%94%B9%E7%8A%B6%E6%80%81%E6%95%B0%E7%BB%84" rel="nofollow">https://stackoom.com/question/1m9h9/在ReactJS中正确修改状态数组</a></p> 
<hr> 
<h4>#2楼</h4> 
<p> <i>The <a href="http://facebook.github.io/react/docs/component-api.html" rel="nofollow">React docs</a> says:</i> <b><a href="http://facebook.github.io/react/docs/component-api.html" rel="nofollow">React文档</a>说：</b> </p> 
<blockquote> 
 <p> <i>Treat this.state as if it were immutable.</i> <b>将this.state视为不可变的。</b> </p> 
</blockquote> 
<p> <i>Your <code>push</code> will mutate the state directly and that could potentially lead to error prone code, even if you are "resetting" the state again afterwards.</i> <b>您的<code>push</code>将直接改变状态，即使您此后再次“重置”状态，也有可能导致易于出错的代码。</b> <i>F.ex, it could lead to that some lifecycle methods like <code>componentDidUpdate</code> won't trigger.</i> <b>例如，它可能导致某些生命周期方法（例如<code>componentDidUpdate</code>不会触发。</b> </p> 
<p> <i>The recommended approach in later React versions is to use an <em>updater</em> function when modifying states to prevent race conditions:</i> <b>在更高版本的React中，建议的方法是在修改状态以防止竞争情况时使用<em>updater</em>函数：</b> </p> 
<pre><code>this.setState(prevState =&gt; ({
  arrayvar: [...prevState.arrayvar, newelement]
}))
</code></pre> 
<p> <i>The memory "waste" is not an issue compared to the errors you might face using non-standard state modifications.</i> <b>与使用非标准状态修改可能会遇到的错误相比，内存“浪费”不是问题。</b> </p> 
<p> <i><strong>Alternative syntax for earlier React versions</strong></i> <b><strong>早期React版本的替代语法</strong></b> </p> 
<p> <i>You can use <code>concat</code> to get a clean syntax since it returns a new array:</i> <b>您可以使用<code>concat</code>获得干净的语法，因为它返回一个新数组：</b> </p> 
<pre><code>this.setState({ 
  arrayvar: this.state.arrayvar.concat([newelement])
})
</code></pre> 
<p> <i>In ES6 you can use the <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator" rel="nofollow">Spread Operator</a> :</i> <b>在ES6中，您可以使用<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator" rel="nofollow">Spread运算符</a> ：</b> </p> 
<pre><code>this.setState({
  arrayvar: [...this.state.arrayvar, newelement]
})
</code></pre> 
<hr> 
<h4>#3楼</h4> 
<p> <i>As @nilgun mentioned in the comment, you can use the react <a href="https://facebook.github.io/react/docs/update.html" rel="nofollow">immutability helpers</a> .</i> <b>如评论中提到的@nilgun，您可以使用react <a href="https://facebook.github.io/react/docs/update.html" rel="nofollow">不可变性助手</a> 。</b> <i>I've found this to be super useful.</i> <b>我发现这非常有用。</b> </p> 
<p> <i>From the docs:</i> <b>从文档：</b> </p> 
<p> <i><strong>Simple push</strong></i> <b><strong>简单推</strong></b> </p> 
<pre><code>var initialArray = [1, 2, 3];
var newArray = update(initialArray, {$push: [4]}); // =&gt; [1, 2, 3, 4]
</code></pre> 
<p> <i><em>initialArray is still [1, 2, 3].</em></i> <b><em>initialArray仍为[1、2、3]。</em></b> </p> 
<hr> 
<h4>#4楼</h4> 
<p> <i>Easiest, if you are using <code>ES6</code> .</i> <b>如果您使用的是<code>ES6</code> ，则最简单。</b> </p> 
<pre><code>initialArray = [1, 2, 3];

newArray = [ ...initialArray, 4 ]; // --&gt; [1,2,3,4]
</code></pre> 
<p> <i>New array will be <code>[1,2,3,4]</code></i> <b>新数组将为<code>[1,2,3,4]</code></b> </p> 
<p> <i>to update your state in <strong>React</strong></i> <b>在<strong>React中</strong>更新您的状态</b> </p> 
<pre><code>this.setState({
         arrayvar:[...this.state.arrayvar, newelement]
       });
</code></pre> 
<p> <i><a href="https://leanpub.com/understandinges6/read#leanpub-auto-array-destructuring" rel="nofollow">Learn more about array destructuring</a></i> <b><a href="https://leanpub.com/understandinges6/read#leanpub-auto-array-destructuring" rel="nofollow">了解有关数组解构的更多信息</a></b> </p> 
<hr> 
<h4>#5楼</h4> 
<p> <i>React may batch updates, and therefore the correct approach is to provide setState with a function that performs the update.</i> <b>React可能会批量更新，因此正确的方法是为setState提供执行更新的功能。</b> </p> 
<p> <i>For the React update addon, the following will reliably work:</i> <b>对于React更新插件，以下将可靠地工作：</b> </p> 
<pre><code>this.setState( state =&gt; update(state, {array: {$push: [4]}}) );
</code></pre> 
<p> <i>or for concat():</i> <b>或对于concat（）：</b> </p> 
<pre><code>this.setState( state =&gt; ({
    array: state.array.concat([4])
}));
</code></pre> 
<p> <i>The following shows what <a href="https://jsbin.com/mofekakuqi/7/edit?js,output" rel="nofollow">https://jsbin.com/mofekakuqi/7/edit?js,output</a> as an example of what happens if you get it wrong.</i> <b>下面显示了<a href="https://jsbin.com/mofekakuqi/7/edit?js,output" rel="nofollow">https://jsbin.com/mofekakuqi/7/edit?js的输出，</a>作为输出示例，说明如果弄错了怎么办。</b> </p> 
<p> <i>The setTimeout() invocation correctly adds three items because React will not batch updates within a setTimeout callback (see <a href="https://groups.google.com/d/msg/reactjs/G6pljvpTGX0/0ihYw2zK9dEJ" rel="nofollow">https://groups.google.com/d/msg/reactjs/G6pljvpTGX0/0ihYw2zK9dEJ</a> ).</i> <b>setTimeout（）调用正确添加了三个项目，因为React不会在setTimeout回调中批量更新（请参阅<a href="https://groups.google.com/d/msg/reactjs/G6pljvpTGX0/0ihYw2zK9dEJ" rel="nofollow">https://groups.google.com/d/msg/reactjs/G6pljvpTGX0/0ihYw2zK9dEJ</a> ）。</b> </p> 
<p> <i>The buggy onClick will only add "Third", but the fixed one, will add F, S and T as expected.</i> <b>越野车onClick仅会添加“第三”，而固定的onClick将按预期添加F，S和T。</b> </p> 
<pre><code>class List extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      array: []
    }

    setTimeout(this.addSome, 500);
  }

  addSome = () =&gt; {
      this.setState(
        update(this.state, {array: {$push: ["First"]}}));
      this.setState(
        update(this.state, {array: {$push: ["Second"]}}));
      this.setState(
        update(this.state, {array: {$push: ["Third"]}}));
    };

  addSomeFixed = () =&gt; {
      this.setState( state =&gt; 
        update(state, {array: {$push: ["F"]}}));
      this.setState( state =&gt; 
        update(state, {array: {$push: ["S"]}}));
      this.setState( state =&gt; 
        update(state, {array: {$push: ["T"]}}));
    };



  render() {

    const list = this.state.array.map((item, i) =&gt; {
      return &lt;li key={i}&gt;{item}&lt;/li&gt;
    });
       console.log(this.state);

    return (
      &lt;div className='list'&gt;
        &lt;button onClick={this.addSome}&gt;add three&lt;/button&gt;
        &lt;button onClick={this.addSomeFixed}&gt;add three (fixed)&lt;/button&gt;
        &lt;ul&gt;
        {list}
        &lt;/ul&gt;
      &lt;/div&gt;
    );
  }
};


ReactDOM.render(&lt;List /&gt;, document.getElementById('app'));
</code></pre> 
<hr> 
<h4>#6楼</h4> 
<p> <i>The simplest way with <code>ES6</code> :</i> <b><code>ES6</code>最简单的方法：</b> </p> 
<pre><code>this.setState(prevState =&gt; ({
    array: [...prevState.array, newElement]
}))
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a12253432280f5e321141e8dcdf8d1ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mysql 批量修改四种方式效率对比（一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c2df8fd2016f21a248c653b42d441a79/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用Unity简单实现RayMarching</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>