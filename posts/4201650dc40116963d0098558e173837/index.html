<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue3.0有哪些哪些更新 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue3.0有哪些哪些更新" />
<meta property="og:description" content="3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的 反应性跟踪。 消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制 （1）监测机制的改 变 ： （2）只能监测属性，不能监测对象检测属性的添加和删除；检测数组索引和长度的变更； 支持 Map、Set、WeakMap 和 WeakSet。 （3）模板作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。 （4）对象式的组件声明方式 vue2.x 中 的 组 件 是 通 过 声 明 的 方 式 传 入 一 系 列 option， 和TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和TypeScript 的结合变得很容易 （5）其它方面的更改 支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。基于 tree shaking 优化，提供了更多的内置功能。 35." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4201650dc40116963d0098558e173837/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-08T14:49:45+08:00" />
<meta property="article:modified_time" content="2022-11-08T14:49:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue3.0有哪些哪些更新</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <span style="color:#000000;">3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的 反应性跟踪。 </span> 
</div> 
<div> 
 <div> 
  <span style="color:#000000;">消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制 </span> 
 </div> 
 <div> 
  <span style="color:#000000;">（1）监测机制的改</span> 
  <span style="color:#000000;">变 ： </span> 
 </div> 
</div> 
<div> 
 <span style="color:#000000;">（2）只能监测属性，不能监测对象检测属性的添加和删除；检测数组索引和长度的变更； </span> 
</div> 
<div> 
 <span style="color:#000000;">支持 Map、Set、WeakMap 和 WeakSet。 </span> 
</div> 
<div> 
 <span style="color:#000000;">（3）模板作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。 </span> 
</div> 
<div> 
 <span style="color:#000000;">（4）对象式的组件声明方式 </span> 
</div> 
<div> 
 <span style="color:#000000;">vue2.x 中 的 组 件 是 通 过 声 明 的 方 式 传 入 一 系 列 option， 和TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和TypeScript 的结合变得很容易 </span> 
</div> 
<div> 
 <span style="color:#000000;">（5）其它方面的更改 </span> 
</div> 
<div> 
 <span style="color:#000000;">支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。基于 tree shaking 优化，提供了更多的内置功能。 </span> 
</div> 
<div> 
 <span style="color:#000000;"><strong>35. defineProperty 和 proxy 的区别 </strong></span> 
</div> 
<div> 
 <span style="color:#000000;">Vue 在实例初始化时遍 历data中的所有属性，并使用Object.defineProperty 把这些属性全部转为 getter/setter。这样当追踪数据发生变化时，setter 会被自动调用。 </span> 
</div> 
<div> 
 <span style="color:#000000;">Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。 </span> 
</div> 
<div> 
 <span style="color:#000000;">但是这样做有以下问题： </span> 
</div> 
<div> 
 <span style="color:#000000;">1.添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理 ，只能通过$set 来调用 Object.defineProperty()处理。 </span> 
</div> 
<div> 
 <span style="color:#000000;">2.无法监控到数组下标和长度的变化。 </span> 
</div> 
<div> 
 <span style="color:#000000;">Vue3 使用 Proxy 来监控数据的变化。</span> 
</div> 
<div> 
 <span style="color:#000000;">Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。</span> 
</div> 
<div> 
 <span style="color:#000000;">相对于 Object.defineProperty()，其有以下特点：</span> 
</div> 
<div> 
 <span style="color:#000000;">1.Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。 </span> 
</div> 
<div> 
 <span style="color:#000000;">2.Proxy 可以监听数组的变化。 </span> 
</div> 
<div></div> 
<div> 
 <span style="color:#000000;"><strong> Vue3.0 为什么要用 proxy？ </strong></span> 
</div> 
<div> 
 <span style="color:#000000;">在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶ </span> 
</div> 
<div> 
 <span style="color:#000000;">不需用使用 Vue.$set 或 Vue.$delete 触发响应式。 </span> 
</div> 
<div> 
 <span style="color:#000000;">全方位的数组变化检测，消除了 Vue2 无效的边界情况。 </span> 
</div> 
<div> 
 <span style="color:#000000;">支持 Map，Set，WeakMap 和 WeakSet。 </span> 
</div> 
<div> 
 <span style="color:#000000;">Proxy 实现的响应式原理与 Vue2 的实现原理相同，实现方式大同小异∶ </span> 
</div> 
<div> 
 <span style="color:#000000;">get 收集依赖 </span> 
</div> 
<div> 
 <span style="color:#000000;">Set、delete 等触发依赖 </span> 
</div> 
<div> 
 <span style="color:#000000;">对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。</span> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/024972e2e20fdbc4ca3a40d0b38a14f4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C语言】数组详解，初学者一看就懂</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6b118d22988690fb917d9e4fb71f1037/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">qt 判断文件是否存在</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>