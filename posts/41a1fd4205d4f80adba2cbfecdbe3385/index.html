<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>要让CLR挂掉的话…… - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="要让CLR挂掉的话……" />
<meta property="og:description" content="http://rednaxelafx.iteye.com/blog/460893
（Disclaimer：如果需要转载请先与我联系。 作者：RednaxelaFX -&gt; rednaxelafx.iteye.com） 系列文章： 要让CLR挂掉的话…… 要让CLR挂掉的话（第二弹）……
前几天跟浩飞老兄闲聊的时候，聊到说一个不知道什么地方在面试人的时候，如果面试者说自己精通Java，他们就出题考面试者如何让JVM挂掉。这种面试方式或许是比较激进，不过倒也可以考考别人对特定JVM的实现的认识。
于是在爆栈上有这么一帖：How do you crash a JVM?。跟帖中一些同学的观点一样，我也不认为爆栈或者爆堆能算得上是“crash”，因为JVM还能正确捕捉到错误，并且执行合适的异常处理。真正的“crash”应该是连正常的异常处理都没起作用，直接就出crash log了；要是能连出crash log的步骤都破坏掉那就更彻底了。 爆栈帖里有人建议说： ralfs 写道 1. Use JNI and crash in the native code. 2. If no security manager is installed you can use reflection to crash the VM. This is VM specific, but normally a VM stores a bunch of pointers to native resources in private fields (e.g. a pointer to the native thread object is stored in a long field in java." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/41a1fd4205d4f80adba2cbfecdbe3385/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-07-23T12:27:36+08:00" />
<meta property="article:modified_time" content="2017-07-23T12:27:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">要让CLR挂掉的话……</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>http://rednaxelafx.iteye.com/blog/460893</p> 
<p>（Disclaimer：如果需要转载请先与我联系。 <br> 作者：RednaxelaFX -&gt; rednaxelafx.iteye.com） <br> <br> 系列文章： <br> 要让CLR挂掉的话…… <br> <a target="_blank" href="http://rednaxelafx.iteye.com/blog/461787" rel="nofollow noopener noreferrer">要让CLR挂掉的话（第二弹）……</a><br> <br> 前几天跟<a target="_blank" href="http://yuesefa.iteye.com/" rel="nofollow noopener noreferrer">浩飞</a>老兄闲聊的时候，聊到说一个不知道什么地方在面试人的时候，如果面试者说自己精通Java，他们就出题考面试者如何让JVM挂掉。这种面试方式或许是比较激进，不过倒也可以考考别人对特定JVM的实现的认识。<br> 于是在<a target="_blank" href="http://stackoverflow.com/" rel="nofollow noopener noreferrer">爆栈</a>上有这么一帖：<a target="_blank" href="http://stackoverflow.com/questions/65200/how-do-you-crash-a-jvm" rel="nofollow noopener noreferrer">How do you crash a JVM?</a>。跟帖中一些同学的观点一样，我也不认为爆栈或者爆堆能算得上是“crash”，因为JVM还能正确捕捉到错误，并且执行合适的异常处理。真正的“crash”应该是连正常的异常处理都没起作用，直接就出crash log了；要是能连出crash log的步骤都破坏掉那就更彻底了。 <br> 爆栈帖里有人建议说： <br> </p> 
<div class="quote_title">
  ralfs 写道 
</div> 
<div class="quote_div">
  1. Use JNI and crash in the native code. 
 <br> 2. If no security manager is installed you can use reflection to crash the VM. This is VM specific, but normally a VM stores a bunch of pointers to native resources in private fields (e.g. a pointer to the native thread object is stored in a long field in 
 <strong>java.lang.Thread</strong>). Just change them via reflection and the VM will crash sooner or later. 
 <br> 3. All VMs have bugs, so you just have to trigger one. 
</div> 
<br> 都是些有趣的建议…… 
<br> 
<br> 对应到.NET上的话， 
<br> 第一点基本上就映射到P/Invoke的使用了。如果被P/Invoke的native code里有非常糟糕的错误而且不使用 
<a target="_blank" href="http://msdn.microsoft.com/en-us/library/ms680657%28VS.85%29.aspx" rel="nofollow noopener noreferrer">SEH</a>，那CLR什么办法也没有，只能让程序crash了。 
<br> 
<br> 第二点是关于操纵VM内部实现用到的指针。各种JVM实现里在不同位置暴露了一些指针（即便是Compressed Oops那也是指针），改变它们的值确实能达到crash的效果，虽然如果更进一步能它它们改成“有意义”的值的话就能更有效的操纵破坏的具体行为。 
<br> CLR里也有许多看起来很无辜的东西实际上是指针来的（注意我是说CLR不是CLI）。一个典型的例子是 
<a target="_blank" href="http://msdn.microsoft.com/en-us/library/system.type.typehandle.aspx" rel="nofollow noopener noreferrer">Type.TypeHandle</a>属性，在CLR里它实际上就是指向类型的MethodTable的指针。通过它我们可以找到很多关于类型的“裸”信息。“裸”是指CLR内部的实现细节，本来不应该暴露出来的部分）。还有一个典型的例子是.NET的类型安全函数指针，委托。下面会看看委托的例子。 
<br> 要操纵VM内部的指针，势必要通过反射去获取或设置一些私有变量的值。这种操作一般都会受到VM的安全管理器监管，在没有足够权限的情况下无法执行。所以其实也不算危险……不，应该说原本用native code的话就有这种危险了，用了VM并没有变得更危险。 
<br> 
<br> 第三点是说VM自身的实现有bug。嗯这种状况常有，像先前我就看到 
<a target="_blank" href="http://rednaxelafx.iteye.com/blog/456647" rel="nofollow noopener noreferrer">HotSpot的JIT有bug挂掉了</a>。CLR小组也没少遇到内部发生内存管理错误的问题，组里有专人盯着这种问题在修。如果发现这样的bug并有意利用的话，也能有效让VM挂掉，甚至进一步做别的事情……呵呵 
<br> 
<br> =========================================================================== 
<br> 
<br> .NET的委托，在不考虑多播（multicast）状况时，完成调用所需要的Delegate类上最关键的3个成员是_target、_methodPtr和_methodPtrAux。其中只有_target是以Delegate.Target属性的形式公开出来的。看看它们都有什么用： 
<br> 
<br> _ 
<strong>target</strong>：委托调用的目标对象。 
<br> .NET的委托是类型安全的，不但指在构造委托实例时会检查其类型与目标方法的signature是否匹配，也指委托能够捕获目标对象的引用，进而能够由其得到相关的类型和方法的元数据，以供执行引擎监管类型的安全性。 
<br> 在CLR的实现中，_target可能有两种情况： 
<br> 1、如果委托指向的方法是成员方法，那么_target就会是指向目标方法所属的对象实例的指针； 
<br> 2、如果委托指向的是静态方法，或者是涉及native方法，那么_target会指向委托实例自身。 
<br> 有趣的是，虽然指向静态方法时_target指向委托实例自身，但Delegate.Target却会返回null。 
<br> 
<br> 
<strong>_methodPtr</strong>：委托调用的目标方法的指针。 
<br> 这个是“函数指针”的真面目，跟C里的函数指针没什么两样。 
<br> 它的值也分两大种情况： 
<br> 1、如果委托指向的方法是成员方法，那么_methodPtr就可能指向一个JIT stub（假如创建委托时目标方法尚未被JIT），或者可能是直接指向目标方法JIT后的地址； 
<br> 2、如果委托指向的方法是静态方法，那么_methodPtr指向的是一个stub，去掉原本调用时隐藏的第一个参数（_target），然后调用_methodPtrAux。这个stub是所有signature相同的委托共享的。 
<br> 如果涉及native方法的话我还没弄清楚具体是什么状况 =v= 
<br> 
<br> 
<strong>_methodPtrAux</strong>：委托调用的目标方法的第二个指针。 
<br> 联系前两个成员的介绍，这个也不例外分两种情况： 
<br> 1、如果委托指向的是成员方法，那么_methodPtrAux就是null（0）。Delegate.Target属性实际的实现是_methodPtrAux.IsNull() ? _target : null，可以看到目标是成员方法与否的影响。 
<br> 2、如果委托指向的是静态方法，那么_methodPtrAux可能指向类似JIT stub的东西，该stub在多次调用后可能会被改写为jmp到实际调用目标方法；也可能一开始就指向目标方法JIT后的地址。 
<br> （CLRv2中，“多次”是3次；采取哪个版本的_methodPtrAux取决于创建委托实例所在的方法在被JIT编译时，目标方法是否已经被JIT编译） 
<br> 
<br> 抽象的描述还是让人摸不着头脑，来看看代码例子： 
<br> 
<div class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    C#代码   
   <a target="_blank" title="收藏这段代码"><img class="star" alt="收藏代码" src="https://images2.imgbox.com/c0/34/m6V9D8Xg_o.png"><img class="spinner" src="https://images2.imgbox.com/b9/75/LBXwUGTZ_o.gif" alt="" style=""></a> 
  </div> 
 </div> 
 <ol class="dp-c"><li><span class="keyword">using</span> System;  </li><li><span class="keyword">using</span> System.Reflection;  </li><li>  </li><li><span class="keyword">namespace</span> TestCLR2Crash {  </li><li>    <span class="keyword">static</span> <span class="keyword">class</span> Program {  </li><li>        <span class="keyword">static</span> <span class="keyword">void</span> Main( <span class="keyword">string</span>[ ] args ) {  </li><li>            Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; iden = x =&gt; x;  </li><li>            Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; succ = x =&gt; x + 1;  </li><li>            var methPtrAuxInfo = <span class="keyword">typeof</span>( Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ).GetField( <span class="string">"_methodPtrAux"</span>, BindingFlags.NonPublic | BindingFlags.Instance );  </li><li>            var succPtrAux = ( IntPtr ) methPtrAuxInfo.GetValue( succ );  </li><li>            methPtrAuxInfo.SetValue( iden, succPtrAux );  </li><li>            Console.WriteLine( iden( 0xBEEF ).ToString( <span class="string">"X"</span> ) ); <span class="comment">// BEF0</span>  </li><li>        }  </li><li>    }  </li><li>}  </li></ol> 
</div> 
<pre title="要让CLR挂掉的话……" class="c#" style="display: none;" name="code">using System;
using System.Reflection;

namespace TestCLR2Crash {
    static class Program {
        static void Main( string[ ] args ) {
            Func&lt;int, int&gt; iden = x =&gt; x;
            Func&lt;int, int&gt; succ = x =&gt; x + 1;
            var methPtrAuxInfo = typeof( Func&lt;int, int&gt; ).GetField( "_methodPtrAux", BindingFlags.NonPublic | BindingFlags.Instance );
            var succPtrAux = ( IntPtr ) methPtrAuxInfo.GetValue( succ );
            methPtrAuxInfo.SetValue( iden, succPtrAux );
            Console.WriteLine( iden( 0xBEEF ).ToString( "X" ) ); // BEF0
        }
    }
}</pre> 
<br> 先注意一些C#的实现细节。Main里的iden与succ所指向的lambda都没有捕获任何自由变量，所以由C#编译器先改写生成对应的私有静态方法。这样，iden与succ就属于“指向静态方法的委托”的情况，可以留意一下相应的_target、_methodPtr与_methodPtrAux的表现。特别的，iden与succ的_target成员指向各自自身；它们的_methodPtr都指向同一个stub，用于剥离第一个隐藏参数并调用_methodPtrAux；由于Main()方法被JIT的时候，两个lambda对应的静态方法尚未被JIT，所以iden与succ的_methodPtrAux各自指向不同的stub（而不是直接指向实际调用目标方法）。 
<br> 
<br> 在代码中，我们把succ的_methodPtrAux提取出来，并设置到iden对应的域里。然后在调用iden时，可以看到实际被调用的是succ指向的那个lambda。 
<br> 
<br> 既然能把函数指针改到一个有效的函数地址上，那要是改为null的话呢？ 
<br> 
<div class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    C#代码   
   <a target="_blank" title="收藏这段代码"><img class="star" alt="收藏代码" src="https://images2.imgbox.com/7f/a4/C1ORf6G5_o.png"><img class="spinner" src="https://images2.imgbox.com/2c/85/tWO0VLs1_o.gif" alt="" style=""></a> 
  </div> 
 </div> 
 <ol class="dp-c"><li><span class="keyword">using</span> System;  </li><li><span class="keyword">using</span> System.Reflection;  </li><li>  </li><li><span class="keyword">namespace</span> TestCLR2Crash {  </li><li>    <span class="keyword">static</span> <span class="keyword">class</span> Program {  </li><li>        <span class="keyword">static</span> <span class="keyword">void</span> Main( <span class="keyword">string</span>[ ] args ) {  </li><li>            Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; iden = x =&gt; x;  </li><li>            var methPtrAuxInfo = <span class="keyword">typeof</span>( Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ).GetField( <span class="string">"_methodPtrAux"</span>, BindingFlags.NonPublic | BindingFlags.Instance );  </li><li>            methPtrAuxInfo.SetValue( iden, IntPtr.Zero );  </li><li>            Console.WriteLine( iden( 0xBEEF ).ToString( <span class="string">"X"</span> ) );  </li><li>        }  </li><li>    }  </li><li>}  </li></ol> 
</div> 
<pre title="要让CLR挂掉的话……" class="c#" style="display: none;" name="code">using System;
using System.Reflection;

namespace TestCLR2Crash {
    static class Program {
        static void Main( string[ ] args ) {
            Func&lt;int, int&gt; iden = x =&gt; x;
            var methPtrAuxInfo = typeof( Func&lt;int, int&gt; ).GetField( "_methodPtrAux", BindingFlags.NonPublic | BindingFlags.Instance );
            methPtrAuxInfo.SetValue( iden, IntPtr.Zero );
            Console.WriteLine( iden( 0xBEEF ).ToString( "X" ) );
        }
    }
}</pre> 
<br> 我们就让CLR挂掉而出现AV（access violation）了： 
<br> 
<div class="quote_title">
  引用 
</div> 
<div class="quote_div">
  Unhandled Exception: System.AccessViolationException: Attempted to read or write protected memory. This is often an indication that other memory is corrupt. 
</div> 
<br> 可惜CLR的实现比较严谨，AV也还是被默认的异常处理捕捉到了。不过如果指向什么别的地方，说不定就能在触发AV前先干点好事了，呵呵。 
<br> 
<br> 再次注意到像这样操纵VM内部的指针需要足够的安全权限才行，否则通过反射也无法像这样修改私有变量的值。所以并不会很不安全，可以放心。 
<br> 
<br> 说真的，即便写个会爆栈的程序，CLR也会扔出类似的错误信息： 
<br> 
<div class="quote_title">
  引用 
</div> 
<div class="quote_div">
  Process is terminated due to StackOverflowException. 
</div> 
<br> 改委托内部的函数指针不够好玩…… 
<br> 
<br> =========================================================================== 
<br> 
<br> 回复中cescshen同学问了个有趣的问题，说为什么改变_target也可以改变实际被调用的对象。我把我的回帖复制上来～ 
<br> 以下内容都是以PC上的32位x86的CLR，版本2.0.50727.3082为前提的讨论。 
<br> 
<br> 
<div class="quote_title">
  cescshen 写道 
</div> 
<div class="quote_div">
  发错，这儿不能删自己的留言。。 
 <br> 
 <br> 
 <div class="dp-highlighter"> 
  <div class="bar"> 
   <div class="tools">
     C#代码   
    <a target="_blank" title="收藏这段代码"><img class="star" alt="收藏代码" src="https://images2.imgbox.com/c1/0d/XxC4ggKI_o.png"><img class="spinner" src="https://images2.imgbox.com/41/dd/TdHlO3mk_o.gif" alt="" style=""></a> 
   </div> 
  </div> 
  <ol class="dp-c"><li>var methPtrAuxInfo = <span class="keyword">typeof</span>( Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ).GetField( <span class="string">"_target"</span>, BindingFlags.NonPublic | BindingFlags.Instance );   </li></ol> 
 </div> 
 <pre title="要让CLR挂掉的话……" class="C#" style="display: none;" name="code">var methPtrAuxInfo = typeof( Func&lt;int, int&gt; ).GetField( "_target", BindingFlags.NonPublic | BindingFlags.Instance ); </pre> 
 <br> 改成这样的话，也能出结果，这个怎么回事？ 
</div> 
<br> 如果你说的不是遇到了错误，而是看到修改_target后iden的行为变成了succ的，那是因为在_methodPtr所指向的那个stub里，代码是这样的： 
<br> 
<div class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    X86 asm代码   
   <a target="_blank" title="收藏这段代码"><img class="star" alt="收藏代码" src="https://images2.imgbox.com/9e/87/1R1k9Vcj_o.png"><img class="spinner" src="https://images2.imgbox.com/9d/84/I1iay7oD_o.gif" alt="" style=""></a> 
  </div> 
 </div> 
 <ol class="dp-default"><li>mov         eax,ecx         // 把第一参数（_target）复制到EAX  </li><li>mov         ecx,edx         // 把原本的第二参数（<span class="number"><span style="color:#c00000">0xBEEF</span></span>）变为第一参数  </li><li>add         eax,10h         // 把_target._methodPtrAux的地址设到EAX  </li><li>jmp         dword ptr [eax] // 间接调用EAX，也就是调用_target._methodPtrAux  </li></ol> 
</div> 
<pre title="要让CLR挂掉的话……" class="x86 asm" style="display: none;" name="code">mov         eax,ecx         // 把第一参数（_target）复制到EAX
mov         ecx,edx         // 把原本的第二参数（0xBEEF）变为第一参数
add         eax,10h         // 把_target._methodPtrAux的地址设到EAX
jmp         dword ptr [eax] // 间接调用EAX，也就是调用_target._methodPtrAux</pre> 
<br> 注意到CLR里JIT编译的代码的calling convention是类似fastcall的，头两个参数分别位于ECX和EDX。在调用iden的时候，代码是这样的： 
<br> 
<div class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    X86 asm代码   
   <a target="_blank" title="收藏这段代码"><img class="star" alt="收藏代码" src="https://images2.imgbox.com/e2/f0/QwD83UgA_o.png"><img class="spinner" src="https://images2.imgbox.com/23/73/Dcnq3p37_o.gif" alt="" style=""></a> 
  </div> 
 </div> 
 <ol class="dp-default"><li>mov         ecx,edi                 // 把iden的引用从EDI复制到ECX  </li><li>mov         edx,0BEEFh              // <span class="number"><span style="color:#c00000">0xBEEF</span></span>复制到EDX作为第二参数  </li><li>mov         eax,dword ptr [ecx+0Ch] // 把iden._methodPtr复制到EAX  </li><li>mov         ecx,dword ptr [ecx+<span class="number"><span style="color:#c00000">4</span></span>]   // 把iden._target复制到ECX作为第一参数  </li><li>call        eax                     // 调用_methodPtr  </li></ol> 
</div> 
<pre title="要让CLR挂掉的话……" class="x86 asm" style="display: none;" name="code">mov         ecx,edi                 // 把iden的引用从EDI复制到ECX
mov         edx,0BEEFh              // 0xBEEF复制到EDX作为第二参数
mov         eax,dword ptr [ecx+0Ch] // 把iden._methodPtr复制到EAX
mov         ecx,dword ptr [ecx+4]   // 把iden._target复制到ECX作为第一参数
call        eax                     // 调用_methodPtr</pre> 
<br> 
<br> 知道从_methodPtr到_methodPtrAux的过程之后，就可以理解为什么改变_target的值也足以改变指向静态方法的委托的行为：因为关键的_methodPtrAux是通过_target来引用的。在正常情况下，_target就指向委托自身，所以没有问题；而改变了_target的值之后，实际被调用的_methodPtrAux就跟着一起变了。 
<br> 
<br> =========================================================================== 
<br> 
<br> 
<a target="_blank" href="http://stackoverflow.com/questions/65200/how-do-you-crash-a-jvm" rel="nofollow noopener noreferrer">爆栈帖</a>里有一个回复可以mark一下： 
<br> 
<div class="quote_title">
  eckes 写道 
</div> 
<div class="quote_div">
  On Linux/Unix you can easyly make a JVM crash by sending it a Signal to the running process. Note: you should not use "SIGSEGV" for this, since Hotspot catches this signal and rethrows it as a NullPointerException in most places. So it is better to send a SIGBUS for example. 
</div> 
<p></p> 
<p><br> </p> 
<p>（Disclaimer：如果需要转载请先与我联系。 <br> 作者：RednaxelaFX -&gt; rednaxelafx.iteye.com） <br> <br> 系列文章： <br> <a target="_blank" href="http://rednaxelafx.iteye.com/blog/460893" rel="nofollow noopener noreferrer">要让CLR挂掉的话……</a><br> 要让CLR挂掉的话（第二弹）…… <br> <br> 同<a target="_blank" href="http://rednaxelafx.iteye.com/blog/460893" rel="nofollow noopener noreferrer">前一篇</a>的后半段一样，以下内容都是以<span style="color:red"><strong>PC上的32位x86的CLR、版本2.0.50727.3082，以及Windows XP SP3为前提</strong></span>的讨论。<br> <br> 前一篇提到了通过改变委托中的指针来改变实际的调用目标。修改委托实例中的_target、_methodPtr、_methodPtrAux这三个成员，都能够改变跳转目标；特别是后两个，它们的类型是IntPtr，可以构造出任意数值的指针设置进去，那样就可以跳转到任意目标了。<br> 但只能指定目标地址，却不能随意控制目标里的代码，显然还不够好玩。如果要跳转的目标是托管方法，那构造一个正常的委托就够了。如果能在<strong>不使用P/Invoke也不使用unsafe code的条件下</strong>在C#程序里执行一小块自定义的native code就好玩多了。先前的两篇日志（<a target="_blank" href="http://rednaxelafx.iteye.com/blog/428721" rel="nofollow noopener noreferrer">这里</a>和<a target="_blank" href="http://rednaxelafx.iteye.com/blog/428780" rel="nofollow noopener noreferrer">这里</a>）我提到在内存里生成native code并执行并不是件难事。那么在CLR上的C#也能做到么？ <br> <br> =========================================================================== <br> <br> <strong>要玩怎样的代码？</strong> <br> <br> 如果能执行任意native code的话，不得不说可玩的东西就多了。例如说把整个调用栈给乱搅一通、把SEH链全都破坏掉；或者……嗯还是别想那么可怕的玩法了，我还不想把自己的系统弄垮。等什么时候我再装个用了就扔的虚拟机镜像再试可怕的玩法……<br> <br> 还是跟前面一样，写段类似HelloWorld的代码，往标准输出流写句话，表明“可以做”就算了。想用System.Console.WriteLine()会有点不爽，因为它要接收CLR对象（的引用）为参数，而我不想费事去在自己的native code里去找出System.String的type token、调用CORINFO_HELP_NEWSFAST创建新实例、调用构造器之类的一大堆麻烦事。我就想把一个C风格的字符串输出而已。那么，就不用.NET标准库里的方法了，干脆直接用Win32 API，简单省事，<a target="_blank" href="http://www.pinvoke.net/default.aspx/kernel32.WriteConsole" rel="nofollow noopener noreferrer">WriteConsole()</a>函数正好够用。调用Win32函数时也懒得通过P/Invoke，而是在native code里直接call过去。 <br> <br> 要用Win32 API，首先得确保需要的DLL已经被加载到当前进程中。CLR为了自身的正常运行，本来就需要加载很多模块。可以看看一个HelloWorld式的托管程序都加载些什么模块进来。<br> </p> 
<div class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    C#代码   
   <a target="_blank" title="收藏这段代码"><img class="star" alt="收藏代码" src="https://images2.imgbox.com/dc/49/m4FuY1bR_o.png"><img class="spinner" src="https://images2.imgbox.com/37/15/WxqkUiH7_o.gif" alt="" style=""></a> 
  </div> 
 </div> 
 <ol class="dp-c"><li><span class="keyword">using</span> System;  </li><li>  </li><li><span class="keyword">static</span> <span class="keyword">class</span> Program {  </li><li>    <span class="keyword">static</span> <span class="keyword">void</span> Main(<span class="keyword">string</span>[] args) {  </li><li>        <span class="comment">// block the program so that we could easily attach a debugger</span>  </li><li>        var name = Console.ReadLine();  </li><li>        Console.WriteLine(<span class="string">"Greet me, {0}"</span>, name);  </li><li>    }  </li><li>}  </li></ol> 
</div> 
<pre title="要让CLR挂掉的话（第二弹）……" class="c#" style="display: none;" name="code">using System;

static class Program {
    static void Main(string[] args) {
        // block the program so that we could easily attach a debugger
        var name = Console.ReadLine();
        Console.WriteLine("Greet me, {0}", name);
    }
}</pre> 
<br> 除了这个exe本身之外，可以看到加载进来的模块有： 
<br> 
<div class="quote_title">
  引用 
</div> 
<div class="quote_div">
  ADVAPI32 
 <br> COMCTL32 
 <br> COMCTL_1 
 <br> GDI32 
 <br> IMM32 
 <br> KERNEL32 
 <br> LPK 
 <br> MSCOREE 
 <br> MSCORJIT 
 <br> MSCORLIB 
 <br> MSCORWKS 
 <br> MSVCR80 
 <br> MSVCRT 
 <br> OLE32 
 <br> RPCRT4 
 <br> SECUR32 
 <br> SHELL32 
 <br> SHLWAPI32 
 <br> USER32 
 <br> USP10 
</div> 
<br> 光是一个HelloWorld就加载了这么多DLL，可以用的函数那就多了 XD 
<br> 要调用的WriteConsoleA()函数位于Kernel32.dll中，在列表里可以找到，没问题。其实就没什么Win32程序是不加载Kernel32.dll的吧 =v= 
<br> 
<br> 怎么获取Win32 API的函数地址呢？如果是在C里，那不用管函数地址，引入windows.h或相关头文件后正常用那些函数就行。要不然LoadLibrary()得到模块句柄然后GetProcAddress()得到函数地址也行。前者在C#里固然是不行（即使用P/Invoke然后用个委托指向包装函数，得到的地址也是stub的地址而不是底下实际目标函数的地址）；后者有自举困难——LoadLibrary()的地址从哪儿来？ 
<br> 
<br> 所以干脆ad-hoc点，既然是玩嘛就先别那么麻烦，先弄出能演示的版本再说。用别的办法找到需要用的函数的地址，然后硬编码到我们生成的native code里就算了。因为DLL有默认的加载地址，只要一个进程里加载的DLL没有地址冲突，它们所在的位置就是可预测的，其中函数的位置也是可预测的。当然，我是在XP上玩，在Vista之后有 
<a target="_blank" href="http://en.wikipedia.org/wiki/Address_space_layout_randomization" rel="nofollow noopener noreferrer">ASLR</a>，地址就不好预测了……但如果按照下文的方法保存生成的native code的话，程序在遇到ASLR前先就被DEP干掉了。 
<br> 
<br> OK，废话那么多，我想达到的效果要是用C直接写会是怎样呢？ 
<br> 
<div class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    C代码   
   <a target="_blank" title="收藏这段代码"><img class="star" alt="收藏代码" src="https://images2.imgbox.com/e1/5a/651hqAna_o.png"><img class="spinner" src="https://images2.imgbox.com/67/1d/ZNUv04vx_o.gif" alt="" style=""></a> 
  </div> 
 </div> 
 <ol class="dp-cpp"><li><span class="preprocessor">#include &lt;windows.h&gt;</span>  </li><li>  </li><li><span class="datatypes"><strong><span style="color:#2e8b57">int</span></strong></span> main() {  </li><li>    <span class="datatypes"><strong><span style="color:#2e8b57">HANDLE</span></strong></span> hStdout = GetStdHandle(STD_OUTPUT_HANDLE);  </li><li>    WriteConsole(hStdout, <span class="string">"Greetings from generated code!\n"</span>, 31, NULL, NULL);  </li><li>      </li><li>    <span class="keyword">return</span> 0;  </li><li>}  </li></ol> 
</div> 
<pre title="要让CLR挂掉的话（第二弹）……" class="c" style="display: none;" name="code">#include &lt;windows.h&gt;

int main() {
    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
    WriteConsole(hStdout, "Greetings from generated code!\n", 31, NULL, NULL);
    
    return 0;
}</pre> 
<br> 很简单对吧？基本对应的机器码和汇编，后面还会用到： 
<br> 
<div class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    X86 asm代码   
   <a target="_blank" title="收藏这段代码"><img class="star" alt="收藏代码" src="https://images2.imgbox.com/9b/16/octZYmbE_o.png"><img class="spinner" src="https://images2.imgbox.com/a3/70/5AyKU8W9_o.gif" alt="" style=""></a> 
  </div> 
 </div> 
 <ol class="dp-default"><li><span class="number"><span style="color:#c00000">55</span></span>              push ebp  </li><li>8BEC            mov  ebp,esp  </li><li>6A F5           push -0B                         ; /DevType = STD_OUTPUT_HANDLE  </li><li>B8 D92F817C     mov  eax,KERNEL32.GetStdHandle   ; |  </li><li>FFD0            call eax                         ; \GetStdHandle  </li><li>6A <span class="number"><span style="color:#c00000">00</span></span>           push <span class="number"><span style="color:#c00000">0</span></span>                           ; /pReserved = NULL  </li><li>6A <span class="number"><span style="color:#c00000">00</span></span>           push <span class="number"><span style="color:#c00000">0</span></span>                           ; |pWritten = NULL  </li><li>6A 1F           push 1F                          ; |CharsToWrite = 1F (<span class="number"><span style="color:#c00000">31</span></span>.)  </li><li>E8 <span class="number"><span style="color:#c00000">00000000</span></span>     call &lt;&amp;next_instruction&gt;         ; |  </li><li><span class="number"><span style="color:#c00000">830424</span></span> <span class="number"><span style="color:#c00000">10</span></span>       add  dword ptr ss:[esp],<span class="number"><span style="color:#c00000">10</span></span>       ; |Buffer  </li><li><span class="number"><span style="color:#c00000">50</span></span>              push eax                         ; |hConsole  </li><li>BA 5DCC817C     mov  edx,KERNEL32.WriteConsoleA  ; |  </li><li>FFD2            call edx                         ; \WriteConsoleA  </li><li>8BE5            mov  esp,ebp  </li><li>5D              pop  ebp  </li><li>C3              ret  </li></ol> 
</div> 
<pre title="要让CLR挂掉的话（第二弹）……" class="x86 asm" style="display: none;" name="code">55              push ebp
8BEC            mov  ebp,esp
6A F5           push -0B                         ; /DevType = STD_OUTPUT_HANDLE
B8 D92F817C     mov  eax,KERNEL32.GetStdHandle   ; |
FFD0            call eax                         ; \GetStdHandle
6A 00           push 0                           ; /pReserved = NULL
6A 00           push 0                           ; |pWritten = NULL
6A 1F           push 1F                          ; |CharsToWrite = 1F (31.)
E8 00000000     call &lt;&amp;next_instruction&gt;         ; |
830424 10       add  dword ptr ss:[esp],10       ; |Buffer
50              push eax                         ; |hConsole
BA 5DCC817C     mov  edx,KERNEL32.WriteConsoleA  ; |
FFD2            call edx                         ; \WriteConsoleA
8BE5            mov  esp,ebp
5D              pop  ebp
C3              ret</pre> 
<br> 我准备把要输出的字符串紧接在代码后面。注意这里用了 
<a target="_blank" href="http://rednaxelafx.iteye.com/blog/428780" rel="nofollow noopener noreferrer">之前介绍过</a>的一个技巧，通过call指令来获取当前IP（指令指针）的值，并由此计算出要输出的字符串的地址。其实不用这个技巧也可以的，毕竟我已经知道代码的起始地址了。不过玩嘛，呵呵～ 
<br> 我用call r32指令而不是call imm32指令来调用那两个Win32函数，是因为前者的r32里装的是虚拟内存的绝对地址，而后者的imm32里装的是相对下一条指令的偏移量；我懒得在生成代码的时候去计算偏移量所以用前者了。 
<br> 另外还要注意，Win32 API的calling convention是WINAPI，也就是__stdcall，是由被调用方来清理栈的。 
<br> 
<br> 其实要让CLR无声无息的就停掉，在native code里调用TerminateProcess()应该也行。这次的例子还是专于HelloWorld好了 =v= 
<br> 
<br> =========================================================================== 
<br> 
<br> 
<strong>如何存放生成的native code？</strong> 
<br> 
<br> 之前 
<a target="_blank" href="http://rednaxelafx.iteye.com/blog/428721" rel="nofollow noopener noreferrer">用C来演示运行时操纵代码</a>的时候，是把native code“生成”到malloc出来的一块堆空间上的。在C#里我要怎么找到可写可执行的一块放代码的空间呢？ 
<br> 
<br> 在 
<a target="_blank" href="http://rednaxelafx.iteye.com/blog/460893" rel="nofollow noopener noreferrer">前一篇</a>的后半段中我介绍了改变委托的_target成员也可以改变最终被调用的目标。留意到_target的类型是System.Object，也就是说任何对象都可以放在里面。如果构造一个委托实例时，它是指向静态方法的，那么它的_methodPtr成员就会指向那个特定的stub：（stub会根据委托类型的参数个数不同而不同，下面是接收一个参数的委托的情况） 
<br> 
<div class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    X86 asm代码   
   <a target="_blank" title="收藏这段代码"><img class="star" alt="收藏代码" src="https://images2.imgbox.com/64/cd/FdeVnUcK_o.png"><img class="spinner" src="https://images2.imgbox.com/60/25/MuSZ48N7_o.gif" alt="" style=""></a> 
  </div> 
 </div> 
 <ol class="dp-default"><li>mov         eax,ecx          ; 把第一参数（_target）复制到EAX  </li><li>mov         ecx,edx          ; 把原本的第二参数变为第一参数  </li><li>add         eax,10h          ; 把_target._methodPtrAux的地址设到EAX  </li><li>jmp         dword ptr [eax]  ; 间接调用EAX，也就是调用_target._methodPtrAux  </li></ol> 
</div> 
<pre title="要让CLR挂掉的话（第二弹）……" class="x86 asm" style="display: none;" name="code">mov         eax,ecx          ; 把第一参数（_target）复制到EAX
mov         ecx,edx          ; 把原本的第二参数变为第一参数
add         eax,10h          ; 把_target._methodPtrAux的地址设到EAX
jmp         dword ptr [eax]  ; 间接调用EAX，也就是调用_target._methodPtrAux</pre> 
<br> 这个stub完全不理会_target到底是什么类型的，直接从偏移量0x10的地方取出一个DWORD，然后就间接跳转过去了。正常情况下_target指向委托自身，那么在偏移量0x10的地方就是_methodPtrAux成员，整个逻辑就是对的。那要是狸猫换太子，放点什么别的东西进去当作_target呢？ 
<br> 
<br> C#里，引用类型的默认内存布局是LayoutKind.Auto，值类型的默认内存布局是LayoutKind.Sequential，而我们现在需要的是在一个确定的偏移量保持跳转目标的地址。给类型指定LayoutKind.Explicit可以达到目的，不过其实有更简单的办法，连特殊类型都不需要声明——直接用数组就行了嘛。数组里的元素肯定是按顺序保存的。 
<br> 
<br> CLR里，一个最简单不过的int[]在内存中的布局如下：（括号中数字表示距离数组起始地址的偏移量） 
<br> 
<pre title="要让CLR挂掉的话（第二弹）……" name="code">-----------------------
|      SyncBlk索引     | （-4）
-----------------------
| 指向MethodTable的指针 | （+0）
-----------------------
|    数组长度 Length    | （+4）
-----------------------
|     下标为0的元素      | （+8+4*0）
-----------------------
|     下标为1的元素      | （+8+4*1）
-----------------------
|         ...          |
-----------------------
|     下标为n的元素      | （+8+4*n）
-----------------------
|         ...          |
-----------------------</pre> 
<br> 而一个委托实例的开头部分在内存中的布局是： 
<br> 
<pre title="要让CLR挂掉的话（第二弹）……" name="code">-----------------------
|      SyncBlk索引     | （-4）
-----------------------
| 指向MethodTable的指针 | （+0）
-----------------------
|       _target       | （+4）
-----------------------
|     _methodBase     | （+8）
-----------------------
|      _methodPtr     | （+12）
-----------------------
|    _methodPtrAux    | （+16）
-----------------------
|   _invocationList   | （+20）
-----------------------
|  _invocationCount   | （+24）
-----------------------</pre> 
<br> 那么只要用一个int[]（或者uint[]），在下标为2的地方放一个数字，然后把该数组设为某个委托的_target，那就……嘿嘿。 
<br> 
<br> 在Windows XP上， 
<a target="_blank" href="http://en.wikipedia.org/wiki/Data_Execution_Prevention" rel="nofollow noopener noreferrer">DEP</a>还没有对所有程序默认开启，所以基本上在堆上申请到的空间都是可写可执行的。CLR里的托管数组都在堆上分配空间，可以把native code“生成”到数组里保存着。不过Vista和Windows 7上DEP默认对所有程序都启用，而不通过VirtualAlloc()或者VirtualProtect()就没办法申请到可写可执行的空间，所以下面的办法在这些新的系统上运行会看到AccessViolationException。 
<br> 
<br> 结合我们需要在特定偏移量保存伪装的_methodPtrAux的需要，我们需要构造的int[]或者uint[]数组应该像这样： 
<br> 
<pre title="要让CLR挂掉的话（第二弹）……" name="code">-----------------------
|      SyncBlk索引     | （-4）
-----------------------
| 指向MethodTable的指针 | （+0）
-----------------------
|    数组长度 Length    | （+4）
-----------------------
|           0          | （+8+4*0==8，下标为0）
-----------------------
|           0          | （+8+4*1==12，下标为1）
-----------------------
|   假的_methodPtrAux   | （+8+4*2==16，下标为2）
-----------------------
|   生成的native code   | （+8+4*3==20 ...）
|         ...          |
-----------------------</pre> 
<br> 其中，在下标为2的地方放置“假的_methodPtrAux”；该值应该等于下标为3的地址，好让委托调用到“生成”的native code。 
<br> 于是又有问题了：我们该如何得到数组的地址？ 
<br> 
<br> =========================================================================== 
<br> 
<br> 
<strong>如何获得对象的地址？</strong> 
<br> 
<br> 可能会有人想到用对象的hashcode来找出对象的地址。让我们笼统的分析一下其合理性。 
<br> 
<br> Java的java.lang.Object和.NET的System.Object都支持获取对象的hashcode。如果一个对象在“活着”的时候不会被移动，则其起始地址不会发生改变；对象间不应该有交叠，所以用对象地址直接作为hashcode是一种很直观的实现。事实上 
<a target="_blank" href="http://code.google.com/android/" rel="nofollow noopener noreferrer">Android</a>里的Dalvik虚拟机就是这样实现Object.hashCode()的，详细可查看 
<a target="_blank" href="http://android.git.kernel.org/?p=platform/dalvik.git;a=tree" rel="nofollow noopener noreferrer">Dalvik源码</a>的 
<a target="_blank" href="http://android.git.kernel.org/?p=platform/dalvik.git;a=blob_plain;f=vm/native/java_lang_Object.c;hb=HEAD" rel="nofollow noopener noreferrer">vm/native/java_lang_Object.c</a>中的Dalvik_java_lang_Object_hashCode()和 
<a target="_blank" href="http://android.git.kernel.org/?p=platform/dalvik.git;a=blob_plain;f=vm/native/InternalNative.c;hb=HEAD" rel="nofollow noopener noreferrer">InternalNative.c</a>中的dvmGetObjectHashCode()。 
<br> 
<div class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    C代码 
  </div> 
 </div> 
 <ol class="dp-cpp"><li><span class="comment">/*</span> </li><li><span class="comment"> * Return the hash code for the specified object.</span> </li><li><span class="comment"> */</span>  </li><li>u4 dvmGetObjectHashCode(Object* obj)  </li><li>{  </li><li>    <span class="keyword">return</span> (u4) obj;  </li><li>}  </li></ol> 
</div> 
<pre title="要让CLR挂掉的话（第二弹）……" class="c" style="display: none;" name="code">/*
 * Return the hash code for the specified object.
 */
u4 dvmGetObjectHashCode(Object* obj)
{
    return (u4) obj;
}</pre> 
<br> 注意到Dalvik的GC是典型的标记-清除（mark-and-sweep）式，不会移动堆中的对象。 
<br> 
<br> 也可以留意一下Apache Harmony里的其中一种hashcode计算方式，第16页： 
<a target="_blank" href="http://people.apache.org/~xli/presentations/ossummit07-drlvm_overview.pdf" rel="nofollow noopener noreferrer">Design a Product-Ready JVM for Apache Harmony</a> 
<br> 
<br> 也有一些JVM的实现会选择以对象地址为源通过位移、异或等运算来计算hashcode，这种情况下要从hashcode反推回来原本的地址就有点困难了。 
<br> Mono在使用不移动对象的GC时，采用的hashcode算法来自Thomas Wang， 
<a target="_blank" href="http://www.concentric.net/~Ttwang/tech/addrhash.htm" rel="nofollow noopener noreferrer">Address Based Hash Function</a> 
<br> 其算法实现是： 
<br> 
<div class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    C代码 
  </div> 
 </div> 
 <ol class="dp-cpp"><li>uint32 address_hash(<span class="datatypes"><strong><span style="color:#2e8b57">char</span></strong></span>* addr)  </li><li>{  </li><li>  <span class="keyword">register</span> uint32 key;  </li><li>  key = (uint32) addr;  </li><li>  <span class="keyword">return</span> (key &gt;&gt; 3) * 2654435761;  </li><li>}  </li></ol> 
</div> 
<pre title="要让CLR挂掉的话（第二弹）……" class="c" style="display: none;" name="code">uint32 address_hash(char* addr)
{
  register uint32 key;
  key = (uint32) addr;
  return (key &gt;&gt; 3) * 2654435761;
}</pre> 
<br> 
<br> 那要是GC会移动对象呢，例如说采用了拷贝式收集器或者压缩式收集器的话？一个办法是可以拿对象第一次被分配的地址为hashcode的源，另一个办法是干脆无视对象的地址，用别的办法来得到能够区分对象身份的值；还有些别的办法是上面两种的混合。 
<a target="_blank" href="http://xiao-feng.blogspot.com/" rel="nofollow noopener noreferrer">Xiao-Feng</a>在 
<a target="_blank" href="http://xiao-feng.blogspot.com/2007/04/object-hashcode-implementation.html" rel="nofollow noopener noreferrer">Object hashcode implementation</a>一帖中描述了Apache Harmony实现hashcode的三种方案，可以参考阅读一下。 
<br> 
<br> CLR中System.Object.GetHashCode()并不返回对象的地址，所以很可惜不能从这里挖出点指针来玩玩。 
<br> 
<br> --------------------------------------------------------------------------- 
<br> 
<br> 然后可能会有人想到像C那样用union来骗过类型系统。 
<br> 
<div class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    C代码 
  </div> 
 </div> 
 <ol class="dp-cpp"><li><span class="preprocessor">#include &lt;stdio.h&gt;</span>  </li><li>  </li><li><span class="keyword">typedef</span> <span class="keyword">union</span> tagMyUnion {  </li><li>    <span class="datatypes"><strong><span style="color:#2e8b57">int</span></strong></span> i;  </li><li>    <span class="datatypes"><strong><span style="color:#2e8b57">float</span></strong></span> f;  </li><li>} MyUnion;  </li><li>  </li><li><span class="datatypes"><strong><span style="color:#2e8b57">int</span></strong></span> main() {  </li><li>    MyUnion u;  </li><li>    <span class="datatypes"><strong><span style="color:#2e8b57">int</span></strong></span> i;  </li><li>      </li><li>    u.f = 2.0f;                                 <span class="comment">// 0x40000000</span>  </li><li>    i = u.i;                                    <span class="comment">// 0x40000000</span>  </li><li>    u.i = i + (1 &lt;&lt; 23);                        <span class="comment">// 0x40800000</span>  </li><li>    printf(<span class="string">"%f\n"</span>, u.f);                        <span class="comment">// 4.000000</span>  </li><li>    printf(<span class="string">"%d, 0x%08x\n"</span>, i, i);               <span class="comment">// 1073741824, 0x40000000</span>  </li><li>    printf(<span class="string">"%d, 0x%08x\n"</span>, (<span class="datatypes"><strong><span style="color:#2e8b57">int</span></strong></span>)u.f, (<span class="datatypes"><strong><span style="color:#2e8b57">int</span></strong></span>)u.f); <span class="comment">// 4, 0x00000004</span>  </li><li>      </li><li>    <span class="keyword">return</span> 0;  </li><li>}  </li></ol> 
</div> 
<pre title="要让CLR挂掉的话（第二弹）……" class="c" style="display: none;" name="code">#include &lt;stdio.h&gt;

typedef union tagMyUnion {
    int i;
    float f;
} MyUnion;

int main() {
    MyUnion u;
    int i;
    
    u.f = 2.0f;                                 // 0x40000000
    i = u.i;                                    // 0x40000000
    u.i = i + (1 &lt;&lt; 23);                        // 0x40800000
    printf("%f\n", u.f);                        // 4.000000
    printf("%d, 0x%08x\n", i, i);               // 1073741824, 0x40000000
    printf("%d, 0x%08x\n", (int)u.f, (int)u.f); // 4, 0x00000004
    
    return 0;
}</pre> 
<br> 在C里，要直接把float类型的值的底层表示“看作”int，光靠类型转换是不行的，因为编译器会在转换的地方插入类似inttofloat()的函数，把底层表示从单精度浮点数格式改变为二的补码整数格式。以前专门的浮点数运算器不普及时，程序员经常自己用整数运算去模拟浮点数运算，需要在不改变底层表示的前提下操作。怎么办呢？像上面那样用union就可以做到。通过union，任意等宽度的类型间都可以做不改变底层表示的转换，跟后来C++的reinterpret_cast作用一样。 
<br> 
<br> CLR里的引用用指针的形式来实现，而指针以直接记录地址的形式来实现。（注意：引用、指针和地址是三个在不同抽象层次上的相关概念，不应该把它们看作同一抽象层次上的概念。） 
<br> 虽然C#中没有reinterpret_cast，但有模拟C的union的结构：显式指定内存布局的struct。如果可以在C#里实现一个union，把IntPtr值和Object引用保存在同一位置，不就可以提取到对象的地址了吗？于是： 
<br> 
<div class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    C#代码 
  </div> 
 </div> 
 <ol class="dp-c"><li><span class="keyword">using</span> System;  </li><li><span class="keyword">using</span> System.Runtime.InteropServices;  </li><li>  </li><li><span class="keyword">namespace</span> TestCLR2Crash {  </li><li>    [StructLayout( LayoutKind.Explicit )]  </li><li>    <span class="keyword">struct</span> Reinterpreter {  </li><li>        [FieldOffset( 0 )]  </li><li>        IntPtr _pointer;  </li><li>        [FieldOffset( 0 )]  </li><li>        <span class="keyword">object</span> _target;  </li><li>  </li><li>        <span class="keyword">public</span> IntPtr Cast( <span class="keyword">object</span> obj ) {  </li><li>            _target = obj;  </li><li>            <span class="keyword">return</span> _pointer;  </li><li>        }  </li><li>    }  </li><li>  </li><li>    <span class="keyword">static</span> <span class="keyword">class</span> Program {  </li><li>        <span class="keyword">static</span> <span class="keyword">void</span> Main( <span class="keyword">string</span>[ ] args ) {  </li><li>            var reinterpreter = <span class="keyword">new</span> Reinterpreter( );  </li><li>            var arr = <span class="keyword">new</span>[ ] { 1, 2, 3 };  </li><li>            var ptr = reinterpreter.Cast( arr );  </li><li>            Console.WriteLine( ptr.ToString( <span class="string">"X"</span> ) );  </li><li>        }  </li><li>    }  </li><li>}  </li></ol> 
</div> 
<pre title="要让CLR挂掉的话（第二弹）……" class="c#" style="display: none;" name="code">using System;
using System.Runtime.InteropServices;

namespace TestCLR2Crash {
    [StructLayout( LayoutKind.Explicit )]
    struct Reinterpreter {
        [FieldOffset( 0 )]
        IntPtr _pointer;
        [FieldOffset( 0 )]
        object _target;

        public IntPtr Cast( object obj ) {
            _target = obj;
            return _pointer;
        }
    }

    static class Program {
        static void Main( string[ ] args ) {
            var reinterpreter = new Reinterpreter( );
            var arr = new[ ] { 1, 2, 3 };
            var ptr = reinterpreter.Cast( arr );
            Console.WriteLine( ptr.ToString( "X" ) );
        }
    }
}</pre> 
<br> 很可惜CLR已经预料到这种玩法，不允许值类型与引用类型的域交叠。上面的代码可以通过编译，但在加载Reinterpreter类型时会出错： 
<br> 
<div class="quote_title">
  引用 
</div> 
<div class="quote_div">
  Unhandled Exception: System.TypeLoadException: Could not load type 'TestCLR2Crash.Reinterpreter' from assembly 'TestCLR2Crash, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null' because it contains an object field at offset 0 that is incorrectly aligned or overlapped by a non-object field. 
 <br>    at TestCLR2Crash.Program.Main(String[] args) 
</div> 
<br> 此路不通 =x=||| 
<br> 
<br> --------------------------------------------------------------------------- 
<br> 
<br> 其实.NET标准库里有 
<a target="_blank" href="http://msdn.microsoft.com/en-us/library/system.runtime.interopservices.gchandle.aspx" rel="nofollow noopener noreferrer">System.Runtime.InteropServices.GCHandle</a>这么个值类型。它的作用主要体现在托管代码与native code的互操作中，以避免需要用到的托管对象在native code执行过程中意外被GC回收。GCHandle也可以把对象“定”（pin）住，以避免native code访问对象的过程中对象地址发生改变。 
<br> 
<br> GCHandle有个 
<a target="_blank" href="http://msdn.microsoft.com/en-us/library/system.runtime.interopservices.gchandle.addrofpinnedobject.aspx" rel="nofollow noopener noreferrer">AddrOfPinnedObject()</a>方法，正好可以提供对象的地址；使用GCHandle还附带了保证对象不被回收的功能，对这帖想要玩的代码是正合适。 
<br> 创建GCHandle时用到的Alloc()方法要求调用它的程序集有SecurityPermissionFlag.UnmanagedCode权限。不过即便用了它，我也没有在代码中显式使用unsafe code，满足我的要求。 
<br> 
<br> 要用GCHandle定住一个对象的话，创建GCHandle时会对一些类型的对象给予特别待遇，包括： 
<br> 1、System.String 
<br> 2、元素为原始类型的数组 
<br> 3、元素为值类型且 
<a target="_blank" href="http://msdn.microsoft.com/en-us/library/75dwhxf7.aspx" rel="nofollow noopener noreferrer">Blittable</a>的数组 
<br> 4、其它Blittable类型 
<br> 任何不在上述范围内的对象obj，传给GCHandle.Alloc(obj, GCHandleType.Pinned)的话，会引发异常： 
<br> 
<div class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    C#代码 
  </div> 
 </div> 
 <ol class="dp-c"><li><span class="keyword">using</span> System;  </li><li><span class="keyword">using</span> System.Runtime.InteropServices;  </li><li>  </li><li><span class="keyword">namespace</span> TestCLR2Crash {  </li><li>    <span class="keyword">static</span> <span class="keyword">class</span> Program {  </li><li>        <span class="keyword">static</span> <span class="keyword">void</span> Main( <span class="keyword">string</span>[ ] args ) {  </li><li>            var o = <span class="keyword">new</span> <span class="keyword">object</span>( );  </li><li>            var handle = GCHandle.Alloc( o, GCHandleType.Pinned );  </li><li>            var addr = handle.AddrOfPinnedObject( );  </li><li>            handle.Free( );  </li><li>        }  </li><li>    }  </li><li>}  </li></ol> 
</div> 
<pre title="要让CLR挂掉的话（第二弹）……" class="c#" style="display: none;" name="code">using System;
using System.Runtime.InteropServices;

namespace TestCLR2Crash {
    static class Program {
        static void Main( string[ ] args ) {
            var o = new object( );
            var handle = GCHandle.Alloc( o, GCHandleType.Pinned );
            var addr = handle.AddrOfPinnedObject( );
            handle.Free( );
        }
    }
}</pre> 
<br> 
<div class="quote_title">
  引用 
</div> 
<div class="quote_div">
  Unhandled Exception: System.ArgumentException: Object contains non-primitive or 
 <br> non-blittable data. 
 <br>    at System.Runtime.InteropServices.GCHandle.InternalAlloc(Object value, GCHandleType type) 
 <br>    at TestCLR2Crash.Program.Main(String[] args) in F:\document\Visual Studio 2008\Projects\TestDev9\TestCLR2Crash\Program.cs:line 8 
</div> 
<br> 换成一个字符串就没问题： 
<br> 
<div class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    C#代码 
  </div> 
 </div> 
 <ol class="dp-c"><li><span class="keyword">using</span> System;  </li><li><span class="keyword">using</span> System.Runtime.InteropServices;  </li><li>  </li><li><span class="keyword">namespace</span> TestCLR2Crash {  </li><li>    <span class="keyword">static</span> <span class="keyword">class</span> Program {  </li><li>        <span class="keyword">static</span> <span class="keyword">void</span> Main( <span class="keyword">string</span>[ ] args ) {  </li><li>            var str = <span class="string">"check me"</span>;  </li><li>            var handle = GCHandle.Alloc( str, GCHandleType.Pinned );  </li><li>            var addr = handle.AddrOfPinnedObject( );  </li><li>            Console.WriteLine( <span class="string">"{0}, {1}"</span>, str, addr.ToInt32( ) );  </li><li>            handle.Free( );  </li><li>        }  </li><li>    }  </li><li>}  </li></ol> 
</div> 
<pre title="要让CLR挂掉的话（第二弹）……" class="c#" style="display: none;" name="code">using System;
using System.Runtime.InteropServices;

namespace TestCLR2Crash {
    static class Program {
        static void Main( string[ ] args ) {
            var str = "check me";
            var handle = GCHandle.Alloc( str, GCHandleType.Pinned );
            var addr = handle.AddrOfPinnedObject( );
            Console.WriteLine( "{0}, {1}", str, addr.ToInt32( ) );
            handle.Free( );
        }
    }
}</pre> 
<br> 
<a target="_blank" href="http://msdn.microsoft.com/en-us/library/system.runtime.interopservices.gchandle.alloc.aspx" rel="nofollow noopener noreferrer">GCHandle.Alloc()</a>文档中对此有提及。我差点看漏了以为文档没说…… 
<br> 
<br> 有趣的是，GCHandle对类型的挑剔还不止于此。GCHandle.AddrOfPinnedObject()方法乍一看像是返回对象自身的起始地址，实际不然，返回的是对象的“ 
<strong>数据区</strong>”的起始地址。对System.String来说，“数据区”就是实际存放字符的char数组（CLR的String实现把char数组融合到String里了，没有单独的“char数组成员”。忽略ObjHeader，跳过MethodTable指针和其它成员，例如m_arrayLength、m_stringLength，跳到m_firstChar也就是融合后char数组的开始）；而对数组来说，“数据区”就是实际存放值的区域（忽略ObjHeader，跳过MethodTable指针和Length）；对其它Blittable类型来说，“数据区”就是Object里MethodTable指针之后的部分。 
<br> 
<br> =========================================================================== 
<br> 
<br> 完事俱备，只欠开工写代码来实现前面讨论的内容。 
<br> 先上代码： 
<br> 
<div class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    C#代码 
  </div> 
 </div> 
 <ol class="dp-c"><li><span class="keyword">using</span> System;  </li><li><span class="keyword">using</span> System.Reflection;  </li><li><span class="keyword">using</span> System.Runtime.InteropServices;  </li><li>  </li><li><span class="keyword">namespace</span> TestCLR2Crash {  </li><li>        <span class="keyword">static</span> <span class="keyword">void</span> Main( <span class="keyword">string</span>[ ] args ) {  </li><li>            <span class="comment">// declare a delegate that refers to a static method,</span>  </li><li>            <span class="comment">// in this case it's a static method generated from the</span>  </li><li>            <span class="comment">// anonymous delegate.</span>  </li><li>            Action action = <span class="keyword">delegate</span>( ) { };  </li><li>  </li><li>            <span class="comment">// "generate" code into an array of uint</span>  </li><li>            var fakeDelegate = <span class="keyword">new</span> <span class="keyword">uint</span>[ ] {  </li><li>                <span class="comment">// dummy values</span>  </li><li>                0x00000000, 0x00000000,  </li><li>                <span class="comment">// fake _methodPtrAux</span>  </li><li>                0x00000000,  </li><li>                <span class="comment">// native code/string</span>  </li><li>                0x6AEC8B55, 0x2FD9B8F5, 0xD0FF7C81, 0x006A006A,  </li><li>                0x00E81F6A, 0x83000000, 0x50102404, 0x81CC5DBA,  </li><li>                0x8BD2FF7C, 0x47C35DE5, 0x74656572, 0x73676E69,  </li><li>                0x6F726620, 0x6567206D, 0x6172656E, 0x20646574,  </li><li>                0x65646F63, 0x00000A21  </li><li>            };  </li><li>  </li><li>            <span class="comment">// fill in the fake _methodPtrAux,</span>  </li><li>            <span class="comment">// make it point to the code region in fakeDelegate</span>  </li><li>            var handle = GCHandle.Alloc( fakeDelegate, GCHandleType.Pinned );  </li><li>            var addr = handle.AddrOfPinnedObject( );  </li><li>            <span class="keyword">const</span> <span class="keyword">int</span> sizeOfUInt32 = <span class="keyword">sizeof</span>( <span class="keyword">uint</span> ); <span class="comment">// 4</span>  </li><li>            <span class="keyword">const</span> <span class="keyword">int</span> indexOfCode = 3;  </li><li>            fakeDelegate[ 2 ] = Convert.ToUInt32( addr.ToInt32( ) + sizeOfUInt32 * indexOfCode );  </li><li>  </li><li>            var targetInfo = <span class="keyword">typeof</span>( Action )  </li><li>                .GetField( <span class="string">"_target"</span>, BindingFlags.NonPublic | BindingFlags.Instance );  </li><li>            targetInfo.SetValue( action, fakeDelegate );  </li><li>            action( );       <span class="comment">// Greetings from generated code!</span>  </li><li>            Console.WriteLine( <span class="string">"Greetings from managed code!"</span> );  </li><li>  </li><li>            handle.Free( );  </li><li>        }  </li><li>    }  </li><li>}  </li></ol> 
</div> 
<pre title="要让CLR挂掉的话（第二弹）……" class="c#" style="display: none;" name="code">using System;
using System.Reflection;
using System.Runtime.InteropServices;

namespace TestCLR2Crash {
        static void Main( string[ ] args ) {
            // declare a delegate that refers to a static method,
            // in this case it's a static method generated from the
            // anonymous delegate.
            Action action = delegate( ) { };

            // "generate" code into an array of uint
            var fakeDelegate = new uint[ ] {
                // dummy values
                0x00000000, 0x00000000,
                // fake _methodPtrAux
                0x00000000,
                // native code/string
                0x6AEC8B55, 0x2FD9B8F5, 0xD0FF7C81, 0x006A006A,
                0x00E81F6A, 0x83000000, 0x50102404, 0x81CC5DBA,
                0x8BD2FF7C, 0x47C35DE5, 0x74656572, 0x73676E69,
                0x6F726620, 0x6567206D, 0x6172656E, 0x20646574,
                0x65646F63, 0x00000A21
            };

            // fill in the fake _methodPtrAux,
            // make it point to the code region in fakeDelegate
            var handle = GCHandle.Alloc( fakeDelegate, GCHandleType.Pinned );
            var addr = handle.AddrOfPinnedObject( );
            const int sizeOfUInt32 = sizeof( uint ); // 4
            const int indexOfCode = 3;
            fakeDelegate[ 2 ] = Convert.ToUInt32( addr.ToInt32( ) + sizeOfUInt32 * indexOfCode );

            var targetInfo = typeof( Action )
                .GetField( "_target", BindingFlags.NonPublic | BindingFlags.Instance );
            targetInfo.SetValue( action, fakeDelegate );
            action( );       // Greetings from generated code!
            Console.WriteLine( "Greetings from managed code!" );

            handle.Free( );
        }
    }
}</pre> 
<br> 执行结果是：（再次提醒：在Vista或者Windows 7上运行会遇到AccessViolationException） 
<br> 
<div class="quote_title">
  引用 
</div> 
<div class="quote_div">
  Greetings from generated code! 
 <br> Greetings from managed code! 
</div> 
<br> Good！成功的让CLR执行了一段我们指定的native code，在标准输出流上显示了"Greetings from generated code!\n"，而且没有显式使用P/Invoke或者unsafe code。为了演示从native code返回后CLR仍在正常运行，所以通过Console.WriteLine()再输出了一行"Greetings from managed code!"。 
<br> 前文基本上已经把代码的原理解释得差不多了（吧？），所以这边就不再详细解释。 
<br> fakeDelegate数组里的native code/string那段可能不太直观，其实那就是前面给出的x86机器码以及"Greetings from generated code!\n"。需要注意的是因为x86的字节序（endian）是little-endian，低位字节在前；而本例中用的数组元素类型是uint，是4字节的整型，所以以4字节为单位，其中的顺序是“反”的。 
<br> 就以第一个数字0x6AEC8B55为例，它在内存中是0x55 0x8B 0xEC 0x6A这4个字节，其中头3个字节就是这两条指令： 
<br> 
<div class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    X86 asm代码 
  </div> 
 </div> 
 <ol class="dp-default"><li><span class="number"><span style="color:#c00000">55</span></span>              push ebp  </li><li>8BEC            mov  ebp,esp  </li></ol> 
</div> 
<pre title="要让CLR挂掉的话（第二弹）……" class="x86 asm" style="display: none;" name="code">55              push ebp
8BEC            mov  ebp,esp</pre> 
<br> 这样应该就好理解了吧？ 
<br> 
<br> =========================================================================== 
<br> 
<br> 回顾标题，“要让CLR挂掉的话”，上面的例子都还没让CLR挂掉，似乎有点不够意思。其实真要让CLR连最后的防护措施都挂掉、连异常都抓不到，那还挺难的。但我们可以很轻松的做出些例子，观察一下平时难得一见的异常。 
<br> （ 
<strong><span style="color:red">在家实验的同学们千万注意了：要自行尝试引发错误的话，一定要小心，不要在有重要资料的系统上试。任意篡改代码或者栈上/堆上的数据，实际会引发什么后果很难预料。发生什么糟糕后果责任要自己承担的哦～</span></strong>） 
<br> 如果构造这样的一段代码： 
<br> 
<div class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    X86 asm代码 
  </div> 
 </div> 
 <ol class="dp-default"><li>83C4 <span class="number"><span style="color:#c00000">08</span></span>         add esp,<span class="number"><span style="color:#c00000">8</span></span>  </li><li>C3              ret  </li></ol> 
</div> 
<pre title="要让CLR挂掉的话（第二弹）……" class="x86 asm" style="display: none;" name="code">83C4 08         add esp,8
C3              ret</pre> 
<br> 把它放到上面的C#例子里： 
<br> 
<div class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    C#代码 
  </div> 
 </div> 
 <ol class="dp-c"><li><span class="keyword">using</span> System;  </li><li><span class="keyword">using</span> System.Reflection;  </li><li><span class="keyword">using</span> System.Runtime.InteropServices;  </li><li>  </li><li><span class="keyword">namespace</span> TestCLR2Crash {  </li><li>        <span class="keyword">static</span> <span class="keyword">void</span> Main( <span class="keyword">string</span>[ ] args ) {  </li><li>            <span class="comment">// declare a delegate that refers to a static method,</span>  </li><li>            <span class="comment">// in this case it's a static method generated from the</span>  </li><li>            <span class="comment">// anonymous delegate.</span>  </li><li>            Action action = <span class="keyword">delegate</span>( ) { };  </li><li>  </li><li>            <span class="comment">// "generate" code into an array of uint</span>  </li><li>            var fakeDelegate = <span class="keyword">new</span> <span class="keyword">uint</span>[ ] {  </li><li>                <span class="comment">// dummy values</span>  </li><li>                0x00000000, 0x00000000,  </li><li>                <span class="comment">// fake _methodPtrAux</span>  </li><li>                0x00000000,  </li><li>                <span class="comment">// native code</span>  </li><li>                0xC308C483  </li><li>            };  </li><li>  </li><li>            <span class="comment">// fill in the fake _methodPtrAux,</span>  </li><li>            <span class="comment">// make it point to the code region in fakeDelegate</span>  </li><li>            var handle = GCHandle.Alloc( fakeDelegate, GCHandleType.Pinned );  </li><li>            var addr = handle.AddrOfPinnedObject( );  </li><li>            <span class="keyword">const</span> <span class="keyword">int</span> sizeOfUInt32 = <span class="keyword">sizeof</span>( <span class="keyword">uint</span> ); <span class="comment">// 4</span>  </li><li>            <span class="keyword">const</span> <span class="keyword">int</span> indexOfCode = 3;  </li><li>            fakeDelegate[ 2 ] = Convert.ToUInt32( addr.ToInt32( ) + sizeOfUInt32 * indexOfCode );  </li><li>  </li><li>            var targetInfo = <span class="keyword">typeof</span>( Action )  </li><li>                .GetField( <span class="string">"_target"</span>, BindingFlags.NonPublic | BindingFlags.Instance );  </li><li>            targetInfo.SetValue( action, fakeDelegate );  </li><li>            action( );  </li><li>            handle.Free( );  </li><li>        }  </li><li>    }  </li><li>}  </li></ol> 
</div> 
<pre title="要让CLR挂掉的话（第二弹）……" class="c#" style="display: none;" name="code">using System;
using System.Reflection;
using System.Runtime.InteropServices;

namespace TestCLR2Crash {
        static void Main( string[ ] args ) {
            // declare a delegate that refers to a static method,
            // in this case it's a static method generated from the
            // anonymous delegate.
            Action action = delegate( ) { };

            // "generate" code into an array of uint
            var fakeDelegate = new uint[ ] {
                // dummy values
                0x00000000, 0x00000000,
                // fake _methodPtrAux
                0x00000000,
                // native code
                0xC308C483
            };

            // fill in the fake _methodPtrAux,
            // make it point to the code region in fakeDelegate
            var handle = GCHandle.Alloc( fakeDelegate, GCHandleType.Pinned );
            var addr = handle.AddrOfPinnedObject( );
            const int sizeOfUInt32 = sizeof( uint ); // 4
            const int indexOfCode = 3;
            fakeDelegate[ 2 ] = Convert.ToUInt32( addr.ToInt32( ) + sizeOfUInt32 * indexOfCode );

            var targetInfo = typeof( Action )
                .GetField( "_target", BindingFlags.NonPublic | BindingFlags.Instance );
            targetInfo.SetValue( action, fakeDelegate );
            action( );
            handle.Free( );
        }
    }
}</pre> 
<br> 执行，我们会看到什么呢？ 
<br> 
<div class="quote_title">
  引用 
</div> 
<div class="quote_div">
  Process is terminated due to StackOverflowException. 
</div> 
<br> 
<br> 把构造的代码改为 
<br> 
<div class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    X86 asm代码 
  </div> 
 </div> 
 <ol class="dp-default"><li>83C4 <span class="number"><span style="color:#c00000">18</span></span>         add esp,18h  </li><li>C3              ret  </li></ol> 
</div> 
<pre title="要让CLR挂掉的话（第二弹）……" class="x86 asm" style="display: none;" name="code">83C4 18         add esp,18h
C3              ret</pre> 
<br> （也就是native code那段的数字是0xC318C483） 
<br> 执行结果是： 
<br> 
<div class="quote_title">
  引用 
</div> 
<div class="quote_div">
  Unhandled Exception: System.Runtime.InteropServices.SEHException: External component has thrown an exception. 
</div> 
<br> stack trace是： 
<br> 
<div class="quote_title">
  引用 
</div> 
<div class="quote_div">
  &gt; 0012f4f9() 
 <br> mscorwks.dll!_CallDescrWorker@20()  + 0x33 bytes 
 <br> mscorwks.dll!_CallDescrWorkerWithHandler@24()  + 0x9f bytes 
 <br> mscorwks.dll!MethodDesc::CallDescr()  + 0x15a bytes 
 <br> mscorwks.dll!MethodDesc::CallTargetWorker()  + 0x1f bytes 
 <br> mscorwks.dll!MethodDescCallSite::CallWithValueTypes()  + 0x1a bytes 
 <br> mscorwks.dll!ClassLoader::RunMain()  - 0x39028 bytes 
 <br> mscorwks.dll!Assembly::ExecuteMainMethod()  + 0xa4 bytes 
 <br> mscorwks.dll!SystemDomain::ExecuteMainMethod()  + 0x416 bytes 
 <br> mscorwks.dll!ExecuteEXE()  + 0x49 bytes 
 <br> mscorwks.dll!__CorExeMain@0()  + 0x98 bytes 
 <br> mscoree.dll!__CorExeMain@0()  + 0x34 bytes 
 <br> kernel32.dll!_BaseProcessStart@4()  + 0x23 bytes 
</div> 
<br> EIP停下的位置是： 
<br> 
<div class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    X86 asm代码 
  </div> 
 </div> 
 <ol class="dp-default"><li>0012F4F9 F4               hlt  </li></ol> 
</div> 
<pre title="要让CLR挂掉的话（第二弹）……" class="x86 asm" style="display: none;" name="code">0012F4F9 F4               hlt</pre> 
<br> 这个地址是Windows上很典型的栈地址。EIP居然跑到这个地方来，把数据当成指令执行了一句“HLT”指令…… 
<br> HLT是一个Ring 0指令，用户模式的应用程序没办法是用这条指令，所以试图执行它引发了错误。 
<br> SEHException这种泛泛的异常少见吧？成功的搞出了一个没有映射到有具体含义的CLR异常，呵呵 ^ ^ 
<br> 
<br> P.S. 这帖告诉我们，类型安全的真面目就是：一旦你开始玩裸指针、玩union、玩goto，啥类型安全都是浮云…… 
<br> P.P.S. 查了文档，Silverlight 3里的 
<a target="_blank" href="http://msdn.microsoft.com/en-us/library/1246yz8f%28VS.95%29.aspx" rel="nofollow noopener noreferrer">GCHandle.Alloc</a>和 
<a target="_blank" href="http://msdn.microsoft.com/en-us/library/system.runtime.interopservices.gchandle.addrofpinnedobject%28VS.95%29.aspx" rel="nofollow noopener noreferrer">GCHandle.AddrOfPinnedObject</a>果然是SecurityCritical的，从用户代码里无法调用它。然而 
<a target="_blank" href="http://msdn.microsoft.com/en-us/library/05eey4y9%28VS.95%29.aspx" rel="nofollow noopener noreferrer">Type.GetMethod</a>和 
<a target="_blank" href="http://msdn.microsoft.com/en-us/library/4ek9c21e%28VS.95%29.aspx" rel="nofollow noopener noreferrer">Type.GetField</a>之类还是Transparent的，还是有搞头——至少在Moonlight上 XD 
<br> P.P.P.S. 呜，但是 
<a target="_blank" href="http://msdn.microsoft.com/en-us/library/6z33zd7h%28VS.95%29.aspx" rel="nofollow noopener noreferrer">FieldInfo.SetValue</a>只能用来设置可访问的域的值……又没搞头了 
<br> 
<div class="quote_title">
  MSDN 写道 
</div> 
<div class="quote_div">
  In Silverlight, only accessible fields can be set using reflection.   
 <br> 
</div> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e80e940b245c962c885ec3c20bdb6fe3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">（POJ 1258）Prim算法 最小生成树</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d92099ab3a7b69975cc058925760a416/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList[[zip file &#34;/data/app/com.g</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>