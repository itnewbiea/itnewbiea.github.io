<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;指针详解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;指针详解" />
<meta property="og:description" content="一、指针的概念 指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型，指针所指向的类型，指针的值或者叫指针所指向的内存区，还有指针本身所占据的内存区。让我们分别说明。
先声明几个指针放着做例子：
int*ptr; char*ptr; int**ptr; int(*ptr)[3]; int*(*ptr)[4]; 二、指针的类型 由于指针是一种独立的类型，这种类型的变量存储的值是内存地址 ，所以指针也是有类型的，指针的类型是指指针本身的类型，从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：
int *ptr; //指针的类型是int * char *ptr; //指针的类型是char * int **ptr; //指针的类型是 int ** int (*ptr)[3]; //指针的类型是 int(*)[3] int *(*ptr)[4]; //指针的类型是 int *(*)[4] 三、指针所指向的类型 当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。
从语法上看，你只需把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如：
int *ptr; //指针所指向的类型是int char *ptr; //指针所指向的的类型是char int **ptr; //指针所指向的的类型是 int * int (*ptr)[3]; //指针所指向的的类型是 int()[3] int *(*ptr)[4]; //指针所指向的的类型是 int *()[4] 在指针的算术运算中，指针所指向的类型有很大的作用。
对于指针所指向的类型，我的理解是指针所指向的内存区，这片内存区所代表的类型，所以指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。
四、指针的值 指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32位程序里，所有类型的指针的值都是一个32位整数，因为32位程序里内存地址全都是32位长。
指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。
指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。
在这里要记住，指针的值就是指针的所指向的内存地址的首地址，而指针的指向则是以XX为首地址的一片内存区域。
五、指针本身所占据的内存区 指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32位平台里，指针本身占据了4个字节的长度。
指针本身占据的内存这个概念在判断一个指针表达式是否是左值时很有用。
六、指针的算术运算 指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的。例如：
char a[20]; int *ptr=a; ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c774531127b1e56f93f2b906d76658cb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-07T23:31:27+08:00" />
<meta property="article:modified_time" content="2022-03-07T23:31:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;指针详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2></h2> 
<h2>一、指针的概念</h2> 
<p>指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型，指针所指向的类型，指针的值或者叫指针所指向的内存区，还有指针本身所占据的内存区。让我们分别说明。</p> 
<p>先声明几个指针放着做例子：</p> 
<pre><code class="language-cpp">
int*ptr;  
char*ptr;  
int**ptr;  
int(*ptr)[3];  
int*(*ptr)[4];</code></pre> 
<h2>二、指针的类型</h2> 
<p>由于指针是一种独立的类型，这种类型的变量存储的值是内存地址 ，所以指针也是有类型的，指针的类型是指指针本身的类型，从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：</p> 
<pre><code class="language-cpp">int *ptr; //指针的类型是int *  
char *ptr; //指针的类型是char *  
int **ptr; //指针的类型是 int ** 
int (*ptr)[3]; //指针的类型是 int(*)[3]  
int *(*ptr)[4]; //指针的类型是 int *(*)[4]</code></pre> 
<h2>三、指针所指向的类型</h2> 
<p>当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。</p> 
<p>从语法上看，你只需把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如：</p> 
<pre><code class="language-cpp">int *ptr; //指针所指向的类型是int  
char *ptr; //指针所指向的的类型是char 
int **ptr; //指针所指向的的类型是 int *  
int (*ptr)[3]; //指针所指向的的类型是 int()[3]  
int *(*ptr)[4]; //指针所指向的的类型是 int *()[4]</code></pre> 
<p>在指针的算术运算中，指针所指向的类型有很大的作用。</p> 
<p>对于指针所指向的类型，我的理解是指针所指向的内存区，这片内存区所代表的类型，所以指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。</p> 
<h2>四、指针的值</h2> 
<p>指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32位程序里，所有类型的指针的值都是一个32位整数，因为32位程序里内存地址全都是32位长。</p> 
<p>指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。</p> 
<p>指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。</p> 
<p>在这里要记住，指针的值就是指针的所指向的内存地址的首地址，而指针的指向则是以XX为首地址的一片内存区域。</p> 
<h2>五、指针本身所占据的内存区</h2> 
<p>指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32位平台里，指针本身占据了4个字节的长度。</p> 
<p>指针本身占据的内存这个概念在判断一个指针表达式是否是左值时很有用。</p> 
<h2>六、指针的算术运算</h2> 
<p>指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的。例如：</p> 
<pre><code class="language-cpp">
 char a[20];  
 int *ptr=a;  
 ...  
 ...   ptr++;</code></pre> 
<p>在上例中，指针ptr的类型是int*,它指向的类型是int，它被初始化为指向整形变量a。接下来的第3句中，指针ptr被加了1，编译器是这样处理的：它把指针ptr的值加上了sizeof(int)，在32位程序中，是被加上了4。由于地址是用字节做单位的，故ptr所指向的地址由原来的变量a的地址向高地址方向增加了4个字节。</p> 
<p>也就是说，ptr++其实是把指针的值加上了sizeof（指针所指向的类型），由于char类型的长度是一个字节，所以原来ptr是指向数组a的第0号单元开始的四个字节，此时指向了数组a中从第4号单元开始的四个字节。</p> 
<p>我们可以用一个指针和一个循环来遍历一个数组，看例子：</p> 
<pre><code class="language-cpp">
int array[20];  
int *ptr=array;  
...  
//此处略去为整型数组赋值的代码。
...  
for(i=0;i&lt;20;i++)  
{      
    (*ptr)++; 
     ptr++；
}</code></pre> 
<p>这个例子将整型数组中各个单元的值加1。由于每次循环都将指针ptr加1，所以每次循环都能访问数组的下一个单元。再看例子：</p> 
<pre><code class="language-cpp">char a[20];  
int *ptr = a;  
...  
...  
ptr += 5;</code></pre> 
<p>在这个例子中，ptr被加上了5，编译器是这样处理的：将指针ptr的值加上5乘sizeof(int)，在32位程序中就是加上了5乘4=20。由于地址的单位是字节，故现在的ptr所指向的地址比起加5后的ptr所指向的地址来说，向高地址方向移动了20个字节。在这个例子中，没加5前的ptr指向数组a的第0号单元开始的四个字节，加5后，ptr已经指向了数组a的合法范围之外了。虽然这种情况在应用上会出问题，但在语法上却是可以的。这也体现出了指针的灵活性。</p> 
<p>如果上例中，ptr是被减去5，那么处理过程大同小异，只不过ptr的值是被减去5乘sizeof(int)，新的ptr指向的地址将比原来的ptr所指向的地址向低地址方向移动了20个字节。</p> 
<p>总结一下，一个指针ptrold加上一个整数n后，结果是一个新的指针ptrnew，ptrnew的类型和ptrold的类型相同，ptrnew所指向的类型和ptrold所指向的类型也相同。ptrnew的值将比ptrold的值增加了n乘sizeof(ptrold所指向的类型)个字节。就是说，ptrnew所指向的内存区，将比ptrold所指向的内存区，向高地址方向移动了n乘sizeof(ptrold所指向的类型)个字节。一个指针ptrold减去一个整数n后，结果是一个新的指针ptrnew，ptrnew的类型和ptrold的类型相同，ptrnew所指向的类型和ptrold所指向的类型也相同。ptrnew的值将比ptrold的值，减少了n乘sizeof(ptrold所指向的类型)个字节，就是说，ptrnew所指向的内存区，将比ptrold所指向的内存区，向低地址方向移动了n乘sizeof(ptrold所指向的类型)个字节。</p> 
<h2>七、运算符&amp;和*</h2> 
<p>这里&amp;是取地址运算符，*是...书上叫做“间接运算符”。&amp;a的运算结果是一个指针，指针的类型是a的类型加个*，指针所指向的类型是a的类型，指针所指向的地址嘛，那就是a的地址。*p的运算结果就五花八门了。总之*p的结果是p所指向的东西，这个东西有这些特点：它的类型是p指向的类型，它所占用的地址是p所指向的地址。</p> 
<pre><code class="language-cpp">
int a=12;  
int b;  
int *p;  
int **ptr;  
p=&amp;a;//&amp;a的结果是一个指针，类型是int*，指向的类型是int，指向的地址是a的地址。
*p=24;//*p的结果，在这里它的类型是int，它所占用的地址是p所指向的地址，显然，*p就是变量a。
ptr=&amp;p;//&amp;p的结果是个指针，该指针的类型是p的类型加个*，在这里是int**。该指针所指向的类型是p的类型，这里是int*。该指针所指向的地址就是指针p自己的地址。
*ptr=&amp;b;//*ptr是个指针，&amp;b的结果也是个指针，且这两个指针的类型和所指向的类型是一样的，所以?amp;b来给*ptr赋值就是毫无问题的了。
**ptr=34;//*ptr的结果是ptr所指向的东西，在这里是一个指针，对这个指针再做一次*运算，结果就是一个int类型的变量。


</code></pre> 
<h2>八、指针表达式</h2> 
<p>一个表达式的最后结果如果是一个指针，那么这个表达式就叫指针表达式。下面是一些指针表达式的例子：</p> 
<pre><code class="language-cpp">int a,b;  
int array[10];  
int *pa;  
pa=&amp;a;//&amp;a是一个指针表达式。
int **ptr=&amp;pa;//&amp;pa也是一个指针表达式。
*ptr=&amp;b;//*ptr和&amp;b都是指针表达式。
pa=array;  
pa++;//这也是指针表达式。</code></pre> 
<pre><code class="language-cpp">
char *arr[20];  
char **parr=arr;//如果把arr看作指针的话，arr也是指针表达式  
char *str;  
str=*parr;//*parr是指针表达式  
str=*(parr+1);//*(parr+1)是指针表达式  
str=*(parr+2);//*(parr+2)是指针表达式</code></pre> 
<p>由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。</p> 
<p>好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。在例七中，&amp;a不是一个左值，因为它还没有占据明确的内存。*ptr是一个左值，因为*ptr这个指针已经占据了内存，其实*ptr就是指针pa，既然pa已经在内存中有了自己的位置，那么*ptr当然也有了自己的位置。</p> 
<h2>九、指针和结构体的关系</h2> 
<p>可以声明一个指向结构类型对象的指针。</p> 
<pre><code class="language-cpp">
struct MyStruct  
{  
int a;  
int b;  
int c;  
}  
MyStruct ss={20,30,40};//声明了结构对象ss，并把ss的三个成员初始化为20，30和40。
MyStruct *ptr=&amp;ss;//声明了一个指向结构对象ss的指针。它的类型是MyStruct*,它指向的类型是MyStruct。
int *pstr=(int*)&amp;ss;//声明了一个指向结构对象ss的指针。但是它的类型和它指向的类型和ptr是不同的。</code></pre> 
<p>请问怎样通过指针ptr来访问ss的三个成员变量？</p> 
<p><strong>答案：</strong></p> 
<pre><code class="language-cpp">
ptr-&gt;a;  
ptr-&gt;b;  
ptr-&gt;c;</code></pre> 
<p>又请问怎样通过指针pstr来访问ss的三个成员变量？</p> 
<pre><code class="language-cpp">
*pstr；//访问了ss的成员a。
*(pstr+1);//访问了ss的成员b。
*(pstr+2)//访问了ss的成员c。</code></pre> 
<p>但是，这样使用pstr来访问结构成员是不正规的，为了说明为什么不正规，让我们看看怎样通过指针来访问数组的各个单元：</p> 
<pre><code class="language-cpp">
int array[3]={35,56,37};  
int *pa=array;</code></pre> 
<p>通过指针pa访问数组array的三个单元的方法是：</p> 
<pre><code class="language-cpp">
*pa;//访问了第0号单元  
*(pa+1);//访问了第1号单元  
*(pa+2);//访问了第2号单元</code></pre> 
<p>从格式上看倒是与通过指针访问结构成员的不正规方法的格式一样。</p> 
<p>所有的C/C++编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个“填充字节”，这就导致各个成员之间可能会有若干个字节的空隙。</p> 
<p>所以，即使pstr访问到了结构对象ss的第一个成员变量a，也不能保证`(pstr+1)就一定能访问到结构成员b。因为成员a和成员b之间可能会有若干填充字节，说不定*(pstr+1)`就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节。</p> 
<h2>十、指针和函数的关系</h2> 
<p>可以把一个指针声明成为一个指向函数的指针。</p> 
<pre><code class="language-cpp">int fun1(char*,int);  
int (*pfun1)(char*,int);  
pfun1=fun1;  
....  
....  
int a=(*pfun1)("abcdefg",7);//通过函数指针调用函数。</code></pre> 
<p> 可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。</p> 
<h2>十一、总结</h2> 
<p>最后，关于指针的部分就说这么多了，主要理解四方面的内容：指针的类型，指针所指向的类型，指针的值或者叫指针所指向的内存区，还有指针本身所占据的内存区。每次遇到指针都要问问自己这四个方面都是什么，对于指针的应用自然就熟悉了。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c938386ab165497b744ecfa152c1cb5c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Sring-IOC控制反转（详解）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/04cbba85b7a39c94f11f19e4e7c25d71/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CH579 中断</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>