<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>POD进阶 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="POD进阶" />
<meta property="og:description" content="Pod的生命周期开始
1 k8s的pod重启策略：Always(默认，deployment的yaml文件只能是Always)pod的yaml文件三种模式都可以，不论正常退出还是非正常退出都重启
2 OnFailure:只有状态码非0才会重启，正常退出是不重启的
3 Never：正常退出和非正常退出都不重启
这三个状态都是容器退出了pod才会重启或不重启
Pod可以有多个容器，只要有一个容器退出，整个pod都会重启，pod内 的所有容器都会重启
docker的重启策略
never Docker：的默认策略是never
on-Failure 也就是非正常退出才会重启容器
always 只要容器退出都会重启
Unless-stopped
只要容器退出就会重启，docker守护进程已经停止的容器，不再重启
Yaml文件快速生成
[root@master01 ~]# kubectl create deployment nginx1 --image=nginx:1.22 --replicas=1 --dry-run=client deployment.apps/nginx1 created (dry run) [root@master01 ~]# kubectl create deployment nginx1 --image=nginx:1.22 --replicas=1 --dry-run=client -o yaml &gt; /opt/test1.yaml #--dry-run=client 表示只是调用了api的对象，不执行命令 ， -o yaml表示指定为yaml文件 [root@master01 opt]# kubectl expose deployment nginx-chen --port=80 --target-port=80 --type=NodePort --dry-run=client -o yaml &gt; /opt/test1-service.yaml #生成service模版 Pod状态
常见
Crashloopbackoff：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c3deb8b7808f96335653093a3af4f985/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-05T16:51:55+08:00" />
<meta property="article:modified_time" content="2024-01-05T16:51:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">POD进阶</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:.0001pt;text-align:justify;"><strong>Pod的生命周期开始</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:43px;">1</td><td style="width:455px;"> <p style="margin-left:.0001pt;text-align:justify;">k8s的pod重启策略：Always(默认，deployment的yaml文件只能是Always)pod的yaml文件三种模式都可以，不论正常退出还是非正常退出都重启</p> </td></tr><tr><td style="width:43px;">2</td><td style="width:455px;"> <p style="text-align:justify;">OnFailure:只有状态码非0才会重启，正常退出是不重启的</p> </td></tr><tr><td style="width:43px;">3</td><td style="width:455px;"> <p style="margin-left:.0001pt;text-align:justify;">Never：正常退出和非正常退出都不重启</p> </td></tr><tr><td style="width:43px;"></td><td style="width:455px;"> <p style="margin-left:.0001pt;text-align:justify;">这三个状态都是容器退出了pod才会重启或不重启</p> <p style="margin-left:.0001pt;text-align:justify;">Pod可以有多个容器，只要有一个容器退出，整个pod都会重启，pod内 的所有容器都会重启</p> </td></tr></tbody></table> 
<p><strong>docker的重启策略</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:121px;">never</td><td style="width:378px;"> <p style="margin-left:.0001pt;text-align:justify;">Docker：的默认策略是never</p> </td></tr><tr><td style="width:121px;">on-Failure</td><td style="width:378px;"> <p style="margin-left:.0001pt;text-align:justify;">也就是非正常退出才会重启容器</p> </td></tr><tr><td style="width:121px;">always</td><td style="width:378px;"> <p style="margin-left:.0001pt;text-align:justify;">只要容器退出都会重启</p> </td></tr><tr><td style="width:121px;"> <p style="margin-left:.0001pt;text-align:justify;">Unless-stopped</p> </td><td style="width:378px;"> <p style="margin-left:.0001pt;text-align:justify;">只要容器退出就会重启，docker守护进程已经停止的容器，不再重启</p> </td></tr></tbody></table> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>Yaml文件快速生成</strong></p> 
<pre><code class="language-bash">[root@master01 ~]# kubectl create deployment nginx1 --image=nginx:1.22 --replicas=1 --dry-run=client
deployment.apps/nginx1 created (dry run)
[root@master01 ~]# kubectl create deployment nginx1 --image=nginx:1.22 --replicas=1 --dry-run=client -o yaml &gt; /opt/test1.yaml
#--dry-run=client 表示只是调用了api的对象，不执行命令 ， -o yaml表示指定为yaml文件

[root@master01 opt]# kubectl expose deployment nginx-chen --port=80 --target-port=80 --type=NodePort --dry-run=client -o yaml &gt; /opt/test1-service.yaml
#生成service模版</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>Pod状态</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>常见</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td> <p style="margin-left:.0001pt;text-align:justify;">Crashloopbackoff：</p> <p style="margin-left:.0001pt;text-align:justify;">表示pod当中的容器已经退出，kubelet正在重启</p> <p style="margin-left:.0001pt;text-align:justify;">Imagepullbackoff：</p> <p style="margin-left:.0001pt;text-align:justify;">表示正在重试拉取镜像</p> <p style="margin-left:.0001pt;text-align:justify;">Errimagepull：</p> <p style="margin-left:.0001pt;text-align:justify;">拉取镜像出错了，原因：网速太慢，镜像名字写错了，镜像仓库挂了</p> <p style="margin-left:.0001pt;text-align:justify;">Evicte：</p> <p style="margin-left:.0001pt;text-align:justify;">pod被驱赶，node节点上的资源不够部署pod或者资源不足，kubelet自动选择一个pod驱逐</p> </td></tr></tbody></table> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>CrashLoopBackOff：    容器退出，kubelet正在将它重启<br> InvalidImageName：    无法解析镜像名称<br> ImageInspectError：   无法校验镜像<br> ErrImageNeverPull：   策略禁止拉取镜像<br> ImagePullBackOff：    正在重试拉取<br> RegistryUnavailable： 连接不到镜像中心<br> ErrImagePull：        通用的拉取镜像出错<br> CreateContainerConfigError： 不能创建kubelet使用的容器配置<br> CreateContainerError： 创建容器失败<br> m.internalLifecycle.PreStartContainer 执行hook报错<br> RunContainerError：   启动容器失败<br> PostStartHookError：   执行hook报错<br> ContainersNotInitialized： 容器没有初始化完毕<br> ContainersNotReady：   容器没有准备完毕<br> ContainerCreating：    容器创建中<br> PodInitializing：pod   初始化中<br> DockerDaemonNotReady：  docker还没有完全启动<br> NetworkPluginNotReady： 网络插件还没有完全启动<br> Evicte:     pod被驱赶</td></tr></tbody></table> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>Pod内的容器使用节点资源的限制</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:75px;"> <p style="margin-left:.0001pt;text-align:justify;">request</p> </td><td style="width:424px;"> <p style="margin-left:.0001pt;text-align:justify;">需要的资源</p> </td></tr><tr><td style="width:75px;"> <p style="margin-left:.0001pt;text-align:justify;">Limit</p> </td><td style="width:424px;"> <p style="margin-left:.0001pt;text-align:justify;">限制最高能占用系统多少资源</p> <p style="margin-left:.0001pt;text-align:justify;">Limit：需要多少，最多也只能占用这么多</p> <p style="margin-left:.0001pt;text-align:justify;">两个限制：</p> <p style="margin-left:.0001pt;text-align:justify;">Cpu：cpu的限制格式：1，2，0.5,0.2,0.3</p> <p style="margin-left:.0001pt;text-align:justify;">1表示可以占用1个cpu</p> <p style="margin-left:.0001pt;text-align:justify;">2可以占用2个cpu</p> <p style="margin-left:.0001pt;text-align:justify;">0.5可以占用半个</p> <p style="margin-left:.0001pt;text-align:justify;">0.2：一个cpu的五分之一</p> <p style="margin-left:.0001pt;text-align:justify;">0.1是最小单位</p> <p style="margin-left:.0001pt;text-align:justify;">要么是整数，要么就是小数点后只能跟一位，最小单位0.1</p> <p style="margin-left:.0001pt;text-align:justify;">m来表示cpu</p> <p style="margin-left:.0001pt;text-align:justify;">Cpu时间分片原理：cpu时间分片，通过周期性的轮流分配cpu时间给各个进程，多个进程可以在cpu上交替执行，在k8s中就是表示占用cpu的比率：m：millicores：单位1000m表示1个cpu，其他以此类推</p> </td></tr><tr><td style="width:75px;">内存</td><td style="width:424px;"> <p style="margin-left:.0001pt;text-align:justify;">内存：都是大写开头后面小写</p> <p style="margin-left:.0001pt;text-align:justify;">Ki</p> <p style="margin-left:.0001pt;text-align:justify;">Mi</p> <p style="margin-left:.0001pt;text-align:justify;">Gi</p> <p style="margin-left:.0001pt;text-align:justify;">Ti</p> </td></tr></tbody></table> 
<pre><code class="language-bash">apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: centos
  name: centos
spec:
  replicas: 1
  selector:
    matchLabels:
      app: centos
  template:
    metadata:
      labels:
        app: centos
    spec:
      containers:
      - image: centos:7
        name: centos
        resources:
          limits:
            memory: "1Gi"
            cpu: "1"
#在创建pod时，一定要给容器做资源限制
</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>k8s怎么设置拉取镜像的策略</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:120px;"> <p style="margin-left:.0001pt;text-align:justify;">ifNotPresent</p> </td><td style="width:378px;"> <p style="margin-left:.0001pt;text-align:justify;">果本地镜像有，就不再拉取，本地没有才会去镜像仓库拉取（默认策略）</p> </td></tr><tr><td style="width:120px;"> <p style="margin-left:.0001pt;text-align:justify;">Always</p> </td><td style="width:378px;"> <p style="margin-left:.0001pt;text-align:justify;">不论镜像是否存在，创建时(重启)都会拉取镜像</p> </td></tr><tr><td style="width:120px;"> <p style="margin-left:.0001pt;text-align:justify;">Never</p> </td><td style="width:378px;"> <p style="margin-left:.0001pt;text-align:justify;">仅仅使用本地镜像，本地没有也不会主动拉取</p> </td></tr><tr><td style="width:120px;"></td><td style="width:378px;"> <p style="margin-left:.0001pt;text-align:justify;">如果都是本地部署，那么用Never</p> <p style="margin-left:.0001pt;text-align:justify;">如果涉及到外部部署，默认策略（事前要把docker的镜像导入到目标主机）</p> <p style="margin-left:.0001pt;text-align:justify;">Always：一般不用</p> </td></tr></tbody></table> 
<p><strong>pod的容器健康检查</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:650px;"><tbody><tr><td style="width:143px;"></td><td style="width:505px;"> <p style="margin-left:.0001pt;text-align:justify;">探针：Probe</p> <p style="margin-left:.0001pt;text-align:justify;">k8s对容器执行的定期诊断检查</p> <p style="margin-left:.0001pt;text-align:justify;">探针有三种规则</p> </td></tr><tr><td style="width:143px;">存活探针</td><td style="width:505px;"> <p style="margin-left:.0001pt;text-align:justify;">livenessProbe</p> <p style="margin-left:.0001pt;text-align:justify;">探测容器是否正常运行，如果探测失败，会杀掉容器，容器会根据重启策略来决定是否重启，不是杀掉pod，只对容器</p> </td></tr><tr><td style="width:143px;"> <p style="margin-left:.0001pt;text-align:justify;">流量探针/就绪探针</p> </td><td style="width:505px;"> <p style="margin-left:.0001pt;text-align:justify;">readinessProbe</p> <p style="margin-left:.0001pt;text-align:justify;">探测容器是否进入ready状态，并做好接收请求的准备，如果探测失败 READY 0/1没有进入ready状态，service会把这个资源对象的端点从endpoints中移除，service也不会把请求转发到这个pod</p> </td></tr><tr><td style="width:143px;"> <p style="margin-left:.0001pt;text-align:justify;">启动探针</p> </td><td style="width:505px;"> <p style="margin-left:.0001pt;text-align:justify;">startupProbe</p> <p style="margin-left:.0001pt;text-align:justify;">只是在容器的启动后开始检测，容器内的应用是否启动成功，在启动探测成功之前，所有的其他的其他探针都会处于禁用状态，一旦启动探针结束，后续的操作不再受启动探针的影响</p> </td></tr><tr><td style="width:143px;"></td><td style="width:505px;"> <p style="margin-left:.0001pt;text-align:justify;">结论：在一个容器当中可以有多个探针，启动探针只在容器启动时探测，存活探针，就绪探针</p> </td></tr></tbody></table> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>probe的检查方法</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:87px;"> <p style="margin-left:.0001pt;text-align:justify;">exec探针</p> </td><td style="width:412px;"> <p style="margin-left:.0001pt;text-align:justify;">在容器内部执行命令，如果命令的返回码是0，表示成功，适用于需要容器neutral自定义命令来检查容器的健康状态情况</p> <p style="margin-left:.0001pt;text-align:justify;">Exec相当于执行了一个shell命令：容器里面执行</p> <p style="margin-left:.0001pt;text-align:justify;">Shell命令执行成功：</p> <p style="margin-left:.0001pt;text-align:justify;">返回码：0表示成功</p> <p style="margin-left:.0001pt;text-align:justify;">成功一次就是探测成功</p> </td></tr><tr><td style="width:87px;"> <p style="margin-left:.0001pt;text-align:justify;">httpGet</p> </td><td style="width:412px;"> <p style="margin-left:.0001pt;text-align:justify;">对指定ip+端口的容器发送一个httpget的请求，响应状态码大于等于200，小于400都是成功x&gt;=200&lt;400，适用于检查容器能否响应http的请求，web容器(nginx,tomcat)</p> <p style="margin-left:.0001pt;text-align:justify;">对web容器发起了一次get请求，可以添加path，指定访问的资源，返回码在大于等于200，小于400的范围内都算成功</p> </td></tr><tr><td style="width:87px;"> <p style="margin-left:.0001pt;text-align:justify;">tcpSocket</p> </td><td style="width:412px;"> <p style="text-align:justify;">端口，对指定端口上的容器ip地址进行tcp检查(三次握手)，端口打开，认为探测成功，检查特定容器的端口监听状态</p> <p style="margin-left:.0001pt;text-align:justify;">相当于telnet，指定的容器监听端口是否打开，是否能和指定的容器监听端口进行通信</p> </td></tr><tr><td style="width:87px;"></td><td style="width:412px;"> <p>诊断的结果</p> <p style="text-align:justify;">1.成功，容器通过了，正常运行</p> <p style="text-align:justify;">2.失败，存活探针会重启</p> <p style="text-align:justify;">3.未知，诊断失败</p> </td></tr></tbody></table> 
<pre><code class="language-bash">apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: centos
  name: centos
spec:
  replicas: 1
  selector:
    matchLabels:
      app: centos
  template:
    metadata:
      labels:
        app: centos
    spec:
      containers:
      - image: centos:7
        name: centos
        command: ["/bin/bash","-c", "touch /opt/123.txt ; sleep 3600"]
        livenessProbe:
          exec:
            command: ["/usr/bin/test","-e", "/opt/123.txt"]
          initiaDelaySeconds: 3
#表示容器启动之后多少秒来进行探测，时间不要设置的太短，可能导致无效探测
          periodSeconds: 2
#表示探针探测的间隔时间，每隔多少秒进行一次检查，应用的延迟敏感度，这个应用非常重要，是核心组件
          failureThreshold: 2
#表示如果探测失败，失败几次之后，把容器标记为不健康
          successThreshold: 1
#只要成功一次就标记位就绪，健康，ready
          timeoutSeconds: 1
#表示每次探测的超时时间，在多少秒内必须完成探测

#liveness，杀死容器重启，所有的探针策略伴随整个pod的生命周期，除了启动探针</code></pre> 
<p><strong>探针重启的方式</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:129px;"> <p>存活探针</p> <p><strong>livenessprobe</strong></p> </td><td style="width:369px;">它是杀死容器，重启</td></tr><tr><td style="width:129px;"> <p>就绪探针</p> <p>readinessProbe</p> </td><td style="width:369px;"> <p>pod的状态是running ready，ready状态是notready，容器不可以提供正的业务访问，就绪探针不会重启容器</p> <p>tcpSocket只是监听容器上的业务端口能否正常通信，添加端口8081，8080正常端口是可以访问的，如果更改了容器的启动端口，监听的端口也要更改</p> </td></tr><tr><td style="width:129px;"> <p>启动探针</p> <p>startupProbe</p> </td><td style="width:369px;">如果探测失败，pod的状态是running但是notready，启动探针探测容器失败之后，会直接重启pod</td></tr><tr><td style="width:129px;"></td><td style="width:369px;"> <p>存活探针和就绪探针，会伴随整个pod的生命周期</p> <p>启动探针没有成功之前，后续的探针都不会执行</p> <p>启动探针成功之后，在pod的生命周期内不会再检测启动探针</p> <p>如果重启了pod之后，相当于重新部署(重构)了一个初始版的新的容器，之前删除掉的需要检测文件，又重新生成，故而exec检测成功，但容器内之前的配置都会消失</p> </td></tr></tbody></table> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:42px;">1</td><td style="width:456px;"> <p style="margin-left:.0001pt;text-align:justify;">在一个yaml当中可以有多个探针，启动，存活，就绪，都针对一个容器</p> </td></tr><tr><td style="width:42px;">2</td><td style="width:456px;"> <p style="margin-left:.0001pt;text-align:justify;">启动探针的优先级最高，只有启动探针成功，后续的探针才会执行</p> </td></tr><tr><td style="width:42px;">3</td><td style="width:456px;"> <p style="margin-left:.0001pt;text-align:justify;">启动探针成功之后，后续除非重启pod，不会再触发启动探针</p> </td></tr><tr><td style="width:42px;">4</td><td style="width:456px;"> <p style="margin-left:.0001pt;text-align:justify;">在pod的生命周期中，伴随pod的一直存在，一直探测的是存活探针和就绪探针</p> </td></tr><tr><td style="width:42px;">5</td><td style="width:456px;"> <p style="margin-left:.0001pt;text-align:justify;">在pod的生命周期当中，后续的条件是满足那个探针的条件，触发哪个探针的条件</p> </td></tr><tr><td style="width:42px;">6</td><td style="width:456px;"> <p style="margin-left:.0001pt;text-align:justify;">就绪探针，如果不影响容器运行，status:running ，这个时候不会重启，但是容器退出的话，就绪探针也会重启</p> </td></tr></tbody></table> 
<p><strong>容器启动和退出时的动作</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:103px;">Poststart</td><td style="width:395px;"> <p style="margin-left:.0001pt;text-align:justify;">容器启动钩子，容器启动之后触发的条件</p> </td></tr><tr><td style="width:103px;"> <p style="margin-left:.0001pt;text-align:justify;">PreStop</p> </td><td style="width:395px;"> <p style="margin-left:.0001pt;text-align:justify;">容器退出钩子，容器退出之后触发的条件</p> </td></tr></tbody></table> 
<pre><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
spec:
  containers:
    - name: nginx1
      image: centos:7
      command: ["/bin/bash", "-c","sleep 3600"]
      volumeMounts:
      - name: test1
        mountPath: /opt
        readOnly: false
#声明容器内部的挂载目录
#要给这个挂载卷取名字，不同的挂载卷的名字不能重复
#readonly:false 可读写
      lifecycle:
        postStart:
          exec:
            command: ["/bin/bash","-c","echo 666 &gt;&gt; /opt/123.text ; sleep 10"]
        preStop:
          exec:
            command: ["/bin/bash","-c","echo 666 &gt;&gt; /opt/123.txt"]
  volumes:
  - name: test1
    hostPath:
      path: /opt/test
      type: DirectoryOrCreate
#声明的是node节点上和容器内的/opt挂载目录
#挂载卷的名称要和挂载的容器内挂载卷名称要一一对应
#hostpath：指定和容器的挂载目录
#type：Directoryorcreate：如果节点上的目录不存在，自动创建该目录
#pod会经常被重启，销毁，一旦容器和node节点欧了挂载卷，数据不会丢失</code></pre> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:53px;"></td><td style="width:445px;">启动和退出的作用</td></tr><tr><td style="width:53px;">1</td><td style="width:445px;">启动可以自定义配置容器的内部变量环境</td></tr><tr><td style="width:53px;">2</td><td style="width:445px;">通知机制，告诉用户容器启动完毕</td></tr><tr><td style="width:53px;">3</td><td style="width:445px;">退出时，可以执行自定义命令，删除或者生成一些必要的程序，自定义销毁方式以及自定义资源回收的方式以及容器的退出等待时间</td></tr></tbody></table> 
<pre><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  labels:
    run: tomcat1
  name: tomcat1
spec:
  containers:
  - image: tomcat:8.0.52
    name: tomcat1
    volumeMounts:
    - name: test1
      mountPath: /opt
      readOnly: false
    lifecycle:
      postStart:
        exec:
          command: ["/bin/bash","-c","echo 666 &gt;&gt; /opt/123.text ; sleep 10"]
      preStop:
        exec:
          command: ["/bin/bash","-c","echo 666 &gt;&gt; /opt/123.txt"]
    startupProbe:
      tcpSocket:
        port: 8080
      initialDelaySeconds: 4
      periodSeconds: 2
    livenessProbe:
      tcpSocket:
        port: 8080
      initialDelaySeconds: 4
      periodSeconds: 2
    readinessProbe:
      tcpSocket:
        port: 8080
      initialDelaySeconds: 4
      periodSeconds: 2
  volumes:
  - name: test1
    hostPath:
      path: /opt/test
      type: DirectoryOrCreate
</code></pre> 
<p><img alt="" height="217" src="https://images2.imgbox.com/cc/33/nvuxWC6g_o.png" width="975"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b186bb1fe9260853f3662db5d17fbc47/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">为了搞项目，我差点把京东 “爬“ 了个遍。。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/63ce49ec834297b12e6752f62a3a8785/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">springboot集成eureka、eureka获取服务列表、EurekaURI路径存在未授权访问</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>