<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RestTemplate使用JSON发送Post请求 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RestTemplate使用JSON发送Post请求" />
<meta property="og:description" content="RestTemplate使用JSON发送Post请求 本文我们说下如何使用Spring的 RestTemplate调用post请求，发送json内容。
1. 定义服务端web接口 1.1. 定义业务接口 先定义Person实体类表示post请求的数据：
public class Person { private Integer id; private String name; // standard constructor, getters, setters } 再定义PersonService接口并实现两个方法，关联使用Person类：
public interface PersonService { public Person saveUpdatePerson(Person person); public Person findPersonById(Integer id); } 这些方法的实现仅返回对象，不再具体讨论，让我们聚焦web层。
1.2. 定义业务REST API 下面我们为Person类定义简单的Rest api：
@PostMapping(value = &#34;/createPerson&#34;, consumes = &#34;application/json&#34;, produces = &#34;application/json&#34;) public Person createPerson(@RequestBody Person person) { return personService.saveUpdatePerson(person); } @PostMapping(value = &#34;/updatePerson&#34;, consumes = &#34;application/json&#34;, produces = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b5f1fc8a37d5816f8cefcba611bafbac/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-01T16:56:44+08:00" />
<meta property="article:modified_time" content="2019-09-01T16:56:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RestTemplate使用JSON发送Post请求</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="RestTemplateJSONPost_0"></a>RestTemplate使用JSON发送Post请求</h3> 
<p>本文我们说下如何使用Spring的 RestTemplate调用post请求，发送json内容。</p> 
<h3><a id="1_web_4"></a>1. 定义服务端web接口</h3> 
<h4><a id="11__6"></a>1.1. 定义业务接口</h4> 
<p>先定义Person实体类表示post请求的数据：</p> 
<pre><code>public class Person {
    private Integer id;
    private String name;
 
    // standard constructor, getters, setters
}
</code></pre> 
<p>再定义PersonService接口并实现两个方法，关联使用Person类：</p> 
<pre><code>public interface PersonService {
 
    public Person saveUpdatePerson(Person person);
    public Person findPersonById(Integer id);
}
</code></pre> 
<p>这些方法的实现仅返回对象，不再具体讨论，让我们聚焦web层。</p> 
<h4><a id="12_REST_API_28"></a>1.2. 定义业务REST API</h4> 
<p>下面我们为Person类定义简单的Rest api：</p> 
<pre><code>@PostMapping(value = "/createPerson", consumes = "application/json", produces = "application/json")
public Person createPerson(@RequestBody Person person) {
    return personService.saveUpdatePerson(person);
}
 
@PostMapping(value = "/updatePerson", consumes = "application/json", produces = "application/json")
public Person updatePerson(@RequestBody Person person, HttpServletResponse response) {
    response.setHeader("Location", ServletUriComponentsBuilder.fromCurrentContextPath()
      .path("/findPerson/" + person.getId()).toUriString());
     
    return personService.saveUpdatePerson(person);
}
</code></pre> 
<p>我们需要发送json格式post请求数据，为此，在两个方法的@PostMapping中增加consumes属性并设置值为“application/json”。类似的，设置produces属性值为“application/json”，为了告诉Spring我们希望响应数据也是json格式。</p> 
<p>person参数前的注解@RequestBody，表明person对象和http请求体绑定。最后两个方法返回Person对象会绑定至http响应体。如果给api类增加@RestController注解，则所有api方法都带有@ResponseBody注解。</p> 
<h3><a id="2_RestTemplate_50"></a>2. 使用RestTemplate</h3> 
<p>现在写几个单元测试，测试Person rest api。我们尝试使用RestTemplate发送post请求给Person api，共三个方法： postForObject, postForEntity, and postForLocation。</p> 
<p>开始实现单元测试之前，先定义setup方法初始化单元测试方法中使用的对象：</p> 
<pre><code>@BeforeClass
public static void runBeforeAllTestMethods() {
    createPersonUrl = "http://localhost:8082/spring-rest/createPerson";
    updatePersonUrl = "http://localhost:8082/spring-rest/updatePerson";
 
    restTemplate = new RestTemplate();
    headers = new HttpHeaders();
    headers.setContentType(MediaType.APPLICATION_JSON);
    
   ObjectNode personJsonObject = objectMapper.createObjectNode();
   personJsonObject.put("id", 1);
   personJsonObject.put("name", "John");
}
</code></pre> 
<p>除了setup方法，还要引入ObjectMapper对象转换JSON字符串为JSONNode对象：</p> 
<pre><code>private final ObjectMapper objectMapper = new ObjectMapper();
</code></pre> 
<p>我们前面提到，post请求数据使用json格式。因此，在请求头中增加 Content-Type属性，值为APPLICATION_JSON 。Spring的 HttpHeaders提供不同的方法访问请求头信息。这里需要通过setContentType方法设置Content-Type 属性值为 application/json。然后给请求对象附加头信息。</p> 
<h4><a id="21_postForObjectjson_79"></a>2.1. 使用postForObject方法发送json</h4> 
<p>RestTemplate的postForObject 方法post对象给uri并返回新的对象。返回值自动被转换为responseType参数指定的类型，这里是字符串。</p> 
<p>我们的需求是发送post请求至person api，创建新的Person对象并响应中包括新创建的对象。<br> 首先，基于personJsonObject构建HttpEntity 类型的请求对象，并在请求头中指定Content-Type。然后调用postForObject 方法发送json请求体：</p> 
<pre><code>@Test
public void givenDataIsJson_whenDataIsPostedByPostForObject_thenResponseBodyIsNotNull()
  throws IOException {
    HttpEntity&lt;String&gt; request = new HttpEntity&lt;String&gt;(personJsonObject.toString(), headers);
     
    String personResultAsJsonStr = restTemplate.postForObject(createPersonUrl, request, String.class);
    JsonNode root = objectMapper.readTree(personResultAsJsonStr);
     
    assertNotNull(personResultAsJsonStr);
    assertNotNull(root);
    assertNotNull(root.path("name").asText());
}
</code></pre> 
<p>该示例中 postForObject() 方法返回字符串响应体。我们也可以通过设置responseType参数使其返回Person类型：</p> 
<pre><code>Person person = restTemplate.postForObject(createPersonUrl, request, Person.class);
 
assertNotNull(person);
assertNotNull(person.getName());
</code></pre> 
<p>实际上我们的请求处理方法(createPersonUrl 参数匹配的)产生json格式的响应体，但对postForObject 方法没有限制，通过设置responseType参数可以自动转换为响应的java类型。</p> 
<h4><a id="22_postForEntityjson_111"></a>2.2. 使用postForEntity发送json</h4> 
<p>相比于postForObject()方法， postForEntity() 返回响应体为 ResponseEntity 类型，其他两个方法功能一致。</p> 
<p>我们的需求是发送post请求至person api，创建新的Person对象并返回ResponseEntity类型响应体。可以使用postForEntity实现该功能：</p> 
<pre><code>@Test
public void givenDataIsJson_whenDataIsPostedByPostForEntity_thenResponseBodyIsNotNull()
  throws IOException {
    HttpEntity&lt;String&gt; request = new HttpEntity&lt;String&gt;(personJsonObject.toString(), headers);
     
    ResponseEntity&lt;String&gt; responseEntityStr = restTemplate.
      postForEntity(createPersonUrl, request, String.class);
    JsonNode root = objectMapper.readTree(responseEntityStr.getBody());
  
    assertNotNull(responseEntityStr.getBody());
    assertNotNull(root.path("name").asText());
}
</code></pre> 
<p>类似的，也可以设置responseType 参数转换响应体为Java类型。这里我们能够返回响应体为ResponseEntity，也能返回响应为 ResponseEntity 对象，只要设置responseType参数为 Person.class:</p> 
<pre><code>ResponseEntity&lt;Person&gt; responseEntityPerson = restTemplate.
  postForEntity(createPersonUrl, request, Person.class);
  
assertNotNull(responseEntityPerson.getBody());
assertNotNull(responseEntityPerson.getBody().getName());
</code></pre> 
<h4><a id="23_postForLocationjson_142"></a>2.3. 使用postForLocation发送json</h4> 
<p>与postForObject 和 postForEntity 方法类型, postForLocation 也发送post请求至特定uri并创建新的对象。唯一的差异是返回值为Location头信息。</p> 
<p>前面updatePerson rest api在响应中设置Location 头信息：</p> 
<pre><code>response.setHeader("Location", ServletUriComponentsBuilder.fromCurrentContextPath()
  .path("/findPerson/" + person.getId()).toUriString());
</code></pre> 
<p>现在我们需要实现更新person对象后接收返回带有Location头信息的响应，使用postForLocation 方法：</p> 
<pre><code>@Test
public void givenDataIsJson_whenDataIsPostedByPostForLocation_thenResponseBodyIsTheLocationHeader() 
  throws JsonProcessingException {
    HttpEntity&lt;String&gt; request = new HttpEntity&lt;String&gt;(personJsonObject.toString(), headers);
    URI locationHeader = restTemplate.postForLocation(updatePersonUrl, request);
     
    assertNotNull(locationHeader);
}
</code></pre> 
<h3><a id="3__165"></a>3. 总结</h3> 
<p>本文讲解了RestTemplate 如何发送json类型的post请求，共三种方法应用与不同场景。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/02e9023b62dcee5602472859b501a91d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java解析并计算字符串算式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d5259011f23b97987bbc4774679c759d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">面相对象</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>