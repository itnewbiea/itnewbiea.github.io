<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Python开发】FastAPI 02：请求参数—路径参数、查询参数 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Python开发】FastAPI 02：请求参数—路径参数、查询参数" />
<meta property="og:description" content="进行接口请求时，请求参数是重中之重了！请求参数指客户端向服务端发送请求时，需要传递给服务端的参数，包括路径参数、查询参数、请求体等。举个例子，如果客户端想要获取某个用户的信息，可以向服务端发送一个 GET 请求，并在请求中传递用户的 ID，这个 ID 就是请求参数。本篇文章介绍路径参数和查询参数。
目录
1 基础_路径参数
1.1 声明路径参数
1.2 声明路径参数声明的类型
1.3 路径操作顺序
1.4 预设值
① 创建一个 Enum 类
② 声明路径参数
③ 使用 Python 枚举类型
1.5 包含路径的路径参数
2 基础_查询参数
2.1 声明查询参数
2.2 默认值
2.3 可选参数
2.4 类型转换
3 数值校验_查询参数
3.1 Query 使用
3.2 通过 Query 校验
① default—默认值
② max_length/min_length—字符最大/小长度
③ regex—正则表达式
④ 声明必需参数
⑤ 声明更多元数据
3.3 查询参数设定为列表/多个值
① List[str]
② list
4 数值校验_路径参数
4.1 Path 使用" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2f938c3d832ab8636e1098dc37242110/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-03T12:52:29+08:00" />
<meta property="article:modified_time" content="2023-06-03T12:52:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Python开发】FastAPI 02：请求参数—路径参数、查询参数</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>进行接口请求时，请求参数是重中之重了！请求参数指客户端向服务端发送请求时，需要传递给服务端的参数，包括路径参数、查询参数、请求体等。举个例子，如果客户端想要获取某个用户的信息，可以向服务端发送一个 GET 请求，并在请求中传递用户的 ID，这个 ID 就是请求参数。本篇文章介绍路径参数和查询参数。</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1%20%E5%9F%BA%E7%A1%80_%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0-toc" style="margin-left:0px;"><a href="#1%20%E5%9F%BA%E7%A1%80_%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0" rel="nofollow">1 基础_路径参数</a></p> 
<p id="1.1%20%E5%A3%B0%E6%98%8E%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#1.1%20%E5%A3%B0%E6%98%8E%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0" rel="nofollow">1.1 声明路径参数</a></p> 
<p id="1.2%C2%A0%E5%A3%B0%E6%98%8E%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E5%A3%B0%E6%98%8E%E7%9A%84%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#1.2%C2%A0%E5%A3%B0%E6%98%8E%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E5%A3%B0%E6%98%8E%E7%9A%84%E7%B1%BB%E5%9E%8B" rel="nofollow">1.2 声明路径参数声明的类型</a></p> 
<p id="1.3%C2%A0%E8%B7%AF%E5%BE%84%E6%93%8D%E4%BD%9C%E9%A1%BA%E5%BA%8F-toc" style="margin-left:40px;"><a href="#1.3%C2%A0%E8%B7%AF%E5%BE%84%E6%93%8D%E4%BD%9C%E9%A1%BA%E5%BA%8F" rel="nofollow">1.3 路径操作顺序</a></p> 
<p id="1.4%C2%A0%E9%A2%84%E8%AE%BE%E5%80%BC-toc" style="margin-left:40px;"><a href="#1.4%C2%A0%E9%A2%84%E8%AE%BE%E5%80%BC" rel="nofollow">1.4 预设值</a></p> 
<p id="%E2%91%A0%C2%A0%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%20Enum%20%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%E2%91%A0%C2%A0%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%20Enum%20%E7%B1%BB" rel="nofollow">① 创建一个 Enum 类</a></p> 
<p id="%E2%91%A1%20%E5%A3%B0%E6%98%8E%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E2%91%A1%20%E5%A3%B0%E6%98%8E%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0" rel="nofollow">② 声明路径参数</a></p> 
<p id="%E2%91%A2%20%E4%BD%BF%E7%94%A8%20Python%20%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#%E2%91%A2%20%E4%BD%BF%E7%94%A8%20Python%20%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B" rel="nofollow">③ 使用 Python 枚举类型</a></p> 
<p id="1.5%C2%A0%E5%8C%85%E5%90%AB%E8%B7%AF%E5%BE%84%E7%9A%84%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#1.5%C2%A0%E5%8C%85%E5%90%AB%E8%B7%AF%E5%BE%84%E7%9A%84%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0" rel="nofollow">1.5 包含路径的路径参数</a></p> 
<p id="2%20%E5%9F%BA%E7%A1%80_%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0-toc" style="margin-left:0px;"><a href="#2%20%E5%9F%BA%E7%A1%80_%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0" rel="nofollow">2 基础_查询参数</a></p> 
<p id="2.1%20%E5%A3%B0%E6%98%8E%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#2.1%20%E5%A3%B0%E6%98%8E%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0" rel="nofollow">2.1 声明查询参数</a></p> 
<p id="2.2%20%E9%BB%98%E8%AE%A4%E5%80%BC-toc" style="margin-left:40px;"><a href="#2.2%20%E9%BB%98%E8%AE%A4%E5%80%BC" rel="nofollow">2.2 默认值</a></p> 
<p id="2.3%20%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#2.3%20%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0" rel="nofollow">2.3 可选参数</a></p> 
<p id="2.4%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-toc" style="margin-left:40px;"><a href="#2.4%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" rel="nofollow">2.4 类型转换</a></p> 
<p id="3%C2%A0%E6%95%B0%E5%80%BC%E6%A0%A1%E9%AA%8C_%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0-toc" style="margin-left:0px;"><a href="#3%C2%A0%E6%95%B0%E5%80%BC%E6%A0%A1%E9%AA%8C_%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0" rel="nofollow">3 数值校验_查询参数</a></p> 
<p id="3.1%C2%A0Query%20%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#3.1%C2%A0Query%20%E4%BD%BF%E7%94%A8" rel="nofollow">3.1 Query 使用</a></p> 
<p id="3.2%20%E9%80%9A%E8%BF%87%20Query%20%E6%A0%A1%E9%AA%8C-toc" style="margin-left:40px;"><a href="#3.2%20%E9%80%9A%E8%BF%87%20Query%20%E6%A0%A1%E9%AA%8C" rel="nofollow">3.2 通过 Query 校验</a></p> 
<p id="%E2%91%A0%C2%A0default%E2%80%94%E9%BB%98%E8%AE%A4%E5%80%BC-toc" style="margin-left:80px;"><a href="#%E2%91%A0%C2%A0default%E2%80%94%E9%BB%98%E8%AE%A4%E5%80%BC" rel="nofollow">① default—默认值</a></p> 
<p id="%E2%91%A1%20max_length%2Fmin_length%E2%80%94%E5%AD%97%E7%AC%A6%E6%9C%80%E5%A4%A7%2F%E5%B0%8F%E9%95%BF%E5%BA%A6-toc" style="margin-left:80px;"><a href="#%E2%91%A1%20max_length%2Fmin_length%E2%80%94%E5%AD%97%E7%AC%A6%E6%9C%80%E5%A4%A7%2F%E5%B0%8F%E9%95%BF%E5%BA%A6" rel="nofollow">② max_length/min_length—字符最大/小长度</a></p> 
<p id="%E2%91%A2%20regex%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E2%91%A2%20regex%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">③ regex—正则表达式</a></p> 
<p id="%E2%91%A3%C2%A0%E5%A3%B0%E6%98%8E%E5%BF%85%E9%9C%80%E5%8F%82%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E2%91%A3%C2%A0%E5%A3%B0%E6%98%8E%E5%BF%85%E9%9C%80%E5%8F%82%E6%95%B0" rel="nofollow">④ 声明必需参数</a></p> 
<p id="%E2%91%A4%20%E5%A3%B0%E6%98%8E%E6%9B%B4%E5%A4%9A%E5%85%83%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#%E2%91%A4%20%E5%A3%B0%E6%98%8E%E6%9B%B4%E5%A4%9A%E5%85%83%E6%95%B0%E6%8D%AE" rel="nofollow">⑤ 声明更多元数据</a></p> 
<p id="3.3%20%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A%E4%B8%BA%E5%88%97%E8%A1%A8%2F%E5%A4%9A%E4%B8%AA%E5%80%BC-toc" style="margin-left:40px;"><a href="#3.3%20%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A%E4%B8%BA%E5%88%97%E8%A1%A8%2F%E5%A4%9A%E4%B8%AA%E5%80%BC" rel="nofollow">3.3 查询参数设定为列表/多个值</a></p> 
<p id="%E2%91%A0%C2%A0List%5Bstr%5D-toc" style="margin-left:80px;"><a href="#%E2%91%A0%C2%A0List%5Bstr%5D" rel="nofollow">① List[str]</a></p> 
<p id="%E2%91%A1%20list-toc" style="margin-left:80px;"><a href="#%E2%91%A1%20list" rel="nofollow">② list</a></p> 
<p id="4%C2%A0%E6%95%B0%E5%80%BC%E6%A0%A1%E9%AA%8C_%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0-toc" style="margin-left:0px;"><a href="#4%C2%A0%E6%95%B0%E5%80%BC%E6%A0%A1%E9%AA%8C_%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0" rel="nofollow">4 数值校验_路径参数</a></p> 
<p id="4.1%C2%A0Path%20%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#4.1%C2%A0Path%20%E4%BD%BF%E7%94%A8" rel="nofollow">4.1 Path 使用</a></p> 
<p id="4.2%C2%A0%E6%8C%89%E9%9C%80%E5%AF%B9%E5%8F%82%E6%95%B0%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#4.2%C2%A0%E6%8C%89%E9%9C%80%E5%AF%B9%E5%8F%82%E6%95%B0%E6%8E%92%E5%BA%8F" rel="nofollow">4.2 按需对参数排序</a></p> 
<p id="4.3%20%E9%80%9A%E8%BF%87%20Path%20%E6%A0%A1%E9%AA%8C-toc" style="margin-left:40px;"><a href="#4.3%20%E9%80%9A%E8%BF%87%20Path%20%E6%A0%A1%E9%AA%8C" rel="nofollow">4.3 通过 Path 校验</a></p> 
<p id="%E2%91%A0%C2%A0ge%E2%80%94%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E-toc" style="margin-left:80px;"><a href="#%E2%91%A0%C2%A0ge%E2%80%94%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E" rel="nofollow">① ge—大于等于</a></p> 
<p id="%E2%91%A1%C2%A0gt%E2%80%94%E5%A4%A7%E4%BA%8E%EF%BC%8Cle%E2%80%94%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E-toc" style="margin-left:80px;"><a href="#%E2%91%A1%C2%A0gt%E2%80%94%E5%A4%A7%E4%BA%8E%EF%BC%8Cle%E2%80%94%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E" rel="nofollow">② gt—大于，le—小于等于</a></p> 
<p id="%E2%91%A2%20%E6%80%BB%E7%BB%93-toc" style="margin-left:80px;"><a href="#%E2%91%A2%20%E6%80%BB%E7%BB%93" rel="nofollow">③ 总结</a></p> 
<hr id="hr-toc"> 
<p>📌<strong>源码地址：</strong></p> 
<p><a href="https://gitee.com/yinyuu/fast-api_study_yinyu" rel="nofollow" title="https://gitee.com/yinyuu/fast-api_study_yinyu">https://gitee.com/yinyuu/fast-api_study_yinyu</a></p> 
<p></p> 
<h2 id="1%20%E5%9F%BA%E7%A1%80_%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0">1 基础_路径参数</h2> 
<h3 id="1.1%20%E5%A3%B0%E6%98%8E%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0">1.1 声明路径参数</h3> 
<p>首先简单来声明下<strong>路径参数</strong>（使用与 Python 格式化字符串相同的语法）：</p> 
<pre><code class="language-python">from fastapi import FastAPI

app = FastAPI()

@app.get("/items/{item_id}")
async def read_item(item_id):
    return {"item_id": item_id}</code></pre> 
<p>代码运行后，路径参数 <strong>item_id </strong>的值将作为参数 <strong>item_id </strong>传递给你的函数。此时 <strong>item_id </strong>不限制类型，输入字符串还是数字均可，不过最终都会被后台转化成字符串。</p> 
<p>运行示例并访问 <a href="http://127.0.0.1:8000/items/yinyu" rel="nofollow" title="http://127.0.0.1:8000/items/yinyu">http://127.0.0.1:8000/items/yinyu</a>，将会看到如下响应 👇</p> 
<p style="text-align:center;"><img alt="" class="left" height="82" src="https://images2.imgbox.com/9d/eb/dFPLfGJS_o.png" width="540"></p> 
<p>若访问 <a href="http://127.0.0.1:8000/items/88" rel="nofollow" title="http://127.0.0.1:8000/items/88">http://127.0.0.1:8000/items/88</a> 响应如下，可看到 <strong>88 </strong>已转化为字符串 <strong>"88"</strong>。</p> 
<p style="text-align:center;"><img alt="" class="left" height="94" src="https://images2.imgbox.com/eb/4b/JgSjMsR2_o.png" width="520"></p> 
<h3 id="1.2%C2%A0%E5%A3%B0%E6%98%8E%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E5%A3%B0%E6%98%8E%E7%9A%84%E7%B1%BB%E5%9E%8B">1.2 声明路径参数声明的类型</h3> 
<p>然后简单声明下路径参数声明的<strong>类型</strong>（使用标准的 Python 类型标注）：</p> 
<pre><code class="language-python">@app.get("/items/{item_id}")
async def read_item(item_id: int):
    return {"item_id": item_id}</code></pre> 
<p><span style="color:#333333;"><span style="background-color:#c7e6ea;">该处的声明类型可以理解为限制类型，也就说该路径参数（查询参数相同）声明类型后，你实际在请求该路径时，只能按照提前声明好的类型进行请求。</span></span></p> 
<p>此时访问 <a href="http://127.0.0.1:8000/items/88" rel="nofollow" title="http://127.0.0.1:8000/items/88">http://127.0.0.1:8000/items/88</a>，响应正常，<strong>88 </strong>即为 int 类型。</p> 
<p style="text-align:center;"><img alt="" class="left" height="82" src="https://images2.imgbox.com/56/b1/dOF39sTX_o.png" width="416"></p> 
<p>若此时访问 <a href="http://127.0.0.1:8000/items/yinyu" rel="nofollow" title="http://127.0.0.1:8000/items/yinyu">http://127.0.0.1:8000/items/yinyu</a>，将会返回报错信息，因为 <strong>yinyu </strong>是字符串类型，而不是  <strong>int </strong>类型，这就是声明了类型的作用 👇</p> 
<p style="text-align:center;"><img alt="" class="left" height="178" src="https://images2.imgbox.com/68/8e/URt04Q0i_o.png" width="418"></p> 
<p></p> 
<blockquote> 
 <p>所有的数据校验都由 <a href="https://pydantic-docs.helpmanual.io/" rel="nofollow" title="Pydantic">Pydantic</a> 在幕后完成。</p> 
 <p>你可以使用同样的类型声明来声明 str、float、bool 以及许多其他的复合数据类型。</p> 
</blockquote> 
<p>📌<strong> 文档</strong></p> 
<p>此时访问 <a href="http://127.0.0.1:8000/docs" rel="nofollow" title="http://127.0.0.1:8000/docs">http://127.0.0.1:8000/docs</a>，将看到自动生成的交互式 API 文档：</p> 
<p style="text-align:center;"><img alt="" class="left" height="439" src="https://images2.imgbox.com/c4/a2/MHZC0Ts1_o.png" width="659"></p> 
<h3 id="1.3%C2%A0%E8%B7%AF%E5%BE%84%E6%93%8D%E4%BD%9C%E9%A1%BA%E5%BA%8F">1.3 路径操作顺序</h3> 
<p>在创建路径操作时，会发现有些情况下路径是相同的。</p> 
<p>比如：<span style="background-color:#f3f3f4;">/users/me</span>，假设它用来获取关于当前用户的数据；<span style="background-color:#f3f3f4;">/users/{user_id}</span> ，假设它用来通过用户 ID 获取关于特定用户的数据。</p> 
<p>由于路径操作是按顺序依次运行的，你需要确保路径 <span style="background-color:#f3f3f4;">/users/me</span> 声明在路径 /users/{user_id} 之前！</p> 
<pre><code class="language-python">from fastapi import FastAPI

app = FastAPI()

@app.get("/users/me")
async def read_user_me():
    return {"user_id": "the current user"}

@app.get("/users/{user_id}")
async def read_user(user_id: str):
    return {"user_id": user_id}</code></pre> 
<p>否则，<span style="background-color:#f3f3f4;">/users/{user_id}</span> 的路径还将与 <span style="background-color:#f3f3f4;">/users/me</span> 相匹配，"认为"自己正在接收一个值为 "me" 的 <strong>user_id </strong>参数。</p> 
<h3 id="1.4%C2%A0%E9%A2%84%E8%AE%BE%E5%80%BC">1.4 预设值</h3> 
<p>有时只需要<strong>给路径参数传递几个常用并且固定的有效值</strong>，那么我就可以通过枚举来定制预设值。</p> 
<h4 id="%E2%91%A0%C2%A0%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%20Enum%20%E7%B1%BB">① 创建一个 Enum 类</h4> 
<p>首先导入 <strong>Enum </strong>并创建一个继承自 <strong>str </strong>和 <strong>Enum </strong>的子类，通过从 <strong>str </strong>继承，API 文档将能够知道这些值必须为 <strong>string </strong>类型并且能够正确地展示出来。</p> 
<p>然后创建具有固定值的类属性，比如 <strong>yinyu </strong>、<strong>s1</strong>、<strong>s2</strong>：</p> 
<pre><code class="language-python">from enum import Enum

class ModelName(str, Enum):
    yinyu = "yinyu_v"
    s1 = "s1_v"
    s2 = "s2_v"</code></pre> 
<blockquote> 
 <p>枚举（或 enums）从 <strong>3.4 版本</strong>起在 Python 中可用。</p> 
</blockquote> 
<h4 id="%E2%91%A1%20%E5%A3%B0%E6%98%8E%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0">② 声明路径参数</h4> 
<p>使用定义好的枚举类<strong>（ModelName）</strong>创建一个带有类型标注的路径参数：</p> 
<pre><code class="language-python">'''包含枚举的路径参数'''
@app.get("/models/{model_name}")
async def get_model(model_name: ModelName):</code></pre> 
<blockquote> 
 <p>路径参数 <strong>model_name </strong>的值将传递给函数 <strong>get_model </strong>的参数 <strong>model_name</strong>，并且这个值的取值范围只能是 <strong>ModelName </strong>枚举类中类属性的值。</p> 
</blockquote> 
<h4 id="%E2%91%A2%20%E4%BD%BF%E7%94%A8%20Python%20%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B">③ 使用 Python 枚举类型</h4> 
<p>此时路径参数的值将是一个枚举成员，那么可以做如下的事情，包括<strong>比较枚举成员</strong>（<span style="background-color:#f3f3f4;">if ModelName is ModelName.yinyu</span>）、获取枚举值（<span style="background-color:#f3f3f4;">model_name.value</span>）、返回枚举成员（<span style="background-color:#f3f3f4;">ModelName.s2</span>）等~</p> 
<pre><code class="language-python">@app.get("/models/{model_name}")
async def get_model(model_name: ModelName):
    # 第 1 种判断方式
    if ModelName is ModelName.yinyu:
        return {"model_name": model_name, "message": "yinyu get"}
    # 第 2 种判断方式，效果一样
    if model_name.value == "s1_name":
        return {"model_name": model_name, "message": "s1 get"}
    else:
        return {"model_name": ModelName.s2, "message": "s2 get"}</code></pre> 
<p>📌<strong> 请求该路径</strong></p> 
<p>完全代码：</p> 
<pre><code class="language-python">from enum import Enum
from fastapi import FastAPI

app = FastAPI()

class ModelName(str, Enum):
    yinyu = "yinyu_v"
    s1 = "s1_v"
    s2 = "s2_v"

'''包含枚举的路径参数'''
@app.get("/models/{model_name}")
async def get_model(model_name: ModelName):
    # 第 1 种判断方式
    if ModelName is ModelName.yinyu:
        return {"model_name": model_name, "message": "yinyu get"}
    # 第 2 种判断方式，效果一样
    if model_name.value == "s1_name":
        return {"model_name": model_name, "message": "s1 get"}
    else:
        return {"model_name": ModelName.s2, "message": "s2 get"}</code></pre> 
<p>访问 <a href="http://127.0.0.1:8000/models/yinyu_v" rel="nofollow" title="127.0.0.1:8000/models/yinyu_v">127.0.0.1:8000/models/yinyu_v</a>，响应如下 👇，<span style="background-color:#c7e6ea;">可以确定地是路径参数中的枚举类校验是以枚举成员的属性为准的，比如 <strong>yinyu </strong>的属性值为 <strong>yinyu_v</strong></span>。</p> 
<p style="text-align:center;"><img alt="" class="left" height="98" src="https://images2.imgbox.com/82/ad/5xhil400_o.png" width="430"></p> 
<h3 id="1.5%C2%A0%E5%8C%85%E5%90%AB%E8%B7%AF%E5%BE%84%E7%9A%84%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0">1.5 包含路径的路径参数</h3> 
<p>适用于文件操作，假设现在你有一个路径操作：<span style="background-color:#f3f3f4;">/files/{file_path}</span>，但是你需要 <strong>file_path </strong>本身包含一个 路径， 比如 <span style="background-color:#f3f3f4;">home/yinyu/myfile.txt</span> 。</p> 
<p>此时使用 <strong>Path 转换器</strong>就可以进行转换，你可以这样使用它：</p> 
<pre><code class="language-python">@app.get("/files/{file_path:path}")
async def read_file(file_path: str):
    return {"file_path": file_path}</code></pre> 
<p>参数的名称为 file_path，结尾部分的 :path 说明该参数应匹配任意的路径。</p> 
<blockquote> 
 <p>你可能会需要参数包含 /home/johndoe/myfile.txt，以斜杠（/）开头。此时，URL 将会是 /files//home/johndoe/myfile.txt，在files 和 home 之间有一个双斜杠（//）。</p> 
</blockquote> 
<p></p> 
<h2 id="2%20%E5%9F%BA%E7%A1%80_%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0">2 基础_查询参数</h2> 
<p>声明不属于路径参数的其他函数参数时，它们将被<strong>自动</strong>解释为<strong>"查询字符串"参数</strong>！</p> 
<h3 id="2.1%20%E5%A3%B0%E6%98%8E%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0">2.1 声明查询参数</h3> 
<p>简单声明两个查询参数，可以看到，他和路径参数是不一样的 👇</p> 
<pre><code class="language-python">from fastapi import FastAPI

app = FastAPI()

@app.get("/items1/")
async def read_item(skip: int, limit: int):
    return {"skip": skip,"limit": limit}</code></pre> 
<p>查询字符串是键值对的集合，这些键值对位于 <strong>URL </strong>的 <strong>？</strong>之后，并以 <strong>&amp;</strong> 符号分隔。</p> 
<p>此时访问 <a href="http://127.0.0.1:8000/items/?skip=0&amp;limit=10" rel="nofollow" title="http://127.0.0.1:8000/items/?skip=0&amp;limit=10">http://127.0.0.1:8000/items/?skip=0&amp;limit=10</a> 👇，同时该查询参数也是必需的，因为这两个查询参数没有设置<strong>默认值</strong>和 <strong>None</strong></p> 
<p style="text-align:center;"><img alt="" class="left" height="84" src="https://images2.imgbox.com/ef/f3/eSUwOlR7_o.png" width="401"></p> 
<p>其中：</p> 
<ul><li><strong>skip</strong>：对应的值为 0</li><li><strong>limit</strong>：对应的值为 10</li></ul> 
<p>由于它们是 URL 的一部分，因此它们的"原始值"是字符串。 但是为它们声明了 Python 类型（在上面的示例中为 int）时，它们将转换为该类型并针对该类型进行校验。</p> 
<h3 id="2.2%20%E9%BB%98%E8%AE%A4%E5%80%BC">2.2 默认值</h3> 
<p>由于查询参数不是路径的固定部分，因此它们可以是可选的，并且可以有默认值。比如给上边接口中的查询参数分别设置默认值为 <strong>0</strong> 和 <strong>10</strong>。</p> 
<pre><code class="language-python">@app.get("/items2/")
async def read_item(skip: int = 0, limit: int = 10):
    return {"skip": skip,"limit": limit}</code></pre> 
<p>若此时访问 <a href="http://127.0.0.1:8000/items2/" rel="nofollow" title="127.0.0.1:8000/items2/">127.0.0.1:8000/items2/</a>，虽然未设定查询参数，但是查询参数会成为事先设定好的默认值 👇</p> 
<p style="text-align:center;"><img alt="" class="left" height="98" src="https://images2.imgbox.com/fb/33/rXquc7F3_o.png" width="403"></p> 
<p>若此时访问 <a href="http://127.0.0.1:8000/items2/?skip=20" rel="nofollow" title="127.0.0.1:8000/items2/?skip=20">127.0.0.1:8000/items2/?skip=20</a>，<strong>skip </strong>将成为在 URL 中设定的值，而 <strong>limit </strong>依旧是默认值 👇</p> 
<p style="text-align:center;"><img alt="" class="left" height="92" src="https://images2.imgbox.com/50/e5/pdZKMG4f_o.png" width="412"></p> 
<h3 id="2.3%20%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0">2.3 可选参数</h3> 
<p>通过同样的方式，你可以将它们的默认值设置为 <strong>None </strong>来声明可选查询参数：</p> 
<pre><code class="language-python">from typing import Union 

@app.get("/items3/{item_id}")
async def read_item(item_id: str, q: Union[str, None] = None):
    if q:
        return {"item_id": item_id, "q": q}
    return {"item_id": item_id}</code></pre> 
<p>其中，查询参数 <strong>q </strong>将是可选的，并且默认值为 <strong>None</strong>。<strong><span style="background-color:#c7e6ea;">Union </span></strong><span style="background-color:#c7e6ea;">的作用是传递两种参数，</span><strong><span style="background-color:#c7e6ea;">q</span></strong><span style="background-color:#c7e6ea;"> 既可以是 </span><strong><span style="background-color:#c7e6ea;">str</span></strong><span style="background-color:#c7e6ea;">，也可以为空。</span></p> 
<p>若此时访问 <a href="http://127.0.0.1:8000/items3/yinyu" rel="nofollow" title="127.0.0.1:8000/items3/yinyu">127.0.0.1:8000/items3/yinyu</a>，正常返回，说明查询参数 <strong>q </strong>已经可选 👇</p> 
<p style="text-align:center;"><img alt="" class="left" height="85" src="https://images2.imgbox.com/55/e0/20B1C1hf_o.png" width="410"></p> 
<p>若此时访问 <a href="http://127.0.0.1:8000/items3/yinyu?q=" rel="nofollow" title="127.0.0.1:8000/items3/yinyu?q=">127.0.0.1:8000/items3/yinyu?q=</a>，也是正常返回，可以简单理解为：<span style="background-color:#f3f3f4;">q=None</span>，这就是<strong>Union </strong>的作用。</p> 
<p style="text-align:center;"><img alt="" class="left" height="82" src="https://images2.imgbox.com/68/fc/52rkCsDt_o.png" width="411"></p> 
<p> 若此时访问 <a href="http://127.0.0.1:8000/items3/yinyu?q=yinyu_v" rel="nofollow" title="127.0.0.1:8000/items3/yinyu?q=yinyu_v">127.0.0.1:8000/items3/yinyu?q=yinyu_v</a>，正常返回 👇</p> 
<p style="text-align:center;"><img alt="" class="left" height="99" src="https://images2.imgbox.com/55/5f/azmqKbg4_o.png" width="459"></p> 
<h3 id="2.4%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">2.4 类型转换</h3> 
<p>你还可以声明 <strong>bool </strong>类型，它们将被自动转换：</p> 
<pre><code class="language-python">@app.get("/items4/{item_id}")
async def read_item(item_id: str, q: Union[str, None] = None, short: bool = False):
    item = {"item_id": item_id}
    if q:
        item.update({"q": q})
    if not short:
        item.update(
            {"description": "This is an amazing item that has a long description"}
        )
    return item</code></pre> 
<p>此时，访问 <a href="http://127.0.0.1:8000/items4/yinyu?short=1" rel="nofollow" title="http://127.0.0.1:8000/items4/yinyu?short=1">http://127.0.0.1:8000/items4/yinyu?short=1</a> ，其中 <strong>1</strong> 也可以是 <strong>True 、true、on、yes</strong>中其中一个，包括任何其他的变体形式（大写，首字母大写等等），你的函数接收的 <strong>short </strong>参数都会是布尔值 <strong>True</strong>。</p> 
<p>对于值为 <strong>False </strong>的情况也是一样的。</p> 
<p></p> 
<h2 id="3%C2%A0%E6%95%B0%E5%80%BC%E6%A0%A1%E9%AA%8C_%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0">3 数值校验_查询参数</h2> 
<h3 id="3.1%C2%A0Query%20%E4%BD%BF%E7%94%A8">3.1 Query 使用</h3> 
<p><strong>Query </strong>是 <strong>FastAPI </strong>专门用来装饰查询参数的类，简单使用如下 👇</p> 
<pre><code class="language-python">from typing import Union
#首先从 fastapi 导入 Query
from fastapi import FastAPI,Query

app = FastAPI()

@app.get("/items1/") #然后使用 Query 修饰查询参数
async def read_items(q: Union[str, None] = Query(description="items1 interface")):
    query_items = {"q": q}
    return query_items</code></pre> 
<p><strong>description </strong>是 <strong>Query </strong>中的一个字段，用来描述该参数；<strong><span style="background-color:#c7e6ea;">Union </span></strong><span style="background-color:#c7e6ea;">的作用是传递两种参数，</span><strong><span style="background-color:#c7e6ea;">q</span></strong><span style="background-color:#c7e6ea;"> 既可以是 </span><strong><span style="background-color:#c7e6ea;">str</span></strong><span style="background-color:#c7e6ea;">，也可以为空。</span></p> 
<p>📌<strong> 文档</strong></p> 
<p>此时访问 <a href="http://127.0.0.1:8000/docs" rel="nofollow" title="http://127.0.0.1:8000/docs">http://127.0.0.1:8000/docs</a>，可看到描述信息~</p> 
<p style="text-align:center;"><img alt="" class="left" height="298" src="https://images2.imgbox.com/f6/70/7Bo4CGVe_o.png" width="624"></p> 
<h3 id="3.2%20%E9%80%9A%E8%BF%87%20Query%20%E6%A0%A1%E9%AA%8C">3.2 通过 Query 校验</h3> 
<p>除了上边的<strong> description ，Query </strong>还可以进行一些额外的校验</p> 
<h4 id="%E2%91%A0%C2%A0default%E2%80%94%E9%BB%98%E8%AE%A4%E5%80%BC">① default—默认值</h4> 
<pre><code class="language-python">@app.get("/items21/")
async def read_items(q: Union[str, None] = Query(default=None)):
    query_items = {"q": q}
    return query_items</code></pre> 
<p>此时，该查询参数等同于 ：<span style="background-color:#f3f3f4;">q: Union[str, None] = None</span></p> 
<p>当然，你也可以将默认值设为有效值：</p> 
<pre><code class="language-python">@app.get("/items22/")
async def read_items(q: str = Query(default="fixedquery")):
    query_items = {"q": q}
    return query_items</code></pre> 
<p>此时，该查询参数等同于 ：<span style="background-color:#f3f3f4;">q = "fixedquery"</span></p> 
<h4 id="%E2%91%A1%20max_length%2Fmin_length%E2%80%94%E5%AD%97%E7%AC%A6%E6%9C%80%E5%A4%A7%2F%E5%B0%8F%E9%95%BF%E5%BA%A6">② max_length/min_length—字符最大/小长度</h4> 
<pre><code class="language-python">@app.get("/items2/")
async def read_items(q: Union[str, None] = Query(default=None, max_length=50, min_length=3)):
    query_items = {"q": q}
    return query_items</code></pre> 
<p><strong>max_length </strong>用于限制查询参数的最大长度，<strong>min_length </strong>用于限制查询参数的最小长度，若超出限制将会报错。</p> 
<blockquote> 
 <p>注意：<strong>max_length </strong>和 <strong>min_length </strong>仅可用于 str 类型的查询参数。</p> 
</blockquote> 
<h4 id="%E2%91%A2%20regex%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">③ regex—正则表达式</h4> 
<pre><code class="language-python">@app.get("/items4/")
async def read_items(
    q: Union[str, None] = Query(default=None, regex="^fixedquery$")
):
    query_items = {"q": q}
    return query_items</code></pre> 
<p>这个指定的正则表达式通过以下规则检查接收到的参数值：</p> 
<ul><li><strong>^</strong>：以该符号之后的字符开头，符号之前没有字符。</li><li><strong>fixedquery</strong>: 匹配 fixedquery。</li><li><strong>$</strong>: 到此结束，在 fixedquery 之后不匹配任何字符。</li></ul> 
<p>也就是说该接口的查询参数只能是"<strong>fixedquery</strong>"，不然就会报错，当然其他的正则表达式都是可以拿来用的！</p> 
<h4 id="%E2%91%A3%C2%A0%E5%A3%B0%E6%98%8E%E5%BF%85%E9%9C%80%E5%8F%82%E6%95%B0">④ 声明必需参数</h4> 
<p>首先当使用 Query ，同时需要声明一个值是必需的，只需不声明默认参数：</p> 
<pre><code class="language-python">@app.get("/items5/")
async def read_items(q: str = Query(min_length=3)):
    query_items = {"q": q}
    return query_items</code></pre> 
<p>有另一种方法可以显式的声明一个值是必需的，即将该参数的默认值设为 <strong>...</strong>。</p> 
<pre><code class="language-python">@app.get("/items6/")
async def read_items(q: str = Query(default=..., min_length=3)):
    query_items = {"q": q}
    return query_items</code></pre> 
<p>如果不想使用 <strong>...</strong>，那么可以从 <strong>Pydantic </strong>导入并使用 <strong>Required</strong>：</p> 
<pre><code class="language-python">from pydantic import Required

@app.get("/items7/")
async def read_items(q: str = Query(default=Required, min_length=3)):
    query_items = {"q": q}
    return query_items</code></pre> 
<p>总的来说，我认为直接省略 <strong>default </strong>即可。</p> 
<h4 id="%E2%91%A4%20%E5%A3%B0%E6%98%8E%E6%9B%B4%E5%A4%9A%E5%85%83%E6%95%B0%E6%8D%AE">⑤ 声明更多元数据</h4> 
<p>你可以为查询参数声明额外的校验和元数据，比如：</p> 
<ul><li><strong>alias</strong>：参数别名</li><li><strong>title</strong>：参数标题</li><li><strong>description</strong>：描述</li><li><strong>deprecated</strong>：弃用</li></ul> 
<pre><code class="language-python">@app.get("/items8/")
async def read_items(
    q: Union[str, None] = Query(
        default=None,
        title="Query string",
        description="Query string for the items to search in the database that have a good match",
        alias="item-query", #别名
        deprecated=True
    )
):
    query_items = {"q": q}
    return query_items</code></pre> 
<p>大家不妨自己去试一下，然后访问 <a href="http://127.0.0.1:8000/docs" rel="nofollow" title="http://127.0.0.1:8000/docs">http://127.0.0.1:8000/docs</a> 查看这些元数据在文档中的表现~</p> 
<h3 id="3.3%20%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A%E4%B8%BA%E5%88%97%E8%A1%A8%2F%E5%A4%9A%E4%B8%AA%E5%80%BC">3.3 查询参数设定为列表/多个值</h3> 
<p>我们还可以使用 Query 去接收一组值。</p> 
<h4 id="%E2%91%A0%C2%A0List%5Bstr%5D">① List[str]</h4> 
<p>一种方式是使用 List[str] 来接收一组值：</p> 
<pre><code class="language-python">@app.get("/items9/")
async def read_items(q: Union[List[str], None] = Query(default=None)):
    query_items = {"q": q}
    return query_items</code></pre> 
<p>此时，访问 <a href="http://localhost:8000/items9/?q=foo&amp;q=bar" rel="nofollow" title="localhost:8000/items9/?q=foo&amp;q=bar">localhost:8000/items9/?q=foo&amp;q=bar</a> 👇</p> 
<p style="text-align:center;"><img alt="" class="left" height="110" src="https://images2.imgbox.com/27/42/EBNZlA9X_o.png" width="496"></p> 
<p>这是因为参数 <strong>q </strong>中以一个 <strong>Python list</strong> 的形式接收到查询参数 <strong>q</strong> 的多个值（<strong>foo </strong>和 <strong>bar</strong>）。</p> 
<p>同样的，我们可以定义在没有任何给定值时的默认 list 值：</p> 
<pre><code class="language-python">@app.get("/items10/")
async def read_items(q: List[str] = Query(default=["foo", "bar"])):
    query_items = {"q": q}
    return query_items</code></pre> 
<h4 id="%E2%91%A1%20list">② list</h4> 
<p>你也可以直接使用 <strong>list </strong>代替 <strong>List [str]</strong>：</p> 
<pre><code class="language-python">@app.get("/items11/")
async def read_items(q: list = Query(default=[])):
    query_items = {"q": q}
    return query_items</code></pre> 
<blockquote> 
 <p>注意：在这种情况下 FastAPI 将不会检查列表的内容。</p> 
 <p>例如，List[int] 将检查（并记录到文档）列表的内容必须是整数，但是单独的 list 不会。</p> 
</blockquote> 
<p></p> 
<h2 id="4%C2%A0%E6%95%B0%E5%80%BC%E6%A0%A1%E9%AA%8C_%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0">4 数值校验_路径参数</h2> 
<p>和前边使用 Query 声明查询参数的更多验证和元数据的方法相同，我们也可以通过Path声明路径参数的相同类型的验证和元数据。</p> 
<h3 id="4.1%C2%A0Path%20%E4%BD%BF%E7%94%A8">4.1 Path 使用</h3> 
<p>简单来说，引入 Path，然后</p> 
<pre><code class="language-python">#1.从 fastapi 导入 Path
from fastapi import FastAPI,Path

app = FastAPI()

@app.get("/items1/{item_id}")
async def read_items(
    #2.声明路径参数 item_id的 title 元数据值
    item_id: int = Path(title="The ID of the item to get"),
):
    return {"item_id": item_id}</code></pre> 
<blockquote> 
 <p>路径参数总是必需的，你可以在声明时使用 ... 将其标记为必需参数。 不过，即使你不设置或使用 None 声明路径参数，那么也不会有任何影响，它依然会是必需参数。</p> 
</blockquote> 
<h3 id="4.2%C2%A0%E6%8C%89%E9%9C%80%E5%AF%B9%E5%8F%82%E6%95%B0%E6%8E%92%E5%BA%8F">4.2 按需对参数排序</h3> 
<p>如果你要声明 <strong>q </strong>查询参数而不使用 <strong>Query </strong>或任何默认值，并且使用 <strong>Path </strong>声明路径参数 <strong>item_id </strong>和使用不同的顺序，则 <strong>Python </strong>对此有一些特殊的语法。语法规则如下：</p> 
<ul><li><span style="background-color:#c7e6ea;">传递 * 作为函数的第一个参数。</span></li></ul> 
<p><strong>Python </strong>不会对该 <strong>* </strong>做任何事情，但是它将知道之后的所有参数都应作为关键字参数（键值对），也被称为 kwargs，来调用。即使它们没有默认值。</p> 
<pre><code class="language-python">@app.get("/items2/{item_id}")
async def read_items(
        *, 
        item_id: int = Path(title="The ID of the item to get"), 
        q: str
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results
</code></pre> 
<p>此时访问 <a href="http://localhost:8000/items2/2222?q=yinyu" rel="nofollow" title="localhost:8000/items2/2222?q=yinyu">localhost:8000/items2/2222?q=yinyu</a> 👇</p> 
<p style="text-align:center;"><img alt="" class="left" height="93" src="https://images2.imgbox.com/dd/eb/a2NAfOhA_o.png" width="447"></p> 
<p>若将 <strong>q </strong>和 <strong>item_id </strong>顺序调换一下，实际接口请求时也不会收到影响：</p> 
<pre><code class="language-python">@app.get("/items2/{item_id}")
async def read_items(
        *,
        q: str,
        item_id: int = Path(title="The ID of the item to get"),
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results</code></pre> 
<h3 id="4.3%20%E9%80%9A%E8%BF%87%20Path%20%E6%A0%A1%E9%AA%8C">4.3 通过 Path 校验</h3> 
<p>使用 <strong>Query </strong>和 <strong>Path</strong>（以及后边其他的类）不仅可以声明字符串约束，还可以声明数值约束（<strong>int</strong>、<strong>float </strong>等数值类型）。</p> 
<h4 id="%E2%91%A0%C2%A0ge%E2%80%94%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E">① ge—大于等于</h4> 
<p>比如，添加 <strong>ge=1</strong> 后，<strong>item_id </strong>将必须是一个大于（<strong>greater than</strong>）或等于（<strong>equal</strong>）<strong>1 </strong>的整数。</p> 
<pre><code class="language-python">@app.get("/items3/{item_id}")
async def read_items(
    *, item_id: int = Path(title="The ID of the item to get", ge=1), q: str
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results</code></pre> 
<h4 id="%E2%91%A1%C2%A0gt%E2%80%94%E5%A4%A7%E4%BA%8E%EF%BC%8Cle%E2%80%94%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E">② gt—大于，le—小于等于</h4> 
<p>同样的规则适用于：</p> 
<ul><li>gt：大于（greater than）</li><li>le：小于等于（less than or equal）</li></ul> 
<pre><code class="language-python">@app.get("/items4/{item_id}")
async def read_items(
    *,item_id: int = Path(title="The ID of the item to get", gt=0, le=1000),q: str,
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results</code></pre> 
<h4 id="%E2%91%A2%20%E6%80%BB%E7%BB%93">③ 总结</h4> 
<ul><li>gt：大于（greater than）</li><li>ge：大于等于（greater than or equal）</li><li>lt：小于（less than）</li><li>le：小于等于（less than or equal）</li></ul> 
<blockquote> 
 <p>Query、Path 以及你后面会看到的其他类继承自一个共同的 Param 类（不需要直接使用它）。 而且它们都共享相同的所有你已看到并用于添加额外校验和元数据的参数。</p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a46f1d754522b85d39900f930cd47cab/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">攻防世界-基础android</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/983af2a73a1db2fb7beaa4e629498a7c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">浏览器多线程到事件循环机制</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>