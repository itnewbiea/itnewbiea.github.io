<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Mybatis中实现批量更新的几种方式 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Mybatis中实现批量更新的几种方式" />
<meta property="og:description" content="一、概述 mybatis中实现批量插入是很简单的，相比大家都知道，这里就不赘述，本文主要讲述如何实现批量更新。
下面介绍本文要讲的几种方式主要是在xml中实现，不包含需要改动代码逻辑的方法，这里，除了网上说的普通情况，还有适合mysql和oracle的批量更新方式： 1. case when 2. foreach成多条sql 3. ON DUPLICATE KEY UPDATE （mysql） 4. replace into （mysql）
这次，我要讲的就是这四种方式。
二、case when 这种方式实现的批量更新操作效率很低，而且，当更新的字段很多时，SQL语句会特别长。
&lt;update id=&#34;updateBatch&#34;&gt; update t_calendar_extend &lt;trim prefix=&#34;set&#34; suffixOverrides=&#34;,&#34;&gt; &lt;trim prefix=&#34;modify_time = case index&#34; suffix=&#34;end,&#34;&gt; &lt;foreach collection=&#34;list&#34; item=&#34;item&#34;&gt; when #{item.index} then #{item.modifyTime} &lt;/foreach&gt; &lt;/trim&gt; &lt;trim prefix=&#34;user_type = case index&#34; suffix=&#34;end&#34;&gt; &lt;foreach collection=&#34;list&#34; item=&#34;item&#34;&gt; when #{item.index} then #{item.type} &lt;/foreach&gt; &lt;/trim&gt; &lt;/trim&gt; &lt;where&gt; index in ( &lt;foreach collection=&#34;list&#34; separator=&#34;,&#34; item=&#34;item&#34;&gt; #{item.index} &lt;/foreach&gt; ) &lt;/where&gt; &lt;/update&gt; 这里，根据index值来更新modify_time 和user_type的值，有几个字段，就要遍历几遍，效率很低。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/dab67c5a5c41c54103878bd78d404c88/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-28T10:12:12+08:00" />
<meta property="article:modified_time" content="2023-08-28T10:12:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Mybatis中实现批量更新的几种方式</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>一、概述</h4> 
<p>mybatis中实现批量插入是很简单的，相比大家都知道，这里就不赘述，本文主要讲述如何实现批量更新。</p> 
<p>下面介绍本文要讲的几种方式主要是在xml中实现，<strong>不包含需要改动代码逻辑的方法</strong>，这里，除了网上说的普通情况，还有适合mysql和oracle的批量更新方式： 1. case when 2. foreach成多条sql 3. ON DUPLICATE KEY UPDATE （mysql） 4. replace into （mysql）</p> 
<p><strong>这次，我要讲的就是这四种方式。</strong></p> 
<h4>二、case when</h4> 
<p>这种方式实现的批量更新操作效率很低，而且，当更新的字段很多时，SQL语句会特别长。</p> 
<pre><code class="language-XML">&lt;update id="updateBatch"&gt;
    update t_calendar_extend
    &lt;trim prefix="set" suffixOverrides=","&gt;
        &lt;trim prefix="modify_time = case index" suffix="end,"&gt;
            &lt;foreach collection="list" item="item"&gt;
                when #{item.index} then #{item.modifyTime}
            &lt;/foreach&gt;
        &lt;/trim&gt;
        &lt;trim prefix="user_type = case index" suffix="end"&gt;
            &lt;foreach collection="list" item="item"&gt;
                when #{item.index} then #{item.type}
            &lt;/foreach&gt;
        &lt;/trim&gt;
    &lt;/trim&gt;
    &lt;where&gt;
        index in (
        &lt;foreach collection="list" separator="," item="item"&gt;
            #{item.index}
        &lt;/foreach&gt;
        )
    &lt;/where&gt;
&lt;/update&gt;</code></pre> 
<p>这里，根据index值来更新modify_time 和user_type的值，有几个字段，就要遍历几遍，效率很低。</p> 
<h4>三、foreach成多条sql</h4> 
<p>这种方式最简单，就是用foreach组装成多条update语句，但Mybatis映射文件中的sql语句默认是不支持以" ; " 结尾的，也就是不支持多条sql语句的执行。所以需要在连接mysql的url上加 &amp;allowMultiQueries=true 这个才可以执行。</p> 
<pre><code class="language-XML">&lt;update id="updateBatch"  parameterType="java.util.List"&gt;  
    &lt;foreach collection="list" item="item" index="index" open="" close="" separator=";"&gt;
        update tableName
        &lt;set&gt;
            name=${item.name},
            name2=${item.name2}
        &lt;/set&gt;
        where id = ${item.id}
    &lt;/foreach&gt;      
&lt;/update&gt;</code></pre> 
<h4>四、ON DUPLICATE KEY UPDATE</h4> 
<p>MYSQL中的ON DUPLICATE KEY UPDATE，是基于主键（PRIMARY KEY）或唯一索引（UNIQUE INDEX）使用的。</p> 
<p><strong>如果已存在该唯一标示或主键就更新，如果不存在该唯一标示或主键则作为新行插入。</strong></p> 
<pre><code class="language-XML">&lt;update id="updateBatch"&gt;
    insert into t_output_calendar (index, 
      cal_date, user_type, create_time, 
      modify_time, delete_flag
      )
    values
    &lt;foreach collection="list" item="item" index="index"
        separator=","&gt;
        (
        #{item.index,jdbcType=INTEGER}, 
        #{item.calDate,jdbcType=TIMESTAMP}, 
        #{item.type,jdbcType=TINYINT}, 
        #{item.createTime,jdbcType=TIMESTAMP}, 
        #{item.modifyTime,jdbcType=TIMESTAMP}, 
        #{item.deleteFlag,jdbcType=TINYINT}
        )
    &lt;/foreach&gt;
    &lt;!--存在即可修改下述字段的数据，注意values()中的内容是数据表中相应的字段名--&gt;	
    ON DUPLICATE KEY UPDATE modify_time = VALUES(modify_time), user_type = VALUES(user_type);
&lt;/update&gt;</code></pre> 
<h4>五、replace into</h4> 
<p>msql的replace into跟insert into的用法完全一样，但是它带有更新功能：</p> 
<p><strong>如果发现表中已经有此行数据（根据主键或者唯一索引判断）则先删除此行数据，然后插入新的数据。否则，直接插入新数据。</strong></p> 
<p>注意，它是先删除数据，然后再插入，这是和<code>ON DUPLICATE KEY UPDATE</code>不同的地方,如果当前的数据库用户没有删除权限，是不能使用replace into的。</p> 
<p>示例：</p> 
<pre><code class="language-XML">&lt;insert id="updateBatch" parameterType="java.util.List"&gt;
    replace into t_output_calendar (index, cal_date, user_type, create_time, 
      modify_time, delete_flag
      )
    values
    &lt;foreach collection="list" item="item" index="index"
        separator=","&gt;
        (
        #{item.index,jdbcType=INTEGER}, 
        #{item.calDate,jdbcType=TIMESTAMP}, 
        #{item.type,jdbcType=TINYINT}, 
        #{item.createTime,jdbcType=TIMESTAMP}, 
        #{item.modifyTime,jdbcType=TIMESTAMP}, 
        #{item.deleteFlag,jdbcType=TINYINT}
        )
    &lt;/foreach&gt;
&lt;/insert&gt;</code></pre> 
<p></p> 
<p>1、insert into表示插入数据，数据库会检查主键，如果出现重复会报错；</p> 
<p>2、replace into表示插入替换数据，需求表中有PrimaryKey，或者unique索引，如果数据库已经存在数据，则用新数据替换，如果没有数据效果则和insert into一样；</p> 
<pre><code class="language-XML">-- 存在就更新：
REPLACE INTO 表名(字段1, 字段2, ...) VALUES(值1, 值2, ...), (值1, 值2, ...);</code></pre> 
<p>3、insert ignore表示，如果表中如果已经存在相同的记录，则忽略当前新数据；</p> 
<pre><code class="language-XML">-- 存在就忽略：
INSERT IGNORE 表名(字段1, 字段2, ...) VALUES(值1, 值2, ...), (值1, 值2, ...);</code></pre> 
<p>4、on duplicate key update 使用该语法可在插入记录的时候先判断记录是否存在，如果不存在则插入，否则更新，很方便，无需执行两条SQL </p> 
<p></p> 
<p>更新 100000条数据的性能就测试结果来看，测试当时使用replace into性能较好。</p> 
<p><code>replace into</code> 和 <code>insert into on duplicate key update</code>的不同在于：</p> 
<p><code>replace into</code> 操作本质是对重复的记录先<code>delete</code> 后<code>insert</code>，如果更新的字段不全会将缺失的字段置为缺省值，用这个要悠着点否则不小心清空大量数据可不是闹着玩的。<br><code>insert into on duplicate key update</code> 则是只<code>update</code>重复记录，不会改变其它字段。</p> 
<p></p> 
<p>参考文章：</p> 
<p><a href="https://blog.csdn.net/zk673820543/article/details/106579809/" title="Mysql 批量修改四种方式效率对比（一）_mysql的replac into 效率_程序员深夜写bug的博客-CSDN博客">Mysql 批量修改四种方式效率对比（一）_mysql的replac into 效率_程序员深夜写bug的博客-CSDN博客</a></p> 
<p><a href="https://mp.weixin.qq.com/s/w8gNtVSJUKw--QxMRKXMxw" rel="nofollow" title="SpringBoot 高效批量插入万级数据，哪种方式最强？">SpringBoot 高效批量插入万级数据，哪种方式最强？</a> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ed8b9bfe70007a2bee5459b389b56b98/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端需要理解的性能优化知识</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ff7786fd78b0b9c12516c6f9ba8e2dff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">流媒体弱网优化之路(BBR应用)——GCC与BBR的算法思想分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>