<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>提取CNN模型中间层输出方法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="提取CNN模型中间层输出方法" />
<meta property="og:description" content="前言 针对结构中定义了多个nn.sequential的网络模型，无法直接获取其内部某一中间层的输出，本文将给出两个方法进行解决。
方法 1 逐层进行forward 创建自定义函数，实现按照执行顺序逐层前向执行网络模型。
-----将模型输入以及模型作为参数传入函数，返回目标结果
def extract_res(inp, model): for index, module in enumerate(model.modules()): # 按执行顺序遍历网络各层操作 if index in [0, 1, ...]: # 去除非操作层 continue inp = module(inp) # 逐层前向执行，得到结果 if index == 3: # 判断是否为目标层 (示例为索引为3的操作) return inp tip: 利用.modules()在进行遍历操作时，其顺序为：
【总网络结构–&gt;各部分–&gt;各部分内部】
==》可见index = 0，1对应为非操作层，需要避免其执行forward。
故在使用此方法时，需要注意摒弃非操作层，跳过执行。此外，须推理出目标输出层对应索引号，才能实现精准获取。
2 使用hook函数 （1）定义保存hook内容的对象类
class SaveOutput: def __init__(self): self.outputs = [] def __call__(self, module, module_in, module_out): self.outputs.append(module_out) def clear(self): self.outputs = [] （2） 为卷积层注册hook" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8c2daea2835811c81a5cf9852e68aa5f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-21T11:24:30+08:00" />
<meta property="article:modified_time" content="2022-04-21T11:24:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">提取CNN模型中间层输出方法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>前言</h3> 
<p>针对结构中定义了<strong>多个nn.sequential</strong>的网络模型，<mark>无法直接获取其内部某一中间层的输出</mark>，本文将给出两个方法进行解决。<br> <img src="https://images2.imgbox.com/64/5a/oGfwUXzT_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/86/23/zaPgRPgK_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_4"></a>方法</h3> 
<h4><a id="1_forward_5"></a>1 逐层进行forward</h4> 
<p>创建自定义函数，实现<mark>按照执行顺序</mark>逐层前向执行网络模型。<br> -----将<strong>模型输入</strong>以及<strong>模型</strong>作为参数传入函数，返回<strong>目标结果</strong></p> 
<pre><code>def extract_res(inp, model):
    for index, module in enumerate(model.modules()):  # 按执行顺序遍历网络各层操作
        if index in [0, 1, ...]:  # 去除非操作层
            continue
        inp = module(inp)  # 逐层前向执行，得到结果
        if index == 3:  # 判断是否为目标层  (示例为索引为3的操作)
            return inp
</code></pre> 
<p><strong><mark>tip:</mark></strong> 利用.modules()在进行遍历操作时，其顺序为：<br> 【总网络结构–&gt;各部分–&gt;各部分内部】<br> <img src="https://images2.imgbox.com/cb/90/9gehq0HH_o.png" alt=""><br> <img src="https://images2.imgbox.com/e9/f4/UZRP7f0t_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/d6/06/BMCGdJUe_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/38/cb/7bftssMh_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/20/72/ZfOvivD4_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/da/3b/zsLssp9e_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/ff/68/VInCkgkp_o.png" alt="在这里插入图片描述"><br> ==》可见index = 0，1对应为非操作层，需要避免其执行forward。<br> 故在使用此方法时，需要注意<strong>摒弃非操作层</strong>，跳过执行。此外，须<strong>推理出目标输出层对应索引号</strong>，才能实现精准获取。</p> 
<hr> 
<h4><a id="2_hook_28"></a>2 使用hook函数</h4> 
<p>（1）定义保存hook内容的对象类</p> 
<pre><code>class SaveOutput:
    def __init__(self):
        self.outputs = []

    def __call__(self, module, module_in, module_out):
        self.outputs.append(module_out)

    def clear(self):
        self.outputs = []
</code></pre> 
<p>（2） 为卷积层注册hook</p> 
<pre><code>	hook_handles = []
	save_output = SaveOutput()
	for layer in model.modules():     # 按执行顺序遍历网络各层操作
	if isinstance(layer, nn.Linear):   # 按操作指令进行判别
	        handle = layer.register_forward_hook(save_output)
	        hook_handles.append(handle)
</code></pre> 
<p>代码中示例即为寻找<strong>所有为执行nn.Linear（）的操作层</strong></p> 
<p>（3） 对输入x进行预测（过程中每计算一个输出将自动调用hook函数）</p> 
<pre><code>out = model(x)  
</code></pre> 
<p>（4）取出通过目标层的输出</p> 
<pre><code>data = save_output.outputs[2]    # 2为目标操作层输出在最终结果列表中的索引
</code></pre> 
<p><strong><mark>tip:</mark></strong> 网络<strong>包含几个操作同名层</strong>，<strong>save_output.outputs的size就为多少</strong>，取出对应位置的输出即可</p> 
<p>------tbc-------<br> 有用可以点个大拇指哦 🤭</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/773a7cd03bd0369470042f3ee075d1ae/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL修改最大连接数限制</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/40951c537f765bb94598bf0e71c3350b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">golang中级进阶（五）：接口接收者、结构体多接口、接口嵌套、空接口类型断言使用细节</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>