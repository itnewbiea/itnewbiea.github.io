<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>apache commons collections - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="apache commons collections" />
<meta property="og:description" content="apache commons collections 本文简要的介绍了apache commons中的collections框架内容。 commons collections ： java集合框架是jdk 1.3对jdk1.2的一个主要的补充。java集合框架包含了很多强大的数据结构，这些数据结构加快了很多重要的java程序的开发。从那之后，集合框架就已经成为java处理集合的公开标准。 commons-collections以jdk的集合框架为基础，提供了新的接口、实现以及工具。它具有以下特点： ® bag接口：适用于包含一个对象的多个拷贝的集合 ® buffer接口：适用于具有顺序的集合类，例如fifos(先进先出) ® bidimap(双向映射)：可以通过值查找键，也可以通过键查找值 ® map迭代器：提供了对映射的快速迭代 ® 对类型检查进行了封装，确保特定类的实例可以被添加到集合中 ® 对转换进行了封装，将集合中的对象转换成被加入时的类型 ® 对集合进行组合，使多个集合看起来就像一个集合一样 ® 有序映射和set，保持元素添加时的顺序，包括一个基于lru的map ® 标识映射可以给予对象的==来比较对象，而不是基于equals方法 ® 引用映射可以允许键and/or值可以有控制的进行回收 ® 很多比较器的实现 ® 很多迭代器的实现 ® 从数组或者枚举到集合的适配器 ® 用来测试或者创建典型set理论的集合属性，例如与、或、闭包 用户指南： commons-collections为了帮助日复一日的编程，提供了大量的类。本部分主要介绍了一些collections的关键特性。 注意同步 commons-collections使用了和标准java集合类似的同步设计方法。如果不添加额外的同步方法，大多数关于集合、映射和bag的实现都不是线程安全的。集合的synchronizexxx方法就是这些实现中的一种方式，可以使集合在多线程的应用程序中被同步。 类层次的javadoc应该指出如果没有额外的同步机制，在进行多线程访问时，某个特定的实现是否是安全的。如果没有特别指出是线程安全的，那么就被认为是需要进行同步的。 工具类： 每个主要的集合接口都有一个utility类。因此，set和sortedset接口的utility类就是setutils。这些utility类提供了操作集合类型的共通方法。 基本的方法都包含在两个根集合接口的utility类中，即collectionutils和maputils。因为所有的其他集合接口都集成collection或者map，所以collectionutils和maputils可以被扩展使用。共同的方法包括交集操作、计数操作、迭代操作、逻辑操作和类型强制转换操作等。同时，utility类还提供了对集合封装类的访问，这与jdk collections类的方式类似。 maps ： map 迭代 jdk中的map接口很难进行迭代。api用户总是需要通过entryset或者keyset进行迭代。commons-collectons现在提供了一个新的接口—mapiterator来允许对maps进行简单的迭代。 iterablemap map = new hashmap(); mapiterator it = map.mapiterator(); while(it.hasnext()){ object key = it.next(); object value = it." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4d01803acba5cb37c0d748292726043f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2010-08-04T14:10:00+08:00" />
<meta property="article:modified_time" content="2010-08-04T14:10:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">apache commons collections</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>apache commons collections</h2> 
<p align="center"> </p> 
<p style="color: #666666;"><a href="http://www.dnbcw.com/biancheng/java" rel="nofollow"></a></p>   
<p></p> 
<div>
  本文简要的介绍了apache commons中的collections框架内容。 
 <strong>commons collections</strong> 
 <strong>：</strong> 
</div> 
<div>
  java集合框架是jdk 1.3对jdk1.2的一个主要的补充。java集合框架包含了很多强大的数据结构，这些数据结构加快了很多重要的java程序的开发。从那之后，集合框架就已经成为java处理集合的公开标准。 
</div> 
<div>
  commons-collections以jdk的集合框架为基础，提供了新的接口、实现以及工具。它具有以下特点： 
</div> 
<div>
  ® bag接口：适用于包含一个对象的多个拷贝的集合 
</div> 
<div>
  ® buffer接口：适用于具有顺序的集合类，例如fifos(先进先出) 
</div> 
<div>
  ® bidimap(双向映射)：可以通过值查找键，也可以通过键查找值 
</div> 
<div>
  ® map迭代器：提供了对映射的快速迭代 
</div> 
<div>
  ® 对类型检查进行了封装，确保特定类的实例可以被添加到集合中 
</div> 
<div>
  ® 对转换进行了封装，将集合中的对象转换成被加入时的类型 
</div> 
<div>
  ® 对集合进行组合，使多个集合看起来就像一个集合一样 
</div> 
<div>
  ® 有序映射和set，保持元素添加时的顺序，包括一个基于lru的map 
</div> 
<div>
  ® 标识映射可以给予对象的==来比较对象，而不是基于equals方法 
</div> 
<div>
  ® 引用映射可以允许键and/or值可以有控制的进行回收 
</div> 
<div>
  ® 很多比较器的实现 
</div> 
<div>
  ® 很多迭代器的实现 
</div> 
<div>
  ® 从数组或者枚举到集合的适配器 
</div> 
<div>
  ® 用来测试或者创建典型set理论的集合属性，例如与、或、闭包 
</div> 
<div> 
 <strong>用户指南：</strong> 
</div> 
<div>
  commons-collections为了帮助日复一日的编程，提供了大量的类。本部分主要介绍了一些collections的关键特性。 
</div> 
<div> 
 <em>注意同步</em> 
</div> 
<div>
  commons-collections使用了和标准java集合类似的同步设计方法。如果不添加额外的同步方法，大多数关于集合、映射和bag的实现都不是线程安全的。集合的synchronizexxx方法就是这些实现中的一种方式，可以使集合在多线程的应用程序中被同步。 
</div> 
<div>
  类层次的javadoc应该指出如果没有额外的同步机制，在进行多线程访问时，某个特定的实现是否是安全的。如果没有特别指出是线程安全的，那么就被认为是需要进行同步的。 
</div> 
<div> 
 <strong>工具类：</strong> 
</div> 
<div>
  每个主要的集合接口都有一个utility类。因此，set和sortedset接口的utility类就是setutils。这些utility类提供了操作集合类型的共通方法。 
</div> 
<div>
  基本的方法都包含在两个根集合接口的utility类中，即collectionutils和maputils。因为所有的其他集合接口都集成collection或者map，所以collectionutils和maputils可以被扩展使用。共同的方法包括交集操作、计数操作、迭代操作、逻辑操作和类型强制转换操作等。同时，utility类还提供了对集合封装类的访问，这与jdk collections类的方式类似。 
</div> 
<div> 
 <strong>maps</strong> 
 <strong>：</strong> 
</div> 
<div> 
 <em>map</em> 
 <em>迭代</em> 
</div> 
<div>
  jdk中的map接口很难进行迭代。api用户总是需要通过entryset或者keyset进行迭代。commons-collectons现在提供了一个新的接口—mapiterator来允许对maps进行简单的迭代。 
</div> 
<div>
  iterablemap map = new hashmap(); 
</div> 
<div>
  mapiterator it = map.mapiterator(); 
</div> 
<div>
  while(it.hasnext()){ 
</div> 
<div>
  object key = it.next(); 
</div> 
<div>
  object value = it.getvalue(); 
</div> 
<div>
  it.setvalue(newvalue); 
</div> 
<div>
  } 
</div> 
<div> 
 <em>有序</em> 
 <em>map</em> 
</div> 
<div>
  commons-collections为maps提供了一个新的接口，orderedmap，这个接口是有顺序的，但是并没有进行排序。linkedmap和listorderedmap(封装器)是这个接口的两种实现。这个接口支持map迭代，同时允许对map进行前向迭代和反向迭代。 
</div> 
<div>
  orderedmap map = new hashmap(); 
</div> 
<div>
  map.put(“five”,5); 
</div> 
<div>
  map.put(“six”,6); 
</div> 
<div>
  map.put(“seven”,7); 
</div> 
<div>
  map.firstkey();       //returns “five” 
</div> 
<div>
  map.nextkey(“five”);   //returns “six” 
</div> 
<div>
  map.nextkey(“six”);     //returns “seven” 
</div> 
<div> 
 <em>biddirectional maps</em> 
 <em>双向映射</em> 
</div> 
<div>
  commons-collections提供了新的接口层次，用于支持双向的映射，即bidimap接口。可以通过key来查找value，也可以通过value来查找key。 
</div> 
<div>
  bidimap bidi = new treebidimap(); 
</div> 
<div>
  bidi.put(“six”,”6”); 
</div> 
<div>
  bidi.get(“six”);      //returns “6” 
</div> 
<div>
  bidi.getkey(“6”);    //returns “six” 
</div> 
<div>
  bidi.removevalue(“6”);  //removes the mapping 
</div> 
<div>
  bidimap inverse = bidi.inversebidimap();  //returns a map with keys and values swapped 
</div> 
<div>
  对于有序的和排序的双向map，也公共了对应的接口。对于每种双向map类型都提供了接口的实现。 
</div> 
<div> 
 <strong>queues&amp;buffers </strong> 
 <strong>队列和缓冲</strong> 
</div> 
<div>
  buffer接口用来支持队列和缓冲。这些接口表示集合可以定义删除的顺序。 
</div> 
<div>
  buffer buffer = new unboundedfifobuffer(); 
</div> 
<div>
  buffer.add(“one”); 
</div> 
<div>
  buffer.add(“two”); 
</div> 
<div>
  buffer.add(“three”); 
</div> 
<div>
  buffer.remove();   //removes and returns the next in order,”one” as this is a fifo 
</div> 
<div>
  buffer.remove();   //removes and returns the next in order,”two” as this is a fifo 
</div> 
<div>
  fifo(队列)、lifo(堆栈)和priority（根据比较器的顺序）的接口实现已经被提供。 
</div> 
<div> 
 <strong>bags</strong> 
</div> 
<div>
  bag接口用于支持bag。它用于表示包含了一个对象的多个拷贝的结合。 
</div> 
<div>
  bag bag = new hashbag(); 
</div> 
<div>
  bag.add(“one”,6); //add 6 copies of “one” 
</div> 
<div>
  bag.remove(“one”,2);  //removes 2 copies of “one” 
</div> 
<div>
  bag.getcount(“one”);  //returns 4 
</div> 
<div>
  对于排序和为排序的bag，具有对应的接口实现。 
</div> 
<div>
    
</div> 
<div>
  下面是对internet中一篇文章的翻译，原文出处：http://www.devx.com/java/article/29392/0/page/3 
</div> 
<div>
  jdk中不是已经有了java集合框架了吗，为什么还要使用apache的集合呢？这是因为apache的集合时对jdk集合的一个补充和增强，它提供了更多的接口和实现类。甚至于它应该成为jdk的一部分。 
</div> 
<div>
  下面是一些笔者比较喜欢的特性： 
</div> 
<div>
  ® bag接口 
</div> 
<div>
  ® 固定大小的map、lru (最近最少使用算法)map和双重(dual)map 
</div> 
<div>
  ® 对象数组和map的迭代器 
</div> 
<div>
  ® map的multikey 
</div> 
<div>
  ® 大量的工具类，提供了使用api的快捷方式 
</div> 
<div>
  ® 封装器，对大多数类提供了自定义的方法 
</div> 
<div>
  collections类根据下面列举的包结构进行组织： 
</div> 
<div> 
 <em>org.apache.commons.collections</em> 
</div> 
<div> 
 <em>org.apache.commons.collections.bag</em> 
</div> 
<div> 
 <em>org.apache.commons.collections.bidimap</em> 
</div> 
<div> 
 <em>org.apache.commons.collections.buffer</em> 
</div> 
<div> 
 <em>org.apache.commons.collections.collection</em> 
</div> 
<div> 
 <em>org.apache.commons.collections.comparators</em> 
</div> 
<div> 
 <em>org.apache.commons.collections.functors</em> 
</div> 
<div> 
 <em>org.apache.commons.collections.iterators</em> 
</div> 
<div> 
 <em>org.apache.commons.collections.keyvalue</em> 
</div> 
<div> 
 <em>org.apache.commons.collections.list</em> 
</div> 
<div> 
 <em>org.apache.commons.collections.map</em> 
</div> 
<div> 
 <em>org.apache.commons.collections.set</em> 
</div> 
<div>
    
</div> 
<div> 
 <strong>org.apache.commons.collections</strong> 
</div> 
<div>
  这个包中定义了由其他包实现的接口、作为工厂类(可以实例化集合类或者集合的封装类)的共通类。一些比较重要的类有arraystack、beanmap、extendedproperties、fastarraylist、fasthashmap和fasttreemap。这些类的细节包含在javadoc中，下面只是简要的介绍各个类在实际中的应用： 
</div> 
<div>
  arraystack:arraystack类实现了stack接口，基于arraylist用来在单线程环境中使用。例如，如果想在一个方法中使用stack进行一些处理，这个类在性能上会比stack(jdk1.4.2中使用vector)好一些。 
</div> 
<div>
  beanmap:就像swing gui中的jbutton一样，使用beanmap，甚至可以将一个map作为一个javabean来进行处理。当在设计用来显示数据源或者应用程序配置属性的gui时，map可以在屏幕上被拖放(d&amp;d)。 
</div> 
<div>
  extendedproperties:这是一个非常有用的类。它和java.util.properties类似，包含了一个用于加载配置信息的load方法，但是这个类有以下的好处： 
</div> 
<div>
  # 属性值可以分布在多行 
</div> 
<div>
  # 提供了用于获取非字符串值的方法。例如，getfload方法用于获取一个fload类型的值。这样就不需要使用wrapper方法来转换获取的字符串值了。 
</div> 
<div>
  fastarraylist, fasthashmap, fasttreemap:这些类可以在多线程环境中使用，如果存在很多只读操作的话。这些类是分别基于arraylist、hashmap和treemap的。 
</div> 
<div> 
 <strong>org.apache.commons.collections.bag</strong> 
</div> 
<div>
  如果需要将一个对象的多个拷贝添加到一个list中时，这个包下面的类就变得非常有用了。在这种情况下，很多开发人员会将对象添加到一个arraylist中，然后每天加一次都要进行一下迭代，来判断是否添加了给定类型的对象。在线购物车是这种情况的一个实际的需求。这种方法的缺点是内存和速度上的不足。 
</div> 
<div>
  解决上述需求的一个比较好的设计就是只保存一个对象的拷贝，而在添加同样类型的实体时，只是增加计数器的值。hashbag和treebag类(分别基于hashmap和treemap)很好的满足了这个需求。 
</div> 
<div>
  如下面的例子所示： 
</div> 
<div>
  package in.co.narayanan.commons.collections.bag; 
</div> 
<div>
  import junit.framework.testcase; 
</div> 
<div>
  import org.apache.commons.collections.bag; 
</div> 
<div>
  import org.apache.commons.collections.bag.hashbag; 
</div> 
<div>
  /** 
</div> 
<div>
   * this domain represents an order placed by the customer. 
</div> 
<div>
   * 
</div> 
<div>
   * @author narayanan a r 
</div> 
<div>
   */ 
</div> 
<div>
  public class order { 
</div> 
<div>
  private bag orderedproducts; 
</div> 
<div>
  public order() { 
</div> 
<div>
    orderedproducts = new hashbag(); 
</div> 
<div>
  } 
</div> 
<div>
  public void addproduct(product p) { 
</div> 
<div>
    orderedproducts.add(p); 
</div> 
<div>
  } 
</div> 
<div>
  public int countwindowslicenses() { 
</div> 
<div>
    return orderedproducts.getcount(product.windows); 
</div> 
<div>
  } 
</div> 
<div>
  public int countlinuxlicenses() { 
</div> 
<div>
    return orderedproducts.getcount(product.linux); 
</div> 
<div>
  } 
</div> 
<div>
  } 
</div> 
<div>
  class product { 
</div> 
<div>
  //ostype is an enum 
</div> 
<div>
  public static final product windows = new product(ostype.windows); 
</div> 
<div>
  public static final product linux = new product(ostype.linux); 
</div> 
<div>
  public static final product mac = new product(ostype.mac); 
</div> 
<div>
  public static final product hpunix = new product(ostype.hpunix); 
</div> 
<div>
  private int quantity; 
</div> 
<div>
  private int version; 
</div> 
<div>
  private float prize; 
</div> 
<div>
  private ostype type; 
</div> 
<div>
  public product(ostype type) { 
</div> 
<div>
    this.type = type; 
</div> 
<div>
  } 
</div> 
<div>
  public int getquantity() { 
</div> 
<div>
    return quantity; 
</div> 
<div>
  } 
</div> 
<div>
  public void setquantity(int quantity) { 
</div> 
<div>
    this.quantity = quantity; 
</div> 
<div>
  } 
</div> 
<div>
  public int getversion() { 
</div> 
<div>
    return version; 
</div> 
<div>
  } 
</div> 
<div>
  public void setversion(int version) { 
</div> 
<div>
    this.version = version; 
</div> 
<div>
  } 
</div> 
<div>
  public float getprize() { 
</div> 
<div>
    return prize; 
</div> 
<div>
  } 
</div> 
<div>
  public void setprize(float prize) { 
</div> 
<div>
    this.prize = prize; 
</div> 
<div>
  } 
</div> 
<div>
  public ostype gettype() { 
</div> 
<div>
    return type; 
</div> 
<div>
  } 
</div> 
<div>
  public void settype(ostype type) { 
</div> 
<div>
    this.type = type; 
</div> 
<div>
  } 
</div> 
<div>
  @override 
</div> 
<div>
  public boolean equals(object o) { 
</div> 
<div>
    if (o instanceof product) { 
</div> 
<div>
     return ((product) o).gettype().equals(this.gettype()); 
</div> 
<div>
    } 
</div> 
<div>
    return super.equals(o); 
</div> 
<div>
  } 
</div> 
<div>
  @override 
</div> 
<div>
  public int hashcode() { 
</div> 
<div>
    return type.hashcode(); 
</div> 
<div>
  } 
</div> 
<div>
  @override 
</div> 
<div>
  public string tostring() { 
</div> 
<div>
    return type.tostring(); 
</div> 
<div>
  } 
</div> 
<div>
  } 
</div> 
<div>
  class testorder extends testcase { 
</div> 
<div>
      public void testorder() { 
</div> 
<div>
    order order = new order(); 
</div> 
<div>
    order.addproduct(new product(ostype.windows)); 
</div> 
<div>
    order.addproduct(new product(ostype.windows)); 
</div> 
<div>
    order.addproduct(new product(ostype.windows)); 
</div> 
<div>
    order.addproduct(new product(ostype.linux)); 
</div> 
<div>
    order.addproduct(new product(ostype.linux)); 
</div> 
<div>
    order.addproduct(new product(ostype.hpunix)); 
</div> 
<div>
    order.addproduct(new product(ostype.mac)); 
</div> 
<div>
    int licenses; 
</div> 
<div>
    licenses = order.countwindowslicenses(); 
</div> 
<div>
    assertequals(3, licenses); 
</div> 
<div>
    licenses = order.countlinuxlicenses(); 
</div> 
<div>
    assertequals(2, licenses); 
</div> 
<div>
      } 
</div> 
<div>
  } 
</div> 
<div>
  通过调试，运行到上述红色行时，order的成员变量orderedproducts的内容为：(tostring显示内容) 
</div> 
<div>
  [2:linux,1:mac,1:hpunix,3:windows] 
</div> 
<div>
  即实际上只存储了一个对象的拷贝，然后使用数字进行标识个数。 
</div> 
<div>
  而orderedproducts的成员hashmap对象的size为4。 
</div> 
<div> 
 <strong>org.apache.commons.collections.bidimap</strong> 
</div> 
<div>
  很多java开发人员通过使用两个hashmap来获取一个键值，方法是将一个值作为键传递到另外一个hashmap。正常情况下，需要对同等的处理名字和值，在这种情况下，就是值也可以做为键(因为在map中键是唯一的，而值是可以不唯一的)。 
</div> 
<div>
  关于org.apache.commons.collections.bidimap的例子是一个原型适配器，集成了peoplesoft和siebel命令行处理引擎，假定一个引擎中的每个命令在另外一个中都有同样的对应。可以在in.co.narayanan.commons.collections.bidimap中找到相关的类。可以通过siebelpeoplesoftconnector来了解这些类，siebelpeoplesoftconnector作为适配器，并包含了bidimap对象。当收到处理siebel命令的请求后，就从bidimap获取对应的peoplesoft命令，然后传送给peoplesoft命令引擎。反之亦然。样例代码中只包含应用程序的一个轮廓。 
</div> 
<div>
  /** 
</div> 
<div>
   *definescontractforthesystemstoconsumeagiven 
</div> 
<div>
   *command. 
</div> 
<div>
   * 
</div> 
<div>
   * 
 <strong>@author</strong>narayananar 
</div> 
<div>
   */ 
</div> 
<div> 
 <strong>public</strong> 
 <strong>interface</strong> icommandconsumer { 
</div> 
<div>
      object consume(string command, object arg); 
</div> 
<div>
  } 
</div> 
<div> 
 <strong>class</strong> siebelcommandconsumer 
 <strong>implements</strong> icommandconsumer { 
</div> 
<div>
      
 <strong>public</strong> object consume(string command, object arg) { 
</div> 
<div>
    system. 
 <em>out</em>.println("processing siebel command:" + command); 
</div> 
<div>
          system. 
 <em>out</em>.println("arg:" + arg); 
</div> 
<div>
    
 <strong>return</strong>"siebel:" + command + "-successful"; 
</div> 
<div>
      } 
</div> 
<div>
  } 
</div> 
<div> 
 <strong>class</strong> peoplesoftcommandconsumer 
 <strong>implements</strong> icommandconsumer { 
</div> 
<div>
      
 <strong>public</strong> object consume(string command, object arg) { 
</div> 
<div>
    system. 
 <em>out</em>.println("processing peoplesoft command:" + command); 
</div> 
<div>
    system. 
 <em>out</em>.println("arg:" + arg); 
</div> 
<div>
    
 <strong>return</strong>"peoplesoft:" + command + "-successful"; 
</div> 
<div>
      } 
</div> 
<div>
  } 
</div> 
<div> 
 <strong>import</strong> org.apache.commons.collections.bidimap.treebidimap; 
</div> 
<div> 
 <strong>import</strong> org.apache.commons.collections.bidimap; 
</div> 
<div>
  /** 
</div> 
<div>
   *responsibleforadaptingboththesystem'scommands. 
</div> 
<div>
   * 
</div> 
<div>
   * 
 <strong>@author</strong>narayananar 
</div> 
<div>
   */ 
</div> 
<div> 
 <strong>public</strong> 
 <strong>class</strong> siebelpeoplesoftconnector { 
</div> 
<div>
      
 <strong>private</strong> icommandconsumer peoplesoft; 
</div> 
<div>
      
 <strong>private</strong> icommandconsumer siebel; 
</div> 
<div>
      
 <strong>private</strong> bidimap commandmap; 
</div> 
<div>
      
 <strong>public</strong> siebelpeoplesoftconnector(icommandconsumer peoplesoft, 
</div> 
<div>
  icommandconsumer siebel) { 
</div> 
<div>
    
 <strong>this</strong>.peoplesoft = peoplesoft; 
</div> 
<div>
    
 <strong>this</strong>.siebel = siebel; 
</div> 
<div>
    commandmap = preparecommandmapping(); 
</div> 
<div>
      } 
</div> 
<div>
      
 <strong>private</strong> bidimap preparecommandmapping() { 
</div> 
<div>
    bidimap map = 
 <strong>new</strong> treebidimap(); 
</div> 
<div>
    map.put("start", "init"); 
</div> 
<div>
    map.put("exit", "quit"); 
</div> 
<div>
    map.put("delete", "remove"); 
</div> 
<div>
    
 <strong>return</strong> map; 
</div> 
<div>
      } 
</div> 
<div>
      /** 
</div> 
<div>
       *delegatesthecalltothepeoplesoftcommandenginebyfetchingthemappedcommand. 
</div> 
<div>
       * 
</div> 
<div>
       * 
 <strong>@param</strong>commandsiebelcommand 
</div> 
<div>
       * 
 <strong>@param</strong>argargumentifany 
</div> 
<div>
       * 
 <strong>@return</strong>resultreturnedfrompeoplesoftcommandengine 
</div> 
<div>
       */ 
</div> 
<div>
      
 <strong>public</strong> object processsiebelcommand(string command, object arg) { 
</div> 
<div>
    
 <strong>return</strong>peoplesoft.consume((string)commandmap.get(command), arg); 
</div> 
<div>
      } 
</div> 
<div>
      /** 
</div> 
<div>
       *delegatesthecalltothesiebelcommandenginebyfetchingthemappedcommand. 
</div> 
<div>
       * 
</div> 
<div>
       * 
 <strong>@param</strong>commandpeoplesoftcommand 
</div> 
<div>
       * 
 <strong>@param</strong>argargumentifany 
</div> 
<div>
       * 
 <strong>@return</strong>resultreturnedfromsiebelcommandengine 
</div> 
<div>
       */ 
</div> 
<div>
      
 <strong>public</strong> object processpeoplesoftcommand(string command, object arg) { 
</div> 
<div>
    
 <strong>return</strong>siebel.consume((string)commandmap.getkey(command), arg); 
</div> 
<div>
      } 
</div> 
<div>
  } 
</div> 
<div>
  即可以根据key查找value，也可以根据value查找key。 
</div> 
<div> 
 <strong>org.apache.commons.collections.buffer</strong> 
</div> 
<div>
  这个包中包含了封装类，直接实现了java.util.collection接口。因此，任何实现collection接口的类都可以使用这些封装类。比较常用的类有predicatedcollection、compositecollection、synchronizedcollection、transformedcollection、typedcollection和unmodifiablecollection。下表提供了关于这些类的一个概览： 
</div> 
<div>
  predicatedcollection:可以通过使用这个类的实例来追加限制条件，将条件定义成一个独立的对象，也就是所谓的前提条件，然后作为参数传送给封装类的工厂方法。 
</div> 
<div>
  ?     compositecollection:使用这个类可以创建集合的集合，并且当添加或者删除对象时具有一个统一的视图。 
</div> 
<div>
  ?     synchronizedcollection:可以使既存的集合线程安全。 
</div> 
<div>
  ?     transformedcollection:当将对象添加到集合时转换对象的类型。例如由string--&gt;integer。 
</div> 
<div>
  ?     typedcollection:与java 1.5类似的泛型。 
</div> 
<div>
  ?     unmodifiablecollection:使集合的引用不可以被修改。 
</div> 
<div> 
 <strong>org.apache.commons.collections.comparators</strong> 
</div> 
<div>
  这个包中包含了很多可复用的类。nullcomparator类和fixedordercomparator是最常用的类。 
</div> 
<div>
  nullcomparator:当对数组或者列表中的实体进行排序时，将null实体移到底部。 
</div> 
<div>
  fixedordercomparator:将一个集合中的顺序重新保存在预定义的列表中。 
</div> 
<div> 
 <strong>org.apache.commons.collections.functors</strong> 
</div> 
<div> 
 <strong>org.apache.commons.collections.iterators</strong> 
</div> 
<div>
  在这个包中包含了很多实现了java.util.iterator接口的类。比较重要的类有mapiterator、arrayiterator、collatingiterator、loopingiterator和iteratorutils。需要通过使用iteratorutils类来使用这个包中的类。 
</div> 
<div> 
 <strong>org.apache.commons.collections.keyvalue</strong> 
</div> 
<div>
  这个包中的multikey类非常有用。如果想要在应用程序中创建一个域(domain)对象并将它们存储在一个基于联合逐渐的map中，就可以通过创建一个multikey的实例，使用记录的主键的值作为参数。然后将这个实例传递给map来存储域对象。 
</div> 
<div>
  这个包中的类的其他用途是存储locale相关的实体，在这种情况下，实际的主键和locale name联合组成key。 
</div> 
<div> 
 <strong>org.apache.commons.collections.list</strong> 
</div> 
<div>
  treelist、fixedsizelist、nodecachinglinkedlist、cursorablelinkedlist、transformedlist和predicatedlist类都是这个包中比较重要的类。它们的javadoc也非常清楚的描述了各自的功能。 
</div> 
<div> 
 <strong>org.apache.commons.collections.map</strong> 
</div> 
<div>
  caseinsensitivemap、compositemap、fixedsizemap、flat3map、lazymap、linkedmap、lrumap、multikeymap、predicatedmap、singletonmap和staticbucketmap类都比较有用。 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e962b523b2e086b02b5dd2d130ea6db7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JS中把字符转成ASCII值的函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1897ae6371d964e15d81599775959364/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据库设计 - 设计表和字段</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>