<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>神经网络之VGG - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="神经网络之VGG" />
<meta property="og:description" content="目录
1.VGG的简单介绍 1.2结构图
3.参考代码
VGGNet-16 架构：完整指南 |卡格尔 (kaggle.com) 1.VGG的简单介绍 经典卷积神经网络的基本组成部分是下面的这个序列：
带填充以保持分辨率的卷积层；
非线性激活函数，如ReLU；
汇聚层，如最大汇聚层。
而一个VGG块与之类似，由一系列卷积层组成，后面再加上用于空间下采样的最大汇聚层。在最初的VGG论文中 (Simonyan and Zisserman, 2014)，作者使用了带有3×3卷积核、填充为1（保持高度和宽度）的卷积层，和带有2×2汇聚窗口、步幅为2（每个块后的分辨率减半）的最大汇聚层。
VGG的全称是视觉几何小组，隶属于牛津大学科学与工程系。它发布了一系列从VGG开始的卷积网络模型，可以应用于人脸识别和图像分类，从VGG16到VGG19。VGG研究卷积网络深度的初衷是了解卷积网络的深度如何影响大规模图像分类和识别的准确性和准确性-Deep-16CNN），为了加深网络层数并避免参数过多，在所有层中都使用了一个小的3x3卷积核。
1.2结构图 VGG的输入被设置为大小为224x244的RGB图像。为训练集图像上的所有图像计算平均RGB值，然后将该图像作为输入输入到VGG卷积网络。使用3x3或1x1滤波器，并且卷积步骤是固定的。有3个VGG全连接层，根据卷积层&#43;全连接层的总数，可以从VGG11到VGG19变化。最小VGG11具有8个卷积层和3个完全连接层。最大VGG19具有16个卷积层&#43;3个完全连接的层。此外，VGG网络后面没有每个卷积层后面的池化层，也没有分布在不同卷积层下的总共5个池化层。下图为VGG结构图：
关于架构图：
VGG16包含16层，VGG19包含19层。在最后三个完全连接的层中，一系列VGG完全相同。整体结构包括5组卷积层，后面是一个MaxPool。不同之处在于，在五组卷积层中包括了越来越多的级联卷积层。
3.参考代码 VGGNet-16 架构：完整指南 |卡格尔 (kaggle.com) 在这里讲述了一个比较完整的代码记录，本文参考李沐老师所写
import torch from torch import nn from d2l import torch as d2l def vgg_block(num_convs, in_channels, out_channels): layers = [] for _ in range(num_convs): layers.append(nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=1)) layers.append(nn.ReLU()) in_channels = out_channels layers.append(nn.MaxPool2d(kernel_size=2,stride=2)) return nn.Sequential(*layers) conv_arch = ((1, 64), (1, 128), (2, 256), (2, 512), (2, 512)) def vgg(conv_arch): conv_blks = [] in_channels = 1 # 卷积层部分 for (num_convs, out_channels) in conv_arch: conv_blks." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/9ef53abe15136216666f079bd9b6d932/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-01T15:56:34+08:00" />
<meta property="article:modified_time" content="2023-07-01T15:56:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">神经网络之VGG</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.VGG%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%C2%A0%C2%A0-toc" style="margin-left:0px;"><a href="#1.VGG%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%C2%A0%C2%A0" rel="nofollow">1.VGG的简单介绍  </a></p> 
<p id="%C2%A01.2%E7%BB%93%E6%9E%84%E5%9B%BE-toc" style="margin-left:0px;"><a href="#%C2%A01.2%E7%BB%93%E6%9E%84%E5%9B%BE" rel="nofollow"> 1.2结构图</a></p> 
<p id="3.%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#3.%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81" rel="nofollow">3.参考代码</a></p> 
<p id="VGGNet-16%20%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97%20%7C%E5%8D%A1%E6%A0%BC%E5%B0%94%20(kaggle.com)%C2%A0-toc" style="margin-left:0px;"><a href="#VGGNet-16%20%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97%20%7C%E5%8D%A1%E6%A0%BC%E5%B0%94%20%28kaggle.com%29%C2%A0" rel="nofollow">VGGNet-16 架构：完整指南 |卡格尔 (kaggle.com) </a></p> 
<p> </p> 
<h2 id="1.VGG%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%C2%A0%C2%A0">1.VGG的简单介绍  </h2> 
<p>经典卷积神经网络的基本组成部分是下面的这个序列：</p> 
<ol><li> <p>带填充以保持分辨率的卷积层；</p> </li><li> <p>非线性激活函数，如ReLU；</p> </li><li> <p>汇聚层，如最大汇聚层。</p> </li></ol> 
<p>而一个VGG块与之类似，由一系列卷积层组成，后面再加上用于空间下采样的最大汇聚层。在最初的VGG论文中 (<a href="https://zh-v2.d2l.ai/chapter_references/zreferences.html#id153" rel="nofollow" title="Simonyan and Zisserman, 2014">Simonyan and Zisserman, 2014</a>)，作者使用了带有3×3卷积核、填充为1（保持高度和宽度）的卷积层，和带有2×2汇聚窗口、步幅为2（每个块后的分辨率减半）的最大汇聚层。</p> 
<p>VGG的全称是视觉几何小组，隶属于牛津大学科学与工程系。它发布了一系列从VGG开始的卷积网络模型，可以应用于人脸识别和图像分类，从VGG16到VGG19。VGG研究卷积网络深度的初衷是了解卷积网络的深度如何影响大规模图像分类和识别的准确性和准确性-Deep-16CNN），为了加深网络层数并避免参数过多，在所有层中都使用了一个小的3x3卷积核。</p> 
<h2 id="%C2%A01.2%E7%BB%93%E6%9E%84%E5%9B%BE"> 1.2结构图</h2> 
<p>VGG的输入被设置为大小为224x244的RGB图像。为训练集图像上的所有图像计算平均RGB值，然后将该图像作为输入输入到VGG卷积网络。使用3x3或1x1滤波器，并且卷积步骤是固定的。有3个VGG全连接层，根据卷积层+全连接层的总数，可以从VGG11到VGG19变化。最小VGG11具有8个卷积层和3个完全连接层。最大VGG19具有16个卷积层+3个完全连接的层。此外，VGG网络后面没有每个卷积层后面的池化层，也没有分布在不同卷积层下的总共5个池化层。下图为VGG结构图：</p> 
<p style="text-align:center;"><img alt="" height="236" src="https://images2.imgbox.com/67/1f/9L4tWYgc_o.png" width="419"> </p> 
<p> 关于架构图：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/da/ca/rmc5fMMx_o.png"></p> 
<blockquote> 
 <p> VGG16包含16层，VGG19包含19层。在最后三个完全连接的层中，一系列VGG完全相同。整体结构包括5组卷积层，后面是一个MaxPool。不同之处在于，在五组卷积层中包括了越来越多的级联卷积层。</p> 
</blockquote> 
<p style="text-align:center;"> <img alt="" height="266" src="https://images2.imgbox.com/f3/e1/0M79rChu_o.jpg" width="416"></p> 
<h2 id="3.%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81">3.参考代码</h2> 
<h2 id="VGGNet-16%20%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97%20%7C%E5%8D%A1%E6%A0%BC%E5%B0%94%20(kaggle.com)%C2%A0"><a href="https://www.kaggle.com/code/blurredmachine/vggnet-16-architecture-a-complete-guide" rel="nofollow" title="VGGNet-16 架构：完整指南 |卡格尔 (kaggle.com)">VGGNet-16 架构：完整指南 |卡格尔 (kaggle.com)</a> </h2> 
<p>在这里讲述了一个比较完整的代码记录，本文参考李沐老师所写</p> 
<pre><code class="hljs">import torch
from torch import nn
from d2l import torch as d2l


def vgg_block(num_convs, in_channels, out_channels):
    layers = []
    for _ in range(num_convs):
        layers.append(nn.Conv2d(in_channels, out_channels,
                                kernel_size=3, padding=1))
        layers.append(nn.ReLU())
        in_channels = out_channels
    layers.append(nn.MaxPool2d(kernel_size=2,stride=2))
    return nn.Sequential(*layers)</code></pre> 
<pre><code class="hljs">conv_arch = ((1, 64), (1, 128), (2, 256), (2, 512), (2, 512))
def vgg(conv_arch):
    conv_blks = []
    in_channels = 1
    # 卷积层部分
    for (num_convs, out_channels) in conv_arch:
        conv_blks.append(vgg_block(num_convs, in_channels, out_channels))
        in_channels = out_channels

    return nn.Sequential(
        *conv_blks, nn.Flatten(),
        # 全连接层部分
        nn.Linear(out_channels * 7 * 7, 4096), nn.ReLU(), nn.Dropout(0.5),
        nn.Linear(4096, 4096), nn.ReLU(), nn.Dropout(0.5),
        nn.Linear(4096, 10))

net = vgg(conv_arch)</code></pre> 
<pre><code class="hljs">#将构建一个高度和宽度为224的单通道数据样本，以观察每个层输出的形状。
X = torch.randn(size=(1, 1, 224, 224))
for blk in net:
    X = blk(X)
    print(blk.__class__.__name__,'output shape:\t',X.shape)</code></pre> 
<p class="img-center"><img alt="" height="209" src="https://images2.imgbox.com/da/85/qF0EjROn_o.png" width="519"></p> 
<p> 为了减少训练时间 将原参数量缩小到原来的1\16.</p> 
<pre><code class="hljs">ratio = 4
small_conv_arch = [(pair[0], pair[1] // ratio) for pair in conv_arch]
net = vgg(small_conv_arch)</code></pre> 
<pre><code class="hljs">lr, num_epochs, batch_size = 0.05, 10, 128
train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=224)
d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())</code></pre> 
<p class="img-center"><img alt="" height="175" src="https://images2.imgbox.com/df/cb/S2DBpwE9_o.png" width="259"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/373d1584668f0dc997697dd4dfa96fca/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【已解决】Ubuntu22.04修复grub引导&#43;用修复软件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0a208a64a73e9d840c3ae07424701000/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">登录空指针异常java.lang.NullPointerException at com.zhao.auth.service.impl....</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>