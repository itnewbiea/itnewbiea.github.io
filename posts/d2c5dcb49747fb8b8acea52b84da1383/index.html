<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>带你理清Node.js 的Web框架的3个层次 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="带你理清Node.js 的Web框架的3个层次" />
<meta property="og:description" content="web 框架指的是处理 http、https 的服务端框架，Node.js 提供了 http、https 模块用于处理协议数据，这是 web 框架的基础。
但是 http、https 的 api 过于简单，用起来比较麻烦，所以一般会用 express、koa、fastify 这种封装了一层的框架来简化。
但 express 类的框架不提供代码架构方面的限制，所以对于模块比较多比较复杂的企业级应用来说并不适合，这时就要用实现了 MVC 的 eggjs、nestjs 这类企业级 web 框架。
这是 web 框架的 3 个层次，理清了它们的关系和适用场景，再去学习才不会迷茫。
下面我们分别来看一下：
http、https
http 是基于 TCP 的，对 TCP 传过来的 http 协议数据做 parse，传给 handler 处理，handler 处理完要返回 http 响应，这是 http 模块做的事情。
const http = require(&#39;http&#39;); const server = http.createServer((req, res) =&gt; { res.writeHead(200, { &#39;Content-Type&#39;: &#39;text/plain&#39; }); res.end(&#39;okay&#39;); }); server.listen(8080, &#39;127.0.0.1&#39;); http 模块虽然能处理请求和响应，但是提供的 api 过于原始：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d2c5dcb49747fb8b8acea52b84da1383/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-17T17:13:05+08:00" />
<meta property="article:modified_time" content="2021-10-17T17:13:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">带你理清Node.js 的Web框架的3个层次</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="带你理清Node.js 的Web框架的3个层次带你理清Node.js 的Web框架的3个层次" height="400" src="https://images2.imgbox.com/a5/8d/UEkGNmP4_o.png" width="600"></p> 
<p><br> web 框架指的是处理 http、https 的服务端框架，Node.js 提供了 http、https 模块用于处理协议数据，这是 web 框架的基础。</p> 
<p>但是 http、https 的 api 过于简单，用起来比较麻烦，所以一般会用 express、koa、fastify 这种封装了一层的框架来简化。</p> 
<p>但 express 类的框架不提供代码架构方面的限制，所以对于模块比较多比较复杂的企业级应用来说并不适合，这时就要用实现了 MVC 的 eggjs、nestjs 这类企业级 web 框架。</p> 
<p>这是 web 框架的 3 个层次，理清了它们的关系和适用场景，再去学习才不会迷茫。</p> 
<p>下面我们分别来看一下：</p> 
<p><strong>http、https</strong></p> 
<p>http 是基于 TCP 的，对 TCP 传过来的 http 协议数据做 parse，传给 handler 处理，handler 处理完要返回 http 响应，这是 http 模块做的事情。</p> 
<pre>const http = require('http'); 
 
const server = http.createServer((req, res) =&gt; { 
  res.writeHead(200, { 'Content-Type': 'text/plain' }); 
  res.end('okay'); 
}); 
 
server.listen(8080, '127.0.0.1'); 
</pre> 
<p>http 模块虽然能处理请求和响应，但是提供的 api 过于原始：</p> 
<p>比如获取请求参数还要用 url 模块 parse 一次</p> 
<pre>const http = require('http'); 
const url = require('url'); 
 
http.createServer(function (req, res) { 
  const queryObject = url.parse(req.url,true).query; 
  console.log(queryObject); 
 
  res.writeHead(200, {'Content-Type': 'text/html'}); 
  res.end('xxx'); 
}).listen(8080); 
</pre> 
<p>比如返回响应只能用 write 或者 end 返回一段 buffer 或 string，想返回 JSON、文件下载、html 视图等都要自己实现。</p> 
<p style="text-align:center;"><img alt="带你理清Node.js 的Web框架的3个层次带你理清Node.js 的Web框架的3个层次" height="253" src="https://images2.imgbox.com/60/4e/IT7yCKlC_o.png" width="600"></p> 
<p><br> 而且 get、post、put、delete 等请求类型也要自己做判断。</p> 
<pre>if(req.method === 'get') { 
    //... 
} else if (req.method === 'post') { 
    //... 
} 
//... 
</pre> 
<p>因为有这些痛点，所以一般我们不会直接用 http 模块，而是用封装了一层的 express、koa、fastify 这类 web 框架。</p> 
<p><strong>express、koa、fastify 等</strong></p> 
<p>express 这类框架解决了刚才的那个痛点问题：<br> 提供了路由机制，不用自己手动判断 method 和 path</p> 
<pre>app.get('/list', function (req, res) { 
  //... 
}) 
app.post('/save', function(req, res) { 
  //... 
}) 
</pre> 
<p>提供了更好用的 request 和 response api：<br> 比如 req.params 获取请求参数</p> 
<pre>app.get('/user/:id', function (req, res) { 
  res.send('user ' + req.params.id) 
}) 
res.download 返回下载的响应

res.download('/report-12345.pdf') 
res.render 返回模版引擎渲染的 html

app.render('xxx-template', { name: 'guang' }, function (err, html) { 
  // ... 
}) 
</pre> 
<p>提供了中间件机制，用于复用一些一些逻辑：<br> 比如文件上传中间件</p> 
<pre>app.use(fileUpload({ 
    useTempFiles : true, 
    tempFileDir : '/tmp/' 
}));
</pre> 
<p>提供了这么多方便的功能，确实比 http 模块用起来简单多了。</p> 
<p>但是 express 类的 web 框架也有问题，就是没有提供组织代码的模式，当模块多了代码很容易乱掉，因为它只是按照类似洋葱的顺序调用中间件，没有模块和 MVC 的划分。</p> 
<p style="text-align:center;"><img alt="带你理清Node.js 的Web框架的3个层次带你理清Node.js 的Web框架的3个层次" height="449" src="https://images2.imgbox.com/61/01/y2mNtgo2_o.png" width="500"></p> 
<p><br> express 类框架做一些小的服务可以，企业级应用还得用 nestjs、eggjs 这类 MVC 框架。</p> 
<p><strong>nestjs、eggjs、midwayjs、daruk 等</strong></p> 
<p>nestjs 类的框架就实现了 MVC 的模式，代码有明显的 Controller、Service、Model、View 的划分：</p> 
<pre>import { Body, Controller, Delete, Get, Param, Post } from '@nestjs/common'; 
import { CreateUserDto } from './dto/create-user.dto'; 
import { User } from './user.entity'; 
import { UsersService } from './users.service'; 
 
@Controller('users') 
export class UsersController { 
  constructor(private readonly usersService: UsersService) {} 
 
  @Post() 
  create(@Body() createUserDto: CreateUserDto): Promise { 
    return this.usersService.create(createUserDto); 
  } 
 
  @Get() 
  findAll(): Promise { 
    return this.usersService.findAll(); 
  } 
 
  @Get(':id') 
  findOne(@Param('id') id: string): Promise { 
    return this.usersService.findOne(id); 
  } 
 
  @Delete(':id') 
  remove(@Param('id') id: string): Promise { 
    return this.usersService.remove(id); 
  } 
} 
</pre> 
<p>nestjs 是对标 java 的 spring 的，实现了 IOC、AOP 等模式，模块之间耦合度很低，就算再复杂的项目，通过 Module、Controller、Service 等也可以很好的被组织起来，相比 express 来说，组织代码方面提升了一个档次。</p> 
<p style="text-align:center;"><img alt="带你理清Node.js 的Web框架的3个层次带你理清Node.js 的Web框架的3个层次" height="329" src="https://images2.imgbox.com/28/97/9stVceEh_o.png" width="600"></p> 
<p><br> nestjs 的底层就是 express、fastify 等 web 框架，而且还可以灵活的切换底层实现。</p> 
<p>可以看到，nestjs、eggjs 类的企业级框架，除了有丰富的 api 以外，更重要的是提供了代码组织的规范，通过 Module、Controller、Service 等概念可以很好的组织复杂的业务逻辑。</p> 
<p><strong>总结</strong></p> 
<p>web 框架都是基于 http、https 模块，但它提供的 api 过于原始，使用起来比较麻烦，所以我们一般会用 express、koa 这类框架来简化，它提供了中间件机制来复用逻辑，提供了更多的 request、response 的 api，但却没有组织复杂代码的能力，对于企业级的复杂应用，还是会用 nestjs、eggjs 这类 MVC 框架，它们的底层是 express、koa，但提供了 Module、Controller、Service 等概念，可以很好的组织复杂的代码。</p> 
<p>要理清楚为什么会有这三个层次，都各自适合什么场景，这样才能更好的掌握它们，在技术选型上才不会迷茫。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ae91888e4d3800eb78f8db01a2383ab8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MacPro微信可以使用，其他应用均不能联网，浏览器网页也打不开</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2e5db409a7e4a356a544e6ca359f5446/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于Less的学习小结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>