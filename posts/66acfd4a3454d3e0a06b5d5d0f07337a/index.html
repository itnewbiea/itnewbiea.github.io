<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; 配置文件类（linux与window可跨平台使用） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; 配置文件类（linux与window可跨平台使用）" />
<meta property="og:description" content="编写程序一直在用的配置文件类，感觉很好用，做一下总结：
.h
class inirw{ public: inirw(const char *filename){iniFileLoad(filename);}; ~inirw(){iniFileFree();}; //加载ini文件至内存 char gFilename[SIZE_FILENAME]; char *gBuffer; int gBuflen; int iniFileLoad(const char *filename); //释放ini文件所占资源 void iniFileFree(); int FindSection(const char *section, char **sect1, char **sect2, char **cont1, char **cont2, char **nextsect); //获取字符串，不带引号 int iniGetString(const char *section, const char *key, char *value, int size, const char *defvalue); //获取整数值 int iniGetInt(const char *section, const char *key, int defvalue); //获取浮点数 double iniGetDouble(const char *section, const char *key, double defvalue); int iniGetValue(const char *section, const char *key, char *value, int maxlen, const char *defvalue); //设置字符串：若value为NULL，则删除该key所在行，包括注释 int iniSetString(const char *section, const char *key, const char *value); //设置整数值：base取值10、16、8，分别表示10、16、8进制，缺省为10进制 int iniSetInt(const char *section, const char *key, int value, int base=10); //	int iniGetIP(const char *section, const char *key, BasicHashTable *hashtable, int size, const char *defvalue); }; #endif ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/66acfd4a3454d3e0a06b5d5d0f07337a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-06-05T16:37:31+08:00" />
<meta property="article:modified_time" content="2018-06-05T16:37:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; 配置文件类（linux与window可跨平台使用）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>编写程序一直在用的配置文件类，感觉很好用，做一下总结：</p> 
<p>.h</p> 
<pre><code class="language-cpp">class inirw{
public:
	inirw(const char *filename){iniFileLoad(filename);};
	~inirw(){iniFileFree();};
	//加载ini文件至内存

	char gFilename[SIZE_FILENAME];
	char *gBuffer;
	int gBuflen;
	int iniFileLoad(const char *filename);
	//释放ini文件所占资源
	void iniFileFree();
	int FindSection(const char *section, char **sect1, char **sect2, char **cont1, char **cont2, char **nextsect);
	//获取字符串，不带引号
	int iniGetString(const char *section, const char *key, char *value, int size, const char *defvalue);
	//获取整数值
	int iniGetInt(const char *section, const char *key, int defvalue);
	//获取浮点数
	double iniGetDouble(const char *section, const char *key, double defvalue);
	int iniGetValue(const char *section, const char *key, char *value, int maxlen, const char *defvalue);
	//设置字符串：若value为NULL，则删除该key所在行，包括注释
	int iniSetString(const char *section, const char *key, const char *value);
	//设置整数值：base取值10、16、8，分别表示10、16、8进制，缺省为10进制
	int iniSetInt(const char *section, const char *key, int value, int base=10);
//	int iniGetIP(const char *section, const char *key, BasicHashTable *hashtable, int size, const char *defvalue);
};
#endif</code></pre> 
<pre><code class="language-html"></code></pre> 
<code class="language-html">.cpp</code> 
<pre class="cpp"><code class="language-html">文中加注释的一部分是我当初用来获取字段相同配置的函数，当初要配置一个黑白名单IP列表而写的，因为牵扯到别的类，在此就加上注释
#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "inirw.h"
//#include "strDup.hh"




#define fmin(x, y)		(x &lt;= y) ? x : y


typedef enum _ELineType_ {
    LINE_IDLE,		//未处理行
	LINE_ERROR,		//错误行
	LINE_EMPTY,		//空白行或注释行
	LINE_SECTION,	//节定义行
	LINE_VALUE		//值定义行
} ELineType ;








//去除串首尾空格，原串被改写
 char *StrStrip(char *s)
{
	size_t size;
	char *p1, *p2;


	size = strlen(s);
	if (!size)
		return s;


	p2 = s + size - 1;


	while ((p2 &gt;= s) &amp;&amp; isspace(*p2))
		p2 --;
	*(p2 + 1) = '\0';


	p1 = s;
	while (*p1 &amp;&amp; isspace(*p1))
		p1 ++;
	if (s != p1)
		memmove(s, p1, p2 - p1 + 2);
	return s;
}




//不区分大小写比较字符串
 int StriCmp(const char *s1, const char *s2)
{
	int ch1, ch2;
	do
	{
		ch1 = (unsigned char)*(s1++);
		if ((ch1 &gt;= 'A') &amp;&amp; (ch1 &lt;= 'Z'))
			ch1 += 0x20;


		ch2 = (unsigned char)*(s2++);
		if ((ch2 &gt;= 'A') &amp;&amp; (ch2 &lt;= 'Z'))
			ch2 += 0x20;
	} while ( ch1 &amp;&amp; (ch1 == ch2) );
	return(ch1 - ch2);
}




//取一行
//输入：数据区(指针及长度)
//输出：行类型、有效内容串(去首尾空格)、注释首、注释尾、下一行首(行尾与下一行首间为换行符)
//      有效内容位置为[buf, rem1)
 int GetLine(char *buf, int buflen, char *content, char **rem1, char **rem2, char **nextline)
{
	char *cont1, *cont2;
	int cntblank, cntCR, cntLF;		//连续空格、换行符数量
	char isQuot1, isQuot2;			//引号
	int i;
	char *p;


	//首先断行断注释，支持如下换行符：\r、\n、\r\n、\n\r
	cntblank = 0;
	cntCR = cntLF = 0;
	isQuot1 = isQuot2 = 0;
	cont1 = *rem1 = 0;
	content[0] = 0;
	for (i = 0, p = buf; i &lt; buflen; i ++, p ++)
	{
		if (*p == 0) {
			p ++;
			break;
		}
		//2个CR或LF，行结束
		if (cntCR == 2 || cntLF == 2) {
			p --;	//回溯1
			break;
		}
		//CR或LF各1个之后任意字符，行结束
		if (cntCR + cntLF &gt;= 2) {
			break;
		}
		//CR或LF之后出现其它字符，行结束
		if ((cntCR || cntLF) &amp;&amp; *p != '\r' &amp;&amp; *p != '\n')
			break;


		switch (*p) {
		case '\r':
			cntCR ++;
			break;
		case '\n':
			cntLF ++;
			break;
		case '\'':
			if (!isQuot2)
				isQuot1 = 1 - isQuot1;
			break;
		case '\"':
			if (!isQuot1)
				isQuot2 = 1 - isQuot2;
			break;
		case ';':
		case '#':
			if (isQuot1 || isQuot2)
				break;
			if (*rem1 == NULL)
				*rem1 = p - cntblank;
			break;
		default:
			if (isspace((unsigned char)*p)) {
				cntblank ++;
			} else {
				cntblank = 0;
				if ((*rem1 == NULL) &amp;&amp; (cont1 == NULL))
					cont1 = p;
			}
			break;
		}
	}


	*nextline = p;
	*rem2 = p - cntCR - cntLF;
	if (*rem1 == NULL)
		*rem1 = *rem2;
	cont2 = *rem1 - cntblank;


	if (cont1 == NULL) {
		cont1 = cont2;
		return LINE_EMPTY;
	}


	i = (int)(cont2 - cont1);
	if (i &gt;= SIZE_LINE)
		return LINE_ERROR;


	//内容头尾已无空格
	memcpy(content, cont1, i);
	content[i] = 0;


	if (content[0] == '[' &amp;&amp; content[i - 1] == ']')
		return LINE_SECTION;
	if (strchr(content, '=') != NULL)
		return LINE_VALUE;
	
	return LINE_ERROR;
}




//取一节section
//输入：节名称
//输出：成功与否、节名称首、节名称尾、节内容首、节内容尾(含换行)、下一节首(节尾与下一节首间为空行或注释行)
 int inirw::FindSection(const char *section, char **sect1, char **sect2, char **cont1, char **cont2, char **nextsect)
{
	int type;
	char content[SIZE_LINE];
	char *rem1, *rem2, *nextline;


	char *p;
	char *empty;
	int uselen = 0;
	char found = 0;


	if (gBuffer == NULL) {
		return 0;
	}


	while (gBuflen - uselen &gt; 0) {
		p = gBuffer + uselen;
		type = GetLine(p, gBuflen - uselen, content, &amp;rem1, &amp;rem2, &amp;nextline);
		uselen += (int)(nextline - p);


		if (LINE_SECTION == type) {
			if (found || section == NULL) break;		//发现另一section
			content[strlen(content) - 1] = 0;			//去尾部]
			StrStrip(content + 1);						//去首尾空格
			if (StriCmp(content + 1, section) == 0) {
				found = 1;
				*sect1 = p;
				*sect2 = rem1;
				*cont1 = nextline;
			}
			empty = nextline;
		} else
		if (LINE_VALUE == type) {
			if (!found &amp;&amp; section == NULL) {
				found = 1;
				*sect1 = p;
				*sect2 = p;
				*cont1 = p;
			}
			empty = nextline;
		}
	}
	
	if (!found) return 0;


	*cont2 = empty;
	*nextsect = nextline;
	return 1;
}




//从一行取键、值
//输入：内容串(将被改写)
//输出：键串、值串
 void GetKeyValue(char *content, char **key, char **value)
{
	char *p;


	p = strchr(content, '=');
	*p = 0;
	StrStrip(content);
	StrStrip(p + 1);
	*key = content;
	*value = p + 1;
}




//释放ini文件所占资源
void inirw:: iniFileFree()
{
	if (gBuffer != NULL) {
		free(gBuffer);
		gBuffer = 0;
		gBuflen = 0;
	}
}




//加载ini文件至内存
int inirw::iniFileLoad(const char *filename)
{
	FILE *file;
	int len;


	//iniFileFree();
	if (strlen(filename) &gt;= sizeof(gFilename))
		return 0;
	strcpy(gFilename, filename);


	file = fopen(gFilename, "ab+");
	if (file == NULL) 
		return 0;


	fseek(file, 0, SEEK_END);
	len = ftell(file);
	gBuffer =(char *) malloc(len);
	if (gBuffer == NULL) {
		fclose(file);
		return 0;
	}


	fseek(file, 0, SEEK_SET);
	len = fread(gBuffer, 1, len, file);
	fclose(file);
	gBuflen = len;
	return 1;
}




//读取值原始串
 int inirw::iniGetValue(const char *section, const char *key, char *value, int maxlen, const char *defvalue)
{
	int type;
	char content[SIZE_LINE];
	char *rem1, *rem2, *nextline;
	char *key0, *value0;


	char *p;
	int uselen = 0;
	char found = 0;
	int len;


	if (gBuffer == NULL || key == NULL) {
		if (value != NULL)
			value[0] = 0;
		return 0;
	}


	while (gBuflen - uselen &gt; 0) {
		p = gBuffer + uselen;
		type = GetLine(p, gBuflen - uselen, content, &amp;rem1, &amp;rem2, &amp;nextline);
		uselen += (int)(nextline - p);


		if (LINE_SECTION == type) {
			if (found || section == NULL) break;		//发现另一section
			content[strlen(content) - 1] = 0;			//去尾部]
			StrStrip(content + 1);						//去首尾空格
			if (StriCmp(content + 1, section) == 0) {
				found = 1;
			}
		} else
		if (LINE_VALUE == type) {
			if (!found &amp;&amp; section == NULL) {
				found = 1;
			}
			if (!found)
				continue;
			GetKeyValue(content, &amp;key0, &amp;value0);
			if (StriCmp(key0, key) == 0) {
				len = strlen(value0);
				if (len == 0) break;		//空值视为无效
				if (value != NULL) {
					len = fmin(len, maxlen - 1);
					strncpy(value, value0, len);
					value[len] = 0;
				}
			//	printf("value = %s\n",value);
				return 1;


			}
		}
	}
	
	//未发现键值取缺省
	if (value != NULL) {
		if (defvalue != NULL) {
			len = fmin(strlen(defvalue), maxlen - 1);
			strncpy(value, defvalue, len);
			value[len] = 0;
			iniSetString(section, key, defvalue);
		} else {
			value[0] = 0;
		}
	}
	return 0;
}


//
//int inirw::iniGetIP(const char *section, const char *key, BasicHashTable *hashtable, int maxlen, const char *defvalue)
//{
//
//	
//	int type;
//	char content[SIZE_LINE];
//	char *rem1, *rem2, *nextline;
//	char *key0, *value0;
//	char *value=NULL;
//	char *p;
//	int uselen = 0;
//	char found = 0;
//	int succed=0;
//	int len;
//
//	if (gBuffer == NULL || key == NULL) {
//		if (value != NULL)
//			value[0] = 0;
//		return 0;
//	}
//
//	while (gBuflen - uselen &gt; 0) {
//		p = gBuffer + uselen;
//		type = GetLine(p, gBuflen - uselen, content, &amp;rem1, &amp;rem2, &amp;nextline);
//		uselen += (int)(nextline - p);
//
//		if (LINE_SECTION == type) {
//			if (found || section == NULL) break;		//发现另一section
//			content[strlen(content) - 1] = 0;			//去尾部]
//			StrStrip(content + 1);						//去首尾空格
//			if (StriCmp(content + 1, section) == 0) {
//				found = 1;
//			}
//		} else
//			if (LINE_VALUE == type) {
//				if (!found &amp;&amp; section == NULL) {
//					found = 1;
//				}
//				if (!found)
//					continue;
//				GetKeyValue(content, &amp;key0, &amp;value0);
//				if (StriCmp(key0, key) == 0) {
//					len = strlen(value0);
//					if (len == 0) break;		//空值视为无效
//					if (value != NULL) {
//						len = fmin(len, maxlen - 1);
//					//	strncpy(value, value0, len);
//					//	value[len] = 0;
//					//printf("value0 =%s\n",value0);
//					//	
//					}
//					value=strDup(value0);
//					//printf("value =%s\n",value);
//					char *key3="-";
//				/*	GetKeyValue(value, &amp;key3, &amp;value0);
//					printf("str1 =%s\n",value0);
//						
//						printf("value =%s\n",value);*/
//				//	printf("value = %s\n",value);
//					char *str1=strstr(value,"-");
//					if(str1!=NULL){
//						len =strlen(value)-strlen(str1);
//						str1+=1;
//					//	printf("str1 =%s\n",str1);
//						
//						value[len] = 0;
//					//	printf("value=%s\n",value);
//						char *begin_str=strrchr(value,'.')+1;
//						char *end_str=strrchr(str1,'.')+1;
//
//					//	printf("begin_str=%s\n",begin_str);
//					//	printf("end_str=%s\n",end_str);
//						
//
//						int iBeginIP=atoi(begin_str);
//						int iEndIP=atoi(end_str);
//						len =strlen(value)-strlen(begin_str);
//						value[len]=0;
//					//	printf("value = %s\n",value);
//					//	printf("%d -%d \n",iBeginIP,iEndIP);
//						while(iBeginIP&lt;=iEndIP){
//							char ipaddr[100]={0};
//							sprintf(ipaddr,"%s%d",value,iBeginIP);
//								printf("ipaddr=%s\n",ipaddr);
//								hashtable-&gt;AddStreamName(ipaddr,(void *)1);
//							iBeginIP++;
//						}
//
//					}
//					else
//						hashtable-&gt;AddStreamName(value,(void *)1);
//
//					succed=1;
//				}
//			}
//	}
//	if(succed)
//		return 1;
//	return 0;
//}


//获取字符串，不带引号
int inirw::iniGetString(const char *section, const char *key, char *value, int maxlen, const char *defvalue)
{
	int ret;
	int len;


	ret = iniGetValue(section, key, value, maxlen, defvalue);
	if (!ret)
		return ret;


	//去首尾空格
	len = strlen(value);
	if (value[0] == '\'' &amp;&amp; value[len - 1] == '\'') {
		value[len - 1] = 0;
		memmove(value, value + 1, len - 1);
	} else
	if (value[0] == '\"' &amp;&amp; value[len - 1] == '\"') {
		value[len - 1] = 0;
		memmove(value, value + 1, len - 1);
	}
	return ret;
}




//获取整数值
int inirw::iniGetInt(const char *section, const char *key, int defvalue)
{
	char valstr[64];


	if (iniGetValue(section, key, valstr, sizeof(valstr), NULL))
	    return (int)strtol(valstr, NULL, 0);
	iniSetInt(section, key,defvalue,10);
	return defvalue;
}




//获取浮点数
double inirw::iniGetDouble(const char *section, const char *key, double defvalue)
{
	char valstr[64];


	if (iniGetValue(section, key, valstr, sizeof(valstr), NULL))
	    return (int)atof(valstr);
	return defvalue;
}




//设置字符串：若value为NULL，则删除该key所在行，包括注释
int inirw::iniSetString(const char *section, const char *key, const char *value)
{
	FILE *file;
	char *sect1, *sect2, *cont1, *cont2, *nextsect;
	char *p;
	int len, type;
	char content[SIZE_LINE];
	char *key0, *value0;
	char *rem1, *rem2, *nextline;




	if (gBuffer == NULL) {
		return 0;
	}


	if (FindSection(section, §1, §2, &amp;cont1, &amp;cont2, &amp;nextsect) == 0)
	{
		//未找到节


		//value无效则返回
		if (value == NULL) 
			return 0;


		//在文件尾部添加
		file = fopen(gFilename, "ab");
		
		if (file == NULL) 
			return 0;


		fprintf(file, "\r\n[%s]\r\n%s=%s;\r\n", section, key, value);
		fclose(file);
		iniFileLoad(gFilename);
		return 1;
	}


	//找到节，则节内查找key
	p = cont1;
	len = (int)(cont2 - cont1);
	while (len &gt; 0) {
		type = GetLine(p, len, content, &amp;rem1, &amp;rem2, &amp;nextline);


		if (LINE_VALUE == type) {
			GetKeyValue(content, &amp;key0, &amp;value0);
			if (StriCmp(key0, key) == 0) {
				//找到key
				file = fopen(gFilename, "wb");
				if (file == NULL) 
					return 0;
				len = (int)(p - gBuffer);
				fwrite(gBuffer, 1, len, file);					//写入key之前部分
				if (value == NULL) {
					//value无效，删除
					len = (int)(nextline - gBuffer);			//整行连同注释一并删除
				} else {
					//value有效，改写
					fprintf(file, "%s=%s", key, value);
					len = (int)(rem1 - gBuffer);				//保留尾部原注释!
				}
				fwrite(gBuffer + len, 1, gBuflen - len, file);	//写入key所在行含注释之后部分
				fclose(file);
				iniFileLoad(gFilename);
				return 1;
			}	
		}


		len -= (int)(nextline - p);
		p = nextline;
	}


	//未找到key


	//value无效则返回
	if (value == NULL) 
		return 0;


	//在文件尾部添加
	file = fopen(gFilename, "wb");
	if (file == NULL) 
		return 0;
	len = (int)(cont2 - gBuffer);
	fwrite(gBuffer, 1, len, file);					//写入key之前部分
	fprintf(file, "%s=%s;\r\n", key, value);
	fwrite(gBuffer + len, 1, gBuflen - len, file);	//写入key之后部分
	fclose(file);
	iniFileLoad(gFilename);
	return 1;
}




//设置整数值：base取值10、16、8，分别表示10、16、8进制，缺省为10进制
int inirw::iniSetInt(const char *section, const char *key, int value, int base)
{
	char valstr[64];


	switch (base) {
	case 16:
		sprintf(valstr, "0x%x", value);
		return iniSetString(section, key, valstr);
	case 8:
		sprintf(valstr, "0%o", value);
		return iniSetString(section, key, valstr);
	default:	//10
		sprintf(valstr, "%d", value);
		return iniSetString(section, key, valstr);
	}
}</code></pre> 
<br> 
<br>用法用例 
<pre><code class="language-cpp">inirw *configRead=new inirw("test.ini");
 char *sect="general";
//若文件中没有这个配置，则会自动生成
int x= configRead-&gt;iniGetInt(sect,"num" ,1);//整型数字的获取
char g_var_departcode[1024]={0};//字符串的获取
configRead-&gt;iniGetString(sect, "departcode", g_var_departcode, sizeof(g_var_departcode), "0");
delete configRead;
</code></pre> 
<br> 
<p><br></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9916f1e7fc7aceb7c2ad8dad9c8c2264/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">网络基础：浅析IP协议</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3b86a1cc7f675866f50e95a833229b36/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">History对象</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>