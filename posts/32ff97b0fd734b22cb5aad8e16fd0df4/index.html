<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java反序列化漏洞基础 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java反序列化漏洞基础" />
<meta property="og:description" content="前言 近年来反序列化漏洞可谓被大家熟知，尤其是的在JAVA 程序中发现了大量的反序列化漏洞，这种漏洞危害极大，可以直接造成RCE，获取到权限，本人之前对于这个漏洞一致认识很浅薄，甚至对于利用方式和工具都不太清楚，本文是对java语言基础的序列化与反序列化进行学习。
序列化与反序列化 Java 序列化是指把 Java 对象转换为字节序列的过程，序列化后的字节数据可以保存在文件、数据库中；而Java 反序列化是指把字节序列恢复为 Java 对象的过程。
所有在网络上面传输的对象，必须是可以序列化的。比如RMI（remote method invoke 远程方法调用），传入的参数和返回的结构都是可序列化的。所有需要保存到磁盘的对象都要实现序列化。通常建议创建的javaBean类都实现Serializable接口。
当然在实际场景中，直接使用JDK序列化的场景是很少的，一般都是使用其他方式，这是因为其本身有很多缺陷，如：无法跨语言、易被攻击、序列化后的流太大、序列化性能太差等。
但是我们通过学习他来了解基础原理，其他方式思路上应该也是大差不差。
java序列化 java中想要实现序列化与反序列化，主要是通过Serializable和Externalizable接口实现的。
Serializable与Externalizable的不同
Serializable接口是不需要提供无参构造器的，因为直接由虚拟机来创建对象的，不通过构造方法。Externalizable是通过反射来创建对象的，需要类中有无参构造器。
采用Externalizable无需产生serialVersionUID，而Serializable接口需要。
Externalizable 接口继承自 Serializable 接口，实现 Externalizable 接口的类完全由自身来控制反序列化的行为，而实现 Serializable 接口的类既可以采用默认的反序列化方式，也可以自定义反序列化方式。
Serializable接口 Serializable接口并没有要实现的方法，只是类似于一个标识符，表示这个类是可以被序列化的，不实现这个接口，序列化时程序会报错。
首先，我们创建一个User 类，这个类一定要实现Serializable接口
class User implements Serializable{ private int age; private String name; public User(){ }; public User(String name,int age){ this.age = age; this.name = name; } public String getName() { return name; } public void setName(String name) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/32ff97b0fd734b22cb5aad8e16fd0df4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-22T23:24:36+08:00" />
<meta property="article:modified_time" content="2023-02-22T23:24:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java反序列化漏洞基础</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="_0"></a>前言</h4> 
<p>近年来反序列化漏洞可谓被大家熟知，尤其是的在JAVA 程序中发现了大量的反序列化漏洞，这种漏洞危害极大，可以直接造成RCE，获取到权限，本人之前对于这个漏洞一致认识很浅薄，甚至对于利用方式和工具都不太清楚，本文是对java语言基础的序列化与反序列化进行学习。</p> 
<h4><a id="_4"></a>序列化与反序列化</h4> 
<p>Java 序列化是指把 Java 对象转换为字节序列的过程，序列化后的字节数据可以保存在文件、数据库中；而Java 反序列化是指把字节序列恢复为 Java 对象的过程。<br> <img src="https://images2.imgbox.com/78/62/ChzYFwW0_o.png" alt="在这里插入图片描述"></p> 
<p>所有在网络上面传输的对象，必须是可以序列化的。比如RMI（remote method invoke 远程方法调用），传入的参数和返回的结构都是可序列化的。所有需要保存到磁盘的对象都要实现序列化。通常建议创建的javaBean类都实现Serializable接口。</p> 
<p>当然在实际场景中，直接使用JDK序列化的场景是很少的，一般都是使用其他方式，这是因为其本身有很多缺陷，如：无法跨语言、易被攻击、序列化后的流太大、序列化性能太差等。</p> 
<p>但是我们通过学习他来了解基础原理，其他方式思路上应该也是大差不差。</p> 
<h4><a id="java_16"></a>java序列化</h4> 
<p>java中想要实现序列化与反序列化，主要是通过Serializable和Externalizable接口实现的。</p> 
<p>Serializable与Externalizable的不同</p> 
<ol><li> <p>Serializable接口是不需要提供无参构造器的，因为直接由虚拟机来创建对象的，不通过构造方法。Externalizable是通过反射来创建对象的，需要类中有无参构造器。</p> </li><li> <p>采用Externalizable无需产生serialVersionUID，而Serializable接口需要。</p> </li><li> <p>Externalizable 接口继承自 Serializable 接口，实现 Externalizable 接口的类完全由自身来控制反序列化的行为，而实现 Serializable 接口的类既可以采用默认的反序列化方式，也可以自定义反序列化方式。</p> </li></ol> 
<h5><a id="Serializable_27"></a>Serializable接口</h5> 
<p>Serializable接口并没有要实现的方法，只是类似于一个标识符，表示这个类是可以被序列化的，不实现这个接口，序列化时程序会报错。</p> 
<p>首先，我们创建一个User 类，这个类一定要实现Serializable接口</p> 
<pre><code>class User implements Serializable{
    private int age;
    private String name;

    public User(){

    };
    public User(String name,int age){
        this.age = age;
        this.name = name;
    }



    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
</code></pre> 
<p>然后，我们使用ObjectOutStream 和FileOutStream 将序列化后的内容输入到文件中，然后再使用ObjectInputStram 和FileInputStream 读取文件，将值反序列化为对象。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">User</span> peter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"peter"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">FileOutputStream</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">ObjectOutputStream</span> io <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
        io<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>peter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        io<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        io<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        file<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token class-name">FileInputStream</span> file1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ObjectInputStream</span> input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>file1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">User</span> pople <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">)</span> input<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pople<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>




    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="Externalizable_93"></a>Externalizable接口</h5> 
<p>实现Externalizable接口，必须实现writeExternal、readExternal方法。除此之外，实现该接口的类必须提供无参构造器，这是因为在反序列化时，是通过反射来创建对象的。</p> 
<p>这里和Serializable接口不一样，</p> 
<pre><code>public interface Externalizable extends java.io.Serializable {
    void writeExternal(ObjectOutput out) throws IOException;
    void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;
}
</code></pre> 
<h5><a id="_104"></a>序列化版本号</h5> 
<p>反序列化必须拥有class文件，但随着项目的升级，class文件也会升级，序列化怎么保证升级前后的兼容性呢？</p> 
<p>java序列化提供了一个private static final long serialVersionUID 的序列化版本号，这个值可以自由指定，也可由JVM根据类信息计算出一个值；由JVM计算的出的值会导致问题，如在程序移植后，JVM的计算方法可能存在差异，导致值不相同。</p> 
<p>只有版本号相同，即使更改了序列化属性，对象也可以正确被反序列化回来。如果反序列化使用的class的版本号与序列化时使用的不一致，程序会报InvalidClassException异常。</p> 
<p>下面是类被修改后的几种情况。</p> 
<ul><li>如果修改了非瞬态变量，则可能导致反序列化失败。如新类中实例变量的类型</li><li>序列化时类的类型不一致，则会反序列化失败，这时候需要更改serialVersionUID</li><li>如果只是新增了实例变量，则反序列化回来新增的是默认值；如果减少了实例变量，反序列化时会忽略掉减少的实例变量。</li></ul> 
<h4><a id="_118"></a>反序列化漏洞</h4> 
<p>Java反序列化了被恶意修改的序列化对象(<mark>须是服务器中存在的对象或者依赖包中的对象</mark>)。</p> 
<p>根据Java官方说明，任何实现Serializable接口的Class都可以定义自己的readObject()方法，只要在重写方法的同时执行了defaultReadObject()方法即可。这样在反序列化的时候会自动invoke该Class下自己定义的readObject()方法。如果该方法书写不当的话就有可能引发恶意代码的执行，如</p> 
<pre><code>package evilSerialize;

import java.io.*;

public class Evil implements Serializable{
    public String cmd;
    private void readObject(java.io.ObjectInputStream stream) throws Exception {
        stream.defaultReadObject();
        Runtime.getRuntime().exec(cmd);
    }
}
</code></pre> 
<p>但肯定不会有程序员写出这样的代码，所以往往实际中反序列化漏洞的构造比较复杂，而且需要借助Java的一些特性如Java的反射来进行漏洞利用。</p> 
<h4><a id="_138"></a>参考</h4> 
<p><a href="https://www.jianshu.com/p/c25c3eea9276" rel="nofollow">https://www.jianshu.com/p/c25c3eea9276</a><br> <a href="https://zhuanlan.zhihu.com/p/474825041" rel="nofollow">https://zhuanlan.zhihu.com/p/474825041</a><br> <a href="https://www.jianshu.com/p/729941f4e00c" rel="nofollow">https://www.jianshu.com/p/729941f4e00c</a><br> <a href="https://zhuanlan.zhihu.com/p/474825041" rel="nofollow">https://zhuanlan.zhihu.com/p/474825041</a><br> <a href="https://www.huaweicloud.com/zhishi/vss-002.html" rel="nofollow">https://www.huaweicloud.com/zhishi/vss-002.html</a><br> <a href="https://leihehe.top/2021/07/28/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8BJava%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%88%86%E6%9E%90-3/" rel="nofollow">https://leihehe.top/2021/07/28/Java反序列化漏洞之Java反序列化流程与分析-3/</a><br> <a href="https://xz.aliyun.com/t/6787" rel="nofollow">https://xz.aliyun.com/t/6787</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1d43e2e2800e591cda5c2db6a40d2a91/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Qt——线程与定时器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e3fcd26c82786260937d354abc87c8db/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IDEA 值得推荐的优秀插件分享</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>