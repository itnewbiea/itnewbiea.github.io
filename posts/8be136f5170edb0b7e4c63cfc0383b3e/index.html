<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>js的内存机制 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="js的内存机制" />
<meta property="og:description" content="前言 像C语言这样的底层语言一般都有底层的内存管理接口，比如 malloc()和free()用于分配内存和释放内存。
而对于JavaScript来说，会在创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放内存，这个自动释放内存的过程称为垃圾回收。
因为自动垃圾回收机制的存在，让大多Javascript开发者感觉他们可以不关心内存管理，所以会在一些情况下导致内存泄漏。
内存模型 JS内存空间分为栈(stack)和堆(heap)，其中栈存放变量，堆存放复杂对象。
JS中五种基本的数据类型Undefined、Null、Boolean、Number、String，是按值访问，数据在栈内存中的存储。
JS的引用数据类型，比如数组Array，它们值的大小是不固定的，引用数据类型的真实对象是保存在堆内存中的。
变量声明的本质是变量名与栈内存地址进行绑定，不直接与堆内存进行绑定。
声明的基本数据类型会将值存储在栈内存中，声明的复杂数据类型会将值存储在堆内存中并将其在堆中的内存地址作为值存到栈内存中。
例子：
基本数据类型
let index = 23 为变量（index）创建一个唯一标识符。
为变量分配一个内存地址（运行时）。
在分配的地址中存储一个值（23）。
基础数据类型直接将值存储在栈内存中，变量绑定到值在栈中对应的地址。
let _index = index 声明另一个变量_index并赋值为index，其实是将_index和index变量绑定到index指向的内存地址。
index = 45 修改变量index的值为基本数据类型，其实是在栈内存中分配内存存储值然后将得到的内存地址绑定到变量index。
复杂数据类型
let students = [] 为变量（students）创建一个唯一标识符。
在栈中给变量分配一个地址a（运行时）。
在堆中分配一个地址b，用来存储值 []（运行时）。
地址a所存储的值为地址b。
复杂数据类型在声明时是在堆内存上分配内存空间存储其值，将分配的堆内存空间地址作为值存储在栈内存上，变量直接绑定的是栈上内存地址。
通过引用来修改复杂数据：
let _students = students _students.push({ name: &#39;小明&#39; }) _status = students 赋值语句只是将两个变量指向同一个栈内存地址，push()语句将在堆内存中分配新空间存储新的数组并将其在堆内存的地址存储到栈中
let obj = { name: &#39;小明&#39; } let arr = [] arr = [ obj ] obj = null 内存模型示意图如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8be136f5170edb0b7e4c63cfc0383b3e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-21T22:58:09+08:00" />
<meta property="article:modified_time" content="2020-04-21T22:58:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">js的内存机制</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="_0"></a>前言</h4> 
<p>像C语言这样的底层语言一般都有底层的内存管理接口，比如 malloc()和free()用于分配内存和释放内存。<br> 而对于JavaScript来说，会在创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放内存，这个自动释放内存的过程称为垃圾回收。<br> 因为自动垃圾回收机制的存在，让大多Javascript开发者感觉他们可以不关心内存管理，所以会在一些情况下导致内存泄漏。</p> 
<h4><a id="_4"></a>内存模型</h4> 
<p>JS内存空间分为栈(stack)和堆(heap)，其中栈存放变量，堆存放复杂对象。</p> 
<p>JS中五种基本的数据类型Undefined、Null、Boolean、Number、String，是按值访问，数据在栈内存中的存储。<br> JS的引用数据类型，比如数组Array，它们值的大小是不固定的，引用数据类型的真实对象是保存在堆内存中的。<br> <img src="https://images2.imgbox.com/7a/ee/uYls9l03_o.png" alt="在这里插入图片描述"><br> 变量声明的本质是变量名与栈内存地址进行绑定，不直接与堆内存进行绑定。<br> 声明的基本数据类型会将值存储在栈内存中，声明的复杂数据类型会将值存储在堆内存中并将其在堆中的内存地址作为值存到栈内存中。</p> 
<p>例子：<br> <strong>基本数据类型</strong></p> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">23</span>
</code></pre> 
<p>为变量（index）创建一个唯一标识符。<br> 为变量分配一个内存地址（运行时）。<br> 在分配的地址中存储一个值（23）。<br> 基础数据类型直接将值存储在栈内存中，变量绑定到值在栈中对应的地址。<br> <img src="https://images2.imgbox.com/8e/58/uHXBPoTY_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> _index <span class="token operator">=</span> index
</code></pre> 
<p>声明另一个变量_index并赋值为index，其实是将_index和index变量绑定到index指向的内存地址。<br> <img src="https://images2.imgbox.com/29/8a/VNXRaLuY_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-javascript">index <span class="token operator">=</span> <span class="token number">45</span>
</code></pre> 
<p>修改变量index的值为基本数据类型，其实是在栈内存中分配内存存储值然后将得到的内存地址绑定到变量index。<br> <img src="https://images2.imgbox.com/da/8d/ONkYGmgz_o.png" alt="在这里插入图片描述"><br> <strong>复杂数据类型</strong></p> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> students <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code></pre> 
<p>为变量（students）创建一个唯一标识符。<br> 在栈中给变量分配一个地址a（运行时）。<br> 在堆中分配一个地址b，用来存储值 []（运行时）。<br> 地址a所存储的值为地址b。<br> 复杂数据类型在声明时是在堆内存上分配内存空间存储其值，将分配的堆内存空间地址作为值存储在栈内存上，变量直接绑定的是栈上内存地址。</p> 
<p><img src="https://images2.imgbox.com/ff/05/QgHDu5EI_o.png" alt="在这里插入图片描述"><br> 通过引用来修改复杂数据：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> _students <span class="token operator">=</span> students
_students<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> name<span class="token punctuation">:</span> <span class="token string">'小明'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p>_status = students 赋值语句只是将两个变量指向同一个栈内存地址，push()语句将在堆内存中分配新空间存储新的数组并将其在堆内存的地址存储到栈中<br> <img src="https://images2.imgbox.com/b3/95/MBAXSXsw_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> name<span class="token punctuation">:</span> <span class="token string">'小明'</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
arr <span class="token operator">=</span> <span class="token punctuation">[</span> obj <span class="token punctuation">]</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span>
</code></pre> 
<p>内存模型示意图如下：<br> <img src="https://images2.imgbox.com/9d/e2/CvFlBt2k_o.png" alt="在这里插入图片描述"><br> [obj]属于复杂类型中引用复杂类型是通过指针引用处理，虽然通过obj=null来清除了obj对于对象{index:‘小明’}的绑定，但是arr对该对象任然存在引用。</p> 
<h4><a id="_67"></a>内存生命周期</h4> 
<p><img src="https://images2.imgbox.com/43/e0/Y40D0bCf_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="JS__69"></a>JS 环境中分配的内存有如下生命周期：</h6> 
<ol><li>内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存</li><li>内存使用：即读写内存，也就是使用变量、函数等</li><li>内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存</li></ol> 
<p><em>为了便于理解，我们使用一个简单的例子来解释这个周期：</em></p> 
<pre><code class="prism language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>  <span class="token comment">// 在内存中给数值变量分配空间</span>
<span class="token function">alert</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 使用内存</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 使用完毕之后，释放内存空间</span>
</code></pre> 
<h4><a id="JS__82"></a>JS 的内存回收</h4> 
<p>JS 有自动垃圾回收机制，回收机制的原理是：找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会每隔固定的时间段就执行一次释放操作。</p> 
<p>然而大多数内存管理的问题都在这个阶段，在这里最艰难的任务是找到不再需要使用的变量：</p> 
<ul><li>在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。</li><li>但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量，以确保性能问题。</li></ul> 
<p>全局变量的生命周期直至浏览器卸载页面才会结束，也就是说全局变量不会被当成垃圾回收。</p> 
<h5><a id="js_91"></a>js的垃圾回收机制</h5> 
<p>对垃圾回收算法来说，核心思想就是如何判断内存已经不再使用了。</p> 
<ol><li>引用计数垃圾收集<br> 这是最简单的垃圾收集算法：此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用）, 对象将被垃圾回收机制回收。示例:</li></ol> 
<pre><code class="prism language-javascript"><span class="token comment">// 创建一个对象person，他有两个指向属性age和name的引用</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    age<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>
    name<span class="token punctuation">:</span> <span class="token string">'aaaa'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> p <span class="token operator">=</span> person<span class="token punctuation">;</span> 
person <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token comment">//原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收</span>

p <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>           <span class="token comment">//原person对象已经没有引用，很快会被回收</span>
</code></pre> 
<p>由上面可以看出，引用计数算法是个简单有效的算法。但它却存在一个致命的问题：循环引用。如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  o<span class="token punctuation">.</span>a <span class="token operator">=</span> o2<span class="token punctuation">;</span> <span class="token comment">// o 引用 o2</span>
  o2<span class="token punctuation">.</span>a <span class="token operator">=</span> o<span class="token punctuation">;</span> <span class="token comment">// o2 引用 o</span>

  <span class="token keyword">return</span> <span class="token string">"azerty"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ol start="3"><li>标记-清除<br> 这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。<br> 这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。<br> <img src="https://images2.imgbox.com/e5/e0/gUxtWj2k_o.png" alt="在这里插入图片描述"><br> 这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。<br> 工作流程：<br> 1.垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记。<br> 2.从根部出发将能触及到的对象的标记清除。<br> 3.那些还存在标记的变量被视为准备删除的变量。<br> 4.最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间。</li></ol> 
<h4><a id="_135"></a>内存泄漏</h4> 
<p>什么是内存泄露：对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。</p> 
<h5><a id="_137"></a>常见的内存泄露案例</h5> 
<h6><a id="1_138"></a>1.全局变量</h6> 
<pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    bar <span class="token operator">=</span> <span class="token string">"some text"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在 JS 中处理未被声明的变量, 上述范例中的 bar时, 会把bar, 定义到全局对象中, 在浏览器中就是 window 上. 在页面中的全局变量, 只有当页面被关闭后才会被销毁. 所以这种写法就会造成内存泄露, 当然在这个例子中泄露的只是一个简单的字符串, 但是在实际的代码中, 往往情况会更加糟糕.</p> 
<p>另外一种意外创建全局变量的情况.</p> 
<pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>var1 <span class="token operator">=</span> <span class="token string">"potential accidental global"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// Foo 被调用时, this 指向全局变量(window)</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在这种情况下调用foo, this被指向了全局变量window, 意外的创建了全局变量.</p> 
<p>我们谈到了一些意外情况下定义的全局变量, 代码中也有一些我们明确定义的全局变量. 如果使用这些全局变量用来暂存大量的数据, 记得在使用后, 对其重新赋值为 null.</p> 
<h6><a id="2__159"></a>2 未销毁的定时器和回调函数</h6> 
<pre><code class="prism language-javascript"><span class="token keyword">var</span> serverData <span class="token operator">=</span> <span class="token function">loadData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> renderer <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'renderer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>renderer<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        renderer<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>serverData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 每 5 秒调用一次</span>
</code></pre> 
<p>如果后续 renderer 元素被移除, 整个定时器实际上没有任何作用. 但如果你没有回收定时器, 整个定时器依然有效, 不但定时器无法被内存回收, 定时器函数中的依赖也无法回收. 在这个案例中的 serverData 也无法被回收。</p> 
<h6><a id="3__171"></a>3. 闭包</h6> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">generateFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> index<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
	<span class="token keyword">return</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  	<span class="token keyword">return</span> obj
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token function">generateFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 此时obj2就指向了上面定义的obj</span>
</code></pre> 
<h6><a id="4_DOM_184"></a>4. DOM引用</h6> 
<p>很多时候, 我们对 Dom 的操作, 会把 Dom 的引用保存在一个数组或者 Map 中。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">var</span> elements <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    image<span class="token punctuation">:</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'image'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    elements<span class="token punctuation">.</span>image<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://example.com/image_name.png'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">removeImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'image'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 这个时候我们对于 #image 仍然有一个引用, Image 元素, 仍然无法被内存回收.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上述案例中, 即使我们对于 image 元素进行了移除, 但是仍然有对 image 元素的引用, 依然无法对其进行内存回收.</p> 
<p>另外需要注意的一个点是, 对于一个 Dom 树的叶子节点的引用. 举个例子: 如果我们引用了一个表格中的td元素, 一旦在 Dom 中删除了整个表格, 我们直观的觉得内存回收应该回收除了被引用的 td外的其他元素. 但是事实上, 这个td 元素是整个表格的一个子元素, 并保留对于其父元素的引用. 这就会导致对于整个表格, 都无法进行内存回收. 所以我们要小心处理对于 Dom 元素的引用.</p> 
<h4><a id="_202"></a>内存泄漏的识别方法</h4> 
<h6><a id="1_203"></a>1.浏览器方法：</h6> 
<p><img src="https://images2.imgbox.com/c0/b6/ciXIh4F1_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="2_205"></a>2.命令行方法：</h6> 
<p>process.memoryUsage() 方法返回 Node.js 进程的内存使用情况的对象，该对象每个属性值的单位为字节。</p> 
<pre><code class="prism language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// {<!-- --></span>
<span class="token comment">//  rss: 4935680,</span>
<span class="token comment">//  heapTotal: 1826816,</span>
<span class="token comment">//  heapUsed: 650472,</span>
<span class="token comment">//  external: 49879</span>
<span class="token comment">// }</span>
</code></pre> 
<ul><li>rss（resident set size）：所有内存占用，包括指令区和堆栈。</li><li>heapTotal："堆"占用的内存，包括用到的和没用到的。</li><li>heapUsed：用到的堆的部分。</li><li>external： V8 引擎内部的 C++ 对象占用的内存。</li></ul> 
<p>判断内存泄漏，以heapUsed字段为准</p> 
<h4><a id="_225"></a>总结</h4> 
<p>即便在 JS 中, 我们很少去直接去做内存管理. 但是我们在写代码的时候, 也要有内存管理的意识, 谨慎的处理可能会造成内存泄露的场景。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/758bf773b0b2350759e312346aff5690/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">warning  Delete `␍`  prettier/prettier（eslint配置的一些问题）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2e2f1e3fc954f9dc77ad8a18eb1edf92/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机视觉——基础矩阵</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>