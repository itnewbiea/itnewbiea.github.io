<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>cocos creator 学习随笔 day03 节点和组件属性 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="cocos creator 学习随笔 day03 节点和组件属性" />
<meta property="og:description" content="目录
节点本身属性
控件属性
场景
空节点
3D对象
2D对象
UI组件
光线
特效
摄像机
地形
节点本身属性 第一栏为节点名，可修改，前面得勾，是表示是否使用该节点，去掉代表隐藏该节点，但是该节点依然存在。书籍图标为帮助信息，齿轮是组件不过这里应该叫做节点菜单，因为点进去得时候，出现得不是组件得操作。Position：相对父节点位置，如果父节点是场景则为世界坐标Rotation：旋转度，延X轴旋转，延Y轴旋转，延Z轴旋转，正数为逆时针旋转Scale：缩放倍数，延X轴缩放，延Y轴缩放，延Z轴缩放，因为是倍数，所以默认全是1，默认不是0，否则显示不出来，没有大小。layer：节点可见性，相机渲染场景，灯光照亮场景，不在范围内，不会展现出来和有亮光。具体看Edit： 控件属性 场景 AutoReleaseAssets：是否自动释放场景资源。勾上(true)就是自动释放，默认是否(false)Ambient：全局环境光属性， SkyColor：天空颜色，我的理解是从天空照射下来的颜色，相当于空中的光源SkyIllum：天空亮度，也可以认为是光的亮度GroundAlbedo：地面颜色，地面（有没有实体地面也可以）发出的颜色，相当于地面有光源上图是当skycolor红色时候，去掉光源后，可以看出来顶部就是纯红色。底下GroundAlbedo就是蓝色侧边则是根据两种颜色的混合过度填充而成。当亮度变大时的显示效果，可以看出来色彩方面亮度模糊了，开始偏向白色。也就是加亮到很大的时候，就是亮色的白。Fog：全局雾效 Enabled：是否启用全局雾效FogColor：全局雾颜色Type：全局雾类型 LINEAR：线性雾 FogStat：雾效起始位置FogEnd：雾效结束位置特点：随着远近变化，越远，颜色越深，越近颜色越浅，雾得朦感胧EXP：指数雾 FogDensity：雾化浓度，取值范围为 0 ~ 1FogAtten：雾化衰减系数特点：不随远近变化，不随角度变化EXP_SQUARED：指数平方雾，看上去好像和上面得没区别 FogDensity：雾化浓度，取值范围为 0 ~ 1FogAtten：雾化衰减系数特点：不随远近变化，不随角度变化LAYERED：层雾，也就是平常见雾，如高楼附近，山顶 FogRange：雾化效果影响的范围FogTop：模型顶点在世界坐标系垂直方向上的位置，小于该位置时所有的顶点都会受到雾化效果的影响FogAtten：雾效减弱系数特点：不随远近而变化，只随观看角度变化shadows阴影 Enabled：是否启用阴影Type：阴影类型 Planar：平面阴影，一般就是普通得阴影，影子垂直于Normal坐标得法线向量，然后阴影是Distance得距离。投影不对非平面实体起作用。也就是如下图，后面得方块，不会接收到投影。 开启方式：场景中启用shadows，需要显示阴影得节点得MeshRenderer中ShadowCastingMode设置为ONNormal：垂直于阴影的法线，用于调整阴影的倾斜度Distance：阴影在法线的方向上与坐标原点的距离注意：Planar 类型的阴影只有投射在平面上才能正常显示，不会投射在物体上，也就是说 MeshRenderer 组件中的 ReceiveShadow 属性是无效的。ShadowMap：是以光源为视点来渲染场景的。从光源位置出发，场景中看不到的地方就是阴影产生的地方。也就是平时得影子。 启用方式：场景中启用shadows，需要显示阴影得节点得MeshRenderer中ReceiveShadow设置为ONPcf：Pcf：百分比渐近过滤（PCF）是一个简单、常见的用于实现阴影边缘反走样的技术，通过对阴影边缘进行平滑处理来消除阴影贴图的锯齿现象。原理是在当前像素（也叫做片段）周围进行采样，然后计算样本跟片段相比更接近光源的比例，使用这个比例对散射光和镜面光成分进行缩放，然后再对片段着色，以达到模糊阴影边缘的效果。原本HARD，支持 5（ FILTER_X5） 倍、9（FILTER_X9） 倍 和 25（FILTER_X25） 倍采样，倍数越大，采样区域越大，阴影边缘也就越模糊。可以看出来，效果并不好。越来越糊。MaxReceived：最多支持产生阴影的光源数量，默认为 4 个，可根据需要自行调整 Bias：设置阴影偏移值，防止 z-fiting，也就是离产生阴影物体得最底部得偏移值。0就是直接位于物体下方开始。越接近1，越远。
Packing：平滑？跟下面得互斥，只能二选一Linear：不进行平滑处理SelfShadow：后面阴影部分得物体，完全遮挡AutoAdapt：若勾选该项，则自动计算阴影产生的范围，否则启用下列属性来手动设置阴影产生的范围。也就是说，下面得属性如果勾选了这个选项，就不起效果。这些属性不熟悉，还是直接用自动吧，手动调节需要很多时间，慢慢一点点调。 Near：设置主光源相机的近裁剪面Far：设置主光源相机的远裁剪面OrthoSize：设置主光源相机的正交视口大小ShadowMapSize：设置阴影纹理大小Aspect：设置主光源相机的正交视口长宽比ShadowColor：阴影颜色Skybox：天空盒，一个包裹整个场景的立方体，可以很好地渲染并展示整个场景环境，在基于 PBR 的工作流中天空盒也可以贡献非常重要的 IBL 环境光照。 Enabled：是否启用UseIBL：是否使用环境光照Envmap：环境贴图，TextureCube 类型，当该属性为空时，天空盒默认使用和显示的是像素贴图，因为一个物体是六个面，所以需要6张可以连接起来得图片，然后资料管理器里面创建一个Cubemap，如下图，然后拉入相应得位置。IsRGBE：环境贴图的像素格式是否为 RGBE 空节点 就是节点。跟别的控件基本节点属性没有任何区别控件就是空节点加上一个MeshRenderer（Materials加Mesh），如果没有加材质，就是下面紫色（默认没有材质颜色）。也就是说，显示加功能就是：节点&#43; MeshRenderer&#43; 脚本外观受Mesh控制，box.mesh就是矩形，capsule就是胶囊等。。。 3D对象 从上面理论得到，3D就是空节点 &#43; MeshRenderer，因为不加MeshRenderer看不到物体。
Capsule：胶囊，空节点 &#43; MeshRenderer（ default-material." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d4ea7ba4b5c81d3bc36a3a2482d884c6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-02T17:42:43+08:00" />
<meta property="article:modified_time" content="2021-08-02T17:42:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">cocos creator 学习随笔 day03 节点和组件属性</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E8%8A%82%E7%82%B9%E6%9C%AC%E8%BA%AB%E5%B1%9E%E6%80%A7-toc" style="margin-left:0px;"><a href="#%E8%8A%82%E7%82%B9%E6%9C%AC%E8%BA%AB%E5%B1%9E%E6%80%A7" rel="nofollow">节点本身属性</a></p> 
<p id="%E7%BB%84%E4%BB%B6%E5%B1%9E%E6%80%A7-toc" style="margin-left:0px;"><a href="#%E7%BB%84%E4%BB%B6%E5%B1%9E%E6%80%A7" rel="nofollow">控件属性</a></p> 
<p id="%E5%9C%BA%E6%99%AF%E7%BB%84%E4%BB%B6%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%9C%BA%E6%99%AF%E7%BB%84%E4%BB%B6%EF%BC%9A" rel="nofollow">场景</a></p> 
<p id="%E7%A9%BA%E8%8A%82%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E7%A9%BA%E8%8A%82%E7%82%B9" rel="nofollow">空节点</a></p> 
<p id="3D%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#3D%E5%AF%B9%E8%B1%A1" rel="nofollow">3D对象</a></p> 
<p id="2D%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#2D%E5%AF%B9%E8%B1%A1" rel="nofollow">2D对象</a></p> 
<p id="UI%E7%BB%84%E4%BB%B6-toc" style="margin-left:40px;"><a href="#UI%E7%BB%84%E4%BB%B6" rel="nofollow">UI组件</a></p> 
<p id="%E5%85%89%E7%BA%BF-toc" style="margin-left:40px;"><a href="#%E5%85%89%E7%BA%BF" rel="nofollow">光线</a></p> 
<p id="%E7%89%B9%E6%95%88-toc" style="margin-left:40px;"><a href="#%E7%89%B9%E6%95%88" rel="nofollow">特效</a></p> 
<p id="%E6%91%84%E5%83%8F%E6%9C%BA-toc" style="margin-left:40px;"><a href="#%E6%91%84%E5%83%8F%E6%9C%BA" rel="nofollow">摄像机</a></p> 
<p id="%E5%9C%B0%E5%BD%A2-toc" style="margin-left:40px;"><a href="#%E5%9C%B0%E5%BD%A2" rel="nofollow">地形</a></p> 
<hr id="hr-toc"> 
<p></p> 
<ol><li> <h2 id="%E8%8A%82%E7%82%B9%E6%9C%AC%E8%BA%AB%E5%B1%9E%E6%80%A7">节点本身属性</h2> 
  <ol><li><img alt="" height="253" src="https://images2.imgbox.com/da/7f/MCJJ9AZS_o.png" width="350"></li><li>第一栏为节点名，可修改，前面得勾，是表示是否使用该节点，去掉代表隐藏该节点，但是该节点依然存在。</li><li>书籍图标为帮助信息，齿轮是组件不过这里应该叫做节点菜单，因为点进去得时候，出现得不是组件得操作。</li><li>Position：相对父节点位置，如果父节点是场景则为世界坐标</li><li>Rotation：旋转度，延X轴旋转，延Y轴旋转，延Z轴旋转，正数为逆时针旋转</li><li>Scale：缩放倍数，延X轴缩放，延Y轴缩放，延Z轴缩放，因为是倍数，所以默认全是1，默认不是0，否则显示不出来，没有大小。</li><li>layer：节点可见性，相机渲染场景，灯光照亮场景，不在范围内，不会展现出来和有亮光。具体看Edit：<img alt="" height="441" src="https://images2.imgbox.com/04/00/WReLr4PE_o.png" width="758"></li></ol></li><li> <h2 id="%E7%BB%84%E4%BB%B6%E5%B1%9E%E6%80%A7">控件属性</h2> 
  <ol><li> <h3 id="%E5%9C%BA%E6%99%AF%E7%BB%84%E4%BB%B6%EF%BC%9A">场景</h3> 
    <ol><li><img alt="" height="663" src="https://images2.imgbox.com/5b/78/3ok7RbPY_o.png" width="271"></li><li>AutoReleaseAssets：是否自动释放场景资源。勾上(true)就是自动释放，默认是否(false)</li><li>Ambient：全局环境光属性， 
      <ol><li>SkyColor：天空颜色，我的理解是从天空照射下来的颜色，相当于空中的光源</li><li>SkyIllum：天空亮度，也可以认为是光的亮度</li><li>GroundAlbedo：地面颜色，地面（有没有实体地面也可以）发出的颜色，相当于地面有光源</li><li><img alt="" height="406" src="https://images2.imgbox.com/23/d0/3A3dfL4j_o.png" width="1092"></li><li>上图是当skycolor红色时候，去掉光源后，可以看出来顶部就是纯红色。</li><li><img alt="" height="428" src="https://images2.imgbox.com/86/69/qnNm3ajs_o.png" width="1079"></li><li>底下GroundAlbedo就是蓝色</li><li>侧边则是根据两种颜色的混合过度填充而成。</li><li><img alt="" height="408" src="https://images2.imgbox.com/57/9a/g5dYLhrw_o.png" width="881">当亮度变大时的显示效果，可以看出来色彩方面亮度模糊了，开始偏向白色。也就是加亮到很大的时候，就是亮色的白。</li></ol></li><li>Fog：全局雾效 
      <ol><li>Enabled：是否启用全局雾效</li><li>FogColor：全局雾颜色</li><li>Type：全局雾类型 
        <ol><li>LINEAR：线性雾 <p></p> 
          <ol><li><img alt="" height="510" src="https://images2.imgbox.com/1c/a0/44oPt1yn_o.png" width="1200"></li><li>FogStat：雾效起始位置</li><li>FogEnd：雾效结束位置</li><li>特点：随着远近变化，越远，颜色越深，越近颜色越浅，雾得朦感胧</li></ol></li><li>EXP：指数雾 
          <ol><li><img alt="" height="484" src="https://images2.imgbox.com/b0/e0/9NZmIPJe_o.png" width="1200"></li><li>FogDensity：雾化浓度，取值范围为 0 ~ 1</li><li>FogAtten：雾化衰减系数</li><li>特点：不随远近变化，不随角度变化</li></ol></li><li>EXP_SQUARED：指数平方雾，看上去好像和上面得没区别 <p></p> <p></p> 
          <ol><li><img alt="" height="347" src="https://images2.imgbox.com/90/38/jr2X9v4Z_o.png" width="1200"></li><li>FogDensity：雾化浓度，取值范围为 0 ~ 1</li><li>FogAtten：雾化衰减系数</li><li>特点：不随远近变化，不随角度变化</li></ol></li><li>LAYERED：层雾，也就是平常见雾，如高楼附近，山顶 <p></p> 
          <ol><li><img alt="" height="393" src="https://images2.imgbox.com/6f/b8/IR0vWEmv_o.png" width="1200"></li><li>FogRange：雾化效果影响的范围</li><li>FogTop：模型顶点在世界坐标系垂直方向上的位置，小于该位置时所有的顶点都会受到雾化效果的影响</li><li>FogAtten：雾效减弱系数</li><li>特点：不随远近而变化，只随观看角度变化</li></ol></li></ol></li></ol></li><li>shadows阴影 
      <ol><li><img alt="" height="191" src="https://images2.imgbox.com/be/62/KfFJ9Okl_o.png" width="411"></li><li>Enabled：是否启用阴影</li><li>Type：阴影类型 
        <ol><li>Planar：平面阴影，一般就是普通得阴影，影子垂直于Normal坐标得法线向量，然后阴影是Distance得距离。投影不对非平面实体起作用。也就是如下图，后面得方块，不会接收到投影。 <p></p> 
          <ol><li><img alt="" height="297" src="https://images2.imgbox.com/50/f1/ujLxJrsj_o.png" width="1200"></li><li>开启方式：场景中启用shadows，需要显示阴影得节点得MeshRenderer中ShadowCastingMode设置为ON</li><li>Normal：垂直于阴影的法线，用于调整阴影的倾斜度</li><li>Distance：阴影在法线的方向上与坐标原点的距离</li><li><strong>注意</strong>：Planar 类型的阴影只有投射在平面上才能正常显示，不会投射在物体上，也就是说 MeshRenderer 组件中的 <strong>ReceiveShadow</strong> 属性是无效的。</li></ol></li><li>ShadowMap：是以光源为视点来渲染场景的。从光源位置出发，场景中看不到的地方就是阴影产生的地方。也就是平时得影子。 
          <ol><li><img alt="" height="395" src="https://images2.imgbox.com/88/02/4xHeJaay_o.png" width="1200"></li><li>启用方式：场景中启用shadows，需要显示阴影得节点得MeshRenderer中ReceiveShadow设置为ON</li><li>Pcf：Pcf：百分比渐近过滤（PCF）是一个简单、常见的用于实现阴影边缘反走样的技术，通过对阴影边缘进行平滑处理来消除阴影贴图的锯齿现象。原理是在当前像素（也叫做片段）周围进行采样，然后计算样本跟片段相比更接近光源的比例，使用这个比例对散射光和镜面光成分进行缩放，然后再对片段着色，以达到模糊阴影边缘的效果。原本<strong>HARD，</strong>支持 5（ <strong>FILTER_X5</strong>） 倍、9（<strong>FILTER_X9</strong>） 倍 和 25（<strong>FILTER_X25</strong>） 倍采样，倍数越大，采样区域越大，阴影边缘也就越模糊。可以看出来，效果并不好。越来越糊。<img alt="" height="853" src="https://images2.imgbox.com/84/63/4A9eB4vh_o.png" width="805"></li><li>MaxReceived：最多支持产生阴影的光源数量，默认为 4 个，可根据需要自行调整</li><li> <p> Bias：设置阴影偏移值，防止 z-fiting，也就是离产生阴影物体得最底部得偏移值。0就是直接位于物体下方开始。越接近1，越远。<img alt="" height="385" src="https://images2.imgbox.com/11/12/uDSsavhy_o.png" width="1008"></p> </li><li>Packing：平滑？跟下面得互斥，只能二选一<img alt="" height="381" src="https://images2.imgbox.com/8b/e7/FBOeZ84U_o.png" width="1200"></li><li>Linear：不进行平滑处理<img alt="" height="381" src="https://images2.imgbox.com/a2/fa/hbMLTsp3_o.png" width="1200"></li><li>SelfShadow：后面阴影部分得物体，完全遮挡<img alt="" height="467" src="https://images2.imgbox.com/fa/29/Db2lF3jW_o.png" width="1200"></li><li>AutoAdapt：若勾选该项，则自动计算阴影产生的范围，否则启用下列属性来手动设置阴影产生的范围。也就是说，下面得属性如果勾选了这个选项，就不起效果。这些属性不熟悉，还是直接用自动吧，手动调节需要很多时间，慢慢一点点调。 
            <ol><li>Near：设置主光源相机的近裁剪面</li><li>Far：设置主光源相机的远裁剪面</li><li>OrthoSize：设置主光源相机的正交视口大小</li><li>ShadowMapSize：设置阴影纹理大小</li><li>Aspect：设置主光源相机的正交视口长宽比</li></ol></li></ol></li></ol></li><li>ShadowColor：阴影颜色</li></ol></li><li>Skybox：天空盒，一个包裹整个场景的立方体，可以很好地渲染并展示整个场景环境，在基于 PBR 的工作流中天空盒也可以贡献非常重要的 IBL 环境光照。 
      <ol><li><img alt="" height="185" src="https://images2.imgbox.com/2c/3d/xB6w7wce_o.png" width="326"></li><li>Enabled：是否启用</li><li>UseIBL：是否使用环境光照</li><li>Envmap：环境贴图，TextureCube 类型，当该属性为空时，天空盒默认使用和显示的是像素贴图，因为一个物体是六个面，所以需要6张可以连接起来得图片，然后资料管理器里面创建一个Cubemap，如下图，然后拉入相应得位置。</li><li><img alt="" height="783" src="https://images2.imgbox.com/5d/94/fklyhIJf_o.png" width="363"></li><li>IsRGBE：环境贴图的像素格式是否为 RGBE</li><li></ol></li></ol></li></ol></li><li> <h3 id="%E7%A9%BA%E8%8A%82%E7%82%B9">空节点</h3> 
  <ol><li>就是节点。跟别的控件基本节点属性没有任何区别<img alt="" height="266" src="https://images2.imgbox.com/e2/d4/tREvD3Fn_o.png" width="348"></li><li>控件就是空节点加上一个MeshRenderer（Materials加Mesh），如果没有加材质，就是下面紫色（默认没有材质颜色）。</li><li><img alt="" height="706" src="https://images2.imgbox.com/94/07/nLjAan9M_o.png" width="1141"><img alt="" height="636" src="https://images2.imgbox.com/97/3d/VeBFtYlS_o.png" width="1200"></li><li>也就是说，显示加功能就是：节点+ MeshRenderer+ 脚本</li><li>外观受Mesh控制，box.mesh就是矩形，capsule就是胶囊等。。。</li></ol></li><li> <h3 id="3D%E5%AF%B9%E8%B1%A1">3D对象</h3> 
  <ol><li> <p><img alt="" height="704" src="https://images2.imgbox.com/e6/b1/j7UNfIiX_o.png" width="345"></p> </li><li> <p>从上面理论得到，3D就是空节点 + MeshRenderer，因为不加MeshRenderer看不到物体。</p> </li><li> <p>Capsule：胶囊，空节点 + MeshRenderer（ default-material.mtl + capsule.mesh）</p> </li><li> <p>Cone：圆锥体，空节点 + MeshRenderer（ default-material.mtl + cone.mesh）</p> </li><li> <p>Cube：立方体，空节点 + MeshRenderer（ default-material.mtl + cube.mesh）</p> </li><li> <p>Cylinder：圆柱，空节点 + MeshRenderer（ default-material.mtl + cylinder.mesh）</p> </li><li> <p>Plane：平面，空节点 + MeshRenderer（ default-material.mtl + plane.mesh）这个有点特殊，好像不能增加高度，就是没办法弄成一个正方体，所以这是个平着得四方形？</p> </li><li> <p>Quad：四方形，空节点 + MeshRenderer（ default-material.mtl + quad.mesh），不能形成体</p> </li><li> <p>Sphere：球体，空节点 + MeshRenderer（ default-material.mtl + sphere.mesh）</p> </li><li> <p>Torus：圆环体，空节点 + MeshRenderer（ default-material.mtl + torus.mesh）</p> </li></ol></li><li> <h3 id="2D%E5%AF%B9%E8%B1%A1">2D对象</h3> <p></p> 
  <ol><li>类似3D，其实2D对象是由空节点 + UITransform+ 对应功能的组件构成。</li><li>2D对象，必须先要有一个Canvas才可以，而3D得相机不能用于2D（具体为什么，放在下面摄像机说明），所以还需要一个相机在Canvas里面。也就是说，cocos creator 3.x 场景下面默认是3D，然后要加一个类似场景得2D外壳Canvas画板，才能放置2D对象。<img alt="" height="202" src="https://images2.imgbox.com/1b/ed/jOaJE181_o.png" width="278"></li><li>Canvas：2D的画板，由空节点 + UITransform + Canvas + Widget，只是组成了Canvas，但是里面还是要相机才可以显示出来，要不然显示不了内容，黑屏。 
    <ol><li><img alt="" height="786" src="https://images2.imgbox.com/e1/f8/zq1C1QYp_o.png" width="559"></li><li>节点属性我们在上面研究过了，这里只看多出来的组件，cc指的是cc库</li><li>cc.UITransform：定义了 UI 上的矩形信息，包括矩形的尺寸和锚点位置。开发者可以通过该组件任意地操作矩形的大小、位置。一般用于渲染、点击事件的计算、界面布局以及屏幕适配等。  
      <ol><li><img alt="" height="104" src="https://images2.imgbox.com/21/a1/f8Nnk9To_o.png" width="407"></li><li>ContentSize：UI 矩形内容尺寸，也就是节点的展示宽高。</li><li>AnchorPoint：UI 矩形锚点位置。相当起点的意思？ 0-1，【0.5，0.5】是中心的位置。</li></ol></li><li>cc.Canvas：画布组件 
      <ol><li><img alt="" height="104" src="https://images2.imgbox.com/78/9b/tKjXCm4w_o.png" width="410"></li><li>CameraComponent：2D渲染相机，这里是最关键的组件属性，把相机绑定到画布组件，才能显示出内容。而且相机不一定是子节点<img alt="" height="469" src="https://images2.imgbox.com/6f/8d/kUljz6HF_o.png" width="742"></li><li>AligCanvasWithScreen：2D下，自动为相机计算参数。这里有自动，也就是可以手动设置？没找到手动设置的位置</li></ol></li><li>cc.Widget：(对齐挂件) 是一个很常用的 UI 布局组件。它能使当前节点自动对齐到父物体的任意位置，或者约束尺寸，让你的游戏可以方便地适配不同的分辨率。 
      <ol><li><img alt="" height="408" src="https://images2.imgbox.com/bc/9e/9gV5Kbzf_o.png" width="292"></li><li>上边图形调节属性后的参考布局。</li><li>Horizontal Alignment：水平方向布局设置，none,left,center,right,strecth 
        <ol><li>none：默认中间布局</li><li>left：距离左侧多少px，出现的left 0px，里面可以设置距离左侧偏移量。<img alt="" height="286" src="https://images2.imgbox.com/2d/6a/7omR3QLB_o.png" width="274"></li><li>center：跟none一样的效果。出现的center 0px好像不能设置<img alt="" height="286" src="https://images2.imgbox.com/5a/b9/0FA4lmXi_o.png" width="273"></li><li>right：距离右侧多少，px出现的right 0px，里面可以设置距离右侧偏移量。<img alt="" height="306" src="https://images2.imgbox.com/f3/73/C0zKnTFp_o.png" width="273"></li><li>strecth：水平两边偏移量，可以设置left和right到目标对象的距离<img alt="" height="302" src="https://images2.imgbox.com/e8/bd/AG9eVjcF_o.png" width="287"></li></ol></li><li>Vertical Alignment：竖直方向布局设置，none,left,center,right,strecth，具体的图跟上面类型，但是方向是竖着的方向。</li><li>Target：对齐的目标，只能是当前节点的其中一个父节点（父父节点），默认为空，表示当前节点的父节点</li><li>AlignMode：指定Widget的对齐模式，用于决定运行时Widget应该何时刷新。默认为ON_WINDOW_RESIZE 
        <ol><li>NONE：不设置对齐模式</li><li>ALWAYS：一直都对齐。</li><li>ON_WINDOW_RESIZE：当窗口修改尺寸的时候重新对齐。</li></ol></li></ol></li></ol></li><li>Graphics：2D绘图，提供了一系列绘画接口，这些接口参考了 Canvas 的绘画接口来进行实现。 
    <ol><li><img alt="" height="547" src="https://images2.imgbox.com/2b/45/DtmKQv3R_o.png" width="311"></li><li>这里可以看出来是由：node + UItransform + Graphics构成，其中Graphics就是提供该控件功能的组件。所以只看Graphics组件就可以了 
      <ol><li>CustomMaterial：自定义材质，该组件使用的材质</li><li>LineWidth：画图的时候，线条的宽度。</li><li>LineJoin：两条线相交时，创建的拐角类型 
        <ol><li>BEVEL：创建斜角</li><li>ROUND：创建圆角</li><li>MITER：默认，创建尖角</li></ol></li><li>LineCap：线条的结束端点样式 
        <ol><li>BUTT：默认。向线条的每个末端添加平直的边缘。</li><li>ROUND：向线条的每个末端添加圆形线帽。</li><li>SQUARE：向线条的每个末端添加正方形线帽。</li></ol></li><li>StrokeColor：笔触颜色。就是画图的时候，使用的笔的颜色</li><li>FillColor：填充颜色，当需要填充时候，填充进去的颜色。</li><li>MiterLimit：正数。最大斜接长度。斜接长度指的是在两条线交汇处内角和外角之间的距离。<strong>注意</strong>：只有当 lineJoin 属性为 <code>miter</code> 时，miterLimit 才有效。</li></ol></li></ol></li><li>Lable：文本控件， 
    <ol><li><img alt="" height="878" src="https://images2.imgbox.com/b5/27/sz5vfkLA_o.png" width="380"></li><li>这里可以看出来是由：node + UItransform + Label构成，其中Label就是提供该控件功能的组件。所以只看Label组件就可以了. 
      <ol><li>CustomMaterial：自定义材质</li><li>Color：展示的文本的颜色</li><li>String：控件展示的文本内容</li><li>HorizontalAlign：水平对齐方式：LEFT，RIGHT，默认：CENTER</li><li>VerticalAlign：竖着对齐方式：TOP，BOTTON，默认：CENTER</li><li>FontSize：字体大小</li><li>FontFamily：字体，可以输入系统已经有的字体如宋体，或者后面字体使用自己的字体。</li><li>LineHeight：</li><li>Overflow：文字排版 
        <ol><li>NONE：空，自动改变width属性。这个是根据UITransform里面的AnchorPoint（锚点）和Label里面的HorizontalAlign有关。默认是按锚点往两边改变宽度。如果要实现说前面固定，后面增加位数，比如显示分数这样的，需要把锚点x设置为0.</li><li>CLAMP：超出边框宽度会被截断，相当于后面没有</li><li>SHRINK：自动根据节点约束框缩小文字，就是当放不下时候，会把字体缩小</li><li>RESIZE_HEIGHT：根据文本内容自动更新节点的height属性，就是会自动改变高度，自动换行展示。相当于把EnableWrapText勾上同样效果。设置为RESIZE_HEIGHT不管有没有EnableWrapText都自动换行。</li></ol></li><li>EnableWrapText：是否允许换行，多行展示</li><li>Font：设置自定义字体</li><li>UseSystemFont：使用系统字体，默认勾上</li><li>CacheMode：字体缓存模式 
        <ol><li>NONE：默认值，对富文本所拆分创建的每个 Label 节点，设置其 CacheMode 为 NONE 类型，即将每个 Label 的整段文本生成一张位图并单独进行渲染。</li><li>BITMAP：对富文本所拆分创建的每个 Label 节点，设置其 CacheMode 为 BITMAP 类型，即将每个 Label 的整段文本生成一张位图，并将该位图添加到动态图集中，再依据动态图集进行合并渲染。</li><li>CHAR：对富文本所拆分创建的每个 Label 节点，设置其 CacheMode 为 CHAR 类型，即将每个 Label 的文本以“字”为单位缓存到全局共享的位图中，相同字体样式和字号的每个字符将在全局共享一份缓存。</li></ol></li><li>IsBold：是否加粗</li><li>IsItalic：是否倾斜</li><li>IsUnderLine：是否在字体下显示下划线。</li></ol></li></ol></li><li>Mask：遮罩，主要组成：Node + UITransform + Mask，mask 节点需要做为 父节点存在. 被裁剪的图片节点应当挂在mask 节点之下做为子节点.Mask 用于规定子节点可渲染的范围，默认带有 Mask 组件的节点会使用该节点的约束框（也就是 <strong>属性检查器</strong> 中 Node 组件的 <strong>ContentSize</strong> 规定的范围）创建一个矩形渲染遮罩，该节点的所有子节点都会依据这个遮罩进行裁剪，遮罩范围外的将不会渲染。控件PageView里面的View就是用了Mask实现的 
    <ol><li><img alt="" height="147" src="https://images2.imgbox.com/0a/7e/CZROx2QN_o.png" width="390"></li><li> <p style="text-align:center;"><img alt="mask" src="https://images2.imgbox.com/ce/6e/5SKFbVAf_o.png"></p> </li><li>前面我们已经研究过node 和 UITransform，我们只要要救Mask组件。</li><li>Type：遮罩类型 
      <ol><li>RECT：矩形 <p style="text-align:center;"><img alt="mask" src="https://images2.imgbox.com/1e/1f/5uZGpli3_o.png"></p> </li><li>ELLIPSE：椭圆 <p style="text-align:center;"><img alt="mask" src="https://images2.imgbox.com/2d/d7/b0NsMuqP_o.png"></p> 
        <ol><li>Segments：椭圆遮罩的曲线细分数</li></ol></li><li>GRAPHICS_STENCIL：自定义图形遮罩 <p style="text-align:center;"><img alt="mask" src="https://images2.imgbox.com/2b/c9/55TL4OoD_o.png"></p> </li><li>IMAGE_STENCIL：自定义图片遮罩 <p style="text-align:center;"><img alt="mask" src="https://images2.imgbox.com/55/82/iBPTUkHQ_o.png"></p> </li></ol></li><li>Inverted：反向遮罩，不支持Canvas模式</li></ol><p></p> </li><li>ParticleSystem2D：2D粒子 
    <ol><li><img alt="" height="556" src="https://images2.imgbox.com/62/62/hdaJ1m87_o.png" width="400"></li><li>这里可以看出来是由：node + UItransform + ParticleSystem2D构成，其中ParticleSystem2D就是提供该控件功能的组件。所以只看ParticleSystem2D组件就可以了.</li><li>CustomMaterial：自定义材质</li><li>Color：渲染的颜色，好像改变了没啥变化。。</li><li>Preview：在编辑器模式下预览粒子，启用后，选中粒子，将自动播放</li><li>PlayOnLoad：加载的时候自动播放</li><li>AutoRemoveOnFinish：粒子播放完毕后自动销毁组件所在的节点</li><li>File：plist格式的粒子配置文件。其实，所以粒子就是个配置文件。</li><li>Custom：是否自定义粒子。可以直接修改plist文件，但是，为啥不能直接创建plist文件，然后再自定义呢，非要外面创建一个plist文件？ 
      <ol><li><img alt="" height="624" src="https://images2.imgbox.com/6b/a5/fml1AM50_o.png" width="387"></li><li>同步：就是把修改了的属性同步修改回去当前splist文件，导出：就是保存为新的文件，然后这边属性面板会自动使用刚刚保存的文件。</li><li>SpriteFrame：粒子贴图定义，每个粒子的贴图，粒子会使用该贴图来定义粒子的形状。</li><li>TotalParticles：粒子总数，默认200，好像有上限</li><li>Duration：粒子系统运行时间。-1代表永远不结束。</li><li>EmissionRate：每秒发射的粒子数量。受粒子总数影响。</li><li>Life：粒子的运行时间及变化范围： 
        <ol><li> <p> 第一个框：是粒子的运行时间：粒子发射出来，然后到消失的时间，一个轮回的时间是多少。</p> </li><li> <p></p> <p>第二个框：是粒子的变化范围：旋转范围大小</p> </li></ol></li><li>StartColor：粒子初始的颜色，前面的颜色看着是下层，后面的是上层<img alt="" height="384" src="https://images2.imgbox.com/ad/ea/ohOTg0FI_o.png" width="1087"></li><li>EndColor：粒子结束的颜色，类似上面，前面的颜色看着是下层，后面的是上层</li><li>Angle：粒子角度及变化范围</li><li>StartSize：粒子的初始大小及变化范围：</li><li>EndSize：粒子的结束大小及变化范围：</li><li>StartSpin：粒子开始自旋及变化范围：</li><li>EndSpin：粒子结束自旋及变化范围：</li><li>PosVar：发射器位置的变化范围（横向和纵向）：<img alt="" height="655" src="https://images2.imgbox.com/30/99/qnxbCssW_o.png" width="790"></li><li>PositionType：粒子位置类型</li><li>EmitterMode：发射器类型：</li><li>Gravity：重力</li><li>Speed：速度</li><li>TangentialAccel：每个粒子的切向加速度变化范围，即垂直于重力方向的加速度，只有在重力模式下可用。</li><li>RadialAccel：粒子径向加速度及变化范围，即平行于重力方向的加速度，只有在重力模式下可用。</li><li>RotationIsDir：每个粒子的旋转是否等于其方向，只有在重力模式可用。</li></ol></li></ol></li><li>Sprite：精灵，按我的理解就是个图片展示。 
    <ol><li>node和UITransform就截图了，直接分析里面的Sprite组件。</li><li><img alt="" height="297" src="https://images2.imgbox.com/77/94/LRNAdJld_o.png" width="395"></li><li>Type：渲染模式 
      <ol><li><img alt="" height="123" src="https://images2.imgbox.com/e1/2b/NHaETCns_o.png" width="460"></li><li>Simple：默认值，根据原始图片资源渲染 Sprite，一般在这个模式下我们不会手动修改节点的尺寸，来保证场景中显示的图像和美术人员生产的图片比例一致。</li><li>Sliced：图像将被分割成九宫格，并按照一定规则进行缩放以适应可随意设置的尺寸(<code>size</code>)。通常用于 UI 元素，或将可以无限放大而不影响图像质量的图片制作成九宫格图来节省游戏资源空间</li><li>Tiled：当 Sprite 的尺寸增大时，图像不会被拉伸，而是会按照原始图片的大小不断重复，就像平铺瓦片一样将原始图片铺满整个 Sprite 规定的大小。</li><li>Filled：根据原点和填充模式的设置，按照一定的方向和比例绘制原始图片的一部分。经常用于进度条的动态展示。<img alt="" height="153" src="https://images2.imgbox.com/0a/1a/XjEzu090_o.png" width="281"> 
        <ol><li>FillCenter：填充中心，没法修改</li><li>FillStart：填充的起始位置，0-1，1为开始点就是结束点，所以不显示图片。</li><li>FillRange：填充总量。0-1，1为开始到结束全部填充。</li></ol></li></ol></li><li>CustomMaterial：自定义材质</li><li>Grayscale：灰度模式，开启后 Sprite 会使用灰度模式渲染。</li><li>Color：渲染颜色，这里的颜色，会跟图片本身的颜色混在一起，形成一个混合色。</li><li>SpriteAtlas：Sprite 显示图片资源所属的图集。就是一个大图有很多的小图，使用splist来进行选择每一个图。</li><li>SpriteFrame：渲染 Sprite 使用的 SpriteFrame 图片资源</li><li>SizeMode：指定 Sprite 的尺寸 
      <ol><li><strong>Trimmed</strong> 表示会使用原始图片资源裁剪透明像素后的尺寸</li><li><strong>Raw</strong> 表示会使用原始图片未经裁剪的尺寸</li><li><strong>Custom</strong> 表示会使用自定义尺寸。当用户手动修改过 <strong>Size</strong> 属性后，<strong>Size Mode</strong> 会被自动设置为 <strong>Custom</strong>，除非再次指定为前两种尺寸。</li></ol></li><li>Trim：是否渲染原始图像周围的透明像素区域</li></ol></li><li>SpriteSplash：单色精灵 
    <ol><li><img alt="" height="304" src="https://images2.imgbox.com/4f/a8/5TyQfl1I_o.png" width="399"></li><li>可以看出来，其实跟上面的精灵是一样的，只是默认的SpriteFrame不一样，一个是default_sprite_splash，一个是default_sprite。</li></ol></li><li>TiledMap：瓦片地图 
    <ol><li><img alt="" height="163" src="https://images2.imgbox.com/45/ba/RLIVyBIU_o.png" width="398"></li><li>瓦片图资源是由 <a href="https://www.mapeditor.org/" rel="nofollow">Tiled 编辑器</a> 所导出的数据格式（Cocos Creator 3.0 支持 Tiled v1.6.0）</li><li>为了提高资源管理效率，建议将导入的 <code>tmx</code>、<code>tsx</code> 和 <code>png</code> 文件存放在单独的目录下，不要和其他资源混在一起。 需要注意的是要把 <code>tmx</code> 文件和 <code>tsx</code> 文件放在同一目录管理，否则可能会导致资源无法被正确加载。</li><li>EnableCulling：启用裁剪，如果需要旋转地图或者把地图置于 3D 相机中，则需要关闭裁剪。如果地图块不是非常多，例如小于 5000 块，那么关闭裁剪能减少 CPU 的运算负担，GPU 直接使用缓存进行渲染</li><li>TmxAsset：指定 <code>.tmx</code> 格式的地图资源（请将 <code>.tmx</code> 和 <code>.tsx</code> 放置于同一文件夹）</li><li>详细使用参考：<a href="https://docs.cocos.com/creator/3.2/manual/zh/editor/components/tiledmap.html?h=enableculling" rel="nofollow">https://docs.cocos.com/creator/3.2/manual/zh/editor/components/tiledmap.html?h=enableculling</a></li></ol></li></ol></li><li> <h3 id="UI%E7%BB%84%E4%BB%B6">UI组件</h3> UI组件，组成跟2D类似，也是空节点+UITransform+相应的功能组件 构成。不过有一些是底下有子节点一起组成的。 
  <ol><li>Button：按钮，主组成：node + UITransform + Sprite + Button，附加一个子节点Label，而Label属于2D控件，所以这就有意思了，感觉这里是按照功能分类的？ 
    <ol><li><img alt="" height="69" src="https://images2.imgbox.com/5b/18/kb81pqcX_o.png" width="247"></li><li><img alt="" height="476" src="https://images2.imgbox.com/f5/e8/LP873q8J_o.png" width="395"></li><li>除了Button组件，其他的，我们都已经研究过了，所以这里就只研究Button组件 
      <ol><li>Target：过渡效果作用目标节点</li><li>Interactable：按钮是否可交互，这一项未选中时，按钮处在禁用状态。</li><li>Transition：按钮状态变化时的过渡类型， 
        <ol><li>NONE：没有过渡效果</li><li>COLOR：颜色过渡，不同状态使用不同的背景颜色 
          <ol><li>NormalColor：普通状态的按钮背景颜色</li><li>PressedColor：按下状态的按钮背景颜色</li><li>HoverColor：悬停状态的按钮背景颜色</li><li>DIsabledColor：禁用状态的按钮背景颜色</li></ol></li><li>SPRITE：图片过渡，不同状态使用不同的背景图片 
          <ol><li>NormalSprite：普通状态的按钮背景图片资源</li><li>PressedSprite：按下状态的按钮背景图片资源</li><li>HoverSprite：悬停状态的按钮背景图片资源</li><li>DIsabledSprite：禁用状态的按钮背景图片资源</li></ol></li><li>SCALE：缩放过渡，当按钮按下时，出现缩放效果 
          <ol><li>Duration：按钮颜色变化或者缩放变化的过度时间</li><li>ZoomScale：当用户点击按钮后，按钮会缩放到一个值，这个值等于Button原始Scale * ZoomScale，zoomscale可以是负数。</li></ol></li></ol></li><li>ClickEvent：点击事件列表。列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。 
        <ol><li><img alt="" height="216" src="https://images2.imgbox.com/85/9b/0JLUA3X6_o.png" width="384"></li><li>每次事件触发，会触发这里配置的对应节点的组件的函数。也就是相当于把这些事件都绑定到当前事件一样了。</li></ol></li></ol></li></ol></li><li>Canvas（上面已经讲过了）</li><li>EditBox：输入框，主组成：node+UItransform + Sprite + EditBox，附加两个子节点TEXT_LABEL，PLACEHOLDER_LABEL 
    <ol><li> <p> <img alt="" height="84" src="https://images2.imgbox.com/37/02/AdwiyhgS_o.png" width="256"></p> </li><li> <p><img alt="" height="657" src="https://images2.imgbox.com/51/61/iEoscurg_o.png" width="383"></p> </li><li> <p>除了EditBox组件，其他的，我们都已经研究过了，所以这里就只研究EditBox组件。和附加子节点TEXT_LABEL，PLACEHOLDER_LABEL</p> 
      <ol><li> <p>String：输入框的初始输入内容，如果内容为空则会显示占位符的文本。</p> </li><li> <p>Placeholder：输入框占位符的文本内容。</p> </li><li> <p>TextLabel：输入框输入文本节点上挂载的Label组件对象</p> </li><li> <p>输入框占位符节点上挂载的Label组件对象</p> </li><li> <p>BackgroundImage：输入框的背景图片</p> </li><li> <p>InputFlag：指定输入标识，可以指定输入方式为密码或者单词首字母大写</p> 
        <ol><li> <p>PASSWORD：表明输入的文本是保密的数据，任何时候都应该隐藏起来</p> </li><li> <p>SENSITIVE：表明输入的文本是敏感数据，它禁止存储到字典或表里面，也不能用来自动补全和提示用户输入。一个信用卡号码就是一个敏感数据的例子。</p> </li><li> <p>INITIAL_CAPS_WORD：这个标志用来指定在文本编辑的时候，是否把每一个单词的首字母大写。</p> </li><li> <p>INITIAL_CAPS_SENTENCE：这个标志用来指定在文本编辑是否每个句子的首字母大写。</p> </li><li> <p>INITIAL_CAPS_ALL_CHARACTERS：自动把输入的所有字符大写。</p> </li><li> <p>DEFAULT：默认模式，输入字符</p> </li></ol></li><li> <p>InputMode：指定输入模式，</p> 
        <ol><li> <p>ANY：用户可以输入任何文本，包括换行符。</p> </li><li> <p>EMAIL_ADDR：允许用户输入一个电子邮件地址。</p> </li><li> <p>NUMERIC：允许用户输入一个整数值。</p> </li><li> <p>PHONE_NUMBER：允许用户输入一个电话号码。</p> </li><li> <p>URL：允许用户输入一个 URL。</p> </li><li> <p>DECIMAL：允许用户输入一个实数。</p> </li><li> <p>SINGLE_LINE：除了换行符以外，用户可以输入任何文本。</p> </li></ol></li><li> <p>ReturnType：</p> 
        <ol><li> <p>DEFAULT：默认。</p> </li><li> <p>DONE：完成类型。</p> </li><li> <p>SEND：发送类型。</p> </li><li> <p>SEARCH：搜索类型。</p> </li><li> <p>GO：跳转类型。</p> </li><li> <p>NEXT：下一个类型。</p> </li></ol></li><li> <p>MaxLength：输入框最大允许输入的字符个数</p> </li><li> <p>TabIndex：修改DOM输入元素的tabIndex，这个属性只有在web上面修改有意义。</p> </li><li> <p>EditingDidBegan：开始编辑文本输入框触发的事件回调</p> </li><li> <p>TextChanged：编辑文本输入框时触发的事件回调</p> </li><li> <p>EditingDidEnded：结束编辑文本输入框时触发的事件回调，在单行模式下，一般是在用户按下回车或者点击屏幕输入框以外的地方调用该函数。多行输入，在用户点击屏幕输入框以外的地方调用该函数</p> </li><li> <p>EditingReturn：当用户按下回车按键时的事件回调，如果时单行输入框，按回车键还会使输入框失去焦点。</p> </li></ol></li><li> <p>TEXT_LABEL：其实就是个Label控件，只是，隐藏起来了，我们可以拖出来，勾上显示，然后填上内容。就可以看到该Label，同理，也是一样的。PLACEHOLDER_LABEL，这两个Label的样式，就是之后输入文字或者显示文字的样式。<img alt="" height="182" src="https://images2.imgbox.com/b2/2f/zTG7iuYE_o.png" width="724"></p> </li></ol></li><li>Layout：自动对齐布局，主组成：node+UItransform + Layout 
    <ol><li><img alt="" height="78" src="https://images2.imgbox.com/fd/bb/czlcddul_o.png" width="398"></li><li>最基础的组件，只有一个属性，就是用来做对齐的。</li><li>Type 
      <ol><li>NONE：默认布局，不会对子节点进行自动布局</li><li>HORIZONTAL：横向自动排布子节点，可以通过 <code>HorizontalDirection</code> 设置水平朝向。朝向分为 <code>LEFT_TO_RIGHT</code> 和 <code>RIGHT_TO_LEFT</code> 两种，前者会按照节点在 <strong>层级管理器</strong> 中显示顺序从左到右排列；后者会按照节点显示从右到左排列。 
        <ol><li><img alt="" height="310" src="https://images2.imgbox.com/8b/af/W689k61U_o.png" width="382"></li><li>AffectedByScale：子节点缩放比例是否影响布局，感觉上就是，水平方向所有子节点的宽度一致。</li><li>ResizeMode：缩放模式 
          <ol><li>NONE：不会对子节点和容器进行大小缩放</li><li>CONTAINER：对容器的大小进行缩放，就是会根据子节点的大小，改变Layout容器的宽高。</li><li>CHILD：对子节点的大小进行缩放，就是会根据Layout容器的大小，改变子节点的宽高。（好像不起效）</li></ol></li><li>PaddingLeft：Layout节点左边界和子节点的内边距，只有在HorizontalDirection是LEFT_TO_RIGHT起效，就是与起点有关。<img alt="" height="288" src="https://images2.imgbox.com/84/16/wkHS2Mfa_o.png" width="1200"></li><li>PaddingRight：Layout节点右边界和子节点的内边距，只有在HorizontalDirection是RIGHT_TO_LEFT起效，就是与起点有关。<img alt="" height="277" src="https://images2.imgbox.com/66/6d/juYknyV7_o.png" width="1200"></li><li>SpacingX：相邻子节点之间的水平距离，会超出ContentSizeW，超界限方向与下面的HorizontalDirection有关<img alt="" height="404" src="https://images2.imgbox.com/b0/1b/TD0Ys4nJ_o.png" width="1200"></li><li>HorizontalDirection：水平排列子节点的方向。 
          <ol><li>LEFT_TO_RIGHT：从左到右排列<img alt="" height="448" src="https://images2.imgbox.com/b6/47/VAMJ90ad_o.png" width="1200"></li><li>RIGHT_TO_LEFT：从右到左排列<img alt="" height="408" src="https://images2.imgbox.com/b7/3b/if2jGLO3_o.png" width="1200"></li></ol></li><li>AlignHorizontal：自动对齐。在Tpye为Horizontal时自动对齐纵坐标（Y轴），就是子节点的y坐标的中心坐标对齐。<img alt="" height="312" src="https://images2.imgbox.com/83/1d/a7uEAmlv_o.png" width="1200"></li></ol></li><li>VERTICAL：垂直自动排布子节点，跟上面类似，只是方向时垂直的。 
        <ol><li>Type：</li><li>AffectedByScale：子节点缩放比例是否影响布局，感觉上就是，垂直方向所有子节点的高度一致。</li><li>ResizeMode：缩放模式 
          <ol><li>NONE：不会对子节点和容器进行大小缩放</li><li>CONTAINER：对容器的大小进行缩放</li><li>CHILD：对子节点的大小进行缩放</li></ol></li><li>PaddingTop：Layout节点上边界和子节点的内边距</li><li>PaddingBottom：Layout节点下边界和子节点的内边距</li><li>SpacingY：相邻子节点之间的距离</li><li>VerticalDirection：垂直排列子节点的方向，子节点树的顺序对应的显示的顺序 
          <ol><li>TOP_TO_BOTTOM：子节点树由上到下对应由显示上到下排列</li><li>BOTTOM_TO_TOP：子节点树由上到下对应由显示下到上排列</li></ol></li><li>AlignVertical：自动对齐。在Tpye为Vertical时自动对齐横坐标（X），就是子节点的x轴中心坐标对齐。</li></ol></li><li>GRID：网格布局，会在固定容器大小内，根据 <code>HorizontalDirection</code> 和 <code>VerticalDirection</code> 组合决定布局起点，根据 <code>StartAxis</code> 属性决定布局方向。意思就是，这个布局就是综合和上面两种类型Horizontal布局和Vertical布局的特点。根据StartAxis来进行优先级判断。SartAxis选择HORIZONTAL时，优先进行水平布局，当放不下，就进行VERTICAL布局。选择VERTICAL，则反之。 
        <ol><li><img alt="" height="438" src="https://images2.imgbox.com/91/df/JMxPJAu2_o.png" width="379"></li><li>AffectedByScale：子节点缩放比例是否影响布局，感觉上就是，垂直方向所有子节点的高度一致。</li><li>ResizeMode：缩放模式 
          <ol><li>NONE：不会对子节点和容器进行大小缩放</li><li>CONTAINER：对容器的大小进行缩放</li><li>CHILD：对子节点的大小进行缩放</li></ol></li><li>CellSize：网格布局中，规定每一个网格的大小。这个会覆盖子节点本身的大小设置。</li><li>StartAxis：网格布局中，子物体排版时的起始方向轴，支持水平和垂直两个方向。 
          <ol><li>HORIZONTAL：水平方向，优先进行水平布局，当放不下，就进行VERTICAL布局。</li><li>VERTICAL ：垂直方向，优先进行垂直布局，当放不下，就进行HORIZONTAL布局。</li></ol></li><li>PaddingLeft：Layout节点左边界和子节点的内边距</li><li>PaddingTop：Layout节点上边界和子节点的内边距</li><li>PaddingRight：Layout节点右边界和子节点的内边距</li><li>PaddingBottom：Layout节点下边界和子节点的内边距</li><li>SpacingX：X轴水平子节点间距</li><li>SpacingY：Y轴垂直子节点间距</li><li>HorizontalDirection：水平排列子节点的方向，子节点树的顺序对应的显示的顺序</li><li>VerticalDirection：垂直排列子节点的方向，子节点树的顺序对应的显示的顺序</li><li>Constraint：网格布局中，内容布局约束。就是行列数量 
          <ol><li>NONE：无约束</li><li>FIXED_ROW：行数固定<img alt="" height="68" src="https://images2.imgbox.com/33/36/x6LySpcw_o.png" width="398"></li><li>FIXED_COL：列数固定<img alt="" height="66" src="https://images2.imgbox.com/fe/c8/hQVygj99_o.png" width="390"></li></ol></li></ol></li></ol></li></ol></li><li>PageView：页面视图，滚动显示不同的页面，是一种页面视图容器.主组成：node+UItransform + Sprite + PageView，附加一个子节点view，view子节点下还有两个子节点content，indictor。content底下还有三个子节点page1，2，3，组成。 
    <ol><li><img alt="" height="147" src="https://images2.imgbox.com/98/76/dtDijFwu_o.png" width="179"></li><li>整体分析：我们这里只研究PageView，组成：node + UITransform + Sprite + PageView，底下view和indicator子节点。view子节点下还有两个子节点content，indictor。content底下还有三个子节点page1，2，3。所以总结就是一个Mask节点底下加一个Layout布局里面三个Sprinte。</li><li><img alt="" height="572" src="https://images2.imgbox.com/e7/d2/9dj3E2Ae_o.png" width="485"></li><li>Inertia：是否开启滚动惯性</li><li>Brake：开启惯性后，在用户停止触摸后滚动多快停止，0表示永不停止，1表示立刻停止</li><li>Elastic：是否允许滚动内容超过边界，并在停止触摸后回弹</li><li>BounceDuration：回弹持续的时间，0表示将立刻反弹</li><li>SizeMode：页面视图中每个页面大小类型,看不出来有啥区别 
      <ol><li>Unified：统一，就是所有页面的大小类型都一致</li><li>Free：自由，可以不一样大小和类型</li></ol></li><li>Direction：页面滚动方向 
      <ol><li>Horizontal：水平滚动切换页面</li><li>Vertical：垂直滚动切换页面</li></ol></li><li>ScrollThreshold：滚动临界值，默认单位百分比，当拖拽超出该数值时，松开会自动滚动下一页，小于时则还原。就是判断是否切换到下一页。</li><li>PageTurningEventTiming：设置PageView页面自动滚动动画结束的阈值，修改此值可以调整PageView事件的发送时机。</li><li>Indicator：页面视图指示器组件。默认关联到下下级的indicator节点</li><li>AutoPageTruningThreshold：快速滑动翻页临界值，当用户快速滑动时，会根据滑动开始和结束的距离与时间计算出一个速度值，该值与此临界值相比较，如果大于临界值，则进行自动翻页。</li><li>PageTruningSpeed：页面滚动速度</li><li>PageEvents：页面视图的事件回调函数</li><li>content：包含可滚动展示内容的节点引用。默认关联到下下下级的content节点。</li><li>下级子节点： 
      <ol><li>view：视图。主组成：Node + UITransform + Mask ，可以看出来，这就是个遮罩节点。具体看上面Mask分析。 
        <ol><li>view的子节点content，组成：Node + UITransform + Layout，可以看出来就是个Layout 
          <ol><li><img alt="" height="356" src="https://images2.imgbox.com/fd/6b/4sUjTH0o_o.png" width="481"></li><li>content子节点page1，2，3，组成：Node + UITransform + Sprite，可以看出来就是个Sprite 
            <ol><li><img alt="" height="388" src="https://images2.imgbox.com/86/72/73J96fyW_o.png" width="474"></li></ol></li></ol></li></ol></li><li>indicator：指示器，是可选的，该组件是用来显示页面的个数和标记当前显示在哪一页。<img alt="" height="257" src="https://images2.imgbox.com/ee/50/lHzSt5Cw_o.png" width="485"> 
        <ol><li>SpriteFrame：每个页面标记显示的图片<img alt="" height="25" src="https://images2.imgbox.com/af/c1/PGHUEGDZ_o.png" width="128"></li><li>Direction：：页面标记摆放方向 
          <ol><li>Horizontal：页面标记水平排放</li><li>Vertical：页面标记垂直排放</li><li><img alt="" height="185" src="https://images2.imgbox.com/3e/4c/nFaU0LYp_o.png" width="172"></li></ol></li><li>CellSize：页面标记大小</li><li><img alt="" height="59" src="https://images2.imgbox.com/94/b2/lAp7xSDX_o.png" width="242"></li><li>Spacing：页面标记之间的边距</li><li><img alt="" height="59" src="https://images2.imgbox.com/4b/05/LmAKa9c1_o.png" width="242"></li></ol></li></ol></li></ol></li><li>ProgressBar：进度条，主组成Node + UITransform + Sprite + ProgressBar，而ProgressBar有个子节点Bar，Bar节点组成：Node + UITransform + Sprite，这里可以看出来就是两个Sprite节点，其中一个有一个ProgressBar组件。所以我们只看ProgressBar组件。 
    <ol><li><img alt="" height="348" src="https://images2.imgbox.com/69/c1/7msteYXn_o.png" width="482"></li><li>BarSprite：进度条显示用的Sprite节点，可以动态改变尺寸</li><li>Mode：进度条显示模式 
      <ol><li>HORIZONTAL：水平方向模式，正常方向为左为0，最右面为顶1.</li><li>VERTICAL：垂直方向模式，正常方向为下为0，最上面为顶1.</li><li>FILLED：扇形填充模式，360°圆形，类似技能cd</li></ol></li><li>TotalLength：进度条在progress为1时的最大长度。</li><li>Progress：当前进度指示，范围从0到1，0表示起点，1表示终点</li><li>Reverse：是否反向驱动进度条，类似于卸载的进度条，往后退。</li></ol></li><li>RichText：富文本，有样式的文本框，组成：Node + UITransform + RichText 组成。我们只看RichText组件。 
    <ol><li><img alt="" height="480" src="https://images2.imgbox.com/a6/7b/JPnxnPJx_o.png" width="1200"></li><li>String：富文本的内容字符串，你可以在里面使用BBCode来指定特定文本的样式。类似&lt;color=#00ff00&gt;Rich&lt;/color&gt;</li><li>UseSystemFont：是否使用系统字体</li><li>FontFamily：富文本定制系统字体<img alt="" height="34" src="https://images2.imgbox.com/32/e1/A1sjActX_o.png" width="481"></li><li>CacheMode：字体缓存模式 
      <ol><li>NONE：默认值，对富文本所拆分创建的每个 Label 节点，设置其 CacheMode 为 NONE 类型，即将每个 Label 的整段文本生成一张位图并单独进行渲染。</li><li>BITMAP：对富文本所拆分创建的每个 Label 节点，设置其 CacheMode 为 BITMAP 类型，即将每个 Label 的整段文本生成一张位图，并将该位图添加到动态图集中，再依据动态图集进行合并渲染。</li><li>CHAR：对富文本所拆分创建的每个 Label 节点，设置其 CacheMode 为 CHAR 类型，即将每个 Label 的文本以“字”为单位缓存到全局共享的位图中，相同字体样式和字号的每个字符将在全局共享一份缓存。</li></ol></li><li>HorizontalAlign：水平对齐方式。也就是说，富文本只有水平对齐，没有垂直对齐。 
      <ol><li>RIGHT：内容相对于锚点，进行右对齐</li><li>CENTER：内容相对于锚点，进行剧中对齐</li><li>LEFT：内容相对于锚点，进行左对齐</li></ol></li><li>FontSize：字体大小，单位point</li><li>MaxWidth：富文本的最大宽度，穿0的话以为着必须手动换行。这不能自动设置换行？</li><li>LineHeight：行高度，单位point，不能设置小于字体，否则字体会压缩</li><li>ImageAtlas：对于img标签里面的src属性名称，都需要在imageAtlas里面找到一个有效的spriteFrame，否则imgtag会判断为无效。</li><li>HandleTouchEvent：选中此选项后，RichText将阻止节点边界框中的所有输入事件（鼠标和触摸），从而防止输入事件穿透到底层节点。不允许冒泡</li></ol></li><li>ScrollView：滚动视图，组成：Node + UITransform + Mask + ScrollView 附加两个子节点scrollBar，view，scrollBar里面有个子节点bar，view有子节点content，content有子节点item。 
    <ol><li><img alt="" height="474" src="https://images2.imgbox.com/99/61/Cxgh05Ny_o.png" width="481"></li><li>子节点有点多，我们先分析拆解看。 
      <ol><li>从最里面看到最外层。</li><li>item组成：Node + UITransform + Label ，所以就是个Label<img alt="" height="151" src="https://images2.imgbox.com/74/1c/zC88z3LC_o.png" width="483"></li><li>content组成：Node + UITransform ，所以就是个有固定大小的Node<img alt="" height="115" src="https://images2.imgbox.com/d2/75/c1fY0qsT_o.png" width="489"></li><li>view组成：Node + UITransform + Mask，所以就是个mask<img alt="" height="151" src="https://images2.imgbox.com/ce/46/wXHvIxwg_o.png" width="488"></li><li>bar组成：Node + UITransform + Sprite，所以就是个sprite<img alt="" height="147" src="https://images2.imgbox.com/8b/db/d3LWtdGj_o.png" width="478"></li><li>scrollBar组成：Node + UITransform + Sprite + Widget + ScrollBar，这里就只分析ScrollBar就可以了。<img alt="" height="360" src="https://images2.imgbox.com/d7/9e/bCZm5tIQ_o.png" width="480"> 
        <ol><li>Handle：作为当前滚动区域位置显示的滑块Sprite，绑定到子节点bar</li><li>Direction：ScrollBar的滚动方向 
          <ol><li>HORIZONTAL：水平反向的滚动</li><li>VERTICAL：垂直方向的滚动，没有两个方向的滚动？</li></ol></li><li>EnableAutoHide：是否在没有滚动动作时自动隐藏ScrollBar</li><li>AutoHideTime：没有滚动动作后经过多久会自动隐藏，注意：只有EnableAutoHide 启用的时候生效。</li></ol></li><li>ScrollView，滚动条，图片见上面主项 
        <ol><li>Horizontal：开启水平滚动条。这个开启有点难配置，要创建一个类似socllBar的子节点。就是把原本的socllBar复制一份，然后需要修改相应socllBar的位置值宽高和里面的bar的位置宽高。开启后，需要把socllBar与新出来的属性HorizontalScrollBar绑定。目前调节后有bug，水平滑块没法设置到最前面。<img alt="" height="544" src="https://images2.imgbox.com/0a/51/YMbLncpP_o.png" width="1200"></li><li>Vertical：垂直滚动条。类似上面。不过编辑器默认就是垂直滚动条。弹出的VerticalScrollBar绑定垂直的Bar。</li><li>Inertia：是否开启滚动惯性</li><li>Brake：开启惯性后，在用户停止触摸后滚动多快停止，0表示永不停止，1表示立刻停止</li><li>Elastic：是否允许滚动内容超过边界，并在停止触摸后回弹</li><li>BounceDuration：回弹持续的时间，0表示将立刻反弹</li><li>Content：包含可滚动展示内容的节点引用</li><li>CancelInnerEvents：滚动行为是否会取消子节点上注册的触摸事件。防止冒泡？</li><li>ScrollEvents：滚动视图的事件回调函数。 <p></p> </li></ol></li></ol></li></ol></li><li>Slider：滑动器，组成：Node + UITransform + Sprite + Slider ，附加子节点Handle 
    <ol><li><img alt="" height="446" src="https://images2.imgbox.com/67/97/CB8qQXfy_o.png" width="1200"></li><li>先分析子节点Handle，组成：Node + UITransform + Sprite + Button，所以这是个带了图片的按钮节点。</li><li>回来看Slider属性</li><li>Handle：滑块按钮部件，绑定子节点Handle</li><li>Direction：滑动方向 
      <ol><li>Horizontal：水平方向</li><li>Vertical：垂直方向</li></ol></li><li>Progress：当前进度值，该数值的区间时0-1之间</li><li>SlideEvents：滑动器组件事件回调函数</li></ol></li><li>Toggle：复选按钮，组成：Node + UITransform + Sprite + Toggle，附带子节点Checkmark 
    <ol><li><img alt="" height="429" src="https://images2.imgbox.com/4d/70/kj1qPeid_o.png" width="1200"></li><li>我们先从小到大</li><li>Checkmark，组成：Node + UITransform + Sprite ，看起来就是个sprite<img alt="" height="147" src="https://images2.imgbox.com/68/7d/X9NTFNTX_o.png" width="494"></li><li>再回来看Toggle 
      <ol><li><img alt="" height="427" src="https://images2.imgbox.com/30/dc/UenUvV8U_o.png" width="479"></li><li>Target：指定背景节点，状态改变时会修改此节点的Color或Sprite属性。这里改变的是自己，所以绑定的是自己</li><li>Interactable：按钮是否可交互，这一项未选中时，按钮处于禁用状态。也就是不开启这个，没法选中勾上</li><li>IsChecked：如果设置这个为true，则check mark 组件会处于enabled状态，否则处于disabled状态。</li><li>CheckMark：Toggle处于选中状态时显示的sprite图片，绑定的是子节点的Checkmark。</li><li>Transition：按钮状态变化时的过度类型 
        <ol><li>NONE：没有过渡效果</li><li>COLOR：颜色过渡，不同状态使用不同的背景颜色 
          <ol><li>NormalColor：普通状态的按钮背景颜色</li><li>PressedColor：按下状态的按钮背景颜色</li><li>HoverColor：悬停状态的按钮背景颜色</li><li>DIsabledColor：禁用状态的按钮背景颜色</li></ol></li><li>SPRITE：图片过渡，不同状态使用不同的背景图片 
          <ol><li>NormalSprite：普通状态的按钮背景图片资源</li><li>PressedSprite：按下状态的按钮背景图片资源</li><li>HoverSprite：悬停状态的按钮背景图片资源</li><li>DIsabledSprite：禁用状态的按钮背景图片资源</li></ol></li><li>SCALE：缩放过渡，当按钮按下时，出现缩放效果 
          <ol><li>Duration：按钮颜色变化或者缩放变化的过度时间</li><li>ZoomScale：当用户点击按钮后，按钮会缩放到一个值，这个值等于Button原始Scale * ZoomScale，zoomscale可以是负数。</li></ol></li></ol></li><li>CheckEvents：Toggle按钮的点击事件列表</li><li>ClickEvents：按钮点击事件的列表，先将数量改为1或更多，就可以为每个点击事件设置接收者和处理方法。</li></ol></li></ol></li><li>ToggleGroup：单选按钮，组成：Node + ToggleContainer ，附加节点3个（默认）Toggle 
    <ol><li><img alt="" height="375" src="https://images2.imgbox.com/3b/0b/hpDHFkE0_o.png" width="1200"></li><li>Toggle分析看上面。所以我们只需要看ToggleGroup就可以</li><li>AllowSwitchOff：如果这个设置为true，那么toggle按钮在被点击的时候可以反复地被选中和未选中。就是可以取消选中的意思，可以全都不选。</li><li>CheckEvents：Toggle按钮的点击事件列表</li></ol></li><li>VideoPlayer：播放器，组成：Node + UITransform + VideoPlayer 
    <ol><li><img alt="" height="528" src="https://images2.imgbox.com/09/48/g4seheZD_o.png" width="1200"></li><li>ResourceType：视频来源 
      <ol><li>REMOTE：远程视频URL 
        <ol><li>RemoteURL：远程视频的URL</li></ol></li><li>LOCAL：本地视频地址 
        <ol><li>Clip：本地视频剪辑</li></ol></li></ol></li><li>PlayOnAwake：视频加载后是否自动开始播放</li><li>PlaybackRate：视频播放时的速率（0.0到10.0）</li><li>Volume：视频的音量（0.0到1.0）</li><li>Mute：视频是否静音，静音时会自动设置音量为0，取消静音是恢复原来的音量</li><li>Loop：视频是否循环播放</li><li>KeepAspectRation：是否保持视频原来的宽高比</li><li>FullScreenOnAwake：是否全屏播放视频</li><li>StayOnBotton：永远在游戏视图最低层（这个属性只有在web平台上有效果。注意：具体效果没法保证一致，跟各个浏览器是否支持与限制有关。</li><li>VideoPlayerEvent：视频播放回调函数，该回调函数会在特定情况被触发，比如播放中，暂时，停止和完成播放。</li></ol></li><li>WebVIew：网页视图，打开一个网页，在web端，点击页面的超链接，会变成新tab打开有点bug，组成：Node + UITransform + WebView 
    <ol><li><img alt="" height="360" src="https://images2.imgbox.com/86/f8/yryffzkb_o.png" width="1170"></li><li>只需要分析WebView</li><li>Url：指定一个URL地址，这个地址以http或者https开头，请填写一个有效的URL地址。</li><li>WebviewEvents：Webview的回调事件，当网页加载过程中，加载完成后或者加载出错时都会回调此函数。</li></ol></li><li>Widget：对齐，(对齐挂件) 是一个很常用的 UI 布局组件。它能使当前节点自动对齐到父物体的任意位置，或者约束尺寸，让你的游戏可以方便地适配不同的分辨率。具体分析见上面，已经分析过了。<img alt="" height="334" src="https://images2.imgbox.com/43/71/DPABYa5H_o.png" width="477"></li></ol><p></p> </li><li> <h3 id="%E5%85%89%E7%BA%BF">光线</h3> 
  <ol><li>注意：只有在3D模式下，看到具体效果</li><li>DirectionalLight：平行光，类似太阳光。平行照射，3D的默认光线就是平行光。        组成：Node + DirectionalLight。 
    <ol><li><img alt="" height="492" src="https://images2.imgbox.com/53/b6/JMtfNyMd_o.png" width="1200"></li><li>Color：光源颜色。就是照射到物体上面反射出来的颜色。</li><li>UseColorTemperature：是否启用光源色温。</li><li>ColorTemperature：光源色温。（1000到15000）</li><li>StaticSettings：设置静态灯光，详情请参考 <a href="https://docs.cocos.com/creator/3.2/manual/zh/concepts/scene/light/lightmap.html" rel="nofollow">光照贴图</a> 
      <ol><li>EditorOnly：是否只在编辑器中生效</li><li>Bakeable：是否烘焙静态光照</li><li>CastShadow：是否投射静态阴影</li></ol></li><li>Illuminance：光源强度。</li></ol></li><li>SphereLight：球面光，就是电灯泡的灯光，组成：Node + SphereLight 
    <ol><li><img alt="" height="472" src="https://images2.imgbox.com/c2/33/LkQXUgAY_o.png" width="1200"></li><li>Trem：当前使用的广度学计量单位 
      <ol><li>LUMINOUS_POWER：发光功率</li><li>LUMINANCE：亮度</li></ol></li><li>LuminousPower：光通量</li><li>Color：光源颜色。就是照射到物体上面反射出来的颜色。</li><li>UseColorTemperature：是否启用光源色温。</li><li>ColorTemperature：光源色温。（1000到15000）</li><li>Size：光源大小，就是灯泡的大小</li><li>Range：光源的照射范围。就是灯光照射远近</li><li>StaticSettings：设置静态灯光，详情请参考 <a href="https://docs.cocos.com/creator/3.2/manual/zh/concepts/scene/light/lightmap.html" rel="nofollow">光照贴图</a> 
      <ol><li>EditorOnly：是否只在编辑器中生效</li><li>Bakeable：是否烘焙静态光照</li><li>CastShadow：是否投射静态阴影</li></ol></li></ol></li><li>SpotLight：聚光，就是舞台聚光灯效果。组成：Node + SpotLight 
    <ol><li><img alt="" height="503" src="https://images2.imgbox.com/74/0c/knvD1H0m_o.png" width="1200"></li><li>Trem：当前使用的广度学计量单位 
      <ol><li>LUMINOUS_POWER：发光功率</li><li>LUMINANCE：亮度</li></ol></li><li>LuminousPower：光通量</li><li>Color：光源颜色。就是照射到物体上面反射出来的颜色。</li><li>UseColorTemperature：是否启用光源色温。</li><li>ColorTemperature：光源色温。（1000到15000）</li><li>Size：光源大小，就是灯泡的大小</li><li>Range：光源的照射范围。就是灯光照射远近</li><li>SpotAngle：调整聚光角度，控制光照范围，就是控制照射光圈的大小范围<img alt="" height="480" src="https://images2.imgbox.com/85/80/GIXYxNHE_o.png" width="1200"></li><li>StaticSettings：设置静态灯光，详情请参考 <a href="https://docs.cocos.com/creator/3.2/manual/zh/concepts/scene/light/lightmap.html" rel="nofollow">光照贴图</a> 
      <ol><li>EditorOnly：是否只在编辑器中生效</li><li>Bakeable：是否烘焙静态光照</li><li>CastShadow：是否投射静态阴影</li></ol></li></ol></li></ol></li><li> <h3 id="%E7%89%B9%E6%95%88">特效</h3> 
  <ol><li>粒子特效（3D），虽然2D下也能看到，但是2D有另外得一个粒子可以使用，所以这里一般用于3D。而且并不用跟2D一样放置在Canvas下。 
    <ol><li><img alt="" height="536" src="https://images2.imgbox.com/13/1d/U7GEqmx9_o.png" width="1200"></li><li>组成：Node + ParticleSystem</li><li><img alt="" height="863" src="https://images2.imgbox.com/ef/b5/mOCCYSzk_o.png" width="450"></li><li><img alt="" height="366" src="https://images2.imgbox.com/98/8c/RJFtz3Yc_o.png" width="449"></li><li>Duration：粒子系统运行时间</li><li>Capacity：粒子系统能生成得最大粒子数量</li><li>Loop：粒子系统是否循环播放</li><li>PlayOnAwake：加载后自动播放</li><li>Prewarm：选中后，粒子系统会以播放完一轮之后得状态开始播放（仅当循环播放启用时有效）</li><li>SimulationSpace：选择粒子系统所在得坐标系 
      <ol><li>World：世界坐标</li><li>Local：本地坐标</li><li>Custom：自定义坐标</li></ol></li><li>SimulationSpeed：控制整个粒子系统得更新速度</li><li>StartDelay：粒子系统开始运行后，延迟粒子发射得时间</li><li>StartLifeTime：粒子生命周期，粒子发射出来到消失得时间</li><li>StartColor：粒子发射出来时得颜色</li><li>ScaleSpace：选择缩放坐标系 
      <ol><li><strong>Local</strong>：基于本地坐标系的缩放</li><li><strong>World</strong>：基于世界坐标系的缩放</li><li><strong>Custom</strong>：自定义缩放，不受节点 <strong>scale</strong> 影响</li></ol></li><li>StartSize3D：是否分别设置粒子X,Y和Z轴得初始大小</li><li>StartSize：X轴初始大小</li><li>StartSpeed：初始速度</li><li>StartRotation3D：是否分别设置粒子X,Y和Z轴得初始旋转角度</li><li>StartRotation：Z轴初始旋转角度</li><li>GravityModifier：粒子受重力影响得重力系数（只支持CPU粒子）</li><li>RateOverTime：每秒发射得粒子数</li><li>RateOverDistance：每移动单位距离发射得粒子数</li><li>Bursts：设定在指定时间发射指定数量得粒子得burst得数量，设置为1后能看到具体设置得可以调整得属性 
      <ol><li><img alt="" height="210" src="https://images2.imgbox.com/28/92/TdmYob5p_o.png" width="484"></li><li><strong>time</strong>：粒子播放多长时候后开始发射 burst</li><li><strong>count</strong>：发射的粒子数量</li><li><strong>repeatCount</strong>：burst触发次数</li><li><strong>repeatInterval</strong>：每次触发的时间间隔</li></ol></li><li>EnableCulling：是否剔除非enable得模块数据</li><li>SpapeModule：粒子发射器模块 <p></p> 
      <ol><li><img alt="" height="524" src="https://images2.imgbox.com/22/0a/NkSqGtZB_o.png" width="705"></li><li>ShapeType：粒子发射器类型 
        <ol><li>Box：长方体盒子模型 
          <ol><li>EmitFrom：粒子从方块的哪个部位发射。 
            <ol><li><strong>Edge</strong>：边框</li><li><strong>Shell</strong>：表面</li><li><strong>Volume</strong>：内部</li></ol></li></ol></li><li>Circle：圆形 
          <ol><li>Radius：粒子发射器半径</li><li>RadiusThickneww：粒子发射器发射位置（对Box类型的发射器无效）0表示表面发射，1表示从中心发射，0到1之间表示在中心到表面发射。</li><li>Arc：粒子发射器在一个扇形范围内发射</li><li>ArcMode：粒子在扇形范围内的发射方式 
            <ol><li>Random</li><li>Loop</li><li>PingPong</li></ol></li><li>ArcSpread：控制可能产生粒子的弧周围的离散间隔</li><li>ArcSpeed：粒子沿圆周发射的速度</li></ol></li><li>Cone：倒锥体，倒圆柱 
          <ol><li>EmitFrom：粒子从方块的哪个部位发射。 
            <ol><li><strong>Edge</strong>：边框</li><li><strong>Shell</strong>：表面</li><li><strong>Volume</strong>：内部</li></ol></li><li>Radius：粒子发射器半径</li><li>RadiusThickneww：粒子发射器发射位置（对Box类型的发射器无效）0表示表面发射，1表示从中心发射，0到1之间表示在中心到表面发射。</li><li>Angle：圆锥的轴与母线的夹角，决定圆锥发射器的开合程度。</li><li>Arc：粒子发射器在一个扇形范围内发射</li><li>ArcMode：粒子在扇形范围内的发射方式 
            <ol><li>Random</li><li>Loop</li><li>PingPong</li></ol></li><li>ArcSpread：控制可能产生粒子的弧周围的离散间隔</li><li>ArcSpeed：粒子沿圆周发射的速度</li><li>Length：圆锥顶部截面距离底部的轴长，决定圆锥发射器的高度。</li></ol></li><li>Sphere：球体 
          <ol><li>EmitFrom：粒子从方块的哪个部位发射。 
            <ol><li><strong>Shell</strong>：表面</li><li><strong>Volume</strong>：内部</li></ol></li><li>Radius：粒子发射器半径</li><li>RadiusThickneww：粒子发射器发射位置（对Box类型的发射器无效）0表示表面发射，1表示从中心发射，0到1之间表示在中心到表面发射。</li></ol></li><li>Hemisphere：半球体，默认底下是平面 
          <ol><li>EmitFrom：粒子从方块的哪个部位发射。 
            <ol><li><strong>Shell</strong>：表面</li><li><strong>Volume</strong>：内部</li></ol></li><li>Radius：粒子发射器半径</li><li>RadiusThickneww：粒子发射器发射位置（对Box类型的发射器无效）0表示表面发射，1表示从中心发射，0到1之间表示在中心到表面发射。</li></ol></li></ol></li><li>Position：粒子发射器位置</li><li>Rotation：粒子发射器旋转角度</li><li>Scale：粒子发射器缩放比例</li><li>AlignToDirection：根据粒子的初始方向决定粒子的移动方向</li><li>RandomDirectionAmount：粒子生成方向随机设定</li><li>SphericalDirectionAmount：表示当前发射方向与当前位置到节点中心连线方向的插值</li><li>RandomPositionAmount：粒子生成位置随机设定（设定此值为非0会使粒子生成位置超出生成器大小范围）。</li></ol></li><li>VelocityOvertimeModule：速度模块 <p></p> 
      <ol><li><img alt="" height="173" src="https://images2.imgbox.com/a9/6f/42nVEyvr_o.png" width="698"></li><li>X：X轴方向上的速度分量</li><li>Y：Y轴方向上的速度分量</li><li>Z：Z轴方向上的速度分量</li><li>SpeedModifier：速度修正系数（只支持CPU粒子）</li><li>Space：速度计算时采用的坐标系 
        <ol><li>World：世界坐标</li><li>Local：本地坐标</li><li>Custom：自定义坐标</li></ol></li></ol></li><li>ForceOvertimeModule：加速模块 <p></p> 
      <ol><li><img alt="" height="153" src="https://images2.imgbox.com/9d/47/lsu1aZDO_o.png" width="706"></li><li>X：X轴方向上的加速度分量</li><li>Y：Y轴方向上的加速度分量</li><li>Z：Z轴方向上的加速度分量</li><li>Space：加速度计算时采用的坐标系 
        <ol><li>World：世界坐标</li><li>Local：本地坐标</li><li>Custom：自定义坐标</li></ol></li></ol></li><li>SizeOvertimeModule：大小模块 
      <ol><li><img alt="" height="93" src="https://images2.imgbox.com/75/c8/4gCF89j4_o.png" width="705"></li><li>SeparateAxes：是否分开设定每个轴上独立控制粒子大小</li><li>Size：定义一条曲线来决定粒子在其生命周期中的大小变化</li></ol></li><li>RotationOvertimeModule：旋转模块 
      <ol><li><img alt="" height="105" src="https://images2.imgbox.com/13/86/WIRyaEgX_o.png" width="706"></li><li>SeparateAxes：是否分开设定每个轴上独立旋转</li><li>Z：绕Z轴设定旋转</li></ol></li><li>ColorOverLifetimeModule：颜色模块 
      <ol><li><img alt="" height="65" src="https://images2.imgbox.com/06/5d/BWSBhLtd_o.png" width="706"></li><li>Color：颜色随时间变化的参数，可采用不同的颜色变化模式</li></ol></li><li>TextureAnimationModule：贴图动画模块 
      <ol><li><img alt="" height="294" src="https://images2.imgbox.com/03/94/SkVCXlrp_o.png" width="704"></li><li>Mode：设定粒子贴图动画的类型（暂只支持Grid模式）</li><li>NumTitlesX：X方向动画帧数</li><li>NumTitlesY：Y方向动画帧数</li><li>Animation：动画播放方式 
        <ol><li>WholeSheet：播放贴图中的所有帧</li><li>SingleRow：只播放其中一行</li></ol></li><li>FrameOverTime：一个周期内动画播放的帧与时间变化曲线</li><li>StartFrame：从第几帧开始播放，时间为整个粒子系统的生命周期</li><li>CycleCount：一个生命周期内播放循环的次数</li><li>RandomRow：随机从动画贴图中选择一行以生成动画，此选项仅在动画播放方式为SingleRow时生效</li><li>RowIndex：从动画贴图中选择行以生成动画，此选项仅在动画播放方式为SingleRow时且禁用randomRow时可用。</li></ol></li><li>LimitVelocityOvertimeModule：限速模块 <p></p> 
      <ol><li><img alt="" height="151" src="https://images2.imgbox.com/34/3d/glRSB8kX_o.png" width="705"></li><li>Space：计算速度下限时采用的坐标系</li><li>Dampen：当前速度与速度下限的插值</li><li>SeparateAxes：是否三个轴分开限制</li><li>Limit：速度下限。当选择了SeparateAxes，这里会分成三个LimitX,limitY,limitZ</li></ol></li><li>TrailModule：拖尾模块 
      <ol><li><img alt="" height="328" src="https://images2.imgbox.com/12/27/FcuMz2Bd_o.png" width="708"></li><li>Mode：Particle在每个粒子的运动轨迹上形成拖尾效果</li><li>LifeTime：拖尾的生命周期</li><li>MinParticleDistance：粒子每生成一个拖尾节点所允许的最短距离</li><li>Space：拖尾所在的坐标系 
        <ol><li>World：在世界坐标系中运行</li><li>Local：在本地坐标系中运行</li><li>Custom：自定义坐标系</li></ol></li><li>TextureMode：贴图在拖尾上的展开形式（目前只有Stretch） 
        <ol><li>Stretch：贴图覆盖在整条拖尾上</li><li>Repeat：贴图覆盖在一段拖尾上</li></ol></li><li>WidthFromParticle：拖尾宽度继承自粒子大小</li><li>WidthRation：拖尾宽度，如果继承自粒子则是粒子大小的比例</li><li>ColorFromParticle：拖尾颜色是否继承自粒子</li><li>ColorOverTrail：拖尾颜色随拖尾自身长度的颜色渐变</li><li>ColorOvertime：拖尾颜色随时间的颜色渐变</li></ol></li><li>Renderer：渲染模块 
      <ol><li><img alt="" height="260" src="https://images2.imgbox.com/ff/a6/PQXZKujN_o.png" width="707"></li><li>RenderMode：设定粒子生成模式</li><li>VelocityScale：在粒子生成StrecthBillboard时，对粒子在运动方向上按速度大小进行拉伸</li><li>LengthScale：在粒子生成方式为StrecthedBillboard时，对粒子在运动方向上按粒子大小进行拉伸。</li><li>Mesh：粒子发射的模型</li><li>ParticleMaterial：粒子使用的材质</li><li>TrailMaterial：拖尾使用的材质</li><li>UseGPU：是否启用GPU粒子</li></ol></li></ol></li></ol></li><li> <h3 id="%E6%91%84%E5%83%8F%E6%9C%BA">摄像机</h3> 
  <ol><li><img alt="" height="822" src="https://images2.imgbox.com/cf/30/a5nhIixN_o.png" width="680"></li><li><img alt="" height="235" src="https://images2.imgbox.com/4f/a9/pTb2nU9p_o.png" width="441"></li><li>如图，上面是2D和3D相机</li><li>属性项是一样得，其中基本节点属性，我们就不研究了，我们先看Camera属性 <p></p> <p></p> 
    <ol><li>Priority：相机渲染优先级，值越小越优先渲染。</li><li>Visibility：可见性集合掩码，代表该相机可以看到哪些层得集合。可以在项目得layer中配置，这里只能看到UI_3D,UI_2D。</li><li><img alt="" height="284" src="https://images2.imgbox.com/c5/6b/I5e7enIx_o.png" width="366"></li><li>ClearFlags：相机的缓冲清除标志位，指定帧缓冲的哪部分要每帧清除</li><li>ClearColor：相机的颜色缓冲默认值</li><li>ClearDepth：相机的深度缓冲默认值</li><li>ClearStencil：相机的模板缓冲默认值</li><li>Projection：相机的投影类型</li><li>FovAxis：指定视角的固定轴向，在此轴上不会跟随屏幕长宽比例变化</li><li>Fov：相机的视角大小</li><li>OrthoHeight：正交模式下的相机视角高度</li><li>Near：相机的近1裁剪距离，应在可接受范围内尽量取最大</li><li>Far：相机的远裁剪距离，应在可接受范围内尽量取最小</li><li>Aperture：相机光圈，影响相机的曝光参数</li><li>Shutter：相机快门，影响相机的曝光参数</li><li>Iso：相机感光度，影响相机的曝光参数</li><li>Rect：此相机最终渲染到屏幕上的视口位置和大小</li><li>TargetTexture：指定此相机的渲染输出贴图，默认为空，直接渲染到屏幕。</li></ol></li></ol></li><li> <h3 id="%E5%9C%B0%E5%BD%A2">地形</h3> </li></ol>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/383fafb131b1bc7980893c772b347c03/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VSCode找不到头文件，配置头文件的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/892f798c6ca35ddaf6d8ecee26bf947c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">服务器 u盘制作系统盘,制作U盘系统盘(WinToFlash)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>