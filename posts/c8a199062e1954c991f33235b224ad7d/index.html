<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java】死锁 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Java】死锁" />
<meta property="og:description" content="一、什么是死锁 死锁指多个线程在执行过程中，因争夺资源造成的一种相互等待的僵局。
进程死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。线程死锁是指由于两个或者两个以上的线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。 二、死锁的必要条件 互斥条件：同一资源同时只能由一个线程读取不可抢占条件：不能强行剥夺线程占有的资源请求和保持条件：请求其他资源的同时对自己手中的资源保持不放循环等待条件：在相互等待资源的过程中，形成一个闭环 三、预防死锁 想要预防死锁，只需要破坏其中一个条件即可，比如使用定时锁、尽量让线程用相同的加锁顺序，还可以用银行家算法，即可解决死锁问题；
破坏互斥条件和不剥夺条件，对sychronized来说，是JVM底层设定的，每个对象都有一个monitor（监视器），在同步操作中，一个线程（或进程）持有一个对象的monitor后，有monitorenter操作，同步方法结束或异常时，有monitorexit操作。所以我们是破坏不了这个2个条件的；如果不是sychronized，如通过Lock完成的互斥条件和不剥夺条件，就可以更改；破坏请求和保持条件，常见的操作有：加锁顺序（指定加锁的顺序或者线程执行的顺序）、加锁时限（对加锁的对象增加超时限制，避免一直占用）；破坏环路等待条件：死锁检测：多线程对期望持有的锁对象不能形成相互(环状)依赖的情况。 如，上述死锁代码中：
线程01持有对象A后，去请求持有对象B；
线程02持有对象B后，去请求持有对象A，-------多线程持有的对象A、B是相互依赖的；造成死锁；
如果是这样，线程01持有对象A后，去请求持有对象B；
线程02持有对象B后，去请求持有对象C， ------------A、B、C之间没有相互依赖，不会死锁；
补充 银行家算法 银行家算法是操作系统的经典算法之一，用于避免死锁情况的出现。
它最初是为银行设计的（因此得名），通过判断借贷是否安全，然后决定借不借。
在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。
用在操作系统中，银行家、出借资金、客户，就分别对应操作系统、资源、申请资源的进程。
每一个新进程进入系统时，必须声明需要每种资源的最大数目，其数目不能超过系统所拥有的的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程，若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态如果不会才将资源分配给它，否则让进程等待。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c8a199062e1954c991f33235b224ad7d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-17T01:02:16+08:00" />
<meta property="article:modified_time" content="2023-02-17T01:02:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java】死锁</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>一、什么是死锁</h3> 
<p><strong>死锁指多个线程在执行过程中，因争夺资源造成的一种相互等待的僵局。</strong></p> 
<ul><li>进程死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</li><li>线程死锁是指由于两个或者两个以上的线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。</li></ul> 
<h3><a id="_7"></a>二、死锁的必要条件</h3> 
<ul><li>互斥条件：同一资源同时只能由一个线程读取</li><li>不可抢占条件：不能强行剥夺线程占有的资源</li><li>请求和保持条件：请求其他资源的同时对自己手中的资源保持不放</li><li>循环等待条件：在相互等待资源的过程中，形成一个闭环</li></ul> 
<h3><a id="_14"></a>三、预防死锁</h3> 
<p>想要预防死锁，只需要破坏其中一个条件即可，比如使用<strong>定时锁</strong>、尽量让线程用相同的加锁顺序，还可以用<strong>银行家算法</strong>，即可解决死锁问题；</p> 
<ol><li>破坏互斥条件和不剥夺条件，对<code>sychronized</code>来说，是<code>JVM</code>底层设定的，每个对象都有一个<code>monitor</code>（监视器），在同步操作中，一个线程（或进程）持有一个对象的<code>monitor</code>后，有<code>monitorenter</code>操作，同步方法结束或异常时，有<code>monitorexit</code>操作。所以我们是破坏不了这个2个条件的；如果不是<code>sychronized</code>，如通过<code>Lock</code>完成的互斥条件和不剥夺条件，就可以更改；</li><li>破坏请求和保持条件，常见的操作有：加锁顺序（指定加锁的顺序或者线程执行的顺序）、加锁时限（对加锁的对象增加超时限制，避免一直占用）；</li><li>破坏环路等待条件：死锁检测：多线程对期望持有的锁对象不能形成相互(环状)依赖的情况。</li></ol> 
<p>如，上述死锁代码中：</p> 
<blockquote> 
 <p>线程01持有对象A后，去请求持有对象B；</p> 
 <p>线程02持有对象B后，去请求持有对象A，-------多线程持有的对象A、B是相互依赖的；造成死锁；</p> 
 <p>如果是这样，线程01持有对象A后，去请求持有对象B；</p> 
 <p>线程02持有对象B后，去请求持有对象C， ------------A、B、C之间没有相互依赖，不会死锁；</p> 
</blockquote> 
<h3><a id="_33"></a>补充</h3> 
<h4><a id="_34"></a>银行家算法</h4> 
<blockquote> 
 <p>银行家算法是操作系统的经典算法之一，用于避免死锁情况的出现。<br> 它最初是为银行设计的（因此得名），通过判断借贷是否安全，然后决定借不借。<br> 在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。<br> 用在操作系统中，银行家、出借资金、客户，就分别对应操作系统、资源、申请资源的进程。<br> 每一个新进程进入系统时，必须声明需要每种资源的最大数目，其数目不能超过系统所拥有的的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程，若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态如果不会才将资源分配给它，否则让进程等待。</p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f1d6a6d699ed251334ace757adeba246/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Axios异步请求 &amp; json格式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a38e20e4f5b3b2c21fb5a24b98449b2d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js之闭包（通俗、易懂）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>