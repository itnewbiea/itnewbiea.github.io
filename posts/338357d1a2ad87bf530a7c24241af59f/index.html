<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>k8s---pod的生命周期 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="k8s---pod的生命周期" />
<meta property="og:description" content="pod的相关知识 pod是k8s中最小的资源管理组件
pod也是最小化运行容器化的应用的资源管理对象
pod是一个抽象的概念，可以理解为一个或者多个容器化应用的集合。
k8s中pod的两种使用方式 （1）一个pod中运行一个容器。&#34;每个po中一个容器&#34;的模式是最常见的用法:在这种使用方式中，你可以把pod想象成是单个容器的封装，kterentes管理的是Pod而不是直接管理容器。
（2）在一个Pod中同时运行多个容器。一个Pod中也可以同时封装几个需要紧密耦合互相协作的容器，它们之间共享资源。这些在同一个Pod中的容器可以互相协作成为一个servie单位。
这些多个容器共享资源，也可以互相协作组成一个service单位。
不论运行一个容器还是多个容器，k8s管理的都是pod不是容器。
一个pod内的多个容器，必须都运行在一个节点上。基于现在容器技术的要求，一个pod运行一个容器，一个容器只运行一个进程。这样做是为了：横向扩展，方便扩缩容。解耦。一个pod内会运行多个容器，耦合度太高，导致整个集群全部失败。实现解耦，基于pod可以创建多个副本，实现高可用和负载均衡。
管理方便，简单直观。
pod内的容器共享资源，共享机制：pause pause容器是基础容器，也可以称为父容器。管理pod内容器的共享操作。
pause还可以管理容器的生命周期。
k8s提供了pause容器
pause作用 1.为pod内的所有容器提供一个命名空间
2.启动容器的pid命名空间，每个pod中都作为pid为1的进程（init进程），回收僵尸进程。
3.创建pod时，先创建pause容器，然后再拉取镜像，生成容器，形成pod
pid为1，是所有进程的父进程。
每创建好一个pod就会自动生成一个pause。
k8s创建pod的工作流程 第一步：master节点发出指令，pod使用的镜像nginx，pod的副本数。第二步：kube-scheduler来分配执行的node节点。第三步：node节点的kubelet收到master，拉pause，拉nginx：1.22 pod1第四步：pause容器先启动，提供命名空间，进程管理管理pid1，来为pod内的容器提供共享服务以及容器的进程管理 pause容器共享两种资源 1.网络资源： 每个pod都会分配一个集群内部的唯一IP地址，pod内的容器共享。pod在集群内部的IP地址和端口。
pod内部的容器可以使用localhost互相通信。pod的中容器与外部同学时，从共享的资源当中进行分配。宿主机的端口映射。
2.存储资源 pod可以指定多个共享的volume，pod内的容器共享这些volume。
volume可以实现数据的持久化。
防止pod重新构建之后文件消失。
pause总结： 每个pod都有一个基础容器--pause。
pause对应的镜像属于k8s集群的一部分。创建集群就会有pause基础镜像。
pod里面包含了一个或者多个相关的容器（应用）
pod外再设置一个初始镜像：
1.pod内部都有一组容器，挂了一个，就算pod失效了吗？引入pause机制，代表整个容器组的状态。
可以解决pod内部容器整体的状态判断。
2.pod内的容器共享IP 共享volume挂载卷。解决了容器内网络通信的问题，解决了容器内部文件共享的问题。
举个不太恰当的例子：kubelect相当于市长，pause相当于区长。kubelect发布指令创建pod，创建pod的具体操作通过pause来完成。pause管理pod内部一系列组件
pod的分类： 自主式pod： 不会自我修复，pod内容器的进程终止，被删除，缺少资源被驱逐，这个pod没有办法自愈。
deployment daemanset
控制器管理pod： 可以滚动升级，可以自愈（自动重启），可以管理pod的数量以及pod的扩缩容。
pod的生命周期 1.pending 挂起 pod已被创建，但是尚未被分配到运行的node节点。
原因：节点的资源不够，需要等待其他pod的调度。
2.running 运行中 pod已经被分配到了node节点，pod内部的所有容器都已经启动，运行状态正常，稳定。
3.complete / successded 表示容器内部的进程运行完毕，正常退出，没有发生错误。
4.failed： pod中的容器非正常退出。发生了错误，需要通过查看详情和日志来定位问题。
5.UNknow： 因为某些原因，k8s集群无法获取pod的状态。APIserver出了问题。
6.terminating ： 终止中，pod正在被删除，里面的容器正在终止。种植过程中，资源回收，垃圾清理，以及终止过程中需要执行的命令。
创建pod的容器分类 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/338357d1a2ad87bf530a7c24241af59f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-03T15:22:53+08:00" />
<meta property="article:modified_time" content="2024-01-03T15:22:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">k8s---pod的生命周期</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <h2>pod的相关知识</h2> 
</blockquote> 
<p>pod是k8s中最小的资源管理组件</p> 
<p>pod也是最小化运行容器化的应用的资源管理对象</p> 
<p>pod是一个抽象的概念，可以理解为一个或者多个容器化应用的集合。</p> 
<p></p> 
<h3>k8s中pod的两种使用方式</h3> 
<p>（1）<strong>一个pod中运行一个容器。</strong>"每个po中一个容器"的模式是最常见的用法:在这种使用方式中，你可以把pod想象成是单个容器的封装，kterentes管理的是Pod而不是直接管理容器。</p> 
<p>（2）<strong>在一个Pod中同时运行多个容器。</strong>一个Pod中也可以同时封装几个需要紧密耦合互相协作的容器，它们之间共享资源。这些在同一个Pod中的容器可以互相协作成为一个servie单位。</p> 
<p></p> 
<p></p> 
<p>这些多个容器共享资源，也可以互相协作组成一个service单位。</p> 
<p>不论运行一个容器还是多个容器，k8s管理的都是pod不是容器。</p> 
<p>一个pod内的多个容器，必须都运行在一个节点上。基于现在容器技术的要求，一个pod运行一个容器，一个容器只运行一个进程。这样做是为了：<strong>横向扩展，方便扩缩容。解耦</strong>。一个pod内会运行多个容器，耦合度太高，导致整个集群全部失败。实现解耦，基于pod可以创建多个副本，实现高可用和负载均衡。</p> 
<p>管理方便，简单直观。</p> 
<p></p> 
<blockquote> 
 <h2>pod内的容器共享资源，共享机制：pause</h2> 
</blockquote> 
<p>pause容器是基础容器，也可以称为父容器。管理pod内容器的共享操作。</p> 
<p>pause还可以管理容器的生命周期。</p> 
<p>k8s提供了pause容器</p> 
<p></p> 
<h3>pause作用</h3> 
<p>1.为pod内的所有容器提供一个命名空间</p> 
<p>2.启动容器的pid命名空间，每个pod中都作为pid为1的进程（init进程），回收僵尸进程。</p> 
<p>3.创建pod时，先创建pause容器，然后再拉取镜像，生成容器，形成pod</p> 
<p><span style="color:#fe2c24;"><strong>pid为1，是所有进程的父进程。<br> 每创建好一个pod就会自动生成一个pause。</strong></span></p> 
<p></p> 
<h2>k8s创建pod的工作流程</h2> 
<ul><li>第一步：master节点发出指令，pod使用的镜像nginx，pod的副本数。</li><li>第二步：kube-scheduler来分配执行的node节点。</li><li>第三步：node节点的kubelet收到master，拉pause，拉nginx：1.22 pod1</li><li>第四步：pause容器先启动，提供命名空间，进程管理管理pid1，来为pod内的容器提供共享服务以及容器的进程管理</li></ul> 
<p></p> 
<p><img alt="" height="1080" src="https://images2.imgbox.com/0d/5b/R3XCTwzD_o.png" width="1200"></p> 
<p></p> 
<h2>pause容器共享两种资源</h2> 
<h3>1.网络资源：</h3> 
<p>每个pod都会分配一个集群内部的唯一IP地址，pod内的容器共享。pod在集群内部的IP地址和端口。</p> 
<p>pod内部的容器可以使用localhost互相通信。pod的中容器与外部同学时，从共享的资源当中进行分配。宿主机的端口映射。</p> 
<p></p> 
<p><img alt="" height="522" src="https://images2.imgbox.com/8b/2a/qM2OdeSm_o.png" width="1075"></p> 
<h3>2.存储资源</h3> 
<p>pod可以指定多个共享的volume，pod内的容器共享这些volume。</p> 
<p>volume可以实现数据的持久化。</p> 
<p>防止pod重新构建之后文件消失。</p> 
<p></p> 
<h2>pause总结：</h2> 
<p>每个pod都有一个基础容器--pause。</p> 
<p>pause对应的镜像属于k8s集群的一部分。创建集群就会有pause基础镜像。</p> 
<p>pod里面包含了一个或者多个相关的容器（应用）</p> 
<p></p> 
<p>pod外再设置一个初始镜像：</p> 
<p>1.pod内部都有一组容器，挂了一个，就算pod失效了吗？引入pause机制，代表整个容器组的状态。</p> 
<p>可以解决pod内部容器整体的状态判断。</p> 
<p>2.pod内的容器共享IP 共享volume挂载卷。解决了容器内网络通信的问题，解决了容器内部文件共享的问题。</p> 
<p></p> 
<p>举个不太恰当的例子：kubelect相当于市长，pause相当于区长。kubelect发布指令创建pod，创建pod的具体操作通过pause来完成。pause管理pod内部一系列组件</p> 
<p><img alt="" height="709" src="https://images2.imgbox.com/7b/40/n65hKo59_o.png" width="773"></p> 
<p></p> 
<blockquote> 
 <h2>pod的分类：</h2> 
</blockquote> 
<h3>自主式pod：</h3> 
<p>不会自我修复，pod内容器的进程终止，被删除，缺少资源被驱逐，这个pod没有办法自愈。</p> 
<p>deployment daemanset</p> 
<h3>控制器管理pod：</h3> 
<p>可以滚动升级，可以自愈（自动重启），可以管理pod的数量以及pod的扩缩容。</p> 
<p></p> 
<blockquote> 
 <h2>pod的生命周期</h2> 
</blockquote> 
<ul><li><strong>1.pending 挂起</strong></li></ul> 
<p>pod已被创建，但是尚未被分配到运行的node节点。</p> 
<p>原因：节点的资源不够，需要等待其他pod的调度。</p> 
<p></p> 
<ul><li><strong>2.running 运行中</strong></li></ul> 
<p>pod已经被分配到了node节点，pod内部的所有容器都已经启动，运行状态正常，稳定。</p> 
<p></p> 
<ul><li><strong>3.complete / successded</strong></li></ul> 
<p>表示容器内部的进程运行完毕，<strong>正常退出</strong>，没有发生错误。</p> 
<p></p> 
<ul><li><strong>4.failed：</strong></li></ul> 
<p>pod中的容器非正常退出。发生了错误，需要通过查看详情和日志来定位问题。</p> 
<p></p> 
<ul><li><strong>5.UNknow：</strong></li></ul> 
<p>因为某些原因，k8s集群无法获取pod的状态。APIserver出了问题。</p> 
<p></p> 
<ul><li><strong>6.terminating ：</strong></li></ul> 
<p>终止中，pod正在被删除，里面的容器正在终止。种植过程中，资源回收，垃圾清理，以及终止过程中需要执行的命令。</p> 
<p><img alt="" height="533" src="https://images2.imgbox.com/52/5c/v0eXnfWW_o.png" width="1104"></p> 
<h2>创建pod的容器分类</h2> 
<p>1.基础容器：pause</p> 
<p>2.init容器（初始化容器）：init c</p> 
<p>1和2这个过程中，pod的状态就算init:0/3</p> 
<p>3.业务容器</p> 
<p>（绿---》蓝---》黄）</p> 
<p></p> 
<p></p> 
<blockquote> 
 <h2>init容器的作用：环境变量</h2> 
</blockquote> 
<p>1.可以在创建的过程中为业务容器定制好相关的代码和工具。</p> 
<p>2.init容器独立于业务容器，他是单独构建的一个镜像，对业务容器就不产生任何安全影响。</p> 
<p>3.init容器能以不同于pod内应用容器的文件系统视图运行。secrets的权限。应用容器无法访问secerts的权限。</p> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>总结init：</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>init容器提供了应用容器运行之前的先决条件，提供了一种阻塞机制或者延迟机制来控制应用容器的启动。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>只有前置条件满足，才会创建Pod内的应用容器。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>1.在pod的启动过程中，容器是按照初始化容器先启动，每个容器必须在下一个容器启动之前，要成功退出。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>2.如果运行失败，会按照容器的重启策略进行指定动作，restartPolicy Always Never onFailure（非正常退出才会重启）</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>3.所有的init容器没有成功之前，pod是不会进入ready状态。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>init容器与server无关，不能对外提供访问。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>4.如果重启pod，所有的init容器一定会重新执行。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>5.如果修改init容器的spec（参数），只限制于image，其他的修改字段都不生效</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>6.每个容器的名称都要唯一，不能重复。</strong></span></p> 
<p></p> 
<p></p> 
<blockquote> 
 <h2>实验模拟</h2> 
</blockquote> 
<pre><code>cd /opt
vim init.yaml

aplVersion: v1
kind: Pod
metadata: 
  name: nginx-init
spec:
  containrts:
  - name: nginx
    image: nginx:1.22
#定义的业务容器
#定义了两个init容器，创建完pause之后，分别运行centos   centos1之后，才会拉起nginx。
  initContainers:
  - name: init-centos
    image: centos:7
    command: ["echo","hello,world"]
  - name: init-centos1
    image: centos:7
    command: ["echo","I am ready"]

wq

kubectl apply -f init.yaml
kubectl describe pod nginx-init
kubectl get pod -o wide</code></pre> 
<p><img alt="" height="664" src="https://images2.imgbox.com/05/33/nn09RhY7_o.png" width="1177"></p> 
<p></p> 
<pre><code>aplVersion: v1
kind: Pod
metadata: 
  name: centos
spec:
  restartPolicy: onFailure
#k8s的pod的重启策略
#always:只要容器退出总是重启，无论容器的状态码是否正常。默认策略，可以不加（默认）
#never:只要容器退出，不论是否正常，都不重启
#onFailure:只有状态码非0，才会重启
#在deployment的yaml文件当中，退出策略只能是always
  containers:
  - name: centos
    image: centos:7
    command: ["echo","I am ready"]

wq</code></pre> 
<p></p> 
<h3>pod的重启策略</h3> 
<ul><li><span style="color:#fe2c24;"><strong>always:只要容器退出总是重启，无论容器的状态码是否正常。默认策略，可以不加（默认）</strong></span></li><li><span style="color:#fe2c24;"><strong>never:只要容器退出，不论是否正常，都不重启</strong></span></li><li><span style="color:#fe2c24;"><strong>onFailure:只有状态码非0，才会重启</strong></span></li></ul> 
<h4><span style="color:#fe2c24;"><strong>pod的重启策略的对象是整个pod集群！</strong></span></h4> 
<p></p> 
<p>总结：</p> 
<p>pause容器：底层容器/基础容器</p> 
<p>提供pod内容器的网络和存储共享，以及pod内容器退出之后资源回收。</p> 
<p>init容器：人为设定的，业务容器启动之间的必要条件。</p> 
<p>pod的生命周期：</p> 
<p>1.pause基础容器</p> 
<p>2.init容器----全部成功退出----业务容器</p> 
<p>3.portstart prestop 容器的钩子</p> 
<p>启动时命令 和 退出时命令</p> 
<p>4.探针：探测容器的健康状态。伴随pod的生命周期（除了启动探针）</p> 
<p>容器重启策略</p> 
<p>pod用来封装容器，业务是容器，服务也是容器，端口也是容器。</p> 
<p></p> 
<blockquote> 
 <h2>k8s每日检查</h2> 
</blockquote> 
<pre><code>kubectl get cs
kubectl get node
kubectl get pod -n kube-system</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7b5c37b2b52aea174ba09ede144471c5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Jvm之垃圾收集器（个人见解仅供参考）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2f5a92e0749e11ab4781d26632ea7d92/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Power Automate删除SharePoint Online或OneDrive for Business文件版本历史</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>