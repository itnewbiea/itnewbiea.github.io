<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据安全】2. Android 全盘加密（Full Disk Encryption）技术介绍 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数据安全】2. Android 全盘加密（Full Disk Encryption）技术介绍" />
<meta property="og:description" content="FDE (Full disk encryption) 的发展经历了几个阶段：
基于软件/硬件实现的 dm-crypt基于硬件 GPCE 实现的 request-dm-crypt基于硬件 ICE 实现的 dm-req-crypt 1. 术语解释 dm-crypt / request-dm-crypt / dm-req-crypt
它们都是位于 linux kernel block 层， 用于加解密数据的 Device Mapper 驱动模块，下文统称 dm crypt 驱动。Device Mapper 可以将整个 block 设备或 block 设备的部分映射到单个设备。
这些 dm crypt 驱动模块使用这个特性将整个用户数据分区，即用户数据分区中的所有扇区映射到另一个设备，例如/dev/dm-N。此时用户数据分区上的任何操作都由设备映射层处理，dm crypt 驱动模块加密所有写操作，并解密所有的读操作。最终整个加密和解密数据的过程对于用户来说是透明的。
至于这些 dm crypt 驱动模块的区别则是拥有更好的 I/O 性能，主要表现在 I/O 吞吐量和 I/O 延时，下文详细介绍。
GPCE
general-purpose crypto engine，ARM 体系结构提供的通用加密引擎。
ICE
inline crypto engine，一般由 SOC 厂商实现，内嵌到存储器控制器的加密引擎。
2. 基于软件/硬件实现的 dm-crypt 该方案已经被废弃，这里只做简单介绍，架构如下所示：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c2bc584b9a588e2da6e333a90e540624/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-04T11:48:49+08:00" />
<meta property="article:modified_time" content="2022-10-04T11:48:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据安全】2. Android 全盘加密（Full Disk Encryption）技术介绍</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>FDE (Full disk encryption) 的发展经历了几个阶段：</p> 
<ul><li>基于软件/硬件实现的 dm-crypt</li><li>基于硬件 GPCE 实现的 request-dm-crypt</li><li>基于硬件 ICE 实现的 dm-req-crypt</li></ul> 
<h2>1. 术语解释</h2> 
<p><strong>dm-crypt / request-dm-crypt / dm-req-crypt</strong></p> 
<p>它们都是位于 linux kernel block 层， 用于加解密数据的 Device Mapper 驱动模块，下文统称 dm crypt 驱动。Device Mapper 可以将整个 block 设备或 block  设备的部分映射到单个设备。</p> 
<p>这些 dm crypt 驱动模块使用这个特性将整个用户数据分区，即用户数据分区中的所有扇区映射到另一个设备，例如/dev/dm-N。此时用户数据分区上的任何操作都由设备映射层处理，dm crypt 驱动模块加密所有写操作，并解密所有的读操作。最终整个加密和解密数据的过程对于用户来说是透明的。</p> 
<p>至于这些 dm crypt 驱动模块的区别则是拥有更好的 I/O 性能，主要表现在 I/O 吞吐量和 I/O 延时，下文详细介绍。</p> 
<p><strong>GPCE</strong></p> 
<p>general-purpose crypto engine，ARM 体系结构提供的通用加密引擎。</p> 
<p><strong>ICE</strong></p> 
<p>inline crypto engine，一般由 SOC 厂商实现，内嵌到存储器控制器的加密引擎。</p> 
<h2>2. 基于软件/硬件实现的 dm-crypt</h2> 
<p>该方案已经被废弃，这里只做简单介绍，架构如下所示：</p> 
<p class="img-center"><img alt="" height="800" src="https://images2.imgbox.com/24/a8/wIbFMFnt_o.png" width="316"></p> 
<p>使用 dm-crypt 加密磁盘：</p> 
<ul><li>dm-crypt 是在基于 BIO 的设备映射器之上提供的磁盘加密机制，它在物理块设备之上提供虚拟块层。</li><li>dm 层将接收到的块 I/O (BIO) 克隆并映射到底层物理设备。</li><li>Android系统中的 VOLD 使用 dm-crypt 将用户数据分区映射到 cryptfs 文件系统。所有对 cryptfs 文件系统的写入都被加密，读取被解密。</li><li>Android 使用 128 位 AES-CBC 模式以及 ESSIV:SHA256 来加密和解密数据。所有加密材料，例如加密密钥和加密类型，都存储在用户数据分区的底部 16 K 中。</li><li>dm-crypt 使用 512 字节的数据包大小来加密和解密数据。这意味着必须为每个扇区创建一个新的密码上下文。除此之外，每次为每个扇区生成 IV，即使用 SHA-256 的 512 字节，这是一个昂贵的机制。</li><li>VOLD 管理所有加密材料并在启动时将其提供给设备映射设备。</li></ul> 
<p><strong>基于软件的实现</strong></p> 
<p>从安全的角度来看，如果加密操作是在软件中完成的，那么密钥必须存在于软件中，这是不可取的。基于软件的磁盘加密有几个缺点：</p> 
<ul><li>它很慢。</li><li>所有加密操作都发生在软件中，因此非常耗电且消耗大量电力。</li><li>将密钥存储在 RAM 中，可以被转储和搜索，所以并不安全。</li></ul> 
<p><strong>基于硬件的实现</strong></p> 
<p>由于通用硬件加密引擎不能很好地处理较小的数据包大小，因此仍然存在性能问题。</p> 
<p></p> 
<h2>3. 基于硬件 GPCE 实现的 request-dm-crypt</h2> 
<p>该方案已经被废弃，这里只做简单介绍，架构如下所示：</p> 
<p class="img-center"><img alt="" height="983" src="https://images2.imgbox.com/7a/2a/8O4glgzb_o.png" width="943"></p> 
<p>相比基于 BIO 的映射器的 dm-crypt， request-dm-crypt 是基于请求的设备映射器，不同之处在于：</p> 
<ul><li>request-dm-crypt 设备映射器不是克隆和映射 BIO，而是移动到软件架构 stack 中的较低位置，它克隆和映射 I/O 请求。</li><li>不需要和 dm-crypt 一样，使用 512 字节的数据包大小来加密和解密数据，大大释放了 GPCE 的性能。</li></ul> 
<p><strong>3.1 写操作流程</strong></p> 
<ol><li>dm 层调用已注册插件 (request-dm-crypt) 的 map API；</li><li>map 函数还会遍历请求中的所有 BIO，并创建所有数据的 SGL（scatter gather list）；</li><li>然后 map 函数调用 Kernel Crypto API，该 API 最终调用 GPCE 加密驱动程序以执行加密操作；</li><li>加密完成后，克隆的请求被添加到 I/O 调度程序队列；</li></ol> 
<p><strong>3.2 读操作流程</strong></p> 
<ol><li>当块驱动完成读请求时，请求被传递到通用块层（blk_end_bidi_request）以完成请求；</li><li>通用块层通过调用请求的end_io函数来完成请求；</li><li>end_io 函数然后调用 request-dm-crypt 的 end_io 函数；</li><li>request-dmcrypt end_io 函数遍历请求中的 BIO 并创建一个 SGL。然后该函数使用此列表调用内核加密 API；</li><li>Kernel Crypto API 最终调用 GPCE 加密驱动程序来执行解密操作；</li><li>最终将数据返回到文件系统。</li></ol> 
<p>使用通用加密引擎 (GPCE) 提供了可以接受的性能量，但由于存储速度不断提高，它还不够。因为 I/O 请求需要通过 request-dm-crypt 处理来执行数据加密和解密，从架构图中可以看出，在原来的 I/O 流程中增加了一个环节增加了延时。因此 FDE 又进化到下文介绍的基于 ICE 实现的 dm-req-crypt。</p> 
<h2>4. 基于硬件 ICE 实现的 dm-req-crypt</h2> 
<p>为了克服性能下降，较新的芯片将内联加密引擎 (ICE) 嵌入到存储设备中。基于 ICE 的 FDE 在 ICE 硬件中执行所有加密操作，而无需返回软件。<span style="color:#fe2c24;">该解决方案提供几乎线速的吞吐量，即加密设备上的 I/O 吞吐量不会降低</span>。</p> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" height="774" src="https://images2.imgbox.com/63/ca/5VzTz0ak_o.png" width="932"> 
  <figcaption>
     FDE Architecture 
  </figcaption> 
 </figure> 
</div> 
<p></p> 
<p><strong>4.1 硬件相关的实现</strong></p> 
<p>ICE 是嵌入到 UFS/eMMC 等存储设备中的硬件块。默认情况下，ICE工作在 Bypass 模式，即ICE硬件不对存储设备要处理的数据进行任何加密操作，这称为 ICE 的全局旁路模式。如果需要，可以将 ICE 配置为在一个方向（即加密或解密）或两个方向（加密和解密）执行加密操作。</p> 
<p>ICE 硬件的一些特征：</p> 
<ul><li>支持 AES-128/-256 位 ECB 和 XTS 模式加密算法；</li><li>加密操作的密钥是从软件中加载的；</li><li>密钥存储在位于 ICE 硬件内部的查找表 (LUT) 中；</li><li>ICE key LUT 中最多可以加载 32 个 key；</li><li>LUT 中的 key 可以通过 key 索引来引用；</li></ul> 
<p><strong>4.2 软件相关的实现</strong></p> 
<p>ICE 硬件将 ICE 寄存器分为两组：</p> 
<ul><li>只能被安全端访问的寄存器，即 TZ</li><li>非安全端也可以访问的寄存器，例如 HLOS</li></ul> 
<p>这种分类要求将 ICE 驱动程序分成两部分：一个从 TZ 空间运行，另一个从 HLOS 空间运行。</p> 
<p>TZ 的 ICE 驱动程序根据 HLOS 端的要求配置密钥：</p> 
<ul><li>出于安全考虑，ICE 驱动程序的 TZ 端负责在冷启动期间重置所有 ICE 密钥 LUT。</li><li>根据 HLOS 的请求，TZ 设置所需的 ICE 硬件寄存器以配置 ICE 硬件中的密钥。 
  <ul><li>密钥配置的一部分是设置上下文，包括算法、模式、密钥长度等。</li><li>另一部分是设置实际密钥。</li></ul></li></ul> 
<p>HLOS 侧的 ICE 驱动程序：</p> 
<ul><li>负责 ICE 硬件的初始化。</li><li>帮助存储驱动程序决定是否对请求执行加密操作。如果决定执行加密操作，则 HLOS 端的 ICE 驱动程序提供所需的配置参数。比如高通平台： 
  <ul><li>在首次加密或加密后重启设备时，当 VOLD 准备好开始加密时（即用户数据分区已卸载），它会通过 libQSEECom 的 API 创建或设置密钥。</li><li>libQSEECom 使用基于 IOCTL 的机制与 QSEECom 驱动程序通信，最终调用 TZ 端的 ICE 驱动程序。</li></ul></li></ul> 
<p>基于 GPCE 和 ICE 的 FDE 解决方案的密钥管理方式没有重大变化。但是，密钥管理有两个不同之处：</p> 
<ul><li>基于 ICE 的解决方案在 ICE 硬件密钥 LUT 中设置密钥。</li><li>基于 GPCE 的 FDE 的情况下，密钥在管道寄存器中设置。</li><li>基于 ICE 的解决方案在已设置密钥的 ICE 硬件中返回密钥 LUT 中的密钥索引。</li><li>基于 GPCE 的 FDE 的情况下，对 TZ 的调用将返回成功（即正整数）或失败（负整数）。</li></ul> 
<p><strong>4.3 数据的处理流</strong></p> 
<p class="img-center"><img alt="" height="994" src="https://images2.imgbox.com/13/8c/AeETRAJG_o.png" width="529"></p> 
<p>加解密时，数据路径类似于基于 GPCE 的 FDE，但有一些区别 ：</p> 
<ol><li>在基于 ICE 的 FDE 的情况下，VOLD 创建基于 dm-req-crypt 的映射设备。在设备创建时，VOLD 提供了已配置密钥的 ICE 密钥 LUT 的密钥索引。</li><li><span style="color:#fe2c24;">在 ICE 的情况下，映射设备被配置为在透明（Transparent）模式下工作。</span></li><li>当基于 dm-req-crypt 的设备工作在透明模式时，VOLD 使用密钥索引更新映射的请求并将请求提交给 <a class="link-info" href="https://blog.51cto.com/alanwu/1391156" rel="nofollow" title="elevator">elevator</a>。</li><li>该请求到达存储驱动程序，它为每个接收到的请求调用 ICE 驱动程序，以了解是否必须执行任何加密操作或绕过加密操作。 
  <ol><li>如果请求需要加密操作，存储驱动程序会从 ICE 驱动程序返回密钥索引值。</li><li>存储驱动程序将请求发送到存储硬件，ICE硬件将执行所需的加密操作。</li></ol></li><li><span style="color:#fe2c24;">当存储驱动程序完成请求时，执行返回到设备映射器驱动程序，该驱动程序调用基于 dm-req-crypt 的 endio 函数来完成请求。由于 ICE 硬件已经执行了加密操作，endio 函数立即完成请求</span>。</li></ol> 
<p>对比基于 GPCE 的 FDE 的架构图可知，它们的最大的区别在于第 2 和第5步，基于 ICE 的 FDE，在这两个步骤中几乎没有损耗，而基于 GPCE 的 FDE 则在这里面分别执行加密和解密数据的操作。</p> 
<h2>5.总结</h2> 
<p>几个 FDE 版本的不断迭代，收益主要是体现在：</p> 
<p><strong> 密钥管理越来越安全</strong></p> 
<ul><li>用于数据加解密的实际密钥不会出现在 HLOS ，同时 HLOS 也无法访问，由 TZ KMS 统一管理；</li><li>密钥无法被 dump、搜索以及 debug (e.g. JTAG)；</li><li>密钥的创建、更新和删除等操作以及使用都严格控制；</li></ul> 
<p><strong>对 I/O 性能的性能越来越小</strong></p> 
<ul><li>基于 ICE 的实现，执行 I/O 时，数据在存储器控制器里流式加解密；</li><li>kernel I/O 软件 stack 几乎不需要增加额外开销；</li><li>当然代价是需要增加专属硬件模块；</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/143e32fe74fa112c0839176bac93e7fc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">matlab绘制图像的直方图、杆状图和折线图等</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2de06b275995f1a05f3a0a255649b590/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">抓包微信小程序openid的教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>