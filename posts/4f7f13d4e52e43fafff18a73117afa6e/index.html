<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ImageNet Classification with Deep Convolutional Neural Networks - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ImageNet Classification with Deep Convolutional Neural Networks" />
<meta property="og:description" content="参考 ImageNet Classification with Deep Convolutional Neural Networks - 云&#43;社区 - 腾讯云
摘要 我们训练了一个大型的深度卷积神经网络，将ImageNet LSVRC -2010竞赛中的120万幅高分辨率图像分成1000个不同的类。在测试数据上，我们实现了top-1名的错误率为37.5%，top-5名的错误率为17.0%，大大优于之前的水平。该神经网络有6000万个参数和65万个神经元，由5个卷积层和3个完全连接的层组成，其中一些卷积层之后是最大汇聚层，最后是100路的softmax。为了使训练更快，我们使用了非饱和神经元和一个非常高效的GPU实现卷积运算。为了减少全连通层的过拟合，我们采用了最近开发的正则化方法“dropout”，该方法被证明是非常有效的。在ILSVRC-2012比赛中，我们也加入了该模型的一个变体，并获得了15.3%的前5名测试错误率，而第二名获得了26.2%的错误率。
1、开场白 四年前，Yann LeCun和他的合作者的一篇论文被领先的计算机视觉大会拒绝，理由是它使用了神经网络，因此没有提供关于如何设计视觉系统的见解。当时，大多数计算机视觉研究人员认为，视觉系统需要仔细地手工设计，使用对任务性质的详细了解。他们假设，在自然图像中对物体进行分类的任务永远不会通过简单地展示图像的例子以及它们包含在一个神经网络中的物体的名称来解决，而这个神经网络从这些训练数据中获取了所有的知识。在视觉研究社区中，许多人没有意识到的是，需要了解领域的程序员仔细手工工程的方法不能推广，同样，需要用功能强大的通用学习过程替代程序员的方法也不能推广。有了足够的计算和数据，学习就比编程更适合复杂的任务，这些任务需要集成许多不同的、有噪声的线索。
四年前，当我们还在多伦多大学(University of Toronto)的时候，我们被称为“监督”(SuperVision)的深层神经网络使我们在自然图像中识别物体的错误率降低了近一半，并引发了计算机视觉领域迟来的范式转变。图4显示了一些监视功能的示例。监督是从20世纪80年代被广泛研究的多层神经网络发展而来的。这些网络使用了多层特征检测器，这些检测器都是从训练数据中学到的。神经科学家和心理学家曾假设，这种特征探测器的层次结构将提供一种强有力的方法来识别物体，但他们不知道如何学习这种层次结构。在1980年代非常激动因为几个不同的研究小组发现,可以训练多层特征探测器有效使用相对简单的算法称为backpropagation来计算,对于每一个形象,整个网络的分类性能如何取决于重量在每个连接上的值。
反向传播可以很好地完成各种任务，但在20世纪80年代，它没有达到其倡导者的很高期望。特别是，事实证明，学习具有许多层的网络是非常困难的，而这些正是应该产生最令人印象深刻的结果的网络。许多研究人员错误地认为，从随机初始权重中学习深度神经网络太难了。20年后，我们知道哪里出了问题:为了让深层神经网络发光，它们需要更多的标记数据和大量的计算。
2、简介 目前的目标识别方法主要使用机器学习方法。为了提高性能，我们可以收集更大的数据集，学习更强大的模型，并使用更好的技术来防止过度拟合。直到最近，标记图像的数据集还相对较小——大约是数万张图像。使用这种大小的数据集可以很好地解决简单的识别任务，特别是如果使用保存标签的转换来增强它们。例如，MNIST数字识别任务的当前最佳错误率(&lt;0.3%)接近人类性能。但现实环境中的物体表现出相当大的变异性，因此，要学会识别它们，有必要使用更大的训练集。事实上，小图像数据集的缺点已经得到了广泛的认识，但是直到最近才有可能收集数百万幅图像的标记数据集。新的更大的数据集包括由数十万张完全分割的图像组成的LabelMe，以及由超过22000个类别的超过1500万张高分辨率图像组成的ImageNet。
要从数以百万计的图像中学习成千上万的物体，我们需要一个具有较大学习能力的模型。然而，目标识别任务的巨大复杂性意味着即使是像ImageNet这样大的数据集也不能指定这个问题，因此我们的模型也应该具有大量的先验知识来补偿我们没有的所有数据。卷积神经网络(CNNs)就是其中一类模型。它们的容量可以通过改变深度和宽度来控制，而且它们还对图像的性质(即统计量的平稳性和像素依赖性的局部性)做出了强有力且基本正确的假设。因此，与具有相同大小层的标准前馈神经网络相比，CNNs具有更少的连接和参数，因此更容易训练，而从理论上讲，它们的最佳性能可能只会略差。
尽管CNNs具有吸引人的特性，尽管其局部架构相对高效，但将其大规模应用于高分辨率图像仍然非常昂贵。幸运的是，当前的GPU与高度优化的2D卷积实现相结合，具有足够强大的功能，可以方便地训练有趣的大型CNNs，而且最近的数据集(如ImageNet)包含足够多的标记示例，可以训练此类模型，而不会出现严重的过拟合。
本文的具体贡献如下：我们对ImageNet large Visual Recognition Challenge ILSVRC - 2010和ILSVRC - 2012比赛中使用的ImageNet子集进行了迄今为止最大的CNNs之一的训练，并取得了迄今为止在这些数据集中所报道的最好的结果。我们编写了一个高度优化的GPU实现的二维卷积和所有其他固有的训练CNNs的操作，我们公开可用。我们的网络包含了许多新的和不寻常的特性，这些特性提高了它的性能，减少了它的训练时间，这些特性在第4节中详细介绍。我们的网络规模使过度拟合成为一个重要的问题，即使有120万个标记的训练示例，所以我们使用了一些有效的技术来防止过度拟合，如第5节所述。我们最终的网络包含5个卷积和3个完全连接的层，这个深度似乎很重要：我们发现去掉任何卷积层(每个卷积层包含的参数不超过模型参数的1%)都会导致性能低下。
最后，网络的大小主要受到当前GPU上可用内存的大小和我们愿意忍受的训练时间的大小的限制。我们的网络需要5到6天的时间来训练两个GTX 580 3GB GPU。我们所有的实验都表明，只要等待更快的gpu和更大的数据集可用，我们的结果就可以得到改善。
3、数据集 ImageNet是一个超过1500万张高分辨率图像的数据集，属于大约22000个类别。这些图片是从网上收集的，并由人类贴标签者使用Amazon’s Mechanical Turk crowd-sourcing tool进行标记。从2010年开始，作为Pascal视觉对象挑战赛的一部分，每年都会举办一场名为ImageNet大型视觉识别挑战赛(ILSVRC)的比赛。ILSVRC使用ImageNet的一个子集，在1000个类别中每个类别大约有1000幅图像。总共大约有120万张训练图像、50,000张验证图像和150,000张测试图像。
ILSVRC-2010是唯一一个可以使用测试集标签的ILSVRC版本，因此这是我们进行大部分实验的版本。由于我们也在ILSVRC-2012竞赛中进入了我们的模型，所以在第7节中，我们也报告了这个版本的数据集的结果，对于这个版本的数据集，测试集标签是不可用的。在ImageNet上，通常报告两个错误率:top-1和top-5，其中top 5错误率是测试图像的一部分，其中正确的标签不在模型认为最可能出现的五个标签中。
ImageNet由可变分辨率的图像组成，而我们的系统需要一个恒定的输入维数。因此，我们将图像降采样到256×256的固定分辨率。对于给定的矩形图像，我们首先对图像进行重新标定，使较短的边长度为256，然后从得到的图像中裁剪出中心256×256的patch。除了从每个像素中减去训练集上的平均活动外，我们没有以任何其他方式对图像进行预处理。因此，我们将网络训练为像素的原始RGB值。
4、结构 图2总结了我们的网络架构。它包含八个学习层——五个卷积层和三个完全连接的层。下面，我们将描述我们的网络架构的一些新奇或不寻常的特性。第4.1 - 4.4节根据我们对其重要性的估计进行排序，最重要的放在第一位
4.1、整流线性单元的非线性 用或来模拟神经元输出f作为其输入x的函数的标准方法。在梯度下降训练时间方面，这些饱和非线性比非饱和非线性慢得多。继Nair和Hinton之后，我们将具有这种非线性的神经元称为整流线性单元(ReLUs)。使用ReLUs的深度CNNs训练速度是使用tanh单元的数倍。如图1所示，它显示了对于特定的四层卷积网络，在CIFAR-10数据集上达到25%的训练误差所需的迭代次数。这张图表明，如果我们使用传统的饱和神经元模型，我们就无法用这么大的神经网络来进行实验。
我们并不是第一个考虑CNNs中传统神经元模型的替代品。例如，Jarrett et al.13声称非线性f(x) = |tanh(x)|对于他们的对比归一化类型特别有效，然后是Caltech-101数据集中的局部平均池。然而，在这个数据集中，主要关注的是防止过度拟合，因此他们所观察到的效果不同于我们在使用ReLUs时报告的加速适应训练集的能力。更快的学习速度对大数据集上训练的大型模型的性能有很大的影响。
4.2、在多GPU上进行训练 一个GTX 580 GPU只有3GB的内存，这限制了可以在其上训练的网络的最大大小。事实证明，120万个训练实例足以训练一个GPU上无法容纳的网络。因此，我们将网络分布在两个GPU上。当前的GPU特别适合跨GPU并行化，因为它们可以直接读写彼此的内存，而不需要经过主机内存。我们使用的并行化方案本质上是将一半内核(或神经元)放在每个GPU上，还有一个额外的技巧：GPU只在特定的层中通信。这意味着，例如，第3层的内核从第2层的所有内核映射中获取输入。然而，第4层的内核只从位于同一GPU的第3层的内核映射中获取输入。对于交叉验证来说，选择连接模式是一个问题，但这允许我们精确地调整通信量，直到它是计算量的可接受部分。
结果的架构与“columnar”CNN的架构有些类似，只是我们的列不是独立的(参见图2)。该方案减少了我们(和前5错误率1.7%和1.2%，分别比净一半的内核在每个卷积层对准一个GPU。双GPU网络的训练时间比单GPU网络略短。
4.3、局部响应归一化 ReLUs有一个理想的特性，即不需要对输入进行标准化以防止其饱和。如果至少有一些训练例子对ReLU产生积极的输入，学习就会发生在那个神经元上。用代表神经元的激活，含义为在处使用核，然后使用ReLU激活函数响应归一化的表达式为：
其中和在相同空间位置上运行n个“相邻”内核映射，n是该层中内核的总数。当然，内核映射的顺序是任意的，并在培训开始之前确定。这种反应归一化实现了一种形式的横向抑制，其灵感来自于在真实神经元中发现的类型，在使用不同内核计算的神经元输出之间产生了对大型活动的竞争。常数k, n、α和β等超参数的值是决定使用一套验证;我们使用k = 2，n = 5，，β= 0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4f7f13d4e52e43fafff18a73117afa6e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-12T20:54:50+08:00" />
<meta property="article:modified_time" content="2022-09-12T20:54:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ImageNet Classification with Deep Convolutional Neural Networks</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:.0001pt;text-align:justify;">参考 <a href="https://cloud.tencent.com/developer/article/1495192" rel="nofollow" title="  ImageNet Classification with Deep Convolutional Neural Networks - 云+社区 - 腾讯云">  ImageNet Classification with Deep Convolutional Neural Networks - 云+社区 - 腾讯云</a></p> 
<h2>摘要</h2> 
<p>我们训练了一个大型的深度卷积神经网络，将ImageNet LSVRC -2010竞赛中的120万幅高分辨率图像分成1000个不同的类。在测试数据上，我们实现了top-1名的错误率为37.5%，top-5名的错误率为17.0%，大大优于之前的水平。该神经网络有6000万个参数和65万个神经元，由5个卷积层和3个完全连接的层组成，其中一些卷积层之后是最大汇聚层，最后是100路的softmax。为了使训练更快，我们使用了非饱和神经元和一个非常高效的GPU实现卷积运算。为了减少全连通层的过拟合，我们采用了最近开发的正则化方法“dropout”，该方法被证明是非常有效的。在ILSVRC-2012比赛中，我们也加入了该模型的一个变体，并获得了15.3%的前5名测试错误率，而第二名获得了26.2%的错误率。</p> 
<h2>1、开场白</h2> 
<p>四年前，Yann LeCun和他的合作者的一篇论文被领先的计算机视觉大会拒绝，理由是它使用了神经网络，因此没有提供关于如何设计视觉系统的见解。当时，大多数计算机视觉研究人员认为，视觉系统需要仔细地手工设计，使用对任务性质的详细了解。他们假设，在自然图像中对物体进行分类的任务永远不会通过简单地展示图像的例子以及它们包含在一个神经网络中的物体的名称来解决，而这个神经网络从这些训练数据中获取了所有的知识。在视觉研究社区中，许多人没有意识到的是，需要了解领域的程序员仔细手工工程的方法不能推广，同样，需要用功能强大的通用学习过程替代程序员的方法也不能推广。有了足够的计算和数据，学习就比编程更适合复杂的任务，这些任务需要集成许多不同的、有噪声的线索。</p> 
<p>四年前，当我们还在多伦多大学(University of Toronto)的时候，我们被称为“监督”(SuperVision)的深层神经网络使我们在自然图像中识别物体的错误率降低了近一半，并引发了计算机视觉领域迟来的范式转变。图4显示了一些监视功能的示例。监督是从20世纪80年代被广泛研究的多层神经网络发展而来的。<span style="color:#e579b6;"><strong>这些网络使用了多层特征检测器，这些检测器都是从训练数据中学到的。</strong></span>神经科学家和心理学家曾假设，这种特征探测器的层次结构将提供一种强有力的方法来识别物体，但他们不知道如何学习这种层次结构。<span style="color:#e579b6;"><strong>在1980年代非常激动因为几个不同的研究小组发现,可以训练多层特征探测器有效使用相对简单的算法称为backpropagation来计算,对于每一个形象,整个网络的分类性能如何取决于重量在每个连接上的值。</strong></span></p> 
<p>反向传播可以很好地完成各种任务，但在20世纪80年代，它没有达到其倡导者的很高期望。特别是，事实证明，学习具有许多层的网络是非常困难的，而这些正是应该产生最令人印象深刻的结果的网络。许多研究人员错误地认为，从随机初始权重中学习深度神经网络太难了。20年后，我们知道哪里出了问题:为了让深层神经网络发光，它们需要更多的标记数据和大量的计算。</p> 
<h2>2、简介</h2> 
<p>目前的目标识别方法主要使用机器学习方法。为了提高性能，我们可以收集更大的数据集，学习更强大的模型，并使用更好的技术来防止过度拟合。直到最近，标记图像的数据集还相对较小——大约是数万张图像。使用这种大小的数据集可以很好地解决简单的识别任务，特别是如果使用保存标签的转换来增强它们。例如，MNIST数字识别任务的当前最佳错误率(&lt;0.3%)接近人类性能。但现实环境中的物体表现出相当大的变异性，因此，要学会识别它们，有必要使用更大的训练集。事实上，小图像数据集的缺点已经得到了广泛的认识，但是直到最近才有可能收集数百万幅图像的标记数据集。新的更大的数据集包括由数十万张完全分割的图像组成的LabelMe，以及由超过22000个类别的超过1500万张高分辨率图像组成的ImageNet。</p> 
<p><span style="color:#e579b6;"><strong>要从数以百万计的图像中学习成千上万的物体，我们需要一个具有较大学习能力的模型。</strong></span>然而，目标识别任务的巨大复杂性意味着即使是像ImageNet这样大的数据集也不能指定这个问题，因此我们的模型也应该具有大量的先验知识来补偿我们没有的所有数据。卷积神经网络(CNNs)就是其中一类模型。它们的容量可以通过改变深度和宽度来控制，而且它们还对图像的性质(即统计量的平稳性和像素依赖性的局部性)做出了强有力且基本正确的假设。因此，与具有相同大小层的标准前馈神经网络相比，CNNs具有更少的连接和参数，因此更容易训练，而从理论上讲，它们的最佳性能可能只会略差。</p> 
<p>尽管CNNs具有吸引人的特性，尽管其局部架构相对高效，但将其大规模应用于高分辨率图像仍然非常昂贵。幸运的是，当前的GPU与高度优化的2D卷积实现相结合，具有足够强大的功能，可以方便地训练有趣的大型CNNs，而且最近的数据集(如ImageNet)包含足够多的标记示例，可以训练此类模型，而不会出现严重的过拟合。</p> 
<p>本文的具体贡献如下：我们对ImageNet large Visual Recognition Challenge ILSVRC - 2010和ILSVRC - 2012比赛中使用的ImageNet子集进行了迄今为止最大的CNNs之一的训练，并取得了迄今为止在这些数据集中所报道的最好的结果。<strong>我们编写了一个高度优化的GPU实现的二维卷积和所有其他固有的训练CNNs的操作，我们公开可用。</strong>我们的网络包含了许多新的和不寻常的特性，这些特性提高了它的性能，减少了它的训练时间，这些特性在第4节中详细介绍。我们的网络规模使过度拟合成为一个重要的问题，即使有120万个标记的训练示例，所以我们使用了一些有效的技术来防止过度拟合，如第5节所述。我们最终的网络包含5个卷积和3个完全连接的层，这个深度似乎很重要：我们发现去掉任何卷积层(每个卷积层包含的参数不超过模型参数的1%)都会导致性能低下。</p> 
<p>最后，网络的大小主要受到当前GPU上可用内存的大小和我们愿意忍受的训练时间的大小的限制。我们的网络需要5到6天的时间来训练两个GTX 580 3GB GPU。我们所有的实验都表明，只要等待更快的gpu和更大的数据集可用，我们的结果就可以得到改善。</p> 
<h2>3、数据集</h2> 
<p>ImageNet是一个超过1500万张高分辨率图像的数据集，属于大约22000个类别。这些图片是从网上收集的，并由人类贴标签者使用Amazon’s Mechanical Turk crowd-sourcing tool进行标记。从2010年开始，作为Pascal视觉对象挑战赛的一部分，每年都会举办一场名为ImageNet大型视觉识别挑战赛(ILSVRC)的比赛。<span style="color:#e579b6;"><strong>ILSVRC使用ImageNet的一个子集，在1000个类别中每个类别大约有1000幅图像。总共大约有120万张训练图像、50,000张验证图像和150,000张测试图像。</strong></span></p> 
<p>ILSVRC-2010是唯一一个可以使用测试集标签的ILSVRC版本，因此这是我们进行大部分实验的版本。由于我们也在ILSVRC-2012竞赛中进入了我们的模型，所以在第7节中，我们也报告了这个版本的数据集的结果，对于这个版本的数据集，测试集标签是不可用的。在ImageNet上，通常报告两个错误率:top-1和top-5，<span style="color:#e579b6;"><strong>其中top 5错误率是测试图像的一部分，其中正确的标签不在模型认为最可能出现的五个标签中。</strong></span></p> 
<p>ImageNet由可变分辨率的图像组成，而我们的系统需要一个恒定的输入维数。因此，我们将图像降采样到256×256的固定分辨率。对于给定的矩形图像，我们首先对图像进行重新标定，使较短的边长度为256，然后从得到的图像中裁剪出中心256×256的patch。除了从每个像素中减去训练集上的平均活动外，我们没有以任何其他方式对图像进行预处理。因此，我们将网络训练为像素的原始RGB值。</p> 
<h2>4、结构</h2> 
<p>图2总结了我们的网络架构。它包含八个学习层——五个卷积层和三个完全连接的层。下面，我们将描述我们的网络架构的一些新奇或不寻常的特性。第4.1 - 4.4节根据我们对其重要性的估计进行排序，最重要的放在第一位</p> 
<p>             <img alt="" class="has" height="324" src="https://images2.imgbox.com/b6/2b/fbdY6p3w_o.png" width="782"></p> 
<h3>4.1、整流线性单元的非线性</h3> 
<p>用<img alt="\large f(x) = tanh(x)" class="mathcode" height="17" src="https://images2.imgbox.com/bc/b7/oGPTql0Y_o.gif" width="110">或<img alt="\large f(x) = (1 + e ^{- x})^ {- 1}" class="mathcode" src="https://images2.imgbox.com/07/b0/pPZKEmDs_o.gif">来模拟神经元输出f作为其输入x的函数的标准方法。在梯度下降训练时间方面，这些饱和非线性比非饱和非线性<img alt="\large f(x) = max(0,x)" class="mathcode" src="https://images2.imgbox.com/53/99/msjSx6NH_o.gif">慢得多。继Nair和Hinton之后，我们将具有这种非线性的神经元称为整流线性单元(ReLUs)。使用ReLUs的深度CNNs训练速度是使用tanh单元的数倍。如图1所示，它显示了对于特定的四层卷积网络，在CIFAR-10数据集上达到25%的训练误差所需的迭代次数。这张图表明，如果我们使用传统的饱和神经元模型，我们就无法用这么大的神经网络来进行实验。</p> 
<p>我们并不是第一个考虑CNNs中传统神经元模型的替代品。例如，Jarrett et al.13声称非线性f(x) = |tanh(x)|对于他们的对比归一化类型特别有效，然后是Caltech-101数据集中的局部平均池。然而，在这个数据集中，主要关注的是防止过度拟合，因此他们所观察到的效果不同于我们在使用ReLUs时报告的加速适应训练集的能力。更快的学习速度对大数据集上训练的大型模型的性能有很大的影响。</p> 
<p>                                <img alt="" class="has" height="555" src="https://images2.imgbox.com/3f/d4/14vg8hqt_o.png" width="510"></p> 
<h3>4.2、在多GPU上进行训练</h3> 
<p>一个GTX 580 GPU只有3GB的内存，这限制了可以在其上训练的网络的最大大小。事实证明，120万个训练实例足以训练一个GPU上无法容纳的网络。因此，我们将网络分布在两个GPU上。当前的GPU特别适合跨GPU并行化，因为它们可以直接读写彼此的内存，而不需要经过主机内存。我们使用的并行化方案本质上是将一半内核(或神经元)放在每个GPU上，还有一个额外的技巧：GPU只在特定的层中通信。这意味着，例如，第3层的内核从第2层的所有内核映射中获取输入。然而，第4层的内核只从位于同一GPU的第3层的内核映射中获取输入。对于交叉验证来说，选择连接模式是一个问题，但这允许我们精确地调整通信量，直到它是计算量的可接受部分。</p> 
<p>结果的架构与“columnar”CNN的架构有些类似，只是我们的列不是独立的(参见图2)。该方案减少了我们(和前5错误率1.7%和1.2%，分别比净一半的内核在每个卷积层对准一个GPU。双GPU网络的训练时间比单GPU网络略短。</p> 
<h3>4.3、局部响应归一化</h3> 
<p>ReLUs有一个理想的特性，即不需要对输入进行标准化以防止其饱和。如果至少有一些训练例子对ReLU产生积极的输入，学习就会发生在那个神经元上。用<img alt="\large a^i_{x,y}" class="mathcode" height="21" src="https://images2.imgbox.com/ee/b6/r2tRQjRR_o.gif" width="25">代表神经元的激活，含义为在<img alt="(x,y)" class="mathcode" src="https://images2.imgbox.com/7b/26/YQx9OUHw_o.png">处使用核<img alt="i" class="mathcode" src="https://images2.imgbox.com/65/88/0piUalyW_o.png">，然后使用ReLU激活函数响应归一化的表达式为：</p> 
<p>                                       <img alt="" class="has" height="88" src="https://images2.imgbox.com/07/d2/39AkNjjk_o.png" width="398"></p> 
<p>其中和在相同空间位置上运行n个“相邻”内核映射，n是该层中内核的总数。当然，内核映射的顺序是任意的，并在培训开始之前确定。这种反应归一化实现了一种形式的横向抑制，其灵感来自于在真实神经元中发现的类型，在使用不同内核计算的神经元输出之间产生了对大型活动的竞争。常数k, n、α和β等超参数的值是决定使用一套验证;我们使用k = 2，n = 5，<img alt="" height="15" src="https://images2.imgbox.com/02/ae/eYe87Ma4_o.png" width="52">，β= 0.75。我们在对某些层应用ReLU非线性之后应用了这种归一化(参见4.5节)。</p> 
<p>这个方案与Jarrett et al的局部对比度归一化方案有一些相似之处，但是我们的方案更准确地称为“亮度归一化”，因为我们没有减去平均活动。我们也在CIFAR-10验证了这种方法的有效性：不用归一化时4层的CNN达到了13%的测试错误率，使用归一化时错误率降低到了11%。</p> 
<h3>4.4、重叠池化</h3> 
<p>CNNs中的汇聚层总结了同一核映射中相邻神经元群的输出。传统上，相邻的池单元汇总的邻域不会重叠。更精确地说，池化可以被认为是由间隔为s像素的池单元网格组成，每个网格汇总一个以池单元位置为中心的大小为z×z的邻域。如果我们设置s = z，我们将得到传统的本地池，就像CNNs中常用的那样。如果我们设置s &lt; z，我们得到重叠池。这是我们在整个网络中使用的，s = 2 z = 3。与非重叠方案s = 2、z = 2相比，该方案将top-1和top-5的错误率分别降低了0.4%和0.3%，产生了等效尺寸的输出。我们通常在训练过程中观察到，具有重叠池的模型发现稍微难以过度匹配。</p> 
<h3>4.5、整体的结构</h3> 
<p>现在我们准备描述CNN的总体架构。如图2所示，网络包含8层权重;前五个是卷积的，其余三个是全连接层。最后一个完全连接层的输出被提供给一个1000路softmax，它产生一个超过1000个类标签的分布。我们的网络将多项式逻辑回归目标最大化，这等价于在预测分布下，将正确标签的log-概率的训练样本均值最大化。</p> 
<p>第二层、第四层和第五层卷积层的内核只连接到上一层连接在同一GPU上的内核映射(见图2)，第三层卷积层的内核连接到第二层的所有内核映射。全连接层的神经元连接到前一层的所有神经元。响应归一化层遵循第一层和第二层卷积。最大池化层(如第4.4节所述)既遵循响应标准化层，也遵循第五个卷积层。每个卷积全连通层的输出均采用ReLU非线性。</p> 
<p>                 <img alt="" class="has" height="319" src="https://images2.imgbox.com/a6/fd/9TjgcTxb_o.png" width="778"></p> 
<p>第一卷积层对大小为11×11×3的96个核的224×224×3输入图像进行滤波，步长为4个像素(这是核映射中相邻神经元感受野中心之间的距离)。第二个卷积层将第一个卷积层的输出(响应归一化和池化)作为输入，使用256个大小为5×5×48的核进行过滤。第三、第四和第五卷积层相互连接，不需要任何池化或标准化层。第三个卷积层有384个大小为3×3×256的内核连接到第二个卷积层的输出(归一化、池化)。第四个卷积层有384个大小为3×3×192的核，第五个卷积层有256个大小为3×3×192的核。完全连接的每一层有4096个神经元。</p> 
<h2>5、减少过拟合</h2> 
<p>我们的神经网络结构有6000万个参数。尽管ILSVRC的1000个类使得每个训练示例对从图像到标签的映射施加10位的约束，但是如果不进行大量的过拟合，学习这么多参数是不够的。下面，我们将描述两种主要的方法来对抗过度拟合。</p> 
<h3>5.1、数据增强</h3> 
<p>减少图像数据过拟合最简单、最常见的方法是使用标签转换来人为地扩大数据集。我们使用了两种不同的数据增强形式，这两种方法都允许从原始图像生成转换后的图像，并且只需要很少的计算，因此转换后的图像不需要存储在磁盘上。在我们的实现中，转换后的图像是在CPU上用Python代码生成的，而GPU正在对前一批图像进行训练。因此，这些数据增强方案实际上是无需计算的。</p> 
<p>数据增强的第一种形式包括生成图像平移和水平反射。我们通过从256×256幅图像中随机抽取224×224个patch(及其水平反射)，并在这些patch上训练我们的网络。这将我们的训练集的大小增加了2048倍，尽管最终的训练示例当然是高度相互依赖的。如果没有这个方案，我们的网络将遭受严重的过度拟合，这将迫使我们使用更小的网络。在测试时，网络通过提取5个224×224个patch(四个角patch和中心patch)及其水平反射(共10个patch)进行预测，并将网络的softmax层对10个patch的预测进行平均。</p> 
<p>第二种形式的数据增强包括改变训练图像中RGB通道的强度。具体来说,我们执行PCA的RGB像素值在整个ImageNet训练集,每个训练图像,我们增加的倍数发现主成分,与相应的特征值大小比例乘以一个来自一个高斯随机变量均值为0和标准偏差0.1。因此对于每个RGB像素<img alt="\large I_{xy}=[ T^R_{xy},T^G_{xy},T^B_{xy}]^T" class="mathcode" height="17" src="https://images2.imgbox.com/45/a7/asMR5qlI_o.gif" width="112">，我们加入下面的数量，</p> 
<p>                                                           <img alt="\large [p_1,p_2,p_3][\alpha_1\lambda_1,\alpha_2\lambda_2,\alpha_2\lambda_2]" class="mathcode" src="https://images2.imgbox.com/25/f8/EqUh5wPB_o.gif"></p> 
<p><img alt="" height="18" src="https://images2.imgbox.com/37/56/CzD8Eufw_o.png" width="15">和<img alt="" height="19" src="https://images2.imgbox.com/9d/fe/WJB37gSH_o.png" width="22">分别是3×3RGB像素值协方差矩阵第i个特征向量和特征值,分别。<img alt="" height="16" src="https://images2.imgbox.com/75/a4/GWHpDFbf_o.png" width="19">是上述随机变量。每个<img alt="" height="15" src="https://images2.imgbox.com/1e/7d/j8ZZDyLZ_o.png" width="18">只画一次像素的一个特定的训练图像,图像是用来训练,此时重新绘制。该方案近似地捕获了自然图像的一个重要特性，即目标标识不受光照强度和颜色变化的影响。该方案将前1位的错误率降低了1%以上。</p> 
<h3>5.2、Droupout</h3> 
<p>结合许多不同模型的预测是一个非常成功的方法来减少测试误差，但是对于已经需要几天时间训练的大型神经网络来说，这似乎太昂贵了。然而，有一个非常有效的模型组合版本，在训练期间只需要花费大约两倍的成本。最近引进的一种叫做“dropout”的技术，将每个隐藏神经元的输出设置为0，概率为0.5。以这种方式“脱落”的神经元不参与正向传递，也不参与反向传播。因此，每次输入被提出时，神经网络都会对不同的体系结构进行采样，但所有这些体系结构都共享权重。 分享这种技术减少了神经元复杂的协同适应，因为神经元不能依赖于特定的其他神经元的存在。因此，它被迫学习与其他神经元的许多不同随机子集一起使用的更健壮的特性。在测试时，我们使用所有的神经元，但将它们的输出乘以0.5，这是一个合理的近似，取由指数型多退出网络产生的预测分布的几何平均值。</p> 
<p>我们在图2的前两个完全连接的层中使用Dropout。没有Dropout，我们的网络表现出明显的过度拟合。Dropout大约是收敛所需迭代次数的两倍。</p> 
<h2>6、学习细节</h2> 
<p>我们使用随机梯度下降训练我们的模型，批量大小为128个例子，动量为0.9，重量衰减为0.0005。我们发现这一小部分的重量衰减对模型的学习很重要。换句话说，这里的重量衰减不仅仅是一个正则化器：它减少了模型的训练误差。权值<img alt="w" class="mathcode" src="https://images2.imgbox.com/bc/f2/VR6hSTwJ_o.png">的更新规则是：                           </p> 
<p>                                         <img alt="\large v_{i+1}:=0.9v_i-0.0005\epsilon w_i-\epsilon \left \langle \frac{\partial L}{\partial w}|_{w_i} \right \rangle_{D_i}" class="mathcode" src="https://images2.imgbox.com/5c/f5/ZTle7Tf4_o.gif"></p> 
<p>                                        <img alt="\large w_{i+1}:=w_i+v_{i+1}" class="mathcode" src="https://images2.imgbox.com/4e/79/IaqDjC9B_o.gif"></p> 
<p><img alt="i" class="mathcode" src="https://images2.imgbox.com/8d/26/5wNXWC2Q_o.png">是迭代索引，<img alt="v" class="mathcode" src="https://images2.imgbox.com/8c/f6/IKzf45yb_o.png">是动量变量，ε是学习速率，<img alt="\large \frac{\partial L}{\partial w}|_{w_i}" class="mathcode" height="27" src="https://images2.imgbox.com/86/5f/OaExnwYy_o.gif" width="31">是目标对w求导的第i批Di的平均值，在<img alt="w_i" class="mathcode" src="https://images2.imgbox.com/f7/db/wSs7eNzn_o.png">处取值。</p> 
<p>我们将每一层的权值初始化为零均值高斯分布，标准差为0.01。我们在第二层、第四层和第五层卷积层以及完全连接的隐藏层中初始化神经元偏差，并使用常数1。这种初始化通过向ReLUs提供积极的输入来加速学习的早期阶段。我们用常数0初始化剩余层中的神经元偏差。</p> 
<p>我们对所有层次使用了相同的学习速度，并在整个训练过程中手动调整。我们采用的启发式方法是将学习速率除以10，当验证错误率停止随当前学习速率改进时。初始化学习率为0.01，终止前降低3次。我们在两台NVIDIA GTX 580 3GB gpu上花了5-6天的时间，通过120万幅图像的训练集，对网络进行了大约90个周期的训练。</p> 
<h2>7、结果</h2> 
<p>我们对ILSVRC-2010的研究结果如表1所示。我们的网络达到了前1名和前5名的测试集错误率分别为37.5%和17.0%。ILSVRC - 2010期间取得最佳性能竞争是47.1%和28.2%,平均方法,预测了从六个sparse-coding模型训练不同的特性,从那以后发表的最好的结果是45.7%和25.7%,平均方法的预测两个分类器训练费舍尔向量(艘)计算从两种类型的密集采样功能。</p> 
<p>我们还在ILSVRC-2012比赛中输入了我们的模型，并将结果报告在表2中。由于ILSVRC-2012测试集标签不是公开可用的，所以我们不能报告我们尝试的所有模型的测试错误率。在这一段的剩余部分，我们交替使用验证和测试错误率，因为根据我们的经验，它们的误差不超过0.1%(见表2)。对5个类似CNNs的预测进行平均，错误率为16.4%。训练一个CNN，在最后一个池层的基础上增加了6个卷积层，对整个ImageNet 2011秋季发行版(1500万张图片，22K个类别)进行分类，然后在ILSVRC-2012上对其进行“finetuning”，出错率为16.6%。在2011年秋季发布的整个版本中，对预先训练的两个CNNs(前面提到的五个CNNs)的预测进行平均，其错误率为15.3%。第二好的参赛作品的错误率为26.2%，其方法是根据不同类型的密集抽样特征计算出在FVs上训练的几个分类器的预测平均值。</p> 
<p>最后，我们还报告了2009年秋季版ImageNet的错误率，该版本包含10184个类别和890万幅图像。在这个数据集上，我们遵循了在文献中使用一半图像用于训练和一半图像用于测试的惯例。由于没有建立测试集，我们的分割必然不同于以前作者使用的分割，但这不会显著影响结果。我们在这个数据集上的前1和前5级错误率分别为67.4%和40.9%，这是通过上面描述的net实现的，但是在最后一个池化层上添加了额外的第6个卷积层。在这个数据集中发表的最佳结果是78.1%和60.9%。</p> 
<h3>7.1、定性评估</h3> 
<p>图3显示了由网络的两个数据连接层学习到的卷积内核。网络已经学会了各种频率和方向选择内核，以及各种颜色的斑点。请注意这两个GPU显示的专门化，这是4.5节中描述的连接受限的结果。GPU 1上的内核在很大程度上是颜色无关的，而GPU 2上的内核在很大程度上是特定于颜色的。这种专门化发生在每次运行期间，并且独立于任何特定的随机权重初始化(模块化GPU的重新编号)。</p> 
<p>在图4的左边面板中，我们定性地评估了网络通过计算它对8张测试图像的前5个预测得到的结果。注意，即使是偏离中心的对象，比如左上角的螨虫，也可以被网络识别。排名前五的大多数品牌似乎都很合理。例如，只有其他类型的猫被认为是豹的合理标签。在某些情况下(格栅，樱桃)，有一个真正的模糊的预期焦点的照片。</p> 
<p>                                         <img alt="" class="has" height="209" src="https://images2.imgbox.com/60/3a/t4bPjJKl_o.png" width="359"></p> 
<p>另一种检测网络视觉知识的方法是考虑最后一个4096维隐层图像的特征激活。如果两幅图像产生的特征激活向量具有小的欧氏分离，我们可以说神经网络的高层认为它们是相似的。图4显示了来自测试集的5幅图像，以及来自训练集的6幅图像，根据这个度量，这6幅图像与每幅图像最相似。注意，在像素级别，检索到的训练图像在L2中通常与第一列中的查询图像不太接近。例如，检索到的狗和大象摆出各种各样的姿势。我们在补充材料中展示了更多测试图像的结果。</p> 
<p>利用两个4096维实值向量之间的欧氏距离计算相似度是低效的，但通过训练一个自动编码器将这些向量压缩成较短的二进制代码可以提高效率。这将产生一个比对原始像素应用自动编码器更好的图像检索方法，原始像素不使用图像标签，因此具有检索具有相似边缘模式的图像的趋势，无论它们在语义上是否相似。</p> 
<p><img alt="" class="has" height="336" src="https://images2.imgbox.com/1e/3b/5gXgluou_o.png" width="676"></p> 
<h2>8、讨论</h2> 
<p>我们的结果表明，一个大的，深入的CNN能够实现破纪录的结果，在一个高度挑战性的数据集上使用纯监督学习。值得注意的是，如果去掉一个卷积层，我们的网络性能就会下降。例如，删除任何中间层都会导致网络的top-1级性能损失约2%。所以深度对于我们取得的成果非常重要。</p> 
<p>为了简化我们的实验，我们没有使用任何无监督的预训练，即使我们期望它会有所帮助，特别是如果我们获得足够的计算能力，在没有获得相应的增加标记数据量的情况下显著增加网络的大小。到目前为止，我们的结果已经有所改善，因为我们已经使我们的网络更大，训练它更久，但我们仍然有许多数量级的去，以匹配人类视觉系统的时间下路径。最后，我们希望在视频序列中使用非常大而深的卷积网络，其中时间结构提供了非常有用的信息，这在静态图像中是不存在的或不太明显的。</p> 
<h2>9、后记</h2> 
<p>电脑视觉界对督导工作的成功反应令人印象深刻。在接下来的一两年里，他们转而使用深度神经网络，现在谷歌、Facebook、微软(Microsoft)、百度和许多其他公司都在广泛使用这种网络。到2015年，更好的硬件、更多的隐藏层以及一系列技术进步将深度卷积神经网络的错误率进一步降低了三倍，使其现在在静态图像上的性能与人类相当接近。大部分功劳这场革命的先驱应该去花了多年开发CNN的技术,但基本缺失的成分是由李飞飞把一个巨大的努力产生标签数据集,终于足以显示神经网络可以做什么。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/393a082f7342accc36edf4d5c2d71d22/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue css 点击按钮进行随机颜色切换 动态</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b404c4bbafd51b7d20bb0d26afbe9fb9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">win11中VMware开启虚拟机电脑蓝屏的解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>