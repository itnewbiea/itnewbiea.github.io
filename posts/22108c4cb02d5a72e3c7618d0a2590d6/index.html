<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java常用17个工具类方法，提升开发效率的“轮子”，避免重复造轮子 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java常用17个工具类方法，提升开发效率的“轮子”，避免重复造轮子" />
<meta property="og:description" content="1. Collections 首先出场的是java.util包下的Collections类，该类主要用于操作集合或者返回集合，我个人非常喜欢用它。
1.1 排序 在工作中经常有对集合排序的需求。
看看使用Collections工具是如何实现升序和降序的：
List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(1); list.add(3); Collections.sort(list);//升序 System.out.println(list); Collections.reverse(list);//降序 System.out.println(list); 执行结果：
[1, 2, 3] [3, 2, 1] 1.2 获取最大或最小值 有时候需要找出集合中的最大值或者最小值，这时可以使用Collections的max和min方法。例如：
List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(1); list.add(3); Integer max = Collections.max(list);//获取最大值 Integer min = Collections.min(list);//获取最小值 System.out.println(max); System.out.println(min); 执行结果：
3 1 1.3 转换线程安全集合 我们都知道，java中的很多集合，比如：ArrayList、LinkedList、HashMap、HashSet等，都是线程不安全的。
换句话说，这些集合在多线程的环境中，添加数据会出现异常。
这时，可以用Collections的synchronizedxxx方法，将这些线程不安全的集合，直接转换成线程安全集合。例如：
List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(1); list.add(3); List&lt;Integer&gt; integers = Collections.synchronizedList(list);//将ArrayList转换成线程安全集合 System.out.println(integers); 它的底层会创建SynchronizedRandomAccessList或者SynchronizedList类，这两个类的很多方法都会用synchronized加锁。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/22108c4cb02d5a72e3c7618d0a2590d6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-29T09:43:18+08:00" />
<meta property="article:modified_time" content="2022-06-29T09:43:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java常用17个工具类方法，提升开发效率的“轮子”，避免重复造轮子</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_Collections_0"></a>1. Collections</h2> 
<p>首先出场的是java.util包下的Collections类，该类主要用于操作集合或者返回集合，我个人非常喜欢用它。</p> 
<h3><a id="11__3"></a>1.1 排序</h3> 
<p>在工作中经常有对集合排序的需求。</p> 
<p>看看使用Collections工具是如何实现升序和降序的：</p> 
<pre><code class="prism language-java">  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//升序</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//降序</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>执行结果：</p> 
<pre><code class="prism language-java"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
</code></pre> 
<h3><a id="12__23"></a>1.2 获取最大或最小值</h3> 
<p>有时候需要找出集合中的最大值或者最小值，这时可以使用Collections的max和min方法。例如：</p> 
<pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> max <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取最大值</span>
<span class="token class-name">Integer</span> min <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取最小值</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>min<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>执行结果：</p> 
<pre><code>3
1
</code></pre> 
<h3><a id="13__41"></a>1.3 转换线程安全集合</h3> 
<p>我们都知道，java中的很多集合，比如：ArrayList、LinkedList、HashMap、HashSet等，都是线程不安全的。</p> 
<p>换句话说，这些集合在多线程的环境中，添加数据会出现异常。</p> 
<p>这时，可以用Collections的synchronizedxxx方法，将这些线程不安全的集合，直接转换成线程安全集合。例如：</p> 
<pre><code>  List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
  list.add(2);
  list.add(1);
  list.add(3);

  List&lt;Integer&gt; integers = Collections.synchronizedList(list);//将ArrayList转换成线程安全集合
  System.out.println(integers);
</code></pre> 
<p>它的底层会创建SynchronizedRandomAccessList或者SynchronizedList类，这两个类的很多方法都会用synchronized加锁。</p> 
<h3><a id="14__58"></a>1.4 返回空集合</h3> 
<p>有时，我们在判空之后，需要返回空集合，就可以使用emptyList方法，例如：</p> 
<pre><code>private List&lt;Integer&gt; fun(List&lt;Integer&gt; list) {
    if (list == null || list.size() == 0) {
        return Collections.emptyList();
    }
    //业务处理
    return list;
}
</code></pre> 
<h3><a id="15__70"></a>1.5 二分查找</h3> 
<p>binarySearch方法提供了一个非常好用的二分查找功能，只用传入指定集合和需要找到的key即可。例如：</p> 
<pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(2);
list.add(1);
list.add(3);

int i = Collections.binarySearch(list, 3);//二分查找
System.out.println(i );
</code></pre> 
<p>执行结果：</p> 
<pre><code>2
</code></pre> 
<h3><a id="16__86"></a>1.6 转换成不可修改集合</h3> 
<p>为了防止后续的程序把某个集合的结果修改了，有时候我们需要把某个集合定义成不可修改的，使用Collections的unmodifiablexxx方法就能轻松实现：</p> 
<pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(2);
list.add(1);
list.add(3);

List&lt;Integer&gt; integers = Collections.unmodifiableList(list);
integers.add(4);
System.out.println(integers);
</code></pre> 
<p>执行结果：</p> 
<pre><code>Exception in thread "main" java.lang.UnsupportedOperationException
 at java.util.Collections$UnmodifiableCollection.add(Collections.java:1055)
 at com.sue.jump.service.test1.UtilTest.main(UtilTest.java:19)
</code></pre> 
<p>当然Collections工具类中还有很多常用的方法，在这里就不一一介绍了，需要你自己去探索。</p> 
<p><img src="https://images2.imgbox.com/4a/12/MqgsTnHm_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d8/5d/BPQc0R0p_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="2_CollectionUtils_112"></a>2. CollectionUtils</h2> 
<p>对集合操作，除了前面说的Collections工具类之后，CollectionUtils工具类也非常常用。</p> 
<p>目前比较主流的是spring的<code>org.springframework.util</code>包下的CollectionUtils工具类。<br> <img src="https://images2.imgbox.com/60/df/goz9VSxU_o.png" alt="在这里插入图片描述"><br> 和<code>apache</code>的org.apache.commons.collections包下的CollectionUtils工具类。<br> <img src="https://images2.imgbox.com/4b/53/knuSDLlo_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/dd/e0/7lqAUyif_o.png" alt="在这里插入图片描述"></p> 
<p><strong>下面我们以apache的CollectionUtils工具类为例</strong>，介绍一下常用方法。</p> 
<h3><a id="21__124"></a>2.1 集合判空</h3> 
<p>通过CollectionUtils工具类的isEmpty方法可以轻松判断集合是否为空，isNotEmpty方法判断集合不为空。</p> 
<pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(2);
list.add(1);
list.add(3);

if (CollectionUtils.isEmpty(list)) {
    System.out.println("集合为空");
}

if (CollectionUtils.isNotEmpty(list)) {
    System.out.println("集合不为空");
}
</code></pre> 
<h3><a id="22__141"></a>2.2 对两个集合进行操作</h3> 
<p>有时候我们需要对已有的两个集合进行操作，比如取交集或者并集等。</p> 
<pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(2);
list.add(1);
list.add(3);

List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();
list2.add(2);
list2.add(4);

//获取并集
Collection&lt;Integer&gt; unionList = CollectionUtils.union(list, list2);
System.out.println(unionList);

//获取交集
Collection&lt;Integer&gt; intersectionList = CollectionUtils.intersection(list, list2);
System.out.println(intersectionList);

//获取交集的补集
Collection&lt;Integer&gt; disjunctionList = CollectionUtils.disjunction(list, list2);
System.out.println(disjunctionList);

//获取差集
Collection&lt;Integer&gt; subtractList = CollectionUtils.subtract(list, list2);
System.out.println(subtractList);
</code></pre> 
<p>执行结果：</p> 
<pre><code>[1, 2, 3, 4]
[2]
[1, 3, 4]
[1, 3]
</code></pre> 
<p>说句实话，对两个集合的操作，在实际工作中用得挺多的，特别是很多批量的场景中。以前我们需要写一堆代码，但没想到有现成的轮子。</p> 
<hr> 
<h2><a id="3_Lists_180"></a>3. Lists</h2> 
<p>如果你引入<code>com.google.guava</code>的pom文件，会获得很多好用的小工具。这里推荐一款com.google.common.collect包下的集合工具：Lists。</p> 
<p>它是在太好用了，让我爱不释手。</p> 
<h3><a id="31__185"></a>3.1 创建空集合</h3> 
<p>有时候，我们想创建一个空集合。这时可以用Lists的newArrayList方法，例如：</p> 
<pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Lists</span><span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="32__191"></a>3.2 快速初始化集合</h3> 
<p>有时候，我们想给一个集合中初始化一些元素。这时可以用Lists的newArrayList方法，例如：</p> 
<pre><code>List&lt;Integer&gt; list = Lists.newArrayList(1, 2, 3);
</code></pre> 
<p>执行结果：</p> 
<pre><code>[1, 2, 3]
</code></pre> 
<h3><a id="33__201"></a>3.3 笛卡尔积</h3> 
<p>如果你想将两个集合做笛卡尔积，Lists的cartesianProduct方法可以帮你实现：</p> 
<pre><code>List&lt;Integer&gt; list1 = Lists.newArrayList(1, 2, 3);
List&lt;Integer&gt; list2 = Lists.newArrayList(4,5);
List&lt;List&lt;Integer&gt;&gt; productList = Lists.cartesianProduct(list1,list2);
System.out.println(productList);
</code></pre> 
<p>执行结果：</p> 
<pre><code>[[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]
</code></pre> 
<h3><a id="34__213"></a>3.4 分页</h3> 
<p>如果你想将一个大集合分成若干个小集合，可以使用Lists的partition方法：</p> 
<pre><code>List&lt;Integer&gt; list = Lists.newArrayList(1, 2, 3, 4, 5);
List&lt;List&lt;Integer&gt;&gt; partitionList = Lists.partition(list, 2);
System.out.println(partitionList);
</code></pre> 
<p>执行结果：</p> 
<pre><code>[[1, 2], [3, 4], [5]]
</code></pre> 
<p>这个例子中，list有5条数据，我将list集合按大小为2，分成了3页，即变成3个小集合。</p> 
<p>这个是我最喜欢的方法之一，经常在项目中使用。</p> 
<p>比如有个需求：现在有5000个id，需要调用批量用户查询接口，查出用户数据。但如果你直接查5000个用户，单次接口响应时间可能会非常慢。如果改成分页处理，每次只查500个用户，异步调用10次接口，就不会有单次接口响应慢的问题。</p> 
<h3><a id="35__230"></a>3.5 流处理</h3> 
<p>如果我们想把某个集合转换成另外一个接口，可以使用Lists的transform方法。例如：</p> 
<pre><code>List&lt;String&gt; list = Lists.newArrayList("a","b","c");
List&lt;String&gt; transformList = Lists.transform(list, x -&gt; x.toUpperCase());
System.out.println(transformList);
</code></pre> 
<p>将小写字母转换成了大写字母。</p> 
<h3><a id="36__239"></a>3.6 颠倒顺序</h3> 
<p>Lists的有颠倒顺序的方法reverse。例如：</p> 
<pre><code>List&lt;Integer&gt; list = Lists.newArrayList(3, 1, 2);
List&lt;Integer&gt; reverseList = Lists.reverse(list);
System.out.println(reverseList);
</code></pre> 
<p>执行结果：</p> 
<pre><code>[2, 1, 3]
</code></pre> 
<p>list的原始顺序是312，使用reverse方法颠倒顺序之后，变成了213。</p> 
<p>Lists还有其他的好用的工具，我在这里只是抛砖引玉，有兴趣的朋友，可以仔细研究一下。</p> 
<p><img src="https://images2.imgbox.com/24/f2/PiC8sr4E_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="4_Objects_258"></a>4. Objects</h2> 
<p>在jdk7之后，提供了Objects工具类，我们可以通过它操作对象。</p> 
<h3><a id="41__261"></a>4.1 对象判空</h3> 
<p>在java中万事万物皆对象，对象的判空可以说无处不在。Objects的isNull方法判断对象是否为空，而nonNull方法判断对象是否不为空。例如：</p> 
<pre><code>Integer integer = new Integer(1);

if (Objects.isNull(integer)) {
    System.out.println("对象为空");
}

if (Objects.nonNull(integer)) {
    System.out.println("对象不为空");
}
</code></pre> 
<h3><a id="42__276"></a>4.2 对象为空抛异常</h3> 
<p>如果我们想在对象为空时，抛出空指针异常，可以使用Objects的requireNonNull方法。例如：</p> 
<pre><code>Integer integer1 = new Integer(128);

Objects.requireNonNull(integer1);
Objects.requireNonNull(integer1, "参数不能为空");
Objects.requireNonNull(integer1, () -&gt; "参数不能为空");
</code></pre> 
<h3><a id="43__286"></a>4.3 判断两个对象是否相等</h3> 
<p>我们经常需要判断两个对象是否相等，Objects给我们提供了equals方法，能非常方便的实现：</p> 
<pre><code>Integer integer1 = new Integer(1);
Integer integer2 = new Integer(1);

System.out.println(Objects.equals(integer1, integer2));
</code></pre> 
<p>执行结果：</p> 
<pre><code>true
</code></pre> 
<p>但使用这个方法有坑，比如例子改成：</p> 
<pre><code>Integer integer1 = new Integer(1);
Long integer2 = new Long(1);

System.out.println(Objects.equals(integer1, integer2));
</code></pre> 
<p>执行结果：</p> 
<pre><code>false
</code></pre> 
<h3><a id="44_hashCode_311"></a>4.4 获取对象的hashCode</h3> 
<p>如果你想获取某个对象的hashCode，可以使用Objects的hashCode方法。例如：</p> 
<pre><code>String str = new String("abc");
System.out.println(Objects.hashCode(str));
</code></pre> 
<p>执行结果：</p> 
<pre><code>96354
</code></pre> 
<p>Objects的内容先介绍到这里，有兴趣的小伙们，可以看看下面更多的方法：</p> 
<p><img src="https://images2.imgbox.com/b3/87/KxSSHNWJ_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="5_BooleanUtils_327"></a>5. BooleanUtils</h3> 
<p>在java中布尔值，随处可见。</p> 
<p>如果你使用了布尔的包装类：Boolean，总感觉有点麻烦，因为它有三种值：null、true、false。我们在处理Boolean对象时，需要经常判空。</p> 
<p>头疼！！！</p> 
<p>但如果使用BooleanUtils类处理布尔值，心情一下子就愉悦起来了。</p> 
<h3><a id="51_truefalse_336"></a>5.1 判断true或false</h3> 
<p>如果你想判断某个参数的值是true或false，可以直接使用isTrue或isFalse方法。例如：</p> 
<pre><code>Boolean aBoolean = new Boolean(true);
System.out.println(BooleanUtils.isTrue(aBoolean));
System.out.println(BooleanUtils.isFalse(aBoolean));
</code></pre> 
<h3><a id="52_truefalse_344"></a>5.2 判断不为true或不为false</h3> 
<p>有时候，需要判断某个参数不为true，即是null或者false。或者判断不为false，即是null或者true。</p> 
<p>可以使用isNotTrue或isNotFalse方法。例如：</p> 
<pre><code>Boolean aBoolean = new Boolean(true);
Boolean aBoolean1 = null;
System.out.println(BooleanUtils.isNotTrue(aBoolean));
System.out.println(BooleanUtils.isNotTrue(aBoolean1));
System.out.println(BooleanUtils.isNotFalse(aBoolean));
System.out.println(BooleanUtils.isNotFalse(aBoolean1));
</code></pre> 
<p>执行结果：</p> 
<pre><code>false
true
true
true
</code></pre> 
<h3><a id="53__364"></a>5.3 转换成数字</h3> 
<p>如果你想将true转换成数字1，false转换成数字0，可以使用toInteger方法：</p> 
<pre><code>Boolean aBoolean = new Boolean(true);
Boolean aBoolean1 = new Boolean(false);
System.out.println(BooleanUtils.toInteger(aBoolean));
System.out.println(BooleanUtils.toInteger(aBoolean1));
</code></pre> 
<p>执行结果：</p> 
<pre><code>1
0
</code></pre> 
<h3><a id="54_Boolean_378"></a>5.4 Boolean转换成布尔值</h3> 
<p>我们有时候需要将包装类Boolean对象，转换成原始的boolean对象，可以使用toBoolean方法。例如：</p> 
<pre><code>Boolean aBoolean = new Boolean(true);
Boolean aBoolean1 = null;
System.out.println(BooleanUtils.toBoolean(aBoolean));
System.out.println(BooleanUtils.toBoolean(aBoolean1));
System.out.println(BooleanUtils.toBooleanDefaultIfNull(aBoolean1, false));
</code></pre> 
<p>我们无需额外的判空了，而且还可以设置Boolean对象为空时返回的默认值。</p> 
<p>BooleanUtils类的方法还有很多，有兴趣的小伙伴可以看看下面的内容：<br> <img src="https://images2.imgbox.com/85/3d/yVK6hGnA_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="6_StringUtils_394"></a>6. StringUtils</h2> 
<p>字符串（String）在我们的日常工作中，用得非常非常非常多。</p> 
<p>在我们的代码中经常需要对字符串判空，截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式等等。</p> 
<p>如果只用String类提供的那些方法，我们需要手写大量的额外代码，不然容易出现各种异常。</p> 
<p>现在有个好消息是：org.apache.commons.lang3包下的StringUtils工具类，给我们提供了非常丰富的选择。</p> 
<h3><a id="61__403"></a>6.1 字符串判空</h3> 
<p>其实空字符串，不只是null一种，还有"“，” "，"null"等等，多种情况。</p> 
<p>StringUtils给我们提供了多个判空的静态方法，例如：</p> 
<pre><code> String str1 = null;
String str2 = "";
String str3 = " ";
String str4 = "abc";
System.out.println(StringUtils.isEmpty(str1));
System.out.println(StringUtils.isEmpty(str2));
System.out.println(StringUtils.isEmpty(str3));
System.out.println(StringUtils.isEmpty(str4));
System.out.println("=====");
System.out.println(StringUtils.isNotEmpty(str1));
System.out.println(StringUtils.isNotEmpty(str2));
System.out.println(StringUtils.isNotEmpty(str3));
System.out.println(StringUtils.isNotEmpty(str4));
System.out.println("=====");
System.out.println(StringUtils.isBlank(str1));
System.out.println(StringUtils.isBlank(str2));
System.out.println(StringUtils.isBlank(str3));
System.out.println(StringUtils.isBlank(str4));
System.out.println("=====");
System.out.println(StringUtils.isNotBlank(str1));
System.out.println(StringUtils.isNotBlank(str2));
System.out.println(StringUtils.isNotBlank(str3));
System.out.println(StringUtils.isNotBlank(str4));
</code></pre> 
<p>执行结果：</p> 
<pre><code>true
true
false
false
=====
false
false
true
true
=====
true
true
true
false
=====
false
false
false
true
</code></pre> 
<p>示例中的：isEmpty、isNotEmpty、isBlank和isNotBlank，这4个判空方法你们可以根据实际情况使用。</p> 
<p>优先推荐使用isBlank和isNotBlank方法，因为它会把" "也考虑进去。</p> 
<h3><a id="62__458"></a>6.2 分隔字符串</h3> 
<p>分隔字符串是常见需求，如果直接使用String类的split方法，就可能会出现空指针异常。</p> 
<pre><code>String str1 = null;
System.out.println(StringUtils.split(str1,","));
System.out.println(str1.split(","));
</code></pre> 
<p>执行结果：</p> 
<pre><code>null
Exception in thread "main" java.lang.NullPointerException
 at com.sue.jump.service.test1.UtilTest.main(UtilTest.java:21)
</code></pre> 
<p>使用StringUtils的split方法会返回null，而使用String的split方法会报指针异常。</p> 
<h3><a id="63__473"></a>6.3 判断是否纯数字</h3> 
<p>给定一个字符串，判断它是否为纯数字，可以使用isNumeric方法。例如：</p> 
<pre><code>String str1 = "123";
String str2 = "123q";
String str3 = "0.33";
System.out.println(StringUtils.isNumeric(str1));
System.out.println(StringUtils.isNumeric(str2));
System.out.println(StringUtils.isNumeric(str3));
</code></pre> 
<p>执行结果：</p> 
<pre><code>true
false
false
</code></pre> 
<h3><a id="64__490"></a>6.4 将集合拼接成字符串</h3> 
<p>有时候，我们需要将某个集合的内容，拼接成一个字符串，然后输出，这时可以使用join方法。例如：</p> 
<pre><code>List&lt;String&gt; list = Lists.newArrayList("a", "b", "c");
List&lt;Integer&gt; list2 = Lists.newArrayList(1, 2, 3);
System.out.println(StringUtils.join(list, ","));
System.out.println(StringUtils.join(list2, " "));
</code></pre> 
<p>执行结果：</p> 
<pre><code>a,b,c
1 2 3
</code></pre> 
<h3><a id="%0Ahttpsimgblogcsdnimgcnd20917e7811947b0b2a62d5161084115png%0Ahttpsimgblogcsdnimgcnd46f6b55ce5747e8b36e7c6ff40c8f21png_503"></a>当然还有很多实用的方法，我在这里就不一一介绍了。<br> <img src="https://images2.imgbox.com/38/30/KC1RBcv7_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/17/77/c1SNa3QH_o.png" alt="在这里插入图片描述"></h3> 
<h2><a id="7_Assert_508"></a>7. Assert</h2> 
<p>很多时候，我们需要在代码中做判断：如果不满足条件，则抛异常。</p> 
<p>有没有统一的封装呢?</p> 
<p>其实spring给我们提供了Assert类，它表示断言。</p> 
<h3><a id="71__515"></a>7.1 断言参数是否为空</h3> 
<p>断言参数是否空，如果不满足条件，则直接抛异常。</p> 
<pre><code>String str = null;
Assert.isNull(str, "str必须为空");
Assert.isNull(str, () -&gt; "str必须为空");
Assert.notNull(str, "str不能为空");
</code></pre> 
<p>如果不满足条件就会抛出IllegalArgumentException异常。</p> 
<h3><a id="72__525"></a>7.2 断言集合是否为空</h3> 
<p>断言集合是否空，如果不满足条件，则直接抛异常。</p> 
<pre><code>List&lt;String&gt; list = null;
Map&lt;String, String&gt; map = null;
Assert.notEmpty(list, "list不能为空");
Assert.notEmpty(list, () -&gt; "list不能为空");
Assert.notEmpty(map, "map不能为空");
</code></pre> 
<p>如果不满足条件就会抛出IllegalArgumentException异常。</p> 
<h3><a id="73__536"></a>7.3 断言条件是否为空</h3> 
<p>断言是否满足某个条件，如果不满足条件，则直接抛异常。</p> 
<pre><code>List&lt;String&gt; list = null;
Assert.isTrue(CollectionUtils.isNotEmpty(list), "list不能为空");
Assert.isTrue(CollectionUtils.isNotEmpty(list), () -&gt; "list不能为空");
</code></pre> 
<p>当然Assert类还有一些其他的功能，这里就不多介绍了。</p> 
<h3><a id="httpsimgblogcsdnimgcn6177c625a77b4f409217b7a57a9e5647png_545"></a><img src="https://images2.imgbox.com/08/e0/Y8dgYuRT_o.png" alt="在这里插入图片描述"></h3> 
<h2><a id="8_IOUtils_548"></a>8. IOUtils</h2> 
<p>IO流在我们日常工作中也用得比较多，尽管java已经给我们提供了丰富的API。</p> 
<p>但我们不得不每次读取文件，或者写入文件之后，写一些重复的的代码。手动在finally代码块中关闭流，不然可能会造成内存溢出。</p> 
<p>有个好消息是：如果你使用org.apache.commons.io包下的IOUtils类，会节省大量的时间。</p> 
<h3><a id="81__555"></a>8.1 读取文件</h3> 
<p>如果你想将某个txt文件中的数据，读取到字符串当中，可以使用IOUtils类的toString方法。例如：</p> 
<pre><code>String str = IOUtils.toString(new FileInputStream("/temp/a.txt"), StandardCharsets.UTF_8);
System.out.println(str);
</code></pre> 
<h3><a id="82__563"></a>8.2 写入文件</h3> 
<p>如果你想将某个字符串的内容，写入到指定文件当中，可以使用IOUtils类的write方法。例如：</p> 
<pre><code>String str = "abcde";
IOUtils.write(str, new FileOutputStream("/temp/b.tx"), StandardCharsets.UTF_8);
</code></pre> 
<h3><a id="83__569"></a>8.3 文件拷贝</h3> 
<p>如果你想将某个文件中的所有内容，都拷贝到另一个文件当中，可以使用IOUtils类的copy方法。例如：</p> 
<pre><code>IOUtils.copy(new FileInputStream("/temp/a.txt"), new FileOutputStream("/temp/b.txt"));
</code></pre> 
<h3><a id="84__574"></a>8.4 读取文件内容到字节数组</h3> 
<p>如果你想将某个文件中的内容，读取字节数组中，可以使用IOUtils类的toByteArray方法。例如：</p> 
<pre><code>byte[] bytes = IOUtils.toByteArray(new FileInputStream("/temp/a.txt"));
</code></pre> 
<p>IOUtils类非常实用，感兴趣的小伙们，可以看看下面内容。</p> 
<p><img src="https://images2.imgbox.com/c7/5c/Gldek4ia_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="9_MDC_586"></a>9. MDC</h2> 
<p>MDC是org.slf4j包下的一个类，它的全称是Mapped Diagnostic Context，我们可以认为它是一个线程安全的存放诊断日志的容器。</p> 
<p>MDC的底层是用了ThreadLocal来保存数据的。</p> 
<p>我们可以用它传递参数。</p> 
<p>例如现在有这样一种场景：我们使用RestTemplate调用远程接口时，有时需要在header中传递信息，比如：traceId，source等，便于在查询日志时能够串联一次完整的请求链路，快速定位问题。</p> 
<p>这种业务场景就能通过ClientHttpRequestInterceptor接口实现，具体做法如下：</p> 
<p>第一步，定义一个LogFilter拦截所有接口请求，在MDC中设置traceId：</p> 
<pre><code>public class LogFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        MdcUtil.add(UUID.randomUUID().toString());
        System.out.println("记录请求日志");
        chain.doFilter(request, response);
        System.out.println("记录响应日志");
    }

    @Override
    public void destroy() {
    }
}
</code></pre> 
<p>第二步，实现ClientHttpRequestInterceptor接口，MDC中获取当前请求的traceId，然后设置到header中：</p> 
<pre><code>public class RestTemplateInterceptor implements ClientHttpRequestInterceptor {

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {
        request.getHeaders().set("traceId", MdcUtil.get());
        return execution.execute(request, body);
    }
}
</code></pre> 
<p>第三步，定义配置类，配置上面定义的RestTemplateInterceptor类：</p> 
<pre><code>@Configuration
public class RestTemplateConfiguration {

    @Bean
    public RestTemplate restTemplate() {
        RestTemplate restTemplate = new RestTemplate();
        restTemplate.setInterceptors(Collections.singletonList(restTemplateInterceptor()));
        return restTemplate;
    }

    @Bean
    public RestTemplateInterceptor restTemplateInterceptor() {
        return new RestTemplateInterceptor();
    }
}
</code></pre> 
<p>其中MdcUtil其实是利用MDC工具在ThreadLocal中存储和获取traceId</p> 
<pre><code>public class MdcUtil {

    private static final String TRACE_ID = "TRACE_ID";

    public static String get() {
        return MDC.get(TRACE_ID);
    }

    public static void add(String value) {
        MDC.put(TRACE_ID, value);
    }
}
</code></pre> 
<p>当然，这个例子中没有演示MdcUtil类的add方法具体调的地方，我们可以在filter中执行接口方法之前，生成traceId，调用MdcUtil类的add方法添加到MDC中，然后在同一个请求的其他地方就能通过MdcUtil类的get方法获取到该traceId。</p> 
<p>能使用MDC保存traceId等参数的根本原因是，用户请求到应用服务器，Tomcat会从线程池中分配一个线程去处理该请求。</p> 
<p>那么该请求的整个过程中，保存到MDC的ThreadLocal中的参数，也是该线程独享的，所以不会有线程安全问题。</p> 
<hr> 
<h2><a id="10_ClassUtils_669"></a>10. ClassUtils</h2> 
<p>spring的org.springframework.util包下的ClassUtils类，它里面有很多让我们惊喜的功能。</p> 
<p>它里面包含了类和对象相关的很多非常实用的方法。</p> 
<h3><a id="101__674"></a>10.1 获取对象的所有接口</h3> 
<p>如果你想获取某个对象的所有接口，可以使用ClassUtils的getAllInterfaces方法。例如：</p> 
<pre><code>Class&lt;?&gt;[] allInterfaces = ClassUtils.getAllInterfaces(new User());
</code></pre> 
<h3><a id="102__679"></a>10.2 获取某个类的包名</h3> 
<p>如果你想获取某个类的包名，可以使用ClassUtils的getPackageName方法。例如：</p> 
<pre><code>String packageName = ClassUtils.getPackageName(User.class);
System.out.println(packageName);
</code></pre> 
<h3><a id="103__686"></a>10.3 判断某个类是否内部类</h3> 
<p>如果你想判断某个类是否内部类，可以使用ClassUtils的isInnerClass方法。例如：</p> 
<pre><code>System.out.println(ClassUtils.isInnerClass(User.class));
</code></pre> 
<h3><a id="104__692"></a>10.4 判断对象是否代理对象</h3> 
<p>如果你想判断对象是否代理对象，可以使用ClassUtils的isCglibProxy方法。例如：</p> 
<pre><code>System.out.println(ClassUtils.isCglibProxy(new User()));
</code></pre> 
<p>ClassUtils还有很多有用的方法，等待着你去发掘。感兴趣的朋友，可以看看下面内容：</p> 
<p><img src="https://images2.imgbox.com/b8/0e/cASOSAYd_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="11_BeanUtils_704"></a>11. BeanUtils</h2> 
<p>spring给我们提供了一个JavaBean的工具类，它在org.springframework.beans包下面，它的名字叫做：BeanUtils。</p> 
<p>让我们一起看看这个工具可以带给我们哪些惊喜。</p> 
<h3><a id="111__709"></a>11.1 拷贝对象的属性</h3> 
<p>曾几何时，你有没有这样的需求：把某个对象中的所有属性，都拷贝到另外一个对象中。这时就能使用BeanUtils的copyProperties方法。例如：</p> 
<pre><code>User user1 = new User();
user1.setId(1L);
user1.setName("苏三说技术");
user1.setAddress("成都");

User user2 = new User();
BeanUtils.copyProperties(user1, user2);
System.out.println(user2);
</code></pre> 
<h3><a id="112__722"></a>11.2 实例化某个类</h3> 
<p>如果你想通过反射实例化一个类的对象，可以使用BeanUtils的instantiateClass方法。例如：</p> 
<pre><code>User user = BeanUtils.instantiateClass(User.class);
System.out.println(user);
</code></pre> 
<h3><a id="113__729"></a>11.3 获取指定类的指定方法</h3> 
<p>如果你想获取某个类的指定方法，可以使用BeanUtils的findDeclaredMethod方法。例如：</p> 
<pre><code>Method declaredMethod = BeanUtils.findDeclaredMethod(User.class, "getId");
System.out.println(declaredMethod.getName());
</code></pre> 
<h3><a id="114__736"></a>11.4 获取指定方法的参数</h3> 
<p>如果你想获取某个方法的参数，可以使用BeanUtils的findPropertyForMethod方法。例如：</p> 
<pre><code>Method declaredMethod = BeanUtils.findDeclaredMethod(User.class, "getId");
PropertyDescriptor propertyForMethod = BeanUtils.findPropertyForMethod(declaredMethod);
System.out.println(propertyForMethod.getName());
</code></pre> 
<p>如果你对BeanUtils比较感兴趣，可以看看下面内容：<br> <img src="https://images2.imgbox.com/0f/c5/XVHNnTha_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="12_ReflectionUtils_748"></a>12. ReflectionUtils</h2> 
<p>有时候，我们需要在项目中使用反射功能，如果使用最原始的方法来开发，代码量会非常多，而且很麻烦，它需要处理一大堆异常以及访问权限等问题。</p> 
<p>好消息是spring给我们提供了一个ReflectionUtils工具，它在org.springframework.util包下面。</p> 
<h3><a id="121__753"></a>12.1 获取方法</h3> 
<p>如果你想获取某个类的某个方法，可以使用ReflectionUtils类的findMethod方法。例如：</p> 
<pre><code>Method method = ReflectionUtils.findMethod(User.class, "getId");
</code></pre> 
<h3><a id="122__758"></a>12.2 获取字段</h3> 
<p>如果你想获取某个类的某个字段，可以使用ReflectionUtils类的findField方法。例如：</p> 
<pre><code>Field field = ReflectionUtils.findField(User.class, "id");
</code></pre> 
<h3><a id="123__764"></a>12.3 执行方法</h3> 
<p>如果你想通过反射调用某个方法，传递参数，可以使用ReflectionUtils类的invokeMethod方法。例如：</p> 
<pre><code> ReflectionUtils.invokeMethod(method, springContextsUtil.getBean(beanName), param);
</code></pre> 
<h3><a id="124__769"></a>12.4 判断字段是否常量</h3> 
<p>如果你想判断某个字段是否常量，可以使用ReflectionUtils类的isPublicStaticFinal方法。例如：</p> 
<pre><code>Field field = ReflectionUtils.findField(User.class, "id");
System.out.println(ReflectionUtils.isPublicStaticFinal(field));
</code></pre> 
<h4><a id="125_equals_775"></a>12.5 判断是否equals方法</h4> 
<p>如果你想判断某个方法是否equals方法，可以使用ReflectionUtils类的isEqualsMethod方法。例如：</p> 
<pre><code>Method method = ReflectionUtils.findMethod(User.class, "getId");
System.out.println(ReflectionUtils.isEqualsMethod(method));
</code></pre> 
<p>当然这个类还有不少有趣的方法，感兴趣的朋友，可以看看下面内容：</p> 
<h3><a id="httpsimgblogcsdnimgcn4d79e8d5951d431494e69a9f419c3b7dpng_783"></a><img src="https://images2.imgbox.com/58/5d/oFWhqBeE_o.png" alt="在这里插入图片描述"></h3> 
<h2><a id="13_Base64Utils_786"></a>13. Base64Utils</h2> 
<p>有时候，为了安全考虑，需要将参数只用base64编码。</p> 
<p>这时就能直接使用org.springframework.util包下的Base64Utils工具类。</p> 
<p>它里面包含：encode和decode方法，用于对数据进行加密和解密。例如：</p> 
<pre><code>String str = "abc";
String encode = new String(Base64Utils.encode(str.getBytes()));
System.out.println("加密后：" + encode);
try {
    String decode = new String(Base64Utils.decode(encode.getBytes()), "utf8");
    System.out.println("解密后：" + decode);
} catch (UnsupportedEncodingException e) {
    e.printStackTrace();
}
</code></pre> 
<p>执行结果：</p> 
<pre><code>加密后：YWJj
解密后：abc
</code></pre> 
<hr> 
<h2><a id="14_StandardCharsets_810"></a>14. StandardCharsets</h2> 
<p>我们在做字符转换的时候，经常需要指定字符编码，比如：UTF-8、ISO-8859-1等等。</p> 
<p>这时就可以直接使用java.nio.charset包下的StandardCharsets类中静态变量。</p> 
<p>例如：</p> 
<pre><code>String str = "abc";
String encode = new String(Base64Utils.encode(str.getBytes()));
System.out.println("加密后：" + encode);
String decode = new String(Base64Utils.decode(encode.getBytes())
, StandardCharsets.UTF_8);
System.out.println("解密后：" + decode);
</code></pre> 
<hr> 
<h2><a id="15_DigestUtils_827"></a>15. DigestUtils</h2> 
<p>有时候，我们需要对数据进行加密处理，比如：md5或sha256。</p> 
<p>可以使用apache的org.apache.commons.codec.digest包下的DigestUtils类。</p> 
<h3><a id="151_md5_832"></a>15.1 md5加密</h3> 
<p>如果你想对数据进行md5加密，可以使用DigestUtils的md5Hex方法。例如：</p> 
<pre><code>String md5Hex = DigestUtils.md5Hex("苏三说技术");
System.out.println(md5Hex);
</code></pre> 
<h3><a id="152_sha256_839"></a>15.2 sha256加密</h3> 
<p>如果你想对数据进行sha256加密，可以使用DigestUtils的sha256Hex方法。例如：</p> 
<pre><code>String md5Hex = DigestUtils.sha256Hex("苏三说技术");
System.out.println(md5Hex);
</code></pre> 
<p>当然这个工具还有很多其他的加密方法：</p> 
<hr> 
<h2><a id="16_SerializationUtils_850"></a>16. SerializationUtils</h2> 
<p>有时候，我们需要把数据进行序列化和反序列化处理。</p> 
<p>传统的做法是某个类实现Serializable接口，然后重新它的writeObject和readObject方法。</p> 
<p>但如果使用org.springframework.util包下的SerializationUtils工具类，能更轻松实现序列化和反序列化功能。例如：</p> 
<pre><code>Map&lt;String, String&gt; map = Maps.newHashMap();
map.put("a", "1");
map.put("b", "2");
map.put("c", "3");
byte[] serialize = SerializationUtils.serialize(map);
Object deserialize = SerializationUtils.deserialize(serialize);
System.out.println(deserialize);
</code></pre> 
<hr> 
<h2><a id="17_HttpStatus_867"></a>17. HttpStatus</h2> 
<p>很多时候，我们会在代码中定义http的返回码，比如：接口正常返回200，异常返回500，接口找不到返回404，接口不可用返回502等。</p> 
<pre><code>private int SUCCESS_CODE = 200;
private int ERROR_CODE = 500;
private int NOT_FOUND_CODE = 404;
</code></pre> 
<p>其实org.springframework.http包下的HttpStatus枚举，或者org.apache.http包下的HttpStatus接口，已经把常用的http返回码给我们定义好了，直接拿来用就可以了，真的不用再重复定义了。</p> 
<p><img src="https://images2.imgbox.com/ca/71/30jfmJyg_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a708cf2b249f4bdf24a1344be37c4c45/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">泛微移动端数据库 ：H2数据库</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ba1dfd3356a1446711b446930096ca60/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">computeIfAbsent()和computeIfPresent</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>