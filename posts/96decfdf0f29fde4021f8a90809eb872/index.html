<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ElasticSearch常用查询操作 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ElasticSearch常用查询操作" />
<meta property="og:description" content="ES查询 一般我们使用ES最多的就是查询，今天就讲一下ES的查询。这里我是建了一个person的索引。
&#34;person&#34; : { &#34;aliases&#34; : { }, &#34;mappings&#34; : { &#34;properties&#34; : { &#34;address&#34; : { &#34;type&#34; : &#34;text&#34;, &#34;fields&#34; : { &#34;keyword&#34; : { &#34;type&#34; : &#34;keyword&#34;, &#34;ignore_above&#34; : 256 } } }, &#34;age&#34; : { &#34;type&#34; : &#34;long&#34; }, &#34;name&#34; : { &#34;type&#34; : &#34;text&#34;, &#34;fields&#34; : { &#34;keyword&#34; : { &#34;type&#34; : &#34;keyword&#34;, &#34;ignore_above&#34; : 256 } } } } } 基本查询操作 1.查询所有数据并进行排序 GET person/_search { &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/96decfdf0f29fde4021f8a90809eb872/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-16T15:51:49+08:00" />
<meta property="article:modified_time" content="2023-04-16T15:51:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ElasticSearch常用查询操作</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>ES查询</h3> 
<p>     一般我们使用ES最多的就是查询，今天就讲一下ES的查询。这里我是建了一个person的索引。</p> 
<pre><code class="hljs">"person" : {
    "aliases" : { },
    "mappings" : {
      "properties" : {
        "address" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        },
        "age" : {
          "type" : "long"
        },
        "name" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        }
      }
    }</code></pre> 
<h3>基本查询操作</h3> 
<h4>1.查询所有数据并进行排序</h4> 
<pre><code class="hljs">GET person/_search
{
  "query":{
    "match_all": {}
  },
  "sort":{
    "age":"desc"
  }
}</code></pre> 
<p>说明：这里是一个GET请求，person代表索引，_search表示搜索(固定写法)。</p> 
<p>"query"表示查询。“match_all”表示查询所有。后面的sort就表示要对查询结果进行排序。age 表示要排序的字段。而desc表示降序排序。asc升序排序。</p> 
<p><img alt="" height="558" src="https://images2.imgbox.com/6a/df/Pa2ai1D7_o.png" width="1163"></p> 
<p> 结果说明：took表示查询花费时间(ms)，_shards分片信息。搜索了多少个分片。hits查询结果，tatoal.value搜索到了几个文档。</p> 
<h4>2.分页查询</h4> 
<p>主要就是用到一个from(第几页)，size(每页大小)。</p> 
<pre><code class="hljs">GET person/_search
{
  "query":{
    "match_all": {}
  },
  "sort":{
    "age":"desc"
  },
  "from":1,
  "size":1
}</code></pre> 
<h4>3.查询段落匹配</h4> 
<p>比如我们想查某个字段里面包好了某个字符串的话，就可以使用这种查询。比如我想查地址里面包含疾风的数据。</p> 
<pre><code class="hljs">GET person/_search
{
  "query":{
    "match_phrase": {
      "address": "疾风"
    }
  }
}</code></pre> 
<p><img alt="" height="611" src="https://images2.imgbox.com/4f/2c/CPVhBccj_o.png" width="1059"> </p> 
<h3>复合查询 </h3> 
<h4>1.多条件bool查询</h4> 
<p>通过布尔将较小的查询组合成大的查询。</p> 
<p>如果存在多个查询条件就需要用到这种查询。比如我要查年龄为23岁，并且地址不在海南的人。这里查询注意格式，方括号大括号不能少，这是我觉得比较难受的一个点。</p> 
<pre><code class="hljs">GET person/_search
{
  "query":{
    "bool":{
      "must":[
        {"match":{"age":"23"}}
        ],
      "must_not": [
        {"match": {
          "address": "海南"
        }}
      ]
    }
  }
}</code></pre> 
<p>bool表示这是一个布尔查询，must和must_not表示必须满足和不满足，而里面的就是条件，必须匹配条件为年龄23，且地址不为海南的人。</p> 
<p><img alt="" height="599" src="https://images2.imgbox.com/62/17/hYhmZjl9_o.png" width="1006"></p> 
<p>特点：</p> 
<ul><li> <p>子查询可以任意顺序出现。</p> </li><li> <p>可以嵌套多个查询，包括布尔查询</p> </li></ul> 
<p>除了上面的must和must_not，还有should(选择性匹配至少满足一条)，filter过滤，必须匹配。</p> 
<h3>全文搜索</h3> 
<h4>1.Match类型</h4> 
<p>使用match全文搜索</p> 
<pre><code class="hljs">GET person/_search
{
  "query": {
    "match": {
      "name": "冯"
    }
  }
}</code></pre> 
<p>这个查询首先回去判断name是text类型，text类型是会被分词的，那么查询字符串本身也会被分词。然后查询字符串会被传入标准分析器中，因为自由一个字所以这个查询的底层是单个的term查询。term查询会计算每个文档的相关度评分_score，如果是多个汉字是怎样？</p> 
<pre><code class="hljs">GET person/_search
{
  "query": {
    "match": {
      "name": "老板"
    }
  }
}</code></pre> 
<p> 结果：</p> 
<p><img alt="" height="818" src="https://images2.imgbox.com/db/cf/FM7eDcDk_o.png" width="1200"></p> 
<p>这里我并没有安装新的分词器，默认是一个汉字分成一个词。他可以等同如下查询：</p> 
<p><img alt="" height="616" src="https://images2.imgbox.com/72/41/f6kzj5xk_o.png" width="1200"> </p> 
<p>他等同于should的两个term查询，只要满足任意一个就可以。其实match还有一个operator参数，默认是or，所以should也能查询出来，如果改成and就是需要同时满足.</p> 
<p><img alt="" height="830" src="https://images2.imgbox.com/26/f8/gqVhHq2l_o.png" width="1200"> 等同于：</p> 
<p><img alt="" height="757" src="https://images2.imgbox.com/b2/93/M19yIgS0_o.png" width="1174"></p> 
<h4>2.quert string类型</h4> 
<p>首先看例子</p> 
<pre><code class="hljs">GET person/_search
{
  "query": {
    "query_string": {
      "default_field": "address",  
      "query": " 疾风 OR 达州"
    }
  }
}</code></pre> 
<p><img alt="" height="786" src="https://images2.imgbox.com/eb/6b/CNHD71W1_o.png" width="650"> </p> 
<p>        </p> 
<pre><code class="hljs">GET person/_search
{
  "query": {
    "query_string": {
      "default_field": "address",
      "query": "疾风 AND 归途"
    }
  }
}</code></pre> 
<p><img alt="" height="605" src="https://images2.imgbox.com/cd/3a/naBiL576_o.png" width="515"> </p> 
<p>上面两个查询仔细看很容易理解，query_string查询就是 根据运算符(and 或者 or)来解析和拆分字符串。然后查询在返回匹配的文档前独立分析每个拆分的文本。</p> 
<p>除了这些查询外还有许多其他查询方式，这里这是讲了一种，以后再使用其他的时候可以对照理解。</p> 
<h3>term查询</h3> 
<h4>1.基于单词的查询，基于id查询。</h4> 
<pre><code class="hljs">GET person/_search
{
  "query": {
    "ids":{
      "values":[1,2,3]
    }
  }
}</code></pre> 
<h4>2.通过前缀查询</h4> 
<pre><code class="hljs">GET person/_search
{
  "query": {
    "prefix": {
      "name": {
        "value": "冯"
      }
    }
  }
}</code></pre> 
<p><img alt="" height="553" src="https://images2.imgbox.com/5f/72/jMRMpiMX_o.png" width="1200"></p> 
<h4>3.分词匹配查询</h4> 
<pre><code class="hljs">GET person/_search
{
  "query": {
    "term": {
      "name": {
        "value": "老"
      }
    }
  }
}</code></pre> 
<h4><img alt="" height="675" src="https://images2.imgbox.com/40/4a/sEFMu0jz_o.png" width="1200"> </h4> 
<p>多个分词匹配</p> 
<p>这里我之前在项目代码里面遇到过，查询对接人通过职位编码来进行匹配，利用了这种查询。还是比较多用的</p> 
<pre><code class="hljs">GET person/_search
{
  "query": {
    "terms": {
      "name": [
        "冯",
        "陈"
      ]
    }
  }
}</code></pre> 
<p> <img alt="" height="547" src="https://images2.imgbox.com/d7/5c/RoCkpFjq_o.png" width="1200"></p> 
<h4>4.通配符：wildcard</h4> 
<pre><code class="hljs">GET person/_search
{
  "query": {
    "wildcard": {
      "name": {
        "value": "冯*"
      }
    }
  }
}</code></pre> 
<h4> 范围查询</h4> 
<pre><code class="hljs">GET person/_search
{
  "query": {
    "range": {
      "age": {
        "gte": 20,
        "lte": 30
      }
    }
  }
}</code></pre> 
<h4>5.正则：regexp</h4> 
<pre><code class="hljs">get person/_search
{
  "query":{
    "regexp": {
      "name": "冯*"
    }
  }
}</code></pre> 
<h4>6.模糊匹配：fuzzy</h4> 
<pre><code class="hljs">get person/_search
{
  "query":{
    "fuzzy": {
      "address": {
        "value": "疾"
      }
    }
  }
}</code></pre> 
<h4>聚合查询</h4> 
<p>聚合查询就是类似我们在SQL中的group by。聚合查询中有两个概念，一个是桶：满足特定条件的文档的集合。还有一个是指标：就是对桶内的文档进行统计计算。所以在ES里面有三种聚合方式：</p> 
<p>1.桶聚合</p> 
<p>2.指标聚合</p> 
<p>3.管道聚合</p> 
<p>首先准备一批数据：</p> 
<pre><code class="hljs">POST /test-agg-cars/_bulk
{ "index": {}}
{ "price" : 10000, "color" : "red", "make" : "honda", "sold" : "2014-10-28" }
{ "index": {}}
{ "price" : 20000, "color" : "red", "make" : "honda", "sold" : "2014-11-05" }
{ "index": {}}
{ "price" : 30000, "color" : "green", "make" : "ford", "sold" : "2014-05-18" }
{ "index": {}}
{ "price" : 15000, "color" : "blue", "make" : "toyota", "sold" : "2014-07-02" }
{ "index": {}}
{ "price" : 12000, "color" : "green", "make" : "toyota", "sold" : "2014-08-19" }
{ "index": {}}
{ "price" : 20000, "color" : "red", "make" : "honda", "sold" : "2014-11-05" }
{ "index": {}}
{ "price" : 80000, "color" : "red", "make" : "bmw", "sold" : "2014-01-01" }
{ "index": {}}
{ "price" : 25000, "color" : "blue", "make" : "ford", "sold" : "2014-02-12" }</code></pre> 
<h4>1.标准聚合</h4> 
<p>比如说我们想得到每个颜色的销量</p> 
<pre><code class="hljs">GET test-agg-cars/_search
{
  "size":0,    							//siz指定为0，hits不会返回搜索结果
  "aggs": {     						//聚合查询
    "pop_colors": {         //为聚合查询的结果指定一个想要的名称
      "terms": { 						//定义桶的类型为terms（桶：满足特定条件的文档集合）
        "field": "color.keyword"   //每个桶的key都与color字段里找到的唯一词对应
      }
    }
  }
}</code></pre> 
<p>查询结果：</p> 
<p><img alt="" height="605" src="https://images2.imgbox.com/eb/d0/87ER9lob_o.png" width="1200"></p> 
<p>doc_count告诉我们每个包含该词项的文档数量。</p> 
<h4>2.多个聚合</h4> 
<p>计算两种桶的结果</p> 
<pre><code class="hljs">GET /test-agg-cars/_search
{
  "size": 0,
  "aggs":{
    "pop_colors":{
      "terms": {
        "field": "color.keyword"
      }
    },
    "make_by":{
      "terms": {
        "field": "make.keyword"
      }
    }
  }
}</code></pre> 
<p> 查询结果</p> 
<p><img alt="" height="827" src="https://images2.imgbox.com/2d/08/i0e0ii0z_o.png" width="1200"></p> 
<h4>3.聚合嵌套</h4> 
<p>比如我们要查询每种颜色的平均价格，首先使用聚合查询每种颜色，然后再嵌套一个聚合查询每种颜色的平均价格。</p> 
<pre><code class="hljs">GET test-agg-cars/_search
{
  "size": 0,
  "aggs": {
    "colors": {
      "terms": {
        "field": "color.keyword"
      },
    "aggs":{
      "avg_price":{
        "avg": {
          "field": "price"
        }
      }
    }
  }
}
}</code></pre> 
<p>查询结果：</p> 
<h4><img alt="" height="798" src="https://images2.imgbox.com/11/be/O2PjpQzx_o.png" width="1125"> 4.前置过滤条件：filter</h4> 
<p>比如我们只想查某一个类型的平均价格，可以先使用filter过滤出来，然后再使用一个嵌套聚合计算平均价格。</p> 
<pre><code class="hljs">GET test-agg-cars/_search
{
  "size": 0,
  "aggs":{
    "make_by":{
      "filter": {
        "term": {
          "make": "honda"
        }
      },
      "aggs": {
        "avg_price": {
          "avg": {
            "field": "price"
          }
        }
      }
    }
  }
}</code></pre> 
<p>查询结果：</p> 
<h4><img alt="" height="582" src="https://images2.imgbox.com/04/de/X9c2GX33_o.png" width="954"> 5.对number类型聚合：range</h4> 
<p>查询某一个范围。</p> 
<pre><code class="hljs">{
  "size":0,
  "aggs": {
    "price_ranges": {
      "range": {
        "field": "price",
        "ranges": [
          {
            "from": 10000,
            "to": 15000
          }
        ]
      }
    }
  }
}</code></pre> 
<p>结果：</p> 
<h4><img alt="" height="636" src="https://images2.imgbox.com/bc/44/xZ0AvPZg_o.png" width="1146"> 6.对日期类型聚合</h4> 
<p>我觉得这种聚合查询应用的场景会比较多。查询某个时间范围内的数据。</p> 
<pre><code class="hljs">GET test-agg-cars/_search
{
  "size":0,
  "aggs": {
    "range": {
      "date_range": {
        "field": "sold",
        "ranges": [
          {
            "from": "2014-10-28",
            "to": "2014-11-05"
          }
        ]
      }
    }
  }
}</code></pre> 
<p>结果：</p> 
<p><img alt="" height="685" src="https://images2.imgbox.com/8f/19/s9aWPJDA_o.png" width="1168"> </p> 
<h3>聚合查询之metric聚合</h3> 
<p>metric聚合从分类上来看，可以分为单值分析和多值分析。</p> 
<ul><li> <p>单值分析就是只输出一个分析结果，标准的stat型。</p> </li></ul> 
<p>1.avg 平均值</p> 
<p>2.max 最大值</p> 
<p>3.min 最小值</p> 
<p>4.sum 和</p> 
<p>5.value_count 数量</p> 
<p>其他类型 cardinality记述(distinct去重)，weighted_avg 带权重的avg。。。</p> 
<ul><li> <p>多值分析</p> <p>省略，因为我觉得不是很常用，到时候会查文档就行。</p> </li></ul> 
<p>单值分析</p> 
<p>avg平均值：计算平均值</p> 
<pre><code class="hljs">GET person/_search
{
  "size": 0, 
  "aggs":{
    "avg_age":{
      "avg": {
        "field": "age"
      }
    }
  }
}
//返回结果
 "aggregations" : {
    "avg_age" : {
      "value" : 30.857142857142858
    }
  }</code></pre> 
<p>max最大值：</p> 
<pre><code class="hljs">GET person/_search
{
  "size":0,
  "aggs": {
    "max_age": {
      "max": {
        "field": "age"
      }
    }
  }
}
//返回结果
 "aggregations" : {
    "max_age" : {
      "value" : 40.0
 }</code></pre> 
<p>min最小值：与最大值类似</p> 
<p>sum求和：</p> 
<pre><code class="hljs">GET person/_search
{
  "size":0,
  "aggs": {
    "sum_age": {
      "sum": {
        "field": "age"
      }
    }
  }
}
//返回结果
  "aggregations" : {
    "sum_age" : {
      "value" : 216.0
    }
  }</code></pre> 
<p>Value_count数量</p> 
<pre><code class="hljs">GET person/_search?size=0
{
  "aggs": {
    "name_count": {
      "value_count": {
        "field": "age"
      }
    }
  }
}
//返回结果
  "aggregations" : {
    "sum_age" : {
      "value" : 216.0
    }
  }</code></pre> 
<p> 目前就简单介绍了这些查询，其实在es官网可以看到很多不同的查询，包括管道啥之类的，但是我们以后使用的时候要知道大致的查询分为哪几类，然后每种查询得能在官网快速定位，然后通过例子学会使用并理解。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/04a6873099594ff081d79f52fed289f1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">24 谈谈内存映射文件mmap</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6e079235657ff907e96f1cdbfbfcaffe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java导出生成word文档并进行下载的方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>