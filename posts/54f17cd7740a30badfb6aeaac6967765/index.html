<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入理解操作系统- - 进程篇（1） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深入理解操作系统- - 进程篇（1）" />
<meta property="og:description" content="目录
进程解释：
process in memory(进程在内存中包含什么) :
并发的进程：
进程定义：
个人定义：
书本定义：
进程状态：
进程何时离开CPU：
内部事件：
外部事件：
进程切换：
中断源：
特权指令和非特权指令：
模式切换：
进程切换：
进程控制块：
进程在物理内存中：
进程调度：
实验篇
进程解释： 1)A program(程序) is a passive entity（被动的实体） , such as a file containing a list of instructions stored on disk(often called an executable file--可执行文件 ).---例如一个文件包含一列指令存储在磁盘 2)A program becomes a process when an executable file is loaded into memory.（当可执行文件（指令）被加载进内存的时候一个程序就变成了进程） 3)A process is an active entity , with a program counter（pc） specifying the next instruction to execute an a set of associated resources." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/54f17cd7740a30badfb6aeaac6967765/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-03T17:15:09+08:00" />
<meta property="article:modified_time" content="2023-10-03T17:15:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入理解操作系统- - 进程篇（1）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E8%BF%9B%E7%A8%8B%E8%A7%A3%E9%87%8A%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E8%BF%9B%E7%A8%8B%E8%A7%A3%E9%87%8A%EF%BC%9A" rel="nofollow">进程解释：</a></p> 
<p id="process%20in%20memory(%E8%BF%9B%E7%A8%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88)%20%3A-toc" style="margin-left:0px;"><a href="#process%20in%20memory%28%E8%BF%9B%E7%A8%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88%29%20%3A" rel="nofollow">process in memory(进程在内存中包含什么) :</a></p> 
<p id="%E5%B9%B6%E5%8F%91%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%B9%B6%E5%8F%91%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%9A" rel="nofollow">并发的进程：</a></p> 
<p id="%E8%BF%9B%E7%A8%8B%E5%AE%9A%E4%B9%89%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E8%BF%9B%E7%A8%8B%E5%AE%9A%E4%B9%89%EF%BC%9A" rel="nofollow">进程定义：</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E5%AE%9A%E4%B9%89%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E5%AE%9A%E4%B9%89%EF%BC%9A" rel="nofollow">个人定义：</a></p> 
<p id="%E4%B9%A6%E6%9C%AC%E5%AE%9A%E4%B9%89%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%B9%A6%E6%9C%AC%E5%AE%9A%E4%B9%89%EF%BC%9A" rel="nofollow">书本定义：</a></p> 
<p id="%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%EF%BC%9A" rel="nofollow">进程状态：</a></p> 
<p id="%E8%BF%9B%E7%A8%8B%E4%BD%95%E6%97%B6%E7%A6%BB%E5%BC%80CPU%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E8%BF%9B%E7%A8%8B%E4%BD%95%E6%97%B6%E7%A6%BB%E5%BC%80CPU%EF%BC%9A" rel="nofollow">进程何时离开CPU：</a></p> 
<p id="%E5%86%85%E9%83%A8%E4%BA%8B%E4%BB%B6%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%86%85%E9%83%A8%E4%BA%8B%E4%BB%B6%EF%BC%9A" rel="nofollow">内部事件：</a></p> 
<p id="%E5%A4%96%E9%83%A8%E4%BA%8B%E4%BB%B6%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%A4%96%E9%83%A8%E4%BA%8B%E4%BB%B6%EF%BC%9A" rel="nofollow">外部事件：</a></p> 
<p id="%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%EF%BC%9A" rel="nofollow">进程切换：</a></p> 
<p id="%E4%B8%AD%E6%96%AD%E6%BA%90%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%B8%AD%E6%96%AD%E6%BA%90%EF%BC%9A" rel="nofollow">中断源：</a></p> 
<p id="%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4%E5%92%8C%E9%9D%9E%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4%E5%92%8C%E9%9D%9E%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4%EF%BC%9A" rel="nofollow">特权指令和非特权指令：</a></p> 
<p id="%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2%EF%BC%9A" rel="nofollow">模式切换：</a></p> 
<p id="%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%EF%BC%9A" rel="nofollow">进程切换：</a></p> 
<p id="%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%EF%BC%9A" rel="nofollow">进程控制块：</a></p> 
<p id="%E8%BF%9B%E7%A8%8B%E5%9C%A8%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E8%BF%9B%E7%A8%8B%E5%9C%A8%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%9A" rel="nofollow">进程在物理内存中：</a></p> 
<p id="%C2%A0%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%9A" rel="nofollow"> 进程调度：</a></p> 
<p id="%C2%A0%E5%AE%9E%E9%AA%8C%E7%AF%87%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%C2%A0%E5%AE%9E%E9%AA%8C%E7%AF%87%EF%BC%9A" rel="nofollow"> 实验篇</a></p> 
<h2 id="%E8%BF%9B%E7%A8%8B%E8%A7%A3%E9%87%8A%EF%BC%9A">进程解释：</h2> 
<div> 
 <span style="color:#373b4f;">1)A </span> 
 <span style="color:#0433ff;">program(程序)</span> 
 <span style="color:#373b4f;"> is a </span> 
 <span style="color:#b51700;">passive entity（被动的实体）</span> 
 <span style="color:#373b4f;">, such as a file </span> 
</div> 
<div> 
 <span style="color:#373b4f;">containing a list of instructions stored on disk(often </span> 
</div> 
<div> 
 <span style="color:#373b4f;">called an </span> 
 <span style="color:#ff9300;">executable file--可执行文件</span> 
 <span style="color:#373b4f;">).---例如一个文件包含一列指令存储在磁盘</span> 
</div> 
<div> 
 <span style="color:#373b4f;">2)A </span> 
 <span style="color:#0433ff;">program</span> 
 <span style="color:#373b4f;"> becomes a </span> 
 <span style="color:#0433ff;">process</span> 
 <span style="color:#373b4f;"> when an executable file </span> 
</div> 
<div> 
 <span style="color:#373b4f;">is loaded into memory.（当可执行文件（指令）被加载进内存的时候一个程序就变成了进程）</span> 
</div> 
<div> 
 <span style="color:#373b4f;">3)A </span> 
 <span style="color:#0433ff;">process</span> 
 <span style="color:#373b4f;"> is an </span> 
 <span style="color:#b51700;">active entity</span> 
 <span style="color:#373b4f;">, with a </span> 
 <span style="color:#ff9300;">program counter（pc）</span> 
</div> 
<div> 
 <span style="color:#373b4f;">specifying the next instruction to execute an a set of </span> 
</div> 
<div> 
 <span style="color:#373b4f;">associated resources.（一个进程是一个活动实体，包含一个程序计数器，规定用来指明下一条要执行的指令---pc+1加的是一个字长）</span> 
</div> 
<div> 
 <h2 id="process%20in%20memory(%E8%BF%9B%E7%A8%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88)%20%3A">process in memory(进程在内存中包含什么) :</h2> 
 <div> 
  <span style="color:#373b4f;">text：二进制代码（指令）（同一个应用程序的不同进程之间是共享程序段的）</span> 
 </div> 
 <div> 
  <span style="color:#373b4f;">data：全局和静态变量数据 </span> 
 </div> 
 <div> 
  <span style="color:#373b4f;">stack：栈用于存放局部变量、函数返回地址 </span> 
 </div> 
 <div> 
  <span style="color:#373b4f;">heap：堆用于程序</span> 
  <span style="color:#fe2c24;">运行时</span> 
  <span style="color:#373b4f;">的动态内存分配</span> 
 </div> 
 <div> 
  <span style="color:#373b4f;">还包括pcb进程控制块</span> 
 </div> 
</div> 
<div> 
 <img alt="" height="521" src="https://images2.imgbox.com/1e/3d/NEeWwSyx_o.png" width="380"> 
</div> 
<div> 
 <pre><code class="language-cpp">int global=100; 
void f(int x, int y){ 
 int* p = malloc(100);
 return; 
} 
void g(int a){ 
 f(a, a+1); 
 return;
} 
int main() 
{ 
 static int i=10; 
 g(i); 
 return 0; 
}</code></pre> 
 <blockquote> 
  <p>将程序加载入内存</p> 
  <p>代码的二进制指令全部放入text区--------存放的指令是只读的</p> 
  <p>先执行main函数指令  将main函数的返回地址写入栈（stack）中</p> 
  <p>发现一个全局变量和一个静态变量放入data区（编译好的代码是有全局观的，所以会知道有全局变量）</p> 
  <p>调用函数g（）， 把g（）函数的局部变量放入栈中，并把函数的返回值压入栈中，</p> 
  <p>调用f（）函数，把f函数的局部变量x,y,p放入栈中，再将f（）函数的返回值放入</p> 
  <p>f（）函数申请的动态内存放入heap，申请的空间内存的首地址赋值给p指针</p> 
  <p>从stack栈中得到f()函数的返回地址，让后出栈，同时函数清理需要把该函数的所有变量从栈中清掉。</p> 
  <p>取出g（）函数返回地址，清空g()函数</p> 
  <p>取出main（）函数的返回值，并清空栈中与data区中的数据</p> 
  <p>heap中的内存必须手动回收</p> 
 </blockquote> 
</div> 
<h2 id="%E5%B9%B6%E5%8F%91%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%9A">并发的进程：</h2> 
<div> 
 <div> 
  <span style="color:#373b4f;">Concurrency：the fact of two or more events or </span> 
 </div> 
 <div> 
  <span style="color:#373b4f;">circumstances happening or existing at the same time. </span> 
 </div> 
</div> 
<div>
  （并发：两个或多个事件的事实同时 
 <strong>发生或存在</strong>的情况---不是同时runing运行--并行） 
</div> 
<h2 id="%E8%BF%9B%E7%A8%8B%E5%AE%9A%E4%B9%89%EF%BC%9A">进程定义：</h2> 
<h3 id="%E4%B8%AA%E4%BA%BA%E5%AE%9A%E4%B9%89%EF%BC%9A">个人定义：</h3> 
<p>进程是一个拥有cpu使用权的进行计算任务的基本单位。</p> 
<div> 
 <h3 id="%E4%B9%A6%E6%9C%AC%E5%AE%9A%E4%B9%89%EF%BC%9A">书本定义：</h3> 
 <div> 
  <span style="color:#373b4f;">进程是一个程序的一次执行过程 </span> 
 </div> 
 <div> 
  <span style="color:#373b4f;">能完成具体的功能 </span> 
 </div> 
 <div> 
  <span style="color:#373b4f;">是在某个数据集合上完成的 </span> 
 </div> 
 <div> 
  <span style="color:#373b4f;">执行过程是可并发的 </span> 
 </div> 
 <div> 
  <span style="color:#373b4f;">进程是资源分配、保护和调度的<strong>基本单位</strong></span> 
 </div> 
 <h2 id="%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%EF%BC%9A">进程状态：</h2> 
 <div> 
  <span style="color:#373b4f;">进程在执行期间自身的状态会发生变化，进程有三 种基本状态，分别是： </span> 
 </div> 
 <div> 
  <span style="color:#ff9300;">运行态（Running）</span> 
  <span style="color:#373b4f;">：此时进程的代码在CPU上运行（正在执行的才是运行态）</span> 
 </div> 
 <div> 
  <span style="color:#ff9300;">就绪态（Ready）</span> 
  <span style="color:#373b4f;">：进程具备运行条件，等待分配CPU </span> 
 </div> 
 <div> 
  <span style="color:#ff9300;">等待态（Waiting）</span> 
  <span style="color:#373b4f;">：进程在等待某些事件的发生（比如 IO操作结束或是一个信号）（不具备运行条件）</span> 
 </div> 
 <h3 id="%E8%BF%9B%E7%A8%8B%E4%BD%95%E6%97%B6%E7%A6%BB%E5%BC%80CPU%EF%BC%9A">进程何时离开CPU：</h3> 
 <div> 
  <h4 id="%E5%86%85%E9%83%A8%E4%BA%8B%E4%BB%B6%EF%BC%9A"><span style="color:#373b4f;">内部事件：</span></h4> 
  <div> 
   <span style="color:#373b4f;">进程</span> 
   <span style="color:#b51700;">主动放弃(yield)</span> 
   <span style="color:#373b4f;">CPU，进入等待/终止状态。 </span> 
  </div> 
  <div> 
   <span style="color:#373b4f;">E.g 使用I/O设备（等待），(非)正常结束（终止）。 </span> 
  </div> 
  <h4 id="%E5%A4%96%E9%83%A8%E4%BA%8B%E4%BB%B6%EF%BC%9A"><span style="color:#373b4f;">外部事件：</span></h4> 
  <div> 
   <span style="color:#373b4f;">进程被剥夺CPU使用权，进入就绪状态。这个动作叫</span> 
   <span style="color:#b51700;">抢占(preempt)</span> 
   <span style="color:#000000;">。 </span> 
  </div> 
  <div> 
   <span style="color:#373b4f;">E.g 时间片到达，高优先权进程到达。</span> 
  </div> 
  <div></div> 
  <div> 
   <img alt="" height="488" src="https://images2.imgbox.com/5b/02/ewdXvOEY_o.png" width="956"> 
  </div> 
  <div></div> 
  <blockquote> 
   <div>
     new是一个新建状态，将程序加载入内存的状态 
   </div> 
   <div>
     当运行除了cpu之外的所有资源都就绪后进入就绪态 
   </div> 
   <div>
     当得到cpu权限后进入运行态，当运行完成后进入terminated状态 
   </div> 
   <div>
     （被动）在运行态cpu被抢夺后进入就绪态 
   </div> 
   <div>
     （主动）在运行态使用I/O设备的时候进入等待状态  等待结束重新进入就绪状态 
   </div> 
  </blockquote> 
  <h2 id="%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%EF%BC%9A">进程切换：</h2> 
  <div></div> 
  <div>
    并发进程中,一个进程在执行过程中可能会被另一个进程替换占有CPU，这个过程称作“进程切换”  
   <img alt="" height="415" src="https://images2.imgbox.com/6a/28/6Jvg1jzS_o.png" width="1059"> 
  </div> 
  <h3 id="%E4%B8%AD%E6%96%AD%E6%BA%90%EF%BC%9A">中断源：</h3> 
  <div> 
   <p><strong>外中断：</strong></p> 
   <p>来自处理器之外的硬件中断信号</p> 
   <p>如时钟中断、键盘中断、外围设备中断 外部中断均是<span style="color:#fe2c24;"><strong>异步中断</strong></span></p> 
   <p><strong>内中断（异常 Exception）：</strong></p> 
   <p>来自于处理器内部，指令执行过程中发生的中断，属<strong><span style="color:#fe2c24;">同步中断</span></strong></p> 
   <p>硬件异常：掉电、奇偶校验错误等</p> 
   <p>程序异常：非法操作、地址越界、断点、除数为0</p> 
   <p>系统调用</p> 
   <p>（参考书籍不同定义就不同---内中断应该只是说法不同 可能依次对应 终止、异常、陷入）</p> 
  </div> 
 </div> 
</div> 
<p><img alt="" height="587" src="https://images2.imgbox.com/c5/90/BDZhwcf5_o.png" width="864">Exception（内）与interrupt（外）统称中断，发生中断后保存进程的上下文信息（相当于快照）（pc---在上边说到程序转换成了二进制指令，不止pc）执行中断处理程序（进入内核），选择对应进程进行恢复进程上下文，返回进程的执行。</p> 
<h3 id="%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4%E5%92%8C%E9%9D%9E%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4%EF%BC%9A">特权指令和非特权指令：</h3> 
<div> 
 <span style="color:#ff9300;">Privileged Instructions </span> 
</div> 
<div> 
 <span style="color:#373b4f;">The Instructions that can run</span> 
 <span style="color:#511b78;"> </span> 
 <span style="color:#956fe7;">only</span> 
 <span style="color:#373b4f;"> in </span> 
 <span style="color:#b51700;">Kernel Mode</span> 
 <span style="color:#373b4f;"> are called Privileged Instructions . </span> 
</div> 
<div> 
 <span style="color:#373b4f;">*I/O instructions and Halt instructions（I/O指令/停止指令）</span> 
</div> 
<div> 
 <span style="color:#373b4f;">*Turn off all Interrupts（关闭中断）</span> 
</div> 
<div> 
 <span style="color:#373b4f;">*Set the Timer  （设置时钟定时器）</span> 
</div> 
<div> 
 <span style="color:#373b4f;">*Process Switching  （进程切换）</span> 
</div> 
<div> 
 <span style="color:#ff9300;">Non-Privileged Instructions </span> 
</div> 
<div> 
 <span style="color:#373b4f;">*The Instructions that can run </span> 
 <span style="color:#956fe7;">only </span> 
 <span style="color:#373b4f;">in </span> 
 <span style="color:#b51700;">User Mode</span> 
 <span style="color:#373b4f;"> are called Non-Privileged Instructions . </span> 
</div> 
<div></div> 
<div>
  怎么区分特权指令和非特权指令？ 
 <br> 通过硬件，设置一个比特位 
</div> 
<div></div> 
<h3 id="%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2%EF%BC%9A">模式切换：</h3> 
<div> 
 <div> 
  <span style="color:#373b4f;">*中断是用户态向核心态转换的唯一途径！系统调用 实质上也是一种中断。 </span> 
 </div> 
 <div> 
  <span style="color:#373b4f;">*OS提供Load PSW指令装载用户进程返回用户状态</span> 
 </div> 
 <div> 
  <img alt="" height="200" src="https://images2.imgbox.com/04/05/zd6oDZQJ_o.png" width="892"> 
 </div> 
 <div></div> 
 <h3>进程切换：</h3> 
 <div>
   1)在进程切换的第一步将cpu的user mode 切换到核心 mode  
 </div> 
 <div>
   2)保存被中断进程的上下文信息 
 </div> 
 <div> 
  <p>3)修改<span style="color:#373b4f;">被中断进程的</span><span style="color:#b51700;">控制信息</span><span style="color:#373b4f;">（如状态等）</span></p> 
  <p><strong><span style="color:#373b4f;">2、3两步会保存到该进程的PCB进程控制块，当重新得到cpu的控制权的时候会将PCB进程控制块加载到cpu</span></strong></p> 
  <div> 
   <span style="color:#373b4f;">4)将被中断的进程加入相应的</span> 
   <span style="color:#b51700;">状态队列 </span> 
  </div> 
  <div> 
   <span style="color:#b51700;">5)调度</span> 
   <span style="color:#373b4f;">一个新的进程并恢复它的上下文信息</span> 
  </div> 
  <h3 id="%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%EF%BC%9A"><span style="color:#373b4f;">进程控制块：</span></h3> 
  <p><span style="color:#373b4f;">每个进程都拥有一个自己的PCB进程控制块</span></p> 
  <div> 
   <div> 
    <span style="color:#373b4f;">A Process </span> 
    <strong><span style="color:#fe2c24;">Control </span></strong> 
    <span style="color:#373b4f;">Block（PCB）contains many pieces of information associated with a specific </span> 
   </div> 
   <div> 
    <span style="color:#373b4f;">process.(一个进程控制块包含很多信息，与一个特定的进程有关)</span> 
   </div> 
   <div></div> 
   <div> 
    <img alt="" height="411" src="https://images2.imgbox.com/38/fc/0F8831ae_o.png" width="1003"> 
   </div> 
   <h4 id="%E8%BF%9B%E7%A8%8B%E5%9C%A8%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%9A">进程在物理内存中：</h4> 
   <div></div> 
   <div> 
    <img alt="" height="510" src="https://images2.imgbox.com/0f/db/xjVrUO6h_o.png" width="736"> 
   </div> 
   <div>
     进程的进程实体并不是整体存放，而是离散存放 
   </div> 
   <div>
     管理进程使用的是进程队列进行管理： 
   </div> 
   <div>
     只有俩个状态--ready（就绪）/等待状态，运行态没用队列只有一个 
   </div> 
   <div>
     就绪状态队列是使用链表进行连接形成队列（只是连接的pcb）,当某个队列需要进入runing状态则从就绪队列中移除 
   </div> 
   <div> 
    <img alt="" height="557" src="https://images2.imgbox.com/f4/06/oX2dZnam_o.png" width="642"> 
   </div> 
  </div> 
 </div> 
</div> 
<h3 id="%C2%A0%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%9A"> 进程调度：</h3> 
<div> 
 <span style="color:#373b4f;">  进程在整个生命周期中会在各个调度队列中迁移， 由操作系统的一个调度器（scheduler）来执行</span> 
</div> 
<div></div> 
<div> 
 <img alt="" height="477" src="https://images2.imgbox.com/8d/2a/UR4MMa3I_o.png" width="1072"> 
</div> 
<p>这里的主动与被动是相对于自身发生的事件来观察的</p> 
<p>eg:当I/O请求发生后cpu是主动离开 </p> 
<p>当时间片结束是操作系统剥夺cpu的执行权，被动</p> 
<p>创建子进程，调用wait函数进行等待，当子进程结束后主动离开</p> 
<p>等待中断，当中断发生后立即交出cpu的执行权。</p> 
<h2 id="%C2%A0%E5%AE%9E%E9%AA%8C%E7%AF%87%EF%BC%9A" style="background-color:transparent;"> 实验篇：</h2> 
<p>Practice: How to create a child process?</p> 
<p>这个实验在上一年学习Linux编程技术的的时候已经做过该实验，在这进行简单实验，若需要详细了解函数的原理可以查考Linux编程技术专栏。</p> 
<p>补充：</p> 
<p>调用fork（）后，会把整个进程的信息进行copy完全复制给新创建的子进程，且两者的内存空间是相互独立的，在fork（）后<strong>父子进程<span style="color:#fe2c24;">并发执行</span>后边的程序</strong>，在子进程中fork函数的返回值为0，在父进程中会返回子进程的pid。（这里的并发可以根据打印信息的程序来判断--会无规律的进行交替打印）<img alt="" height="701" src="https://images2.imgbox.com/1f/10/GuAGXPRS_o.png" width="1200"></p> 
<p>getppid（）函数是获得当前进程的父进程的pid（注：如果父进程在子进程结束之前结束，则子进程变成孤儿进程，则需要找1号进程（是系统启动的第一个进程INITD）作为父进程，即托管给系统进程）</p> 
<p>为了避免孤儿进程的发生，我们引入了wait(NULL)方法，该方法作用与父进程，让父进程等待子进程结束后再返回。  </p> 
<p> 代码如下：</p> 
<p><img alt="" height="395" src="https://images2.imgbox.com/fe/03/vcHkpXdp_o.png" width="603"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9fcab1f93c886cd666bffc4111e0e987/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java 终止线程的4种方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/267a65528bd117dce7e3c72477c7e9c0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于Git Clone时候遇到的超时问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>