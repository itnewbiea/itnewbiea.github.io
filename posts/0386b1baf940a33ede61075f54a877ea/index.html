<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【目标检测算法】Fast R-CNN（详解） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【目标检测算法】Fast R-CNN（详解）" />
<meta property="og:description" content="Fast R-CNN 学习目标1. Fast R-CNN1.1 RoI pooling1.2 End-to-End model 2. 多任务损失-Multi-task loss3. R-CNN、SPPNet、Fast R-CNN效果对比4. Fast R-CNN总结5. 总结6. 问题 学习目标 目标
了解Fast R-CNN的结构特点说明RoI pooling的特点了解多任务损失 【目标检测算法】改进-SPPNet（详解）SPPNet的性能已经得到很大的改善，但是由于网络之间不统一训练，造成很大的麻烦，所以接下来的Fast R-CNN就是为了解决这样的问题
1. Fast R-CNN 改进的地方：
提出一个RoI pooling，然后整合整个模型，把CNN、RoIpooling、分类器、bbox回归几个模块整个一起训练 步骤 首先将整个图片输入到一个基础卷积网络，得到整张图的feature map将选择性搜索算法的结果region proposal（RoI）映射到feature map中RoI pooling layer提取一个固定长度的特征向量，每个特征会输入到一系列全连接层，得到一个RoI特征向量**（此步骤是对每一个候选区域都会进行同样的操作）** 其中一个是传统softmax层进行分类，输出类别有K个类别加上”背景”类另一个是bounding box regressor 1.1 RoI pooling 首先RoI pooling只是一个简单版本的SPP，目的是为了减少计算时间并且得出固定长度的向量。
RoI池层使用最大池化将任何有效的RoI区域内的特征转换成具有H×W的固定空间范围的小feature map，其中H和W是超参数 它们独立于任何特定的RoI。 为什么要设计单个尺度呢？这要涉及到single scale与multi scale两者的优缺点
single scale，直接将image定为某种scale，直接输入网络来训练即可。（Fast R-CNN）multi scal，也就是要生成一个金字塔 后者比前者更加准确些，没有突更多，但是第一种时间要省很多，所以实际采用的是第一个策略，因此Fast R-CNN要比SPPNet快很多也是因为这里的原因。
1.2 End-to-End model 从输入端到输出端直接用一个神经网络相连，整体优化目标函数。
接着我们来看为什么后面的整个网络能进行统一训练？
特征提取CNN的训练和SVM分类器的训练在时间上是先后顺序，两者的训练方式独立，因此SVMs的训练Loss无法更新SPP-Layer之前的卷积层参数，去掉了SVM分类这一过程，所有特征都存储在内存中，不占用硬盘空间，形成了End-to-End模型（proposal除外，end-to-end在Faster-RCNN中得以完善）
使用了softmax分类 2. 多任务损失-Multi-task loss 两个loss，分别是：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0386b1baf940a33ede61075f54a877ea/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-14T13:02:35+08:00" />
<meta property="article:modified_time" content="2021-08-14T13:02:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【目标检测算法】Fast R-CNN（详解）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Fast R-CNN</h4> 
 <ul><li><a href="#_1" rel="nofollow">学习目标</a></li><li><a href="#1_Fast_RCNN_12" rel="nofollow">1. Fast R-CNN</a></li><li><ul><li><a href="#11_RoI_pooling_28" rel="nofollow">1.1 RoI pooling</a></li><li><a href="#12_EndtoEnd_model_44" rel="nofollow">1.2 End-to-End model</a></li></ul> 
  </li><li><a href="#2_Multitask_loss_54" rel="nofollow">2. 多任务损失-Multi-task loss</a></li><li><a href="#3_RCNNSPPNetFast_RCNN_70" rel="nofollow">3. R-CNN、SPPNet、Fast R-CNN效果对比</a></li><li><a href="#4_Fast_RCNN_78" rel="nofollow">4. Fast R-CNN总结</a></li><li><a href="#5__86" rel="nofollow">5. 总结</a></li><li><a href="#6__92" rel="nofollow">6. 问题</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>学习目标</h2> 
<ul><li> <p>目标</p> 
  <ul><li>了解Fast R-CNN的结构特点</li><li>说明RoI pooling的特点</li><li>了解多任务损失</li></ul> </li></ul> 
<p><a href="https://blog.csdn.net/qq_46092061/article/details/119699519?spm=1001.2014.3001.5501">【目标检测算法】改进-SPPNet（详解）</a><strong>SPPNet</strong>的性能已经得到很大的改善，但是由于网络之间不统一训练，造成很大的麻烦，所以接下来的<strong>Fast R-CNN</strong>就是为了解决这样的问题</p> 
<h2><a id="1_Fast_RCNN_12"></a>1. Fast R-CNN</h2> 
<p><strong>改进的地方：</strong></p> 
<ul><li>提出一个RoI pooling，然后整合整个模型，把CNN、RoIpooling、分类器、bbox回归几个模块整个一起训练</li></ul> 
<p><img src="https://images2.imgbox.com/fd/d6/WX6DRK87_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>步骤</strong> 
  <ul><li>首先将整个图片输入到一个基础卷积网络，得到整张图的feature map</li><li>将选择性搜索算法的结果region proposal（RoI）映射到feature map中</li><li>RoI pooling layer提取一个<strong>固定长度</strong>的特征向量，每个特征会输入到一系列全连接层，得到一个RoI特征向量**（此步骤是对每一个候选区域都会进行同样的操作）** 
    <ul><li>其中一个是传统softmax层进行分类，输出类别有K个类别加上”背景”类</li><li>另一个是bounding box regressor</li></ul> </li></ul> </li></ul> 
<h3><a id="11_RoI_pooling_28"></a>1.1 RoI pooling</h3> 
<p>首先RoI pooling只是一个简单版本的SPP，目的是为了减少计算时间并且得出固定长度的向量。</p> 
<p><img src="https://images2.imgbox.com/e3/ee/qYHCC6Sr_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>RoI池层</strong>使用最大池化将任何有效的RoI区域内的特征转换成具有H×W的固定空间范围的小feature map，其中H和W是<strong>超参数</strong> 它们独立于任何特定的RoI。</li></ul> 
<p>为什么要设计单个尺度呢？这要涉及到<strong>single scale与multi scale</strong>两者的优缺点</p> 
<ul><li><strong>single scale</strong>，直接将image定为某种scale，直接输入网络来训练即可。（Fast R-CNN）</li><li><strong>multi scal</strong>，也就是要生成一个金字塔</li></ul> 
<p><strong>后者比前者更加准确些，没有突更多，但是第一种时间要省很多，所以实际采用的是第一个策略，因此Fast R-CNN要比SPPNet快很多也是因为这里的原因。</strong></p> 
<h3><a id="12_EndtoEnd_model_44"></a>1.2 End-to-End model</h3> 
<p>从输入端到输出端直接用一个神经网络相连，整体优化目标函数。</p> 
<p><strong>接着我们来看为什么后面的整个网络能进行统一训练？</strong></p> 
<p>特征提取<strong>CNN</strong>的训练和<strong>SVM分类器</strong>的训练在时间上是先后顺序，两者的训练方式<strong>独立</strong>，因此SVMs的训练Loss无法更新SPP-Layer之前的卷积层参数，去掉了SVM分类这一过程，所有特征都存储在内存中，不占用硬盘空间，形成了<strong>End-to-End模型</strong>（proposal除外，end-to-end在Faster-RCNN中得以完善）</p> 
<ul><li><strong>使用了softmax分类</strong></li></ul> 
<h2><a id="2_Multitask_loss_54"></a>2. 多任务损失-Multi-task loss</h2> 
<p><strong>两个loss，分别是：</strong></p> 
<ul><li>对于分类loss，是一个N+1路的softmax输出，其中的N是类别个数，1是背景，<strong>使用交叉熵损失</strong></li><li>对于回归loss，是一个4xN路输出的regressor，也就是说对于每个类别都会训练一个单独的regressor的意思，<strong>使用平均绝对误差（MAE）损失即L1损失</strong></li></ul> 
<p><img src="https://images2.imgbox.com/63/64/nijUVzi9_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>fine-tuning</strong>训练: 
  <ul><li>在微调时，调整 CNN+RoI pooling+softmax</li><li>调整bbox regressor回归当中的参数</li></ul> </li></ul> 
<h2><a id="3_RCNNSPPNetFast_RCNN_70"></a>3. R-CNN、SPPNet、Fast R-CNN效果对比</h2> 
<table><thead><tr><th align="center">参数</th><th align="center">R-CNN</th><th align="center">SPPNet</th><th align="center">Fast R-CNN</th></tr></thead><tbody><tr><td align="center">训练时间(h)</td><td align="center">84</td><td align="center">25</td><td align="center"><strong>9.5</strong></td></tr><tr><td align="center">测试时间/图片</td><td align="center">47.0s</td><td align="center">2.3s</td><td align="center"><strong>0.32s</strong></td></tr><tr><td align="center">mAP</td><td align="center">66.0</td><td align="center">63.1</td><td align="center"><strong>66.9</strong></td></tr></tbody></table> 
<h2><a id="4_Fast_RCNN_78"></a>4. Fast R-CNN总结</h2> 
<p><img src="https://images2.imgbox.com/3b/d2/01Q04wJX_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>缺点</strong> 
  <ul><li>使用Selective Search提取Region Proposals，没有实现真正意义上的端对端，<strong>操作也十分耗时</strong></li></ul> </li></ul> 
<h2><a id="5__86"></a>5. 总结</h2> 
<ul><li>掌握Fast R-CNN的改进</li><li>掌握RoI pooling的作用</li><li>掌握多任务损失结构</li></ul> 
<h2><a id="6__92"></a>6. 问题</h2> 
<p><strong>1、详细说明RoI pooling过程？</strong></p> 
<p><strong>2、Fast R-CNN的损失是怎么样的？</strong></p> 
<p><mark><strong>加油!</strong></mark></p> 
<p><mark><strong>感谢!</strong></mark></p> 
<p><mark><strong>努力!</strong></mark></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cb3d38645154e6bae130d643e91226a1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一文搞懂内联函数！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fb8bba1d25367c0bf3b9e9d176b027b0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">安装CUDA时报错ModuleNotFoundError: No module named Quirks的原因</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>