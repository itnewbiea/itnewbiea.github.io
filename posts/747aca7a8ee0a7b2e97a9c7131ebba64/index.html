<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据安全--KMS - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据安全--KMS" />
<meta property="og:description" content="背景介绍 密钥管理服务（KMS）是一套密钥管理系统， 可以针对云上数据/各端上的加密需求精心设计的密码应用服务，为您的应用提供符合各种要求的密钥服务及极简应用加解密服务，助您轻松使用密钥来加密保护敏感的数据资产。
方案 开发者身份受保护数据保护目的解决方案网站或应用开发证书、密钥网站和应用会使用HTTPS证书来保证通信协议的安全，也会使用密钥来给文件打上自己企业的签名，但是这些常见的安全解决方案非常依赖证书和密钥本身的安全。KMS密钥管理后台服务开发密码、登录密钥、配置数据库密码、登录密钥、后台服务的配置信息可能会被黑客利用，明文存储在硬盘上非常危险。KMS密钥管理内容、社交网站或应用用户原创内容、有价值的知识产权企业依赖核心的UGC内容或独特的知识产权来建立在行业的竞争优势，一定不能发生『拖库』这样的事故。KMS信封加密政府、金融机构协议通信内容、重要文件和资料政府和金融机构任何的通信和存储数据都具有高价值性和高保密性，需要在建立业务系统时就考虑好合规性和安全性。KMS信封加密 架构 架构图描述:
KMS: 根密钥生成，为了生成根密钥的保密性，由三个人分别输入三段约定好算法的随机因子到HSM中去生成根密钥，非法读取HSM中的根密钥会导致HSM被破坏而不可用从而保护了根密钥不被泄露。另外为了保存好根密钥以备及时恢复，要将三段随机因子分别保存到三个保险柜中。为了防止根密钥被泄露，根密钥RootKey由密钥管理服务KMS从硬件安全模块即HSM中读取,按照一定的分散算法打散存储在内存中。SDK: 开发者将SDK集成到自己开发的服务或者系统的代码中,以实现只需要调用较为简单抽象的接口就能够使用密钥管理服务的相关功能。SDK中进行加解密是为了防止业务方私自保存密钥。Client主要是负责SDK的Http请求相关的功能,加解密模块则是负责SDK加解密相关的功能。 KMS核心功能 包括密钥生命周期：
1、密钥生成 - 统一管理密钥的生成，一般要求根密钥具备较高的随机性以防止密钥被猜测、应用密钥通过安全的分散算法派生生成。
2、密钥存储 - 安全的存储密钥，如使用专用的安全存储设施或采用高强度加密保护，防止密钥的泄露和窃取。
3、密钥分发 - 确保密钥从生成、存储环境向使用环境传输的过程中不被泄露。
4、密钥注销 - 密钥生命周期完结之后，合理、安全地销毁密钥，并对销毁步骤作进行记录。
5、密钥更新 - 通过合理的密钥更替机制，降低密钥长期使用带来的暴露风险。一般要求：根密钥长期有效，具备更替能力；应用密钥定期更新，防止恶意破解；过程密钥一次一密，并通过引入时间戳、流水号等应用数据防止重放攻击。
6、密钥备份 - 保证重要密钥的备份恢复机制，在密钥丢失、灾难场景下，能够较快恢复密码服务能力，恢复时间目标(RTO)和恢复点目标(RPO)满足业务方需求。
7、密钥应用和密码运算服务 - 在具体的应用场景下，KMS还负责为业务方提供与应用相关的安全接口，如：数据加密封装、隐私数据脱敏、接口签名等。
一般情况下我们将KMS系统划分为三个核心模块：
1、安全区 - 整个系统的安全根，主要负责安全存储系统的根密钥，仅对系统内必要的功能模块开放访问权限。
2、服务层 - 系统主要功能的实现部分，为用户和KMS的应用提供密钥管理、数据加密、数字签名等服务，这也是KMS中与业务逻辑关系最紧密的部分。
3、接入层 - 面向应用系统提供业务接入能力，通过提供多语言、多框架适配的SDK，来支持无侵入或低侵入的集成。
密钥生成 从网上弄了一个图，大致如下：
初始密钥的密钥因子：用于导出初始秘钥。初始密钥：用于加密工作密钥。工作密钥：用于加密敏感数据(密码、个人信息等)的密钥。 生成 导出初始密钥的初始向量的生成
使用安全随机数算法生成16字节随机数，并做一些其他随机运算（参见已实现的代码）。并写死在代码中，不再更改。
导出初始密钥的密钥因子的生成
使用安全随机数算法生成16字节随机数，并以16进制形式保存在密钥因子文件中。
初始密钥生成
PBKDF2算法是一个标准的密钥导出算法，可用于导出对称密钥，计算公式为：
DK = PBKDF2(Password, Salt, count, dkLen) 输入： Password：用户输入的口令或者读取的一串字符串，这里使用&#34;密钥因子&#34;。 Salt ：盐值，字符串，这里使用&#34;初始向量&#34; count ：迭代次数，正整数，默认使用&#34;50,000&#34;次 dkLen ：导出密钥的字节长度，正整数，该长度需根据应用程序或密码应用模块所需要的工作密钥长度来定义，以AES128加密算法为例，密钥长度为128bit，即16字节。 输出： DK ：导出的密钥，长度为dkLen个字节的字符串。 Hash函数： 优先使用HmacSHA256、HmacSHA384、HmacSHA512等强密码算法，如果是由于使用的加密库等方面的原因导致不支持相应的强密码算法，也可以使用HmacSHA1，但迭代次数（count）需定义为&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/747aca7a8ee0a7b2e97a9c7131ebba64/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-06T11:15:08+08:00" />
<meta property="article:modified_time" content="2022-04-06T11:15:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据安全--KMS</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>背景介绍</h3> 
<p>密钥管理服务（KMS）是一套密钥管理系统， 可以针对云上数据/各端上的加密需求精心设计的密码应用服务，为您的应用提供符合各种要求的密钥服务及极简应用加解密服务，助您轻松使用密钥来加密保护敏感的数据资产。</p> 
<h3><a id="_3"></a>方案</h3> 
<table><thead><tr><th align="left">开发者身份</th><th align="left">受保护数据</th><th align="left">保护目的</th><th align="left">解决方案</th></tr></thead><tbody><tr><td align="left">网站或应用开发</td><td align="left">证书、密钥</td><td align="left">网站和应用会使用HTTPS证书来保证通信协议的安全，也会使用密钥来给文件打上自己企业的签名，但是这些<font color="red">常见的安全解决方案非常依赖证书和密钥本身的安全。</font></td><td align="left">KMS密钥管理</td></tr><tr><td align="left">后台服务开发</td><td align="left">密码、登录密钥、配置</td><td align="left">数据库密码、登录密钥、后台服务的配置信息可能会被黑客利用，明文存储在硬盘上非常危险。</td><td align="left">KMS密钥管理</td></tr><tr><td align="left">内容、社交网站或应用</td><td align="left">用户原创内容、有价值的知识产权</td><td align="left">企业依赖核心的UGC内容或独特的知识产权来建立在行业的竞争优势，一定不能发生『拖库』这样的事故。</td><td align="left">KMS信封加密</td></tr><tr><td align="left">政府、金融机构</td><td align="left">协议通信内容、重要文件和资料</td><td align="left">政府和金融机构任何的通信和存储数据都具有高价值性和高保密性，需要在建立业务系统时就考虑好合规性和安全性。</td><td align="left">KMS信封加密</td></tr></tbody></table> 
<h3><a id="_11"></a>架构</h3> 
<p><img src="https://images2.imgbox.com/8f/76/gMU3GqWM_o.png" alt="在这里插入图片描述"></p> 
<p>架构图描述:</p> 
<ol><li>KMS: 根密钥生成，为了生成根密钥的保密性，由三个人分别输入三段约定好算法的随机因子到HSM中去生成根密钥，非法读取HSM中的根密钥会导致HSM被破坏而不可用从而保护了根密钥不被泄露。另外为了保存好根密钥以备及时恢复，要将三段随机因子分别保存到三个保险柜中。为了防止根密钥被泄露，根密钥RootKey由密钥管理服务KMS从硬件安全模块即HSM中读取,按照一定的分散算法打散存储在内存中。</li><li>SDK: 开发者将SDK集成到自己开发的服务或者系统的代码中,以实现只需要调用较为简单抽象的接口就能够使用密钥管理服务的相关功能。SDK中进行加解密是为了防止业务方私自保存密钥。Client主要是负责SDK的Http请求相关的功能,加解密模块则是负责SDK加解密相关的功能。</li></ol> 
<h4><a id="KMS_18"></a>KMS核心功能</h4> 
<p>包括密钥生命周期：<br> 1、密钥生成 - 统一管理密钥的生成，一般要求根密钥具备较高的随机性以防止密钥被猜测、应用密钥通过安全的分散算法派生生成。<br> 2、密钥存储 - 安全的存储密钥，如使用专用的安全存储设施或采用高强度加密保护，防止密钥的泄露和窃取。<br> 3、密钥分发 - 确保密钥从生成、存储环境向使用环境传输的过程中不被泄露。<br> 4、密钥注销 - 密钥生命周期完结之后，合理、安全地销毁密钥，并对销毁步骤作进行记录。<br> 5、密钥更新 - 通过合理的密钥更替机制，降低密钥长期使用带来的暴露风险。一般要求：根密钥长期有效，具备更替能力；应用密钥定期更新，防止恶意破解；过程密钥一次一密，并通过引入时间戳、流水号等应用数据防止重放攻击。<br> 6、密钥备份 - 保证重要密钥的备份恢复机制，在密钥丢失、灾难场景下，能够较快恢复密码服务能力，恢复时间目标(RTO)和恢复点目标(RPO)满足业务方需求。<br> 7、密钥应用和密码运算服务 - 在具体的应用场景下，KMS还负责为业务方提供与应用相关的安全接口，如：数据加密封装、隐私数据脱敏、接口签名等。</p> 
<p><strong>一般情况下我们将KMS系统划分为三个核心模块</strong>：<br> 1、安全区 - 整个系统的安全根，主要负责安全存储系统的根密钥，仅对系统内必要的功能模块开放访问权限。<br> 2、服务层 - 系统主要功能的实现部分，为用户和KMS的应用提供密钥管理、数据加密、数字签名等服务，这也是KMS中与业务逻辑关系最紧密的部分。<br> 3、接入层 - 面向应用系统提供业务接入能力，通过提供多语言、多框架适配的SDK，来支持无侵入或低侵入的集成。</p> 
<h4><a id="_33"></a>密钥生成</h4> 
<p>从网上弄了一个图，大致如下：<br> <img src="https://images2.imgbox.com/9d/a2/iYvO8Xma_o.png" alt="在这里插入图片描述"></p> 
<ul><li>初始密钥的密钥因子：用于导出初始秘钥。</li><li>初始密钥：用于加密工作密钥。</li><li>工作密钥：用于加密敏感数据(密码、个人信息等)的密钥。</li></ul> 
<h5><a id="_41"></a>生成</h5> 
<ol><li> <p>导出初始密钥的初始向量的生成<br> 使用安全随机数算法生成16字节随机数，并做一些其他随机运算（参见已实现的代码）。并写死在代码中，不再更改。</p> </li><li> <p>导出初始密钥的密钥因子的生成<br> 使用安全随机数算法生成16字节随机数，并以16进制形式保存在密钥因子文件中。</p> </li><li> <p>初始密钥生成<br> PBKDF2算法是一个标准的密钥导出算法，可用于导出对称密钥，计算公式为：</p> </li></ol> 
<pre><code>DK  =  PBKDF2(Password, Salt, count, dkLen)
输入：
  Password：用户输入的口令或者读取的一串字符串，这里使用"密钥因子"。
  Salt  ：盐值，字符串，这里使用"初始向量"
  count ：迭代次数，正整数，默认使用"50,000"次
  dkLen ：导出密钥的字节长度，正整数，该长度需根据应用程序或密码应用模块所需要的工作密钥长度来定义，以AES128加密算法为例，密钥长度为128bit，即16字节。
输出：
  DK ：导出的密钥，长度为dkLen个字节的字符串。


Hash函数：
优先使用HmacSHA256、HmacSHA384、HmacSHA512等强密码算法，如果是由于使用的加密库等方面的原因导致不支持相应的强密码算法，也可以使用HmacSHA1，但迭代次数（count）需定义为"100000""次。


Java示例代码：
  SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");
</code></pre> 
<ol start="4"><li>工作密钥的生成<br> 使用安全随机数算法生成16字节随机数，再使用初始秘钥加密，将结果保存在工作秘钥文件中。</li></ol> 
<h4><a id="_72"></a>密钥更新</h4> 
<p>在密钥泄露、到期等原因下，需要更新秘钥。</p> 
<pre><code>代码参考：
https://github.com/xdc0209/java-code/blob/master/basicKnowledge/src/com/xdc/basic/skills/encrypt/aes/%E4%B8%80%E7%A7%8D%E5%AE%89%E5%85%A8%E5%BA%A6%E8%BE%83%E9%AB%98%E7%9A%84AES%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F.txt

https://kyakya.icu/article/java%E5%AF%86%E7%A0%81%E5%AD%A6-10.%E6%95%B0%E5%AD%97%E4%BF%A1%E5%B0%81#KEK
</code></pre> 
<h4><a id="_81"></a>密钥派生</h4> 
<p>KMS中最为关键的模块是密钥派生模块。根据用户ID和随机因子通过伪随机函数派生出KEK或者DEK等密钥。KMS杜绝明文持久化保存密钥，派生出来的KEK通过Rootkey加密保存在数据库，派生出来的DEK通过KEK加密保存在数据库。</p> 
<p>创建密钥：<br> 1.用户调用KMS提供的SDK创建用户数据密钥<br> 2.用户传入用户ID等必要信息(如果要创建KEK则传入部门信息，如果创建DEK则传入应用信息)<br> 3.KMS服务器验证请求<br> 4.验证通过,KMS服务器在该用户名下创建新的密钥并返回密钥ID</p> 
<p>数据加密过程：<br> 1.KMS系统随机生成DEK<br> 2.使用DEK对数据进行加密<br> 3.使用KEK对DEK进行加密<br> 4.将加密后的数据和加密后的DEK一并存入数据库</p> 
<p>数据解密过程：<br> 1.从数据库提取出加密后的数据和加密后的DEK<br> 2.使用KEK对加密后的DEK进行解密<br> 3.使用解密后的DEK对加密后的秘闻数据进行解密，得到原始数据</p> 
<pre><code>第一层：工作密钥，DEK，用来加密实际的敏感数据。
第二层：密钥加密密钥，又叫做终端主密钥，KEK，用来加密工作密钥，在各个终端中存在。
第三层：非对称密钥，数字证书的一部分，用来识别身份，并加密传输KEK。

KDF (key derivation function，密钥派生函数) 可以通过特定算法将密码派生出指定长度的密钥，非常适用于密码验证的密码哈希处理。
常用于密码哈希的 KDF 算法有 bcrypt，scrypt，Argon2，PBKDF2。在 2013 到 2015 年间进行的密码哈希竞赛宣布 Argon2 成为获胜者，所以目前最为推荐用于密码哈希的算法就是 Argon2。

Go 中提供了 golang.org/x/crypto，其中包括常用的 KDF：
Argon2, golang.org/x/crypto/argon2。
Bcrypt, golang.org/x/crypto/bcrypt。
Scrypt, golang.org/x/crypto/scrypt。
PBKDF2, golang.org/x/crypto/pbkdf2。
HKDF, golang.org/x/crypto/hkdf。
</code></pre> 
<h4><a id="_117"></a>密钥管理</h4> 
<p>初始化阶段：<br> 1.各个Service首先在KMS中接入获得身份令牌token<br> 2.各个Service生成自己的RSA公私钥<br> 3.各个Service拿自己的RSA公钥去CA申请证书</p> 
<p>密钥准备阶段：<br> 1.Service用自己的证书去KMS申请需要的密钥<br> 2.密钥保存在Service本地，定期去KMS重新获取（当有效期设置为0时，即不在Service本地保存，一次一密）</p> 
<p>业务调用阶段：<br> 1.Service用获取到的签名密钥做签名，加密密钥做加密，调用其他服务。<br> 2.其他业务线校验签名，返回数据。</p> 
<h4><a id="_131"></a>密钥轮换</h4> 
<p>广泛重复的使用加密密钥，会对加密密钥的安全造成风险。为了确保加密密钥的安全性，用户需要为用户主密钥创建新的密钥材料。</p> 
<p>用户可以通过以下两种方式创建新的密钥材料：</p> 
<ul><li>创建新的用户主密钥。</li><li>为现有的用户主密钥开启密钥轮换，KMS自动为用户主密钥生成新的密钥材料。密钥轮换只会更改用户主密钥的密钥材料，用户主密钥的属性（密钥ID、别名、描述、权限）不会发生变化。</li></ul> 
<p>开启密钥轮换后，密钥管理服务会根据设置的轮换周期（默认365天）自动轮换密钥，每次轮换都会生成一个新版本的用户主密钥，轮换的密钥加解密数据的方式，如下所示：</p> 
<ul><li>加密数据时，KMS会自动使用当前最新版本的用户主密钥来执行加密操作。</li><li>解密数据时，KMS会自动使用加密时所使用的用户主密钥来执行解密操作。</li></ul> 
<p>密钥管理服务会保留与该用户主密钥关联的所有版本的用户主密钥。这使得KMS可以解密使用该用户主密钥加密的任何密文。</p> 
<p>默认主密钥和外部导入的密钥不支持密钥轮换。</p> 
<pre><code>开启轮换：
1.可根据设定时间进行轮转(定期更换)
2.开启后直接使用最新的密钥版本

未开启轮换：
根据密钥的版本进行使用
</code></pre> 
<h4><a id="_155"></a>密钥使用</h4> 
<pre><code>设备和服务可通过请求参数获取自己的密钥套件, 
request: {
    type: 1/2/3
    ak: uuid
    rk: 随机16位数
    device:{
        dsn = value.get('Device Serial Number') +
        password = value.get('Password') +
        dev_id = value.get('Device Identifier')
        net_id = value.get('Network Identifier')
        mach_id = value.get('Machine Identifier')
        med_id = value.get('Media Identifier')    
    }
}
申请后返回：车机的话每个uid一套，减少链接延迟可设置轮换(主要用于传输协议和预埋密钥)
KeySuite: {
deviceId:
keyId:
keySecret: {
    aesKey:    
    aesKeyHash:    
    hmacKey:  
    hmacKeyHash: 确认唯一性编码
} 
}
1.可根据版本进行密钥使用
</code></pre> 
<h4><a id="_185"></a>密钥吊销</h4> 
<p>服务公私钥泄漏后，需要吊销。吊销过程如下：<br> 将需要吊销的公钥导入到离线的根密钥管理系统中，生成吊销列表，由根私钥对吊销列表签名；<br> 将吊销文件通过OTA升级（车机）、软件升级（手机APP）的形式内置到Android Framework或APP中；<br> 车机、手机验签时先检查服务公钥是否在吊销列表中，如果在吊销列表中，验签失败，如果没在吊销列表中，执行后续的验签动作；</p> 
<h4><a id="_191"></a>验证签名</h4> 
<p>可采用层级验证签名的方式进行</p> 
<h3><a id="_194"></a>应急处理</h3> 
<p>主密钥和业务密钥可以进行备份（CDC机制）<br> 根密钥直接复制一份保留(存储方式根据自己的公司进行制定)<br> 密钥相关系统运行在安全区</p> 
<h3><a id="_200"></a>思考</h3> 
<p>1、什么时候做数字签名？<br> 每次接口调用都做数字签名。</p> 
<p>2、数据加密的算法？<br> 建议采用对称加密AES256位密钥，待加密的数据类型不同，选择不同模式，一般情况下CBC模式适合大多数场景，XTS模式适合本地存储场景。</p> 
<p>3、如何判断一条数据是否被加密？<br> 在系统迁移的过程中，必然出现明文和加密两种逻辑同事出现的情况，此时就需要程序判断数据是明文还是密文，建议在SDK中提供方法判断。</p> 
<p>4、存储加密数据库索引如何处理？<br> 基于安全的设计，相同的明文可能密文不同，因此需要建立一条不可逆并且与明文一一对应的值做索引。</p> 
<p>5、存储加密历史数据如何处理？<br> 第一次加密之前的历史数据，需要提前先由刷库工具统一将明文刷成密文，刷库时，需要先新建一列密文列，将明文列加密后刷到密文列中，之后程序写入或者更新操作时，需要对明文列、密文列双写，读取操作时只读取密文列，等程序稳定运行一段时间后，再将明文列删除。第一次加密之后，随着密钥定期更新，不同时期的数据使用不同密钥加密。</p> 
<p>6、密钥如何存储？<br> 在KMS服务端，工作密钥需要加密存储于数据库中，加密存储的密钥可采用分段式密钥，通过RAID方式将不同密钥段存储于不同介质中。</p> 
<p>7、证书如何生成下发？<br> 证书生成下发通常有两种方式，第一种是SDK生成RSA公私钥，将RSA公钥发给CA申请证书，CA用自己的私钥签发证书后返回给SDK。第二种是直接CA生成RSA公私钥，并签发证书，并下发给SDK。这两种方式可根据实际业务需求选择。证书是对客户端做身份识别的最重要标识，因此在第一次下发证书时，建议采用可信的第三方系统独立下发，如SRE发布系统。如果有有效且安全的手段保证客户端的合法性，可通过SDK与KMS的交互来下发证书。</p> 
<p>8、证书如何验证，保证客户端的合法性？<br> 证书验证需要两个步骤：<br> （1）验证证书的合法性，通过CA的公钥解密证书，校验签名即可验证证书的合法性、未被篡改。（2）验证客户端持有证书对应的私钥，KMS向SDK发起challenge，向SDK发送一个随机数，SDK使用私钥加密后，返回给KMS，KMS使用证书中的公钥解密，验证SDK确实持有合法的私钥，证明SDK的合法身份。为了保证安全性，KMS发送的随机数可以做一次哈希。</p> 
<p>9、密钥协商方式？<br> 密钥协商可采用集中协商或者分散协商两种方式。<br> （1）集中协商：各个SDK分别向KMS请求密钥，KMS生成后返回给各个SDK。<br> （2）分散协商：假设有两个客户端A和B，A和B使用DH密钥协商算法，来协商密钥。</p> 
<p>10、容器怎么调用密钥?<br> 容器直接以sidecar方式运行</p> 
<p>11、怎么保证service端运行的密钥安全?<br> 难点：agent运行安全和本身安全保证</p> 
<p>12、身份认证方式？<br> a. 采用ak/sk认证—ram访问管理控制<br> b. 采用IAM(outh2协议)认证/IDaas</p> 
<h3><a id="_242"></a>参考</h3> 
<p>密钥管理架构设计概述<br> https://segmentfault.com/a/1190000019179595<br> 分布式密钥管理系统(Tenzorum/NuCypher)<br> https://mp.weixin.qq.com/s/u6EFAn4lqYFZYvZsCGhrRw<br> 密钥交换算法<br> https://www.liaoxuefeng.com/wiki/1252599548343744/1304227905273889<br> go密钥依赖库(SM2/SM3/SM4[分组密码算法]/x509)<br> https://github.com/tjfoc/gmsm<br> https://studygolang.com/articles/21300<br> 密钥分散算法/打散算法的三种解决方案及选型场景<br> https://zhuanlan.zhihu.com/p/191017039<br> AK/SK身份认证系统<br> https://blog.51cto.com/u_15301988/3127042#Step_1_AKSK_29<br> https://zhuanlan.zhihu.com/p/109988929 (hmac)<br> https://www.cnblogs.com/wangzhen-fly/p/11091254.html （您可以为ak生成UUID，为sk生成随机字节）<br> https://github.com/huaweicloudDocs/iam/blob/master/cn.zh-cn/API%E5%8F%82%E8%80%83/%E8%AE%A4%E8%AF%81%E9%89%B4%E6%9D%83.md<br> 谈AK管理之基础篇 - 如何进行访问密钥的全生命周期管理？<br> https://developer.aliyun.com/article/782639<br> https://developer.aliyun.com/article/782641?utm_content=g_1000254832<br> 爱奇艺kms<br> https://www.secrss.com/articles/34234<br> 开源的几个kms相关<br> https://www.cnblogs.com/2018/p/14356796.html<br> TLS 中的密钥计算<br> https://halfrost.com/https-key-cipher/#toc-3<br> kmip使用<br> https://pkg.go.dev/github.com/gemalto/kmip-go#example-Server<br> https://blog.csdn.net/lihuayong/article/details/19121655?utm_source=app&amp;app_version=4.21.0&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen<br> https://blog.csdn.net/lihuayong/article/details/25098093?spm=1001.2101.3001.6650.8&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-8.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-8.no_search_link&amp;utm_relevant_index=9<br> https://github.com/smira/go-kmip/blob/a8ea65df664e89a2edd6f7558988c753960d2145/client.go<br> https://pykmip.readthedocs.io/en/latest/server.html#configuration<br> 加密信封和生成证书<br> https://kyakya.icu/article/java%E5%AF%86%E7%A0%81%E5%AD%A6-11.%E7%94%9F%E6%88%90%E8%87%AA%E8%AF%81%E4%B9%A6%E5%92%8C%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6<br> python创建证书<br> https://github.com/OpenKMIP/PyKMIP/blob/645cbf2ae931b03b8f5ebe2458683da1b2276794/bin/create_certificates.py<br> ssl/tls<br> https://blog.csdn.net/vip97yigang/article/details/84721027<br> https://zhuanlan.zhihu.com/p/438843363<br> https://github.com/cloudflare/cfssl<br> go grpc<br> https://segmentfault.com/a/1190000019216566<br> KMIP文档(要求使用TLS相互身份认证，本身有一套密钥操作模板)<br> https://www.ibm.com/support/pages/sites/default/files/inline-files/$FILE/chs_kmip.pdf</p> 
<p>vault<br> https://huangjunwen.github.io/post/2017/vault/<br> https://huangjunwen.github.io/post/2017/shamir-secret-sharding/<br> vault安装<br> https://www.secrss.com/articles/11755<br> https://shuhari.dev/blog/2018/02/vault-introduction<br> docker vault<br> https://shuhari.dev/blog/2018/02/vault-introduction<br> https://jenkins-zh.blog.csdn.net/article/details/105548898?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.no_search_link&amp;utm_relevant_index=6<br> kmip in vault<br> https://learn.hashicorp.com/tutorials/vault/kmip-engine<br> vault策略管理<br> https://learn.hashicorp.com/tutorials/vault/policies?_x_tr_sl=auto&amp;_x_tr_tl=zh-CN&amp;_x_tr_hl=zh-CN&amp;_x_tr_pto=op</p> 
<p>vsm产品<br> http://www.westone.com.cn/products/40/135.html<br> 云密码服务技术白皮书<br> http://www.bccia.org.cn/upload/files/2019/12/19f490f47a6d26bd.pdf</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e3161bf1417c31bfe48660e4842cdae7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机未解决难题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fd8ee6e9ec7827e8d667f1495d133149/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SHELL常用语法详细说明</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>