<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43; 线程间通信方式 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43; 线程间通信方式" />
<meta property="og:description" content=" 文章目录 线程同步和线程互斥线程间通信方式信号量、条件变量、互斥量进程、线程、协程多进程和多线程 线程同步和线程互斥 互斥 某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的，线程间不需要知道彼此的存在。
同步 在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问，线程间知道彼此的存在。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源
线程间通信方式 两个进程间的两个线程通信，相当于进程间通信：
信号量, socket网络连接, 共享内存 ,管道,共享文件一个进程中的两个线程间通信方式：
1.互斥锁
mutex;
lock_guard (在构造函数里加锁，在析构函数里解锁）
unique_lock 自动加锁、解锁
atomic 基本类型的原子操作
参考链接：
std::unique_lock与std::lock_guard区别
C&#43;&#43;11 std::unique_lock与std::lock_guard区别及多线程应用实例
C11:std::unique_lock和std::lock_guard的区别
2.条件变量condition_variable
关于互斥锁和条件变量：
互斥量可以保护共享数据的修改，如果线程正在等待共享数据的某个条件出现，仅用互斥量的话就需要反复对互斥对象锁定解锁，以检查值的变化，这样将频繁查询的效率非常低。
条件变量可以让等待共享数据条件的线程进入休眠，并在条件达成时唤醒等待线程，提供一种更高效的线程同步方式。条件变量一般和互斥锁同时使用，提供一种更高效的线程同步方式。
3.信号量
4.读写锁shared_lock。 信号量、条件变量、互斥量 1.互斥锁是为上锁而优化的；条件变量是为等待而优化的； 信号量既可用于上锁，也可用于等待，因此会有更多的开销和更高的复杂性。
2.互斥锁，条件变量都只用于同一个进程的各线程间，而信号量可用于不同进程间的同步。当信号量用于进程间同步时，要求信号量建立在共享内存区。
3.读写锁与互斥量类似，不过读写锁允许更高的并行性。读写锁也叫做共享-独占锁，当读写锁以读模式锁住时，它是以共享模式锁住的；当他以写模式锁住时，它是以独占模式锁住的。
进程、线程、协程 1.进程有自己独立的堆和栈，都不共享，是操作系统调度的基本单位
2.线程有自己独立的栈和共享的堆，是cpu调度的基本单位
3.协程有自己独立的栈和共享的堆，由程序员在代码里显示调度。
协程的优点：
没有线程切换的开销，执行销量高；只有一个线程，共享资源不加锁。 多进程和多线程 需要频繁创建销毁的优先用线程。
web服务器。来一个建立一个线程，断了就销毁线程。要是用进程，创建和销毁的代价是很难承受的。需要进行大量计算的优先使用线程
所谓大量计算，当然就是要消耗很多cpu，切换频繁了，这种情况先线程是最合适的。比如：图像处理、算法处理强相关的处理用线程，弱相关的处理用进程。
一般的server需要完成如下任务：消息收发和消息处理。消息收发和消息处理就是弱相关的任务，而消息处理里面可能又分为消息解码、业务处理，这两个任务相对来说相关性就要强多了。因此消息收发和消息处理可以分进程设计，消息解码和业务处理可以分线程设计。可能扩展到多机分布的用进程，多核分布的用线程。 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/46555835af32e708bb19ce89c041f284/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-28T23:07:51+08:00" />
<meta property="article:modified_time" content="2019-07-28T23:07:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43; 线程间通信方式</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">线程同步和线程互斥</a></li><li><a href="#_11" rel="nofollow">线程间通信方式</a></li><li><a href="#_33" rel="nofollow">信号量、条件变量、互斥量</a></li><li><a href="#_41" rel="nofollow">进程、线程、协程</a></li><li><a href="#_53" rel="nofollow">多进程和多线程</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>线程同步和线程互斥</h3> 
<ul><li>互斥</li></ul> 
<p>某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的，线程间不需要知道彼此的存在。</p> 
<ul><li>同步</li></ul> 
<p>在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问，线程间知道彼此的存在。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源</p> 
<h3><a id="_11"></a>线程间通信方式</h3> 
<ul><li>两个进程间的两个线程通信，相当于进程间通信：<br> 信号量, socket网络连接, 共享内存 ,管道,共享文件</li><li>一个进程中的两个线程间通信方式：<br> 1.互斥锁<br> mutex;<br> lock_guard (在构造函数里加锁，在析构函数里解锁）<br> unique_lock 自动加锁、解锁<br> atomic 基本类型的原子操作<br> 参考链接：<br> <a href="https://blog.csdn.net/rusbme/article/details/104650538">std::unique_lock与std::lock_guard区别</a><br> <a href="https://blog.csdn.net/business122/article/details/80881962">C++11 std::unique_lock与std::lock_guard区别及多线程应用实例</a><br> <a href="https://blog.csdn.net/qq_37233607/article/details/80159873">C11:std::unique_lock和std::lock_guard的区别</a><br> 2.条件变量condition_variable<br> 关于互斥锁和条件变量：<br> 互斥量可以保护共享数据的修改，如果线程正在等待共享数据的某个条件出现，仅用互斥量的话就需要反复对互斥对象锁定解锁，以检查值的变化，这样将频繁查询的效率非常低。<br> 条件变量可以让等待共享数据条件的线程进入休眠，并在条件达成时唤醒等待线程，提供一种更高效的线程同步方式。条件变量一般和互斥锁同时使用，提供一种更高效的线程同步方式。<br> 3.信号量<br> 4.读写锁shared_lock。</li></ul> 
<h3><a id="_33"></a>信号量、条件变量、互斥量</h3> 
<p>1.互斥锁是为上锁而优化的；条件变量是为等待而优化的； 信号量既可用于上锁，也可用于等待，因此会有更多的开销和更高的复杂性。</p> 
<p>2.互斥锁，条件变量都只用于同一个进程的各线程间，而信号量可用于不同进程间的同步。当信号量用于进程间同步时，要求信号量建立在共享内存区。</p> 
<p>3.读写锁与互斥量类似，不过读写锁允许更高的并行性。读写锁也叫做共享-独占锁，当读写锁以读模式锁住时，它是以共享模式锁住的；当他以写模式锁住时，它是以独占模式锁住的。</p> 
<h3><a id="_41"></a>进程、线程、协程</h3> 
<p>1.进程有自己独立的堆和栈，都不共享，是操作系统调度的基本单位</p> 
<p>2.线程有自己独立的栈和共享的堆，是cpu调度的基本单位</p> 
<p>3.协程有自己独立的栈和共享的堆，由程序员在代码里显示调度。</p> 
<p>协程的优点：</p> 
<ul><li>没有线程切换的开销，执行销量高；</li><li>只有一个线程，共享资源不加锁。</li></ul> 
<h3><a id="_53"></a>多进程和多线程</h3> 
<p><img src="https://images2.imgbox.com/7f/ec/OhKPqvWk_o.png" alt="在这里插入图片描述"></p> 
<ul><li>需要频繁创建销毁的优先用线程。<br> web服务器。来一个建立一个线程，断了就销毁线程。要是用进程，创建和销毁的代价是很难承受的。</li><li>需要进行大量计算的优先使用线程<br> 所谓大量计算，当然就是要消耗很多cpu，切换频繁了，这种情况先线程是最合适的。比如：图像处理、算法处理</li><li>强相关的处理用线程，弱相关的处理用进程。<br> 一般的server需要完成如下任务：消息收发和消息处理。消息收发和消息处理就是弱相关的任务，而消息处理里面可能又分为消息解码、业务处理，这两个任务相对来说相关性就要强多了。因此消息收发和消息处理可以分进程设计，消息解码和业务处理可以分线程设计。</li><li>可能扩展到多机分布的用进程，多核分布的用线程。</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a60b77a5c4f9489cff99ec18f1813f3b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HIVE 大数据实战项目</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/72c1ef8c6e4758fa02c1923f55bb1dde/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于OpenCV4.1.0实现静态图片人脸检测</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>