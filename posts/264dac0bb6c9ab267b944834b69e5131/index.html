<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python系统编程 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python系统编程" />
<meta property="og:description" content="文章目录 系统编程系统工具概述sys模块os模块 脚本运行上下文当前工作路径命令行参数shell环境变量标准流 文件和目录工具文件工具目录工具 并行系统工具进程分支线程 系统编程 系统工具 概述 python系统模块:
模块名作用*sys负责导出与怕以后呢解释器本身相关的组件*os包含与python所在底层操作系统相应的变量和函数*os.path为文件和目录处理工具提供了可移植的接口glob用于文件名扩展socket用于网络连接和进程间通信threading,_thread,queue用于运行和同步化并发线程subprocess,multiprocessing用于启动和控制并行进程signal,select,shutil,tempfile用于多种系统相关任务第三方扩展以下pySerial串行端口接口Pexpect用于控制程序间对话Twisted网络框架 获取模块文档:
获取属性:dir()
获取用法:__doc__或help()
sys模块 工具作用*sys.platform底层操作系统名称sys.maxsize当前计算机可容纳的最大整型sys.versionpython解释器版本号*sys.path正在运行的python解释器真正的模块搜索路径包含代表脚本主目录的指示器(首项),交互模式下是空字符串可以更改,并不是永久性的*sys.modules字典,python进程所导入的每一个模块sys.getrefcount查看对象的引用次数sys.builtin_module_namespython可执行程序的内置模块名称sys.exc_info()元祖,最近异常的类型,值,追踪对象追踪对象可用模块traceback处理将追踪对象传入traceback.print_tb()sys.argv命令行参数stdin,stdout,stdrrr标准流sys.exit强制退出 os模块 提供了POSIX(可移植操作系统接口)工具,不依赖平台的目录处理,os.path
常用的os工具:
任务工具shell变量os.environ:设置和获取shell环境变量运行程序os.execvos.execlp:启动新程序os.spawnv:启动带有底层控制的新程序os.system():在pythin脚本中运行shell命令,会暂停它的调用者,可在命令后加&amp;os.popen():运行shell命令并与其输入流(传入’w’参数,write()方法)或输出流(默认,read()方法)相连接.os.startfile():用相应的软件打开文件,无论文件是什么派生程序os.waitpid,os.killos.fork:在类Unix系统下派生新的子进程os.pipe:负责进程间通信文件描述符,文件锁os.resd,os.writeos.open:打开基于底层描述符的文件os.stat:获取文件底层信息文件处理os.rename,os.rmdiros.walk:将函数和循环运用与整个目录树的各部分os.remove:根据路径名删除文件os.mkdir:创建新目录os.mkfifo:创建新的命名管道管理工具:提供信息,帮助管理os.chmod,os.listdir,os.accessos.getpid():给出掉用函数的进程的idos.getcwd():返回当前目录os.chdir():改变目录移植工具os.path.split(‘path’):将路径分割为目录和文件os.path.splitext(‘path’):分割了文件的扩展名os.path.normpath(‘path’:将路径分隔符统一为平台的目录分隔符)os.path.abspath(‘path’):返回文件的完整目录路径名.如添加前缀和处理…语法os.path.join:将目录和文件合成路径os.path.dirname(‘path’)/basename(‘path’):返回目录/文件os.sep:目录分割符号os.pathsep:目录列表中分隔目录的符号os.pardir:父目录os.curdir:当前目录os.linesep:换行符路径名工具os.path.getsize(‘path’):通过文件名获取文件大小os.path.isdir(‘path’)/isfile(‘path’):检测文件类型,是目录/文件os.path.exists(‘path’):测试文件是否存在 脚本运行上下文 当前工作路径 当前工作路径(CWD)与脚本所在路径区别:
当前工作路径(CWD): 当前工作路径是启动脚本的路径,即输入命令行的地方.脚本中没有路径的文件名将会映射到此.通过os.getcwd()获得,os.chdir()改变.当通过图标执行一个脚本时,cwd会被设置为脚本所在路径. 脚本所在路径: 脚本所在路径是脚本文件物理存储位置.import导入时,最先搜索的目录.可以通过sys.path列表中的首项看到. 命令行参数 sys.argv:得到命令行参数列表.sys.argv[0]为执行脚本的名称,在命令行出现的顺序决定列表中的索引
python中的命令行处理工具解析更复杂的命令行:
getopt模块optparse模块,功能更强大 note:
unix上的可执行脚本:
脚本第一行#!/usr/bin/env指定解释器
chmod u&#43;x scripname:增加可执行权限
shell环境变量 python通过一个类似python字典的对象os.environ访问环境变量
获取环境变量:
os.environ[‘环境变量名’],例如获取PYTHONPATH:os.environ[‘PYTHONPATH’] 修改环境变量:
通过对os.environ[‘环境变量名’]赋值,在内部调用os.putenv改变环境变量(修改是临时的,只对程序本身和子程序有效)
子程序:由Unix下的os.spawnv,os.fork/exec,以及所有平台的os.popen,os.system,subprocess启动的程序
修改是临时的原因:一个子程序始终从父程序继承环境变量,而子程序的环境变量不会传递给父进程.
标准流 标准流是预先打开的文件对象,python启动时被绑定到控制台窗口,sys模块提供了标准输入(sys.stdin),标准输出(sys.stdout)和错误流(sys.stderr)
重定向流到文件或程序(依赖shell命令行):
标准输入流重定向到文件输入:&lt; fielname
标准输出流重定向到文件:&gt;filename
结合使用:&lt; inputfile &gt; outputfile
管道,一个程序的标准输出发送到另一个程序的标准输入,python脚本可以在任意一端:|
重定向流与用户交互:
当输入流被重定向后,linux中可以通过/dev/tty文件(当前虚拟终端)读取键盘输入
文件的isatty()方法探测文件是否连接到控制台
重定向流到python对象:
任何提供了类似文件read方法的对象可以指定给sys.stdin,以从该对象的read方法读取输入
任何定义了类似文件write方法的对象可以指定给sys.stdout,所有标准输出将发送到该对象方法上
需要保存和重置原来的流
io标准库:
```python from io import StringIO, BytesIO # StringIO提供对象,将文件对象接口和内存字符串相映射(文本) buff = StringIO() # 在字符串中保存写入的文本 buff." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/264dac0bb6c9ab267b944834b69e5131/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-23T21:49:06+08:00" />
<meta property="article:modified_time" content="2023-11-23T21:49:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python系统编程</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <div id="top"></div> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_3" rel="nofollow">系统编程</a></li><li><ul><li><a href="#top_5" rel="nofollow">系统工具</a></li><li><ul><li><a href="#_7" rel="nofollow">概述</a></li><li><a href="#sys_32" rel="nofollow">sys模块</a></li><li><a href="#os_52" rel="nofollow">os模块</a></li></ul> 
   </li><li><a href="#top_98" rel="nofollow">脚本运行上下文</a></li><li><ul><li><a href="#_100" rel="nofollow">当前工作路径</a></li><li><a href="#_114" rel="nofollow">命令行参数</a></li><li><a href="#shell_128" rel="nofollow">shell环境变量</a></li><li><a href="#_144" rel="nofollow">标准流</a></li></ul> 
   </li><li><a href="#top_236" rel="nofollow">文件和目录工具</a></li><li><ul><li><a href="#_238" rel="nofollow">文件工具</a></li><li><a href="#_299" rel="nofollow">目录工具</a></li></ul> 
   </li><li><a href="#top_319" rel="nofollow">并行系统工具</a></li><li><ul><li><a href="#_321" rel="nofollow">进程分支</a></li><li><a href="#_351" rel="nofollow">线程</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_3"></a>系统编程</h2> 
<h3><a id="top_5"></a><a href="#top" rel="nofollow">系统工具</a></h3> 
<h4><a id="_7"></a>概述</h4> 
<p>python系统模块:</p> 
<table><thead><tr><th>模块名</th><th>作用</th></tr></thead><tbody><tr><td>*sys</td><td>负责导出与怕以后呢解释器本身相关的组件</td></tr><tr><td>*os</td><td>包含与python所在底层操作系统相应的变量和函数</td></tr><tr><td>*os.path</td><td>为文件和目录处理工具提供了可移植的接口</td></tr><tr><td>glob</td><td>用于文件名扩展</td></tr><tr><td>socket</td><td>用于网络连接和进程间通信</td></tr><tr><td>threading,_thread,queue</td><td>用于运行和同步化并发线程</td></tr><tr><td>subprocess,multiprocessing</td><td>用于启动和控制并行进程</td></tr><tr><td>signal,select,shutil,tempfile</td><td>用于多种系统相关任务</td></tr><tr><td>第三方扩展</td><td>以下</td></tr><tr><td>pySerial</td><td>串行端口接口</td></tr><tr><td>Pexpect</td><td>用于控制程序间对话</td></tr><tr><td>Twisted</td><td>网络框架</td></tr></tbody></table> 
<p>获取模块文档:</p> 
<ul><li> <p>获取属性:dir()</p> </li><li> <p>获取用法:<code>__doc__</code>或help()</p> </li></ul> 
<h4><a id="sys_32"></a>sys模块</h4> 
<table><thead><tr><th>工具</th><th>作用</th></tr></thead><tbody><tr><td>*sys.platform</td><td>底层操作系统名称</td></tr><tr><td>sys.maxsize</td><td>当前计算机可容纳的最大整型</td></tr><tr><td>sys.version</td><td>python解释器版本号</td></tr><tr><td>*sys.path</td><td>正在运行的python解释器真正的模块搜索路径</td></tr><tr><td></td><td>包含代表脚本主目录的指示器(首项),交互模式下是空字符串</td></tr><tr><td></td><td>可以更改,并不是永久性的</td></tr><tr><td>*sys.modules</td><td>字典,python进程所导入的每一个模块</td></tr><tr><td>sys.getrefcount</td><td>查看对象的引用次数</td></tr><tr><td>sys.builtin_module_names</td><td>python可执行程序的内置模块名称</td></tr><tr><td>sys.exc_info()</td><td>元祖,最近异常的类型,值,追踪对象</td></tr><tr><td></td><td>追踪对象可用模块traceback处理</td></tr><tr><td></td><td>将追踪对象传入traceback.print_tb()</td></tr><tr><td>sys.argv</td><td>命令行参数</td></tr><tr><td>stdin,stdout,stdrrr</td><td>标准流</td></tr><tr><td>sys.exit</td><td>强制退出</td></tr></tbody></table> 
<h4><a id="os_52"></a>os模块</h4> 
<p>提供了POSIX(可移植操作系统接口)工具,不依赖平台的目录处理,os.path</p> 
<p>常用的os工具:</p> 
<table><thead><tr><th>任务</th><th>工具</th></tr></thead><tbody><tr><td>shell变量</td><td>os.environ:设置和获取shell环境变量</td></tr><tr><td>运行程序</td><td>os.execv</td></tr><tr><td></td><td>os.execlp:启动新程序</td></tr><tr><td></td><td>os.spawnv:启动带有底层控制的新程序</td></tr><tr><td></td><td>os.system():在pythin脚本中运行shell命令,会暂停它的调用者,可在命令后加&amp;</td></tr><tr><td></td><td>os.popen():运行shell命令并与其输入流(传入’w’参数,write()方法)或输出流(默认,read()方法)相连接.</td></tr><tr><td></td><td>os.startfile():用相应的软件打开文件,无论文件是什么</td></tr><tr><td>派生程序</td><td>os.waitpid,os.kill</td></tr><tr><td></td><td>os.fork:在类Unix系统下派生新的子进程</td></tr><tr><td></td><td>os.pipe:负责进程间通信</td></tr><tr><td>文件描述符,文件锁</td><td>os.resd,os.write</td></tr><tr><td></td><td>os.open:打开基于底层描述符的文件</td></tr><tr><td></td><td>os.stat:获取文件底层信息</td></tr><tr><td>文件处理</td><td>os.rename,os.rmdir</td></tr><tr><td></td><td>os.walk:将函数和循环运用与整个目录树的各部分</td></tr><tr><td></td><td>os.remove:根据路径名删除文件</td></tr><tr><td></td><td>os.mkdir:创建新目录</td></tr><tr><td></td><td>os.mkfifo:创建新的命名管道</td></tr><tr><td>管理工具:提供信息,帮助管理</td><td>os.chmod,os.listdir,os.access</td></tr><tr><td></td><td>os.getpid():给出掉用函数的进程的id</td></tr><tr><td></td><td>os.getcwd():返回当前目录</td></tr><tr><td></td><td>os.chdir():改变目录</td></tr><tr><td>移植工具</td><td>os.path.split(‘path’):将路径分割为目录和文件</td></tr><tr><td></td><td>os.path.splitext(‘path’):分割了文件的扩展名</td></tr><tr><td></td><td>os.path.normpath(‘path’:将路径分隔符统一为平台的目录分隔符)</td></tr><tr><td></td><td>os.path.abspath(‘path’):返回文件的完整目录路径名.如添加前缀和处理…语法</td></tr><tr><td></td><td>os.path.join:将目录和文件合成路径</td></tr><tr><td></td><td>os.path.dirname(‘path’)/basename(‘path’):返回目录/文件</td></tr><tr><td></td><td>os.sep:目录分割符号</td></tr><tr><td></td><td>os.pathsep:目录列表中分隔目录的符号</td></tr><tr><td></td><td>os.pardir:父目录</td></tr><tr><td></td><td>os.curdir:当前目录</td></tr><tr><td></td><td>os.linesep:换行符</td></tr><tr><td>路径名工具</td><td>os.path.getsize(‘path’):通过文件名获取文件大小</td></tr><tr><td></td><td>os.path.isdir(‘path’)/isfile(‘path’):检测文件类型,是目录/文件</td></tr><tr><td></td><td>os.path.exists(‘path’):测试文件是否存在</td></tr></tbody></table> 
<h3><a id="top_98"></a><a href="#top" rel="nofollow">脚本运行上下文</a></h3> 
<h4><a id="_100"></a>当前工作路径</h4> 
<p>当前工作路径(CWD)与脚本所在路径区别:</p> 
<ul><li>当前工作路径(CWD): 
  <ul><li>当前工作路径是启动脚本的路径,即输入命令行的地方.</li><li>脚本中没有路径的文件名将会映射到此.</li><li>通过os.getcwd()获得,os.chdir()改变.</li><li>当通过图标执行一个脚本时,cwd会被设置为脚本所在路径.</li></ul> </li><li>脚本所在路径: 
  <ul><li>脚本所在路径是脚本文件物理存储位置.</li><li>import导入时,最先搜索的目录.</li><li>可以通过sys.path列表中的首项看到.</li></ul> </li></ul> 
<h4><a id="_114"></a>命令行参数</h4> 
<p>sys.argv:得到命令行参数列表.sys.argv[0]为执行脚本的名称,在命令行出现的顺序决定列表中的索引</p> 
<p>python中的命令行处理工具解析更复杂的命令行:</p> 
<ul><li>getopt模块</li><li>optparse模块,功能更强大</li></ul> 
<blockquote> 
 <p>note:<br> unix上的可执行脚本:<br> 脚本第一行#!/usr/bin/env指定解释器<br> chmod u+x scripname:增加可执行权限</p> 
</blockquote> 
<h4><a id="shell_128"></a>shell环境变量</h4> 
<p>python通过一个类似python字典的对象os.environ访问环境变量</p> 
<p>获取环境变量:</p> 
<ul><li>os.environ[‘环境变量名’],例如获取PYTHONPATH:os.environ[‘PYTHONPATH’]</li></ul> 
<p>修改环境变量:</p> 
<ul><li> <p>通过对os.environ[‘环境变量名’]赋值,在内部调用os.putenv改变环境变量(修改是临时的,只对程序本身和子程序有效)</p> 
  <ul><li> <p>子程序:由Unix下的os.spawnv,os.fork/exec,以及所有平台的os.popen,os.system,subprocess启动的程序</p> </li><li> <p>修改是临时的原因:一个子程序始终从父程序继承环境变量,而子程序的环境变量不会传递给父进程.</p> </li></ul> </li></ul> 
<h4><a id="_144"></a>标准流</h4> 
<p>标准流是预先打开的文件对象,python启动时被绑定到控制台窗口,sys模块提供了标准输入(sys.stdin),标准输出(sys.stdout)和错误流(sys.stderr)</p> 
<p>重定向流到文件或程序(依赖shell命令行):</p> 
<ul><li> <p>标准输入流重定向到文件输入:<code>&lt; fielname</code></p> </li><li> <p>标准输出流重定向到文件:<code>&gt;filename</code></p> </li><li> <p>结合使用:<code>&lt; inputfile &gt; outputfile</code></p> </li><li> <p>管道,一个程序的标准输出发送到另一个程序的标准输入,python脚本可以在任意一端:<code>|</code></p> </li></ul> 
<p>重定向流与用户交互:</p> 
<ul><li> <p>当输入流被重定向后,linux中可以通过/dev/tty文件(当前虚拟终端)读取键盘输入</p> </li><li> <p>文件的isatty()方法探测文件是否连接到控制台</p> </li></ul> 
<p>重定向流到python对象:</p> 
<ul><li> <p>任何提供了类似文件read方法的对象可以指定给sys.stdin,以从该对象的read方法读取输入</p> </li><li> <p>任何定义了类似文件write方法的对象可以指定给sys.stdout,所有标准输出将发送到该对象方法上</p> </li><li> <p>需要保存和重置原来的流</p> </li></ul> 
<p>io标准库:</p> 
<pre><code>```python
from io import StringIO, BytesIO

# StringIO提供对象,将文件对象接口和内存字符串相映射(文本)

buff = StringIO()  # 在字符串中保存写入的文本
buff.write('string\n')
buff.getvalue()  # 取出值

buff = StringIO('string\nstream\n')  # 从字符串中读取输入值
buff.readline() 

# ByteIO提供对象,将文件操作映射到内存字节缓冲区(二进制)

stream = BytesIO()  # 在字节缓冲区中保存写入的文本
stream.write(b'stream')
stream.getvalue()

stream = BytesIO(b'stream')  # # 从字节缓冲区中读取输入值
stream.read()
```
</code></pre> 
<p>print调用中的重定向语法:</p> 
<ul><li>print(string, file=filename) #filename为文件名,需要打开的,有写入权限的</li></ul> 
<p>subprocess模块:</p> 
<ul><li> <p>运行命令的替代方案,对流的控制更完善,控制的是子程序的流.</p> </li><li> <p>subprocess.call(‘cmd’,shell=True),shell与平台相关,类Unix上为真时,由shell执行程序,否则由os.execvp运行</p> </li><li> <p>将stdout流与管道连接,然后用communicate来运行命令,并接收它的标准输出流和错误流文件</p> <pre><code class="prism language-python"><span class="token keyword">from</span> subprocess <span class="token keyword">import</span> Popen<span class="token punctuation">,</span> PIPE

pipe <span class="token operator">=</span> Popen<span class="token punctuation">(</span><span class="token string">'python hello.py'</span><span class="token punctuation">,</span> stdout<span class="token operator">=</span>PIPE<span class="token punctuation">,</span> stdin<span class="token operator">=</span>PIPE<span class="token punctuation">)</span> <span class="token comment"># 获取派生程序的输出流和输入流</span>
pipe2 <span class="token operator">=</span> Popen<span class="token punctuation">(</span><span class="token string">'python reader.py'</span><span class="token punctuation">,</span> stdin<span class="token operator">=</span>pipe<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span> <span class="token comment"># 将pipe的输出流给pipe2的输入流</span>
pipe<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token comment">#写入输入流</span>
pipe<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 关闭输入流文件</span>
pipe<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 读取输出流</span>

<span class="token comment"># pipe.communicate() # </span>
<span class="token comment"># pipe.returncode  # 查看退出状态,成功一般是0</span>
pipe<span class="token punctuation">.</span>wait<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 退出状态</span>
</code></pre> </li></ul> 
<p>os.popen:</p> 
<pre><code>```python
import os

pipe = os.popen('python hello_out.py')  # 默认对stdout读
pipe.read()
print(pipe.close())  # None代表没有错误

pipe = os.popen('python hello_in.py', 'w')  # 对stdin写
pipe.write('Gumby') 
pipe.close()
```
</code></pre> 
<h3><a id="top_236"></a><a href="#top" rel="nofollow">文件和目录工具</a></h3> 
<h4><a id="_238"></a>文件工具</h4> 
<p>内建文件对象</p> 
<ul><li> <p>支持多种方法:将缓冲区写入磁盘(‘flush’),释放系统资源( ‘close’),获取底层文件句柄(‘fileno’),读取数据(‘read’, ‘readline’, ‘readlines’),移动到文件的任意位置(‘seek’),返回当前位置(‘tell’),写入数据(‘writable’, ‘write’, ‘writelines’)</p> </li><li> <p><code>open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</code></p> 
  <ul><li> <p>file:文件名,也可以是文件描述符</p> </li><li> <p>mode:r可读(默认);w可写,并擦除以前任何内容;a追加;+可读可写;b以二进制方式打开</p> </li><li> <p>buffering:0无缓存,二进制模式;1逐行缓冲;其他全缓冲(默认)</p> </li><li> <p>encoding:编码设置</p> </li></ul> </li><li> <p>seek(N, whence=0)</p> 
  <ul><li> <p>0:绝对的开始位置,偏移量非负</p> </li><li> <p>1:相对前位置,偏移量可正可负</p> </li><li> <p>2:绝对的末尾位置,偏移量一般为负</p> </li></ul> </li></ul> 
<p>用struct模块解析打包的二进制数据:</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> struct  <span class="token comment"># 导入包</span>
data <span class="token operator">=</span> struct<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">'&gt;i4shf'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'spam'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1.234</span><span class="token punctuation">)</span>  <span class="token comment"># 按照特定格式打包,&gt;表示高位优先,i是四字节整数,4s代表四字节字符串,h是二字节整数,f是浮点数</span>
value <span class="token operator">=</span> struct<span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">'&gt;i4shf'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>  <span class="token comment"># 按照同样的格式解包 </span>
</code></pre> 
<p>os模块中的底层文件工具</p> 
<ul><li> <p>os.open(path, flags, mode):打开文件并返回其描述符.描述符是整数代码或句柄,用来标识文件,mode是模式标识符,提供更多的底层控制.</p> 
  <ul><li> <p>O_EXCL:唯一访问权</p> </li><li> <p>O_NONBLOCK:非阻塞模式</p> </li><li> <p>(os.O_RDWR|os.O_BINARY):相当与rb+</p> </li></ul> </li><li> <p>os.read(descriptor, N):最多读取N个字节并返回一个字节字符串,descriptor是描述符.</p> </li><li> <p>os.write(descriptor, string):把字节字符串string中的字节写入文件.</p> </li><li> <p>os.lseek(descriptor, position, how):在文件中移至position,how相当与seek中的模式.</p> </li><li> <p>os.fdopen(descriptor, ‘rb’):将文件描述符封装成文件对象,第二个参数是文件对象模式</p> </li><li> <p>其他os模块文件工具</p> </li><li> <p>os.chmod(filepath, Ooxxx):更改文件权限.文件路径和三位八进制(与Unix下文件设置相同)</p> </li><li> <p>os.renaem(oldname, newname):更改名称</p> </li><li> <p>os.remove(filename):删除文件</p> </li><li> <p>os.stat:(fielname):文件的底层信息</p> </li></ul> 
<h4><a id="_299"></a>目录工具</h4> 
<p>遍历目录</p> 
<ul><li> <p>os.popen():运行shell列表命令,例如unix中ls,windows中dir.与命令耦合,不跨平台</p> </li><li> <p>glob.glob()模块:接受路径文件名(每一级路径都可以)模式扩展(?单个字符,*任意个字符,[]字符选集),返回一个匹配文件名(带前缀路径)组成的列表.</p> </li><li> <p>os.listdir():接受路径目录名,返回该目录下所有文件名(不带路径前缀)列表.</p> 
  <ul><li> <p>golb和walk都都通过调用listdir实现.</p> </li><li> <p>如果文件名有特殊字符,可以通过传入字节字符串(b’…').</p> </li><li> <p>文件名编码:os.getfilesystemencoding()</p> </li></ul> </li></ul> 
<p>遍历目录树</p> 
<ul><li>os.walk():接受一个路径目录名,返回一个生成器,为该目录及其每一个递归子目录下产生一个包括(当前目录名称,子目录列表,文件列表)的三元组.用topdown=False参数可以自底向上遍历.删除返回的元祖里子目录列表中的名称,可以对目录树的枝干进行修剪.</li></ul> 
<h3><a id="top_319"></a><a href="#top" rel="nofollow">并行系统工具</a></h3> 
<h4><a id="_321"></a>进程分支</h4> 
<p>os.fork():</p> 
<ul><li> <p>启动新的并行子进程(内存中原来进程的一个副本),在子进程中返回0,在父进程中返回pid</p> </li><li> <p>os.getpid()获得当前进程的pid</p> </li><li> <p>全局对象在子进程开始是有相同的值,全局内存是被复制而不是共享,只改变自己的副本.</p> </li><li> <p>子进程可以通过显是的调用os._exit(0)退出</p> </li></ul> 
<p>fork和exec组合:</p> 
<ul><li> <p>os.execlp():用一个全新的程序覆盖执行原来的程序,通过fork启动子进程再exec覆盖,开启一个与原程序并行运行的新程序,但pid不变</p> </li><li> <p>exec系列:</p> 
  <ul><li> <p>execv(program, commandlinesequence):参数为可执行程序的名称(完整路径),命令行参数字符串组成的列表或元组(在shell中输入的命令)</p> </li><li> <p>execl(program, argv0, argv1, …, argvN):参数形式传入命令行参数</p> </li><li> <p>excelp,excevp:用系统搜索路径定位可执行程序(不需要完整路径)</p> </li><li> <p>execve,execle:在最后添加一个字典参数,包含发送给程序的shell环境变量</p> </li><li> <p>execvpe,execlpe:使用搜索路径并且接受shell环境变量字典参数</p> </li><li> <p>例子:<code>os.execlp('python', 'python', 'child.py', str(parm))</code></p> </li></ul> </li></ul> 
<h4><a id="_351"></a>线程</h4> 
<p>在同一个进程中,和程序的其他部分并行的调用函数(或其他可调用对象),常用于非阻塞的输入调用和GUI中长时间的任务.</p> 
<p>特点:</p> 
<ul><li> <p>相对与分支进程开销小,进程适合计算密集型操作,线程适合IO密集型操作</p> </li><li> <p>共享全局内存(对象和命名空间4),要仔细控制共享项目的访问权</p> </li><li> <p>全局解释器锁(GIL):同一时间只有一个线程运行python代码,不能利用多核</p> </li></ul> 
<p>_thread模块:</p> 
<ul><li> <p>_thread.start_new_thread():</p> 
  <ul><li> <p>开始一个新线程,接受一个函数(或其他可调用对象,如lambda函数,对象方法)和一个参数元组,返回一个无用值.</p> </li><li> <p>线程在其运行的函数返回后退出,或主线程退出后随之退出.</p> </li><li> <p>线程出现异常不影响程序其他部分的运行.</p> </li></ul> </li><li> <p>同步访问共享对象和名称:</p> 
  <ul><li> <p>锁:要修改一个共享对象,线程 需要获得一把锁,然后修改,之后释放锁给其他线程获取.确保任何时间只有一个线程持有锁.</p> </li><li> <p>_thread.allocate_lock():创建全局锁对象,_thread.exit():线程退出</p> </li><li> <p>全局锁对象的acquire()方法获取锁,release()方法释放锁,之间是需要互斥的操作</p> </li><li> <p>locked()方法检测锁是否被获取,被获取返回true</p> </li></ul> </li><li> <p>等待派生线程退出(线程通信)</p> 
  <ul><li> <p>锁列表:创建一个锁列表,通过为每一个子线程结尾获取一把锁,判断每一把锁是否都被获取,则说明子线程都已经结束,就可以退出主线程.</p> </li><li> <p>整数列表:创建一个列表,每一个子线程结尾都改变其值,通过判断是否每一个值都改变了,得知子线程是否都结束.可在主线程中用time.sleep()暂停等待子线程结束</p> </li></ul> </li><li> <p>上下文管理</p> 
  <ul><li>with mutex(全局锁对象):自动上锁和解锁</li></ul> </li></ul> 
<p>threading模块:</p> 
<ul><li> <p>基于对象和类的较高层面的接口,内部使用_thread实现</p> </li><li> <p>可以通过继承threading.Thread对象定制带有状态(初始化方法)和run()行为(提供线程逻辑业务)的线程类.</p> </li><li> <p>threading.Lock():创建全局锁对象.全局锁对象的acquire()方法获取锁,release()方法释放锁,之间是需要互斥的操作</p> </li><li> <p>线程类对象的start()方法:在线程中运行run方法.join():等待直到线程退出.如果任何一个派生线程(守护线程除外)还在运行中,程序不会退出.线程类对象的daemon属性=True可设为守护线程</p> </li><li> <p>threading.Thread对象接受传给target参数的调用对象和任意传给args参数(默认(),代表无)</p> </li><li> <p>threading模块还有Semaphore, Condition和Event等</p> </li></ul> 
<p>queue模块:</p> 
<ul><li> <p>线程程序由一系列消费者程序和一系列生产者程序组成,通过将数据存入一个共享的队列或从中取出来进行通信,保证线程安全.队列同步化的是数据传递,某些操作仍然需要为其他目的而使用锁.</p> </li><li> <p>queue.Queue(maxsize = 0)创建一个队列对象.maxsize可限制队列大小,默认无限制.</p> </li><li> <p>queue.LifoQueue(maxsize = 0)创建一个栈队列对象</p> </li><li> <p>queue.PriorityQueue(maxsize = 0)创建一个优先级队列.典型加入的元素是一个元祖(优先级, 数据),优先级数越小,级别越高</p> </li><li> <p>queue.deque(maxsize = 0)创建一个双线队列</p> </li><li> <p>queue.empty异常,queue.Full异常:队列空取,队列满存产生的异常</p> </li><li> <p>队列对象(例如Queue)的put(item, block=True, timeout=None)方法向队列中存入数据.如果满,blocking = False 直接报 Full异常。如果blocking = True，就是等一会，timeout必须为 0 或正数。None为一直等下去，0为不等，正数n为等待n秒还不能存入，报Full异常</p> </li><li> <p>Queue.get()方法从队列中取出数据,参数类似put</p> </li><li> <p>Queue.empty(),Queue.full():判断队列是否为空,为满</p> </li><li> <p>Queue.task_done():表示队列中某个元素被消费进程使用，消费结束发送的信息</p> </li><li> <p>Queue.join():一直阻塞直到队列中的所有元素都被取出和执行</p> </li></ul> 
<p>GUI与线程:</p> 
<ul><li>GUI程序一般采用主GUI线程加一到多个长时间运行的生产者线程,主线程更新界面,每个生产者线程执行一个长时间任务.所有线程共享一个队列,非GUI线程显示结果,GUI线程消耗它们.</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/313b91a421f4c1092610cd208432e9a2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C#winform中使用SQLite数据库</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4c6cf52c926a442013f71bd48054976d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python单例模式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>