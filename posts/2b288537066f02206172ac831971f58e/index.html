<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>互斥锁与死锁 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="互斥锁与死锁" />
<meta property="og:description" content="在多线程程序中，多个线程可能会共用同一个对象，为了防止多个线程在争夺、使用同一份对象时可能会对该对象造成的改变，引入互斥锁。互斥锁可保证在任一时刻，只能有一个线程访问该对象，从而保证共享数据操作的完整性。
互斥锁基本原理： 互斥锁是一个二元变量，其状态为开锁(允许0)和上锁(禁止1)，将某个共享资源与某个特定互斥锁在逻辑上绑定(要申请该资源必须先获取锁)。 (1)访问公共资源前，必须申请该互斥锁，若处于开锁状态，则申请到锁对象，并立即占有该锁，以防止其他线程访问该资源；如果该互斥锁处于锁定状态，则阻塞当前线程或返回busy。 (2)只有锁定该互斥锁的进程才能释放该互斥锁，其他线程试图释放无效。 (3)互斥锁在同一个线程内，没有互斥的特性。
从互斥锁的行为看，线程加锁和解锁之间的代码相当于一个独木桥，同一时刻只有一个线程能执行。从全局上看，在这个地方，所有并行运行的线程都变成了排队运行了。比较专业的叫法是同步执行，这段代码区域叫临界区。同步执行就破坏了线程并行性的初衷了，临界区越大破坏得越厉害。所以在实际应用中，应该尽量避免有临界区出现。实在不行，临界区也要尽量的小。
互斥锁主要函数 初始化 静态方式初始化 POSIX定义了一个宏PTHREAD_MUTEX_INITIALIZER来静态初始化互斥锁，方法如下： pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; pthread_mutex_t是一个结构，而PTHREAD_MUTEX_INITIALIZER则是一个结构常量。
动态方式初始化 int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t *attr); 参数： mutex：表示初始化的互斥锁的指针。 attr：指向互斥锁对象属性的指针，通常情况下初始化为NULL，即使用默认属性。
申请互斥锁 如果一个线程要占用共享资源，必须先申请对应互斥锁，使用函数：
int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_trylock(pthread_mutex_t *mutex); 这两种方式的区别是，前者采用阻塞方式申请互斥锁，当一个线程在申请共享资源时发现该资源已经被锁定，就会阻塞等待。而pthread_mutex_trylock却不会阻塞，当要申请共享资源时发现该资源已经被锁定时，会返回一个EBUSY信号，使用pthread_mutex_trylock的目的是提高程序运行的并行性。
释放互斥锁 也称为解锁，使用函数：
int pthread_mutex_unlock(pthread_mutex_t *mutex); 释放只能由占有该互斥锁的线程完成，如果释放成功，返回0，失败返回错误编号。
销毁互斥锁 使用函数：
int pthread_mutex_destory(pthread_mutex_t *mutex ); 销毁一个互斥锁即意味着释放它所占用的资源，且要求锁当前处于开放状态。由于在Linux中，互斥锁并不占用任何资源，因此LinuxThreads中的 pthread_mutex_destroy()除了检查锁状态以外（锁定状态则返回EBUSY）没有其他动作。
死锁 什么是死锁 一般情况下，如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这叫做死锁（Deadlock）。 另一种：若线程A获得了锁1，线程B获得了锁2，这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1，于是线程A和B都永远处于挂起状态了。
死锁产生的四个必要条件 互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。
循环等待条件：若干进程间形成首尾相接循环等待资源的关系。
这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。
如何避免死锁 预防死锁： 我们可以通过破坏死锁产生的4个必要条件来预防死锁。 首先明确一下资源互斥是资源使用的固有特性是无法改变的，所以只能从其他3个条件入手。
破坏”请求与保持条件“：第一种方法，静态分配，即每个进程在开始执行时就申请他所需要的全部资源。第二种方法，动态分配，即每个进程在申请所需要的资源时他本身不占用系统资源。
破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源，以及新申请的资源才可以重新启动，执行。
破坏“循环等待”条件：采用资源有序分配法。其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。
避免死锁: 死锁避免的基本思想：系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则予以分配，这是一种保证系统不进入死锁状态的动态策略。 解除死锁 当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有： 剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态； 撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2b288537066f02206172ac831971f58e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-04-22T16:01:44+08:00" />
<meta property="article:modified_time" content="2018-04-22T16:01:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">互斥锁与死锁</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>在多线程程序中，多个线程可能会共用同一个对象，为了防止多个线程在争夺、使用同一份对象时可能会对该对象造成的改变，引入互斥锁。互斥锁可保证在任一时刻，只能有一个线程访问该对象，从而保证共享数据操作的完整性。</p> 
<h5 id="互斥锁基本原理">互斥锁基本原理：</h5> 
<p>互斥锁是一个二元变量，其状态为开锁(允许0)和上锁(禁止1)，将某个共享资源与某个特定互斥锁在逻辑上绑定(要申请该资源必须先获取锁)。 <br> (1)访问公共资源前，必须申请该互斥锁，若处于开锁状态，则申请到锁对象，并立即占有该锁，以防止其他线程访问该资源；如果该互斥锁处于锁定状态，则阻塞当前线程或返回busy。 <br> (2)只有锁定该互斥锁的进程才能释放该互斥锁，其他线程试图释放无效。 <br> (3)互斥锁在同一个线程内，没有互斥的特性。</p> 
<p>从互斥锁的行为看，线程加锁和解锁之间的代码相当于一个独木桥，同一时刻只有一个线程能执行。从全局上看，在这个地方，所有并行运行的线程都变成了排队运行了。比较专业的叫法是同步执行，这段代码区域叫临界区。同步执行就破坏了线程并行性的初衷了，临界区越大破坏得越厉害。所以在实际应用中，应该尽量避免有临界区出现。实在不行，临界区也要尽量的小。</p> 
<h5 id="互斥锁主要函数">互斥锁主要函数</h5> 
<h6 id="初始化">初始化</h6> 
<h6 id="静态方式初始化">静态方式初始化</h6> 
<p>POSIX定义了一个宏<code>PTHREAD_MUTEX_INITIALIZER</code>来静态初始化互斥锁，方法如下： </p> 
<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">pthread_mutex_t mutex </span>=<span class="hljs-string"> PTHREAD_MUTEX_INITIALIZER; </span></code></pre> 
<p>pthread_mutex_t是一个结构，而PTHREAD_MUTEX_INITIALIZER则是一个结构常量。</p> 
<h6 id="动态方式初始化">动态方式初始化</h6> 
<pre class="prettyprint"><code class=" hljs perl"><span class="hljs-keyword">int</span> pthread_mutex_init(pthread_mutex_t <span class="hljs-variable">*mutex</span>,const pthread_mutexattr_t <span class="hljs-variable">*attr</span>); </code></pre> 
<p>参数： <br> mutex：表示初始化的互斥锁的指针。 <br> attr：指向互斥锁对象属性的指针，通常情况下初始化为NULL，即使用默认属性。</p> 
<h6 id="申请互斥锁">申请互斥锁</h6> 
<p>如果一个线程要占用共享资源，必须先申请对应互斥锁，使用函数：</p> 
<pre class="prettyprint"><code class=" hljs perl"><span class="hljs-keyword">int</span> pthread_mutex_lock(pthread_mutex_t <span class="hljs-variable">*mutex</span>);  
<span class="hljs-keyword">int</span> pthread_mutex_trylock(pthread_mutex_t <span class="hljs-variable">*mutex</span>);  </code></pre> 
<p>这两种方式的区别是，前者采用阻塞方式申请互斥锁，当一个线程在申请共享资源时发现该资源已经被锁定，就会阻塞等待。而<code>pthread_mutex_trylock</code>却不会阻塞，当要申请共享资源时发现该资源已经被锁定时，会返回一个EBUSY信号，使用<code>pthread_mutex_trylock</code>的目的是提高程序运行的并行性。</p> 
<h6 id="释放互斥锁">释放互斥锁</h6> 
<p>也称为解锁，使用函数：</p> 
<pre class="prettyprint"><code class=" hljs perl"><span class="hljs-keyword">int</span> pthread_mutex_unlock(pthread_mutex_t <span class="hljs-variable">*mutex</span>);  </code></pre> 
<p>释放只能由占有该互斥锁的线程完成，如果释放成功，返回0，失败返回错误编号。</p> 
<h6 id="销毁互斥锁">销毁互斥锁</h6> 
<p>使用函数：</p> 
<pre class="prettyprint"><code class=" hljs perl"><span class="hljs-keyword">int</span> pthread_mutex_destory(pthread_mutex_t <span class="hljs-variable">*mutex</span> );  </code></pre> 
<p>销毁一个互斥锁即意味着释放它所占用的资源，且要求锁当前处于开放状态。由于在Linux中，互斥锁并不占用任何资源，因此LinuxThreads中的 <code>pthread_mutex_destroy()</code>除了检查锁状态以外（锁定状态则返回EBUSY）没有其他动作。</p> 
<h5 id="死锁">死锁</h5> 
<h6 id="什么是死锁">什么是死锁</h6> 
<p>一般情况下，如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这叫做死锁（Deadlock）。 <br> 另一种：若线程A获得了锁1，线程B获得了锁2，这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1，于是线程A和B都永远处于挂起状态了。</p> 
<h6 id="死锁产生的四个必要条件">死锁产生的四个必要条件</h6> 
<p><strong>互斥条件：</strong>一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</p> 
<p><strong>请求与保持条件：</strong>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p> 
<p><strong>不可剥夺条件：</strong>进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</p> 
<p><strong>循环等待条件：</strong>若干进程间形成首尾相接循环等待资源的关系。</p> 
<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p> 
<h6 id="如何避免死锁">如何避免死锁</h6> 
<h6 id="预防死锁">预防死锁：</h6> 
<p>我们可以通过破坏死锁产生的4个必要条件来预防死锁。 <br> 首先明确一下资源互斥是资源使用的固有特性是无法改变的，所以只能从其他3个条件入手。</p> 
<p><strong>破坏”请求与保持条件“：</strong>第一种方法，静态分配，即每个进程在开始执行时就申请他所需要的全部资源。第二种方法，动态分配，即每个进程在申请所需要的资源时他本身不占用系统资源。</p> 
<p><strong>破坏“不可剥夺”条件：</strong>一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源，以及新申请的资源才可以重新启动，执行。</p> 
<p><strong>破坏“循环等待”条件：</strong>采用资源有序分配法。其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。</p> 
<h6 id="避免死锁">避免死锁:</h6> 
<p>死锁避免的基本思想：系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则予以分配，这是一种保证系统不进入死锁状态的动态策略。 </p> 
<h6 id="解除死锁">解除死锁</h6> 
<p>当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有： <br> <strong>剥夺资源：</strong>从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态； <br> <strong>撤消进程：</strong>可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</p> 
<p>参考： <br> 1.<a href="https://blog.csdn.net/jiajun2001/article/details/12624923">https://blog.csdn.net/jiajun2001/article/details/12624923</a> <br> 2.<a href="https://blog.csdn.net/jyy305/article/details/70077042">https://blog.csdn.net/jyy305/article/details/70077042</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/41a8444e9dbc920b357896a8e3b323b6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据存储——动态内存申请和释放（c语言）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/89ed4f9279916717478084a3145a6a0f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java中printf的用法总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>