<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C语言】数组详解，初学者一看就懂 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C语言】数组详解，初学者一看就懂" />
<meta property="og:description" content="你每天都在做很多看起来毫无意义的决定，但某天你的某个决定就能改变你的一生。——《西雅图不眠夜》 目录
什么是C语言数组？
1、一维数组的创建与初始化
1.1数组的创建格式
1.2数组的初始化
1.3一维数组的使用
1.4一维数组在内存中的存储
2、二维数组的创建与初始化
2.1二维数组的创建格式
2.2二维数组初始化
2.3二维数组的使用
2.4二维数组在内存中的存储
3、越界数组
4、为什么数组下标是从0开始的？
5、数组作为函数参数
5.1冒泡排序函数的错误设计
5.2数组名到底是什么？
5.3冒泡排序函数的正确设计
什么是C语言数组？ 首先，从字面了解数组是一堆数字组成的集合。C语言中数组是一组固定大小且相同类型元素的集合。数组分为一维数组和二维数组。数组类型的声明并不是对一个元素进行声明而是对整个数组里面的元素类型都进行声明。所有的数组元素都是在一块连续的地址上的存储的，第一个元素占最低的地址，最后一个元素占最高的地址。数组的下标从0开始到元素的个数减1结束。 1、一维数组的创建与初始化 1.1数组的创建格式 数组是由数组类型&#43;数组名&#43;数组大小组成的，其中最重要的是数组大小是一个常量表达式。结合下图理解：
🤼数组的创建格式有四种情况，如下所示：
情况1，定义一个数组并给定数组大小
int arry1[10]；//未初始化的名为arry1的整形数组大小是10
情况2，定义一个常量并给定数组大小为这个常量
const int a=5；//定义一个常量a=5
int arry5[a]；//未初始化的名为arry5的整形数组大小是5
情况3，数组大小为常量表达式
int arry6[5&#43;6]；//未初始化的名为arry6的整形数组大小是11
情况4，空数组
int arry7[]；//未初始化的名为arry7的整形数组大小未知
温馨提示：以上均是用整形定义的，您可以定义其他类型。
注意：数组创建，在C99标准之前， [] 中要给一个常量才可以，不能使用变量。在C99标准支持了变长数组的概念，数组的大小可以使用变量指定，但是数组不能初始化。
1.2数组的初始化 在了解数组的创建格式后，我们来看数组的初始化。初始化就是在创建数组后给定数组里面与数组类型相同的元素。初始化又分为完全初始化和不完全初始化，我们来看代码：
1、int arry[10] = { 0 };//完全初始化 2、int arry1[6] = { 1,2,3 };//不完全初始化 3、int arry2[5] = { 1,2,3,4,5 };//完全初始化 4、char arry3[] = { &#39;a&#39;,&#39;b&#39;,&#39;c&#39; };//完全初始化 5、char arry4[] = { &#39;a&#39;,&#39;b&#39;,66,&#39;c&#39; };//完全初始化 6、char arry5[] = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/024972e2e20fdbc4ca3a40d0b38a14f4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-08T14:47:15+08:00" />
<meta property="article:modified_time" content="2022-11-08T14:47:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C语言】数组详解，初学者一看就懂</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" height="236" src="https://images2.imgbox.com/28/9e/jrDcb1xl_o.png" width="250"></p> 
<p style="text-align:center;"><span style="color:#494949;"><strong>你每天都在做很多看起来毫无意义的决定，但某天你的某个决定就能改变你的一生。——《西雅图不眠夜》 </strong></span></p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AFC%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AFC%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%EF%BC%9F" rel="nofollow">什么是C语言数组？</a></p> 
<p id="1%E3%80%81%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">1、一维数组的创建与初始化</a></p> 
<p id="1.1%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F-toc" style="margin-left:40px;"><a href="#1.1%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F" rel="nofollow">1.1数组的创建格式</a></p> 
<p id="1.2%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#1.2%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">1.2数组的初始化</a></p> 
<p id="1.3%E4%B8%80%E5%A0%86%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#1.3%E4%B8%80%E5%A0%86%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">1.3一维数组的使用</a></p> 
<p id="%C2%A01.4%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8-toc" style="margin-left:40px;"><a href="#%C2%A01.4%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8" rel="nofollow">1.4一维数组在内存中的存储</a></p> 
<p id="2%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">2、二维数组的创建与初始化</a></p> 
<p id="2.1%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F-toc" style="margin-left:40px;"><a href="#2.1%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F" rel="nofollow">2.1二维数组的创建格式</a></p> 
<p id="2.2%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#2.2%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">2.2二维数组初始化</a></p> 
<p id="2.3%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#2.3%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">2.3二维数组的使用</a></p> 
<p id="2.4%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8-toc" style="margin-left:40px;"><a href="#2.4%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8" rel="nofollow">2.4二维数组在内存中的存储</a></p> 
<p id="3%E3%80%81%E8%B6%8A%E7%95%8C%E6%95%B0%E7%BB%84-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E8%B6%8A%E7%95%8C%E6%95%B0%E7%BB%84" rel="nofollow">3、越界数组</a></p> 
<p id="4%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E6%98%AF%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%EF%BC%9F-toc" style="margin-left:0px;"><a href="#4%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E6%98%AF%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%EF%BC%9F" rel="nofollow">4、为什么数组下标是从0开始的？</a></p> 
<p id="5%E3%80%81%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-toc" style="margin-left:0px;"><a href="#5%E3%80%81%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0" rel="nofollow">5、数组作为函数参数</a></p> 
<p id="5.1%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0%E7%9A%84%E9%94%99%E8%AF%AF%E8%AE%BE%E8%AE%A1-toc" style="margin-left:40px;"><a href="#5.1%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0%E7%9A%84%E9%94%99%E8%AF%AF%E8%AE%BE%E8%AE%A1" rel="nofollow">5.1冒泡排序函数的错误设计</a></p> 
<p id="5.2%E6%95%B0%E7%BB%84%E5%90%8D%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px;"><a href="#5.2%E6%95%B0%E7%BB%84%E5%90%8D%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">5.2数组名到底是什么？</a></p> 
<p id="5.3%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0%E7%9A%84%E6%AD%A3%E7%A1%AE%E8%AE%BE%E8%AE%A1-toc" style="margin-left:40px;"><a href="#5.3%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0%E7%9A%84%E6%AD%A3%E7%A1%AE%E8%AE%BE%E8%AE%A1" rel="nofollow">5.3冒泡排序函数的正确设计</a></p> 
<hr> 
<h2 id="%E4%BB%80%E4%B9%88%E6%98%AFC%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%EF%BC%9F"><span style="color:#0d0016;"><strong>什么是C语言数组？</strong></span></h2> 
<ul><li><span style="color:#0d0016;"><strong>首先，从字面了解数组是一堆数字组成的集合。C语言中数组是一组固定大小且相同类型元素的集合。数组分为一维数组和二维数组。</strong></span></li><li><span style="color:#0d0016;"><strong>数组类型的声明并不是对一个元素进行声明而是对整个数组里面的元素类型都进行声明。</strong></span></li><li><span style="color:#0d0016;"><strong>所有的数组元素都是在一块连续的地址上的存储的，第一个元素占最低的地址，最后一个元素占最高的地址。</strong></span></li><li><span style="color:#0d0016;"><strong>数组的下标从0开始到元素的个数减1结束。</strong></span></li></ul> 
<hr> 
<p class="img-center"><img alt="" height="254" src="https://images2.imgbox.com/08/68/qz74CXMp_o.png" width="700"></p> 
<hr> 
<h2 id="1%E3%80%81%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span style="color:#0d0016;"><strong>1、一维数组的创建与初始化</strong></span></h2> 
<h3 id="1.1%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F"><span style="color:#333333;"><strong>1.1数组的创建格式</strong></span></h3> 
<p><span style="color:#0d0016;"><strong>数组是由数组类型+数组名+数组大小组成的，其中最重要的是数组大小是一个常量表达式。结合下图理解：</strong></span></p> 
<p><img alt="" height="132" src="https://images2.imgbox.com/9f/49/yH7NoeUs_o.png" width="700"></p> 
<hr> 
<p> <span style="color:#be191c;"><strong>🤼数组的创建格式有四种情况，如下所示：</strong></span></p> 
<blockquote> 
 <p><strong><span style="color:#1c7331;">情况1，定义一个数组并给定数组大小</span></strong></p> 
 <p><strong><span style="color:#511b78;">int arry1[10]；</span><span style="color:#494949;">//未初始化的名为arry1的整形数组大小是10</span></strong></p> 
 <hr> 
 <p><strong><span style="color:#1c7331;">情况2，定义一个常量并给定数组大小为这个常量</span></strong></p> 
 <p><strong><span style="color:#511b78;">const int a=5；</span><span style="color:#494949;">//定义一个常量a=5</span></strong></p> 
 <p><strong><span style="color:#511b78;">int arry5[a]；</span><span style="color:#494949;">//未初始化的名为arry5的整形数组大小是5</span></strong></p> 
 <hr> 
 <p><span style="color:#1c7331;"><strong>情况3，数组大小为常量表达式</strong></span></p> 
 <p><strong><span style="color:#511b78;">int arry6[5+6]；</span><span style="color:#494949;">//未初始化的名为arry6的整形数组大小是11</span></strong></p> 
 <hr> 
 <p><span style="color:#1c7331;"><strong>情况4，空数组</strong></span></p> 
 <p><strong><span style="color:#511b78;">int arry7[]；</span><span style="color:#494949;">//未初始化的名为arry7的整形数组大小未知</span></strong></p> 
 <hr> 
 <p><strong><span style="color:#be191c;">温馨提示</span><span style="color:#0d0016;">：</span><span style="color:#494949;">以上均是用整形定义的，您可以定义其他类型。</span></strong></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>注意</strong></span><span style="color:#0d0016;"><strong>：数组创建，在C99标准之前， [] 中要给一个常量才可以，不能使用变量。在C99标准支持了变长数组的概念，数组的大小可以使用变量指定，但是数组不能初始化。</strong></span></p> 
<hr> 
<h3 id="1.2%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><strong><span style="color:#0d0016;">1.2数组的初始化</span></strong></h3> 
<p><span style="color:#0d0016;"><strong>在了解数组的创建格式后，我们来看数组的初始化。初始化就是在创建数组后给定数组里面与数组类型相同的元素。初始化又分为完全初始化和不完全初始化，我们来看代码：</strong></span></p> 
<pre><code class="language-cpp">    1、int arry[10] = { 0 };//完全初始化
    2、int arry1[6] = { 1,2,3 };//不完全初始化
	3、int arry2[5] = { 1,2,3,4,5 };//完全初始化
	4、char arry3[] = { 'a','b','c' };//完全初始化
	5、char arry4[] = { 'a','b',66,'c' };//完全初始化
	6、char arry5[] = "abcdef";//完全初始化
    7、char arry6[10] = "abc";//不完全初始化</code></pre> 
<blockquote> 
 <p><span style="color:#1c7331;"><strong>以上代码1~7我依次来讲解：</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>1、int arry[10] = { 0 };</strong></span><span style="color:#494949;"><strong>arry数组是完全初始化，10个元素全是0</strong></span></p> 
 <img alt="" class="left" height="309" src="https://images2.imgbox.com/8f/8c/zBabUXAA_o.png" width="250"> 
 <p></p> 
 <p><span style="color:#fe2c24;"><strong>2、int arry1[6] = { 1,2,3 };</strong></span><span style="color:#494949;"><strong>arry1数组是不完全初始化，我们初始化了前三个元素，剩余的三个元素默认初始化为0。那么前三个元素是1，2，3。后三个元素是0，0，0</strong></span><span style="color:#0d0016;">。</span></p> 
 <p class="img-center"><img alt="" height="309" src="https://images2.imgbox.com/d4/57/QlneZiGL_o.png" width="250"></p> 
 <p></p> 
 <hr> 
 <p><strong><span style="color:#fe2c24;">3、int arry2[5] = { 1,2,3,4,5 };</span><span style="color:#494949;">arry2数组是完全初始化，5个元素都初始化了。</span></strong></p> 
 <img alt="" class="left" height="309" src="https://images2.imgbox.com/56/f4/vx25bj1b_o.png" width="250"> 
 <p></p> 
 <p><span style="color:#fe2c24;"><strong>4、char arry3[] = { 'a','b','c' };</strong></span><span style="color:#494949;"><strong>arry3数组是完全完全初始化，它不指定元素的个数。但编译器通过初始化内容来确定该数组元素的个数。</strong></span></p> 
 <p class="img-center"><img alt="" height="309" src="https://images2.imgbox.com/6a/4c/YRvNP5r8_o.png" width="250"></p> 
 <hr> 
 <p><span style="color:#fe2c24;"><strong>5、char arry4[] = { 'a','b',66,'c' };</strong></span><span style="color:#494949;"><strong>arry4也是完全初始化，它也没指定元素的个数，编译器通过初始化内容来确定该数组元素个数。其中66虽然是整型数字，但是数组类型是char所以编译器也认为66对应的是字符B。B的ASCLL码是66。</strong></span></p> 
 <img alt="" class="left" height="387" src="https://images2.imgbox.com/4a/d9/AfoVytEY_o.png" width="250"> 
 <p></p> 
 <p><span style="color:#fe2c24;"><strong>6、char arry5[] = "abcdef";</strong></span><span style="color:#494949;"><strong>arry5数组是完全初始化，未给定数组大小，编译器通过初始化内容来确定元素个数，但由于初始化是用双引号（""）引起来，所以编译器自行在字符串末尾加上字符串结束标识符（转义字符）'\0'。因此虽输入5个字符，实际大小为6个字符。</strong></span></p> 
 <p class="img-center"><img alt="" height="387" src="https://images2.imgbox.com/9c/77/U6cXAxtT_o.png" width="250"></p> 
 <hr> 
 <p><strong><span style="color:#fe2c24;">7、char arry6[10] = "abc";</span><span style="color:#494949;">arry6数组是不完全初始化，初始化了前三个字符，其余字符由编译器默认为转义字符'\0'。</span></strong></p> 
 <img alt="" class="left" height="387" src="https://images2.imgbox.com/7e/61/UIC79EW1_o.png" width="250"> 
 <p></p> 
 <p><span style="color:#494949;"><strong>我们可以用sizeof取出数组占的总字节数然后除以siz该数组的首元素字节数就可以得出该数组的元素个数。例如：sizeof(arry)/sizeof(arry[0])。</strong></span></p> 
 <p><img alt="" height="564" src="https://images2.imgbox.com/c8/fe/JPf0AcN8_o.png" width="1200"></p> 
 <p></p> 
 <p></p> 
 <p></p> 
</blockquote> 
<hr> 
<p><span style="color:#0d0016;"><strong>🤼‍♀️</strong></span><span style="color:#be191c;"><strong> 那么如果我们想要将定义的数组以字符串的形式打印，我们该怎么做呢。有以下代码：</strong></span></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	char arry1[] = { 'a','b','c' };
	char arry2[] = "abc";
	printf("%s\n", arry1);
	printf("%s\n", arry2);
	return 0;
}</code></pre> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>输出结果：</strong></span><br><span style="color:#494949;"><strong>abc烫烫烫烫?烫烫烫?d<br> abc</strong></span></p> 
 <hr> 
 <p><span style="color:#494949;"><strong>我们可以看到只有arry2输出了正确的值，为什么会这样呢。我们在{}里面定义的虽然是完全初始化了，但是要以字符串的形式打印出来我们需要在{}里结尾处加上一个结束标识符</strong></span><span style="color:#fe2c24;"><strong>'\0'</strong></span><span style="color:#494949;"><strong>。</strong></span></p> 
 <p></p> 
 <p><img alt="" height="266" src="https://images2.imgbox.com/61/f0/XowjuLtE_o.png" width="1200"></p> 
 <hr> 
 <p><span style="color:#494949;"><strong>在{}字符结尾加上</strong></span><span style="color:#fe2c24;"><strong>'\0'</strong></span><span style="color:#494949;"><strong>后：</strong></span></p> 
 <p><strong><span style="color:#494949;"><img alt="" height="500" src="https://images2.imgbox.com/de/43/Fl01e34M_o.png" width="1200"></span></strong></p> 
 <p><strong><span style="color:#494949;">当我们取这两个数组的长度时'\0'也算作一个字符，但字符串输出时并不显示'\0'，'\0'只是做一个结束标识，但还是得占一个字符内存。</span></strong></p> 
</blockquote> 
<hr> 
<h3 id="1.3%E4%B8%80%E5%A0%86%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8"><strong><span style="color:#0d0016;">1.3一维数组的使用</span></strong></h3> 
<p><span style="color:#494949;"><strong>我们先来介绍一个操作符：</strong></span><span style="color:#fe2c24;"><strong> [] </strong></span><span style="color:#494949;"><strong>，下标引用操作符。它其实就是数组访问的操作符。数组的下标是从0开始到元素的个数减1结束。我们来看程序，有一程序，定义一个一维数组，顺序打印和逆序打印出这个这个数组。</strong></span></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int arry[10] = {1,2,3,4,5,6,7,8,9,10};//定义一个数组元素为1-10
	for (int i = 0; i &lt; 10; i++)
	{
		printf("%d ", arry[i]);//依次输出arry[0]-arry[9]
	}
	printf("\n");
	for (int j = 9; j &gt;=0; j--)
	{
		printf("%d ", arry[j]);//依次输出arry[9]-arry[0]
	}
	return 0;
}</code></pre> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>输出：</strong></span></p> 
 <p><span style="color:#494949;"><strong>1 2 3 4 5 6 7 8 9 10<br> 10 9 8 7 6 5 4 3 2 1</strong></span></p> 
 <hr> 
 <p><span style="color:#494949;"><strong>上面我们说到数组的下标是从0开始直到元素的个数减1结束，因此遍历打印数组，for循环是很好的选择。</strong></span></p> 
 <p><img alt="" height="239" src="https://images2.imgbox.com/96/8b/PXFB7UIY_o.png" width="800"></p> 
</blockquote> 
<hr> 
<blockquote> 
 <p><span style="color:#1c7331;"><strong>总结：</strong></span></p> 
 <ul><li><span style="color:#494949;"><strong>数组是使用下标来访问的，下标是从0开始</strong></span></li><li><span style="color:#494949;"><strong>数组的大小可以通过sizeof计算得到</strong></span></li></ul> 
 <p><img alt="" height="198" src="https://images2.imgbox.com/c6/de/j5tx6dHB_o.png" width="800"></p> 
</blockquote> 
<hr> 
<h3 id="%C2%A01.4%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8"><strong><span style="color:#0d0016;">1.4一维数组在内存中的存储</span></strong></h3> 
<p><span style="color:#494949;"><strong>一维数组在内存中是连续着存放的，随着下标的增长下标所在的地址是由低往高增长的。</strong></span></p> 
<p><img alt="" height="165" src="https://images2.imgbox.com/16/bd/O8jRrTXn_o.png" width="600"></p> 
<hr> 
<p><strong><span style="color:#be191c;"> 🤼我们来看程序：</span></strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int arry[] = { 1,2,3,4,5,6,7 };
	int n = sizeof(arry) / sizeof(arry[0]);
	for (int i = 0; i &lt; n; i++)
	{
		printf("&amp;arry[%d] = %p\n", i, &amp;arry[i]);
	}
	return 0;
}
</code></pre> 
<blockquote> 
 <p><span style="color:#494949;"><strong>输出结果如下图：</strong></span></p> 
 <p><img alt="" height="537" src="https://images2.imgbox.com/0c/02/EvT9dZtF_o.png" width="1200"></p> 
 <hr> 
 <p><span style="color:#494949;"><strong>我们可以通过地址找到找到该元素，怎样找呢用指针来找。指针指向数组中元素的地址，再对指针进行解引用就可以找到该元素。比如我想找到数组的第3个元素，我们来看图理解：</strong></span></p> 
 <p><img alt="" height="317" src="https://images2.imgbox.com/f5/74/cKY5eGfw_o.png" width="1200"></p> 
 <p><span style="color:#494949;"><strong>第3个元素对应数组的下标是2，指针p指向了下标2对应的地址。再对p进行解引用就可以得到该元素。</strong></span></p> 
</blockquote> 
<hr> 
<h2 id="2%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span style="color:#0d0016;"><strong>2、二维数组的创建与初始化</strong></span></h2> 
<h3 id="2.1%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F"><strong><span style="color:#0d0016;">2.1二维数组的创建格式</span></strong></h3> 
<p><span style="color:#494949;"><strong>上面我们了解到了一维数组的创建格式，那么二维数组的创建格式与一维数组的创建格式相差不大。下面我就来介绍，先看一组代码：</strong></span></p> 
<pre><code class="language-cpp">   1、int arry1[2][3];
   2、char arry2[3][4];
   3、float arry3[5][6];</code></pre> 
<blockquote> 
 <p><span style="color:#494949;"><strong>我们看到二维数组也是一样由数据类型+数组名+数组大小构成，唯一不同点就是比一维数组多了一个[]。多的一个[]代表列数前面的[]代表行数。</strong></span></p> 
 <ul><li><strong><span style="color:#fe2c24;">1、int arry1[2][3];</span><span style="color:#494949;">表示这是一个2行3列的二维数组，arry1里面有6个元素</span></strong></li><li><strong><span style="color:#fe2c24;">2、char arry2[3][4];</span><span style="color:#494949;">表示这是一个3行4列的二维数组，arry2里面有12个元素</span></strong></li><li><strong><span style="color:#fe2c24;">3、float arry3[5][6];</span><span style="color:#494949;">表示这是一个5行6列的二维数组 ，arry3里面有30个元素</span></strong></li></ul> 
</blockquote> 
<hr> 
<h3 id="2.2%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><strong><span style="color:#0d0016;">2.2二维数组初始化</span></strong></h3> 
<p><span style="color:#494949;"><strong>二维数组也也分为完全初始化和不完全初始化，我们来看代码：</strong></span></p> 
<pre><code class="language-cpp">int main()
{
	int arry1[2][3] = {1,2,3,4,5,6};
	int arry2[3][4] = {1,2,3,4,5,6};
	int arry3[3][2] = { {1,2},{3,4},{5,6} };
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong><span style="color:#494949;">arry1完全初始化，初始化6个元素。</span></strong></p> 
 <p><strong><span style="color:#494949;">arry2不完全初始化，初始化前两行部分元素，后两行默认为0</span></strong></p> 
 <p><strong><span style="color:#494949;">arry3完全初始化，写成{}里面多个{}的形式，怎样理解呢。{}里面的第一个{}代表第一行，第二个{}代表第二行，第三个{}代表第三行。列数就是最外层{}里面{}的个数，我们结合监视窗口来理解：</span></strong></p> 
 <p><img alt="" height="429" src="https://images2.imgbox.com/33/50/nAczSXCs_o.png" width="1200"></p> 
 <hr> 
 <p><span style="color:#494949;"><strong>如何通过下标来访问各个元素呢，我们拿arry2来举例。与一维数组一样行数开始从0开始到总行数减1结束，列也是从0开始到总列数减1结束。</strong></span></p> 
 <p><img alt="" height="281" src="https://images2.imgbox.com/fd/f8/NWjbvZgQ_o.png" width="400"></p> 
</blockquote> 
<hr> 
<p> 🤼<strong><span style="color:#be191c;">注意，一维数组的数组大小可以省略同过初始化来确定元素个数，二维数组中的行可以省略，列不能省略。如以下代码：</span></strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int arry1[][2] = { 1,2,3,4,5,6,7,8 };
	int arry2[][4] = { 1,2,3,4,5,6,7,8 };
	return 0;
}</code></pre> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>结果如下： </strong></span></p> 
 <p><span style="color:#494949;"><strong>行省略话，系统根据初始化的内容会自动生成相应的行数。arry1生成了</strong></span><span style="color:#fe2c24;"><strong>4行2列</strong></span><span style="color:#494949;"><strong>的二维数组，arry2生成了</strong></span><span style="color:#fe2c24;"><strong>2行4列</strong></span><span style="color:#494949;"><strong>的二维数组。</strong></span></p> 
 <p><img alt="" height="408" src="https://images2.imgbox.com/b2/09/gcJlegAz_o.png" width="1200"></p> 
</blockquote> 
<hr> 
<h3 id="2.3%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8"><strong><span style="color:#0d0016;">2.3二维数组的使用</span></strong></h3> 
<p><span style="color:#494949;"><strong>二维数组的使用也是通过下标来找到各个元素的，第一行的起始下标是0最后一行下标是总行数-1，列也是一样的。第一列的起始下标是0最后一列下标是总列数-1。我们可以通过</strong></span><span style="color:#fe2c24;"><strong>行的下标</strong></span><span style="color:#494949;"><strong>和</strong></span><span style="color:#fe2c24;"><strong>列的下标</strong></span><span style="color:#494949;"><strong>结合起来找到某一元素。如我要找第二行第二个元素：</strong></span><span style="color:#be191c;"><strong>arry[1][1]</strong></span><span style="color:#494949;"><strong>。</strong></span></p> 
<p><span style="color:#be191c;"><strong>🤼‍♀️定义一个二维数组，打印出这个数组的各个元素：</strong></span></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int arry[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };//定义一个3行4列的二维数组
	for (int i = 0; i &lt; 3; i++)//控制行号
	{
		for (int j = 0; j &lt; 4; j++)//控制列号
		{
			printf("%d ", arry[i][j]);//输出第i行的元素
		}
		printf("\n");//每输出一行换行一次
	}
	return 0;
}</code></pre> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>输出结果：</strong></span></p> 
 <p><span style="color:#494949;"><strong>1 2 3 4<br> 5 6 7 8<br> 9 10 11 12</strong></span></p> 
</blockquote> 
<hr> 
<h3 id="2.4%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8"><strong><span style="color:#0d0016;">2.4二维数组在内存中的存储</span></strong></h3> 
<p><span style="color:#be191c;"><strong>🤼‍♀️有一程序，定义一个二维数组并初始化该数组，打印出各个元素所占的地址：</strong></span></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int arry[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };
	for (int i = 0; i &lt; 3; i++)
	{
		for (int j = 0; j &lt; 4; j++)
		{
			printf("&amp;arry[%d][%d] = %p\n",i,j,&amp;arry[i][j]);
		}
	}
	return 0;
}
</code></pre> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>输出结果：</strong></span></p> 
 <p><img alt="" height="410" src="https://images2.imgbox.com/e1/0d/z2U8X9zX_o.png" width="1200"></p> 
 <p></p> 
 <hr> 
 <p><span style="color:#494949;"><strong>我们发现，二维数组在内存中的地址也是连续的 。</strong></span><img alt="" height="457" src="https://images2.imgbox.com/fa/1a/s7ATC4ap_o.png" width="1092"></p> 
 <p><span style="color:#494949;"><strong>从侧面说明了二维数组也是一个一维数组，只不过定义的时候把它定义成了二维数组。如一个arry[12]定义成arry[3][4]。或者这样理解由三个一维数组组成的一个二维数组。这样我们就不难明白了。</strong></span></p> 
</blockquote> 
<hr> 
<h2 id="3%E3%80%81%E8%B6%8A%E7%95%8C%E6%95%B0%E7%BB%84"><span style="color:#0d0016;"><strong>3、越界数组</strong></span></h2> 
<p><strong><span style="color:#494949;">数组的下标是有范围限制的，设数组有n个元素，数组的下标规定从0开始的，最后一个元素的下标是n-1。如果数组的下标小于0或者大于n-1，此时数据就越界访问了，超出了定义数组时数组的合法空间。这就是为什么我们经常打印出一堆乱码</span><span style="color:#fe2c24;">烫烫烫烫</span><span style="color:#494949;">什么的。最后C语言本身是不做数组下标的越界检查，编译器也不一定报错，不报错不代表程序就是正确的。所以我们一定要认真调试代码。</span></strong><br><span style="color:#be191c;"><strong>🤼‍♀️我们来看一程序：</strong></span></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
 
int main()
{
	int arry[] = { 6,7,8,9,10 };
	int n = sizeof(arry) / sizeof(arry[0]);
	for (int i = 0; i &lt;= n; i++)
	{
		printf("%d ", arry[i]);
	}
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">输出：</span><span style="color:#494949;">6 7 8 9 10 -858993460</span></strong></p> 
 <hr> 
 <p><strong>以上代码for语句中i&lt;=n，超出了下标的最大范围。导致最后一次输出一堆乱码，这就是越界数组。</strong></p> 
</blockquote> 
<hr> 
<h2><span style="color:#0d0016;"><strong>4、为什么数组下标是从0开始的？</strong></span></h2> 
<p><span style="color:#494949;"><strong>为啥数组下标是从0开始的，是为了数组寻址更方便。按我们平常的思想从1开始不是更方便吗？数组是一种线性表数据结构，它是一相同类型的数据在内存中连续存储的。当我们创建一个数组的时候。</strong></span></p> 
<p><strong><span style="color:#0d0016;">系统会根据以下的寻址公式在内存中开辟一道空间</span><span style="color:#0d0016;">：</span></strong></p> 
<blockquote> 
 <p><span style="color:#494949;"><strong>a[i]_address = base_address + i * data_type_size</strong></span></p> 
</blockquote> 
<p><span style="color:#0d0016;"><strong>如果是下标从1开始，公式就会变成这样：</strong></span></p> 
<blockquote> 
 <p><span style="color:#494949;"><strong>a[i]_address = base_address + (i-1)*type_size</strong></span></p> 
</blockquote> 
<p><strong><span style="color:#494949;">我们可以看到，如果是从1开始每次寻找该数组的地址都要进行减1 ，别看这一个小小的减1。当我们的数组元素过多的时候，进行的减1也变多了。这样程序运行的速度就变慢了，占的内存也更多了。那么如果我们从0开始的话就不会出现每次寻址的时候都要进行减1这样的操作。</span></strong></p> 
<hr> 
<h2 id="5%E3%80%81%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span style="color:#0d0016;"><strong>5、数组作为函数参数</strong></span></h2> 
<h3 id="5.1%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0%E7%9A%84%E9%94%99%E8%AF%AF%E8%AE%BE%E8%AE%A1"><span style="color:#0d0016;"><strong>5.1冒泡排序函数的错误设计</strong></span></h3> 
<p><span style="color:#494949;"><strong>首先我们要知道到冒泡排序是什么意思，冒泡排序就是给你一组无序的数据。让你依次判断两数之间最大的数，直到把最大的数放到最后。假设数组有n个元素，那么就判断n-1次。因为当你判断n-1次的时候最大的数已经是在数组的最后一位了。我们来看一个图来理解：</strong></span></p> 
<p><img alt="" height="795" src="https://images2.imgbox.com/b1/e8/tKBur47B_o.png" width="1200"></p> 
<hr> 
<p><span style="color:#be191c;"><strong>🤼我们来看错误的设计：</strong></span></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

void MaoPao(int arry[])
{
	int n = sizeof(arry) / sizeof(arry[0]);//数组大小
	for (int i = 0; i &lt; n - 1; i++)
	{
		for (int j = 0; j &lt; n - 1 - i; j++)
		{
			int tmp = 0;
			tmp = arry[j];
			arry[j] = arry[j + 1];
			arry[j + 1] = tmp;
		}
	}
}
int main()
{
	int arry[] = { 2,3,5,4,6,8,9,7,1,0 };//初始化数组
	MaoPao(arry);
	int n = sizeof(arry) / sizeof(arry[0]);//数组大小
	for (int i = 0; i &lt; n; i++)
	{
		printf("%d ", arry[i]);
	}
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">输出结果：</span><span style="color:#494949;">2 3 5 4 6 8 9 7 1 0 </span></strong></p> 
 <hr> 
 <p><span style="color:#494949;"><strong>因为实参在传参的时候传过去的是arry数组的首地址，sizeof首地址/sizeof首地址=1。所以导致程序没有发生改变。</strong></span></p> 
</blockquote> 
<p><strong>为什么会出现输出的结果还是原数组的值的，原因就是我们传参过去参数问题。具体解释如下：</strong> </p> 
<hr> 
<h3><span style="color:#0d0016;"><strong>5.2数组名到底是什么？</strong></span></h3> 
<p><span style="color:#be191c;"><strong>🤼数组名就是数组首元素的地址，我们来验证一下：</strong></span></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int arry[] = { 1,2,3 };
	printf("%p\n", &amp;arry[0]);
	printf("%p\n", arry);
	printf("%d\n", *arry);
	return 0;
}</code></pre> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>输出：</strong></span></p> 
 <p><span style="color:#494949;"><strong>012FF7AC<br> 012FF7AC<br> 1</strong></span></p> 
 <hr> 
 <p><span style="color:#494949;"><strong>第一个printf输出的是1的地址，就是首元素的地址。</strong></span></p> 
 <p><span style="color:#494949;"><strong>第二个printf输出的是arry数组名的地址，同时输出的也是首元素的地址，可见数组名就是首元素的地址。</strong></span></p> 
 <p><span style="color:#494949;"><strong>第三个printf输出的是对arry数组名的地址的解引用，输出1说明了数组名就是一个地址且是数组首元素的地址。</strong></span></p> 
 <p><span style="color:#494949;"><strong>以上三个例子都说明了，数组名等同于数组首元素地址。也就是以后我们可以通过数组名来进行操作数组。</strong></span></p> 
</blockquote> 
<hr> 
<p><span style="color:#0d0016;"><strong> 但是有两个例外：</strong></span></p> 
<ul><li><strong><span style="color:#494949;">sizeof（数组名），这里的sizeof取的是整个数组的大小。</span></strong></li><li><strong><span style="color:#494949;">&amp;数组名，这里的数组名表示整个数组，&amp;数组名取出的是整个数组的地址。</span></strong></li></ul> 
<p><strong><span style="color:#be191c;">🤼‍♀️我们再来看一个代码：</span></strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int arry[10] = { 0 };
	printf("%d\n", sizeof(arry));
	printf("%p\n", arry);
	printf("%p\n", arry + 1);
	printf("%p\n", &amp;arry[0]);
	printf("%p\n", &amp;arry[0]+1);
	printf("%p\n", &amp;arry+1);
	return 0;
}</code></pre> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>输出：</strong></span></p> 
 <p><strong><span style="color:#494949;">40<br> 012FF77C<br> 012FF780<br> 012FF77C<br> 012FF780<br> 012FF7A4</span></strong></p> 
 <hr> 
 <p><span style="color:#494949;"><strong>第一个printf证明了sizeof（数组名）是取整个数组的大小。</strong></span><span style="color:#494949;"><strong>最后一个printf证明了&amp;数组名取的是整个数组地址，只能说数组名的地址是首元素的地址也是整个数组的地址。不同的情况具体分析。</strong></span></p> 
 <p><img alt="" height="516" src="https://images2.imgbox.com/bf/9e/oo8wzoF6_o.png" width="1200"></p> 
 <p><strong>可能还有小伙不懂上图中是怎样观察到不同的，这就与我们的十六进制知识有关了。我们只看后两位，7C到80加4H（4D），7C到A4+28H（40D）。H代表十六进制，D代表十进制。也就是说最后一个printf输出的整个数组的地址+1后的地址值。</strong></p> 
</blockquote> 
<hr> 
<h3 id="5.3%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0%E7%9A%84%E6%AD%A3%E7%A1%AE%E8%AE%BE%E8%AE%A1"><span style="color:#0d0016;"><strong>5.3冒泡排序函数的正确设计</strong></span></h3> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

void MaoPao(int arry[],int n)
{
	for (int i = 0; i &lt; n - 1; i++)
	{
		for (int j = 0; j &lt; n - 1 - i; j++)
		{
			int tmp = 0;
			if (arry[j] &gt; arry[j + 1])
			{
				tmp = arry[j];
				arry[j] = arry[j + 1];
				arry[j + 1] = tmp;
			}
		}
	}
}
int main()
{
	int arry[] = { 2,3,5,4,6,8,9,7,1,0 };
	int n = sizeof(arry) / sizeof(arry[0]);
	MaoPao(arry,n);
	for (int i = 0; i &lt; n; i++)
	{
		printf("%d ", arry[i]);
	}
	return 0;
}
</code></pre> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>输出：</strong></span><span style="color:#494949;"><strong>0 1 2 3 4 5 6 7 8 9</strong></span></p> 
 <hr> 
 <p><span style="color:#494949;"><strong>以上我们在传参之前就求好数组元素的个数，再把求好的数组元素个数传给MaoPao函数。这样就可以做到万无一失了。</strong></span></p> 
</blockquote> 
<hr> 
<p style="text-align:center;"><span style="color:#333333;"><strong>本期博客到这里就结束，感谢各位的耐心观看。</strong></span></p> 
<p style="text-align:center;"><strong><span style="color:#494949;"><img alt="" height="237" src="https://images2.imgbox.com/ad/cd/GLEZDcLm_o.jpg" width="250"></span></strong></p> 
<p style="text-align:center;"><span style="color:#494949;"><strong>Nave Give Up </strong></span></p> 
<hr> 
<p><strong> <a class="link-info" href="https://blog.csdn.net/weixin_64916311?type=blog" title="拳击哥的主页">拳击哥的主页</a></strong></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0d588506dbbfd4ab38792db72fbc5d9c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">手机如何实现边充电边传输数据？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4201650dc40116963d0098558e173837/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue3.0有哪些哪些更新</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>