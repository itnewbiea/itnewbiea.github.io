<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JWT令牌的获取与过滤器Filter的使用 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JWT令牌的获取与过滤器Filter的使用" />
<meta property="og:description" content="JWT，全称JSON Web Token（JSON Web令牌），是一个开放标准 (rfc7519)。它定义了一种紧凑的、自包含的方式，以JSON对象的形式安全地在各方之间传输信息。这种信息可以被验证和信任，因为它是通过数字签名实现的。
JWT可以使用HMAC算法或使用RSA的公钥/私钥对进行签名，防止被篡改。JWT基于json，非常方便解析，可以在令牌中自定义丰富的内容，易扩展。通过非对称加密算法及数字签名技术，JWT防止篡改，安
全性高。
//生成JWT @Test public void testGenJwt(){ Map&lt;String,Object&gt; claims = new HashMap&lt;&gt;(); claims.put(&#34;id&#34;, 1); claims.put(&#34;name&#34;, &#34;tom&#34;); String jwt = Jwts.builder() .signWith(SignatureAlgorithm.HS256, &#34;monian&#34;) //签名算法 .setClaims(claims) //自定义内容(载荷) .setExpiration(new Date(System.currentTimeMillis() &#43; 3600 * 1000)) //设置有效期为1h .compact(); System.out.println(jwt); } //解析令牌 @Test public void testParseJwt(){ Claims claims = Jwts.parser() .setSigningKey(&#34;monian&#34;) .parseClaimsJws(&#34;eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoidG9tIiwiaWQiOjEsImV4cCI6MTcwMTUxMTAwMH0.3ejLF6AimqpzbmTmN6WPcJvxoXAFPT9c5oNbk-0U5o4&#34;) .getBody(); System.out.println(claims); } } 控制台：
eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoidG9tIiwiaWQiOjEsImV4cCI6MTcwMTY2Mzc0NX0.HGgjyiW398CeKGosnOXGxd68KF3nJ_R8LYRrkG8-Ih8 在JWT官网解析可得：
通过测试类解析令牌可得： Demo测试：通过JWT令牌判断用户是否登录，否则不能访问相关的数据： @Slf4j @WebFilter(urlPatterns = &#34;/*&#34;) public class LoginCheckFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse resp = (HttpServletResponse) response; //1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b634aa8971450151a5c8e9dacc8e0042/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-04T11:34:31+08:00" />
<meta property="article:modified_time" content="2023-12-04T11:34:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JWT令牌的获取与过滤器Filter的使用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>JWT，全称JSON Web Token（JSON Web令牌），是一个开放标准 (rfc7519)。它定义了一种紧凑的、自包含的方式，以JSON对象的形式安全地在各方之间传输信息。这种信息可以被验证和信任，因为它是通过数字签名实现的。</p> 
<p>JWT可以使用HMAC算法或使用RSA的公钥/私钥对进行签名，防止被篡改。JWT基于json，非常方便解析，可以在令牌中自定义丰富的内容，易扩展。通过非对称加密算法及数字签名技术，JWT防止篡改，安</p> 
<p>全性高。</p> 
<pre><code class="language-java">    //生成JWT
    @Test
    public void testGenJwt(){
        Map&lt;String,Object&gt; claims = new HashMap&lt;&gt;();
        claims.put("id", 1);
        claims.put("name", "tom");

        String jwt = Jwts.builder()
                .signWith(SignatureAlgorithm.HS256, "monian") //签名算法
                .setClaims(claims) //自定义内容(载荷)
                .setExpiration(new Date(System.currentTimeMillis() + 3600 * 1000)) //设置有效期为1h
                .compact();
        System.out.println(jwt);
    }

    //解析令牌
    @Test
    public void testParseJwt(){
        Claims claims = Jwts.parser()
                .setSigningKey("monian")
                .parseClaimsJws("eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoidG9tIiwiaWQiOjEsImV4cCI6MTcwMTUxMTAwMH0.3ejLF6AimqpzbmTmN6WPcJvxoXAFPT9c5oNbk-0U5o4")
                .getBody();
        System.out.println(claims);
    }
}
</code></pre> 
<p> 控制台：</p> 
<p><img alt="" height="235" src="https://images2.imgbox.com/3b/a0/3bHBeYOH_o.png" width="985"></p> 
<pre><code class="language-XML">eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoidG9tIiwiaWQiOjEsImV4cCI6MTcwMTY2Mzc0NX0.HGgjyiW398CeKGosnOXGxd68KF3nJ_R8LYRrkG8-Ih8</code></pre> 
<p> 在JWT官网解析可得：</p> 
<p><img alt="" height="487" src="https://images2.imgbox.com/7c/b7/qr5ixMqt_o.png" width="1200"></p> 
<p></p> 
<p>通过测试类解析令牌可得： </p> 
<p><img alt="" height="113" src="https://images2.imgbox.com/fb/86/RJsYNNa3_o.png" width="262"></p> 
<p></p> 
<p>Demo测试：通过JWT令牌判断用户是否登录，否则不能访问相关的数据： </p> 
<pre><code class="language-java">@Slf4j
@WebFilter(urlPatterns = "/*")
public class LoginCheckFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {

        HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse resp = (HttpServletResponse) response;

        //1.获取请求url
        String url = req.getRequestURL().toString();
        log.info("请求的url:{}", url);

        //2.判断请求url是否包含login，如果包含说明是登陆操作，放行
        if (url.contains("login")) {
            log.info("登陆操作，放行...");
            chain.doFilter(request, response);
            return;
        }

        //3.获取请求头中的令牌(token)
        String jwt = req.getHeader("token");

        //4.判断令牌是否存在，如果不存在，返回错误结果(未登录)
        if (!StringUtils.hasLength(jwt)) {
            log.info("请求头token为空，返回未登录的信息");
            Result error = Result.error("NOT_LOGIN");
            //手动转化 对象——json ----&gt; 阿里巴巴fast.JSON
            String notLogin = JSONObject.toJSONString(error);
            resp.getWriter().write(notLogin);
            return;
        }

        //5.解析token，如果解析失败，返回错误结果(未登录)
        try {
            JwtUtils.parseJWT(jwt);
        } catch (Exception e) {
            e.printStackTrace();
            log.info("解析令牌失败，返回未登录错误信息");
            Result error = Result.error("NOT_LOGIN");
            //手动转化 对象-- json --------&gt; 阿里巴巴fastJSON
            String notLogin = JSONObject.toJSONString(error);
            resp.getWriter().write(notLogin);
            return;
        }


        //6.放行
        log.info("令牌合法，放行");
        chain.doFilter(request, response);
    }
}
</code></pre> 
<p>详细解析： </p> 
<ol><li> <p><code>public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException</code>：这是<code>doFilter</code>方法的定义，它接收三个参数：<code>ServletRequest</code>对象、<code>ServletResponse</code>对象和<code>FilterChain</code>对象。这个方法在过滤器被调用时执行，用于处理请求和响应。</p> </li><li> <p><code>HttpServletRequest req = (HttpServletRequest) request;</code>：将传入的<code>ServletRequest</code>对象强制转换为<code>HttpServletRequest</code>对象，以便使用HTTP特定的方法。</p> </li><li> <p><code>HttpServletResponse resp = (HttpServletResponse) response;</code>：将传入的<code>ServletResponse</code>对象强制转换为<code>HttpServletResponse</code>对象，以便使用HTTP特定的方法。</p> </li><li> <p><code>String url = req.getRequestURL().toString();</code>：获取请求的URL，并将其转换为字符串。</p> </li><li> <p><code>String url = req.getRequestURL().toString();</code>：获取请求的URL，并将其转换为字符串。</p> </li><li> <p><code>if (url.contains("login")) {<!-- --></code>：检查URL是否包含"login"字符串。如果包含，说明这是一个登录操作。</p> </li><li> <p><code>String jwt = req.getHeader("token");</code>：从请求头中获取名为"token"的值，并将其存储在变量<code>jwt</code>中。</p> </li><li> <p><code>if (!StringUtils.hasLength(jwt)) {<!-- --></code>：检查<code>jwt</code>变量是否为空或长度为0。如果为空或长度为0，说明没有提供令牌。</p> </li><li> <p><code>String notLogin = JSONObject.toJSONString(error);</code>：将<code>error</code>对象转换为JSON字符串。</p> </li><li> <p><code>JwtUtils.parseJWT(jwt);</code>：尝试解析提供的令牌。如果解析失败，将抛出异常。</p> </li><li> <p><code>String notLogin = JSONObject.toJSONString(error);</code>：将<code>error</code>对象转换为JSON字符串。</p> </li><li> <p><code>resp.getWriter().write(notLogin);</code>：将未登录的错误信息写入响应的输出流。</p> </li></ol>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/347b21cf7ece6488eec1cf871c07e089/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">流批一体历史背景及基础介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/14d719df53a0881f4b8655da8409f184/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">go语言使用代码示例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>