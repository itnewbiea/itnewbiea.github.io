<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>fillstyle属性_从零打造Echarts —— V2 属性更新和样式解析 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="fillstyle属性_从零打造Echarts —— V2 属性更新和样式解析" />
<meta property="og:description" content="从零打造Echarts —— V2 属性更新和样式解析 本文开始v2版本（直到xrender初步完成为止，标题均指xrender的版本和特性）。
回顾V1 在上个版本中，我们实现了zrender官方文档首页的代码示例。不过还有一些问题等待我们解决。
样式规则 运行之前的代码可以看到其结果如下。
没有指定填充颜色的图形会被填充为黑色，描边同理。就我个人理解而言，对于一个图形，通常需要默认描边，而填充则不需要。需要更多的样式规则应用，如透明度，线宽。 回到XElement.ts中，显然随着样式越来越复杂，需要将样式处理抽离为一个函数。
/** * 将指定样式绑定到上下文中 */ function bindStyle (ctx: CanvasRenderingContext2D, style: XElementStyle) { let fill = style.fill || &#39;transparent&#39; ctx.fillStyle = fill ctx.strokeStyle = style.stroke ctx.globalAlpha = style.opacity ctx.lineWidth = style.lineWidth } 然后在之前的beforeRender中应用即可。之后可以看到没有指定填充的图形不再有填充（更多的样式则需要依次处理，后面用到了再添加）。
~~高倍屏~~ ~~但是看着看着就觉得有什么不对，怎么这么模糊呢？这牵扯到设备独立像素和绘制像素等东西，和图片在高倍屏下的问题是一样的，不明白的可以自行搜索。解决方式和1px边框类似，找到渲染倍率，绘制的时候数据乘以这个倍率，然后将画布缩放为一倍大小即可。~~
添加元素后重绘频率 在之前的代码中，如果连续调用add，会连续触发render，这种情况下应该将其合并为一次。使用防抖函数，很容易做到这一点。
在util.ts中添加防抖函数。
export function debounce (fn: Function, delay = 300) { let timer = null return function (...args) { clearTimeout(timer) timer = setTimeout(() =&gt; { fn(." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/55e2a2b13356332149c24baa4ff4be30/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-08T16:40:14+08:00" />
<meta property="article:modified_time" content="2021-01-08T16:40:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">fillstyle属性_从零打造Echarts —— V2 属性更新和样式解析</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <h3>从零打造Echarts —— V2 属性更新和样式解析</h3> 
 <p>本文开始v2版本（直到<code>xrender</code>初步完成为止，标题均指<code>xrender</code>的版本和特性）。</p> 
 <h3>回顾V1</h3> 
 <p>在上个版本中，我们实现了<code>zrender</code>官方文档首页的代码示例。不过还有一些问题等待我们解决。</p> 
 <h3>样式规则</h3> 
 <p>运行之前的代码可以看到其结果如下。</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/d3/e8/YPgMZu7A_o.png" alt="2a87e9a878c9ce59e15add859f36c45b.png"> 
 </div> 
 <ul><li>没有指定填充颜色的图形会被填充为黑色，描边同理。就我个人理解而言，对于一个图形，通常需要默认描边，而填充则不需要。</li><li>需要更多的样式规则应用，如透明度，线宽。</li></ul> 
 <p>回到<code>XElement.ts</code>中，显然随着样式越来越复杂，需要将样式处理抽离为一个函数。</p> 
 <div class="has"> 
  <pre class="has"><code>/**
 * 将指定样式绑定到上下文中
 */
function bindStyle (ctx: CanvasRenderingContext2D, style: XElementStyle) {
  let fill = style.fill || 'transparent'
  ctx.fillStyle = fill
  ctx.strokeStyle = style.stroke
  ctx.globalAlpha = style.opacity
  ctx.lineWidth = style.lineWidth
}</code></pre> 
 </div> 
 <p>然后在之前的<code>beforeRender</code>中应用即可。之后可以看到没有指定填充的图形不再有填充（更多的样式则需要依次处理，后面用到了再添加）。</p> 
 <h3>~~高倍屏~~</h3> 
 <p>~~但是看着看着就觉得有什么不对，怎么这么模糊呢？这牵扯到设备独立像素和绘制像素等东西，和图片在高倍屏下的问题是一样的，不明白的可以自行搜索。解决方式和<code>1px</code>边框类似，找到渲染倍率，绘制的时候数据乘以这个倍率，然后将画布缩放为一倍大小即可。~~</p> 
 <h3>添加元素后重绘频率</h3> 
 <p>在之前的代码中，如果连续调用<code>add</code>，会连续触发<code>render</code>，这种情况下应该将其合并为一次。使用防抖函数，很容易做到这一点。</p> 
 <p>在<code>util.ts</code>中添加防抖函数。</p> 
 <div class="has"> 
  <pre class="has"><code>export function debounce (fn: Function, delay = 300) {
  let timer = null
  return function (...args) {
    clearTimeout(timer)
    timer = setTimeout(() =&gt; {
      fn(...args)
    }, delay)
  }
}</code></pre> 
 </div> 
 <p>问题是要在哪里加入防抖？是<code>XRender</code>中，还是<code>Painter中</code>？我暂时决定加入到<code>Painter</code>，间隔控制在一帧<code>16ms</code>。修改<code>Painter.render</code></p> 
 <div class="has"> 
  <pre class="has"><code>class Painter {
  render = debounce(() =&gt; {
    let xelements = this.stage.getAll()
    for (let i = 0; i &lt; xelements.length; i += 1) {
      xelements[i].refresh(this.ctx)
    }
  }, 16)
}</code></pre> 
 </div> 
 <h3>层级</h3> 
 <p>在之前的代码中，如果两个图形有区域重合，后添加的图形会覆盖之前的图形，而实际使用中往往需要指定图形在最上层，只需要引入层级<code>zLevel</code>即可做到这一点。编辑<code>XElement.ts</code>。</p> 
 <div class="has"> 
  <pre class="has"><code>export interface XElementOptions {
  /**
   * 元素所处层级
   */
  zLevel?: number
}
class XElement {
  updateOptions () {
    // ...
    // 不考虑它为0
    if (opt.zLevel) {
      this.zLevel = opt.zLevel
    }
  }
}</code></pre> 
 </div> 
 <p>然后在<code>Stage.getAll</code>中对所有元素进行排序。</p> 
 <div class="has"> 
  <pre class="has"><code>class Stage {
  /**
   * 获取所有元素
   */
  getAll () {
    this.updateXElements()

    return this.xelements
  }
  updateXElements () {
    // zLevel高的在后，其它按加入次序排列
    this.xelements.sort((a, b) =&gt; {
      return a.zLevel - b.zLevel
    })
  }
}</code></pre> 
 </div> 
 <p><code>App.vue</code>中为第一个圆加入<code>zLevel: 2</code>的参数，可以看到它不再被第二个圆遮挡(为了明显区分，加了fill参数)。</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/b6/58/lXwFLyJS_o.png" alt="34104dbd03b5bc95b45bcd2aab127a1a.png"> 
 </div> 
 <h3>更多选项</h3> 
 <p>之前对于<code>XRender</code>的设计显然太过简单，现在试着添加一些参数，比如指定画布的宽高和背景色——当然，它会被传递给<code>Painter</code>。所以此处只展示<code>Painter.ts</code>内的代码。</p> 
 <div class="has"> 
  <pre class="has"><code>function createCanvas (dom: string | HTMLCanvasElement | HTMLElement) {
  // ...
  let canvas = document.createElement('canvas');
  (&lt;HTMLElement&gt;dom).appendChild(canvas)

  canvas.height = (&lt;HTMLElement&gt;dom).clientHeight
  canvas.width = (&lt;HTMLElement&gt;dom).clientWidth

  return canvas
}
/**
 * 后续还有更多的样式需要设置
 */
function setCanvasStyle (canvas: HTMLCanvasElement, opt: PainterOptions) {
  if (opt.height) {
    canvas.height = opt.height
    canvas.style.height = `${opt.height}px`
  } else {
    opt.height = canvas.clientHeight
  }
  if (opt.width) {
    canvas.width = opt.width
    canvas.style.width = `${opt.width}px`
  } else {
    opt.width = canvas.clientWidth
  }
  if (opt.backgroundColor) {
    canvas.style.backgroundColor = opt.backgroundColor
  }
class Painter {
  constructor (dom: string | HTMLCanvasElement | HTMLElement, stage: Stage, opt: PainterOptions) {
    this.opt = opt
    this.canvas = createCanvas(dom)
    setCanvasStyle(this.canvas, opt)
    // ...
  }
}</code></pre> 
 </div> 
 <h3>属性更新</h3> 
 <p>显然我们是需要对已创建的元素进行属性的更新的——不然无法实现动画，更新属性之后则需要重新渲染，但是我们也知道无法只对单个元素重绘，只能全部重新绘制（clip方法虽然能限定绘制区域，但是这并没有本质区别）。能否在绘制元素时给定清除方法，更新单个元素时调用清除方法，再重新绘制呢？事实上这是可以的，不过除了让事情变得更复杂以外，没有多余的好处，还会让层级关系变得一团糟。</p> 
 <blockquote>
   以上为写作本文时的个人理解，仅供参考。 
 </blockquote> 
 <p>而此前的代码中元素不知道掌控全局渲染的<code>Painter</code>或者说<code>XRender</code>，也就无法触发，需要将其关联起来——显然不能在构造函数中传入，得在另外的时机注入，回想一下代码过程，它们是在<code>add</code>方法中产生交集的，那么可以这样做。</p> 
 <div class="has"> 
  <pre class="has"><code>class XElement {
  /**
   * 设置元素相关的`xr`
   */
  setXr (xr: XRender) {
    this._xr = xr
  }
}
class XRender {
  add (...xelements: XElement[]) {
    xelements.forEach(xel =&gt; {
      xel.setXr(this)
    })
    // ...
  }
}</code></pre> 
 </div> 
 <p>然后编写更新属性的方法，更新完毕后调用<code>xr.render</code>即可。更新属性（我们命名为<code>attr</code>）分为两种情况，一如要更新层级，<code>attr('zLevel', 1)</code>；一如要更新某一个样式或形状，可以有两种实现方式，如<code>attr('style', { fill: '#f00' })</code>，以及<code>attr('style.fill', '#f00')</code>，考虑到很可能会一次更新多个属性，这里选择第一种——然后更新层级也可以这样做<code>attr({ zLevel: 1 })</code>。实现过程很简单，这里只贴出代码。</p> 
 <div class="has"> 
  <pre class="has"><code>class XElement {
  /**
   * 到后面会发现，对不同的属性，需要有不同的设置方法
  */
  attrFunctions = {
    shape: (newShape: Object) =&gt; {
      let shape = this.options.shape
      merge(shape, newShape)
    },
    style: (newStyle) =&gt; {
      let style = this.options.style
      merge(style, newStyle)
    }
  }
  /**
   * 实际设置属性的方法
   */
  attrKv (key: string, value: any) {
    let updateMethod = this.attrFunctions[key]
    if (updateMethod) {
      updateMethod(value)
    } else {
      this.options[key] = value
    }
  }
  /**
   * 更新属性并重绘
   */
  attr (key: String | Object, value?: any) {
    if (isString(key)) {
      this.attrKv(key as string, value)
    } else if (isObject(key)) {
      for (let name in key) {
        if (key.hasOwnProperty(name)) {
          this.attrKv(name, key[name])
        }
      }
    }
    this.updateOptions()
    this._xr.render()
  }
}</code></pre> 
 </div> 
 <p>在<code>App.vue</code>中添加代码<code>circle.attr({ shape: { r: 60 } })</code>，发现已经生效。</p> 
 <h3>显示/隐藏</h3> 
 <p>显示和隐藏一个元素也是常见的功能，实现它只需要为元素添加<code>ignored</code>属性并提供<code>show</code>和<code>hide</code>方法来改变此属性，最后在<code>Stage.getAll</code>中过滤掉<code>ignored</code>为真的元素即可。</p> 
 <div class="has"> 
  <pre class="has"><code>class XElement {
  /**
   * 为真的话绘制时会忽略此元素
   */
  ignored: boolean
  /**
   * 显示元素
   */
  show () {
    this.ignored = false
    this._xr.render()
  }
  /**
   * 隐藏元素
   */
  hide () {
    this.ignored = true
    this._xr.render()
  }
}
class Stage {/**
   * 获取所有元素
   */
  getAll () {
    this.updateXElements()
    return this.xelements.filter(xel =&gt; !xel.ignored)
  }
}</code></pre> 
 </div> 
 <p>试验一下<code>circle.hide()</code>，(⊙o⊙)…好像没什么效果，想了想，在每次更新前应该清空画布才对。</p> 
 <div class="has"> 
  <pre class="has"><code>class Painter {
  render = debounce(() =&gt; {
    this.beforeRender()
    //...
  })
  beforeRender () {
    this.ctx.clearRect(0, 0, this.opt.width, this.opt.height)
  }
}</code></pre> 
 </div> 
 <p>保存，ok。</p> 
 <h3>小结</h3> 
 <p>本版本的新功能并不多，可以说是对<code>v1</code>的一点补充。但是它也是实现下个功能不可缺少的一部分。</p> 
 <h3>V3预览</h3> 
 <p>动画。</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cab0d59050a112a3289c7f0943a52b74/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">点击出现蓝色边框或者出现半透明蓝色背景解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1029d68e33fdd8bb6fd98dc65863ea18/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">新一代轻量级应用服务器 — WebSphere Liberty Profile Server 介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>