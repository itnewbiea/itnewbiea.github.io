<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>springboot中使用RSA加密实现密码信息的密文传输 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="springboot中使用RSA加密实现密码信息的密文传输" />
<meta property="og:description" content="1、创建RASUtils
package com.demo.springboot.util; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.apache.tomcat.util.codec.binary.Base64; import javax.crypto.Cipher; import java.security.*; import java.security.spec.PKCS8EncodedKeySpec; import java.security.spec.X509EncodedKeySpec; import java.util.HashMap; import java.util.LinkedList; import java.util.List; import java.util.Map; public class RSAUtils { protected static final Log log = LogFactory.getLog(RSAUtils.class); private static String KEY_RSA_TYPE = &#34;RSA&#34;; private static String KEY_RSA_TYPE_ALL = &#34;RSA/ECB/PKCS1Padding&#34;; private static int KEY_SIZE = 1024;//JDK方式RSA加密最大只有1024位 private static int ENCODE_PART_SIZE = KEY_SIZE/8; public static final String PUBLIC_KEY_NAME = &#34;public&#34;; public static final String PRIVATE_KEY_NAME = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5a4edec364ad08b4688bfeb7f73d1e0d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-25T11:03:10+08:00" />
<meta property="article:modified_time" content="2020-12-25T11:03:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">springboot中使用RSA加密实现密码信息的密文传输</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1、创建RASUtils</p> 
<pre><code>package com.demo.springboot.util;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.tomcat.util.codec.binary.Base64;

import javax.crypto.Cipher;
import java.security.*;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

public class RSAUtils {
    protected static final Log log = LogFactory.getLog(RSAUtils.class);
    private static String KEY_RSA_TYPE = "RSA";
    private static String KEY_RSA_TYPE_ALL = "RSA/ECB/PKCS1Padding";
    private static int KEY_SIZE = 1024;//JDK方式RSA加密最大只有1024位
    private static int ENCODE_PART_SIZE = KEY_SIZE/8;
    public static final String PUBLIC_KEY_NAME = "public";
    public static final String PRIVATE_KEY_NAME = "private";

    /**
     * 创建公钥秘钥
     * @return
     */
    public static Map&lt;String,String&gt; createRSAKeys(){
        Map&lt;String,String&gt; keyPairMap = new HashMap&lt;&gt;();//里面存放公私秘钥的Base64位加密
        try {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(KEY_RSA_TYPE);
            keyPairGenerator.initialize(KEY_SIZE,new SecureRandom());
            KeyPair keyPair = keyPairGenerator.generateKeyPair();

            //获取公钥秘钥
            String publicKeyValue = Base64.encodeBase64String(keyPair.getPublic().getEncoded());
            String privateKeyValue = Base64.encodeBase64String(keyPair.getPrivate().getEncoded());

            //存入公钥秘钥，以便以后获取
            keyPairMap.put(PUBLIC_KEY_NAME,publicKeyValue);
            keyPairMap.put(PRIVATE_KEY_NAME,privateKeyValue);
        } catch (NoSuchAlgorithmException e) {
            log.error("当前JDK版本没找到RSA加密算法！");
            e.printStackTrace();
        }
        return keyPairMap;
    }

    /**
     * 公钥加密
     * 描述：
     *     1字节 = 8位；
     *     最大加密长度如 1024位私钥时，最大加密长度为 128-11 = 117字节，不管多长数据，加密出来都是 128 字节长度。
     * @param sourceStr
     * @param publicKeyBase64Str
     * @return
     */
    public static String encode(String sourceStr,String publicKeyBase64Str){
        byte [] publicBytes = Base64.decodeBase64(publicKeyBase64Str);
        //公钥加密
        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(publicBytes);
        List&lt;byte[]&gt; alreadyEncodeListData = new LinkedList&lt;&gt;();

        int maxEncodeSize = ENCODE_PART_SIZE - 11;
        String encodeBase64Result = null;
        try {
            KeyFactory keyFactory = KeyFactory.getInstance(KEY_RSA_TYPE);
            PublicKey publicKey = keyFactory.generatePublic(x509EncodedKeySpec);
            Cipher cipher = Cipher.getInstance(KEY_RSA_TYPE_ALL);
            cipher.init(Cipher.ENCRYPT_MODE,publicKey);
            byte[] sourceBytes = sourceStr.getBytes("utf-8");
            int sourceLen = sourceBytes.length;
            for(int i=0;i&lt;sourceLen;i+=maxEncodeSize){
                int curPosition = sourceLen - i;
                int tempLen = curPosition;
                if(curPosition &gt; maxEncodeSize){
                    tempLen = maxEncodeSize;
                }
                byte[] tempBytes = new byte[tempLen];//待加密分段数据
                System.arraycopy(sourceBytes,i,tempBytes,0,tempLen);
                byte[] tempAlreadyEncodeData = cipher.doFinal(tempBytes);
                alreadyEncodeListData.add(tempAlreadyEncodeData);
            }
            int partLen = alreadyEncodeListData.size();//加密次数

            int allEncodeLen = partLen * ENCODE_PART_SIZE;
            byte[] encodeData = new byte[allEncodeLen];//存放所有RSA分段加密数据
            for (int i = 0; i &lt; partLen; i++) {
                byte[] tempByteList = alreadyEncodeListData.get(i);
                System.arraycopy(tempByteList,0,encodeData,i*ENCODE_PART_SIZE,ENCODE_PART_SIZE);
            }
            encodeBase64Result = Base64.encodeBase64String(encodeData);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return encodeBase64Result;
    }

    /**
     * 私钥解密
     * @param sourceBase64RSA
     * @param privateKeyBase64Str
     */
    public static String decode(String sourceBase64RSA,String privateKeyBase64Str){
        byte[] privateBytes = Base64.decodeBase64(privateKeyBase64Str);
        byte[] encodeSource = Base64.decodeBase64(sourceBase64RSA);
        int encodePartLen = encodeSource.length/ENCODE_PART_SIZE;
        List&lt;byte[]&gt; decodeListData = new LinkedList&lt;&gt;();//所有解密数据
        String decodeStrResult = null;
        //私钥解密
        PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(privateBytes);
        try {
            KeyFactory keyFactory = KeyFactory.getInstance(KEY_RSA_TYPE);
            PrivateKey privateKey = keyFactory.generatePrivate(pkcs8EncodedKeySpec);
            Cipher cipher = Cipher.getInstance(KEY_RSA_TYPE_ALL);
            cipher.init(Cipher.DECRYPT_MODE,privateKey);
            int allDecodeByteLen = 0;//初始化所有被解密数据长度
            for (int i = 0; i &lt; encodePartLen; i++) {
                byte[] tempEncodedData = new byte[ENCODE_PART_SIZE];
                System.arraycopy(encodeSource,i*ENCODE_PART_SIZE,tempEncodedData,0,ENCODE_PART_SIZE);
                byte[] decodePartData = cipher.doFinal(tempEncodedData);
                decodeListData.add(decodePartData);
                allDecodeByteLen += decodePartData.length;
            }
            byte [] decodeResultBytes = new byte[allDecodeByteLen];
            for (int i = 0,curPosition = 0; i &lt; encodePartLen; i++) {
                byte[] tempSorceBytes = decodeListData.get(i);
                int tempSourceBytesLen = tempSorceBytes.length;
                System.arraycopy(tempSorceBytes,0,decodeResultBytes,curPosition,tempSourceBytesLen);
                curPosition += tempSourceBytesLen;
            }
            decodeStrResult = new String(decodeResultBytes,"UTF-8");
        }catch (Exception e){
            e.printStackTrace();
        }
        return decodeStrResult;
    }
}

</code></pre> 
<p>2、生成公钥和私钥</p> 
<pre><code>package com.demo.springboot;

import com.demo.springboot.util.RSAUtils;

import java.util.Map;

/**
 * @author zhanghongkai
 * @version 1.0
 * @Classname Test5
 * @Description Test5
 * @Date 2020/12/25 10:24
 */
public class Test5 {
    public static void main(String[] args) {
        Map&lt;String, String&gt; rsaKeys = RSAUtils.createRSAKeys();
        String publicKey = rsaKeys.get(RSAUtils.PUBLIC_KEY_NAME);
        System.out.println("publicKey:"+ publicKey);
        String privateKey = rsaKeys.get(RSAUtils.PRIVATE_KEY_NAME);
        System.out.println("privateKey:"+ privateKey);
    }
}
</code></pre> 
<p>输出结果为：</p> 
<blockquote> 
 <p>publicKey:MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCtY9zORw7e5CH45W5yyxtzzPqsCgHZbNV7usrWaT5enn+XUSyw1i21Gy4Jf26uHT5I2a8mdZ7gNfewFAJNF9wVFmaOUShaxaO6xlTrDN3VRSCjQNLDZhaTBfKnVtbQ3nrR2Tp8CE4fgydZFnLm9O+saDYqspRFfIfIOhxXhQRU3wIDAQAB<br> privateKey:MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAK1j3M5HDt7kIfjlbnLLG3PM+qwKAdls1Xu6ytZpPl6ef5dRLLDWLbUbLgl/bq4dPkjZryZ1nuA197AUAk0X3BUWZo5RKFrFo7rGVOsM3dVFIKNA0sNmFpMF8qdW1tDeetHZOnwITh+DJ1kWcub076xoNiqylEV8h8g6HFeFBFTfAgMBAAECgYEAlg4fkJFkaDdMw0djb4shBfW2Vt8OPKl4k+zTD/3i0SYgS8cfgybIRbzw+Z1EHwEF3yws7X7LcUSjR8n5N9jXSCRKxEvCksczGM80qJMBypgGh4DzKTlm9ScnbnmYlUYf+cSz53EsoktQLtCqP08tGhYZr2Qe2lJlrgKnSuIrNbkCQQDy+B3XMirkAgveGWD26ofMTcv5ZDw/KyiF69QCGQ0y5EP21esUxXwmVgwbtOx7Q2Ox0jPP6HkczWYCzCsNBJ0dAkEAtrBy23PLbUeSqyEc8D8Psvs0OekQOoogZjJtzj5eFCCZjbWd8PJ0KMAoRnZtqCqGWGP3eRwKntHW1VtaAA/lKwJBAJqdjBfKhALOzpCKo+rdOoenpjrRL4mfRE1c0nB3Uq/lFN76KHvyZFvc/B2Rl7+lFccuFeyjapcKmnUDSg4htn0CQHMTnqYBwMhrZ0YIq7Ph5T+24OUBnEljrJjzdxuNSbGf/1m2Z3DZKLZqpHQOMXDWqJ2RCtftA/ua7pqi2oRjftUCQDVN7DP6Nk/wFiyXwGKDez6jWpjpU5DKak+d0zD462EadQCMDEyHBpgtqPBpMMvVMGXsQtyUiHDOJzooiEEPRho=</p> 
</blockquote> 
<p>3、将公钥和私钥配置到springboot的配置文件application.properties中</p> 
<blockquote> 
 <pre>publicKey=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCtY9zORw7e5CH45W5yyxtzzPqsCgHZbNV7usrWaT5enn+XUSyw1i21Gy4Jf26uHT5I2a8mdZ7gNfewFAJNF9wVFmaOUShaxaO6xlTrDN3VRSCjQNLDZhaTBfKnVtbQ3nrR2Tp8CE4fgydZFnLm9O+saDYqspRFfIfIOhxXhQRU3wIDAQAB
privateKey=MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAK1j3M5HDt7kIfjlbnLLG3PM+qwKAdls1Xu6ytZpPl6ef5dRLLDWLbUbLgl/bq4dPkjZryZ1nuA197AUAk0X3BUWZo5RKFrFo7rGVOsM3dVFIKNA0sNmFpMF8qdW1tDeetHZOnwITh+DJ1kWcub076xoNiqylEV8h8g6HFeFBFTfAgMBAAECgYEAlg4fkJFkaDdMw0djb4shBfW2Vt8OPKl4k+zTD/3i0SYgS8cfgybIRbzw+Z1EHwEF3yws7X7LcUSjR8n5N9jXSCRKxEvCksczGM80qJMBypgGh4DzKTlm9ScnbnmYlUYf+cSz53EsoktQLtCqP08tGhYZr2Qe2lJlrgKnSuIrNbkCQQDy+B3XMirkAgveGWD26ofMTcv5ZDw/KyiF69QCGQ0y5EP21esUxXwmVgwbtOx7Q2Ox0jPP6HkczWYCzCsNBJ0dAkEAtrBy23PLbUeSqyEc8D8Psvs0OekQOoogZjJtzj5eFCCZjbWd8PJ0KMAoRnZtqCqGWGP3eRwKntHW1VtaAA/lKwJBAJqdjBfKhALOzpCKo+rdOoenpjrRL4mfRE1c0nB3Uq/lFN76KHvyZFvc/B2Rl7+lFccuFeyjapcKmnUDSg4htn0CQHMTnqYBwMhrZ0YIq7Ph5T+24OUBnEljrJjzdxuNSbGf/1m2Z3DZKLZqpHQOMXDWqJ2RCtftA/ua7pqi2oRjftUCQDVN7DP6Nk/wFiyXwGKDez6jWpjpU5DKak+d0zD462EadQCMDEyHBpgtqPBpMMvVMGXsQtyUiHDOJzooiEEPRho=</pre> 
</blockquote> 
<p> 4、编写登录控制器，主要是登录解密方法和获取公钥方法</p> 
<pre><code>package com.demo.springboot.controller;

import com.demo.springboot.util.RSAUtils;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * @author zhanghongkai
 * @version 1.0
 * @Classname LoginController
 * @Description LoginController
 * @Date 2020/12/25 10:30
 */
@Controller
public class LoginController {
    @Value("${publicKey}")
    private String publicKey;

    @Value("${privateKey}")
    private String privateKey;

    @RequestMapping("getPublicKey")
    @ResponseBody
    public String getPublicKey(){
        return this.publicKey;
    }

    @RequestMapping("login")
    @ResponseBody
    public String login(@RequestBody User user){
        String password = user.getPassword();
        System.out.println(password);
        password = RSAUtils.decode(password,this.privateKey);
        System.out.println(password);
        return "登录成功";
    }
}
</code></pre> 
<p>5、前端引入jsencrypt，我这里使用在vue中yinru</p> 
<blockquote> 
 <p>npm install jsencrypt --save</p> 
</blockquote> 
<p> 6、使用jsencrypt加密并发送密文到后台</p> 
<pre><code>&lt;template&gt;
    &lt;div&gt;123&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    import JSEncrypt from 'jsencrypt';
    export default {
        name: "Test5",
        methods:{
            test(){
                console.log(123);
            }
        },
        mounted(){
            this.axios.get('http://localhost:8080/demo/getPublicKey').then(res =&gt; {
               let publicKey = res.data;
               if (publicKey){
                   console.log(publicKey)
                   let encrypt = new JSEncrypt();
                   encrypt.setPublicKey(publicKey);
                   let password = '123456';
                   password = encrypt.encrypt(password);
                   let loginData = {username:'admin',password:password};
                   this.axios.post('http://localhost:8080/demo/login',loginData).then(res =&gt; {
                       console.log(res.data)
                   })
               } else{
                   this.$message.error('获取公钥失败')
               }
            });

        }
    }
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre> 
<p>7、后台解密密文，输出为：</p> 
<p>ceq7LtFesQYyi/zR5Rr5P3uBHLmFUVgwx8iOgA6paOmREu9xXDwncGQveGLNHmbM5dNBCo4ErDlP5uUNsLvDCq1EwG63PaNzKYPMvs6BByj8isg9YT9l7MqY9UuC9bSOahFYeAtJ5lESX26zWs55WdRYvNcFv3PCExDJys6bFHo=<br> 123456</p> 
<p>解密成功</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a75df9c9e6d1fa0be23d0403b289f8e4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Android】 一个crash 背后竟然暗藏玄机，速看！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a61387d76ebd39fbdf2be3820ab5e215/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Openlayers 投影与坐标转换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>