<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>百万级Excel数据导入导出，就该这么玩 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="百万级Excel数据导入导出，就该这么玩" />
<meta property="og:description" content="SpringForAll社区 2023-08-21 08:30 发表于上海
关注我
，回复关键字“spring”，
免费领取Spring学习资料。
SpringForAll社区
分享关于Spring的一切
286篇原创内容
公众号
在项目开发中往往需要使用到数据的导入和导出，导入就是从Excel中导入到DB中，而导出就是从DB中查询数据然后使用POI写到Excel上。
大数据的导入和导出，相信大家在日常的开发、面试中都会遇到。
很多问题只要这一次解决了，总给复盘记录，后期遇到同样的问题就好解决了。好啦，废话不多说开始正文！欢迎关注公众号：SpringForAll社区（spring4all.com），专注分享关于Spring的一切！回复“加群”还可加入Spring技术交流群！
1.传统POI的的版本优缺点比较 其实想到数据的导入导出，理所当然的会想到apache的poi技术，以及Excel的版本问题。
HSSFWorkbook
这个实现类是我们早期使用最多的对象，它可以操作Excel2003以前（包含2003）的所有Excel版本。在2003以前Excel的版本后缀还是.xls
XSSFWorkbook
这个实现类现在在很多公司都可以发现还在使用，它是操作的Excel2003–Excel2007之间的版本，Excel的扩展名是.xlsx
SXSSFWorkbook
这个实现类是POI3.8之后的版本才有的,它可以操作Excel2007以后的所有版本Excel,扩展名是.xlsx
HSSFWorkbook 它是POI版本中最常用的方式，不过:
它的缺点是 最多只能导出 65535行，也就是导出的数据函数超过这个数据就会报错;
它的优点是 不会报内存溢出。（因为数据量还不到7w所以内存一般都够用，首先你得明确知道这种方式是将数据先读取到内存中，然后再操作）
XSSFWorkbook 优点：这种形式的出现是为了突破HSSFWorkbook的65535行局限，是为了针对Excel2007版本的1048576行，16384列，最多可以导出104w条数据；
缺点：伴随的问题来了，虽然导出数据行数增加了好多倍，但是随之而来的内存溢出问题也成了噩梦。因为你所创建的book，Sheet，row，cell等在写入到Excel之前，都是存放在内存中的（这还没有算Excel的一些样式格式等等），可想而知，内存不溢出就有点不科学了！！！
SXSSFWorkbook 从POI 3.8版本开始，提供了一种基于XSSF的低内存占用的SXSSF方式：
优点：
这种方式不会一般不会出现内存溢出（它使用了硬盘来换取内存空间，
也就是当内存中数据达到一定程度这些数据会被持久化到硬盘中存储起来，而内存中存的都是最新的数据），
并且支持大型Excel文件的创建（存储百万条数据绰绰有余）。
缺点：
既然一部分数据持久化到了硬盘中，且不能被查看和访问那么就会导致，
在同一时间点我们只能访问一定数量的数据，也就是内存中存储的数据;
sheet.clone()方法将不再支持,还是因为持久化的原因;
不再支持对公式的求值，还是因为持久化的原因，在硬盘中的数据没法读取到内存中进行计算；
在使用模板方式下载数据的时候，不能改动表头，还是因为持久化的问题，写到了硬盘里就不能改变了；
这里顺便给大家推荐一款我们自己开发的Chrome插件：Youtube中文配音（http://youtube-dubbing.com/）。如果您跟我们一样，热爱看国外的视频学习前沿知识或者其他内容，该插件可以很好的帮助您讲外语视频一键转化为中文视频！
2.使用方式哪种看情况 经过了解也知道了这三种Workbook的优点和缺点，那么具体使用哪种方式还是需要看情况的：
我一般会根据这样几种情况做分析选择：
1、当我们经常导入导出的数据不超过7w的情况下，可以使用 HSSFWorkbook 或者 XSSFWorkbook都行；
2、当数据量查过7w并且导出的Excel中不牵扯对Excel的样式，公式，格式等操作的情况下，推荐使用SXSSFWorkbook;
3、当数据量查过7w，并且我们需要操做Excel中的表头，样式，公式等，这时候我们可以使用 XSSFWorkbook 配合进行分批查询，分批写入Excel的方式来做；
3.百万数据导入导出 想要解决问题我们首先要明白自己遇到的问题是什么？
1、 我遇到的数据量超级大，使用传统的POI方式来完成导入导出很明显会内存溢出，并且效率会非常低；
2、 数据量大直接使用select * from tableName肯定不行，一下子查出来300w条数据肯定会很慢；
3、 300w 数据导出到Excel时肯定不能都写在一个Sheet中，这样效率会非常低；估计打开都得几分钟；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/80246e83eb60698ad8bce7a50ee6b2b4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-22T09:21:02+08:00" />
<meta property="article:modified_time" content="2023-08-22T09:21:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">百万级Excel数据导入导出，就该这么玩</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a id="js_name">SpringForAll社区</a> <em id="publish_time">2023-08-21 08:30</em> <em id="js_ip_wording_wrp">发表于上海</em></p> 
<p>关注我</p> 
<p class="img-center"><img alt="图片" height="64" src="https://images2.imgbox.com/12/a8/qDblFVqs_o.png" width="64"></p> 
<p>，回复关键字<strong>“spring”</strong>，</p> 
<p>免费领取<strong>Spring学习资料</strong>。</p> 
<p></p> 
<p class="img-center"><img alt="" height="128" src="https://images2.imgbox.com/36/30/fnj345bl_o.png" width="128"></p> 
<p><strong id="js_a11y_wx_profile_nickname">SpringForAll社区</strong></p> 
<p>分享关于Spring的一切</p> 
<p>286篇原创内容</p> 
<p>公众号</p> 
<p>在项目开发中往往需要使用到数据的导入和导出，导入就是从Excel中导入到DB中，而导出就是从DB中查询数据然后使用POI写到Excel上。</p> 
<p>大数据的导入和导出，相信大家在日常的开发、面试中都会遇到。</p> 
<p>很多问题只要这一次解决了，总给复盘记录，后期遇到同样的问题就好解决了。好啦，废话不多说开始正文！欢迎关注公众号：SpringForAll社区（spring4all.com），专注分享关于Spring的一切！回复“加群”还可加入Spring技术交流群！</p> 
<h3>1.传统POI的的版本优缺点比较</h3> 
<p>其实想到数据的导入导出，理所当然的会想到apache的poi技术，以及Excel的版本问题。</p> 
<ul><li> <p><strong>HSSFWorkbook</strong></p> </li></ul> 
<p>这个实现类是我们早期使用最多的对象，它可以操作Excel2003以前（包含2003）的所有Excel版本。在2003以前Excel的版本后缀还是.xls</p> 
<ul><li> <p><strong>XSSFWorkbook</strong></p> </li></ul> 
<p>这个实现类现在在很多公司都可以发现还在使用，它是操作的Excel2003–Excel2007之间的版本，Excel的扩展名是.xlsx</p> 
<ul><li> <p><strong>SXSSFWorkbook</strong></p> </li></ul> 
<p>这个实现类是POI3.8之后的版本才有的,它可以操作Excel2007以后的所有版本Excel,扩展名是.xlsx</p> 
<h4>HSSFWorkbook</h4> 
<p>它是POI版本中最常用的方式，不过:</p> 
<ul><li> <p>它的缺点是 最多只能导出 65535行，也就是导出的数据函数超过这个数据就会报错;</p> </li><li> <p>它的优点是 不会报内存溢出。（因为数据量还不到7w所以内存一般都够用，首先你得明确知道这种方式是将数据先读取到内存中，然后再操作）</p> </li></ul> 
<h4>XSSFWorkbook</h4> 
<ul><li> <p>优点：这种形式的出现是为了突破HSSFWorkbook的65535行局限，是为了针对Excel2007版本的1048576行，16384列，最多可以导出104w条数据；</p> </li><li> <p>缺点：伴随的问题来了，虽然导出数据行数增加了好多倍，但是随之而来的内存溢出问题也成了噩梦。因为你所创建的book，Sheet，row，cell等在写入到Excel之前，都是存放在内存中的（这还没有算Excel的一些样式格式等等），可想而知，内存不溢出就有点不科学了！！！</p> </li></ul> 
<h4>SXSSFWorkbook</h4> 
<p>从POI 3.8版本开始，提供了一种基于XSSF的低内存占用的SXSSF方式：</p> 
<p><strong>优点：</strong></p> 
<ul><li> <p>这种方式不会一般不会出现内存溢出（它使用了硬盘来换取内存空间，</p> </li><li> <p>也就是当内存中数据达到一定程度这些数据会被持久化到硬盘中存储起来，而内存中存的都是最新的数据），</p> </li><li> <p>并且支持大型Excel文件的创建（存储百万条数据绰绰有余）。</p> </li></ul> 
<p><strong>缺点：</strong></p> 
<ul><li> <p>既然一部分数据持久化到了硬盘中，且不能被查看和访问那么就会导致，</p> </li><li> <p>在同一时间点我们只能访问一定数量的数据，也就是内存中存储的数据;</p> </li><li> <p>sheet.clone()方法将不再支持,还是因为持久化的原因;</p> </li><li> <p>不再支持对公式的求值，还是因为持久化的原因，在硬盘中的数据没法读取到内存中进行计算；</p> </li><li> <p>在使用模板方式下载数据的时候，不能改动表头，还是因为持久化的问题，写到了硬盘里就不能改变了；</p> <p></p> <p></p> </li></ul> 
<p>这里顺便给大家推荐一款我们自己开发的Chrome插件：Youtube中文配音（http://youtube-dubbing.com/）。如果您跟我们一样，热爱看国外的视频学习前沿知识或者其他内容，该插件可以很好的帮助您讲外语视频一键转化为中文视频！</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="780" src="https://images2.imgbox.com/8a/cd/qqXp4F2E_o.png" width="1029"></p> 
<p></p> 
<h3>2.使用方式哪种看情况</h3> 
<p>经过了解也知道了这三种Workbook的优点和缺点，那么具体使用哪种方式还是需要看情况的：</p> 
<p>我一般会根据这样几种情况做分析选择：</p> 
<p>1、当我们经常导入导出的数据不超过7w的情况下，可以使用 HSSFWorkbook 或者 XSSFWorkbook都行；</p> 
<p>2、当数据量查过7w并且导出的Excel中不牵扯对Excel的样式，公式，格式等操作的情况下，推荐使用SXSSFWorkbook;</p> 
<p>3、当数据量查过7w，并且我们需要操做Excel中的表头，样式，公式等，这时候我们可以使用 XSSFWorkbook 配合进行分批查询，分批写入Excel的方式来做；</p> 
<h3>3.百万数据导入导出</h3> 
<p>想要解决问题我们首先要明白自己遇到的问题是什么？</p> 
<p>1、 我遇到的数据量超级大，使用传统的POI方式来完成导入导出很明显会内存溢出，并且效率会非常低；</p> 
<p>2、 数据量大直接使用select * from tableName肯定不行，一下子查出来300w条数据肯定会很慢；</p> 
<p>3、 300w 数据导出到Excel时肯定不能都写在一个Sheet中，这样效率会非常低；估计打开都得几分钟；</p> 
<p>4、 300w数据导出到Excel中肯定不能一行一行的导出到Excel中。频繁IO操作绝对不行；</p> 
<p>5、 导入时300万数据存储到DB如果循环一条条插入也肯定不行；</p> 
<p>6、导入时300w数据如果使用Mybatis的批量插入肯定不行，因为Mybatis的批量插入其实就是SQL的循环；一样很慢。</p> 
<p><strong>解决思路：</strong></p> 
<p>针对1 ：</p> 
<blockquote> 
 <p>其实问题所在就是内存溢出，我们只要使用对上面介绍的POI方式即可，主要问题就是原生的POI解决起来相当麻烦。</p> 
 <p>经过查阅资料翻看到阿里的一款POI封装工具EasyExcel，上面问题等到解决；</p> 
</blockquote> 
<p>针对2：</p> 
<blockquote> 
 <p>不能一次性查询出全部数据，我们可以分批进行查询，只不过时多查询几次的问题，况且市面上分页插件很多。此问题好解决。</p> 
</blockquote> 
<p>针对3：</p> 
<blockquote> 
 <p>可以将300w条数据写到不同的Sheet中，每一个Sheet写一百万即可。</p> 
</blockquote> 
<p>针对4：</p> 
<blockquote> 
 <p>不能一行一行的写入到Excel上，我们可以将分批查询的数据分批写入到Excel中。</p> 
</blockquote> 
<p>针对5：</p> 
<blockquote> 
 <p>导入到DB时我们可以将Excel中读取的数据存储到集合中，到了一定数量，直接批量插入到DB中。</p> 
</blockquote> 
<p>针对6：</p> 
<blockquote> 
 <p>不能使用Mybatis的批量插入，我们可以使用JDBC的批量插入，配合事务来完成批量插入到DB。即 Excel读取分批+JDBC分批插入+事务。</p> 
</blockquote> 
<h4>3.1 模拟500w数据导出</h4> 
<p>需求：使用EasyExcel完成500w数据的导出。</p> 
<p><strong>500w数据的导出解决思路：</strong></p> 
<ul><li> <p>首先在查询数据库层面，需要分批进行查询（比如每次查询20w）</p> </li><li> <p>每查询一次结束，就使用EasyExcel工具将这些数据写入一次；</p> </li><li> <p>当一个Sheet写满了100w条数据，开始将查询的数据写入到另一个Sheet中；</p> </li><li> <p>如此循环直到数据全部导出到Excel完毕。</p> </li></ul> 
<blockquote> 
 <p>ps:我们需要计算Sheet个数，以及循环写入次数。特别是最后一个Sheet的写入次数</p> 
</blockquote> 
<p>因为你不知道最后一个Sheet会写入多少数据，可能是100w，也可能是25w因为我们这里的500w只是模拟数据，有可能导出的数据比500w多也可能少</p> 
<blockquote> 
 <p>ps:我们需要计算写入次数，因为我们使用的分页查询，所以需要注意写入的次数。</p> 
</blockquote> 
<p>其实查询数据库多少次就是写入多少次</p> 
<h5>准备工作</h5> 
<p>1.基于maven搭建springboot工程，引入easyexcel依赖，这里我是用的时3.0版本</p> 
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
   &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;
   &lt;version&gt;3.0.5&lt;/version&gt;
&lt;/dependency&gt;
</code></pre> 
<p>2.创建海量数据的sql脚本</p> 
<pre><code>CREATE TABLE dept( /*部门表*/
deptno MEDIUMINT   UNSIGNED  NOT NULL  DEFAULT 0,
dname VARCHAR(20)  NOT NULL  DEFAULT "",
loc VARCHAR(13) NOT NULL DEFAULT ""
) ;

#创建表EMP雇员
CREATE TABLE emp
(empno  MEDIUMINT UNSIGNED  NOT NULL  DEFAULT 0, /*编号*/
ename VARCHAR(20) NOT NULL DEFAULT "", /*名字*/
job VARCHAR(9) NOT NULL DEFAULT "",/*工作*/
mgr MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,/*上级编号*/
hiredate DATE NOT NULL,/*入职时间*/
sal DECIMAL(7,2)  NOT NULL,/*薪水*/
comm DECIMAL(7,2) NOT NULL,/*红利*/
deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0 /*部门编号*/
) ;

#工资级别表
CREATE TABLE salgrade
(
grade MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,
losal DECIMAL(17,2)  NOT NULL,
hisal DECIMAL(17,2)  NOT NULL
);

#测试数据
INSERT INTO salgrade VALUES (1,700,1200);
INSERT INTO salgrade VALUES (2,1201,1400);
INSERT INTO salgrade VALUES (3,1401,2000);
INSERT INTO salgrade VALUES (4,2001,3000);
INSERT INTO salgrade VALUES (5,3001,9999);

delimiter $$

#创建一个函数，名字 rand_string，可以随机返回我指定的个数字符串
create function rand_string(n INT)
returns varchar(255) #该函数会返回一个字符串
begin
#定义了一个变量 chars_str， 类型  varchar(100)
#默认给 chars_str 初始值   'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ'
 declare chars_str varchar(100) default
   'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ'; 
 declare return_str varchar(255) default '';
 declare i int default 0; 
 while i &lt; n do
    # concat 函数 : 连接函数mysql函数
   set return_str =concat(return_str,substring(chars_str,floor(1+rand()*52),1));
   set i = i + 1;
   end while;
  return return_str;
  end $$


 #这里我们又自定了一个函数,返回一个随机的部门号
create function rand_num( )
returns int(5)
begin
declare i int default 0;
set i = floor(10+rand()*500);
return i;
end $$

 #创建一个存储过程， 可以添加雇员
create procedure insert_emp(in start int(10),in max_num int(10))
begin
declare i int default 0;
#set autocommit =0 把autocommit设置成0
 #autocommit = 0 含义: 不要自动提交
 set autocommit = 0; #默认不提交sql语句
 repeat
 set i = i + 1;
 #通过前面写的函数随机产生字符串和部门编号，然后加入到emp表
 insert into emp values ((start+i) ,rand_string(6),'SALESMAN',0001,curdate(),2000,400,rand_num());
  until i = max_num
 end repeat;
 #commit整体提交所有sql语句，提高效率
   commit;
 end $$

 #添加8000000数据
call insert_emp(100001,8000000)$$

#命令结束符，再重新设置为;
delimiter ;
</code></pre> 
<p>3.实体类</p> 
<pre><code>@Data
@NoArgsConstructor
@AllArgsConstructor
public class Emp implements Serializable {
    @ExcelProperty(value = "员工编号")
    private Integer empno;

    @ExcelProperty(value = "员工名称")
    private String ename;

    @ExcelProperty(value = "工作")
    private String job;

    @ExcelProperty(value = "主管编号")
    private Integer mgr;

    @ExcelProperty(value = "入职日期")
    private Date hiredate;

    @ExcelProperty(value = "薪资")
    private BigDecimal sal;

    @ExcelProperty(value = "奖金")
    private BigDecimal comm;

    @ExcelProperty(value = "所属部门")
    private Integer deptno;

}
</code></pre> 
<p>4.vo类</p> 
<pre><code>@Data
public class EmpVo {

    @ExcelProperty(value = "员工编号")
    private Integer empno;

    @ExcelProperty(value = "员工名称")
    private String ename;

    @ExcelProperty(value = "工作")
    private String job;

    @ExcelProperty(value = "主管编号")
    private Integer mgr;

    @ExcelProperty(value = "入职日期")
    private Date hiredate;

    @ExcelProperty(value = "薪资")
    private BigDecimal sal;

    @ExcelProperty(value = "奖金")
    private BigDecimal comm;

    @ExcelProperty(value = "所属部门")
    private Integer deptno;

}
</code></pre> 
<h5>导出核心代码</h5> 
<pre><code>@Resource
private EmpService empService;
/**
 * 分批次导出
 */
@GetMapping("/export")
public void export() throws IOException {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    empService.export();
    stopWatch.stop();
    System.out.println("共计耗时： " + stopWatch.getTotalTimeSeconds()+"S");
}
public class ExcelConstants {
 //一个sheet装100w数据
    public static final Integer PER_SHEET_ROW_COUNT = 1000000;
    //每次查询20w数据，每次写入20w数据
    public static final Integer PER_WRITE_ROW_COUNT = 200000;
}
@Override
public void export() throws IOException {
    OutputStream outputStream =null;
    try {
        //记录总数:实际中需要根据查询条件进行统计即可
        //LambdaQueryWrapper&lt;Emp&gt; lambdaQueryWrapper = new QueryWrapper&lt;Emp&gt;().lambda().eq(Emp::getEmpno, 1000001);
        Integer totalCount = empMapper.selectCount(null);
        //每一个Sheet存放100w条数据
        Integer sheetDataRows = ExcelConstants.PER_SHEET_ROW_COUNT;
        //每次写入的数据量20w,每页查询20W
        Integer writeDataRows = ExcelConstants.PER_WRITE_ROW_COUNT;
        //计算需要的Sheet数量
        Integer sheetNum = totalCount % sheetDataRows == 0 ? (totalCount / sheetDataRows) : (totalCount / sheetDataRows + 1);
        //计算一般情况下每一个Sheet需要写入的次数(一般情况不包含最后一个sheet,因为最后一个sheet不确定会写入多少条数据)
        Integer oneSheetWriteCount = sheetDataRows / writeDataRows;
        //计算最后一个sheet需要写入的次数
        Integer lastSheetWriteCount = totalCount % sheetDataRows == 0 ? oneSheetWriteCount : (totalCount % sheetDataRows % writeDataRows == 0 ? (totalCount / sheetDataRows / writeDataRows) : (totalCount / sheetDataRows / writeDataRows + 1));

        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletResponse response = requestAttributes.getResponse();
        outputStream = response.getOutputStream();
        //必须放到循环外，否则会刷新流
        ExcelWriter excelWriter = EasyExcel.write(outputStream).build();

        //开始分批查询分次写入
        for (int i = 0; i &lt; sheetNum; i++) {
            //创建Sheet
            WriteSheet sheet = new WriteSheet();
            sheet.setSheetName("测试Sheet1"+i);
            sheet.setSheetNo(i);
            //循环写入次数: j的自增条件是当不是最后一个Sheet的时候写入次数为正常的每个Sheet写入的次数,如果是最后一个就需要使用计算的次数lastSheetWriteCount
            for (int j = 0; j &lt; (i != sheetNum - 1 ? oneSheetWriteCount : lastSheetWriteCount); j++) {
                //分页查询一次20w
                Page&lt;Emp&gt; page = empMapper.selectPage(new Page(j + 1 + oneSheetWriteCount * i, writeDataRows), null);
                List&lt;Emp&gt; empList = page.getRecords();
                List&lt;EmpVo&gt; empVoList = new ArrayList&lt;&gt;();
                for (Emp emp : empList) {
                    EmpVo empVo = new EmpVo();
                    BeanUtils.copyProperties(emp, empVo);
                    empVoList.add(empVo);
                }
                WriteSheet writeSheet = EasyExcel.writerSheet(i, "员工信息" + (i + 1)).head(EmpVo.class)
                        .registerWriteHandler(new LongestMatchColumnWidthStyleStrategy()).build();
                //写数据
                excelWriter.write(empVoList, writeSheet);
            }
        }
        // 下载EXCEL
        response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
        response.setCharacterEncoding("utf-8");
        // 这里URLEncoder.encode可以防止浏览器端导出excel文件名中文乱码 当然和easyexcel没有关系
        String fileName = URLEncoder.encode("员工信息", "UTF-8").replaceAll("\\+", "%20");
        response.setHeader("Content-disposition", "attachment;filename*=utf-8''" + fileName + ".xlsx");
        excelWriter.finish();
        outputStream.flush();
    } catch (IOException e) {
        e.printStackTrace();
    } catch (BeansException e) {
        e.printStackTrace();
    }finally {
        if (outputStream != null) {
            outputStream.close();
        }
    }
}
</code></pre> 
<p>这是我电脑测试时内存占用和CPU使用情况，当然开了其他一些应用。</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="490" src="https://images2.imgbox.com/97/8a/o9SEJJgZ_o.png" width="939"></p> 
<p>导出500w数据共计耗时，可以看到差不多400s左右，当然还要考虑业务复杂度已经电脑配置，我这里只是一个导出的demo并不涉及其他业务逻辑，在实际开发中可能时间会比这个更长一些</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="412" src="https://images2.imgbox.com/60/24/WXeg4UeT_o.png" width="1080"></p> 
<p>看下导出效果，我上面的脚本向插入了500w数据，100w一个sheet因此正好五个</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="261" src="https://images2.imgbox.com/11/ca/d5VsYFZU_o.png" width="711"></p> 
<p></p> 
<p class="img-center"><img alt="图片" height="565" src="https://images2.imgbox.com/a5/15/ZIuLZ74R_o.png" width="1080"></p> 
<h4>3.2模拟500w数据导入</h4> 
<p>500W数据的导入解决思路</p> 
<p>1、首先是分批读取读取Excel中的500w数据，这一点EasyExcel有自己的解决方案，我们可以参考Demo即可，只需要把它分批的参数5000调大即可。</p> 
<p>2、其次就是往DB里插入，怎么去插入这20w条数据，当然不能一条一条的循环，应该批量插入这20w条数据，同样也不能使用Mybatis的批量插入语，因为效率也低。</p> 
<p>3、使用JDBC+事务的批量操作将数据插入到数据库。（分批读取+JDBC分批插入+手动事务控制）</p> 
<p><strong>代码实现</strong></p> 
<p>controller层测试接口</p> 
<pre><code>@Resource
private EmpService empService;

@GetMapping("/importData")
public void importData() {
    String fileName = "C:\\Users\\asus\\Desktop\\员工信息.xlsx";
    //记录开始读取Excel时间,也是导入程序开始时间
    long startReadTime = System.currentTimeMillis();
    System.out.println("------开始读取Excel的Sheet时间(包括导入数据过程):" + startReadTime + "ms------");
    //读取所有Sheet的数据.每次读完一个Sheet就会调用这个方法
    EasyExcel.read(fileName, new EasyExceGeneralDatalListener(empService)).doReadAll();
    long endReadTime = System.currentTimeMillis();
    System.out.println("------结束读取Excel的Sheet时间(包括导入数据过程):" + endReadTime + "ms------");
    System.out.println("------读取Excel的Sheet时间(包括导入数据)共计耗时:" + (endReadTime-startReadTime) + "ms------");
}
</code></pre> 
<p>Excel导入事件监听</p> 
<pre><code>// 事件监听
public class EasyExceGeneralDatalListener extends AnalysisEventListener&lt;Map&lt;Integer, String&gt;&gt; {
    /**
     * 处理业务逻辑的Service,也可以是Mapper
     */
    private EmpService empService;

    /**
     * 用于存储读取的数据
     */
    private List&lt;Map&lt;Integer, String&gt;&gt; dataList = new ArrayList&lt;Map&lt;Integer, String&gt;&gt;();

    public EasyExceGeneralDatalListener() {
    }

    public EasyExceGeneralDatalListener(EmpService empService) {
        this.empService = empService;
    }

    @Override
    public void invoke(Map&lt;Integer, String&gt; data, AnalysisContext context) {
        //数据add进入集合
        dataList.add(data);
        //size是否为100000条:这里其实就是分批.当数据等于10w的时候执行一次插入
        if (dataList.size() &gt;= ExcelConstants.GENERAL_ONCE_SAVE_TO_DB_ROWS) {
            //存入数据库:数据小于1w条使用Mybatis的批量插入即可;
            saveData();
            //清理集合便于GC回收
            dataList.clear();
        }
    }

    /**
     * 保存数据到DB
     *
     * @param
     * @MethodName: saveData
     * @return: void
     */
    private void saveData() {
        empService.importData(dataList);
        dataList.clear();
    }

    /**
     * Excel中所有数据解析完毕会调用此方法
     *
     * @param: context
     * @MethodName: doAfterAllAnalysed
     * @return: void
     */
    @Override
    public void doAfterAllAnalysed(AnalysisContext context) {
        saveData();
        dataList.clear();
    }
}
</code></pre> 
<h5>核心业务代码</h5> 
<pre><code>public interface EmpService {
    void export() throws IOException;

    void importData(List&lt;Map&lt;Integer, String&gt;&gt; dataList);

}
    /*
     * 测试用Excel导入超过10w条数据,经过测试发现,使用Mybatis的批量插入速度非常慢,所以这里可以使用 数据分批+JDBC分批插入+事务来继续插入速度会非常快
    */
    @Override
    public void importData(List&lt;Map&lt;Integer, String&gt;&gt; dataList) {
        //结果集中数据为0时,结束方法.进行下一次调用
        if (dataList.size() == 0) {
            return;
        }
        //JDBC分批插入+事务操作完成对20w数据的插入
        Connection conn = null;
        PreparedStatement ps = null;
        try {
            long startTime = System.currentTimeMillis();
            System.out.println(dataList.size() + "条,开始导入到数据库时间:" + startTime + "ms");
            conn = JDBCDruidUtils.getConnection();
            //控制事务:默认不提交
            conn.setAutoCommit(false);
            String sql = "insert into emp (`empno`, `ename`, `job`, `mgr`, `hiredate`, `sal`, `comm`, `deptno`) values";
            sql += "(?,?,?,?,?,?,?,?)";
            ps = conn.prepareStatement(sql);
            //循环结果集:这里循环不支持lambda表达式
            for (int i = 0; i &lt; dataList.size(); i++) {
                Map&lt;Integer, String&gt; item = dataList.get(i);
                ps.setString(1, item.get(0));
                ps.setString(2, item.get(1));
                ps.setString(3, item.get(2));
                ps.setString(4, item.get(3));
                ps.setString(5, item.get(4));
                ps.setString(6, item.get(5));
                ps.setString(7, item.get(6));
                ps.setString(8, item.get(7));
                //将一组参数添加到此 PreparedStatement 对象的批处理命令中。
                ps.addBatch();
            }
            //执行批处理
            ps.executeBatch();
            //手动提交事务
            conn.commit();
            long endTime = System.currentTimeMillis();
            System.out.println(dataList.size() + "条,结束导入到数据库时间:" + endTime + "ms");
            System.out.println(dataList.size() + "条,导入用时:" + (endTime - startTime) + "ms");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //关连接
            JDBCDruidUtils.close(conn, ps);
        }
    }

}
</code></pre> 
<h5>jdbc工具类</h5> 
<pre><code>//JDBC工具类
public class JDBCDruidUtils {
    private static DataSource dataSource;

    /*
   创建数据Properties集合对象加载加载配置文件
    */
    static {
        Properties pro = new Properties();
        //加载数据库连接池对象
        try {
            //获取数据库连接池对象
            pro.load(JDBCDruidUtils.class.getClassLoader().getResourceAsStream("druid.properties"));
            dataSource = DruidDataSourceFactory.createDataSource(pro);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /*
    获取连接
     */
    public static Connection getConnection() throws SQLException {
        return dataSource.getConnection();
    }


    /**
     * 关闭conn,和 statement独对象资源
     *
     * @param connection
     * @param statement
     * @MethodName: close
     * @return: void
     */
    public static void close(Connection connection, Statement statement) {
        if (connection != null) {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        if (statement != null) {
            try {
                statement.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * 关闭 conn , statement 和resultset三个对象资源
     *
     * @param connection
     * @param statement
     * @param resultSet
     * @MethodName: close
     * @return: void
     */
    public static void close(Connection connection, Statement statement, ResultSet resultSet) {
        close(connection, statement);
        if (resultSet != null) {
            try {
                resultSet.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    /*
    获取连接池对象
     */
    public static DataSource getDataSource() {
        return dataSource;
    }

}
</code></pre> 
<p>druid.properties配置文件</p> 
<p>这里我将文件创建在类路径下，需要注意的是连接mysql数据库时需要指定<code>rewriteBatchedStatements=true</code>批处理才会生效，否则还是逐条插入效率较低，<code>allowMultiQueries=true</code>表示可以使sql语句中有多个insert或者update语句（语句之间携带分号），这里可以忽略。</p> 
<pre><code># druid.properties配置
driverClassName=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/llp?autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=GMT%2B8&amp;allowMultiQueries=true&amp;rewriteBatchedStatements=true
username=root
password=root
initialSize=10
maxActive=50
maxWait=60000
</code></pre> 
<p>测试结果</p> 
<pre><code>------开始读取Excel的Sheet时间(包括导入数据过程):1674181403555ms------
200000条,开始导入到数据库时间:1674181409740ms
2023-01-20 10:23:29.943  INFO 18580 --- [nio-8888-exec-1] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} inited
200000条,结束导入到数据库时间:1674181413252ms
200000条,导入用时:3512ms
200000条,开始导入到数据库时间:1674181418422ms
200000条,结束导入到数据库时间:1674181420999ms
200000条,导入用时:2577ms
.....
200000条,开始导入到数据库时间:1674181607405ms
200000条,结束导入到数据库时间:1674181610154ms
200000条,导入用时:2749ms
------结束读取Excel的Sheet时间(包括导入数据过程):1674181610155ms------
------读取Excel的Sheet时间(包括导入数据)共计耗时:206600ms------
</code></pre> 
<p>这里我删除里部分日志，从打印结果可以看出，在我的电脑上导入500w数据差不多需要200多秒的时间。当然公司的业务逻辑很复杂，数据量也比较多，表的字段也比较多，导入和导出的速度会比现在测试的要慢一点。</p> 
<h3>4.总结</h3> 
<p>1.如此大批量数据的导出和导入操作，会占用大量的内存实际开发中还应限制操作人数。</p> 
<p>2.在做大批量的数据导入时，可以使用jdbc手动开启事务，批量提交。</p> 
<p>来源：blog.csdn.net/qq_44981526/article/details/128738042</p> 
<p></p> 
<p></p> 
<p>END</p> 
<p></p> 
<p></p> 
<p><strong>往</strong></p> 
<p><strong>期</strong></p> 
<p><strong>精</strong></p> 
<p><strong>彩</strong></p> 
<p><a href="http://mp.weixin.qq.com/s?__biz=Mzg2MDYzODI5Nw==&amp;mid=2247520076&amp;idx=1&amp;sn=bd17f299641d45f393e6cc7357ca9b00&amp;chksm=ce21927af9561b6c3276791de76375876cfa75fb585e6c899b8fe9adaa35189d9127ca1104e7&amp;scene=21#wechat_redirect" rel="nofollow" title="你的Spring Boot应用启动很慢？不妨试试这个神器！">你的Spring Boot应用启动很慢？不妨试试这个神器！</a></p> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1ed7840a525f55873ad1f1c58330c2cc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">通俗易懂的C语言指针知识讲解(详细,深入) 1</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5539439a95f2ce724348795022f76159/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">itext7 html转pdf 英文或数字不自动换行的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>