<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用scikit-learn计算分类器的ROC曲线及AUC值 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用scikit-learn计算分类器的ROC曲线及AUC值" />
<meta property="og:description" content="在前面的博客中介绍了使用scikit-learn绘制分类器的学习曲线，今天介绍一下使用scikit-learn绘制分类器的ROC曲线，以及计算AUC的值。
ROC曲线主要用于衡量二分类器的性能，当正负样本不均衡时，准确率和召回率不能合理度量分类器的性能。关于ROC曲线和AUC的计算scikit-learn工具包中主要提供了以下几个函数：
1、roc_curve函数（只能用于二分类）：根据模型预测结果（概率，置信度等）和样本真实标签，按照模型预测结果降序排序依次选择阈值，基于阈值计算fpr、tpr，基于fpr和tpr即可得到分类器的ROC曲线
2、auc函数：基于roc_curve函数返回fpr、tpr序列计算二分类器的AUC值
3、roc_auc_score函数：基于样本真实标签y_target和模型预测结果（概率，置信度等）计算AUC的值，可以用于计算多分类器的AUC数值
下面通过例子看一下函数的具体使用方法：
roc_curve示例：
根据模型预测结果（概率，置信度等）和样本真实标签，按照模型预测结果降序排序依次选择阈值，基于阈值计算fpr/tpr。
from sklearn.metrics import roc_auc_score from sklearn.metrics import roc_curve from sklearn.metrics import auc import numpy as np y = np.array([1, 1, 2, 2]) scores = np.array([0.1, 0.4, 0.35, 0.8]) fpr, tpr, thresholds = roc_curve(y, scores, pos_label=2) fpr, tpr, thresholds 输出的fpr、tpr和thresholds如下：
(array([0. , 0. , 0.5, 0.5, 1. ]),
array([0. , 0.5, 0.5, 1. , 1. ]),
array([1.8 , 0.8 , 0.4 , 0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/fceb46adef0462b7892bba4fdc8e2648/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-13T20:40:38+08:00" />
<meta property="article:modified_time" content="2020-06-13T20:40:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用scikit-learn计算分类器的ROC曲线及AUC值</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-indent:33px;">在前面的博客中介绍了<a href="https://blog.csdn.net/cxx654/article/details/104922756">使用scikit-learn绘制分类器的学习曲线</a>，今天介绍一下使用scikit-learn绘制分类器的ROC曲线，以及计算AUC的值。</p> 
<p style="text-indent:33px;">ROC曲线主要用于衡量二分类器的性能，当正负样本不均衡时，准确率和召回率不能合理度量分类器的性能。关于ROC曲线和AUC的计算scikit-learn工具包中主要提供了以下几个函数：</p> 
<p style="text-indent:33px;">1、roc_curve函数（只能用于二分类）：根据模型预测结果（概率，置信度等）和样本真实标签，按照模型预测结果降序排序依次选择阈值，基于阈值计算fpr、tpr，基于fpr和tpr即可得到分类器的ROC曲线</p> 
<p style="text-indent:33px;">2、auc函数：基于roc_curve函数返回fpr、tpr序列计算二分类器的AUC值</p> 
<p style="text-indent:33px;">3、roc_auc_score函数：基于样本真实标签y_target和模型预测结果（概率，置信度等）计算AUC的值，可以用于计算多分类器的AUC数值</p> 
<p style="text-indent:33px;">下面通过例子看一下函数的具体使用方法：</p> 
<p style="text-indent:33px;"><strong>roc_curve示例：</strong></p> 
<p style="text-indent:33px;">根据模型预测结果（概率，置信度等）和样本真实标签，按照模型预测结果降序排序依次选择阈值，基于阈值计算fpr/tpr。</p> 
<pre><code class="language-python">from sklearn.metrics import roc_auc_score
from sklearn.metrics import roc_curve
from sklearn.metrics import auc
import numpy as np


y = np.array([1, 1, 2, 2])
scores = np.array([0.1, 0.4, 0.35, 0.8])
fpr, tpr, thresholds = roc_curve(y, scores, pos_label=2)

fpr, tpr, thresholds</code></pre> 
<p style="text-indent:33px;">输出的fpr、tpr和thresholds如下：</p> 
<p style="text-indent:0;">(array([0. , 0. , 0.5, 0.5, 1. ]),<br> array([0. , 0.5, 0.5, 1. , 1. ]),<br> array([1.8 , 0.8 , 0.4 , 0.35, 0.1 ]))</p> 
<p style="text-indent:33px;">基于fpr（x轴）和tpr（y轴）绘制ROC曲线如下：</p> 
<pre><code class="language-python">%matplotlib inline
from matplotlib import pyplot as plt

plt.plot(fpr, tpr)
plt.xlabel("FPR")
plt.ylabel("TPR")
plt.xlim([0, 1])
plt.ylim([0, 1])</code></pre> 
<p style="text-align:center;"><img alt="" height="266" src="https://images2.imgbox.com/90/f5/2iWeYZeW_o.png" width="394"></p> 
<p style="text-indent:33px;"><strong>auc示例：</strong></p> 
<p style="text-indent:33px;">基于roc_curve函数返回fpr、tpr序列计算AUC的值（和roc_auc_score等价）。</p> 
<pre><code class="language-python">import numpy as np
y = np.array([1, 1, 2, 2])
pred = np.array([0.1, 0.4, 0.35, 0.8])
fpr, tpr, thresholds = roc_curve(y, pred, pos_label=2)
auc(fpr, tpr), roc_auc_score(y, pred)</code></pre> 
<p style="text-indent:33px;">输出结果如下：</p> 
<p style="text-indent:33px;">(0.75, 0.75)</p> 
<p style="text-indent:33px;"><strong>roc_auc_score示例：</strong></p> 
<p style="text-indent:33px;">基于样本真实标签y_target和模型预测结果（概率，置信度等）计算AUC的值，可以用于计算多分类器的AUC数值。</p> 
<pre><code class="language-python">%matplotlib inline
import matplotlib.pyplot as plt
import numpy as np
from sklearn.svm import SVC
from sklearn.metrics import roc_curve, roc_auc_score, auc, plot_roc_curve
from sklearn.multiclass import OneVsOneClassifier, OneVsRestClassifier
from sklearn.preprocessing import label_binarize
from sklearn import datasets
from sklearn.model_selection import train_test_split
np.random.seed(100)

# 加载iris数据集
iris = datasets.load_iris()
X = iris.data
y = iris.target
print(X.shape, y.shape)
n_samples, n_features = X.shape

# iris数据集加入噪声，使得ROC不是那么完美
X = np.c_[X, np.random.randn(n_samples, 50 * n_features)]
# y = label_binarize(y, classes=[0, 1, 2])
# n_classes = y.shape[1]
# 训练样本的类别数量
n_classes = 3

# 划分训练集和测试集
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=.5, random_state=0)
print(X_train.shape, y_train.shape)
print(X_test.shape, y_test.shape)

# 使用One-vs-One模式训练SVM分类器
clf = OneVsRestClassifier(SVC(kernel="linear", probability=True))
clf.fit(X_train, y_train)

# 计算分类器在测试集上的决策值
y_scores = clf.predict_proba(X_test)
print(y_scores.shape)

# 绘制每个类别的ROC曲线
fig, axes = plt.subplots(2, 2, figsize=(8, 8))
colors = ["r", "g", "b", "k"]
markers = ["o", "^", "v", "+"]

y_test = label_binarize(y_test, classes=clf.classes_)
for i in range(n_classes):
    # 计算每个类别的FPR, TPR 
    fpr, tpr, thr = roc_curve(y_test[:, i], y_scores[:, i])
#     print("classes_{}, fpr: {}, tpr: {}, threshold: {}".format(i, fpr, tpr, thr))
    # 绘制ROC曲线，并计算AUC值
    axes[int(i / 2), i % 2].plot(fpr, tpr, color=colors[i], marker=markers[i], label="AUC: {:.2f}".format(auc(fpr, tpr)))
    axes[int(i / 2), i % 2].set_xlabel("FPR")
    axes[int(i / 2), i % 2].set_ylabel("TPR")
    axes[int(i / 2), i % 2].set_title("Class_{}".format(clf.classes_[i]))
    axes[int(i / 2), i % 2].legend(loc="lower right")

print("AUC:", roc_auc_score(y_test, clf.predict_proba(X_test), multi_class="ovr", average=None))</code></pre> 
<p style="text-indent:33px;">输出结果如下：</p> 
<p style="text-indent:33px;">AUC: [0.99647266 0.8237037  0.90196078]</p> 
<p style="text-align:center;"><img alt="" height="496" src="https://images2.imgbox.com/34/ff/E3GQd7rO_o.png" width="505"></p> 
<p style="text-indent:33px;">这个例子中是一个多分类问题，y_scores和y_test的形状都是（n_samples， 3），且y_scores、y_test的每列分别代表clf.classes_每种类型的真实标签和预测概率，然后基于每种类型的真是标签和预测概率计使用roc_curve函数计算fpr和tpr，并使用auc函数计算AUC的值。最后使用roc_auc_score函数计算多分类的整体AUC值。</p> 
<p style="text-indent:33px;">在计算多分类的roc_auc_score值时，可以通过参数multi_class : {'raise', 'ovr', 'ovo'}控制多分类模型是使用哪种模式训练的，参数average : {'micro', 'macro', 'samples', 'weighted'} or None表示使用何种方式计算多分类器AUC的值，常用的包括宏平均和微平均。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/36/99/cVcNGim5_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a4/e5/8OU35iKn_o.png"></p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f1df138e48763920dd9e22ec583e7b2b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">XML文件配置JDBC连接url的时候多个参数报错解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5d9154114f1d974b98dfe70d6152792a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">问题:ssm关于mybatis没有找到配置问题(not found)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>