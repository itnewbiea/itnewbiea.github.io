<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java 21 新特性】顺序集合（Sequenced Collections） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Java 21 新特性】顺序集合（Sequenced Collections）" />
<meta property="og:description" content="1 摘要 引入新的接口表示具有定义的遇到顺序的集合。每个这样的集合都有一个明确定义的第一个元素、第二个元素，依此类推，直到最后一个元素。提供统一的API来访问它的第一个和最后一个元素，并以相反的顺序处理它的元素。
&#34;生活只能向后理解；但必须向前生活。&#34;—基尔克高德
2 动机 Java集合框架缺乏表示具有定义的遇到顺序的元素序列的集合类型。它还缺乏适用于这些集合的统一操作集。这些差距一直是问题和抱怨的重要来源。
如List和Deque都定义了遇到顺序，但共同父类Collection却没有定义遇到顺序。同样，Set没有定义遇到顺序，而子类型HashSet也没定义，但子类型如SortedSet和LinkedHashSet却定义了。因此，对遇到顺序的支持在类型层次结构中分散，使得在API中表达某些有用概念很困难，即不能在Collection中描述具有遇到顺序的参数或返回值。Collection太一般了，将这些约束规定到散文规范中，可能导致难以调试的错误。List太具体了，排除了SortedSet和LinkedHashSet。
FAQ 视图集合通常被迫降级到较弱语义。用Collections::unmodifiableSet包装LinkedHashSet会产生一个Set，丢弃了顺序信息。
没有定义它们的接口，与遇到顺序相关的操作要么不一致，要么缺失。虽许多实现支持获取第一个或最后一个元素，但每个集合都定义了自己的方式，有些不明显或完全缺失：
First elementLast elementListlist.get(0)list.get(list.size() - 1)Dequedeque.getFirst()deque.getLast()SortedSetsortedSet.first()sortedSet.last()LinkedHashSetlinkedHashSet.iterator().next()// missing 一些是不必要的繁琐，如获取List的最后一个元素有些甚至没有英雄主义是不可能的：获取LinkedHashSet的最后一个元素的唯一方法是迭代整个集合！同样，从第一个元素到最后一个元素遍历通常需用迭代器或使用普通for循环，使代码冗长不直观 为解决这些问题，引入新接口SequencedCollection表示具有定义的遇到顺序的集合。每个SequencedCollection都有一个明确定义的第一个元素、第二个元素，依此类推，直到最后一个元素。它还提供统一的API访问它的第一个和最后一个元素，并以相反的顺序处理它的元素。
SequencedCollection还提供新reversed()方法，提供一个反向排序的视图。这视图可让集合以相反顺序处理元素，使用所有常见迭代机制，如增强for循环、显式的iterator()循环、forEach()、stream()、parallelStream()和toArray()。
如以前从LinkedHashSet获取反向排序的流困难，现只需linkedHashSet.reversed().stream()。
SequencedCollection还从Deque中提升一些方法，支持在两端添加、获取和删除元素：
void addFirst(E)void addLast(E)E getFirst()E getLast()E removeFirst()E removeLast() add(E)和remove()方法可选，主要是为支持不可修改的集合的情况。如集合为空，get()和remove()方法将抛出NoSuchElementException。
由于SequencedCollection的子接口具有冲突的定义，所以在SequencedCollection中没有定义equals()和hashCode()方法。
这些改动使得具有遇到顺序的集合更加易于使用和操作，并提供了一致的API来处理这些集合的元素。
Sequenced Sets Set接口的扩展，有序集合，不含重复元素：
// since 21 interface SequencedSet&lt;E&gt; extends Set&lt;E&gt;, SequencedCollection&lt;E&gt; { SequencedSet&lt;E&gt; reversed(); // 协变重写 } SequencedSet接口提供reversed()方法，用于返回一个反转顺序的SequencedSet。对于LinkedHashSet等集合，若元素已存在于集合中，则会将其移动到适当位置。这解决LinkedHashSet无法重新定位元素痛点。
SequencedMap Map接口的扩展，条目具有定义好的遍历顺序。
interface SequencedMap&lt;K,V&gt; extends Map&lt;K,V&gt; { // 新方法 SequencedMap&lt;K,V&gt; reversed(); SequencedSet&lt;K&gt; sequencedKeySet(); SequencedCollection&lt;V&gt; sequencedValues(); SequencedSet&lt;Entry&lt;K,V&gt;&gt; sequencedEntrySet(); V putFirst(K, V); V putLast(K, V); // 从NavigableMap中提升的方法 Entry&lt;K, V&gt; firstEntry(); Entry&lt;K, V&gt; lastEntry(); Entry&lt;K, V&gt; pollFirstEntry(); Entry&lt;K, V&gt; pollLastEntry(); } reversed()返回一个反转顺序的SequencedMapsequencedKeySet()返回一个有序的键集合sequencedValues()返回一个有序的值集合sequencedEntrySet()返回一个有序的条目集合 SequencedMap还提供了putFirst()和putLast()方法，用于在指定位置插入键值对。对于SortedMap等映射，这些方法会抛出UnsupportedOperationException。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0a73a1fe959e05c4e55052d95beec1f0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-02T09:55:39+08:00" />
<meta property="article:modified_time" content="2024-01-02T09:55:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java 21 新特性】顺序集合（Sequenced Collections）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="1-摘要">1 摘要</h3> 
<p>引入新的接口表示具有定义的遇到顺序的集合。每个这样的集合都有一个明确定义的第一个元素、第二个元素，依此类推，直到最后一个元素。提供统一的API来访问它的第一个和最后一个元素，并以相反的顺序处理它的元素。</p> 
<blockquote> 
 <p>"生活只能向后理解；但必须向前生活。"—基尔克高德</p> 
</blockquote> 
<h3 id="2-动机">2 动机</h3> 
<p>Java集合框架缺乏表示具有定义的遇到顺序的元素序列的集合类型。它还缺乏适用于这些集合的统一操作集。这些差距一直是问题和抱怨的重要来源。</p> 
<p>如List和Deque都定义了遇到顺序，但共同父类Collection却没有定义遇到顺序。同样，Set没有定义遇到顺序，而子类型HashSet也没定义，但子类型如SortedSet和LinkedHashSet却定义了。因此，对遇到顺序的支持在类型层次结构中分散，使得在API中表达某些有用概念很困难，即不能在Collection中描述具有遇到顺序的参数或返回值。Collection太一般了，将这些约束规定到散文规范中，可能导致难以调试的错误。List太具体了，排除了SortedSet和LinkedHashSet。</p> 
<h4 id="faq">FAQ</h4> 
<p>视图集合通常被迫降级到较弱语义。用Collections::unmodifiableSet包装LinkedHashSet会产生一个Set，丢弃了顺序信息。</p> 
<p>没有定义它们的接口，与遇到顺序相关的操作要么不一致，要么缺失。虽许多实现支持获取第一个或最后一个元素，但每个集合都定义了自己的方式，有些不明显或完全缺失：</p> 
<table><thead><tr><th align="right"></th><th align="left">First element</th><th align="left">Last element</th></tr></thead><tbody><tr><td align="right"><code>List</code></td><td align="left"><code>list.get(0)</code></td><td align="left"><code>list.get(list.size() - 1)</code></td></tr><tr><td align="right"><code>Deque</code></td><td align="left"><code>deque.getFirst()</code></td><td align="left"><code>deque.getLast()</code></td></tr><tr><td align="right"><code>SortedSet</code></td><td align="left"><code>sortedSet.first()</code></td><td align="left"><code>sortedSet.last()</code></td></tr><tr><td align="right"><code>LinkedHashSet</code></td><td align="left"><code>linkedHashSet.iterator().next()</code></td><td align="left"><code>// missing</code></td></tr></tbody></table> 
<ul><li>一些是不必要的繁琐，如获取List的最后一个元素</li><li>有些甚至没有英雄主义是不可能的：获取LinkedHashSet的最后一个元素的唯一方法是迭代整个集合！</li><li>同样，从第一个元素到最后一个元素遍历通常需用迭代器或使用普通for循环，使代码冗长不直观</li></ul> 
<p>为解决这些问题，引入新接口SequencedCollection表示具有定义的遇到顺序的集合。每个SequencedCollection都有一个明确定义的第一个元素、第二个元素，依此类推，直到最后一个元素。它还提供统一的API访问它的第一个和最后一个元素，并以相反的顺序处理它的元素。</p> 
<p>SequencedCollection还提供新reversed()方法，提供一个反向排序的视图。这视图可让集合以相反顺序处理元素，使用所有常见迭代机制，如增强for循环、显式的iterator()循环、forEach()、stream()、parallelStream()和toArray()。</p> 
<p>如以前从LinkedHashSet获取反向排序的流困难，现只需linkedHashSet.reversed().stream()。</p> 
<p>SequencedCollection还从Deque中提升一些方法，支持在两端添加、获取和删除元素：</p> 
<ul><li><code>void addFirst(E)</code></li><li><code>void addLast(E)</code></li><li><code>E getFirst()</code></li><li><code>E getLast()</code></li><li><code>E removeFirst()</code></li><li><code>E removeLast()</code></li></ul> 
<p>add<em>(E)和remove</em>()方法可选，主要是为支持不可修改的集合的情况。如集合为空，get<em>()和remove</em>()方法将抛出NoSuchElementException。</p> 
<p>由于SequencedCollection的子接口具有冲突的定义，所以在SequencedCollection中没有定义equals()和hashCode()方法。</p> 
<p>这些改动使得具有遇到顺序的集合更加易于使用和操作，并提供了一致的API来处理这些集合的元素。</p> 
<h3 id="sequenced-sets">Sequenced Sets</h3> 
<p>Set接口的扩展，有序集合，不含重复元素：</p> 
<pre><code class="language-java">// since 21
interface SequencedSet&lt;E&gt; extends Set&lt;E&gt;, SequencedCollection&lt;E&gt; {
    SequencedSet&lt;E&gt; reversed();    // 协变重写
}</code></pre> 
<p>SequencedSet接口提供reversed()方法，用于返回一个反转顺序的SequencedSet。对于LinkedHashSet等集合，若元素已存在于集合中，则会将其移动到适当位置。这解决LinkedHashSet无法重新定位元素痛点。</p> 
<h3 id="sequencedmap">SequencedMap</h3> 
<p>Map接口的扩展，条目具有定义好的遍历顺序。</p> 
<pre><code class="language-java">interface SequencedMap&lt;K,V&gt; extends Map&lt;K,V&gt; {
    // 新方法
    SequencedMap&lt;K,V&gt; reversed();
    SequencedSet&lt;K&gt; sequencedKeySet();
    SequencedCollection&lt;V&gt; sequencedValues();
    SequencedSet&lt;Entry&lt;K,V&gt;&gt; sequencedEntrySet();
    V putFirst(K, V);
    V putLast(K, V);
    // 从NavigableMap中提升的方法
    Entry&lt;K, V&gt; firstEntry();
    Entry&lt;K, V&gt; lastEntry();
    Entry&lt;K, V&gt; pollFirstEntry();
    Entry&lt;K, V&gt; pollLastEntry();
}</code></pre> 
<ul><li>reversed()返回一个反转顺序的SequencedMap</li><li>sequencedKeySet()返回一个有序的键集合</li><li>sequencedValues()返回一个有序的值集合</li><li>sequencedEntrySet()返回一个有序的条目集合</li></ul> 
<p>SequencedMap还提供了putFirst()和putLast()方法，用于在指定位置插入键值对。对于SortedMap等映射，这些方法会抛出UnsupportedOperationException。</p> 
<p>SequencedMap还提升了一些方法从NavigableMap接口，这些方法支持在两端获取和删除条目。</p> 
<h3 id="retrofitting">Retrofitting</h3> 
<p>为了将新的接口与现有的类和接口结构整合起来，调整：</p> 
<p><img src="https://images2.imgbox.com/72/b3/tjPmXWzi_o.png" alt="img"></p> 
<ul><li>List接口现在直接继承自SequencedCollection接口</li><li>Deque接口现在直接继承自SequencedCollection接口</li><li>LinkedHashSet类实现了SequencedSet接口</li><li>SortedSet接口现在直接继承自SequencedSet接口</li><li>LinkedHashMap类实现了SequencedMap接口</li><li>SortedMap接口现在直接继承自SequencedMap接口。</li></ul> 
<p>在适当的位置为reversed()方法提供了协变重写。如List#reversed()重写为返回一个List类型的值，而不是SequencedCollection类型的值。</p> 
<p>还在Collections工具类中添加了一些新的方法，用于创建不可修改的包装器：</p> 
<ul><li>Collections.unmodifiableSequencedCollection(sequencedCollection)</li><li>Collections.unmodifiableSequencedSet(sequencedSet)</li><li>Collections.unmodifiableSequencedMap(sequencedMap)</li></ul> 
<h3 id="替代方案">替代方案</h3> 
<h4 id="类型">类型</h4> 
<p>将List接口重新定义为通用的有序集合类型。虽然List是有序的，但它也支持通过整数索引访问元素。许多有序的数据结构并不自然地支持索引，因此它们将被要求通过迭代来支持索引访问，这将导致索引访问的性能从O(1)变为O(n)，延续了LinkedList的错误。</p> 
<p>Deque作为通用的序列类型似乎是一个不错的选择，因为它已经支持了正确的一组操作。然而，它还包含了其他操作，包括一系列返回null的操作（offer、peek和poll），以及从Queue继承的操作。这些操作对于队列来说是合理的，但对于其他集合来说则不太合适。如果将Deque重新定义为通用的序列类型，那么List也将成为一个Queue，并支持栈操作，导致API变得混乱和令人困惑。</p> 
<h4 id="命名">命名</h4> 
<p>术语"sequence"（序列）在这里被选择，它暗示了元素按照一定的顺序排列。它在各个平台上都被广泛使用，表示具有类似语义的集合。</p> 
<p>术语"ordered"（有序）并不够具体。我们需要迭代两个方向上的元素，并在两端进行操作。一个有序的集合，如Queue，是一个明显的例外：它是有序的，但它也明显是不对称的。</p> 
<p>术语"reversible"（可逆）在之前的版本中使用过，但它并没有立即唤起双端的概念。也许更大的问题是，Map变体将被命名为ReversibleMap，这会误导地暗示它支持通过键和值进行查找（有时称为BiMap或BidiMap）。</p> 
<h4 id="add-put-and-unsupportedoperationexception">Add, put, and <code>UnsupportedOperationException</code></h4> 
<p>对于通过相对比较确定顺序的集合，例如SortedSet的addFirst和SortedMap的putLast方法会抛出UnsupportedOperationException。一些集合不实现所有SequencedCollection操作的不对称性可能看起来不太好。然而，这是有价值的，因为它将SortedSet和SortedMap纳入到有序集合的家族中，使它们可以比以前更广泛地使用。这种不对称性也与集合框架中的先前设计决策保持一致。例如，Map的keySet方法返回一个Set，即使实际返回的实现不支持添加操作。</p> 
<p>另一种方法是通过重新调整接口来保持添加操作的独立性。这将导致在结构上有很薄的语义的新接口类型（例如AddableCollection），在实践中没有用处，并且会使类型层次结构变得混乱。</p> 
<h4 id="测试">测试</h4> 
<p>我们将在JDK的回归测试套件中添加一套全面的测试。</p> 
<h4 id="风险和假设">风险和假设</h4> 
<p>在继承层次结构中高层次地引入新的方法可能会导致对明显方法名称（如reversed()和getFirst()）的冲突。</p> 
<p>特别需要关注的是List和Deque上reversed()方法的协变重写。这些重写与已经实现了List和Deque的现有集合在源代码和二进制兼容性上是不兼容的。在JDK中有两个这样的集合的例子：LinkedList和一个内部类sun.awt.util.IdentityLinkedList。LinkedList类通过在LinkedList本身上引入一个新的reversed()协变重写来处理。内部的IdentityLinkedList类被删除，因为它不再需要。</p> 
<p>提案的早期版本在SequencedMap接口上引入了keySet()、values()和entrySet()方法的协变重写。经过一些分析，确定这种方法引入了不兼容性的风险太大；实际上，它使任何现有的子类都无效。选择了另一种方法，即在SequencedMap中引入了新的sequencedKeySet()、sequencedValues()和sequencedEntrySet()方法，而不是调整现有方法为协变重写。回顾起来，这可能是因为在Java 6中引入navigableKeySet()方法时采用了类似的方法，而不是修改现有的keySet()方法为协变重写。</p> 
<p>有关不兼容性风险的完整分析，请参见附加到CSR（JDK-8266572）的报告。</p> 
<h4 id="历史">历史</h4> 
<p>这个提案是我们2021年ReversibleCollections提案的一个增量演进。与该提案相比，主要的变化是改名、引入SequencedMap接口以及引入不可修改的包装器方法。</p> 
<p>ReversibleCollection提案又基于Tagir Valeev的2020年OrderedMap/OrderedSet提案。该提案中的一些基本概念仍然存在，尽管在细节上有很多不同。</p> 
<p>多年来，我们收到了许多关于将List与Set或Map结合的请求和提案。这些请求包括4152834、4245809、4264420、4268146、6447049和8037382。</p> 
<p>其中一些请求在Java 1.4中引入的LinkedHashSet和LinkedHashMap中部分得到了满足。虽然这些类满足了一些用例，但它们的引入留下了集合框架中抽象和操作的空白，如上所述。</p> 
<h4 id="测试-1">测试</h4> 
<p>我们将向JDK的回归测试套件中添加一套全面的测试。</p> 
<h4 id="风险和假设-1">风险和假设</h4> 
<p>在继承层次结构中引入新的方法存在冲突的风险，例如reversed()和getFirst()这样的明显方法名称。 特别关注的是List和Deque上的covariant overrides的reversed()方法。这些方法与已实现List和Deque的现有集合在源代码和二进制上不兼容。在JDK中有两个这样的集合的示例：LinkedList和一个内部类sun.awt.util.IdentityLinkedList。LinkedList类通过在LinkedList本身上引入了一个新的reversed() covariant override来处理。内部的IdentityLinkedList类被删除，因为它不再需要。 提案的早期版本在SequencedMap接口的keySet()、values()和entrySet()方法上引入了covariant overrides。经过一些分析，确定这种方法引入了太大的不兼容风险；实质上，它使任何现有的子类无效。选择了另一种替代方法，即在SequencedMap中引入新的方法sequencedKeySet()、sequencedValues()和sequencedEntrySet()，而不是调整现有方法为covariant overrides。回顾起来，可能出于同样的原因，在Java 6中引入navigableKeySet()方法时采取了类似的方法，而不是修改现有的keySet()方法为covariant override。 有关不兼容风险的完整分析，请参阅附加到CSR（JDK-8266572）的报告。</p> 
<p>参考</p> 
<ul><li><a href="https://blog.csdn.net/qq_33589510/category_6949777.html">编程严选网专栏-JDK21新特性</a> 
  <blockquote> 
   <p>本文由博客一文多发平台 <a href="https://openwrite.cn?from=article_bottom" rel="nofollow">OpenWrite</a> 发布！</p> 
  </blockquote> </li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5b4d8e7e74424590142ce6575e699168/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">配置文件的创建和部署</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7f1463b62b24f06c07b49309b52d32fd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Oracle merge into 详解（有则更新，无则插入）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>