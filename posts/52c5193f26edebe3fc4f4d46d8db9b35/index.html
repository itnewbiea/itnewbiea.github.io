<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>排列组合（STL算法中next_permutation和prev_permutation剖析） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="排列组合（STL算法中next_permutation和prev_permutation剖析）" />
<meta property="og:description" content="STL提供了两个用来计算排列组合关系的算法，分别是next_permucation和prev_permutation。解决全排列问题。
首先我们必须了解什么是“下一个”排列组合,什么是“前一个”排列组合。考虑三个字符所组成的序列{a,b, c)。这个序列有六个可能的排列组合: abc，acb，bac,bca，cab,cba。
这些排列组合根据less-than操作符做字典顺序（按照升序排列）的排序。也就是说，abc名列第一，因为每一个元素都小于其后的元素。acb是次一个排列组合，因为它是固定了a(序列内最小元素）之后所做的新组合。同样道理，那些固定b(序列内次小元素）而做的排列组合，在次序上将先于那些固定c而做的排列组合。以bac和 bca为例，bac在 bca之前，因为序列ac小于序列ca。面对bca，我们可以说其前一个排列组合是bac，而其后一个排列组合是cab。序列abc没有“前一个”排列组合，cba没有“后一个”排列组合。
next_permutation next_permutation ( ）会取得〔 first,last）所标示之序列的下一个排列组合。如果没有下一个排列组合，便返回false;否则返回true。
next_permutation 算法过程： 首先，从最尾端开始往前寻找两个相邻元素，令第一元素为*i，第二元素为 *ii，且满足*i&lt; *ii。找到这样一组相邻元素后,再从最尾端开始往前检验,找出第一个大于*i的元素，令为*j，将 i,j元素对调，再将 ii 之后的所有元素颠倒排列。此即所求之“下一个”排列组合。
e.g.以序列{0，1，2，3，4}为例，获得”下一个”排列组合。 输入序列{0，1，2，3，4}
第一元素为*i == 3，第二元素为 *ii == 4，且满足*i&lt; *ii. 找到这样一组相邻元素(3 4)
从最尾端开始往前检验,找出第一个大于*i的元素，令为*j == 4
将 i,j元素对调(*i == 4*j == 3)，再将 ii 之后的所有元素颠倒排列
输出“下一个”排列组合{0，1，2，4，3}；
e.g.以序列{0，1，2，4，3}为例，获得”下一个”排列组合。 输入序列{0，1，2，4，3}
第一元素为*i == 2，第二元素为 *ii == 4，且满足*i&lt; *ii. 找到这样一组相邻元素(2 4)
从最尾端开始往前检验,找出第一个大于*i的元素，令为*j == 3
将 i,j元素对调(*i == 3 *j == 2)，再将 ii 之后的所有元素颠倒排列 (4 2--&gt;2 4)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/52c5193f26edebe3fc4f4d46d8db9b35/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-15T20:25:20+08:00" />
<meta property="article:modified_time" content="2023-03-15T20:25:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">排列组合（STL算法中next_permutation和prev_permutation剖析）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <p style="">STL提供了两个用来计算排列组合关系的算法，分别是next_permucation和prev_permutation。解决全排列问题。</p> 
 <p style="text-indent:1.4em;">首先我们必须了解什么是“下一个”排列组合,什么是“前一个”排列组合。考虑三个字符所组成的序列{a,b, c)。这个序列有六个可能的排列组合: abc，acb，bac,bca，cab,cba。</p> 
 <p style="text-indent:1.4em;">这些排列组合根据less-than操作符做字典顺序（按照升序排列）的排序。也就是说，abc名列第一，因为每一个元素都小于其后的元素。acb是次一个排列组合，因为它是固定了a(序列内最小元素）之后所做的新组合。同样道理，那些固定b(序列内次小元素）而做的排列组合，在次序上将先于那些固定c而做的排列组合。以bac和 bca为例，bac在 bca之前，因为序列ac小于序列ca。面对bca，我们可以说其前一个排列组合是bac，而其后一个排列组合是cab。序列abc没有“前一个”排列组合，cba没有“后一个”排列组合。</p> 
 <h2 style=""><span class="kdocs-bold" style="font-weight:bold;">next_permutation</span></h2> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">next_permutation ( ）</span>会取得〔 first,last）所标示之序列的下一个排列组合。如果没有下一个排列组合，便返回false;否则返回true。</p> 
 <p style=""> </p> 
 <h3 style=""><span class="kdocs-bold" style="font-weight:bold;">next_permutation 算法过程：</span></h3> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:705px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:39.432625%;height:0;"> 
    <img src="https://images2.imgbox.com/09/e9/ifLRES7V_o.png" style="margin-left:;display:block;width:705px;margin-top:-39.432625%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="text-indent:1.4em;">首先，从最<span class="kdocs-bold" style="font-weight:bold;">尾端开始往前</span>寻找两个相邻元素，令第一元素为*i，第二元素为 *ii，且满足<span class="kdocs-bold" style="font-weight:bold;">*i&lt; *ii</span>。找到这样一组相邻元素后,再从最尾端开始往前检验,找出<span class="kdocs-bold" style="font-weight:bold;">第一个大于*i的元素</span>，令为*j，将<span class="kdocs-bold" style="font-weight:bold;"> i,j元素对调</span>，再将 <span class="kdocs-bold" style="font-weight:bold;">ii 之后的所有元素颠倒排列</span>。此即所求之“下一个”排列组合。</p> 
 <p style=""></p> 
 <h3 style="">e.g.以序列{0，1，2，3，4}为例，获得”下一个”排列组合。</h3> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:798px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:48.1203%;height:0;"> 
    <img src="https://images2.imgbox.com/bd/0e/Yv4uQL76_o.png" style="margin-left:;display:block;width:798px;margin-top:-48.1203%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">输入序列{0，1，2，3，4}</p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>第一元素为<span class="kdocs-bold" style="font-weight:bold;">*i </span>== 3，第二元素为 <span class="kdocs-bold" style="font-weight:bold;">*ii</span> == 4，且满足<span class="kdocs-bold" style="font-weight:bold;">*i&lt; *ii.</span> 找到这样一组相邻元素(3 4)</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>从最尾端开始往前检验,找出<span class="kdocs-bold" style="font-weight:bold;">第一个大于*i的元素</span>，令为*j == 4</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>将<span class="kdocs-bold" style="font-weight:bold;"> i,j元素对调</span>(*i == 4*j == 3)，再将 <span class="kdocs-bold" style="font-weight:bold;">ii 之后的所有元素颠倒排列</span></p></li></ol> 
 <p style="">输出“下一个”排列组合{0，1，2，4，3}；</p> 
 <p style=""></p> 
 <h3 style="">e.g.以序列{0，1，2，4，3}为例，获得”下一个”排列组合。</h3> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:759px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:42.160736%;height:0;"> 
    <img src="https://images2.imgbox.com/6c/f0/2OSX09au_o.png" style="margin-left:;display:block;width:759px;margin-top:-42.160736%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:left;">输入序列{0，1，2，4，3}</p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><p>第一元素为<span class="kdocs-bold" style="font-weight:bold;">*i </span>== 2，第二元素为 <span class="kdocs-bold" style="font-weight:bold;">*ii</span> == 4，且满足<span class="kdocs-bold" style="font-weight:bold;">*i&lt; *ii.</span> 找到这样一组相邻元素(2 4)</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><p>从最尾端开始往前检验,找出<span class="kdocs-bold" style="font-weight:bold;">第一个大于*i的元素</span>，令为*j == 3</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><p>将<span class="kdocs-bold" style="font-weight:bold;"> i,j元素对调</span>(*i == 3 *j == 2)，再将 <span class="kdocs-bold" style="font-weight:bold;">ii 之后的所有元素颠倒排列 </span>(4 2--&gt;2 4)</p></li></ol> 
 <p style="text-align:left;">输出“下一个”排列组合{0，1，3，2，4}；</p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:861px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:64.45993%;height:0;"> 
    <img src="https://images2.imgbox.com/00/a5/yIV5aYB3_o.png" style="margin-left:;display:block;width:861px;margin-top:-64.45993%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:788px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:92.766495%;height:0;"> 
    <img src="https://images2.imgbox.com/75/8f/6HJ0spU2_o.png" style="margin-left:;display:block;width:788px;margin-top:-92.766495%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">代码测试求全排列问题：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">#include&lt;iostream&gt;

using namespace std;

bool test_next_permutation(char* first, char* last)
{
    if(first == last) return false;
    char* i = first;
    ++i;
    if(i == last) return false;//只有一个元素
    i = last;                //i指向尾部
    --i;

    for(;;)
    {
        char* ii = i;
        --i;
        //以上，以确定一组相邻元素(升序)
        if(*i &lt; *ii){ //如果前一个小
            char * j = last; //j指向尾部（尾元素下一个）
            while(!(*i &lt; *--j));//由尾向前，找到比*i大的元素
            swap(*i,*j);  //交换i，j元素
            reverse(ii,last);//将ii后全部元素逆序排序
            return true;
        }
        if(i == first){  //进行首元素
            reverse(first, last);//全部逆向排序
            return false;
        }
    }
}
int main()
{
    char s[5] = "0123";
    do
    {
        cout&lt;&lt;s&lt;&lt;endl;
        
    }while(test_next_permutation(s,s+4));
    return 0;
}</code></pre> 
 <h2 style="">prev_permutation</h2> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:856px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:96.14486%;height:0;"> 
    <img src="https://images2.imgbox.com/02/85/THkIzcn2_o.png" style="margin-left:;display:block;width:856px;margin-top:-96.14486%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:795px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:99.74842%;height:0;"> 
    <img src="https://images2.imgbox.com/95/6b/DOAEMRlp_o.png" style="margin-left:;display:block;width:795px;margin-top:-99.74842%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e39b5c224543c1312ffb984ce4ab35bc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">利用Matlab替换图片部分颜色</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/402a4003d5a07b582cbf2f3bf5845aef/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">YOLOv4算法详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>