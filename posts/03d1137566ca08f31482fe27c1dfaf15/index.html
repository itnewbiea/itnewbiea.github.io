<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python算法与数据结构-常用查找算法一(37) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python算法与数据结构-常用查找算法一(37)" />
<meta property="og:description" content="一、什么是查找 查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。查找表（Search Table）：由同一类型的数据元素（或记录）构成的集合关键字（Key）：数据元素中某个数据项的值，又称为键值。主键（Primary Key）：可唯一地标识某个数据元素或记录的关键字。 搜索是在一个项目集合中找到一个特定项目的算法过程。搜索通常的答案是真的或假的，因为该项目是否存在。 搜索的几种常见方法：顺序查找、二分法查找、二叉树查找、哈希查找。
二、无序表查找 也就是数据不排序的线性查找，遍历数据元素。
算法分析：最好情况是在第一个位置就找到了，此为O(1)；最坏情况在最后一个位置才找到，此为O(n)；所以平均查找次数为(n&#43;1)/2。最终时间复杂度为O(n)
# 最基础的遍历无序列表的查找算法 # 时间复杂度O(n) def sequential_search(lis, key): length = len(lis) for i in range(length): if lis[i] == key: return i else: return False if __name__ == &#39;__main__&#39;: LIST = [1, 5, 8, 123, 22, 54, 7, 99, 300, 222] result = sequential_search(LIST, 123) print(result) 三、二分查找(Binary Search) 二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。
算法核心：在查找表中不断取中间元素与查找值进行比较，以二分之一的倍率进行表范围的缩小。
1、二分查找的python代码实现
def binary_search(lis, key): low = 0 high = len(lis) - 1 time = 0 while low &lt; high: time &#43;= 1 mid = int((low &#43; high) / 2) if key &lt; lis[mid]: high = mid - 1 elif key &gt; lis[mid]: low = mid &#43; 1 else: # 打印折半的次数 print(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/03d1137566ca08f31482fe27c1dfaf15/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-25T05:11:00+08:00" />
<meta property="article:modified_time" content="2019-06-25T05:11:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python算法与数据结构-常用查找算法一(37)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <h4 id="一基本概念">一、什么是查找</h4> 
 <ul><li>查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</li><li>查找表（Search Table）：由同一类型的数据元素（或记录）构成的集合</li><li>关键字（Key）：数据元素中某个数据项的值，又称为键值。</li><li>主键（Primary Key）：可唯一地标识某个数据元素或记录的关键字。</li></ul> 
 <p>　　搜索是在一个项目集合中找到一个特定项目的算法过程。搜索通常的答案是真的或假的，因为该项目是否存在。 搜索的几种常见方法：顺序查找、二分法查找、二叉树查找、哈希查找。</p> 
 <h4> <span style="font-size:1.17em;">二、无序表查找</span></h4> 
 <p>也就是数据不排序的线性查找，遍历数据元素。<br>算法分析：最好情况是在第一个位置就找到了，此为O(1)；最坏情况在最后一个位置才找到，此为O(n)；所以平均查找次数为(n+1)/2。<strong>最终时间复杂度为O(n)</strong></p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#008000;">#</span><span style="color:#008000;"> 最基础的遍历无序列表的查找算法</span><span style="color:#008000;">
#</span><span style="color:#008000;"> 时间复杂度O(n)</span>

<span style="color:#0000ff;">def</span><span style="color:#000000;"> sequential_search(lis, key):
    length </span>=<span style="color:#000000;"> len(lis)
    </span><span style="color:#0000ff;">for</span> i <span style="color:#0000ff;">in</span><span style="color:#000000;"> range(length):
        </span><span style="color:#0000ff;">if</span> lis[i] ==<span style="color:#000000;"> key:
            </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> i
    </span><span style="color:#0000ff;">else</span><span style="color:#000000;">:
        </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> False


</span><span style="color:#0000ff;">if</span> <span style="color:#800080;">__name__</span> == <span style="color:#800000;">'</span><span style="color:#800000;">__main__</span><span style="color:#800000;">'</span><span style="color:#000000;">:
    LIST </span>= [1, 5, 8, 123, 22, 54, 7, 99, 300, 222<span style="color:#000000;">]
    result </span>= sequential_search(LIST, 123<span style="color:#000000;">)
    </span><span style="color:#0000ff;">print</span>(result)</pre> 
 </div> 
 <h4 id="二分查找binary-search">三、二分查找(Binary Search)</h4> 
 <p>二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p> 
 <p><strong>算法核心：在查找表中不断取中间元素与查找值进行比较，以二分之一的倍率进行表范围的缩小。</strong></p> 
 <p><strong>1、二分查找的python代码实现</strong></p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">def</span><span style="color:#000000;"> binary_search(lis, key):
    low </span>=<span style="color:#000000;"> 0
    high </span>= len(lis) - 1<span style="color:#000000;">
    time </span>=<span style="color:#000000;"> 0
    </span><span style="color:#0000ff;">while</span> low &lt;<span style="color:#000000;"> high:
        time </span>+= 1<span style="color:#000000;">
        mid </span>= int((low + high) / 2<span style="color:#000000;">)
        </span><span style="color:#0000ff;">if</span> key &lt;<span style="color:#000000;"> lis[mid]:
            high </span>= mid - 1
        <span style="color:#0000ff;">elif</span> key &gt;<span style="color:#000000;"> lis[mid]:
            low </span>= mid + 1
        <span style="color:#0000ff;">else</span><span style="color:#000000;">:
            </span><span style="color:#008000;">#</span><span style="color:#008000;"> 打印折半的次数</span>
            <span style="color:#0000ff;">print</span>(<span style="color:#800000;">"</span><span style="color:#800000;">times: %s</span><span style="color:#800000;">"</span> %<span style="color:#000000;"> time)
            </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> mid
    </span><span style="color:#0000ff;">print</span>(<span style="color:#800000;">"</span><span style="color:#800000;">times: %s</span><span style="color:#800000;">"</span> %<span style="color:#000000;"> time)
    </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> False

</span><span style="color:#0000ff;">if</span> <span style="color:#800080;">__name__</span> == <span style="color:#800000;">'</span><span style="color:#800000;">__main__</span><span style="color:#800000;">'</span><span style="color:#000000;">:
    LIST </span>= [1, 5, 7, 8, 22, 54, 99, 123, 200, 222, 444<span style="color:#000000;">]
    result </span>= binary_search(LIST, 1<span style="color:#000000;">)
    </span><span style="color:#0000ff;">print</span>(result)</pre> 
 </div> 
 <p>运行结果为：</p> 
 <div class="cnblogs_code"> 
  <pre>查找次数为: 3<span style="color:#000000;">
下表为：0</span></pre> 
 </div> 
 <p><strong>2、二分查找的C语言代码实现</strong></p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#008000;">//</span><span style="color:#008000;">  main.m
</span><span style="color:#008000;">//</span><span style="color:#008000;">  二分查找
</span><span style="color:#008000;">//</span><span style="color:#008000;">  Created by 侯垒 on 2019/7/1.
</span><span style="color:#008000;">//</span><span style="color:#008000;">  Copyright © 2019 可爱的侯老师. All rights reserved.</span>
<span style="color:#000000;">
# include </span>&lt;stdio.h&gt;
<span style="color:#0000ff;">int</span> binary_search(<span style="color:#0000ff;">int</span> array[],<span style="color:#0000ff;">int</span> key,<span style="color:#0000ff;">int</span><span style="color:#000000;"> len)
{
    </span><span style="color:#0000ff;">int</span> low = <span style="color:#800080;">0</span><span style="color:#000000;">;
    </span><span style="color:#0000ff;">int</span> high = len-<span style="color:#800080;">1</span><span style="color:#000000;">;
    </span><span style="color:#0000ff;">int</span> time = <span style="color:#800080;">0</span><span style="color:#000000;">;
    </span><span style="color:#0000ff;">while</span> (low&lt;<span style="color:#000000;">high)
    {
        time</span>++<span style="color:#000000;">;
        </span><span style="color:#0000ff;">int</span> mid = (<span style="color:#0000ff;">int</span>)(low+high)/<span style="color:#800080;">2</span><span style="color:#000000;">;
        </span><span style="color:#0000ff;">if</span> (key&lt;<span style="color:#000000;">array[mid])
        {
            high </span>= mid-<span style="color:#800080;">1</span><span style="color:#000000;">;
        }
        </span><span style="color:#0000ff;">else</span> <span style="color:#0000ff;">if</span>(key&gt;<span style="color:#000000;">array[mid])
        {
            low </span>= mid+<span style="color:#800080;">1</span><span style="color:#000000;">;
        }
        </span><span style="color:#0000ff;">else</span><span style="color:#000000;">
        {
            </span><span style="color:#008000;">//</span><span style="color:#008000;"> 打印这本的次数</span>
            printf(<span style="color:#800000;">"</span><span style="color:#800000;">查询次数 = %d\n</span><span style="color:#800000;">"</span><span style="color:#000000;">,time);
            </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> mid;
        }
    }
    printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">查询次数 = %d\n</span><span style="color:#800000;">"</span><span style="color:#000000;">,time);
    </span><span style="color:#0000ff;">return</span> -<span style="color:#800080;">1</span><span style="color:#000000;">;
}

</span><span style="color:#0000ff;">int</span> main(<span style="color:#0000ff;">int</span> argc, <span style="color:#0000ff;">const</span> <span style="color:#0000ff;">char</span> *<span style="color:#000000;"> argv[])
{
    </span><span style="color:#0000ff;">int</span> array[<span style="color:#800080;">11</span>] = {<!-- --><span style="color:#800080;">1</span>, <span style="color:#800080;">5</span>, <span style="color:#800080;">7</span>, <span style="color:#800080;">8</span>, <span style="color:#800080;">22</span>, <span style="color:#800080;">54</span>, <span style="color:#800080;">99</span>, <span style="color:#800080;">123</span>, <span style="color:#800080;">200</span>, <span style="color:#800080;">222</span>, <span style="color:#800080;">444</span><span style="color:#000000;">};
    </span><span style="color:#0000ff;">int</span> index = binary_search(array, <span style="color:#800080;">1</span>, <span style="color:#800080;">11</span><span style="color:#000000;">);
    printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">下标是 = %d\n</span><span style="color:#800000;">"</span><span style="color:#000000;">,index);
    </span><span style="color:#0000ff;">return</span> <span style="color:#800080;">0</span><span style="color:#000000;">;
}</span></pre> 
 </div> 
 <p>运行结果为：</p> 
 <div class="cnblogs_code"> 
  <pre>查询次数 = <span style="color:#800080;">3</span><span style="color:#000000;">

下标是 </span>= <span style="color:#800080;">0</span></pre> 
 </div> 
 <h4>四、插值查找</h4> 
 <p>　　在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？</p> 
 <p>　　打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。</p> 
 <p>　　同样的，比如要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找5， 我们自然会考虑从数组下标较小的开始查找。</p> 
 <p>　　经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下：</p> 
 <p>　　mid=(low+high)/2, 即mid=low+1/2*(high-low);</p> 
 <p>　　通过类比，我们可以将查找的点改进为如下：</p> 
 <p>　　<strong>mid=low+(key-list[low])/(list[high]-list[low])*(high-low)，</strong></p> 
 <p>　　也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。</p> 
 <p>　　基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。</p> 
 <p>　　注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</p> 
 <p>　　复杂度分析：查找成功或者失败的时间复杂度均为<strong>O</strong>(<strong>log(</strong><strong>n)</strong>)。</p> 
 <p><strong>1、插值查找的python代码实现</strong></p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">def</span><span style="color:#000000;"> chazhi_search(lis, key):
    low </span>=<span style="color:#000000;"> 0
    high </span>= len(lis) - 1<span style="color:#000000;">
    time </span>=<span style="color:#000000;"> 0
    </span><span style="color:#0000ff;">while</span> low &lt;<span style="color:#000000;"> high:
        time </span>+= 1
        <span style="color:#008000;">#</span><span style="color:#008000;"> 计算mid值是插值算法的核心代码</span>
        mid = low + int((key - lis[low])/(lis[high] - lis[low]) * (high -<span style="color:#000000;"> low))
        </span><span style="color:#0000ff;">print</span>(<span style="color:#800000;">"</span><span style="color:#800000;">mid=%s, low=%s, high=%s</span><span style="color:#800000;">"</span> %<span style="color:#000000;"> (mid, low, high))
        </span><span style="color:#0000ff;">if</span> key &lt;<span style="color:#000000;"> lis[mid]:
            high </span>= mid - 1
        <span style="color:#0000ff;">elif</span> key &gt;<span style="color:#000000;"> lis[mid]:
            low </span>= mid + 1
        <span style="color:#0000ff;">else</span><span style="color:#000000;">:
            </span><span style="color:#008000;">#</span><span style="color:#008000;"> 打印查找的次数</span>
            <span style="color:#0000ff;">print</span>(<span style="color:#800000;">"</span><span style="color:#800000;">查询次数: %s</span><span style="color:#800000;">"</span> %<span style="color:#000000;"> time)
            </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> mid
    </span><span style="color:#0000ff;">print</span>(<span style="color:#800000;">"</span><span style="color:#800000;">times: %s</span><span style="color:#800000;">"</span> %<span style="color:#000000;"> time)
    </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> False

</span><span style="color:#0000ff;">if</span> <span style="color:#800080;">__name__</span> == <span style="color:#800000;">'</span><span style="color:#800000;">__main__</span><span style="color:#800000;">'</span><span style="color:#000000;">:
    LIST </span>= [1, 5, 7, 8, 22, 54, 99, 123, 200, 222, 444<span style="color:#000000;">]
    index </span>= chazhi_search(LIST, 1<span style="color:#000000;">)
    </span><span style="color:#0000ff;">print</span>(<span style="color:#800000;">"</span><span style="color:#800000;">下标为：%s</span><span style="color:#800000;">"</span>%index)</pre> 
 </div> 
 <p>运行结果为：</p> 
 <div class="cnblogs_code"> 
  <pre>mid=<span style="color:#800080;">0</span>, low=<span style="color:#800080;">0</span>, high=<span style="color:#800080;">10</span><span style="color:#000000;">
查询次数: </span><span style="color:#800080;">1</span><span style="color:#000000;">
下标为：</span><span style="color:#800080;">0</span></pre> 
 </div> 
 <p>2、插值查找的C语言代码实现</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#008000;">//</span><span style="color:#008000;">  main.m
</span><span style="color:#008000;">//</span><span style="color:#008000;">  插值查找
</span><span style="color:#008000;">//</span><span style="color:#008000;">  Created by 侯垒 on 2019/7/1.
</span><span style="color:#008000;">//</span><span style="color:#008000;">  Copyright © 2019 可爱的侯老师. All rights reserved.</span>
<span style="color:#000000;">
#include</span>&lt;stdio.h&gt;
<span style="color:#0000ff;">int</span> chazhi_search(<span style="color:#0000ff;">int</span> array[],<span style="color:#0000ff;">int</span> key,<span style="color:#0000ff;">int</span><span style="color:#000000;"> len)
{
    </span><span style="color:#0000ff;">int</span> low = <span style="color:#800080;">0</span><span style="color:#000000;">;
    </span><span style="color:#0000ff;">int</span> high = len-<span style="color:#800080;">1</span><span style="color:#000000;">;
    </span><span style="color:#0000ff;">int</span> time = <span style="color:#800080;">0</span><span style="color:#000000;">;
    
    </span><span style="color:#0000ff;">while</span> (low&lt;<span style="color:#000000;">high)
    {
        time</span>++<span style="color:#000000;">;
        </span><span style="color:#008000;">//</span><span style="color:#008000;"> 计算mid值是插值算法的核心代码</span>
        <span style="color:#0000ff;">int</span> mid = low + (<span style="color:#0000ff;">int</span>)((key - array[low])/(array[high]-array[low])*(high-<span style="color:#000000;">low));
        printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">mid=%d, low=%d, high=%d\n</span><span style="color:#800000;">"</span><span style="color:#000000;">,mid, low, high);
        </span><span style="color:#0000ff;">if</span> (key&lt;<span style="color:#000000;">array[mid])
        {
            high </span>= mid-<span style="color:#800080;">1</span><span style="color:#000000;">;
        }
        </span><span style="color:#0000ff;">else</span> <span style="color:#0000ff;">if</span> (key&gt;<span style="color:#000000;">array[mid])
        {
            low </span>= mid+<span style="color:#800080;">1</span><span style="color:#000000;">;
        }
        </span><span style="color:#0000ff;">else</span><span style="color:#000000;">
        {
            </span><span style="color:#008000;">//</span><span style="color:#008000;"> 打印查找的次数</span>
            printf(<span style="color:#800000;">"</span><span style="color:#800000;">查询次数:%d\n</span><span style="color:#800000;">"</span><span style="color:#000000;">,time);
            </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> mid;
        }
    }
    printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">查询次数:%d\n</span><span style="color:#800000;">"</span><span style="color:#000000;">,time);
    </span><span style="color:#0000ff;">return</span> -<span style="color:#800080;">1</span><span style="color:#000000;">;
}

</span><span style="color:#0000ff;">int</span> main(<span style="color:#0000ff;">int</span> argc, <span style="color:#0000ff;">const</span> <span style="color:#0000ff;">char</span> *<span style="color:#000000;"> argv[]) {
    </span><span style="color:#0000ff;">int</span> arr[] = {<!-- --><span style="color:#800080;">1</span>, <span style="color:#800080;">5</span>, <span style="color:#800080;">7</span>, <span style="color:#800080;">8</span>, <span style="color:#800080;">22</span>, <span style="color:#800080;">54</span>, <span style="color:#800080;">99</span>, <span style="color:#800080;">123</span>, <span style="color:#800080;">200</span>, <span style="color:#800080;">222</span>, <span style="color:#800080;">444</span><span style="color:#000000;">};
    </span><span style="color:#0000ff;">int</span> index = chazhi_search(arr, <span style="color:#800080;">1</span>, <span style="color:#800080;">11</span><span style="color:#000000;">);
    printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">下标为：%d\n</span><span style="color:#800000;">"</span><span style="color:#000000;">,index);
    
    </span><span style="color:#0000ff;">return</span> <span style="color:#800080;">0</span><span style="color:#000000;">;
}</span></pre> 
 </div> 
 <p>运行结果为：</p> 
 <div class="cnblogs_code"> 
  <pre>mid=<span style="color:#800080;">0</span>, low=<span style="color:#800080;">0</span>, high=<span style="color:#800080;">10</span><span style="color:#000000;">
查询次数:</span><span style="color:#800080;">1</span><span style="color:#000000;">
下标为：</span><span style="color:#800080;">0</span></pre> 
 </div> 
 <p> </p> 
</div> 
<p>转载于:https://www.cnblogs.com/Se7eN-HOU/p/11115268.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2b1f601fe81f493beb91e449ca17487d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【面试】Android Retrofit&#43;Rxjava 如何实现同时请求多个接口数据?</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/84e1423bd260a891ef3949196e16e02d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">背景鼠标不动吸附线条</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>