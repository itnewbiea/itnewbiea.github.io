<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>力扣刷题记录（28）LeetCode：797、200、463 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="力扣刷题记录（28）LeetCode：797、200、463" />
<meta property="og:description" content="797. 所有可能的路径 解题思路：回溯算法，当收集到的路径的最后一个值等于n-1时，收集答案。
参数：图、当前结点
class Solution { public: vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; ans; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph,int index) { if(path.back()==graph.size()-1) { ans.push_back(path); return; } for(int i=0;i&lt;graph[index].size();i&#43;&#43;) { path.push_back(graph[index][i]); dfs(graph,graph[index][i]); //回溯 path.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; allPathsSourceTarget(vector&lt;vector&lt;int&gt;&gt;&amp; graph) { //从0开始的，先将0传入路径中 path.push_back(0); dfs(graph,0); return ans; } }; 200. 岛屿数量 解题思路：如果我们遍历到一块陆地，那我们就以这块陆地为中心向它的周围扩散，将所有与之相连的陆地全部都标记。这时我们所标记的所有相连的陆地就形成了一片岛屿，岛屿数量加一。那我们如果对所有陆地都进行这样的操作，就可以得到岛屿的数量。需要注意的是我们需要对已经标记过的陆地进行这样的操作，因为它已经是前面统计过的岛屿的一部分。
class Solution { private: void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid,int x,int y) { //判断是否越界 if(x&gt;=grid[0].size() || y&gt;=grid.size()) return; //判断岛屿是否遍历过 只遍历岛屿 if(grid[y][x]==&#39;2&#39;||grid[y][x]==&#39;0&#39;) return; //将岛屿的状态改为遍历过 grid[y][x]=&#39;2&#39;; dfs(grid,x-1,y); dfs(grid,x&#43;1,y); dfs(grid,x,y-1); dfs(grid,x,y&#43;1); } public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { int ans=0; for(int i=0;i&lt;grid." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e732b8ed80ae3cd421f78e3ceb510fe4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-06T15:29:17+08:00" />
<meta property="article:modified_time" content="2024-01-06T15:29:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">力扣刷题记录（28）LeetCode：797、200、463</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4><a href="https://leetcode.cn/problems/all-paths-from-source-to-target/" rel="nofollow" title="797. 所有可能的路径">797. 所有可能的路径</a></h4> 
<p><img alt="" height="705" src="https://images2.imgbox.com/4a/a1/G1dTVyva_o.png" width="684"></p> 
<p>解题思路：回溯算法，当收集到的路径的最后一个值等于n-1时，收集答案。</p> 
<p>参数：图、当前结点</p> 
<p> </p> 
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; path;
    vector&lt;vector&lt;int&gt;&gt; ans;
    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph,int index)
    {
        if(path.back()==graph.size()-1)
        {
            ans.push_back(path);
            return;
        }
        for(int i=0;i&lt;graph[index].size();i++)
        {
            path.push_back(graph[index][i]);
            dfs(graph,graph[index][i]);
            //回溯
            path.pop_back();
        }
    }
    vector&lt;vector&lt;int&gt;&gt; allPathsSourceTarget(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {
        //从0开始的，先将0传入路径中
        path.push_back(0);
        dfs(graph,0);
        return ans;
    }
};</code></pre> 
<h4><a href="https://leetcode.cn/problems/number-of-islands/" rel="nofollow" title="200. 岛屿数量">200. 岛屿数量</a></h4> 
<p><img alt="" height="522" src="https://images2.imgbox.com/e0/71/8tLFQ4sI_o.png" width="680"></p> 
<p>解题思路：如果我们遍历到一块陆地，那我们就以这块陆地为中心向它的周围扩散，将所有与之相连的陆地全部都标记。这时我们所标记的所有相连的陆地就形成了一片岛屿，岛屿数量加一。那我们如果对所有陆地都进行这样的操作，就可以得到岛屿的数量。需要注意的是我们需要对已经标记过的陆地进行这样的操作，因为它已经是前面统计过的岛屿的一部分。</p> 
<pre><code class="language-cpp">class Solution {
private:
    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid,int x,int y)
    {
        //判断是否越界
        if(x&gt;=grid[0].size() || y&gt;=grid.size()) return;
        //判断岛屿是否遍历过 只遍历岛屿
        if(grid[y][x]=='2'||grid[y][x]=='0')  return;
        //将岛屿的状态改为遍历过
        grid[y][x]='2';
        dfs(grid,x-1,y);
        dfs(grid,x+1,y);
        dfs(grid,x,y-1);
        dfs(grid,x,y+1);

    }
public:
    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
        int ans=0;
        for(int i=0;i&lt;grid.size();i++)
        {
            for(int j=0;j&lt;grid[0].size();j++)
            {
                if(grid[i][j]=='1')
                {
                    //将和该陆地连在一起的陆地的状态都改变为遍历过
                    dfs(grid,j,i);
                    ans++;
                }
            }
        }
        return ans;
    }
};
</code></pre> 
<h4><a href="https://leetcode.cn/problems/island-perimeter/" rel="nofollow" title="463. 岛屿的周长">463. 岛屿的周长</a> </h4> 
<p><img alt="" height="679" src="https://images2.imgbox.com/c6/bc/xBmAzOTa_o.png" width="689"></p> 
<p>解题思路：深度优先遍历，可以向上下左右是个方向进行深度遍历。如果在某一方向上遍历到水或者超出了边界，那么这个方向上的周长就确定是1了。如果遍历到陆地则继续深入下去。需要注意的是对于遍历过的元素一定要做标记，否则将陷入死循环中。</p> 
<pre><code class="language-cpp">class Solution {
public:
    int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid,int i,int j)
    {
        if( (i&gt;=grid.size() || i&lt;0) || (j&gt;=grid[0].size()||j&lt;0) )   return 1;
        if(grid[i][j]==0) return 1;
        //遍历过的将不再遍历 且持有的周长为0
        if(grid[i][j]==2)   return 0;
        //对遍历过的陆地进行标记
        grid[i][j]=2;
        return dfs(grid,i-1,j)+dfs(grid,i+1,j)+dfs(grid,i,j-1)+dfs(grid,i,j+1);
    }
    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        for(int i=0;i&lt;grid.size();i++)
        {
            for(int j=0;j&lt;grid[0].size();j++)
            {
                if(grid[i][j]==1) return dfs(grid,i,j);
            }
        }
        return 0;
    }
};</code></pre> 
<h4> 总结</h4> 
<p>图论题目主要是运用两种方法，深度优先遍历、广度优先遍历，本文章的三道题所用的均是深度优先遍历。</p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b8500ebe9023af34e9719f35cfd7ce54/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python项目分享 基于Django的问答社区管理系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2a8d1b48c71d08bdb58884218224c2c8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python3 注释</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>