<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>canvas绘制“飞机大战”小游戏，真香 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="canvas绘制“飞机大战”小游戏，真香" />
<meta property="og:description" content="原文：canvas绘制“飞机大战”小游戏，真香！，点击链接查看更多技术内容。
canvas是ArkUI开发框架里的画布组件，常用于自定义绘制图形。因为其轻量、灵活、高效等优点，被广泛应用于UI界面开发中。
本期，我们将为大家介绍canvas组件的使用。
目录
一、canvas介绍
二、canvas基础绘制方法
三、飞机大战小游戏绘制实践
一、canvas介绍 1. 什么是canvas？
在Web浏览器中，canvas是一个可自定义width、height的矩形画布，画布左上角为坐标原点，以像素为单位，水平向右为x轴，垂直向下为y轴，画布内所有元素的位置基于原点进行定位。
如图1所示，我们通过&lt;canvas&gt;标签，创建了一个width=1500px，height=900px的空白画布，我们还需要“画笔”才能绘制图形。canvas采用轻量的逐像素渲染机制，以JS为“画笔”直接控制画布像素，从而实现图形绘制。
图1 canvas画布
2. canvas的“画笔”
canvas本身虽不具备绘制能力，但是提供了获取“画笔”的方法。开发者可通过getContext(&#39;2d&#39;)方法获取CanvasRenderingContext2D对象完成2D图像绘制，或通过getContext(&#39;webgl&#39;)方法获取WebGLRenderingContext对象完成3D图像绘制。
目前，ArkUI开发框架中的WebGL1.0及WebGL2.0标准3D图形绘制能力正在完善中，所以本文将着重介绍2D图像的绘制。如图2所示，是CanvasRenderingContext2D对象提供的部分2D图像绘制方法，丰富的绘制方法让开发者能高效的绘制出矩形、文本、图片等。
图2 图像绘制方法
另外，开发者还可以获取OffscreenCanvasRenderingContext2D对象进行离屏绘制，绘制方法同上。
当绘制的图形比较复杂时，频繁的删除与重绘会消耗很多性能。开发者可根据自身的需求灵活选取canvas的渲染方式。这时，开发者可以根据自身的需求灵活选取离屏渲染的方式，通过创建OffscreenCanvas对象作为一个缓冲区，然后将需要绘制的内容先绘制在OffscreenCanvas上，最后再将OffscreenCanvas绘制到主画布上，以提高画布性能，确保绘图的质量。
二、canvas基础绘制方法 通过上节对canvas组件的基本介绍，相信大家对canvas组件已经有了一定的认识，下面我们将为大家实际演示canvas组件在ArkUI开发框架中的使用方法。ArkUI开发框架参考Web浏览器中canvas的设计，并在“类Web开发范式”及“声明式开发范式”两种开发范式中进行提供，接下来我们将分别介绍这两种开发范式中canvas的使用。
1. 类Web开发范式中canvas的绘制方法
类Web开发范式，使用HML标签文件进行布局搭建、CSS文件进行样式描述，并通过JS语言进行逻辑处理。目前，JS语言的canvas绘图功能已经基本上完善，下面我们将通过两个示例，展示基于JS语言的canvas组件基础使用方法。
（1）矩形填充
CanvasRenderingContext2D对象提供了fillRect(x, y, width,height)方法，用于绘制一个填充的矩形。如图3所示，在画布内绘制了一个黑色的填充矩形，x与y指定了在canvas画布上所绘制的矩形的左上角（相对于原点）的坐标，width和height则设置了矩形的尺寸。
图3 填充的矩形
示例代码如下：
//创建一个width=1500px，height=900px的画布 &lt;!-- xxx.hml --&gt; &lt;div&gt; &lt;canvas ref=&#34;canvas&#34; style=&#34;width: 1500px; height: 900px; &#34;&gt;&lt;/canvas&gt; &lt;/div&gt; //xxx.js export default { onShow() { const el =this.$refs.canvas; //获取2D绘制对象 const ctx = el.getContext(&#39;2d&#39;); //设置填充为黑色 ctx.fillStyle = &#39;#000000&#39;; //设置填充矩形的坐标及尺寸 ctx.fillRect(200, 200, 300, 300); } } （2）缩放与阴影" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/72f0ecfe98d7343486854925f803798e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-09T15:10:36+08:00" />
<meta property="article:modified_time" content="2023-05-09T15:10:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">canvas绘制“飞机大战”小游戏，真香</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>原文：<a href="https://mp.weixin.qq.com/s/B5dPvSA-JhjcdhUFVkAh-Q" rel="nofollow" title="canvas绘制“飞机大战”小游戏，真香！">canvas绘制“飞机大战”小游戏，真香！</a>，点击链接查看更多技术内容。</p> 
<p></p> 
<p>canvas是ArkUI开发框架里的画布组件，常用于自定义绘制图形。因为其轻量、灵活、高效等优点，被广泛应用于UI界面开发中。</p> 
<p></p> 
<p>本期，我们将为大家介绍canvas组件的使用。</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81canvas%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81canvas%E4%BB%8B%E7%BB%8D" rel="nofollow">一、canvas介绍</a></p> 
<p id="%E4%BA%8C%E3%80%81canvas%E5%9F%BA%E7%A1%80%E7%BB%98%E5%88%B6%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81canvas%E5%9F%BA%E7%A1%80%E7%BB%98%E5%88%B6%E6%96%B9%E6%B3%95" rel="nofollow">二、canvas基础绘制方法</a></p> 
<p id="%E4%B8%89%E3%80%81%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%BB%98%E5%88%B6%E5%AE%9E%E8%B7%B5-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%BB%98%E5%88%B6%E5%AE%9E%E8%B7%B5" rel="nofollow">三、飞机大战小游戏绘制实践</a></p> 
<hr id="hr-toc"> 
<h3 id="%E4%B8%80%E3%80%81canvas%E4%BB%8B%E7%BB%8D"><strong>一、canvas介绍</strong></h3> 
<p><br><span style="color:#4da8ee;"><strong>1.  什么是canvas？</strong></span></p> 
<p><br> 在Web浏览器中，canvas是一个可自定义width、height的矩形画布，画布左上角为坐标原点，以像素为单位，水平向右为x轴，垂直向下为y轴，画布内所有元素的位置基于原点进行定位。</p> 
<p></p> 
<p>如图1所示，我们通过&lt;canvas&gt;标签，创建了一个width=1500px，height=900px的空白画布，我们还需要“画笔”才能绘制图形。canvas采用轻量的逐像素渲染机制，以JS为“画笔”直接控制画布像素，从而实现图形绘制。</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9a/11/JnrgsSJl_o.png"></p> 
<p style="text-align:center;">图1 canvas画布</p> 
<p></p> 
<p><span style="color:#4da8ee;"><strong>2.  canvas的“画笔”</strong></span></p> 
<p><br> canvas本身虽不具备绘制能力，但是提供了获取“画笔”的方法。开发者可通过getContext('2d')方法获取CanvasRenderingContext2D对象完成2D图像绘制，或通过getContext('webgl')方法获取WebGLRenderingContext对象完成3D图像绘制。</p> 
<p></p> 
<p>目前，ArkUI开发框架中的WebGL1.0及WebGL2.0标准3D图形绘制能力正在完善中，所以本文将着重介绍2D图像的绘制。如图2所示，是CanvasRenderingContext2D对象提供的部分2D图像绘制方法，丰富的绘制方法让开发者能高效的绘制出矩形、文本、图片等。</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/52/36/hWvL2fqc_o.png"></p> 
<p style="text-align:center;">图2 图像绘制方法</p> 
<p></p> 
<p>另外，开发者还可以获取OffscreenCanvasRenderingContext2D对象进行离屏绘制，绘制方法同上。</p> 
<p></p> 
<p>当绘制的图形比较复杂时，频繁的删除与重绘会消耗很多性能。开发者可根据自身的需求灵活选取canvas的渲染方式。这时，开发者可以根据自身的需求灵活选取离屏渲染的方式，通过创建OffscreenCanvas对象作为一个缓冲区，然后将需要绘制的内容先绘制在OffscreenCanvas上，最后再将OffscreenCanvas绘制到主画布上，以提高画布性能，确保绘图的质量。</p> 
<p></p> 
<h3 id="%E4%BA%8C%E3%80%81canvas%E5%9F%BA%E7%A1%80%E7%BB%98%E5%88%B6%E6%96%B9%E6%B3%95"><strong>二、canvas基础绘制方法</strong></h3> 
<p><br> 通过上节对canvas组件的基本介绍，相信大家对canvas组件已经有了一定的认识，下面我们将为大家实际演示canvas组件在ArkUI开发框架中的使用方法。ArkUI开发框架参考Web浏览器中canvas的设计，并在“类Web开发范式”及“声明式开发范式”两种开发范式中进行提供，接下来我们将分别介绍这两种开发范式中canvas的使用。</p> 
<p></p> 
<p><span style="color:#4da8ee;"><strong>1.  类Web开发范式中canvas的绘制方法</strong></span></p> 
<p><br> 类Web开发范式，使用HML标签文件进行布局搭建、CSS文件进行样式描述，并通过JS语言进行逻辑处理。目前，JS语言的canvas绘图功能已经基本上完善，下面我们将通过两个示例，展示基于JS语言的canvas组件基础使用方法。</p> 
<p></p> 
<p><strong>（1）矩形填充</strong></p> 
<p></p> 
<p>CanvasRenderingContext2D对象提供了fillRect(x, y, width,height)方法，用于绘制一个填充的矩形。如图3所示，在画布内绘制了一个黑色的填充矩形，x与y指定了在canvas画布上所绘制的矩形的左上角（相对于原点）的坐标，width和height则设置了矩形的尺寸。</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a9/5e/ffplQSHK_o.png"></p> 
<p style="text-align:center;">图3 填充的矩形</p> 
<p></p> 
<p>示例代码如下：</p> 
<p></p> 
<pre><code>//创建一个width=1500px，height=900px的画布
&lt;!-- xxx.hml --&gt;
&lt;div&gt;
  &lt;canvas ref="canvas" style="width: 1500px; height: 900px; "&gt;&lt;/canvas&gt;
&lt;/div&gt;</code></pre> 
<p></p> 
<pre><code>//xxx.js
export default {
  onShow() {
    const el =this.$refs.canvas;
    //获取2D绘制对象
    const ctx = el.getContext('2d');
    //设置填充为黑色
    ctx.fillStyle = '#000000';
    //设置填充矩形的坐标及尺寸
    ctx.fillRect(200, 200, 300, 300);
   }
}</code></pre> 
<p><br><strong>（2）缩放与阴影</strong></p> 
<p></p> 
<p>CanvasRenderingContext2D对象提供了scale(x,y)方法，参数x表示横轴方向上缩放倍数，y表示纵轴方向上缩放的倍数，值得注意的是缩放过程中定位也会被缩放。如图4所示，是将上个示例中的填充矩形通过 scale(2,1.5)进行缩放，并通过shadowBlur方法加上阴影后的效果。</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6d/03/HgpKDGuQ_o.png"></p> 
<p style="text-align:center;">图4 缩放与添加阴影后的效果</p> 
<p></p> 
<p>示例代码如下：</p> 
<p></p> 
<pre><code>//xxx.js
export default {
  onShow() {
    const el =this.$refs.canvas;
    const ctx = el.getContext('2d');
   //设置绘制阴影的模糊级别
    ctx.shadowBlur = 80;
    ctx.shadowColor = 'rgb(0,0,0)';
    ctx.fillStyle = 'rgb(0,0,0)';
    // x Scale to 200%,y Scale to 150%
    ctx.scale(2, 1.5);
    ctx.fillRect(200, 200, 300, 300);
   }
}</code></pre> 
<p><br><span style="color:#4da8ee;"><strong>2.  声明式开发范式中canvas的绘制方法</strong></span></p> 
<p><br> 声明式开发范式，采用TS语言并进行声明式UI语法扩展，从组件、动效和状态管理三个维度提供了UI绘制能力。目前，eTS语言已经提供了canvas组件绘制能力，但功能仍在完善中。下面我们将通过两个示例，展示声明式开发范式中canvas组件的基础使用方法。</p> 
<p></p> 
<p><strong>（1）图片叠加</strong></p> 
<p></p> 
<p>如图5所示，是三张图片叠加的效果，顶层的图片覆盖了底层的图片。通过依次使用drawImage(x,y, width, height)方法设置图片坐标及尺寸，后面绘制的图片自动覆盖原来的图像，从而达到预期效果。</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/90/fb/blBKXIU0_o.png"></p> 
<p style="text-align:center;">图5 图片叠加</p> 
<p></p> 
<p>扩展的TS语言采用更接近自然语义的编程方式，让开发者可以直观地描述UI界面，示例代码如下：</p> 
<p></p> 
<pre><code>@Entry
@Component
struct IndexCanvas1 {
  private settings:RenderingContextSettings = new RenderingContextSettings(true);
//获取绘图对象
  private ctx: RenderingContext = new RenderingContext(this.settings);
//列出所要用到的图片
  private img:ImageBitmap = new ImageBitmap("common/bg.jpg");
  build() {
    Column() {
      //创建canvas
      Canvas(this.ctx)
        .width(1500)
        .height(900)
        .border({color:"blue",width:1,})
        .backgroundColor('#ffff00')
         //开始绘制
        .onReady(() =&gt; {
          this.ctx.drawImage( this.img,400,200,540,300);
          this.ctx.drawImage( this.img,500,300,540,300);
          this.ctx.drawImage( this.img,600,400,540,300);
        })
    }
    .width('100%')
    .height('100%')
  }
}</code></pre> 
<p><br><strong>（2）点击创建线性渐变</strong></p> 
<p></p> 
<p>如图6所示，在画布中是一个线性渐变效果。本示例基于canvas扩展了一个Button组件，通过点击“Click”按钮，触发onClick()方法，并通过调用createLinearGradient()方法，绘制出了一个线性渐变色。</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d2/c9/7D40u03V_o.png"></p> 
<p style="text-align:center;">图6 图片上添加文字</p> 
<p></p> 
<p>示例代码如下：</p> 
<p></p> 
<pre><code>@Entry
@Component
struct GradientExample {
  private settings: RenderingContextSettings = new RenderingContextSettings(true);
  private context: RenderingContext = new RenderingContext(this.settings);
  private gra: CanvasGradient = new CanvasGradient();
  build() {
    Column({ space: 5 })  {
//创建一个画布
      Canvas(this.context)
        .width(1500)
        .height(900)
        .backgroundColor('#ffff00 ')
      Column() {
//设置按钮的样式
        Button('Click').width(250).height(100).backgroundColor('#000000')
          .onClick(() =&gt; {
//创建一个线性渐变色
            var grad = this.context.createLinearGradient(600, 200, 400, 750)
            grad.addColorStop(0.0, 'red');
            grad.addColorStop(0.5, 'white');
            grad.addColorStop(1.0, 'green');
            this.context.fillStyle = grad;
            this.context.fillRect(400, 200, 550, 550);
          })
       }.alignItems(HorizontalAlign.center)
     }
   }
 }</code></pre> 
<h3 id="%E4%B8%89%E3%80%81%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%BB%98%E5%88%B6%E5%AE%9E%E8%B7%B5"><br><strong>三、飞机大战小游戏绘制实践</strong></h3> 
<p><br> 如图7所示，是一款“飞机大战”小游戏，通过控制战机的移动摧毁敌机。如何使用ArkUI开发框架提供的canvas组件轻松实现这个经典怀旧的小游戏？实现思路及关键代码如下：</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e5/de/D0EnCD4H_o.gif"></p> 
<p style="text-align:center;">图7 飞机大战小游戏</p> 
<p></p> 
<p><strong>1. 首先列出游戏所用到的图片。</strong></p> 
<p></p> 
<pre><code>private imgList:Array&lt;string&gt; = ["xx.png","xx.png"…];</code></pre> 
<p><br><strong>2. 将图片渲染到canvas画布上。</strong></p> 
<p></p> 
<pre><code>let img:ImageBitmap = new ImageBitmap("图片路径（如common/images）/"+this.imgList[数组下标]);
this.ctx.drawImage( img,150/* x坐标*/,  150/* y坐标*/, 600/*宽*/, 600/*高*/)</code></pre> 
<p><br><strong>3. 绘制背景图片和战机向下移动的效果。</strong></p> 
<p></p> 
<pre><code>this.ctx.drawImage(this.bg, 0, this.bgY);
this.ctx.drawImage(this.bg, 0, this.bgY - 480);
this.bgY++ == 480 &amp;&amp; (this.bgY = 0);</code></pre> 
<p><br><strong>4. 使用Math.round函数随机获取敌机图片并渲染到画布上。并且改变敌机y轴坐标，使它向下运动。</strong></p> 
<p></p> 
<pre><code>Efight = Math.round(Math.random()*7);
//前七张为敌机图片。
let img:ImageBitmap = new ImageBitmap("common/img"+this.imgList[Efight]);
this.ctx.drawImage(img, 0, this.Eheight + 50);//渲染敌机</code></pre> 
<p><br><strong>5. 在页面每隔120s出现一排子弹，之后减小或增大（x,y）轴的坐标达到子弹射出效果。</strong></p> 
<p></p> 
<pre><code>let i= 0;
setInterval(()=&gt;{
  this.ctx.drawImage(this.bulImg1,image.x – 10 – (i *10) , image.x + (i *10))
  this.ctx.drawImage(this.bulimg2, this. bulImg1,image.x – (i *10) , i image.x + (i *10))
  this.ctx.drawImage(this.bulimg3, image.x + 10 + (i *10), image.x + (i *10))
i ++;
},120)</code></pre> 
<p><br><strong>6.使用onTouch方法获取战机移动位置，获取拖动的坐标后重新设置战机的图片坐标，使战机实现拖动效果。</strong></p> 
<p></p> 
<pre><code>.onTouch((event)=&gt;{
  var offsetX = event.localX ||event.touches[0].localX;
  var offsetY = event.localY ||event.touches[0].localY;
  var w = this.heroImg[0].width,
      h = this.heroImg[0].height;
  var nx = offsetX - w / 2,
      ny = offsetY - h / 2;
      nx &lt; 20 - w / 2 ? nx = 20 - w / 2 : nx &gt; (this.windowWidth - w / 2 - 20) ? nx =
  (this.windowWidth - w / 2 - 20) : 0;
  ny &lt; 0 ? ny = 0 : ny &gt; (this.windowHeight - h / 2) ? ny = (this.windowHeight –
  h/2) : 0;
     this.hero.x = nx;
     this.hero.y = ny;
     this.hero.count = 2;</code></pre> 
<p><br> 注：本示例引用了部分开源资源：<a href="https://github.com/xs528/game" title="GitHub - xs528/game: canvas实现的飞机大战">GitHub - xs528/game: canvas实现的飞机大战</a>，感兴趣的开发者可参考此开源资源，结合文中的实现思路补全代码。</p> 
<p></p> 
<p>以上就是本期全部内容，期待广大开发者能通过canvas组件绘制出精美的图形。更多canvas组件的详细使用方法，可跳转到官网文档（<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-canvas-canvas-0000000000621808" rel="nofollow" title="文档中心">文档中心</a>）进行学习。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/080e2c91f2410442f9acd2a62cb8ab73/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LINUX系统下的modbus库安装</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4fcc27674759066cbf71a35770f4ec2e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python代码大全</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>