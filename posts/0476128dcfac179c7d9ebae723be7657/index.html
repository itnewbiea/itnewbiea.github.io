<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;：函数指针进阶(二)：指向对象成员函数的指针 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;：函数指针进阶(二)：指向对象成员函数的指针" />
<meta property="og:description" content="1：普通函数函数指针定义 我们知道 指向普通函数的指针，一般这么定义 ：
数据类型名 (* 指针变量名)（参数列表）
void (*func)(int)
或者前面加一个 typedef typedef 数据类型名（*指针变量名）（参数列表）
typedef void (*funv) (int)
这两种方式都可以，但是建议使用第二种方式：因为第二种方式相当于给 函数指针定义了一个别名，能隐藏笨拙的语法构造以及平台一些相关的数据类型，可以使得代码更美观，可维护性、可移植性、可读性更强。
实例：
如果不带 typedef 关键字
//定义一个函数 void tech(void) { printf(&#34;tech dreamer&#34;); } void main() { //定义一个指针，指针的名字叫func，它可以指向一个函数，并通过函数指针调用该函数 void (*func)(); func = &amp;tech; // 将func()函数的入口地址赋给指针变量pf，所以，pf就指向func()函数 func(); //第一种调用方式，带参数也可以 (*func)(); //第二种调用方式，带参数也可以 } 增加 typedef 关键字 void tech(void) { printf(&#34;tech dreamer&#34;); } //命名一个类型，那么这个时候func不可以直接调用，而是一个类型了 typedef void (*func)(); void main() { //定义一个可调用的指针变量（函数）：myfunc （这个是主要区别） func myfunc; myfunc = &amp;tech; //将func()函数的入口地址赋给指针变量pf，所以，pf就指向func()函数 myfunc(); //第一种调用方式，带参数也可以 (*myfunc)(); //第二种调用方式，带参数也可以 } 2：对象成员函数函数指针定义 标题1介绍了，普通函数函数指针的定义，对象成员函数指针定义情况相比要复杂一些。 那么复杂在哪里了？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0476128dcfac179c7d9ebae723be7657/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-04T21:45:07+08:00" />
<meta property="article:modified_time" content="2022-12-04T21:45:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;：函数指针进阶(二)：指向对象成员函数的指针</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1：普通函数函数指针定义</h2> 
<p>我们知道 指向普通函数的指针，一般这么定义 ：</p> 
<blockquote> 
 <p><strong>数据类型名</strong><strong> (* </strong><strong>指针变量名</strong><strong>)</strong><strong>（参数列表）</strong></p> 
 <p>void (*func)(int)</p> 
 <p></p> 
 <p><strong>或者前面加一个  typedef </strong></p> 
 <p>typedef 数据类型名（*指针变量名）（参数列表）</p> 
 <p>typedef void (*funv) (int)</p> 
 <p>这两种方式都可以，但是建议使用第二种方式：因为第二种方式相当于给 函数指针定义了一个别名，能隐藏笨拙的语法构造以及平台一些相关的数据类型，可以使得代码更美观，可维护性、可移植性、可读性更强。</p> 
</blockquote> 
<p>实例：</p> 
<blockquote> 
 <p><strong>如果不带 typedef 关键字</strong></p> 
 <pre><code class="language-cpp">//定义一个函数
void tech(void) { printf("tech dreamer"); }
void main()
{
    //定义一个指针，指针的名字叫func，它可以指向一个函数，并通过函数指针调用该函数
    void (*func)();
    func = &amp;tech; // 将func()函数的入口地址赋给指针变量pf，所以，pf就指向func()函数
    func();        //第一种调用方式，带参数也可以
    (*func)();     //第二种调用方式，带参数也可以
}</code></pre> 
</blockquote> 
<blockquote> 
 <p><strong>增加 typedef 关键字</strong> </p> 
 <pre><code class="language-cpp">void tech(void) { printf("tech dreamer"); }
//命名一个类型，那么这个时候func不可以直接调用，而是一个类型了
typedef void (*func)();
void main()
{
    //定义一个可调用的指针变量（函数）：myfunc （这个是主要区别）
    func myfunc;
    myfunc = &amp;tech; //将func()函数的入口地址赋给指针变量pf，所以，pf就指向func()函数
    myfunc();         //第一种调用方式，带参数也可以
    (*myfunc)();      //第二种调用方式，带参数也可以
}</code></pre> 
</blockquote> 
<h2>2：对象成员函数函数指针定义</h2> 
<p>标题1介绍了，普通函数函数指针的定义，对象成员函数指针定义情况相比要复杂一些。 那么复杂在哪里了？</p> 
<p>首先成员函数和普通函数的根本区别是：成员函数是类中的一个成员，编译系统要求在指针赋值语句中，指针变量的类型必须与赋值右侧函数的类型相匹配，具体以下三个方面需匹配。</p> 
<ol><li>函数参数的类型和参数的个数要匹配</li><li>函数返回值要匹配</li><li>函数所属的类要匹配</li></ol> 
<p>所以定义指向公用的 成员函数的指针变量操作步骤为：</p> 
<blockquote> 
 <p><strong>1：定义形式：数据类型名 （类名::   *指针变量名）（参数列表）</strong></p> 
 <p><strong>2： 函数指针赋值： 指针变量名 = &amp;类名::成员函数名</strong></p> 
 <p><strong>可以让它指向一个公用成员函数，只需要把公用成员函数的入口地址赋值给一个指向公用成员函数的指针变量即可。</strong></p> 
 <p><strong>3：函数调用：(对象名.*函数指针变量名)()</strong></p> 
</blockquote> 
<p>思考：这样定义的函数指针变量，指向了一个类中的一个函数。但是，当一个类实例化为多个对象的时候，到底要怎样使用该函数指针？函数指针指向哪一个对象函数，所以，我们在调用函数指针的时候，就必须指定哪一个对象。看下面这个例子：</p> 
<pre><code class="language-cpp">// main.cpp


#include&lt;iostream&gt;
#include&lt;string&gt;
class  Student
{
public:
	// 定义成员变量
	char name[32];
	char addr[32];
	long number;

	Student(char* pn, char* pa, long n) {
		strcpy_s(name, pn);
		strcpy_s(addr, pa);
		number = n;
	}

	void print() {
		std::cout &lt;&lt; "name = " &lt;&lt; name &lt;&lt; std::endl;
		std::cout &lt;&lt; "addr = " &lt;&lt; addr &lt;&lt; std::endl;
		std::cout &lt;&lt; "number = " &lt;&lt; number &lt;&lt; std::endl;
	}

private:

};
// 定义Student类中的一个函数指针
void(Student::* pFunc)();

int main(void) {
	std::string name = "xiaoming";
	std::string addr = "wuhan";
	Student stu((char*)name.c_str(),(char*)addr.c_str(), 123456789);

	// 给函数指针赋值
	pFunc = &amp;Student::print;
	// 通过函数指针调用成员函数(且必须指定具体类对象)
	(stu.*pFunc)();
	return 0;
}


// 打印结果
name = xiaoming
addr = wuhan
number = 123456789
</code></pre> 
<p>这里有个知识点：大家可以好好体会。</p> 
<blockquote> 
 <p>对象的成员函数不是存放在对象的空间中的，而是存放在对象外的空间中。如果有多个同类的对象，他们公用同一个函数代码段（类的成员函数），那么他们不是属于某一个对象，而是属于该类，由所有的类对象共享。因此，Student类中的 print()成员函数，不是属于stu对象的，而是属于 Student类。所以，给指针变量 pFunc赋值的地址，应该是Student类公用的函数代码段的入口地址。</p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eb6a5bf374c46506b05f46ba0a34135c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue3element如何通过表格外的按钮来控制表格内部的所有状态全选全不选</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/216358ca4bf43c5c8fc675dd6414fc63/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ES6-基础语法三</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>