<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Leectcode417太平洋大西洋水流问题_med_C&#43;&#43; - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Leectcode417太平洋大西洋水流问题_med_C&#43;&#43;" />
<meta property="og:description" content="给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。
规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。
请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。
提示：
输出坐标的顺序不重要
m 和 n 都小于150
示例：
给定下面的 5x5 矩阵:
太平洋 ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) *
~ 3 2 3 (4) (4) *
~ 2 4 (5) 3 1 *
~ (6) (7) 1 4 5 *
~ (5) 1 1 2 4 *
* * * * * 大西洋
返回:
[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5665c09e7fed8b4c5462c0ce41e8e405/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-14T18:03:25+08:00" />
<meta property="article:modified_time" content="2020-03-14T18:03:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Leectcode417太平洋大西洋水流问题_med_C&#43;&#43;</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。</p> 
<p>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。</p> 
<p>请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。</p> 
<p> </p> 
<p>提示：</p> 
<p>输出坐标的顺序不重要<br> m 和 n 都小于150<br>  </p> 
<p>示例：</p> 
<p> </p> 
<p>给定下面的 5x5 矩阵:</p> 
<p>  太平洋 ~   ~   ~   ~   ~ <br>        ~  1   2   2   3  (5) *<br>        ~  3   2   3  (4) (4) *<br>        ~  2   4  (5)  3   1  *<br>        ~ (6) (7)  1   4   5  *<br>        ~ (5)  1   1   2   4  *<br>           *   *   *   *   * 大西洋</p> 
<p>返回:</p> 
<p>[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).</p> 
<p>思路：按照DFS的想法，从可以达到的边上的点主词进行深度优先搜索。取交集。</p> 
<p>第一版按照之前的DFS的想法写出的思路如下，发现堆栈会溢出。通过cout打印可以看出，出现了在两个点循环调准的情况。如下图所示</p> 
<pre><code class="language-cpp">class Solution {
    int d[4][2] = {<!-- -->{0,1},{0,-1},{-1,0},{1,0}};

    bool IfValid(const vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int x, int y)
    {
        if( x&lt;0 || x&gt;=matrix.size() || y&lt;0 || y&gt;=matrix[0].size())
        {
            return false;
        }
        return true;

    }
    void DFS(const vector&lt;vector&lt;int&gt;&gt;&amp; matrix,const int x,const int y,vector&lt;vector&lt;bool&gt;&gt;&amp; res)
    {
        res[x][y] = true;
        
        for(int i=0;i&lt;4;i++)
        {
            int newx = x+d[i][0];
            int newy = y+ d[i][1];

            if(IfValid(matrix,newx,newy) &amp;&amp; matrix[newx][newy] &gt;= matrix[x][y])
            {
                cout&lt;&lt;"newx="&lt;&lt;newx&lt;&lt;"newy="&lt;&lt;newy&lt;&lt;endl;
                DFS(matrix,newx,newy,res);
            }
        }
        return;
    }
public:
    vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        vector&lt;vector&lt;int&gt;&gt; positionResult;
        int height = matrix.size();
        if(height == 0) return positionResult;
        int length = matrix[0].size();
        vector&lt;vector&lt;bool&gt;&gt; toTai(height,vector&lt;bool&gt;(length,false));
        vector&lt;vector&lt;bool&gt;&gt; toDa(height,vector&lt;bool&gt;(length,false));

        //利用DFS的方式从边上开始遍历完成
        for( int i=0;i&lt;height;i++)
        {
            DFS(matrix,i,0, toTai);
            DFS(matrix,i,length-1,toDa);
        }
        for(int i=0; i&lt;length;i++)
        {
            DFS(matrix,0,i,toTai);
            DFS(matrix,height-1,i,toDa);
        }

        //去交集
        for(int i=0; i&lt;height; i++)
        {
            for(int j=0; j&lt;length; j++)
            {
                if(toDa[i][j] &amp;&amp; toTai[i][j])
                {
                    vector&lt;int&gt; one;
                    one.push_back(i);
                    one.push_back(j);
                    positionResult.push_back(one);
                }
            }
        }

        return positionResult;
    }
};</code></pre> 
<p><img alt="" height="293" src="https://images2.imgbox.com/26/a7/xPaHd9hi_o.png" width="532"></p> 
<p> </p> 
<p>这里仔细看是出现了无限递归，原因是res的结果只做了复制而没做使用。因此需要在递归前的判断加一个对res是否为true的判断，如果是true的话就代表搜索检查过了，则不再检查。</p> 
<pre><code class="language-cpp">class Solution {
    int d[4][2] = {<!-- -->{0,1},{0,-1},{-1,0},{1,0}};

    bool IfValid(const vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int x, int y)
    {
        if( x&lt;0 || x&gt;=matrix.size() || y&lt;0 || y&gt;=matrix[0].size())
        {
            return false;
        }
        return true;

    }
    void DFS(const vector&lt;vector&lt;int&gt;&gt;&amp; matrix,const int x,const int y,vector&lt;vector&lt;bool&gt;&gt;&amp; res)
    {
        res[x][y] = true;
        
        for(int i=0;i&lt;4;i++)
        {
            int newx = x+d[i][0];
            int newy = y+ d[i][1];

            if(IfValid(matrix,newx,newy) &amp;&amp; matrix[newx][newy] &gt;= matrix[x][y] &amp;&amp; !res[newx][newy])
            {
                cout&lt;&lt;"newx="&lt;&lt;newx&lt;&lt;"newy="&lt;&lt;newy&lt;&lt;endl;
                DFS(matrix,newx,newy,res);
            }
        }
        return;
    }
public:
    vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        vector&lt;vector&lt;int&gt;&gt; positionResult;
        int height = matrix.size();
        if(height == 0) return positionResult;
        int length = matrix[0].size();
        vector&lt;vector&lt;bool&gt;&gt; toTai(height,vector&lt;bool&gt;(length,false));
        vector&lt;vector&lt;bool&gt;&gt; toDa(height,vector&lt;bool&gt;(length,false));

        //利用DFS的方式从边上开始遍历完成
        for( int i=0;i&lt;height;i++)
        {
            DFS(matrix,i,0, toTai);
            DFS(matrix,i,length-1,toDa);
        }
        for(int i=0; i&lt;length;i++)
        {
            DFS(matrix,0,i,toTai);
            DFS(matrix,height-1,i,toDa);
        }

        //去交集
        for(int i=0; i&lt;height; i++)
        {
            for(int j=0; j&lt;length; j++)
            {
                if(toDa[i][j] &amp;&amp; toTai[i][j])
                {
                    vector&lt;int&gt; one;
                    one.push_back(i);
                    one.push_back(j);
                    positionResult.push_back(one);
                }
            }
        }

        return positionResult;
    }
};</code></pre> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/866cff7a89bc7789941a654f5c55b6e7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python 写入csv的两种方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/27834dfe6b5fa34936f2ebfdd9f32736/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">反汇编基础、OllyDbg简介和界面、基本操作、初级TraceMe练习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>