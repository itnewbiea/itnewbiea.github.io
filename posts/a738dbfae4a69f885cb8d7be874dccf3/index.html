<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【MQTT学习】lesson6.详解 QoS0 和 QoS1 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【MQTT学习】lesson6.详解 QoS0 和 QoS1" />
<meta property="og:description" content="在前面的课程中我们多次提到了 QoS（Quality of Service）的概念，CONNECT、PUBLISH、SUBSCRIBE 中都有 QoS 的标识，那么 MQTT 提供的 QoS 是什么呢？本节课核心内容：
MQTT 中的 QoS 等级QoS0QoS1代码实践 6.1 MQTT 中的 QoS 等级
作为最初用来在网络带宽窄、信号不稳定的环境下传输数据的协议，MQTT 设计了一套保证消息稳定传输的机制，包括消息应答、存储和重传。在这套机制下，提供了三种不同层次 QoS：
QoS0，At most once，至多一次；QoS1，At least once，至少一次；QoS2，Exactly once，确保只有一次。 什么意思呢，QoS 是消息的发送方（Sender）和接受方（Receiver）之间达成的一个协议：
QoS0 代表，Sender 发送的一条消息，Receiver 最多能收到一次，也就是说 Sender 尽力向 Receiver 发送消息，如果发送失败，也就算了；QoS1 代表，Sender 发送的一条消息，Receiver 至少能收到一次，也就是说 Sender 向 Receiver 发送消息，如果发送失败，会继续重试，直到 Receiver 收到消息为止，但是因为重传的原因，Receiver 有可能会收到重复的消息；QoS2 代表，Sender 发送的一条消息，Receiver 确保能收到而且只收到一次，也就是说 Sender 尽力向 Receiver 发送消息，如果发送失败，会继续重试，直到 Receiver 收到消息为止，同时保证 Receiver 不会因为消息重传而收到重复的消息。 要注意的是，QoS 是 Sender 和 Receiver 之间达成的协议，不是 Publisher 和 Subscriber 之间达成的协议。也就是说 Publisher 发布一条 QoS1 的消息，只能保证 Broker 能至少收到一次这个消息；至于对应的 Subscriber 能否至少收到一次这个消息，还要取决于 Subscriber 在 Subscribe 的时候和 Broker 协商的 QoS 等级。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a738dbfae4a69f885cb8d7be874dccf3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-05-26T12:04:08+08:00" />
<meta property="article:modified_time" content="2019-05-26T12:04:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【MQTT学习】lesson6.详解 QoS0 和 QoS1</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0cm;"><span style="color:#3f3f3f;">在前面的课程中我们多次提到了 QoS（Quality of Service）的概念，CONNECT、PUBLISH、SUBSCRIBE 中都有 QoS 的标识，那么 MQTT 提供的 QoS 是什么呢？本节课核心内容：</span></p> 
<ul><li><span style="color:#3f3f3f;">MQTT </span><span style="color:#3f3f3f;">中的 QoS 等级</span></li><li><span style="color:#3f3f3f;">QoS0</span></li><li><span style="color:#3f3f3f;">QoS1</span></li><li><span style="color:#3f3f3f;">代码实践</span></li></ul> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">6.1 MQTT </span><span style="color:#3f3f3f;">中的</span><span style="color:#3f3f3f;"> QoS </span><span style="color:#3f3f3f;">等级</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">作为最初用来在网络带宽窄、信号不稳定的环境下传输数据的协议，MQTT 设计了一套保证消息稳定传输的机制，包括消息应答、存储和重传。在这套机制下，提供了三种不同层次 QoS：</span></p> 
<ul><li><span style="color:#3f3f3f;">QoS0</span><span style="color:#3f3f3f;">，At most once，至多一次；</span></li><li><span style="color:#3f3f3f;">QoS1</span><span style="color:#3f3f3f;">，At least once，至少一次；</span></li><li><span style="color:#3f3f3f;">QoS2</span><span style="color:#3f3f3f;">，Exactly once，确保只有一次。</span></li></ul> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">什么意思呢，QoS 是消息的发送方（Sender）和接受方（Receiver）之间达成的一个协议：</span></p> 
<ul><li><span style="color:#3f3f3f;">QoS0 </span><span style="color:#3f3f3f;">代表，Sender 发送的一条消息，Receiver 最多能收到一次，也就是说 Sender 尽力向 Receiver 发送消息，如果发送失败，也就算了；</span></li><li><span style="color:#3f3f3f;">QoS1 </span><span style="color:#3f3f3f;">代表，Sender 发送的一条消息，Receiver 至少能收到一次，也就是说 Sender 向 Receiver 发送消息，如果发送失败，会继续重试，直到 Receiver 收到消息为止，但是因为重传的原因，Receiver 有可能会收到重复的消息；</span></li><li><span style="color:#3f3f3f;">QoS2 </span><span style="color:#3f3f3f;">代表，Sender 发送的一条消息，Receiver 确保能收到而且只收到一次，也就是说 Sender 尽力向 Receiver 发送消息，如果发送失败，会继续重试，直到 Receiver 收到消息为止，同时保证 Receiver 不会因为消息重传而收到重复的消息。</span></li></ul> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">要注意的是，QoS 是 Sender 和 Receiver 之间达成的协议，不是 Publisher 和 Subscriber 之间达成的协议。也就是说 Publisher 发布一条 QoS1 的消息，只能保证 Broker 能至少收到一次这个消息；至于对应的 Subscriber 能否至少收到一次这个消息，还要取决于 Subscriber 在 Subscribe 的时候和 Broker 协商的 QoS 等级。</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">接下来我们来看一下 QoS0 和 QoS1 的机制，并讨论一下什么是 QoS 降级。</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">6.2 QoS0</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">QoS0 </span><span style="color:#3f3f3f;">是最简单的一个 QoS 等级了，在这个 QoS 等级下，Sender 和 Receiver 之间一次消息的传递流程如下：</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="222" src="https://images2.imgbox.com/8b/f6/tFyMqgYu_o.jpg" width="882"></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">Sender </span><span style="color:#3f3f3f;">向 Receiver 发送一个包含消息数据的 PUBLISH 包，然后不管结果如何，丢弃掉已发送的 PUBLISH 包，一条消息的发送完成。</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">6.3 QoS1</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">QoS </span><span style="color:#3f3f3f;">要保证消息至少到达 Sender 一次，所以有一个应答的机制，在 Qos1 等级下的 Sender 和 Receiver 的一次消息的传递流程如下。</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="222" src="https://images2.imgbox.com/55/89/7XDbreFJ_o.jpg" width="882"></p> 
<ol><li><span style="color:#3f3f3f;">Sender </span><span style="color:#3f3f3f;">向 Receiver 发送一个带有消息数据的 PUBLISH 包， 并在本地保存这个 PUBLISH 包。</span></li><li><span style="color:#3f3f3f;">Receiver </span><span style="color:#3f3f3f;">收到 PUBLISH 包以后，向 Sender 发送一个 PUBACK 数据包，PUBACK 数据包没有消息体（Payload），在可变头中（Variable header）中有一个包标识（Packet Identifier），和它收到的 PUBLISH 包中的 Packet Identifier 一致。</span></li><li><span style="color:#3f3f3f;">Sender </span><span style="color:#3f3f3f;">收到 PUBACK 之后，根据 PUBACK 包中的 Packet Identifier 找到本地保存的 PUBLISH 包，然后丢弃掉，一次消息的发送完成。</span></li><li><span style="color:#3f3f3f;">如果 Sender 在一段时间内没有收到 PUBLISH 包对应的 PUBACK，它将该 PUBLISH 包的 DUP 标识设为 1（代表是重新发送的 PUBLISH 包），然后重新发送该 PUBLISH 包。重复这个流程，直到收到 PUBACK，然后执行第 3 步。</span></li></ol> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">6.4 </span><span style="color:#3f3f3f;">代码实践</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">这里我们实现一个发布端和一个订阅端，可以通过命令行参数来指定发布和订阅的 QoS，同时，通过捕获“packetsend”和“packetreceive”事件，将发送和接受到的 MQTT 数据包的类型打印出来。</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">完整的代码 publish_with_qos.js 如下：</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#a626a4;">var</span></strong><span style="color:#383a42;"> args = </span><strong><span style="color:#c18401;">require</span></strong><span style="color:#383a42;">(</span><span style="color:#50a14f;">'yargs'</span><span style="color:#383a42;">).argv;</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#a626a4;">var</span></strong><span style="color:#383a42;"> mqtt = </span><strong><span style="color:#c18401;">require</span></strong><span style="color:#383a42;">(</span><span style="color:#50a14f;">'mqtt'</span><span style="color:#383a42;">)</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#a626a4;">var</span></strong><span style="color:#383a42;"> client = mqtt.connect(</span><span style="color:#50a14f;">'mqtt://iot.eclipse.org'</span><span style="color:#383a42;">, {<!-- --></span></p> 
<p style="margin-left:0cm;">    <span style="color:#986801;">clientId</span><span style="color:#383a42;">: </span><span style="color:#50a14f;">"mqtt_sample_publisher_2"</span><span style="color:#383a42;">,</span></p> 
<p style="margin-left:0cm;">    <span style="color:#986801;">clean</span><span style="color:#383a42;">: </span><span style="color:#0184bb;">false</span></p> 
<p style="margin-left:0cm;"><span style="color:#383a42;">})</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><span style="color:#383a42;">client.on(</span><span style="color:#50a14f;">'connect'</span><span style="color:#383a42;">, </span><strong><span style="color:#a626a4;">function</span></strong><span style="color:#383a42;"> (connack) {<!-- --></span></p> 
<p style="margin-left:0cm;">    <strong><span style="color:#a626a4;">if</span></strong><span style="color:#383a42;"> (connack.returnCode == </span><span style="color:#986801;">0</span><span style="color:#383a42;">) {<!-- --></span></p> 
<p style="margin-left:0cm;"><span style="color:#383a42;">        client.on(</span><span style="color:#50a14f;">'packetsend'</span><span style="color:#383a42;">, </span><strong><span style="color:#a626a4;">function</span></strong><span style="color:#383a42;"> (packet) {<!-- --></span></p> 
<p style="margin-left:0cm;">            <strong><span style="color:#c18401;">console</span></strong><span style="color:#383a42;">.log(</span><span style="color:#50a14f;">`send: </span><span style="color:#e45649;">${packet.cmd}</span><span style="color:#50a14f;">`</span><span style="color:#383a42;">)</span></p> 
<p style="margin-left:0cm;"><span style="color:#383a42;">        })</span></p> 
<p style="margin-left:0cm;"><span style="color:#383a42;">        client.on(</span><span style="color:#50a14f;">'packetreceive'</span><span style="color:#383a42;">, </span><strong><span style="color:#a626a4;">function</span></strong><span style="color:#383a42;"> (packet) {<!-- --></span></p> 
<p style="margin-left:0cm;">            <strong><span style="color:#c18401;">console</span></strong><span style="color:#383a42;">.log(</span><span style="color:#50a14f;">`receive: </span><span style="color:#e45649;">${packet.cmd}</span><span style="color:#50a14f;">`</span><span style="color:#383a42;">)</span></p> 
<p style="margin-left:0cm;"><span style="color:#383a42;">        })</span></p> 
<p style="margin-left:0cm;"><span style="color:#383a42;">        client.publish(</span><span style="color:#50a14f;">"home/sample_topic"</span><span style="color:#383a42;">, </span><strong><span style="color:#c18401;">JSON</span></strong><span style="color:#383a42;">.stringify({<!-- --></span><span style="color:#986801;">data</span><span style="color:#383a42;">: </span><span style="color:#50a14f;">'test'</span><span style="color:#383a42;">}), {<!-- --></span><span style="color:#986801;">qos</span><span style="color:#383a42;">: args.qos})</span></p> 
<p style="margin-left:0cm;"><span style="color:#383a42;">    } </span><strong><span style="color:#a626a4;">else</span></strong><span style="color:#383a42;"> {<!-- --></span></p> 
<p style="margin-left:0cm;">        <strong><span style="color:#c18401;">console</span></strong><span style="color:#383a42;">.log(</span><span style="color:#50a14f;">`Connection failed: </span><span style="color:#e45649;">${connack.returnCode}</span><span style="color:#50a14f;">`</span><span style="color:#383a42;">)</span></p> 
<p style="margin-left:0cm;"><span style="color:#383a42;">    }</span></p> 
<p style="margin-left:0cm;"><span style="color:#383a42;">})</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">subscribe_with_qos.js:</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#a626a4;">var</span></strong><span style="color:#383a42;"> args = </span><strong><span style="color:#c18401;">require</span></strong><span style="color:#383a42;">(</span><span style="color:#50a14f;">'yargs'</span><span style="color:#383a42;">).argv;</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#a626a4;">var</span></strong><span style="color:#383a42;"> mqtt = </span><strong><span style="color:#c18401;">require</span></strong><span style="color:#383a42;">(</span><span style="color:#50a14f;">'mqtt'</span><span style="color:#383a42;">)</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#a626a4;">var</span></strong><span style="color:#383a42;"> client = mqtt.connect(</span><span style="color:#50a14f;">'mqtt://iot.eclipse.org'</span><span style="color:#383a42;">, {<!-- --></span></p> 
<p style="margin-left:0cm;">    <span style="color:#986801;">clientId</span><span style="color:#383a42;">: </span><span style="color:#50a14f;">"mqtt_sample_subscriber_id_2"</span><span style="color:#383a42;">,</span></p> 
<p style="margin-left:0cm;">    <span style="color:#986801;">clean</span><span style="color:#383a42;">: </span><span style="color:#0184bb;">false</span></p> 
<p style="margin-left:0cm;"><span style="color:#383a42;">})</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><span style="color:#383a42;">client.on(</span><span style="color:#50a14f;">'connect'</span><span style="color:#383a42;">, </span><strong><span style="color:#a626a4;">function</span></strong><span style="color:#383a42;"> (connack) {<!-- --></span></p> 
<p style="margin-left:0cm;">    <strong><span style="color:#a626a4;">if</span></strong><span style="color:#383a42;"> (connack.returnCode == </span><span style="color:#986801;">0</span><span style="color:#383a42;">) {<!-- --></span></p> 
<p style="margin-left:0cm;"><span style="color:#383a42;">        client.subscribe(</span><span style="color:#50a14f;">"home/sample_topic"</span><span style="color:#383a42;">, {<!-- --></span><span style="color:#986801;">qos</span><span style="color:#383a42;">: args.qos}, </span><strong><span style="color:#a626a4;">function</span></strong><span style="color:#383a42;"> () {<!-- --></span></p> 
<p style="margin-left:0cm;"><span style="color:#383a42;">            client.on(</span><span style="color:#50a14f;">'packetsend'</span><span style="color:#383a42;">, </span><strong><span style="color:#a626a4;">function</span></strong><span style="color:#383a42;"> (packet) {<!-- --></span></p> 
<p style="margin-left:0cm;">                <strong><span style="color:#c18401;">console</span></strong><span style="color:#383a42;">.log(</span><span style="color:#50a14f;">`send: </span><span style="color:#e45649;">${packet.cmd}</span><span style="color:#50a14f;">`</span><span style="color:#383a42;">)</span></p> 
<p style="margin-left:0cm;"><span style="color:#383a42;">            })</span></p> 
<p style="margin-left:0cm;"><span style="color:#383a42;">            client.on(</span><span style="color:#50a14f;">'packetreceive'</span><span style="color:#383a42;">, </span><strong><span style="color:#a626a4;">function</span></strong><span style="color:#383a42;"> (packet) {<!-- --></span></p> 
<p style="margin-left:0cm;">                <strong><span style="color:#c18401;">console</span></strong><span style="color:#383a42;">.log(</span><span style="color:#50a14f;">`receive: </span><span style="color:#e45649;">${packet.cmd}</span><span style="color:#50a14f;">`</span><span style="color:#383a42;">)</span></p> 
<p style="margin-left:0cm;"><span style="color:#383a42;">            })</span></p> 
<p style="margin-left:0cm;"><span style="color:#383a42;">        })</span></p> 
<p style="margin-left:0cm;"><span style="color:#383a42;">    } </span><strong><span style="color:#a626a4;">else</span></strong><span style="color:#383a42;"> {<!-- --></span></p> 
<p style="margin-left:0cm;">        <strong><span style="color:#c18401;">console</span></strong><span style="color:#383a42;">.log(</span><span style="color:#50a14f;">`Connection failed: </span><span style="color:#e45649;">${connack.returnCode}</span><span style="color:#50a14f;">`</span><span style="color:#383a42;">)</span></p> 
<p style="margin-left:0cm;"><span style="color:#383a42;">    }</span></p> 
<p style="margin-left:0cm;"><span style="color:#383a42;">})</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">在 subscribe_with_qos.js 中， Client 每次连接到 Broker 之后都会按照参数指定的 QoS 重新订阅主题，订阅成功以后才开始捕获接收和发送的数据包，所以 Client 在连接之后，重新订阅之前收到的离线消息不会被打印出来。</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">我们可以通过 </span><span style="color:#3f3f3f;">node publish_with_qos.js --qos=xxx</span> <span style="color:#3f3f3f;">和 </span><span style="color:#3f3f3f;">node subscribe_with_qos.js --qos=xxx</span> <span style="color:#3f3f3f;">来运行这两个 JS 程序。</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">接下来我们用 4 种参数组合来运行这两 JS 程序，看看输出分别是什么。</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">注意：需要先运行 subscribe_with_qos.js 再运行 publish_with_qos.js，确保接收到消息可以打印出来。</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">6.4.1 </span><span style="color:#3f3f3f;">发布使用</span><span style="color:#3f3f3f;"> QoS0</span><span style="color:#3f3f3f;">，订阅使用</span><span style="color:#3f3f3f;"> QoS0</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">node publish_with_qos.js --qos=0</span> <span style="color:#3f3f3f;">输出为：</span></p> 
<p style="margin-left:0cm;"><span style="color:#50a14f;">send</span><span style="color:#383a42;">: publish</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">node subscribe_with_qos.js --qos=0</span> <span style="color:#3f3f3f;">输出为：</span></p> 
<p style="margin-left:0cm;"><span style="color:#50a14f;">receive</span><span style="color:#383a42;">: publish</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">结果显而易见，Publisher 到 Broker，Broker 到 Subscriber 都是用的 QoS0。</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">6.4.2 </span><span style="color:#3f3f3f;">发布使用</span><span style="color:#3f3f3f;"> QoS1</span><span style="color:#3f3f3f;">，订阅使用</span><span style="color:#3f3f3f;"> QoS1</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">node publish_with_qos.js --qos=1</span> <span style="color:#3f3f3f;">输出为：</span></p> 
<p style="margin-left:0cm;"><span style="color:#50a14f;">send</span><span style="color:#383a42;">: publish</span></p> 
<p style="margin-left:0cm;"><span style="color:#50a14f;">receive</span><span style="color:#383a42;">: puback</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">node subscribe_with_qos.js --qos=1</span> <span style="color:#3f3f3f;">输出为：</span></p> 
<p style="margin-left:0cm;"><span style="color:#50a14f;">receive</span><span style="color:#383a42;">: publish</span></p> 
<p style="margin-left:0cm;"><span style="color:#50a14f;">send</span><span style="color:#383a42;">: puback</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">同样地，结果显而易见，Publisher 到 Broker，Broker 到 Subscriber 都是用的 QoS1。</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">6.4.3 </span><span style="color:#3f3f3f;">发布使用</span><span style="color:#3f3f3f;"> QoS0</span><span style="color:#3f3f3f;">，订阅使用</span><span style="color:#3f3f3f;"> QoS1</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">node publish_with_qos.js --qos=0</span> <span style="color:#3f3f3f;">输出为：</span></p> 
<p style="margin-left:0cm;"><span style="color:#50a14f;">send</span><span style="color:#383a42;">: publish</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">node subscribe_with_qos.js --qos=1</span> <span style="color:#3f3f3f;">输出为：</span></p> 
<p style="margin-left:0cm;"><span style="color:#50a14f;">receive</span><span style="color:#383a42;">: publish</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">这里就有点奇怪了， 很明显 Broker 到 Subscriber 这段使用的是 QoS0，和 Subscriber 订阅时指定的 QoS 不一样。原因我们后面来讲。</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">6.4.4 </span><span style="color:#3f3f3f;">发布使用</span><span style="color:#3f3f3f;"> QoS1</span><span style="color:#3f3f3f;">，订阅使用</span><span style="color:#3f3f3f;"> QoS0</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">node publish_with_qos.js --qos=1</span> <span style="color:#3f3f3f;">输出为：</span></p> 
<p style="margin-left:0cm;"><span style="color:#50a14f;">send</span><span style="color:#383a42;">: publish</span></p> 
<p style="margin-left:0cm;"><span style="color:#50a14f;">receive</span><span style="color:#383a42;">: puback</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">node subscribe_with_qos.js --qos=0</span> <span style="color:#3f3f3f;">输出为：</span></p> 
<p style="margin-left:0cm;"><span style="color:#50a14f;">receive</span><span style="color:#383a42;">: publish</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">和设定的一样， Publisher 到 Broker 使用 QoS1，Broker 到 Subscriber 使用的 QoS0。Publisher 使用 QoS1 发布消息，但是消息到 Subscriber 却是 QoS0。也就是说有可能无法收到消息，这种现象叫做 QoS 的降级（QoS Degrade）。</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">这里有一个很重要的计算方法，<strong>在 MQTT 协议中，从 Broker 到 Subscriber 这段消息传递的实际 QoS 等于：Publisher 发布消息时指定的 QoS 等级和 Subscriber 在订阅时与 Broker 协商的 QoS 等级，这两个 QoS 等级中的最小那一个。</strong></span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#3f3f3f;">Actual Subscribe QoS = MIN(Publish QoS, Subscribe QoS)</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">这也就解释了“publish qos=0, subscribe qos=1”的情况下 Subscriber 的实际 QoS 为 0，以及“publish qos=1, subscribe qos=0”时出现 QoS 降级的原因。</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">理解了实际 Subscriber QoS 的计算方法，你才能很好地设计你系统里面 Publisher 和 Subscriber 使用的 QoS。例如，如果你希望 Subscriber 至少收到一次 Publisher 的消息，那么你要确保 Publisher 和 Subscriber 都使用不小于 1 的 QoS 等级。</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">6.5 </span><span style="color:#3f3f3f;">小结</span></p> 
<p style="margin-left:0cm;"><span style="color:#3f3f3f;">在这一课里面，我们学习了相对比较简单的两种 QoS 等级，同时学习了实际 QoS 的计算方法，接下来我们学习相对复杂的 QoS2 以及 QoS 的最佳实践。</span></p> 
<p style="margin-left:0cm;">By Urien 2019年5月26日 12:04:07</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/07e307806f4dca7e3eb78bcb8e7a5bad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Prometheus学习系列（十三）之配置解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3e40e41a364f4cb078b6eff915369305/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">什么是虚拟机（virtual machine）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>