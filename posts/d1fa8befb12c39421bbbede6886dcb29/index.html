<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【博学谷学习记录】超强总结，用心分享 | 陌陌案例-离线与实时查询 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【博学谷学习记录】超强总结，用心分享 | 陌陌案例-离线与实时查询" />
<meta property="og:description" content="#博学谷IT技术支持#
一、案例需求 选择合理的存储容器进行数据存储，支持即席查询与离线分析实时统计消息总量实时统计各个地区收发消息的总量实时统计每一位客户发送和接收消息数量 二、架构流程 2.1 数据采集操作：基于flume实现消息数据采集 监听数据源文件，一旦文件中有新的内容出现，将对应数据写入Kafka中，同时既能监听文件，也能监听目录
操作步骤
1. 确定三大组件
Source组件：Taildir Source
Sink组件：Kafka Sink
channel组件：Memory Channel
2. 调整采集配置信息
3. 配置采集文件
4. 在Kafka中创建MOMO_MSG的Topic
5. 启动Flume组件，准备进行数据采集工作
6. 测试是否正常采集
2.2 写入到HBase 1. 在HBase中创建一个名称空间：MOMO_CHAT
2. 在HBase中创建表
列族设计：C1是否需要压缩：GZ预分区：基于Hash预分区，6个版本号：仅需要保留1个TTL：数据永久保存不需要考虑 3. 创建一个消费者完成数据写入到HBase
4. 测试操作
启动相关的软件：zookeeper、hadoop、hbase、kafka启动消费者代码启动陌陌数据源检测hbase表中是否有数据 2.3 对接Phoenix 创建视图
create view MOMO_CHAT.MOMO_MSG( &#34;id&#34; varchar primary key, C1.&#34;msg_time&#34; varchar, C1.&#34;sender_nickyname&#34; varchar, C1.&#34;sender_account&#34; varchar, C1.&#34;sender_sex&#34; varchar, C1.&#34;sender_ip&#34; varchar, C1.&#34;sender_os&#34; varchar, C1.&#34;sender_phone_type&#34; varchar, C1.&#34;sender_network&#34; varchar, C1.&#34;sender_gps&#34; varchar, C1.&#34;receiver_nickyname&#34; varchar, C1.&#34;receiver_ip&#34; varchar, C1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d1fa8befb12c39421bbbede6886dcb29/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-12T10:19:00+08:00" />
<meta property="article:modified_time" content="2023-06-12T10:19:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【博学谷学习记录】超强总结，用心分享 | 陌陌案例-离线与实时查询</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p> #博学谷IT技术支持#</p> 
</blockquote> 
<h2>一、案例需求</h2> 
<ol><li>选择合理的存储容器进行数据存储，支持即席查询与离线分析</li><li>实时统计消息总量</li><li>实时统计各个地区收发消息的总量</li><li>实时统计每一位客户发送和接收消息数量</li></ol> 
<h2>二、架构流程</h2> 
<h3>2.1 数据采集操作：基于flume实现消息数据采集</h3> 
<blockquote> 
 <p>监听数据源文件，一旦文件中有新的内容出现，将对应数据写入Kafka中，同时既能监听文件，也能监听目录</p> 
</blockquote> 
<p>操作步骤</p> 
<p>1. 确定三大组件</p> 
<p>Source组件：Taildir Source</p> 
<p>Sink组件：Kafka Sink</p> 
<p>channel组件：Memory Channel</p> 
<p>2. 调整采集配置信息</p> 
<p>3. 配置采集文件</p> 
<p>4. 在Kafka中创建MOMO_MSG的Topic</p> 
<p>5. 启动Flume组件，准备进行数据采集工作</p> 
<p>6. 测试是否正常采集</p> 
<h3>2.2 写入到HBase</h3> 
<p>1. 在HBase中创建一个名称空间：MOMO_CHAT</p> 
<p>2. 在HBase中创建表</p> 
<ol><li>列族设计：C1</li><li>是否需要压缩：GZ</li><li>预分区：基于Hash预分区，6个</li><li>版本号：仅需要保留1个</li><li>TTL：数据永久保存不需要考虑</li></ol> 
<p>3. 创建一个消费者完成数据写入到HBase</p> 
<p>4. 测试操作</p> 
<ol><li>启动相关的软件：zookeeper、hadoop、hbase、kafka</li><li>启动消费者代码</li><li>启动陌陌数据源</li><li>检测hbase表中是否有数据</li></ol> 
<h3>2.3 对接Phoenix</h3> 
<p>创建视图</p> 
<pre><code class="language-sql">create view MOMO_CHAT.MOMO_MSG(
    "id" varchar primary key,
    C1."msg_time" varchar,
    C1."sender_nickyname" varchar,
    C1."sender_account" varchar,
    C1."sender_sex" varchar,
    C1."sender_ip" varchar,
    C1."sender_os" varchar,
    C1."sender_phone_type" varchar,
    C1."sender_network" varchar,
    C1."sender_gps" varchar,
    C1."receiver_nickyname" varchar,
    C1."receiver_ip" varchar,
    C1."receiver_account" varchar,
    C1."receiver_os" varchar,
    C1."receiver_phone_type" varchar,
    C1."receiver_network" varchar,
    C1."receiver_gps" varchar,
    C1."receiver_sex" varchar,
    C1."msg_type" varchar,
    C1."distance" varchar,
    C1."message" varchar
)</code></pre> 
<p><img alt="" height="446" src="https://images2.imgbox.com/8c/56/64XW8QD5_o.png" width="1200"></p> 
<h3>2.4 对接Hive</h3> 
<p>与HBase集成</p> 
<pre><code class="language-sql">create external table MOMO_CHAT.MOMO_MSG(
    id string,
    msg_time string,
    sender_nickyname string,
    sender_account string,
    sender_sex string,
    sender_ip string,
    sender_os string,
    sender_phone_type string,
    sender_network string,
    sender_gps string,
    receiver_nickyname string,
    receiver_ip string,
    receiver_account string,
    receiver_os string,
    receiver_phone_type string,
    receiver_network string,
    receiver_gps string,
    receiver_sex string,
    msg_type string,
    distance string,
    message string
)
stored by 'org.apache.hadoop.hive.hbase.HBaseStorageHandler' 
with serdeproperties('hbase.columns.mapping'=':key,C1:msg_time,
C1:sender_nickyname,
C1:sender_account,
C1:sender_sex,
C1:sender_ip,
C1:sender_os,
C1:sender_phone_type,
C1:sender_network,
C1:sender_gps,
C1:receiver_nickyname,
C1:receiver_ip,
C1:receiver_account,
C1:receiver_os,
C1:receiver_phone_type,
C1:receiver_network,
C1:receiver_gps,
C1:receiver_sex,
C1:msg_type,
C1:distance,
C1:message')
tblproperties('hbase.table.name'='MOMO_CHAT:MOMO_MSG');
</code></pre> 
<h3>2.5 基于Flink进行实时统计计算</h3> 
<ul><li>实时需求 
  <ul><li>实时统计各个用户发送消息总量</li></ul></li></ul> 
<pre><code class="language-java">// 设置过滤条件, 将不符合数据过滤掉
SingleOutputStreamOperator&lt;String&gt; filterOperator = streamSource.filter(new FilterFunction&lt;String&gt;() {
    @Override
    public boolean filter(String msg) throws Exception {
        return (msg != null &amp;&amp; !"".equals(msg.trim()) &amp;&amp; msg.split("\001").length == 20); 
        // 如果需要此数据, 请返回true 如果不需要, 返回false
    }
});

// 对数据进行转换操作: 将消息中发件人的GPS, 根据GPS地址获取其省份信息, 将省份信息作为key, value放置为1
SingleOutputStreamOperator&lt;Tuple2&lt;String, Long&gt;&gt; mapOperator = filterOperator.map(new MapFunction&lt;String, Tuple2&lt;String, Long&gt;&gt;() {
    @Override
    public Tuple2&lt;String, Long&gt; map(String msg) throws Exception {
        // 对消息数据进行切割操作
        String[] fields = msg.split("\001");
        // 获取发件人的GPS信息
        String[] latAndLng = fields[15].split(",");

        String lng = latAndLng[0].trim();
        String lat = latAndLng[1].trim();

        // 根据经纬度查询省份信息
        String province = HttpClientUtils.findByLatAndLng(lat, lng);

        // 返回数据
        return new Tuple2&lt;&gt;(province, 1L);
    }
});
// 根据省份分组,求和即可
SingleOutputStreamOperator&lt;Tuple2&lt;String, Long&gt;&gt; sumOperator = mapOperator.keyBy(0).sum(1);

// 将Tuple2转换为 momocountBean对象
SingleOutputStreamOperator&lt;MoMoCountBean&gt; operator = sumOperator.map(new MapFunction&lt;Tuple2&lt;String, Long&gt;, MoMoCountBean&gt;() {
    @Override
    public MoMoCountBean map(Tuple2&lt;String, Long&gt; tuple2) throws Exception {
        String province = tuple2.f0;
        Long msgCount = tuple2.f1;

        MoMoCountBean moMoCountBean = new MoMoCountBean();
        moMoCountBean.setMoMoProvince(province);
        moMoCountBean.setMoMo_MsgCount(msgCount);

        return moMoCountBean;
    }
});

// 设置Sink组件, 写入到Mysql
operator.addSink(new MysqlSink("3"));</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6412bc77fd314dc6a82b6d50dc7c05c0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Prometheus 实践操作 -＞ prometheus配置部署</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8609cb65544dad1fc22b6e14164a8f63/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringBoot整合rabbitmq</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>