<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;基础系列(一) 对象指针 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;基础系列(一) 对象指针" />
<meta property="og:description" content="一. 函数指针和指针函数 1.1 函数指针 这两个是C语言里两个比较绕的概念，我们先说一下函数指针
函数指针本质是一个指针，该指针的地址指向了一个函数。
在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址，而且函数名表示的就是这个地址。
写法如下： 函数返回值类型 (* 指针变量名) (函数参数列表);
int (*fun) (int a ， int b);
1.2 指针函数 指针函数本质是一个函数， 其返回值为指针
指针函数是一个函数。函数都有返回类型（如果不返回值，则为无值型），只不过指针函数返回类型是某一类型的指针。
写法如下：
*类型标识符 函数名(参数表)；
int *fun(int x,int y);
常规函数和指针函数区别: 在函数名前面多了一个 * 号，而这个函数就是一个指针函数。其返回值是一个 int 类型的指针，是一个地址。
其他理解方式：
指针函数：int* fun(int x,int y);
函数指针：int (*fun)(int x,int y);
可以简单粗暴的理解为，指针函数的*是属于数据类型的，而函数指针的星号是属于函数名的。
一个很简单的判定方法就是观察(*)，记住其中一个即可：
int (*p)(int,int);有括号，*与p结合，*p就是个指针，指向返回值为整型且有两个整型参数的函数的指针，因此称为函数指针。
int*p(int,int); 没有括号，*与int结合，int*为返回类型，p就是一个函数名，这时就是一个指针函数，只不过返回值类型为int*。
二. 对象指针 我们在来看看C&#43;&#43;中的对象指针
2.1 指向对象成员函数的指针 需要注意的：定义指向对象成员函数的指针变量的方法和定义指向普通函数的指针变量方法所有不同。
指向普通函数的指针变量就是第一小节中说的函数指针
而定义一个指向对象成员函数的指针变量要复杂一点，直接通过代码来说明
#include &lt;iostream&gt; using namespace std; class Time { public: Time(int, int, int); //声明带参构造函数 int hour; int minute; int sec; void get_time(); // 声明共有成员函数 }; Time :: Time(int h, int m, int s) { hour = h; minute = m; sec = s; } void Time::get_time() { cout&lt;&lt;hour &lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/adba4951520560e887bd0f25f927e160/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-19T17:19:43+08:00" />
<meta property="article:modified_time" content="2023-10-19T17:19:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;基础系列(一) 对象指针</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一. 函数指针和指针函数</h3> 
<h4>1.1 函数指针</h4> 
<p>         这两个是C语言里两个比较绕的概念，我们先说一下函数指针</p> 
<p>         函数指针本质是一个指针，该指针的地址指向了一个函数。</p> 
<p>         在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址，而且函数名表示的就是这个地址。</p> 
<p>        写法如下：   </p> 
<p>        函数返回值类型 (* 指针变量名) (函数参数列表);</p> 
<p>        int  (*fun) (int a ， int b);</p> 
<p></p> 
<h4>1.2 指针函数</h4> 
<p>         指针函数本质是一个函数， 其返回值为指针</p> 
<p>         <strong>指针函数是一个<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0/301912?fromModule=lemma_inlink" rel="nofollow" title="函数">函数</a></strong>。函数都有返回类型（如果不<a href="https://baike.baidu.com/item/%E8%BF%94%E5%9B%9E%E5%80%BC/9629649?fromModule=lemma_inlink" rel="nofollow" title="返回值">返回值</a>，则为无值型），只不过指针函数返回类型是某一类型的指针。</p> 
<p>        写法如下：</p> 
<p>        *类型标识符 函数名(参数表)；</p> 
<p>        int  *fun(int x,int y);</p> 
<p>       常规函数和指针函数区别: 在函数名前面多了一个 * 号，而这个函数就是一个指针函数。其返回值是一个 int 类型的指针，是一个地址。</p> 
<p></p> 
<p>其他理解方式：</p> 
<p>指针函数：int* fun(int x,int y);</p> 
<p>函数指针：int (*fun)(int x,int y);</p> 
<p>可以简单粗暴的理解为，指针函数的*是属于数据类型的，而函数指针的星号是属于函数名的。</p> 
<p>一个很简单的判定方法就是观察(*)，记住其中一个即可：</p> 
<p>int (*p)(int,int);有括号，*与p结合，*p就是个指针，指向返回值为整型且有两个整型参数的函数的指针，因此称为函数指针。</p> 
<p>int*p(int,int); 没有括号，*与int结合，int*为返回类型，p就是一个函数名，这时就是一个指针函数，只不过返回值类型为int*。</p> 
<p></p> 
<h3>二. 对象指针</h3> 
<p>      我们在来看看C++中的对象指针</p> 
<h4>2.1 指向对象成员函数的指针</h4> 
<p>        需要注意的：定义指向对象成员函数的指针变量的方法和定义指向普通函数的指针变量方法所有不同。</p> 
<p>        指向普通函数的指针变量就是第一小节中说的函数指针</p> 
<p><img alt="" height="309" src="https://images2.imgbox.com/94/37/MITzKvuw_o.png" width="1035"></p> 
<p>   而定义一个指向对象成员函数的指针变量要复杂一点，直接通过代码来说明</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Time {
    public:
    Time(int, int, int);  //声明带参构造函数
    int hour;
    int minute;
    int sec;
    void get_time(); // 声明共有成员函数
};


Time :: Time(int h, int m, int s) {
    hour = h;
    minute = m;
    sec = s;
}

void Time::get_time() {
    cout&lt;&lt;hour &lt;&lt;":" &lt;&lt;minute &lt;&lt; ":" &lt;&lt; sec &lt;&lt; endl;
}

int main(int argc, const char** argv){
    Time t1(10, 20, 25);  // 定义Time对象t1
    int *p = &amp;t1.hour; //定义指向整型数据的指针变量p  并使p指向t1.hour
    cout&lt;&lt; *p &lt;&lt; endl;  
    
    t1.get_time(); //调用对象 t1的成员函数get_time()

    Time *p2 = &amp;t1;  //定义指向Time 类对象的指针变量 p2, 并使 p2指向   t1
    p2-&gt;get_time();  // 调用  p2 所指对象（即t1）的get_time() 方法

    void (Time :: *p3) (); //定义指向Time类公用成员函数的指针变量p3;
    p3 = &amp;Time::get_time;  // 使p3指向Time类公用成员函数get_time();

    (t1.*p3)(); //调用对象 t1中   p3所指的成员函数即 t1.get_time();

     void (Time :: *p4) () = &amp;Time::get_time; // 定义指针变量时指定其指向

    return 0;
}</code></pre> 
<p>打印输出：</p> 
<pre><code class="language-cpp">10
10:20:25
10:20:25
10:20:25</code></pre> 
<p><img alt="" height="612" src="https://images2.imgbox.com/af/13/Ixd9uGPO_o.png" width="1200"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dff1abcc12ec708e8072c2bc3207f8a8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">EasyPlayer播放视频因流媒体协议不一致导致的无法播放问题处理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4059168fefe6ea10650a6f783e08dbc1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">iOS 用masonry布局Scrollview的问题,添加在scrollview的子控件约束失效</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>