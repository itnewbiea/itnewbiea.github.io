<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>prometheus 配置服务器监控、服务监控、容器中服务监控与告警 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="prometheus 配置服务器监控、服务监控、容器中服务监控与告警" />
<meta property="og:description" content="最近公司有几个服务遇到了瓶颈，也就是数据量增加了，没有人发现，这不是缺少一个监控服务和告警的系统吗？ 主要需求是监控每个服务，顺带监控一下服务器和一些中间件，这里采集的2种，zabbix和prometheus，由于我们要监控的是Docker容器中的服务，最终选择prometheus。
如下：
一 实现功能 服务宕机，不能提供服务，飞书收到告警信息。容器中服务占用分配内存达到50， 飞书收到预警信息。容器中服务中JVM堆内存占用达到80， 飞书收到预警信息。服务发生OOM后，服务可以立刻重启。 二：流程图 三 步骤 确定要监控的docker服务， 这里以公司的A服务为例子
查看服务的Dockerfile 和run.sh Dockerfile是构建docker镜像，run.sh是启动服务用的
1.1 Dockerfile中java执行命令添加：
&#34;-XX:&#43;HeapDumpOnOutOfMemoryError&#34;,&#34;-XX:HeapDumpPath=/temp/dump&#34;,&#34;-XX:&#43;ExitOnOutOfMemoryError&#34;,&#34;-XX:MaxRAMPercentage=75.0&#34;
-XX:&#43;HeapDumpOnOutOfMemoryError：参数表示当JVM发生OOM时，自动生成DUMP文件
-XX:HeapDumpPath=/temp/dump：生成dump目录文件的位置
-XX:&#43;ExitOnOutOfMemoryError：JVM在第一次出现内存不足错误时退出，启动JVM实例
-XX:MaxRAMPercentage=75.0： 这为JVM定义了75％的总内存限制
查看服务目前容器大小，和占用内存大小，保证占用内存稳定在30%一下。
docker stats dcda4228b794
这边找了一个47%的，只给了1G的容器大小。需求中超过50%就会告警。
如果超过50%,需要在启动容器的run.sh命令中提升初始容器大小
修改--memory 1024m \ --memory-swap 1024m \的值，是容器的内存大小
以上是容器要做的一些调整，也是自己定义的规则。
2. Idea中找到A应用，修改POM和 application.properties文件
application.properties中添加
management.endpoint.health.show-details=always
management.endpoints.web.exposure.include=*
这边要注意，如果你是yml文件 management.endpoints.web.exposure.include=*，
这个 * 一定要加 &#39;&#39;单引号，*在yml文件中是通配符。
POM中添加，目的是当前服务可以提供一些监控指标
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.micrometer&lt;/groupId&gt; &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt; &lt;/dependency&gt; 注意，如果你的服务属于对外接口访问服务，有Shiro拦截的话要配置
filterChainDefinitionMap.put(&#34;/actuator/prometheus&#34;, &#34;anon&#34;); 至此完成代码的整改，可以提交代码，部署服务。
确定服务正常启动：输入docker ps -a (不加-a就看正常运行的服务，-a是看所有的服务，包括停止的)
去服务器厂商放开当前服务对外的端口号，主要是对指定监控的服务器放开，不是所有
环境地址访问 http://ip:port/actuator/prometheus" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c2748f955e3b63c73c3a01302126f646/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-08T17:15:47+08:00" />
<meta property="article:modified_time" content="2023-03-08T17:15:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">prometheus 配置服务器监控、服务监控、容器中服务监控与告警</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>       最近公司有几个服务遇到了瓶颈，也就是数据量增加了，没有人发现，这不是缺少一个监控服务和告警的系统吗？  </p> 
<p></p> 
<p>      主要需求是监控每个服务，顺带监控一下服务器和一些中间件，这里采集的2种，zabbix和prometheus，由于我们要监控的是Docker容器中的服务，最终选择prometheus。</p> 
<p>如下：</p> 
<h3>一 实现功能</h3> 
<ol><li style="text-align:justify;">服务宕机，不能提供服务，飞书收到告警信息。</li><li style="text-align:justify;">容器中服务占用分配内存达到50， 飞书收到预警信息。</li><li style="text-align:justify;">容器中服务中JVM堆内存占用达到80， 飞书收到预警信息。</li><li style="text-align:justify;">服务发生OOM后，服务可以立刻重启。</li></ol> 
<h3> <strong>二：流程图</strong></h3> 
<p><img alt="" height="344" src="https://images2.imgbox.com/70/0c/loy5cSlK_o.jpg" width="692"></p> 
<h3> 三 步骤</h3> 
<p>确定要监控的docker服务， 这里以公司的A服务为例子</p> 
<ol><li style="text-align:justify;"><strong>查看服务的Dockerfile 和run.sh   </strong></li></ol> 
<p>Dockerfile是构建docker镜像，run.sh是启动服务用的</p> 
<p> <strong>1.1 Dockerfile中java执行命令添加：</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">"-XX:+HeapDumpOnOutOfMemoryError","-XX:HeapDumpPath=/temp/dump","-XX:+ExitOnOutOfMemoryError","-XX:MaxRAMPercentage=75.0"</p> 
<p>-XX:+HeapDumpOnOutOfMemoryError：参数表示当JVM发生OOM时，自动生成<a href="https://so.csdn.net/so/search?q=DUMP&amp;spm=1001.2101.3001.7020" title="DUMP">DUMP</a>文件</p> 
<p>-XX:HeapDumpPath=/temp/dump：生成dump目录文件的位置</p> 
<p>-XX:+ExitOnOutOfMemoryError：JVM在第一次出现内存不足错误时退出，启动JVM实例</p> 
<p>-XX:MaxRAMPercentage=75.0： 这为JVM定义了75％的总内存限制</p> 
<p><img alt="" height="29" src="https://images2.imgbox.com/b1/34/XlZFHklM_o.png" width="625"></p> 
<p style="margin-left:.0001pt;text-align:justify;">查看服务目前容器大小，和占用内存大小，保证占用内存稳定在30%一下。</p> 
<p style="margin-left:.0001pt;text-align:justify;">docker stats dcda4228b794</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="81" src="https://images2.imgbox.com/73/49/TdFs7aDV_o.png" width="1035"></p> 
<p> 这边找了一个47%的，只给了1G的容器大小。需求中超过50%就会告警。</p> 
<p>如果超过50%,需要在启动容器的run.sh命令中提升初始容器大小</p> 
<p style="margin-left:.0001pt;text-align:justify;">修改--memory 1024m \   --memory-swap 1024m \的值，是容器的内存大小</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">以上是容器要做的一些调整，也是自己定义的规则。</p> 
<p style="text-align:justify;"><strong>2. Idea中找到A应用，修改POM和 application.properties文件</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">application.properties中添加</p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#2b2b2b;"><span style="background-color:#2b2b2b;"><span style="color:#ffffff;">management.endpoint.health.show-details</span></span><span style="background-color:#2b2b2b;"><span style="color:#ffffff;">=</span></span><span style="background-color:#2b2b2b;"><span style="color:#ffffff;">always</span></span><br><span style="background-color:#2b2b2b;"><span style="color:#ffffff;">management.endpoints.web.exposure.include</span></span><span style="background-color:#2b2b2b;"><span style="color:#ffffff;">=</span></span><span style="background-color:#2b2b2b;"><span style="color:#ffffff;">*</span></span></span></p> 
<p>这边要注意，如果你是yml文件 <span style="background-color:#2b2b2b;"><span style="background-color:#2b2b2b;"><span style="color:#ffffff;">management.endpoints.web.exposure.include</span></span><span style="background-color:#2b2b2b;"><span style="color:#ffffff;">=</span></span><span style="background-color:#2b2b2b;"><span style="color:#ffffff;">*，</span></span></span></p> 
<p><span style="color:#fe2c24;">这个 * 一定要加 ''单引号，*在yml文件中是通配符。</span></p> 
<p><img alt="" height="433" src="https://images2.imgbox.com/c1/81/jMzprQkj_o.png" width="1030"></p> 
<p style="margin-left:.0001pt;text-align:justify;">POM中添加，目的是当前服务可以提供一些监控指标</p> 
<pre><code class="language-java">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;
    &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre> 
<p> 注意，如果你的服务属于对外接口访问服务，有Shiro拦截的话要配置</p> 
<pre><code class="language-java">filterChainDefinitionMap.put("/actuator/prometheus", "anon");</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">至此完成代码的整改，可以提交代码，部署服务。</p> 
<p style="margin-left:.0001pt;text-align:justify;">确定服务正常启动：输入docker ps -a  (不加-a就看正常运行的服务，-a是看所有的服务，包括停止的)</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="58" src="https://images2.imgbox.com/13/10/cgPYmMs6_o.png" width="1034"></p> 
<p> 去服务器厂商放开当前服务对外的端口号，主要是对指定监控的服务器放开，不是所有</p> 
<p><img alt="" height="516" src="https://images2.imgbox.com/f9/f8/EARB0SVA_o.png" width="1076"></p> 
<p style="margin-left:.0001pt;text-align:justify;">环境地址访问  <a href="http://120.46.163.45:60004/actuator/prometheus" rel="nofollow" title="http://ip:port/actuator/prometheus">http://ip:port/actuator/prometheus</a></p> 
<p style="margin-left:.0001pt;text-align:justify;">看到如下，就是提供的指标数据</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3> 3 docker容器监控服务</h3> 
<p>部署prometheus,alertmanager,garfana, 还有一个推消息给飞书的服务， 这个大家如果想找到怎么部署，可以留言，我整理一下，写出来。不过后面有时间我也会更新这边部署监控文章的。</p> 
<p><img alt="" height="247" src="https://images2.imgbox.com/d3/71/jVUJSaiR_o.png" width="1200"></p> 
<p></p> 
<p>1. cadvisor 是容器内个服务的监控指标提取</p> 
<p>2. prometheus-webhook-feishu 是网上找的一个开源的飞书通知服务</p> 
<p>3.alertmanager是告警管理 --通知2下发告警的</p> 
<p>4.grafana是可视化大屏，对prometheus采集的数据可视化展示</p> 
<p>5.node-exporter 是服务器监控，提取服务器的指标数据</p> 
<p>6.prometheus 是核心的监控服务</p> 
<h3>4. 配置prometheus</h3> 
<p style="margin-left:.0001pt;text-align:justify;">进入prometheus</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="97" src="https://images2.imgbox.com/8d/54/G6gjdiS2_o.png" width="967"></p> 
<p> 看到这几个文件夹/文件，其中主要配置实例在prometheus.yml中，rules文件下是配置告警规则的。</p> 
<p style="margin-left:.0001pt;text-align:justify;">进入<span style="color:#ff0000;">prometheus.yml</span>仿照- job_name: 自己创建一个</p> 
<pre><code class="language-html">- job_name: "A"    # 监控的job名称

    metrics_path: '/actuator/prometheus'   # 监控的指标路径

    static_configs:

      - targets: ['ip:port']    #监控的服务器和端口端口已经开放

        labels:

          serviceId: A-snapshot   #服务id告警展示

          serviceName: A-web  #服务名称   告警展示</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">重启prometheus</p> 
<p style="margin-left:.0001pt;text-align:justify;">docker restart prometheus</p> 
<p style="margin-left:.0001pt;text-align:justify;">访问http://ip:9090/查看配置的任务，如下up状态代表服务正常启动，配置任务成功。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="672" src="https://images2.imgbox.com/f8/b9/qtOyStZ1_o.png" width="1200"></p> 
<p> rules下有配置服务器/服务的告警规则</p> 
<p>1. 服务器内存使用超过98%告警规则</p> 
<p><img alt="" height="490" src="https://images2.imgbox.com/4c/7a/gaACCk3P_o.png" width="1200"></p> 
<p>  (node_memory_MemTotal_bytes - (node_memory_MemFree_bytes+node_memory_Buffers_bytes+node_memory_Cached_bytes )) / node_memory_MemTotal_bytes * 100 &gt; 98</p> 
<p><img alt="" height="315" src="https://images2.imgbox.com/fc/65/UlaWOfDx_o.png" width="1140"></p> 
<p> (node_filesystem_size_bytes - node_filesystem_avail_bytes) / node_filesystem_size_bytes * 100 &gt; 95</p> 
<p><img alt="" height="290" src="https://images2.imgbox.com/78/5b/Kd4tZ9ce_o.png" width="906"></p> 
<p>会对配置在prometheus中没有job都做监控，up==0标识改服务宕机，提示。</p> 
<p>可以做验证</p> 
<p> docker stop A服务容器id</p> 
<p><img alt="" height="86" src="https://images2.imgbox.com/60/a3/HjiuFya4_o.png" width="223"></p> 
<p> <img alt="" height="503" src="https://images2.imgbox.com/95/35/VjtXIWam_o.png" width="947"></p> 
<p>飞书收到这个通知，如何配置 prometheus-alertmanager-feishu的流程后续会同步上</p> 
<p></p> 
<h3 style="text-align:justify;"><strong>4.配置其他告警规则 这里配置容器内存超过50提示，和服务jvm中堆占用80提示</strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">配置路径/minitor/prometheus/rules</p> 
<p style="margin-left:.0001pt;text-align:justify;">可以自己重新定义一个yml ，下面yml下面所有规则都会被prometheus识别，一般按照项目建一个文件</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>容器内存超过50</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="546" src="https://images2.imgbox.com/f0/f3/C4cnBmpF_o.png" width="1200"></p> 
<pre><code class="language-java">
groups:
# 组名。报警规则组名称
- name:  A服务内存预警
  rules:
  - alert:  a服务内存使用率预警
  # expr：基于PromQL表达式告警触发条件，用于计算是否有时间序列满足该条件。
    expr: container_memory_usage_bytes{image="a:latest"}/container_spec_memory_limit_bytes{image="a:latest"} * 100 &gt; 50
  # for：评估等待时间，可选参数。用于表示只有当触发条件持续一段时间后才发送告警。在等待期间新产生告警的状态为pending。
    for: 20s # for语句会使 Prometheus 服务等待指定的时间, 然后执行查询表达式。（for 表示告警持续的时长，若持续时长小于该时间就不发给alertmanager了，大于
该时间再发。for的值不要小于prometheus中的scrape_interval，例如scrape_interval为30s，for为15s，如果触发告警规则，则再经过for时长后也一定会告警，这是因为&gt;最新的度量指标还没有拉取，在15s时仍会用原来值进行计算。另外，要注意的是只有在第一次触发告警时才会等待(for)时长。）
  # labels：自定义标签，允许用户指定要附加到告警上的一组附加标签。
    labels:
    # severity: 指定告警级别。有三种等级，分别为 warning, critical 和 emergency 。严重等级依次递增。
      severity: critical
  # annotations: 附加信息，比如用于描述告警详细信息的文字等，annotations的内容在告警产生时会一同作为参数发送到Alertmanager。
    annotations:
      title: "a服务内存使用率预警"
      serviceName: "{<!-- -->{ $labels.serviceName }}"
      instance: "{<!-- -->{ $labels.instance }}"
      value: "{<!-- -->{ $value }}"
      btn: "点击查看详情 :玫瑰:"
      link: "http://xxxxxxxxx:9090/targets"
      template: "**${serviceName}**(${instance})正式服务内存使用率已经超过阈值 **50%**, 请及时处理！\n当前值: ${value}%"
</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">expr:container_memory_usage_bytes{image="a:latest"}/container_spec_memory_limit_bytes{image="a:latest"} * 100 &gt; 50<br> 这个可以在之前prometheus查看</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="585" src="https://images2.imgbox.com/15/29/HGooKduo_o.png" width="1200"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>服务jvm中堆占用80提示</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="363" src="https://images2.imgbox.com/e5/85/mRZGriKI_o.png" width="1200"></p> 
<pre><code class="language-java">
- name: A服务堆内存超高预警
  rules:
  - alert: A服务堆内存使用率超高预警
    expr: sum(jvm_memory_used_bytes{serviceId="a", area="heap"})*100/sum(jvm_memory_max_bytes{serviceId="a", area="heap"}) &gt; 80
    for: 20s
    labels:
       severity: red
    annotations:
      title: "a服务堆内存使用率超高预警"
      serviceName: "{<!-- -->{ $labels.serviceName }}"
      instance: "{<!-- -->{ $labels.instance }}"
      value: "{<!-- -->{ $value }}"
      btn: "点击查看详情 :玫瑰:"
      link: "http://xxxxxxxx:9090/targets"
      template: "**${serviceName}**(${instance})正式环境服务内存使用率已经超过阈值 **80%**, 请及时处理！\n当前值: ${value}%"</code></pre> 
<p> expr: sum(jvm_memory_used_bytes{serviceId="job中配置的", area="heap"})*100/sum(jvm_memory_max_bytes{serviceId="job中配置的", area="heap"}) &gt; 80</p> 
<p> <img alt="" height="436" src="https://images2.imgbox.com/15/a2/p0iroReQ_o.png" width="1200"></p> 
<p> 重启prometheus</p> 
<h3 style="text-align:justify;"><strong>5 验证容器内存超过50  堆内存超80  和出现OOM后容器自动重启服务</strong></h3> 
<p> 在服务中加一个测试oom的接口， 正式发布后，这个接口要去掉</p> 
<p style="margin-left:.0001pt;text-align:justify;">如下： 会不断的生成不回收的对象 /dev/d</p> 
<pre><code class="language-java">package xxx;

import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 */
@Slf4j
@RestController
@RequestMapping("dev")
public class Controller {


    @RequestMapping("/a")
    public Integer message() {
        log.info("&gt;&gt;&gt;&gt;info");
        log.debug("&gt;&gt;&gt;&gt;&gt;Debug");
        return Runtime.getRuntime().availableProcessors();
    }

    @RequestMapping("/d")
    public String messaged(HttpServletRequest request) throws InterruptedException {
        log.info("&gt;&gt;&gt;&gt;info");
        log.debug("&gt;&gt;&gt;&gt;&gt;Debug");
        List&lt;Object&gt; list = new ArrayList&lt;&gt;();
        new Thread(new Runnable() {
            @Override
            public void run() {
                List&lt;Object&gt; list2 = new ArrayList&lt;&gt;();
                int initSize =  1024 * 1024 * 300;
                Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
                int i= 0;
                while(true) {
                    try{
                        Thread.sleep(5000);
                    } catch(Exception e) {
                        e.printStackTrace();
                    }
                    //每次添加50M
                    int userMemory = 1024*1024*10;
                    i++;
                    map.put("userMemory" + i, new byte[userMemory]);
                    list.add(map);
                    list2.add(map);
                }
            }
        }).start();
        return "OK";
    }
}</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">这里对A服务运行dev/d接口</p> 
<p style="margin-left:.0001pt;text-align:justify;">先看dev/a 是看运行的cpu个数，验证服务是否启动</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="230" src="https://images2.imgbox.com/0b/06/xnfC6I7f_o.png" width="380"></p> 
<p style="margin-left:.0001pt;text-align:justify;">这时候别着急让服务OOM</p> 
<p style="margin-left:.0001pt;text-align:justify;">先看cAdvisor，容器监控都靠他，监控别的服务器容器也要在对应服务器上安装。</p> 
<p style="margin-left:.0001pt;text-align:justify;">环境运行： <a href="http://cc-tsp-01:19190/" rel="nofollow" title="http://ip:19190/">http://ip:19190/</a></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="506" src="https://images2.imgbox.com/fe/7d/RwJdiXGw_o.png" width="1176"></p> 
<p style="margin-left:.0001pt;text-align:justify;">点击<a href="http://cc-tsp-01:19190/docker" rel="nofollow" title="Docker Containers">Docker Containers</a>可以看具体容器的信息,找到你要配置的容器A</p> 
<p style="margin-left:.0001pt;text-align:justify;">里面包括很多参数指标信息，这里先看容器内存</p> 
<p style="margin-left:.0001pt;text-align:justify;"> <img alt="" height="631" src="https://images2.imgbox.com/f0/58/NYCUThTD_o.png" width="1186"></p> 
<p> 和docker stats运行的值基本一致</p> 
<p style="margin-left:.0001pt;text-align:justify;">Jvm堆内存使用占比，我们可以根据cAdvisor提供的</p> 
<p style="margin-left:.0001pt;text-align:justify;">jvm_memory_used_bytes</p> 
<p style="margin-left:.0001pt;text-align:justify;">jvm_memory_max_bytes</p> 
<h4 style="text-align:justify;"><strong>执行接口，查看对应数据，验证告警信息。</strong></h4> 
<p> 等会我们执行增加jvm堆内存的接口，要看容器的内存使用，和jvm中堆占比都上升，知道堆内存占比100%发生OOM后，容器重启服务，过程中，会提示容器内存使用超过50%，堆内存使用超过80%</p> 
<p>1. 系统OOM 产生dump文件 之前第一步有配置</p> 
<p>2. 系统OOM 会立刻重启服务，保证不宕机，服务可用</p> 
<p>3. 容器内存超50% 告警</p> 
<p>4. 堆内存超80% 告警</p> 
<p>第一个：</p> 
<p>在docker下dump/temp发现 java_pid6.hprof 文件--后面讲</p> 
<p>第二个 服务立刻重启，并且输入dev/a  还是可以访问的</p> 
<p>第三个 收到告警</p> 
<p>这个过程，百分比是慢慢上升的可以通过docker stats/cadvisor看数据</p> 
<p><img alt="" height="434" src="https://images2.imgbox.com/c6/e6/hHsWjJaZ_o.png" width="819"><img alt="" height="683" src="https://images2.imgbox.com/c8/47/UPD6yyXP_o.png" width="715"></p> 
<p></p> 
<ul><li style="text-align:left;"><strong><strong><strong>继续监控</strong></strong></strong></li></ul> 
<p> 此时堆内存已经达到91 &gt; 80</p> 
<p><img alt="" height="533" src="https://images2.imgbox.com/9d/f8/YCZ2lAsq_o.png" width="1196"></p> 
<p> 容器内存也快达到，瓶颈</p> 
<p><img alt="" height="553" src="https://images2.imgbox.com/ac/30/1DHAP0gJ_o.png" width="856"></p> 
<p> <img alt="" height="463" src="https://images2.imgbox.com/e7/37/2I2fqifU_o.png" width="835"></p> 
<p></p> 
<ul><li style="text-align:justify;"><strong><strong>继续监控，突然会服务重新，出现OOM</strong></strong>，</li></ul> 
<p style="margin-left:.0001pt;text-align:justify;">也可以docker logs -f xxx查看日志，此时对象都释放掉了</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="448" src="https://images2.imgbox.com/d6/52/la31rlcg_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;">又回到服务初始容器内存占比和jvm堆使用占比</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">至此，完成了服务宕机告警，容器内存超50%告警，堆内存超80%告警，服务出现OOM后服务重启。</p> 
<h3 style="text-align:justify;"><strong>6 可视化监控的页面grafana</strong></h3> 
<p><strong>可以通过看大屏数据，感觉还挺牛的，可以自定义。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><a href="http://cc-tsp-01:3000/" rel="nofollow" title="http://xxxxx:3000/">http://xxxxx:3000/</a>    grafana可视化监控，是对prometheus采集的数据做大屏展示</p> 
<p style="margin-left:.0001pt;text-align:justify;">如：展示刚刚容器中jvm的一些指标信息  配置模板id：<span style="color:#fe2c24;">4701</span> 用过grafana你就知道了。相当于一个模版id</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p> 展示当前服务器中所有容器的cpu,内存，硬盘等使用情况</p> 
<p>模板id: <span style="color:#fe2c24;">116000</span> 是查看当前容器中各服务，cpu,内存使用情况。</p> 
<p><img alt="" height="645" src="https://images2.imgbox.com/01/b1/NykvQdJl_o.png" width="1200"></p> 
<p> 也可以对整个服务器做监控展示    模板id：<span style="color:#fe2c24;">8919</span></p> 
<p><img alt="" height="339" src="https://images2.imgbox.com/b2/4f/g0KJ7LJ2_o.png" width="1200"></p> 
<p>grafana的更多常用模板地址:<a href="https://grafana.com/grafana/dashboards/" rel="nofollow" title="Dashboards | Grafana Labs">Dashboards | Grafana Labs</a> </p> 
<p>目前监控的实现方案如上，有好的优化方案和新的监控点，告警点互相讨论。</p> 
<p></p> 
<h3>7 <strong>上面代码出现OOM，简单排查过程</strong></h3> 
<h3><strong>主要是分析dump文件</strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">通过写的代码，看到开启一个线程，不停的给ArrayList插入一个value是10M的Map</p> 
<p style="margin-left:.0001pt;text-align:justify;">在配置java启动中，我们把oom自动生成的dump文件拿出来</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="120" src="https://images2.imgbox.com/b2/fc/WzF2HCkW_o.png" width="1125"></p> 
<p>进到容器中把文件cp到宿主机</p> 
<p> 分析工具：MemoryAnalyzer  导入文件</p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;">1 进入Leak Suspects  2进入Dominator Tree</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="532" src="https://images2.imgbox.com/2f/e7/OZqYVxby_o.png" width="1200"></p> 
<p style="margin-left:.0001pt;text-align:justify;">进入Leak Suspects 点击detail  发现出现一堆HashMap没有回收，这和我们的代码问题一致</p> 
<p> <img alt="" height="762" src="https://images2.imgbox.com/aa/a1/fTAjuOwv_o.png" width="1200"></p> 
<p> 进入 Dominator Tree查看</p> 
<p></p> 
<p><img alt="" height="730" src="https://images2.imgbox.com/5a/ff/1XYDDyFL_o.png" width="1200"></p> 
<p style="margin-left:.0001pt;text-align:justify;">发现有很多的HashMap key 是递增的，value是一个10M的Byte[]</p> 
<p style="margin-left:.0001pt;text-align:justify;">代码都是自己写的。哈哈。</p> 
<p style="margin-left:.0001pt;text-align:justify;"> 定位代码：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="406" src="https://images2.imgbox.com/5f/ce/G35PXLuz_o.png" width="718"></p> 
<p></p> 
<p>服务地址：</p> 
<p style="margin-left:.0001pt;text-align:justify;">Promethues:   <a href="http://cc-tsp-01:9090" rel="nofollow" title="http://xxxx:9090">http://xxxx:9090</a></p> 
<p style="margin-left:.0001pt;text-align:justify;">Grafana: <a href="http://cc-tsp-01:3000" rel="nofollow" title="http://xxxx:3000">http://xxxx:3000</a></p> 
<p style="margin-left:.0001pt;text-align:justify;">Alertmanager: <a href="http://cc-tsp-01:19093" rel="nofollow" title="http://xxxx:19093">http://xxxx:19093</a></p> 
<p style="margin-left:.0001pt;text-align:justify;">cAdvisor的所有容器监控 <a href="http://cc-tsp-01:19190/containers/" rel="nofollow" title="http://xxxxx:19190/containers/">http://xxxxx:19190/containers/</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3069e6b141a7cb605a832b781b158c56/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C#调用OPC UA 解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5a8d4a87ea7badb569cd2d997961115e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一个基于element plus table 的表格封装组件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>