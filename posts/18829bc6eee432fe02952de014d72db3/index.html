<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Applink使用教程及原理解析 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Applink使用教程及原理解析" />
<meta property="og:description" content="今年11.11大促期间，各大电商平台都使出了浑身解数，吸引剁手族买买买。个推作为大促期间的消息推送服务商，为蘑菇街等电商APP在消息的稳定下发环节提供着强大支撑和保障。今年的11.11个推全球消息下发总量再创新高，超过274亿条。而2017年和2018年11.11当天个推推送的总下发量分别是超过110亿条和232亿条。
那么个推是如何在11.11期间支撑起数百亿级别的推送量，且使消息推送稳定率达到了99.9%的呢？这背后离不开个推强大智能的技术服务。而Applink 在推送中也发挥了一定的做用。它使消息不再局限于手机通知栏。开发者可以通过AppLink技术，让用户在点击短信、信息流或Banner后，直接跳转到APP指定页面，在打造流畅用户体验的同时实现了高效的转化，提升了消息推送的到达率与点击率。本文将着重分析一下个推Applink的技术原理和使用方式。
简介
通过 Link这个单词我们可以看出这是一种链接，使用此链接可以直接跳转到 APP。Applink常用于应用拉活、跨应用启动、推送通知启动等场景。
流程
在AS 上其实已经有详细的使用步骤解析了，这里给大家普及下 。
快速点击 shift 两次，输入 APPLink 即可找到 AS 提供的集成教程。详细教程可参加AS，总共分为 4 步：
add URL intent filters
创建一个 URL 或者也可以点击 “How it works” 按钮
Add logic to handle the intent
选择通过 applink 启动的入口 activity。点击完成后，AS 会自动在两个地方进行修改，详情如下：
（一）
&lt;activity android:name=&#34;.TestActivity&#34;&gt; &lt;intent-filter&gt; &lt;action android:name=&#34;android.intent.action.VIEW&#34; /&gt; &lt;category android:name=&#34;android.intent.category.DEFAULT&#34; /&gt; &lt;category android:name=&#34;android.intent.category.BROWSABLE&#34; /&gt; &lt;data android:scheme=&#34;http&#34; android:host=&#34;geyan.getui.com&#34; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 此处多了一个 data，看到这个 data 标签，我们可以大胆的猜测，这个 applink可能是一种隐式的APP启动方式。
（二）
protected void onCreate(@Nullable Bundle savedInstanceState) { super." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/18829bc6eee432fe02952de014d72db3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-11-14T01:04:38+08:00" />
<meta property="article:modified_time" content="2019-11-14T01:04:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Applink使用教程及原理解析</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>今年11.11大促期间，各大电商平台都使出了浑身解数，吸引剁手族买买买。个推作为大促期间的消息推送服务商，为蘑菇街等电商APP在消息的稳定下发环节提供着强大支撑和保障。<strong>今年的11.11个推全球消息下发总量再创新高，</strong><strong>超过</strong><strong>274</strong><strong>亿条</strong>。而2017年和2018年11.11当天个推推送的总下发量分别是超过110亿条和232亿条。</p> 
<p> </p> 
<p>那么个推是如何在11.11期间支撑起数百亿级别的推送量，且使消息推送稳定率达到了99.9%的呢？这背后离不开个推强大智能的技术服务。而Applink 在推送中也发挥了一定的做用。它使消息不再局限于手机通知栏。开发者可以通过AppLink技术，让用户在点击短信、信息流或Banner后，直接跳转到APP指定页面，在打造流畅用户体验的同时实现了高效的转化，提升了消息推送的到达率与点击率。<strong>本文将着重分析一下个推Applink的技术原理和使用方式。</strong></p> 
<p> </p> 
<p> </p> 
<p><strong>简介</strong></p> 
<p>通过 Link这个单词我们可以看出这是一种链接，使用此链接可以直接跳转到 APP。Applink常用于应用拉活、跨应用启动、推送通知启动等场景。</p> 
<p> </p> 
<p><strong>流程</strong></p> 
<p>在AS 上其实已经有详细的使用步骤解析了，这里给大家普及下 。</p> 
<p> </p> 
<p>快速点击 shift 两次，输入 APPLink 即可找到 AS 提供的集成教程。详细教程可参加AS，总共分为 4 步：</p> 
<p> </p> 
<p><strong>add URL intent filters</strong></p> 
<p>创建一个 URL </p> 
<p><img alt="" class="has" height="1" src="https://images2.imgbox.com/0f/c1/kg20QkoG_o.gif" width="1"></p> 
<p>或者也可以点击 “How it works” 按钮</p> 
<p><strong>Add logic to handle the intent</strong></p> 
<p>选择通过 applink 启动的入口 activity。点击完成后，AS 会自动在两个地方进行修改，详情如下：</p> 
<p>（一）</p> 
<p> </p> 
<pre><code> &lt;activity android:name=".TestActivity"&gt;</code><code>            &lt;intent-filter&gt;</code><code>                &lt;action android:name="android.intent.action.VIEW" /&gt;</code>
<code>                &lt;category android:name="android.intent.category.DEFAULT" /&gt;</code><code>                &lt;category android:name="android.intent.category.BROWSABLE" /&gt;</code>
<code>                &lt;data</code><code>                    android:scheme="http"</code><code>                    android:host="geyan.getui.com" /&gt;</code><code>            &lt;/intent-filter&gt;</code><code>        &lt;/activity&gt;</code></pre> 
<p> </p> 
<p> </p> 
<p>此处多了一个 data，看到这个 data 标签，我们可以大胆的猜测，这个 applink可能是一种隐式的APP启动方式。</p> 
<p> </p> 
<p>（二）</p> 
<p> </p> 
<pre><code>    protected void onCreate(@Nullable Bundle savedInstanceState) {<!-- --></code><code>        super.onCreate(savedInstanceState);</code><code>        setContentView(R.layout.activity_test);</code><code>        // ATTENTION: This was auto-generated to handle app links.</code><code>        Intent appLinkIntent = getIntent();</code><code>        String appLinkAction = appLinkIntent.getAction();</code><code>        Uri appLinkData = appLinkIntent.getData();</code><code>    }</code></pre> 
<p> </p> 
<p> </p> 
<p>applink 的值即为之前配置的 url 链接，此处配置是为接收数据所用，不再予以赘述。</p> 
<p> </p> 
<p><strong>Associate website</strong></p> 
<p>这一步最为关键：开发者需要根据 APP 证书生成一个 json 文件，这样可以保证用户在 APP 安装的时候，通过安卓系统的校验。选择你的线上证书，然后点击生成会得到一个 assetlinks.json 的文件，需要把这个文件放到服务器指定的目录下。</p> 
<p><img alt="" class="has" height="1" src="https://images2.imgbox.com/aa/bc/p0ULkTnF_o.gif" width="1"></p> 
<p>基于安全原因，这个文件必须通过 SSL 的 GET 请求获取，JSON 格式如下：</p> 
<ul><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li></ul> 
<pre><code>[{<!-- --></code><code>  "relation": ["delegate_permission/common.handle_all_urls"],</code><code>  "target": {<!-- --></code><code>    "namespace": "android_app",</code><code>    "package_name": "com.lenny.myapplication",</code><code>    "sha256_cert_fingerprints":</code><code>    ["E7:E8:47:2A:E1:BF:63:F7:A3:F8:D1:A5:E1:A3:4A:47:88:0F:B5:F3:EA:68:3F:5C:D8:BC:0B:BA:3E:C2:D2:61"]</code><code>  }</code><code>}]</code></pre> 
<p>sha256_cert_fingerprints 这个参数可以通过 keytool 命令获取。最后把这个文件上传到 你配置的地址/.well-know/statements/json。为了避免今后每个 app 链接请求都需要访问网络，安卓只会在 app 安装的时候检查这个文件。如果你能在请求 https://yourdomain.com/.well-known/statements.json 的时候看到这个文件（替换成自己的域名），则说明服务端的配置是成功的。目前我们可以通过 http 获得这个文件，但是在M最终版里只能通过 HTTPS 验证。确保你的 web 站点支持 HTTPS 请求。 若一个host需要配置多个app，那么assetlinks.json需要添加多个app的信息。若一个 app 需要配置多个 host，每个 host 的 .well-known 下都要配置assetlinks.json。url 的后缀是不是一定要写成 /.well-know/statements/json 格式呢？后续讲原理的时候我们会涉及到，这里先不展开。</p> 
<p> </p> 
<p>###Test device我们操作的最终目的是为了拿到一个 URL。大多数情况下，我们会在 url 中拼接一些参数，比如</p> 
<p> </p> 
<ul><li> </li></ul> 
<pre class="has"><code>https://yourdomain.com/products/123?coupon=save90</code></pre> 
<p>其中 ./products/123?coupon=save90 是我们之前在第二步填写的 path。测试方法比较多样，可以使用通知、短信来进行测试，也可以使用 adb 进行直接模拟。我这边选择 adb 模拟。</p> 
<p> </p> 
<ul><li> </li><li> </li><li> </li><li> </li></ul> 
<pre><code>adb shell am start</code><code>-W -a android.intent.action.VIEW</code><code>-d "https://yourdomain.com/products/123?coupon=save90"</code><code>[包名]</code></pre> 
<p>使用这个命令就会自动打开 APP。前提是 yourdomain.com 网站上存在了 web-app 关联文件。</p> 
<p> </p> 
<p> </p> 
<p><strong>原理</strong></p> 
<p>上述操作相对比较简单，依葫芦画瓢就行。下面讲些深层次的东西：不仅要知道要会用，还得知道为什么可以这么用，不然和咸鱼有啥区别？</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/c2/8a/6xSNkQ1M_o.png"></p> 
<p>上文也提到了我们配置的域名是在 activity 的 data 标签里面，因此我们可以认为 applink 是一种隐式启动方式，应用安装的时候根据 data 的内容到这个网页下面去获取 assetlinks.json 进行校验，如果符合条件则把 这个 url 保存在本地，当点击 webview 或者短信里面的 url的时候，系统会自动与本地库中的域名相匹配， 如果匹配失败则会被自动认为是 deeplink 的连接。也就说在第一次安装 APP 的时候安卓系统是会去验证data 标签下面的域名，那我们可以推理出安装APP的底层实现其实是在源码中 PackageManagerService进行的。以下方法可以帮助你快速找到校验 APPLink 的入口 PackageManagerService 的 installPackageLI。</p> 
<p> </p> 
<p>PackageMmanagerService.class</p> 
<ul><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li></ul> 
<pre><code>private void installPackageLI(InstallArgs args, PackageInstalledInfo res) {<!-- --></code><code>    final int installFlags = args.installFlags;</code><code>    &lt;!--开始验证applink--&gt;</code><code>    startIntentFilterVerifications(args.user.getIdentifier(), replace, pkg);</code><code>    ...</code><code>    </code><code>    }</code><code>    </code><code>    private void startIntentFilterVerifications(int userId, boolean replacing,</code><code>        PackageParser.Package pkg) {<!-- --></code><code>    ...</code>
<code>    mHandler.removeMessages(START_INTENT_FILTER_VERIFICATIONS);</code><code>    final Message msg = mHandler.obtainMessage(START_INTENT_FILTER_VERIFICATIONS);</code><code>    msg.obj = new IFVerificationParams(pkg, replacing, userId, verifierUid);</code><code>    mHandler.sendMessage(msg);</code><code>}</code></pre> 
<p>可以看到这边发送了一个 message 为 START_INTENT_FILTER_VERIFICATIONS 的 handler 消息，在 handle 的 run 方法里又会接着调用 verifyIntentFiltersIfNeeded。</p> 
<pre><code>private void verifyIntentFiltersIfNeeded(int userId, int verifierUid, boolean replacing,</code><code>        PackageParser.Package pkg) {<!-- --></code><code>        ...</code><code>        &lt;!--检查是否有Activity设置了AppLink--&gt;</code><code>        final boolean hasDomainURLs = hasDomainURLs(pkg);</code><code>        if (!hasDomainURLs) {<!-- --></code><code>            if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,</code><code>                    "No domain URLs, so no need to verify any IntentFilter!");</code><code>            return;</code><code>        }</code><code>        &lt;!--是否autoverigy--&gt;</code><code>        boolean needToVerify = false;</code><code>        for (PackageParser.Activity a : pkg.activities) {<!-- --></code><code>            for (ActivityIntentInfo filter : a.intents) {<!-- --></code><code>            &lt;!--needsVerification是否设置autoverify --&gt;</code><code>                if (filter.needsVerification() &amp;&amp; needsNetworkVerificationLPr(filter)) {<!-- --></code><code>                    needToVerify = true;</code><code>                    break;</code><code>                }</code><code>            }</code><code>        }</code><code>      &lt;!--如果有搜集需要验证的Activity信息及scheme信息--&gt;</code><code>        if (needToVerify) {<!-- --></code><code>            final int verificationId = mIntentFilterVerificationToken++;</code><code>            for (PackageParser.Activity a : pkg.activities) {<!-- --></code><code>                for (ActivityIntentInfo filter : a.intents) {<!-- --></code><code>                    if (filter.handlesWebUris(true) &amp;&amp; needsNetworkVerificationLPr(filter)) {<!-- --></code><code>                        if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,</code><code>                                "Verification needed for IntentFilter:" + filter.toString());</code><code>                        mIntentFilterVerifier.addOneIntentFilterVerification(</code><code>                                verifierUid, userId, verificationId, filter, packageName);</code><code>                        count++;</code><code>                    }    }   } }  }</code><code>   &lt;!--开始验证--&gt;</code><code>    if (count &gt; 0) {<!-- --></code><code>        mIntentFilterVerifier.startVerifications(userId);</code><code>    } </code><code>}</code></pre> 
<p>安卓底层在安装APP时会对 APPLink 进行检查、搜集、验证，判断其是否为http/https，以及是否有 flag 为 Intent.ACTION_DEFAULT与Intent.ACTION_VIEW 的参数，接着便开启验证。</p> 
<p>PMS#IntentVerifierProxy.class​​​​​​​</p> 
<pre><code>public void startVerifications(int userId) {<!-- --></code><code>        ...</code><code>            sendVerificationRequest(userId, verificationId, ivs);</code><code>        }</code><code>        mCurrentIntentFilterVerifications.clear();</code><code>    }</code>
<code>    private void sendVerificationRequest(int userId, int verificationId,</code><code>            IntentFilterVerificationState ivs) {<!-- --></code>
<code>        Intent verificationIntent = new Intent(Intent.ACTION_INTENT_FILTER_NEEDS_VERIFICATION);</code><code>        verificationIntent.putExtra(</code><code>                PackageManager.EXTRA_INTENT_FILTER_VERIFICATION_ID,</code><code>                verificationId);</code><code>        verificationIntent.putExtra(</code><code>                PackageManager.EXTRA_INTENT_FILTER_VERIFICATION_URI_SCHEME,</code><code>                getDefaultScheme());</code><code>        verificationIntent.putExtra(</code><code>                PackageManager.EXTRA_INTENT_FILTER_VERIFICATION_HOSTS,</code><code>                ivs.getHostsString());</code><code>        verificationIntent.putExtra(</code><code>                PackageManager.EXTRA_INTENT_FILTER_VERIFICATION_PACKAGE_NAME,</code><code>                ivs.getPackageName());</code><code>        verificationIntent.setComponent(mIntentFilterVerifierComponent);</code><code>        verificationIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);</code>
<code>        UserHandle user = new UserHandle(userId);</code><code>        mContext.sendBroadcastAsUser(verificationIntent, user);</code><code>    }</code></pre> 
<p>目前 Android是通过发送一个广播来进行验证的，也就是说，这是个异步的过程，验证是需要耗时的（网络请求），发出去的广播会被 IntentFilterVerificationReceiver 接收到。这个类又会再次 start DirectStatementService,在这个 service 里面又会去调用 DirectStatementRetriever 类。在此类的 retrieveStatementFromUrl 方法中才是真正请求网络的地方。</p> 
<p>DirectStatementRetriever.class​​​​​​​</p> 
<pre><code>  @Override</code><code>    public Result retrieveStatements(AbstractAsset source) throws AssociationServiceException {<!-- --></code><code>        if (source instanceof AndroidAppAsset) {<!-- --></code><code>            return retrieveFromAndroid((AndroidAppAsset) source);</code><code>        } else if (source instanceof WebAsset) {<!-- --></code><code>            return retrieveFromWeb((WebAsset) source);</code><code>        } else {<!-- --></code><code>            throw new AssociationServiceException("Namespace is not supported.");</code><code>        }</code><code>    }</code><code>  private Result retrieveFromWeb(WebAsset asset)</code><code>            throws AssociationServiceException {<!-- --></code><code>        return retrieveStatementFromUrl(computeAssociationJsonUrl(asset), MAX_INCLUDE_LEVEL, asset);</code><code>    }</code><code>    private String computeAssociationJsonUrl(WebAsset asset) {<!-- --></code><code>        try {<!-- --></code><code>            return new URL(asset.getScheme(), asset.getDomain(), asset.getPort(),</code><code>                    WELL_KNOWN_STATEMENT_PATH)</code><code>                    .toExternalForm();</code><code>        } catch (MalformedURLException e) {<!-- --></code><code>            throw new AssertionError("Invalid domain name in database.");</code><code>        }</code><code>    }</code><code>private Result retrieveStatementFromUrl(String urlString, int maxIncludeLevel,</code><code>                                        AbstractAsset source)</code><code>        throws AssociationServiceException {<!-- --></code><code>    List&lt;Statement&gt; statements = new ArrayList&lt;Statement&gt;();</code><code>    if (maxIncludeLevel &lt; 0) {<!-- --></code><code>        return Result.create(statements, DO_NOT_CACHE_RESULT);</code><code>    }</code>
<code>    WebContent webContent;</code><code>    try {<!-- --></code><code>        URL url = new URL(urlString);</code><code>        if (!source.followInsecureInclude()</code><code>                &amp;&amp; !url.getProtocol().toLowerCase().equals("https")) {<!-- --></code><code>            return Result.create(statements, DO_NOT_CACHE_RESULT);</code><code>        }</code><code>        &lt;!--通过网络请求获取配置--&gt;</code><code>        webContent = mUrlFetcher.getWebContentFromUrlWithRetry(url,</code><code>                HTTP_CONTENT_SIZE_LIMIT_IN_BYTES, HTTP_CONNECTION_TIMEOUT_MILLIS,</code><code>                HTTP_CONNECTION_BACKOFF_MILLIS, HTTP_CONNECTION_RETRY);</code><code>    } catch (IOException | InterruptedException e) {<!-- --></code><code>        return Result.create(statements, DO_NOT_CACHE_RESULT);</code><code>    }</code><code>    </code><code>    try {<!-- --></code><code>        ParsedStatement result = StatementParser</code><code>                .parseStatementList(webContent.getContent(), source);</code><code>        statements.addAll(result.getStatements());</code><code>        &lt;!--如果有一对多的情况，或者说设置了“代理”，则循环获取配置--&gt;</code><code>        for (String delegate : result.getDelegates()) {<!-- --></code><code>            statements.addAll(</code><code>                    retrieveStatementFromUrl(delegate, maxIncludeLevel - 1, source)</code><code>                            .getStatements());</code><code>        }</code><code>        &lt;!--发送结果--&gt;</code><code>        return Result.create(statements, webContent.getExpireTimeMillis());</code><code>    } catch (JSONException | IOException e) {<!-- --></code><code>        return Result.create(statements, DO_NOT_CACHE_RESULT);</code><code>    }</code><code>}</code></pre> 
<p>以上讲解我们可以得出一个结论，即Applink的本质是通过 HTTPURLConnection 去发起请求。前文还留了个问题，url 的后缀是不是一定要写成是不是一定要写成/.well-known/assetlinks.json 格式呢？看到这里相信大家都已经明白了，格式一定要这么写！！格式就是 WELL_KNOWN_STATEMENT_PATH 参数！</p> 
<p> </p> 
<pre class="has"><code>    private static final String WELL_KNOWN_STATEMENT_PATH = "/.well-known/assetlinks.json";</code></pre> 
<p> </p> 
<p> </p> 
<p><strong>缺点</strong></p> 
<p>1. 只能在 Android M 系统上支持 在配置好了app对Applink的支持之后，只有运行Android M的用户才能使Applink正常工作。Android M之前版本的用户点击链接无法直接进入app，而是回到浏览器的web页面。</p> 
<p> </p> 
<p>2. 要使用App Links开发者必须维护一个与app相关联的网站 对于小的开发者来说这个有点困难，因为他们没有能力为app维护一个网站，但是它们仍然希望通过web链接获得流量。</p> 
<p> </p> 
<p>3. 对 ink 域名不太友善 在测试中发现，国内各大厂商对 .ink 域名不太友善，很多厂商仅支持 .com 域名，却不支持 .ink 域名。</p> 
<p> </p> 
<p>（调研结果仅供参考）</p> 
<table><tbody><tr><td colspan="1" rowspan="1"> <p>机型</p> </td><td colspan="1" rowspan="1"> <p>版本</p> </td><td colspan="1" rowspan="1"> <p> </p> <p>     是否识别ink</p> <p> </p> </td><td colspan="1" rowspan="1"> <p> </p> <p>是否识别</p> <p>com</p> <p> </p> </td></tr><tr><td colspan="1" rowspan="1"> <p>小米</p> </td><td colspan="1" rowspan="1"> <p>MI6 Android 8.0 MIUI 9.5</p> </td><td colspan="1" rowspan="1"> <p>否</p> </td><td colspan="1" rowspan="1"> <p>是</p> </td></tr><tr><td colspan="1" rowspan="1"> <p>小米</p> </td><td colspan="1" rowspan="1"> <p>MI5 Android 7.0 MIUI 9.5</p> </td><td colspan="1" rowspan="1"> <p>否</p> </td><td colspan="1" rowspan="1"> <p>是</p> </td></tr><tr><td colspan="1" rowspan="1"> <p>魅族</p> </td><td colspan="1" rowspan="1"> <p>PRO 7 Android 7.0 Flyme 6.1.3.1A</p> </td><td colspan="1" rowspan="1"> <p>否</p> </td><td colspan="1" rowspan="1"> <p>是</p> </td></tr><tr><td colspan="1" rowspan="1"> <p>三星</p> </td><td colspan="1" rowspan="1"> <p>S8 Android 7.0</p> </td><td colspan="1" rowspan="1"> <p> </p> <p>是，弹框    </p> <p> </p> </td><td colspan="1" rowspan="1"> <p>是</p> </td></tr><tr><td colspan="1" rowspan="1"> <p>华为</p> </td><td colspan="1" rowspan="1"> <p>HonorV10 Android 8.0 EMUI 8.0</p> </td><td colspan="1" rowspan="1"> <p>是</p> </td><td colspan="1" rowspan="1"> <p>是</p> </td></tr><tr><td colspan="1" rowspan="1"> <p>oppo</p> </td><td colspan="1" rowspan="1"> <p>R11s Android 7.1.1 ColorOS 3.2</p> </td><td colspan="1" rowspan="1"> <p>是</p> </td><td colspan="1" rowspan="1"> <p>是</p> </td></tr><tr><td colspan="1" rowspan="1"> <p>oppo</p> </td><td colspan="1" rowspan="1"> <p>A59s Android 5.1 ColorOS 3.0</p> </td><td colspan="1" rowspan="1"> <p>是,不能跳转到app</p> </td><td colspan="1" rowspan="1"> <p>是,不能跳转到app</p> </td></tr><tr><td colspan="1" rowspan="1"> <p>vivo</p> </td><td colspan="1" rowspan="1"> <p>X6Plus A Android 5.0.2 Funtouch OS_2.5</p> </td><td colspan="1" rowspan="1"> <p>否</p> </td><td colspan="1" rowspan="1"> <p> </p> <p>是</p> <p> </p> </td></tr><tr><td colspan="1" rowspan="1"> <p>vivo</p> </td><td colspan="1" rowspan="1"> <p>767 Android 6.0 Funtouch OS_2.6</p> </td><td colspan="1" rowspan="1"> <p>是,不能跳转到app</p> </td><td colspan="1" rowspan="1"> <p>是,不能跳转到app</p> </td></tr><tr><td colspan="1" rowspan="1"> <p>vivo</p> </td><td colspan="1" rowspan="1"> <p>X9 Android 7.1.1 Funtouch OS_3.1</p> </td><td colspan="1" rowspan="1"> <p>是,不能跳转到app</p> </td><td colspan="1" rowspan="1"> <p>是,不能跳转到app</p> </td></tr></tbody></table> 
<p> </p> 
<p><strong>总结</strong></p> 
<p>通过使用Applink，我们个推拓宽了交互场景，对App的启动有了一个更多元化的选择，缩短了App的启动路径，能够使用户更快地启动App；同时，因为Applink的内在逻辑已经在 Android framework 层兼容，这使得我们推送服务的准确性也得到了一定的保障。未来，个推也将持续优化消息推送服务，并进一步提高推送的到达率与点击率，以满足一些实时性要求更高更复杂的业务场景需求。</p> 
<p> </p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/9d/54/j4tnkJdE_o.png"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a2b7532bcf3e296f51ccf8d0940fb567/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Nvidia Xavier 命令 操作 链接 备忘</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/afe546aa9c944ced214d7cf321ea98d3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">element-ui上传组件（el-upload）单文件上传，单选文件 覆盖已有文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>