<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【软件测试】白盒测试与黑盒测试 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【软件测试】白盒测试与黑盒测试" />
<meta property="og:description" content="白盒测试与黑盒测试 测试用例定义生成的基本准测设计步骤作用测试数据和测试用例的区别 黑盒测试定义优点缺点黑盒测试的实施过程等价类划分法边界值分析法错误推测法因果图判定表判定表例题 白盒测试介绍覆盖程度基本路径覆盖程序流程图简化成控制流图计算圈复杂度导出测试用例准备测试用例 例题1) 绘制控制流图2）列出所有决定及其条件分支3） 使用判定/条件覆盖测试方法来设计测试用例4） 请使用条件组合测试方法来设计测试用例5） 请使用路径覆盖方法来设计测试用例6） 请使用基本路径测试方法来设计测试用例 本文介绍白盒测试与黑盒测试有关内容，并伴随例子讲解 测试用例 测试用例就是一个文档，描述输入、动作、或者时间和一个期望的结果，其目的是确定应用程序的某个特性是否正常的工作。
软件测试用例的基本要素包括测试用例编号、测试标题、重要级别、测试输入、操作步骤、预期结果。
定义 满足特定目的的测试数据、测试代码、测试规程的集合
是发现软件缺陷的最小测试执行单元
有特殊的书写标准和基本原则
生成的基本准测 代表性：能够代表并覆盖各种输入数据、操作和环境设置等
可判定性：测试结果的正确性是可判定的
可再现性：对同样的测试用例，系统的执行结果应当是相同的
设计步骤 为测试需求确定测试用例-&gt;为测试用例确定输入输出-&gt;编写测试用例-&gt;评审测试用例-&gt;跟踪测试用例
作用 避免盲目测试；估算测试工作量；减少回归测试的复杂程度；方便书写软件测试缺陷报告；实施不同级别的测试
测试数据和测试用例的区别 测试数据：被用来测试系统的输入数据（输入）
测试用例：被测试系统的输入和根据规格说明书预测的该系统的输出（输入&amp;输出）
黑盒测试 定义 黑盒测试又称功能测试、数据驱动测试或基于规格说明书的测试，是一种从用户观点出发的测试。
等价性划分、边值分析、组合测试、随机测试和误差猜测、场景测试
黑盒测试主要测试的错误类型有：
①不正确或遗漏的功能；
②接口、界面错误；
③性能错误；
④数据结构或外部数据访问错误；
⑤初始化或终止条件错误等等。
优点 （1）有针对性地寻找问题，并且定位问题更准确。
（2）黑盒测试可以证明产品是否达到用户要求的功能，符合用户的工作要求。
（3）黑盒测试与软件如何实现无关，如果实现发生变化，黑盒测试用例仍然可用（可重用性，面向回归测试）
（4）测试用例开发可以与软件开发同时进行，可节省软件开发时间，通过软件的用例就可以设计出大部分黑盒测试用例。
（5）能重复执行相同的动作，测试工作中最枯燥的部分可交由机器完成。
缺点 （1）需要充分了解待测试软件产品所用到的各项技术，测试人员需要具有较多经验。
（2）测试用例数量较大
（3）测试用例可能产生很多冗余
（4）功能性测试的覆盖范围不可能达到100%
（5）在测试过程中很多是手工测试操作。
（6）测试人员要负责大量文档、报表的编制和整理工作。
黑盒测试的实施过程 （1）测试计划阶段
（2）测试设计阶段
依据程序需求规格说明书或用户手册，按照一定规范化的方法进行软件功能划分和设计测试用例。
（3）测试执行阶段
按照设计的测试用例执行测试;
自由测试(作为测试用例测试的补充)。
（4）测试总结阶段
等价类划分法 等价类是指某个输入域的子集合。 在该子集合中,各个输入数据对于揭露程序中的错误都是等效的。
并合理地假定：测试某等价类的代表值就等于对这一类其它值的测试，因此每个等价类取一个数据就行
有效等价类
是指对于程序的规格说明来说是合理的,有意义的输入数据构成的集合。利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能。一般只有规定输入数据的一组值且对每一个输入值分别处理的时候才会有N个有效等价类和一个无效等价类，其他规则一般都只有一个有效等价类 无效等价类
与有效等价类的定义恰巧相反。无效等价类指对程序的规格说明是不合理的或无意义的输入数据所构成的集合。对于具体的问题，无效等价类至少应有一个，也可能有多个。 示例：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/9084b066e59bf77f52e428a2f64324d3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-02T22:58:22+08:00" />
<meta property="article:modified_time" content="2023-06-02T22:58:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【软件测试】白盒测试与黑盒测试</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>白盒测试与黑盒测试</h4> 
 <ul><li><a href="#_2" rel="nofollow">测试用例</a></li><li><ul><li><a href="#_6" rel="nofollow">定义</a></li><li><a href="#_10" rel="nofollow">生成的基本准测</a></li><li><a href="#_14" rel="nofollow">设计步骤</a></li><li><a href="#_16" rel="nofollow">作用</a></li><li><a href="#_19" rel="nofollow">测试数据和测试用例的区别</a></li></ul> 
  </li><li><a href="#_22" rel="nofollow">黑盒测试</a></li><li><ul><li><a href="#_23" rel="nofollow">定义</a></li><li><a href="#_34" rel="nofollow">优点</a></li><li><a href="#_42" rel="nofollow">缺点</a></li><li><a href="#_50" rel="nofollow">黑盒测试的实施过程</a></li><li><a href="#_61" rel="nofollow">等价类划分法</a></li><li><a href="#_87" rel="nofollow">边界值分析法</a></li><li><a href="#_131" rel="nofollow">错误推测法</a></li><li><a href="#_148" rel="nofollow">因果图</a></li><li><a href="#_182" rel="nofollow">判定表</a></li><li><ul><li><a href="#_198" rel="nofollow">判定表例题</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_216" rel="nofollow">白盒测试</a></li><li><ul><li><a href="#_217" rel="nofollow">介绍</a></li><li><a href="#_231" rel="nofollow">覆盖程度</a></li><li><ul><li><a href="#_275" rel="nofollow">基本路径覆盖</a></li><li><ul><li><a href="#_285" rel="nofollow">程序流程图简化成控制流图</a></li><li><a href="#_295" rel="nofollow">计算圈复杂度</a></li><li><a href="#_308" rel="nofollow">导出测试用例</a></li><li><a href="#_317" rel="nofollow">准备测试用例</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_351" rel="nofollow">例题</a></li><li><ul><li><a href="#1__363" rel="nofollow">1) 绘制控制流图</a></li><li><a href="#2_367" rel="nofollow">2）列出所有决定及其条件分支</a></li><li><a href="#3__372" rel="nofollow">3） 使用判定/条件覆盖测试方法来设计测试用例</a></li><li><a href="#4__375" rel="nofollow">4） 请使用条件组合测试方法来设计测试用例</a></li><li><a href="#5__378" rel="nofollow">5） 请使用路径覆盖方法来设计测试用例</a></li><li><a href="#6__381" rel="nofollow">6） 请使用基本路径测试方法来设计测试用例</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<br> 本文介绍白盒测试与黑盒测试有关内容，并伴随例子讲解 
<p></p> 
<h2><a id="_2"></a>测试用例</h2> 
<p>测试用例就是一个文档，描述输入、动作、或者时间和一个期望的结果，其目的是确定应用程序的某个特性是否正常的工作。<br> 软件测试用例的基本要素包括测试用例编号、测试标题、重要级别、测试输入、操作步骤、预期结果。</p> 
<h3><a id="_6"></a>定义</h3> 
<p>满足特定目的的测试数据、测试代码、测试规程的集合<br> 是发现软件缺陷的最小测试执行单元<br> 有特殊的书写标准和基本原则</p> 
<h3><a id="_10"></a>生成的基本准测</h3> 
<p>代表性：能够代表并覆盖各种输入数据、操作和环境设置等<br> 可判定性：测试结果的正确性是可判定的<br> 可再现性：对同样的测试用例，系统的执行结果应当是相同的</p> 
<h3><a id="_14"></a>设计步骤</h3> 
<p>为测试需求确定测试用例-&gt;为测试用例确定输入输出-&gt;编写测试用例-&gt;评审测试用例-&gt;跟踪测试用例</p> 
<h3><a id="_16"></a>作用</h3> 
<p>避免盲目测试；估算测试工作量；减少回归测试的复杂程度；方便书写软件测试缺陷报告；实施不同级别的测试</p> 
<h3><a id="_19"></a>测试数据和测试用例的区别</h3> 
<p>测试数据：被用来测试系统的输入数据（输入）<br> 测试用例：被测试系统的输入和根据规格说明书预测的该系统的输出（输入&amp;输出）</p> 
<h2><a id="_22"></a>黑盒测试</h2> 
<h3><a id="_23"></a>定义</h3> 
<p>黑盒测试又称功能测试、数据驱动测试或基于规格说明书的测试，是一种<strong>从用户观点出发的测试。</strong></p> 
<p>等价性划分、边值分析、组合测试、随机测试和误差猜测、场景测试</p> 
<p>黑盒测试主要测试的错误类型有：<br> ①不正确或遗漏的功能；<br> ②接口、界面错误；<br> ③性能错误；<br> ④数据结构或外部数据访问错误；<br> ⑤初始化或终止条件错误等等。</p> 
<h3><a id="_34"></a>优点</h3> 
<p>（1）有针对性地寻找问题，并且定位问题更准确。<br> （2）黑盒测试可以证明产品是否达到用户要求的功能，符合用户的工作要求。<br> （3）黑盒测试与软件如何实现无关，如果实现发生变化，黑盒测试用例仍然可用（可重用性，面向回归测试）<br> （4）测试用例开发可以与软件开发同时进行，可节省软件开发时间，通过软件的用例就可以设计出大部分黑盒测试用例。<br> （5）能重复执行相同的动作，测试工作中最枯燥的部分可交由机器完成。</p> 
<h3><a id="_42"></a>缺点</h3> 
<p>（1）需要充分了解待测试软件产品所用到的各项技术，测试人员需要具有较多经验。<br> （2）测试用例数量较大<br> （3）测试用例可能产生很多冗余<br> （4）功能性测试的覆盖范围不可能达到100%<br> （5）在测试过程中很多是手工测试操作。<br> （6）测试人员要负责大量文档、报表的编制和整理工作。</p> 
<h3><a id="_50"></a>黑盒测试的实施过程</h3> 
<p>（1）测试计划阶段<br> （2）测试设计阶段<br> 　　 依据程序需求规格说明书或用户手册，按照一定规范化的方法进行<strong>软件功能划分</strong>和<strong>设计测试用例</strong>。<br> （3）测试执行阶段<br> 　　按照设计的测试用例执行测试;<br> 　　自由测试(作为测试用例测试的补充)。<br> （4）测试总结阶段</p> 
<h3><a id="_61"></a>等价类划分法</h3> 
<p>等价类是指某个输入域的子集合。 在该子集合中,各个输入数据对于揭露程序中的错误都是等效的。<br> 并合理地假定：测试某<strong>等价类的代表值就等于对这一类其它值的测试，因此每个等价类取一个数据就行</strong></p> 
<p>有效等价类</p> 
<ul><li>是指对于程序的规格说明来说是合理的,有意义的输入数据构成的集合。</li><li>利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能。</li><li>一般只有规定输入数据的一组值且对每一个输入值分别处理的时候才会有<strong>N个有效等价类和一个无效等价类</strong>，其他规则一般都只有一个有效等价类</li></ul> 
<p>无效等价类</p> 
<ul><li>与有效等价类的定义恰巧相反。</li><li>无效等价类指对程序的规格说明是不合理的或无意义的输入数据所构成的集合。</li><li>对于具体的问题，无效等价类至少应有一个，也可能有多个。</li></ul> 
<p>示例：<br> 设有一个档案管理系统，要求用户输入以年月表示的日期。假设日期限定在1990年1月~2049年12月，并规定日期由6位数字字符组成，前4位表示年，后2位表示月。现用<strong>等价类划分法设计测试用例，来测试程序的“日期检查功能”。</strong><br> 1）划分等价类并编号<br> <img src="https://images2.imgbox.com/4a/7f/ya7yahtB_o.png" alt="在这里插入图片描述"><br> 2)设计测试用例，以便覆盖所有的有效等价类在表中列出了3个有效等价类，编号分别为①、⑤、⑧，设计的测试用例如下：<br> <img src="https://images2.imgbox.com/83/51/f5DEkU5v_o.png" alt="在这里插入图片描述"><br> 3）为每一个无效等价类设计一个测试用例，设计结果如下：</p> 
<p><img src="https://images2.imgbox.com/e7/1e/Fzq1sx2q_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_87"></a>边界值分析法</h3> 
<ul><li>是对等价类划分的补充</li><li>边界值分析不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件。</li><li>边界值分析不仅考虑输入条件，还要考虑输出空间产生的测试情况</li></ul> 
<p>边界值分析法用例设计原则：<br> 1）如果输入条件规定了值的范围,则应取刚达到这个范围的边界的值,以及刚刚超越这个范围边界的值作为测试输入数据。</p> 
<p>例如，如果程序的规格说明中规定：“重量在10公斤至50公斤范围内的邮件，其邮费计算公式为……”。作为测试用例，我们应取10及50，还应取10.01,49.99,9.99及50.01等。</p> 
<p>2）如果输入条件规定了值的个数,则用最大个数,最小个数,比最小个数少一,比最大个数多一的数作为测试数据。<br> 比如，一个输入文件应包括1~255个记录，则测试用例可取1和255，还应取0及256等。</p> 
<p>3）将规则1）和2）应用于输出条件，即设计测试用例使输出值达到边界值及其左右的值。<br> 例如，某程序的规格说明要求计算出“每月保险金扣除额为0至1165.25元”，其测试用例可取0.00及1165.24、还可取一0.01及1165．26等。<br> 再如一程序属于情报检索系统，要求每次”最少显示1条、最多显示4条情报摘要”，这时我们应考虑的测试用例包括1和4，还应包括0和5等。</p> 
<p>4）如果程序的规格说明给出的输入域或输出域是有序集合,则应选取<strong>集合的第一个元素和最后一个元素</strong>作为测试用例。<br> 5）如果程序中使用了一个<strong>内部数据结构</strong>,则应当选择这个内部数据结构的边界上的值作为测试用例。<br> 6）分析规格说明,找出其它可能的边界条件。</p> 
<p>例题：<br> 程序的输入文件由一些有80个字符的记录组成,如右图所示，所有记录分为3组：<br> <img src="https://images2.imgbox.com/7d/a8/OQdxxFpy_o.png" alt="在这里插入图片描述"></p> 
<p>① 标题：<br> 这一组只有一个记录，其内容为输出成绩报告的名字。<br> ②试卷各题标准答案记录：<br> 每个记录均在第80个字符处标以数字“2”。该组的第一个记录的第1至第3个字符为题目编号（取值为1一999）。第10至第59个字符给出第1至第50题的答案（每个合法字符表示一个答案）。该组的第2，第3……个记录相应为第51至第100，第101至第150，…题的答案。<br> ③每个学生的答卷描述：<br> 该组中每个记录的第80个字符均为数字“3”。每个学生的答卷在若干个记录中给出。如甲的首记录第1至第9字符给出学生姓名及学号，第10至第59字符列出的是甲所做的第1至第50题的答案。若试题数超过50，则第2，第3……记录分别给出他的第51至第100，第101至第150……题的解答。然后是学生乙的答卷记录<br> 学生人数不超过200，试题数不超过999<br> 程序的输出有4个报告：<br> a)按学号排列的成绩单，列出每个学生的成绩、名次。<br> b)按学生成绩排序的成绩单。<br> c)平均分数及标准偏差的报告。<br> d)试题分析报告。按试题号排序，列出各题学生答对的百分比。<br> 解答：分别考虑输入条件和输出条件，以及边界条件。给出下表所示的输入条件及相应的测试用例。</p> 
<p><img src="https://images2.imgbox.com/b6/29/Xrcpau0W_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/26/f0/Z247ZD5T_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/af/8f/9StkDNsA_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_131"></a>错误推测法</h3> 
<p>基于经验和直觉推测程序中所有可能存在的各种错误, 从而有针对性的设计测试用例的方法。比如输入数据为0</p> 
<p>例如，针对例3，采用错误推测法还可补充设计一些测试用例：<br> 1、 程序是否把空格作为回答<br> 2、 在回答记录中混有标准答案记录<br> 3、 除了标题记录外，还有一些的记录最后一个字符即不是2也不是3<br> 4、 有两个学生的学号相同<br> 5、试题数是负数。</p> 
<p>再如，测试一个对线性表（比如数组）进行排序的程序，可推测列出以下几项需要特别测试的情况：<br> 1）输入的线性表为空表；<br> 2）表中只含有一个元素；<br> 3）输入表中所有元素已排好序；<br> 4）输入表已按逆序排好；<br> 5）输入表中部分或全部元素相同。</p> 
<h3><a id="_148"></a>因果图</h3> 
<ul><li>前面介绍的等价类划分方法和边界值分析方法,都是着重考虑输入条件,但未考虑输入条件之间的联系, 相互组合等。</li><li>考虑输入条件之间的相互组合,可能会产生一些新的情况. 但要检查输入条件的组合不是一件容易的事情, 即使把所有输入条件划分成等价类,他们之间的组合情况也相当多. 因此必须考虑采用一种适合于描述对于多种条件的组合,相应产生多个动作的形式来考虑设计测试用例。这就需要利用因果图（ Cause一Effect Graphics ）方法。</li><li>采用因果图方法能够帮助我们按一定步骤，高效率地选择测试用例，同时还能为我们指出，程序规格说明描述中存在着什么问题。</li></ul> 
<p><img src="https://images2.imgbox.com/18/a3/kCW2eaxp_o.png" alt="在这里插入图片描述"><br> 左结点表示输入状态（或称原因），右结点表示输出状态（或称结果）。<br> Ci表示原因，通常置于图的左部； ei表示结果，通常在图的右部。 ci和ei均可取值0或1，0表示某状态不出现，1表示某状态出现</p> 
<p>关系<br> ①恒等：若ci是1，则ei也是1；否则ei为0。<br> ②非：若ci是1，则ei是0；否则ei是1。<br> ③或：若c1或c2或c3是1，则ei是1；否则ei为0。“或”可有任意个输入。<br> ④与：若c1和c2都是1，则ei为1；否则ei为0。“与”也可有任意个输入。</p> 
<p>例子：<br> 原因：<br> 1.售货机有零钱找 2.投入1元硬币<br> 3.投入5角硬币 4.押下橙汁按钮<br> 5.押下啤酒按钮<br> 结果：<br> 21. 售货机〖零钱找完〗灯亮 <br> 22. 退还1元硬币<br> 23. 退还5角硬币 <br> 24. 送出橙汁饮料<br> 25. 送出啤酒饮料</p> 
<p><img src="https://images2.imgbox.com/fd/9e/Y6jYLOJA_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ac/02/JdUnNS3I_o.png" alt="在这里插入图片描述"><br> 因果图方法是一个非常有效的黑盒测试方法，它能够生成没有重复性的且发现错误能力强的测试用例，而且对输入、输出同时进行了分析。<br> 从因果图生成的测试用例（局部,组合关系下的）包括了所有输入数据的取TRUE与取FALSE的情况,构成的测试用例数目达到最少,且测试用例数目随输入数据数目的增加而线性地增加。<br> 如果哪个开发项目在设计阶段就采用了判定表，也就不必再画因果图，而是可以直接利用判定表设计测试用例了。</p> 
<h3><a id="_182"></a>判定表</h3> 
<p>判定表通常由四个部分组成：<br> 条件桩（Condition Stub）:列出了问题的所有条件，通常认为列出得条件的次序无关紧要。<br> 动作桩（Action Stub）:列出了问题规定可能采取的操作，这些操作的排列顺序没有约束。<br> 条件项（Condition Entry）:列出针对它左列条件的取值，在所有可能情况下的真假值。<br> 动作项（Action Entry）:列出在条件项的各种取值情况下应该采取的动作。</p> 
<p>例子：<br> 问题要求：”…… 对功率大于50马力的机器、维修记录不全或已运行10年以上的机器，应给予优先的维修处理……” 。 这里假定，“维修记录不全”和“优先维修处理”均已在别处有更严格的定义 。 请建立判定表。<br> ①确定规则的个数：这里有3个条件，每个条件有两个取值，故应有2<em>2</em>2=8种规则。<br> ②列出所有的条件茬和动作茬：<img src="https://images2.imgbox.com/21/6b/Gc6msGMs_o.png" alt="在这里插入图片描述"><br> ③填入条件项。可从最后1行条件项开始，逐行向上填满。如第三行是： Y N Y N Y N Y N第二行是： Y Y N N Y Y N N等等。<br> ④填人动作桩和动作顶。这样便得到形如图的初始判定表。<br> <img src="https://images2.imgbox.com/21/ef/UTJpnon9_o.png" alt="在这里插入图片描述"><br> ⑤化简。合并相似规则后得到图<br> <img src="https://images2.imgbox.com/ba/b9/tajOw1JG_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_198"></a>判定表例题</h4> 
<p>请根据判定表方法为以下a、b、c边的直角三角形问题设计测试用例。<br> a、b和c应为1至100的正整数；<br> 如果任何一侧小于1或大于100，则输出为“无效输入”；<br> 如果任意两条边的和小于或等于第三条边，则输出为“非三角形”；<br> 如果任意两边的平方和等于第三边的平方，则输出为“直角三角形”；否则输出为“一般三角形”；<br> 1） 请绘制决策表。<br> 2） 请列出测试用例。</p> 
<p>首先我们假设输入一定为整数，确定规则个数，这里有3个条件，其中第一个条件有3种取值，规则数量为3<em>2</em>2 = 12</p> 
<p>这里列出所有条件茬和动作茬：<br> <img src="https://images2.imgbox.com/80/e4/Z8JyoZ7H_o.png" alt="在这里插入图片描述"><br> 判定表：<br> <img src="https://images2.imgbox.com/5a/77/T2cyYJAS_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/fe/a2/r4dKkF5w_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_216"></a>白盒测试</h2> 
<h3><a id="_217"></a>介绍</h3> 
<p>白盒测试也称结构测试或逻辑驱动测试，是一种测试用例设计方法，它从程序的<strong>控制结构导出测试用例</strong>。<br> 白盒测试使用被测单元内部如何工作的信息，允许测试人员对程序内部逻辑结构及有关信息来设计和选择测试用例，对程序进行测试。</p> 
<p>基本要求：<br> 保证一个模块中的所有独立路径至少被执行一次；<br> 对所有的<strong>逻辑值均需要测试真、假</strong>两个分支；<br> 在上下边界及可操作范围内<strong>运行所有循环</strong>；<br> 检查内部数据结构以确保其有效性。</p> 
<p>应用白盒法时，手头必须有程序的规格说明以及程序清单。<br> 白盒法考虑的是测试用例对程序内部逻辑的覆盖程度。<br> 最彻底的白盒法是覆盖程序中的每一条路径，但是由于程序中一般含有循环，所以路径的数目极大，要执行每一条路径是不可能的，只能希望覆盖的程度尽可能高些。</p> 
<h3><a id="_231"></a>覆盖程度</h3> 
<p>从低到高：</p> 
<p>语句覆盖：选择足够的测试用例，使得程序中每个语句至少都能被执行一次。<br> 判定覆盖（也称为分支覆盖）：执行足够的测试用例，使得<strong>程序中的每一个分支至少都通过一次（仅要求取到每一个结果）</strong>。<br> 条件覆盖：执行足够的测试用例，使程序中每个判断的<strong>每个条件的每个可能取值至少执行一</strong>次；<br> 判定/条件覆盖：执行足够的测试用例，使得判定中<strong>每个条件取到各种可能的值</strong>，并使每个判定<strong>取到各种可能的结果（所有结果被取过）</strong>。<br> 条件组合覆盖：执行足够的例子，使得每个判定中条件的各种可能组合都至少出现一次。<br> 基本路径测试：设计足够多的测试用例，运行所测程序，要覆盖程序中所有可能的路径。这是最强的覆盖准则。但在路径数目很大时，真正做到完全覆盖是很困难的，必须把覆盖路径数目压缩到一定限度。</p> 
<p>例子：<br> <img src="https://images2.imgbox.com/c9/b3/E8Qd6bgP_o.png" alt="在这里插入图片描述"><br> 语句覆盖：x=4、y=5、z=5 程序执行的路径是：abd<br> 分支覆盖：①x=4，z=0，y=6 (沿路径acd执行)；<br> ② x=5，z=5，y=2(沿路径abe执行)<br> 条件覆盖：<br> 对于第一个判断：<br> 条件x&gt;3 取真值为T1，取假值为-T1<br> 条件z&lt;10 取真值为T2，取假值为-T2<br> 对于第二个判断：<br> 条件x=4 取真值为T3，取假值为-T3<br> 条件y&gt;5 取真值为T4，取假值为-T4<br> <img src="https://images2.imgbox.com/fc/05/4VSefYt5_o.png" alt="在这里插入图片描述"></p> 
<p>注意“条件覆盖”并不包含“分支覆盖”，</p> 
<p>而“分支 ／条件覆盖”，它的含义是：执行足够的测试用例，使得分支中每个条件取到各种可能的值，并使每个分支取到各种可能的结果。它才是包含前两者的覆盖</p> 
<p><img src="https://images2.imgbox.com/30/c8/4KQrbECA_o.png" alt="在这里插入图片描述"></p> 
<p>条件组合覆盖：<br> 1、x&gt;3,z&lt;10 记做T1 T2，第一个判断的取真分支<br> 2、x&gt;3,z&gt;=10 记做T1 -T2，第一个判断的取假分支<br> 3、x&lt;=3,z&lt;10 记做-T1 T2，第一个判断的取假分支<br> 4、x&lt;=3,z&gt;=10 记做-T1 -T2，第一个判断的取假分支<br> 5、x=4,y&gt;5 记做T3 T4，第二个判断的取真分支<br> 6、x=4,y&lt;=5 记做T3 -T4，第二个判断的取真分支<br> 7、x!=4,y&gt;5 记做-T3 T4，第二个判断的取真分支<br> 8、x!=4,y&lt;=5 记做-T3 -T4，第二个判断的取假分支</p> 
<p>根据定义取4个测试用例，就可以覆盖上面8种条件取值的组合。上面的测试用例覆盖了所有条件的可能取值的组合，覆盖了所有判断的可取分支，但是却丢失了一条路径abe（路径组合可能丢失）<br> <img src="https://images2.imgbox.com/e6/df/L0AdH9Hd_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_275"></a>基本路径覆盖</h4> 
<p>步骤：<br> 程序的控制流图：描述程序控制流的一种图示方法<br> 程序圈复杂度：McCabe复杂性度量。从程序的环路复杂性可导出程序基本路径集合中的独立路径条数。<br> 导出测试用例：根据圈复杂度和程序结构设计用例数据输入和预期结果。<br> 准备测试用例：确保基本路径集中的每一条路径的执行</p> 
<p>下面是基本路径覆盖的结果用例<br> <img src="https://images2.imgbox.com/c9/78/psSw3BNy_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_285"></a>程序流程图简化成控制流图</h5> 
<p><img src="https://images2.imgbox.com/05/18/mdJRv0uA_o.png" alt="在这里插入图片描述"><br> 在将程序流程图简化成控制流图时，应注意：<br> 在选择或多分支结构中，<strong>分支的汇聚处应有一个汇聚结点。</strong><br> 边和结点圈定的区域叫做区域，当对区域计数时，图形外的区域也应记为一个区域。</p> 
<p><img src="https://images2.imgbox.com/16/0c/gvNTZU2N_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/77/2b/2OeHtw1V_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ba/f8/Xwnta8F6_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_295"></a>计算圈复杂度</h5> 
<p>圈复杂度是一种为程序逻辑复杂性提供定量测度的软件度量，将该度量用于<strong>计算程序的基本的独立路径数目</strong>。</p> 
<p>有以下三种方法计算圈复杂度：</p> 
<ul><li>流图中区域的数量对应于圈复杂度；</li><li>给定流图G的圈复杂度V(G)，定义为V(G)=E-N+2，E是流图中边的数量，N是流图中结点的数量；</li><li>给定流图G的圈复杂度V(G)，定义为V(G)=P+1，P是流图G中<strong>判定结点的数量</strong>。</li></ul> 
<p>对应上面图中的圈复杂度，计算如下：<br> 流图中有四个区域；<br> V(G)=10条边-8结点+2=4;<br> V(G)=3个判定结点+1=4。<br> <img src="https://images2.imgbox.com/6f/bb/a5tNI3SZ_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_308"></a>导出测试用例</h5> 
<p>第三步：导出测试用例<br> 根据上面的计算方法，可得出四个独立的路径。(一条独立路径是指，和其他的独立路径相比，至少引入一个新处理语句或一个新判断的程序通路。V(G)值正好等于该程序的独立路径的条数。)<br> 路径1：4-14<br> 路径2：4-6-7-14<br> 路径3：4-6-8-10-13-4-14<br> 路径4：4-6-8-11-13-4-14<br> 根据上面的独立路径，去设计输入数据，使程序分别执行到上面四条路径。</p> 
<h5><a id="_317"></a>准备测试用例</h5> 
<p>路径1：4-14<br> 输入数据：iRecordNum＝0，或者<br> 取iRecordNum&lt;0的某一个值<br> 预期结果：x＝0<br> 路径2：4-6-7-14<br> 输入数据：iRecordNum＝1,iType＝0<br> 预期结果：x＝2<br> 路径3：4-6-8-10-13-4-14<br> 输入数据：iRecordNum＝1,iType＝1<br> 预期结果：x＝10<br> 路径4：4-6-8-11-13-4-14<br> 输入数据：iRecordNum＝1,iType＝2<br> 预期结果：x＝20</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span>  <span class="token function">Sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> iRecordNum<span class="token punctuation">,</span><span class="token keyword">int</span> iType<span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>  
   <span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token keyword">while</span> <span class="token punctuation">(</span>iRecordNum<span class="token operator">--</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span>
	   <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">==</span>iType<span class="token punctuation">)</span>
              <span class="token punctuation">{<!-- --></span>x<span class="token operator">=</span>y<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
        <span class="token keyword">else</span>
	     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">=</span> <span class="token operator">=</span>iType<span class="token punctuation">)</span>
  		x<span class="token operator">=</span>y<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span>
           <span class="token keyword">else</span>
        	x<span class="token operator">=</span>y<span class="token operator">+</span><span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_351"></a>例题</h3> 
<p>请使用以下白盒测试技术完成测试用例设计。<br> 1）请绘制控制流程图。<br> 2） 请列出所有决定及其条件分支。<br> 3） 请使用判定/条件覆盖测试方法来设计测试用例。<br> 4） 请使用条件组合测试方法来设计测试用例。<br> 5） 请使用路径覆盖方法来设计测试用例。<br> 6） 请使用基本路径测试方法来设计测试用例</p> 
<p><img src="https://images2.imgbox.com/6d/de/pZSOBdip_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1__363"></a>1) 绘制控制流图</h4> 
<p>先画出程序流图再转为控制流图</p> 
<p><img src="https://images2.imgbox.com/71/00/EABEpWQ5_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_367"></a>2）列出所有决定及其条件分支</h4> 
<p>注意列出的时候利用字母进行标记</p> 
<p><img src="https://images2.imgbox.com/22/64/lAin6Cjw_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3__372"></a>3） 使用判定/条件覆盖测试方法来设计测试用例</h4> 
<p><img src="https://images2.imgbox.com/09/ef/GmuY8j5Q_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4__375"></a>4） 请使用条件组合测试方法来设计测试用例</h4> 
<p><img src="https://images2.imgbox.com/fe/b5/AJqnxztO_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="5__378"></a>5） 请使用路径覆盖方法来设计测试用例</h4> 
<p><img src="https://images2.imgbox.com/47/29/qwegzIR7_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="6__381"></a>6） 请使用基本路径测试方法来设计测试用例</h4> 
<p><img src="https://images2.imgbox.com/99/65/7kpIwFJJ_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6dd1623c4742e9b97112dfd0e9272260/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">购买手机之前不妨先查询一下价格走势图,了解手机历史价格趋势</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/946611d8cb4b5ea27bbc897c3f241b82/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">matplotlib - 确保 0 在 RdBu 颜色条中变为白色</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>