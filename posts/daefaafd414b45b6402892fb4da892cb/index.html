<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker中仓库、镜像和容器用法详解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker中仓库、镜像和容器用法详解" />
<meta property="og:description" content="1、仓库、镜像和容器之间的关系 2、Docker镜像 当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载，如果不指定版本，默认下载最新的版本。也可以通过配置，使用自定义的镜像仓库。
2.1 查看镜像信息 2.1.1　使用images命令列出镜像 使用 docker images 或者 docker image ls来列出本地主机上的镜像：
docker images docker image ls 选项说明：
REPOSITORY：表示镜像的仓库源TAG：镜像的标签, 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本IMAGE ID：镜像ID，它唯一的标识了镜像。在使用id时，可以使用该id的前若干个字符组成的可区分串来代替完整的ID。CREATED：镜像创建时间，说明镜像的最后更新时间。SIZE：镜像大小 2.1.2 使用tag命令添加镜像标签 使用docker tag命令为本地镜像任意添加新的标签。当TAG为&lt;none&gt;时，直接为该镜像打上标签，若TAG不为&lt;none&gt;时，此时操作相当于复制链接一份。
如：添加一个新的myubuntu:latest镜像：
docker tag ubuntu:18.04 myubuntu:latest 注意：可以注意到ID的相同的，docker tag命令添加的标签实际上起到了类似链接的作用。
如TAG为&lt;none&gt;时：
docker tag d1165f221234 hello-world:old_image 注意：此时直接为该镜像打上了标签。
2.1.3 使用inspect命令查看详细信息 docker inspect ubuntu:18.04 执行结果：
[root@dgw-machine ~]# docker inspect ubuntu:18.04 [ { &#34;Id&#34;: &#34;sha256:3941d3b032a8168d53508410a67baad120a563df67a7959565a30a1cb2114731&#34;, &#34;RepoTags&#34;: [ &#34;myubuntu:latest&#34;, &#34;ubuntu:18.04&#34; ], &#34;RepoDigests&#34;: [ &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/daefaafd414b45b6402892fb4da892cb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-23T23:21:39+08:00" />
<meta property="article:modified_time" content="2023-05-23T23:21:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker中仓库、镜像和容器用法详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1、仓库、镜像和容器之间的关系</h2> 
<p><img alt="" height="543" src="https://images2.imgbox.com/a2/96/nycoDoVK_o.png" width="1059"></p> 
<h2>2、Docker镜像</h2> 
<p>        当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载，如果不指定版本，默认下载最新的版本。也可以通过配置，使用自定义的镜像仓库。</p> 
<h3>2.1 查看镜像信息</h3> 
<h4>2.1.1　使用images命令列出镜像</h4> 
<p>使用 docker images 或者 docker image ls来列出本地主机上的镜像：</p> 
<pre><code class="language-bash">docker images
docker image ls</code></pre> 
<p><img alt="" height="454" src="https://images2.imgbox.com/65/70/kP7Pd1nw_o.png" width="1200"></p> 
<p>选项说明：</p> 
<ol><li>REPOSITORY：表示镜像的仓库源</li><li>TAG：镜像的标签, 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本</li><li>IMAGE ID：镜像ID，它唯一的标识了镜像。在使用id时，可以使用该id的前若干个字符组成的可区分串来代替完整的ID。</li><li>CREATED：镜像创建时间，说明镜像的最后更新时间。</li><li>SIZE：镜像大小  </li></ol> 
<h4>2.1.2 使用tag命令添加镜像标签</h4> 
<p>        使用docker tag命令为本地镜像任意添加新的标签。当TAG为&lt;none&gt;时，直接为该镜像打上标签，若TAG不为&lt;none&gt;时，此时操作相当于复制链接一份。</p> 
<p>如：添加一个新的myubuntu:latest镜像：</p> 
<pre><code class="language-bash">docker tag ubuntu:18.04 myubuntu:latest</code></pre> 
<p><img alt="" height="183" src="https://images2.imgbox.com/9e/1f/0m2Urw49_o.png" width="861"></p> 
<p><img alt="" height="136" src="https://images2.imgbox.com/32/7d/eRUaSbr7_o.png" width="895"></p> 
<p><span style="color:#fe2c24;"><strong>注意：</strong></span>可以注意到ID的相同的，docker tag命令添加的标签实际上起到了类似链接的作用。</p> 
<p>如TAG为&lt;none&gt;时：</p> 
<pre><code class="language-bash">docker tag d1165f221234 hello-world:old_image</code></pre> 
<p><img alt="" height="437" src="https://images2.imgbox.com/e5/23/rjvWQ7nq_o.png" width="1152"></p> 
<p><span style="color:#fe2c24;"><strong>注意：</strong></span>此时直接为该镜像打上了标签。</p> 
<h4>2.1.3 使用inspect命令查看详细信息</h4> 
<pre><code class="language-bash">docker inspect ubuntu:18.04</code></pre> 
<p>执行结果：</p> 
<pre><code class="language-bash">[root@dgw-machine ~]# docker inspect ubuntu:18.04
[
    {
        "Id": "sha256:3941d3b032a8168d53508410a67baad120a563df67a7959565a30a1cb2114731",
        "RepoTags": [
            "myubuntu:latest",
            "ubuntu:18.04"
        ],
        "RepoDigests": [
            "ubuntu@sha256:8aa9c2798215f99544d1ce7439ea9c3a6dfd82de607da1cec3a8a2fae005931b"
        ],
        "Parent": "",
        "Comment": "",
        "Created": "2023-03-08T03:22:44.73196058Z",
        "Container": "ee3fcc8c88d3f3129f1236850de28a7eba0da7c548a7b23a6495905ebcf255ea",
        "ContainerConfig": {
            "Hostname": "ee3fcc8c88d3",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/sh",
                "-c",
                "#(nop) ",
                "CMD [\"/bin/bash\"]"
            ],
            "Image": "sha256:b64649bc9d1a48300ec5a929146aa3c5ca80046f74c33aa5de65a7046f5177a6",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {
                "org.opencontainers.image.ref.name": "ubuntu",
                "org.opencontainers.image.version": "18.04"
            }
        },
        "DockerVersion": "20.10.12",
        "Author": "",
        "Config": {
            "Hostname": "",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/bash"
            ],
            "Image": "sha256:b64649bc9d1a48300ec5a929146aa3c5ca80046f74c33aa5de65a7046f5177a6",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {
                "org.opencontainers.image.ref.name": "ubuntu",
                "org.opencontainers.image.version": "18.04"
            }
        },
        "Architecture": "amd64",
        "Os": "linux",
        "Size": 63146040,
        "VirtualSize": 63146040,
        "GraphDriver": {
            "Data": {
                "MergedDir": "/var/lib/docker/overlay2/16361f3b03baee1bac13d5476160ddb296b800caec61cebd427b24a32b758e42/merged",
                "UpperDir": "/var/lib/docker/overlay2/16361f3b03baee1bac13d5476160ddb296b800caec61cebd427b24a32b758e42/diff",
                "WorkDir": "/var/lib/docker/overlay2/16361f3b03baee1bac13d5476160ddb296b800caec61cebd427b24a32b758e42/work"
            },
            "Name": "overlay2"
        },
        "RootFS": {
            "Type": "layers",
            "Layers": [
                "sha256:b7e0fa7bfe7f9796f1268cca2e65a8bfb1e010277652cee9a9c9d077a83db3c4"
            ]
        },
        "Metadata": {
            "LastTagTime": "2023-05-14T11:50:51.28460608+08:00"
        }
    }
]
</code></pre> 
<p>上述命令返回的是一个json格式的信息，如果只需要其中某条信息时，可以使用-f指定。</p> 
<p>如获取镜像的RootFS：</p> 
<pre><code class="language-bash">docker inspect -f {<!-- -->{".RootFS"}} ubuntu:18.04
docker inspect -f {<!-- -->{".RootFS.Type"}} ubuntu:18.04</code></pre> 
<p><img alt="" height="122" src="https://images2.imgbox.com/fd/d1/TiD2Wlys_o.png" width="845"></p> 
<h4>2.1.4 使用history命令查看镜像历史</h4> 
<pre><code class="language-bash">docker history ubuntu:18.04</code></pre> 
<p><img alt="" height="235" src="https://images2.imgbox.com/ca/5f/cMwOr0NA_o.png" width="924"></p> 
<p> 过长的命令被自动截断了，可以添加--no-trunc命令：</p> 
<p><img alt="" height="368" src="https://images2.imgbox.com/fc/63/9S1lnJJJ_o.png" width="1200"></p> 
<h3>2.2 查找镜像</h3> 
<p>以查找mysql为例：</p> 
<h4><strong>2.2.1 通过Docker Hub 进行查找</strong>, 比如<a href="https://hub.docker.com/search?q=mysql&amp;type=image" rel="nofollow" title="Docker Hub">Docker Hub</a></h4> 
<p><img alt="" height="878" src="https://images2.imgbox.com/4b/05/I1Vvw8pk_o.png" width="1200"></p> 
<h4><strong>2.2.2 使用 docker search 命令来搜索镜像</strong></h4> 
<pre><code class="language-bash">docker search mysql</code></pre> 
<p><img alt="" height="659" src="https://images2.imgbox.com/d6/ad/S0rwE13V_o.png" width="1200"></p> 
<p>参数介绍：</p> 
<ul><li>NAME: 镜像仓库源的名称</li><li>DESCRIPTION: 镜像的描述</li><li>OFFICIAL: 是否 docker 官方发布</li><li>STARS: 类似 Github 里面的 star，表示点赞、喜欢的意思。</li><li>AUTOMATED: 自动构建</li></ul> 
<p>支持的命令主要包括：</p> 
<ol><li>-f，--filter  filter：过滤输出的内容</li><li>--format string：格式化输出内容</li><li>--limit int：限制输出的结果个数，默认为25个</li><li>--no-trunc：不截断输出结果</li></ol> 
<p>示例如下：</p> 
<pre><code class="language-bash"># 搜索官方提供的
docker search --filter=is-official=true mysql
docker search -f=is-official=true mysql
docker search -f is-official=true mysql</code></pre> 
<p><img alt="" height="438" src="https://images2.imgbox.com/7f/5e/iXnBtVpD_o.png" width="934"></p> 
<pre><code class="language-bash">#搜索收藏数超过4的
docker search -f stars=100 mysql</code></pre> 
<p><img alt="" height="172" src="https://images2.imgbox.com/99/43/Hhkz4NS9_o.png" width="896"></p> 
<h3>2.3 拉取/获取镜像</h3> 
<p>使用如下命令：</p> 
<pre><code class="language-bash">docker [image] pull NAME[:TAG]</code></pre> 
<p>其中：NAME是镜像仓库名称，TAG是镜像的标签。</p> 
<p>        对于docker镜像来说，如果不显示指定 TAG，则默认会选择latest标签，这样会下载仓库中最新版本的镜像。</p> 
<h4><strong>2.3.1 获取mysql镜像</strong></h4> 
<pre><code class="language-bash">docker pull mysql</code></pre> 
<p><img alt="" height="366" src="https://images2.imgbox.com/13/94/WpcEcsAu_o.png" width="1119"></p> 
<p><img alt="" height="412" src="https://images2.imgbox.com/5d/1f/lmVtiyQB_o.png" width="1050"></p> 
<h4><strong>2.3.2 获取Ubuntu镜像</strong></h4> 
<pre><code class="language-bash">docker pull ubuntu:18.04</code></pre> 
<p><img alt="" height="154" src="https://images2.imgbox.com/7a/35/h3ZJhBd4_o.png" width="855"></p> 
<h3>2.4 删除镜像</h3> 
<pre><code class="language-bash">sudo docker image rm 镜像名或镜像ID
sudo docker image rm hello-world
sudo docker image rm fce289e99eb9</code></pre> 
<p><span style="color:#fe2c24;">注意：</span><span style="color:#a2e043;">删除的前提是：这个对象没有创建容器。镜像正在运行时是不能删除的。需要先把容器给stop、删除，然后再删除镜像。</span></p> 
<p><img alt="" height="568" src="https://images2.imgbox.com/0a/90/xrehpB5t_o.png" width="1200"></p> 
<h4>2.4.1 使用标签删除镜像</h4> 
<p>        使用docker rmi或者docker image rm命令可以删除镜像。</p> 
<p>支持的选项：</p> 
<ol><li>-f，-force：强制删除镜像，即使有容器依赖它</li><li>-no-prune：不要请理未带标签的父镜像</li></ol> 
<pre><code class="language-bash">docker rmi myubuntu:latest</code></pre> 
<p><img alt="" height="293" src="https://images2.imgbox.com/ca/a7/nSqZLQMd_o.png" width="975"></p> 
<p><span style="color:#fe2c24;"><strong>注意：</strong></span>当镜像只剩下一个标签的时候，docker rmi会彻底的删除镜像。</p> 
<h4>2.4.2 使用ID删除镜像</h4> 
<pre><code class="language-bash">docker image rm fce289e99eb9</code></pre> 
<p>当使用docker rmi ID命令时，会先尝试删除该ID所有指向的镜像标签，然后再删除该镜像本身。</p> 
<p><strong><span style="color:#fe2c24;">注意：</span></strong>通常不推荐使用-f参数来强制删除一个存在的容器依赖的镜像。正确的做法是先删除依赖该镜像的所有容器，再删除该镜像。</p> 
<h4>2.4.3 清理镜像</h4> 
<p>        使用docker 一段时间后，系统中可能会遗留一些临时的镜像文件，以及一些没有使用的镜像，可以通过docker image prune命令来进行清理。</p> 
<p>支持的选项包括：</p> 
<ul><li>-a，-all：删除所有无用的镜像，不光是临时镜像</li><li>-filter filter：只清理符合给定过滤器的镜像</li><li>-f，-force：强制删除镜像，而不进行提示确认</li></ul> 
<p>如下命令-f会自动清理临时的遗留镜像文件层，最后提示释放的存储空间。</p> 
<pre><code class="language-bash">docker image prune -f</code></pre> 
<p><img alt="" height="54" src="https://images2.imgbox.com/f6/3c/d5KRMECi_o.png" width="735"></p> 
<pre><code class="language-bash">docker image prune -a</code></pre> 
<p><img alt="" height="269" src="https://images2.imgbox.com/f2/e5/fn9cyDOz_o.png" width="975"></p> 
<h3>2.5 更新镜像</h3> 
<p>        针对ubantu镜像，是否可以在里面安装一些软件，然后再生成一个新的镜像呢？这就需要重新commit出一个新的镜像。</p> 
<p>以ubantu镜像为例：</p> 
<p>首先run一个ubantu容器，同时在里面进行apt-get update更新操作：</p> 
<pre><code class="language-bash">docker run -it ubuntu:latest
apt-get update</code></pre> 
<p><img alt="" height="476" src="https://images2.imgbox.com/93/e8/56TZWPdI_o.png" width="1149"></p> 
<h3>2.6 创建镜像</h3> 
<p>创建镜像主要有三种方法：基于已有镜像的容器创建、基于本地模板导入、基于Dockerfile创建。</p> 
<h4>2.6.1 基于已有容器创建</h4> 
<p>命令格式：</p> 
<pre><code class="language-bash">docker [container] commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code></pre> 
<p>主要选项包括：</p> 
<ul><li>-a，--author=""：作者信息</li><li>-c，--change=[]：提交的时候执行Dockerfile指令，包括CMD | ENTRYPOINT|ENV | EXPOSE | LABEL | ONBUILD | USER | VOLUME | WORKDIR等</li><li>-m，--message=""：提交信息</li><li>-p，--pause=true：提交时暂停容器运行</li></ul> 
<p><strong>实例操作：</strong></p> 
<p>首先下载一个镜像，以Ubuntu最新镜像为例：</p> 
<p><img alt="" height="263" src="https://images2.imgbox.com/0f/57/HxCh2ToT_o.png" width="846"></p> 
<p>然后启动镜像，并在其中进行修改操作：</p> 
<pre><code class="language-bash">docker run -it ubuntu:latest /bin/bash</code></pre> 
<p><img alt="" height="109" src="https://images2.imgbox.com/6e/85/QaeikX9y_o.png" width="855"></p> 
<p>记住容器的id：18db64bd342f，也可以通过下面命令查看：</p> 
<p><img alt="" height="112" src="https://images2.imgbox.com/6f/19/kO974IMc_o.png" width="1159"></p> 
<p>使用docker commit命令提交一个镜像：</p> 
<pre><code class="language-bash">docker commit -m "Added a new file" -a "dgw" 18db64bd342f test:1.0</code></pre> 
<p><img alt="" height="184" src="https://images2.imgbox.com/fd/10/bpK0txhB_o.png" width="1009"></p> 
<h4>2.6.2 基于本地模板导入</h4> 
<p>        可以直接从一个操作系统模板文件中导入一个镜像。</p> 
<p><img alt="" height="75" src="https://images2.imgbox.com/d2/71/WFHzauWp_o.png" width="599"></p> 
<p> <img alt="" height="240" src="https://images2.imgbox.com/cf/0a/dGhFXdcv_o.png" width="605"></p> 
<p><strong>注意：</strong></p> 
<p><img alt="" height="333" src="https://images2.imgbox.com/dd/10/GyjXXRsr_o.png" width="1200"></p> 
<h4>2.6.3 基于Dockerfile创建</h4> 
<p><img alt="" height="418" src="https://images2.imgbox.com/61/c0/w2jXOJGj_o.png" width="633"></p> 
<h3>2.7 镜像的导出</h3> 
<p>        可以使用docker save命令将镜像导出到本地文件。</p> 
<p>命令参数：</p> 
<ul><li>-o，-output string：导出镜像到指定的文件中。</li><li>&gt;：同 -o 方法。</li></ul> 
<p>使用tag导出：</p> 
<pre><code class="language-bash">docker save -o ubuntu_18.04.tar ubuntu:latest
docker save &gt; ubuntu_18.04_2.tar ubuntu:latest</code></pre> 
<p><img alt="" height="340" src="https://images2.imgbox.com/c1/f6/217Fdqr1_o.png" width="883"></p> 
<p>使用id导出：</p> 
<pre><code class="language-bash">docker save &gt; ubuntu_18.04_3.tar 6b7dfa7e8fdb</code></pre> 
<p><img alt="" height="167" src="https://images2.imgbox.com/b9/c4/wTGtke5g_o.png" width="886"></p> 
<p>之后用户就可以复制.tar文件将镜像分享给别人。</p> 
<h3>2.8 镜像的导入</h3> 
<p>使用docker load命令将导出的tar文件再导入到本地镜像库。</p> 
<p>支持的参数：</p> 
<ul><li>-i，-input string：从指定文件中读入镜像内容。</li><li>&lt;：同 -i</li></ul> 
<pre><code class="language-bash">docker load -i ubuntu_18.04.tar</code></pre> 
<p><img alt="" height="522" src="https://images2.imgbox.com/93/13/frZZ8TAQ_o.png" width="1094"></p> 
<p>        这将导入镜像和相关的元数据信息（包括标签等）。导入成功后，可以使用docker images命令进行查看，与原镜像一致。</p> 
<h3>2.9 上传镜像</h3> 
<p>        可以使用docker push 命令上传镜像到仓库，默认上传到Docker Hub官方仓库（需要登录）。</p> 
<p><img alt="" height="357" src="https://images2.imgbox.com/7f/90/CH3Yzp1P_o.png" width="619"></p> 
<h2>3、Docker容器</h2> 
<p>        在生产环境中，为了提高容器的高可用性和安全性，一方面要合理利用资源限制参数来管理容器的资源消耗；另一方面要指定合适的容器重启策略，来自动重启退出的容器。此外，还可以使用HAProxy等辅助工具来处理负载均衡，自动切换故障的应用容器。</p> 
<h3>3.1 创建容器</h3> 
<h4>3.1.1 新建容器</h4> 
<p>        可以使用docker create命令新建一个容器。</p> 
<pre><code class="language-bash">docker create -it ubuntu:18.04</code></pre> 
<p><img alt="" height="103" src="https://images2.imgbox.com/ef/f4/FuuyGYBb_o.png" width="473"></p> 
<p><img alt="" height="230" src="https://images2.imgbox.com/f8/2f/jErpXstW_o.png" width="1104"></p> 
<p><span style="color:#fe2c24;"><strong>注意：</strong></span>使用docker create命令创建的容器处于停止状态，可以使用docker start命令来启动它。</p> 
<h4>3.1.2 启动容器</h4> 
<p>        可以使用docker start命令来启动一个已经创建的容器。</p> 
<pre><code class="language-bash">docker start id</code></pre> 
<p><img alt="" height="273" src="https://images2.imgbox.com/b7/7e/6l9qz1k7_o.png" width="1071"></p> 
<h4>3.1.3 新建并启动容器</h4> 
<p>可以使用docker run命令直接新建并启动容器。</p> 
<p>docker run等价于先执行docker create命令，再执行docker start命令。</p> 
<p>示例：（输出一个hello world，然后容器自动停止）</p> 
<pre><code class="language-bash">docker run ubuntu:18.04 /bin/echo "Hello world"</code></pre> 
<p><img alt="" height="73" src="https://images2.imgbox.com/74/04/ZPX3Su9i_o.png" width="729"></p> 
<p><strong><span style="color:#fe2c24;">注意：</span></strong>如果镜像不指定版本号，默认是latest，若不存在的话会自动下载。</p> 
<p>当利用docker run来创建并启动容器时，Docker在后台运行的标准操作包括：</p> 
<p><img alt="" height="185" src="https://images2.imgbox.com/57/15/yhWz599n_o.png" width="535"></p> 
<p>启动一个bash终端，允许用户进行交互：</p> 
<pre><code class="language-bash">docker run -it ubuntu:18.04 /bin/bash</code></pre> 
<p><img alt="" height="80" src="https://images2.imgbox.com/9d/00/oRYwp4lc_o.png" width="627"></p> 
<p>其中：</p> 
<ul><li>-it 可以连写的，表示 -i -t</li><li>-t  选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上，</li><li>-i  测让容器的标准输入保持打开。</li></ul> 
<p>在交互式模式下，用户可以通过创建的终端来输入命令：</p> 
<p><img alt="" height="228" src="https://images2.imgbox.com/de/ed/0OfPF0nF_o.png" width="910"></p> 
<p>可以使用Ctrl+d或输入exit命令来退出容器。 </p> 
<p><img alt="" height="72" src="https://images2.imgbox.com/37/4f/tkkWVXgG_o.png" width="622"></p> 
<p>        对于所创建的bash容器，当用户使用exit命令退出bash进程之后，容器也会自动退出。这是因为对于容器来说，当其中的应用退出后，容器的使命完成，也就没有继续运行的必要了。</p> 
<p>        可以使用docker  container  wait CONTAINER[CONTAINER....]子命令来等待容器退出，并打印退出返回结果。</p> 
<p>        某些时候，执行docker  [container]  run时候因为命令无法正常执行容器会出错直接退出，此时可以查看退出的错误代码。</p> 
<p>默认情况下，常见错误代码包括:</p> 
<ul><li>125: Docker daemon执行出错，例如指定了不支持的Docker命令参数;</li><li>126:所指定命令无法执行，例如权限出错;</li><li>127:容器内命令无法找到。</li></ul> 
<h4>3.1.4 容器重启</h4> 
<p>使用docker restart命令重启容器。</p> 
<p><img alt="" height="308" src="https://images2.imgbox.com/1e/69/3nlOgwJa_o.png" width="904"></p> 
<p><img alt="" height="322" src="https://images2.imgbox.com/0f/ad/XHPoA0Kc_o.png" width="1200"></p> 
<h4>3.1.5 守护态运行</h4> 
<p>        大部分时候需要Docker容器以守护态在后台运行，可以添加 -d 来实现。</p> 
<pre><code class="language-bash">docker run -d ubuntu:18.04 /bin/bash -c "while true; do echo hello world; sleep 1; done"</code></pre> 
<p><img alt="" height="281" src="https://images2.imgbox.com/e5/b7/lKKMSeg6_o.png" width="1200"></p> 
<h4>3.1.6 查看容器输出</h4> 
<p>         要获取容器的输出信息，可以使用docker logs命令。</p> 
<p><img alt="" height="206" src="https://images2.imgbox.com/32/5e/FHozHpn2_o.png" width="602"></p> 
<pre><code class="language-bash">docker logs --help</code></pre> 
<p><img alt="" height="417" src="https://images2.imgbox.com/6b/47/SbPIDFGl_o.png" width="1102"></p> 
<pre><code class="language-bash">docker logs -t dbef38912874</code></pre> 
<p><img alt="" height="156" src="https://images2.imgbox.com/f4/d7/xu0hXxzt_o.png" width="776"></p> 
<h3>3.2 停止容器</h3> 
<h4>3.2.1 暂停容器</h4> 
<p>        可以使用docker pause 命令来暂停一个运行中的容器。</p> 
<p>示例：启动一个容器，然后将其暂停</p> 
<pre><code class="language-bash">docker run -d --name test_pause ubuntu:18.04 /bin/bash -c "while true; do echo hello world; sleep 1; done"
docker pause test_pause</code></pre> 
<p><img alt="" height="322" src="https://images2.imgbox.com/aa/63/EKm1qVHI_o.png" width="1148"></p> 
<p>处于pause状态的容器，可以使用docker unpause命令来恢复到运行状态：</p> 
<pre><code class="language-bash">docker unpause test_pause</code></pre> 
<p><img alt="" height="277" src="https://images2.imgbox.com/c8/42/nUnYLWsV_o.png" width="1187"></p> 
<h4>3.2.2 终止容器</h4> 
<p>        使用docker  stop 命令来终止一个正在运行的容器。</p> 
<p>        该命令会首先发送SIGTERM信号，等待一段超时时间后（默认是10s），再发送SIGKILL信号来终止容器。</p> 
<pre><code class="language-bash">docker stop id</code></pre> 
<p><img alt="" height="274" src="https://images2.imgbox.com/39/b8/BOL5iZDq_o.png" width="1042"></p> 
<h4>3.2.3 强制停止容器</h4> 
<p>加上<code>-f</code>之后是可以强制停止容器的。</p> 
<pre><code class="language-bash">docker rm -f fcf727bda146</code></pre> 
<p><img alt="" src="https://images2.imgbox.com/16/41/4FNzXaSq_o.png"></p> 
<h4>3.2.4 清理停止的容器</h4> 
<p>执行docker container prune命令，会自动清除掉所有处于停止状态的容器。</p> 
<pre><code class="language-bash">docker container prune</code></pre> 
<p><img alt="" height="659" src="https://images2.imgbox.com/6d/7a/OvCW6JI5_o.png" width="1200"></p> 
<p>还可以使用docker kill 直接发送SIGKILL信号来强行终止容器。</p> 
<p>可以使用docker ps -qa命令来查看所有容器的ID。</p> 
<pre><code class="language-bash">docker ps -qa</code></pre> 
<p> <img alt="" height="59" src="https://images2.imgbox.com/dc/c4/m2jn1A9w_o.png" width="519"></p> 
<p>可以使用docker start命令启动处于停止状态的容器。</p> 
<p>也可以使用docker restart命令重新启动容器。先将一个运行的容器终止，然后再重新启动。</p> 
<pre><code class="language-bash">docker restart 67b354e0d141</code></pre> 
<p><img alt="" height="229" src="https://images2.imgbox.com/8f/f3/N4tHkonO_o.png" width="895"></p> 
<h3>3.3 进入容器</h3> 
<h4>3.3.1 attach命令</h4> 
<p>        attach命令是Docker官方自带的命令。</p> 
<p><img alt="" height="174" src="https://images2.imgbox.com/73/67/vz0FNRIA_o.png" width="604"></p> 
<p><img alt="" height="330" src="https://images2.imgbox.com/a5/07/gtkoYmVa_o.png" width="779"></p> 
<pre><code class="language-bash">docker run -itd ubuntu:18.04
docker ps
docker attach intelligent_fermi</code></pre> 
<p><img alt="" height="212" src="https://images2.imgbox.com/16/17/cDm3fOWv_o.png" width="929"></p> 
<p><span style="color:#fe2c24;"><strong>注意：</strong></span>当多个窗口同时attach到同一个容器的时候，所有窗口都会同步显示;当某个窗口因命令阻塞时，其他窗口也无法执行操作了。</p> 
<p><span style="color:#fe2c24;"><strong>注意：</strong></span>使用docker attach进入时，当使用exit退出时容器也跟着停止了。</p> 
<h4>3.3.2 exec命令</h4> 
<p>        可以在运行中容器内直接执行任意命令。</p> 
<p><img alt="" height="265" src="https://images2.imgbox.com/ad/ca/uQolVeXX_o.png" width="639"></p> 
<p><img alt="" height="467" src="https://images2.imgbox.com/0c/b0/qcg6VBo3_o.png" width="847"></p> 
<pre><code class="language-bash">docker exec -it intelligent_fermi /bin/bash</code></pre> 
<p><img alt="" height="282" src="https://images2.imgbox.com/c5/46/v3zMSLKh_o.png" width="967"></p> 
<p>通过指定 -it 参数来保持标准输入打开，并且分配一个伪终端。</p> 
<p><strong><span style="color:#fe2c24;">注意：</span></strong>当退出容器时，不会导致容器的停止。</p> 
<h3>3.4 删除容器</h3> 
<p>        可以使用docker rm 命令来删除处于终止或者退出状态的容器。</p> 
<p><img alt="" height="137" src="https://images2.imgbox.com/2a/c8/fJ2MJpak_o.png" width="521"></p> 
<p><img alt="" height="326" src="https://images2.imgbox.com/32/71/0CXd8b1m_o.png" width="763"></p> 
<p>        默认情况下，docker rm命令只能删除已经处于终止或退出状态的容器，并不能册删除还处于运行状态的容器。</p> 
<pre><code class="language-bash">docker rm practical_jemison</code></pre> 
<p><img alt="" height="242" src="https://images2.imgbox.com/e1/43/YyAdYVuC_o.png" width="1015"></p> 
<p>        如果要直接删除一个运行中的容器，可以添加-f参数。Docker会先发送SIGKILL信号给容器,终止其中的应用，之后强行删除。或者也可以先stop容器，然后再rm删除容器。</p> 
<pre><code class="language-bash">docker rm -f intelligent_fermi</code></pre> 
<p><img alt="" height="275" src="https://images2.imgbox.com/7f/c3/YYK2XqfE_o.png" width="1200"></p> 
<h3>3.5 导出容器</h3> 
<p>        可以导出一个已经创建的容器到一个文件中，不管此时这个容器是否处于运行状态。</p> 
<pre><code class="language-bash">docker export -o ubuntu_hello_world.tar 0e3f62f364a3
或者
docker export 0e3f62f364a3 &gt; ubuntu_hello_world2.tar</code></pre> 
<p>其中，-o选项来指定导出的.tar文件名 ，也可以直接通过重定向来实现。</p> 
<p><img alt="" height="208" src="https://images2.imgbox.com/61/cc/MH0Z3BOZ_o.png" width="1062"></p> 
<p><img alt="" height="112" src="https://images2.imgbox.com/46/24/v0fw9nea_o.png" width="857"></p> 
<p>        之后，就可以将导出的.tar文件传输到别的机器上，然后通过导入命令到系统中，实现容器的迁移。</p> 
<p><span style="color:#fe2c24;"><strong>注意：</strong></span>导出容器的时候，容器无需关闭</p> 
<h3>3.6 导入容器</h3> 
<p>        导出的文件可以通过docker import 命令导入变成镜像。</p> 
<pre><code class="language-bash">docker import --help</code></pre> 
<p><img alt="" height="326" src="https://images2.imgbox.com/d2/fc/89DKyhLQ_o.png" width="772"></p> 
<p>        可以通过-c，--change=[ ]选项在导入的同时执行对容器进行修改的Dockerfile文件。</p> 
<pre><code class="language-bash">docker import ubuntu_hello_world.tar test/ubuntu:v1</code></pre> 
<p><img alt="" height="190" src="https://images2.imgbox.com/40/e9/C5OgpZ0w_o.png" width="889"></p> 
<p>        docker load命令和docker import命令类似。实际上，既可以使用docker load命令来导入镜像存储文件到本地镜像库，也可以使用docker import 命令来导入一个容器快照到本地镜像仓库。二者的区别：容器快照文件将丢弃所有的历史记录和元数据信息（即仅保留容器当时的快照状态），而镜像存储文件将保存完整记录，体积更大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p> 
<h3>3.7 查看容器</h3> 
<h4>3.7.1 查看启动的容器</h4> 
<p><img alt="" height="590" src="https://images2.imgbox.com/88/47/7rqTGdx6_o.png" width="1200"></p> 
<ul><li>-a 表示all 所有的</li></ul> 
<p><img alt="" height="274" src="https://images2.imgbox.com/82/3e/bJcqgyHz_o.png" width="1200"></p> 
<pre><code class="language-bash"># 查看正在运行的容器
sudo docker container ls
# 查看所有的容器
sudo docker container ls --all
docker ps</code></pre> 
<p><img alt="" height="540" src="https://images2.imgbox.com/26/6d/0WgKCMKs_o.png" width="1200"></p> 
<h4>3.7.2 查看容器详情</h4> 
<p>        可以使用docker container inspect命令查询详情，会以json格式返回包括容器的id、创建时间、路径、状态、镜像、配置等在内的各项信息。</p> 
<pre><code class="language-bash">docker container inspect eloquent_robinson</code></pre> 
<p><img alt="" height="361" src="https://images2.imgbox.com/02/f6/TpOrgBtS_o.png" width="1097"></p> 
<pre><code class="language-bash">[root@dgw-machine ~]# docker container inspect eloquent_robinson
[
    {
        "Id": "0e3f62f364a357fae84b577379c67ed78ff485c1a855fa9cee004f8fc0f30ff7",
        "Created": "2023-05-21T05:06:52.230375082Z",
        "Path": "/bin/bash",
        "Args": [
            "-c",
            "while true; do echo hello world; sleep 1; done"
        ],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 11785,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2023-05-21T05:06:52.554615834Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
        },
        "Image": "sha256:e28a50f651f9eefbc8883ddc64704d609f3d95bf1ea9e41f873a8da68ea5ec98",
        "ResolvConfPath": "/var/lib/docker/containers/0e3f62f364a357fae84b577379c67ed78ff485c1a855fa9cee004f8fc0f30ff7/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/0e3f62f364a357fae84b577379c67ed78ff485c1a855fa9cee004f8fc0f30ff7/hostname",
        "HostsPath": "/var/lib/docker/containers/0e3f62f364a357fae84b577379c67ed78ff485c1a855fa9cee004f8fc0f30ff7/hosts",
        "LogPath": "/var/lib/docker/containers/0e3f62f364a357fae84b577379c67ed78ff485c1a855fa9cee004f8fc0f30ff7/0e3f62f364a357fae84b577379c67ed78ff485c1a855fa9cee004f8fc0f30ff7-json.log",
        "Name": "/eloquent_robinson",
        "RestartCount": 0,
        "Driver": "overlay2",
        "Platform": "linux",
        "MountLabel": "",
        "ProcessLabel": "",
        "AppArmorProfile": "",
        "ExecIDs": null,
        "HostConfig": {
            "Binds": null,
            "ContainerIDFile": "",
            "LogConfig": {
                "Type": "json-file",
                "Config": {}
            },
            "NetworkMode": "default",
            "PortBindings": {},
            "RestartPolicy": {
                "Name": "no",
                "MaximumRetryCount": 0
            },
            "AutoRemove": false,
            "VolumeDriver": "",
            "VolumesFrom": null,
            "ConsoleSize": [
                27,
                166
            ],
            "CapAdd": null,
            "CapDrop": null,
            "CgroupnsMode": "host",
            "Dns": [],
            "DnsOptions": [],
            "DnsSearch": [],
            "ExtraHosts": null,
            "GroupAdd": null,
            "IpcMode": "private",
            "Cgroup": "",
            "Links": null,
            "OomScoreAdj": 0,
            "PidMode": "",
            "Privileged": false,
            "PublishAllPorts": false,
            "ReadonlyRootfs": false,
            "SecurityOpt": null,
            "UTSMode": "",
            "UsernsMode": "",
            "ShmSize": 67108864,
            "Runtime": "runc",
            "Isolation": "",
            "CpuShares": 0,
            "Memory": 0,
            "NanoCpus": 0,
            "CgroupParent": "",
            "BlkioWeight": 0,
            "BlkioWeightDevice": [],
            "BlkioDeviceReadBps": [],
            "BlkioDeviceWriteBps": [],
            "BlkioDeviceReadIOps": [],
            "BlkioDeviceWriteIOps": [],
            "CpuPeriod": 0,
            "CpuQuota": 0,
            "CpuRealtimePeriod": 0,
            "CpuRealtimeRuntime": 0,
            "CpusetCpus": "",
            "CpusetMems": "",
            "Devices": [],
            "DeviceCgroupRules": null,
            "DeviceRequests": null,
            "MemoryReservation": 0,
            "MemorySwap": 0,
            "MemorySwappiness": null,
            "OomKillDisable": false,
            "PidsLimit": null,
            "Ulimits": null,
            "CpuCount": 0,
            "CpuPercent": 0,
            "IOMaximumIOps": 0,
            "IOMaximumBandwidth": 0,
            "MaskedPaths": [
                "/proc/asound",
                "/proc/acpi",
                "/proc/kcore",
                "/proc/keys",
                "/proc/latency_stats",
                "/proc/timer_list",
                "/proc/timer_stats",
                "/proc/sched_debug",
                "/proc/scsi",
                "/sys/firmware"
            ],
            "ReadonlyPaths": [
                "/proc/bus",
                "/proc/fs",
                "/proc/irq",
                "/proc/sys",
                "/proc/sysrq-trigger"
            ]
        },
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/255e8f6f55b45d7614bd012fcc0d2f8efdd1a44d3564d5ab0ab90da041867b2c-init/diff:/var/lib/docker/overlay2/d2db9613f837932d77d6dc5a11090e59704626d4358161a1ae364967bde28315/diff",
                "MergedDir": "/var/lib/docker/overlay2/255e8f6f55b45d7614bd012fcc0d2f8efdd1a44d3564d5ab0ab90da041867b2c/merged",
                "UpperDir": "/var/lib/docker/overlay2/255e8f6f55b45d7614bd012fcc0d2f8efdd1a44d3564d5ab0ab90da041867b2c/diff",
                "WorkDir": "/var/lib/docker/overlay2/255e8f6f55b45d7614bd012fcc0d2f8efdd1a44d3564d5ab0ab90da041867b2c/work"
            },
            "Name": "overlay2"
        },
        "Mounts": [],
        "Config": {
            "Hostname": "0e3f62f364a3",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/bash",
                "-c",
                "while true; do echo hello world; sleep 1; done"
            ],
            "Image": "ubuntu:18.04",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {}
        },
        "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "11f5f2a64705ba6ef8419547bb0bbb3aacba5a68288de1b1ad2e092656484ca6",
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "Ports": {},
            "SandboxKey": "/var/run/docker/netns/11f5f2a64705",
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "2a6e6d63a0ff4d1cbfa4da9ad5353c7cc32acf7e5015a064f6b5d40c82472922",
            "Gateway": "172.17.0.1",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.2",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "MacAddress": "02:42:ac:11:00:02",
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "63bc5376b3ecf16d0d60b4952199d183cd553485dfebe9de3b65927f9e98b28c",
                    "EndpointID": "2a6e6d63a0ff4d1cbfa4da9ad5353c7cc32acf7e5015a064f6b5d40c82472922",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:02",
                    "DriverOpts": null
                }
            }
        }
    }
]
</code></pre> 
<h4>3.7.3 查看容器内进程</h4> 
<p>        使用top方法查看容器内进程，类似于Linux系统中的top命令。会打印出容器内的进程信息，包括PID、用户、时间、命令等。</p> 
<pre><code class="language-bash">docker top eloquent_robinson</code></pre> 
<p><img alt="" height="223" src="https://images2.imgbox.com/89/4c/nZAsT2gP_o.png" width="1200"></p> 
<h4>3.7.4 查看统计信息</h4> 
<p>        使用stats命令查看统计信息，会显示CPU、内存、存储、网络等使用情况的统计信息。</p> 
<p><img alt="" height="470" src="https://images2.imgbox.com/63/00/LYKxEHOM_o.png" width="1200"></p> 
<pre><code class="language-bash">docker stats eloquent_robinson</code></pre> 
<p><img alt="" height="98" src="https://images2.imgbox.com/9f/b7/4y7KhuhW_o.png" width="1001"></p> 
<h3>3.8 复制文件</h3> 
<p>        container cp命令支持在容器和主机之间复制文件。</p> 
<p><img alt="" height="475" src="https://images2.imgbox.com/f6/8f/0Xv3QIK4_o.png" width="1200"></p> 
<p><img alt="" height="481" src="https://images2.imgbox.com/e1/72/hExXm2WG_o.png" width="1196"></p> 
<p> 将容器中数据复制到宿主机上：</p> 
<pre><code class="language-bash">docker cp eloquent_robinson:/tmp .</code></pre> 
<p><img alt="" height="206" src="https://images2.imgbox.com/03/03/5fSfZEi4_o.png" width="1016"></p> 
<p>将宿主机上数据复制到容器中：</p> 
<pre><code class="language-bash">docker cp 111.txt eloquent_robinson:/tmp</code></pre> 
<p><img alt="" height="305" src="https://images2.imgbox.com/34/fb/CUhWs0jL_o.png" width="929"></p> 
<h4>3.9 查看容器变更</h4> 
<p>        docker diff查看容器内文件系统的变更。</p> 
<p><img alt="" height="229" src="https://images2.imgbox.com/b5/3a/QA7ommAu_o.png" width="849"></p> 
<pre><code class="language-bash">docker container diff eloquent_robinson</code></pre> 
<p><img alt="" height="166" src="https://images2.imgbox.com/b3/ab/Ati4ZimK_o.png" width="763"></p> 
<h4>3.10 查看容器端口映射</h4> 
<p>        docker port命令可以查看容器的端口映射情况。</p> 
<p><img alt="" height="204" src="https://images2.imgbox.com/36/d6/jEpJ01G1_o.png" width="725"></p> 
<pre><code class="language-bash">docker container port objective_burnell</code></pre> 
<p><img alt="" height="87" src="https://images2.imgbox.com/18/e7/EZUaw3JX_o.png" width="728"></p> 
<h4>3.11 更新容器配置</h4> 
<p>        docker update命令可以更新容器中的一些运行时配置，主要是一些资源限制份额。</p> 
<p><img alt="" height="606" src="https://images2.imgbox.com/7b/4e/MhmYAseZ_o.png" width="1151"></p> 
<h3>3.12 容器别名及操作</h3> 
<pre><code class="language-bash">docker run -itd --name new_ubuntu new/ubuntu:v2.0.1 /bin/bash</code></pre> 
<p><img alt="" height="420" src="https://images2.imgbox.com/04/f1/XM2cpjOB_o.png" width="1200"></p> 
<h3>3.13 容器错误日志</h3> 
<pre><code class="language-bash">例：实时查看docker容器名为user-dgw的最后10行日志
docker logs -f -t --tail 10 user-dgw

例：查看指定时间后的日志，只显示最后100行：
docker logs -f -t --since="2018-02-08" --tail=100 user-dgw

例：查看最近30分钟的日志:
docker logs --since 30m user-dgw

例：查看某时间之后的日志：
docker logs -t --since="2018-02-08T13:23:37" user-dgw

例：查看某时间段日志：
docker logs -t --since="2018-02-08T13:23:37" --until "2018-02-09T12:23:37" user-dgw

例：将错误日志写入文件：
docker logs -f -t --since="2018-02-18" user-dgw | grep error &gt;&gt; logs_error.txt</code></pre> 
<h2>4、Docker仓库</h2> 
<p>仓库（Repository）是集中存放镜像的地方。</p> 
<ul><li>可以采用共有的仓库，也可以自己搭建Docker Registry;</li><li>如果之前有自己的Artifactory或者Nexus，它们同样可以支持Docker Registry功能;</li><li>带界面的也可以使用Harbor等</li></ul> 
<h3>4.1公共镜像Docker Hub</h3> 
<p>注册官方docker hub：<a href="https://hub.docker.com/" rel="nofollow" title="Docker Hub">Docker Hub</a></p> 
<p>本人注册名称为：dgwdocker</p> 
<h4><strong>4.1.1 登录：</strong></h4> 
<p>        可以通过docker login命令输入用户名、密码和邮箱来完成注册和登录。注册成功后，本地用户目录下会自动创建.docker/config.json文件，保存用户的认证信息。</p> 
<p>        登录成功后用户可以上传个人制作的镜像到Docker Hub。</p> 
<p><img alt="" height="104" src="https://images2.imgbox.com/36/f1/NBH4f75B_o.png" width="1200"></p> 
<h4><strong>4.1.2 镜像准备：</strong></h4> 
<p><img alt="" height="207" src="https://images2.imgbox.com/94/7a/acIjCzd8_o.png" width="961"></p> 
<h4><strong>4.1.3 将镜像推送至Docke Hub服务器：</strong></h4> 
<p><img alt="" height="88" src="https://images2.imgbox.com/1f/91/2vJdKciH_o.png" width="858"></p> 
<h3>4.2 第三方镜像市场</h3> 
<h4>4.2.1 查看镜像</h4> 
<p>如时速云：<a href="https://tenxcloud.com/" rel="nofollow" title="https://tenxcloud.com/">https://tenxcloud.com/</a></p> 
<p>时速云官方仓库中的镜像会保持与DockerHub中官方镜像的同步。</p> 
<h4>4.2.2 下载镜像</h4> 
<p>下载镜像同样是使用docker pull命令，但是要在前面添加服务器的地址。</p> 
<p>略</p> 
<h3>4.3 搭建本地私有仓库</h3> 
<h4>4.3.1 使用registry镜像创建私有仓库</h4> 
<p>官方提供了registry镜像来简单搭建一套本地私有仓库环境。</p> 
<pre><code class="language-bash">docker run -d -p 5000:5000 registry:2</code></pre> 
<p> 这将自动下载并启动一个registry容器，创建本地的私有仓库服务。</p> 
<p><img alt="" height="278" src="https://images2.imgbox.com/de/5a/gwwqDjx3_o.png" width="904"></p> 
<p><img alt="" height="141" src="https://images2.imgbox.com/2f/6d/nhfftaZ7_o.png" width="763"></p> 
<p>此时，在本地启动了一个私有仓库服务，监听端口为5000。</p> 
<p><img alt="" height="91" src="https://images2.imgbox.com/ca/d3/d1MO8vpF_o.png" width="1200"></p> 
<h4>4.3.2 管理私有仓库</h4> 
<p>略</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/51b351a4585810d6d2e897a4cef24b25/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IGMP协议基础，组播配置和过程解析（华为）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/803d8b910c61d6578fefa253ea0adeb6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在linux里面把一个在前台运行的命令转为后台运行</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>