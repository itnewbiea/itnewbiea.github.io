<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HashMap 剖析与理解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HashMap 剖析与理解" />
<meta property="og:description" content="序言 ConCurrentHashMap 是一个被忽视的Java Concurrent包下面的类，在满足并发的「安全性」，和「活跃性」的前提下，做到了与不考虑线程安全的 HashMap 同等效率. 作者是大名鼎鼎的Doug Lea，他老人家在Java 并发领域做的贡献，确实是我们的榜样。下篇文章，对ConCurrentHashMap做一个分析，希望这个代码中的闪光点，能够对各位读者产生启发。这里先介绍HashMap做的实现，便于后面我们理解2者的差异，以及[Doug Lea]完成的ConCurrentHashMap类具有那些惊为天人的地方。这里我们先看看JDK里面是如何实现 HashMap 的。
JDK 是如何定义Map接口的 在设计一个通用的模块和功能的时候，我们需要静下心来分析下根本需求是什么？根据这个需求来建立我们的根本需求。
Map，就是Key-Value对，通过Key可以快速找到对应的Value，核心的需求是Put和Get方法。
public void put(K,V); public V get(K); 在实际的需求里面，虽然不同于Collection，但是一些基础功能和需求是共通的，所以需要额外地加上一些基础方法，比如isEmpty(),size()等。于是而后在原来的基础上添加了其他基础抽象，最后形成的接口大体可以如下
public void clear(); public boolean containsKey(Object key); public boolean containsValue(Object value); public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(); public boolean equals(Object object); ... public V remove(Object key); public int size(); 在这个时候，可能会有2个问题
1）为什么Map接口没有继承自Collection?
这个在JDK的问题里面所说的是Map，和Collection根本是两个东西，具体可以参考下面的引用
This was by design. We feel that mappings are not collections and collections are not mappings. Thus, it makes little sense for Map to extend the Collection interface (or vice versa)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0f68cebb04254dc721cbe2e950111501/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-05-09T15:23:54+08:00" />
<meta property="article:modified_time" content="2015-05-09T15:23:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HashMap 剖析与理解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="序言">序言</h3> 
<p>ConCurrentHashMap 是一个被忽视的Java Concurrent包下面的类，在满足并发的「安全性」，和「活跃性」的前提下，做到了与不考虑线程安全的 HashMap 同等效率. 作者是大名鼎鼎的<a href="http://en.wikipedia.org/wiki/Doug_Lea" rel="nofollow">Doug Lea</a>，他老人家在Java 并发领域做的贡献，确实是我们的榜样。下篇文章，对ConCurrentHashMap做一个分析，希望这个代码中的闪光点，能够对各位读者产生启发。这里先介绍HashMap做的实现，便于后面我们理解2者的差异，以及[Doug Lea]完成的ConCurrentHashMap类具有那些惊为天人的地方。这里我们先看看JDK里面是如何实现 HashMap 的。</p> 
<h3 id="jdk-是如何定义map接口的">JDK 是如何定义Map接口的</h3> 
<p>在设计一个通用的模块和功能的时候，我们需要静下心来分析下根本需求是什么？根据这个需求来建立我们的根本需求。</p> 
<p>Map，就是Key-Value对，通过Key可以快速找到对应的Value，核心的需求是Put和Get方法。</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span>(K,V);
<span class="hljs-keyword">public</span> V <span class="hljs-title">get</span>(K);</code></pre> 
<p>在实际的需求里面，虽然不同于Collection，但是一些基础功能和需求是共通的，所以需要额外地加上一些基础方法，比如<code>isEmpty()</code>,<code>size()</code>等。于是而后在原来的基础上添加了其他基础抽象，最后形成的接口大体可以如下</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span>();
<span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsKey</span>(Object key);
<span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsValue</span>(Object value);
<span class="hljs-keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="hljs-title">entrySet</span>();
<span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span>(Object object);
...
<span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span>(Object key);
<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span>();
</code></pre> 
<p>在这个时候，可能会有2个问题</p> 
<p>1）为什么Map接口没有继承自Collection?</p> 
<p>这个在JDK的问题里面所说的是Map，和Collection根本是两个东西，具体可以参考下面的引用</p> 
<blockquote> 
 <p>This was by design. We feel that mappings are not collections and collections are not mappings. Thus, it makes little sense for Map to extend the Collection interface (or vice versa). <br> If a Map is a Collection, what are the elements? The only reasonable answer is “Key-value pairs”, but this provides a very limited (and not particularly useful) Map abstraction. You can’t ask what value a given key maps to, nor can you delete the entry for a given key without knowing what value it maps to. <br> Collection could be made to extend Map, but this raises the question: what are the keys? There’s no really satisfactory answer, and forcing one leads to an unnatural interface. <br> Maps can be viewed as Collections (of keys, values, or pairs), and this fact is reflected in the three “Collection view operations” on Maps (keySet, entrySet, and values). While it is, in principle, possible to view a List as a Map mapping indices to elements, this has the nasty property that deleting an element from the List changes the Key associated with every element before the deleted element. That’s why we don’t have a map view operation on Lists.</p> 
</blockquote> 
<p>Map可以用Collection来实现，但不一定意味着Map就一定是Collection，Collecton也不一定是Map。</p> 
<p>2）为什么没有实现Iterator接口？</p> 
<p>Map在定义上面就没有要求一定是可以迭代的，有人可能疑问用EntrySet来实现迭代啊？但是从设计的角度上去理解，如果用EntrySet的方式在接口里面申明Iterator接口，就意味着把内部的实现细节暴露出去了。所以宁愿提供<code>entrySet()</code>的接口。</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-javadoc">/**
 * Returns a {@code Set} containing all of the mappings in this {@code Map}. Each mapping is
 * an instance of {@link Map.Entry}. As the {@code Set} is backed by this {@code Map},
 * changes in one will be reflected in the other.
 *
 *<span class="hljs-javadoctag"> @return</span> a set of the mappings
 */</span>
<span class="hljs-keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="hljs-title">entrySet</span>();</code></pre> 
<h3 id="java是如何实现hashmap的">Java是如何实现HashMap的</h3> 
<h4 id="hashmap-基础单元">HashMap 基础单元</h4> 
<p>HashMap作为我们经常用的类，几乎没有程序猿不熟悉Map的用法, 没有道理不去熟悉下HashMap的实现原理。</p> 
<p>HashMap使用java提供的基础类型中的数组，用<em>HashMapEntry</em></p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">final</span> K key;
V value;
<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;
HashMapEntry&lt;K, V&gt; next;</code></pre> 
<h4 id="hashmap-如何避免冲突和解决冲突的">HashMap 如何避免冲突和解决冲突的</h4> 
<p>当两个Key同时hash到一个值时，就会出现这样的冲突。这个冲突主要有2种解决方法。</p> 
<ol><li>开放地址，亦即如果hash冲突，则在空闲的位置进行插入</li><li>hash复用，同一个hash值，链式地加入多个value</li></ol> 
<p>HashMap通过递归，选择了第二种方式来解决冲突的问题。</p> 
<p>整个HashMap的核心部分是hash方法，我们先从最核心的方法看起，<code>HashMap</code>是如何实现将hashCode值映射到table数组里面的索引里面的。</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-annotation">@Override</span> <span class="hljs-keyword">public</span> V <span class="hljs-title">put</span>(K key, V value) {
    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span> putValueForNullKey(value);
    }

    <span class="hljs-keyword">int</span> hash = Collections.secondaryHash(key);
    HashMapEntry&lt;K, V&gt;[] tab = table;
    <span class="hljs-keyword">int</span> index = hash &amp; (tab.length - <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span> (HashMapEntry&lt;K, V&gt; e = tab[index]; e != <span class="hljs-keyword">null</span>; e = e.next) {
        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; key.equals(e.key)) {
            preModify(e);
            V oldValue = e.value;
            e.value = value;
            <span class="hljs-keyword">return</span> oldValue;
        }
    }

    <span class="hljs-comment">// No entry for (non-null) key is present; create one</span>
    modCount++;
    <span class="hljs-keyword">if</span> (size++ &gt; threshold) {
        tab = doubleCapacity();
        index = hash &amp; (tab.length - <span class="hljs-number">1</span>);
    }
    addNewEntry(key, value, hash, index);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
}</code></pre> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// Collections.secondaryHash(key)方法里面使用了</span>
<span class="hljs-keyword">int</span> hash = Collections.secondaryHash(key);
<span class="hljs-keyword">int</span> index = hash &amp; (tab.length - <span class="hljs-number">1</span>);</code></pre> 
<p>在这里面可以看到Hash的代码主要是Wang/Jenkins hash方法，这个方法具有两个属性</p> 
<ol><li>雪崩性（更改输入参数的任何一位，就将引起输出有一半以上的位发生变化）</li><li>可逆性（input ==&gt; hash ==&gt; inverse_hash ==&gt; input）</li></ol> 
<p>Collections.secondaryHash能够使得hash过后的值的分布更加均匀，尽可能地避免冲突，<a href="http://burtleburtle.net/bob/hash/integer.html" rel="nofollow">具体原理点连接</a>，注意这里的前提是table的长度为2的幂次方，从构造函数对capacity的改造可以看出来。<code>hash &amp; (tab.length - 1)</code> 当tab.length为2^n-1的时候，可以保证结果不大于tab.length。</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span>(<span class="hljs-keyword">int</span> capacity) {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">if</span> (capacity &lt; MINIMUM_CAPACITY) {
        capacity = MINIMUM_CAPACITY;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (capacity &gt; MAXIMUM_CAPACITY) {
        capacity = MAXIMUM_CAPACITY;
    } <span class="hljs-keyword">else</span> {
        capacity = Collections.roundUpToPowerOfTwo(capacity);
    }
    makeTable(capacity);
    <span class="hljs-comment">// ...</span>
}</code></pre> 
<p>这里举一个例子，如果现在Table的容量是16，如果最后的结果是 <strong>hash &amp; (16-1)</strong>，也就是 <strong>hash &amp; (00001111)</strong>。现在我们试着对hash值是31(00011111), 63(00111111),95(01011111)进行操作，理论上映射到的index值应该是不尽相同的，然而实际的情况确实如下的情形：</p> 
<p>31=00011111 ==&amp; 00001111==&gt; 1111=15</p> 
<p>63=00111111 ==&amp; 00001111==&gt; 1111=15</p> 
<p>95=01011111 ==&amp; 00001111==&gt; 1111=15</p> 
<p>因此Collections.secondaryHash需要解决的问题，就是避免上面的情况，效果见下面的例子：</p> 
<p>31=00011111 ==secondaryHash==&gt; 00011110==&amp; 00001110==&gt; 14</p> 
<p>63=00111111 ==secondaryHash==&gt; 00111100==&amp; 00001100==&gt; 12</p> 
<p>95=01011111 ==secondaryHash==&gt; 01011010==&amp; 00001010==&gt; 10</p> 
<h4 id="hashmap-如何解决容量不足的问题">HashMap 如何解决容量不足的问题</h4> 
<p>前面解决了hash冲突的问题，那么现在如何解决容量不足的问题了。考虑这样的情况，如果用户大量地调用put方法，在这种情况下，如果容量不变，那么势必会出现大量的冲突，调用get方法时，可能需要很长长度的遍历才能得到答案，性能损失严重，因此，我们可以发现源码中有这样一种方法：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">if</span> (size++ &gt; threshold) {
    tab = doubleCapacity();
    index = hash &amp; (tab.length - <span class="hljs-number">1</span>);
}</code></pre> 
<p>JDK给出的方案是扩容，doubleCapacity()方法，比如原来容量为16，当现在的使用量大于<em>DEFAULT_LOAD_FACTOR*Capacity</em>，下次直接把容量扩展到32. <br> 这段代码注解说的是这整个类的精华，我们必须好好研究下.</p> 
<blockquote> 
 <blockquote> 
  <p>Rehash the bucket using the minimum number of field writes, and this is the most subtle and delicate code in the class.</p> 
 </blockquote> 
</blockquote> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-javadoc">/**
 * Doubles the capacity of the hash table. Existing entries are placed in
 * the correct bucket on the enlarged table. If the current capacity is,
 * MAXIMUM_CAPACITY, this method is a no-op. Returns the table, which
 * will be new unless we were already at MAXIMUM_CAPACITY.
 */</span>
<span class="hljs-keyword">private</span> HashMapEntry&lt;K, V&gt;[] <span class="hljs-title">doubleCapacity</span>() {
    HashMapEntry&lt;K, V&gt;[] oldTable = table;
    <span class="hljs-keyword">int</span> oldCapacity = oldTable.length;
    <span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) {
        <span class="hljs-keyword">return</span> oldTable;
    }
    <span class="hljs-keyword">int</span> newCapacity = oldCapacity * <span class="hljs-number">2</span>;
    HashMapEntry&lt;K, V&gt;[] newTable = makeTable(newCapacity);
    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> newTable;
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCapacity; j++) {
        <span class="hljs-comment">/*
         * Rehash the bucket using the minimum number of field writes.
         * This is the most subtle and delicate code in the class.
         */</span>
        HashMapEntry&lt;K, V&gt; e = oldTable[j];
        <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">int</span> highBit = e.hash &amp; oldCapacity;
        HashMapEntry&lt;K, V&gt; broken = <span class="hljs-keyword">null</span>;
        newTable[j | highBit] = e;
        <span class="hljs-keyword">for</span> (HashMapEntry&lt;K, V&gt; n = e.next; n != <span class="hljs-keyword">null</span>; e = n, n = n.next) {
            <span class="hljs-keyword">int</span> nextHighBit = n.hash &amp; oldCapacity;
            <span class="hljs-keyword">if</span> (nextHighBit != highBit) {
                <span class="hljs-keyword">if</span> (broken == <span class="hljs-keyword">null</span>)
                    newTable[j | nextHighBit] = n;
                <span class="hljs-keyword">else</span>
                    broken.next = n;
                broken = e;
                highBit = nextHighBit;
            }
        }
        <span class="hljs-keyword">if</span> (broken != <span class="hljs-keyword">null</span>)
            broken.next = <span class="hljs-keyword">null</span>;
    }
    <span class="hljs-keyword">return</span> newTable;
}</code></pre> 
<p>我们注意其中这部分的代码</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">int</span> highBit = e.hash &amp; oldCapacity;
newTable[j | highBit] = e;</code></pre> 
<p>我们现在来说明，oldCapacity假设为16(00010000), <strong>int highBit = e.hash &amp; oldCapacity</strong>能够得到高位的值，因为低位全为0，经过与操作过后，低位一定是0。J 在这里是index，J 与 高位的值进行与操作过后，就能得到在扩容后面的新的index值。</p> 
<p>设想一下，理论上我们得到的新的值应该是 <strong>newValue = hash &amp; (newCapacity - 1)</strong>，与<strong>oldValue = hash &amp; (oldCapacity - 1)</strong>的区别仅在于高位上。 因此我们用J | highBit 就可以得到新的index值。</p> 
<h4 id="hashmap-是如何解决迭代问题">HashMap 是如何解决迭代问题</h4> 
<p>首先HashMap提供了3种形式的迭代方法，分别是针对Entry，Key和Value的迭代器，这里实现的代码就比较简单，看下具体的例子就可以知道。实现方式主要是依赖于对HashEntity数组进行遍历即可实现。</p> 
<p>问题在于如何保证迭代的时候，基于正确的输出，聪明的你一定看出来了，难度在于「多线程情况的处理」。在迭代的时候，外部可以通过调用put和remove的方法，来改变正在迭代的对象。但从设计之处，HashMap自身就不是线程安全的，因此HashMap在迭代的时候使用了一种Fast—Fail的实现方式，在HashIterator里面维持了一个 expectedModCount 的变量，在每次调用的时候如果发现<strong>ModCount != expectedModCount</strong>，则抛出ConcurrentModificationException 异常。但本身这种检验不能保证在发生错误的情况下，一定能抛出异常，所以我们需要在使用HashMap的时候，心里知道这是「非线程安全」的。</p> 
<pre class="prettyprint"><code class="language-java hljs ">HashMapEntry&lt;K, V&gt; nextEntry() {
    <span class="hljs-keyword">if</span> (modCount != expectedModCount)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();
    <span class="hljs-keyword">if</span> (nextEntry == <span class="hljs-keyword">null</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();

    HashMapEntry&lt;K, V&gt; entryToReturn = nextEntry;
    HashMapEntry&lt;K, V&gt;[] tab = table;
    HashMapEntry&lt;K, V&gt; next = entryToReturn.next;
    <span class="hljs-keyword">while</span> (next == <span class="hljs-keyword">null</span> &amp;&amp; nextIndex &lt; tab.length) {
        next = tab[nextIndex++];
    }
    nextEntry = next;
    <span class="hljs-keyword">return</span> lastEntryReturned = entryToReturn;
}</code></pre> 
<h4 id="hashmap-是如何实现序列化接口的">HashMap 是如何实现序列化接口的</h4> 
<p>HashMap是实现了Serializable接口的，这种Hash的结构如何实现序列化？按照最朴素的想法，按照默认的实现即可，但是细想之下，一个16位的数组如果只存了一个数据，却要把16位的数组到序列化进去，这本身并不可取。于是HashMap 将其他数据申明为transient，比如：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;</code></pre> 
<p>避免这些常量参与到序列化的细节里面去，在另一方面重写 <strong>writeObject()</strong> 和 <strong>readObject()</strong>方法，通过这样的方式来实现序列化，在代码里面添加了注释，便于大家理解。</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span>(ObjectOutputStream stream) <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-comment">// Emulate loadFactor field for other implementations to read</span>
    ObjectOutputStream.PutField fields = stream.putFields();
    fields.put(<span class="hljs-string">"loadFactor"</span>, DEFAULT_LOAD_FACTOR);
    stream.writeFields();

    <span class="hljs-comment">// 写入table的容量</span>
    stream.writeInt(table.length); <span class="hljs-comment">// Capacity</span>
    <span class="hljs-comment">// 写入目前的Entry数量</span>
    stream.writeInt(size);
    <span class="hljs-keyword">for</span> (Entry&lt;K, V&gt; e : entrySet()) {
        <span class="hljs-comment">// 迭代地写入Key和Value</span>
        stream.writeObject(e.getKey());
        stream.writeObject(e.getValue());
    }
}</code></pre> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span>(ObjectInputStream stream) <span class="hljs-keyword">throws</span> IOException,
            ClassNotFoundException {
    stream.defaultReadObject();
    <span class="hljs-keyword">int</span> capacity = stream.readInt();
    <span class="hljs-keyword">if</span> (capacity &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidObjectException(<span class="hljs-string">"Capacity: "</span> + capacity);
    }
    <span class="hljs-keyword">if</span> (capacity &lt; MINIMUM_CAPACITY) {
        capacity = MINIMUM_CAPACITY;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (capacity &gt; MAXIMUM_CAPACITY) {
        capacity = MAXIMUM_CAPACITY;
    } <span class="hljs-keyword">else</span> {
        capacity = Collections.roundUpToPowerOfTwo(capacity);
    }
    makeTable(capacity);

    <span class="hljs-comment">// 得到size大小</span>
    <span class="hljs-keyword">int</span> size = stream.readInt();
    <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidObjectException(<span class="hljs-string">"Size: "</span> + size);
    }

    init(); <span class="hljs-comment">// Give subclass (LinkedHashMap) a chance to initialize itself</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
        <span class="hljs-annotation">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>) K key = (K) stream.readObject();
        <span class="hljs-annotation">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>) V val = (V) stream.readObject();
        <span class="hljs-comment">// 构造函数里面，会计算hash放置到响应的地方</span>
        constructorPut(key, val);
    }
}</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b159aa01e76a6c1c7e3e89913c1c697b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">给Xcode已有项目添加git代码仓库</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/54f8e35cdd80aabe9449e51ab57df76d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">matlab中如何获取当前日期时间</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>