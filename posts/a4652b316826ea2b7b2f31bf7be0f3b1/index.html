<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>多继承与虚继承内存布局 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="多继承与虚继承内存布局" />
<meta property="og:description" content="class a {int data_a;}; class va : virtual public a {int data_va;}; class va2 : virtual public a {int data_va2;}; class b : public a {int data_b;}; class b2 : public a{int data_b2;}; class child : virtual public va, virtual public b, public va2, public b2 {int data_child;}; 内存布局：
１、布局中先实继承类，再子类成员，再虚继承类
２、虚继承的类只实例化一个内存
３、实继承的类，分别实例化一个内存
４、虚继承的类会深度遍历添加虚爷类的内存，且只添加一次，后面用到这个虚爷类时可直接复用
５、子类的虚表与第一个实基类合并，如果没有实基类，则加一个子类的虚表
６、实例化顺序与内存布局不同，是按写的顺序来的，本例中顺序为：va::a() -&gt; va() -&gt; b()::a() -&gt; b() -&gt; va2() -&gt; b2::a() -&gt; b2() 其中va2的构造不需要再调一次a的构造，因为虚类只有一个。
/** 实继承虚基类 */ *vtbl_va2 data_va2 // 这里没有va２::a 的　data_a　因为是虚继承的a类 // 虚类a只有一个，它会在深度遍历virtual继承类va时添加在va后面。 /** 实继承实基类 */ *vtbl_b2　b2::a::data_a // b2实继承的a，所以先有a的成员再有b2的成员 data_b2 // 子类成员 data_child /** 虚继承虚基类 */ *vtbl_va data_va // 虚继承深度遍历找到虚基基类a，放在这后面 *vtbl_a data_a /** 虚继承实基类 */ *vtbl_b b::a::data_a data_b 虚表的特点：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a4652b316826ea2b7b2f31bf7be0f3b1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-03T16:17:24+08:00" />
<meta property="article:modified_time" content="2024-01-03T16:17:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">多继承与虚继承内存布局</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <pre><code class="prism language-c++">class a {int data_a;};
class va : virtual public a {int data_va;};
class va2 : virtual public a {int data_va2;};
class b : public a {int data_b;};
class b2 : public a{int data_b2;};
class child : 
  virtual public va, 
  virtual public b, 
  public va2, 
  public b2 {int data_child;};
</code></pre> 
<p>内存布局：<br> １、布局中先实继承类，再子类成员，再虚继承类<br> ２、虚继承的类只实例化一个内存<br> ３、实继承的类，分别实例化一个内存<br> ４、虚继承的类会深度遍历添加虚爷类的内存，且只添加一次，后面用到这个虚爷类时可直接复用<br> ５、子类的虚表与第一个实基类合并，如果没有实基类，则加一个子类的虚表<br> ６、实例化顺序与内存布局不同，是按写的顺序来的，本例中顺序为：va::a() -&gt; va() -&gt; b()::a() -&gt; b() -&gt; va2() -&gt; b2::a() -&gt; b2() 其中va2的构造不需要再调一次a的构造，因为虚类只有一个。</p> 
<pre><code class="prism language-c++">/** 实继承虚基类 */
*vtbl_va2 
data_va2
// 这里没有va２::a 的　data_a　因为是虚继承的a类
// 虚类a只有一个，它会在深度遍历virtual继承类va时添加在va后面。
/** 实继承实基类 */
*vtbl_b2　
b2::a::data_a // b2实继承的a，所以先有a的成员再有b2的成员
data_b2
// 子类成员
data_child
/** 虚继承虚基类 */
*vtbl_va
data_va
// 虚继承深度遍历找到虚基基类a，放在这后面
*vtbl_a
data_a
/** 虚继承实基类 */
*vtbl_b
b::a::data_a
data_b
</code></pre> 
<p>虚表的特点：<br> １、虚表位置-16为本基类相对子类（无论父还是爷，都是相对子类）的this指针偏移。<br> ２、虚表位置-8指向子类（无论父还是爷，都是其子类）的typeinfo所在位置（即typeid(class)的返回地址）。<br> ３、子类会修改所有基类（以及爷类）的虚表中重写了的虚函数的指针。<br> ４、子类的虚表与第一个实继承类的虚表合并，没有实继承类时，单独创建一个虚表在最顶部。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c1cff4d5ca5d80f0e8efb012fef9cb4a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">卡巴斯基曝光苹果处理器“神秘后门”，复杂程度堪称史诗级！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/66a19040e465fa514ceaaa9c83e3f4c8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java项目:餐厅点餐系统(java&#43;SpringBoot&#43;HTML&#43;layui&#43;Echarts&#43;mysql)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>