<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式之抽象工厂模式 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式之抽象工厂模式" />
<meta property="og:description" content="一、定义 前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。
同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。
本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，图 1 所示的是海尔工厂和 TCL 工厂所生产的电视机与空调对应的关系图。
二、模式的定义与特点 抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。
抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。
使用抽象工厂模式一般要满足以下条件。
系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。系统一次只可能消费其中某一族产品，即同族的产品一起使用。 抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。
可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。 其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。
三、模式的结构与实现 代码
/// &lt;summary&gt; /// 抽象工厂 /// &lt;/summary&gt; interface AbstractFactory { Product newProduct1(); Product newProduct2(); } //抽象产品：提供了产品的接口 interface Product { void show(); } //具体产品1：实现抽象产品中的抽象方法 class ConcreteProduct1 : Product { public void show() { Console.WriteLine(&#34;具体产品1显示...&#34;); } } //具体产品2：实现抽象产品中的抽象方法 class ConcreteProduct2 : Product { public void show() { Console.WriteLine(&#34;具体产品2显示...&#34;); } } class ConcreteFactory1 : AbstractFactory { public Product newProduct1() { Console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f74bac0617d139aecd26d57df36e6611/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-23T21:12:45+08:00" />
<meta property="article:modified_time" content="2020-09-23T21:12:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式之抽象工厂模式</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>一、定义</h4> 
<p>前面介绍的<a href="http://c.biancheng.net/view/1348.html" rel="nofollow">工厂方法模式</a>中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。<br><br> 同种类称为同等级，也就是说：<a href="http://c.biancheng.net/view/1348.html" rel="nofollow">工厂方法模式</a>只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。<br><br> 本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，图 1 所示的是海尔工厂和 TCL 工厂所生产的电视机与空调对应的关系图。</p> 
<p style="text-align:center;"><img alt="" height="315" src="https://images2.imgbox.com/d7/a4/d9uE2Yej_o.png" width="400"></p> 
<h4>二、模式的定义与特点</h4> 
<p>抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。<br><br> 抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。<br><br> 使用抽象工厂模式一般要满足以下条件。</p> 
<ul><li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li><li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li></ul> 
<p><br> 抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</p> 
<ul><li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li><li>当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。</li><li>抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。</li></ul> 
<p><br> 其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。</p> 
<h4>三、模式的结构与实现</h4> 
<p><img alt="" height="576" src="https://images2.imgbox.com/7b/52/i3QPmJ0L_o.png" width="580"></p> 
<p>代码</p> 
<pre><code class="language-cs">    /// &lt;summary&gt;
    /// 抽象工厂
    /// &lt;/summary&gt;
    interface AbstractFactory
    {
        Product newProduct1();
        Product newProduct2();
    }

    //抽象产品：提供了产品的接口
    interface Product
    {
        void show();
    }

    //具体产品1：实现抽象产品中的抽象方法
    class ConcreteProduct1 : Product
    {
        public void show()
        {
            Console.WriteLine("具体产品1显示...");
        }
    }

    //具体产品2：实现抽象产品中的抽象方法
    class ConcreteProduct2 : Product
    {
        public void show()
        {
            Console.WriteLine("具体产品2显示...");
        }
    }


    class ConcreteFactory1 : AbstractFactory
    {
        public Product newProduct1()
        {
            Console.WriteLine("具体工厂 1 生成--&gt;具体产品 11...");
            return new ConcreteProduct1();
        }
        public Product newProduct2()
        {
            Console.WriteLine("具体工厂 1 生成--&gt;具体产品 21...");
            return new ConcreteProduct2();
        }
    }

    public class Program
    {
        static void Main(string[] args)
        {
            try
            {
                Product a;
                AbstractFactory af =new ConcreteFactory1();
                a = af.newProduct1();
                a.show();
                Console.ReadKey();
            }
            catch (Exception e)
            {
              
            }
        }
    }</code></pre> 
<p><img alt="" height="200" src="https://images2.imgbox.com/b9/b1/lu8s6nGJ_o.png" width="460"></p> 
<p>参考：</p> 
<p><a href="http://c.biancheng.net/view/1351.html" rel="nofollow">http://c.biancheng.net/view/1351.html</a></p> 
<p><a href="https://www.cnblogs.com/toutou/p/4899388.html#_label2" rel="nofollow">https://www.cnblogs.com/toutou/p/4899388.html#_label2</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/50394e9a8dd98bde54350433e1ce3955/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python3 Flask Redis 如何切换数据库</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/31b175755283cdf2f798fdbd721d905b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">iphone 自动跳转应用_如何在iPhone上设置“请勿打扰”自动回复消息</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>