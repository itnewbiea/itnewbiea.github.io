<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>实验五 继承与派生 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="实验五 继承与派生" />
<meta property="og:description" content="实验目的和要求 1.掌握派生类的定义方法的和派生类构造函数定义方法。
2.掌握在不同继承方式的情况下，基类成员在派生类中的访问权限。
3.掌握在多继承方式的情况下，构造函数与析构函数的调用时机与顺序。
实验内容 1.调试下列程序，并在对程序进行修改后再调试，指出调试中出错原因。
//sy5_1.cpp #include&lt;iostream&gt; using namespace std; class A { public: void seta(int i){a=i;} int geta(){return a;} public: int a; }; class B:public A { public: void setb(int i){b=i;} int getb(){return b;} void show(){cout&lt;&lt;&#34;A::a=&#34;&lt;&lt;a&lt;&lt;endl;} public: int b; }; int main() { B bb; bb.seta(6); bb.setb(3); bb.show(); cout&lt;&lt;&#34;A::a=&#34;&lt;&lt;bb.a&lt;&lt;endl; cout&lt;&lt;&#34;B::b=&#34;&lt;&lt;bb.b&lt;&lt;endl; cout&lt;&lt;&#34;A::a=&#34;&lt;&lt;bb.geta()&lt;&lt;endl; cout&lt;&lt;&#34;B::b=&#34;&lt;&lt;bb.getb()&lt;&lt;endl; return 0; } 运行结果： 按下列要求对程序进行修改，然后调试，对出现的错误分析其原因。
（1）将派生类B的继承方式改为private时，会出现哪些错误和不正常现象？为什么？
答：将派生类B的继承方式改为private时，编译程序指出语句2、语句5、语句7有错。这是因为当类的继承方式为私有继承时，基类A的公有成员函数a，公有成员函数seta（）和geta（）作为派生类B的私有成员，派生类成员可以直接访问它们，但在类外部，派生类的对象无法访问它们。
（2）将派生类B的继承方式改为protected时，会出现哪些错误和不正常现象？为什么？
答：将派生类B的继承方式改为protected时，编译程序指出语句2、语句5、语句7有错。这是因为当类的继承方式为保护继承时，基类A的公有数据成员a，公有成员函数seta（）和geta（）作为派生类B的保护成员，派生类成员可以直接访问它们，但在类外部，派生类的对象无法访问它们。
（3）将派生类B的继承方式恢复为public，再将类A中的数据成员int型变量a的访问权限改为private时，会出现哪些错误和不正常现象？为什么？
答：主函数中的语句5、语句9出现了错误；因为B采用的是公有继承，所以B中和主函数中不能访问A中的私有函数。
（4）派生类B的继承方式仍为public，将类A中的数据成员int型变量a的访问权限改为protected时，会出现哪些错误和不正常现象？为什么？
答：主函数中的语句5出现了错误；因为B采用公有继承，所以A中保护成员在B中仍为保护成员，B中可以访问A中的保护成员，但不能通过类的对象访问类的保护成员。
2.重写教材中的Li4_10.cpp，给每个类增加一个析构函数，并使类之间的关系如附图1所示，再写出程序的输出结果。（sy5_2.cpp）
附图1 类之间的关系 修改程序如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/61f8387cfd783b7fd9b943cd012031f6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-04T21:26:47+08:00" />
<meta property="article:modified_time" content="2018-05-04T21:26:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">实验五 继承与派生</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p align="justify"></p> 
<h4><strong><span style="color:rgb(79,79,79);"><span style="font-family:'宋体';">实验目的和要求</span></span></strong></h4> 
<p align="justify"><span style="color:rgb(79,79,79);">1.掌握派生类的定义方法的和派生类构造函数定义方法。</span></p> 
<p align="justify"><span style="color:rgb(79,79,79);">2.掌握在不同继承方式的情况下，基类成员在派生类中的访问权限。</span></p> 
<p align="justify"><span style="color:rgb(79,79,79);">3.掌握在多继承方式的情况下，构造函数与析构函数的调用时机与顺序。</span></p> 
<p align="justify"></p> 
<h4><strong><span style="color:rgb(79,79,79);"><span style="font-family:'宋体';">实验内容</span></span></strong></h4> 
<p align="justify"><span style="color:rgb(79,79,79);">1.调试下列程序，并在对程序进行修改后再调试，指出调试中出错原因。</span></p> 
<p align="justify"><span style="color:rgb(79,79,79);"></span></p> 
<pre><code class="language-cpp">//sy5_1.cpp
#include&lt;iostream&gt;
using namespace std;
class A
{
public:
   void seta(int i){a=i;}
   int geta(){return a;}
public:
    int a;
};
class B:public A
{
public:
    void setb(int i){b=i;}
    int getb(){return b;}
    void show(){cout&lt;&lt;"A::a="&lt;&lt;a&lt;&lt;endl;}
public:
    int b;
};
int main()
{
   B bb;
   bb.seta(6);
   bb.setb(3);
   bb.show();
   cout&lt;&lt;"A::a="&lt;&lt;bb.a&lt;&lt;endl;
   cout&lt;&lt;"B::b="&lt;&lt;bb.b&lt;&lt;endl;
   cout&lt;&lt;"A::a="&lt;&lt;bb.geta()&lt;&lt;endl;
   cout&lt;&lt;"B::b="&lt;&lt;bb.getb()&lt;&lt;endl;
   return 0;
}
</code></pre> 
<div>
  运行结果： 
</div> 
<div> 
 <img src="https://images2.imgbox.com/d8/01/YTVwvOSu_o.png" alt=""> 
 <br> 
</div> 
<p align="justify"><span style="color:rgb(79,79,79);"><img alt="" src=""><img alt="" src=""></span><span style="color:rgb(79,79,79);"><span style="font-family:'宋体';">按下列要求对程序进行修改，然后调试，对出现的错误分析其原因。</span></span></p> 
<p align="justify"><span style="color:rgb(79,79,79);"><span style="font-family:'宋体';">（</span>1）将派生类B的继承方式改为private时，会出现哪些错误和不正常现象？为什么？</span></p> 
<p align="justify"><span style="color:rgb(79,79,79);"><span style="font-family:'宋体';">   答：将派生类</span>B的继承方式改为private时，编译程序指出语句2、语句5、语句7有错。这是因为当类的继承方式为私有继承时，基类A的公有成员函数a，公有成员函数seta（）和geta（）作为派生类B的私有成员，派生类成员可以直接访问它们，但在类外部，派生类的对象无法访问它们。</span></p> 
<p align="justify"><span style="color:rgb(79,79,79);"><span style="font-family:'宋体';">（</span>2）将派生类B的继承方式改为protected时，会出现哪些错误和不正常现象？为什么？</span></p> 
<p align="justify"><span style="color:rgb(79,79,79);"><span style="font-family:'宋体';">   答：将派生类</span>B的继承方式改为protected时，编译程序指出语句2、语句5、语句7有错。这是因为当类的继承方式为保护继承时，基类A的公有数据成员a，公有成员函数seta（）和geta（）作为派生类B的保护成员，派生类成员可以直接访问它们，但在类外部，派生类的对象无法访问它们。</span></p> 
<p align="justify"><span style="color:rgb(79,79,79);"><span style="font-family:'宋体';">（</span>3）将派生类B的继承方式恢复为public，再将类A中的数据成员int型变量a的访问权限改为private时，会出现哪些错误和不正常现象？为什么？</span></p> 
<p align="justify"><span style="color:rgb(79,79,79);"><span style="font-family:'宋体';">   答：主函数中的语句5、语句9出现了错误；因为B采用的是公有继承，所以B中和主函数中不能访问A中的私有函数。</span></span></p> 
<p align="justify"><span style="color:rgb(79,79,79);"><span style="font-family:'宋体';">（</span>4）派生类B的继承方式仍为public，将类A中的数据成员int型变量a的访问权限改为protected时，会出现哪些错误和不正常现象？为什么？</span></p> 
<p align="justify"><span style="color:rgb(79,79,79);">         答：主函数中的语句5出现了错误；因为B采用公有继承，所以A中保护成员在B中仍为保护成员，B中可以访问A中的保护成员，但不能通过类的对象访问类的保护成员。</span></p> 
<p align="justify"><span style="color:rgb(79,79,79);"><br></span></p> 
<p align="justify"><span style="color:rgb(79,79,79);">2.重写教材中的Li4_10.cpp，给每个类增加一个析构函数，并使类之间的关系如附图1所示，再写出程序的输出结果。（sy5_2.cpp）</span></p> 
<p align="justify"><span style="color:rgb(79,79,79);"> <img src="https://images2.imgbox.com/96/9b/ClSvq0Tf_o.png" alt=""><img alt="" src=""><img alt="" src=""><img alt="" src=""><img alt="" src=""></span></p> 
<h3>                       <strong> 附图1   类之间的关系</strong></h3> 
<p>修改程序如下：</p> 
<p> </p> 
<pre><code class="language-cpp">//sy5_2.cpp
#include&lt;iostream&gt;
using namespace std;
class Base1
{
public:
   Base1(){cout&lt;&lt;"constructing Base1"&lt;&lt;endl;}
   ~Base1(){cout&lt;&lt;"destructing Base1"&lt;&lt;endl;}
};
class Base2
{
    public:
      Base2(){cout&lt;&lt;"constructing Base2"&lt;&lt;endl;}
     ~Base2(){cout&lt;&lt;"destructing Base2"&lt;&lt;endl;}
};
class Derived1:public Base2,virtual public Base1
{
    public:
    Derived1(){cout&lt;&lt;"constructing Derived1"&lt;&lt;endl;}
    ~Derived1(){cout&lt;&lt;"destructing Derived1"&lt;&lt;endl;}
};
class Derived2:public Base2,virtual public Base1
{
    public:
    Derived2(){cout&lt;&lt;"constructing Derived2"&lt;&lt;endl;}
    ~Derived2(){cout&lt;&lt;"destructing Derived2"&lt;&lt;endl;}
};
class Derived3:public Derived1,virtual public Derived2
{
    public:
    Derived3(){cout&lt;&lt;"constructing Derived3"&lt;&lt;endl;}
    ~Derived3(){cout&lt;&lt;"destructing Derived3"&lt;&lt;endl;}
};
int main()
{
   Derived3 obj;
   return 0;
}
</code></pre> 
<br> 
<p><span style="font-family:'宋体';">程序输出结果如下</span>:</p> 
<p><img src="https://images2.imgbox.com/bb/41/GJxwTM7h_o.png" alt=""> <img alt="" src=""><img alt="" src=""><img alt="" src=""><img alt="" src=""></p> 
<p><br></p> 
<p align="justify"><span style="color:rgb(79,79,79);">3. </span><span style="color:rgb(79,79,79);"><span style="font-family:'宋体';">利用继承性与派生类来管理学生和教师的档案。假设要管理下述几类人员的如下一些数据。</span></span></p> 
<p align="justify"><span style="color:rgb(79,79,79);">   teacher（教师）类：姓名、性别、年龄、学号、系别；</span></p> 
<p align="justify"><span style="color:rgb(79,79,79);">  </span><span style="color:rgb(79,79,79);"> </span><span style="color:rgb(79,79,79);">gradstudent（研究生）类：姓名、性别、年龄、学号、系别、导师；</span></p> 
<p align="justify"><span style="color:rgb(79,79,79);">  要求每个类只设立构造函数以及显示类对象数据的成员函数。编写主函数，说明有关类对象，并对其类成员函数进行简单使用。（sy5_3.cpp）</span></p> 
<div> 
 <span style="color:rgb(79,79,79);"><span style="font-family:'宋体';">编写程序如下：</span></span> 
</div> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
class teacher{
    public:
        teacher(string name,char sex,int age,string title,string course)
         {
             nam=name;
             s=sex;
             a=age;
             t=title;
             c=course;
        }
        void print()
        {
            cout&lt;&lt;"name: "&lt;&lt;nam&lt;&lt;endl;
            cout&lt;&lt;"sex: "&lt;&lt;s&lt;&lt;endl;
            cout&lt;&lt;"age: "&lt;&lt;a&lt;&lt;endl;
            cout&lt;&lt;"title: "&lt;&lt;t&lt;&lt;endl;
            cout&lt;&lt;"course: "&lt;&lt;c&lt;&lt;endl;
        }
        protected:
             string nam;
              char s;
              int a;
              string t;
              string c;
              };
    class student{
        public:
            student(string name,char sex,int age,int number, string department)
             {
                 nam=name;
                 s=sex;
                 a=age;
                 num=number;
                 dep=department;
            }
    void print()
    {
         cout&lt;&lt;"name: "&lt;&lt;nam&lt;&lt;endl;
         cout&lt;&lt;"sex: "&lt;&lt;s&lt;&lt;endl;
         cout&lt;&lt;"age: "&lt;&lt;a&lt;&lt;endl;
         cout&lt;&lt;"number: "&lt;&lt;num&lt;&lt;endl;
         cout&lt;&lt;"department: "&lt;&lt;dep&lt;&lt;endl;
    }
      protected:
           string nam;
           char s;
           int a;
           int num;
           string dep;
        };
    class gradstudent:public student
    {
        public:
            gradstudent(string name,char sex,int age,int number, string department,string professor):student(name,sex,age,number,department)
            {
                 pro=professor;
            }
        void print()
        {
            cout&lt;&lt;"name: "&lt;&lt;nam&lt;&lt;endl;
            cout&lt;&lt;"sex: "&lt;&lt;s&lt;&lt;endl;
            cout&lt;&lt;"age: "&lt;&lt;a&lt;&lt;endl;
            cout&lt;&lt;"number: "&lt;&lt;num&lt;&lt;endl;
            cout&lt;&lt;"department: "&lt;&lt;dep&lt;&lt;endl;
            cout&lt;&lt;"professor: "&lt;&lt;pro&lt;&lt;endl;
            }
        private:
            string pro;
            };
    int main()
    {
         cout&lt;&lt;"*********************************************"&lt;&lt;endl;
         cout&lt;&lt;"******欢迎您来到学生和教师档案查询系统*******"&lt;&lt;endl;
         cout&lt;&lt;"*********************************************"&lt;&lt;endl;
          int i,j;
          teacher teac("shishuaishuai",'m',27,"js","mxdx");
          student stu("liendan",'w',22,22,"computer");
          gradstudent grad("chengkai",'m',25,12,"computer","hzp");
          cout&lt;&lt;endl;
          loop:cout&lt;&lt;"请输入你要查询的对象："&lt;&lt;endl&lt;&lt;"1.教师; 2.学生; 3.研究生。"&lt;&lt;endl;
          {
              cin&gt;&gt;i; if(i==1)teac.print();
              else if(i==2) stu.print();
              else grad.print();
         }
            cout&lt;&lt;endl;
            cout&lt;&lt;"是否继续查询？ 1.yes 2.no"&lt;&lt;endl; cin&gt;&gt;j;
            if(j==1) goto loop;
             else return 0;
}
</code></pre> 
<br> 
<pre><code class="language-cpp"></code></pre> 
<p align="justify"><code class="language-cpp"><span style="color:rgb(79,79,79);"><span style="font-family:'宋体';">程序输出结果如下：</span></span></code></p> 
<p align="justify"><code class="language-cpp"><span style="color:rgb(79,79,79);"><span style="font-family:'宋体';"><img src="https://images2.imgbox.com/7f/b9/4YCdRlGb_o.png" alt=""></span></span></code></p> 
<p align="justify"><code class="language-cpp"><span style="color:rgb(79,79,79);">4.试写出所能想到的所有形状（包括二维的和三维的），生成一个形状层次类结构。生成的层次结构一Shape作为基类，并由此派生出TwoDimShape类和ThreeDimShape类。它们的派生类是不同形状类，定义层次结构中的每一个类，并用函数main（）进行测试。（sy5_4.cpp）</span></code></p> 
<p align="justify"><code class="language-cpp"><span style="color:rgb(79,79,79);"><span style="font-family:'宋体';">编写程序如下：</span></span></code></p> 
<pre class="cpp"><code class="language-cpp">//sy5_4.cpp
#include&lt;iostream&gt;
using namespace std;
class Shape
{
public:
   Shape(){};
   double area() const{return 0.0;}
   double bulk() const{return 0.0;}
};
class TwoDimShape:public Shape{};
class Circle:public TwoDimShape
{
    public:
    Circle(double r){R=r;}
    double area()const{return 3.14*R*R;}
    protected:
    double R;
};
class ThreeDimShape:public Shape{};
class sphere:public ThreeDimShape
{
    public:
    sphere(double w){R=w;}
    double bulk()const{return 4/3*3.14*R*R*R;}
    protected:
    double R;
};
int main()
{
    Shape sha;
    double area;
    double bulk;
    Circle c(7.0);
    area=c.area();
    cout&lt;&lt;"Area of circle is "&lt;&lt;area&lt;&lt;endl;
    sphere sph(9.0);
    bulk=sph.bulk();
    cout&lt;&lt;"Bulk of sphere is "&lt;&lt;bulk&lt;&lt;endl;
   return 0;
}
</code></pre> 
<br> 
<p align="justify"><span style="color:rgb(79,79,79);"><span style="font-family:'宋体';">程序输出结果如下：</span></span></p> 
<p> <img src="https://images2.imgbox.com/ff/bd/u9BIY9j5_o.png" alt=""><img alt="" src=""></p> 
<p align="justify"></p> 
<h4><strong><span style="color:rgb(79,79,79);"><span style="font-family:'宋体';">分析与讨论</span></span></strong></h4> 
<p align="justify"><span style="color:rgb(79,79,79);">1.通过对实验内容中第1题的调试，总结不同继承方式的情况下，基类成员在派生类中的访问权限。</span></p> 
<p align="justify"><span style="color:rgb(79,79,79);">        <span style="font-size:12px;">答：<span style="color:rgb(79,79,79);font-family:SimSun;text-align:justify;">当类的继承方式为公有继承时，在派生类中，基类的公有成员和保护成员被继承后分别作为派生类的公有成员和保护成员，这样使得派生类的成员函数可以直接访问它们，而派生类成员函数无法直接访问基类的私有成员。在类的外部，派生了的对象可以访问继承下来的基类公有成员。                      </span><span style="color:rgb(79,79,79);font-family:SimSun;text-align:justify;">当类的继承方式为私有继承时，在派生类中，基类的公有成员和保护成员作为派生类的私有成员，派生类的成员函数可以直接访问它们，而派生类的成员函数无法直接访问基类的私有成员。在类外部，派生类的对象无法访问基类的所有成员。</span><br style="color:rgb(79,79,79);font-family:SimSun;text-align:justify;"><span style="color:rgb(79,79,79);font-family:SimSun;text-align:justify;">     当类的继承方式为保护继承时，在派生类中，基类的公有成员和保护成员作为派生类的保护成员，派生类的成员函数可以直接访问它们，而派生类的成员函数无法直接访问基类的私有成员。在类外部，派生类的对象无法基类的所有成员。</span></span></span></p> 
<p align="justify"><span style="color:rgb(79,79,79);">2.解释实验内容第2题的运行结果，总结多继承方式的情况下，构造函数与析构函数的调用时机与顺序。虚基类的构造函数与普通基类的构造函数在调用时有什么不同？</span></p> 
<p align="justify"><span style="color:rgb(79,79,79);">      答：<span style="font-family:SimSun;background-color:rgb(255,255,255);">构造函数的调用顺序：先调用所有基类的构造函数，再调用派生类中子对象类的构造函数（如果派生类中没有子对象），最后调用派生类的构造函数。</span></span></p> 
<p align="justify"><span style="color:rgb(79,79,79);"><span style="font-family:SimSun;background-color:rgb(255,255,255);">     虚基类的构造函数的调用顺序：遵循两个原则，而且按顺序优先满足：1 先调用完所以基类，再调用子类；2 先调用虚拟基类，再调用非<span style="font-family:SimSun;background-color:rgb(255,255,255);">虚拟基类，</span>一旦调用了虚拟基类的构造函数，则非虚拟基类构造函数就按照声明的顺序被调用。</span></span></p> 
<p align="justify"><span style="color:rgb(79,79,79);"><span style="font-family:SimSun;background-color:rgb(255,255,255);">     <span style="font-family:SimSun;background-color:rgb(255,255,255);">普通基类的构造函数：虚基类构造函数、普通基类构造函数、子类构造函数和其他（从左至右依次执行）。</span></span></span></p> 
<p align="justify"><span style="color:rgb(79,79,79);">3.如果希望附图1中的Base1、Base2均有两个，如何修改顺序</span><span style="color:rgb(79,79,79);"><span style="font-family:'宋体';">？</span></span></p> 
<p><br></p> 
<p><br></p> 
<p></p> 
<h4> 实验总结：</h4> 
<p><span style="font-family:'宋体';">     通过本章的学习了解类的继承，三种继承方式的区别，以及通过参数列表对派生类的成员赋值的方法，即调用基类构造函数后再对新增成员赋值，虚基类的使用时为了对基类数据保存一份拷贝，应注意的是在基类其他的直接派生类继承时也应声明是虚基类，多重继承时的应注意构造函数赋值的规律；只是在本次实验的操作过程中还是存在了很多的问题需要我们认真的去学习和思考，同时也让我意识到自己对于本次的实验中的一些知识点还没有掌握好，需要自己在课下多花时间来学习。</span></p> 
<br>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/68084e31d52ad58af548bde4fd80c8ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">unity如何用代码创建自已的logo</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ff2e01f6af1a593c852186f4ebaaade5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mybase数据文件损坏，在数据流里侦测到无效的版本号</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>