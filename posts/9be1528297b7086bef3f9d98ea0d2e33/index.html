<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>6、spring的五种类型通知 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="6、spring的五种类型通知" />
<meta property="og:description" content="spring共提供了五种类型的通知：
通知类型接口描述Around 环绕通知org.aopalliance.intercept.MethodInterceptor拦截对目标方法调用Before 前置通知org.springframework.aop.MethodBeforeAdvice 在目标方法调用前调用After 后置通知org.springframework.aop.AfterReturningAdvice在目标方法调用后调用Throws 异常通知org.springframework.aop.ThrowsAdvice当目标方法抛出异常时调用 还有一类是引入通知，用来定义切入点的。 上一篇里面已经介绍了前置通知，就是在方法被调用前先执行前置通知
现在介绍一下其他的通知：
1、后置通知：
后置通知类的写法：
package com.cdtax.aop; import java.lang.reflect.Method; import org.springframework.aop.AfterReturningAdvice; public class MyAfterReturningAdvice implements AfterReturningAdvice { @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(&#34;后置通知被：关闭资源，&#34;); } } 在beans.xml中的配置： &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;beans xmlns=&#34;http://www.springframework.org/schema/beans&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xmlns:context=&#34;http://www.springframework.org/schema/context&#34; xmlns:tx=&#34;http://www.springframework.org/schema/tx&#34; xsi:schemaLocation=&#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&#34;&gt; &lt;!-- 配置被代理的对象 --&gt; &lt;bean id=&#34;test1Service&#34; class=&#34;com.cdtax.aop.Test1Service&#34;&gt; &lt;property name=&#34;name&#34; value=&#34;小明&#34;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置前置通知 --&gt; &lt;bean id=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/9be1528297b7086bef3f9d98ea0d2e33/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-02-11T08:46:51+08:00" />
<meta property="article:modified_time" content="2014-02-11T08:46:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">6、spring的五种类型通知</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>spring共提供了五种类型的通知：</p> 
<p> </p> 
<table border="1" width="600" cellspacing="1" cellpadding="1"><tbody><tr><td>通知类型</td><td>接口</td><td>描述</td></tr><tr><td>Around 环绕通知</td><td>org.aopalliance.intercept.MethodInterceptor</td><td>拦截对目标方法调用</td></tr><tr><td>Before 前置通知</td><td>org.springframework.aop.MethodBeforeAdvice </td><td>在目标方法调用前调用</td></tr><tr><td>After  后置通知</td><td>org.springframework.aop.AfterReturningAdvice</td><td>在目标方法调用后调用</td></tr><tr><td>Throws 异常通知</td><td>org.springframework.aop.ThrowsAdvice</td><td>当目标方法抛出异常时调用</td></tr></tbody></table> 还有一类是引入通知，用来定义切入点的。 
<p></p> 
<p>上一篇里面已经介绍了前置通知，就是在方法被调用前先执行前置通知</p> 
<p>现在介绍一下其他的通知：</p> 
<p>1、后置通知：</p> 
<p>后置通知类的写法：</p> 
<p></p> 
<pre><code class="language-java">package com.cdtax.aop;

import java.lang.reflect.Method;

import org.springframework.aop.AfterReturningAdvice;

public class MyAfterReturningAdvice <span style="color:#ff0000;">implements AfterReturningAdvice</span>
{

	@Override
	public void afterReturning(Object returnValue, Method method,
			Object[] args, Object target) throws Throwable
	{
		System.out.println("后置通知被：关闭资源，");
	}

}
</code></pre>在beans.xml中的配置： 
<p></p> 
<p></p> 
<pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd
				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;

&lt;!-- 配置被代理的对象 --&gt;
&lt;bean id="test1Service" class="com.cdtax.aop.Test1Service"&gt;
	&lt;property name="name" value="小明"&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;!-- 配置前置通知 --&gt;
&lt;bean id="myMethodBeforeAdvice" class="com.cdtax.aop.MyMethodBeforeAdvice"&gt;&lt;/bean&gt;

<span style="color:#ff0000;">&lt;!-- 配置后置通知 --&gt;</span>
&lt;bean id="myAfterReturningAdvice" class="com.cdtax.aop.MyAfterReturningAdvice"&gt;&lt;/bean&gt;

&lt;!-- 配置代理对象 --&gt;
&lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt; 
&lt;!-- 代理接口集 --&gt;
	&lt;property name="proxyInterfaces"&gt;
		&lt;list&gt;
			&lt;value&gt;com.cdtax.aop.TestServiceInter&lt;/value&gt;
			&lt;value&gt;com.cdtax.aop.TestServiceInter2&lt;/value&gt;
		&lt;/list&gt;
	&lt;/property&gt;
	
	&lt;!-- 把通知织入到代理对象  | 拦截器名集--&gt;
	&lt;property name="interceptorNames"&gt;
		&lt;list&gt;
		&lt;!-- 相当于把 MyMethodBeforeAdvice前置通知和代理对象关联起来，我们也可以把通知看成拦截器，struts2核心就是拦截器 --&gt;
		 &lt;value&gt;myMethodBeforeAdvice&lt;/value&gt; 
				
		<span style="color:#ff0000;">&lt;!-- 织入后置通知 --&gt;</span>
		&lt;value&gt;myAfterReturningAdvice&lt;/value&gt;
				
		&lt;/list&gt;
	&lt;/property&gt;
	
	&lt;!-- 配置被代理对象，可以指定 --&gt;
	&lt;property name="target" ref="test1Service"&gt;
		
	&lt;/property&gt;
&lt;/bean&gt;
&lt;/beans&gt;</code></pre> 
<br> 测试类： 
<p></p> 
<p></p> 
<pre><code class="language-java">package com.cdtax.aop;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App1
{
	public static void main(String[] args)
	{
		ApplicationContext ac = new ClassPathXmlApplicationContext("com/cdtax/aop/beans.xml");
		
//		Test1Service ts = (Test1Service) ac.getBean("test1Service");
//		ts.sayHello();
		
		TestServiceInter ts1 =  (TestServiceInter) ac.getBean("proxyFactoryBean");
		ts1.sayHello();
		((TestServiceInter2)ts1).sayBye();
	}
}
</code></pre> 
<br> 执行结果： 
<p></p> 
<p>-----------------------------<br> 前置通知  ：记录日志...sayHello<br> hai 小明<br> 后置通知被调用：关闭资源，<br> -----------------------------<br> 前置通知  ：记录日志...sayBye<br> bye 小明<br> 后置通知被调用：关闭资源，<br> <br> </p> 
<p>2、环绕通知</p> 
<p></p> 
<pre><code class="language-java">package com.cdtax.aop;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

public class MyMethodInterceptor <span style="color:#ff0000;">implements MethodInterceptor</span>
{

	@Override
	public Object invoke(MethodInvocation arg0) throws Throwable
	{
		System.out.println("环绕通知被调用：调用方法前执行  ");
		Object obj = arg0.proceed();
		System.out.println("环绕通知被调用：调用方法后执行   ");
		return obj;
	}
}</code></pre> 
<br> 配置beans.xml 
<p></p> 
<p></p> 
<pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd
				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;

&lt;!-- 配置被代理的对象 --&gt;
&lt;bean id="test1Service" class="com.cdtax.aop.Test1Service"&gt;
	&lt;property name="name" value="小明"&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;!-- 配置前置通知 --&gt;
&lt;bean id="myMethodBeforeAdvice" class="com.cdtax.aop.MyMethodBeforeAdvice"&gt;&lt;/bean&gt;

&lt;!-- 配置后置通知 --&gt;
&lt;bean id="myAfterReturningAdvice" class="com.cdtax.aop.MyAfterReturningAdvice"&gt;&lt;/bean&gt;

<span style="color:#ff0000;">&lt;!-- 配置环绕通知 --&gt;</span>
&lt;bean id="myMethodInterceptor" class="com.cdtax.aop.MyMethodInterceptor"&gt;&lt;/bean&gt;


&lt;!-- 配置代理对象 --&gt;
&lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt; 
&lt;!-- 代理接口集 --&gt;
	&lt;property name="proxyInterfaces"&gt;
		&lt;list&gt;
			&lt;value&gt;com.cdtax.aop.TestServiceInter&lt;/value&gt;
			&lt;value&gt;com.cdtax.aop.TestServiceInter2&lt;/value&gt;
		&lt;/list&gt;
	&lt;/property&gt;
	
	&lt;!-- 把通知织入到代理对象  | 拦截器名集--&gt;
	&lt;property name="interceptorNames"&gt;
		&lt;list&gt;
		&lt;!-- 相当于把 MyMethodBeforeAdvice前置通知和代理对象关联起来，我们也可以把通知看成拦截器，struts2核心就是拦截器 --&gt;
		 &lt;value&gt;myMethodBeforeAdvice&lt;/value&gt; 
				
		&lt;!-- 织入后置通知 --&gt;
		&lt;value&gt;myAfterReturningAdvice&lt;/value&gt;
		
		<span style="color:#ff0000;">&lt;!-- 织入环绕通知 --&gt;</span>
		&lt;value&gt;myMethodInterceptor&lt;/value&gt;
				
		&lt;/list&gt;
	&lt;/property&gt;
	
	&lt;!-- 配置被代理对象，可以指定 --&gt;
	&lt;property name="target" ref="test1Service"&gt;
		
	&lt;/property&gt;
&lt;/bean&gt;
&lt;/beans&gt;</code></pre> 
<br> 执行App1测试类，执行结果： 
<p></p> 
<p>-----------------------------<br> 前置通知  ：记录日志...sayHello<br> 环绕通知被调用：调用方法前执行  <br> hai 小明<br> 环绕通知被调用：调用方法后执行   <br> 后置通知被调用：关闭资源，<br> -----------------------------<br> 前置通知  ：记录日志...sayBye<br> 环绕通知被调用：调用方法前执行  <br> bye 小明<br> 环绕通知被调用：调用方法后执行   <br> 后置通知被调用：关闭资源，<br> </p> 
<p>3、异常通知：</p> 
<p>修改Test1Service类，</p> 
<p></p> 
<pre><code class="language-java">package com.cdtax.aop;

public class Test1Service implements TestServiceInter,TestServiceInter2
{

	private String name;
	
	public String getName()
	{
		return name;
	}

	public void setName(String name)
	{
		this.name = name;
	}

	@Override
	public void sayHello()
	{
		System.out.println("hai " + name);
	}

	@Override
	public void sayBye()
	{
		System.out.println("bye " + name);
		<span style="color:#ff0000;">int i = 9 / 0;</span>
	}
}</code></pre> 
<br> 在sayBye（）方法中增加一个除零异常 
<p></p> 
<p>编写异常通知：</p> 
<p></p> 
<pre><code class="language-java">package com.cdtax.aop;

import java.lang.reflect.Method;

import org.springframework.aop.ThrowsAdvice;

public class MyThrowsAdvice <span style="color:#ff0000;">implements ThrowsAdvice</span>
{
	public void afterThrowing(Method m,Object[] os,Object target,Exception throwable)
	{
		System.out.println("异常通知：出大事了" + throwable.getMessage());
	}
}
</code></pre> 
<br> 在beans.xml中配置： 
<p></p> 
<p></p> 
<pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd
				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;

&lt;!-- 配置被代理的对象 --&gt;
&lt;bean id="test1Service" class="com.cdtax.aop.Test1Service"&gt;
	&lt;property name="name" value="小明"&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;!-- 配置前置通知 --&gt;
&lt;bean id="myMethodBeforeAdvice" class="com.cdtax.aop.MyMethodBeforeAdvice"&gt;&lt;/bean&gt;

&lt;!-- 配置后置通知 --&gt;
&lt;bean id="myAfterReturningAdvice" class="com.cdtax.aop.MyAfterReturningAdvice"&gt;&lt;/bean&gt;

&lt;!-- 配置环绕通知 --&gt;
&lt;bean id="myMethodInterceptor" class="com.cdtax.aop.MyMethodInterceptor"&gt;&lt;/bean&gt;

<span style="color:#ff0000;">&lt;!-- 配置异常通知 --&gt;</span>
&lt;bean id="myThrowsAdvice" class="com.cdtax.aop.MyThrowsAdvice"&gt;&lt;/bean&gt;

&lt;!-- 配置代理对象 --&gt;
&lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt; 
&lt;!-- 代理接口集 --&gt;
	&lt;property name="proxyInterfaces"&gt;
		&lt;list&gt;
			&lt;value&gt;com.cdtax.aop.TestServiceInter&lt;/value&gt;
			&lt;value&gt;com.cdtax.aop.TestServiceInter2&lt;/value&gt;
		&lt;/list&gt;
	&lt;/property&gt;
	
	&lt;!-- 把通知织入到代理对象  | 拦截器名集--&gt;
	&lt;property name="interceptorNames"&gt;
		&lt;list&gt;
		&lt;!-- 相当于把 MyMethodBeforeAdvice前置通知和代理对象关联起来，我们也可以把通知看成拦截器，struts2核心就是拦截器 --&gt;
		 &lt;!-- 织入前置通知 --&gt;
		 &lt;value&gt;myMethodBeforeAdvice&lt;/value&gt; 
				
		&lt;!-- 织入后置通知 --&gt;
		&lt;value&gt;myAfterReturningAdvice&lt;/value&gt;
		
		&lt;!-- 织入环绕通知 --&gt;
		&lt;value&gt;myMethodInterceptor&lt;/value&gt;
		
		<span style="color:#ff0000;">&lt;!-- 织入异常通知 --&gt;</span>
		&lt;value&gt;myThrowsAdvice&lt;/value&gt;
				
		&lt;/list&gt;
	&lt;/property&gt;
	
	&lt;!-- 配置被代理对象，可以指定 --&gt;
	&lt;property name="target" ref="test1Service"&gt;
		
	&lt;/property&gt;
&lt;/bean&gt;
&lt;/beans&gt;</code></pre> 
<br> 运行App1测试类结果： 
<p></p> 
<p>-----------------------------<br> 前置通知  ：记录日志...sayHello<br> 环绕通知被调用：调用方法前执行  <br> hai 小明<br> 环绕通知被调用：调用方法后执行   <br> 后置通知被调用：关闭资源，<br> -----------------------------<br> 前置通知  ：记录日志...sayBye<br> 环绕通知被调用：调用方法前执行  <br> bye 小明<br> <span style="color:#ff0000">异常通知：出大事了/ by zero</span><br> Exception in thread "main" java.lang.ArithmeticException: / by zero<br> <span style="white-space:pre"></span>at com.cdtax.aop.Test1Service.sayBye(Test1Service.java:28)<br> <span style="white-space:pre"></span>at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br> <span style="white-space:pre"></span>at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)<br> <span style="white-space:pre"></span>at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)<br> <span style="white-space:pre"></span>at java.lang.reflect.Method.invoke(Method.java:597)<br> <span style="white-space:pre"></span>at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:307)<br> <span style="white-space:pre"></span>at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:182)<br> <span style="white-space:pre"></span>at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:149)<br> <span style="white-space:pre"></span>at org.springframework.aop.framework.adapter.ThrowsAdviceInterceptor.invoke(ThrowsAdviceInterceptor.java:126)<br> <span style="white-space:pre"></span>at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)<br> <span style="white-space:pre"></span>at com.cdtax.aop.MyMethodInterceptor.invoke(MyMethodInterceptor.java:13)<br> <span style="white-space:pre"></span>at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)<br> <span style="white-space:pre"></span>at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:50)<br> <span style="white-space:pre"></span>at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)<br> <span style="white-space:pre"></span>at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:50)<br> <span style="white-space:pre"></span>at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)<br> <span style="white-space:pre"></span>at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)<br> <span style="white-space:pre"></span>at $Proxy0.sayBye(Unknown Source)<br> <span style="white-space:pre"></span>at com.cdtax.aop.App1.main(App1.java:17)<br> </p> 
<p>4、最后一个是引入通知，引入通知不需要编写相应的类，只需要进行配置，目的是用来指定哪些方法需要执行相应的通知，如，我们想指定只有sayHello（）方法执行前置通知，</p> 
<p>在beans.xml中如下配置：</p> 
<p></p> 
<pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd
				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;

&lt;!-- 配置被代理的对象 --&gt;
&lt;bean id="test1Service" class="com.cdtax.aop.Test1Service"&gt;
	&lt;property name="name" value="小明"&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;!-- 配置前置通知 --&gt;
&lt;bean id="myMethodBeforeAdvice" class="com.cdtax.aop.MyMethodBeforeAdvice"&gt;&lt;/bean&gt;

&lt;!-- 配置后置通知 --&gt;
&lt;bean id="myAfterReturningAdvice" class="com.cdtax.aop.MyAfterReturningAdvice"&gt;&lt;/bean&gt;

&lt;!-- 配置环绕通知 --&gt;
&lt;bean id="myMethodInterceptor" class="com.cdtax.aop.MyMethodInterceptor"&gt;&lt;/bean&gt;

&lt;!-- 配置异常通知 --&gt;
&lt;bean id="myThrowsAdvice" class="com.cdtax.aop.MyThrowsAdvice"&gt;&lt;/bean&gt;

<span style="color:#ff0000;">&lt;!-- 定义前置通知的切入点 （引用通知） --&gt;
&lt;bean id="myMethodBeforeAdviceFilter" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor"&gt;
	&lt;property name="advice" ref="myMethodBeforeAdvice"&gt;&lt;/property&gt;
	&lt;property name="mappedNames"&gt;
		&lt;list&gt;
			&lt;value&gt;sayHello&lt;/value&gt;
		&lt;/list&gt;
	&lt;/property&gt;
&lt;/bean&gt;</span>

&lt;!-- 配置代理对象 --&gt;
&lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt; 
&lt;!-- 代理接口集 --&gt;
	&lt;property name="proxyInterfaces"&gt;
		&lt;list&gt;
			&lt;value&gt;com.cdtax.aop.TestServiceInter&lt;/value&gt;
			&lt;value&gt;com.cdtax.aop.TestServiceInter2&lt;/value&gt;
		&lt;/list&gt;
	&lt;/property&gt;
	
	&lt;!-- 把通知织入到代理对象  | 拦截器名集--&gt;
	&lt;property name="interceptorNames"&gt;
		&lt;list&gt;
		&lt;!-- 相当于把 MyMethodBeforeAdvice前置通知和代理对象关联起来，我们也可以把通知看成拦截器，struts2核心就是拦截器 --&gt;
		&lt;!-- &lt;value&gt;myMethodBeforeAdvice&lt;/value&gt;   --&gt;
		
		<span style="color:#ff0000;">&lt;!-- 使用自定义切入点的前置通知 --&gt;
		&lt;value&gt;myMethodBeforeAdviceFilter&lt;/value&gt;</span>
				
		&lt;!-- 织入后置通知 --&gt;
		&lt;value&gt;myAfterReturningAdvice&lt;/value&gt;
		
		&lt;!-- 织入环绕通知 --&gt;
		&lt;value&gt;myMethodInterceptor&lt;/value&gt;
		
		&lt;!-- 织入异常通知 --&gt;
		&lt;value&gt;myThrowsAdvice&lt;/value&gt;
				
		&lt;/list&gt;
	&lt;/property&gt;
	
	&lt;!-- 配置被代理对象，可以指定 --&gt;
	&lt;property name="target" ref="test1Service"&gt;
		
	&lt;/property&gt;
&lt;/bean&gt;
&lt;/beans&gt;</code></pre>更改Test1Service的sayBye（）方法，去掉除零异常这一步，执行App1测试类结果： 
<p></p> 
<p>-----------------------------<br> 前置通知  ：记录日志...sayHello<br> 环绕通知被调用：调用方法前执行  <br> hai 小明<br> 环绕通知被调用：调用方法后执行   <br> 后置通知被调用：关闭资源，<br> 环绕通知被调用：调用方法前执行  <br> bye 小明<br> 环绕通知被调用：调用方法后执行   <br> 后置通知被调用：关闭资源，</p> 
<p>可以看到，只有sayHello（）方法执行了前置通知，sayBye（）方法没有执行</p> 
<p>这就是引用通知，用来定义切入点的。</p> 
<p>5、关于ts1的类型，</p> 
<p></p> 
<pre><code class="language-java">package com.cdtax.aop;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App1
{
	public static void main(String[] args)
	{
		ApplicationContext ac = new ClassPathXmlApplicationContext("com/cdtax/aop/beans.xml");
		
//		Test1Service ts = (Test1Service) ac.getBean("test1Service");
//		ts.sayHello();
		
		TestServiceInter ts1 =  (TestServiceInter) ac.getBean("proxyFactoryBean");
		ts1.sayHello();
		<span style="color:#cc0000;">System.out.println("ts1的类型：" + ts1);</span>
		((TestServiceInter2)ts1).sayBye();
	}
}</code></pre>我们获得ts1是通过getBean("proxyFactoryBean");获得的，proxyFactoryBean的class是org.springframework.aop.framework.ProxyFactoryBean，那么ts1的类型是不是也是它呢？运行上述程序，结果： 
<p></p> 
<p>-----------------------------<br> 前置通知  ：记录日志...sayHello<br> 环绕通知被调用：调用方法前执行  <br> hai 小明<br> 环绕通知被调用：调用方法后执行   <br> 后置通知被调用：关闭资源，<br> 环绕通知被调用：调用方法前执行  <br> 环绕通知被调用：调用方法后执行   <br> 后置通知被调用：关闭资源，<br> <span style="color:#cc0000">ts1的类型：com.cdtax.aop.Test1Service@1982fc1</span><br> 环绕通知被调用：调用方法前执行  <br> bye 小明<br> 环绕通知被调用：调用方法后执行   <br> 后置通知被调用：关闭资源，<br> <br> 可以看出，ts1的类型是<span style="color:rgb(204,0,0)">com.cdtax.aop.Test1Service，</span>它是proxyFactoryBean动态代理生成的。org.springframework.aop.framework.ProxyFactoryBean内部实现了动态代理方式。</p> 
<p>spring在运行期创建代理，不需要特殊的编译器，spring有两种代理方式：</p> 
<p>（1）若目标对象实现了若干接口，spring使用JDK的java.lang.reflect.Proxy类代理该类让spring动态产生一个新类，他实现了所需的接口，织入了通知，并且代理对目标对象的所有请求。<br> （2）若目标对象没有实现任何接口，spring使用CGLIB库生成目标对象的子类。使用该方式时需要注意：<br>         1）对接口创建代理优先于对类创建代理，因为会产生更加松耦合的系统。对类代理是让遗留系统或无法实现接口的第三方类库同样可以得到通知，这种方式应该是beiyongfang'an。<br>         2）标记为final的方法不能够被通知。spring是为目标类产生子类。任何需要被通知的方法都被复写。将通知织入。final方法是不允许重写的。</p> 
<p>spring实现了aop联盟接口。</p> 
<p>spring只支持方法连接点：不提供属性接入点，spring的观点是属性拦截破坏了封装。面向对象的概念是对象自己处理工作，其他对象只能通过方法调用来得到结果。</p> 
<p>6、对于引入通知，定义切面时可以使用正则表达式，如在定义切入点时使用say*，表示以say开头的所有方法。</p> 
<p><br> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f37a04edd2b6aa6d0726e35c5e0c2e5b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Hibernate  hql查询语句 Count：统计函数 Min：求最小值函数 Max：求最大值函数 Sum：求和函数 Avg：求平均数函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/40d1516108ff28f48bac0e88ac174a84/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Sqlserver 异常处理，常见问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>