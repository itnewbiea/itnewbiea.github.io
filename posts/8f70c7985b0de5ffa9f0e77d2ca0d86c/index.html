<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>voc数据集_目标检测数据集的增强（旋转，镜像，亮度等）含针对VOC标注格式数据的源码... - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="voc数据集_目标检测数据集的增强（旋转，镜像，亮度等）含针对VOC标注格式数据的源码..." />
<meta property="og:description" content="对目标检测数据集的增强方案有很多，网上的资料写的零零散散，而且我好像没有找到一个系统完整的针对某套完整数据集的源码，这两天自己写了几个增强方案的源码，针对的是voc格式的数据集！
只要有自己标注好的数据，按VOC格式组织好文件，就能用上这套代码。比如目前只有几百张数据，那么这样增强后会大大的扩充自己的数据集。
源码地址​github.com 目录 0对图像/标签的旋转
1不损失图像信息的旋转
2对图像/标签的镜像
3对原图和标签的亮度/对比度变换
0对图像/标签的旋转 难点在于对标签的旋转，前面其实我有写过一篇文章介绍过旋转大致原理
lim0：目标检测增强数据——旋转目标和对应标签​zhuanlan.zhihu.com 前面的文章的代码只是针对一张图片的一个demo。本文会给出一个具体的处理VOC数据集格式的完整代码，涉及对.xml文件的基本操作，以及对文件，文件夹的基本操作，虽然都很基础，但是很多细节还是值得记录:
需要处理的数据文件树(VOC数据格式)
|---Annotations
----0.xml
......
----XX.xml
|---JPEGImages
----0.jpg
......
----XX..jpg
#定义旋转图像文件的函数 def getRotatedImg(Pi_angle,img_path,img_write_path): img = cv2.imread(img_path) ..... ###详细代码见github rotated_img = cv2.warpAffine(img, M, (cols, rows)) # 旋转后的图像保持大小不变 cv2.imwrite(img_write_path,rotated_img) return a,b #定义处理.xml文件的函数 def getRotatedAnno(Pi_angle,a,b,anno_path,anno_write_path): tree = ET.parse(anno_path) root = tree.getroot() objects = root.findall(&#34;object&#34;) for obj in objects: ..... ###详细代码见github tree.write(anno_write_path) # 保存修改后的XML文件 def rotate(angle,img_dir,anno_dir,img_write_dir,anno_write_dir): if not os.path.exists(img_write_dir): os.makedirs(img_write_dir) if not os." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8f70c7985b0de5ffa9f0e77d2ca0d86c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-11T22:23:48+08:00" />
<meta property="article:modified_time" content="2020-12-11T22:23:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">voc数据集_目标检测数据集的增强（旋转，镜像，亮度等）含针对VOC标注格式数据的源码...</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <p>对目标检测数据集的增强方案有很多，网上的资料写的零零散散，而且我好像没有找到一个系统完整的针对某套完整数据集的源码，这两天自己写了几个增强方案的源码，针对的是voc格式的数据集！</p> 
 <p>只要有自己标注好的数据，按VOC格式组织好文件，就能用上这套代码。比如目前只有几百张数据，那么这样增强后会大大的扩充自己的数据集。</p> 
 源码地址​github.com 
 <h4>目录</h4> 
 <p> 0对图像/标签的旋转</p> 
 <p> 1不损失图像信息的旋转</p> 
 <p> 2对图像/标签的镜像</p> 
 <p> 3对原图和标签的亮度/对比度变换</p> 
 <h4>0对图像/标签的旋转</h4> 
 <p>难点在于对标签的旋转，前面其实我有写过一篇文章介绍过旋转大致原理</p> 
  
 lim0：目标检测增强数据——旋转目标和对应标签​zhuanlan.zhihu.com 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>前面的文章的代码只是针对一张图片的一个demo。本文会给出一个具体的处理VOC数据集格式的完整代码，涉及对.xml文件的基本操作，以及对文件，文件夹的基本操作，虽然都很基础，但是很多细节还是值得记录:</p> 
 <p>需要处理的数据文件树(VOC数据格式)</p> 
 <p>|---Annotations</p> 
 <p> ----0.xml</p> 
 <p> ......</p> 
 <p> ----XX.xml</p> 
 <p>|---JPEGImages</p> 
 <p> ----0.jpg</p> 
 <p> ......</p> 
 <p> ----XX..jpg</p> 
 <div class="has"> 
  <pre class="has"><code>#定义旋转图像文件的函数
def getRotatedImg(Pi_angle,img_path,img_write_path):
    img = cv2.imread(img_path)
    .....
        ###详细代码见github
    rotated_img = cv2.warpAffine(img, M, (cols, rows))  # 旋转后的图像保持大小不变
    cv2.imwrite(img_write_path,rotated_img)
    return a,b
#定义处理.xml文件的函数
def getRotatedAnno(Pi_angle,a,b,anno_path,anno_write_path):
    tree = ET.parse(anno_path)
    root = tree.getroot()
    objects = root.findall("object")
    for obj in objects:
        .....
        ###详细代码见github
    tree.write(anno_write_path)  # 保存修改后的XML文件

def rotate(angle,img_dir,anno_dir,img_write_dir,anno_write_dir):
    if not os.path.exists(img_write_dir):
        os.makedirs(img_write_dir)
    if not os.path.exists(anno_write_dir):
        os.makedirs(anno_write_dir)
    Pi_angle = -angle * math.pi / 180.0  # 弧度制，后面旋转坐标需要用到，注意负号！！！
    img_names=os.listdir(img_dir)
    for img_name in img_names:
        .....
        ###详细代码见github
        #
        a,b=getRotatedImg(Pi_angle,img_path,img_write_path)
        getRotatedAnno(Pi_angle,a,b,anno_path,anno_write_path)

angles=[-30,30,.....]
img_dir='several/JPEGImages'
anno_dir='several/Annotations'
img_write_dir='Rotated/rotated_JPEGImages'
anno_write_dir='Rotated/rotated_Annotations'
for angle in angles:
    rotate(angle,img_dir,anno_dir,img_write_dir,anno_write_dir)</code></pre> 
 </div> 
 <h4>1不损失图像信息的旋转</h4> 
 <p>由于图像的旋转会使得一部分信息损失(可以脑补)，而且不是很容易的判断旋转后的图像是否还包含我们的完整目标。 因此可以尝试把原图像先安装长/短边的长度填充为一个正方形，这样可以确保填充后的图像在旋转过程中，原图中的目标信息不会丢失。 然后可以旋转作一个裁剪（根据目标的标签坐标，只要避开旋转后的标签坐标就能很好的裁剪出图像），当然也可以不裁剪，但是这样会降低模型 训练的效率</p> 
 <div class="has"> 
  <pre class="has"><code>img=cv2.imread('14h.jpg')
rows, cols = img.shape[:2]
##填充图像为正方形，而且要能保证填充后的图像在0到360°旋转的时候，原图像的像素不会损失
re=cv2.copyMakeBorder(img,int(cols/2),int(cols/2),int(rows/2),int(rows/2),cv2.BORDER_CONSTANT)

def getRotatedImg(Pi_angle,img_path,img_write_path):
    img = cv2.imread(img_path)
    rows, cols = img.shape[:2]
    a, b = cols / 2, rows / 2
    M = cv2.getRotationMatrix2D((a, b), angle, 1)
    rotated_img = cv2.warpAffine(img, M, (cols, rows))  # 旋转后的图像保持大小不变
    cv2.imwrite(img_write_path,rotated_img)

for angle in range(0,180,30):
    Pi_angle = -angle * math.pi / 180.0
    img_path='re.jpg'
    img_write_path=str(angle)+'.jpg'
    getRotatedImg(Pi_angle, img_path, img_write_path)

#验证是否标签被正确的改变
#for origin image: xmin:606 ymin:489 xmax:855 ymax:1023
cv2.rectangle(re,(606+int(rows/2),489+int(cols/2)),(855+int(rows/2),1023+int(cols/2)),(0,255,0),4)
#
def crop():
    pass</code></pre> 
 </div> 
 <h4>2对图像/标签的镜像</h4> 
 <p>该部分主要是对图像进行水平，竖直，对角的镜像变换。 对图像的操作cv2.flip()；对标签的变化其实就是利用原图的长宽来减去原像素，三种情况有所不同，但很好理解，只是有些细节需要注意，见代码！ 注：对原图的对角镜像其实等价于对原图旋转180°。原代码全部贴出来太多了，这里只展示结构，详细代码请见作者github，文章开头已经给出</p> 
 <p>W,H代表图像的尺度</p> 
 <p> x_<i>out=W-x_in</i> 水平只是x变，y不变</p> 
 <p> y_<i>out=W-y_in</i> 竖直只是y变，x不变</p> 
 <p> 对角X变，y变</p> 
 <p>注意细节就是变完后的：xmin,xmax,ymin,ymax是哪一个，自己要判断好，见代码！！！</p> 
 <div class="has"> 
  <pre class="has"><code>def h_MirrorImg(img_path,img_write_path):
    img = cv2.imread(img_path)
    mirror_img = cv2.flip(img, 1)                #水平镜像
    cv2.imwrite(img_write_path,mirror_img)
def v_MirrorImg(img_path,img_write_path):
    pass                                       #竖直镜像
def a_MirrorImg(img_path,img_write_path):
    pass                                    #对角镜像

def h_MirrorAnno(anno_path,anno_write_path):
    tree = ET.parse(anno_path)
    root = tree.getroot()
    size=root.find('size')
    w=int(size.find('width').text)
    objects = root.findall("object")
    for obj in objects:
        bbox = obj.find('bndbox')
        x1 = float(bbox.find('xmin').text)
        x2 = float(bbox.find('xmax').text)
        x1=w-x1+1 #这就是镜像后的坐标和原坐标的对应关系，但为了避免为0或小于0最好加1
        x2=w-x2+1
        assert x1&gt;0
        assert x2&gt;0
        bbox.find('xmin').text=str(int(x2))      #细节:是x2而不是x1
        bbox.find('xmax').text=str(int(x1))
    tree.write(anno_write_path)  # 保存修改后的XML文件

def v_MirrorAnno(anno_path,anno_write_path):          #竖直镜像标签的处理
    pass ###详细代码见github
    tree.write(anno_write_path)  

def a_MirrorAnno(anno_path,anno_write_path):         #对角镜像标签的处理

    pass ###详细代码见github
    tree.write(anno_write_path)  

def mirror(img_dir,anno_dir,img_write_dir,anno_write_dir):
    for img_name in img_names:
         ###详细代码见github
</code></pre> 
 </div> 
 <h4>3对原图和标签的亮度/对比度变换</h4> 
 <p>该部分本还应该有对图像的颜色变换，下次更新！</p> 
 <p>对亮度和对比度的调节利用的是对像素的简单线性变换，就是一个一次函数</p> 
 <p> output_pixel=alpha*(input_pixel)+beta</p> 
 <div class="has"> 
  <pre class="has"><code>def getColorImg(alpha,beta,img_path,img_write_path):
    img = cv2.imread(img_path)
    colored_img = np.uint8(np.clip((alpha * img + beta), 0, 255))
    cv2.imwrite(img_write_path,colored_img)

def getColorAnno(anno_path,anno_write_path):
    tree = ET.parse(anno_path)
    tree.write(anno_write_path)  # 标签不用变，因为变换后的图像和原图是一样大小

def color(alpha,beta,img_dir,anno_dir,img_write_dir,anno_write_dir):
    ####详细代码见github
    for img_name in img_names:
       ###详细代码见github
        getColorImg(alpha,beta,img_path,img_write_path)
        getColorAnno(anno_path,anno_write_path)

alphas=[0.3,0.5,1.2,1.6]
beta=10</code></pre> 
 </div> 
 <p>后面有时间的话还会继续补充给出一些其它方案的代码</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d1b73db76ffb77189bc10d3199fc7fe9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">编程语言难度排名_当前最流行的十大编程语言都有哪些用途和优缺点？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/09442db946d64a3472de84c43de5830f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JSP页面的内容及JSP页面工作原理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>