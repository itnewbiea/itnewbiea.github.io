<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈" />
<meta property="og:description" content="转载请注明出处： http://kyang.cc/ 栈是什么？栈有什么作用？ 首先，栈 (stack) 是一种串列形式的 数据结构。这种数据结构的特点是 后入先出 (LIFO, Last In First Out)，数据只能在串列的一端 (称为：栈顶 top) 进行 推入 (push) 和 弹出 (pop) 操作。根据栈的特点，很容易的想到可以利用数组，来实现这种数据结构。但是本文要讨论的并不是软件层面的栈，而是硬件层面的栈。
大多数的处理器架构，都有实现硬件栈。有专门的栈指针寄存器，以及特定的硬件指令来完成 入栈/出栈 的操作。例如在 ARM 架构上，R13 (SP) 指针是堆栈指针寄存器，而 PUSH 是用于压栈的汇编指令，POP 则是出栈的汇编指令。
【扩展阅读】：ARM 寄存器简介
ARM 处理器拥有 37 个寄存器。 这些寄存器按部分重叠组方式加以排列。 每个处理器模式都有一个不同的寄存器组。 编组的寄存器为处理处理器异常和特权操作提供了快速的上下文切换。
提供了下列寄存器： - 三十个 32 位通用寄存器： - 存在十五个通用寄存器，它们分别是 r0-r12、sp、lr - sp (r13) 是堆栈指针。C/C&#43;&#43; 编译器始终将 sp 用作堆栈指针 - lr (r14) 用于存储调用子例程时的返回地址。如果返回地址存储在堆栈上，则可将 lr 用作通用寄存器 - 程序计数器 (pc)：指令寄存器 - 应用程序状态寄存器 (APSR)：存放算术逻辑单元 (ALU) 状态标记的副本 - 当前程序状态寄存器 (CPSR)：存放 APSR 标记，当前处理器模式，中断禁用标记等 - 保存的程序状态寄存器 (SPSR)：当发生异常时，使用 SPSR 来存储 CPSR" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/3dd69eab46ae4cf1cb3bff6d6a150c78/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-09-01T21:52:02+08:00" />
<meta property="article:modified_time" content="2016-09-01T21:52:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><font color="red"> <strong>转载请注明出处：</strong> <a href="http://kyang.cc/" rel="nofollow">http://kyang.cc/</a> </font></p> 
<h3 id="栈是什么栈有什么作用">栈是什么？栈有什么作用？</h3> 
<p>首先，栈 (stack) 是一种串列形式的 <strong>数据结构</strong>。这种数据结构的特点是 <strong>后入先出</strong> (LIFO, Last In First Out)，数据只能在串列的一端 (称为：栈顶 top) 进行 <strong>推入</strong> (push) 和 <strong>弹出</strong> (pop) 操作。根据栈的特点，很容易的想到可以利用数组，来实现这种数据结构。但是本文要讨论的并不是软件层面的栈，而是硬件层面的栈。</p> 
<p><img src="https://images2.imgbox.com/55/3a/BwR7aoIj_o.png" alt="栈结构" title=""></p> 
<p>大多数的处理器架构，都有实现硬件栈。有专门的栈指针寄存器，以及特定的硬件指令来完成 入栈/出栈 的操作。例如在 ARM 架构上，R13 (SP) 指针是堆栈指针寄存器，而 PUSH 是用于压栈的汇编指令，POP 则是出栈的汇编指令。</p> 
<blockquote> 
 <p>【扩展阅读】：<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204ic/Babefbce.html" rel="nofollow">ARM 寄存器简介</a></p> 
 <p>ARM 处理器拥有 37 个寄存器。 这些寄存器按部分重叠组方式加以排列。 每个处理器模式都有一个不同的寄存器组。 编组的寄存器为处理处理器异常和特权操作提供了快速的上下文切换。</p> 
 <p>提供了下列寄存器： <br> - 三十个 32 位通用寄存器： <br> - 存在十五个通用寄存器，它们分别是 r0-r12、sp、lr <br> - sp (r13) 是堆栈指针。C/C++ 编译器始终将 sp 用作堆栈指针 <br> - lr (r14) 用于存储调用子例程时的返回地址。如果返回地址存储在堆栈上，则可将 lr 用作通用寄存器 <br> - 程序计数器 (pc)：指令寄存器 <br> - 应用程序状态寄存器 (APSR)：存放算术逻辑单元 (ALU) 状态标记的副本 <br> - 当前程序状态寄存器 (CPSR)：存放 APSR 标记，当前处理器模式，中断禁用标记等 <br> - 保存的程序状态寄存器 (SPSR)：当发生异常时，使用 SPSR 来存储 CPSR</p> 
</blockquote> 
<p>上面是栈的原理和实现，下面我们来看看栈有什么作用。栈作用可以从两个方面体现：<strong>函数调用</strong> 和 <strong>多任务支持</strong> 。</p> 
<h4 id="一函数调用">一、函数调用</h4> 
<p>我们知道一个函数调用有以下三个基本过程： <br> - 调用参数的传入 <br> - 局部变量的空间管理 <br> - 函数返回</p> 
<p>函数的调用必须是高效的，而数据存放在 <strong>CPU通用寄存器</strong> 或者 <strong>RAM 内存</strong> 中无疑是最好的选择。以传递调用参数为例，我们可以选择使用 CPU通用寄存器 来存放参数。但是通用寄存器的数目都是有限的，当出现函数嵌套调用时，子函数再次使用原有的通用寄存器必然会导致冲突。因此如果想用它来传递参数，那在调用子函数前，就必须先 <strong>保存原有寄存器的值</strong>，然后当子函数退出的时候再 <strong>恢复原有寄存器的值</strong> 。</p> 
 
<p>函数的调用参数数目一般都相对少，因此通用寄存器是可以满足一定需求的。但是局部变量的数目和占用空间都是比较大的，再依赖有限的通用寄存器未免强人所难，因此我们可以采用某些 RAM 内存区域来存储局部变量。但是存储在哪里合适？既不能让函数嵌套调用的时候有冲突，又要注重效率。</p> 
<p>这种情况下，栈无疑提供很好的解决办法。一、对于通用寄存器传参的冲突，我们可以再调用子函数前，将通用寄存器临时压入栈中；在子函数调用完毕后，在将已保存的寄存器再弹出恢复回来。二、而局部变量的空间申请，也只需要向下移动下栈顶指针；将栈顶指针向回移动，即可就可完成局部变量的空间释放；三、对于函数的返回，也只需要在调用子函数前，将返回地址压入栈中，待子函数调用结束后，将函数返回地址弹出给 PC 指针，即完成了函数调用的返回；</p> 
<p>于是上述函数调用的三个基本过程，就演变记录一个栈指针的过程。每次函数调用的时候，都配套一个栈指针。即使循环嵌套调用函数，只要对应函数栈指针是不同的，也不会出现冲突。</p> 
<p><img src="https://images2.imgbox.com/5f/ab/fX7ET6IF_o.png" alt="函数栈结构" title=""></p> 
<blockquote> 
 <p>【扩展阅读】：<a href="http://www.cnblogs.com/clover-toeic/p/3755401.html" rel="nofollow">函数栈帧 (Stack Frame)</a></p> 
 <p>函数调用经常是嵌套的，在同一时刻，栈中会有多个函数的信息。每个未完成运行的函数占用一个独立的连续区域，称作栈帧(Stack Frame)。栈帧存放着函数参数，局部变量及恢复前一栈帧所需要的数据等，函数调用时入栈的顺序为：</p> 
 <p>实参N~1 → 主调函数返回地址 → 主调函数帧基指针EBP → 被调函数局部变量1~N</p> 
 <p>栈帧的边界由 <strong>栈帧基地址指针 EBP</strong> 和 <strong>栈指针 ESP</strong> 界定，EBP 指向当前栈帧底部(高地址)，在当前栈帧内位置固定；ESP指向当前栈帧顶部(低地址)，当程序执行时ESP会随着数据的入栈和出栈而移动。因此函数中对大部分数据的访问都基于EBP进行。函数调用栈的典型内存布局如下图所示：</p> 
 <p><img src="https://images2.imgbox.com/6b/ec/4oD4tlQt_o.png" alt="函数调用栈的典型内存布局" title=""></p> 
</blockquote> 
<p><br></p> 
<h4 id="二多任务支持">二、多任务支持</h4> 
<p>然而栈的意义还不只是函数调用，有了它的存在，才能构建出操作系统的多任务模式。我们以 main 函数调用为例，main 函数包含一个无限循环体，循环体中先调用 A 函数，再调用 B 函数。</p> 
<pre class="prettyprint"><code class=" hljs scss">func <span class="hljs-function">B()</span><span class="hljs-value">:
  return;</span>

func <span class="hljs-function">A()</span><span class="hljs-value">:
  B();</span>

func <span class="hljs-function">main()</span><span class="hljs-value">:
  while (<span class="hljs-number">1</span>)
    A();</span></code></pre> 
<p>试想在单处理器情况下，程序将永远停留在此 main 函数中。即使有另外一个任务在等待状态，程序是没法从此 main 函数里面跳转到另一个任务。因为如果是函数调用关系，本质上还是属于 main 函数的任务中，不能算多任务切换。<strong>此刻的 main 函数任务本身其实和它的栈绑定在了一起，无论如何嵌套调用函数，栈指针都在本栈范围内移动。</strong></p> 
<p>由此可以看出一个任务可以利用以下信息来表征： <br> 1. main 函数体代码 <br> 2. main 函数栈指针 <br> 3. 当前 CPU 寄存器信息</p> 
<p>假如我们可以保存以上信息，则完全可以强制让出 CPU 去处理其他任务。只要将来想继续执行此 main 任务的时候，把上面的信息恢复回去即可。有了这样的先决条件，多任务就有了存在的基础，也可以看出栈存在的另一个意义。<strong>在多任务模式下，当调度程序认为有必要进行任务切换的话，只需保存任务的信息（即上面说的三个内容）。恢复另一个任务的状态，然后跳转到上次运行的位置，就可以恢复运行了。</strong></p> 
<p>可见每个任务都有自己的栈空间，正是有了独立的栈空间，为了代码重用，不同的任务甚至可以混用任务的函数体本身，例如可以一个main函数有两个任务实例。至此之后的操作系统的框架也形成了，譬如任务在调用 sleep() 等待的时候，可以主动让出 CPU 给别的任务使用，或者分时操作系统任务在时间片用完是也会被迫的让出 CPU。不论是哪种方法，只要想办法切换任务的上下文空间，切换栈即可。</p> 
<p><img src="https://images2.imgbox.com/ed/bf/wnhhp35K_o.png" alt="多任务模型" title=""></p> 
<blockquote> 
 <p>【扩展阅读】：任务、线程、进程 三者关系</p> 
 <p>任务是一个抽象的概念，即指软件完成的一个活动；而线程则是完成任务所需的动作；进程则指的是完成此动作所需资源的统称；关于三者的关系，有一个形象的比喻： <br> - 任务 = 送货 <br> - 线程 = 开送货车 <br> - 系统调度 = 决定合适开哪部送货车 <br> - 进程 = 道路 + 加油站 + 送货车 + 修车厂</p> 
</blockquote> 
<hr> 
<p><br></p> 
<h3 id="linux-中有几种栈各种栈的内存位置">Linux 中有几种栈？各种栈的内存位置？</h3> 
<p>介绍完栈的工作原理和用途作用后，我们回归到 Linux 内核上来。内核将栈分成四种：</p> 
<ul><li>进程栈</li><li>线程栈</li><li>内核栈</li><li>中断栈</li></ul> 
<h4 id="一进程栈"><strong>一、进程栈</strong></h4> 
<p>进程栈是属于用户态栈，和进程 <strong>虚拟地址空间 (Virtual Address Space)</strong> 密切相关。那我们先了解下什么是虚拟地址空间：在 32 位机器下，虚拟地址空间大小为 4G。这些虚拟地址通过页表 (Page Table) 映射到物理内存，页表由操作系统维护，并被处理器的内存管理单元 (MMU) 硬件引用。<strong>每个进程都拥有一套属于它自己的页表，因此对于每个进程而言都好像独享了整个虚拟地址空间。</strong></p> 
<p>Linux 内核将这 4G 字节的空间分为两部分，将最高的 1G 字节（0xC0000000-0xFFFFFFFF）供内核使用，称为 <strong>内核空间</strong>。而将较低的3G字节（0x00000000-0xBFFFFFFF）供各个进程使用，称为 <strong>用户空间</strong>。每个进程可以通过系统调用陷入内核态，因此内核空间是由所有进程共享的。虽然说内核和用户态进程占用了这么大地址空间，但是并不意味它们使用了这么多物理内存，仅表示它可以支配这么大的地址空间。它们是根据需要，将物理内存映射到虚拟地址空间中使用。</p> 
<p><img src="https://images2.imgbox.com/33/cb/77QPAeVc_o.png" alt="Linux虚拟地址空间" title=""></p> 
<p>Linux 对进程地址空间有个标准布局，地址空间中由各个不同的内存段组成 (Memory Segment)，主要的内存段如下： <br> - 程序段 (Text Segment)：可执行文件代码的内存映射 <br> - 数据段 (Data Segment)：可执行文件的已初始化全局变量的内存映射 <br> - BSS段 (BSS Segment)：未初始化的全局变量或者静态变量（用零页初始化） <br> - 堆区 (Heap) : 存储动态内存分配，匿名的内存映射 <br> - 栈区 (Stack) : 进程用户空间栈，由编译器自动分配释放，存放函数的参数值、局部变量的值等 <br> - 映射段(Memory Mapping Segment)：任何内存映射文件</p> 
<p><img src="https://images2.imgbox.com/9d/03/XlKZjkIr_o.png" alt="Linux标准进程内存段布局" title=""></p> 
<p><strong>而上面进程虚拟地址空间中的栈区，正指的是我们所说的进程栈</strong>。进程栈的初始化大小是由编译器和链接器计算出来的，但是栈的实时大小并不是固定的，Linux 内核会根据入栈情况对栈区进行动态增长（其实也就是添加新的页表）。但是并不是说栈区可以无限增长，它也有最大限制 <code>RLIMIT_STACK</code> (一般为 8M)，我们可以通过 <code>ulimit</code> 来查看或更改 <code>RLIMIT_STACK</code> 的值。</p> 
<blockquote> 
 <p>【扩展阅读】：如何确认进程栈的大小</p> 
 <p>我们要知道栈的大小，那必须得知道栈的起始地址和结束地址。<strong>栈起始地址</strong> 获取很简单，只需要嵌入汇编指令获取栈指针 esp 地址即可。<strong>栈结束地址</strong> 的获取有点麻烦，我们需要先利用递归函数把栈搞溢出了，然后再 GDB 中把栈溢出的时候把栈指针 esp 打印出来即可。代码如下：</p> 
</blockquote> 
<pre class="prettyprint"><code class="language-C hljs scss"><span class="hljs-comment">/* file name: stacksize.c */</span>

void *orig_stack_pointer;

void <span class="hljs-function">blow_stack()</span> {
    <span class="hljs-function">blow_stack()</span>;
}

int <span class="hljs-function">main()</span> {
    __<span class="hljs-function">asm__(<span class="hljs-string">"movl %esp, orig_stack_pointer"</span>)</span>;

    <span class="hljs-function">blow_stack()</span>;
    return 0;
}</code></pre> 
<pre class="prettyprint"><code class="language-shell hljs lasso">$ g<span class="hljs-subst">++</span> <span class="hljs-attribute">-g</span> stacksize<span class="hljs-built_in">.</span>c <span class="hljs-attribute">-o</span> <span class="hljs-built_in">.</span>/stacksize
$ gdb <span class="hljs-built_in">.</span>/stacksize
(gdb) r
Starting program: /home/home/misc<span class="hljs-attribute">-code</span>/setrlimit

Program received signal SIGSEGV, Segmentation fault<span class="hljs-built_in">.</span>
blow_stack () at setrlimit<span class="hljs-built_in">.</span>c:<span class="hljs-number">4</span>
<span class="hljs-number">4</span>       blow_stack();
(gdb) print (<span class="hljs-literal">void</span> <span class="hljs-subst">*</span>)<span class="hljs-variable">$esp</span>
$<span class="hljs-number">1</span> <span class="hljs-subst">=</span> (<span class="hljs-literal">void</span> <span class="hljs-subst">*</span>) <span class="hljs-number">0xffffffffff7ff000</span>
(gdb) print (<span class="hljs-literal">void</span> <span class="hljs-subst">*</span>)orig_stack_pointer
$<span class="hljs-number">2</span> <span class="hljs-subst">=</span> (<span class="hljs-literal">void</span> <span class="hljs-subst">*</span>) <span class="hljs-number">0xffffc800</span>
(gdb) print <span class="hljs-number">0xffffc800</span><span class="hljs-subst">-</span><span class="hljs-number">0xff7ff000</span>
$<span class="hljs-number">3</span> <span class="hljs-subst">=</span> <span class="hljs-number">8378368</span>    <span class="hljs-comment">// Current Process Stack Size is 8M</span></code></pre> 
<p>上面对进程的地址空间有个比较全局的介绍，那我们看下 Linux 内核中是怎么体现上面内存布局的。内核使用内存描述符来表示进程的地址空间，该描述符表示着进程所有地址空间的信息。内存描述符由 mm_struct 结构体表示，下面给出内存描述符结构中各个域的描述，请大家结合前面的 进程内存段布局 图一起看：</p> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">struct</span> mm_struct {
    <span class="hljs-keyword">struct</span> vm_area_struct *mmap;           <span class="hljs-comment">/* 内存区域链表 */</span>
    <span class="hljs-keyword">struct</span> rb_root mm_rb;                  <span class="hljs-comment">/* VMA 形成的红黑树 */</span>
    ...
    <span class="hljs-keyword">struct</span> list_head mmlist;               <span class="hljs-comment">/* 所有 mm_struct 形成的链表 */</span>
    ...
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> total_vm;                <span class="hljs-comment">/* 全部页面数目 */</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> locked_vm;               <span class="hljs-comment">/* 上锁的页面数据 */</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> pinned_vm;               <span class="hljs-comment">/* Refcount permanently increased */</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> shared_vm;               <span class="hljs-comment">/* 共享页面数目 Shared pages (files) */</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> exec_vm;                 <span class="hljs-comment">/* 可执行页面数目 VM_EXEC &amp; ~VM_WRITE */</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> stack_vm;                <span class="hljs-comment">/* 栈区页面数目 VM_GROWSUP/DOWN */</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> def_flags;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> start_code, end_code, start_data, end_data;    <span class="hljs-comment">/* 代码段、数据段 起始地址和结束地址 */</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> start_brk, brk, start_stack;                   <span class="hljs-comment">/* 栈区 的起始地址，堆区 起始地址和结束地址 */</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg_start, arg_end, env_start, env_end;        <span class="hljs-comment">/* 命令行参数 和 环境变量的 起始地址和结束地址 */</span>
    ...
    <span class="hljs-comment">/* Architecture-specific MM context */</span>
    mm_context_t context;                  <span class="hljs-comment">/* 体系结构特殊数据 */</span>

    <span class="hljs-comment">/* Must use atomic bitops to access the bits */</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;                   <span class="hljs-comment">/* 状态标志位 */</span>
    ...
    <span class="hljs-comment">/* Coredumping and NUMA and HugePage 相关结构体 */</span>
};</code></pre> 
<p><img src="https://images2.imgbox.com/24/11/lY1MU8TO_o.png" alt="mm_struct 内存段" title=""></p> 
<blockquote> 
 <p>【扩展阅读】：进程栈的动态增长实现</p> 
 <p>进程在运行的过程中，通过不断向栈区压入数据，当超出栈区容量时，就会耗尽栈所对应的内存区域，这将触发一个 <strong>缺页异常 (page fault)</strong>。通过异常陷入内核态后，异常会被内核的 <code>expand_stack()</code> 函数处理，进而调用 <code>acct_stack_growth()</code> 来检查是否还有合适的地方用于栈的增长。</p> 
 <p>如果栈的大小低于 <code>RLIMIT_STACK</code>（通常为8MB），那么一般情况下栈会被加长，程序继续执行，感觉不到发生了什么事情，这是一种将栈扩展到所需大小的常规机制。然而，如果达到了最大栈空间的大小，就会发生 <strong>栈溢出（stack overflow）</strong>，进程将会收到内核发出的 <strong>段错误（segmentation fault）</strong> 信号。</p> 
 <p>动态栈增长是唯一一种访问未映射内存区域而被允许的情形，其他任何对未映射内存区域的访问都会触发页错误，从而导致段错误。一些被映射的区域是只读的，因此企图写这些区域也会导致段错误。</p> 
</blockquote> 
<h4 id="二线程栈"><strong>二、线程栈</strong></h4> 
<p>从 Linux 内核的角度来说，其实它并没有线程的概念。Linux 把所有线程都当做进程来实现，它将线程和进程不加区分的统一到了 task_struct 中。线程仅仅被视为一个与其他进程共享某些资源的进程，而是否共享地址空间几乎是进程和 Linux 中所谓线程的唯一区别。线程创建的时候，加上了 CLONE_VM 标记，这样 <strong>线程的内存描述符 将直接指向 父进程的内存描述符</strong>。</p> 
<pre class="prettyprint"><code class=" hljs lasso">  <span class="hljs-keyword">if</span> (clone_flags <span class="hljs-subst">&amp;</span> CLONE_VM) {
    <span class="hljs-comment">/*
     * current 是父进程而 tsk 在 fork() 执行期间是共享子进程
     */</span>
    atomic_inc(<span class="hljs-subst">&amp;</span>current<span class="hljs-subst">-&gt;</span>mm<span class="hljs-subst">-&gt;</span>mm_users);
    tsk<span class="hljs-subst">-&gt;</span>mm <span class="hljs-subst">=</span> current<span class="hljs-subst">-&gt;</span>mm;
  }</code></pre> 
<p>虽然线程的地址空间和进程一样，但是对待其地址空间的 stack 还是有些区别的。对于 Linux 进程或者说主线程，其 stack 是在 fork 的时候生成的，实际上就是复制了父亲的 stack 空间地址，然后写时拷贝 (cow) 以及动态增长。然而对于主线程生成的子线程而言，其 stack 将不再是这样的了，而是事先固定下来的，使用 mmap 系统调用，它不带有 VM_STACK_FLAGS 标记。这个可以从 glibc 的<code>nptl/allocatestack.c</code> 中的 <code>allocate_stack()</code> 函数中看到：</p> 
<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">mem </span>=<span class="hljs-string"> mmap (NULL, size, prot,
            MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);</span></code></pre> 
<p>由于线程的 <code>mm-&gt;start_stack</code> 栈地址和所属进程相同，所以线程栈的起始地址并没有存放在 <code>task_struct</code> 中，应该是使用 <code>pthread_attr_t</code> 中的 <code>stackaddr</code> 来初始化 <code>task_struct-&gt;thread-&gt;sp</code>（sp 指向 <code>struct pt_regs</code> 对象，该结构体用于保存用户进程或者线程的寄存器现场）。这些都不重要，重要的是，<strong>线程栈不能动态增长，一旦用尽就没了，这是和生成进程的 fork 不同的地方</strong>。由于线程栈是从进程的地址空间中 map 出来的一块内存区域，原则上是线程私有的。但是同一个进程的所有线程生成的时候浅拷贝生成者的 task_struct 的很多字段，其中包括所有的 <code>vma</code>，如果愿意，其它线程也还是可以访问到的，于是一定要注意。</p> 
<h4 id="三进程内核栈"><strong>三、进程内核栈</strong></h4> 
<p>在每一个进程的生命周期中，必然会通过到系统调用陷入内核。在执行系统调用陷入内核之后，这些内核代码所使用的栈并不是原先进程用户空间中的栈，而是一个单独内核空间的栈，这个称作进程内核栈。进程内核栈在进程创建的时候，通过 slab 分配器从 <code>thread_info_cache</code> 缓存池中分配出来，其大小为 <code>THREAD_SIZE</code>，一般来说是一个页大小 4K；</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">union</span> thread_union {                                   
        <span class="hljs-keyword">struct</span> thread_info thread_info;                
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-built_in">stack</span>[THREAD_SIZE/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>)];
};                                                     </code></pre> 
<p><code>thread_union</code> 进程内核栈 和 <code>task_struct</code> 进程描述符有着紧密的联系。由于内核经常要访问 <code>task_struct</code>，高效获取当前进程的描述符是一件非常重要的事情。因此内核将进程内核栈的头部一段空间，用于存放 <code>thread_info</code> 结构体，而此结构体中则记录了对应进程的描述符，两者关系如下图（对应内核函数为 <code>dup_task_struct()</code>）：</p> 
<p><img src="https://images2.imgbox.com/2e/8e/s6DqhK08_o.png" alt="进程内核栈与进程描述符" title=""></p> 
<p>有了上述关联结构后，内核可以先获取到栈顶指针 esp，然后通过 esp 来获取 <code>thread_info</code>。这里有一个小技巧，直接将 esp 的地址与上 <code>~(THREAD_SIZE - 1)</code> 后即可直接获得 <code>thread_info</code> 的地址。由于 <code>thread_union</code> 结构体是从 <code>thread_info_cache</code> 的 Slab 缓存池中申请出来的，而 <code>thread_info_cache</code> 在 <code>kmem_cache_create</code> 创建的时候，保证了地址是 <code>THREAD_SIZE</code> 对齐的。因此只需要对栈指针进行 THREAD_SIZE 对齐，即可获得 <code>thread_union</code> 的地址，也就获得了 <code>thread_union</code> 的地址。成功获取到 <code>thread_info</code> 后，直接取出它的 task 成员就成功得到了 <code>task_struct</code>。其实上面这段描述，也就是 <strong>current</strong> 宏的实现方法：</p> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">register</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> current_stack_pointer <span class="hljs-keyword">asm</span> (<span class="hljs-string">"sp"</span>);

<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> thread_info *current_thread_info(<span class="hljs-keyword">void</span>)  
{                                                            
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">struct</span> thread_info *)                        
                (current_stack_pointer &amp; ~(THREAD_SIZE - <span class="hljs-number">1</span>));
}                                                            

<span class="hljs-preprocessor">#define get_current() (current_thread_info()-&gt;task)</span>

<span class="hljs-preprocessor">#define current get_current()                       </span></code></pre> 
<h4 id="四中断栈"><strong>四、中断栈</strong></h4> 
<p>进程陷入内核态的时候，需要内核栈来支持内核函数调用。中断也是如此，当系统收到中断事件后，进行中断处理的时候，也需要中断栈来支持函数调用。由于系统中断的时候，系统当然是处于内核态的，所以中断栈是可以和内核栈共享的。但是具体是否共享，这和具体处理架构密切相关。</p> 
<p>X86 上中断栈就是独立于内核栈的；独立的中断栈所在内存空间的分配发生在 <code>arch/x86/kernel/irq_32.c</code> 的 <code>irq_ctx_init()</code> 函数中(如果是多处理器系统，那么每个处理器都会有一个独立的中断栈)，函数使用 <code>__alloc_pages</code> 在低端内存区分配 <strong>2个物理页面</strong>，也就是8KB大小的空间。有趣的是，这个函数还会为 <code>softirq</code> 分配一个同样大小的独立堆栈。如此说来，<code>softirq</code> 将不会在 <code>hardirq</code> 的中断栈上执行，而是在自己的上下文中执行。</p> 
<p><img src="https://images2.imgbox.com/55/af/Srcl7teh_o.png" alt="中断栈" title=""></p> 
<p>而 ARM 上中断栈和内核栈则是共享的；中断栈和内核栈共享有一个负面因素，如果中断发生嵌套，可能会造成栈溢出，从而可能会破坏到内核栈的一些重要数据，所以栈空间有时候难免会捉襟见肘。</p> 
<hr> 
<p><br></p> 
<h3 id="linux-为什么需要区分这些栈">Linux 为什么需要区分这些栈？</h3> 
<p>为什么需要区分这些栈，其实都是设计上的问题。这里就我看到过的一些观点进行汇总，供大家讨论：</p> 
<ol><li><p>为什么需要单独的进程内核栈？</p> 
  <ul><li>所有进程运行的时候，都可能通过系统调用陷入内核态继续执行。假设第一个进程 A 陷入内核态执行的时候，需要等待读取网卡的数据，主动调用 <code>schedule()</code> 让出 CPU；此时调度器唤醒了另一个进程 B，碰巧进程 B 也需要系统调用进入内核态。那问题就来了，如果内核栈只有一个，那进程 B 进入内核态的时候产生的压栈操作，必然会破坏掉进程 A 已有的内核栈数据；一但进程 A 的内核栈数据被破坏，很可能导致进程 A 的内核态无法正确返回到对应的用户态了；</li></ul></li><li><p>为什么需要单独的线程栈？</p> 
  <ul><li>Linux 调度程序中并没有区分线程和进程，当调度程序需要唤醒”进程”的时候，必然需要恢复进程的上下文环境，也就是进程栈；但是线程和父进程完全共享一份地址空间，如果栈也用同一个那就会遇到以下问题。假如进程的栈指针初始值为 0x7ffc80000000；父进程 A 先执行，调用了一些函数后栈指针 esp 为 0x7ffc8000FF00，此时父进程主动休眠了；接着调度器唤醒子线程 A1： <br> 
    <ul><li>此时 A1 的栈指针 esp 如果为初始值 0x7ffc80000000，则线程 A1 一但出现函数调用，必然会破坏父进程 A 已入栈的数据。</li><li>如果此时线程 A1 的栈指针和父进程最后更新的值一致，esp 为 0x7ffc8000FF00，那线程 A1 进行一些函数调用后，栈指针 esp 增加到 0x7ffc8000FFFF，然后线程 A1 休眠；调度器再次换成父进程 A 执行，那这个时候父进程的栈指针是应该为 0x7ffc8000FF00 还是 0x7ffc8000FFFF 呢？无论栈指针被设置到哪个值，都会有问题不是吗？</li></ul></li></ul></li><li><p>进程和线程是否共享一个内核栈？</p> 
  <ul><li>No，线程和进程创建的时候都调用 <code>dup_task_struct</code> 来创建 task 相关结构体，而内核栈也是在此函数中 <code>alloc_thread_info_node</code> 出来的。因此虽然线程和进程共享一个地址空间 <code>mm_struct</code>，但是并不共享一个内核栈。</li></ul></li><li><p>为什么需要单独中断栈？</p> 
  <ul><li>这个问题其实不对，ARM 架构就没有独立的中断栈。</li></ul></li></ol> 
<p>大家还有什么观点，可以在留言下来 :-D</p> 
<hr> 
<p><br></p> 
<p>文章写到这也就结束了，您要是还能看到这，我一定要表示忠心的感谢，文章是在太长了，我都写快一个星期了。好了，终于可以 Released 了，<code>hexo deploy</code>，再会！</p> 
<ul><li>K.Yang</li></ul> 
<p><br> <br></p> 
<h3 id="参考文章">参考文章</h3> 
<p><a href="http://www.cnblogs.com/scnutiger/articles/3770991.html" rel="nofollow">栈的作用</a></p> 
<p><a href="http://www.cnblogs.com/clover-toeic/p/3755401.html" rel="nofollow">C语言函数调用栈(一)</a></p> 
<p><a href="http://blog.csdn.net/wangyezi19930928/article/details/16921927">函数调用栈 剖析＋图解</a></p> 
<p><a href="http://blog.csdn.net/wangxiaolong_china/article/details/6844325">进程地址空间分布</a></p> 
<p><a href="http://blog.csdn.net/daniel_ice/article/details/8146003">Linux 进程栈和线程栈的区别</a></p> 
<p><a href="http://wuchong.me/blog/2014/07/24/linux-process-manage/" rel="nofollow">Linux基础：进程管理</a></p> 
<p><a href="http://stackoverflow.com/questions/12490929/how-process-size-is-determined" rel="nofollow">stackoverflow - How Process Size is determined?</a></p> 
<p><a href="http://stackoverflow.com/questions/37462630/rlimit-stack-seems-to-change-according-to-setrlimit-getrlimit-but-stack-size-do" rel="nofollow">stackoverflow - RLIMIT_STACK seems to change according to setrlimit/getrlimit, but stack size doesn’t seem to actually change</a></p> 
<p><a href="http://stackoverflow.com/questions/4369078/relation-betwee-stack-limit-and-threads" rel="nofollow">stackoverflow - Relation between stack limit and threads</a></p> 
<p><a href="http://blog.chinaunix.net/uid-20543672-id-2996319.html" rel="nofollow">对 Linux 的进程内核栈的认识</a></p> 
<p><a href="http://my.oschina.net/yuyang/blog/212257" rel="nofollow">Linux进程内核栈</a></p> 
<p><a href="http://blog.chinaunix.net/uid-14528823-id-4136760.html" rel="nofollow">Linux中的栈：用户态栈/内核栈/中断栈</a></p> 
<p><a href="http://people.freebsd.org/~lstewart/articles/cpumemory.pdf" rel="nofollow">What Every Programmer Should Know About Memory? - Ulrich Drepper (Red Hat, Inc.)</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9dad02c6b707dfbfb73793b86972e787/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MyBatis——动态SQL讲解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2ac3ba9ca6e2499823c89d2711966ff3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Js获取  数组或对象  的长度</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>