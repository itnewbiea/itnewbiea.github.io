<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C# 反射调用方法与特性调用方法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C# 反射调用方法与特性调用方法" />
<meta property="og:description" content="在一些高级的开源项目中通常会使用到反射和打特性，如果对于c#初级的程序员第一眼看到肯定一脸懵逼，我以前也是这样过来的所以今天公司没啥事情可以干，就写一下笔记 ，unity 开源项目ET（以前看et项目时只知道原理不知其中的代码所以今天自已实现一下原理） 中就使用了这种方式实现。在此我解析一下反射与自定义特性的主要功能（反射网上搜索一大堆这里主要是介绍自定义特性的与反射结合使用的好处）：
反射：反射就是通过加载程序集（什么是程序集，程序集就是一个文件，一个存放了IL语句的dll，它可以是C#所有的语法或者说一个项目中所有的cs文件，打包成IL语言，在此我们不学习IL语法只知道它是什么）获取类（class）再获取类中的属性、方法、字段；
所以下面主要实现的功能是 例子 一： 通过反射调用方法
自定义 一个 类（可以是抽象类也可以是普通类）
//命名空间 namespace ConsoleApp1 { //一个基类 abstract class Game { public virtual void start() { } public virtual void updata() { } } //继承Game class Compent : Game { public override void start() { Console.WriteLine(&#34;my start&#34;); } public override void updata() { Console.WriteLine(&#34;updata&#34;); } } } 然后在主线程中解析程序集调用方法
namespace ConsoleApp1 { class Program { //存放所有继承Game的子类 private static List&lt;Game&gt; Games = new List&lt;Game&gt;(); //是否退出 private static bool isexit = false; static void Main(string[] args) { //获取程序集所有的类 Type[] types = typeof(Program)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5347804bd1a05e7c7b307a9c8488471a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-01T16:59:46+08:00" />
<meta property="article:modified_time" content="2019-06-01T16:59:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C# 反射调用方法与特性调用方法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在一些高级的开源项目中通常会使用到反射和打特性，如果对于c#初级的程序员第一眼看到肯定一脸懵逼，我以前也是这样过来的所以今天公司没啥事情可以干，就写一下笔记 ，<a href="https://github.com/egametang/ET">unity 开源项目ET</a>（以前看et项目时只知道原理不知其中的代码所以今天自已实现一下原理） 中就使用了这种方式实现。在此我解析一下反射与自定义特性的主要功能（<span style="color:#f33b45;">反射网上搜索一大堆这里主要是介绍自定义特性的与反射结合使用的好处</span>）：</p> 
<p>反射：反射就是通过加载程序集（什么是程序集，程序集就是一个文件，一个存放了IL语句的dll，它可以是C#所有的语法或者说一个项目中所有的cs文件，打包成IL语言，在此我们不学习IL语法只知道它是什么）获取类（class）再获取类中的属性、方法、字段；</p> 
<p>所以下面主要实现的功能是 </p> 
<p>例子 一：   <span style="color:#f33b45;">通过反射调用方法</span></p> 
<p>自定义 一个 类（可以是抽象类也可以是普通类）</p> 
<pre class="has"><code class="language-cs">//命名空间
namespace ConsoleApp1
{
//一个基类
  abstract  class Game
    {
        public virtual void start() { }
        public virtual void updata() { }
    }
//继承Game
    class Compent : Game
    {

       
        public  override void start() {
            Console.WriteLine("my  start");
        }
     
        public override void updata()
        {
            Console.WriteLine("updata");
        }
    }

}</code></pre> 
<p>然后在主线程中解析程序集调用方法</p> 
<pre class="has"><code class="language-cs">namespace ConsoleApp1
{ 
    class Program
    {

        //存放所有继承Game的子类
        private  static   List&lt;Game&gt; Games = new List&lt;Game&gt;();
        //是否退出
        private   static bool isexit = false;

        static void Main(string[] args)
        {

             //获取程序集所有的类
            Type[] types = typeof(Program).Assembly.GetTypes();

            //遍历
            foreach (Type  t in types) {

               // AttributeLogic(t);
                //如果是Game本身就下一条
                if (t.Name == typeof(Game).Name)
                    continue;
                //判断当前类是否继承Game
                if ( typeof(Game).IsAssignableFrom(t))
                {
                    //实例一个Game 子类
                    object reflectTest = Activator.CreateInstance(t);
                    Game g = reflectTest as Game;               
                    Games.Add(g);

                }                          
            }//找到了程序集所有继承Game的子类了并把它们都放在Games列表里边

            init();

            //结束主线程
            while (true)
            {
                if (Console.ReadKey().Key == ConsoleKey.A)
                {
                    isexit = true;
                   break;
                }
            }
        }

        //开始处理
        static void init()
        {

            foreach (var item in Games)
            {
                item.start();
            }

            new Thread(GameLogic).Start();
        }


        static void GameLogic()
        {
            while (!isexit)
            {
                foreach (var g in Games)
                {
                    g.updata();
                }
                Thread.Sleep(20);
            }
        }
            
    }
}</code></pre> 
<p>运行结果是</p> 
<pre class="has"><code>my start
updata
updata
</code></pre> 
<p> </p> 
<p>简单的反射调用方法已经完成了。</p> 
<p>例子二：<span style="color:#f33b45;">自定义特性的与反射结合使用</span></p> 
<p>首先我自定义自已的一个特性</p> 
<pre class="has"><code>
namespace ConsoleApp1
{
    //自定义特性类
    [AttributeUsage(AttributeTargets.All)]
    class GameSystem:Attribute//正常格式是GameSystemAttribute这样的
    {
        public GameSystem() { }

    }

   //自定义一个player类
    class player
    {

        //GameSystem特性类的名字，如果定义的时候特性类的名字是这样GameSystemAttribute打上特性也是一样的
    
        [GameSystem]//给start打上特性
        public  void start()
        {
            Console.WriteLine("GameSystem  start");
        }


        [GameSystem]//也给updata打上特性
        public void Updata()
        {
            Console.WriteLine("my  updata");
        }
    }
}</code></pre> 
<p> </p> 
<p>然后在主线程中测试</p> 
<p> </p> 
<pre class="has"><code>namespace ConsoleApp1
{
    class Program
    { 
        static void Main(string[] args)
        {

          
            Type[] types = typeof(Program).Assembly.GetTypes();


            foreach (Type  t in types) {

                AttributeLogic(t);
            }
        }

        
        
        static void AttributeLogic(Type type)
        {
          
            
            foreach (MethodInfo method in type.GetMethods())
            {
                foreach (Attribute attr in method.GetCustomAttributes())
                {
                    if (attr is GameSystem)
                    {
                        object reflectTest = Activator.CreateInstance(type);
                        MethodInfo methodInfo = type.GetMethod(method.Name);
                        methodInfo.Invoke(reflectTest, null);
                    }
                }
            }

        }
        
    }
}</code></pre> 
<p>运行结果是</p> 
<pre class="has"><code>GameSystem start
my updata</code></pre> 
<p>这就是打特性的神其之处</p> 
<p><span style="color:#f33b45;">只要你在任何方法中打上[GameSystem] 只要是无参的都可以任意执行（方法有返回值也可以），你也可以自已拓展方法中的参数。</span></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/204b92c53821ea8cd2e4ec5dda7b002e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决JsonResponse接口返回值中文是乱码的情况</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f7fd19baa4fdc92b30e5c588c5a60dab/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux 十四 修改文件操作权限 用户文件权限详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>