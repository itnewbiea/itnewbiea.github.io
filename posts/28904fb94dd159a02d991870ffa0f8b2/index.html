<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ES6 中的类（class） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ES6 中的类（class）" />
<meta property="og:description" content="前言 ES6 引入的 class 关键字具有定义类的能力。类是 ECMAScript 中新的基础性语法糖。虽然 ES6 表面上看起来可以支持正式的面向对象编程，但实际上它背后使用的依旧是原型和构造函数的概念。（笔记内容参考《JavaScript 高级程序设计（第 4 版）》章节 8.4 类）。以前在笔记《js 中原型、原型链和继承概念（详细全面）》中简要提过部分内容，这里系统看一次。
ES6 学习系列笔记
ES6 总结Symbol、Map、SetES6 中的类（class）代理与反射Promise 与异步函数迭代器和生成器 1 类的定义 定义类有两种主要方式：类声明和类表达式。两种方式都需要使用 class 关键字加大括号定义。类表达式与函数表达式类似，在它们被求值前都不能被引用。但是类声明与函数声明不同，类声明不能提升，即在声明之前引用该类都会抛出引用错误 ReferenceError（类似暂时性死区，因为类受块级作用域限制，个人认为这两者是存在关系的，书中没有说明）。
// 类声明 class Person { } // 类表达式 const Tree = class {}; // 类声明不提升 // ReferenceError: Cannot access &#39;C&#39; before initialization console.log(C); class C {} // function 和 class 关键字类似于 var 和 let、const 的区别。 // 函数声明受函数作用域限制，类受块作用域限制。 { function f() { console.log(&#39;f&#39;); } class Cx {} } f(); // &#39;f&#39; // ReferenceError: Cx is not defined console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/28904fb94dd159a02d991870ffa0f8b2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-20T21:56:37+08:00" />
<meta property="article:modified_time" content="2023-04-20T21:56:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ES6 中的类（class）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>前言</h3> 
<p><strong><em>ES6</em> 引入的 <em>class</em> 关键字具有定义类的能力。类是 <em>ECMAScript</em> 中新的基础性语法糖</strong>。虽然 <em>ES6</em> 表面上看起来可以支持正式的面向对象编程，但实际上它背后使用的依旧是原型和构造函数的概念。（笔记内容参考《<em>JavaScript</em> 高级程序设计（第 <em>4</em> 版）》章节 <em>8.4 类</em>）。以前在笔记《<em>js 中原型、原型链和继承概念（详细全面）</em>》中简要提过部分内容，这里系统看一次。</p> 
<p><em>ES6</em> 学习系列笔记</p> 
<ol><li><a href="https://blog.csdn.net/TKOP_/article/details/129963475?spm=1001.2014.3001.5502"><em>ES6</em> 总结</a></li><li><a href="https://blog.csdn.net/TKOP_/article/details/130084739?spm=1001.2014.3001.5502"><em>Symbol、Map、Set</em></a></li><li><a href="https://blog.csdn.net/TKOP_/article/details/130144058?spm=1001.2014.3001.5501"><em>ES6</em> 中的类（<em>class</em>）</a></li><li><a href="https://blog.csdn.net/TKOP_/article/details/130047429?spm=1001.2014.3001.5501">代理与反射</a></li><li><a href="https://blog.csdn.net/TKOP_/article/details/129856827?spm=1001.2014.3001.5501"><em>Promise</em> 与异步函数</a></li><li><a href="https://blog.csdn.net/TKOP_/article/details/129813858?spm=1001.2014.3001.5501">迭代器和生成器</a></li></ol> 
<h3><a id="1__16"></a>1 类的定义</h3> 
<p>定义类有两种主要方式：<strong>类声明和类表达式</strong>。两种方式都需要使用 <strong><em>class</em> 关键字加大括号定义</strong>。类表达式与函数表达式类似，在它们被求值前都不能被引用。但是类声明与函数声明不同，<strong>类声明不能提升</strong>，即在声明之前引用该类都会抛出引用错误 <em>ReferenceError</em>（<strong>类似暂时性死区，因为类受块级作用域限制</strong>，个人认为这两者是存在关系的，书中没有说明）。</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 类声明</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>

<span class="token comment">// 类表达式</span>
<span class="token keyword">const</span> Tree <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 类声明不提升</span>
<span class="token comment">// ReferenceError: Cannot access 'C' before initialization</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token comment">// function 和 class 关键字类似于 var 和 let、const 的区别。</span>
<span class="token comment">// 函数声明受函数作用域限制，类受块作用域限制。</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'f'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">class</span> <span class="token class-name">Cx</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'f'</span>

<span class="token comment">// ReferenceError: Cx is not defined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Cx<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>类包含可选的构造函数方法、静态类方法、实例方法、获取函数和设置函数等</strong>。与函数构造函数一样，多数编程风格都建议类名首字母大写，以区别于通过它创建的实例。默认情况下，类定义中的代码都在严格模式下执行。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 实例私有属性或者方法（ES10）</span>
    #age<span class="token punctuation">;</span>

    <span class="token comment">// 类构造函数</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> privateAge</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>#age <span class="token operator">=</span> privateAge<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 实例方法（原型对象上）</span>
    <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">不想告诉你我的年龄是</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token keyword">this</span><span class="token punctuation">.</span>#age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 静态类方法</span>
    <span class="token keyword">static</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'tkop'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>name<span class="token punctuation">,</span> p<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Person<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>类表达式表现出来的特征与函数非常相似，例如 <em>name</em> 属性是一样，如果表达式声明具有 <em>name</em> 则首选返回该名称字符串，否则是表达式左边的值。<strong>本质就是表达式最后的值</strong>。<strong>且它们都无法在表达式作用域外部访问这个标识符</strong>。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> Person <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token class-name">PersonName</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">identify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>name<span class="token punctuation">,</span> PersonName<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">identify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// ReferenceError: PersonName is not defined</span>
<span class="token comment">// p = new PersonName();</span>

<span class="token keyword">const</span> <span class="token function-variable function">F</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">F</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> Fn<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// ReferenceError: Fn is not defined</span>
<span class="token comment">// f = new Fn();</span>
<span class="token comment">// Fn();</span>

<span class="token comment">// ========================</span>
<span class="token keyword">const</span> Personx <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">identify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Personx<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Personx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">identify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> <span class="token function-variable function">Fx</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Fx<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">Fx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="2__115"></a>2 类构造函数</h3> 
<p><strong>实际上可以将类定义时大括号内部作用域包含的内容视为是对类（可视为特殊函数）的原型对象的初始化</strong>。内部定义的方法即为原型对象上的方法，<strong>例如 <em>constructor</em> 关键字用于在类定义块内部创建类的构造函数</strong>（即为 <em>prototype</em> 的 <em>constructor</em> 属性）。</p> 
<h4><a id="21__120"></a>2.1 类的实例化</h4> 
<p>方法名 <em>constructor</em> 会告诉解释器在使用 <em>new</em> 操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必须的，不定义则相当于将构造函数定义为空函数。<strong>使用 <em>new</em> 操作符调用类的构造函数会执行如下操作</strong>。</p> 
<ol><li>在内存中创建一个新对象。</li><li><strong>这个新对象内部的 <em>[[Prototype]]</em> 指针被赋值为构造函数的 <em>protorype</em> 属性（对象原型属性指向构造函数原型对象）</strong>。</li><li><strong>构造函数内部的 <em>this</em> 被赋值为这个新对象（<em>this</em> 指向新对象）</strong>。</li><li>执行构造函数内部的代码（给新对象添加属性）。</li><li>如果构造函数返回<strong>非空对象</strong>，则返回该对象；否则返回刚创建的新对象。</li></ol> 
<pre><code class="prism language-javascript"><span class="token comment">// 构造函数为空函数</span>
<span class="token keyword">class</span> <span class="token class-name">C1</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'instanceof C1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 执行构造函数并为新对象添加属性</span>
<span class="token keyword">class</span> <span class="token class-name">C2</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>instanceProperty <span class="token operator">=</span> arg<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C2</span><span class="token punctuation">(</span><span class="token string">'arg_input'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
instance1<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>instanceProperty<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>实例化时涉及的问题：</p> 
<p>1、类实例化时传入的参数会作为构造函数的参数。如果不需要参数，则调用时类名后面的括号也是可选的。</p> 
<p>2、<strong>构造函数执行完成后默认会返回 <em>this</em> 对象。构造函数返回的对象会被用作实例化的对象，如果外部没有什么引用返回的 <em>this</em> 对象，那么这个对象会被销毁</strong>。</p> 
<p>3、如果构造函数返回的不是默认的 <em>this</em> 对象，而是其他对象。则需要注意这个对象与类并没有关联（使用 <em>instanceof</em> 操作符检测为 <em>false</em>，并不是类的实例）。<strong>因为该对象的对象原型并没有被修改</strong>。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">class</span> <span class="token class-name">C3</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>instanceProperty <span class="token operator">=</span> arg <span class="token operator">||</span> <span class="token string">'default'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> instance3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C3</span><span class="token punctuation">(</span><span class="token string">'arg_input'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> instance4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C3</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance3<span class="token punctuation">.</span>instanceProperty<span class="token punctuation">,</span> instance4<span class="token punctuation">.</span>instanceProperty<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">C4</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">uname</span><span class="token operator">:</span> <span class="token string">'扬尘'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> instance5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance5 <span class="token keyword">instanceof</span> <span class="token class-name">C4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>注意：类构造函数与构造函数的主要区别是，类构造函数必须使用 <em>new</em> 操作符调用</strong>。否则会抛出错误 <em>TypeError</em>。类构造函数在实例化后会成为普通的实例方法（严格来说是原型对象上共享的方法，仍然需要使用 <em>new</em> 调用）。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 实际上是 Person.prototype.constructor</span>
<span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">p1<span class="token punctuation">.</span>constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// TypeError: Class constructor Person cannot be invoked without 'new'</span>
<span class="token comment">// Person();</span>
<span class="token comment">// p1.constructor();</span>
</code></pre> 
<h4><a id="22__196"></a>2.2 将类当成特殊函数</h4> 
<p><strong>我们可以从类各方面的表现看出类就是一种特殊的函数，具有 <em>prototype</em> 属性，而这个原型对象也具有一个 <em>constructor</em> 属性指向类的本身。</strong></p> 
<pre><code class="prism language-javascript"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// function</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {constructor: ƒ}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person <span class="token operator">===</span> p<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>至此，所有有关类定义的基本概念应该都非常明确了。但是书中却多余地给出了下面的这段描述。</p> 
<p><a href="https://imgse.com/i/p9S9OaD" rel="nofollow"><img src="https://images2.imgbox.com/b0/b2/xYBiCXwu_o.jpg" alt="p9S9OaD.jpg"></a></p> 
<p>之所以说多余是因为<strong>示例中获取的并不是类块中定义的 <em>constructor</em> 函数</strong>。前面我们提到过，在类内定义的所有内容可以视为是原型对象中的属性和方法。使用实例或者原型对象都可以访问，且 <em>constructor</em> 指向的是类自身。示例中的 <em>Person.constructor</em> 引用的当然不会是类中定义的该属性。<strong>它是类这个函数对象（将其视为一个对象）的对象原型（<em>__proro__</em>）上的一个属性，也就是实例化 <em>Person</em> 的构造函数</strong>。验证如下：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token comment">// 实例化的 Person 对象是函数类型</span>
<span class="token comment">// 那用它的构造函数再次实例化一个对象也应该是函数类型;</span>
<span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person<span class="token punctuation">.</span>constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'function'</span>
</code></pre> 
<blockquote> 
 <p><strong>不应该将类块内的构造函数和类的 <em>constructor</em> 属性混为一谈，如果不理解其中的原理，就会徒增负担</strong>。</p> 
</blockquote> 
<p>描述方面也不够详细：类中定义的 <em>constructor</em> 方法不会被当成构造函数？在对它使用 <em>instanceof</em> 操作符会返回 <em>false</em> ？（概念描述有点含糊了）。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token comment">// 这才是类中的constructor 方法，上面只是类的 constructor 属性</span>
<span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">o<span class="token punctuation">.</span>constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 可以当成构造函数使用，因为指向类的本身</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'object'</span>

<span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">p<span class="token punctuation">.</span>constructor</span> <span class="token operator">&amp;&amp;</span> p <span class="token keyword">instanceof</span> <span class="token class-name">o<span class="token punctuation">.</span>constructor</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="3__247"></a>3 实例、原型和类成员</h3> 
<p><strong>类的语法可以非常方便地定义应该存在于实例上的成员、应该存在于原型上的成员，及应该存在于类本身的成员。</strong></p> 
<h4><a id="31__251"></a>3.1 实例成员</h4> 
<p><strong>实例成员是指每次使用 <em>new</em> 操作符调用构造函数时，内部为新创建的实例（<em>this</em>）添加的“自有”属性。每次创建的实例都对应唯一的成员对象，该对象上面的实例成员都不会在原型上共享。</strong></p> 
<pre><code class="prism language-javascript"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>friends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'扬尘'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> p0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p0<span class="token punctuation">.</span>id<span class="token punctuation">,</span> p1<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p0<span class="token punctuation">.</span>friends <span class="token operator">===</span> p1<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 当然可以继续添加新成员</span>
p0<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'tkop'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p0<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="32__273"></a>3.2 原型方法与访问器</h4> 
<p><strong>类定义语法将在类块中定义的方法作为原型方法。类方法等同于对象属性，因此可以使用字符串或者计算的值作为键。同时也支持获取和设置访问器属性，语法和行为同普通对象一样。</strong></p> 
<pre><code class="prism language-javascript"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'instance_say'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'prototype_say'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">'symbolKey'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'symbolKey'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">[</span><span class="token string">'conputed'</span> <span class="token operator">+</span> <span class="token string">'Key'</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'conputedKey'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">set</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token parameter">newName</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_name <span class="token operator">=</span> <span class="token string">'get_'</span> <span class="token operator">+</span> newName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'instance_say'</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'prototype_say'</span>
p<span class="token punctuation">.</span><span class="token function">conputedKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'conputedKey'</span>
p<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">'symbolKey'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'symbolKey'</span>
p<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'tkop'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'get_tkop'</span>
</code></pre> 
<blockquote> 
 <p><strong>可以将方法定义在类构造函数中或者类块中，但是不能在类块中给原型添加原始值或者对象作为成员数据</strong>。</p> 
</blockquote> 
<pre><code class="prism language-javascript"><span class="token comment">// Uncaught SyntaxError: Unexpected identifier 'name'</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Jack'</span><span class="token punctuation">;</span>
    <span class="token comment">// 这个会变为实例成员（公有字段声明）</span>
    <span class="token comment">// name = 'Jack';</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="33__319"></a>3.3 静态类方法和实例私有属性</h4> 
<p>可以在类上定义静态方法。这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。<strong>静态成员在类定义中使用 <em>static</em> 关键字作为前缀。静态成员由类调用，其中的 this 引用类自身</strong>。<strong>静态方法非常合适作为实例工厂</strong>。类似于 <em>Promise.resolve()</em> 和 <em>Promise.reject()</em>。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'instance_say'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'prototype_say'</span><span class="token punctuation">,</span> <span class="token keyword">this</span> <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Person_say'</span><span class="token punctuation">,</span> <span class="token keyword">this</span> <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 创建返回一个随机年龄属性值的 Person 实例</span>
        <span class="token comment">// return new this(Math.floor(Math.random() * 100));</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'instance_say'</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'prototype_say'  true</span>
Person<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Person_say' true</span>

p <span class="token operator">=</span> Person<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Person { age: 88, say: [Function (anonymous)] }</span>
</code></pre> 
<p><em>JavaScript</em> 以前没有<strong>私有成员</strong>的概念，只是利用闭包结合 <em>Symbol</em> 或者 <em>WeakMap</em> 等类型模拟实现了私有属性的概念。但是在 <em>ECMAScript2019</em> 中新增了在类块中使用 “<em>#</em>” 定义私有成员的语法（<strong>私有字段声明</strong>）。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
    #address<span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> address</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>#address <span class="token operator">=</span> address<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#address<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'扬尘'</span><span class="token punctuation">,</span> <span class="token string">'个人隐私-家庭地址'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '个人隐私-家庭地址'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [ 'name' ]</span>
</code></pre> 
<h4><a id="34__370"></a>3.4 非函数原型和类成员</h4> 
<p><strong>可以注意到前面的类定义并不显示支持在原型或者类上添加成员数据</strong>。但是在类定义外部，可以手动添加（其实类块内支持在类上添加成员数据，示例如下）。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">static</span> anotherName <span class="token operator">=</span> <span class="token string">'P'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>anotherName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'P'</span>

<span class="token comment">// 手动添加</span>
<span class="token keyword">class</span> <span class="token class-name">Per</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>Per<span class="token punctuation">.</span>greeting<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Per</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 在类上定义数据成员。</span>
Per<span class="token punctuation">.</span>greeting <span class="token operator">=</span> <span class="token string">'My name is'</span><span class="token punctuation">;</span>

<span class="token comment">// 在原型上定义数据成员。</span>
<span class="token class-name">Per</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Lucky'</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'My name is Lucky'</span>
</code></pre> 
<h4><a id="35__399"></a>3.5 迭代器与生成器方法</h4> 
<p><strong>类定义语法支持在原型和类本身上定义生成器方法。也可以通过添加默认的迭代器，将类实例定义为可迭代对象</strong>。这部分在迭代器和生成器部分已学习，这里只罗列代码。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">class</span> <span class="token class-name">Per</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>rest</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>arg <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>rest<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">*</span><span class="token function">createNicknameIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">yield</span> <span class="token string">'Jack'</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span> <span class="token string">'Jake'</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span> <span class="token string">'J-Dog'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token operator">*</span><span class="token function">createJobIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">yield</span><span class="token operator">*</span> <span class="token punctuation">[</span><span class="token string">'Butcher'</span><span class="token punctuation">,</span> <span class="token string">'Baker'</span><span class="token punctuation">,</span> <span class="token string">'Candlestick maker'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 生成器方法作为默认迭代器</span>
    <span class="token comment">// *[Symbol.iterator]() {<!-- --></span>
    <span class="token comment">//     yield * this.arg.entries();</span>
    <span class="token comment">// }</span>

    <span class="token comment">// 只返回迭代器实例</span>
    <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>arg<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Per</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> nicknameIterator <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">createNicknameIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nicknameIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Jack'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nicknameIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Jake'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nicknameIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'J-Dog'</span>

<span class="token keyword">let</span> jobIterator <span class="token operator">=</span> Per<span class="token punctuation">.</span><span class="token function">createJobIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>jobIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Butcher'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>jobIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Baker'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>jobIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Candlestick maker'</span>

<span class="token keyword">const</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Per</span><span class="token punctuation">(</span><span class="token string">'401'</span><span class="token punctuation">,</span> <span class="token string">'402'</span><span class="token punctuation">,</span> <span class="token string">'403'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>index<span class="token punctuation">,</span> errorCode<span class="token punctuation">]</span> <span class="token keyword">of</span> p2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token string">'=&gt;'</span> <span class="token operator">+</span> errorCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// '0=&gt;401'  '1=&gt;402'  '2=&gt;403'</span>
</code></pre> 
<h3><a id="4__445"></a>4 继承</h3> 
<p><em>ES6</em> 新增特性原生支持了类继承机制。虽然类继承使用的是新语法，但背后依旧使用的是原型链。</p> 
<h4><a id="41__449"></a>4.1 基础语法</h4> 
<p><em>ES6</em> 类支持单继承。使用 <strong><em>extends</em> 关键字</strong>，就可以继承任何拥有 <em>[[Constructor]]</em> 和原型的对象（这就包括着普通的构造函数）。<strong>派生类都会通过原型链访问到类和原型上定义的方法</strong>。</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 超类</span>
<span class="token keyword">class</span> <span class="token class-name">Sclass</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">identifyPrototype</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token function">identifyClass</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 派生类，可以使用表达式的形式。</span>
<span class="token comment">// const Dclass = class extends Sclass {};</span>
<span class="token keyword">class</span> <span class="token class-name">Dclass</span> <span class="token keyword">extends</span> <span class="token class-name">Sclass</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token keyword">let</span> s0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> d0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s0<span class="token punctuation">.</span><span class="token function">identifyPrototype</span><span class="token punctuation">(</span><span class="token string">'s'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s Sclass {}</span>
d0<span class="token punctuation">.</span><span class="token function">identifyPrototype</span><span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// d Dclass {}</span>

Sclass<span class="token punctuation">.</span><span class="token function">identifyClass</span><span class="token punctuation">(</span><span class="token string">'S'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// S [class Sclass]</span>
Dclass<span class="token punctuation">.</span><span class="token function">identifyClass</span><span class="token punctuation">(</span><span class="token string">'D'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// D class Dclass extends Sclass {}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Sclass</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> <span class="token class-name">Dclass</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre> 
<h4><a id="42_HomeObject__super_480"></a>4.2 构造函数、HomeObject 和 super()</h4> 
<p><strong>派生类的方法可以通过 <strong>super 关键字</strong>引用它们的原型</strong>。<strong>需要注意的是 <em>super</em> 是一个关键字，并且有一些特殊的语法结构。<em>super</em> 不是一个指向原型对象的变量</strong>。<em>super</em> 语法总结：</p> 
<ol><li>这个关键字只能在派生类中使用（这里只是相对超类而言，在对象字面量中也可以使用，详细看 <em>MDN</em> 文档），而且仅限于类构造函数、实例方法和静态方法内部。</li><li>不能单独引用 <em>super</em> 关键字，要么作为<strong>函数调用</strong>，要么进行<strong>属性查询</strong>。</li><li><strong>在派生类构造函数中调用 <em>super()</em> 会调用父类构造函数，并将返回的实例赋值给 <em>this</em>。如果需要给父类构造函数传参需要手动传入</strong>。</li><li>在构造函数中，不能在调用 <em>super()</em> 之前引用 <em>this</em>。</li><li>如果派生类没有定义构造函数，则在实例化时默认调用 <em>super()</em>，且会传入所有传给派生类的参数。</li><li>派生类只要返回的是构造函数中的 <em>this</em> 对象，就必须调用 <em>super()</em>。</li></ol> 
<pre><code class="prism language-javascript"><span class="token keyword">class</span> <span class="token class-name">Sclass</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// SyntaxError: 'super' keyword unexpected here</span>
        <span class="token comment">// super();</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'log-in-S'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Dclass</span> <span class="token keyword">extends</span> <span class="token class-name">Sclass</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> identify</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 不能再调用 super() 之前引用 this，否则会抛出 ReferenceError</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>identify <span class="token operator">=</span> identify<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 通过 super 调用父类原型对象上的成员</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'log-in-D'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> d0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dclass</span><span class="token punctuation">(</span><span class="token string">'派生类'</span><span class="token punctuation">,</span> <span class="token string">'d0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>d0<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Dclass { name: '派生类', identify: 'd0' }</span>
d0<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'log-in-S'   'log-in-D'</span>

<span class="token comment">// ----------第5点和第6点------</span>
<span class="token keyword">class</span> <span class="token class-name">Sclass</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// class Dclass extends Sclass {}</span>
<span class="token keyword">class</span> <span class="token class-name">Dclass</span> <span class="token keyword">extends</span> <span class="token class-name">Sclass</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// super(name);</span>
        <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> d1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dclass</span><span class="token punctuation">(</span><span class="token string">'派生类'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>d1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 对应结果分别为 Dclass { name: '派生类' }  {}</span>
</code></pre> 
<blockquote> 
 <p><strong><em>ES6</em> 给类构造函数和静态方法添加了内部属性 <em>[[HomeObject]]</em>，这个特性是一个指针，指向定义该方法的对象。这个指针是自动赋值的，且供 <em>JavaScript</em> 引擎内部访问。<em>super</em> 始终定义为 <em>[[HomeObject]]</em> 的原型。</strong></p> 
</blockquote> 
<h4><a id="43__544"></a>4.3 抽象基类</h4> 
<p><strong>抽象基类是指通过在基类的构造函数中对类实例化过程进行控制，从而达到定义特殊基类的概念</strong>。例如定义一个可供继承，但本身不能被实例化的基类。定义派生类必须具有某个方法的基类。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">class</span> <span class="token class-name">Sclass</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">new</span><span class="token punctuation">.</span>target <span class="token operator">===</span> Sclass<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token keyword">new</span><span class="token punctuation">.</span>target<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 不能被实例化</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>say<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token keyword">new</span><span class="token punctuation">.</span>target<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 必须定义一个 say 方法</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Dclass</span> <span class="token keyword">extends</span> <span class="token class-name">Sclass</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token comment">// Error: class Sclass{...} 不能被实例化</span>
<span class="token keyword">let</span> s0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//  Error: class Dclass extends Sclass {} 必须定义一个 say 方法</span>
<span class="token comment">// let d0 = new Dclass();</span>
</code></pre> 
<h4><a id="44__574"></a>4.4 继承内置类型</h4> 
<p><strong><em>ES6</em> 类的继承语法使得内置引用类型的继承变得更加方便。但是有些内置类型的方法会返回新的实例。默认情况下，返回实例的类型与原始实例的类型是一致的。如果需要覆盖这个默认行为，可以覆盖 <em>Symbol.species</em> 访问器，这个访问器决定在创建返回的实例时使用的类</strong>。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">class</span> <span class="token class-name">DeriveArray</span> <span class="token keyword">extends</span> <span class="token class-name">Array</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">shuffle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">const</span> j <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// static get [Symbol.species]() {<!-- --></span>
    <span class="token comment">//     return Array;</span>
    <span class="token comment">// }</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DeriveArray</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'J'</span><span class="token punctuation">,</span> <span class="token string">'Q'</span><span class="token punctuation">,</span> <span class="token string">'K'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token keyword">instanceof</span> <span class="token class-name">DeriveArray</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token comment">// DeriveArray(7) ['A', '2', '3', '4', 'J', 'Q', 'K']</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span><span class="token function">shuffle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// DeriveArray(7) ['4', 'Q', 'J', 'A', 'K', '3', '2']</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> a0 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span><span class="token function">isNaN</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// DeriveArray(3) [ '3', '2', '4' ]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a0 <span class="token keyword">instanceof</span> <span class="token class-name">DeriveArray</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token comment">// 覆盖 Symbol.species 访问器后创建返回的实例使用的类不再跟原始实例一样</span>
<span class="token comment">// console.log(a0 instanceof DeriveArray); // false</span>
</code></pre> 
<h4><a id="45__610"></a>4.5 类混入</h4> 
<p>略。。。</p> 
<blockquote> 
 <p>很多 <em>JavaScript</em> 框架（特别是 <em>React</em>）已经抛弃混入模式，转向了<strong>组合模式</strong>（把方法提取到独立的类和辅助对象中，然后把它们组合起来，但不使用继承）。这反映了“组合胜过继承”的软件设计原则。</p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9ee50fadf67a268b12fca29f6735f434/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">GDOUCTF web</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5f06c9c94b961be07469f51507c991c9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">代理与反射</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>