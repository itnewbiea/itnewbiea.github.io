<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>详细整理Java 从命令控制台输入数据读取输入流System.in的几种常用方法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="详细整理Java 从命令控制台输入数据读取输入流System.in的几种常用方法" />
<meta property="og:description" content="一、System.in（最笨的方法） 首先看jdk的API.
System的静态方法in返回的是一个InputStream类型的对象，则我们可以用读取输入流的方式对其进行读取。
按API的说法“此流已打开并准备提供输入数据。通常，此流对应于键盘输入或者由主机环境或用户指定的另一个输入源。”键盘上按下的任何一个键都会被当做是输入值。
如何回显输入值？
我们就用读取输入流的方式进行读取，还是看API
InputStream包含方法read();read(byte[] b);read(byte[] b, int off, int len) ;
1、read(); 看API从输入流中读取数据的下一个字节。返回 0 到 255 范围内的 int 字节值。
返回一个整型字节数据，该数据表示的是字节因此是Unicode的第一个字节或是字符的ASCII码值。该方法是从一个流中一个一个的读取数据，因此是一个迭代的过程。
如果到达流的末尾，则返回 -1
重复调用System.in.read()实际上是在遍历该流中的每一个字节数据。最常见的流是键盘输入流。以下为例：
import java.io.IOException; public class Test1 { public static void main(String[] args) throws IOException { System.out.println(&#34;请输入：&#34;); int i = 0; while(i!=-1){//读取输入流中的字节直到流的末尾返回1 i = System.in.read(); System.out.println(i); } } } 如图我们输入ABCD则返回了其ASCII值 如果System.out.println(i);改为System.out.println((char)i);强制转换为char字符，则输出ABCD
这里的13和10是读取的键盘的回车，我们在键盘上按一下回车键，实际上读取到的是两个字符，即“\r”（13）和“\n”（10）。字符“\r”表示回车，即光标回到当前行的行首而不换行；字符“\n”表示换行，即光标移到当前行的下一行行首。
(这里还要PS下回车的来历：
回车 \r 本义是光标重新回到本行开头，r的英文return，控制字符可以写成CR，即Carriage Return 换行 \n 本义是光标往下一行（不一定到下一行行首），n的英文newline，控制字符可以写成LF，即Line Feed 在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。 后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。 /*======================================*/ \n: UNIX 系统行末结束符 \n\r: window 系统行末结束符 \r: MAC OS 系统行末结束符 /*======================================*/ 一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号 有兴趣可以去查看相关资料 )" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8da8672ba98d79ecd27f597af92dd3cf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-08-09T09:01:00+08:00" />
<meta property="article:modified_time" content="2013-08-09T09:01:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">详细整理Java 从命令控制台输入数据读取输入流System.in的几种常用方法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="iteye-blog-content-contain" style="font-size:14px;"> 
 <h3>一、<strong>System.in（最笨的方法）</strong> </h3> 
 <p>首先看jdk的API.</p> 
 <p><img src="https://images2.imgbox.com/54/26/Sa496J6x_o.jpg" alt=""></p> 
 <p>System的静态方法in返回的是一个<span style="font-size:12px;"><span style="font-family:Calibri;">InputStream</span><span style="font-family:'宋体';">类型的对象，则我们可以用读取输入流的方式对其进行读取。</span></span></p> 
 <p><span style="font-size:12px;"><span style="font-family:'宋体';">按API的说法“此流已打开并准备提供输入数据。通常，此流对应于键盘输入或者由主机环境或用户指定的另一个输入源。”键盘上按下的任何一个键都会被当做是输入值。</span></span></p> 
 <p><span style="font-family:'宋体';font-size:12px;">如何回显输入值？</span></p> 
 <p><span style="font-family:'宋体';font-size:12px;">我们就用读取输入流的方式进行读取，还是看API</span></p> 
 <p>InputStream包含方法read();read(byte[] b);read(byte[] b, int off, int len) ;<span style="font-family:'宋体';font-size:12px;"><br></span></p> 
 <h4>1、read();</h4> 
 <p>看API从输入流中读取数据的下一个字节。返回 <code>0</code> 到 <code>255</code> 范围内的 <code>int</code> 字节值。</p> 
 <p>返回一个整型字节数据，该数据表示的是字节因此是Unicode的第一个字节或是字符的ASCII码值。该方法是从一个流中一个一个的读取数据，因此是一个迭代的过程。</p> 
 <p>如果到达流的末尾，则返回 <code>-1</code></p> 
 <p> </p> 
 <p>重复调用System.in.read()实际上是在遍历该流中的每一个字节数据。最常见的流是键盘输入流。以下为例：</p> 
 <p> </p> 
 <pre><code class="language-java">import java.io.IOException;
public class Test1 {
	public static void main(String[] args) throws IOException {
		System.out.println("请输入：");
		int i = 0;
		while(i!=-1){//读取输入流中的字节直到流的末尾返回1
			i = System.in.read();
			System.out.println(i);
		}
	}
}</code></pre> 
 <p>如图我们输入ABCD则返回了其ASCII值 如果System.out.println(i);改为System.out.println((char)i);强制转换为char字符，则输出ABCD</p> 
 <p><img src="https://images2.imgbox.com/02/19/NJarEJUL_o.jpg" alt=""><img src="https://images2.imgbox.com/7b/20/cQF4y6eM_o.jpg" alt=""></p> 
 <p>这里的13和10是读取的键盘的回车<span style="font-family:'宋体';font-size:14px;line-height:22px;background-color:#f5fdff;">，我们在键盘上按一下回车键，实际上读取到的是两个字符，即“\r”（13）和“\n”（10）。字符“\r”表示回车，即光标回到当前行的行首而不换行；字符“\n”表示换行，即光标移到当前行的下一行行首。</span></p> 
 <p><span style="font-family:'宋体';font-size:14px;line-height:22px;background-color:#f5fdff;">(这里还要PS下回车的来历：</span></p> 
 <p> </p> 
 <pre class="best-text mb-10">回车 \r 本义是光标重新回到本行开头，r的英文return，控制字符可以写成CR，即Carriage Return
换行 \n 本义是光标往下一行（不一定到下一行行首），n的英文newline，控制字符可以写成LF，即Line Feed</pre> 
 <pre class="best-text mb-10">在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。</pre> 
 <pre class="best-text mb-10">后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。
/*======================================*/
\n:  UNIX 系统行末结束符
\n\r: window 系统行末结束符
\r:  MAC OS 系统行末结束符
/*======================================*/
一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号</pre> 
 <pre class="best-text mb-10">有兴趣可以去查看相关资料</pre> 
 <p>)</p> 
 <p> </p> 
 <p><span style="font-family:'宋体';font-size:14px;line-height:22px;background-color:#f5fdff;">这里还有一个小情况，看下面的小例子</span></p> 
 <p> </p> 
 <pre><code class="language-java">import java.io.IOException;
public class Test2 {
	public static void main(String[] args) throws IOException {
		System.out.println("请输入：");
		char ch = (char)System.in.read();
		System.out.println("hello" + ch + "AB");
		}
	}</code></pre> 
 <p>很明显这是只读取一个字符，然后插入到字符串“hello”和“AB”之间，我们无论输入1个字符还是多个字符都是只读取第一个字符，如输入“UFO”<br> 打印出“helloUAB”但我们不输入任何值只按一个回车时，在cmd命令窗口与IDE工具（eclipse）输出就不一样了，如下图：</p> 
 <p> </p> 
 <p><span style="font-family:'宋体';"><span style="font-size:14px;line-height:22px;">cmd命令行，编译运行结果 eclipse运行结果输入“UFO” 和只按回车两种情况</span></span></p> 
 <p><img src="https://images2.imgbox.com/c1/92/MBrrKBdT_o.jpg" alt=""><img src="https://images2.imgbox.com/d8/a4/QmXboURO_o.jpg" alt=""><img src="https://images2.imgbox.com/c8/4f/tFQ2uIYu_o.jpg" alt=""></p> 
 <p>我们可以注意到输入其它字符的运行结果一样，直接按回车的话，cmd下打印出的是"ABllo",也就是说cmd回车（获得两个字符<span style="font-family:'宋体';font-size:14px;line-height:22px;background-color:#f5fdff;">“\r”和“\n”</span>），只读取了第一个字符“\r”，即将光标放到行首不换行，所以导致了覆盖hello,那为什么在IDE工具（eclipse）下也是只读取了回车，却换行了呢，<span style="color:#cc0000;">这应该是eclipse将回车与换行是连用的，无论是System.out.print("a\rb");System.out.print("a\nb");还是System.out.print("a\r\nb");输出都是a回车b.</span>此句系本人杜撰，大家可以亲试核实。好了read()就说这些了</p> 
 <h4>2、read(byte[] b)</h4> 
 <div>
   API里 
  <span style="font-family:Calibri;">InputStream的read(byte[] b)同样是返回一个int值，但此处的用法跟read()完全不一样。此处是从输入流中读取一定数量的字节，并将其存储在缓冲区数组<code>b</code> 中。以整数形式返回实际读取的字节数</span> 
 </div> 
 <div> 
  <p>如果 <code>b</code> 的长度为 0，则不读取任何字节并返回 <code>0</code>；否则，尝试读取至少一个字节。如果因为流位于文件末尾而没有可用的字节，则返回值<code>-1</code>；否则，至少读取一个字节并将其存储在<code>b</code> 中。</p> 
  <p>将读取的第一个字节存储在元素 <code>b[0]</code> 中，下一个存储在 <code>b[1]</code> 中，依次类推。读取的字节数最多等于 <code> b</code> 的长度。设 <em>k</em> 为实际读取的字节数；这些字节将存储在 <code>b[0]</code> 到 <code>b[</code><em>k</em><code>-1]</code> 的元素中，不影响<code>b[</code><em>k</em><code>]</code> 到<code>b[b.length-1]</code> 的元素。</p> 
 </div> 
 <div> 
  <span style="font-family:Calibri;">此时我们有了byte数组，有了返回的字节数，就可以用String的构造方法<strong>String</strong><code>(byte[]bytes, intoffset, intlength)</code>： 通过使用平台的默认字符集解码指定的 byte 子数组，构造一个新的<code>String</code>。即可返回键盘的输入</span> 
 </div> 
 <div> 
  <span style="font-family:Calibri;">示例如下</span> 
 </div> 
 <pre><code class="language-java">public class TestInput1 {
 
         public static void main(String[] args) {
 
                   try{
 
                            //提示信息
 
                            System.out.println("请输入：");
 
                            //数组缓冲
 
                            byte[] b = new byte[1024];
 
                            //读取数据
 
                            int n = System.in.read(b);
 
                            //转换为字符串
 
                            String s = new String(b,0,n);
 
                            //回显内容
 
                            System.out.println("输入内容为：" + s);
 
                   }catch(Exception e){}
 
         }
 
}</code></pre> 
 <p>这里斟酌<span style="font-family:Calibri;">通过使用平台的默认字符集解码指定的 byte 子数组，构造一个新的</span><code style="color:#cc6600;">String</code><span style="font-family:Calibri;"><span style="color:#cc6600;">。</span>这句话，我亲自核实，此TestInput1.Java的编码格式为utf-8非本地默认编码格式时（我们国内的电脑默认编码GB2312），输出到控制台会是乱码，而改为GB2312时则正确输出，已证实。</span></p> 
 <p><span style="font-family:Calibri;">还有一句<span style="color:#cc6600;">...</span><span style="font-family:Calibri;">不影响</span><code style="color:#cc6600;">b[</code><span style="font-family:Calibri;"><em>k</em></span><code style="color:#cc6600;">]</code><span style="font-family:Calibri;">到</span><code style="color:#cc6600;">b[b.length-1]</code><span style="font-family:Calibri;"><span style="color:#cc6600;">的元素。</span>我们也可以试试，将以上代码略作改动如下：</span></span></p> 
 <p> </p> 
 <pre><code class="language-java">public class TestInput1 {
 
         public static void main(String[] args) {
                   try{
                            //提示信息
                            System.out.println("请输入：");
 
                            //数组缓冲
                            byte[] b = new byte[1024];
                            
                            //假设我们已知道键盘输入的是ABCD加回车是6个字符，我们将b[0]到b[9]分别提前赋值
                            for (int i = 0; i &lt; 10; i++) {//这里b[0]-b[9]分别赋值a-j
                    			b[i] = (byte)(97+i);//a的ascii值为97
                    		}
 
                            //读取数据
 
                            int n = System.in.read(b);
                            //转换为字符串
                            //这次我们构造String为了输出byte数组的所有值，所以不再用返回的值n而用我们预知的10个
                            String s = new String(b,0,10);
                            //回显内容
                            System.out.println("输入内容为：" + s);
 
                   }catch(Exception e){}
         }
}</code></pre> 
 <p><br> 这次我们打印到控制台的是：<br><img src="https://images2.imgbox.com/16/da/zeHvWkJ3_o.jpg" alt="">很明显原本应该输出的是abcdefghij经过读取键盘输入后，影响了n=6个字节，4个字母加回车的“\r”“\n”此句也证实了回车确实是两个字符。</p> 
 <p> </p> 
 <p> </p> 
 <h4>3、read(byte[] b<code>, intoff, intlen)</code> </h4> 
 <div> 
  <code>和上面类似但读取的长度，位置做了限定API如下：</code> 
 </div> 
 <div> 
  <code>将输入流中最多 <code>len</code> 个数据字节读入 byte 数组。尝试读取 <code>len</code> 个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数<br></code> 
 </div> 
 <div> 
  <code>将读取的第一个字节存储在元素 <code>b[off]</code> 中，下一个存储在 <code>b[off+1]</code> 中，依次类推。读取的字节数最多等于<code>len</code>。设<em>k</em> 为实际读取的字节数；这些字节将存储在 <code>b[off]</code> 到 <code>b[off+</code><em>k</em><code>-1]</code> 的元素中，不影响<code>b[off+</code><em>k</em><code>]</code> 到<code>b[off+len-1]</code> 的元素。<br></code> 
 </div> 
 <div> 
  <code>同样拿上面的abcdefghij做个例子仅仅将上一个例子的int n = System.in.read(b);改为int n = System.in.read(b,3,4);则意思的，将读取的第一个字节存储在b[3]依次最多存储4个，这时我们再次运行，还是输入ABCD,刚好4个，错还有回车两个，输出的控制台是：</code> 
 </div> 
 <div> 
  <code> </code> 
 </div> 
 <div> 
  <code><img src="https://images2.imgbox.com/08/51/3GnLrOK7_o.jpg" alt="">很明显b[3],b[4],b[5],b[6]处的字符defg被读入的4个字符覆盖，而且是只读取了4个，没有回车。<br></code> 
 </div> 
 <div> 
  <span style="font-family:monospace;">本来是要说JAVA从控制台输入数据的方法，结果扯了这么多，现在说说第二个方法：</span> 
 </div> 
 <div> 
  <h3>二、<span style="font-family:monospace;">java.util.Scanner</span> </h3> 从 JDK 5.0 开始，基本类库中增加了java.util.Scanner类，使用它的Scanner(InputStream source)构造方法，可以传入系统的输入流System.in而从控制台中读取数据。当通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。如果要获取输入的内容，则只需要调用Scanner的nextLine()方法即可。 
 </div> 
 <div> 
  <pre><code class="language-java">import java.util.Scanner;
public class TestSc {
	public static void main(String[] args) {
		System.out.println("请输入：");
		Scanner sc = new Scanner(System.in); 
		System.out.println(sc.nextLine());
	}
}</code></pre> 输出到控制台即是你键入的字符串，这里不做演示，关键说下Scanner的next(),nextLine(); 
 </div> 
 <h4><span style="font-family:monospace;">1、nextLine();</span></h4> 
 <div> 
  <span style="font-family:monospace;"><span style="font-family:monospace;">API此扫描器执行当前行，并返回跳过的输入信息。 此方法返回当前行的其余部分，不包括结尾处的行分隔符。意思就是读出当前下标的一行，对它来讲每行就是他的分隔符。如上例子中的末尾</span></span> 
  <pre><code class="language-java">System.out.println(sc.nextLine());改为</code></pre> 
  <pre><code class="language-java">System.out.println("hello"+sc.nextLine()+"ufo");
</code></pre> 
  <pre></pre> 
  <pre><code class="language-java"><span style="font-family:monospace;">输入“ABCD”打印到控制台为“helloABCDufo”回车并没有被输出。比较来说此方法更简洁实用，其实是Scanner对System.in做了封装处理。</span></code></pre> 
  <pre></pre> 
 </div> 
 <div> 
  <h4><span style="font-family:monospace;">2、next();</span></h4> 
  <div> 
   <span style="font-family:monospace;">查找并返回来自此扫描器的下一个完整标记。完整标记的前后是与分隔模式匹配的输入信息，Scanner默认使用空格作为分割符来分隔文本，但允许你指定新的分隔符如下例：<br></span> 
  </div> 
  <div> 
   <span style="font-family:monospace;"> </span> 
  </div> 
  <div> 
   <pre><code class="language-java">import java.util.Scanner;
public class TestSc {
	public static void main(String[] args) {
		Scanner sc = new Scanner("aa bb cc,dd,ee");
		//sc.useDelimiter(",");
		 while (sc.hasNext()) { 
             System.out.println(sc.next()); 
		 }
	}
}
</code></pre> 将空格做分隔符输出结果为： 将注释去掉，试用逗号做分隔符输出为： 
  </div> 
  <div> 
   <br> 
   <img src="https://images2.imgbox.com/37/74/A5nwrxvt_o.jpg" alt=""> 
   <img src="https://images2.imgbox.com/c1/f5/6zVIJHSR_o.jpg" alt=""> Scanner的更多方法资料可以自己去查阅学习。 
  </div> 
  <div>
    继续JAVA 
   <span style="font-family:monospace;">从控制台输入数据的方法</span> 
  </div> 
  <h3><span style="font-family:monospace;">三、<span style="font-family:monospace;">java.io.Console</span></span></h3> 
 </div> 
 <div> 
  <span style="font-family:monospace;">从 JDK 6.0 开始，基本类库中增加了java.io.Console类，用于获得与当前 Java 虚拟机关联的基于字符的控制台设备。在纯字符的控制台界面下，可以更加方便地读取数据<br></span> 
 </div> 
 <div> 
  <pre><code class="language-java">import java.io.Console;
public class TestSc {
	public static void main(String[] args) {
		System.out.println("请输入");
		Console cs = System.console();
		if (cs == null) { 
            throw new IllegalStateException("不能使用控制台"); 
        } 
        System.out.println(cs.readLine()); 
	}
}
</code></pre> 值得一提的是此方法只是在cmd命令窗口可以得到Console实例顺利运行，在IDE工具下如eclipse下得不到Console实例的，cs==null无法实现输入。 
  <br> API中解释： 
  <p>虚拟机是否具有控制台取决于底层平台，还取决于调用虚拟机的方式。如果虚拟机从一个交互式命令行开始启动，且没有重定向标准输入和输出流，那么其控制台将存在，并且通常连接到键盘并从虚拟机启动的地方显示。如果虚拟机是自动启动的（例如，由后台作业调度程序启动），那么它通常没有控制台。</p> 
  <p>如果此虚拟机具有控制台，那么它将由此类唯一的实例（可通过调用 <a href="/admin/blogs/1937424/" rel="nofollow"><code>System.console()</code></a> 方法获得）表示。如果没有可用的控制台设备，那么对该方法的调用将返回<tt>null</tt>。</p> 
 </div> 
 <div> 
  <span style="font-family:monospace;">所以在 IDE 的环境下，重新定向了标准输入和输出流，也是就是将系统控制台上的输入输出重定向到了 IDE 的控制台中。因此，在 IDE 中不能使用这个程序。<br></span> 
 </div> 
 <div> 
  <span style="font-family:monospace;"> </span> 
 </div> 
 <div> 
  <span style="font-family:monospace;">继续正题，<span style="font-family:monospace;">JAVA从控制台输入数据的方法</span></span> 
 </div> 
 <div> 
  <span style="font-family:monospace;"><span style="font-family:monospace;"> </span></span> 
 </div> 
 <h3> <span style="font-family:monospace;"><span style="font-family:monospace;">四、</span></span><span style="font-family:monospace;">BufferedReader</span> </h3> 
 <div> 
  <span style="font-family:monospace;">其实也是用的IO流这个就不多解释了，就这样吧。</span> 
 </div> 
 <pre><code class="language-java">try {
	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	String s = br.readLine();		
} catch (IOException e) {
	e.printStackTrace();
}</code></pre> 
 <p>readLine():读取一个文本行。</p> 
 <p> </p> 
 <p> </p> 
 <div>
     
 </div> 
 <p><span style="font-size:18px;"><strong><span style="font-family:'Comic Sans MS';"><span style="color:#ff0000;"> </span></span></strong></span></p> 
 <div>
     
 </div> 
 <div> 
  <span style="font-family:monospace;"> </span> 
 </div> 
 <div> 
  <span style="font-family:monospace;"> </span> 
 </div> 
 <div> 
  <span style="font-family:monospace;"> </span> 
 </div> 
 <div> 
  <span style="font-family:monospace;"> </span> 
 </div> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/da6c6cbe9cdfaa13ed1c612351ae4454/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">httpclient中文乱码问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/46d7c77432c607c4ae427ed3517af3ef/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">20130828可注册域名列表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>