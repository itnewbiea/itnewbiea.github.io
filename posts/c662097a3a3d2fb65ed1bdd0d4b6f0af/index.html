<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>模型微调（fine-tuning） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="模型微调（fine-tuning）" />
<meta property="og:description" content="特征提取 微调首先要弄清楚一个概念：特征提取。
用于图像分类的卷积神经网络包括两部分：一系列的卷积层和池化层（卷积基） &#43; 一个密集连接分类器。对于卷积神经网络而言，特征提取就是取出之前训练好的网络的卷积基，用新数据训练一个新的分类器。那么为什么要重复使用之前的卷积基，而要训练新的分类器呢？这是因为卷积基学到的东西更加通用，而分类器学到的东西则针对于模型训练的输出类别，并且密集连接层舍弃了空间信息。
卷积基的通用性取决于该层在模型中的深度。模型中更靠近输入的层提取的特征更通用，更靠近输出的层提取的特征更抽象。
在特征提取时，应冻结卷积基，不对其进行训练，即训练过程中不改变卷积基的权重，只训练最后的dense层。在keras中，冻结方法为将卷积基每层的trainable属性设为False。
模型微调 模型微调与特征提取互为补充。对于用于特征提取的冻结的卷积基，微调是指将其靠近输出的几层解冻，并将这几层与分类器联合训练，让模型更加适用于当前要解决的问题。在keras中，解冻即将对应层的trainable属性设为True。
微调网络的步骤 在已经训练好的base network上添加自定义网络冻结基网络训练所添加的部分解冻基网络的一些层联合训练解冻的层和新添加的部分 总结 微调，就是基于预训练模型进行微调，比如用大型数据集Imagenet训练好的resnet，再在自己的数据集上训练一部分靠近输出的层，使之更加适用于自己的问题。
需要微调的情况：
预训练模型的数据集与自己的数据集相似，但自己的数据集太少计算资源不够 是否微调以及微调的方法要根据自己的数据集大小、数据集与预训练模型数据集的相似程度来选择。
不同情况下的微调：
数据量少，相似度高：修改最后几层；数据量少，相似度低：保留预训练模型的前几层，训练后面的层；数据量大，相似度高：这是最理想的情况。使用预训练的权重初始化模型，重新训练整个模型；数据量大，相似度低：直接重新训练整个模型。 参考 [1]《Python深度学习》
[2] 知乎（如何进行模型微调）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c662097a3a3d2fb65ed1bdd0d4b6f0af/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-20T01:41:15+08:00" />
<meta property="article:modified_time" content="2022-07-20T01:41:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">模型微调（fine-tuning）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="_0"></a>特征提取</h4> 
<p>微调首先要弄清楚一个概念：特征提取。<br> 用于图像分类的卷积神经网络包括两部分：一系列的卷积层和池化层（卷积基） + 一个密集连接分类器。对于卷积神经网络而言，特征提取就是取出之前训练好的网络的卷积基，用新数据训练一个新的分类器。那么为什么要重复使用之前的卷积基，而要训练新的分类器呢？这是因为卷积基学到的东西更加通用，而分类器学到的东西则针对于模型训练的输出类别，并且密集连接层舍弃了空间信息。<br> 卷积基的通用性取决于该层在模型中的深度。模型中更靠近输入的层提取的特征更通用，更靠近输出的层提取的特征更抽象。<br> 在特征提取时，应冻结卷积基，不对其进行训练，即训练过程中不改变卷积基的权重，只训练最后的dense层。在keras中，冻结方法为将卷积基每层的trainable属性设为False。</p> 
<h4><a id="_7"></a>模型微调</h4> 
<p>模型微调与特征提取互为补充。对于用于特征提取的冻结的卷积基，微调是指将其靠近输出的几层解冻，并将这几层与分类器联合训练，让模型更加适用于当前要解决的问题。在keras中，解冻即将对应层的trainable属性设为True。</p> 
<h4><a id="_11"></a>微调网络的步骤</h4> 
<ol><li>在已经训练好的base network上添加自定义网络</li><li>冻结基网络</li><li>训练所添加的部分</li><li>解冻基网络的一些层</li><li>联合训练解冻的层和新添加的部分</li></ol> 
<h4><a id="_19"></a>总结</h4> 
<p>微调，就是基于预训练模型进行微调，比如用大型数据集Imagenet训练好的resnet，再在自己的数据集上训练一部分靠近输出的层，使之更加适用于自己的问题。</p> 
<p>需要微调的情况：</p> 
<ol><li>预训练模型的数据集与自己的数据集相似，但自己的数据集太少</li><li>计算资源不够</li></ol> 
<p>是否微调以及微调的方法要根据自己的数据集大小、数据集与预训练模型数据集的相似程度来选择。</p> 
<p>不同情况下的微调：</p> 
<ul><li>数据量少，相似度高：修改最后几层；</li><li>数据量少，相似度低：保留预训练模型的前几层，训练后面的层；</li><li>数据量大，相似度高：这是最理想的情况。使用预训练的权重初始化模型，重新训练整个模型；</li><li>数据量大，相似度低：直接重新训练整个模型。</li></ul> 
<h4><a id="_37"></a>参考</h4> 
<p>[1]《Python深度学习》<br> [2] <a href="https://zhuanlan.zhihu.com/p/379147111" rel="nofollow">知乎（如何进行模型微调）</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8fb390118f2cdcc4be86276f0e758fc8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL和Navicat的安装与配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2646725576798b0748a5c4308d272a8a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">class06：node获取数据</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>