<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43;学习笔记 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43;学习笔记" />
<meta property="og:description" content="1、初识c&#43;&#43; 1.1、常量 作用：用于记录程序中不可修改的变量。
2、核心编程 2.1 内存分区模型 c&#43;&#43; 程序执行时，将内存大方向划分为4个区域。
代码区：存放函数体的二进制代码，由操作系统进行管理。
全局区：存放全局变量及静态变量及常量
栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。
堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。
栈区：
不要返回局部变量的地址
数据由编译器管理开辟和释放。
int *fun(int b) //形参数据也会在栈区 { int a = 10; //局部变量 存在栈区 栈区的数据在函数执行完后自动释放。 return &amp;a;	//返回局部变量的地址。 } 堆区
在c&#43;&#43; 主要利用new 开辟数据。
int * fun() { int *p = new int(10); // 利用new 关键字把10 开辟在堆上， return p; } int main() { system(&#34;pause&#34;); return 0; } 手动释放：delete
int * fun() { int * p = new int (10); retturn p; } void test() { int *p = fun(); cout &lt;&lt; *p &lt;&lt; endl; delete p; // 释放 内存 } //在堆上开辟数组 void test01() { int * arr = new int [10]; //10代表数组有10 个元素 for（int i = 0; i &lt; 10 ;i&#43;&#43; ) { arr[i] = i &#43; 100; } for( int i = 0 ; i &lt; 10 ; i&#43;&#43;) { cout &lt;&lt; arr[i] &lt;&lt;endl; } delete [] arr; // 释放的时候 要加上 [] } 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/558f998c4898bee9717ec4f5678abede/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-24T09:35:50+08:00" />
<meta property="article:modified_time" content="2023-03-24T09:35:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;学习笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="1c_0"></a>1、初识c++</h4> 
<h5><a id="11_2"></a>1.1、常量</h5> 
<p>作用：用于记录程序中不可修改的变量。</p> 
<h4><a id="2_8"></a>2、核心编程</h4> 
<h5><a id="21__10"></a>2.1 内存分区模型</h5> 
<p>c++ 程序执行时，将内存大方向划分为4个区域。</p> 
<p>代码区：存放函数体的二进制代码，由操作系统进行管理。</p> 
<p>全局区：存放全局变量及静态变量及常量</p> 
<p>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。</p> 
<p>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。</p> 
<p><strong>栈区</strong>：</p> 
<p>不要返回局部变量的地址</p> 
<p>数据由编译器管理开辟和释放。</p> 
<pre><code class="prism language-c++">int *fun(int b)  //形参数据也会在栈区
{
	int a = 10; //局部变量 存在栈区 栈区的数据在函数执行完后自动释放。
	return &amp;a;	//返回局部变量的地址。
}
</code></pre> 
<p><strong>堆区</strong></p> 
<p>在c++ 主要利用new 开辟数据。</p> 
<pre><code class="prism language-c++">int * fun()
{
	int *p = new  int(10); // 利用new 关键字把10 开辟在堆上，
	return p;
}

int main()
{
  system("pause");
  return 0; 
}
</code></pre> 
<p>手动释放：delete</p> 
<pre><code class="prism language-c++"> int * fun()
 {
   int * p = new int (10);
   retturn p;
 }

void test()
{
  int *p = fun();
  cout &lt;&lt; *p &lt;&lt; endl;
  delete p;  // 释放 内存
}

//在堆上开辟数组
void test01()
{
  int * arr = new int [10]; //10代表数组有10 个元素
  
  for（int i = 0; i &lt; 10 ;i++ )
  {
    arr[i] = i + 100;
  }
  
  for( int i = 0 ; i &lt; 10 ; i++)
  {
    cout &lt;&lt; arr[i] &lt;&lt;endl;
  }
  
  delete [] arr; // 释放的时候 要加上 []
}
</code></pre> 
<h6><a id="211__97"></a>2.1.1 程序运行前</h6> 
<p>c++中程序运行前 分为全局区和代码区。</p> 
<p>代码区的特点是共享和只读。</p> 
<p>全局区中存放全局变量、静态变量、常量</p> 
<p>常量区中存放 const修饰的全局变量 和字符串常量。</p> 
<h5><a id="22__109"></a>2.2 引用</h5> 
<h6><a id="221__111"></a>2.2.1 引用的基本用法</h6> 
<p>作用： 给变量起别名</p> 
<p>语法： 数据类型 &amp;别名 = 原名</p> 
<pre><code class="prism language-c++">int a = 10;
int &amp;b = a;

cout &lt;&lt; a &lt;&lt; endl;
cout &lt;&lt; b &lt;&lt; endl;
</code></pre> 
<h6><a id="222__125"></a>2.2.2 引用注意事项</h6> 
<ul><li>引用必须初始化</li><li>引用初始化后，不可以改变</li></ul> 
<pre><code class="prism language-c++">int a = 10;
int &amp;b = a;
int c = 20;  //赋值操作 不是更改引用

cout &lt;&lt; a &lt;&lt; endl; //20
cout &lt;&lt; b &lt;&lt; endl; //20
cout &lt;&lt; c &lt;&lt; endl; //20
</code></pre> 
<h6><a id="223__140"></a>2.2.3 引用做函数参数</h6> 
<ul><li>引用传递 ，形参也会修饰实参。</li></ul> 
<pre><code class="prism language-c++">void swap(int &amp;a , int &amp;b)
{
	int temp = a;
	a = b;
	b = temp;
}

int main()
{
  int a = 10 , b = 20;
  swap(a , b);
  
  cout &lt;&lt; a ;//20
  cout &lt;&lt; b ;//10
}
</code></pre> 
<h6><a id="224__162"></a>2.2.4 引用做函数返回值</h6> 
<p>作用： 引用是可以作为函数返回值存在的。</p> 
<ul><li>不要返回局部变量引用</li><li>用法： 函数调用作为左指。</li></ul> 
<pre><code class="prism language-c++"> //发现是引用 转换为 int * const ref = &amp;a;
void fun(int &amp;ref)
{
  ref = 100; //ref 是引用 转换为 *ref = 100
}

int main ()
{
  int a = 10;
  int &amp; ref = a ;
  
  ref = 20 ;
  
}
</code></pre> 
<h6><a id="225__188"></a>2.2.5 常量引用</h6> 
<ul><li>用来修饰形参 ， 防止误操作。</li></ul> 
<pre><code class="prism language-c++">const int &amp; ref = 10;

void showValue(const int &amp;val) //修饰形参 ， 防止误操作
{
  cout &lt;&lt; "val = " &lt;&lt; val &lt;&lt; endl;
}

</code></pre> 
<h5><a id="23__204"></a>2.3 函数高级</h5> 
<h6><a id="231__206"></a>2.3.1、 函数提高</h6> 
<pre><code class="prism language-c++">//如果我们传入数据，就用自己的数据，如果没有，那么就用默认值。
int fun(int a , int b = 10 , int c = 30)
{
	return a + b + c;
}
// 如果某个位置有了默认参数，那么从这个数字开始。都必须有默认值。 
// 声明有默认参数，函数实现就不能有默认参数。 ---声明和实现只能有一个默认参数。

</code></pre> 
<h6><a id="232__223"></a>2.3.2 函数重载</h6> 
<ul><li>函数名可以相同，提高复用性</li></ul> 
<p>重载满足条件：</p> 
<p>1、同一个作用域下。</p> 
<p>2、函数名相同，参数类型不同或者个数不同。</p> 
<pre><code class="prism language-c++">void fun()
{
    cout &lt;&lt; "this is fun" &lt;&lt;endl;
}
void fun(int a ){
    cout &lt;&lt; "this is fun!" &lt;&lt; endl;
}	
</code></pre> 
<p>函数重载的注意事项：</p> 
<p>1、引用作为重载的条件</p> 
<pre><code class="prism language-c++">void fun(int &amp;a) 
{
    cout &lt;&lt; "int &amp;a :" &lt;&lt;endl; 
}

void fun(const int &amp;a) //编译器做了优化 ， 创建一个临时数据，然后让a 指向那个临时空间。
{
    cout &lt;&lt; "const int &amp;a :" &lt;&lt;endl;
}

int main ()
{
    int a = 10;
    fun(a);  //执行第一个方法。
  	fun(10); //执行第二个方法。
}
</code></pre> 
<p>2、函数重载碰到默认参数</p> 
<pre><code class="prism language-c++">void fun(int a , int b = 10)
{
    cout &lt;&lt; "fun(int a , int b = 10): "&lt;&lt;endl;
}

void fun(int a)
{
    cout &lt;&lt; " fun(int a )" &lt;&lt;endl;
}

int main ()
{
    fun(10); //函数重载碰到默认参数，出现二义性，报错，尽量避免这种情况
}
</code></pre> 
<h5><a id="24__295"></a>2.4 类和对象</h5> 
<p>c++ 面向对象的三大特性 ： 封装、继承、多态。</p> 
<h6><a id="1_299"></a>1、封装</h6> 
<pre><code class="prism language-c++">class Circle
{
//访问权限
public:
    int m_r;
    
    double calcle()
    {
        return PI * m_r * 2;
    }
};

int main ()
{
    Circle c1;
    
    c1.m_r = 10;
    
    cout &lt;&lt; "周长 ：" &lt;&lt; c1.calcle() &lt;&lt; endl;
    
}
</code></pre> 
<h6><a id="11_327"></a>1.1、访问权限</h6> 
<ul><li>公共权限：public 类外可以访问</li><li>保护权限：protected 类外不可以访问。 儿子可以访问父亲中保护内容</li><li>私有权限：private 类外不可以访问。 儿子不可以访问父亲中保护内容</li></ul> 
<p>类. 默认权限 是 private</p> 
<p>Struct 默认权限是 public</p> 
<h6><a id="12_341"></a>1.2、成员属性设置私有</h6> 
<p>可以自己控制 读写权限</p> 
<p>对于写 可以检测数据的有效性</p> 
<pre><code class="prism language-c++">class Per
{
private:
    string name;
    int age;
    
public:
    void setName(string m_name)
    {
        name = m_name;
    }
    
    void show()
    {
        cout &lt;&lt; "name : " &lt;&lt; name &lt;&lt; endl;
    }
};
</code></pre> 
<h6><a id="2_371"></a>2、对象初始化和清理</h6> 
<h6><a id="21_373"></a>2.1、构造函数和析构函数</h6> 
<ul><li>构造函数：创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li><li>析构函数：主要作用于对象<strong>销毁</strong>前自动调用，执行一些清理工作。</li></ul> 
<p>构造函数语法： 类名（）{}</p> 
<p>​ 1、没有返回值</p> 
<p>​ 2、函数名与类名相同</p> 
<p>​ 3、构造函数可以有参数，可以发生重载</p> 
<p>​ 4、创建对象的时候，构造函数会自动调用，而且只调用一次</p> 
<p>析构函数语法：～类名（）{}</p> 
<p>​ 1、没有返回值</p> 
<p>​ 2、对象销毁前调用</p> 
<pre><code class="prism language-c++">class Pr
{
public:
    Pr()
    {
        cout &lt;&lt; "构造函数被调用 "&lt;&lt;endl;
    }
    ~Pr()
    {
        cout &lt;&lt; "析构函数" &lt;&lt; endl;
    }
};
void test()
{
    Pr p;   //在栈上的数据，执行完毕后，会释放对象
}
int main ()
{
    
    Pr p;
    
    system("pause");
    return 0; 
     
}
</code></pre> 
<h6><a id="22_426"></a>2.2、构造函数的分类及调用</h6> 
<p>参数分类 无惨构造（默认构造） 有参构造</p> 
<p>类型分类 普通构造 拷贝构造</p> 
<p>拷贝构造函数调用时机</p> 
<p>c++ 调用拷贝函数通常有三种情况</p> 
<ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li></ul> 
<pre><code class="prism language-c++">class Person
{
public:
    Person()
    {
        cout &lt;&lt; "默认构造函数 ..."&lt;&lt;endl;
    }
    Person(int a)
    {
        age = a;
        cout &lt;&lt; "有参构造函数 ..."&lt;&lt;endl;
    }
    Person(const Person &amp;p)
    {
        age = p.age;
        cout &lt;&lt; "拷贝构造函数 ..."&lt;&lt;endl;
    }
    int age;
};
void test()
{
    //
    Person p1(10);
    Person p2(p1);
}
</code></pre> 
<ul><li>值传递的方式给函数参数传值</li></ul> 
<pre><code class="prism language-c++">void doWork(Person p)
{
    
}
void test()
{
    Person p;
    doWork(p);
}
</code></pre> 
<ul><li>以值方式返回局部</li></ul> 
<h6><a id="23_494"></a>2.3、构造函数调用规则</h6> 
<p>默认情况下，c++ 编译器至少给一个类添加三个函数。</p> 
<p>1、默认构造函数</p> 
<p>2、默认析构函数</p> 
<p>3、默认拷贝构造函数，对属性进行值拷贝。</p> 
<p>构造函数调用规则：</p> 
<ul><li> <p>如果定义有参构造函数，c++<strong>不再提供默认无参构造</strong>，但是会提供默认拷贝构造。</p> </li><li> <p>如果用户定义拷贝构造函数，c++不再提供其他构造函数。</p> </li></ul> 
<h6><a id="24_514"></a>2.4、深拷贝与浅拷贝</h6> 
<p>浅拷贝：简单的赋值拷贝操作。</p> 
<p>深拷贝：在堆区重新申请空间，进行拷贝操作。</p> 
<p>浅拷贝带来的问题： 堆区的内容重复释放。</p> 
<p>浅拷贝 复制的知识地址 实际上指向的还是同一块地址，c++ 执行模拟栈</p> 
<pre><code class="prism language-c++">class Man
{
public:
    Man()
    {
        cout &lt;&lt; "man 默认构造函数 " &lt;&lt; endl;
    }
    Man(int age , int height)
    {
        m_age = age;
        m_height = new int(height);
        cout &lt;&lt; "Man 有参构造函数" &lt;&lt; endl;
    }
    //自己实现 拷贝构造函数，解决浅拷贝带来的问题
    Man( const Man &amp;p)
    {
        cout &lt;&lt; " 拷贝构造函数 " &lt;&lt; endl;
        m_age = p.m_age;
        // m_height = p.height 编译器默认实现的代码。 浅拷贝操作
        
        //深拷贝
        m_height = new int(*p.m_height);
    }
    ~Man()
    {
        //析构代码，将堆区开辟数据做释放操作。
        if(m_height != NULL)
        {
            delete  m_height;
            m_height = NULL;
        }
        cout &lt;&lt; "Man 析构函数" &lt;&lt; endl;
    }
    
    int m_age;
    int * m_height;
};
void test()
{
    Man m(18 , 180);
    cout &lt;&lt; "m1 的年龄为："&lt;&lt; m.m_age &lt;&lt; " 身高为：" &lt;&lt; *m.m_height  &lt;&lt;endl;
    Man m2(m);
    cout &lt;&lt; "m1 的年龄为："&lt;&lt; m.m_age &lt;&lt; " 身高为：" &lt;&lt; *m.m_height &lt;&lt;endl;
}
</code></pre> 
<h6><a id="25_575"></a>2.5、初始化列表</h6> 
<p>作用： c++提供了初始化列表</p> 
<pre><code class="prism language-c++">class An
{
public:
  	// 初始化列表方式初始化
    An(int a , int b , int c) :m_A(a) , m_B(b) , m_C(c){}
    void Print()
    {
        cout &lt;&lt; "a = " &lt;&lt; m_A &lt;&lt; "  b = " &lt;&lt; m_B &lt;&lt; " c = " &lt;&lt; m_C &lt;&lt;endl;
    }
private:
    int m_A;
    int m_B;
    int m_C;
};
int main ()
{
    An a(1 , 2, 3);
    a.Print();
    
}
</code></pre> 
<h6><a id="26_606"></a>2.6、类对象作为类成员</h6> 
<p>c++ 类中成员可以是另一个类的对象，我们称该成员为对象成员</p> 
<pre><code class="prism language-c++">class A {}

class B
{
  A a;
}
</code></pre> 
<pre><code class="prism language-c++">class Phone
{
public:
    Phone(string name){
        m_name = name;
        cout &lt;&lt; "phone 构造函数调用" &lt;&lt; endl;
    }
    ~Phone()
    {
        cout &lt;&lt; "phone 析构函数调用" &lt;&lt; endl;
    }
    string m_name;
};
class Pe
{
public:
    Pe(string name , string phone): m_name(name) , m_phone(phone){
        cout &lt;&lt; "pe 构造函数调用" &lt;&lt; endl;
    }
    ~Pe()
    {
        cout &lt;&lt; "pe 析构函数调用" &lt;&lt; endl;
    }
    string m_name;
    Phone m_phone;
};
void test01()
{
    Pe pe("张三" ,"apple");
    cout &lt;&lt; pe.m_name &lt;&lt; "  " &lt;&lt; pe.m_phone.m_name&lt;&lt; endl;
}
</code></pre> 
<p>创建 B 对象时 ，A 与 B 的构造和析构的顺序是：</p> 
<pre><code class="prism language-markdown">输出：
phone 构造函数调用
pe 构造函数调用
张三  apple
pe 析构函数调用
phone 析构函数调用
</code></pre> 
<h6><a id="27_668"></a>2.7、静态成员</h6> 
<p>静态成员就是在成员变量和成员函数前加上static, 称为静态成员。</p> 
<ul><li>静态成员变量 
  <ul><li>所有对象共享同一份数据。</li><li>在编译阶段分配内存。</li></ul> </li></ul> 
<pre><code class="prism language-c++">class Person1
{
public:
    static int m_a;
    
    //静态成员变量也是有访问权限。private 可进行访问。
};
//初始化
int Person1::m_a = 100;
void test02()
{
    //静态成员变量 不属于某个对象上，所有对象都共享同一份数据
    //1、通过对象访问
    Person1 p1;
    cout &lt;&lt; p1.m_a &lt;&lt;endl;
    
    //2、通过类名进行访问
    cout &lt;&lt; Person1::m_a &lt;&lt; endl;
    
} 
</code></pre> 
<ul><li>静态成员函数 
  <ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul> </li></ul> 
<pre><code class="prism language-c++">class Person1
{
public:
    static void func()
    {
        //m_b = 200  静态成员函数 不可以访问 非静态成员变量 ，无法区分到底是哪个对象的
        cout &lt;&lt; "static void fun 调用" &lt;&lt; endl;
    }
  	int m_b;
    static int m_a;
};

void test02()
{
    //1、
    Person1 p1;
    p1.func();
    
    //2、
    Person1::func();
} 
</code></pre> 
<h6><a id="3_Cthis__733"></a>3、 C++对象模型和this 指针</h6> 
<p>this 指向被调用的成员函数所属的对象。</p> 
<p>this 用途：</p> 
<ul><li>当形参和成员变量同名时，可用this指针来区分</li><li>在类的非静态成员函数中返回对象本身，可用 return *this</li></ul> 
<pre><code class="prism language-c++">class Person1
{
public:
    Person1(int age)
    {
        this-&gt;age = age;
    }
    
    Person1&amp; addPersonAge(Person1 p)
    {
        this -&gt; age += p.age;
      	//返回对象本身 
        return *this;
    }
    
    int age ;
};
void test01()
{
    //1、解决名称冲突
    Person1 p1(18);
    cout &lt;&lt; "p1 年龄 为" &lt;&lt; p1.age &lt;&lt; endl;
}
void test02()
{
    //返回对象本身用 *this
    Person1 p1(10);
    Person1 p2(10);
    
    p2.addPersonAge(10).addPersonAge(10).addPersonAge(10);
    cout &lt;&lt; p2.age &lt;&lt; endl;
} 
</code></pre> 
<h6><a id="31_783"></a>3.1、空指针调用成员函数</h6> 
<pre><code class="prism language-c++">class Person
{
public:
    void showClassName()
    {
        cout &lt;&lt; "this is person clas " &lt;&lt;endl;
    }
    void showPersonAge()
    {
        //指针为空，因为传入的指针为空
        if(this == NULL)
        {
            return;
        }
        cout &lt;&lt; "age = " &lt;&lt; m_age &lt;&lt; endl;
    }
    int m_age;
};

void test01()
{
    Person *p = NULL;
    
    p-&gt;showClassName();
    
    p-&gt;showPersonAge();
}
</code></pre> 
<h6><a id="32const__817"></a>3.2、const 修饰成员函数</h6> 
<p><strong>常函数</strong>：</p> 
<ul><li>成员函数后加 const 后我们称为这个函数为常函数</li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable , 在常函数中依旧可以修改</li></ul> 
<p><strong>常对象：</strong></p> 
<ul><li>声明对象前加const 称该对象为常对象</li><li>常对象只能调用常函数</li></ul> 
<p>常对象里面的成员属性需要初始化。</p> 
<pre><code class="prism language-c++">class Person
{
public:
    // this指针的本质 是指针常量 指针的指向是不可以修改的
    // const Person * const this；
    // 在成员函数后面加const ，修饰的是this 指向，让指针指向的值也不可以修改。
    void showPerson() const
    {
        this -&gt; m_b = 100;
        //this -&gt; m_a = 100;
        //this = NULL; // this 指针不可以修改指针的指向
        cout &lt;&lt; this-&gt;m_b  &lt;&lt; endl;
    }
    
    void func()
    {
        
    }
    
    int m_a = 10;
    mutable int m_b = 10; //特殊变量 即使在常函数中，也可以修改这个值 加关键字 mutable
};

void test01()
{
    Person p;
    p.showPerson();
}

void test02()
{
    const Person p;  //在对象前加const 变为常对象
    p.m_b = 1200;
    cout &lt;&lt; p.m_b &lt;&lt; endl;
    
    //常对象只能调用常函数
    p.showPerson();
    //p.func()  报错 不可以调用普通函数
}
</code></pre> 
<h6><a id="4_884"></a>4、友元</h6> 
<p>有些私有属性，也想让类外特殊的一些函数或者类进行访问，就需要用到友元技术。</p> 
<p>友元的目的是让一个函数或者类 访问另一个类的私有成员</p> 
<p>关键字为 ： <strong>feiend</strong></p> 
<p>友元的三种实现：</p> 
<ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul> 
<h6><a id="41_908"></a>4.1、全局函数做友元</h6> 
<pre><code class="prism language-c++">class Building
{
    //友元 可访问类里私有元素 全局函数做友元 
    friend void goodGay( Building *building);
public:
    Building()
    {
        m_SittingRoom = "客厅";
        m_BedRoom = "卧室";
    }
    
public:
    string m_SittingRoom;
    
private:
    string m_BedRoom;
};

void goodGay( Building *building)
{
    cout &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;
    cout &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;
}
void test03()
{
    Building build;
    goodGay(&amp;build);
}
</code></pre> 
<h6><a id="42_943"></a>4.2、类做友元</h6> 
<pre><code class="prism language-c++">class Building;
class GoodGay
{
public:
    GoodGay();
    void visit();
    
private:
    Building *building;
};

class Building
{
    //告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类的私有内容
    friend class GoodGay;
    
public:
    Building();
    
public:
    string m_SittingRoom;
private:
    string m_BedRoom;
};

Building::Building()
{
    m_SittingRoom = "客厅";
    m_BedRoom = "卧室";
}

GoodGay::GoodGay()
{
    building = new Building;
}

void GoodGay::visit()
{
    cout &lt;&lt; "好基友正在访问：" &lt;&lt; building-&gt;m_SittingRoom &lt;&lt;endl;
    
    cout &lt;&lt; "好基友正在访问：" &lt;&lt; building-&gt;m_BedRoom &lt;&lt;endl;
}

void test03()
{
    GoodGay gg;
    gg.visit();
}
</code></pre> 
<h6><a id="43_1002"></a>4.3、成员函数做友元</h6> 
<pre><code class="prism language-c++">class Building;
class GoodGay
{
public:
    GoodGay();
    void visit();
    
private:
    Building * building;
    
};

class Building
{
    friend void  GoodGay::visit();
public:
    Building();
    
public:
    string m_sittingRoom ;
private:
    string m_bedRoom;
};

Building::Building()
{
    this-&gt;m_sittingRoom = "客厅";
    this-&gt;m_bedRoom = "卧室";
}

GoodGay::GoodGay()
{
    building = new Building;
}

void GoodGay::visit()
{
    cout &lt;&lt; building-&gt;m_sittingRoom &lt;&lt; endl;
    cout &lt;&lt; building-&gt;m_bedRoom &lt;&lt; endl;
}

void test03()
{
    GoodGay gg;
    gg.visit();
}
</code></pre> 
<h6><a id="5_1057"></a>5、运算符重载</h6> 
<p>对已有运算符重新进行定义，赋予其另一种功能，以适应不同数据类型。</p> 
<h6><a id="51_1063"></a>5.1、加号运算符重载</h6> 
<p>作用：实现两个自定义数据类型相加的运算。</p> 
<pre><code class="prism language-c++">class Method
{
public:
    //成员函数重载运算符
//    Method operator+ (Method &amp;p)
//    {
//        Method temp ;
//        temp.m_a = this-&gt;m_a + p.m_a;
//        temp.m_b = this-&gt;m_b + p.m_b;
//        return  temp;
//    }
    
    int m_a ;
    int m_b;
};

Method operator+(Method &amp;m1 , Method &amp;m2)
{
    Method temp ;
    temp.m_a = m1.m_a + m2.m_a;
    temp.m_b = m2.m_b + m2.m_b;
    return temp;
}

void test04()
{
    Method m1;
    m1.m_b = 10;
    m1.m_a = 10;
    Method m2;
    m2.m_b = 10;
    m2.m_a = 10;
    //成员函数重载调用
    //Person p3 = p1.operate+(p2);  本质上
    Method m3 = m1 + m2;
    cout &lt;&lt; " a =  " &lt;&lt; m3.m_a &lt;&lt; endl &lt;&lt; " b =  " &lt;&lt; m3.m_b &lt;&lt; endl;
}
</code></pre> 
<h6><a id="52_1111"></a>5.2、左移运算符</h6> 
<h6><a id="6_1115"></a>6、继承</h6> 
<p><strong>继承是面向三大对象的特性</strong></p> 
<h6><a id="61_1121"></a>6.1、基本语法</h6> 
<pre><code class="prism language-c++">//语法 class 子类 ： 继承方式 父类

class Animal
{
public:
    void eat()
    {
        cout &lt;&lt; " 我 会吃" &lt;&lt;endl;
    }
};

class Dog:public Animal
{
public:
    void go()
    {
        cout &lt;&lt; "狗会跑" &lt;&lt;endl;
    }
};
</code></pre> 
<h6><a id="62_1149"></a>6.2、继承方式</h6> 
<p><strong>主要继承方式</strong></p> 
<ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul> 
<pre><code class="prism language-c++">class Base
{
public:
    int m_a;
protected:
    int m_b;
    //父类的私有元素 是不会被继承的元素所访问
private:
    int m_c;
};

//public 方式
class Son1 : public Base
{
public:
    void func()
    {
        cout &lt;&lt; m_a &lt;&lt;endl;  // 父类公共成员，子类还是公共权限
        cout &lt;&lt; m_b &lt;&lt; endl; // 父类保护成员，到子类中变为保护权限
    }
};

class Son2 : protected Base
{
public:
    void func()
    {
        cout &lt;&lt; m_a &lt;&lt;endl;  // 父类公共成员，到子类中变为保护权限
        cout &lt;&lt; m_b &lt;&lt; endl; // 父类保护成员，到子类中变为保护权限
    }
};

class Son3 : private Base
{
public:
    void func()
    {
        cout &lt;&lt; m_a &lt;&lt;endl;  // 父类公共成员，到子类中变为私有权限
        cout &lt;&lt; m_b &lt;&lt; endl; // 父类保护成员，到子类中变为私有权限
    }
};
</code></pre> 
<h6><a id="63__1207"></a>6.3、 继承中对象模型</h6> 
<pre><code class="prism language-c++">class Base
{
public:
    int m_a;
protected:
    int m_b;
    //父类的私有元素 是不会被继承的元素所访问
private:
    int m_c;
};
class Son4:public Base
{
public:
    int m_d;
};

void test05()
{
    //16
    //父类所有非静态成员属性都会被子类继承下去
    // 父类私有成员属性 是被编译器隐藏了 因此是访问不到 但是确实被继承了
    Son4 s1;
    cout &lt;&lt; sizeof(s1) &lt;&lt; endl;
}
</code></pre> 
<h6><a id="64__1242"></a>6.4 、继承中构造和析构顺序</h6> 
<p>继承中构造和析构顺序如下：</p> 
<p><strong>先构造父类，再构造子类，析构到顺序与构造的顺序相反。</strong></p> 
<pre><code class="prism language-c++">class Base1
{
public:
    Base1()
    {
        cout &lt;&lt; "base 构造函数" &lt;&lt; endl;
    }
    ~Base1()
    {
        cout &lt;&lt; "base 析构函数" &lt;&lt; endl;
    }
};

class Son5 : public Base1
{
public:
    Son5()
    {
        cout &lt;&lt; "son 构造函数" &lt;&lt; endl;
    }
    ~Son5()
    {
        cout &lt;&lt; "son 析构函数" &lt;&lt; endl;
    }
};

void test1()
{
    Son5 s;
}
//base 构造函数
//son 构造函数
//son 析构函数
//base 析构函数
</code></pre> 
<h6><a id="65_1291"></a>6.5、继承同名成员处理方式</h6> 
<ul><li>访问子类同名成员 直接访问即可</li><li>访问父类同名成员 需要加作用域</li></ul> 
<pre><code class="prism language-c++">class Base2
{
public:
    Base2()
    {
        m_A = 100;
    }
    void func()
    {
        cout &lt;&lt; "base " &lt;&lt; endl;
    }
    int m_A = 100;
};

class Son6:public Base2
{
public:
    Son6()
    {
        m_A = 200;
    }
    void func()
    {
        cout &lt;&lt; " son " &lt;&lt; endl;
    }
    int m_A;
};
//同名属性处理方式
void test2()
{
    Son6 s;
    cout &lt;&lt; "son  m_a = " &lt;&lt; s.m_A &lt;&lt; endl;
    //如果通过 子类对象 访问到父类中同名成员 ， 需要加作用域
    cout &lt;&lt; "base m_a = " &lt;&lt; s.Base2::m_A &lt;&lt; endl;
}
void test3()
{
    Son6 s;
    s.func();
    s.Base2::func();
}
</code></pre> 
<p>总结</p> 
<blockquote> 
 <p>子类对象可以直接访问到子类中同名成员</p> 
 <p>子类对象加作用域可以访问到父类同名成员</p> 
 <p>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类同名函数</p> 
</blockquote> 
<h6><a id="66_1360"></a>6.6、继承同名静态成员处理方式</h6> 
<p>静态成员和非静态成员出现同名，处理方式一致</p> 
<ul><li>访问子类同名成员 直接访问</li><li>访问父类同名成员 需要加作用域</li></ul> 
<h6><a id="67_1371"></a>6.7、多继承语法</h6> 
<p>c++允许一个类继承多个类</p> 
<p>语法：class 子类 ：继承方式 父类1 ， 继承方式 父类2</p> 
<p>多继承可能引发父类中有同名成员出现，需要加作用域区分</p> 
<p><strong>c++ 实际开发中不建议用多继承</strong></p> 
<h6><a id="68__1389"></a>6.8、 菱形继承</h6> 
<p>菱形继承概念：</p> 
<p>​ 两个派生类继承同一个基类</p> 
<p>​ 又有某个类同时继承这两个派生类</p> 
<p>​ 这种称为 菱形继承 或者钻石继承</p> 
<pre><code class="prism language-c++">class Animal1
{
public:
    int m_Age;
};

//利用虚继承 解决菱形继承的问题
//继承之前 加上关键字 virtual 变为虚继承
class Sheep:virtual public Animal1{};

class Tuo:virtual public Animal1{};

class SheepTuo:public Sheep , public Tuo
{
    
};

void test4()
{
    SheepTuo st;
    st.Sheep::m_Age = 18;
    st.Tuo::m_Age = 28;
    //当菱形继承，两个父类拥有相同数据，需要加以作用域区分
    cout &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;
    cout &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;
}
</code></pre> 
<h6><a id="7_1436"></a>7、多态</h6> 
<p><strong>多态分为两类</strong>：</p> 
<ul><li>静态多态：函数重载 和 运算符重载属于静态多态 ，</li><li>动态多态：派生类和虚函数实现运行时多态</li></ul> 
<p>静态多态和动态多态区别：</p> 
<ul><li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li></ul> 
<pre><code class="prism language-c++">class Animal2
{
public:
    //c11  c++动态多态仅支持直接父类、
    //父类作为一个节点 使得各个不同的子类都能传入同一个函数题中并且调用子类对应的重载函数
    virtual void speak()
    {
        cout &lt;&lt; "动物在说话" &lt;&lt; endl;
    }
};

class Cat : public Animal2
{
public:
    // 重写 函数返回值类型
    void speak()
    {
        cout &lt;&lt; "小猫在说话" &lt;&lt; endl;
    }
};

//动态多态满足条件
//1、有继承关系
//2、子类重写父类的虚函数

//多态使用条件
//父类引用指向子类对象
void speak(Animal2 &amp;animal)
{
    animal.speak();
}

void test5()
{
    Cat c;
    speak(c);
}
</code></pre> 
<h6><a id="71___1494"></a>7.1、多态案例 - 计算器</h6> 
<pre><code class="prism language-c++">class Calculator
{
public:
    
    virtual int getResult()
    {
        return 0;
    }
    
    int m_Num1;
    int m_NUm2;
};

class AddCalculator : public Calculator
{
public:
    int getResult()
    {
        return m_Num1 + m_NUm2;
    }
};

class MulCalculator : public Calculator
{
public:
    int getResult()
    {
        return m_Num1 - m_NUm2;
    }
};

void test6()
{
    Calculator * cal = new AddCalculator;
    cal-&gt;m_NUm2 = 100;
    cal-&gt;m_Num1 = 100;
    
    cout &lt;&lt; cal-&gt;m_Num1 &lt;&lt; " + " &lt;&lt; cal-&gt;m_NUm2 &lt;&lt; " = " &lt;&lt; cal-&gt;getResult() &lt;&lt;endl;
    delete cal;
    
    cal = new MulCalculator;
    cal-&gt;m_NUm2 = 100;
    cal-&gt;m_Num1 = 100;
    
    cout &lt;&lt; cal-&gt;m_Num1 &lt;&lt; " - " &lt;&lt; cal-&gt;m_NUm2 &lt;&lt; " = " &lt;&lt; cal-&gt;getResult() &lt;&lt;endl;
    delete cal;
}
</code></pre> 
<h6><a id="72_1550"></a>7.2、纯虚函数和抽象类</h6> 
<p>纯虚函数语法 ： virtual 返回值类型 函数名 （参数列表）= 0；</p> 
<p>当类中有了纯虚函数 这个类称为抽象类</p> 
<p><strong>抽象类特点</strong></p> 
<ul><li>无法实例化对象</li><li>子类必须重写抽象类的纯虚函数，否则也属于抽象类</li></ul> 
<pre><code class="prism language-c++">class Bas
{
public:	
		//纯虚函数
  	// 类中只要有一个纯虚函数 就称为 抽象类
  	//抽象类无法实例化对象
  	//子类必须重写父类的纯虚函数 否则也属于抽象类
    virtual void fun() = 0;  //即便是void 也只能是 = 0
};

class Son7:public Bas
{
public:
  void fun()
    {
      cout &lt;&lt; " son7 ----" &lt;&lt;endl;
  }
};

void test7()
{
    Bas * b = new Son7;
    
    b-&gt;fun();
}
</code></pre> 
<h6><a id="73_1599"></a>7.3、虚析构和纯虚析构</h6> 
<p>多态使用时，如果子类有属性开辟到堆区，那么父类指针在释放时无法调用子类的析构函数</p> 
<p>解决方式： 将父类的析构函数改为 <strong>虚析构</strong> 或者 <strong>纯虚析构</strong></p> 
<p>虚析构和纯虚析构共性：</p> 
<ul><li>可以解决父类指针释放子类对象</li><li>都需要具体的函数实现</li></ul> 
<p>虚析构和纯虚析构区别：</p> 
<ul><li>如果是纯虚析构 ， 该类属于抽象类 无法实例化对象</li></ul> 
<p>虚析构语法：<br> virtual ~类名（）{}</p> 
<p>纯虚析构语法：</p> 
<p>virtaul ～类名（） = 0；</p> 
<p>该函数需要实现，可以用类：：方法的方式来声明</p> 
<pre><code class="prism language-c++">class Big
{
public:
    Big()
    {
        cout &lt;&lt; "big 构造函数" &lt;&lt;endl;
    }
     virtual void speak()
    {
        cout &lt;&lt; " big speak " &lt;&lt; endl;
    }
    virtual ~Big()
    {
        cout &lt;&lt; " big 析构函数" &lt;&lt; endl;
    }
};

class Small :public Big
{
public:
    Small(string name)
    {
        cout &lt;&lt; "small 构造函数" &lt;&lt; endl;
        m_name = new string(name);
    }
    
    void speak()
    {
        cout &lt;&lt; "small speak" &lt;&lt;endl;
    }
    
    ~Small()
    {
        cout &lt;&lt; " Cat 析构函数 调用" &lt;&lt; endl;
        if(this -&gt; m_name != NULL){
            delete m_name;
            m_name = NULL;
        }
    }
    
    string *m_name;
};

void test8()
{
    Big *b = new Small("tom");
    b-&gt;speak();
    
    //通过父类指针去释放，会导致子类对象可能处理不干净，造成内存泄露
    //给基类添加一个虚析构函数
    //虚析构函数就是用来解决父类指针 释放子类对象
    
    delete b;
}

</code></pre> 
<p>总结：</p> 
<p>​ 1、虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p> 
<p>​ 2、如果子类中没有堆区数据，可以不写为虚析构或者纯虚析构</p> 
<p>​ 3、拥有纯虚析构函数的类也属于抽象类</p> 
<h4><a id="3_1709"></a>3、文件操作</h4> 
<p>通过文件可以将数据持久化</p> 
<p>c++中对文件操作需要包含 头文件 </p> 
<p>文件类型分为两种：</p> 
<p>1、文本文件 - 文件以文本的ASCII码 形式存储在计算机中</p> 
<p>2、二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂他们</p> 
<p>操作文件的三大类</p> 
<p>1、ofstream ： 写操作</p> 
<p>2、ifstream ：读操作</p> 
<p>3、fstream : 读写操作</p> 
<h5><a id="51_1739"></a>5.1、文本文件</h5> 
<h6><a id="511_1741"></a>5.1.1、写文件</h6> 
<p>​ 写文件步骤如下：</p> 
<p>​ 1、包含头文件</p> 
<p>​ #include </p> 
<p>​ 2、创建流对象</p> 
<p>​ of stream ofs;</p> 
<p>​ 3、打开文件</p> 
<p>​ ofs.open(“文件路径” ， 打开方式);</p> 
<p>​ 4、写数据</p> 
<p>​ ofs &lt;&lt; “学入的数据”;</p> 
<p>​ 5、关闭文件</p> 
<p>​ ofs.close() ;</p> 
<p>文件打开方式：</p> 
<p>ios::in 为读文件而打开文件</p> 
<p>ios::out 为写文件而打开文件</p> 
<p>ios::binary 二进制</p> 
<h6><a id="512_1779"></a>5.1.2、读文件</h6> 
<h4><a id="4_C__1785"></a>4、 C++ 提高编程</h4> 
<h5><a id="41_1789"></a>4.1模版</h5> 
<h6><a id="11__1793"></a>1.1 函数模版</h6> 
<ul><li>泛型编程。主要利用技术就是模板</li><li>c++提供两种模版机制 ： 函数模版 和 类模版</li></ul> 
<p>语法：</p> 
<pre><code class="prism language-c++">template &lt;typename &gt;
函数声明 或 定义
</code></pre> 
<p>解释：</p> 
<p>Template – 声明创建模版</p> 
<h6><a id="12%09_1815"></a>1.2 函数模版</h6> 
<h6><a id="1_1819"></a>1、函数模版语法</h6> 
<pre><code class="prism language-c++">//函数模版
template &lt;typename  T&gt;  // typename 可以替换成class 声明一个模版。告诉编译器后面的T 不要报错，T时一个通用的数据类型
void mySwap(T &amp;a , T &amp;b)
{
    T temp = a ;
    a = b;
    b = temp;
}

int main()
{
    int a = 10 , b = 20;
    double a1 = 1.1 , b1 = 2.2;
    
    //自动类型推导
    mySwap(a, b);
    
    //显示指定类型
    mySwap(a1, b1);
    
    cout &lt;&lt; "a1 =  " &lt;&lt; a1 &lt;&lt; "  b1 =  " &lt;&lt; b1 &lt;&lt; endl;
    
    cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; "  b = " &lt;&lt; b &lt;&lt; endl;
    
}
</code></pre> 
<h6><a id="2_1851"></a>2、注意事项</h6> 
<p>​ 使用模版时必须确定出通用数据类型T， 并且能够推一致的类型</p> 
<h6><a id="3_1859"></a>3、函数模版案例</h6> 
<pre><code class="prism language-c++">//函数模版
template &lt;typename  T&gt;  // 声明一个模版。告诉编译器后面的T 不要报错，T时一个通用的数据类型
void mySwap(T &amp;a , T &amp;b)
{
    T temp = a ;
    a = b;
    b = temp;
}

//实现通用 对数组 进行排序的函数
// 从大到大

//排序算法
template &lt;class T&gt;
void mySort(T arr[] , int len)
{
    for(int i = 0 ; i &lt; len - 1; i++ ){
        int min = i;
        for(int j = i + 1 ; j &lt; len ; j++){
            if( arr[min] &gt; arr[j]){
                min = j;
            }
        }
        if(min != i){
            mySwap(arr[i], arr[min]);
        }
    }
}
</code></pre> 
<h6><a id="4_1894"></a>4、普通函数和函数模版区别：</h6> 
<p>​ 1、普通函数调用 可以发生隐式类型转换</p> 
<p>​ 2、函数模版 用自动类型推导，不可以发生隐式类型转换</p> 
<p>​ 3、函数模版 用显示指定类型，可以发生隐式类型转换</p> 
<h6><a id="5___1904"></a>5、普通函数 和 函数模版的调用规则</h6> 
<p>​ 1、如果函数模版和普通函数都可以实现，优先调用普通函数</p> 
<p>​ 2、可以通过空模版参数列表来强调函数模版</p> 
<pre><code class="prism language-c++">void myPrint(int a , int b)
{
    cout &lt;&lt; "普通函数" &lt;&lt; endl;
}

template &lt;class T&gt;
void myPrint(T a , T b)
{
    cout &lt;&lt; "调用的模版" &lt;&lt; endl;
}

int main()
{
    int a = 10, b = 20;
    
    //myPrint(a, b);
    
    //强制调用函数模版
    myPrint&lt;&gt;(a, b);
}

</code></pre> 
<p>​</p> 
<p>​ 3、函数模版可以发生重载</p> 
<p>​ 4、如果函数模版可以产生更好的匹配，优先调用函数模版</p> 
<h6><a id="6_1946"></a>6、局限性</h6> 
<p>模版不是万能的，有些特定数据类型，需要用具体化方式做特殊处理</p> 
<pre><code class="prism language-c++">class Person
{
public:
    Person(string name , int age){
        this-&gt;m_Age = age ;
        this-&gt;m_Name = name;
    }
    string m_Name;
    int m_Age;
};

template &lt;class T&gt;
bool myComp(T &amp;a , T &amp;b){
    return a == b;
}

template&lt;&gt; bool myComp(Person &amp;p1 , Person &amp;p2)
{
    bool flag;
    if(p1.m_Age == p2.m_Age &amp;&amp; p1.m_Name == p2.m_Name)
    {
        return true;
    }else{
        return false;
    }
}

void test()
{
    Person p("a" , 10);
    Person p1("a" , 11);
    
    cout &lt;&lt; myComp(p, p1) &lt;&lt; endl;
}

</code></pre> 
<h6><a id="13%09_1994"></a>1.3 类模版</h6> 
<h6><a id="1_1998"></a>1、类模版语法：</h6> 
<pre><code class="prism language-c++">//类模版
template &lt;class nameType , class ageType&gt;
class MyPerson
{
public:
    MyPerson(nameType name , ageType age)
    {
        this-&gt;name = name;
        this-&gt;age = age;
    }
    
    void show()
    {
        cout &lt;&lt; this-&gt;name &lt;&lt; "  " &lt;&lt; this-&gt;age &lt;&lt; endl;
    }
    
    nameType name;
    ageType age;
};

void test1()
{
    MyPerson m1("张三" , 189);
    m1.show(); 
}

</code></pre> 
<h6><a id="2_2031"></a>2、类模版对象做函数参数</h6> 
<p>一共三种传入方式：</p> 
<p>1、指定传入类型 - 直接显示对象的数据类型</p> 
<p>2、参数模版化 - 将对象中的参数变为模版进行传递</p> 
<p>3、整个类模版化 - 讲这个对象类型模版化进行传递</p> 
<pre><code class="prism language-c++">//1、指定传入类型
void printPerson( MyPerson&lt;string, int&gt; &amp;m)
{
    m.show();
}

//2、参数模版化
template&lt;class T1 , class T2&gt;
void printPerson2(MyPerson&lt;T1, T2&gt; &amp;p)
{
    p.show();
}
//3、整个类模版化
template&lt;class T&gt;
void printPerson3(T &amp;t)
{
    t.show();
}

void test1()
{
    MyPerson&lt;string, int&gt; m("aa" , 10);
    printPerson3(m);
}
</code></pre> 
<h6><a id="3_2074"></a>3、类模版与继承</h6> 
<pre><code class="prism language-c++">template &lt;class T&gt;
class Base
{
    T m;
};

//class Son : public Base 错误， 必须知道Base 数据类型
class Son : public Base&lt;int &gt;
{
    
};

//如果想灵活指定父类的T类型， 子类也需要变类模版
template&lt;class T1 , class T2&gt;
class Son1 : public Base&lt;T1&gt;
{
    T2 obj;
};
</code></pre> 
<h6><a id="4_2101"></a>4、类模版成员函数类外实现</h6> 
<h4><a id="5STL_2107"></a>5、STL</h4> 
<h5><a id="1stl_2109"></a>1、初识stl</h5> 
<h6><a id="11_2111"></a>1.1、基本概念</h6> 
<ul><li>STL。： 标准模版库</li><li>STL. 从广义上分 ： 容器 算法 迭代器</li><li>容器和算法可以通过迭代器进行无缝连接</li><li>s t l 几乎所有代码都采用了模版类或者模版函数</li></ul> 
<h6><a id="12stl__2122"></a>1.2、stl 六大组件</h6> 
<p>​ <strong>容器、算法、迭代器、仿函数 、 适配器、空间适配器</strong></p> 
<p>1、容器： 哥中数据结构。如vector 、 list. 、de que 、set 、 map 等用来存放数据</p> 
<p>2、算法： 各种常用算法，如sort 。</p> 
<p>3、迭代器： 扮演了容器和算法之间的胶合剂</p> 
<p>4、仿函数：行为类似函数</p> 
<p>5、适配器 ：一种用来修饰容器或者仿函数或迭代器接口的东西</p> 
<p>6、空间配置器；负责空间的配置与管理</p> 
<h6><a id="13__2142"></a>1.3、 简单遍历</h6> 
<pre><code class="prism language-c++">void test()
{
    //创建yige vector 容器 ，数组
    vector&lt;int&gt; v;
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);
    
    for(vector&lt;int&gt;::iterator it = v.begin() ; it != v.end() ; it++)
    {
        cout &lt;&lt; *it &lt;&lt; " ";
        
    }
    cout &lt;&lt; endl;
}

void test1()
{
    vector&lt;vector&lt;int&gt;&gt; v;
    
    vector&lt;int&gt; v1;
    vector&lt;int&gt; v2;
    vector&lt;int&gt; v3;
    vector&lt;int&gt; v4;
    
    for(int i = 0 ; i &lt; 4 ; i ++)
    {
        v1.push_back(i + 1);
        v2.push_back(i + 2);
        v3.push_back(i + 2);
        v4.push_back(i + 2);
    }
    
    v.push_back(v1);
    v.push_back(v2);
    v.push_back(v3);
    v.push_back(v4);
    
    for(vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin() ; it != v.end() ; it++)
    {
        for(vector&lt;int&gt;::iterator vit = (*it).begin() ; vit != (*it).end() ; vit++)
        {
            cout &lt;&lt; *vit &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }
    
}
</code></pre> 
<h5><a id="2_2197"></a>2、容器</h5> 
<h6><a id="1string___2199"></a>1、string 容器</h6> 
<h6><a id="21string__2201"></a>2.1、string 基本概念</h6> 
<ul><li>string 是 C++ 风格的字符串 而 string 本质上是一个类</li></ul> 
<p>string 和 char* 区别：</p> 
<ul><li>Char* 是一个指针</li><li>string 是一个类 类内部封装了char* 管理这个类 , 是一个char * 型 的容器</li></ul> 
<p>特点： string 类封装 了很多成员方法</p> 
<p>比如 ： find copy delete replace insert</p> 
<p>string 管理cha r * 所分配的内存 不用担心复制和越界等，由类内部 进行负责</p> 
<h6><a id="22string___2224"></a>2.2、string 构造函数</h6> 
<h6><a id="_2226"></a></h6> 
<ul><li> <p>string() //创建一个空字符串</p> <p>String(const char *s);</p> </li><li> <p>string(const string &amp; str) ； 使用string 对象初始化另一个string 对象</p> </li><li> <p>string(int n , char c) 使用n 个字符串c 初始化</p> </li></ul> 
<pre><code class="prism language-c++">void test2()
{
    string s1;
    
    const char * str = "hello";
    string s2(str);
    
    string s3(s2);
    
    string s4(10 , 'a');
}
</code></pre> 
<h6><a id="23string_2254"></a>2.3、string赋值操作</h6> 
<h6><a id="_2256"></a></h6> 
<pre><code class="prism language-c++">//1 、operator
//2、 assign

void test2()
{
    //string &amp; operator = const char * str;
    string str1 = "hello ";
    
    string str2 = str1;
    cout &lt;&lt; "str2 = " &lt;&lt; str2 &lt;&lt; endl;
    
    string str3;
    str3.assign("hello" , 5);
    cout &lt;&lt; "str3 = " &lt;&lt; str3 &lt;&lt; endl;
}
</code></pre> 
<h6><a id="24string__2278"></a>2.4、string 拼接</h6> 
<ul><li>+=</li><li>append</li></ul> 
<h6><a id="25_2287"></a>2.5、查找和替换</h6> 
<h6><a id="_2289"></a></h6> 
<ul><li>查找 ； 查找字符串是否存在 find</li><li>替换 ： 在指定位置替换字符串 replace</li></ul> 
<pre><code class="prism language-c++">void test4()
{
    string str = "abcdefgh";
    //find
    int pos = str.find("dq");
    
    cout &lt;&lt; str.find("dq") &lt;&lt; " " &lt;&lt; pos &lt;&lt;  endl; //输出出现的位置
    //rfind  和 find 区别
    // rfind 从右往左。find  从左往右
    
    
    //替换
    //从1 号位置起 三个字符  替换成“1111”
    string str1 = str.replace( 1 , 3, "1111");
    cout &lt;&lt; str1 &lt;&lt; endl;
    
}

</code></pre> 
<h6><a id="26_2321"></a>2.6、字符串比较</h6> 
<pre><code class="prism language-c++">void test5()
{
    string str1 = "hello";
    string str2 = "hell";
    
    if(str1.compare(str2) == 0)
    {
        cout &lt;&lt; "相等" &lt;&lt;endl;
    }else if(str1.compare(str2) &gt; 0)
    {
        cout &lt;&lt; "str1 大于 str2" &lt;&lt; endl;
    }else{
        cout &lt;&lt; "str1 小于 str2" &lt;&lt; endl;
    }
}
</code></pre> 
<h6><a id="27_2343"></a>2.7、插入和删除</h6> 
<pre><code class="prism language-c++">void test6()
{
    string str = "hello";
    
    str.insert(1, "aaa");
    
    cout &lt;&lt; str &lt;&lt; endl;
    
    str.erase( 1 , 3);
    
    cout &lt;&lt; str &lt;&lt; endl;
}	
</code></pre> 
<h6><a id="2vector__2362"></a>2、vector 容器</h6> 
<p>单端数组 , 可动态扩展</p> 
<p><strong>动态扩展：</strong></p> 
<ul><li>寻找更大的内存空间，将原数据拷贝，把之前的内存释放。</li></ul> 
<h6><a id="21_2374"></a>2.1、构造函数。</h6> 
<pre><code class="prism language-c++">void printVector(vector&lt;int&gt; &amp;v)
{
    for(vector&lt;int&gt;::iterator it = v.begin() ; it != v.end() ; it ++)
    {
        cout &lt;&lt; *it &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
}

void test7()
{
    vector&lt;int &gt; v1;
    
    for(int i = 0 ; i &lt; 10 ; i++)
    {
        v1.push_back(i);
    }
    printVector(v1);
}
</code></pre> 
<h6><a id="3deque_2404"></a>3、deque容器</h6> 
<ul><li>双端数组，可以对头端进行插入删除操作。</li></ul> 
<p>deque 和 vector 区别：</p> 
<ul><li>Vector 对于头部的插入删除效率低，数据量越大，效率越低</li><li>de que相对而言，对头部的插入删除速度比vector快</li><li>Vector 访问元素的速度会比deque快，这和两者内部实现有关。</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1f96ced99e308249195c8bfd030a2f58/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言--编写程序，从键盘输入月份号，输出该月的英文名。（用指针知识）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/60d4c2f7e377f7124c25e040f3f53b73/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">css动画实践</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>