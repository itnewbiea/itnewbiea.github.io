<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>买卖股票最佳时期系列 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="买卖股票最佳时期系列" />
<meta property="og:description" content="代码已在 leetcode 上验证通过。
通解方式，学习：https://leetcode-cn.com/circle/article/qiAgHn/
T[i][k][0] = max(T[i - 1][k][0], T[i - 1][k][1] &#43; prices[i])
T[i][k][1] = max(T[i - 1][k][1], T[i - 1][k - 1][0] - prices[i])
121.买卖股票的最佳时机
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。
注意：你不能在买入股票前卖出股票。
class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { if (prices.size() &lt;= 0) return 0; int profit0=0, profit1=-prices[0]; for (int i = 1; i &lt; prices.size(); i&#43;&#43;) { profit0 = max(profit0, profit1&#43;prices[i]); profit1 = max(profit1, -prices[i]); } return profit0; } }; 122." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f37adb8c9d4bace177701ef6aaad12e3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-27T10:58:23+08:00" />
<meta property="article:modified_time" content="2020-08-27T10:58:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">买卖股票最佳时期系列</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <br> 
<p>代码已在 leetcode 上验证通过。</p> 
<br> 
<p>通解方式，学习：https://leetcode-cn.com/circle/article/qiAgHn/</p> 
<p>T[i][k][0] = max(T[i - 1][k][0], T[i - 1][k][1] + prices[i])</p> 
<p>T[i][k][1] = max(T[i - 1][k][1], T[i - 1][k - 1][0] - prices[i])</p> 
<br> 
<br> 
<p><strong>121.买卖股票的最佳时机</strong></p> 
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p> 
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p> 
<p>注意：你不能在买入股票前卖出股票。</p> 
<pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        if (prices.size() &lt;= 0)  return 0;
        int profit0=0, profit1=-prices[0];
        for (int i = 1; i &lt; prices.size(); i++)
        {
            profit0 = max(profit0, profit1+prices[i]);
            profit1 = max(profit1, -prices[i]);
        }
        return profit0;
    }
};
</code></pre> 
<br> 
<br> 
<p><strong>122.买卖股票的最佳时机 II</strong></p> 
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p> 
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p> 
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p> 
<pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        if (prices.size() &lt;= 0)  return 0;
        int profit0=0, profit1=-prices[0];
        for (int i = 1; i &lt; prices.size(); i++)
        {
            int newProfit0 = max(profit0, profit1+prices[i]);
            int newProfit1 = max(profit1, profit0-prices[i]);
            profit0 = newProfit0;
            profit1 = newProfit1;
        }
        return profit0;
    }
};
</code></pre> 
<br> 
<br> 
<p><strong>123.买卖股票的最佳时机 III</strong></p> 
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p> 
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p> 
<p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p> 
<pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        if (prices.size() &lt;= 0)  return 0;
        int profitOne0=0, profitOne1=-prices[0];
        int profitTwo0=0, profitTwo1=-prices[0];
        for (int i = 1; i &lt; prices.size(); i++)
        {
            profitTwo0 = max(profitTwo0, profitTwo1+prices[i]);
            profitTwo1 = max(profitTwo1, profitOne0-prices[i]);
            profitOne0 = max(profitOne0, profitOne1+prices[i]);
            profitOne1 = max(profitOne1, -prices[i]);
        }
        return profitTwo0;
    }
};
</code></pre> 
<br> 
<br> 
<p><strong>188.买卖股票的最佳时机 IV</strong></p> 
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p> 
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p> 
<p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p> 
<pre><code>class Solution {
public:
    int maxProfit(int k, vector&lt;int&gt;&amp; prices) {
        if (prices.size() &lt;= 0)  return 0;
        if (k &gt;= prices.size()/2)  return maxProfitInf(prices);
        vector&lt;vector&lt;int&gt;&gt; profit(k+1, vector&lt;int&gt;(2,0));
        for (int i = 1; i &lt;= k; i++)  profit[i][1]=-prices[0];
        for (int i = 1; i &lt; prices.size(); i++)
        {
            for (int j = k; j &gt; 0; j--)
            {
                profit[j][0] = max(profit[j][0], profit[j][1]+prices[i]);
                profit[j][1] = max(profit[j][1], profit[j-1][0]-prices[i]);
            }
        }
        return profit[k][0];
    }

    int maxProfitInf(vector&lt;int&gt;&amp; prices) {
        if (prices.size() &lt;= 0)  return 0;
        int profit0=0, profit1=-prices[0];
        for (int i = 1; i &lt; prices.size(); i++)
        {
            profit0 = max(profit0, profit1+prices[i]);
            profit1 = max(profit1, profit0-prices[i]);
        }
        return profit0;
    }
};
</code></pre> 
<br> 
<br> 
<p><strong>309.最佳买卖股票时机含冷冻期</strong></p> 
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p> 
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p> 
<p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br> 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p> 
<pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        if (prices.size() &lt;= 0)  return 0;
        int prevprofit0=0, profit0=0, profit1=-prices[0];
        for (int i = 1; i &lt; prices.size(); i++)
        {
            int newProfit0 = max(profit0, profit1+prices[i]);
            int newProfit1 = max(profit1, prevprofit0-prices[i]);
            prevprofit0 = profit0;
            profit0 = newProfit0;
            profit1 = newProfit1;
        }
        return profit0;
    }
};
</code></pre> 
<br> 
<br> 
<p><strong>714.买卖股票的最佳时机含手续费</strong></p> 
<p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p> 
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p> 
<p>返回获得利润的最大值。</p> 
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p> 
<pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) {
        if (prices.size() &lt;= 0)  return 0;
        int profit0=0, profit1=-prices[0];
        for (int i = 1; i &lt; prices.size(); i++)
        {
            int newProfit0 = max(profit0, profit1+prices[i]-fee);
            int newProfit1 = max(profit1, profit0-prices[i]);
            profit0 = newProfit0;
            profit1 = newProfit1;
        }
        return profit0;
    }
};
</code></pre> 
<br> 
<br> 
<h3><a id="_214"></a><strong>附录</strong></h3> 
<p>本人代码，买卖股票的最佳时期123.</p> 
<br> 
<p><strong>1：只可卖一次</strong></p> 
<pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int minPri=INT_MAX, maxPro=0;
        for (int i = 0 ; i &lt; prices.size(); i++)
        {
            minPri = min(minPri, prices[i]);
            maxPro = max(maxPro, prices[i]-minPri);
        }
        return maxPro;
    }
};
</code></pre> 
<br> 
<p><strong>2：可以卖无限次</strong></p> 
<pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int maxPro = 0;
        for (int i = 1; i &lt; prices.size(); i++)
            if (prices[i] &gt; prices[i-1])
                maxPro += prices[i] - prices[i-1];
        return maxPro;
    }
};
</code></pre> 
<br> 
<p><strong>3：只可以卖俩次</strong></p> 
<pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        
        int maxPro = 0;
        int n = prices.size();
        vector&lt;int&gt; first(n,0);
        vector&lt;int&gt; second(n,0);

        int minF=INT_MAX, maxS=INT_MIN;
        int proF=INT_MIN, proS=INT_MAX;
        for (int i = 0; i &lt; n; i++)
        {
            minF = min(minF, prices[i]);
            proF = max(proF, prices[i] - minF);
            first[i] = proF;
        }
        for (int i = n-1; i &gt;= 0; i--)
        {
            maxS = max(maxS, prices[i]);
            proS = min(proS, prices[i] - maxS);
            second[i] = proS;
        }
        for (int i = 0; i &lt; n; i++)
            maxPro = max(maxPro, first[i] - second[i]);
        
        return maxPro;
    }
};
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d4ba066fd2c6b9efa773f1e00bdf7360/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android禁止安装三方应用(屏蔽所有安装应用的方式)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a33967b4ad495e66a75f7b702d079915/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">httpServletRequest.getParameter 参数中存在“&amp;”导致获取不到完整参数的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>