<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python3 进阶---多线程和锁 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python3 进阶---多线程和锁" />
<meta property="og:description" content="1.首先了解几个概念
（1）并发：多个任务同时进行，但是同一时刻只能处理一个任务，只有一个处理器，是逻辑意义上的同时发生
（2）并行：多个任务同时进行，而且在同一时刻是同时在执行的，有多个处理器，是物理意义上的同时发生
（3）进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位
（4）线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位
（5）一个进程至少包括一个线程
2.线程的创建与调用
# -*-coding:utf-8 -*- import threading import time start_time = time.time() def foo(name): start = time.time() print(&#34;hello %s&#34; % name) time.sleep(2) end = time.time() cost_time = end - start print(cost_time) # 创建线程 # target参数指向要执行的函数名 # args参数指向要执行的函数的参数，元组或者列表都可以 threading1 = threading.Thread(target=foo, args=(&#34;小明&#34;,)) threading2 = threading.Thread(target=foo, args=(&#34;小红&#34;,)) # 启动线程 threading1.start() threading2.start() # 堵塞主线程：线程.join()，直到当前线程运行结束才会继续运行主线程 # threading1运行完才会继续执行主线程 threading1.join() # threading1运行完才会继续执行主线程 threading2.join() end_time = time.time() print(&#34;total time:&#34;, end_time - start_time) 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f6d270fe029a94280c7c472435f511a7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-29T00:05:31+08:00" />
<meta property="article:modified_time" content="2020-08-29T00:05:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python3 进阶---多线程和锁</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>1.首先了解几个概念</strong></p> 
<p>（1）并发：多个任务同时进行，但是同一时刻只能处理一个任务，只有一个处理器，是逻辑意义上的同时发生</p> 
<p>（2）并行：多个任务同时进行，而且在同一时刻是同时在执行的，有多个处理器，是物理意义上的同时发生</p> 
<p>（3）进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位</p> 
<p>（4）线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位</p> 
<p>（5）一个进程至少包括一个线程</p> 
<p> </p> 
<p><strong>2.线程的创建与调用</strong></p> 
<pre><code class="language-python"># -*-coding:utf-8 -*-

import threading
import time

start_time = time.time()


def foo(name):
    start = time.time()
    print("hello %s" % name)
    time.sleep(2)
    end = time.time()
    cost_time = end - start
    print(cost_time)


# 创建线程
# target参数指向要执行的函数名
# args参数指向要执行的函数的参数，元组或者列表都可以
threading1 = threading.Thread(target=foo, args=("小明",))
threading2 = threading.Thread(target=foo, args=("小红",))

# 启动线程
threading1.start()
threading2.start()

# 堵塞主线程：线程.join()，直到当前线程运行结束才会继续运行主线程
# threading1运行完才会继续执行主线程
threading1.join()
# threading1运行完才会继续执行主线程
threading2.join()

end_time = time.time()

print("total time:", end_time - start_time)
</code></pre> 
<p> </p> 
<p><strong>3.守护线程</strong></p> 
<p>（1）通过t1.setDaemon(True) 设置线程t1为守护线程</p> 
<p>（2）守护线程在主线程结束之后会随之结束，不会再继续执行</p> 
<p>（3）守护线程需要在线程启动之前设置</p> 
<pre><code class="language-python"># -*-coding:utf-8 -*-

"""
守护线程：主线程结束，子线程也跟着结束
"""

import threading
import time

def foo():
    while True:
        print("生产了一个数据")
        time.sleep(1)

t1 = threading.Thread(target=foo)
# 守护线程必须在启动之前设置
# 主线程结束，t1跟着结束
t1.setDaemon(True)
t1.start()

print("主线程结束。。。。。")
</code></pre> 
<p><strong> </strong></p> 
<p><strong>4.同步锁</strong></p> 
<p>（1）创建同步锁：lock=threading.Lock()</p> 
<p>（2）同步锁上锁和解锁必须成对出现，否则会出现问题</p> 
<p>（3）上锁：lock.acquire(),重要数据操作之前上锁</p> 
<p>（4）解锁：lock.release()，重要数据操作之后解锁</p> 
<p> </p> 
<p><strong>5.死锁</strong></p> 
<p>线程死锁：多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。</p> 
<p>处理方式：</p> 
<p>（1）递归锁：不同任务之间的线程用递归锁</p> 
<p>         lock_R = threading.RLock()</p> 
<p>        # 递归锁内部维护着一个计算器</p> 
<p>        # 每次上锁，计数器+1</p> 
<p>        # 每次解锁，计算器-1</p> 
<p>        # 计数器必须&gt;=0</p> 
<p>（2）同步锁：同一个任务之间的线程用同步锁</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p><strong> </strong></p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/daf0828e7eaf5a56e41db81f49191b01/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Liunx（一）VMware虚拟机安装学习--Liunx学习的准备</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/068b3a6678ab93f00c43367c0c1b43e6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue element 树形图回显</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>