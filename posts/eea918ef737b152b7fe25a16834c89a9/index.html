<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java #垃圾回收相关算法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java #垃圾回收相关算法" />
<meta property="og:description" content="目录
标记阶段：
·引用计数算法
·可达性分析算法（根搜索算法）
清除阶段：
·标记-清除（Mark-Sweep）算法
·复制算法
·标记-压缩/整理 算法
分代回收思想
增量收集算法
标记阶段： ·引用计数算法 原理：对于每一个对象，保存一个整型的引用计数器属性，有任何对象引用了该对象，引用计数器值加1，当引用失效时，引用计数器值减1。当引用计数器值为0时，表示对象不在被使用，可以进行回收。
有致命的缺点：无法解决循环引用的问题。如图1：当外部指针p断开时，发现next对象的引用计数器值永远不会为0，对象无法被回收，造成内存泄漏。导致Java虚拟机中没有使用该算法。
图1 ·可达性分析算法（根搜索算法） 原理：以根对象集合（GC Roots）为起始点，从上至下搜索对象，判断对象是否被根对象直接或间接的引用着，如果对象没有被根对象集合直接或间接的引用着，则是不可达的。
使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的环境中进行。这也是导致垃圾回收时，导致stop the world的原因。
在可达性分析算法中，只有直接或间接被根对象连接着的对象，才是存活对象。如图2：
图2 哪些结构可以作为根对象（GC Roots）：
虚拟机栈中引用的对象。比如：各个线程被调用方法中使用到的参数、局部变量等。本地方法栈内JNI（通常说的本地方法）引用的对象。方法区中类静态属性引用的对象。比如：Java类的引用类型静态变量。方法区中常量引用的对象。比如：字符串常量池（String Table）里的引用。所有被同步锁synchronized持有的对象Java虚拟机内部的引用。基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。 清除阶段： ·标记-清除（Mark-Sweep）算法 当堆中的有效内存空间(available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world)，然后进行两项工作，第一项则是标记，第二项则是清除。
标记：Collector从引用根节点开始遍历，标记不被回收的对象，一般是在对象的Header中记录为可达对象。
清除：Collector对堆内存从头到尾进行线性遍历，将对象Header中没有标记为可达的对象，将其回收。
图3 缺点：回收后的内存是分散的，碎片状的，需要维护一个空闲列表（空闲列表：把一个地址告诉给空闲列表，空闲列表来记录这些地址是空闲的，之后数据就直接覆盖在该地址的数据）。
·复制算法 原理：将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。
图4 优点：
保证空间连续性。不需要标记过程。适用于可达对象少，垃圾对象多的场景，比如surviver区（from区和to区）。 缺点：
需要两倍的内存。从栈中的引用地址需要改变（因为对象的地址改变了）。当可达的对象很多时，复制算法就不适用了。 ·标记-压缩/整理 算法 标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩(Mark-Sweep-Compact)算法。
图5 与标记-清除算法的区别
二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。
可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。
优点：
解决了标记-清除算法的 “碎片” 问题。解决了复制算法两倍内存的问题。 缺点：
效率没有复制算法高。移动了对象，需要改变引用地址。 分代回收思想 新生代垃圾回收频率高，存活对象少，采用复制算法。
老年代垃圾回收频率低，存活对象多，采用标记-清除算法或与标记-整理算法混合使用。
增量收集算法 如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。
总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/eea918ef737b152b7fe25a16834c89a9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-05T17:25:43+08:00" />
<meta property="article:modified_time" content="2021-07-05T17:25:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java #垃圾回收相关算法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%EF%BC%9A" rel="nofollow">标记阶段：</a></p> 
<p id="%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95" rel="nofollow">·引用计数算法</a></p> 
<p id="%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%88%E6%A0%B9%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%88%E6%A0%B9%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%EF%BC%89" rel="nofollow">·可达性分析算法（根搜索算法）</a></p> 
<p id="%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A" rel="nofollow">清除阶段：</a></p> 
<p id="%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%EF%BC%88Mark-Sweep%EF%BC%89%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%EF%BC%88Mark-Sweep%EF%BC%89%E7%AE%97%E6%B3%95" rel="nofollow">·标记-清除（Mark-Sweep）算法</a></p> 
<p id="%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95" rel="nofollow">·复制算法</a></p> 
<p id="%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%2F%E6%95%B4%E7%90%86%20%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%2F%E6%95%B4%E7%90%86%20%E7%AE%97%E6%B3%95" rel="nofollow">·标记-压缩/整理 算法</a></p> 
<p id="%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E6%80%9D%E6%83%B3-toc" style="margin-left:40px;"><a href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E6%80%9D%E6%83%B3" rel="nofollow">分代回收思想</a></p> 
<p id="%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95" rel="nofollow">增量收集算法</a></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<hr id="hr-toc"> 
<h3 id="%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%EF%BC%9A">标记阶段：</h3> 
<h4 id="%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95">·引用计数算法</h4> 
<p>原理：对于每一个对象，保存一个整型的引用计数器属性，有任何对象引用了该对象，引用计数器值加1，当引用失效时，引用计数器值减1。当引用计数器值为0时，表示对象不在被使用，可以进行回收。</p> 
<p><span style="color:#fe2c24;">有致命的缺点</span>：无法解决循环引用的问题。如图1：当外部指针p断开时，发现next对象的引用计数器值永远不会为0，对象无法被回收，造成内存泄漏。导致Java虚拟机中没有使用该算法。</p> 
<figure class="image"> 
 <img alt="" height="456" src="https://images2.imgbox.com/9d/d6/7a8bYKTq_o.png" width="759"> 
 <figcaption>
   图1 
 </figcaption> 
</figure> 
<h4 id="%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%88%E6%A0%B9%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%EF%BC%89">·可达性分析算法（根搜索算法）</h4> 
<p>原理：以根对象集合（GC Roots）为起始点，从上至下搜索对象，判断对象是否被根对象直接或间接的引用着，如果对象没有被根对象集合直接或间接的引用着，则是不可达的。</p> 
<p>使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的环境中进行。这也是导致垃圾回收时，导致stop the world的原因。</p> 
<p>在可达性分析算法中，只有直接或间接被根对象连接着的对象，才是存活对象。如图2：</p> 
<figure class="image"> 
 <img alt="" height="433" src="https://images2.imgbox.com/6f/3b/TtvUCovG_o.png" width="640"> 
 <figcaption>
   图2 
 </figcaption> 
</figure> 
<p>哪些结构可以作为根对象（GC Roots）：</p> 
<ol><li>虚拟机栈中引用的对象。比如：各个线程被调用方法中使用到的参数、局部变量等。</li><li>本地方法栈内JNI（通常说的本地方法）引用的对象。</li><li>方法区中类静态属性引用的对象。比如：Java类的引用类型静态变量。</li><li>方法区中常量引用的对象。比如：字符串常量池（String Table）里的引用。</li><li>所有被同步锁synchronized持有的对象</li><li>Java虚拟机内部的引用。基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。</li></ol> 
<h3 id="%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A">清除阶段：</h3> 
<h4 id="%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%EF%BC%88Mark-Sweep%EF%BC%89%E7%AE%97%E6%B3%95">·标记-清除（Mark-Sweep）算法</h4> 
<p>当堆中的有效内存空间(available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world)，然后进行两项工作，第一项则是标记，第二项则是清除。</p> 
<p><strong>标记：</strong>Collector从引用根节点开始遍历，标记不被回收的对象，一般是在对象的Header中记录为可达对象。</p> 
<p><strong>清除：</strong>Collector对堆内存从头到尾进行线性遍历，将对象Header中没有标记为可达的对象，将其回收。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="576" src="https://images2.imgbox.com/ad/3b/zhzuvtS8_o.png" width="720"> 
  <figcaption>
    图3 
  </figcaption> 
 </figure> 
</div> 
<p>缺点：回收后的内存是分散的，碎片状的，需要维护一个空闲列表（空闲列表：把一个地址告诉给空闲列表，空闲列表来记录这些地址是空闲的，之后数据就直接覆盖在该地址的数据）。</p> 
<h4 id="%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95">·复制算法</h4> 
<p>原理：将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="468" src="https://images2.imgbox.com/43/e1/mdDnCV7f_o.png" width="810"> 
  <figcaption>
    图4 
  </figcaption> 
 </figure> 
</div> 
<p>优点：</p> 
<ul><li>保证空间连续性。</li><li>不需要标记过程。</li><li>适用于可达对象少，垃圾对象多的场景，比如surviver区（from区和to区）。</li></ul> 
<p>缺点：</p> 
<ul><li>需要两倍的内存。</li><li>从栈中的引用地址需要改变（因为对象的地址改变了）。</li><li>当可达的对象很多时，复制算法就不适用了。</li></ul> 
<h4 id="%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%2F%E6%95%B4%E7%90%86%20%E7%AE%97%E6%B3%95">·标记-压缩/整理 算法</h4> 
<p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩(Mark-Sweep-Compact)算法。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="471" src="https://images2.imgbox.com/3c/7d/dySVrZ5a_o.png" width="586"> 
  <figcaption>
    图5 
  </figcaption> 
 </figure> 
</div> 
<p><span style="color:#fe2c24;">与标记-清除算法的区别</span></p> 
<p>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。</p> 
<p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p> 
<p>优点：</p> 
<ul><li>解决了标记-清除算法的 “碎片” 问题。</li><li>解决了复制算法两倍内存的问题。</li></ul> 
<p>缺点：</p> 
<ul><li>效率没有复制算法高。</li><li>移动了对象，需要改变引用地址。</li></ul> 
<h3 id="%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E6%80%9D%E6%83%B3">分代回收思想</h3> 
<p>新生代垃圾回收频率高，存活对象少，采用复制算法。</p> 
<p>老年代垃圾回收频率低，存活对象多，采用标记-清除算法或与标记-整理算法混合使用。</p> 
<h3 id="%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95">增量收集算法</h3> 
<p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p> 
<p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</p> 
<h4></h4>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a469f9fac4645a29c76180b272fe7d36/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java #对象的finalization机制</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/675f632de6a15e82c282854f8beff1ae/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于STM32的颜色传感器TCS3472</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>