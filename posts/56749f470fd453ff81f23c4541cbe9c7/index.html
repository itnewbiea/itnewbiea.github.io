<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>grpc java 安全性设计SSL/TLS - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="grpc java 安全性设计SSL/TLS" />
<meta property="og:description" content="一. 基于 SSL/TLS 的通道加密当存在跨网络边界的 RPC 调用时，往往需要通过 TLS/SSL 对传输通道进行加密，以防止请求和响应消息中的敏感数据泄漏。跨网络边界调用场景主要有三种： 1. 后端微服务直接开放给端侧，例如手机 App、TV、多屏等，没有统一的 API Gateway/SLB 做安全接入和认证；
2. 后端微服务直接开放给 DMZ 部署的管理或者运维类 Portal；
3. 后端微服务直接开放给第三方合作伙伴 / 渠道。
除了跨网络之外，对于一些安全等级要求比较高的业务场景，即便是内网通信，只要跨主机 /VM/ 容器通信，都强制要求对传输通道进行加密。在该场景下，即便只存在内网各模块的 RPC 调用，仍然需要做 SSL/TLS。
目前使用最广的 SSL/TLS 工具 / 类库就是 OpenSSL，它是为网络通信提供安全及数据完整性的一种安全协议，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及 SSL 协议。
多数 SSL 加密网站是用名为 OpenSSL 的开源软件包，由于这也是互联网应用最广泛的安全传输方法，被网银、在线支付、电商网站、门户网站、电子邮件等重要网站广泛使用。
二. 认证和鉴权RPC 的认证和鉴权机制主要包含两点： 1. 认证：对调用方身份进行识别，防止非法调用； 2. 鉴权：对调用方的权限进行校验，防止越权调用。
事实上，并非所有的 RPC 调用都必须要做认证和鉴权，例如通过 API Gateway 网关接入的流量，已经在网关侧做了鉴权和身份认证，对来自网关的流量 RPC 服务端就不需要重复鉴权。
另外，一些对安全性要求不太高的场景，可以只做认证而不做细粒度的鉴权。
三. gRPC 安全机制 谷歌提供了可扩展的安全认证机制，以满足不同业务场景需求，它提供的授权机制主要有四类：
1. 通道凭证：默认提供了基于 HTTP/2 的 TLS，对客户端和服务端交换的所有数据进行加密传输；
2. 调用凭证：被附加在每次 RPC 调用上，通过 Credentials 将认证信息附加到消息头中，由服务端做授权认证；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/56749f470fd453ff81f23c4541cbe9c7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-09T16:52:41+08:00" />
<meta property="article:modified_time" content="2018-05-09T16:52:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">grpc java 安全性设计SSL/TLS</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h5><strong>一.  基于 SSL/TLS 的通道加密</strong></h5>当存在跨网络边界的 RPC 调用时，往往需要通过 TLS/SSL 对传输通道进行加密，以防止请求和响应消息中的敏感数据泄漏。跨网络边界调用场景主要有三种： 
<br> 
<br> 
<strong>1.  后端微服务直接开放给端侧，例如手机 App、TV、多屏等，没有统一的 API Gateway/SLB 做安全接入和认证；<br>2.  后端微服务直接开放给 DMZ 部署的管理或者运维类 Portal；<br></strong> 
<p><strong>3.  后端微服务直接开放给第三方合作伙伴 / 渠道。</strong></p> 
<p>除了跨网络之外，对于一些安全等级要求比较高的业务场景，即便是内网通信，只要跨主机 /VM/ 容器通信，都强制要求对传输通道进行加密。在该场景下，即便只存在内网各模块的 RPC 调用，仍然需要做 SSL/TLS。</p> 
<p></p> 
<p>目前使用最广的 SSL/TLS 工具 / 类库就是 OpenSSL，它是为网络通信提供安全及数据完整性的一种安全协议，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及 SSL 协议。</p> 
<p>多数 SSL 加密网站是用名为 OpenSSL 的开源软件包，由于这也是互联网应用最广泛的安全传输方法，被网银、在线支付、电商网站、门户网站、电子邮件等重要网站广泛使用。</p> 
<p><br></p> 
<p></p> 
<h5><strong>二.  认证和鉴权</strong></h5>RPC 的认证和鉴权机制主要包含两点： 
<br> 
<br> 
<strong>1.  认证：对调用方身份进行识别，防止非法调用；</strong> 
<br> 
<p><strong>2.  鉴权：对调用方的权限进行校验，防止越权调用。</strong></p> 
<p>事实上，并非所有的 RPC 调用都必须要做认证和鉴权，例如通过 API Gateway 网关接入的流量，已经在网关侧做了鉴权和身份认证，对来自网关的流量 RPC 服务端就不需要重复鉴权。</p> 
<p>另外，一些对安全性要求不太高的场景，可以只做认证而不做细粒度的鉴权。</p> 
<p><br></p> 
<p></p> 
<h5><strong>三.  gRPC 安全机制</strong></h5> 
<p>谷歌提供了可扩展的安全认证机制，以满足不同业务场景需求，它提供的授权机制主要有四类：</p> 
<strong>1.  通道凭证：默认提供了基于 HTTP/2 的 TLS，对客户端和服务端交换的所有数据进行加密传输；<br>2.  调用凭证：被附加在每次 RPC 调用上，通过 Credentials 将认证信息附加到消息头中，由服务端做授权认证；<br>3.  组合凭证：将一个频道凭证和一个调用凭证关联起来创建一个新的频道凭证，在这个频道上的每次调用会发送组合的调用凭证来作为授权数据，最典型的场景就是使用 HTTP S 来传输 Access Token；<br></strong> 
<p><strong>4. Google 的 OAuth 2.0：gRPC 内置的谷歌的 OAuth 2.0 认证机制，通过 gRPC 访问 Google API 时，使用 Service Accounts 密钥作为凭证获取授权令牌。</strong></p> 
<p></p> 
<p><br></p> 
<h5><strong>四.  gRPC 的 TLS 策略</strong></h5> 
<p>gRPC 基于 HTTP/2 协议，默认会开启 SSL/TLS。gRPC 的 TLS 实现有两种策略：</p> 
<strong>1.  基于 OpenSSL 的 TLS<br></strong> 
<p><strong>2.  基于 Jetty ALPN/NPN 的 TLS</strong></p>对于非安卓的后端 Java 应用，gRPC 强烈推荐使用 OpenSSL，原因如下： 
<br> 
<br>1.  性能更高：基于 OpenSSL 的 gRPC 调用比使用 JDK GCM 的性能高 10 倍以上； 
<br>2.  密码算法更丰富：OpenSSL 支持的密码算法比 JDK SSL 提供的更丰富，特别是 HTTP/2 协议使用的加密算法； 
<br>OpenSSL 支持 ALPN 回退到 NPN； 
<br>3.  不需要根据 JDK 的版本升级配套升级 ALPN 类库（Jetty 的 ALPN 版本与 JDK 特定版本配套使用）。 
<br>gRPC 的 HTTP/2 和 TLS 基于 Netty 框架实现，如果使用 OpenSSL，则需要依赖 Netty 的 netty-tcnative。 
<br> 
<br> 
<br>Netty 的 OpenSSL 有两种实现机制：Dynamic linked 和 Statically Linked。在开发和测试环境中，建议使用 Statically Linked 的方式（netty-tcnative-boringssl-static），它提供了对 ALPN 的支持以及 HTTP/2 需要的密码算法，不需要额外再集成 Jetty 的 ALPN 类库。从 1.1.33.Fork16 版本开始支持所有的操作系统，可以实现跨平台运行。 
<br> 
<br>对于生产环境，则建议使用 Dynamic linked 的方式，原因如下： 
<br> 
<br>很多场景下需要升级 OpenSSL 的版本或者打安全补丁，如果使用动态链接方式（例如 apt-ge），则应用软件不需要级联升级； 
<br>对于一些紧急的 OpenSSL 安全补丁，如果采用 Statically Linked 的方式，需要等待 Netty 社区提供新的静态编译补丁版本，可能会存在一定的滞后性。 
<br> 
<p>netty-tcnative-boringssl-static 的 gradle 配置如下：</p> 
<pre><code class="language-java">//ssl
compile 'io.netty:netty-tcnative-boringssl-static:2.0.8.Final'</code></pre> 
<p><br></p> 
<h5><strong>五.  使用样例参考</strong></h5> 
<p>服务端配置demo:</p> 
<pre><code class="language-java">import io.grpc.Server;
import io.grpc.ServerBuilder;
import io.netty.handler.ssl.util.SelfSignedCertificate;

/**
 * @describe GRpcServer default ssl demo
 * @author zhikai.chen
 * @date 2018年5月7日 下午3:55:10
 */
public class GRpcServerDefaultSSL {
	
	private static final Logger logger = LoggerFactory.getLogger(GRpcServerDefaultSSL.class);

    private Server server;

    private void start() throws IOException, CertificateException {
        /* The port on which the server should run */
        int port = 50051;
        SelfSignedCertificate ssc = new SelfSignedCertificate();
        //底层默认使用netty4.1的nio同步非阻塞模型
        server = ServerBuilder.forPort(port).useTransportSecurity(ssc.certificate(), ssc.privateKey())
        		.addService(new PhoneServiceImp())
                .build()
                .start();
        logger.info("Server started, listening on " + port);
        Runtime.getRuntime().addShutdownHook(new Thread() {
            @Override
            public void run() {
                System.err.println("*** shutting down gRPC server since JVM is shutting down");
                GRpcServerDefaultSSL.this.stop();
                System.err.println("*** server shut down");
            }
        });
    }

    private void stop() {
        if (server != null) {
            server.shutdown();
        }
    }

    /**
     * Await termination on the main thread since the grpc library uses daemon
     * threads.
     */
    private void blockUntilShutdown() throws InterruptedException {
        if (server != null) {
            server.awaitTermination();
        }
    }

    /**
     * Main launches the server from the command line.
     * @throws CertificateException 
     */
    public static void main(String[] args) throws IOException, InterruptedException, CertificateException {
        final GRpcServerDefaultSSL server = new GRpcServerDefaultSSL();
        server.start();
        server.blockUntilShutdown();
    }

}
</code></pre> 
<br> 
<p>客户端配置demo:</p> 
<pre><code class="language-java">import java.util.concurrent.TimeUnit;

import javax.net.ssl.SSLException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ylifegroup.protobuf.PhoneServiceGrpc;
import com.ylifegroup.protobuf.Phonebook.AddPhoneToUserRequest;
import com.ylifegroup.protobuf.Phonebook.AddPhoneToUserResponse;
import com.ylifegroup.protobuf.Phonebook.PhoneType;

import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.StatusRuntimeException;
import io.grpc.netty.GrpcSslContexts;
import io.grpc.netty.NettyChannelBuilder;
import io.netty.handler.codec.http2.Http2SecurityUtil;
import io.netty.handler.ssl.ApplicationProtocolConfig;
import io.netty.handler.ssl.ApplicationProtocolNames;
import io.netty.handler.ssl.OpenSsl;
import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.SslProvider;
import io.netty.handler.ssl.SupportedCipherSuiteFilter;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;

/**
 * @describe GRpcClient Block demo
 * @author zhikai.chen
 * @date 2018年5月7日 下午4:00:58
 */
public class GRpcClientBlockSSL {
	
	private static final Logger logger = LoggerFactory.getLogger(GRpcClientBlockSSL.class);

    private final ManagedChannel channel;

    private final PhoneServiceGrpc.PhoneServiceBlockingStub blockingStub;

    /** Construct client connecting to gRPC server at {@code host:port}. 
     * @throws SSLException */
    public GRpcClientBlockSSL(String host, int port) throws SSLException {
    	this(NettyChannelBuilder.forAddress(host, port).sslContext(
                GrpcSslContexts.forClient().
                ciphers(Http2SecurityUtil.CIPHERS,
                        SupportedCipherSuiteFilter.INSTANCE).
                trustManager(InsecureTrustManagerFactory.INSTANCE).build()));
    }
    
    /** Construct client connecting to gRPC server at {@code host:port}. 
     * @throws SSLException */
    public GRpcClientBlockSSL(String host, int port,boolean value) throws SSLException {
    	this(NettyChannelBuilder.forAddress(host, port).sslContext(SslContextBuilder.forClient()
                .sslProvider(OpenSsl.isAlpnSupported() ? SslProvider.OPENSSL : SslProvider.JDK)
                .ciphers(Http2SecurityUtil.CIPHERS, SupportedCipherSuiteFilter.INSTANCE)
                .trustManager(InsecureTrustManagerFactory.INSTANCE)
                .applicationProtocolConfig(new ApplicationProtocolConfig(
                        ApplicationProtocolConfig.Protocol.ALPN,
                        ApplicationProtocolConfig.SelectorFailureBehavior.NO_ADVERTISE,
                        ApplicationProtocolConfig.SelectedListenerFailureBehavior.ACCEPT,
                        ApplicationProtocolNames.HTTP_2,
                        ApplicationProtocolNames.HTTP_1_1))
                .build()));
    }
    
    /** Construct client for accessing RouteGuide server using the existing channel. */
    GRpcClientBlockSSL(ManagedChannelBuilder&lt;?&gt; channelBuilder) {
      channel = channelBuilder.build();
      blockingStub = PhoneServiceGrpc.newBlockingStub(channel);
    }

    public void shutdown() throws InterruptedException {
        channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);
    }

    /** add phone to user. */
    public void addPhoneToUser(int uid, PhoneType phoneType, String phoneNubmer) {
        logger.info("Will try to add phone to user " + uid);
        AddPhoneToUserRequest request = AddPhoneToUserRequest.newBuilder().setUid(uid).setPhoneType(phoneType)
                .setPhoneNumber(phoneNubmer).build();
        AddPhoneToUserResponse response;
        try {
            response = blockingStub.addPhoneToUser(request);
        } catch (StatusRuntimeException e) {
            logger.warn("RPC failed: {0}", e.getStatus());
            return;
        }
        logger.info("Result: " + response.getResult());
    }

    public static void main(String[] args) throws Exception {
        GRpcClientBlockSSL client = new GRpcClientBlockSSL("localhost", 50051);
        try {
            client.addPhoneToUser(1, PhoneType.WORK, "13888888888");
            
            client = new GRpcClientBlockSSL("localhost", 50051,true);
            client.addPhoneToUser(1, PhoneType.WORK, "13888888888");
        } finally {
            client.shutdown();
        }
    }

}</code></pre> 
<p><br></p> 
<p>运行效果图参考：</p> 
<p><img src="https://images2.imgbox.com/2b/36/LwHCoNY3_o.png" alt=""><br></p> 
<p><br></p> 
<p><img src="https://images2.imgbox.com/7f/96/mCzFMHHl_o.png" alt=""><br></p> 
<p><br></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9d4c7d582446e6bfe0877f9e52286d3c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HTML复习笔记汇总(1)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/86de6fc08fb13b6dc55e36be423f4769/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AccessibilityService自启动</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>