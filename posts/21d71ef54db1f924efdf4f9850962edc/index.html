<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>FTPS的正确使用 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="FTPS的正确使用" />
<meta property="og:description" content="关于FTP、FTPS 与 SFTP 简介见另外一篇转载的文章,讲的比较详细,此文不在另外描述.
https://blog.csdn.net/ericwuhk/article/details/109120158
FTPS在微软官网寥寥数笔,看完也一头雾水,无奈找了一通,找了到了一份开源代码,研究了一通发觉可用,至此记录.
https://docs.microsoft.com/en-us/archive/blogs/adarshk/using-ftpwebrequest-to-do-ftp-over-ssl
一句未改得原始代码上传至CSDN,以便哪天找不到国外网站资源.
https://download.csdn.net/download/ericwuhk/12984869
第一步:打开源码,VS报弹框不用理,直接确定即可.在原始代码中直接rebuild编译FTPSClient,生成&#34;AlexPilotti.FTPS.Client.dll&#34;和“AlexPilotti.FTPS.Client.XML&#34; 这两个文件导入至所需得项目路径下,直接引用就可.
第二步:编译FTPSClientCmdApp,生成ftps.exe,打开cmd命令窗口查看工具是否可正常使用
ftps -h 10.131.128.6 -U user -P password -ssl CredentialsRequired -g /Modules/ZW01TLAA.IMZ C:\Users\XXX\Desktop\mytest 第三步:在自己的项目中,导入&#34;AlexPilotti.FTPS.Client.dll&#34;和“AlexPilotti.FTPS.Client.XML&#34;后,需要修改代码才能正确使用.核心代码修改如下:
using System; using System.Data; using System.IO; using BaseLibrary.ExecutionResults; using System.Text; using System.Net; using System.Net.Security; using System.Security.Cryptography.X509Certificates; using BaseLibrary.Config; using AlexPilotti.FTPS.Client; public class readfile { public string strServerPath; public FTPSClient client; public void initFTPS() { CCfg ccfg = new CCfg(); strServerPath = ccfg.GetValue(&#34;serverPath&#34;);//modules string user = ccfg." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/21d71ef54db1f924efdf4f9850962edc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-20T19:41:07+08:00" />
<meta property="article:modified_time" content="2020-10-20T19:41:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">FTPS的正确使用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>关于FTP、FTPS 与 SFTP 简介见另外一篇转载的文章,讲的比较详细,此文不在另外描述.</p> 
<p><a href="https://blog.csdn.net/ericwuhk/article/details/109120158">https://blog.csdn.net/ericwuhk/article/details/109120158</a></p> 
<p>FTPS在微软官网寥寥数笔,看完也一头雾水,无奈找了一通,找了到了一份开源代码,研究了一通发觉可用,至此记录.</p> 
<p><a href="https://docs.microsoft.com/en-us/archive/blogs/adarshk/using-ftpwebrequest-to-do-ftp-over-ssl" rel="nofollow">https://docs.microsoft.com/en-us/archive/blogs/adarshk/using-ftpwebrequest-to-do-ftp-over-ssl</a></p> 
<p>一句未改得原始代码上传至CSDN,以便哪天找不到国外网站资源.</p> 
<p><a href="https://download.csdn.net/download/ericwuhk/12984869">https://download.csdn.net/download/ericwuhk/12984869</a></p> 
<p><strong>第一步:</strong>打开源码,VS报弹框不用理,直接确定即可.在原始代码中直接rebuild编译FTPSClient,生成"AlexPilotti.FTPS.Client.dll"和“AlexPilotti.FTPS.Client.XML" 这两个文件导入至所需得项目路径下,直接引用就可.</p> 
<p><img alt="" height="407" src="https://images2.imgbox.com/de/28/Cb8r8Ae7_o.png" width="357"></p> 
<p><strong>第二步:</strong>编译FTPSClientCmdApp,生成ftps.exe,打开cmd命令窗口查看工具是否可正常使用</p> 
<pre><code>ftps -h 10.131.128.6 -U user -P password -ssl CredentialsRequired -g /Modules/ZW01TLAA.IMZ C:\Users\XXX\Desktop\mytest</code></pre> 
<p><strong>第三步:</strong>在自己的项目中,导入"AlexPilotti.FTPS.Client.dll"和“AlexPilotti.FTPS.Client.XML"后,需要修改代码才能正确使用.核心代码修改如下:</p> 
<pre><code class="language-cs">using System;
using System.Data;
using System.IO;
using BaseLibrary.ExecutionResults;
using System.Text;
using System.Net;
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;
using BaseLibrary.Config;
using AlexPilotti.FTPS.Client;

public class readfile
{
    public string strServerPath;
    public FTPSClient client;

    public void initFTPS()
        {
            CCfg ccfg = new CCfg();
            strServerPath = ccfg.GetValue("serverPath");//modules
            string user = ccfg.GetValue("user");//"ftpsuser"
            string password = ccfg.GetValue("password");//"password"
            string ip = ccfg.GetValue("ip");//"192.168.1.1"

            client = new FTPSClient();
            NetworkCredential credential = new NetworkCredential(user, password);
            ESSLSupportMode sslRequestSupportMode = ESSLSupportMode.DataChannelRequested;
            X509Certificate x509ClientCert = null;
            string sslClientCertPath = null;
            int sslMinKeyExchangeAlgStrength = 0;
            int sslMinCipherAlgStrength = 0;
            int sslMinHashAlgStrength = 0;
            int timeout = 120;
            bool useCtrlEndPointAddressForData = false;
            EDataConnectionMode dataConnectionMode = EDataConnectionMode.Passive;
            if (sslClientCertPath != null)
            {
                x509ClientCert = X509Certificate.CreateFromCertFile(sslClientCertPath);
            }
            client.Connect(ip, 21,
                credential,
                sslRequestSupportMode,
                new RemoteCertificateValidationCallback(ValidateTestServerCertificate),
                x509ClientCert,
                sslMinKeyExchangeAlgStrength,
                sslMinCipherAlgStrength,
                sslMinHashAlgStrength,
                timeout * 1000,
                useCtrlEndPointAddressForData,
                dataConnectionMode);                            
        }

        enum EInvalidSslCertificateHandling { Refuse, Accept, Prompt }
        private  bool ValidateTestServerCertificate(object sender, X509Certificate                     certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
        {
            bool certOk = false;
            EInvalidSslCertificateHandling sslInvalidServerCertHandling = EInvalidSslCertificateHandling.Prompt;

            if (sslPolicyErrors == SslPolicyErrors.None)
                certOk = true;
            else
            {
                Console.Error.WriteLine();

                if ((sslPolicyErrors &amp; SslPolicyErrors.RemoteCertificateChainErrors) &gt; 0)
                    Info("WARNING: SSL/TLS remote certificate chain warning");

                if ((sslPolicyErrors &amp; SslPolicyErrors.RemoteCertificateNameMismatch) &gt; 0)
                    Info("WARNING: SSL/TLS remote certificate name mismatch");

                if ((sslPolicyErrors &amp; SslPolicyErrors.RemoteCertificateNotAvailable) &gt; 0)
                    Info("WARNING: SSL/TLS remote certificate not available");

                if (sslInvalidServerCertHandling == EInvalidSslCertificateHandling.Accept)
                    certOk = true;
            }

            if (!certOk)
            {                
                Info("SSL/TLS Server certificate details:");                
                Info(GetCertificateInfo(certificate));
            }

            if (!certOk &amp;&amp; sslInvalidServerCertHandling == EInvalidSslCertificateHandling.Prompt)
            {
                //certOk = Utility.ConsoleConfirm("Accept invalid server certificate? (Y/N)");
                certOk = true;
            }

            return certOk;
        }

        public static string GetCertificateInfo(X509Certificate certificate)
        {
            StringBuilder certInfo = new StringBuilder();

            //Note: certificate.ToString() returns just the class name in Mono 2.0

            // Simulate the .Net frameworks 2.0 ToString()
            certInfo.AppendLine("[Subject]");
            certInfo.AppendLine(certificate.Subject);
            certInfo.AppendLine("");
            certInfo.AppendLine("[Issuer]");
            certInfo.AppendLine(certificate.Issuer);
            certInfo.AppendLine("");
            certInfo.AppendLine("[Serial Number]");
            certInfo.AppendLine(certificate.GetSerialNumberString());
            certInfo.AppendLine("");
            certInfo.AppendLine("[Not Before]");
            certInfo.AppendLine(certificate.GetEffectiveDateString());
            certInfo.AppendLine("");
            certInfo.AppendLine("[Not After]");
            certInfo.AppendLine(certificate.GetExpirationDateString());
            certInfo.AppendLine("");
            certInfo.AppendLine("[Thumbprint]");
            certInfo.AppendLine(certificate.GetCertHashString());

            return certInfo.ToString();
        }

        public void Download(string strServerFile,string strLocalFile)
        {
            if (!File.Exists(strLocalFile))
            {
                if (client == null)
                {
                    initFTPS();
                }
                Info($"{strServerFile} is copying.");
                client.GetFile($"/{strServerPath}/{strServerFile}", strLocalFile);
            }
            else
            {
                Info($"{strServerFile} is already existed!");
            }
        }
}

</code></pre> 
<p>是不是相当简单呢?</p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7b14bf1f860f242a4ef6af4760ba9366/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">正则表达式校验YYYYMMDD日期格式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/119f63ebf2ef02661f05f657be3aefee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">英特尔与Lightbits Labs展开战略性合作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>