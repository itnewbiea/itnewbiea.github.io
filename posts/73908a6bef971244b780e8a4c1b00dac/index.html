<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>动态系统MATLAB分析的初步研究（一） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="动态系统MATLAB分析的初步研究（一）" />
<meta property="og:description" content="目录
用MATLAB进行部分分式展开
用MATLAB求B（s）/A（s）的零点和极点
求多项式的根
动态系统数学模型的变换
传递函数模型到状态空间模型的变换。
状态空间到传递函数的变换。
连续时间系统到离散时间系统的变换。
用MATLAB进行部分分式展开 现在讨论函数（一般形式）
已知传递函数：
对该函数，可以通过下列命令求得其部分分式展开
&gt;&gt; num=[2 5 3 6] num = 2 5 3 6 &gt;&gt; den=[1 6 11 6] den = 1 6 11 6 &gt;&gt; [r,p,k]=residue(num,den) r = -6.0000 -4.0000 3.0000 p = -3.0000 -2.0000 -1.0000 k = 2 可以看出，留数由向量r给出，极点位置由向量p给出，直接项则由向量k给出。上述结果的部分分式展开式为：
命令residue还能用来根据部分分式展开式构成(分子和分母)多项式。即上述过程的反过程。
假设我们知道函数的部分分式展开和（如上图所示），如何求出原先的传递函数？
r = [-6	-4	3]; p = [-3	-2	-1]; k = 2; &gt;&gt; [num,den] = residue(r,p,k) num = 2 5 3 6 den = 1 6 11 6 再借助printsys()函数直接构造成传递函数（采用s的多项式的比来显示num/den）；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/73908a6bef971244b780e8a4c1b00dac/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-03T15:49:23+08:00" />
<meta property="article:modified_time" content="2022-05-03T15:49:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">动态系统MATLAB分析的初步研究（一）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%94%A8MATLAB%E8%BF%9B%E8%A1%8C%E9%83%A8%E5%88%86%E5%88%86%E5%BC%8F%E5%B1%95%E5%BC%80-toc" style="margin-left:0px;"><a href="#%E7%94%A8MATLAB%E8%BF%9B%E8%A1%8C%E9%83%A8%E5%88%86%E5%88%86%E5%BC%8F%E5%B1%95%E5%BC%80" rel="nofollow">用MATLAB进行部分分式展开</a></p> 
<p id="%C2%A0%E7%94%A8MATLAB%E6%B1%82B%EF%BC%88s%EF%BC%89%2FA%EF%BC%88s%EF%BC%89%E7%9A%84%E9%9B%B6%E7%82%B9%E5%92%8C%E6%9E%81%E7%82%B9-toc" style="margin-left:0px;"><a href="#%C2%A0%E7%94%A8MATLAB%E6%B1%82B%EF%BC%88s%EF%BC%89%2FA%EF%BC%88s%EF%BC%89%E7%9A%84%E9%9B%B6%E7%82%B9%E5%92%8C%E6%9E%81%E7%82%B9" rel="nofollow"> 用MATLAB求B（s）/A（s）的零点和极点</a></p> 
<p id="%E6%B1%82%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E6%A0%B9-toc" style="margin-left:0px;"><a href="#%E6%B1%82%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E6%A0%B9" rel="nofollow">求多项式的根</a></p> 
<p id="%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%98%E6%8D%A2-toc" style="margin-left:0px;"><a href="#%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%98%E6%8D%A2" rel="nofollow">动态系统数学模型的变换</a></p> 
<p id="%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E6%A8%A1%E5%9E%8B%E5%88%B0%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%98%E6%8D%A2%E3%80%82-toc" style="margin-left:40px;"><a href="#%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E6%A8%A1%E5%9E%8B%E5%88%B0%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%98%E6%8D%A2%E3%80%82" rel="nofollow">传递函数模型到状态空间模型的变换。</a></p> 
<p id="%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E5%88%B0%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%98%E6%8D%A2%E3%80%82-toc" style="margin-left:40px;"><a href="#%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E5%88%B0%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%98%E6%8D%A2%E3%80%82" rel="nofollow">状态空间到传递函数的变换。</a></p> 
<p id="%C2%A0%E8%BF%9E%E7%BB%AD%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F%E5%88%B0%E7%A6%BB%E6%95%A3%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%98%E6%8D%A2%E3%80%82-toc" style="margin-left:40px;"><a href="#%C2%A0%E8%BF%9E%E7%BB%AD%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F%E5%88%B0%E7%A6%BB%E6%95%A3%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%98%E6%8D%A2%E3%80%82" rel="nofollow"> 连续时间系统到离散时间系统的变换。</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E7%94%A8MATLAB%E8%BF%9B%E8%A1%8C%E9%83%A8%E5%88%86%E5%88%86%E5%BC%8F%E5%B1%95%E5%BC%80">用MATLAB进行部分分式展开</h2> 
<p>现在讨论函数（一般形式）</p> 
<p><img alt="" height="352" src="https://images2.imgbox.com/9c/2f/vhfuz60H_o.png" width="798"></p> 
<p>已知传递函数：</p> 
<p> <img alt="" height="84" src="https://images2.imgbox.com/cc/ce/X9dYsi8y_o.png" width="203"></p> 
<p>对该函数，可以通过下列命令求得其部分分式展开</p> 
<pre><code>&gt;&gt; num=[2 5 3 6]

num =

     2     5     3     6

&gt;&gt; den=[1 6 11 6]

den =

     1     6    11     6

&gt;&gt; [r,p,k]=residue(num,den)

r =

   -6.0000
   -4.0000
    3.0000


p =

   -3.0000
   -2.0000
   -1.0000


k =

     2</code></pre> 
<p style="margin-left:0pt;text-align:left;"><span style="color:#000000;">可以看出，留数由向量</span><span style="color:#000000;">r</span><span style="color:#000000;">给出，极点位置由向量</span><span style="color:#000000;">p</span><span style="color:#000000;">给出，直接项则由向量</span><span style="color:#000000;">k</span><span style="color:#000000;">给出。上述结果</span><span style="color:#000000;">的部分分式展开式为：</span></p> 
<p style="margin-left:0pt;text-align:left;"><img alt="" height="151" src="https://images2.imgbox.com/34/18/39EpXuCy_o.png" width="700"></p> 
<p></p> 
<p> <span style="color:#000000;"><span style="color:#000000;">命令</span><span style="color:#000000;">residue</span><span style="color:#000000;">还能用来根据部分分式展开式构成(分子和分母)多项式。即上述过程的反过程。</span></span></p> 
<p><span style="color:#000000;"><span style="color:#000000;">假设我们知道函数的部分分式展开和（如上图所示），如何求出原先的传递函数？</span></span></p> 
<pre><code>r = [-6	-4	3];
p = [-3	-2	-1];
k = 2;
 
&gt;&gt; [num,den] = residue(r,p,k)

num =

     2     5     3     6


den =

     1     6    11     6
</code></pre> 
<p>再借助printsys()函数直接构造成传递函数（采用s的多项式的比来显示num/den）；</p> 
<pre><code>&gt;&gt; printsys(num,den,'s')
 
num/den = 
 
   2 s^3 + 5 s^2 + 3 s + 6
   -----------------------
    s^3 + 6 s^2 + 11 s + 6</code></pre> 
<p> 对于有重极点的情况：</p> 
<p><img alt="" height="136" src="https://images2.imgbox.com/94/5a/BjKzj9Dy_o.png" width="757"></p> 
<p> 处理方法相同：</p> 
<p><img alt="" height="201" src="https://images2.imgbox.com/3b/ba/4r8hsYWR_o.png" width="760"></p> 
<p> 代码如下：</p> 
<pre><code>&gt;&gt; num=[1 2 3]

num =

     1     2     3

&gt;&gt; den=[1 3 3 1]

den =

     1     3     3     1

&gt;&gt;  [r,p,k]=residue(num,den)

r =

    1.0000
    0.0000
    2.0000


p =

   -1.0000
   -1.0000
   -1.0000


k =

     []</code></pre> 
<p> 有重根时从前往后分别对应的是（s+1）、（s+1）^2、(s+1)^3……</p> 
<p> <img alt="" height="106" src="https://images2.imgbox.com/89/29/6utWtzZP_o.png" width="789"></p> 
<h2 id="%C2%A0%E7%94%A8MATLAB%E6%B1%82B%EF%BC%88s%EF%BC%89%2FA%EF%BC%88s%EF%BC%89%E7%9A%84%E9%9B%B6%E7%82%B9%E5%92%8C%E6%9E%81%E7%82%B9"> 用MATLAB求B（s）/A（s）的零点和极点</h2> 
<blockquote> 
 <p style="margin-left:0pt;text-align:left;"><span style="color:#000000;">MATLAB</span><span style="color:#000000;">命令</span></p> 
 <p style="margin-left:161pt;text-align:left;"><span style="color:#000000;">[z,p,K] = tf2zp(num,den)</span></p> 
 <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><strong><span style="color:#000000;"><strong>可以求得</strong></span></strong><em><span style="color:#000000;"><em>B(</em></span></em><em><span style="color:#000000;"><em>s</em></span></em><em><span style="color:#000000;"><em>)/A(s)</em></span></em><strong><span style="color:#000000;"><strong>的零点、极点和增益</strong></span></strong><span style="color:#000000;">K0</span></span></p> 
</blockquote> 
<p> 同样以这个例子为例：</p> 
<p><img alt="" height="84" src="https://images2.imgbox.com/0e/c6/KtVbIp2Z_o.png" width="203"></p> 
<pre><code>&gt;&gt; num=[2 5 3 6]

num =

     2     5     3     6

&gt;&gt; den=[1 6 11 6]

den =

     1     6    11     6

&gt;&gt; [z,p,K] = tf2zp(num,den)

z =

  -2.3965 + 0.0000i
  -0.0518 + 1.1177i
  -0.0518 - 1.1177i


p =

   -3.0000
   -2.0000
   -1.0000


K =

     2
</code></pre> 
<p>可以求得该模型有一对共轭零点和一个实数零点，有三个负实部的极点（实数），系统稳定。增益K=2。</p> 
<p>参考MATLAB帮助文档：</p> 
<blockquote> 
 <p>&gt;&gt; help  tf2zp<br>  tf2zp  Transfer function to zero-pole conversion.<br>     [Z,P,K] = tf2zp(NUM,DEN)  finds the zeros, poles, and gains:<br>  <br>                   (s-z1)(s-z2)...(s-zn)<br>         H(s) =  K ---------------------<br>                   (s-p1)(s-p2)...(s-pn)<br>  </p> 
</blockquote> 
<p>可见，求得的增益K为系统的根轨迹增益（即传递函数化为s的首一多项式） 。</p> 
<p>同时，可以用<code>zplane（z，p）</code>绘出<strong>零、极点分布图</strong></p> 
<pre><code>&gt;&gt; zplane(z,p)
</code></pre> 
<p>如图所示：</p> 
<p><img alt="" height="514" src="https://images2.imgbox.com/60/e6/28HXwg5Z_o.png" width="576"></p> 
<p>前文中提到，<span style="color:#000000;">[z,p,K] = tf2zp(num,den)中的2谐音‘to’，表示‘到’。以此类推，[num,den]=zp2tf(z,p,k)的功能是根据零极点、增益求出传递函数B（s）/A（s）。</span></p> 
<pre><code>&gt;&gt; z = [-1; -2; -3];
p= [-2+j*3;-2-j*3;-5];
K = 5;
[num,den] = zp2tf(z,p,K)

num =

     5    30    55    30


den =

     1     9    33    65</code></pre> 
<pre><code>&gt;&gt; printsys(num,den,'s1')
 
num/den = 
 
   5 s1^3 + 30 s1^2 + 55 s1 + 30
   -----------------------------
     s1^3 + 9 s1^2 + 33 s1 + 65</code></pre> 
<h2 id="%E6%B1%82%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E6%A0%B9" style="margin-left:0pt;text-align:left;">求多项式的根</h2> 
<p>如果只需求出零点或者极点，即只需求出多项式的根，可以采用r=roots(d)</p> 
<pre><code>&gt;&gt; d=[1 9 33 65]

d =

     1     9    33    65

&gt;&gt; r=roots(d)

r =

 -5.000000000000002 + 0.000000000000000i
 -1.999999999999999 + 3.000000000000000i
 -1.999999999999999 - 3.000000000000000i</code></pre> 
<p>上述命令即求s1^3 + 9 s1^2 + 33 s1 + 65=0的根。</p> 
<p>命令poly(r)可以生产原来的多项式</p> 
<pre><code>&gt;&gt; d=poly(r)

d =

   1.000000000000000   8.999999999999998  32.999999999999986  64.999999999999986</code></pre> 
<h2 id="%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%98%E6%8D%A2" style="margin-left:0pt;text-align:left;"><span style="color:#000000;">动态系统数学模型的变换</span></h2> 
<p style="margin-left:0pt;text-align:left;"><span style="color:#000000;">MATLAB</span><span style="color:#000000;">具有将线性时不变系统的一种数学模型变换为另一种模型的有用命令。 下面所列的变换是在求解控制工程问题时有用的线性系统变换：</span></p> 
<p style="margin-left:0pt;text-align:left;"><span style="color:#000000;">•</span><span style="color:#000000;">传递函数模型到状态空间模型的变换</span><span style="color:#000000;">(tf2ss)</span></p> 
<p style="margin-left:0pt;text-align:left;"><span style="color:#000000;">•</span><span style="color:#000000;">状态空间模型到传递函数横型的变换</span><span style="color:#000000;">(</span><span style="color:#000000;">ss2tf)</span></p> 
<p style="margin-left:0pt;text-align:justify;"><span style="color:#000000;">•</span><span style="color:#000000;">状态空间模型到零点-极点模型的变换</span><span style="color:#000000;">(ss2zp)</span></p> 
<p style="margin-left:0pt;text-align:justify;"><span style="color:#000000;">•</span><span style="color:#000000;">零点-极点模型到状态空间模型的变换</span><span style="color:#000000;">(zp2ss)</span></p> 
<p style="margin-left:0pt;text-align:justify;"><span style="color:#000000;">•</span><span style="color:#000000;">传递函数模型到零点-极点模型的变换</span><span style="color:#000000;">(</span><span style="color:#000000;">tf2zp)</span></p> 
<p style="margin-left:0pt;text-align:justify;"><span style="color:#000000;">•</span><span style="color:#000000;">零点-极点模型到传递函数模型的变换</span><span style="color:#000000;">(zp2tf)</span></p> 
<p style="margin-left:0pt;text-align:left;"><span style="color:#000000;">•</span><span style="color:#000000;">连续时间系统到离散时间系统的变换</span><span style="color:#000000;">(c2d)</span></p> 
<p style="margin-left:0pt;text-align:left;"><span style="color:#000000;">下文先讨论传递函数模型到状态空间模型的变换。</span></p> 
<blockquote> 
 <p style="margin-left:0pt;text-align:left;"></p> 
 <h3 id="%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E6%A8%A1%E5%9E%8B%E5%88%B0%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%98%E6%8D%A2%E3%80%82" style="margin-left:0pt;text-align:left;"><strong><span style="color:#000000;"><strong>传递函数模型到状态空间模型的变换。</strong></span></strong></h3> 
 <p style="margin-left:0pt;text-align:left;"><strong><span style="color:#000000;"><strong>命令</strong></span></strong></p> 
 <p style="margin-left:0pt;text-align:center;"><span style="color:#000000;">[A,B,C,D] </span><span style="color:#000000;">= </span><span style="color:#000000;">tf2ss(num,den)</span></p> 
 <p style="margin-left:0pt;text-align:left;"><span style="color:#000000;">将具有传递函数形式</span></p> 
 <p style="margin-left:0pt;text-align:center;"><img alt="\frac{Y(s)}{U(s)}=\frac{num}{den}=C(sI-A)^{-1}B+D" class="mathcode" src="https://images2.imgbox.com/96/55/UdnAhX2c_o.png"></p> 
 <p style="margin-left:0pt;text-align:left;"><span style="color:#000000;">的系统变换为状态空间形式</span></p> 
 <p style="margin-left:0pt;text-align:center;"><strong><span style="color:#000000;"><strong>x </strong></span></strong><strong><span style="color:#000000;"><strong>= </strong></span></strong><strong><span style="color:#000000;"><strong>Ax </strong></span></strong><strong><span style="color:#000000;"><strong>+ </strong></span></strong><strong><span style="color:#000000;"><strong>Bu</strong></span></strong></p> 
 <p style="margin-left:0pt;text-align:center;"><strong><span style="color:#000000;"><strong>y </strong></span></strong><strong><span style="color:#000000;"><strong>= </strong></span></strong><strong><span style="color:#000000;"><strong>Cx </strong></span></strong><strong><span style="color:#000000;"><strong>+ </strong></span></strong><em><span style="color:#000000;"><em>Du</em></span></em></p> 
</blockquote> 
<p><span style="color:#000000;">特别需要注意的是，任何系统的状态空间表达式都不是唯一的。同一个系统具有许多个（实际是无限多个）状态空间表达式。</span><span style="color:#000000;">MATLAB</span><span style="color:#000000;">命令只给出这些表达式中的一种可能形式。</span></p> 
<p><img alt="" height="440" src="https://images2.imgbox.com/15/75/a67Mh6IN_o.png" width="800"></p> 
<p> 即这个系统存在着无限多个可能的状态空间表达式。下面是相应的程序：（MATLAB系统只给出一种可能性）</p> 
<pre><code>&gt;&gt;  num = [10 10];
den = [1 6 5 10];
 [A,B,C,D] = tf2ss(num,den)

A =

    -6    -5   -10
     1     0     0
     0     1     0


B =

     1
     0
     0


C =

     0    10    10


D =

     0</code></pre> 
<blockquote> 
 <h3 id="%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E5%88%B0%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%98%E6%8D%A2%E3%80%82" style="margin-left:0pt;text-align:left;"><strong><span style="color:#000000;"><strong>状态空间到传递函数的变换。</strong></span></strong></h3> 
 <p style="margin-left:0pt;text-align:left;"><span style="color:#000000;">为了从状态空间方程获得传递函数，可以采用命令</span></p> 
 <p style="margin-left:0pt;text-align:center;"><span style="color:#000000;">[num,den] </span><span style="color:#000000;">= </span><span style="color:#000000;">ss2tf(A,B,C,D,iu)</span></p> 
</blockquote> 
<p> </p> 
<p style="margin-left:0pt;text-align:justify;"><span style="color:#000000;">对于输入量多于</span><span style="color:#000000;">1</span><span style="color:#000000;">个的系统必须指定</span><span style="color:#000000;">iu。</span><span style="color:#000000;">例如，如果该系统具有</span><span style="color:#000000;">3</span><span style="color:#000000;">个输入</span><span style="color:#000000;">(“u1, </span><span style="color:#000000;">u2,u3</span><span style="color:#000000;">)，那么 </span><span style="color:#000000;">iu</span><span style="color:#000000;">必须是</span><span style="color:#000000;">1,2</span><span style="color:#000000;">或</span><span style="color:#000000;">3,</span><span style="color:#000000;">其中</span><span style="color:#000000;">1</span><span style="color:#000000;">表示</span><span style="color:#000000;">u1, </span><span style="color:#000000;">2</span><span style="color:#000000;">表示</span><em><span style="color:#000000;"><em>u2</em></span></em><span style="color:#000000;">, 3</span><span style="color:#000000;">表示</span><em><span style="color:#000000;"><em>u3。</em></span></em></p> 
<p style="margin-left:0pt;text-align:left;"><span style="color:#000000;">如果该系统只有</span><span style="color:#000000;">1</span><span style="color:#000000;">个输入，那么既可以使用</span></p> 
<p style="margin-left:0pt;text-align:center;"><span style="color:#000000;">[num,den] </span><span style="color:#000000;">= </span><span style="color:#000000;">ss2tf(A,B,C,D)</span></p> 
<p style="margin-left:0pt;text-align:left;"><span style="color:#000000;">也可以使用</span></p> 
<p style="margin-left:0pt;text-align:center;"><span style="color:#000000;">[num,den] </span><span style="color:#000000;">= </span><span style="color:#000000;">ss2tf(A,B,C,D,1)</span></p> 
<p><img alt="" height="230" src="https://images2.imgbox.com/f0/33/vUSr48DZ_o.png" width="796"></p> 
<p>对于这个状态空间表达式，可以求得两个传递函数（因为有两个输入）。下面是相应的程序：</p> 
<pre><code>&gt;&gt; A =	[0	1;-2 -3];
   B =	[1 0;0 1];
   C =[1 0];
   D =[0 0];
&gt;&gt; [num,den]=ss2tf(A,B,C,D,1)

num =

     0     1     3


den =

     1     3     2

&gt;&gt; [num,den]=ss2tf(A,B,C,D,2)

num =

     0     0     1


den =

     1     3     2</code></pre> 
<p><img alt="" height="154" src="https://images2.imgbox.com/21/25/QCBIwHr5_o.png" width="796"></p> 
<blockquote> 
 <h3 id="%C2%A0%E8%BF%9E%E7%BB%AD%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F%E5%88%B0%E7%A6%BB%E6%95%A3%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%98%E6%8D%A2%E3%80%82"> <strong><span style="color:#000000;"><strong>连续时间系统到离散时间系统的变换。</strong></span></strong></h3> 
 <p style="margin-left:0pt;text-align:left;"><strong><span style="color:#000000;"><strong>命令</strong></span></strong></p> 
 <p style="margin-left:0pt;text-align:center;"><span style="color:#000000;">[G,H] </span><span style="color:#000000;">= </span><span style="color:#000000;">c2d(A,B,Ts)</span></p> 
 <p style="margin-left:0pt;text-align:left;"><span style="color:#000000;">可以将连续时间状态空间模型变换为离散时间状态空间模型，其中</span><span style="color:#000000;">Ts</span><span style="color:#000000;">是以秒为单位表示的采 样周期。这里假设输入端有个零阶保持器。也就是说，采用上述命令，能将</span></p> 
 <p style="margin-left:0pt;text-align:center;"><img alt="\dot{x} = Ax + Bu" class="mathcode" src="https://images2.imgbox.com/34/4a/mvRIudoC_o.png"></p> 
 <p style="margin-left:0pt;">变换为</p> 
 <p style="margin-left:0pt;text-align:center;"><img alt="x(k+1)=Gx(k)+Hu(k)" class="mathcode" src="https://images2.imgbox.com/2c/38/veCBXVMy_o.png"></p> 
</blockquote> 
<p> <img alt="" height="146" src="https://images2.imgbox.com/8c/c5/XPdlTeUL_o.png" width="758"></p> 
<p> 下面是相应的程序：</p> 
<pre><code>&gt;&gt; A= [0 1;-25 -4];
&gt;&gt; B=[0;1];
&gt;&gt; [G,H]=c2d(A,B,0.05)

G =

    0.9709    0.0448
   -1.1212    0.7915


H =

    0.0012
    0.0448</code></pre> 
<p style="margin-left:0pt;"><span style="color:#000000;"><span style="color:#000000;">值得注意的是，如果采用</span><span style="color:#000000;">format long,</span><span style="color:#000000;">则可以得到更加精确的</span><span style="color:#000000;">H</span><span style="color:#000000;">矩阵。</span></span></p> 
<pre><code>&gt;&gt; A= [0 1;-25 -4];
&gt;&gt; B=[0;1];
&gt;&gt; format long
&gt;&gt; [G,H]=c2d(A,B,0.05)

G =

   0.970883253819295   0.044847042382640
  -1.121176059565992   0.791495084288736


H =

   0.001164669847228
   0.044847042382640</code></pre> 
<p>我们发现，这两次求得的矩阵G和H是不同的，第二次求得的结果更加准确。所以，再将连续时间系统变换为离散时间系统时，建议使用format long。</p> 
<p>我是小韩每天进步一点点，一名研0的研究生，刚开始写博客。希望和大家多多交流，一起进步！</p> 
<p>求朋友点赞、收藏、关注哈，鼓励一下新人博主，或者提出建议。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7778f11109c70192d4374e8d04b39e61/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IDEA 中 ANTLR 4 的安装与使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d030259213f24c9b407e239b1c9ac4a2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mybatis快速入门</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>