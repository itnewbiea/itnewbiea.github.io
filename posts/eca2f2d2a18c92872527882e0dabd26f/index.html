<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32之SPI读写FLASH(W25Q64) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32之SPI读写FLASH(W25Q64)" />
<meta property="og:description" content="/* 名称:STM32之SPI读写FLASH(W25Q64) 说明: 1.对于SPI读写FLASH和I2C读写EEPROM很相似，都是通过一定的通信协议来操纵外部存储设备。我们需要按照对应的通信协议发送存储设备所支持的指令（如读指令、写指令等），然后等待存储设备根据主机所接收到的指令进行相应的动作。
2.再来说说不同点吧：对于通信协议来说，I2C相对来说要简单些，通信速度也稍微较慢些。而SPI串行通信协议则要相对复杂的多，当然其通信速度也要高不少。对于存储设备来说，EEPROM属于小容量的存储设备，支持字节擦除、页写入，现在一般用于存储小容量的数据；而FLASH属于大容量的存储设备，不支持字节擦除，只支持扇区擦除、块擦除和整片擦除，要注意的是在对FLASH进行写入的时候一般都需要先进行擦除，否则可能会导致数据出错。
3.这里介绍一个连续多字节写入函数。无论是对于EEPROM和FLASH来说，其都有“写入回滚”的现象（就是达到页边界的话，会重新从一页的开始出重新进行写入）。所以，这样的话连续多字节写入就要考虑是否达到页边界的问题。对于页写入函数一般的思路：是按照所给的地址是否正好是页首处、要写入的字节数是否大于一页等等进行讨论。在本驱动程序中写了一个函数，不用考虑是否达到边界的问题，写入字节数也没有限制（当然要小于FLASH容量）。其基本的思路是：采用页偏移的概念，即到达下一个页边界还需要多少字节，每次写入的字节数就是这个页偏移和待写入剩余字节的最小值。具体的代码见： SPI_Write_Datas(uint32_t addr,uint8_t *writeBuff,uint32_t numByteToWrite)；
注:本驱动程序大部分来自STM32指南者配套代码 */
驱动程序源文件：
#include &#34;./flash/bsp_spi_flash.h&#34; #include &#34;./usart/bsp_usart.h&#34; static __IO uint32_t SPITimeout = SPIT_LONG_TIMEOUT; static uint32_t SPI_TIMEOUT_UserCallback(uint8_t errorCode); /** * @brief SPII/O配置 * @param 无 * @retval 无 */ static void SPI_GPIO_Config(void) { GPIO_InitTypeDef GPIO_InitStructure; /* 使能与SPI 有关的时钟 */ FLASH_SPI_APBxClock_FUN ( FLASH_SPI_CLK, ENABLE ); FLASH_SPI_GPIO_APBxClock_FUN ( FLASH_SPI_GPIO_CLK, ENABLE ); /* MISO MOSI SCK*/ GPIO_InitStructure.GPIO_Pin = FLASH_SPI_SCK_PIN; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(FLASH_SPI_SCK_PORT, &amp;GPIO_InitStructure); GPIO_InitStructure." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/eca2f2d2a18c92872527882e0dabd26f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-04-04T13:40:56+08:00" />
<meta property="article:modified_time" content="2018-04-04T13:40:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32之SPI读写FLASH(W25Q64)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>/* <br> 名称:STM32之SPI读写FLASH(W25Q64) <br> 说明: <br> 1.对于SPI读写FLASH和I2C读写EEPROM很相似，都是通过一定的通信协议来操纵外部存储设备。我们需要按照对应的通信协议发送存储设备所支持的指令（如读指令、写指令等），然后等待存储设备根据主机所接收到的指令进行相应的动作。</p> 
<p>2.再来说说不同点吧：对于通信协议来说，I2C相对来说要简单些，通信速度也稍微较慢些。而SPI串行通信协议则要相对复杂的多，当然其通信速度也要高不少。对于存储设备来说，EEPROM属于小容量的存储设备，支持字节擦除、页写入，现在一般用于存储小容量的数据；而FLASH属于大容量的存储设备，不支持字节擦除，只支持扇区擦除、块擦除和整片擦除，要注意的是在对FLASH进行写入的时候一般都需要先进行擦除，否则可能会导致数据出错。</p> 
<p>3.这里介绍一个连续多字节写入函数。无论是对于EEPROM和FLASH来说，其都有“写入回滚”的现象（就是达到页边界的话，会重新从一页的开始出重新进行写入）。所以，这样的话连续多字节写入就要考虑是否达到页边界的问题。对于页写入函数一般的思路：是按照所给的地址是否正好是页首处、要写入的字节数是否大于一页等等进行讨论。在本驱动程序中写了一个函数，不用考虑是否达到边界的问题，写入字节数也没有限制（当然要小于FLASH容量）。其基本的思路是：采用页偏移的概念，即到达下一个页边界还需要多少字节，每次写入的字节数就是这个页偏移和待写入剩余字节的最小值。具体的代码见： <br> SPI_Write_Datas(uint32_t addr,uint8_t *writeBuff,uint32_t numByteToWrite)；</p> 
<pre><code>注:本驱动程序大部分来自STM32指南者配套代码
</code></pre> 
<p>*/</p> 
<p>驱动程序源文件：</p> 
<pre class="prettyprint"><code class=" hljs java">#include <span class="hljs-string">"./flash/bsp_spi_flash.h"</span>
#include <span class="hljs-string">"./usart/bsp_usart.h"</span>      

<span class="hljs-keyword">static</span> __IO uint32_t  SPITimeout = SPIT_LONG_TIMEOUT;     


<span class="hljs-keyword">static</span> uint32_t SPI_TIMEOUT_UserCallback(uint8_t errorCode);


<span class="hljs-javadoc">/**
  *<span class="hljs-javadoctag"> @brief</span>  SPII/O配置
  *<span class="hljs-javadoctag"> @param</span>  无
  *<span class="hljs-javadoctag"> @retval</span> 无
  */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> SPI_GPIO_Config(<span class="hljs-keyword">void</span>)
{
  GPIO_InitTypeDef  GPIO_InitStructure; 

    <span class="hljs-comment">/* 使能与SPI 有关的时钟 */</span>
    FLASH_SPI_APBxClock_FUN ( FLASH_SPI_CLK, ENABLE );
    FLASH_SPI_GPIO_APBxClock_FUN ( FLASH_SPI_GPIO_CLK, ENABLE );


  <span class="hljs-comment">/* MISO MOSI SCK*/</span>
  GPIO_InitStructure.GPIO_Pin = FLASH_SPI_SCK_PIN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;          
  GPIO_Init(FLASH_SPI_SCK_PORT, &amp;GPIO_InitStructure);

    GPIO_InitStructure.GPIO_Pin = FLASH_SPI_MOSI_PIN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;          
  GPIO_Init(FLASH_SPI_MOSI_PORT, &amp;GPIO_InitStructure);

    GPIO_InitStructure.GPIO_Pin = FLASH_SPI_MISO_PIN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;        
  GPIO_Init(FLASH_SPI_MISO_PORT, &amp;GPIO_InitStructure);

    <span class="hljs-comment">//初始化CS引脚，使用软件控制，所以直接设置成推挽输出    </span>
    GPIO_InitStructure.GPIO_Pin = FLASH_SPI_CS_PIN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;         
  GPIO_Init(FLASH_SPI_CS_PORT, &amp;GPIO_InitStructure);

    FLASH_SPI_CS_HIGH;
}


<span class="hljs-javadoc">/**
  *<span class="hljs-javadoctag"> @brief</span>  SPI 工作模式配置
  *<span class="hljs-javadoctag"> @param</span>  无
  *<span class="hljs-javadoctag"> @retval</span> 无
  */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> SPI_Mode_Config(<span class="hljs-keyword">void</span>)
{
  SPI_InitTypeDef  SPI_InitStructure; 

    SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2 ;
    <span class="hljs-comment">//SPI 使用模式3</span>
    SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge ;
    SPI_InitStructure.SPI_CPOL = SPI_CPOL_High ;
    SPI_InitStructure.SPI_CRCPolynomial = <span class="hljs-number">0</span>;<span class="hljs-comment">//不使用CRC功能，数值随便写</span>
    SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
    SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex ;<span class="hljs-comment">//双线全双工</span>
    SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB  ;
    SPI_InitStructure.SPI_Mode = SPI_Mode_Master  ;
    SPI_InitStructure.SPI_NSS = SPI_NSS_Soft  ; 

    SPI_Init(FLASH_SPIx,&amp;SPI_InitStructure);    <span class="hljs-comment">//写入配置到寄存器</span>

    SPI_Cmd(FLASH_SPIx,ENABLE);<span class="hljs-comment">//使能SPI</span>

}


<span class="hljs-javadoc">/**
  *<span class="hljs-javadoctag"> @brief</span>  SPI 初始化
  *<span class="hljs-javadoctag"> @param</span>  无
  *<span class="hljs-javadoctag"> @retval</span> 无
  */</span>
<span class="hljs-keyword">void</span> SPI_FLASH_Init(<span class="hljs-keyword">void</span>)
{

    SPI_GPIO_Config();
    SPI_Mode_Config();

}

<span class="hljs-comment">//发送并接收一个字节</span>
uint8_t SPI_FLASH_Send_Byte(uint8_t data)
{
    SPITimeout = SPIT_FLAG_TIMEOUT;
    <span class="hljs-comment">//检查并等待至TX缓冲区为空</span>
    <span class="hljs-keyword">while</span>(SPI_I2S_GetFlagStatus(FLASH_SPIx,SPI_I2S_FLAG_TXE) == RESET)
    {
        <span class="hljs-keyword">if</span>((SPITimeout--) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> SPI_TIMEOUT_UserCallback(<span class="hljs-number">0</span>);
    }

    <span class="hljs-comment">//程序执行到此处，TX缓冲区已空</span>
    SPI_I2S_SendData (FLASH_SPIx,data);


    SPITimeout = SPIT_FLAG_TIMEOUT;
    <span class="hljs-comment">//检查并等待至RX缓冲区为非空</span>
    <span class="hljs-keyword">while</span>(SPI_I2S_GetFlagStatus(FLASH_SPIx,SPI_I2S_FLAG_RXNE) == RESET)
    {
        <span class="hljs-keyword">if</span>((SPITimeout--) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> SPI_TIMEOUT_UserCallback(<span class="hljs-number">0</span>);
    }

    <span class="hljs-comment">//程序执行到此处，说明数据发送完毕，并接收到一字字节 </span>
    <span class="hljs-keyword">return</span> SPI_I2S_ReceiveData(FLASH_SPIx); 

}

uint8_t SPI_FLASH_Read_Byte(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-keyword">return</span> SPI_FLASH_Send_Byte(DUMMY); 
}



<span class="hljs-comment">//读取ID号</span>
uint32_t SPI_Read_ID(<span class="hljs-keyword">void</span>)
{
    uint32_t flash_id;

    <span class="hljs-comment">//片选使能</span>
    FLASH_SPI_CS_LOW;
    SPI_FLASH_Send_Byte(READ_JEDEC_ID);

    flash_id = SPI_FLASH_Send_Byte(DUMMY);

    flash_id &lt;&lt;= <span class="hljs-number">8</span>;

    flash_id |= SPI_FLASH_Send_Byte(DUMMY); 

    flash_id &lt;&lt;= <span class="hljs-number">8</span>;

    flash_id |= SPI_FLASH_Send_Byte(DUMMY); 

    FLASH_SPI_CS_HIGH;  

    <span class="hljs-keyword">return</span> flash_id;
}

<span class="hljs-comment">//FLASH写入使能</span>
<span class="hljs-keyword">void</span> SPI_Write_Enable(<span class="hljs-keyword">void</span>)
{
        <span class="hljs-comment">//片选使能</span>
    FLASH_SPI_CS_LOW;
    SPI_FLASH_Send_Byte(WRITE_ENABLE);   
    FLASH_SPI_CS_HIGH;  
}



<span class="hljs-comment">//擦除FLASH指定扇区</span>
<span class="hljs-keyword">void</span> SPI_Erase_Sector(uint32_t addr)
{   
    SPI_Write_Enable();
        <span class="hljs-comment">//片选使能</span>
    FLASH_SPI_CS_LOW;
    SPI_FLASH_Send_Byte(ERASE_SECTOR);

    SPI_FLASH_Send_Byte((addr&gt;&gt;<span class="hljs-number">16</span>)&amp;<span class="hljs-number">0xff</span>);

    SPI_FLASH_Send_Byte((addr&gt;&gt;<span class="hljs-number">8</span>)&amp;<span class="hljs-number">0xff</span>); 

  SPI_FLASH_Send_Byte(addr&amp;<span class="hljs-number">0xff</span>); 

    FLASH_SPI_CS_HIGH;  

    SPI_WaitForWriteEnd();

}


<span class="hljs-comment">//读取FLASH的内容</span>
<span class="hljs-keyword">void</span> SPI_Read_Data(uint32_t addr,uint8_t *readBuff,uint32_t numByteToRead)
{
        <span class="hljs-comment">//片选使能</span>
    FLASH_SPI_CS_LOW;
    SPI_FLASH_Send_Byte(READ_DATA);

    SPI_FLASH_Send_Byte((addr&gt;&gt;<span class="hljs-number">16</span>)&amp;<span class="hljs-number">0xff</span>);

    SPI_FLASH_Send_Byte((addr&gt;&gt;<span class="hljs-number">8</span>)&amp;<span class="hljs-number">0xff</span>); 

  SPI_FLASH_Send_Byte(addr&amp;<span class="hljs-number">0xff</span>); 

    <span class="hljs-keyword">while</span>(numByteToRead--)
    {   
        *readBuff = SPI_FLASH_Send_Byte(DUMMY);
        readBuff++;
    }


    FLASH_SPI_CS_HIGH;  

}





<span class="hljs-comment">//向FLASH写入内容</span>
<span class="hljs-keyword">void</span> SPI_Write_Data(uint32_t addr,uint8_t *writeBuff,uint32_t numByteToWrite)
{
    SPI_Write_Enable();
        <span class="hljs-comment">//片选使能</span>
    FLASH_SPI_CS_LOW;
    SPI_FLASH_Send_Byte(WRITE_DATA);

    SPI_FLASH_Send_Byte((addr&gt;&gt;<span class="hljs-number">16</span>)&amp;<span class="hljs-number">0xff</span>);

    SPI_FLASH_Send_Byte((addr&gt;&gt;<span class="hljs-number">8</span>)&amp;<span class="hljs-number">0xff</span>); 

  SPI_FLASH_Send_Byte(addr&amp;<span class="hljs-number">0xff</span>); 

    <span class="hljs-keyword">while</span>(numByteToWrite--)
    {   
        SPI_FLASH_Send_Byte(*writeBuff);
        writeBuff++;
    }


    FLASH_SPI_CS_HIGH;  
    SPI_WaitForWriteEnd();
}


<span class="hljs-comment">//连续写入多字节：不用考虑是否达到边界的问题，写入字节数也没有限制（当然要小于FLASH容量）</span>
<span class="hljs-keyword">void</span> SPI_Write_Datas(uint32_t addr,uint8_t *writeBuff,uint32_t numByteToWrite)
{

    uint32_t page_offset = <span class="hljs-number">0</span>;           <span class="hljs-comment">//距离下一个页地址边界的偏移（距离）</span>
    uint32_t write_len = <span class="hljs-number">0</span>;             <span class="hljs-comment">//每次要写入的字节数量    </span>

    <span class="hljs-keyword">int</span> page_size = <span class="hljs-number">256</span>;                <span class="hljs-comment">//页大小</span>

    SPI_Write_Enable();
        <span class="hljs-comment">//片选使能</span>
    FLASH_SPI_CS_LOW;

    <span class="hljs-keyword">while</span>(numByteToWrite &gt; <span class="hljs-number">0</span>)
    {
        page_offset = page_size - (numByteToWrite % page_size);         <span class="hljs-comment">//计算页偏移</span>

        write_len = numByteToWrite&gt;page_offset ? page_offset : numByteToWrite;          <span class="hljs-comment">//选择较小的作为本次写入的数据字节长度</span>

        SPI_Write_Data( addr,writeBuff,write_len);

        <span class="hljs-comment">//if(numByteToWrite)</span>

        <span class="hljs-comment">//改变相应参数</span>
        numByteToWrite = numByteToWrite - write_len;            <span class="hljs-comment">//减少写入数量</span>
        writeBuff = writeBuff + write_len;              <span class="hljs-comment">//增加写入缓冲地址</span>
        addr = addr+write_len;                              <span class="hljs-comment">//增加FLASH写入的地址</span>


    }

    FLASH_SPI_CS_HIGH;
}



<span class="hljs-comment">//等待FLASH内部时序操作完成</span>
<span class="hljs-keyword">void</span> SPI_WaitForWriteEnd(<span class="hljs-keyword">void</span>)
{
    uint8_t status_reg = <span class="hljs-number">0</span>;

    <span class="hljs-comment">//片选使能</span>
    FLASH_SPI_CS_LOW;

    SPI_FLASH_Send_Byte(READ_STATUS);

    do
    {   
    status_reg = SPI_FLASH_Send_Byte(DUMMY);
    }
    <span class="hljs-keyword">while</span>((status_reg &amp; <span class="hljs-number">0x01</span>) == <span class="hljs-number">1</span>);

    FLASH_SPI_CS_HIGH;  


}



<span class="hljs-javadoc">/**
  *<span class="hljs-javadoctag"> @brief</span>  Basic management of the timeout situation.
  *<span class="hljs-javadoctag"> @param</span>  errorCode：错误代码，可以用来定位是哪个环节出错.
  *<span class="hljs-javadoctag"> @retval</span> 返回0，表示SPI读取失败.
  */</span>
<span class="hljs-keyword">static</span>  uint32_t SPI_TIMEOUT_UserCallback(uint8_t errorCode)
{
  <span class="hljs-comment">/* Block communication and all processes */</span>
  FLASH_ERROR(<span class="hljs-string">"SPI 等待超时!errorCode = %d"</span>,errorCode);

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p>头文件:</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#ifndef __SPI_FLASH_H</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> __SPI_FLASH_H</span>


<span class="hljs-preprocessor">#include "stm32f10x.h"</span>

<span class="hljs-comment">//如果使用霸道开发板，把该宏配置成1 ，指南者配置成0</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> USE_BD          0</span>

<span class="hljs-comment">/**************************SPI参数定义********************************/</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span>             FLASH_SPIx                                SPI1</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span>             FLASH_SPI_APBxClock_FUN                  RCC_APB2PeriphClockCmd</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span>             FLASH_SPI_CLK                             RCC_APB2Periph_SPI1</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span>             FLASH_SPI_GPIO_APBxClock_FUN            RCC_APB2PeriphClockCmd</span>



<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span>             FLASH_SPI_SCK_PORT                        GPIOA   </span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span>             FLASH_SPI_SCK_PIN                         GPIO_Pin_5</span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span>             FLASH_SPI_MOSI_PORT                        GPIOA </span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span>             FLASH_SPI_MOSI_PIN                         GPIO_Pin_7</span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span>             FLASH_SPI_MISO_PORT                        GPIOA </span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span>             FLASH_SPI_MISO_PIN                         GPIO_Pin_6</span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">if</span> (USE_BD ==1)</span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span>             FLASH_SPI_GPIO_CLK                        RCC_APB2Periph_GPIOA</span>

    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span>             FLASH_SPI_CS_PORT                        GPIOA </span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span>             FLASH_SPI_CS_PIN                         GPIO_Pin_4</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">else</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span>             FLASH_SPI_GPIO_CLK                        (RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOC)</span>

    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span>             FLASH_SPI_CS_PORT                        GPIOC</span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span>             FLASH_SPI_CS_PIN                         GPIO_Pin_0</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>


<span class="hljs-comment">//CS引脚配置</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> FLASH_SPI_CS_HIGH       GPIO_SetBits(FLASH_SPI_CS_PORT,FLASH_SPI_CS_PIN);</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> FLASH_SPI_CS_LOW          GPIO_ResetBits(FLASH_SPI_CS_PORT,FLASH_SPI_CS_PIN);</span>


<span class="hljs-comment">/*等待超时时间*/</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> SPIT_FLAG_TIMEOUT         ((uint32_t)0x1000)</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> SPIT_LONG_TIMEOUT         ((uint32_t)(10 * SPIT_FLAG_TIMEOUT))</span>


<span class="hljs-comment">/*信息输出*/</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> FLASH_DEBUG_ON         0</span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> FLASH_INFO(fmt,arg...)           printf("&lt;&lt;-FLASH-INFO-&gt;&gt; "fmt"\n",##arg)</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> FLASH_ERROR(fmt,arg...)          printf("&lt;&lt;-FLASH-ERROR-&gt;&gt; "fmt"\n",##arg)</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> FLASH_DEBUG(fmt,arg...)          do{\</span>
                                          <span class="hljs-keyword">if</span>(FLASH_DEBUG_ON)\
                                          printf(<span class="hljs-string">"&lt;&lt;-FLASH-DEBUG-&gt;&gt; [%d]"</span>fmt<span class="hljs-string">"\n"</span>,__LINE__, <span class="hljs-preprocessor">##arg);\</span>
                                          }<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>)

<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> DUMMY                           0x00    </span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> READ_JEDEC_ID     0x9f                                                                                  </span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> ERASE_SECTOR            0x20                                                                            </span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> READ_STATUS             0x05</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> READ_DATA                   0x03        </span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> WRITE_ENABLE      0x06                                                                                  </span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> WRITE_DATA              0x02                                                                                    </span>


<span class="hljs-keyword">void</span> SPI_FLASH_Init(<span class="hljs-keyword">void</span>);
uint32_t SPI_Read_ID(<span class="hljs-keyword">void</span>);
<span class="hljs-keyword">void</span> SPI_Erase_Sector(uint32_t addr);
<span class="hljs-keyword">void</span> SPI_Read_Data(uint32_t addr,uint8_t *readBuff,uint32_t numByteToRead);
<span class="hljs-keyword">void</span> SPI_Write_Data(uint32_t addr,uint8_t *writeBuff,uint32_t numByteToWrite);

<span class="hljs-keyword">void</span> SPI_WaitForWriteEnd(<span class="hljs-keyword">void</span>);


<span class="hljs-comment">//连续写入多字节</span>
<span class="hljs-keyword">void</span> SPI_Write_Datas(uint32_t addr,uint8_t *writeBuff,uint32_t numByteToWrite);

<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span> /* __SPI_FLASH_H */</span>
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/caf3856e1d1828c23018d3ddb6a6dadb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SimpleHostRoutingFilter</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/218a5039cdb5aec7bb4f5baade763126/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">机器学习 基础知识</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>