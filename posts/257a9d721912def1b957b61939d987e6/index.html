<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】顺序表(SeqList)（增、删、查、改）详解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数据结构】顺序表(SeqList)（增、删、查、改）详解" />
<meta property="og:description" content="一、顺序表的概念和结构 1、顺序表的概念： 顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储。在数组上完成数据的增删查改。
2、顺序表的结构： （1）静态顺序表：使用定长数组存储元素 缺点：只适用于确定知道需要存多少数据的场景。静态顺序表的定长数组导致 N 定大了，空间开多了浪费，开少了不够用。
// 顺序表的静态存储 #define N 10 typedef int SLDataType; typedef struct SeqList { SLDataType array[N];// 定长数组 size_t size;// 有效数据个数 }SeqList; （2）动态顺序表：使用动态开辟的数组存储元素 优点：动态顺序表可以根据需要动态的分配空间大小。
// 顺序表的动态存储 typedef int SLDataType; //类型重命名，后续要存储其它类型时方便更改 typedef struct SeqList { SLDataType* a;// 指向动态开辟的数组 size_t size;// 有效数据个数（当前顺序表中已存放的数据个数） size_t capacity;// 容量大小（顺序表总共能够存放的数据个数） }SeqList; 注：size_t 数据类型表示 C 中任何对象所能达到的最大长度，它是无符号整数。 二、动态顺序表的接口实现 1、创建文件 test.c（主函数、测试顺序表各个接口功能）SeqList.c（动态顺序表接口函数的实现）SeqList.h（动态顺序表的类型定义、接口函数声明、引用的头文件） 2、SeqList.h 头文件代码 // SeqList.h #pragma once // 防止头文件被二次引用 #include&lt;stdio.h&gt; #include&lt;assert.h&gt; // assert #include&lt;stdlib.h&gt; // realloc typedef int SLDataType; // 后续要存储其它类型时方便直接更改 // 顺序表的动态存储 typedef struct SeqList { SLDataType* a; // 指向动态开辟的数组 size_t size ; // 有效数据个数 size_t capicity ; // 容量空间的大小 }SeqList; // 基本增删查改接口 // 顺序表初始化 void SeqListInit(SeqList* psl); // 顺序表销毁 void SeqListDestory(SeqList* psl); // 检查空间，如果满了，进行增容 void CheckCapacity(SeqList* psl); // 顺序表尾插 void SeqListPushBack(SeqList* psl, SLDataType x); // 顺序表尾删 void SeqListPopBack(SeqList* psl); // 顺序表头插 void SeqListPushFront(SeqList* psl, SLDataType x); // 顺序表头删 void SeqListPopFront(SeqList* psl); // 顺序表打印 void SeqListPrint(SeqList* psl); // 顺序表查找 int SeqListFind(SeqList* psl, SLDataType x); // 顺序表在pos位置插入x void SeqListInsert(SeqList* psl, size_t pos, SLDataType x); // 顺序表删除pos位置的值 void SeqListErase(SeqList* psl, size_t pos); // 查看顺序表中的有效数据个数 size_t SeqListSize(const SeqList* psl); // 修改指定下标位置的数据 void SeqListAt(SeqList* psl, size_t pos, SLDataType x); 三、在 SeqList." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/257a9d721912def1b957b61939d987e6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-14T07:32:02+08:00" />
<meta property="article:modified_time" content="2023-10-14T07:32:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】顺序表(SeqList)（增、删、查、改）详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、顺序表的概念和结构</h2> 
<blockquote> 
 <h4><span style="color:#0d0016;"><strong>1、顺序表的概念：</strong></span></h4> 
 <p><span style="color:#fe2c24;"><strong>顺序表</strong></span>是用一段物理地址<span style="color:#fe2c24;"><strong>连续</strong></span>的存储单元依次存储数据元素的<span style="color:#fe2c24;"><strong>线性结构</strong></span>，<strong>一般情况下采用<span style="color:#fe2c24;">数组</span>存储</strong>。在数组上完成数据的<strong>增删查改</strong>。</p> 
</blockquote> 
<hr> 
<h4> 2、顺序表的结构：</h4> 
<h6>（1）静态顺序表：使用定长数组存储元素</h6> 
<p>缺点：只适用于确定知道需要存多少数据的场景。静态顺序表的定长数组导致 N 定大了，空间开多了浪费，开少了不够用。</p> 
<pre><code class="language-cpp">// 顺序表的静态存储
#define N 10
typedef int SLDataType;

typedef struct SeqList
{
	SLDataType array[N];// 定长数组
	size_t size;// 有效数据个数
}SeqList;
</code></pre> 
<hr> 
<h6> （2）动态顺序表：使用动态开辟的数组存储元素</h6> 
<p>优点：动态顺序表可以根据需要动态的分配空间大小。</p> 
<pre><code class="language-cpp">// 顺序表的动态存储
typedef int SLDataType; //类型重命名，后续要存储其它类型时方便更改

typedef struct SeqList
{
	SLDataType* a;// 指向动态开辟的数组
	size_t size;// 有效数据个数（当前顺序表中已存放的数据个数）
	size_t capacity;// 容量大小（顺序表总共能够存放的数据个数）
}SeqList;
</code></pre> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">注</span></strong>：size_t 数据类型表示 C 中任何对象所能达到的最大长度，它是无符号整数。 </p> 
</blockquote> 
<hr> 
<h2> 二、动态顺序表的接口实现</h2> 
<h4>1、创建文件</h4> 
<blockquote> 
 <ol><li><strong>test.c</strong>（主函数、测试顺序表各个接口功能）</li><li><strong>SeqList.c</strong>（动态顺序表接口函数的实现）</li><li><strong>SeqList.h</strong>（动态顺序表的类型定义、接口函数声明、引用的头文件）</li></ol> 
</blockquote> 
<p><img alt="" height="295" src="https://images2.imgbox.com/c5/d6/AUjvt0J8_o.png" width="349">  </p> 
<hr> 
<h4> 2、SeqList.h 头文件代码</h4> 
<pre><code class="language-cpp">// SeqList.h
#pragma once // 防止头文件被二次引用

#include&lt;stdio.h&gt;
#include&lt;assert.h&gt; // assert
#include&lt;stdlib.h&gt; // realloc

typedef int SLDataType; // 后续要存储其它类型时方便直接更改

// 顺序表的动态存储
typedef struct SeqList
{
    SLDataType* a; // 指向动态开辟的数组
    size_t size ; // 有效数据个数
    size_t capicity ; // 容量空间的大小
}SeqList;

// 基本增删查改接口
// 顺序表初始化
void SeqListInit(SeqList* psl);
// 顺序表销毁
void SeqListDestory(SeqList* psl);
// 检查空间，如果满了，进行增容
void CheckCapacity(SeqList* psl);
// 顺序表尾插
void SeqListPushBack(SeqList* psl, SLDataType x);
// 顺序表尾删
void SeqListPopBack(SeqList* psl);
// 顺序表头插
void SeqListPushFront(SeqList* psl, SLDataType x);
// 顺序表头删
void SeqListPopFront(SeqList* psl);
// 顺序表打印
void SeqListPrint(SeqList* psl);
// 顺序表查找
int SeqListFind(SeqList* psl, SLDataType x); 
// 顺序表在pos位置插入x
void SeqListInsert(SeqList* psl, size_t pos, SLDataType x);
// 顺序表删除pos位置的值
void SeqListErase(SeqList* psl, size_t pos);
// 查看顺序表中的有效数据个数 
size_t SeqListSize(const SeqList* psl);
// 修改指定下标位置的数据
void SeqListAt(SeqList* psl, size_t pos, SLDataType x);</code></pre> 
<hr> 
<h2> 三、在 SeqList.c 中实现各个接口函数</h2> 
<h4>1、初始化顺序表</h4> 
<pre><code class="language-cpp">// 初始化顺序表
void SeqListInit(SeqList* psl)
{
	assert(psl); // 断言 -- 防止传进来的指针为空

	psl-&gt;a = NULL; // 初始化顺序表为空
    psl-&gt;size = 0; // 初始数据个数为0
	psl-&gt;capacity = 0; // 初始空间容量为0
}</code></pre> 
<hr> 
<h4>2、顺序表销毁</h4> 
<pre><code class="language-cpp">// 销毁顺序表
void SeqListDestroy(SeqList* psl)
{
	assert(psl); // 断言 -- 防止传进来的指针为空

	free(psl-&gt;a); // 释放动态开辟的空间
    psl-&gt;a = NULL; // 置空
	psl-&gt;size = 0; // 数据个数置为0
	psl-&gt;capacity = 0; // 空间容量大小置为0
}</code></pre> 
<hr> 
<h4>3、检查空间，如果满了，进行增容 </h4> 
<pre><code class="language-cpp">// 检查顺序表容量是否满了，好进行增容
void CheckCapity(SeqList* psl)
{
	if (psl-&gt;size == psl-&gt;capacity) // 检查容量，满了则增容
	{
        // 原来容量为0，扩容为4；不为0，扩容为原来的2倍
		size_t newcapacity = psl-&gt;capacity == 0 ? 4 : 2 * (psl-&gt;capacity);
		psl-&gt;a = (SeqList*)realloc(psl-&gt;a, sizeof(SLDateType) * newcapacity); // 扩容
		psl-&gt;capacity = newcapacity; // 更新容量
	}
}</code></pre> 
<blockquote> 
 <h6>为什么不采取插一个数据，增容一个空间的方式呢？</h6> 
 <p>因为这样做很麻烦，代价也很大。一般情况下，为了<span style="color:#fe2c24;"><strong>避免频繁的增容</strong></span>，当空间满了之后，我们不会选择一个一个的去增，而是<span style="color:#fe2c24;"><strong>一次增容 2 倍</strong></span>，当然也不会一次增容太大，比如 3 倍 4 倍，这样<strong>空间可能会造成浪费</strong>，所以 2 倍是一个折中的选择。</p> 
</blockquote> 
<hr> 
<blockquote> 
 <p> <span style="color:#fe2c24;"><strong>注</strong></span>：<span style="color:#fe2c24;"><strong>realloc</strong></span> 在开辟动态内存空间时，如果传给它的是一个<strong>空指针</strong>，那么他就会开辟一个新的内存空间，用法类似<span style="color:#fe2c24;"><strong>malloc</strong></span>。</p> 
</blockquote> 
<hr> 
<h4>4、顺序表尾插</h4> 
<pre><code class="language-cpp">// 顺序表尾插
void SeqListPushBack(SeqList* psl, SLDateType x) // O(1)
{
	// 不需要断言 空指针也符合条件

    // 第一种写法：
    /* CheckCapacity(psl); // 检查顺序表容量是否已满
	psl-&gt;a[psl-&gt;size] = x; // 尾插数据
	psl-&gt;size++; // 有效数据个数+1 */

    // 第二种写法：
	SeqListInsert(psl, psl-&gt;size, x);
}</code></pre> 
<p class="img-center"><img alt="" height="241" src="https://images2.imgbox.com/44/1e/bo9P5gXs_o.png" width="300"></p> 
<hr> 
<h4>5、顺序表尾删</h4> 
<pre><code class="language-cpp">// 顺序表尾删
void SeqListPopBack(SeqList* psl) // O(1)
{
	assert(psl); // 断言

    // 第一种写法：
    /* assert(psl-&gt;size &gt; 0); // 尾删 -- 顺序表不能为空
	//psl-&gt;a[psl-&gt;size - 1] = 0; // 不知道SLDataType是什么类型的数据，不能冒然的直接赋值为0
	psl-&gt;size--; // 有效数据个数-1 */

    // 第二种写法：
	SeqListErase(psl, psl-&gt;size - 1);
}</code></pre> 
<blockquote> 
 <h6>关于在程序中检查错误的方式：</h6> 
 <p>（1）温柔检查法： 如果出现错误，程序就不再继续执行。因为一般情况下，程序运行成功就返回0，则运行失败就返回-1。<br> （2）暴力检查法（<span style="color:#fe2c24;"><strong>推荐</strong></span>）：如果发生错误，程序会报警告，可以直接知道出错位置。</p> 
 <pre><code class="language-cpp">// 温柔处理方式
    if (psl-&gt;size &gt; 0)
    {
        psl-&gt;a[ps-&gt;size - 1] = 0;
        psl-&gt;size--;
    }

// 暴力处理方式
    assert(psl-&gt;size &gt; 0);
    psl-&gt;size--;</code></pre> 
 <hr> 
 <p><span style="color:#fe2c24;"><strong>注</strong></span>：不知道 <span style="color:#fe2c24;"><strong>SLDataType</strong></span> 是什么类型的数据，不能冒然的将顺序表最后一个数据赋值为 0，我们只需<strong>将有效数据个数 <span style="color:#fe2c24;">size 减 1</span> 即可达到尾删的目的</strong>。 </p> 
</blockquote> 
<p class="img-center"><img alt="" height="326" src="https://images2.imgbox.com/97/d5/qa4jFyIV_o.png" width="260"></p> 
<hr> 
<h4>6、顺序表头插</h4> 
<pre><code class="language-cpp">// 顺序表头插
void SeqListPushFront(SeqList* psl, SLDateType x) // O(n)
{
    // 头插不需要断言 空指针也符合条件

    /* CheckCapacity(psl); // 检查顺序表容量是否已满
	for (int i = psl-&gt;size - 1; i &gt;= 0; i--) // 顺序表中[0,size-1]的元素依次向后挪动一位
	{
		psl-&gt;a[i + 1] = psl-&gt;a[i];
	}
	psl-&gt;a[0] = x; // 头插数据
	psl-&gt;size++; // 有效数据个数+1 */

	SeqListInsert(psl, 0, x);
}</code></pre> 
<p class="img-center"><img alt="" height="317" src="https://images2.imgbox.com/78/19/4FEtFDIC_o.png" width="300"></p> 
<hr> 
<h4>7、顺序表头删</h4> 
<pre><code class="language-cpp">// 顺序表头删
void SeqListPopFront(SeqList* psl) // O(n)
{
	assert(psl); // 断言

    // 方法一：
    /* assert(psl-&gt;size &gt; 0);  //顺序表不能为空
	for (int i = 1; i &lt; psl-&gt;size; i++) // 顺序表中[1,size-1]的元素依次向前挪动一位
	{
		psl-&gt;a[i - 1] = psl-&gt;a[i];
	}
	psl-&gt;size--; // 有效数据个数-1 */

    // 方法二：
	SeqListErase(psl, 0);
}</code></pre> 
<p class="img-center"><img alt="" height="333" src="https://images2.imgbox.com/aa/5b/oifK8fqA_o.png" width="280"></p> 
<hr> 
<h4>8、顺序表打印</h4> 
<pre><code class="language-cpp">// 打印顺序表
void SeqListPrint(SeqList* ps)
{
	assert(ps); // 断言

    if (psl-&gt;size == 0) // 顺序表为空
	{
		printf("顺序表为空\n");
		return;
	}

    // 顺序表不为空
	for (size_t i = 0; i &lt; ps-&gt;size; i++)
	{
		printf("%d ", ps-&gt;a[i]);
	}
	printf("\n");
}</code></pre> 
<hr> 
<h4> 9、顺序表查找指定值</h4> 
<pre><code class="language-cpp">// 顺序表查找
int SeqListFind(SeqList* psl, SLDateType x)
{
	assert(psl); // 断言
	for (int i = 0; i &lt; psl-&gt;size; i++)
	{
		if (psl-&gt;a[i] == x)
		{
			return i; //查找到，返回该值在数组中的下标
		}
	}
	return -1; // 没查找到
}</code></pre> 
<p class="img-center"><img alt="" height="419" src="https://images2.imgbox.com/79/87/m4STxjdk_o.png" width="280"></p> 
<hr> 
<h4> 10、顺序表在pos位置插入x</h4> 
<pre><code class="language-cpp">// 顺序表在pos位置插入x
void SeqListInsert(SeqList* psl, size_t pos, SLDateType x)
{
	assert(psl); // 断言
	assert(pos &gt;= 0 &amp;&amp; pos &lt;= (psl-&gt;size)); // 检查pos下标的合法性
	CheckCapity(psl);

    // 第一种写法：
	/* size_t end = psl-&gt;size;
	while (end &gt; pos)
	{
		psl-&gt;a[end] = psl-&gt;a[end - 1];
		end--;
	} */

    //第二种写法：
    size_t i = 0;
	for (i = psl-&gt;size; i &gt; pos; i--)  // 将pos位置后面的数据依次向后挪动一位
	{
		psl-&gt;a[i] = psl-&gt;a[i - 1];
	}

	psl-&gt;a[pos] = x; // 插入数据
	psl-&gt;size++; // 有效数据个数+1
}</code></pre> 
<hr> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>注</strong></span>：原先下面这种写法，当顺序表为空 size = 0 时，会导致 i = -1，执行 i &gt;= pos 时，<strong>i 被算术转换成无符号数</strong>，而<strong><span style="color:#fe2c24;">无符号数的 -1 </span>是一个值很大的正数</strong>，<strong>远远大于 pos</strong>，满足条件进入循环，会造成<span style="color:#fe2c24;"><strong>越界访问</strong></span>。 </p> 
</blockquote> 
<pre><code class="language-cpp">int i = 0;
for (i = psl-&gt;size - 1; i &gt;= pos; i--)
	psl-&gt;a[i + 1] = psl-&gt;a[i];</code></pre> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>注</strong></span>：转换并不会改变 i 本身的值，而是在执行 i &gt;= pos 时，生成一个临时值与 pos 进行比较。如果在顺序表头部（pos = 0）插入数据，i 最终也会减成 -1，被算术转换后变成一个很大的数。</p> 
 <hr> 
 <p><span style="color:#fe2c24;"><strong>总结</strong></span>：<strong>避免负数给到无符号数</strong>，或者<strong>避免有符号数变成负数</strong>后，被算术转换或整型提升后，变成一个很大的数。按照第二种写法就可以避免 i 变成负数（-1）了。</p> 
</blockquote> 
<hr> 
<blockquote> 
 <p> 实现了此接口，顺序表<span style="color:#fe2c24;"><strong>头插</strong></span>和<span style="color:#fe2c24;"><strong>尾插</strong></span>相当于在下标为 <strong>0</strong> 和 <strong>psl -&gt; size-1</strong> 位置处插入数据。</p> 
</blockquote> 
<hr> 
<p class="img-center"><img alt="" height="319" src="https://images2.imgbox.com/90/b0/cTpCLdLP_o.png" width="280"></p> 
<hr> 
<h4>11、顺序表删除pos位置的值</h4> 
<pre><code class="language-cpp">// 顺序表删除pos位置的值
void SeqListErase(SeqList* psl, size_t pos)
{
	assert(psl); // 断言
    assert(psl-&gt;size &gt; 0); // 顺序表不能为空
	assert(pos &gt;= 0 &amp;&amp; pos &lt; psl-&gt;size); // 检查pos下标的合法性

    // 第一种写法：
	/* size_t start = pos;
	while (start &lt; psl-&gt;size-1)
	{
		psl-&gt;a[start] = psl-&gt;a[start + 1];
		start++;
	} */

    //第二种写法：
    size_t i = 0;
	for (i = pos + 1; i &lt; psl-&gt;size; i++)  // 将pos位置后面的数据依次向前挪动一位
	{
		psl-&gt;a[i - 1] = psl-&gt;a[i];
	}

	psl-&gt;size--; // 有效数据个数-1
}</code></pre> 
<blockquote> 
 <p>实现了此接口，顺序表<span style="color:#fe2c24;"><strong>头删</strong></span>和<span style="color:#fe2c24;"><strong>尾删</strong></span>相当于删除下标为 <strong>0 </strong>和 <strong>psl -&gt; size-1 </strong>位置处的数据。</p> 
</blockquote> 
<hr> 
<p class="img-center"><img alt="" height="296" src="https://images2.imgbox.com/85/4f/m1ghuWs9_o.png" width="280"></p> 
<hr> 
<h4>12、查看顺序表中的有效数据个数 </h4> 
<pre><code class="language-cpp">// 查看顺序表中的有效数据个数
size_t SeqListSize(const SeqList* psl)
{
	assert(psl); // 断言
	return psl-&gt;size;
}</code></pre> 
<blockquote> 
 <h6>为什么不选择在主函数里面直接通过定义的结构体变量直接访问，还要弄一个相关函数呢？</h6> 
 <p>在数据结构中，如果要<strong>访问或者修改数据结构中的数据</strong>，<span style="color:#fe2c24;"><strong>不要直接访问</strong></span>，而是应该去调用它的函数来访问和修改，这样会更加<strong>规范和安全</strong>，也更<span style="color:#fe2c24;"><strong>方便检查出是否出现了越界等错误情况</strong></span>。</p> 
</blockquote> 
<hr> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>数组越界是不一定报错的，系统对越界的检查是设岗检查。</strong></span></p> 
</blockquote> 
<blockquote> 
 <ul><li> <p>越界读（读了不属于自己的数据），一般是检查不出来的，往往并不会造成内存奔溃。</p> </li><li> <p>越界写（缓冲区溢出）如果是修改到标志位才会被检查出来，会造成数据破坏，严重会造成内存奔溃。</p> </li></ul> 
 <p>（系统在数组末尾后设的有标志位，越界写时，恰好修改到标志位了，就会被检查出来）</p> 
</blockquote> 
<hr> 
<h4>13、修改指定下标位置的数据</h4> 
<pre><code class="language-cpp">// 修改指定下标位置的数据
void SeqListAt(SeqList* psl, size_t pos, SLDataType x)
{
	assert(psl); // 断言
    assert(psl-&gt;size &gt; 0); // 顺序表不能为空
	assert(pos &gt;= 0 &amp;&amp; pos &lt; psl-&gt;size); // 检查pos下标的合法性
	psl-&gt;a[pos] = x; // 修改pos下标处对应的数据
}</code></pre> 
<hr> 
<h2> 四、代码整合</h2> 
<pre><code class="language-cpp">// SeqList.c
#include "SeqList.h"
﻿
// 初始化顺序表
void SeqListInit(SeqList* psl)
{
	assert(psl); // 断言 -- 防止传进来的指针为空

	psl-&gt;a = NULL; // 初始化顺序表为空
    psl-&gt;size = 0; // 初始数据个数为0
	psl-&gt;capacity = 0; // 初始空间容量为0
}

// 销毁顺序表
void SeqListDestroy(SeqList* psl)
{
	assert(psl); // 断言 -- 防止传进来的指针为空

	free(psl-&gt;a); // 释放动态开辟的空间
    psl-&gt;a = NULL; // 置空
	psl-&gt;size = 0; // 数据个数置为0
	psl-&gt;capacity = 0; // 空间容量大小置为0
}

// 检查顺序表容量是否满了，好进行增容
void CheckCapity(SeqList* psl)
{
	if (psl-&gt;size == psl-&gt;capacity) // 检查容量，满了则增容
	{
        // 原来容量为0，扩容为4；不为0，扩容为原来的2倍
		size_t newcapacity = psl-&gt;capacity == 0 ? 4 : 2 * (psl-&gt;capacity);
		psl-&gt;a = (SeqList*)realloc(psl-&gt;a, sizeof(SLDateType) * newcapacity); // 扩容
		psl-&gt;capacity = newcapacity; // 更新容量
	}
}

// 顺序表尾插
void SeqListPushBack(SeqList* psl, SLDateType x) // O(1)
{
	SeqListInsert(psl, psl-&gt;size, x);
}

// 顺序表尾删
void SeqListPopBack(SeqList* psl) // O(1)
{
	assert(psl); // 断言
	SeqListErase(psl, psl-&gt;size - 1);
}

// 顺序表头插
void SeqListPushFront(SeqList* psl, SLDateType x) // O(n)
{
	SeqListInsert(psl, 0, x);
}

// 顺序表头删
void SeqListPopFront(SeqList* psl) // O(n)
{
	assert(psl); // 断言
	SeqListErase(psl, 0);
}

// 打印顺序表
void SeqListPrint(SeqList* ps)
{
	assert(ps); // 断言

    if (psl-&gt;size == 0) // 顺序表为空
	{
		printf("顺序表为空\n");
		return;
	}

    // 顺序表不为空
	for (size_t i = 0; i &lt; ps-&gt;size; i++)
	{
		printf("%d ", ps-&gt;a[i]);
	}
	printf("\n");
}

// 顺序表查找
int SeqListFind(SeqList* psl, SLDateType x)
{
	assert(psl); // 断言
	for (int i = 0; i &lt; psl-&gt;size; i++)
	{
		if (psl-&gt;a[i] == x)
		{
			return i; //查找到，返回该值在数组中的下标
		}
	}
	return -1; // 没查找到
}

// 顺序表在pos位置插入x
void SeqListInsert(SeqList* psl, size_t pos, SLDateType x)
{
	assert(psl); // 断言
	assert(pos &gt;= 0 &amp;&amp; pos &lt;= (psl-&gt;size)); // 检查pos下标的合法性
	CheckCapity(psl);

    size_t i = 0;
	for (i = psl-&gt;size; i &gt; pos; i--)  // 将pos位置后面的数据依次向后挪动一位
	{
		psl-&gt;a[i] = psl-&gt;a[i - 1];
	}
	psl-&gt;a[pos] = x; // 插入数据
	psl-&gt;size++; // 有效数据个数+1
}

// 顺序表删除pos位置的值
void SeqListErase(SeqList* psl, size_t pos)
{
	assert(psl); // 断言
    assert(psl-&gt;size &gt; 0); // 顺序表不能为空
	assert(pos &gt;= 0 &amp;&amp; pos &lt; psl-&gt;size); // 检查pos下标的合法性

    size_t i = 0;
	for (i = pos + 1; i &lt; psl-&gt;size; i++)  // 将pos位置后面的数据依次向前挪动一位
	{
		psl-&gt;a[i - 1] = psl-&gt;a[i];
	}
	psl-&gt;size--; // 有效数据个数-1
}

// 查看顺序表中的有效数据个数
size_t SeqListSize(const SeqList* psl)
{
	assert(psl); // 断言
	return psl-&gt;size;
}

// 修改指定下标位置的数据
void SeqListAt(SeqList* psl, size_t pos, SLDataType x)
{
	assert(psl); // 断言
    assert(psl-&gt;size &gt; 0); // 顺序表不能为空
	assert(pos &gt;= 0 &amp;&amp; pos &lt; psl-&gt;size); // 检查pos下标的合法性
	psl-&gt;a[pos] = x; // 修改pos下标处对应的数据
}</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fd111c912b74bcff76d0ff113c2ea17c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pytorch中的归一化函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f044a839acac0577566b40e98af7a121/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网工配置命令基础总结（2）----VRRP配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>