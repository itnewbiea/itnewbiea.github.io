<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringCloud采用Jackson序列化统一响应不正当的消息转换器导致的异常问题 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringCloud采用Jackson序列化统一响应不正当的消息转换器导致的异常问题" />
<meta property="og:description" content="SpringCloud采用Jackson序列化统一响应不正当的消息转换器导致的异常问题 环境说明 org.springframework.cloud.spring-cloud-dependencies.2020.0.0
org.springframework.boot.spring-boot-dependencies.2.4.0
com.fasterxml.jackson.core.jackson-core.2.12.0
问题说明 我们在使用@RestControllerAdvice注解与ResponseBodyAdvice制定微服务统一返回值的时候,Spring根据消息转换器的是否支持进行选择，而我们在此时更改了返回值类型，导致的返回值类型转换出现异常 出现异常:org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.ClassCastException: class com.pkk.spring.cloud.core.common.rpc.response.ResponseBody cannot be cast to class java.lang.String (com.pkk.spring.cloud.core.common.rpc.response.ResponseBody is in unnamed module of loader ‘app’; java.lang.String is in module java.base of loader ‘bootstrap’)
at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014) ~[spring-webmvc-5.3.1.jar:5.3.1]
at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.3.1.jar:5.3.1]
问题分析解决思路 消息处理器在处理的时候被StringHttpMessageConverter消息处理器给捕获了,并做了处理,这时我把方法返回的值给变为ResponseBody对象,再去转String出现了异常 解决思路一:优先使用自定义的MappingJackson2HttpMessageConverter消息处理返回的数据 方式一:通过WebMvcConfigurer或者WebMvcConfigurerSupport下面的extendMessageConverters方法改变排序 解决思路二:把匹配到的StringHttpMessageConverter消息处理器给删除掉,让给我们自定义的消息处理器 方式一:通过WebMvcConfigurer或者WebMvcConfigurerSupport下面的extendMessageConverters方法删除此消息处理器 解决思路三:我们直接不转换返回值类型,在beforeBodyWrite方法中判断返回值如果是String类型,我们处理完之后在转为JSON字符串 通过下面的源码分析思路,发现我们配置的MappingJackson2HttpMessageConverter消息转换器在处理一个请求的时候,没有被匹配到,直接跳过？ 解决思路一:分析发现【converter.canWrite】不符合,不符合的原因就是MediaType的原因,增加支持相应的MediaType(原因分析见org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter#canWrite) 解决代码示例 通过WebMvcConfigurer或者WebMvcConfigurerSupport下面的extendMessageConverters方法改变排序 /** * Mvc的配置 * * @author peikunkun * @version V1.0 * @date 2021-01-07 17:46 **/ @Configuration public class MessageConverterOrderWebMvcConfigurer implements WebMvcConfigurer { @Autowired private MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter; @Override public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/fa100536830172df2dd4671a8a08c277/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-08T18:11:24+08:00" />
<meta property="article:modified_time" content="2021-01-08T18:11:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringCloud采用Jackson序列化统一响应不正当的消息转换器导致的异常问题</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="SpringCloudJackson_1"></a>SpringCloud采用Jackson序列化统一响应不正当的消息转换器导致的异常问题</h3> 
<h3><a id="_3"></a>环境说明</h3> 
<blockquote> 
 <p>org.springframework.cloud.spring-cloud-dependencies.2020.0.0<br> org.springframework.boot.spring-boot-dependencies.2.4.0<br> com.fasterxml.jackson.core.jackson-core.2.12.0</p> 
</blockquote> 
<h3><a id="_9"></a>问题说明</h3> 
<blockquote> 
 <ol><li>我们在使用@RestControllerAdvice注解与ResponseBodyAdvice制定微服务统一返回值的时候,Spring根据消息转换器的是否支持进行选择，而我们在此时更改了返回值类型，导致的返回值类型转换出现异常</li></ol> 
 <blockquote> 
  <p>出现异常:org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.ClassCastException: class com.pkk.spring.cloud.core.common.rpc.response.ResponseBody cannot be cast to class java.lang.String (com.pkk.spring.cloud.core.common.rpc.response.ResponseBody is in unnamed module of loader ‘app’; java.lang.String is in module java.base of loader ‘bootstrap’)<br> at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014) ~[spring-webmvc-5.3.1.jar:5.3.1]<br> at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.3.1.jar:5.3.1]</p> 
 </blockquote> 
</blockquote> 
<h3><a id="_17"></a>问题分析解决思路</h3> 
<blockquote> 
 <ol><li>消息处理器在处理的时候被StringHttpMessageConverter消息处理器给捕获了,并做了处理,这时我把方法返回的值给变为ResponseBody对象,再去转String出现了异常</li></ol> 
 <blockquote> 
  <ul><li>解决思路一:优先使用自定义的MappingJackson2HttpMessageConverter消息处理返回的数据</li></ul> 
  <blockquote> 
   <ul><li>方式一:<a href="#1" rel="nofollow">通过WebMvcConfigurer或者WebMvcConfigurerSupport下面的extendMessageConverters方法改变排序</a></li></ul> 
  </blockquote> 
 </blockquote> 
</blockquote> 
<blockquote> 
 <blockquote> 
  <ul><li>解决思路二:把匹配到的StringHttpMessageConverter消息处理器给删除掉,让给我们自定义的消息处理器</li></ul> 
  <blockquote> 
   <ul><li>方式一:<a href="#2" rel="nofollow">通过WebMvcConfigurer或者WebMvcConfigurerSupport下面的extendMessageConverters方法删除此消息处理器</a></li></ul> 
  </blockquote> 
 </blockquote> 
</blockquote> 
<blockquote> 
 <blockquote> 
  <ul><li>解决思路三:<a href="#3" rel="nofollow">我们直接不转换返回值类型,在beforeBodyWrite方法中判断返回值如果是String类型,我们处理完之后在转为JSON字符串</a></li></ul> 
 </blockquote> 
</blockquote> 
<blockquote> 
 <ol start="2"><li>通过下面的源码分析思路,发现我们配置的MappingJackson2HttpMessageConverter消息转换器在处理一个请求的时候,没有被匹配到,直接跳过？</li></ol> 
 <blockquote> 
  <ul><li>解决思路一:<a href="#4" rel="nofollow">分析发现【converter.canWrite】不符合,不符合的原因就是MediaType的原因,增加支持相应的MediaType(原因分析见org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter#canWrite)</a></li></ul> 
 </blockquote> 
</blockquote> 
<h3><a id="_31"></a>解决代码示例</h3> 
<ol><li><span id="1">通过WebMvcConfigurer或者WebMvcConfigurerSupport下面的extendMessageConverters方法改变排序</span></li></ol> 
<pre><code class="prism language-makedown">/**
 * Mvc的配置
 *
 * @author peikunkun
 * @version V1.0
 * @date 2021-01-07 17:46
 **/
@Configuration
public class MessageConverterOrderWebMvcConfigurer implements WebMvcConfigurer {


  @Autowired
  private MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter;


  @Override
  public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {

    //方法一:把jackson解析器放在第一位,这样匹配完了之后,就会直接返回;[是否匹配和我们解析器支持的类型有关[supportedMediaTypes]详细见源码
    // org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor#writeWithMessageConverters]
    converters.add(0, mappingJackson2HttpMessageConverter);
  }
}
</code></pre> 
<ol start="2"><li><span id="2">通过WebMvcConfigurer或者WebMvcConfigurerSupport下面的extendMessageConverters方法删除此消息处理器</span></li></ol> 
<pre><code class="prism language-makedown">/**
 * Mvc的配置
 *
 * @author peikunkun
 * @version V1.0
 * @date 2021-01-07 17:46
 **/
@Configuration
public class MessageConverterOrderWebMvcConfigurer implements WebMvcConfigurer {
  
  @Override
  public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
    //方法二:我们可以把匹配到的Spring自带的默认String值解析器去掉，这样匹配到的就有可能到jackson解析器来处理
    converters.removeIf(converter -&gt; converter.getClass() == StringHttpMessageConverter.class);
  }
}
</code></pre> 
<ol start="3"><li><span id="3">我们直接不转换返回值类型,在beforeBodyWrite方法中判断返回值如果是String类型,我们处理完之后在转为JSON字符串</span></li></ol> 
<pre><code class="prism language-makedown">/**
 * 普通响应类统一处理
 *
 * @author peikunkun
 * @version V1.0
 * @date 2021-01-06 16:26
 **/
//这里尽量让加密的判断优先级更低一点(请求的时候,加密的优先级高一点)
@Order(1)
@RestControllerAdvice
//当开启此注解的时候启用此响应处理器
//@ConditionalOnBean(annotation = EnableGlobalResponse.class)
public class ResponseHandle implements ResponseBodyAdvice&lt;Object&gt; {


  @Autowired
  private MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter;

  /**
   * 是否支持此消息响应处理器
   *
   * @return boolean
   * @Param methodParameter
   * @Param aClass
   * @author peikunkun
   * @date 2021/1/6 0006 下午 4:29
   * @since
   */
  @Override
  public boolean supports(MethodParameter methodParameter, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass) {
    //当前方法的类上存在或者方法上存在此注解,取消给解析器
    if (methodParameter.getMethod().getDeclaringClass().isAnnotationPresent(IgnoreResponseConverter.class) ||
        methodParameter.hasMethodAnnotation(IgnoreResponseConverter.class)) {
      return false;
    }
    return true;
  }

  /**
   * 在选择HttpMessageConverter之后且在调用其write方法之前调用。
   * &lt;p&gt;
   * 参数：正文–要写的正文
   * returnType –控制器方法的返回类型
   * selectedContentType –通过内容协商选择的内容类型
   * selectedConverterType –选择要写入响应的转换器类型
   * 请求–当前请求
   * 响应–当前响应
   * 返回值：
   * 传入的正文或经过修改的（可能是新的）实例
   */
  @SneakyThrows
  @Override
  public Object beforeBodyWrite(Object o, MethodParameter methodParameter, MediaType mediaType,
      Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest serverHttpRequest,
      ServerHttpResponse serverHttpResponse) {
	//字符串的特殊处理
    if (o instanceof String) {
      return mappingJackson2HttpMessageConverter.getObjectMapper().writeValueAsString(R.success(o));
    }

    ResponseBody result = null;
    if (o instanceof ResponseBody) {
      result = (ResponseBody) o;
    } else {
      result = R.success(o);
    }
    return result;
  }
}
</code></pre> 
<ol start="4"><li><span id="4">分析发现【converter.canWrite】不符合,不符合的原因就是MediaType的原因,增加支持相应的MediaType(原因分析见org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter#canWrite)</span></li></ol> 
<pre><code class="prism language-makedown">/**
 * 消息转换处理器
 *
 * @author peikunkun
 * @version V1.0
 * @date 2021-01-06 17:36
 **/
public class MessageConverterConfig {


  /**
   * 使用jackson序列化消息转换
   *
   * @return org.springframework.boot.autoconfigure.http.HttpMessageConverters
   * @Param
   * @author peikunkun
   * @date 2021/1/6 0006 下午 6:09
   * @since
   */
  @Bean
  public MappingJackson2HttpMessageConverter fastJsonHttpMessageConverters() {
    MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter();
    messageConverter.setDefaultCharset(Charset.defaultCharset());

    //@formatter:off
    ObjectMapper objectMapper = new ObjectMapper();
    // 忽略json字符串中不识别的属性
    objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    // 忽略无法转换的对象
    objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
    // PrettyPrinter 格式化输出
    objectMapper.configure(SerializationFeature.INDENT_OUTPUT, true);
    // 指定时区
    objectMapper.setTimeZone(TimeZone.getTimeZone("GMT+8:00"));
    // 日期类型字符串处理
    objectMapper.setDateFormat(new SimpleDateFormat(DatePattern.NORM_DATETIME_PATTERN));

    // java8日期日期处理
    JavaTimeModule javaTimeModule = new JavaTimeModule();
    javaTimeModule.addSerializer(LocalDateTime.class,new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DatePattern.NORM_DATETIME_PATTERN)));
    javaTimeModule.addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DatePattern.NORM_DATE_PATTERN)));
    javaTimeModule.addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DatePattern.NORM_TIME_PATTERN)));
    javaTimeModule.addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DatePattern.NORM_DATETIME_PATTERN)));
    javaTimeModule.addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DatePattern.NORM_DATE_PATTERN)));
    javaTimeModule.addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DatePattern.NORM_TIME_PATTERN)));
    objectMapper.registerModule(javaTimeModule);
    messageConverter.setObjectMapper(objectMapper);



    //支持的媒体类型
    List&lt;MediaType&gt; supportedMediaTypes = new LinkedList&lt;&gt;();
    supportedMediaTypes.add(MediaType.APPLICATION_JSON_UTF8);


    //页面直接请求的类型(这里是新增加的支持的匹配的类型,页面访问的时候类型为text/html)
    supportedMediaTypes.add(MediaType.TEXT_HTML);


    messageConverter.setSupportedMediaTypes(supportedMediaTypes);
    //@formatter:on
    return messageConverter;
  }

}
</code></pre> 
<h3><a id="_223"></a>问题源码分析</h3> 
<blockquote> 
 <p>HttpMessageConverter类是Spring的消息转换类，他是用来处理流和接口的参数类型或返回值类型之间的转换的。</p> 
</blockquote> 
<ol><li> <p>我们通过Debug模式定位出现异常的</p> 
  <ul><li>首先定位到异常代码位置org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor#writeWithMessageConverters<br> <img src="https://images2.imgbox.com/70/6e/s4pwH8Gf_o.png" alt="在这里插入图片描述"></li><li>有上图可以看出,代码是获取了所有的消息转换器,依次进行尝试,根据converter.canWrite判断是否可输出，可以的话,获取所有的请求响应链(RequestResponseBodyAdviceChain)调用其beforeBodyWrite方法进行处理，这时会调用我们自定义的ResponseHandle#beforeBodyWrite方法,我们在这个方法中改变了其返回值,将返回值更改为ResponseBody类型;这之后的body类型将会由[String-&gt;ResponseBody类型]，最终会调用converter.write()方进行输出;过程见下图</li></ul> <pre><code class="prism language-makedown">if (selectedMediaType != null) {
		selectedMediaType = selectedMediaType.removeQualityValue();
		for (HttpMessageConverter&lt;?&gt; converter : this.messageConverters) {
			GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ?
					(GenericHttpMessageConverter&lt;?&gt;) converter : null);
			if (genericConverter != null ?
					((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) :
					converter.canWrite(valueType, selectedMediaType)) {
				body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,
						(Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) converter.getClass(),
						inputMessage, outputMessage);
				if (body != null) {
					Object theBody = body;
					LogFormatUtils.traceDebug(logger, traceOn -&gt;
							"Writing [" + LogFormatUtils.formatValue(theBody, !traceOn) + "]");
					addContentDispositionHeader(inputMessage, outputMessage);
					if (genericConverter != null) {
						genericConverter.write(body, targetType, selectedMediaType, outputMessage);
					}
					else {
						((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);
					}
				}
				else {
					if (logger.isDebugEnabled()) {
						logger.debug("Nothing to write: null body");
					}
				}
				return;
			}
		}
	}
</code></pre> 
  <ul><li>图例<br> <img src="https://images2.imgbox.com/e3/cf/X0EmnoB0_o.png" alt="在这里插入图片描述"></li><li>异常转换核心步骤<br> <img src="https://images2.imgbox.com/55/03/raI8Jt2y_o.png" alt="在这里插入图片描述"></li></ul> </li></ol> 
<h3><a id="MAVEN_270"></a>项目MAVEN相关依赖支持</h3> 
<pre><code class="prism language-markdown">&lt;dependencies&gt;
    &lt;!--自动装配的配置--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;
    &lt;/dependency&gt;


    &lt;!--@RestControllerAdvice的统一响应处理支持--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;!--ResponseBodyAdvice接口的拓展支持响应类操作--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;!--使用jackson的序列化--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!--使用jackson的序列化的JavaTimeModule序列化操作--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;
      &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1029d68e33fdd8bb6fd98dc65863ea18/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">新一代轻量级应用服务器 — WebSphere Liberty Profile Server 介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bdd95ccbcb406a29108e006155cda5af/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">个推实人认证SDK使用初体验</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>