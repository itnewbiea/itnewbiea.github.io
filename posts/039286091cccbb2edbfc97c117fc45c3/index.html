<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>sharding-proxy分表配置过程记录 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="sharding-proxy分表配置过程记录" />
<meta property="og:description" content="之前研究过通过mycat进行分库分表的配置，最近发现很多项目上用的都是sharding-proxy来实现，所以也来进行一个学习。下面来简单记录一下搭建的过程。
下载 首先自然是去官网下载软件，这里我下载的是最新版5.1.2，下载地址如下：
https://www.apache.org/dyn/closer.lua/shardingsphere/5.1.2/apache-shardingsphere-5.1.2-shardingsphere-proxy-bin.tar.gz
直接在centos虚拟机上用 wget命令进行下载即可，下载完成后，输入 tar -zxvf apache-shardingsphere-5.1.2-shardingsphere-proxy-bin.tar.gz进行解压，最终解压出来一个文件夹，进行下一步。
配置 进入文件夹，可以看到一个十分眼熟的文件结构，非常像tomcat。可能apache家的软件都是这个结构？（笑）
进入conf，首先我们修改 server.yaml这个配置文件，这个配置文件主要是用来设置一个虚拟的登录用户以及密码。
进去之后我们可以看到官方已经提供了样例配置，都被注释掉了。我们只需要放开需要修改的注释，并进行修改即可。这里我主要修改的内容如下：
rules: - !AUTHORITY users: - root@%:123456 - sharding@:sharding props: proxy-default-port: 3333 这里的配置，是开放了两个用户，root和sharding，作为连接我们sharding-proxy的用户。以及修改了应用启动的端口号，默认使用的是3307，但我还有其他的应用占用了3307，所以这里改成了3333。
接着我们修改config-sharding.yaml这个配置文件，这个文件就是我们分库分表的主要配置文件了。
这个文件也是官方提供了样例配置，我们同样只需要放开注释，进行修改：
###################################################################################################### # # If you want to connect to MySQL, you should manually copy MySQL driver to lib directory. # ###################################################################################################### databaseName: aki_sharding dataSources: ds_0: url: jdbc:mysql://127.0.0.1:3306/aki_ds_0?serverTimezone=UTC&amp;useSSL=false username: root password: 123456 connectionTimeoutMilliseconds: 30000 idleTimeoutMilliseconds: 60000 maxLifetimeMilliseconds: 1800000 maxPoolSize: 50 minPoolSize: 1 # ds_1: # url: jdbc:mysql://127." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/039286091cccbb2edbfc97c117fc45c3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-21T11:19:00+08:00" />
<meta property="article:modified_time" content="2022-11-21T11:19:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">sharding-proxy分表配置过程记录</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>之前研究过通过mycat进行分库分表的配置，最近发现很多项目上用的都是sharding-proxy来实现，所以也来进行一个学习。下面来简单记录一下搭建的过程。</p> 
<h4><a id="_2"></a>下载</h4> 
<p>首先自然是去官网下载软件，这里我下载的是最新版5.1.2，下载地址如下：</p> 
<p>https://www.apache.org/dyn/closer.lua/shardingsphere/5.1.2/apache-shardingsphere-5.1.2-shardingsphere-proxy-bin.tar.gz</p> 
<p>直接在centos虚拟机上用 <code>wget</code>命令进行下载即可，下载完成后，输入 <code>tar -zxvf apache-shardingsphere-5.1.2-shardingsphere-proxy-bin.tar.gz</code>进行解压，最终解压出来一个文件夹，进行下一步。</p> 
<p align="left"><img alt="" src="https://images2.imgbox.com/ba/53/mvR0GeU5_o.png" width="auto" height="auto"></p> 
<h4><a id="_12"></a>配置</h4> 
<p>进入文件夹，可以看到一个十分眼熟的文件结构，非常像tomcat。可能apache家的软件都是这个结构？（笑）</p> 
<p align="left"><img alt="" src="https://images2.imgbox.com/1e/ad/m4ybGAaL_o.png" width="auto" height="auto"></p> 
<p>进入conf，首先我们修改 <code>server.yaml</code>这个配置文件，这个配置文件主要是用来设置一个虚拟的登录用户以及密码。</p> 
<p>进去之后我们可以看到官方已经提供了样例配置，都被注释掉了。我们只需要放开需要修改的注释，并进行修改即可。这里我主要修改的内容如下：</p> 
<pre><code>rules:
  - !AUTHORITY
    users:
      - root@%:123456
      - sharding@:sharding
props:
  proxy-default-port: 3333
</code></pre> 
<p>这里的配置，是开放了两个用户，root和sharding，作为连接我们sharding-proxy的用户。以及修改了应用启动的端口号，默认使用的是3307，但我还有其他的应用占用了3307，所以这里改成了3333。</p> 
<p>接着我们修改config-sharding.yaml这个配置文件，这个文件就是我们分库分表的主要配置文件了。</p> 
<p>这个文件也是官方提供了样例配置，我们同样只需要放开注释，进行修改：</p> 
<pre><code>######################################################################################################
#
# If you want to connect to MySQL, you should manually copy MySQL driver to lib directory.
#
######################################################################################################

databaseName: aki_sharding

dataSources:
  ds_0:
    url: jdbc:mysql://127.0.0.1:3306/aki_ds_0?serverTimezone=UTC&amp;useSSL=false
    username: root
    password: 123456
    connectionTimeoutMilliseconds: 30000
    idleTimeoutMilliseconds: 60000
    maxLifetimeMilliseconds: 1800000
    maxPoolSize: 50
    minPoolSize: 1
#  ds_1:
#    url: jdbc:mysql://127.0.0.1:3306/aki_ds_1?serverTimezone=UTC&amp;useSSL=false
#    username: root
#    password: 123456
#    connectionTimeoutMilliseconds: 30000
#    idleTimeoutMilliseconds: 60000
#    maxLifetimeMilliseconds: 1800000
#    maxPoolSize: 50
#    minPoolSize: 1

rules:
- !SHARDING
  tables:
    t_order:
      actualDataNodes: ds_0.t_order_${0..1}
      tableStrategy:
        standard:
          shardingColumn: order_id
          shardingAlgorithmName: t_order_inline
      keyGenerateStrategy:
        column: order_id
        keyGeneratorName: snowflake
    t_order_item:
      actualDataNodes: ds_0.t_order_item_${0..1}
      tableStrategy:
        standard:
          shardingColumn: order_id
          shardingAlgorithmName: t_order_item_inline
      keyGenerateStrategy:
        column: order_item_id
        keyGeneratorName: snowflake
  bindingTables:
    - t_order,t_order_item
#  defaultDatabaseStrategy:
#    standard:
#      shardingColumn: user_id
#      shardingAlgorithmName: database_inline
#  defaultTableStrategy:
#    none:

  shardingAlgorithms:
    database_inline:
      type: INLINE
      props:
        algorithm-expression: ds_${user_id % 2}
    t_order_inline:
      type: INLINE
      props:
        algorithm-expression: t_order_${order_id % 2}
    t_order_item_inline:
      type: INLINE
      props:
        algorithm-expression: t_order_item_${order_id % 2}

  keyGenerators:
    snowflake:
      type: SNOWFLAKE

</code></pre> 
<p>这个配置文件比较长，我们挑一些重要的来看看。</p> 
<p>首先是开头，可以看到是配置了虚拟的数据库名称，以及数据源。这里可以看到我注释掉了第二个数据源，因为这里的多个数据源实际上对应着多个数据库，是一个分库的概念。这里我们先只探究分表的玩法。</p> 
<p>再往下是一些分库分表的规则，这里可以配置数据按什么规则来进行分表，以及哪些表需要进行分表、主键生成策略等等，这里采用的是雪花id。</p> 
<p>最后，还有一点需要注意，就是sharding-proxy本身并没有mysql的连接jar包，所以这里我们需要自己去准备一个，然后放到lib文件夹中。这里我用的mysql版本是8.x的，所以connector jar包也用了8.x的。</p> 
<p align="left"><img alt="" src="https://images2.imgbox.com/f5/29/U9cdMnnu_o.png" width="auto" height="auto"></p> 
<h4><a id="_127"></a>测试</h4> 
<p>配置完成后，程序启动方法也很简单。进入bin目录，执行start.sh即可。日志会自动输出到logs/stdout.log中</p> 
<p><strong>在启动之前，还需要注意，我们需要在真实的数据源中建立对应的数据库，否则启动会报错</strong></p> 
<p>我们用navicat连接进行测试</p> 
<p align="left"><img alt="" src="https://images2.imgbox.com/57/b1/Y2fenmm2_o.png" width="auto" height="auto"></p> 
<p>可以看到，在3333端口连接成功了。</p> 
<p>然后，我们在这个aki_sharding库中，建立2张表：t_order，aki_test。这两张表，一个是在前面的配置文件中配置的要进行分表的表，一个则是完全无关的表。我们来看看会是什么样的结果：</p> 
<p align="left"><img alt="" src="https://images2.imgbox.com/97/68/HC0Oj6VG_o.png" width="auto" height="auto"></p> 
<p>可以看到，在宿主库中，sharding-proxy帮我们把t_order表进行了分表，分成了2张。而对于aki_test表，则是普通的创建。</p> 
<p>下面我们试着往t_order表中插入几条数据进行测试：</p> 
<p align="left"><img alt="" src="https://images2.imgbox.com/49/47/gih1udUw_o.png" width="auto" height="auto"></p> 
<p>然后我们去宿主库进行查看：</p> 
<p align="left"><img alt="" src="https://images2.imgbox.com/84/58/CYIKL4xz_o.png" width="auto" height="auto"></p> 
<p align="left"><img alt="" src="https://images2.imgbox.com/d0/79/pADuxs3f_o.png" width="auto" height="auto"></p> 
<p>可以看到，主键id是用雪花id生成的，并且按照规则分配到了2张表中。这样我们就完成了分表的基本操作。</p> 
<p>经过测试，基本的查询、修改、删除、插入等操作，对用户来说都是无感知的，可以把sharding-proxy虚拟出来的这个数据库，当成真正的数据库来进行使用。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d82c20acb3761b487878c7d5ac8dcf8f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深度学习_用LSTM&#43;Attention与Self-Attention</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/36696997d918503e06b49204826af393/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">小程序 获取不到微信用户信息</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>