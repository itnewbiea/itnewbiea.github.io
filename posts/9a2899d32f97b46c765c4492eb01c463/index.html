<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ONNXRUNTIME_EXCEPTION : Non-zero status code returned while running Where node. Name:‘Where‘ - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ONNXRUNTIME_EXCEPTION : Non-zero status code returned while running Where node. Name:‘Where‘" />
<meta property="og:description" content="遇到此类错误，如：
onnxruntime.capi.onnxruntime_pybind11_state.InvalidArgument: [ONNXRuntimeError] : 2 : INVALID_ARGUMENT : Non-zero status code returned while running Gather node. Name:&#39;Gather_4445&#39; Status Message: indices element out of data bounds, idx=8 must be within the inclusive range [-3,2]
或：
RUNTIME_EXCEPTION : Non-zero status code returned while running Where node. Name:&#39;Where&#39; Status Message...
可以配合Netron工具（安装方法：pip install netron，使用时终端输入netron）查看导出的onnx模型网络图，可以查找相应的Node（如：Where_XXXX），再去代码中找对应代码，将其改为onnx支持的tensor运算方式即可解决相应问题。
根据在ONNX导出时遇到的问题比较麻烦的是和torch.gather、torch.where、torch.split等Tensor运算方法。
1. torch.where函数
torch.where（condition，x，y）-&gt;tensor
当满足condition，则来自于a，反之来自b
import torch condition=torch.randn(2,2) # tensor([[ 0.2589, -0.5600], # [ 0.9056, -0.3915]]) a=torch.tensor([[0,0],[0,0]]) b=torch.tensor([[1,1],[1,1]]) torch.where(cond&gt;0.5,a,b) 得到结果" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/9a2899d32f97b46c765c4492eb01c463/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-20T08:56:53+08:00" />
<meta property="article:modified_time" content="2022-06-20T08:56:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ONNXRUNTIME_EXCEPTION : Non-zero status code returned while running Where node. Name:‘Where‘</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p>遇到此类错误，如：</p> 
<p>onnxruntime.capi.onnxruntime_pybind11_state.InvalidArgument: [ONNXRuntimeError] : 2 : INVALID_ARGUMENT : Non-zero status code returned while running Gather node. Name:'Gather_4445' Status Message: indices element out of data bounds, idx=8 must be within the inclusive range [-3,2]</p> 
<p>或：</p> 
<p>RUNTIME_EXCEPTION : Non-zero status code returned while running Where node. Name:'Where' Status Message...</p> 
<p>可以配合Netron工具（安装方法：pip install netron，使用时终端输入netron）查看导出的onnx模型网络图，可以查找相应的Node（如：Where_XXXX），再去代码中找对应代码，将其改为onnx支持的tensor运算方式即可解决相应问题。</p> 
<p>根据在ONNX导出时遇到的问题比较麻烦的是和torch.gather、torch.where、torch.split等Tensor运算方法。</p> 
<p>1. <strong>torch.where函数</strong></p> 
<p>torch.where（condition，x，y）-&gt;tensor</p> 
<p>当满足condition，则来自于a，反之来自b</p> 
<pre><code class="language-python">import torch
condition=torch.randn(2,2)
# tensor([[ 0.2589, -0.5600],
#        [ 0.9056, -0.3915]])
a=torch.tensor([[0,0],[0,0]])
b=torch.tensor([[1,1],[1,1]])
torch.where(cond&gt;0.5,a,b)
</code></pre> 
<p>得到结果</p> 
<pre><code class="language-python">tensor([[1, 1],
        [0, 1]])
</code></pre> 
<p>输出为0的代表来源为a，输出为1的代表来源为b</p> 
<p><strong>2. torch.gather（查表的过程）</strong></p> 
<p>torch.gather（input，dim，index，out=None）-&gt;tensor</p> 
<p>就像是给了数据以后，查表得到对应参数，再收集回来进行输出。</p> 
<p>gather函数即为gather（对应的参数表，dim，数据表）</p> 
<pre><code class="language-python">import torch
prob=torch.randn(4,4)
#tensor([[-0.9845,  0.5094, -0.5014, -0.5354],
#        [-1.8514,  0.2640,  0.7895, -0.1660],
#        [ 0.3955,  0.7571,  0.1451,  0.1970],
#        [ 0.3674, -0.8006, -0.5625,  1.3455]])
idx=prob.topk(dim=1,k=2)
idx=idx[1]
#tensor([[1, 2],
#        [2, 1],
#        [1, 0],
#        [3, 0]]))
label=torch.arange(4)+100
#tensor([100, 101, 102, 103])
torch.gather(label.expand(4,4),dim=1,index=idx.long())
</code></pre> 
<p> 输出结果：</p> 
<pre><code class="language-python">tensor([[101, 102],
        [102, 101],
        [101, 100],
        [103, 100]])</code></pre> 
<p>3. torch.split</p> 
<p>含义：将一个张量分为几个chunks</p> 
<p>torch.split(tensor, split_size_or_sections, dim=0)</p> 
<h4>参数<strong>：</strong></h4> 
<ul><li> <p><strong>tensor</strong>(Tensor) -张量分裂。</p> </li><li> <p><strong>split_size_or_sections</strong>(int) 或者<em>(</em>list<em>(</em>int<em>)</em>) -单个块的大小或每个块的大小列表</p> </li><li> <p><strong>dim</strong>(int) -沿其分割张量的维度。</p> </li></ul> 
<p>如果<code>split_size_or_sections</code> 是整数类型，那么tensor将被分成大小相等的块(如果可能)。如果沿给定维度 <code>dim</code> 的张量大小不能被 <code>split_size</code> 整除，则最后一个块会更小。</p> 
<p>如果 <code>split_size_or_sections</code> 是一个列表，那么 tensor 将根据 <code>split_size_or_sections</code> 被拆分为大小在 <code>dim</code> 中的 <code>len(split_size_or_sections)</code> 块。</p> 
<p>示例：</p> 
<pre><code class="language-python">&gt;&gt;&gt; a = torch.arange(8).reshape(4,2)
&gt;&gt;&gt; a
tensor([[0, 1],
        [2, 3],
        [4, 5],
        [6, 7]])
&gt;&gt;&gt; torch.split(a, 3)
(tensor([[0, 1],
         [2, 3],
         [4, 5]]),
 tensor([[6, 7]]))
&gt;&gt;&gt; torch.split(a, [1,3])
(tensor([[0, 1]]),
 tensor([[2, 3],
         [4, 5],
         [6, 7]]))</code></pre> 
<p><strong>4. <code>Tensor.scatter_函数</code></strong></p> 
<h2>TORCH.TENSOR.SCATTER_</h2> 
<p><code>Tensor.</code><code>scatter_</code>(<em>dim</em>, <em>index</em>, <em>src</em>, <em>reduce=None</em>) → <a href="https://pytorch.org/docs/1.10/tensors.html#torch.Tensor" rel="nofollow" title="Tensor">Tensor</a></p> 
<p>Writes all values from the tensor <code>src</code> into <code>self</code> at the indices specified in the <code>index</code> tensor. For each value in <code>src</code>, its output index is specified by its index in <code>src</code> for <code>dimension != dim</code> and by the corresponding value in <code>index</code> for <code>dimension = dim</code>.</p> 
<p>For a 3-D tensor, <code>self</code> is updated as: </p> 
<pre><code class="language-python">self[index[i][j][k]][j][k] = src[i][j][k]  # if dim == 0
self[i][index[i][j][k]][k] = src[i][j][k]  # if dim == 1
self[i][j][index[i][j][k]] = src[i][j][k]  # if dim == 2</code></pre> 
<pre id="codecell0">This is the reverse operation of the manner described in <a href="https://pytorch.org/docs/1.10/generated/torch.Tensor.gather.html#torch.Tensor.gather" rel="nofollow" title="gather()">gather()</a>.</pre> 
<p></p> 
<p><code>self</code>, <code>index</code> and <code>src</code> (if it is a Tensor) should all have the same number of dimensions. It is also required that <code>index.size(d) &lt;= src.size(d)</code> for all dimensions <code>d</code>, and that <code>index.size(d) &lt;= self.size(d)</code> for all dimensions <code>d != dim</code>. Note that <code>index</code> and <code>src</code> do not broadcast.</p> 
<p>Moreover, as for <a href="https://pytorch.org/docs/1.10/generated/torch.Tensor.gather.html#torch.Tensor.gather" rel="nofollow" title="gather()">gather()</a>, the values of <code>index</code> must be between <code>0</code> and <code>self.size(dim) - 1</code> inclusive.</p> 
<p>Parameters</p> 
<ul><li> <p><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" rel="nofollow" title="int">int</a>) – the axis along which to index</p> </li><li> <p><strong>index</strong> (<em>LongTensor</em>) – the indices of elements to scatter, can be either empty or of the same dimensionality as <code>src</code>. When empty, the operation returns <code>self</code> unchanged.</p> </li><li> <p><strong>src</strong> (<a href="https://pytorch.org/docs/1.10/tensors.html#torch.Tensor" rel="nofollow" title="Tensor">Tensor</a><em> or </em><a href="https://docs.python.org/3/library/functions.html#float" rel="nofollow" title="float">float</a>) – the source element(s) to scatter.</p> </li><li> <p><strong>reduce</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str" rel="nofollow" title="str">str</a><em>, </em><em>optional</em>) – reduction operation to apply, can be either <code>'add'</code> or <code>'multiply'</code>.</p> </li></ul> 
<p>总结：scatter函数就是把src数组中的数据重新分配到output数组当中，index数组中表示了要把src数组中的数据分配到output数组中的位置，若未指定，则填充0.</p> 
<p>举例：</p> 
<pre><code class="language-python">&gt;&gt;&gt; src = torch.arange(1, 11).reshape((2, 5))
&gt;&gt;&gt; src
tensor([[ 1,  2,  3,  4,  5],
        [ 6,  7,  8,  9, 10]])
&gt;&gt;&gt; index = torch.tensor([[0, 1, 2, 0]])
&gt;&gt;&gt; torch.zeros(3, 5, dtype=src.dtype).scatter_(0, index, src)
tensor([[1, 0, 0, 4, 0],
        [0, 2, 0, 0, 0],
        [0, 0, 3, 0, 0]])
&gt;&gt;&gt; index = torch.tensor([[0, 1, 2], [0, 1, 4]])
&gt;&gt;&gt; torch.zeros(3, 5, dtype=src.dtype).scatter_(1, index, src)
tensor([[1, 2, 3, 0, 0],
        [6, 7, 0, 0, 8],
        [0, 0, 0, 0, 0]])

&gt;&gt;&gt; torch.full((2, 4), 2.).scatter_(1, torch.tensor([[2], [3]]),
...            1.23, reduce='multiply')
tensor([[2.0000, 2.0000, 2.4600, 2.0000],
        [2.0000, 2.0000, 2.0000, 2.4600]])
&gt;&gt;&gt; torch.full((2, 4), 2.).scatter_(1, torch.tensor([[2], [3]]),
...            1.23, reduce='add')
tensor([[2.0000, 2.0000, 3.2300, 2.0000],
        [2.0000, 2.0000, 2.0000, 3.2300]])</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2357a1ebe61842a473d50bbb768caba2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot&#43;druid&#43;aop动态数据源切换实现-修改中</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dbd4c853c826c172845d8daafda5c610/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">jmeter函数助手二次开发之加解密</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>