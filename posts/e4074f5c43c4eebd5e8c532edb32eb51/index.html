<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ICLR 2022）ODConv：即插即用的动态卷积 （附代码） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ICLR 2022）ODConv：即插即用的动态卷积 （附代码）" />
<meta property="og:description" content="论文地址：Omni-Dimensional Dynamic Convolution | OpenReview
代码地址：https://github.com/OSVAI/ODConv/blob/main/modules/odconv.py
1.是什么？ ODConv是一种动态卷积算法，它的原理是在卷积过程中，根据输入数据的特征动态地调整卷积核的形状和大小，以适应不同的输入数据。具体来说，ODConv通过引入一个可学习的形变模块，根据输入数据的特征动态地调整卷积核的形状和大小，从而提高了卷积神经网络的性能。与CondConv和DyConv不同，ODConv不仅考虑了空间维度、输入通道维度和输出通道维度，还考虑了卷积核的形状和大小，因此可以更好地适应不同的输入数据。
2.为什么？ 常规卷积只有一个静态卷积核且与输入样本无关。对于动态卷积来说，它对多个卷积核进行线性加权，而加权值则与输入有关，这就使得动态卷积具有输入依赖性。它可以描述如下：
尽管动态卷积的定义很简单，但CondConv与DyConv的实现是不相同的，主要体现在计算的结构训练策略以及实施动态卷积的层，这些实现上的差异导致了不同的模型精度、模型大小以及推理效率。
两者均为采用了类SE架构，但CondConv采用的是Sigmoid，而DyConv采用的是Softmax；DyConv采用的退化策略进行训练以抑制Softmax的one-hot输出；对于他们嵌入的CNN架构，CondConv替换了最后几个模块的卷积与全连接层，而DyConv则对除第一个卷积外的其他卷积均进行了替换。 根据动态卷积的公式来看，动态卷积有两个基本元素：
卷积核；用于计算注意力{}的注意力函数 给定n个卷积核，其对应的核空间有以下四个维度：
空间核尺寸k×k；输入通道数输出通道数卷积核数量n 然而，对于CondConv与DyConv来说，均采用单个注意力标量，这就意味着它的的输出滤波器∈对于输入具有相同的注意力值。换句话说，卷积核 的空间维度、输入通道维度以及输出通道维度均被CondConv与DyConv所忽视了。这就导致了关于核空间的粗糙探索。这可能就是为什么CondConv与DyConv对于大网络的性能增益较低的原因。
此外，相比常规卷积，动态卷积的卷积核参数往往是其n倍。比如CondConv中的n=8，DyConv中的n=4。当动态卷积使用过多时无疑会极大程度提升模型大小。我们发现：当 移除掉CondConv/DyConv中的注意力机制(即=1)后，其性能提升接近于零。比如，对于ResNet18，其性能增益从1.78%/2.51%下降到了0.08%/0.14。
上述发现意味着：动态卷积中的注意力机制起关键性作用，更有效的设计也许可以在模型精度与大小之间得到更好的平衡。
一定程度上讲，ODConv可以视作CondConv的延续，将CondConv中一个维度上的动态特性进行了扩展，同时了考虑了空域、输入通道、输出通道等维度上的动态性，故称之为全维度动态卷积。ODConv通过并行策略采用多维注意力机制沿核空间的四个维度学习互补性注意力。作为一种“即插即用”的操作，它可以轻易的嵌入到现有CNN网络中。ImageNet分类与COCO检测任务上的实验验证了所提ODConv的优异性：即可提升大模型的性能，又可提升轻量型模型的性能，实乃万金油是也！值得一提的是，受益于其改进的特征提取能力，ODConv搭配一个卷积核时仍可取得与现有多核动态卷积相当甚至更优的性能。
3 怎么样？ 3.1 网络结构 基于前述讨论，ODConv通过并行策略引入一种多维注意力机制以对卷积核空间的四个维度学习更灵活的注意力。上图给出CondConv、DyConv以及ODConv的差异图。
延续动态卷积的定义，ODConv可以描述成如下形式：
其中，表示卷积核的注意力标量，,,表示新引入的三个注意力，分别沿空域维度、输入通道维度以及输出通道维度。这四个注意力采用多头注意力模块计算得到。
在ODConv中，对于卷积核，对k*k空域位置上的卷积参数赋予不用的注意力值，见上图a；对不同输入通道的卷积滤波器赋予不同的注意力值，见上图b；对不同输出通道的卷积滤波器赋予不同的注意力值，见上图c；而则对n个整体卷积核赋予不同的值，见上图d。
原则上来讲，这四种类型的注意力是互补的，通过渐进式对卷积沿位置、通道、滤波器以及核等维度乘以不同的注意力将使得卷积操作对于输入存在各个维度的差异性，提供更好的性能以捕获丰富上下文信息。因此，ODCOnv可以大幅提升卷积的特征提取能力；更重要的是，采用更少卷积核的ODConv可以取得与CondConv、DyConv相当甚至更优的性能。
对比前面两种动态卷积的公式可以发现：ODConv是一种更广义的动态卷积。此外，当设置n=1,===1时，ODConv则退化为仅具有滤波器层面的注意力，基于输入对卷积滤波器进行调制后再进行卷积，类似于SE。故SE是ODConv的一个特例。
那么如何实现ODConv的四种类型的注意力值呢？延续CondConv与DyConv，我们同样采用SE风格的注意力模块，但使其具有多个头以计算多种类型注意力，整体结构见上图。具体来说，对于输入先通过GAP收缩为长度为的特征向量，然后采用FC与四个头生成不同类型的注意力值。对于四个头，其维度分别为k*k,×1,×1,n×1。
在训练方面，我们采用了DyConv中的退化策略以加速训练。在具体架构嵌入方面，我们参考DyConv对除第一个卷积外的其他所有卷积进行替换。
3.2 代码实现 import torch import torch.nn as nn import torch.nn.functional as F import torch.autograd class Attention(nn.Module): def __init__(self, in_planes, out_planes, kernel_size, groups=1, reduction=0.0625, kernel_num=4, min_channel=16): super(Attention, self).__init__() attention_channel = max(int(in_planes * reduction), min_channel) self.kernel_size = kernel_size self." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e4074f5c43c4eebd5e8c532edb32eb51/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-01T21:51:28+08:00" />
<meta property="article:modified_time" content="2023-11-01T21:51:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ICLR 2022）ODConv：即插即用的动态卷积 （附代码）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>论文地址：<a href="https://openreview.net/forum?id=DmpCfq6Mg39" title="Omni-Dimensional Dynamic Convolution | OpenReview">Omni-Dimensional Dynamic Convolution | OpenReview</a></p> 
<p>代码地址：<a href="https://github.com/OSVAI/ODConv/blob/main/modules/odconv.py" title="https://github.com/OSVAI/ODConv/blob/main/modules/odconv.py">https://github.com/OSVAI/ODConv/blob/main/modules/odconv.py</a></p> 
<p></p> 
<h3>1.是什么？</h3> 
<p>ODConv是一种动态卷积算法，它的原理是在卷积过程中，根据输入数据的特征动态地调整卷积核的形状和大小，以适应不同的输入数据。具体来说，ODConv通过引入一个可学习的形变模块，根据输入数据的特征动态地调整卷积核的形状和大小，从而提高了卷积神经网络的性能。与CondConv和DyConv不同，ODConv不仅考虑了空间维度、输入通道维度和输出通道维度，还考虑了卷积核的形状和大小，因此可以更好地适应不同的输入数据。</p> 
<h3>2.为什么？</h3> 
<p>常规卷积只有一个静态卷积核且与输入样本无关。对于动态卷积来说，它对多个卷积核进行线性加权，而加权值则与输入有关，这就使得动态卷积具有输入依赖性。它可以描述如下：</p> 
<p class="img-center"><img alt="" height="64" src="https://images2.imgbox.com/e2/78/0pBnkQdi_o.png" width="493"></p> 
<p>尽管动态卷积的定义很简单，但CondConv与DyConv的实现是不相同的，主要体现在计算<img alt="a_{wi}" class="mathcode" src="https://images2.imgbox.com/13/97/iPmdzyyk_o.png">的结构<img alt="\pi_{wi}(x)" class="mathcode" src="https://images2.imgbox.com/9f/e1/egFqPBag_o.png">训练策略以及实施动态卷积的层，这些实现上的差异导致了不同的模型精度、模型大小以及推理效率。</p> 
<ul><li>两者均为<img alt="\pi_{wi}(x)" class="mathcode" src="https://images2.imgbox.com/f3/e3/6MI83ZWn_o.png">采用了类SE架构，但CondConv采用的是Sigmoid，而DyConv采用的是Softmax；</li><li>DyConv采用的退化策略进行训练以抑制Softmax的one-hot输出；</li><li>对于他们嵌入的CNN架构，CondConv替换了最后几个模块的卷积与全连接层，而DyConv则对除第一个卷积外的其他卷积均进行了替换。</li></ul> 
<p>根据动态卷积的公式来看，动态卷积有两个基本元素：</p> 
<ul><li>卷积核<img alt="{W_{1},..,W_{n}}" class="mathcode" src="https://images2.imgbox.com/7a/fa/NC61vMgm_o.png">；</li><li>用于计算注意力{<!-- --><img alt="a_{w1,...,a_{wn}}" class="mathcode" src="https://images2.imgbox.com/86/89/H8292NkH_o.png">}的注意力函数<img alt="\phi _{wi}(x)" class="mathcode" src="https://images2.imgbox.com/72/48/ySz7cPxU_o.png"></li></ul> 
<p>给定n个卷积核，其对应的核空间有以下四个维度：</p> 
<ul><li>空间核尺寸k×k；</li><li>输入通道数<img alt="c_{in}" class="mathcode" src="https://images2.imgbox.com/2a/ac/fHLq568Q_o.png"></li><li>输出通道数<img alt="c_{out}" class="mathcode" src="https://images2.imgbox.com/ea/73/sPZ70jqY_o.png"></li><li>卷积核数量n</li></ul> 
<p>然而，对于CondConv与DyConv来说，<img alt="\phi _{wi}(x)" class="mathcode" src="https://images2.imgbox.com/b6/e2/6gesrzKo_o.png">均采用单个注意力标量<img alt="a_{wi}" class="mathcode" src="https://images2.imgbox.com/7a/5d/ORoA3wGA_o.png">，这就意味着它的的输出滤波器<img alt="W_{i}^{m}" class="mathcode" src="https://images2.imgbox.com/6e/63/S4Docloz_o.png">∈<img alt="R^{k*k*c_{in}}" class="mathcode" src="https://images2.imgbox.com/b3/ad/ttQPm1ML_o.png">对于输入具有相同的注意力值。换句话说，<strong>卷积核</strong> <img alt="W_{i}" class="mathcode" src="https://images2.imgbox.com/be/98/kU1aE93r_o.png"><strong>的空间维度、输入通道维度以及输出通道维度均被CondConv与DyConv所忽视了</strong>。这就导致了关于核空间的<strong>粗糙探索</strong>。这可能就是<strong>为什么CondConv与DyConv对于大网络的性能增益较低</strong>的原因。</p> 
<p>此外，相比常规卷积，动态卷积的卷积核参数往往是其n倍。比如CondConv中的n=8，DyConv中的n=4。当动态卷积使用过多时无疑会极大程度提升模型大小。我们发现：当 移除掉CondConv/DyConv中的注意力机制(即<img alt="a_{wi}" class="mathcode" src="https://images2.imgbox.com/19/45/XlYYxfix_o.png">=1)后，其性能提升接近于零。比如，对于ResNet18，其性能增益从1.78%/2.51%下降到了0.08%/0.14。</p> 
<p>上述发现意味着：<strong>动态卷积中的注意力机制起关键性作用</strong>，更有效的设计也许可以在模型精度与大小之间得到更好的平衡。</p> 
<p>一定程度上讲，ODConv可以视作CondConv的延续，将CondConv中一个维度上的动态特性进行了扩展，同时了考虑了空域、输入通道、输出通道等维度上的动态性，故称之为全维度动态卷积。ODConv通过并行策略采用多维注意力机制沿核空间的四个维度学习互补性注意力。作为一种“即插即用”的操作，它可以轻易的嵌入到现有CNN网络中。ImageNet分类与COCO检测任务上的实验验证了所提ODConv的优异性：即可提升大模型的性能，又可提升轻量型模型的性能，实乃万金油是也！值得一提的是，受益于其改进的特征提取能力，<strong>ODConv搭配一个卷积核时仍可取得与现有多核动态卷积相当甚至更优的性能</strong>。</p> 
<h3>3 怎么样？</h3> 
<h4>3.1 网络结构</h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/15/e1/USWW6vzn_o.png"></p> 
<p>基于前述讨论，ODConv通过并行策略引入一种多维注意力机制以对卷积核空间的四个维度学习更灵活的注意力。上图给出CondConv、DyConv以及ODConv的差异图。</p> 
<p>延续动态卷积的定义，ODConv可以描述成如下形式：</p> 
<p><img alt="" height="59" src="https://images2.imgbox.com/19/af/y7dveVv6_o.png" width="1003"></p> 
<p>其中，<img alt="a_{wi}" class="mathcode" src="https://images2.imgbox.com/ba/29/tznEMWAb_o.png">表示卷积核<img alt="W_{i}" class="mathcode" src="https://images2.imgbox.com/7b/c3/0UJlO5E6_o.png">的注意力标量，<img alt="a_{si}\epsilon R^{k*k}" class="mathcode" src="https://images2.imgbox.com/c3/02/UYdBVmdH_o.png">,<img alt="a_{ci}\epsilon R^{c_{in}}" class="mathcode" src="https://images2.imgbox.com/3b/0b/8bHkOLic_o.png">,<img alt="a_{fi}\epsilon R^{c_{out}}" class="mathcode" src="https://images2.imgbox.com/7c/ea/i0BSmsQG_o.png">表示新引入的三个注意力，分别沿空域维度、输入通道维度以及输出通道维度。这四个注意力采用多头注意力模块<img alt="\pi_{i}(x)" class="mathcode" src="https://images2.imgbox.com/0d/4f/rmzjRy9G_o.png">计算得到。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/13/4f/7e2oVuwE_o.png"></p> 
<p>在ODConv中，对于卷积核<img alt="W_{i}" class="mathcode" src="https://images2.imgbox.com/a0/a4/V4D5toYZ_o.png">，<img alt="a_{si}" class="mathcode" src="https://images2.imgbox.com/d0/e0/RGUE6Q4J_o.png">对k*k空域位置上的卷积参数赋予不用的注意力值，见上图a；<img alt="a_{ci}" class="mathcode" src="https://images2.imgbox.com/13/91/Tr8CdzPc_o.png">对不同输入通道的卷积滤波器赋予不同的注意力值，见上图b；<img alt="a_{fi}" class="mathcode" src="https://images2.imgbox.com/86/cb/r8uZVbZT_o.png">对不同输出通道的卷积滤波器赋予不同的注意力值，见上图c；而<img alt="a_{wi}" class="mathcode" src="https://images2.imgbox.com/7a/78/PaE5Klae_o.png">则对n个整体卷积核赋予不同的值，见上图d。</p> 
<p>原则上来讲，这四种类型的注意力是互补的，通过渐进式对卷积<img alt="W_{i}" class="mathcode" src="https://images2.imgbox.com/9e/ce/a1Y8weZm_o.png">沿位置、通道、滤波器以及核等维度乘以不同的注意力将使得卷积操作对于输入存在各个维度的差异性，提供更好的性能以捕获丰富上下文信息。因此，ODCOnv可以大幅提升卷积的特征提取能力；更重要的是，采用更少卷积核的ODConv可以取得与CondConv、DyConv相当甚至更优的性能。</p> 
<p>对比前面两种动态卷积的公式可以发现：ODConv是一种更广义的动态卷积。此外，当设置n=1,<img alt="a_{s1}" class="mathcode" src="https://images2.imgbox.com/29/33/zozJPSGZ_o.png">=<img alt="a_{c1}" class="mathcode" src="https://images2.imgbox.com/0c/f5/gjRZ3ozc_o.png">=<img alt="a_{w1}" class="mathcode" src="https://images2.imgbox.com/17/80/aT9JPHmF_o.png">=1时，ODConv则退化为仅具有滤波器层面的注意力，基于输入对卷积滤波器进行调制后再进行卷积，类似于SE。故SE是ODConv的一个特例。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/96/04/zX85MTQK_o.png"></p> 
<p></p> 
<p>那么如何实现ODConv的四种类型的注意力值呢？延续CondConv与DyConv，我们同样采用SE风格的注意力模块，但使其具有多个头以计算多种类型注意力，整体结构见上图。具体来说，对于输入先通过GAP收缩为长度为<img alt="c_{in}" class="mathcode" src="https://images2.imgbox.com/00/3d/3oyx9ulS_o.png">的特征向量，然后采用FC与四个头生成不同类型的注意力值。对于四个头，其维度分别为k*k,<img alt="c_{in}" class="mathcode" src="https://images2.imgbox.com/45/33/xPBHWclj_o.png">×1,<img alt="c_{out}" class="mathcode" src="https://images2.imgbox.com/d8/81/gZFxysWn_o.png">×1,n×1。</p> 
<p>在训练方面，我们采用了DyConv中的退化策略以加速训练。在具体架构嵌入方面，我们参考DyConv对除第一个卷积外的其他所有卷积进行替换。</p> 
<h4>3.2 代码实现</h4> 
<pre><code class="language-python">import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.autograd


class Attention(nn.Module):
    def __init__(self, in_planes, out_planes, kernel_size, groups=1, reduction=0.0625, kernel_num=4, min_channel=16):
        super(Attention, self).__init__()
        attention_channel = max(int(in_planes * reduction), min_channel)
        self.kernel_size = kernel_size
        self.kernel_num = kernel_num
        self.temperature = 1.0

        self.avgpool = nn.AdaptiveAvgPool2d(1)
        self.fc = nn.Conv2d(in_planes, attention_channel, 1, bias=False)
        self.bn = nn.BatchNorm2d(attention_channel)
        self.relu = nn.ReLU(inplace=True)

        self.channel_fc = nn.Conv2d(attention_channel, in_planes, 1, bias=True)
        self.func_channel = self.get_channel_attention

        if in_planes == groups and in_planes == out_planes:  # depth-wise convolution
            self.func_filter = self.skip
        else:
            self.filter_fc = nn.Conv2d(attention_channel, out_planes, 1, bias=True)
            self.func_filter = self.get_filter_attention

        if kernel_size == 1:  # point-wise convolution
            self.func_spatial = self.skip
        else:
            self.spatial_fc = nn.Conv2d(attention_channel, kernel_size * kernel_size, 1, bias=True)
            self.func_spatial = self.get_spatial_attention

        if kernel_num == 1:
            self.func_kernel = self.skip
        else:
            self.kernel_fc = nn.Conv2d(attention_channel, kernel_num, 1, bias=True)
            self.func_kernel = self.get_kernel_attention

        self._initialize_weights()

    def _initialize_weights(self):
        for m in self.modules():
            if isinstance(m, nn.Conv2d):
                nn.init.kaiming_normal_(m.weight, mode='fan_out', nonlinearity='relu')
                if m.bias is not None:
                    nn.init.constant_(m.bias, 0)
            if isinstance(m, nn.BatchNorm2d):
                nn.init.constant_(m.weight, 1)
                nn.init.constant_(m.bias, 0)

    def update_temperature(self, temperature):
        self.temperature = temperature

    @staticmethod
    def skip(_):
        return 1.0

    def get_channel_attention(self, x):
        channel_attention = torch.sigmoid(self.channel_fc(x).view(x.size(0), -1, 1, 1) / self.temperature)
        return channel_attention

    def get_filter_attention(self, x):
        filter_attention = torch.sigmoid(self.filter_fc(x).view(x.size(0), -1, 1, 1) / self.temperature)
        return filter_attention

    def get_spatial_attention(self, x):
        spatial_attention = self.spatial_fc(x).view(x.size(0), 1, 1, 1, self.kernel_size, self.kernel_size)
        spatial_attention = torch.sigmoid(spatial_attention / self.temperature)
        return spatial_attention

    def get_kernel_attention(self, x):
        kernel_attention = self.kernel_fc(x).view(x.size(0), -1, 1, 1, 1, 1)
        kernel_attention = F.softmax(kernel_attention / self.temperature, dim=1)
        return kernel_attention

    def forward(self, x):
        x = self.avgpool(x)
        x = self.fc(x)
        x = self.bn(x)
        x = self.relu(x)
        return self.func_channel(x), self.func_filter(x), self.func_spatial(x), self.func_kernel(x)


class ODConv2d(nn.Module):
    def __init__(self, in_planes, out_planes, kernel_size, stride=1, padding=0, dilation=1, groups=1,
                 reduction=0.0625, kernel_num=4):
        super(ODConv2d, self).__init__()
        self.in_planes = in_planes
        self.out_planes = out_planes
        self.kernel_size = kernel_size
        self.stride = stride
        self.padding = padding
        self.dilation = dilation
        self.groups = groups
        self.kernel_num = kernel_num
        self.attention = Attention(in_planes, out_planes, kernel_size, groups=groups,
                                   reduction=reduction, kernel_num=kernel_num)
        self.weight = nn.Parameter(torch.randn(kernel_num, out_planes, in_planes//groups, kernel_size, kernel_size),
                                   requires_grad=True)
        self._initialize_weights()

        if self.kernel_size == 1 and self.kernel_num == 1:
            self._forward_impl = self._forward_impl_pw1x
        else:
            self._forward_impl = self._forward_impl_common

    def _initialize_weights(self):
        for i in range(self.kernel_num):
            nn.init.kaiming_normal_(self.weight[i], mode='fan_out', nonlinearity='relu')

    def update_temperature(self, temperature):
        self.attention.update_temperature(temperature)

    def _forward_impl_common(self, x):
        # Multiplying channel attention (or filter attention) to weights and feature maps are equivalent,
        # while we observe that when using the latter method the models will run faster with less gpu memory cost.
        channel_attention, filter_attention, spatial_attention, kernel_attention = self.attention(x)
        batch_size, in_planes, height, width = x.size()
        x = x * channel_attention
        x = x.reshape(1, -1, height, width)
        aggregate_weight = spatial_attention * kernel_attention * self.weight.unsqueeze(dim=0)
        aggregate_weight = torch.sum(aggregate_weight, dim=1).view(
            [-1, self.in_planes // self.groups, self.kernel_size, self.kernel_size])
        output = F.conv2d(x, weight=aggregate_weight, bias=None, stride=self.stride, padding=self.padding,
                          dilation=self.dilation, groups=self.groups * batch_size)
        output = output.view(batch_size, self.out_planes, output.size(-2), output.size(-1))
        output = output * filter_attention
        return output

    def _forward_impl_pw1x(self, x):
        channel_attention, filter_attention, spatial_attention, kernel_attention = self.attention(x)
        x = x * channel_attention
        output = F.conv2d(x, weight=self.weight.squeeze(dim=0), bias=None, stride=self.stride, padding=self.padding,
                          dilation=self.dilation, groups=self.groups)
        output = output * filter_attention
        return output

    def forward(self, x):
        return self._forward_impl(x)</code></pre> 
<p> 参考：</p> 
<p><a class="link-info" href="https://blog.csdn.net/weixin_43227262/article/details/130239826?spm=1018.2226.3001.9630.1&amp;extra%5Btitle%5D=ODConv%E8%AF%A6%E8%A7%A3&amp;extra%5Butm_medium%5D=distribute.pc_search_result.none-task-cask-2~all~insert_cask~default-1-null.142%5Ev96%5Epc_search_result_base2&amp;extra%5Butm_source%5D=vip_chatgpt_common_search_pc_result" title="ODConv详解">ODConv详解</a></p> 
<p><a class="link-info" href="https://blog.csdn.net/amusi1994/article/details/122995091?spm=1018.2226.3001.9630.1&amp;extra%5Btitle%5D=ICLR%202022%20%7C%20%E6%B6%A8%E7%82%B9%E7%A5%9E%E5%99%A8%EF%BC%81Intel%E6%8F%90%E5%87%BAODConv%EF%BC%9A%E5%8D%B3%E6%8F%92%E5%8D%B3%E7%94%A8%E7%9A%84%E5%8A%A8%E6%80%81%E5%8D%B7%E7%A7%AF&amp;extra%5Butm_medium%5D=distribute.pc_search_result.none-task-cask-2~all~insert_cask~default-1-null.142%5Ev96%5Epc_search_result_base2&amp;extra%5Butm_source%5D=vip_chatgpt_common_search_pc_result" title="ICLR 2022 | 涨点神器！Intel提出ODConv：即插即用的动态卷积">ICLR 2022 | 涨点神器！Intel提出ODConv：即插即用的动态卷积</a></p> 
<p><a class="link-info" href="https://zhuanlan.zhihu.com/p/468466504" rel="nofollow" title="致敬CondConv！Intel提出即插即用的“万金油”动态卷积ODConv">致敬CondConv！Intel提出即插即用的“万金油”动态卷积ODConv</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/513f72e1f44f0ada541ce39742e3244c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mAP@.5和mAP@.5:0.95的区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5b5e7de92f320ae0dc2c2e92ae2d0609/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">图像二值化阈值调整——OTSU算法（大津法/最大类间方差法）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>