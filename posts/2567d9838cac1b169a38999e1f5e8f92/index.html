<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java（多）线程中注入Spring的Bean - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java（多）线程中注入Spring的Bean" />
<meta property="og:description" content="问题说明 今天在web应用中用到了Java多线程的技术来并发处理一些业务，但在执行时一直会报NullPointerException的错误，问题定位了一下发现是线程中的Spring bean没有被注入，bean对象的值为null。 原因分析 web容器在启动应用时，并没有提前将线程中的bean注入（在线程启动前，web容易也是无法感知的） 解决方案 方法有多种，网上也看到了不少。 1. 使用static声明变量 可参见 引用 http://blog.csdn.net/bjamosgavin/article/details/6125497 但这个方法自己试了一下但是没有成功。。。 2. 把线程设置为主程序的内部类 这也是一种简单的方法，主程序在web容器加载时肯定是可以注入Spring bean的，那么将线程的实现类放在主程序的类中便可以“共享”Spring的bean，（当然，这需要提前把线程中的需要用到的bean定义在外层的类中）。 具体操作方法，就是将生成线程的线程池定义在主程序的类中，每个线程的实现类作为内部类也定义在主程序中。这个方法自己试过，是可以的。 3. 使用静态方法直接取的容器中的spring对象 这个方法稍微专业点，可以线程的分发与线程的实现分离出来。在每个线程中使用静态方法直接取的容器中的spring对象。 使用静态方法获取容器中的spring对象可以参见 引用 http://littie1987.iteye.com/blog/937877， 或者http://my.oschina.net/skyline520/blog/181158?p={{page}} 但一定要记住，你定义这个工具类也要配置成spring中的bean! 下面贴一下我在使用时的代码 （1）定义工具类 public class SpringApplicationContextHolder implements ApplicationContextAware { private static ApplicationContext context; @Override public void setApplicationContext(ApplicationContext context) throws BeansException { SpringApplicationContextHolder.context = context; } public static Object getSpringBean(String beanName) { notEmpty(beanName, &#34;bean name is required&#34;); return context==null?null:context.getBean(beanName); } public static String[] getBeanDefinitionNames() { return context." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2567d9838cac1b169a38999e1f5e8f92/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-02-27T16:42:00+08:00" />
<meta property="article:modified_time" content="2016-02-27T16:42:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java（多）线程中注入Spring的Bean</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p><strong>问题说明</strong> <br>今天在web应用中用到了Java多线程的技术来并发处理一些业务，但在执行时一直会报NullPointerException的错误，问题定位了一下发现是线程中的Spring bean没有被注入，bean对象的值为null。 <br><br><strong>原因分析</strong> <br>web容器在启动应用时，并没有提前将线程中的bean注入（在线程启动前，web容易也是无法感知的） <br><br><strong>解决方案</strong> <br>方法有多种，网上也看到了不少。 <br>1. 使用static声明变量 <br>可参见 </p> 
 <div class="quote_title">
   引用 
 </div> 
 <div class="quote_div"> 
  <br>http://blog.csdn.net/bjamosgavin/article/details/6125497  
 </div> 
 <p> <br>但这个方法自己试了一下但是没有成功。。。 <br>2. 把线程设置为主程序的内部类 <br>这也是一种简单的方法，主程序在web容器加载时肯定是可以注入Spring bean的，那么将线程的实现类放在主程序的类中便可以“共享”Spring的bean，（当然，这需要提前把线程中的需要用到的bean定义在外层的类中）。 <br>具体操作方法，就是将生成线程的线程池定义在主程序的类中，每个线程的实现类作为内部类也定义在主程序中。这个方法自己试过，是可以的。 <br>3. 使用静态方法直接取的容器中的spring对象 <br>这个方法稍微专业点，可以线程的分发与线程的实现分离出来。在每个线程中使用静态方法直接取的容器中的spring对象。 <br>使用静态方法获取容器中的spring对象可以参见 </p> 
 <div class="quote_title">
   引用 
 </div> 
 <div class="quote_div"> 
  <br>http://littie1987.iteye.com/blog/937877，  
  <br>或者http://my.oschina.net/skyline520/blog/181158?p={<!-- -->{page}}  
 </div> 
 <p> <br>但一定要记住，你定义这个工具类也要配置成spring中的bean! <br><br>下面贴一下我在使用时的代码 <br>（1）定义工具类 </p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">public</span> <span style="color:#0000ff;">class</span> SpringApplicationContextHolder <span style="color:#0000ff;">implements</span><span style="color:#000000;"> ApplicationContextAware {  
  
    </span><span style="color:#0000ff;">private</span> <span style="color:#0000ff;">static</span><span style="color:#000000;"> ApplicationContext context;  
  
    @Override  
    </span><span style="color:#0000ff;">public</span> <span style="color:#0000ff;">void</span> setApplicationContext(ApplicationContext context) <span style="color:#0000ff;">throws</span><span style="color:#000000;"> BeansException {  
        SpringApplicationContextHolder.context </span>=<span style="color:#000000;"> context;  
    }  
  
     
    </span><span style="color:#0000ff;">public</span> <span style="color:#0000ff;">static</span><span style="color:#000000;"> Object getSpringBean(String beanName) {  
        notEmpty(beanName, </span>"bean name is required"<span style="color:#000000;">);  
        </span><span style="color:#0000ff;">return</span> context==<span style="color:#0000ff;">null</span>?<span style="color:#0000ff;">null</span><span style="color:#000000;">:context.getBean(beanName);  
    }  
  
    </span><span style="color:#0000ff;">public</span> <span style="color:#0000ff;">static</span><span style="color:#000000;"> String[] getBeanDefinitionNames() {  
        </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> context.getBeanDefinitionNames();  
    }  </span></pre> 
 </div> 
 <p>在Spring中注册工具类的bean </p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">bean </span><span style="color:#ff0000;">class</span><span style="color:#0000ff;">="com.xxx.spring.SpringApplicationContextHolder"</span> <span style="color:#0000ff;">/&gt;</span>  </pre> 
 </div> 
 <p>线程中获取bean </p> 
 <div class="cnblogs_code"> 
  <pre>UserRepo user = (UserRepo) SpringApplicationContextHolder.getSpringBean("userRepo"); </pre> 
 </div> 
 <p> </p> 
 <p><span style="font-family:Helvetica, Tahoma, Arial, sans-serif;line-height:25.2px;"> </span></p> 
</div> 
<p>转载于:https://www.cnblogs.com/vinozly/p/5223147.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/95dfa833cf7da13277cdda4a00a69937/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">wireshark过滤rtmp协议</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/588ad0d465c4904a0a813d6ce4c84dcb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c#如何采集需要登录的页面</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>