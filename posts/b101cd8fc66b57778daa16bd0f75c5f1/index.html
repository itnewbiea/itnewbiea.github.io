<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>printf的实现原理 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="printf的实现原理" />
<meta property="og:description" content="要了解变参函数的实现，首先我们的弄清楚几个问题：
1: 该函数有几个参数。
2: 该函数怎样去访问这些参数。
3: 在访问完成后，如何从堆栈中释放这些参数。
函数变参 对于c语言，它的调用规则遵循_cdedl调用规则。 在_cdedl规则中：
1. 参数从右到左依次入栈
2. 调用者负责清理堆栈
3. 参数的数量类型不会导致编译阶段的错误
printf的声明： int _cdecl printf(const char* format, …); // _cdecl是C和C＋＋程序的缺省调用方式
栈由高地址向低地址生长，又参数从右到左依次入栈，所以栈的高地址是printf最右边的参数。以
printf(&#34;%d %f %c %s\n&#34;, 3, 5.40, A, &#34;hello world&#34;);为例，其栈的结构如下：
在被调用的函数内部我怎么知道变参的类型是什么呢？对于printf函数来说，调用者通过第一个fmt参数中的%&#43;格式字符的方式通知了被调用者（printf的实现者）。
格式解析 扫描format参数里的字符，如果是普通字符就打印输出，如果是%，就说明后面有可能是格式字符，需要进行检测，然后从栈低（其实是第一个参数的位置）弹出指定类型的数据，按照指定格式（十进制、十六进制、指定宽度、指定精度等等）进行输出。基本上是一个字符串解析的过程。
typedef char *va_list;
#define _INTSIZEOF(n) ( (sizeof(n) &#43; sizeof(int) - 1) &amp; ~(sizeof(int) - 1) ) /* 1 */
#define va_start(va_list ap, format) ( ap = (va_list)&amp;format&#43; _INTSIZEOF(format) ) /* 2 */ #define va_arg(va_list ap,type) ( *(type*)((ap &#43;= _INTSIZEOF(type)) -_INTSIZEOF(type)) ) /* 3 */" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b101cd8fc66b57778daa16bd0f75c5f1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-07T18:25:32+08:00" />
<meta property="article:modified_time" content="2020-09-07T18:25:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">printf的实现原理</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>      要了解变参函数的实现，首先我们的弄清楚几个问题：<br> 1:  该函数有几个参数。<br> 2:  该函数怎样去访问这些参数。<br> 3:  在访问完成后，如何从堆栈中释放这些参数。</p> 
<h3>函数变参</h3> 
<p>     对于c语言，它的调用规则遵循_cdedl调用规则。 在_cdedl规则中：</p> 
<blockquote> 
 <p>    1.  参数从右到左依次入栈<br>     2.  调用者负责清理堆栈<br>     3.  参数的数量类型不会导致编译阶段的错误</p> 
</blockquote> 
<p>    printf的声明：   int _cdecl printf(const char* format, …);      // _cdecl是C和C＋＋程序的缺省调用方式</p> 
<p>     栈由高地址向低地址生长，又参数从右到左依次入栈，所以栈的高地址是printf最右边的参数。以</p> 
<p>printf("%d %f %c %s\n", 3, 5.40, A, "hello world");为例，其栈的结构如下：</p> 
<p><img alt="" height="675" src="https://images2.imgbox.com/2a/70/GPhQYC0V_o.png" width="500"></p> 
<p>       在被调用的函数内部我怎么知道变参的类型是什么呢？对于printf函数来说，调用者通过第一个fmt参数中的%+格式字符的方式通知了被调用者（printf的实现者）。</p> 
<h3> 格式解析</h3> 
<p>       扫描format参数里的字符，如果是普通字符就打印输出，如果是%，就说明后面有可能是格式字符，需要进行检测，然后从栈低（其实是第一个参数的位置）弹出指定类型的数据，按照指定格式（十进制、十六进制、指定宽度、指定精度等等）进行输出。基本上是一个字符串解析的过程。</p> 
<blockquote> 
 <p>typedef char *va_list;<br> #define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1) )                          /* 1 */<br> #define va_start(va_list  ap, format) ( ap = (va_list)&amp;format+ _INTSIZEOF(format) )           /* 2 */     <br> #define va_arg(va_list  ap,type)  <br>               ( *(type*)((ap += _INTSIZEOF(type)) -_INTSIZEOF(type)) )                                   /* 3 */<br> #define va_end(va_list  ap)  ( ap = (va_list)0 )                                                                      /* 4 */</p> 
</blockquote> 
<p>1:  将sizeof(n)按sizeof(int)对齐</p> 
<p>2:  初始化参数指针ap，将format右边第一个参数地址赋值给ap</p> 
<p>3: type用来指名当前参数类型, 获得ap指向参数的值，同时使ap指向下一个参数</p> 
<p>4: 在有些简单的实现中不起任何作用，在有些实现中可能会把ap改成无效值，这里把ap指针指向了 NULL</p> 
<p> </p> 
<blockquote> 
 <p> c标准要求在同一个函数中va_start 和va_end 要配对的出现。那么到现在，处理多参数函数的步骤就是<br> 1：首先是要保证该函数至少有一个参数，同时用...参数申明函数是变参函数。<br> 2：在函数内部以va_start(ap,format)宏初始化参数指针。<br> 3：用va_arg(ap,type)从左到右逐个取参数值。</p> 
</blockquote> 
<p> printf()格式转换的一般形式如下：</p> 
<blockquote> 
 <p>%[flags][width][.prec][type]<br> prec有一下几种情况：<br>                     正整数的最小位数<br>                     在浮点数中表示的小数位数<br>                     %g格式表示有效为的最大值<br>                     %s格式表示字符串的最大长度<br>                     若为*符号表示下个参数值为最大长度<br> width：为输出的最小长度，如果这个输出参数并非数值，而是*符号，则表示以下一个参数当做输出长度。</p> 
</blockquote> 
<p> </p> 
<p> 另附一些比较有用的链接：</p> 
<p><a href="https://www.zhihu.com/question/28749911/answer/42981235" rel="nofollow">printf的原理</a></p> 
<p><a href="https://www.cnblogs.com/saolv/p/7779364.html" rel="nofollow">printf 函数的实现原理</a></p> 
<p><a href="https://www.cnblogs.com/cpoint/p/3368993.html" rel="nofollow">C语言中可变参数函数实现原理</a></p> 
<p><a href="https://blog.csdn.net/sugarbliss/article/details/80230710?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.channel_param">printf()用法详解</a></p> 
<p><a href="https://blog.csdn.net/plm199513100/article/details/104905990">printf打印函数的原理浅析</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/30c812f084491ce1df3c4c6977c42ac9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python爬虫——片库网 爬取 视频</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0b140c125c8016b22e40fc02061469b6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">文件的读写基本操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>