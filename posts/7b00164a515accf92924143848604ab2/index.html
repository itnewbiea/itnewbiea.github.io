<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JDK1.8 新特性（一）【默认方法、静态方法和Lambda表达式】 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JDK1.8 新特性（一）【默认方法、静态方法和Lambda表达式】" />
<meta property="og:description" content="前言 今天学习Java8 新特性，主要是之前在学习 Scala、JavaFX 中遇到一些 Lambda 表达式，感觉 lambda 表达式确实很简洁，很有必要学一学，重点是提升逼格，让别人看不懂才是最装的。
目录
前言
1、接口的默认方法与静态方法
编写接口
编写接口的实现类
测试
2、Lambda表达式（重点）
2.1、Lambda 表达式规范
2.1.1、函数接口的定义
2.1.2、Java 内置的函数接口 2.2、Lambda 基础语法
2.2.1、无参方法调用
（1）编写函数接口
（2）使用 lambda 2.2.2、有参方法调用
（1）编写函数接口
（2）使用 lambda 2.3、Lambda 的精简写法
2.3.1、无参方法
2.3.2、有参方法
练习
2.4、Lambda 实战
forEach
集合排序
1、接口的默认方法与静态方法 什么是普通方法？
我们可以把 Java 中的方法看成两类：普通方法（有方法体的）和抽象方法（没有方法体的，需要子类去实现的，比如接口、抽象类）。
JDK8 之前，Java 中接口 Interface 之中可以定义变量和方法：
变量 必须是 public、static、final 的方法 必须是 public、abstract 的 而且这些修饰符都是默认的，也就是不需要我们写。
从JDK8 开始 支持使用 static 和 default 来修饰方法，可以写方法体，不需要子类重写被 static 和 default修饰的方法。
接口中定义的默认方法只有子类对象才能调用，而接口中定义的静态方法只有接口类才能调用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/7b00164a515accf92924143848604ab2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-13T08:12:23+08:00" />
<meta property="article:modified_time" content="2023-11-13T08:12:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JDK1.8 新特性（一）【默认方法、静态方法和Lambda表达式】</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言 </h2> 
<p>        今天学习Java8 新特性，主要是之前在学习 Scala、JavaFX 中遇到一些 Lambda 表达式，感觉 lambda 表达式确实很简洁，很有必要学一学，重点是提升逼格，让别人看不懂才是最装的。</p> 
<p><strong>目录</strong></p> 
<p style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p style="margin-left:0px;"><a href="#1%E3%80%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95" rel="nofollow">1、接口的默认方法与静态方法</a></p> 
<p style="margin-left:40px;"><a href="#%E7%BC%96%E5%86%99%E6%8E%A5%E5%8F%A3" rel="nofollow">编写接口</a></p> 
<p style="margin-left:40px;"><a href="#%E7%BC%96%E5%86%99%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB" rel="nofollow">编写接口的实现类</a></p> 
<p style="margin-left:40px;"><a href="#%E6%B5%8B%E8%AF%95" rel="nofollow">测试</a></p> 
<p style="margin-left:0px;"><a href="#2%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89" rel="nofollow">2、Lambda表达式（重点）</a></p> 
<p style="margin-left:40px;"><a href="#2.1%E3%80%81Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%84%E8%8C%83" rel="nofollow">2.1、Lambda 表达式规范</a></p> 
<p style="margin-left:80px;"><a href="#2.1.1%E3%80%81%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">2.1.1、函数接口的定义</a></p> 
<p style="margin-left:80px;"><a href="#2.1.2%E3%80%81Java%20%E5%86%85%E7%BD%AE%E7%9A%84%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3%C2%A0" rel="nofollow">2.1.2、Java 内置的函数接口 </a></p> 
<p style="margin-left:40px;"><a href="#2.2%E3%80%81Lambda%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95" rel="nofollow">2.2、Lambda 基础语法</a></p> 
<p style="margin-left:80px;"><a href="#2.2.1%E3%80%81%E6%97%A0%E5%8F%82%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8" rel="nofollow">2.2.1、无参方法调用</a></p> 
<p style="margin-left:120px;"><a href="#%EF%BC%881%EF%BC%89%E7%BC%96%E5%86%99%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3" rel="nofollow">（1）编写函数接口</a></p> 
<p style="margin-left:120px;"><a href="#%EF%BC%882%EF%BC%89%E4%BD%BF%E7%94%A8%20lambda%C2%A0" rel="nofollow">（2）使用 lambda </a></p> 
<p style="margin-left:80px;"><a href="#2.2.2%E3%80%81%E6%9C%89%E5%8F%82%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8" rel="nofollow">2.2.2、有参方法调用</a></p> 
<p style="margin-left:120px;"><a href="#%EF%BC%881%EF%BC%89%E7%BC%96%E5%86%99%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3" rel="nofollow">（1）编写函数接口</a></p> 
<p style="margin-left:120px;"><a href="#%EF%BC%882%EF%BC%89%E4%BD%BF%E7%94%A8%20lambda%C2%A0" rel="nofollow">（2）使用 lambda </a></p> 
<p style="margin-left:40px;"><a href="#2.3%E3%80%81Lambda%20%E7%9A%84%E7%B2%BE%E7%AE%80%E5%86%99%E6%B3%95" rel="nofollow">2.3、Lambda 的精简写法</a></p> 
<p style="margin-left:80px;"><a href="#2.3.1%E3%80%81%E6%97%A0%E5%8F%82%E6%96%B9%E6%B3%95" rel="nofollow">2.3.1、无参方法</a></p> 
<p style="margin-left:80px;"><a href="#2.3.2%E3%80%81%E6%9C%89%E5%8F%82%E6%96%B9%E6%B3%95" rel="nofollow">2.3.2、有参方法</a></p> 
<p style="margin-left:80px;"><a href="#%E7%BB%83%E4%B9%A0" rel="nofollow">练习</a></p> 
<p style="margin-left:40px;"><a href="#2.4%E3%80%81Lambda%20%E5%AE%9E%E6%88%98" rel="nofollow">2.4、Lambda 实战</a></p> 
<p style="margin-left:80px;"><a href="#forEach" rel="nofollow">forEach</a></p> 
<p style="margin-left:80px;"><a href="#%E9%9B%86%E5%90%88%E6%8E%92%E5%BA%8F" rel="nofollow">集合排序</a></p> 
<hr> 
<p> </p> 
<h2>1、接口的默认方法与静态方法</h2> 
<p>什么是普通方法？</p> 
<p>我们可以把 Java 中的方法看成两类：普通方法（有方法体的）和抽象方法（没有方法体的，需要子类去实现的，比如接口、抽象类）。</p> 
<p>JDK8 之前，Java 中接口 Interface 之中可以定义变量和方法：</p> 
<ul><li><strong>变量 </strong>必须是 public、static、final 的</li><li><strong>方法 </strong>必须是 public、abstract 的</li></ul> 
<p>而且这些修饰符都是默认的，也就是不需要我们写。</p> 
<p>从JDK8 开始 <strong>支持使用 static 和 default 来修饰方法</strong>，<strong>可以写方法体</strong>，<strong>不需要子类重写被 static 和 default修饰的方法</strong>。</p> 
<p>接口中定义的默认方法只有子类对象才能调用，而接口中定义的静态方法只有接口类才能调用。</p> 
<h3>编写接口</h3> 
<pre><code class="language-java">public interface JDK8Interface {
    /*
     * 默认就是 public abstract 的,不需要加修饰符
    */
    void add();
    /*
     * JDK8 提供 默认的方法
     */
    default void get(){
        System.out.println("get");
    }

    /*
     * JDK8 提供的静态方法 只能通过 接口名.方法名来 调用
     */
    static void del(){
        System.out.println("del");
    }
}
</code></pre> 
<h3>编写接口的实现类</h3> 
<pre><code class="language-java">public class JDK8InterfaceImpl implements JDK8Interface {

    @Override
    public void add() {
        System.out.println("add");
    }
    
}
</code></pre> 
<h3>测试</h3> 
<pre><code class="language-java">public class Test01 {
    public static void main(String[] args) {
        JDK8InterfaceImpl jdk8Interface = new JDK8InterfaceImpl();
        jdk8Interface.add();
        jdk8Interface.get();
        JDK8Interface.del();    
    }
}</code></pre> 
<p>我们可以得到这样一个结论：接口中定义的默认方法只有子类对象才能调用，而接口中定义的静态方法只有接口类才能调用。</p> 
<h2>2、Lambda表达式（重点）</h2> 
<p>什么是 Lambda 表达式？</p> 
<p>Lanmbda 表达式是一个匿名函数，即没有函数名的函数，基于数学中的 λ 而得名。</p> 
<p>优点：简化匿名内部类的调用，减少代码量。</p> 
<p>缺点：不好调试</p> 
<p>编写接口：</p> 
<pre><code class="language-java">public interface OrderService {
    void get();
}</code></pre> 
<p> 测试：</p> 
<pre><code class="language-java">public class Test02 {
    public static void main(String[] args) {

        // 1. 通过匿名内部类创建一个实现OrderService接口的子类
        OrderService service = new OrderService() {
            @Override
            public void get() {
                System.out.println("get");
            }
        };
        service.get();

        // 2. lambda 表达式  括号代表参数列表
        ((OrderService) ()-&gt; System.out.println("get")).get();

        // 3. 同样是lambda表达式
        new Thread(()-&gt; System.out.println("get")).start();

    }
}</code></pre> 
<p>注意：这里的接口只能有一个抽象方法！具体原因看下面。</p> 
<h3>2.1、Lambda 表达式规范</h3> 
<h4>2.1.1、函数接口的定义</h4> 
<p>Java 中使用 Lambda 表达式依赖于函数接口。我们在 new 一个对象，需要传入的参数是接口类型时，可以使用该 接口的实现类，也可以直接构造一个匿名内部类（这里我们就可以通过 lambda 表达式来简化代码，提高开发效率，主要是看起来是真的舒服）。</p> 
<ul><li>在接口当中只允许存在一个抽象方法。</li><li>允许使用 default 和 static 修饰的方法。</li><li>使用注解 @FunctionalInterface 来标记该接口为函数接口（接口中只包含一个方法的叫做函数接口），我们可以发现，如果接口中出现了超过1个的抽象方法代码就会爆红。</li><li>可以定义 Object 类中的方法</li></ul> 
<p>下面是我自定义的一个函数接口。</p> 
<pre><code class="language-java">/**
 * 函数接口 只允许包含一个抽象方法
 * 4. 使用注解 @FunctionalInterface 来标注着是一个函数接口
 */
@FunctionalInterface
public interface MyFunctionInterface {
    // 1. 只允许存在一个方法
    void get();

    // 2. 允许存在 default 和 static 修饰的方法
    default void add(){
        System.out.println("add");
    }
    static void ss(){
        System.out.println("ss");
    }

    // 3. 可以存在 Object 类中的方法
    String toString();
    boolean equals(Object obj);
    int hashCode();
}</code></pre> 
<h4>2.1.2、Java 内置的函数接口 </h4> 
<pre><code class="language-java">new Thread(new Runnable() {
            @Override
            public void run() {
               // 方法体 
            }
        }).start();</code></pre> 
<p><img src="https://images2.imgbox.com/1f/d5/bQrJOgII_o.png" alt="85902ec0c9e442348597d55f5cccf61b.png"></p> 
<p>正因为i Runnable 是一个函数接口，所以我们可以这样简写：</p> 
<pre><code class="language-java">new Thread(()-&gt;{
          // 方法体  
        }).start();</code></pre> 
<h3>2.2、Lambda 基础语法</h3> 
<p>语法：</p> 
<pre><code class="language-java">() -&gt; {}</code></pre> 
<ul><li>()：参数列表 </li><li>-&gt;：分隔符</li><li>{}：方法体</li></ul> 
<h4>2.2.1、无参方法调用</h4> 
<p>（1）编写函数接口</p> 
<p> </p> 
<pre><code class="language-java">@FunctionalInterface
public interface ParamLambdaInterface {
    void get();
}</code></pre> 
<p>（2）使用 lambda </p> 
<pre><code class="language-java">public class Test03 {
    public static void main(String[] args) {
        // 1. 匿名内部类
        new ParamLambdaInterface(){
            @Override
            public void get() {
                System.out.println("get");
            }
        };
        // 2. lambda 表达式
        ParamLambdaInterface pl = () -&gt; {
            System.out.println("get");
        };
        pl.get();

    }
}</code></pre> 
<p> </p> 
<h4>2.2.2、有参方法调用</h4> 
<p>（1）编写函数接口</p> 
<pre><code class="language-java">@FunctionalInterface
public interface OrderService {
    void get(String name);
}</code></pre> 
<p>（2）使用 lambda </p> 
<pre><code class="language-java">public class Test04 {
    public static void main(String[] args) {

        // 1. 通过匿名内部类创建一个实现OrderService接口的子类
        OrderService service = new OrderService() {
            @Override
            public void get(String name) {
                System.out.println(name);
            }
        };
        service.get("tom");

        // 2. lambda 表达式 参数类型可以省略
        OrderService od = (name)-&gt;{
            System.out.println(name);
        };
        od.get("get");
    
        // 简化
        ((OrderService) System.out::println).get("tom");
    }
}</code></pre> 
<h3>2.3、Lambda 的精简写法</h3> 
<h4>2.3.1、无参方法</h4> 
<p>上面 2.2.1 也可以这么写：</p> 
<pre><code class="language-java">// 一行代码的情况下 可以省去花括号
((ParamLambdaInterface) () -&gt; System.out.println("get")).get();</code></pre> 
<h4>2.3.2、有参方法</h4> 
<p>2.2.2 可以这么写：</p> 
<p>如果参数只有一个可以省去括号</p> 
<pre><code class="language-java">((OrderService) name -&gt; System.out.println(name)).get("get");</code></pre> 
<h4>练习</h4> 
<p>定义一个用于计算和的函数接口</p> 
<pre><code class="language-java">@FunctionalInterface
public interface AddInterface {
    int add(int a,int b);
}</code></pre> 
<p>测试，求 1 和 2 的和</p> 
<pre><code class="language-java">int result = ((AddInterface) (a, b) -&gt; a + b).add(1, 2);</code></pre> 
<h3>2.4、Lambda 实战</h3> 
<h4>forEach</h4> 
<p>定义一个存放姓名的 List ：</p> 
<pre><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("mike");
        list.add("tom");
        list.add("bob");</code></pre> 
<p>使用 List 的 forEach 方法打印所有元素： </p> 
<p><img src="https://images2.imgbox.com/e1/a4/ty8EBtE3_o.png" alt="bfdd1c872ba84719ac449bd36e3eed7b.png"></p> 
<p>可以看到 forEach 的参数也是一个函数接口，而且只有一个抽象方法 accept。 </p> 
<pre><code class="language-java">    // 1. 普通写法
    list.forEach(new Consumer&lt;String&gt;() {
            @Override
            public void accept(String s) {
                System.out.println(s);
            }
        });    
    
    // 2. lambda
    list.forEach(name-&gt; System.out.println(name) );

    // 简化
    list.forEach(System.out::println);</code></pre> 
<p>将输出结果全部大写输出：</p> 
<pre><code class="language-java">// 将名字转为大写再输出
        list.forEach(name-&gt; System.out.println(name.toUpperCase(Locale.ROOT)));</code></pre> 
<h4>集合排序</h4> 
<p>数据准备</p> 
<pre><code class="language-java">public class User {
    private String name;
    private Integer age;

    public User(){}

    public User(String name, Integer age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }
}
</code></pre> 
<p>创建一个 User 集合</p> 
<pre><code class="language-java">List&lt;User&gt; list = new ArrayList&lt;&gt;();
        list.add(new User("mike",20));
        list.add(new User("bob",18));
        list.add(new User("tom",25));</code></pre> 
<p>使用 lambda 进行排序：</p> 
<pre><code class="language-java">    // 1. 普通写法
    list.sort(new Comparator&lt;User&gt;() {
            @Override
            public int compare(User o1, User o2) {
                return 0;
            }
        });
    // 2. lambda 表达式
    list.sort((user1,user2)-&gt; user1.getAge()-user2.getAge());   // 升序排列
    
    // 输出结果
    list.forEach(System.out::println);</code></pre> 
<p>运行结果：</p> 
<pre><code class="language-java">User{name='bob', age=18}
User{name='mike', age=20}
User{name='tom', age=25}</code></pre> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b0d73a5564db636644f918f8ef26b1a3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">传统点云分割三部曲（一）——VCCS（Voxel Cloud Connectivity Segmentation）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eacc97ddbec5c768869ea97405716c81/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PHP7使用C&#43;&#43;扩展开发</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>