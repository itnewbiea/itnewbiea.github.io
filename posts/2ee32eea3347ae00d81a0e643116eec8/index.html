<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>并发（2） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="并发（2）" />
<meta property="og:description" content="目录
6.通常线程有哪几种使用方式？
7.基础线程机制有哪些？
8.线程的中断方式有哪些？
9.线程的互斥同步方式有哪些？如何比较和选择？
10.Synchronized可以作用在哪里？
6.通常线程有哪几种使用方式？ 有三种使用线程的方法：
实现Runnable接口；
实现Callable接口;
集成Thread类。
实现Runnable和Callable接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过Thread来调用。可以说任务是通过线程驱动从而执行的。
7.基础线程机制有哪些？ Executor管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。
主要有三种Excutor:
1.CachedThreadPool:一个任务创建一个线程；
2.FixedThreadPool:所有任务只能使用固定大小的线程。
3.SingleThreadExecutor:相当于大小为1的FixedThreadPool。
Daemon
守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。
当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。
main()属于非守护线程。使用setDaemon()方法将一个线程设置为守护线程。
sleep（）
Thread.sleep(millisec)方法会休眠当前正在执行的线程，Millisec单位为毫秒。
sleep()可能会抛出InterruptedException，因为异常不能跨线程传播回main()中，因此必须在本地进行处理。线程中抛出的其他异常也同样需要在本地进行处理。
yield()
对静态方法Thread.yield()调用声明了当前线程已经完成了声明周期中最重要的部分，可以切换给其他线程来执行。该方法只是对县城调度器的一个建议，而且也只是建议具有相同优先级的其他线程可以运行。
8.线程的中断方式有哪些？ 一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。
InterruptedException
通过调用一个线程的interrupt()来中断该线程，如果该线程处于阻塞，限期等待或者无限期等待状态，那么就会抛出InterruptedException,从而提前结束该线程。但是不能中断I/O阻塞和synchronized锁阻塞。
对于以下代码，在main()中启动一个线程之后再中断他，由于线程中调用了Thread.sleep()方法，因此会抛出InterruptedException,从而提前结束线程，不执行之后的语句。
interrupted()
如果一个线程的run()方法执行一盒无限循环，并且没有执行sleep()等会抛出InterruptedException的操作，那么调用线程的interrupt()方法就无法使线程提前结束。
但是调用interrupt()方法会设置线程的中断标记，此时调用Interrupt（）方法会返回true。因此可以在循环体中使用interrupted()方法来判断线程是否处于中断状态，从而提前结束线程。
Excutor的中断操作
调用Excutor的shutdown（）方法会等待线程都执行完毕后再关闭，但是如果调用的是shutdownNow（）方法，则相当于调用每个线程的interrupt()方法。
9.线程的互斥同步方式有哪些？如何比较和选择？ Java提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是JVM实现的synchronized，而另一个是JDK实现的ReentrantLock。
1.锁的实现
synchronized时JVM实现的，而ReentrantLock是JDK实现的。
2.性能
新版本Java对Synchronized进行了很多优化，例如自旋锁等，synchronized与ReentrantLock大致相同。
3.等待可中断
当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock可中断，而synchronized不行。
4.公平锁
公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来一次获得锁。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但是也可以是公平的。
5.锁绑定多个条件
一个ReentrantLock可以同时绑定多个Condition对象。
10.Synchronized可以作用在哪里？ 对象锁
方法锁
类锁" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2ee32eea3347ae00d81a0e643116eec8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-06T17:42:10+08:00" />
<meta property="article:modified_time" content="2024-01-06T17:42:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">并发（2）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:200px;"></p> 
<p id="6.%E9%80%9A%E5%B8%B8%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9F-toc" style="margin-left:200px;"><a href="#6.%E9%80%9A%E5%B8%B8%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9F" rel="nofollow">6.通常线程有哪几种使用方式？</a></p> 
<p id="7.%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-toc" style="margin-left:200px;"><a href="#7.%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F" rel="nofollow">7.基础线程机制有哪些？</a></p> 
<p id="8.%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-toc" style="margin-left:200px;"><a href="#8.%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F" rel="nofollow">8.线程的中断方式有哪些？</a></p> 
<p id="9.%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E5%92%8C%E9%80%89%E6%8B%A9%EF%BC%9F-toc" style="margin-left:200px;"><a href="#9.%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E5%92%8C%E9%80%89%E6%8B%A9%EF%BC%9F" rel="nofollow">9.线程的互斥同步方式有哪些？如何比较和选择？</a></p> 
<p id="10.Synchronized%E5%8F%AF%E4%BB%A5%E4%BD%9C%E7%94%A8%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F-toc" style="margin-left:200px;"><a href="#10.Synchronized%E5%8F%AF%E4%BB%A5%E4%BD%9C%E7%94%A8%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F" rel="nofollow">10.Synchronized可以作用在哪里？</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h6 id="6.%E9%80%9A%E5%B8%B8%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9F">6.通常线程有哪几种使用方式？</h6> 
<p>有三种使用线程的方法：</p> 
<p>实现Runnable接口；</p> 
<p>实现Callable接口;</p> 
<p>集成Thread类。</p> 
<p>实现Runnable和Callable接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过Thread来调用。可以说任务是通过线程驱动从而执行的。</p> 
<h6 id="7.%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">7.基础线程机制有哪些？</h6> 
<p>Executor管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p> 
<p>主要有三种Excutor:</p> 
<p>1.CachedThreadPool:一个任务创建一个线程；</p> 
<p>2.FixedThreadPool:所有任务只能使用固定大小的线程。</p> 
<p>3.SingleThreadExecutor:相当于大小为1的FixedThreadPool。</p> 
<p>Daemon</p> 
<p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p> 
<p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p> 
<p>main()属于非守护线程。使用setDaemon()方法将一个线程设置为守护线程。</p> 
<p>sleep（）</p> 
<p>Thread.sleep(millisec)方法会休眠当前正在执行的线程，Millisec单位为毫秒。</p> 
<p>sleep()可能会抛出InterruptedException，因为异常不能跨线程传播回main()中，因此必须在本地进行处理。线程中抛出的其他异常也同样需要在本地进行处理。</p> 
<p>yield()</p> 
<p>对静态方法Thread.yield()调用声明了当前线程已经完成了声明周期中最重要的部分，可以切换给其他线程来执行。该方法只是对县城调度器的一个建议，而且也只是建议具有相同优先级的其他线程可以运行。</p> 
<h6 id="8.%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">8.线程的中断方式有哪些？</h6> 
<p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p> 
<p>InterruptedException</p> 
<p>通过调用一个线程的interrupt()来中断该线程，如果该线程处于阻塞，限期等待或者无限期等待状态，那么就会抛出InterruptedException,从而提前结束该线程。但是不能中断I/O阻塞和synchronized锁阻塞。</p> 
<p>对于以下代码，在main()中启动一个线程之后再中断他，由于线程中调用了Thread.sleep()方法，因此会抛出InterruptedException,从而提前结束线程，不执行之后的语句。</p> 
<p><img alt="" height="488" src="https://images2.imgbox.com/17/75/yRKfaUyV_o.png" width="726"></p> 
<p> <img alt="" height="146" src="https://images2.imgbox.com/fd/95/ENSIhIsA_o.png" width="668"></p> 
<p>interrupted()</p> 
<p>如果一个线程的run()方法执行一盒无限循环，并且没有执行sleep()等会抛出InterruptedException的操作，那么调用线程的interrupt()方法就无法使线程提前结束。</p> 
<p>但是调用interrupt()方法会设置线程的中断标记，此时调用Interrupt（）方法会返回true。因此可以在循环体中使用interrupted()方法来判断线程是否处于中断状态，从而提前结束线程。</p> 
<p>Excutor的中断操作</p> 
<p>调用Excutor的shutdown（）方法会等待线程都执行完毕后再关闭，但是如果调用的是shutdownNow（）方法，则相当于调用每个线程的interrupt()方法。</p> 
<h6 id="9.%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E5%92%8C%E9%80%89%E6%8B%A9%EF%BC%9F">9.线程的互斥同步方式有哪些？如何比较和选择？</h6> 
<p>Java提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是JVM实现的synchronized，而另一个是JDK实现的ReentrantLock。</p> 
<p>1.锁的实现</p> 
<p>synchronized时JVM实现的，而ReentrantLock是JDK实现的。</p> 
<p>2.性能</p> 
<p>新版本Java对Synchronized进行了很多优化，例如自旋锁等，synchronized与ReentrantLock大致相同。</p> 
<p>3.等待可中断</p> 
<p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock可中断，而synchronized不行。</p> 
<p>4.公平锁</p> 
<p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来一次获得锁。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但是也可以是公平的。</p> 
<p>5.锁绑定多个条件</p> 
<p>一个ReentrantLock可以同时绑定多个Condition对象。</p> 
<h6 id="10.Synchronized%E5%8F%AF%E4%BB%A5%E4%BD%9C%E7%94%A8%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F">10.Synchronized可以作用在哪里？</h6> 
<p>对象锁</p> 
<p>方法锁</p> 
<p>类锁</p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/93d26b1338c924a574373bc656dd7def/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43; set用法总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b28f976f56976d8fcde4c1227eefda71/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">华为面经总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>