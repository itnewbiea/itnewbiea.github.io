<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#调用OPC UA 解决方案 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#调用OPC UA 解决方案" />
<meta property="og:description" content="1、Opc 基金会git地址：OPC Foundation · GitHub
其中：UA-.NETStandard 、UA-.NETStandard-Samples比价有参考价值
2、参数传递方式：ns=2;s=参数名（ns表示命名空间索引，一般为2）
特殊情况可以查看所有命名空间：ns=0;i=2255，也可以用（OpcUaHelper.Tool）工具查看
下载地址：C#opc学习资源代码-其它文档类资源-CSDN下载
3、根据opc基金会提供方法整理出调用代码：OPCUAC#控制类库-制造文档类资源-CSDN下载
using Opc.Ua; using Opc.Ua.Client; using Opc.Ua.Configuration; using System; using System.Collections; using System.Collections.Generic; using System.IO; using System.Linq; using System.Threading.Tasks; namespace OPCUALink { /// &lt;summary&gt; /// OPC UA Client with examples of basic functionality. /// &lt;/summary&gt; public class UAClient { #region Constructors public UAClient(bool isdebug = false) { if (isdebug) { return; } ApplicationInstance application = new ApplicationInstance(); application.ApplicationName = SessionName; application." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/3069e6b141a7cb605a832b781b158c56/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-08T16:54:39+08:00" />
<meta property="article:modified_time" content="2023-03-08T16:54:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#调用OPC UA 解决方案</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1、Opc 基金会git地址：<a href="https://github.com/OPCFoundation" title="OPC Foundation · GitHub">OPC Foundation · GitHub</a></p> 
<p>其中：<a href="https://github.com/OPCFoundation/UA-.NETStandard" title="UA-.NETStandard ">UA-.NETStandard </a> 、UA-.NETStandard-Samples比价有参考价值</p> 
<p>2、参数传递方式：ns=2;s=参数名（ns表示命名空间索引，一般为2）</p> 
<p>特殊情况可以查看所有命名空间：ns=0;i=2255，也可以用（OpcUaHelper.Tool）工具查看</p> 
<p>下载地址：<a href="https://download.csdn.net/download/ReflexMechanism/80940649?spm=1001.2014.3001.5503" title="C#opc学习资源代码-其它文档类资源-CSDN下载">C#opc学习资源代码-其它文档类资源-CSDN下载</a></p> 
<p>3、根据opc基金会提供方法整理出调用代码：<a href="https://download.csdn.net/download/ReflexMechanism/80955628?spm=1001.2014.3001.5503" title="OPCUAC#控制类库-制造文档类资源-CSDN下载">OPCUAC#控制类库-制造文档类资源-CSDN下载</a></p> 
<pre><code class="language-cs">using Opc.Ua;
using Opc.Ua.Client;
using Opc.Ua.Configuration;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

namespace OPCUALink
{
    /// &lt;summary&gt;
    /// OPC UA Client with examples of basic functionality.
    /// &lt;/summary&gt;
    public class UAClient
    {
        #region Constructors
        public UAClient(bool isdebug = false)
        {
            if (isdebug)
            {
                return;
            }
            ApplicationInstance application = new ApplicationInstance();
            application.ApplicationName = SessionName;
            application.ApplicationType = ApplicationType.Client;
            //加载配置文件
            application.LoadApplicationConfiguration(ConfigPath, silent: false).Wait();
            // check the application certificate.
            //application.CheckApplicationInstanceCertificate(silent: false, minimumKeySize: 0).Wait();
            m_validateResponse = ClientBase.ValidateResponse;
            m_configuration = application.ApplicationConfiguration;
            m_configuration.CertificateValidator.CertificateValidation += CertificateValidation;
            ReceiveMsg += Msg;
        }
        #endregion

        #region Public Properties
        /// &lt;summary&gt;
        /// session.
        /// &lt;/summary&gt;
        public Session Session =&gt; m_session;
        public static string conStr = "ns=3;s=";
        /// &lt;summary&gt;
        /// session名称
        /// &lt;/summary&gt;
        public string SessionName { get; set; } = "DefaultSession";
        /// &lt;summary&gt;
        /// opcua服务地址
        /// &lt;/summary&gt;
        public string ServerUrl { get; set; } = "opc.tcp://192.168.0.1/";
        /// &lt;summary&gt;
        /// 配置文件
        /// &lt;/summary&gt;
        public string ConfigPath { get; set; } = "ConsoleReferenceClient.Config.xml";
        /// &lt;summary&gt;
        /// 日志委托
        /// &lt;/summary&gt;
        public Action&lt;string&gt; LogAction { get; set; } = t =&gt; { Console.Write(t); };
        /// &lt;summary&gt;
        /// 订阅委托
        /// &lt;/summary&gt;
        /// &lt;param name="DisplayName"&gt;&lt;/param&gt;
        /// &lt;param name="Value"&gt;&lt;/param&gt;
        public delegate void ShowMonitoredItemNotification(string DisplayName, string Value);
        public ShowMonitoredItemNotification ReceiveMsg;
        #endregion

        #region Public Methods
        /// &lt;summary&gt;
        /// 连接服务器
        /// &lt;/summary&gt;
        public async Task&lt;bool&gt; ConnectAsync()
        {

            try
            {
                //if (m_session != null &amp;&amp; m_session.Connected &amp;&amp; m_session.SessionId.ToString() == null)
                //{
                //    LogAction?.Invoke("Session already connected!");
                //}
                //else
                //{
                //    LogAction?.Invoke("Connecting...");
                //    EndpointDescription endpointDescription = CoreClientUtils.SelectEndpoint(ServerUrl, false);
                //    EndpointConfiguration endpointConfiguration = EndpointConfiguration.Create(m_configuration);
                //    Session session = await Session.Create(endpoint: new ConfiguredEndpoint(null, endpointDescription, endpointConfiguration), configuration: m_configuration, updateBeforeConnect: false, checkDomain: false, sessionName: m_configuration.ApplicationName, sessionTimeout: 1800000u, identity: new UserIdentity(), preferredLocales: null);
                //    if (session?.Connected ?? false)
                //    {
                //        m_session = session;
                //    }

                //    LogAction?.Invoke("New Session Created with SessionName = " + m_session.SessionName);
                //    WriteLogWorkDate_n("OpcUa", "连接成功：" + ServerUrl);
                //}

                if (m_session != null &amp;&amp; m_session.Connected == true &amp;&amp; m_session.SessionId.ToString() == null)
                {
                    LogAction?.Invoke("Session already connected!");
                }
                else
                {
                    //Conect();
                    LogAction?.Invoke("Connecting...");

                    // Get the endpoint by connecting to server's discovery endpoint.
                    // Try to find the first endopint without security.
                    EndpointDescription endpointDescription = CoreClientUtils.SelectEndpoint(ServerUrl, false);

                    EndpointConfiguration endpointConfiguration = EndpointConfiguration.Create(m_configuration);
                    ConfiguredEndpoint endpoint = new ConfiguredEndpoint(null, endpointDescription, endpointConfiguration);

                    // Create the session
                    Session session = await Session.Create(
                        m_configuration,
                        endpoint,
                        false,
                        false,
                        m_configuration.ApplicationName,
                        30 * 60 * 1000,//30 * 60 * 10,//
                        new UserIdentity(),
                        null
                    );

                    // Assign the created session
                    if (session != null &amp;&amp; session.Connected)
                    {
                        m_session = session;
                    }

                    // Session created successfully.
                    LogAction?.Invoke($"New Session Created with SessionName = {m_session.SessionName}");
                    WriteLogWorkDate_n("OpcUa", "连接成功：" + ServerUrl);

                }
                return true;
            }
            catch (Exception ex)
            {
                // Log Error
                LogAction?.Invoke($"Create Session Error : {ex.Message}");
                WriteLogWorkDate_n("OpcUa", "连接失败：" + ServerUrl + ":" + ex.Message);
                ConnectAsync().Wait();
                return false;
            }
        }

        private async void Conect()
        {
            LogAction?.Invoke("Connecting...");

            // Get the endpoint by connecting to server's discovery endpoint.
            // Try to find the first endopint without security.
            EndpointDescription endpointDescription = CoreClientUtils.SelectEndpoint(ServerUrl, false);

            EndpointConfiguration endpointConfiguration = EndpointConfiguration.Create(m_configuration);
            ConfiguredEndpoint endpoint = new ConfiguredEndpoint(null, endpointDescription, endpointConfiguration);

            // Create the session
            Session session = await Session.Create(
                m_configuration,
                endpoint,
                false,
                false,
                m_configuration.ApplicationName,
                30 * 60 * 10,//30 * 60 * 1000,
                new UserIdentity(),
                null
            );

            // Assign the created session
            if (session != null &amp;&amp; session.Connected)
            {
                m_session = session;
            }

            // Session created successfully.
            LogAction?.Invoke($"New Session Created with SessionName = {m_session.SessionName}");

        }

        /// &lt;summary&gt;
        /// 断开链接
        /// &lt;/summary&gt;
        public void Disconnect()
        {
            try
            {
                WriteLogWorkDate_n("OpcUa", "断开连接：" + ServerUrl);

                if (m_session != null)
                {
                    LogAction?.Invoke("Disconnecting...");

                    m_session.Close();
                    m_session.Dispose();
                    m_session = null;

                    // Log Session Disconnected event
                    LogAction?.Invoke("Session Disconnected.");
                }
                else
                {
                    LogAction?.Invoke("Session not created!");
                }
            }
            catch (Exception ex)
            {
                // Log Error
                LogAction?.Invoke($"Disconnect Error : {ex.Message}");
            }
        }
        string oldword = "";
        /// &lt;summary&gt;
        /// 读单个节点
        /// &lt;/summary&gt;
        /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
        /// &lt;param name="location"&gt;ns=4;s=A_AGV到周转桶&lt;/param&gt;
        /// &lt;returns&gt;ns=0;i=2255 查看所有命名空间&lt;/returns&gt;
        public T ReadNode&lt;T&gt;(string location)
        {
            #region 
            //DataValue dataValue = null;
            //if (m_session == null || !m_session.Connected)
            //{
            //     ConnectAsync();
            //}

            //try
            //{
            //    dataValue = m_session.ReadValue(conStr + location);
            //}
            //catch
            //{
            //    ConnectAsync();
            //    dataValue = m_session.ReadValue(conStr + location);
            //}

            //return (T)dataValue.Value; 
            #endregion
            if (m_session == null || m_session.Connected == false)
            {
                ConnectAsync().Wait();
            }
            DataValue value = null;
            try
            {
                value = m_session.ReadValue(conStr + location);
            }
            catch (Exception)
            {
                ConnectAsync().Wait();
                value = m_session.ReadValue(conStr + location);
            }
            string newword = "读单个节点：" + location + ":" + value.Value;
            if (newword != oldword)
            {
                WriteLogWorkDate_n("OpcUa", newword);
                oldword = newword;
            }

            return (T)value.Value;
        }
        /// &lt;summary&gt;
        /// 读多个节点
        /// &lt;/summary&gt;
        /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
        /// &lt;param name="locations"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public List&lt;T&gt; ReadNodes&lt;T&gt;(List&lt;string&gt; locations)
        {
            for (int i = 0; i &lt; locations.Count; i++)
            {
                locations[i] = conStr + locations[i];
            }
            if (m_session == null || m_session.Connected == false)
            {
                ConnectAsync().Wait();
            }
            var typeList = new List&lt;Type&gt;();
            foreach (var location in locations)
            {
                typeList.Add(typeof(T));
            }
            var nodeIds = locations.Select(t =&gt; new NodeId(t)).ToList();
            List&lt;object&gt; values = new List&lt;object&gt;();
            try
            {
                m_session.ReadValues(nodeIds, typeList, out values, out List&lt;ServiceResult&gt; errors);
            }
            catch (Exception)
            {
                ConnectAsync().Wait();
                m_session.ReadValues(nodeIds, typeList, out values, out List&lt;ServiceResult&gt; errors);
            }
            return values.Select(t =&gt; (T)t).ToList();

        }
        /// &lt;summary&gt;
        /// 写单个节点
        /// &lt;/summary&gt;
        /// &lt;param name="location"&gt;&lt;/param&gt;
        /// &lt;param name="value"&gt;&lt;/param&gt;
        public void WriteNode(string location, object value)
        {
            location = conStr + location;
            if (m_session == null || m_session.Connected == false)
            {
                ConnectAsync().Wait();
            }
            WriteLogWorkDate_n("OpcUa", "写单个节点：" + location + ":" + value);

            WriteValueCollection nodesToWrite = new WriteValueCollection();
            WriteValue intWriteVal = new WriteValue();
            intWriteVal.NodeId = new NodeId(location);
            intWriteVal.AttributeId = Attributes.Value;
            intWriteVal.Value = new DataValue();
            intWriteVal.Value.Value = value;
            nodesToWrite.Add(intWriteVal);
            try
            {
                m_session.Write(null,
                                   nodesToWrite,
                                   out StatusCodeCollection results,
                                   out DiagnosticInfoCollection diagnosticInfos);
            }
            catch (Exception)
            {
                ConnectAsync().Wait();
                m_session.Write(null,
                                  nodesToWrite,
                                  out StatusCodeCollection results,
                                  out DiagnosticInfoCollection diagnosticInfos);
            }
        }
        /// &lt;summary&gt;
        /// 写多个节点
        /// &lt;/summary&gt;
        /// &lt;param name="locations"&gt;&lt;/param&gt;
        /// &lt;param name="values"&gt;&lt;/param&gt;
        public void WriteNodes(List&lt;string&gt; locations, List&lt;object&gt; values)
        {
            if (m_session == null || m_session.Connected == false)
            {
                ConnectAsync().Wait();
            }
            WriteValueCollection nodesToWrite = new WriteValueCollection();
            for (int i = 0; i &lt; locations.Count; i++)
            {
                WriteLogWorkDate_n("OpcUa", "写多个节点：" + locations[i] + ":" + values[i]);

                WriteValue intWriteVal = new WriteValue();
                intWriteVal.NodeId = new NodeId(conStr + locations[i]);
                intWriteVal.AttributeId = Attributes.Value;
                intWriteVal.Value = new DataValue();
                intWriteVal.Value.Value = values[i];
                nodesToWrite.Add(intWriteVal);
            }
            m_session.Write(null,
                            nodesToWrite,
                            out StatusCodeCollection results,
                            out DiagnosticInfoCollection diagnosticInfos);
        }
        /// &lt;summary&gt;
        ///订阅多个节点
        /// &lt;/summary&gt;
        public void SubscribeToDataChanges(List&lt;string&gt; locations)
        {
            if (m_session == null || m_session.Connected == false)
            {
                ConnectAsync().Wait();
                return;
            }
            try
            {
                // 创建订阅以接收数据更改通知
                // 定义订阅参数
                Subscription subscription = new Subscription(m_session.DefaultSubscription);

                subscription.DisplayName = "Console ReferenceClient Subscription";
                subscription.PublishingEnabled = true;
                subscription.PublishingInterval = 1000;

                m_session.AddSubscription(subscription);

                //在服务器端创建订阅
                subscription.Create();

                foreach (string loa in locations)
                {
                    MonitoredItem intMonitoredItem = new MonitoredItem(subscription.DefaultItem);
                    // Int32 Node - Objects\CTT\Scalar\Simulation\Int32
                    intMonitoredItem.StartNodeId = new NodeId(conStr + loa);
                    intMonitoredItem.AttributeId = Attributes.Value;
                    intMonitoredItem.DisplayName = conStr + loa;
                    intMonitoredItem.SamplingInterval = 1000;
                    intMonitoredItem.Notification += OnMonitoredItemNotification;
                    subscription.AddItem(intMonitoredItem);
                }
                // 在服务器端创建监控项
                subscription.ApplyChanges();
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message);
            }
        }

        /// &lt;summary&gt;
        /// 从服务器读取值节点，不分类型
        /// &lt;/summary&gt;
        /// &lt;param name="nodeId"&gt;node id&lt;/param&gt;
        /// &lt;returns&gt;DataValue&lt;/returns&gt;
        public string ReadAllNode()//DataValue ReadAllNode()
        {
            NodeId nodeId = new NodeId(conStr + $"\"上位机读取交互数据\".\"培养箱抓取完成\"");
            string res = "";
            ReadValueIdCollection nodesToRead = new ReadValueIdCollection
            {
                new ReadValueId( )
                {
                    NodeId = nodeId,
                    AttributeId = Attributes.Value
                }
            };

            // read the current value
            try
            {
                m_session.Read(
                       null,
                       0,
                       TimestampsToReturn.Neither,
                       nodesToRead,
                       out DataValueCollection results,
                       out DiagnosticInfoCollection diagnosticInfos);

                ClientBase.ValidateResponse(results, nodesToRead);
                ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToRead);
                DataValue dv = results[0];
            }
            catch
            {
                ConnectAsync().Wait();
                m_session.Read(
                       null,
                       0,
                       TimestampsToReturn.Neither,
                       nodesToRead,
                       out DataValueCollection results,
                       out DiagnosticInfoCollection diagnosticInfos);

                ClientBase.ValidateResponse(results, nodesToRead);
                ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToRead);
                DataValue dv = results[0];
                res = dv.Value.ToString();
            }
            return res;
        }

        #endregion

        #region Private Methods

        private void Msg(string DisplayName, string Value)
        {

        }
        private void OnMonitoredItemNotification(MonitoredItem monitoredItem, MonitoredItemNotificationEventArgs e)
        {
            try
            {
                // Log MonitoredItem Notification event
                MonitoredItemNotification notification = e.NotificationValue as MonitoredItemNotification;
                WriteLogWorkDate_n("OpcUa", "订阅反馈：" + monitoredItem.DisplayName + ":" + notification.Value.ToString());
                ReceiveMsg(monitoredItem.DisplayName, notification.Value.ToString());
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message);
                WriteLogWorkDate_n("OpcUa", "订阅反馈：" + monitoredItem.DisplayName + ":" + ex.Message);
            }
        }

        /// &lt;summary&gt;
        /// Handles the certificate validation event.
        /// This event is triggered every time an untrusted certificate is received from the server.
        /// &lt;/summary&gt;
        private void CertificateValidation(CertificateValidator sender, CertificateValidationEventArgs e)
        {
            bool certificateAccepted = true;

            // ****
            // Implement a custom logic to decide if the certificate should be
            // accepted or not and set certificateAccepted flag accordingly.
            // The certificate can be retrieved from the e.Certificate field
            // ***

            ServiceResult error = e.Error;
            while (error != null)
            {
                LogAction?.Invoke(error.ToString());
                error = error.InnerResult;
            }

            if (certificateAccepted)
            {
                LogAction?.Invoke($"Untrusted Certificate accepted. SubjectName = {e.Certificate.SubjectName}");
            }

            e.AcceptAll = certificateAccepted;
        }
        #endregion

        #region Private Fields

        private ApplicationConfiguration m_configuration;

        private Session m_session;

        private readonly Action&lt;IList, IList&gt; m_validateResponse;

        #endregion

        public static void WriteLogWorkDate_n(string fstyle, string messagestr)
        {
            #region  日志文件写入每天生成一个文件 txt
            try
            {
                //创建一个文件流，用以写入或者创建一个StreamWriter
                string filenamenew = fstyle + DateTime.Now.ToString("yyyy-MM-dd") + ".txt";
                string date = DateTime.Now.ToString("yyyy-MM-dd");

                //信息中下上时间直接写入 wqy 20180319
                string msg = "";
                if (messagestr == "")
                {
                    msg = messagestr;
                }
                else
                {
                    msg = DateTime.Now.ToString("HH:mm:ss:fff") + " " + messagestr;
                }

                //包装箱文件夹不存在创建
                string xhpath = AppDomain.CurrentDomain.BaseDirectory + "log\\" + date + "\\";
                //文件夹不存在创建
                if (!Directory.Exists(xhpath))
                {
                    Directory.CreateDirectory(xhpath);
                }

                filenamenew = xhpath + filenamenew;

                FileStream fs = new FileStream(filenamenew, FileMode.OpenOrCreate, FileAccess.ReadWrite);
                StreamWriter m_streamWriter = new StreamWriter(fs);
                m_streamWriter.Flush();
                // 使用StreamWriter来往文件中写入内容
                m_streamWriter.BaseStream.Seek(0, SeekOrigin.End);
                // 把richTextBox1中的内容写入文件
                m_streamWriter.Write(msg + "\r\n");
                //关闭此文件
                m_streamWriter.Flush();
                m_streamWriter.Close();
                fs.Close();
            }
            catch (Exception ex)
            {
            }
            #endregion
        }

    }
}
</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/59ad75265c213eccd19ff607c55532a7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python将文件夹中所有子文件夹中的图片统一保存</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c2748f955e3b63c73c3a01302126f646/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">prometheus 配置服务器监控、服务监控、容器中服务监控与告警</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>