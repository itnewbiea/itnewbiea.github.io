<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法复杂度 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法复杂度" />
<meta property="og:description" content="前言：哈喽小伙伴们，从这篇文章开始，博主就要带领大家一起进入数据结构与算法的学习啦。
C语言掌握的还不扎实的小伙伴一定要记得先补习哦。
今天我们就先来学习——算法复杂度。
目录
一.算法效率
二.时间复杂度
1.时间复杂度的定义
2.大O的渐进表示法
三.空间复杂度
4.总结 一.算法效率 小伙伴们从开始学习编程到现在，肯定已经做过了不少的编程题，那么我们解决这些题目的思路，就称之为算法。 我们还知道，每一道复杂的题目肯定都不止一种解法，那么我们如何判断一个算法的好坏呢？
算法在编写成可执行程序后，运行时肯定都需要消耗时间和空间。因此，衡量一个算法的好坏，一般是从时间和空间两个维度来衡量的，也就是时间复杂度和空间复杂度。
二.时间复杂度 1.时间复杂度的定义 那么时间复杂度究竟是什么东西呢？？？
博主这里通俗的告诉大家，实际上就是我们数学上所学习的函数。
那么再简单一点来说，时间复杂度就是我们代码中，某些基本操作的执行次数。 下面我们就通过实际例子来讲解时间复杂度： void Func1(int N) { int count = 0; for (int i = 0; i &lt; N; &#43;&#43;i) { for (int j = 0; j &lt; N; &#43;&#43;j) { &#43;&#43;count; } } for (int k = 0; k &lt; 2 * N; &#43;&#43;k) { &#43;&#43;count; } int M = 10; while (M--) { &#43;&#43;count; } printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/cc41df8edd0f64c8687feaf3f8d28867/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-26T15:28:14+08:00" />
<meta property="article:modified_time" content="2023-10-26T15:28:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法复杂度</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>前言：哈喽小伙伴们，从这篇文章开始，博主就要带领大家一起进入<span style="color:#956fe7;"><strong>数据结构与算法</strong></span>的学习啦。</p> 
<p>C语言掌握的还不扎实的小伙伴一定要记得先补习哦。</p> 
<p>今天我们就先来学习——<span style="color:#956fe7;"><strong>算法复杂度</strong></span>。</p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87" rel="nofollow">一.算法效率</a></p> 
<p id="%E4%BA%8C.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">二.时间复杂度</a></p> 
<p id="1.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#1.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">1.时间复杂度的定义</a></p> 
<p id="2.%E5%A4%A7O%E7%9A%84%E6%B8%90%E8%BF%9B%E8%A1%A8%E7%A4%BA%E6%B3%95-toc" style="margin-left:40px;"><a href="#2.%E5%A4%A7O%E7%9A%84%E6%B8%90%E8%BF%9B%E8%A1%A8%E7%A4%BA%E6%B3%95" rel="nofollow">2.大O的渐进表示法</a></p> 
<p id="%E4%B8%89.%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">三.空间复杂度</a></p> 
<p id="4.%E6%80%BB%E7%BB%93%C2%A0-toc" style="margin-left:0px;"><a href="#4.%E6%80%BB%E7%BB%93%C2%A0" rel="nofollow">4.总结 </a></p> 
<hr id="hr-toc"> 
<h2>一.算法效率</h2> 
<p>小伙伴们从开始学习编程到现在，肯定已经做过了不少的编程题，那么我们<strong><span style="background-color:#ffd900;">解决这些题目的思路，就称之为算法</span></strong>。 </p> 
<p>我们还知道，每一道复杂的题目肯定都<span style="color:#fe2c24;"><strong>不止一种解法</strong></span>，那么我们<span style="color:#fe2c24;"><strong>如何判断一个算法的好坏呢</strong></span>？</p> 
<p>算法在编写成可执行程序后，运行时肯定都<span style="color:#fe2c24;"><strong>需要消耗时间和空间</strong></span>。因此，衡量一个算法的好坏，一般是从<span style="color:#fe2c24;"><strong>时间和空间</strong></span>两个维度来衡量的，也就是<strong><span style="background-color:#ffd900;">时间复杂度和空间复杂度</span></strong>。</p> 
<hr> 
<h2 id="%E4%BA%8C.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">二.时间复杂度</h2> 
<h3 id="1.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E5%AE%9A%E4%B9%89">1.时间复杂度的定义</h3> 
<p>那么时间复杂度究竟是什么东西呢？？？</p> 
<p>博主这里通俗的告诉大家，实际上就是我们<span style="color:#fe2c24;"><strong>数学上所学习的函数</strong></span>。</p> 
<p>那么再简单一点来说，时间复杂度就是我们代码中，<span style="color:#fe2c24;"><strong>某些基本操作的执行次数</strong></span>。 </p> 
<p>下面我们就通过实际例子来讲解时间复杂度： </p> 
<pre><code class="language-cpp">void Func1(int N)
{
	int count = 0;
	for (int i = 0; i &lt; N; ++i)
	{
		for (int j = 0; j &lt; N; ++j)
		{
			++count;
		}
	}

	for (int k = 0; k &lt; 2 * N; ++k)
	{
		++count;
	}
	int M = 10;
	while (M--)
	{
		++count;
	}
	printf("%d\n", count);
}</code></pre> 
<p>我们来看这个函数，试问它的<span style="color:#fe2c24;"><strong>时间复杂度是多少</strong></span>？？？</p> 
<p>能够看出，这个函数一共有<span style="color:#fe2c24;"><strong>三个循环</strong></span>，其中第一个还是<span style="color:#fe2c24;"><strong>嵌套循环</strong></span>。</p> 
<p>那么这三个循环的<span style="color:#fe2c24;"><strong>循环次数</strong></span>分别是多少呢？？？</p> 
<p>不难看出，第一个嵌套循环的循环次数为<span style="color:#fe2c24;"><strong>N*2次</strong></span>，第二个为<span style="color:#fe2c24;"><strong>2N次</strong></span>，第三个则为<span style="color:#fe2c24;"><strong>10次</strong></span>。</p> 
<p>那么我们就能得出<strong><span style="background-color:#ffd900;">使用这个函数所需要执行循环的次数F(N) = N ^ 2 + 2N + 10</span></strong>。</p> 
<p>这个函数式，就是我们所说的时间复杂度。但是这样的写法是不是有的复杂而且好老套。</p> 
<p>但是我们学过数学就会知道，<span style="color:#ff9900;"><strong>当N的值不断取大时，影响最大的会是幂数最高的项</strong></span>，比如：</p> 
<blockquote> 
 <p><strong>N = 10         F(N) = 130<br> N = 100       F(N) = 10210<br> N = 1000     F(N) = 1002010</strong></p> 
</blockquote> 
<p> 所以我们规定时间复杂度的简易写法为<span style="color:#fe2c24;"><strong>取影响最大的项：</strong></span></p> 
<blockquote> 
 <p><strong>O(N^2)</strong></p> 
</blockquote> 
<p>这种时间复杂度的取法，也叫做<span style="color:#fe2c24;"><strong>大O的渐进表示法</strong></span>。</p> 
<hr> 
<h3 id="2.%E5%A4%A7O%E7%9A%84%E6%B8%90%E8%BF%9B%E8%A1%A8%E7%A4%BA%E6%B3%95">2.大O的渐进表示法</h3> 
<p>大O符号（Big O notation）：是用于<span style="color:#fe2c24;"><strong>描述函数渐进行为</strong></span>的数学符号。<br> 推导大O阶方法：</p> 
<blockquote> 
 <ol><li><strong>用常数1取代运行时间中的所有加法常数。</strong></li><li><strong>在修改后的运行次数函数中，只保留最高阶项。</strong></li><li><strong>如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。</strong> </li></ol> 
</blockquote> 
<p>了解过大O的渐进表示法时候， 我们再来看一个例子：</p> 
<pre><code class="language-cpp">void Func2(int N)
{
	int count = 0;
	for (int k = 0; k &lt; 2 * N; ++k)
	{
		++count;
	}
	int M = 10;
	while (M--)
	{
		++count;
	}
	printf("%d\n", count);
}</code></pre> 
<p>这个函数的时间复杂度是多少呢？？？</p> 
<p>能够得出<span style="color:#fe2c24;"><strong>F(N) = 2N + 10</strong></span>，<strong><span style="background-color:#ffd900;">保留最高阶2N，再去除与N相乘的常数2，得出时间复杂度为O(N)</span></strong>。</p> 
<p>到这里小伙伴们是否已经了解到时间复杂度的求解方法了呢？？？</p> 
<p>那么我们再来看一例子：</p> 
<pre><code class="language-cpp">void Func3(int N, int M)
{
     int count = 0;
     for (int k = 0; k &lt; M; ++k)
     {
         ++count;
     }
     for (int k = 0; k &lt; N ; ++k)
     {
         ++count;
     }
     printf("%d\n", count);
}</code></pre> 
<p> 这个函数的时间复杂度是多少呢？？？</p> 
<p><span style="color:#fe2c24;"><strong>F(N) = N + M</strong></span>，好像<strong><span style="background-color:#ffd900;">大O法的三条规则都不是很满足</span></strong>，那么到底该怎么表示呢？？？</p> 
<blockquote> 
 <p><strong>当我们不知道N和M的大小关系时，时间复杂度表示为O(N+M)；</strong></p> 
 <p><strong>当N远大于M时，时间复杂度表示为O(N)；</strong></p> 
 <p><strong>当N远小于M时，时间复杂度表示为O(M)；</strong></p> 
 <p><strong>当N和M差不多大时，时间复杂度表示为O(N)或者O(M)都可以。</strong></p> 
</blockquote> 
<p>那么我们再来看最后一个例子：</p> 
<pre><code class="language-cpp">void Func4(int N)
{
	int count = 0;
	for (int k = 0; k &lt; 100; ++k)
	{
		++count;
	}
	printf("%d\n", count);
}</code></pre> 
<p>这个函数的时间复杂度是多少呢？？？</p> 
<p>是<span style="color:#fe2c24;"><strong>O(100)</strong></span>吗？并不是，根据大O表示法的第一条规定，<span style="color:#fe2c24;"><strong>用常数1取代所有运行的常数次数</strong></span>，也就是说，<strong><span style="background-color:#ffd900;">如果你的循环是常数次，那么时间复杂度就为O(1)</span></strong>。</p> 
<p>实际上，<strong><span style="background-color:#ffd900;">如果一个循环进行的次数为常数次，那么它的运行时间都是相同的</span></strong>，感兴趣的小伙伴们可以测试一下<span style="color:#fe2c24;"><strong>一个循环运行1次和运行1亿次的时间是否是相同的</strong></span>。</p> 
<p>另外有些算法的时间复杂度存在<span style="color:#fe2c24;"><strong>最好、平均和最坏情况</strong></span>：</p> 
<blockquote> 
 <p><strong> 最坏情况：任意输入规模的最大运行次数(上界)<br>  平均情况：任意输入规模的期望运行次数<br>  最好情况：任意输入规模的最小运行次数(下界)</strong></p> 
</blockquote> 
<p>例如：<strong>在一个长度为N数组中搜索一个数据x</strong>：</p> 
<blockquote> 
 <p><strong> 最好情况：1次找到<br>  最坏情况：N次找到<br>  平均情况：N/2次找到</strong></p> 
</blockquote> 
<p>在实际中一般情况关注的是算法的<span style="color:#fe2c24;"><strong>最坏运行情况</strong></span>，所以数组中搜索数据<span style="color:#fe2c24;"><strong>时间复杂度为O(N)</strong></span>。</p> 
<hr> 
<h2 id="%E4%B8%89.%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">三.空间复杂度</h2> 
<p>空间复杂度和时间复杂度一样，也是通过一个<span style="color:#fe2c24;"><strong>数学表达式</strong></span>来表示，它是对一个算法在运行过程中<span style="color:#fe2c24;"><strong>额外的</strong></span>，<span style="color:#fe2c24;"><strong>临时创建的变量所占用的空间大小</strong></span>的量度。</p> 
<p>此外，对于空间复杂度的运算规则，同样也是采用<span style="color:#fe2c24;"><strong>大O的渐进表示法</strong></span>。</p> 
<p>因为<strong><span style="background-color:#ffd900;">函数运行时所需要的栈空间在编译期间已经确定好了</span></strong>，因此<strong><span style="background-color:#ffd900;">空间复杂度主要通过函数在运行的时候显示申请的额外空间</span></strong>来确定。</p> 
<p>下面我们就来通过实际例子来讲解空间复杂度的计算方法：</p> 
<pre><code class="language-cpp">void BubbleSort(int* a, int n)
{
	assert(a);
	for (int end = n; end &gt; 0; --end)
	{
		int exchange = 0;
		for (int i = 1; i &lt; end; ++i)
		{
			if (a[i - 1] &gt; a[i])
			{
				Swap(&amp;a[i - 1], &amp;a[i]);
				exchange = 1;
			}
		}
		if (exchange == 0)
			break;
	}
}</code></pre> 
<p>来看我们熟悉的<span style="color:#fe2c24;"><strong>冒泡排序函数</strong></span>，它的空间复杂度是多少呢？？？</p> 
<p>这个函数中额外创建了<span style="color:#fe2c24;"><strong>哪几个临时变量</strong></span>？</p> 
<p>不难看出，<strong><span style="background-color:#ffd900;">end，exchange，i这三个变量是临时创建的</span></strong>，所以该函数的空间复杂度就为<span style="color:#fe2c24;"><strong>O(1)</strong></span>。</p> 
<p>有的小伙伴可能发现，<span style="color:#fe2c24;"><strong>end和i变量不是一直在循环创建吗</strong></span>，不应该是<span style="color:#fe2c24;"><strong>O(N^2)</strong></span>吗？？？</p> 
<p> 要注意，<span style="color:#fe2c24;"><strong>空间和时间是不一样的</strong></span>。</p> 
<p><strong><span style="background-color:#ffd900;">时间过去了就没有了，再也找不回来了</span></strong>；而<strong><span style="background-color:#ffd900;">空间却是可以长期存在的，可以反复利用的</span></strong>，当我们循环使用end和i变量时，实际上<span style="color:#fe2c24;"><strong>一直在使用同一块空间</strong></span>。</p> 
<pre><code class="language-cpp">long long* Fibonacci(int n)
{
	if (n == 0)
		return NULL;

	long long* fibArray = (long long*)malloc((n + 1) * sizeof(long long));
	fibArray[0] = 0;
	fibArray[1] = 1;
	for (int i = 2; i &lt;= n; ++i)
	{
		fibArray[i] = fibArray[i - 1] + fibArray[i - 2];
	}
	return fibArray;
}</code></pre> 
<p>我们再来看这个斐波那契函数，这个就很直观了，直接就能看见<strong><span style="background-color:#ffd900;">用malloc函数开辟了n+1个空间大小，还有一个变量i，总共是n+2个空间</span></strong>，那么根据大O表示法，空间复杂度为<span style="color:#fe2c24;"><strong>O(N)</strong></span>。</p> 
<hr> 
<h2 id="4.%E6%80%BB%E7%BB%93%C2%A0">4.总结 </h2> 
<p>那么对于数据结构的第一块知识——算法复杂度到这里就跟大家分享完啦，这一块知识并不难，就是一些个计算题，多多练习都是能够很轻松掌握的。</p> 
<p>喜欢博主文章的小伙伴不要忘记<span style="color:#956fe7;"><strong>一键三连呀</strong></span>！！！</p> 
<p>我们下期再见啦！！！</p> 
<p style="text-align:center;"><img alt="" height="229" src="https://images2.imgbox.com/0c/70/suqglfjK_o.jpg" width="228"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2296b59d3f7e9df5d4cb9a429e877874/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ffmpeg常用命令（获取视频缩略图等）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8865b978f4f783584ac20c77917e5cf3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PySide6 编写的仪表盘</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>