<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title># Apifox前后端开发人员使用场景 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="# Apifox前后端开发人员使用场景" />
<meta property="og:description" content="Apifox前后端开发人员使用场景 概述 官网：Apifox 快速入门 | Apifox 帮助文档
功能描述 1、在日常编程开发过程中经常使用前后端分离架构的模式，一个项目的落地会通过产品、开发、测试三方会审，对项目需求评审过后，前后端开发会制定一些接口，通常会用以下方式：
编写指定接口文档。后端开发依据接口文档开发接口，一边开发一边测试。前端开发需要（Mock）数据供前端调用。开发完成后，测试通过（Postman，Jmeter）去进行接口测试。 2、为了能让项目落地更加便捷，Apifox应运而生实现了API设计开发测试一体化协作。Apifox=Postman&#43;Swagger&#43;Jmeter&#43;Mock工具集。
优势 1、Apifox 是 API 文档、API 调试、API Mock、API 自动化测试一体化协作平台。高效、及时、准确！
2、接口信息云端实时同步更新，响应团队协作。
3、Apifox 项目可“在线分享” API 文档，分享出去的 API 文档可设置为公开或需要密码访问，方便与外部团队进行协作。
4、支持导出各种数据格式OpenApi (Swagger)、Markdown、Html等
开发人员使用流程 总述 前端（或后端）在 Apifox 上定好接口文档初稿。前后端 一起评审、完善接口文档，定好接口用例。前端 使用系统根据接口文档自动生成的 Mock 数据进入开发，无需手写 mock 规则。后端 使用接口用例 调试开发中的接口，当所有接口用例调试通过，接口即开发完成。若开发过程中接口有改动，调试的时候会自动更新文档，零成本的保障了接口维护的及时性。后端 每次调试完一个功能就保存为一个接口用例。测试人员 直接使用接口用例测试接口。所有接口开发完成后，测试人员（也可以是后端）使用集合测试功能进行多接口集成测试，完整测试整个接口调用流程。前后端 都开发完，前端从Mock 数据切换到正式数据，联调通常都会非常顺利，因为前后端双方都完全遵守了接口定义的规范。 新建团队 创建团队、创建新项目
邀请团队成员设置团队权限、设置项目权限通知设置：支持将通知集成到第三方应用平台，接口变更后可发送消息通知 编写接口文档 编写基本信息请求参数设置：新建数据模型，参数直接关联模型的属性返回响应定义
响应示例编写：响应示例可根据MocK规则自动生成
前端使用Mock 发送Mock快捷请求，直接获取接口样例数据
后端调试模式开发接口 后端开发人员用调试模式对接口进行开发调试后端人员调试用例可以保存下来 接口用例测试 测试人员或者后端人员对保存的接口用例进行测试 前后端联调 前后端都开发完，前端从Mock 数据切换到正式数据 接口文档分享 可以生成在线文档进行查看
其它使用场景 接口管理 查看历史版本 查看接口修改历史时，可以与某次操作进行对比
在线分享 在 API 设计、开发、沟通、协作中，逻辑上应该以团队内共同定义的 API 文档为标准。实际操作中，团队成员习惯依靠 Word、PDF 格式文件进行 API 文档协作，造成大量信息未能及时同步，将接口以在线形式分享将有助于提高团队之间的沟通效率。 用例管理 定义接口的时候定义好这些不同状态的用例，接口调试的时候直接运行，非常高效。 Mock功能 根据接口/数据结构定义、Mock 规则配置、Mock 期望配置等功能自动生成模拟数据 登录状态获取 Session/Cookie 方式 先执行登录接口，执行完成后全局 Cookie 会自动保存返回的 Session/Cookie 信息。然后运行其他接口，会自动带上 Session/Cookie 信息。 Token 方式 在环境 里的全局参数统一设置，所有接口运行时会自动加上全局参数，无需每个接口手动设置 全自动登录 自动登录过一次后，保存登录态，避免每次执行用例都调用登录接口。编写前置脚本，将登录接口返回的登录凭证写入环境变量 接口自动化测试 获取Token公共脚本 编写前置脚本（获取用户登录token） // 定义发送登录接口请求方法 function sendLoginRequest() { // 获取环境里的 前置 URL const baseUrl = pm." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f58d1f33db135af77b8e43290e92b25f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-20T20:21:38+08:00" />
<meta property="article:modified_time" content="2023-11-20T20:21:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title"># Apifox前后端开发人员使用场景</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Apifox_0"></a>Apifox前后端开发人员使用场景</h2> 
<h3><a id="_2"></a>概述</h3> 
<blockquote> 
 <p>官网：<a href="https://apifox.com/help/" rel="nofollow">Apifox 快速入门 | Apifox 帮助文档</a></p> 
</blockquote> 
<h4><a id="_6"></a>功能描述</h4> 
<p>1、在日常编程开发过程中经常使用前后端分离架构的模式，一个项目的落地会通过产品、开发、测试三方会审，对项目需求评审过后，前后端开发会制定一些接口，通常会用以下方式：</p> 
<ul><li>编写指定接口文档。</li><li>后端开发依据接口文档开发接口，一边开发一边测试。</li><li>前端开发需要（<code>Mock</code>）数据供前端调用。</li><li>开发完成后，测试通过（<code>Postman</code>，<code>Jmeter</code>）去进行接口测试。</li></ul> 
<p>2、为了能让项目落地更加便捷，<code>Apifox</code>应运而生实现了<code>API</code>设计开发测试一体化协作。<code>Apifox=Postman+Swagger+Jmeter+Mock</code>工具集。<br> <img src="https://images2.imgbox.com/b7/7b/L6CDcn8i_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_17"></a>优势</h4> 
<p><img src="https://images2.imgbox.com/a3/bb/1uFLAO99_o.png" alt="在这里插入图片描述"><br> 1、<code>Apifox</code> 是 <code>API</code> 文档、<code>API</code> 调试、<code>API Mock</code>、<code>API</code> 自动化测试一体化协作平台。高效、及时、准确！<br> 2、接口信息云端实时同步更新，响应团队协作。<br> 3、<code>Apifox</code> 项目可“在线分享” <code>API</code> 文档，分享出去的 <code>API</code> 文档可设置为公开或需要密码访问，方便与外部团队进行协作。<br> 4、支持导出各种数据格式<code>OpenApi (Swagger)</code>、<code>Markdown</code>、<code>Html</code>等</p> 
<p><img src="https://images2.imgbox.com/0b/b2/7NKHM0qd_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/5f/80/Cte3w1ym_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_26"></a>开发人员使用流程</h3> 
<h4><a id="_27"></a>总述</h4> 
<ol><li><strong>前端</strong>（或<strong>后端</strong>）在 <code>Apifox</code> 上定好<code>接口文档</code>初稿。</li><li><strong>前后端</strong> 一起评审、完善<code>接口文档</code>，定好<code>接口用例</code>。</li><li><strong>前端</strong> 使用系统根据接口文档自动生成的 <code>Mock</code> 数据进入开发，无需手写 <code>mock</code> 规则。</li><li><strong>后端</strong> 使用<code>接口用例</code> 调试开发中的接口，当所有接口用例调试通过，接口即开发完成。若开发过程中接口有改动，调试的时候会自动更新文档，零成本的保障了接口维护的及时性。</li><li><strong>后端</strong> 每次调试完一个功能就保存为一个<code>接口用例</code>。</li><li><strong>测试人员</strong> 直接使用<code>接口用例</code>测试接口。</li><li>所有接口开发完成后，<strong>测试人员</strong>（也可以是<strong>后端</strong>）使用集合测试功能进行多接口集成测试，完整测试整个接口调用流程。</li><li><strong>前后端</strong> 都开发完，前端从<code>Mock</code> 数据切换到<code>正式数据</code>，联调通常都会非常顺利，因为前后端双方都完全遵守了接口定义的规范。</li></ol> 
<h4><a id="_36"></a>新建团队</h4> 
<ol><li>创建团队、创建新项目<br> <img src="https://images2.imgbox.com/8e/b6/ioD4ADPi_o.png" alt="在这里插入图片描述"></li><li>邀请团队成员</li><li>设置团队权限、设置项目权限</li><li>通知设置：支持将通知集成到第三方应用平台，接口变更后可发送消息通知</li></ol> 
<h4><a id="_42"></a>编写接口文档</h4> 
<ol><li>编写基本信息</li><li>请求参数设置：新建数据模型，参数直接关联模型的属性</li><li>返回响应定义<br> <img src="https://images2.imgbox.com/fb/99/zOjniW6I_o.png" alt="在这里插入图片描述"></li><li>响应示例编写：响应示例可根据<code>MocK</code>规则自动生成<br> <img src="https://images2.imgbox.com/02/f6/VqNeeofD_o.png" alt="在这里插入图片描述"></li></ol> 
<h4><a id="Mock_49"></a>前端使用Mock</h4> 
<ul><li>发送<code>Mock</code>快捷请求，直接获取接口样例数据<br> <img src="https://images2.imgbox.com/2b/4d/G7eVZV4V_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="_52"></a>后端调试模式开发接口</h4> 
<ol><li>后端开发人员用调试模式对接口进行开发调试</li><li>后端人员调试用例可以保存下来</li></ol> 
<h4><a id="_55"></a>接口用例测试</h4> 
<ol><li>测试人员或者后端人员对保存的接口用例进行测试</li></ol> 
<h4><a id="_57"></a>前后端联调</h4> 
<ol><li>前后端都开发完，前端从<code>Mock</code> 数据切换到正式数据</li></ol> 
<h4><a id="_59"></a>接口文档分享</h4> 
<ol><li>可以生成在线文档进行查看<br> <img src="https://images2.imgbox.com/a4/d2/x2pa3Gma_o.png" alt="在这里插入图片描述"></li></ol> 
<h3><a id="_62"></a>其它使用场景</h3> 
<h4><a id="_63"></a>接口管理</h4> 
<h5><a id="_64"></a>查看历史版本</h5> 
<ul><li>查看接口修改历史时，可以与某次操作进行对比<br> <img src="https://images2.imgbox.com/fc/1c/EcNritSm_o.png" alt="在这里插入图片描述"></li></ul> 
<h5><a id="_67"></a>在线分享</h5> 
<ul><li>在 <code>API</code> 设计、开发、沟通、协作中，逻辑上应该以团队内共同定义的 <code>API</code> 文档为标准。</li><li>实际操作中，团队成员习惯依靠 <code>Word</code>、<code>PDF</code> 格式文件进行 <code>API</code> 文档协作，造成大量信息未能及时同步，将接口以在线形式分享将有助于提高团队之间的沟通效率。</li></ul> 
<h5><a id="_71"></a>用例管理</h5> 
<ul><li>定义接口的时候定义好这些不同状态的用例，接口调试的时候直接运行，非常高效。</li></ul> 
<h4><a id="Mock_73"></a>Mock功能</h4> 
<ul><li>根据接口/数据结构定义、<code>Mock</code> 规则配置、<code>Mock</code> 期望配置等功能自动生成模拟数据</li></ul> 
<h4><a id="_75"></a>登录状态获取</h4> 
<h5><a id="SessionCookie__76"></a>Session/Cookie 方式</h5> 
<ul><li>先执行登录接口，执行完成后全局 <code>Cookie</code> 会自动保存返回的 <code>Session/Cookie</code> 信息。</li><li>然后运行其他接口，会自动带上 <code>Session/Cookie</code> 信息。</li></ul> 
<h5><a id="Token__79"></a>Token 方式</h5> 
<ul><li>在环境 里的<code>全局参数</code>统一设置，所有接口运行时会自动加上<code>全局参数</code>，无需每个接口手动设置</li></ul> 
<h5><a id="_81"></a>全自动登录</h5> 
<ol><li>自动登录过一次后，保存登录态，避免每次执行用例都调用登录接口。</li><li>编写前置脚本，将登录接口返回的登录凭证写入环境变量</li></ol> 
<h4><a id="_84"></a>接口自动化测试</h4> 
<h5><a id="Token_85"></a>获取Token公共脚本</h5> 
<ul><li>编写前置脚本（获取用户登录<code>token</code>）</li></ul> 
<pre><code class="prism language-js"><span class="token comment">// 定义发送登录接口请求方法</span>
<span class="token keyword">function</span> <span class="token function">sendLoginRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 获取环境里的 前置 URL</span>
  <span class="token keyword">const</span> baseUrl <span class="token operator">=</span> pm<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">getBaseUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 构造一个 POST x-www-form-urlencoded 格式请求。这里需要改成你们实际登录接口的请求参数。</span>
  <span class="token keyword">const</span> loginRequest <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">url</span><span class="token operator">:</span> baseUrl <span class="token operator">+</span> <span class="token string">"/test/login"</span><span class="token punctuation">,</span>
    <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">"POST"</span><span class="token punctuation">,</span>
    <span class="token comment">// body 为 x-www-form-urlencoded 格式</span>
    <span class="token literal-property property">header</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token string-property property">"Content-Type"</span><span class="token operator">:</span> <span class="token string">"application/json"</span><span class="token punctuation">,</span> <span class="token comment">// 注意：header 需要加上 </span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">body</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token literal-property property">mode</span><span class="token operator">:</span> <span class="token string">"raw"</span><span class="token punctuation">,</span> <span class="token comment">// 此处为 urlencoded</span>
      <span class="token comment">// 此处为 urlencoded</span>
      <span class="token literal-property property">raw</span><span class="token operator">:</span>
        <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> <span class="token string-property property">"username"</span><span class="token operator">:</span> <span class="token string">"M8Lw9O0Qwy9+/LIuJlpa9IwkkDUnCeuirYhznDRqUZEwd247AHIxVVBCqoH+65XPkNmzV15jAvrZ3Id87JtorA=="</span><span class="token punctuation">,</span> <span class="token string-property property">"pwd"</span><span class="token operator">:</span> <span class="token string">"nepr2BP3KRk6vCkrTVYaVzsdX/UgwkmP8DqSMuZRcyTSvBFYtGfPhohv4XQ+20RkG8o+d2HNqY2aRAxO9Wr6vg=="</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// 发送请求。</span>
  pm<span class="token punctuation">.</span><span class="token function">sendRequest</span><span class="token punctuation">(</span>loginRequest<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 读取接口返回的 json 数据。</span>
      <span class="token keyword">const</span> jsonData <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>jsonData<span class="token punctuation">)</span>
      <span class="token comment">// 将 accessToken 写入环境变量 Token</span>
      pm<span class="token punctuation">.</span>environment<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"Token"</span><span class="token punctuation">,</span> jsonData<span class="token punctuation">.</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 获取环境变量里的 Token</span>
<span class="token keyword">const</span> accessToken <span class="token operator">=</span> pm<span class="token punctuation">.</span>environment<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"Token"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 如 Token 没有值,则执行发送登录接口请求</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>accessToken<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">sendLoginRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_132"></a>自动化编排</h5> 
<ul><li>选择接口用例对接口进行编排操作</li><li>设置编排的线程数和循环数</li></ul> 
<h5><a id="_135"></a>接口编排结果</h5> 
<ul><li>可以导出报告查看执行情况</li><li>串行调用：将多个<code>API</code>串行调用，从而实现多个API的顺序执行。</li><li>并行调用：将多个<code>API</code>并行调用，从而实现多个<code>API</code>的并发执行。</li><li>条件调用：根据某些条件，选择调用不同的<code>API</code>。</li><li>循环调用：多次调用同一个<code>API</code>。</li></ul> 
<p>要使用接口编排，您需要先创建一个接口编排文件。接口编排文件是一个<code>JSON</code>文件，其中包含了接口编排的定义。您可以使用<code>Apifox</code>提供的接口编排编辑器来创建接口编排文件。 创建接口编排文件后，您可以使用<code>Apifox</code>的接口编排功能来调用接口编排。您可以通过以下步骤来调用接口编排：</p> 
<ol><li>在<code>Apifox</code>中打开接口编排文件。</li><li>点击调用接口编排按钮。</li><li>选择要调用的接口编排。</li><li>点击调用按钮。</li></ol> 
<p><code>Apifox</code>会根据接口编排文件的定义，调用相应的<code>API</code>。当所有<code>API</code>调用完成后，<code>Apifox</code>会返回接口编排的执行结果。</p> 
<h4><a id="_151"></a>接口性能测试</h4> 
<ul><li>接口开发人员在开发接口的过程中，通过配置线程数、循环次数在接口联调完成之后进行并发测试，对慢的接口进行优化。</li><li>可以将测试场景以 <code>JMeter</code> 格式导出，然后再导入至 <code>JMeter</code> 运行性能测试。</li></ul> 
<ol><li>负载测试：<code>Apifox</code>可以生成负载测试，模拟真实用户流量来测试<code>API</code>的性能。您可以设置并发用户数、请求频率和持续时间等参数，以模拟不同负载条件下的<code>API</code>性能。</li><li>压力测试：<code>Apifox</code>可以进行压力测试，通过增加并发用户数和请求频率，来测试<code>API</code>在高负载情况下的性能表现。这有助于确定<code>API</code>在高负载条件下的稳定性和可靠性。</li><li>性能监控：<code>Apifox</code>提供实时的性能监控功能，可以监测API的响应时间、吞吐量、错误率等指标。您可以实时查看<code>API</code>的性能表现，并及时发现任何异常或潜在的问题。</li><li>性能分析：<code>Apifox</code>生成详细的性能报告，展示<code>API</code>在不同负载条件下的性能数据。报告中包括平均响应时间、最大响应时间、吞吐量、错误率等指标，帮助您深入了解<code>API</code>的性能状况，并找出性能瓶颈。</li><li>性能优化：根据性能报告中的数据和分析结果，您可以针对性地优化<code>API</code>的性能。可以通过优化代码、增加服务器资源、缓存数据等方式来提升<code>API</code>的性能和响应速度。<br> 实时查看<code>API</code>的性能表现，并及时发现任何异常或潜在的问题。</li><li>性能分析：<code>Apifox</code>生成详细的性能报告，展示<code>API</code>在不同负载条件下的性能数据。报告中包括平均响应时间、最大响应时间、吞吐量、错误率等指标，帮助您深入了解<code>API</code>的性能状况，并找出性能瓶颈。</li><li>性能优化：根据性能报告中的数据和分析结果，您可以针对性地优化<code>API</code>的性能。可以通过优化代码、增加服务器资源、缓存数据等方式来提升<code>API</code>的性能和响应速度。</li></ol>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f623ae898dc2ac0e1fccb2e4eb418499/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JMeter HTTP请求的详细指南，还不知道的快来看</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/10a85ee3d2925b59f01861998f88a58d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">gradle8.0或者其他版本下载太慢或者time out超时（完美解决方法）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>