<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>DjangoRestFramework概括 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="DjangoRestFramework概括" />
<meta property="og:description" content="一 drf入门规范 前后端开发模式：混合、分离
API接口：地址、请求方法、请求参数、返回值
测试软件的使用：postman、Apifox等
序列化和反序列化
restful规范：比如http响应状态码
在Django中写符合规范的接口
djangorestframework：django的app
快速使用
二 CBV源码分析 CBV源码分析
路由中，视图类.as_view() ----&gt; django的View的as_view() ----&gt;执行结果view内存地址----&gt;请求来了，路由匹配成功----&gt;view(request) ----&gt;return self.dispatch() ----&gt; View的dispatch ----&gt;通过反射，不同的请求会执行视图类中跟请求同名的方法
APIview源码分析
APIView继承了View 视图类： class BookView(APIView)：
路由中 ，视图类.as_view() ----&gt;drf的APIView的as_view() ----&gt;调用父类的as_view,去除csrf ----&gt;
View类的as_view内部的view闭包函数（加了个装饰器） ----&gt;view(request) ----&gt;return self.dispatch() ----&gt;APIView的dispatch()
三 Request类的对象 request.data
request.query_params
request.Files
request.method,request.path等
重写了魔术方法（）
四 序列化组件（drf核心） 能做的事：序列化、反序列化校验、序列化
Serializer ----&gt;book表先做序列化
定义序列化类
class BookSerializer (Serializer):
name=serializer.CharField()
使用序列化类
ser=BookSerializer(instance=qs,单个对象,many=True)
ser.data #字典
字段类：很多，如ListField、DictField
字段参数：反序列化校验，字段自己的规则
read_only write_only
反序列化校验：1.字段自己 2.局部钩子：validate_字段名 3.全局钩子validate
反序列化保存：校验过后，ser.save() ----&gt;判断instance是否存在，如果不存在，就是调用ser的create方法。在序列化类中，重写create
反序列化更新：校验过后，ser.save() ----&gt;判断instance是否存在，如果不存在，就是调用ser的update方法。在序列化类中，重写update" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/db49ded132f52dc03cc95e0393f2cb18/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-29T20:50:59+08:00" />
<meta property="article:modified_time" content="2023-12-29T20:50:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">DjangoRestFramework概括</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一 drf入门规范</h2> 
<p>前后端开发模式：混合、分离</p> 
<p>API接口：地址、请求方法、请求参数、返回值</p> 
<p>测试软件的使用：postman、Apifox等</p> 
<p>序列化和反序列化</p> 
<p>restful规范：比如http响应状态码</p> 
<p>在Django中写符合规范的接口</p> 
<p>djangorestframework：django的app</p> 
<p>快速使用</p> 
<h2>二 CBV源码分析</h2> 
<p>CBV源码分析</p> 
<p>路由中，视图类.as_view() ----&gt; django的View的as_view() ----&gt;执行结果view内存地址----&gt;请求来了，路由匹配成功----&gt;view(request) ----&gt;return self.dispatch() ----&gt; View的dispatch ----&gt;通过反射，不同的请求会执行视图类中跟请求同名的方法</p> 
<p>APIview源码分析</p> 
<p>APIView继承了View </p> 
<p>视图类： class BookView(APIView)：</p> 
<p>路由中 ，视图类.as_view() ----&gt;drf的APIView的as_view() ----&gt;调用父类的as_view,去除csrf ----&gt;</p> 
<p>View类的as_view内部的view闭包函数（加了个装饰器） ----&gt;view(request) ----&gt;return self.dispatch() ----&gt;APIView的dispatch()</p> 
<h2>三 Request类的对象</h2> 
<p>request.data</p> 
<p>request.query_params</p> 
<p>request.Files</p> 
<p>request.method,request.path等</p> 
<p>重写了魔术方法（）</p> 
<h2>四 序列化组件（drf核心）</h2> 
<p>能做的事：序列化、反序列化校验、序列化</p> 
<blockquote> 
 <p>Serializer ----&gt;book表先做序列化</p> 
 <p>        定义序列化类</p> 
 <p>                class BookSerializer (Serializer):</p> 
 <p>                        name=serializer.CharField()</p> 
 <p>        使用序列化类</p> 
 <p>                ser=BookSerializer(instance=qs,单个对象,many=True)</p> 
 <p>                ser.data  #字典</p> 
</blockquote> 
<p>字段类：很多，如ListField、DictField</p> 
<p>字段参数：反序列化校验，字段自己的规则</p> 
<p>read_only     write_only</p> 
<p>反序列化校验：1.字段自己 2.局部钩子：validate_字段名 3.全局钩子validate</p> 
<p>反序列化保存：校验过后，ser.save() ----&gt;判断instance是否存在，如果不存在，就是调用ser的create方法。在序列化类中，重写create</p> 
<p>反序列化更新：校验过后，ser.save() ----&gt;判断instance是否存在，如果不存在，就是调用ser的update方法。在序列化类中，重写update</p> 
<p>ModelSerializer的使用：不需要写一个个字段，跟表模型有对应关系</p> 
<p>        extra_kwargs</p> 
<p>        其他跟Serializer一模一样</p> 
<p>序列化，定制返回格式</p> 
<p>        source</p> 
<p>        SerializerMethodField：写在序列化类中，配合一个 get_字段名的方法，返回什么，前端就看到什么</p> 
<p>        在表模型中写：写方法，返回字典、列表、字符串 ----&gt;在序列化类中可以使用ListField、DictField </p> 
<h2>五 请求与响应</h2> 
<p>Request类的对象</p> 
<p>        接收前端传入的编码格式：json，urlencoded，form-data</p> 
<p>        局部配置   全局配置</p> 
<p>        Request的源码</p> 
<p>Response类的对象</p> 
<p>        前端看到的形式（浏览器，json）</p> 
<p>        源码分析：data  headers status_code</p> 
<h2>六 视图组件</h2> 
<p>两个视图基类：APIView，GenericAPIView</p> 
<p>五个视图扩展类，必须配合GenericAPIView。基于它再封装成自己的5个视图扩展类，返回格式符合公司规范</p> 
<p>九个视图子类：5个视图扩展类+GenericAPIView</p> 
<p>视图集：ViewSetMixin：只要继承它，路由写法就变了</p> 
<p>              ViewSet：ViewSetMixin，views.APIView</p> 
<p>              GenericViewSet：ViewSetMixin，generics.GenericAPIView</p> 
<p>              ModelViewSet：</p> 
<p>                                1.继承了ModelViewSet，没有增加一条记录，就干某个事，重写</p> 
<p>                                   perform_create</p> 
<p>                                2.序列化使用一个序列化类，反序列化使用配置的那个序列化类 </p> 
<p>                                3.自定义了一个方法：login，使用了action装饰器，让它取到的qs对象和序列</p> 
<p>                                  化类跟配置的都不一样 </p> 
<p>                ReadOnlyModelViewSet</p> 
<p>视图类：self 内部有request对象，还有个action，就是视图类中方法的字符串名</p> 
<h2>七 认证、频率、组件</h2> 
<p>认证：写个类，继承BaseAuthentication，重写authenticate方法，在里面做认证，如果认证通过返回两个值，如果认证失败，就抛异常 ----&gt;局部、全局配置</p> 
<p>权限：同上</p> 
<p>频率：写个类，继承SimpleRateThrottle，重写get_cache_key，返回什么，就以什么做限制（ip，用户id） ----&gt;类属性：scop ----&gt;配置文件配置，全局和局部</p> 
<h2>八 排序</h2> 
<p>使用内置的即可，查询所有接口，才有排序，必须继承GenericAPIView</p> 
<p>在视图类中，配置filter_backends=[OrderingFilter]，还需要配置属性：ordering_fields=[id,price]</p> 
<p>如果是继承APIView写排序，自己写</p> 
<h2>九 过滤        </h2> 
<p>内置：SearchFilter，模糊查询</p> 
<p>第三方：django-filter</p> 
<p>自己写的：写一个类，继承BaseFilterBackend，重写filter_queryset，返回qs对象，返回的就是过来后的</p> 
<h2>十 分页</h2> 
<p>三种分页方式：PageNumberPagination,LimitOffsetPagination,CursorPagination</p> 
<p>每个里有些类属性控制：每页显示多少条，最多显示多少条，第几页等</p> 
<p>写个类，继承三个之一，配置在视图类上（必须继承GenericAPIView）</p> 
<p>继承APIView写分页</p> 
<h2>十一 异常处理</h2> 
<p>全局异常处理 ----&gt;同一返回格式</p> 
<p>写个函数：custom_exception_handler(exc,context) ----&gt; 调用了原来的exception_handler （只能处理drf的异常） ----&gt; 返回两种情况：None，Response的对象</p> 
<p>配置在drf的配置文件</p> 
<h2></h2> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7ee09a961838077e118fbd25ad9cef64/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">网络安全（黑客）技术——高效自学</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2eec25d0bcdee36a46145d578fa3c279/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">k8s报错处理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>