<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>printf打印函数的原理浅析 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="printf打印函数的原理浅析" />
<meta property="og:description" content="printf的底层原理浅析 目录 printf的底层原理浅析前言函数变参格式解析一个简单的printf示例结语 补充 前言 最近在学习linux内核的时候用到了自定义实现的printf，学习了一下，在此记录，希望有助于大家。
在C语言中，我们用到的最多的输出功能函数大概就是printf了。但以前只是调用C语言的库函数，具体printf是如何实现的呢？
说到底两件事：
（1）、函数变参
（2）、格式解析
下面将简要介绍以上两点内容，最后附一个简单的printf例子。
函数变参 何为函数变参？简要来说就是参数个数不固定的函数。大部分时间，我们用的、写的都是参数固定的函数。但是为了应对想printf这种参数不固定的函数（），C语言提供了一种变参函数的机制。
int printf (const char *__format, ...); 如上所示为pritnf的声明。其中format就是我们以前写的格式化字符串，其中包括我们想输出的内容和参数占位符（用%&#43;格式化字符来占位）。后面的 ‘…’，就是代表不固定的参数。
我们调用的使用像下面这样进行调用：
printf（“This is a test: %d,%c,%s”,a,b,c）; 这里的…，就代表了a,b,c三个参数。
说完了变参函数的概念，下面说说变参函数的实现原理。
我们知道，在调用函数的时候，函数的参数是在栈中分配的。 比如说调用下面这个普通函数。
//函数声明 int Add(int a,int b); //函数调用 Add(3,5); 其栈大概是向下面这样分配的。
如下图所示。
即，一般来说，栈空间是从搞地址向低地址分配，函数参数从右依次向左分配。分配完成之后，在函数内部的操作就是对这栈空间的变量进行的操作，这也是为什么我们在函数内部改变传入参数的值，却不能够传到函数外部的原因（如果不使用指针或者地址的话）。
而对于变参函数来说，其基本的传参原则是和上面说的一致。但是 由于其函数声明参数并不固定，所以有些栈中的变量是没有名字的，我们如果想使用这段空间，必须由我们自己通过指针来实现。
是不是有点蒙圈，有点绕？
小二，来点栗子。
如果我这样调用printf函数
printf（“This is a test: %d,%c,%s”,10,&#39;A&#39;,&#34;helloworld&#34;）; 看下面栈的内存分配图。
如上图所示，在栈中只有format变量（字符指针类型，在printf的声明函数中定义了此参数），是有名字的，其他的三个内存空间里面只有值，但是没有名字来指明它们。所以，我们只能通过地址变量来找到（访问）它们。
这里要稍微补充一点，一般来说，对于变参函数来说，虽然其参数的个数是不固定的，但是其最少要有一个参数，就像printf函数中至少要有一个format参数一样（好像在宏定义变参函数中，可以由0个参数，这里不讨论）。
为什么呢？
答：这个最少要有的一个参数一般就是用来定位栈顶空间的。就像我们在上面描述的那样，栈内存的分配是从右向左的，最左边的参数就是栈顶元素。相当于，我们知道了栈顶的地址，只要再根据变参中每个参数的类型（int、char型等），相应的进行地址偏移，就可以访问变参的内容。
哎呀，又有一个问题了，在被调用的函数内部我怎么知道变参的类型是什么呢？
嘿嘿，还真是，一般你还真是不知道。这种情况下就需要调用者和被调用者商量好了。对于printf函数来说，调用者通过%&#43;格式字符的方式通知了被调用者（printf的实现者）。
怎么通知的呢？
答：就是通过第一个format参数了。因为%&#43;格式字符都是在format参数里的啊。
格式解析 弄懂了上面所说的，剩下的就没什么好说的了。 简单提一下。
简单来说就是扫描format参数里的字符，如果是普通字符就打印输出，如果是%，就说明后面有可能是格式字符，需要进行检测，然后从栈顶（其实是第一个参数的位置）弹出指定类型的数据，按照指定格式（十进制、十六进制、指定宽度、指定精度等等）进行输出。
基本上是一个字符串解析的过程。后面代码有解析，在此就不详述了。
一个简单的printf示例 //从传递的栈中获取参数的一些设置 typedef char * va_list; #define _INTSIZEOF(n) ((sizeof(n)&#43;sizeof(int)-1)&amp;~(sizeof(int) - 1) )	#define va_start(ap,v) ( ap = (va_list)&amp;v &#43; _INTSIZEOF(v) ) #define va_arg(ap,t) ( *(t *)((ap &#43;= _INTSIZEOF(t)) - _INTSIZEOF(t)) ) #define va_end(ap) ( ap = (va_list)0 ) #define BUFFER_SIZE 4096 static char print_buf[BUFFER_SIZE]; static char num_to_char[] = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8748f2c4ec0f861bff87975eb7f97d06/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-16T20:55:48+08:00" />
<meta property="article:modified_time" content="2020-03-16T20:55:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">printf打印函数的原理浅析</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="printf_0"></a>printf的底层原理浅析</h2> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#printf_0" rel="nofollow">printf的底层原理浅析</a></li><li><ul><li><a href="#_3" rel="nofollow">前言</a></li><li><a href="#_14" rel="nofollow">函数变参</a></li><li><a href="#_76" rel="nofollow">格式解析</a></li><li><a href="#printf_84" rel="nofollow">一个简单的printf示例</a></li><li><a href="#_229" rel="nofollow">结语</a></li></ul> 
  </li><li><a href="#_248" rel="nofollow">补充</a></li></ul> 
</div> 
<p></p> 
<h3><a id="_3"></a>前言</h3> 
<p>  最近在学习linux内核的时候用到了自定义实现的printf，学习了一下，在此记录，希望有助于大家。</p> 
<p>  在C语言中，我们用到的最多的输出功能函数大概就是printf了。但以前只是调用C语言的库函数，具体printf是如何实现的呢？</p> 
<p>说到底两件事：<br> （1）、函数变参<br> （2）、格式解析</p> 
<p>  下面将简要介绍以上两点内容，最后附一个简单的printf例子。</p> 
<h3><a id="_14"></a>函数变参</h3> 
<p>  何为函数变参？简要来说就是参数个数不固定的函数。大部分时间，我们用的、写的都是参数固定的函数。但是为了应对想printf这种参数不固定的函数（），C语言提供了一种变参函数的机制。</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> printf <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>__format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>如上所示为pritnf的声明。其中format就是我们以前写的格式化字符串，其中包括我们想输出的内容和参数占位符（用%+格式化字符来占位）。后面的 ‘<strong>…</strong>’，就是代表不固定的参数。<br> 我们调用的使用像下面这样进行调用：</p> 
<pre><code class="prism language-c">printf（“This is a test<span class="token punctuation">:</span> <span class="token operator">%</span>d<span class="token punctuation">,</span><span class="token operator">%</span>c<span class="token punctuation">,</span><span class="token operator">%</span>s”<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c）<span class="token punctuation">;</span>
</code></pre> 
<p>这里的…，就代表了a,b,c三个参数。</p> 
<p>说完了变参函数的概念，下面说说变参函数的实现原理。</p> 
<p>我们知道，在调用函数的时候，函数的参数是在栈中分配的。 比如说调用下面这个普通函数。</p> 
<pre><code class="prism language-c"><span class="token comment">//函数声明</span>
<span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-c"><span class="token comment">//函数调用</span>
<span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>其栈大概是向下面这样分配的。</p> 
<p>如下图所示。<br> <img src="https://images2.imgbox.com/b8/fe/f0tiThPE_o.png" alt="在这里插入图片描述"><br> 即，一般来说，栈空间是从搞地址向低地址分配，函数参数从右依次向左分配。分配完成之后，在函数内部的操作就是对这栈空间的变量进行的操作，这也是为什么我们在函数内部改变传入参数的值，却不能够传到函数外部的原因（如果不使用指针或者地址的话）。</p> 
<p>而对于变参函数来说，其基本的传参原则是和上面说的一致。但是 由于其函数声明参数并不固定，所以有些栈中的变量是没有名字的，我们如果想使用这段空间，必须由我们自己通过指针来实现。</p> 
<p>是不是有点蒙圈，有点绕？<br> 小二，来点栗子。</p> 
<p>如果我这样调用printf函数</p> 
<pre><code class="prism language-c">printf（“This is a test<span class="token punctuation">:</span> <span class="token operator">%</span>d<span class="token punctuation">,</span><span class="token operator">%</span>c<span class="token punctuation">,</span><span class="token operator">%</span>s”<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">'A'</span><span class="token punctuation">,</span><span class="token string">"helloworld"</span>）<span class="token punctuation">;</span>
</code></pre> 
<p>看下面栈的内存分配图。<br> <img src="https://images2.imgbox.com/d7/b5/JACVBu4t_o.png" alt="在这里插入图片描述"><br> 如上图所示，在栈中只有format变量（字符指针类型，在printf的声明函数中定义了此参数），是有名字的，其他的三个内存空间里面只有值，但是没有名字来指明它们。所以，我们只能通过地址变量来找到（访问）它们。</p> 
<p>这里要稍微补充一点，一般来说，对于变参函数来说，虽然其参数的个数是不固定的，但是其最少要有一个参数，就像printf函数中至少要有一个format参数一样（好像在宏定义变参函数中，可以由0个参数，这里不讨论）。</p> 
<p>为什么呢？<br> 答：这个最少要有的一个参数一般就是用来定位栈顶空间的。就像我们在上面描述的那样，栈内存的分配是从右向左的，最左边的参数就是栈顶元素。相当于，我们知道了栈顶的地址，只要再根据变参中每个参数的类型（int、char型等），相应的进行地址偏移，就可以访问变参的内容。</p> 
<p>哎呀，又有一个问题了，在被调用的函数内部我怎么知道变参的类型是什么呢？<br> 嘿嘿，还真是，一般你还真是不知道。这种情况下就需要调用者和被调用者商量好了。对于printf函数来说，调用者通过%+格式字符的方式通知了被调用者（printf的实现者）。</p> 
<p>怎么通知的呢？<br> 答：就是通过第一个format参数了。因为%+格式字符都是在format参数里的啊。</p> 
<h3><a id="_76"></a>格式解析</h3> 
<p>  弄懂了上面所说的，剩下的就没什么好说的了。 简单提一下。</p> 
<p>  简单来说就是扫描format参数里的字符，如果是普通字符就打印输出，如果是%，就说明后面有可能是格式字符，需要进行检测，然后从栈顶（其实是第一个参数的位置）弹出指定类型的数据，按照指定格式（十进制、十六进制、指定宽度、指定精度等等）进行输出。</p> 
<p>  基本上是一个字符串解析的过程。后面代码有解析，在此就不详述了。</p> 
<h3><a id="printf_84"></a>一个简单的printf示例</h3> 
<pre><code class="prism language-c"><span class="token comment">//从传递的栈中获取参数的一些设置</span>
<span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span> va_list<span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">define</span> _INTSIZEOF(n)   ((sizeof(n)+sizeof(int)-1)&amp;~(sizeof(int) - 1) )		</span>
<span class="token macro property">#<span class="token directive keyword">define</span> va_start(ap,v) ( ap = (va_list)&amp;v + _INTSIZEOF(v) )</span>
<span class="token macro property">#<span class="token directive keyword">define</span> va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )</span>
<span class="token macro property">#<span class="token directive keyword">define</span> va_end(ap)    ( ap = (va_list)0 )</span>

<span class="token macro property">#<span class="token directive keyword">define</span> BUFFER_SIZE 4096</span>

<span class="token keyword">static</span> <span class="token keyword">char</span> print_buf<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">char</span> num_to_char<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"0123456789ABCDEF"</span><span class="token punctuation">;</span>

<span class="token comment">//将十进制数据转化为字符型数据</span>
<span class="token keyword">int</span> <span class="token function">fillD</span><span class="token punctuation">(</span><span class="token keyword">char</span> print_buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> num<span class="token punctuation">,</span><span class="token keyword">int</span> base<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">int</span> tmp<span class="token punctuation">;</span>
    <span class="token keyword">char</span> tmp_str<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> tmp_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        tmp_str<span class="token punctuation">[</span>tmp_index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0'</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment">//如果是负数的话，记录下符号后转为相反的数</span>
    <span class="token punctuation">{<!-- --></span>
        print_buf<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'-'</span><span class="token punctuation">;</span>
        num <span class="token operator">=</span> <span class="token operator">-</span>num<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//将num转化为base进制的数据</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>num <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        tmp <span class="token operator">=</span> num <span class="token operator">%</span> base<span class="token punctuation">;</span>     <span class="token comment">//取最低位元素</span>
        tmp_str<span class="token punctuation">[</span>tmp_index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> num_to_char<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">//入栈，填入字符型数字</span>

        num <span class="token operator">=</span> num<span class="token operator">/</span> base<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//将字符型数字出栈倒入buf中</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> tmp_index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">--</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        print_buf<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp_str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> k<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//填充字符串</span>
<span class="token keyword">int</span> <span class="token function">fillStr</span><span class="token punctuation">(</span><span class="token keyword">char</span> print_buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span> src<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>src<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        print_buf<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> src<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> k<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//处理具体的解析，并输出到printf_buf中  //I , %c take %d years to  %x fin %s ished it\n ;</span>
<span class="token keyword">int</span> <span class="token function">my_vsnprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span> print_buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> size<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fmt<span class="token punctuation">,</span>va_list arg_list<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">char</span> tmp_c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> tmp_int <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>tmp_cp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>


    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size <span class="token operator">&amp;&amp;</span> fmt<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
       <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">'%'</span> <span class="token operator">!=</span> fmt<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span>       <span class="token comment">//直接输出的普通格式字符</span>
       <span class="token punctuation">{<!-- --></span>
           print_buf<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> fmt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">else</span>             <span class="token comment">//需要特殊处理的字符</span>
       <span class="token punctuation">{<!-- --></span>
           <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> size<span class="token punctuation">)</span>
           <span class="token punctuation">{<!-- --></span>
               <span class="token keyword">switch</span><span class="token punctuation">(</span>fmt<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
               <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">case</span> <span class="token string">'c'</span><span class="token punctuation">:</span>       <span class="token comment">//处理字符型数据</span>
                 tmp_c <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>arg_list<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//获得字符型参数</span>
                 print_buf<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp_c<span class="token punctuation">;</span>

                   <span class="token keyword">break</span><span class="token punctuation">;</span>
               <span class="token keyword">case</span> <span class="token string">'d'</span><span class="token punctuation">:</span>        <span class="token comment">//处理十进制数据</span>
                   tmp_int <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>arg_list<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                   k <span class="token operator">=</span> <span class="token function">fillD</span><span class="token punctuation">(</span>print_buf<span class="token punctuation">,</span>k<span class="token punctuation">,</span>tmp_int<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//填充十进制数据</span>

                   <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token keyword">case</span> <span class="token string">'x'</span><span class="token punctuation">:</span>           <span class="token comment">//处理十六进制数据</span>
                   <span class="token comment">//填充16进制标志符号</span>
                   print_buf<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0'</span><span class="token punctuation">;</span>
                   print_buf<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'x'</span><span class="token punctuation">;</span>

                   tmp_int<span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>arg_list<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//获取int型数据</span>
                   k <span class="token operator">=</span> <span class="token function">fillD</span><span class="token punctuation">(</span>print_buf<span class="token punctuation">,</span>k<span class="token punctuation">,</span>tmp_int<span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//填充十六进制数据</span>

                   <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token keyword">case</span> <span class="token string">'s'</span><span class="token punctuation">:</span>           <span class="token comment">//处理字符串</span>
                    tmp_cp <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>arg_list<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获得字符串型数据</span>
                    k <span class="token operator">=</span> <span class="token function">fillStr</span><span class="token punctuation">(</span>print_buf<span class="token punctuation">,</span>k<span class="token punctuation">,</span>tmp_cp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//填充字符串</span>

                   <span class="token keyword">break</span><span class="token punctuation">;</span>

               <span class="token punctuation">}</span>


           <span class="token punctuation">}</span>
           <span class="token keyword">else</span>
               print_buf<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> fmt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">//最后一个字符是%，直接读取即可</span>
       <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> k<span class="token punctuation">;</span>       <span class="token comment">//返回当前位置</span>
<span class="token punctuation">}</span>


<span class="token comment">//输出缓冲区里的字符</span>
<span class="token keyword">void</span> <span class="token function">__put_str</span><span class="token punctuation">(</span><span class="token keyword">char</span> print_buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token function">putchar</span><span class="token punctuation">(</span>print_buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">printk</span><span class="token punctuation">(</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>fmt<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    va_list arg_list<span class="token punctuation">;</span>

    <span class="token function">va_start</span><span class="token punctuation">(</span>arg_list<span class="token punctuation">,</span>fmt<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//arg_list指向第一个参数的位置(不是fmt)</span>

    len <span class="token operator">=</span> <span class="token function">my_vsnprintf</span><span class="token punctuation">(</span>print_buf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>print_buf<span class="token punctuation">)</span><span class="token punctuation">,</span>fmt<span class="token punctuation">,</span>arg_list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//解析参数，并打印到输出中</span>

    <span class="token function">va_end</span><span class="token punctuation">(</span>arg_list<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//变参结束</span>

    <span class="token function">__put_str</span><span class="token punctuation">(</span>print_buf<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//转换成字符输出</span>

<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_229"></a>结语</h3> 
<p>是不是懂了？做个作业呗。<br> 1、以下代码段是C语言提供的变参函数的主要代码部分，你看看，能看的懂吗？</p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span> va_list<span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">define</span> _INTSIZEOF(n)   ((sizeof(n)+sizeof(int)-1)&amp;~(sizeof(int) - 1) )		</span>
<span class="token macro property">#<span class="token directive keyword">define</span> va_start(ap,v) ( ap = (va_list)&amp;v + _INTSIZEOF(v) )</span>
<span class="token macro property">#<span class="token directive keyword">define</span> va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )</span>
<span class="token macro property">#<span class="token directive keyword">define</span> va_end(ap)    ( ap = (va_list)0 )</span>

</code></pre> 
<p>2、一般情况下，在传递字符串参数的时候，为何在栈中保存的都是字符串的首地址，而不是整个字符串内容呢？</p> 
<p>这么简单的问题，一定难不倒你了。</p> 
<h2><a id="_248"></a>补充</h2> 
<p>按理说，函数形参的传递在栈内存中的分布应该是和我上面说的差不多，但是最近在做实验的时候，发现了不一样的结果。形式上是函数调用栈空间是从下往上的。具体原因，也不是很了解，如果有懂的大佬，希望帮我指点下迷津。</p> 
<p>以下是我的测试代码：</p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">char</span> a<span class="token punctuation">,</span> <span class="token keyword">short</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">,</span><span class="token keyword">int</span> d<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %c,&amp;a = %0x\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"b = %d,&amp;b = %0x\n"</span><span class="token punctuation">,</span>b<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"c = %d,&amp;c = %0x\n"</span><span class="token punctuation">,</span>c<span class="token punctuation">,</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"d = %d,&amp;d = %0x\n"</span><span class="token punctuation">,</span>d<span class="token punctuation">,</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在window上结果是<br> <img src="https://images2.imgbox.com/24/b3/h9s0iigp_o.png" alt="在这里插入图片描述"><br> 这个结果是符合预期的。<br> 但是,在linux上测试出现了下面的现象，<br> <img src="https://images2.imgbox.com/6a/a0/fn0SD1eR_o.png" alt="在这里插入图片描述"><br> 完全和上面的地址顺序相反。</p> 
<p>了解吗？给我解释一下呗。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3438853fa3d141182d5a1bb2859e3b79/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JS中Key-Value操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5e4587069b305448ce263419f85a4a69/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Oracle数据库文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>